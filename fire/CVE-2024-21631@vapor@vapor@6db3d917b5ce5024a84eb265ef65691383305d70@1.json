{
  "cve_id": "CVE-2024-21631",
  "cve_desc": "Vapor is an HTTP web framework for Swift. Prior to version 4.90.0, Vapor's `vapor_urlparser_parse` function uses `uint16_t` indexes when parsing a URI's components, which may cause integer overflows when parsing untrusted inputs. This vulnerability does not affect Vapor directly but could impact applications relying on the URI type for validating user input. The URI type is used in several places in Vapor. A developer may decide to use URI to represent a URL in their application (especially if that URL is then passed to the HTTP Client) and rely on its public properties and methods. However, URI may fail to properly parse a valid (albeit abnormally long) URL, due to string ranges being converted to 16-bit integers. An attacker may use this behavior to trick the application into accepting a URL to an untrusted destination. By padding the port number with zeros, an attacker can cause an integer overflow to occur when the URL authority is parsed and, as a result, spoof the host. Version 4.90.0 contains a patch for this issue. As a workaround, validate user input before parsing as a URI or, if possible, use Foundation's `URL` and `URLComponents` utilities.\n",
  "repo": "vapor/vapor",
  "patch_hash": "6db3d917b5ce5024a84eb265ef65691383305d70",
  "patch_info": {
    "commit_hash": "6db3d917b5ce5024a84eb265ef65691383305d70",
    "repo": "vapor/vapor",
    "commit_url": "https://github.com/vapor/vapor/commit/6db3d917b5ce5024a84eb265ef65691383305d70",
    "files": [
      "Package.swift",
      "Package@swift-5.9.swift",
      "Sources/CVaporURLParser/include/urlparser.h",
      "Sources/CVaporURLParser/urlparser.c",
      "Sources/Vapor/HTTP/EndpointCache.swift",
      "Sources/Vapor/HTTP/Headers/HTTPCookies.swift",
      "Sources/Vapor/Response/Response+Body.swift",
      "Sources/Vapor/Utilities/URI.swift",
      "Tests/VaporTests/ClientTests.swift",
      "Tests/VaporTests/RequestTests.swift",
      "Tests/VaporTests/ServerTests.swift",
      "Tests/VaporTests/URITests.swift",
      "Tests/VaporTests/ValidationTests.swift"
    ],
    "message": "Merge pull request from GHSA-r6r4-5pr8-gjcp\n\n* Replace the ancient CVaporURLParser code with use of Foundation's URLComponents\n\n* Fixes for weird macOS behaviors\n\n* Tests fixup\n\n* Add test for extreme-length untrusted input which triggered failures in the old implementation.\n\n* Fix Sendable warnings across multiple Swift versions\n\n* Indirect through URL to get to URLComponents so parsing is consistent on Linux.\n\n* A couple more test fixes.",
    "before_after_code_files": [
      "Package.swift||Package.swift",
      "Package@swift-5.9.swift||Package@swift-5.9.swift",
      "Sources/CVaporURLParser/include/urlparser.h||Sources/CVaporURLParser/include/urlparser.h",
      "Sources/CVaporURLParser/urlparser.c||Sources/CVaporURLParser/urlparser.c",
      "Sources/Vapor/HTTP/EndpointCache.swift||Sources/Vapor/HTTP/EndpointCache.swift",
      "Sources/Vapor/HTTP/Headers/HTTPCookies.swift||Sources/Vapor/HTTP/Headers/HTTPCookies.swift",
      "Sources/Vapor/Response/Response+Body.swift||Sources/Vapor/Response/Response+Body.swift",
      "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift",
      "Tests/VaporTests/ClientTests.swift||Tests/VaporTests/ClientTests.swift",
      "Tests/VaporTests/RequestTests.swift||Tests/VaporTests/RequestTests.swift",
      "Tests/VaporTests/ServerTests.swift||Tests/VaporTests/ServerTests.swift",
      "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift",
      "Tests/VaporTests/ValidationTests.swift||Tests/VaporTests/ValidationTests.swift"
    ]
  },
  "patch_diff": {
    "Package.swift||Package.swift": [
      "File: Package.swift -> Package.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "66:     targets: [",
      "68:         .target(name: \"CVaporBcrypt\"),",
      "72:         .target(name: \"Vapor\", dependencies: [",
      "",
      "[Removed Lines]",
      "69:         .target(name: \"CVaporURLParser\"),",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "74:             .product(name: \"AsyncKit\", package: \"async-kit\"),",
      "75:             .product(name: \"Backtrace\", package: \"swift-backtrace\"),",
      "76:             .target(name: \"CVaporBcrypt\"),",
      "78:             .product(name: \"ConsoleKit\", package: \"console-kit\"),",
      "79:             .product(name: \"Logging\", package: \"swift-log\"),",
      "80:             .product(name: \"Metrics\", package: \"swift-metrics\"),",
      "",
      "[Removed Lines]",
      "77:             .target(name: \"CVaporURLParser\"),",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Package@swift-5.9.swift||Package@swift-5.9.swift": [
      "File: Package@swift-5.9.swift -> Package@swift-5.9.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "63:     targets: [",
      "65:         .target(name: \"CVaporBcrypt\"),",
      "69:         .target(",
      "70:             name: \"Vapor\",",
      "",
      "[Removed Lines]",
      "66:         .target(name: \"CVaporURLParser\"),",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "72:                 .product(name: \"AsyncHTTPClient\", package: \"async-http-client\"),",
      "73:                 .product(name: \"AsyncKit\", package: \"async-kit\"),",
      "74:                 .target(name: \"CVaporBcrypt\"),",
      "76:                 .product(name: \"ConsoleKit\", package: \"console-kit\"),",
      "77:                 .product(name: \"Logging\", package: \"swift-log\"),",
      "78:                 .product(name: \"Metrics\", package: \"swift-metrics\"),",
      "",
      "[Removed Lines]",
      "75:                 .target(name: \"CVaporURLParser\"),",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "130:                 .copy(\"Utilities/expired.crt\"),",
      "131:                 .copy(\"Utilities/expired.key\"),",
      "132:             ],",
      "134:         ),",
      "135:         .testTarget(",
      "136:             name: \"AsyncTests\",",
      "",
      "[Removed Lines]",
      "133:             swiftSettings: [.enableExperimentalFeature(\"StrictConcurrency=complete\")]",
      "",
      "[Added Lines]",
      "131:             swiftSettings: [",
      "132:                 .enableUpcomingFeature(\"BareSlashRegexLiterals\"),",
      "133:                 .enableExperimentalFeature(\"StrictConcurrency=complete\"),",
      "134:             ]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "138:                 .product(name: \"NIOTestUtils\", package: \"swift-nio\"),",
      "139:                 .target(name: \"XCTVapor\"),",
      "140:             ],",
      "142:         ),",
      "143:     ]",
      "144: )",
      "",
      "[Removed Lines]",
      "141:             swiftSettings: [.enableExperimentalFeature(\"StrictConcurrency=complete\")]",
      "",
      "[Added Lines]",
      "142:             swiftSettings: [",
      "143:                 .enableUpcomingFeature(\"BareSlashRegexLiterals\"),",
      "144:                 .enableExperimentalFeature(\"StrictConcurrency=complete\"),",
      "145:             ]",
      "",
      "---------------"
    ],
    "Sources/CVaporURLParser/include/urlparser.h||Sources/CVaporURLParser/include/urlparser.h": [
      "File: Sources/CVaporURLParser/include/urlparser.h -> Sources/CVaporURLParser/include/urlparser.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Sources/CVaporURLParser/urlparser.c||Sources/CVaporURLParser/urlparser.c": [
      "File: Sources/CVaporURLParser/urlparser.c -> Sources/CVaporURLParser/urlparser.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Sources/Vapor/HTTP/EndpointCache.swift||Sources/Vapor/HTTP/EndpointCache.swift": [
      "File: Sources/Vapor/HTTP/EndpointCache.swift -> Sources/Vapor/HTTP/EndpointCache.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: import Foundation",
      "2: import NIOConcurrencyHelpers",
      "3: import NIOCore",
      "4: import Logging",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #if !canImport(Darwin) && swift(<5.9)",
      "2: @preconcurrency import Foundation",
      "3: #else",
      "5: #endif",
      "",
      "---------------"
    ],
    "Sources/Vapor/HTTP/Headers/HTTPCookies.swift||Sources/Vapor/HTTP/Headers/HTTPCookies.swift": [
      "File: Sources/Vapor/HTTP/Headers/HTTPCookies.swift -> Sources/Vapor/HTTP/Headers/HTTPCookies.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: import Foundation",
      "2: import NIOHTTP1",
      "4: extension HTTPHeaders {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #if !canImport(Darwin) && swift(<5.9)",
      "2: @preconcurrency import Foundation",
      "3: #else",
      "5: #endif",
      "",
      "---------------"
    ],
    "Sources/Vapor/Response/Response+Body.swift||Sources/Vapor/Response/Response+Body.swift": [
      "File: Sources/Vapor/Response/Response+Body.swift -> Sources/Vapor/Response/Response+Body.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: @preconcurrency import Dispatch",
      "2: import Foundation",
      "3: import NIOCore",
      "4: import NIOConcurrencyHelpers",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: #if !canImport(Darwin) && swift(<5.9)",
      "3: @preconcurrency import Foundation",
      "4: #else",
      "6: #endif",
      "",
      "---------------"
    ],
    "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift": [
      "File: Sources/Vapor/Utilities/URI.swift -> Sources/Vapor/Utilities/URI.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "3: public struct URI: Sendable, ExpressibleByStringInterpolation, CustomStringConvertible {",
      "39:     public init(string: String = \"/\") {",
      "41:     }",
      "43:     public var description: String {",
      "45:     }",
      "47:     public init(",
      "48:         scheme: String?,",
      "49:         host: String? = nil,",
      "50:         port: Int? = nil,",
      "51:         path: String,",
      "",
      "[Removed Lines]",
      "1: import CVaporURLParser",
      "5:     public struct Scheme: Sendable, ExpressibleByStringInterpolation {",
      "7:         public static let http: Self = \"http\"",
      "10:         public static let https: Self = \"https\"",
      "17:         public static let httpUnixDomainSocket: Self = \"http+unix\"",
      "24:         public static let httpsUnixDomainSocket: Self = \"https+unix\"",
      "26:         public let value: String?",
      "28:         public init(stringLiteral value: String) {",
      "29:             self.value = value",
      "30:         }",
      "32:         public init(_ value: String? = nil) {",
      "33:             self.value = value",
      "34:         }",
      "35:     }",
      "37:     public var string: String",
      "40:         self.string = string",
      "44:         return self.string",
      "",
      "[Added Lines]",
      "1: #if !canImport(Darwin)",
      "2: @preconcurrency import struct Foundation.URLComponents",
      "3: #else",
      "4: import struct Foundation.URLComponents",
      "5: #endif",
      "33:     private var components: URLComponents?",
      "36:         self.components = URL(string: string).flatMap { .init(url: $0, resolvingAgainstBaseURL: true) }",
      "40:         self.string",
      "45:         userinfo: String?,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "54:     ) {",
      "55:         self.init(",
      "56:             scheme: Scheme(scheme),",
      "57:             host: host,",
      "58:             port: port,",
      "59:             path: path,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "54:             userinfo: userinfo,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "61:             fragment: fragment",
      "62:         )",
      "63:     }",
      "65:     public init(",
      "67:         host: String? = nil,",
      "68:         port: Int? = nil,",
      "69:         path: String,",
      "70:         query: String? = nil,",
      "71:         fragment: String? = nil",
      "72:     ) {",
      "85:         } else {",
      "90:         }",
      "95:     }",
      "97:     public init(stringLiteral value: String) {",
      "98:         self.init(string: value)",
      "99:     }",
      "105:     public var scheme: String? {",
      "109:         set {",
      "118:         }",
      "119:     }",
      "121:     public var host: String? {",
      "135:     }",
      "137:     public var port: Int? {",
      "151:     }",
      "153:     public var path: String {",
      "167:     }",
      "169:     public var query: String? {",
      "183:     }",
      "185:     public var fragment: String? {",
      "199:     }",
      "227:     }",
      "228: }",
      "",
      "[Removed Lines]",
      "66:         scheme: Scheme = Scheme(),",
      "73:         var string = \"\"",
      "74:         if let scheme = scheme.value {",
      "75:             string += scheme + \"://\"",
      "76:         }",
      "77:         if let host = host?.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) {",
      "78:             string += host",
      "79:         }",
      "80:         if let port = port {",
      "81:             string += \":\" + port.description",
      "82:         }",
      "83:         if path.hasPrefix(\"/\") {",
      "84:             string += path",
      "86:             string += \"/\" + path",
      "87:         }",
      "88:         if let query = query {",
      "89:             string += \"?\" + query",
      "91:         if let fragment = fragment {",
      "92:             string += \"#\" + fragment",
      "93:         }",
      "94:         self.string = string",
      "101:     private enum Component {",
      "102:         case scheme, host, port, path, query, fragment, userinfo",
      "103:     }",
      "106:         get {",
      "107:             return self.parse(.scheme)",
      "108:         }",
      "110:             self = .init(",
      "111:                 scheme: newValue,",
      "112:                 host: self.host,",
      "113:                 port: self.port,",
      "114:                 path: self.path,",
      "115:                 query: self.query,",
      "116:                 fragment: self.fragment",
      "117:             )",
      "122:         get {",
      "123:             return self.parse(.host)",
      "124:         }",
      "125:         set {",
      "126:             self = .init(",
      "127:                 scheme: self.scheme,",
      "128:                 host: newValue,",
      "129:                 port: self.port,",
      "130:                 path: self.path,",
      "131:                 query: self.query,",
      "132:                 fragment: self.fragment",
      "133:             )",
      "134:         }",
      "138:         get {",
      "139:             return self.parse(.port).flatMap(Int.init)",
      "140:         }",
      "141:         set {",
      "142:             self = .init(",
      "143:                 scheme: self.scheme,",
      "144:                 host: self.host,",
      "145:                 port: newValue,",
      "146:                 path: self.path,",
      "147:                 query: self.query,",
      "148:                 fragment: self.fragment",
      "149:             )",
      "150:         }",
      "154:         get {",
      "155:             return self.parse(.path) ?? \"\"",
      "156:         }",
      "157:         set {",
      "158:             self = .init(",
      "159:                 scheme: self.scheme,",
      "160:                 host: self.host,",
      "161:                 port: self.port,",
      "162:                 path: newValue,",
      "163:                 query: self.query,",
      "164:                 fragment: self.fragment",
      "165:             )",
      "166:         }",
      "170:         get {",
      "171:             return self.parse(.query)",
      "172:         }",
      "173:         set {",
      "174:             self = .init(",
      "175:                 scheme: self.scheme,",
      "176:                 host: self.host,",
      "177:                 port: self.port,",
      "178:                 path: self.path,",
      "179:                 query: newValue,",
      "180:                 fragment: self.fragment",
      "181:             )",
      "182:         }",
      "186:         get {",
      "187:             return self.parse(.fragment)",
      "188:         }",
      "189:         set {",
      "190:             self = .init(",
      "191:                 scheme: self.scheme,",
      "192:                 host: self.host,",
      "193:                 port: self.port,",
      "194:                 path: self.path,",
      "195:                 query: self.query,",
      "196:                 fragment: newValue",
      "197:             )",
      "198:         }",
      "201:     private func parse(_ component: Component) -> String? {",
      "202:         var url = vapor_urlparser_url()",
      "203:         vapor_urlparser_parse(self.string, self.string.count, 0, &url)",
      "204:         let data: vapor_urlparser_field_data",
      "205:         switch component {",
      "206:         case .scheme:",
      "207:             data = url.field_data.0",
      "208:         case .host:",
      "209:             data = url.field_data.1",
      "210:         case .port:",
      "211:             data = url.field_data.2",
      "212:         case .path:",
      "213:             data = url.field_data.3",
      "214:         case .query:",
      "215:             data = url.field_data.4",
      "216:         case .fragment:",
      "217:             data = url.field_data.5",
      "218:         case .userinfo:",
      "219:             data = url.field_data.6",
      "220:         }",
      "221:         if data.len == 0 {",
      "222:             return nil",
      "223:         }",
      "224:         let start = self.string.index(self.string.startIndex, offsetBy: numericCast(data.off))",
      "225:         let end = self.string.index(start, offsetBy: numericCast(data.len))",
      "226:         return String(self.string[start..<end])",
      "",
      "[Added Lines]",
      "63:     public init(scheme: String?, host: String? = nil, port: Int? = nil, path: String, query: String? = nil, fragment: String? = nil) {",
      "64:         self.init(scheme: scheme, userinfo: nil, host: host, port: port, path: path, query: query, fragment: fragment)",
      "65:     }",
      "67:     public init(scheme: Scheme = .init(), host: String? = nil, port: Int? = nil, path: String, query: String? = nil, fragment: String? = nil) {",
      "68:         self.init(scheme: scheme, userinfo: nil, host: host, port: port, path: path, query: query, fragment: fragment)",
      "69:     }",
      "82:         scheme: Scheme = .init(),",
      "83:         userinfo: String?,",
      "90:         let path = path.first == \"/\" ? path : \"/\\(path)\"",
      "91:         var components: URLComponents!",
      "93:         if scheme.value == nil, userinfo == nil, host == nil, port == nil, query == nil, fragment == nil {",
      "95:             components = URL(string: path).flatMap { .init(url: $0, resolvingAgainstBaseURL: true) }",
      "102:             components = .init()",
      "103:             components.scheme = scheme.value?.addingPercentEncoding(withAllowedCharacters: .urlSchemeAllowed)",
      "104:             if let host {",
      "105:                 if let creds = userinfo?.split(separator: \":\", maxSplits: 1, omittingEmptySubsequences: false), !creds[0].isEmpty {",
      "106:                     components.percentEncodedUser = creds[0].addingPercentEncoding(withAllowedCharacters: .urlUserAllowed)",
      "107:                     if creds.count > 1, !creds[1].isEmpty {",
      "108:                         components.percentEncodedPassword = creds[1].addingPercentEncoding(withAllowedCharacters: .urlPasswordAllowed)",
      "109:                     }",
      "110:                 }",
      "112:                 #if canImport(Darwin)",
      "113:                 if #available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *) {",
      "114:                     components.encodedHost = host.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)",
      "115:                 } else {",
      "116:                     components.percentEncodedHost = host.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)",
      "117:                 }",
      "118:                 #else",
      "119:                 components.percentEncodedHost = host.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)",
      "120:                 #endif",
      "121:                 components.port = port",
      "122:             } else {",
      "126:             }",
      "127:             components.percentEncodedPath = path.addingPercentEncoding(withAllowedCharacters: .urlCorrectPathAllowed) ?? \"/\"",
      "128:             components.percentEncodedQuery = query?.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)",
      "129:             components.percentEncodedFragment = fragment?.addingPercentEncoding(withAllowedCharacters: .urlFragmentAllowed)",
      "131:         self.components = components",
      "139:         get { self.components?.scheme }",
      "140:         set { self.components?.scheme = newValue }",
      "141:     }",
      "143:     public var userinfo: String? {",
      "144:         get { self.components?.user.map { \"\\($0)\\(self.components?.password.map { \":\\($0)\" } ?? \"\")\" } }",
      "146:             if let userinfoData = newValue?.split(separator: \":\", maxSplits: 1, omittingEmptySubsequences: false) {",
      "147:                 self.components?.user = .init(userinfoData[0])",
      "148:                 self.components?.password = userinfoData.count > 1 ? .init(userinfoData[1]) : nil",
      "149:             } else {",
      "150:                 self.components?.user = nil",
      "151:             }",
      "156:         get { self.components?.host }",
      "157:         set { self.components?.host = newValue }",
      "161:         get { self.components?.port }",
      "162:         set { self.components?.port = newValue }",
      "166:         get { self.components?.path ?? \"/\" }",
      "167:         set { self.components?.path = newValue }",
      "171:         get { self.components?.query }",
      "172:         set { self.components?.query = newValue }",
      "176:         get { self.components?.fragment }",
      "177:         set { self.components?.fragment = newValue }",
      "180:     public var string: String {",
      "181:         #if canImport(Darwin)",
      "182:         self.components?.string ?? \"\"",
      "183:         #else",
      "185:         self.components?.string?.replacingOccurrences(of: \"%3B\", with: \";\") ?? \"\"",
      "186:         #endif",
      "187:     }",
      "189: }",
      "191: extension URI {",
      "196:     public struct Scheme {",
      "198:         public let value: String?",
      "203:         public init(_ value: String? = nil) { self.value = value }",
      "210:         public static let http: Self = \"http\"",
      "215:         public static let https: Self = \"https\"",
      "228:         public static let httpUnixDomainSocket: Self = \"http+unix\"",
      "250:         public static let httpsUnixDomainSocket: Self = \"https+unix\"",
      "253:     }",
      "254: }",
      "256: extension URI.Scheme: ExpressibleByStringInterpolation {",
      "258:     public init(stringLiteral value: String) { self.init(value) }",
      "259: }",
      "261: extension URI.Scheme: CustomStringConvertible {",
      "263:     public var description: String { self.value ?? \"\" }",
      "264: }",
      "266: extension URI.Scheme: Sendable {}",
      "268: extension CharacterSet {",
      "272:     fileprivate static var urlSchemeAllowed: Self {",
      "275:         Self.urlHostAllowed.intersection(Self.alphanumerics.union(.init(charactersIn: \"+-.\")))",
      "276:     }",
      "284:     fileprivate static var urlCorrectPathAllowed: Self {",
      "285:         #if canImport(Darwin)",
      "286:         .urlPathAllowed",
      "287:         #else",
      "288:         .urlPathAllowed.union(.init(charactersIn: \";\"))",
      "289:         #endif",
      "",
      "---------------"
    ],
    "Tests/VaporTests/ClientTests.swift||Tests/VaporTests/ClientTests.swift": [
      "File: Tests/VaporTests/ClientTests.swift -> Tests/VaporTests/ClientTests.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "5: #endif",
      "6: import XCTest",
      "7: import Vapor",
      "8: import NIOCore",
      "",
      "[Removed Lines]",
      "1: #if os(Linux)",
      "2: @preconcurrency import Foundation",
      "3: #else",
      "4: import Foundation",
      "",
      "[Added Lines]",
      "1: #if !canImport(Darwin)",
      "2: @preconcurrency import Dispatch",
      "4: import Foundation",
      "",
      "---------------"
    ],
    "Tests/VaporTests/RequestTests.swift||Tests/VaporTests/RequestTests.swift": [
      "File: Tests/VaporTests/RequestTests.swift -> Tests/VaporTests/RequestTests.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "143:         }",
      "144:     }",
      "247:     func testRedirect() throws {",
      "248:         let app = Application(.testing)",
      "249:         defer { app.shutdown() }",
      "",
      "[Removed Lines]",
      "146:     func testURI() throws {",
      "147:         do {",
      "148:             var uri = URI(string: \"http://vapor.codes/foo?bar=baz#qux\")",
      "149:             XCTAssertEqual(uri.scheme, \"http\")",
      "150:             XCTAssertEqual(uri.host, \"vapor.codes\")",
      "151:             XCTAssertEqual(uri.path, \"/foo\")",
      "152:             XCTAssertEqual(uri.query, \"bar=baz\")",
      "153:             XCTAssertEqual(uri.fragment, \"qux\")",
      "154:             uri.query = \"bar=baz&test=1\"",
      "155:             XCTAssertEqual(uri.string, \"http://vapor.codes/foo?bar=baz&test=1#qux\")",
      "156:             uri.query = nil",
      "157:             XCTAssertEqual(uri.string, \"http://vapor.codes/foo#qux\")",
      "158:         }",
      "159:         do {",
      "160:             let uri = URI(string: \"/foo/bar/baz\")",
      "161:             XCTAssertEqual(uri.path, \"/foo/bar/baz\")",
      "162:         }",
      "163:         do {",
      "164:             let uri = URI(string: \"ws://echo.websocket.org/\")",
      "165:             XCTAssertEqual(uri.scheme, \"ws\")",
      "166:             XCTAssertEqual(uri.host, \"echo.websocket.org\")",
      "167:             XCTAssertEqual(uri.path, \"/\")",
      "168:         }",
      "169:         do {",
      "170:             let uri = URI(string: \"http://foo\")",
      "171:             XCTAssertEqual(uri.scheme, \"http\")",
      "172:             XCTAssertEqual(uri.host, \"foo\")",
      "173:             XCTAssertEqual(uri.path, \"\")",
      "174:         }",
      "175:         do {",
      "176:             let uri = URI(string: \"foo\")",
      "177:             XCTAssertEqual(uri.scheme, \"foo\")",
      "178:             XCTAssertEqual(uri.host, nil)",
      "179:             XCTAssertEqual(uri.path, \"\")",
      "180:         }",
      "181:         do {",
      "182:             let uri: URI = \"/foo/bar/baz\"",
      "183:             XCTAssertEqual(uri.path, \"/foo/bar/baz\")",
      "184:         }",
      "185:         do {",
      "186:             let foo = \"foo\"",
      "187:             let uri: URI = \"/\\(foo)/bar/baz\"",
      "188:             XCTAssertEqual(uri.path, \"/foo/bar/baz\")",
      "189:         }",
      "190:         do {",
      "191:             let uri = URI(scheme: \"foo\", host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "192:             XCTAssertEqual(uri.string, \"foo://host:1/test?query#fragment\")",
      "193:         }",
      "194:         do {",
      "195:             let bar = \"bar\"",
      "196:             let uri = URI(scheme: \"foo\\(bar)\", host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "197:             XCTAssertEqual(uri.string, \"foobar://host:1/test?query#fragment\")",
      "198:         }",
      "199:         do {",
      "200:             let uri = URI(scheme: \"foo\", host: \"host\", port: 1, path: \"/test\", query: \"query\", fragment: \"fragment\")",
      "201:             XCTAssertEqual(uri.string, \"foo://host:1/test?query#fragment\")",
      "202:         }",
      "203:         do {",
      "204:             let scheme = \"foo\"",
      "205:             let uri = URI(scheme: scheme, host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "206:             XCTAssertEqual(uri.string, \"foo://host:1/test?query#fragment\")",
      "207:         }",
      "208:         do {",
      "209:             let scheme: String? = \"foo\"",
      "210:             let uri = URI(scheme: scheme, host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "211:             XCTAssertEqual(uri.string, \"foo://host:1/test?query#fragment\")",
      "212:         }",
      "213:         do {",
      "214:             let uri = URI(scheme: .http, host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "215:             XCTAssertEqual(uri.string, \"http://host:1/test?query#fragment\")",
      "216:         }",
      "217:         do {",
      "218:             let uri = URI(scheme: nil, host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "219:             XCTAssertEqual(uri.string, \"host:1/test?query#fragment\")",
      "220:         }",
      "221:         do {",
      "222:             let uri = URI(scheme: URI.Scheme(), host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "223:             XCTAssertEqual(uri.string, \"host:1/test?query#fragment\")",
      "224:         }",
      "225:         do {",
      "226:             let uri = URI(host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "227:             XCTAssertEqual(uri.string, \"host:1/test?query#fragment\")",
      "228:         }",
      "229:         do {",
      "230:             let uri = URI(scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\", query: \"query\", fragment: \"fragment\")",
      "231:             XCTAssertEqual(uri.string, \"http+unix://%2Fpath/test?query#fragment\")",
      "232:         }",
      "233:         do {",
      "234:             let uri = URI(scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\", fragment: \"fragment\")",
      "235:             XCTAssertEqual(uri.string, \"http+unix://%2Fpath/test#fragment\")",
      "236:         }",
      "237:         do {",
      "238:             let uri = URI(scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\")",
      "239:             XCTAssertEqual(uri.string, \"http+unix://%2Fpath/test\")",
      "240:         }",
      "241:         do {",
      "242:             let uri = URI()",
      "243:             XCTAssertEqual(uri.string, \"/\")",
      "244:         }",
      "245:     }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Tests/VaporTests/ServerTests.swift||Tests/VaporTests/ServerTests.swift": [
      "File: Tests/VaporTests/ServerTests.swift -> Tests/VaporTests/ServerTests.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "5: #endif",
      "6: import Vapor",
      "7: import XCTest",
      "8: import AsyncHTTPClient",
      "",
      "[Removed Lines]",
      "1: #if os(Linux)",
      "2: @preconcurrency import Foundation",
      "3: #else",
      "4: import Foundation",
      "",
      "[Added Lines]",
      "1: #if !canImport(Darwin)",
      "2: @preconcurrency import Dispatch",
      "4: import Foundation",
      "",
      "---------------"
    ],
    "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift": [
      "File: Tests/VaporTests/URITests.swift -> Tests/VaporTests/URITests.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: import XCTVapor",
      "2: import XCTest",
      "3: import Vapor",
      "4: import NIOCore",
      "5: import Algorithms",
      "7: extension RangeReplaceableCollection where Self.SubSequence == Substring, Self: StringProtocol {",
      "8:     #if compiler(>=5.9)",
      "9:     #if hasFeature(BareSlashRegexLiterals)",
      "10:     private static var percentEncodingPattern: Regex<Substring> { /(?:%\\p{AHex}{2})+/ }",
      "11:     #else",
      "12:     private static var percentEncodingPattern: Regex<Substring> { try! Regex(\"(?:%\\\\p{AHex}{2})+\") }",
      "13:     #endif",
      "14:     #else",
      "15:     private static var percentEncodingPattern: Regex<Substring> { try! Regex(\"(?:%\\\\p{AHex}{2})+\") }",
      "16:     #endif",
      "21:     var safelyUrlDecoded: Self {",
      "22:         self.replacing(",
      "23:             Self.percentEncodingPattern,",
      "24:             with: { Self(decoding: $0.0.split(separator: \"%\").map { .init($0, radix: 16)! }, as: UTF8.self) }",
      "25:         )",
      "26:     }",
      "27: }",
      "29: func XCTAssertURIComponents(",
      "30:        scheme: @autoclosure () throws -> URI.Scheme?,",
      "31:      userinfo: @autoclosure () throws -> String? = nil,",
      "32:          host: @autoclosure () throws -> String? = nil,",
      "33:          port: @autoclosure () throws -> Int?    = nil,",
      "34:          path: @autoclosure () throws -> String,",
      "35:         query: @autoclosure () throws -> String? = nil,",
      "36:      fragment: @autoclosure () throws -> String? = nil,",
      "37:      generate expected: @autoclosure () throws -> String,",
      "38:     _ message: @autoclosure () -> String = \"\", file: StaticString = #filePath, line: UInt = #line",
      "39: ) {",
      "40:     XCTAssertURIComponents(",
      "41:         scheme: try scheme()?.value,",
      "42:         userinfo: try userinfo(),",
      "43:         host: try host(),",
      "44:         port: try port(),",
      "45:         path: try path(),",
      "46:         query: try query(),",
      "47:         fragment: try fragment(),",
      "48:         generate: try expected(),",
      "49:         message(), file: file, line: line",
      "50:     )",
      "51: }",
      "53: func XCTAssertURIComponents(",
      "54:        scheme: @autoclosure () throws -> String? = nil,",
      "55:      userinfo: @autoclosure () throws -> String? = nil,",
      "56:          host: @autoclosure () throws -> String? = nil,",
      "57:          port: @autoclosure () throws -> Int?    = nil,",
      "58:          path: @autoclosure () throws -> String,",
      "59:         query: @autoclosure () throws -> String? = nil,",
      "60:      fragment: @autoclosure () throws -> String? = nil,",
      "61:      generate expected: @autoclosure () throws -> String,",
      "62:     _ message: @autoclosure () -> String = \"\", file: StaticString = #filePath, line: UInt = #line",
      "63: ) {",
      "64:     do {",
      "65:         let scheme = try scheme(), userinfo = try userinfo(), host = try host(), port = try port(),",
      "66:             path = try path(), query = try query(), fragment = try fragment()",
      "67:         let uri = URI(scheme: scheme, userinfo: userinfo, host: host, port: port, path: path, query: query, fragment: fragment)",
      "70:         XCTAssertEqual(uri.scheme,   scheme?.safelyUrlDecoded,   \"(scheme) \\(message())\", file: file, line: line)",
      "71:         XCTAssertEqual(uri.userinfo, userinfo?.safelyUrlDecoded, \"(userinfo) \\(message())\", file: file, line: line)",
      "72:         XCTAssertEqual(uri.host,     host?.safelyUrlDecoded,     \"(host) \\(message())\", file: file, line: line)",
      "73:         XCTAssertEqual(uri.port,     port,                       \"(port) \\(message())\", file: file, line: line)",
      "74:         XCTAssertEqual(uri.path,     \"/\\(path.safelyUrlDecoded.trimmingPrefix(\"/\"))\", \"(path) \\(message())\", file: file, line: line)",
      "75:         XCTAssertEqual(uri.query,    query?.safelyUrlDecoded,    \"(query) \\(message())\", file: file, line: line)",
      "76:         XCTAssertEqual(uri.fragment, fragment?.safelyUrlDecoded, \"(fragment) \\(message())\", file: file, line: line)",
      "79:         XCTAssertEqual(uri.string,   try expected(),             \"(string) \\(message())\", file: file, line: line)",
      "80:     } catch {",
      "81:         XCTAssertEqual(try { throw error }(), false,             message(), file: file, line: line)",
      "82:     }",
      "83: }",
      "85: func XCTAssertURIString(",
      "86:      _ string: @autoclosure () throws -> String,",
      "87:      hasScheme scheme:     @autoclosure () throws -> String? = nil,",
      "88:      hasUserinfo userinfo: @autoclosure () throws -> String? = nil,",
      "89:      hasHost host:         @autoclosure () throws -> String? = \"\",",
      "90:      hasPort port:         @autoclosure () throws -> Int?    = nil,",
      "91:      hasPath path:         @autoclosure () throws -> String,",
      "92:      hasQuery query:       @autoclosure () throws -> String? = nil,",
      "93:      hasFragment fragment: @autoclosure () throws -> String? = nil,",
      "94:      hasEqualString exact: @autoclosure () throws -> Bool = true,",
      "95:     _ message: @autoclosure () -> String = \"\", file: StaticString = #filePath, line: UInt = #line",
      "96: ) {",
      "97:     do {",
      "98:         let string = try string()",
      "99:         let uri = URI(string: string)",
      "102:         XCTAssertEqual(uri.scheme,   try scheme()?.safelyUrlDecoded,   \"(scheme) \\(message())\", file: file, line: line)",
      "103:         XCTAssertEqual(uri.userinfo, try userinfo()?.safelyUrlDecoded, \"(userinfo) \\(message())\", file: file, line: line)",
      "104:         XCTAssertEqual(uri.host,     try host()?.safelyUrlDecoded,     \"(host) \\(message())\", file: file, line: line)",
      "105:         XCTAssertEqual(uri.port,     try port(),                       \"(port) \\(message())\", file: file, line: line)",
      "106:         XCTAssertEqual(uri.path,     try path().safelyUrlDecoded,      \"(path) \\(message())\", file: file, line: line)",
      "107:         XCTAssertEqual(uri.query,    try query()?.safelyUrlDecoded,    \"(query) \\(message())\", file: file, line: line)",
      "108:         XCTAssertEqual(uri.fragment, try fragment()?.safelyUrlDecoded, \"(fragment) \\(message())\", file: file, line: line)",
      "111:         if try exact() {",
      "112:             XCTAssertEqual(uri.string,   string,                       \"(string) \\(message())\", file: file, line: line)",
      "113:         }",
      "114:     } catch {",
      "115:         XCTAssertEqual(try { throw error }(), false,                   message(), file: file, line: line)",
      "116:     }",
      "117: }",
      "119: final class URITests: XCTestCase {",
      "120:     func testBasicConstruction() {",
      "121:         XCTAssertURIString(",
      "122:             \"https://user:pass@vapor.codes:1234/foo?bar=baz#qux\",",
      "123:             hasScheme: \"https\",",
      "124:             hasUserinfo: \"user:pass\",",
      "125:             hasHost: \"vapor.codes\",",
      "126:             hasPort: 1234,",
      "127:             hasPath: \"/foo\",",
      "128:             hasQuery: \"bar=baz\",",
      "129:             hasFragment: \"qux\"",
      "130:         )",
      "131:         XCTAssertURIComponents(",
      "132:             scheme: \"https\",",
      "133:             userinfo: \"user:pass\",",
      "134:             host: \"vapor.codes\",",
      "135:             port: 1234,",
      "136:             path: \"/foo\",",
      "137:             query: \"bar=baz\",",
      "138:             fragment: \"qux\",",
      "139:             generate: \"https://user:pass@vapor.codes:1234/foo?bar=baz#qux\"",
      "140:         )",
      "142:         XCTAssertURIString(\"wss://echo.websocket.org/\", hasScheme: \"wss\", hasHost: \"echo.websocket.org\", hasPath: \"/\")",
      "143:         XCTAssertURIComponents(scheme: \"wss\", host: \"echo.websocket.org\", path: \"/\", generate: \"wss://echo.websocket.org/\")",
      "144:     }",
      "146:     func testMutation() {",
      "147:         var uri = URI(string: \"https://user:pass@vapor.codes:1234/foo?bar=baz#qux\")",
      "150:         uri.query = \"bar=baz&test=1\"",
      "151:         XCTAssertEqual(uri.string, \"https://user:pass@vapor.codes:1234/foo?bar=baz&test=1#qux\")",
      "154:         uri.query = nil",
      "155:         XCTAssertEqual(uri.string, \"https://user:pass@vapor.codes:1234/foo#qux\")",
      "156:     }",
      "158:     func testPathStrings() {",
      "160:         let uri = URI(string: \"/foo/bar/baz\")",
      "161:         XCTAssertEqual(uri.path, \"/foo/bar/baz\")",
      "162:     }",
      "164:     func testNonAbsolutePath() {",
      "165:         let uri = URI(string: \"foo\")",
      "170:         XCTAssertEqual(uri.scheme, nil)",
      "171:         XCTAssertEqual(uri.host, nil)",
      "172:         XCTAssertEqual(uri.path, \"foo\")",
      "173:     }",
      "175:     func testStringInterpolation() {",
      "176:         let foo = \"foo\"",
      "177:         XCTAssertEqual((\"/\\(foo)/bar/baz\" as URI).path, \"/foo/bar/baz\")",
      "179:         let bar = \"bar\"",
      "180:         let uri = URI(scheme: \"foo\\(bar)\", host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "181:         XCTAssertEqual(uri.string, \"foobar://host:1/test?query#fragment\")",
      "182:     }",
      "184:     func testVariousSchemesAndWeirdHosts() {",
      "187:         XCTAssertURIComponents(",
      "188:             host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\",",
      "189:             generate: \"//host:1/test?query#fragment\"",
      "190:         )",
      "191:         XCTAssertURIComponents(",
      "192:             scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\",",
      "193:             generate: \"http+unix://%2Fpath/test\"",
      "194:         )",
      "195:         XCTAssertURIComponents(",
      "196:             scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\", fragment: \"fragment\",",
      "197:             generate: \"http+unix://%2Fpath/test#fragment\"",
      "198:         )",
      "199:         XCTAssertURIComponents(",
      "200:             scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\", query: \"query\", fragment: \"fragment\",",
      "201:             generate: \"http+unix://%2Fpath/test?query#fragment\"",
      "202:         )",
      "203:     }",
      "205:     func testDefaultInitializer() {",
      "206:         let uri = URI.init()",
      "207:         XCTAssertEqual(uri.string, \"/\")",
      "208:     }",
      "210:     func testOverlongURIParsing() {",
      "211:         let zeros = String(repeating: \"0\", count: 65_512)",
      "212:         let untrustedInput = \"[https://vapor.codes.somewhere-else.test:](https://vapor.codes.somewhere-else.test/\\(zeros)443)[\\(zeros)](https://vapor.codes.somewhere-else.test/\\(zeros)443)[443](https://vapor.codes.somewhere-else.test/\\(zeros)443)\"",
      "214:         XCTAssertURIString(untrustedInput, hasHost: nil, hasPath: untrustedInput, hasEqualString: false)",
      "215:     }",
      "217:     func testUrlParsingVectors() {",
      "218:         XCTAssertURIString(\"file:///usr/local/bin\", hasScheme: \"file\", hasPath: \"/usr/local/bin\")",
      "219:         XCTAssertURIString(\"file:/usr/local/bin\", hasScheme: \"file\", hasHost: nil, hasPath: \"/usr/local/bin\")",
      "220:         XCTAssertURIString(\"file://localhost/usr/local/bin\", hasScheme: \"file\", hasHost: \"localhost\", hasPath: \"/usr/local/bin\")",
      "221:         XCTAssertURIString(\"file://usr/local/bin\", hasScheme: \"file\", hasHost: \"usr\", hasPath: \"/local/bin\")",
      "222:         XCTAssertURIString(\"/usr/local/bin\", hasHost: nil, hasPath: \"/usr/local/bin\")",
      "223:         XCTAssertURIString(\"file://localhost/usr/local/bin/\", hasScheme: \"file\", hasHost: \"localhost\", hasPath: \"/usr/local/bin/\")",
      "224:         XCTAssertURIString(\"file://localhost/\", hasScheme: \"file\", hasHost: \"localhost\", hasPath: \"/\")",
      "225:         XCTAssertURIString(\"file:///\", hasScheme: \"file\", hasPath: \"/\")",
      "226:         XCTAssertURIString(\"file:/\", hasScheme: \"file\", hasHost: nil, hasPath: \"/\")",
      "227:         XCTAssertURIString(\"file:///Volumes\", hasScheme: \"file\", hasPath: \"/Volumes\")",
      "228:         XCTAssertURIString(\"file:///Users/darin\", hasScheme: \"file\", hasPath: \"/Users/darin\")",
      "229:         XCTAssertURIString(\"file:/\", hasScheme: \"file\", hasHost: nil, hasPath: \"/\")",
      "230:         XCTAssertURIString(\"file:///.\", hasScheme: \"file\", hasPath: \"/.\")",
      "231:         XCTAssertURIString(\"file:///./.\", hasScheme: \"file\", hasPath: \"/./.\")",
      "232:         XCTAssertURIString(\"file:///.///.\", hasScheme: \"file\", hasPath: \"/.///.\")",
      "233:         XCTAssertURIString(\"file:///a/..\", hasScheme: \"file\", hasPath: \"/a/..\")",
      "234:         XCTAssertURIString(\"file:///a/b/..\", hasScheme: \"file\", hasPath: \"/a/b/..\")",
      "235:         XCTAssertURIString(\"file:///a/b//..\", hasScheme: \"file\", hasPath: \"/a/b//..\")",
      "236:         XCTAssertURIString(\"file:///./a/b/..\", hasScheme: \"file\", hasPath: \"/./a/b/..\")",
      "237:         XCTAssertURIString(\"file:///a/./b/..\", hasScheme: \"file\", hasPath: \"/a/./b/..\")",
      "238:         XCTAssertURIString(\"file:///a/b/./..\", hasScheme: \"file\", hasPath: \"/a/b/./..\")",
      "239:         XCTAssertURIString(\"file:///a///b//..\", hasScheme: \"file\", hasPath: \"/a///b//..\")",
      "240:         XCTAssertURIString(\"file:///a/b/../..\", hasScheme: \"file\", hasPath: \"/a/b/../..\")",
      "241:         XCTAssertURIString(\"file:///a/b/c/../..\", hasScheme: \"file\", hasPath: \"/a/b/c/../..\")",
      "242:         XCTAssertURIString(\"file:///a/../b/..\", hasScheme: \"file\", hasPath: \"/a/../b/..\")",
      "243:         XCTAssertURIString(\"file:///a/../b/../c\", hasScheme: \"file\", hasPath: \"/a/../b/../c\")",
      "244:         XCTAssertURIString(\"file:///a/../b/../c\", hasScheme: \"file\", hasPath: \"/a/../b/../c\")",
      "245:         XCTAssertURIString(\"ftp://ftp.gnu.org/\", hasScheme: \"ftp\", hasHost: \"ftp.gnu.org\", hasPath: \"/\")",
      "246:         XCTAssertURIString(\"ftp://ftp.gnu.org/pub/gnu\", hasScheme: \"ftp\", hasHost: \"ftp.gnu.org\", hasPath: \"/pub/gnu\")",
      "247:         XCTAssertURIString(\"ftp://luser@ftp.gnu.org/pub/gnu\",",
      "248:             hasScheme: \"ftp\", hasUserinfo: \"luser\", hasHost: \"ftp.gnu.org\", hasPath: \"/pub/gnu\"",
      "249:         )",
      "250:         XCTAssertURIString(\"ftp://@ftp.gnu.org/pub/gnu\", hasScheme: \"ftp\", hasUserinfo: \"\", hasHost: \"ftp.gnu.org\", hasPath: \"/pub/gnu\")",
      "251:         XCTAssertURIString(\"ftp://luser:password@ftp.gnu.org/pub/gnu\",",
      "252:             hasScheme: \"ftp\", hasUserinfo: \"luser:password\", hasHost: \"ftp.gnu.org\", hasPath: \"/pub/gnu\"",
      "253:         )",
      "254:         XCTAssertURIString(\"ftp://:password@ftp.gnu.org/pub/gnu\",",
      "255:             hasScheme: \"ftp\", hasUserinfo: \":password\", hasHost: \"ftp.gnu.org\", hasPath: \"/pub/gnu\"",
      "256:         )",
      "257:         XCTAssertURIString(\"ftp://ftp.gnu.org:72/pub/gnu\", hasScheme: \"ftp\", hasHost: \"ftp.gnu.org\", hasPort: 72, hasPath: \"/pub/gnu\")",
      "258:         XCTAssertURIString(\"ftp://:72/pub/gnu\", hasScheme: \"ftp\", hasHost: \"\", hasPort: 72, hasPath: \"/pub/gnu\")",
      "259:         XCTAssertURIString(\"http://localhost/usr/local/bin/\", hasScheme: \"http\", hasHost: \"localhost\", hasPath: \"/usr/local/bin/\")",
      "260:         XCTAssertURIString(\"http://localhost/\", hasScheme: \"http\", hasHost: \"localhost\", hasPath: \"/\")",
      "261:         XCTAssertURIString(\"http://www.apple.com/\", hasScheme: \"http\", hasHost: \"www.apple.com\", hasPath: \"/\")",
      "262:         XCTAssertURIString(\"http://www.apple.com/dir\", hasScheme: \"http\", hasHost: \"www.apple.com\", hasPath: \"/dir\")",
      "263:         XCTAssertURIString(\"http://www.apple.com/dir/\", hasScheme: \"http\", hasHost: \"www.apple.com\", hasPath: \"/dir/\")",
      "264:         XCTAssertURIString(\"http://darin:nothin@www.apple.com:42/dir/\",",
      "265:             hasScheme: \"http\", hasUserinfo: \"darin:nothin\", hasHost: \"www.apple.com\", hasPort: 42, hasPath: \"/dir/\"",
      "266:         )",
      "267:         XCTAssertURIString(\"http:/\", hasScheme: \"http\", hasHost: nil, hasPath: \"/\")",
      "268:         XCTAssertURIString(\"http://www.apple.com/query?email=darin@apple.com\",",
      "269:             hasScheme: \"http\", hasHost: \"www.apple.com\", hasPath: \"/query\", hasQuery: \"email=darin@apple.com\"",
      "270:         )",
      "271:         XCTAssertURIString(\"HTTP://WWW.ZOO.COM/\", hasScheme: \"HTTP\", hasHost: \"WWW.ZOO.COM\", hasPath: \"/\")",
      "272:         XCTAssertURIString(\"HTTP://WWW.ZOO.COM/ED\", hasScheme: \"HTTP\", hasHost: \"WWW.ZOO.COM\", hasPath: \"/ED\")",
      "273:         XCTAssertURIString(\"http://groups.google.com/groups?as_uauthors=joe@blow.com&as_scoring=d&hl=en\",",
      "274:             hasScheme: \"http\", hasHost: \"groups.google.com\", hasPath: \"/groups\", hasQuery: \"as_uauthors=joe@blow.com&as_scoring=d&hl=en\"",
      "275:         )",
      "276:         XCTAssertURIString(\"http://my.site.com/some/page.html#fragment\",",
      "277:             hasScheme: \"http\", hasHost: \"my.site.com\", hasPath: \"/some/page.html\", hasFragment: \"fragment\"",
      "278:         )",
      "279:         XCTAssertURIString(\"scheme://user:pass@host:1/path/path2/file.html;params?query#fragment\",",
      "280:             hasScheme: \"scheme\", hasUserinfo: \"user:pass\", hasHost: \"host\", hasPort: 1, hasPath: \"/path/path2/file.html;params\",",
      "281:             hasQuery: \"query\", hasFragment: \"fragment\"",
      "282:         )",
      "283:         XCTAssertURIString(\"http://test.com/a%20space\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/a space\")",
      "284:         XCTAssertURIString(\"http://test.com/aBrace%7B\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/aBrace{\")",
      "285:         XCTAssertURIString(\"http://test.com/aJ%4a\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/aJJ\")",
      "286:         XCTAssertURIString(\"file:///%3F\", hasScheme: \"file\", hasPath: \"/?\")",
      "287:         XCTAssertURIString(\"file:///%78\", hasScheme: \"file\", hasPath: \"/x\")",
      "288:         XCTAssertURIString(\"file:///?\", hasScheme: \"file\", hasPath: \"/\", hasQuery: \"\")",
      "289:         XCTAssertURIString(\"file:///&\", hasScheme: \"file\", hasPath: \"/&\")",
      "290:         XCTAssertURIString(\"file:///x\", hasScheme: \"file\", hasPath: \"/x\")",
      "291:         XCTAssertURIString(\"http:///%3F\", hasScheme: \"http\", hasPath: \"/?\")",
      "292:         XCTAssertURIString(\"http:///%78\", hasScheme: \"http\", hasPath: \"/x\")",
      "293:         XCTAssertURIString(\"http:///?\", hasScheme: \"http\", hasPath: \"/\", hasQuery: \"\")",
      "294:         XCTAssertURIString(\"http:///&\", hasScheme: \"http\", hasPath: \"/&\")",
      "295:         XCTAssertURIString(\"http:///x\", hasScheme: \"http\", hasPath: \"/x\")",
      "296:         XCTAssertURIString(\"glorb:///%3F\", hasScheme: \"glorb\", hasPath: \"/?\")",
      "297:         XCTAssertURIString(\"glorb:///%78\", hasScheme: \"glorb\", hasPath: \"/x\")",
      "298:         XCTAssertURIString(\"glorb:///?\", hasScheme: \"glorb\", hasPath: \"/\", hasQuery: \"\")",
      "299:         XCTAssertURIString(\"glorb:///&\", hasScheme: \"glorb\", hasPath: \"/&\")",
      "300:         XCTAssertURIString(\"glorb:///x\", hasScheme: \"glorb\", hasPath: \"/x\")",
      "301:         XCTAssertURIString(\"uahsfcncvuhrtgvnahr\", hasHost: nil, hasPath: \"uahsfcncvuhrtgvnahr\")",
      "302:         XCTAssertURIString(\"http://[fe80::20a:27ff:feae:8b9e]/\", hasScheme: \"http\", hasHost: \"[fe80::20a:27ff:feae:8b9e]\", hasPath: \"/\")",
      "303:         XCTAssertURIString(\"http://[fe80::20a:27ff:feae:8b9e%25en0]/\", hasScheme: \"http\", hasHost: \"[fe80::20a:27ff:feae:8b9e%en0]\", hasPath: \"/\")",
      "304:         XCTAssertURIString(\"http://host.com/foo/bar/../index.html\", hasScheme: \"http\", hasHost: \"host.com\", hasPath: \"/foo/bar/../index.html\")",
      "305:         XCTAssertURIString(\"http://host.com/foo/bar/./index.html\", hasScheme: \"http\", hasHost: \"host.com\", hasPath: \"/foo/bar/./index.html\")",
      "306:         XCTAssertURIString(\"http:/cgi-bin/Count.cgi?ft=0\", hasScheme: \"http\", hasHost: nil, hasPath: \"/cgi-bin/Count.cgi\", hasQuery: \"ft=0\")",
      "307:         XCTAssertURIString(\"file://///\", hasScheme: \"file\", hasPath: \"///\")",
      "308:         XCTAssertURIString(\"file:/Volumes\", hasScheme: \"file\", hasHost: nil, hasPath: \"/Volumes\")",
      "309:         XCTAssertURIString(\"/Volumes\", hasHost: nil, hasPath: \"/Volumes\")",
      "310:         XCTAssertURIString(\".\", hasHost: nil, hasPath: \".\")",
      "311:         XCTAssertURIString(\"./a\", hasHost: nil, hasPath: \"./a\")",
      "312:         XCTAssertURIString(\"../a\", hasHost: nil, hasPath: \"../a\")",
      "313:         XCTAssertURIString(\"../../a\", hasHost: nil, hasPath: \"../../a\")",
      "314:         XCTAssertURIString(\"/\", hasHost: nil, hasPath: \"/\")",
      "315:         XCTAssertURIString(\"http://a/b/c/./g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./g\")",
      "316:         XCTAssertURIString(\"http://a/b/c/.\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/.\")",
      "317:         XCTAssertURIString(\"http://a/b/c/./\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./\")",
      "318:         XCTAssertURIString(\"http://a/b/c/..\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/..\")",
      "319:         XCTAssertURIString(\"http://a/b/c/../\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../\")",
      "320:         XCTAssertURIString(\"http://a/b/c/../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../g\")",
      "321:         XCTAssertURIString(\"http://a/b/c/../..\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../..\")",
      "322:         XCTAssertURIString(\"http://a/b/c/../../\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../../\")",
      "323:         XCTAssertURIString(\"http://a/b/c/../../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../../g\")",
      "324:         XCTAssertURIString(\"http://a/b/c/../../../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../../../g\")",
      "325:         XCTAssertURIString(\"http://a/b/c/../../../../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../../../../g\")",
      "326:         XCTAssertURIString(\"http://a/b/c/./g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./g\")",
      "327:         XCTAssertURIString(\"http://a/b/c/../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../g\")",
      "328:         XCTAssertURIString(\"http://a/b/c/g.\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g.\")",
      "329:         XCTAssertURIString(\"http://a/b/c/.g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/.g\")",
      "330:         XCTAssertURIString(\"http://a/b/c/g..\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g..\")",
      "331:         XCTAssertURIString(\"http://a/b/c/..g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/..g\")",
      "332:         XCTAssertURIString(\"http://a/b/c/./../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./../g\")",
      "333:         XCTAssertURIString(\"http://a/b/c/./g/.\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./g/.\")",
      "334:         XCTAssertURIString(\"http://a/b/c/g/./h\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g/./h\")",
      "335:         XCTAssertURIString(\"http://a/b/c/g/../h\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g/../h\")",
      "336:         XCTAssertURIString(\"http://a/b/c/g;x=1/./y\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g;x=1/./y\")",
      "337:         XCTAssertURIString(\"http://a/b/c/g;x=1/../y\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g;x=1/../y\")",
      "338:         XCTAssertURIString(\"http://a/b/c/g?y/./x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g\", hasQuery: \"y/./x\")",
      "339:         XCTAssertURIString(\"http://a/b/c/g?y/../x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g\", hasQuery: \"y/../x\")",
      "340:         XCTAssertURIString(\"http://a/b/c/g#s/./x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g\", hasFragment: \"s/./x\")",
      "341:         XCTAssertURIString(\"http://a/b/c/g#s/../x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g\", hasFragment: \"s/../x\")",
      "342:         XCTAssertURIString(\"http://a/../../x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/../../x\")",
      "343:         XCTAssertURIString(\"http://a/..///../x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/..///../x\")",
      "344:     }",
      "345: }",
      "",
      "---------------"
    ],
    "Tests/VaporTests/ValidationTests.swift||Tests/VaporTests/ValidationTests.swift": [
      "File: Tests/VaporTests/ValidationTests.swift -> Tests/VaporTests/ValidationTests.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "161:         \"\"\"",
      "162:         XCTAssertNoThrow(try Email.validate(json: valid))",
      "165:         XCTAssertNoThrow(try Email.validate(query: validURL))",
      "168:         XCTAssertNoThrow(try Email.validate(query: validURL2))",
      "170:         let invalidUser = \"\"\"",
      "",
      "[Removed Lines]",
      "164:         let validURL: URI = \"https://tanner.xyz/email?email=\u00df@tanner.xyz\"",
      "167:         let validURL2: URI = \"https://tanner.xyz/email?email=me@\u00dfanner.xyz\"",
      "",
      "[Added Lines]",
      "166:         let validURL: URI = \"https://tanner.xyz/email?email=%C3%9F@tanner.xyz\" // \u00df",
      "169:         let validURL2: URI = \"https://tanner.xyz/email?email=me@%C3%9Fanner.xyz\"",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d5025b3fa0aac5d0b636532a86d6ed705e55e9a3",
      "candidate_info": {
        "commit_hash": "d5025b3fa0aac5d0b636532a86d6ed705e55e9a3",
        "repo": "vapor/vapor",
        "commit_url": "https://github.com/vapor/vapor/commit/d5025b3fa0aac5d0b636532a86d6ed705e55e9a3",
        "files": [
          "README.md",
          "Sources/Vapor/Content/ContainerGetPathExecutor.swift",
          "Sources/Vapor/Content/ContentCoders.swift",
          "Sources/Vapor/Content/ContentContainer.swift",
          "Sources/Vapor/Content/JSONCoders+Content.swift",
          "Sources/Vapor/Content/PlaintextDecoder.swift",
          "Sources/Vapor/Content/PlaintextEncoder.swift",
          "Sources/Vapor/Content/URLQueryCoders.swift",
          "Sources/Vapor/Content/URLQueryContainer.swift",
          "Sources/Vapor/Multipart/FormDataDecoder+Content.swift",
          "Sources/Vapor/Multipart/FormDataEncoder+Content.swift",
          "Sources/Vapor/URLEncodedForm/URLEncodedFormDecoder.swift",
          "Sources/Vapor/URLEncodedForm/URLEncodedFormEncoder.swift",
          "Sources/Vapor/Utilities/URI.swift",
          "Tests/AsyncTests/AsyncCommandsTests.swift",
          "Tests/AsyncTests/AsyncRequestTests.swift",
          "Tests/VaporTests/ClientTests.swift",
          "Tests/VaporTests/ContentTests.swift",
          "Tests/VaporTests/RouteTests.swift",
          "Tests/VaporTests/ServerTests.swift",
          "Tests/VaporTests/URITests.swift"
        ],
        "message": "Fix broken URI behaviors (#3140)\n\n* Fix the issues with URI's behavior and add tests for the various issues reported on GitHub\n* Fix Sendable correctness in the various content coder subsystems\n* Tweak a few timeouts to reduce test runtime (reduced by 2/3)\n* Use app.startup() rather than app.start() in async contexts in tests\n* Minor README updates\n* Add Mastodon link to replace old Twitter one\n* Add missing image alt text",
        "before_after_code_files": [
          "Sources/Vapor/Content/ContainerGetPathExecutor.swift||Sources/Vapor/Content/ContainerGetPathExecutor.swift",
          "Sources/Vapor/Content/ContentCoders.swift||Sources/Vapor/Content/ContentCoders.swift",
          "Sources/Vapor/Content/ContentContainer.swift||Sources/Vapor/Content/ContentContainer.swift",
          "Sources/Vapor/Content/JSONCoders+Content.swift||Sources/Vapor/Content/JSONCoders+Content.swift",
          "Sources/Vapor/Content/PlaintextDecoder.swift||Sources/Vapor/Content/PlaintextDecoder.swift",
          "Sources/Vapor/Content/PlaintextEncoder.swift||Sources/Vapor/Content/PlaintextEncoder.swift",
          "Sources/Vapor/Content/URLQueryCoders.swift||Sources/Vapor/Content/URLQueryCoders.swift",
          "Sources/Vapor/Content/URLQueryContainer.swift||Sources/Vapor/Content/URLQueryContainer.swift",
          "Sources/Vapor/Multipart/FormDataDecoder+Content.swift||Sources/Vapor/Multipart/FormDataDecoder+Content.swift",
          "Sources/Vapor/Multipart/FormDataEncoder+Content.swift||Sources/Vapor/Multipart/FormDataEncoder+Content.swift",
          "Sources/Vapor/URLEncodedForm/URLEncodedFormDecoder.swift||Sources/Vapor/URLEncodedForm/URLEncodedFormDecoder.swift",
          "Sources/Vapor/URLEncodedForm/URLEncodedFormEncoder.swift||Sources/Vapor/URLEncodedForm/URLEncodedFormEncoder.swift",
          "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift",
          "Tests/AsyncTests/AsyncCommandsTests.swift||Tests/AsyncTests/AsyncCommandsTests.swift",
          "Tests/AsyncTests/AsyncRequestTests.swift||Tests/AsyncTests/AsyncRequestTests.swift",
          "Tests/VaporTests/ClientTests.swift||Tests/VaporTests/ClientTests.swift",
          "Tests/VaporTests/ContentTests.swift||Tests/VaporTests/ContentTests.swift",
          "Tests/VaporTests/RouteTests.swift||Tests/VaporTests/RouteTests.swift",
          "Tests/VaporTests/ServerTests.swift||Tests/VaporTests/ServerTests.swift",
          "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift",
            "Tests/VaporTests/ClientTests.swift||Tests/VaporTests/ClientTests.swift",
            "Tests/VaporTests/ServerTests.swift||Tests/VaporTests/ServerTests.swift",
            "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift"
          ],
          "candidate": [
            "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift",
            "Tests/VaporTests/ClientTests.swift||Tests/VaporTests/ClientTests.swift",
            "Tests/VaporTests/ServerTests.swift||Tests/VaporTests/ServerTests.swift",
            "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift"
          ]
        }
      },
      "candidate_diff": {
        "Sources/Vapor/Content/ContainerGetPathExecutor.swift||Sources/Vapor/Content/ContainerGetPathExecutor.swift": [
          "File: Sources/Vapor/Content/ContainerGetPathExecutor.swift -> Sources/Vapor/Content/ContainerGetPathExecutor.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: internal struct ContainerGetPathExecutor<D: Decodable>: Decodable {",
          "3:     let result: D",
          "6:         [.containerGetKeypath: keyPath]",
          "7:     }",
          "",
          "[Removed Lines]",
          "5:     static func userInfo(for keyPath: [CodingKey]) -> [CodingUserInfoKey: Any] {",
          "",
          "[Added Lines]",
          "5:     static func userInfo(for keyPath: [CodingKey]) -> [CodingUserInfoKey: Sendable] {",
          "",
          "---------------"
        ],
        "Sources/Vapor/Content/ContentCoders.swift||Sources/Vapor/Content/ContentCoders.swift": [
          "File: Sources/Vapor/Content/ContentCoders.swift -> Sources/Vapor/Content/ContentCoders.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:         where E: Encodable",
          "26: }",
          "",
          "[Removed Lines]",
          "24:     func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders, userInfo: [CodingUserInfoKey: Any]) throws",
          "",
          "[Added Lines]",
          "24:     func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders, userInfo: [CodingUserInfoKey: Sendable]) throws",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "46:         where D: Decodable",
          "47: }",
          "49: extension ContentEncoder {",
          "51:         where E: Encodable",
          "52:     {",
          "53:         try self.encode(encodable, to: &body, headers: &headers)",
          "",
          "[Removed Lines]",
          "45:     func decode<D>(_ decodable: D.Type, from body: ByteBuffer, headers: HTTPHeaders, userInfo: [CodingUserInfoKey: Any]) throws -> D",
          "50:     public func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders, userInfo: [CodingUserInfoKey: Any]) throws",
          "",
          "[Added Lines]",
          "45:     func decode<D>(_ decodable: D.Type, from body: ByteBuffer, headers: HTTPHeaders, userInfo: [CodingUserInfoKey: Sendable]) throws -> D",
          "50:     public func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders, userInfo: [CodingUserInfoKey: Sendable]) throws",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "55: }",
          "57: extension ContentDecoder {",
          "59:         where D: Decodable",
          "60:     {",
          "61:         try self.decode(decodable, from: body, headers: headers)",
          "",
          "[Removed Lines]",
          "58:     public func decode<D>(_ decodable: D.Type, from body: ByteBuffer, headers: HTTPHeaders, userInfo: [CodingUserInfoKey: Any]) throws -> D",
          "",
          "[Added Lines]",
          "58:     public func decode<D>(_ decodable: D.Type, from body: ByteBuffer, headers: HTTPHeaders, userInfo: [CodingUserInfoKey: Sendable]) throws -> D",
          "",
          "---------------"
        ],
        "Sources/Vapor/Content/ContentContainer.swift||Sources/Vapor/Content/ContentContainer.swift": [
          "File: Sources/Vapor/Content/ContentContainer.swift -> Sources/Vapor/Content/ContentContainer.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "133: fileprivate struct ForwardingContentDecoder: ContentDecoder {",
          "136:     func decode<D: Decodable>(_: D.Type, from body: ByteBuffer, headers: HTTPHeaders) throws -> D {",
          "137:         try self.base.decode(D.self, from: body, headers: headers, userInfo: self.info)",
          "138:     }",
          "140:         try self.base.decode(D.self, from: body, headers: headers, userInfo: userInfo.merging(self.info) { $1 })",
          "141:     }",
          "142: }",
          "",
          "[Removed Lines]",
          "134:     let base: ContentDecoder, info: [CodingUserInfoKey: Any]",
          "139:     func decode<D: Decodable>(_: D.Type, from body: ByteBuffer, headers: HTTPHeaders, userInfo: [CodingUserInfoKey: Any]) throws -> D {",
          "",
          "[Added Lines]",
          "134:     let base: ContentDecoder, info: [CodingUserInfoKey: Sendable]",
          "139:     func decode<D: Decodable>(_: D.Type, from body: ByteBuffer, headers: HTTPHeaders, userInfo: [CodingUserInfoKey: Sendable]) throws -> D {",
          "",
          "---------------"
        ],
        "Sources/Vapor/Content/JSONCoders+Content.swift||Sources/Vapor/Content/JSONCoders+Content.swift": [
          "File: Sources/Vapor/Content/JSONCoders+Content.swift -> Sources/Vapor/Content/JSONCoders+Content.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "9:         try self.encode(encodable, to: &body, headers: &headers, userInfo: [:])",
          "10:     }",
          "13:         where E: Encodable",
          "14:     {",
          "15:         headers.contentType = .json",
          "",
          "[Removed Lines]",
          "12:     public func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders, userInfo: [CodingUserInfoKey: Any]) throws",
          "",
          "[Added Lines]",
          "12:     public func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders, userInfo: [CodingUserInfoKey: Sendable]) throws",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36:         try self.decode(D.self, from: body, headers: headers, userInfo: [:])",
          "37:     }",
          "40:         where D: Decodable",
          "41:     {",
          "42:         let data = body.getData(at: body.readerIndex, length: body.readableBytes) ?? Data()",
          "",
          "[Removed Lines]",
          "39:     public func decode<D>(_ decodable: D.Type, from body: ByteBuffer, headers: HTTPHeaders, userInfo: [CodingUserInfoKey: Any]) throws -> D",
          "",
          "[Added Lines]",
          "39:     public func decode<D>(_ decodable: D.Type, from body: ByteBuffer, headers: HTTPHeaders, userInfo: [CodingUserInfoKey: Sendable]) throws -> D",
          "",
          "---------------"
        ],
        "Sources/Vapor/Content/PlaintextDecoder.swift||Sources/Vapor/Content/PlaintextDecoder.swift": [
          "File: Sources/Vapor/Content/PlaintextDecoder.swift -> Sources/Vapor/Content/PlaintextDecoder.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "13:     }",
          "17:         where D : Decodable",
          "18:     {",
          "19:         let string = body.getString(at: body.readerIndex, length: body.readableBytes)",
          "",
          "[Removed Lines]",
          "16:     public func decode<D>(_ decodable: D.Type, from body: ByteBuffer, headers: HTTPHeaders, userInfo: [CodingUserInfoKey: Any]) throws -> D",
          "",
          "[Added Lines]",
          "16:     public func decode<D>(_ decodable: D.Type, from body: ByteBuffer, headers: HTTPHeaders, userInfo: [CodingUserInfoKey: Sendable]) throws -> D",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29:     let userInfo: [CodingUserInfoKey: Any]",
          "30:     let plaintext: String?",
          "33:         self.plaintext = plaintext",
          "34:         self.userInfo = userInfo",
          "35:     }",
          "",
          "[Removed Lines]",
          "32:     init(plaintext: String?, userInfo: [CodingUserInfoKey: Any] = [:]) {",
          "",
          "[Added Lines]",
          "32:     init(plaintext: String?, userInfo: [CodingUserInfoKey: Sendable] = [:]) {",
          "",
          "---------------"
        ],
        "Sources/Vapor/Content/PlaintextEncoder.swift||Sources/Vapor/Content/PlaintextEncoder.swift": [
          "File: Sources/Vapor/Content/PlaintextEncoder.swift -> Sources/Vapor/Content/PlaintextEncoder.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "26:         try self.encode(encodable, to: &body, headers: &headers, userInfo: [:])",
          "27:     }",
          "30:         where E: Encodable",
          "31:     {",
          "32:         let actualEncoder: _PlaintextEncoder",
          "33:         if !userInfo.isEmpty {  // Changing a coder's userInfo is a thread-unsafe mutation, operate on a copy",
          "35:         } else {",
          "36:             actualEncoder = self.encoder",
          "37:         }",
          "",
          "[Removed Lines]",
          "29:     public func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders, userInfo: [CodingUserInfoKey: Any]) throws",
          "34:             actualEncoder = _PlaintextEncoder(userInfo: self.encoder.userInfo.merging(userInfo) { $1 })",
          "",
          "[Added Lines]",
          "29:     public func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders, userInfo: [CodingUserInfoKey: Sendable]) throws",
          "34:             actualEncoder = _PlaintextEncoder(userInfo: self.encoder.userInfoSendable.merging(userInfo) { $1 })",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52: private final class _PlaintextEncoder: Encoder, SingleValueEncodingContainer {",
          "53:     public var codingPath: [CodingKey] = []",
          "55:     public var plaintext: String?",
          "59:     public func container<Key: CodingKey>(keyedBy type: Key.Type) -> KeyedEncodingContainer<Key> { .init(FailureEncoder<Key>()) }",
          "60:     public func unkeyedContainer() -> UnkeyedEncodingContainer { FailureEncoder() }",
          "",
          "[Removed Lines]",
          "54:     public var userInfo: [CodingUserInfoKey: Any]",
          "57:     public init(userInfo: [CodingUserInfoKey: Any] = [:]) { self.userInfo = userInfo }",
          "",
          "[Added Lines]",
          "54:     fileprivate var userInfoSendable: [CodingUserInfoKey: Sendable]",
          "55:     public var userInfo: [CodingUserInfoKey: Any] { self.userInfoSendable }",
          "58:     public init(userInfo: [CodingUserInfoKey: Sendable] = [:]) { self.userInfoSendable = userInfo }",
          "",
          "---------------"
        ],
        "Sources/Vapor/Content/URLQueryCoders.swift||Sources/Vapor/Content/URLQueryCoders.swift": [
          "File: Sources/Vapor/Content/URLQueryCoders.swift -> Sources/Vapor/Content/URLQueryCoders.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "2:     func decode<D>(_ decodable: D.Type, from url: URI) throws -> D",
          "3:         where D: Decodable",
          "6:         where D: Decodable",
          "7: }",
          "",
          "[Removed Lines]",
          "5:     func decode<D>(_ decodable: D.Type, from url: URI, userInfo: [CodingUserInfoKey: Any]) throws -> D",
          "",
          "[Added Lines]",
          "5:     func decode<D>(_ decodable: D.Type, from url: URI, userInfo: [CodingUserInfoKey: Sendable]) throws -> D",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "10:     func encode<E>(_ encodable: E, to url: inout URI) throws",
          "11:         where E: Encodable",
          "14:         where E: Encodable",
          "15: }",
          "17: extension URLQueryEncoder {",
          "19:         where E: Encodable",
          "20:     {",
          "21:         try self.encode(encodable, to: &url)",
          "",
          "[Removed Lines]",
          "13:     func encode<E>(_ encodable: E, to url: inout URI, userInfo: [CodingUserInfoKey: Any]) throws",
          "18:     public func encode<E>(_ encodable: E, to url: inout URI, userInfo: [CodingUserInfoKey: Any]) throws",
          "",
          "[Added Lines]",
          "13:     func encode<E>(_ encodable: E, to url: inout URI, userInfo: [CodingUserInfoKey: Sendable]) throws",
          "18:     public func encode<E>(_ encodable: E, to url: inout URI, userInfo: [CodingUserInfoKey: Sendable]) throws",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "23: }",
          "25: extension URLQueryDecoder {",
          "27:         where D: Decodable",
          "28:     {",
          "29:         try self.decode(decodable, from: url)",
          "",
          "[Removed Lines]",
          "26:     public func decode<D>(_ decodable: D.Type, from url: URI, userInfo: [CodingUserInfoKey: Any]) throws -> D",
          "",
          "[Added Lines]",
          "26:     public func decode<D>(_ decodable: D.Type, from url: URI, userInfo: [CodingUserInfoKey: Sendable]) throws -> D",
          "",
          "---------------"
        ],
        "Sources/Vapor/Content/URLQueryContainer.swift||Sources/Vapor/Content/URLQueryContainer.swift": [
          "File: Sources/Vapor/Content/URLQueryContainer.swift -> Sources/Vapor/Content/URLQueryContainer.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "100: fileprivate struct ForwardingURLQueryDecoder: URLQueryDecoder {",
          "103:     func decode<D: Decodable>(_: D.Type, from url: URI) throws -> D { try self.base.decode(D.self, from: url, userInfo: self.info) }",
          "105:         try self.base.decode(D.self, from: url, userInfo: userInfo.merging(self.info) { $1 })",
          "106:     }",
          "107: }",
          "",
          "[Removed Lines]",
          "101:     let base: URLQueryDecoder, info: [CodingUserInfoKey: Any]",
          "104:     func decode<D: Decodable>(_: D.Type, from url: URI, userInfo: [CodingUserInfoKey: Any]) throws -> D {",
          "",
          "[Added Lines]",
          "101:     let base: URLQueryDecoder, info: [CodingUserInfoKey: Sendable]",
          "104:     func decode<D: Decodable>(_: D.Type, from url: URI, userInfo: [CodingUserInfoKey: Sendable]) throws -> D {",
          "",
          "---------------"
        ],
        "Sources/Vapor/Multipart/FormDataDecoder+Content.swift||Sources/Vapor/Multipart/FormDataDecoder+Content.swift": [
          "File: Sources/Vapor/Multipart/FormDataDecoder+Content.swift -> Sources/Vapor/Multipart/FormDataDecoder+Content.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "9:         try self.decode(D.self, from: body, headers: headers, userInfo: [:])",
          "10:     }",
          "13:         where D: Decodable",
          "14:     {",
          "15:         guard let boundary = headers.contentType?.parameters[\"boundary\"] else {",
          "",
          "[Removed Lines]",
          "12:     public func decode<D>(_ decodable: D.Type, from body: ByteBuffer, headers: HTTPHeaders, userInfo: [CodingUserInfoKey: Any]) throws -> D",
          "",
          "[Added Lines]",
          "12:     public func decode<D>(_ decodable: D.Type, from body: ByteBuffer, headers: HTTPHeaders, userInfo: [CodingUserInfoKey: Sendable]) throws -> D",
          "",
          "---------------"
        ],
        "Sources/Vapor/Multipart/FormDataEncoder+Content.swift||Sources/Vapor/Multipart/FormDataEncoder+Content.swift": [
          "File: Sources/Vapor/Multipart/FormDataEncoder+Content.swift -> Sources/Vapor/Multipart/FormDataEncoder+Content.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import NIOCore",
          "5: extension FormDataEncoder: ContentEncoder {",
          "9:         try self.encode(encodable, to: &body, headers: &headers, userInfo: [:])",
          "10:     }",
          "15:         let boundary = \"----vaporBoundary\\(randomBoundaryData())\"",
          "16:         headers.contentType = HTTPMediaType(type: \"multipart\", subType: \"form-data\", parameters: [\"boundary\": boundary])",
          "17:         if !userInfo.isEmpty {",
          "18:             var actualEncoder = self  // Changing a coder's userInfo is a thread-unsafe mutation, operate on a copy",
          "19:             actualEncoder.userInfo.merge(userInfo) { $1 }",
          "20:             return try actualEncoder.encode(encodable, boundary: boundary, into: &body)",
          "21:         } else {",
          "",
          "[Removed Lines]",
          "6:     public func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders) throws",
          "7:         where E: Encodable",
          "8:     {",
          "12:     public func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders, userInfo: [CodingUserInfoKey: Any]) throws",
          "13:         where E: Encodable",
          "14:     {",
          "",
          "[Added Lines]",
          "6:     public func encode<E: Encodable>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders) throws {",
          "10:     public func encode<E: Encodable>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders, userInfo: [CodingUserInfoKey: Sendable]) throws {",
          "",
          "---------------"
        ],
        "Sources/Vapor/URLEncodedForm/URLEncodedFormDecoder.swift||Sources/Vapor/URLEncodedForm/URLEncodedFormDecoder.swift": [
          "File: Sources/Vapor/URLEncodedForm/URLEncodedFormDecoder.swift -> Sources/Vapor/URLEncodedForm/URLEncodedFormDecoder.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: import Foundation",
          "3: import NIOHTTP1",
          "17: public struct URLEncodedFormDecoder: ContentDecoder, URLQueryDecoder {",
          "19:     public struct Configuration {",
          "21:         public enum DateDecodingStrategy {",
          "23:             case secondsSince1970",
          "25:             case iso8601",
          "27:             case custom((Decoder) throws -> Date)",
          "28:         }",
          "30:         let boolFlags: Bool",
          "31:         let arraySeparators: [Character]",
          "32:         let dateDecodingStrategy: DateDecodingStrategy",
          "44:         public init(",
          "45:             boolFlags: Bool = true,",
          "46:             arraySeparators: [Character] = [\",\", \"|\"],",
          "47:             dateDecodingStrategy: DateDecodingStrategy = .secondsSince1970,",
          "49:         ) {",
          "50:             self.boolFlags = boolFlags",
          "51:             self.arraySeparators = arraySeparators",
          "",
          "[Removed Lines]",
          "33:         let userInfo: [CodingUserInfoKey: Any]",
          "48:             userInfo: [CodingUserInfoKey: Any] = [:]",
          "",
          "[Added Lines]",
          "38:         let userInfo: [CodingUserInfoKey: Sendable]",
          "57:             userInfo: [CodingUserInfoKey: Sendable] = [:]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54:         }",
          "55:     }",
          "59:     private let parser: URLEncodedFormParser",
          "61:     private let configuration: Configuration",
          "72:         self.parser = URLEncodedFormParser()",
          "73:         self.configuration = configuration",
          "74:     }",
          "80:         try self.decode(D.self, from: body, headers: headers, userInfo: [:])",
          "81:     }",
          "87:         guard headers.contentType == .urlEncodedForm else {",
          "88:             throw Abort(.unsupportedMediaType)",
          "89:         }",
          "90:         let string = body.getString(at: body.readerIndex, length: body.readableBytes) ?? \"\"",
          "91:         return try self.decode(D.self, from: string, userInfo: userInfo)",
          "92:     }",
          "102:         try self.decode(D.self, from: url, userInfo: [:])",
          "103:     }",
          "115:     }",
          "131:         let configuration: URLEncodedFormDecoder.Configuration",
          "132:         if !userInfo.isEmpty { // Changing a coder's userInfo is a thread-unsafe mutation, operate on a copy",
          "134:         } else {",
          "135:             configuration = self.configuration",
          "136:         }",
          "137:         let decoder = _Decoder(data: parsedData, codingPath: [], configuration: configuration)",
          "138:         return try D(from: decoder)",
          "139:     }",
          "140: }",
          "",
          "[Removed Lines]",
          "69:     public init(",
          "70:         configuration: Configuration = .init()",
          "71:     ) {",
          "77:     public func decode<D>(_ decodable: D.Type, from body: ByteBuffer, headers: HTTPHeaders) throws -> D",
          "78:         where D: Decodable",
          "79:     {",
          "84:     public func decode<D>(_ decodable: D.Type, from body: ByteBuffer, headers: HTTPHeaders, userInfo: [CodingUserInfoKey: Any]) throws -> D",
          "85:         where D: Decodable",
          "86:     {",
          "101:     public func decode<D>(_ decodable: D.Type, from url: URI) throws -> D where D : Decodable {",
          "113:     public func decode<D>(_ decodable: D.Type, from url: URI, userInfo: [CodingUserInfoKey: Any]) throws -> D where D : Decodable {",
          "114:         try self.decode(D.self, from: url.query ?? \"\", userInfo: userInfo)",
          "129:     public func decode<D>(_ decodable: D.Type, from string: String, userInfo: [CodingUserInfoKey: Any] = [:]) throws -> D where D : Decodable {",
          "130:         let parsedData = try self.parser.parse(string)",
          "133:             configuration = .init(boolFlags: self.configuration.boolFlags, arraySeparators: self.configuration.arraySeparators, dateDecodingStrategy: self.configuration.dateDecodingStrategy, userInfo: self.configuration.userInfo.merging(userInfo) { $1 })",
          "",
          "[Added Lines]",
          "85:     public init(configuration: Configuration = .init()) {",
          "91:     public func decode<D: Decodable>(_: D.Type, from body: ByteBuffer, headers: HTTPHeaders) throws -> D {",
          "96:     public func decode<D: Decodable>(_: D.Type, from body: ByteBuffer, headers: HTTPHeaders, userInfo: [CodingUserInfoKey: Sendable]) throws -> D {",
          "107:     public func decode<D: Decodable>(_: D.Type, from url: URI) throws -> D {",
          "112:     public func decode<D: Decodable>(_: D.Type, from url: URI, userInfo: [CodingUserInfoKey: Sendable]) throws -> D {",
          "113:         try self.decode(D.self, from: url.query ?? \"\", userInfo: userInfo)",
          "114:     }",
          "129:     public func decode<D: Decodable>(_: D.Type, from string: String) throws -> D {",
          "143:         try self.decode(D.self, from: string, userInfo: [:])",
          "160:     public func decode<D: Decodable>(_: D.Type, from string: String, userInfo: [CodingUserInfoKey: Sendable]) throws -> D {",
          "164:             configuration = .init(",
          "165:                 boolFlags: self.configuration.boolFlags,",
          "166:                 arraySeparators: self.configuration.arraySeparators,",
          "167:                 dateDecodingStrategy: self.configuration.dateDecodingStrategy,",
          "168:                 userInfo: self.configuration.userInfo.merging(userInfo) { $1 }",
          "169:             )",
          "174:         let parsedData = try self.parser.parse(string)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "145: private struct _Decoder: Decoder {",
          "146:     var data: URLEncodedFormData",
          "148:     var configuration: URLEncodedFormDecoder.Configuration",
          "151:     var userInfo: [CodingUserInfoKey: Any] { self.configuration.userInfo }",
          "154:     init(data: URLEncodedFormData, codingPath: [CodingKey], configuration: URLEncodedFormDecoder.Configuration) {",
          "155:         self.data = data",
          "156:         self.codingPath = codingPath",
          "157:         self.configuration = configuration",
          "158:     }",
          "165:             codingPath: self.codingPath,",
          "167:         ))",
          "168:     }",
          "173:         let data: URLEncodedFormData",
          "174:         var codingPath: [CodingKey]",
          "175:         var configuration: URLEncodedFormDecoder.Configuration",
          "177:         var allKeys: [Key] {",
          "179:         }",
          "181:         init(",
          "",
          "[Removed Lines]",
          "147:     var codingPath: [CodingKey]",
          "160:     func container<Key>(keyedBy type: Key.Type) throws -> KeyedDecodingContainer<Key>",
          "161:         where Key: CodingKey",
          "162:     {",
          "163:         return KeyedDecodingContainer(KeyedContainer<Key>(",
          "164:             data: data,",
          "166:             configuration: configuration",
          "170:     struct KeyedContainer<Key>: KeyedDecodingContainerProtocol",
          "171:         where Key: CodingKey",
          "172:     {",
          "178:             return self.data.children.keys.compactMap { Key(stringValue: String($0)) }",
          "",
          "[Added Lines]",
          "189:     var codingPath: [CodingKey]",
          "201:     func container<Key: CodingKey>(keyedBy: Key.Type) throws -> KeyedDecodingContainer<Key> {",
          "202:         .init(KeyedContainer<Key>(",
          "203:             data: self.data,",
          "205:             configuration: self.configuration",
          "209:     struct KeyedContainer<Key: CodingKey>: KeyedDecodingContainerProtocol {",
          "215:             self.data.children.keys.compactMap { Key(stringValue: String($0)) }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "189:         }",
          "191:         func contains(_ key: Key) -> Bool {",
          "193:         }",
          "195:         func decodeNil(forKey key: Key) throws -> Bool {",
          "197:         }",
          "203:         }",
          "211:             let child = self.data.children[key.stringValue] ?? []",
          "219:                     }",
          "223:                     return result as! T",
          "226:                 }",
          "227:             } else {",
          "230:             }",
          "231:         }",
          "242:         }",
          "244:         func nestedUnkeyedContainer(forKey key: Key) throws -> UnkeyedDecodingContainer {",
          "249:                 codingPath: self.codingPath + [key],",
          "251:             )",
          "252:         }",
          "254:         func superDecoder() throws -> Decoder {",
          "258:         }",
          "260:         func superDecoder(forKey key: Key) throws -> Decoder {",
          "264:         }",
          "265:     }",
          "267:     func unkeyedContainer() throws -> UnkeyedDecodingContainer {",
          "269:     }",
          "271:     struct UnkeyedContainer: UnkeyedDecodingContainer {",
          "",
          "[Removed Lines]",
          "192:             return self.data.children[key.stringValue] != nil",
          "196:             return self.data.children[key.stringValue] == nil",
          "199:         private func decodeDate(forKey key: Key) throws -> Date {",
          "201:             let child = self.data.children[key.stringValue] ?? []",
          "202:             return try configuration.decodeDate(from: child, codingPath: self.codingPath, forKey: key)",
          "205:         func decode<T>(_ type: T.Type, forKey key: Key) throws -> T where T: Decodable {",
          "207:             guard !(T.self is Date.Type) else {",
          "208:                 return try decodeDate(forKey: key) as! T",
          "209:             }",
          "212:             if let convertible = T.self as? URLQueryFragmentConvertible.Type {",
          "213:                 guard let value = child.values.last else {",
          "214:                     if self.configuration.boolFlags {",
          "216:                         if let _ = T.self as? Bool.Type {",
          "217:                             return self.data.values.contains(.urlDecoded(key.stringValue)) as! T",
          "218:                         }",
          "220:                     throw DecodingError.valueNotFound(T.self, at: self.codingPath + [key])",
          "221:                 }",
          "222:                 if let result = convertible.init(urlQueryFragmentValue: value) {",
          "224:                 } else {",
          "225:                     throw DecodingError.typeMismatch(T.self, at: self.codingPath + [key])",
          "228:                 let decoder = _Decoder(data: child, codingPath: self.codingPath + [key], configuration: configuration)",
          "229:                 return try T(from: decoder)",
          "233:         func nestedContainer<NestedKey>(",
          "234:             keyedBy type: NestedKey.Type,",
          "235:             forKey key: Key",
          "236:         ) throws -> KeyedDecodingContainer<NestedKey>",
          "237:             where NestedKey: CodingKey",
          "238:         {",
          "239:             let child = self.data.children[key.stringValue] ?? []",
          "241:             return KeyedDecodingContainer(KeyedContainer<NestedKey>(data: child, codingPath: self.codingPath + [key], configuration: configuration))",
          "245:             let child = self.data.children[key.stringValue] ?? []",
          "247:             return try UnkeyedContainer(",
          "248:                 data: child,",
          "250:                 configuration: configuration",
          "255:             let child = self.data.children[\"super\"] ?? []",
          "257:             return _Decoder(data: child, codingPath: self.codingPath + [BasicCodingKey.key(\"super\")], configuration: self.configuration)",
          "261:             let child = self.data.children[key.stringValue] ?? []",
          "263:             return _Decoder(data: child, codingPath: self.codingPath + [key], configuration: self.configuration)",
          "268:         return try UnkeyedContainer(data: data, codingPath: codingPath, configuration: configuration)",
          "",
          "[Added Lines]",
          "229:             self.data.children[key.stringValue] != nil",
          "233:             self.data.children[key.stringValue] == nil",
          "236:         private func decodeDate(forKey key: Key, child: URLEncodedFormData) throws -> Date {",
          "237:             try configuration.decodeDate(from: child, codingPath: self.codingPath, forKey: key)",
          "240:         func decode<T: Decodable>(_: T.Type, forKey key: Key) throws -> T {",
          "246:             if T.self is Date.Type {",
          "247:                 return try self.decodeDate(forKey: key, child: child) as! T",
          "248:             } else if let convertible = T.self as? URLQueryFragmentConvertible.Type {",
          "249:                 switch child.values.last {",
          "250:                 case let value?:",
          "251:                     guard let result = convertible.init(urlQueryFragmentValue: value) else {",
          "252:                         throw DecodingError.typeMismatch(T.self, at: self.codingPath + [key])",
          "255:                 case nil where self.configuration.boolFlags && T.self is Bool.Type:",
          "257:                     return self.data.values.contains(.urlDecoded(key.stringValue)) as! T",
          "258:                 default:",
          "259:                     throw DecodingError.valueNotFound(T.self, at: self.codingPath + [key])",
          "262:                 let decoder = _Decoder(data: child, codingPath: self.codingPath + [key], configuration: self.configuration)",
          "264:                 return try T.init(from: decoder)",
          "268:         func nestedContainer<NestedKey: CodingKey>(keyedBy: NestedKey.Type, forKey key: Key) throws -> KeyedDecodingContainer<NestedKey> {",
          "269:             .init(KeyedContainer<NestedKey>(",
          "270:                 data: self.data.children[key.stringValue] ?? [],",
          "271:                 codingPath: self.codingPath + [key],",
          "272:                 configuration: self.configuration",
          "273:             ))",
          "277:             try UnkeyedContainer(",
          "278:                 data: self.data.children[key.stringValue] ?? [],",
          "280:                 configuration: self.configuration",
          "285:             _Decoder(",
          "286:                 data: self.data.children[\"super\"] ?? [],",
          "287:                 codingPath: self.codingPath + [BasicCodingKey.key(\"super\")],",
          "288:                 configuration: self.configuration",
          "289:             )",
          "293:             _Decoder(",
          "294:                 data: self.data.children[key.stringValue] ?? [],",
          "295:                 codingPath: self.codingPath + [key],",
          "296:                 configuration: self.configuration",
          "297:             )",
          "302:         try UnkeyedContainer(data: self.data, codingPath: self.codingPath, configuration: self.configuration)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "276:         var allChildKeysAreNumbers: Bool",
          "278:         var count: Int? {",
          "280:             if self.allChildKeysAreNumbers {",
          "281:                 return data.children.count",
          "282:             }",
          "285:         }",
          "286:         var isAtEnd: Bool {",
          "287:             guard let count = self.count else {",
          "288:                 return true",
          "289:             }",
          "290:             return currentIndex >= count",
          "291:         }",
          "292:         var currentIndex: Int",
          "294:         init(",
          "",
          "[Removed Lines]",
          "284:             return self.values.count",
          "",
          "[Added Lines]",
          "316:             } else {",
          "318:                 return self.values.count",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "300:             self.codingPath = codingPath",
          "301:             self.configuration = configuration",
          "302:             self.currentIndex = 0",
          "308:                 self.values = data.values",
          "309:             } else {",
          "311:                 var values = data.values",
          "313:                 if let valuesInBracket = data.children[\"\"] {",
          "315:                 }",
          "325:                 }",
          "326:             }",
          "327:         }",
          "329:         func decodeNil() throws -> Bool {",
          "331:         }",
          "334:             defer { self.currentIndex += 1 }",
          "335:             if self.allChildKeysAreNumbers {",
          "336:                 let childData = self.data.children[String(self.currentIndex)]!",
          "339:                 let decoder = _Decoder(",
          "340:                     data: childData,",
          "341:                     codingPath: self.codingPath + [BasicCodingKey.index(self.currentIndex)],",
          "342:                     configuration: self.configuration",
          "343:                 )",
          "344:                 return try T(from: decoder)",
          "345:             } else {",
          "346:                 let value = self.values[self.currentIndex]",
          "356:                         throw DecodingError.typeMismatch(T.self, at: self.codingPath + [BasicCodingKey.index(self.currentIndex)])",
          "357:                     }",
          "358:                 } else {",
          "362:                 }",
          "363:             }",
          "364:         }",
          "367:             throw DecodingError.typeMismatch([String: Decodable].self, at: self.codingPath + [BasicCodingKey.index(self.currentIndex)])",
          "368:         }",
          "",
          "[Removed Lines]",
          "305:             self.allChildKeysAreNumbers = data.children.count > 0 && data.allChildKeysAreSequentialIntegers",
          "307:             if allChildKeysAreNumbers {",
          "314:                     values = values + valuesInBracket.values",
          "318:                 self.values = try values.flatMap { value in",
          "319:                     try value.asUrlEncoded()",
          "320:                         .split(omittingEmptySubsequences: false,",
          "321:                                whereSeparator: configuration.arraySeparators.contains)",
          "322:                         .map { (ss: Substring) in",
          "323:                             URLQueryFragment.urlEncoded(String(ss))",
          "324:                         }",
          "330:             return false",
          "333:         mutating func decode<T>(_ type: T.Type) throws -> T where T: Decodable {",
          "348:                 guard !(T.self is Date.Type) else {",
          "349:                     return try self.configuration.decodeDate(from: value, codingPath: self.codingPath, forKey: BasicCodingKey.index(self.currentIndex)) as! T",
          "350:                 }",
          "352:                 if let convertible = T.self as? URLQueryFragmentConvertible.Type {",
          "353:                     if let result = convertible.init(urlQueryFragmentValue: value) {",
          "354:                         return result as! T",
          "355:                     } else {",
          "360:                     let decoder = _Decoder(data: URLEncodedFormData(values: [value]), codingPath: self.codingPath + [BasicCodingKey.index(self.currentIndex)], configuration: self.configuration)",
          "361:                     return try T(from: decoder)",
          "366:         mutating func nestedContainer<NestedKey>(keyedBy type: NestedKey.Type) throws -> KeyedDecodingContainer<NestedKey> where NestedKey: CodingKey {",
          "",
          "[Added Lines]",
          "341:             self.allChildKeysAreNumbers = !data.children.isEmpty && data.allChildKeysAreSequentialIntegers",
          "343:             if self.allChildKeysAreNumbers {",
          "351:                     values += valuesInBracket.values",
          "355:                 self.values = try values.flatMap {",
          "356:                     try $0.asUrlEncoded()",
          "357:                         .split(omittingEmptySubsequences: false, whereSeparator: configuration.arraySeparators.contains)",
          "358:                         .map { .urlEncoded(.init($0)) }",
          "364:             false",
          "367:         mutating func decode<T: Decodable>(_: T.Type) throws -> T {",
          "383:                 if T.self is Date.Type {",
          "384:                     return try self.configuration.decodeDate(",
          "385:                         from: value,",
          "386:                         codingPath: self.codingPath,",
          "387:                         forKey: BasicCodingKey.index(self.currentIndex)",
          "388:                     ) as! T",
          "389:                 } else if let convertible = T.self as? URLQueryFragmentConvertible.Type {",
          "390:                     guard let result = convertible.init(urlQueryFragmentValue: value) else {",
          "393:                     return result as! T",
          "395:                     let decoder = _Decoder(",
          "396:                         data: URLEncodedFormData(values: [value]),",
          "397:                         codingPath: self.codingPath + [BasicCodingKey.index(self.currentIndex)],",
          "398:                         configuration: self.configuration",
          "399:                     )",
          "401:                     return try T.init(from: decoder)",
          "406:         mutating func nestedContainer<NestedKey: CodingKey>(keyedBy: NestedKey.Type) throws -> KeyedDecodingContainer<NestedKey> {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "374:         mutating func superDecoder() throws -> Decoder {",
          "375:             defer { self.currentIndex += 1 }",
          "376:             let data = self.allChildKeysAreNumbers ? self.data.children[self.currentIndex.description]! : .init(values: [self.values[self.currentIndex]])",
          "378:         }",
          "379:     }",
          "381:     func singleValueContainer() throws -> SingleValueDecodingContainer {",
          "383:     }",
          "385:     struct SingleValueContainer: SingleValueDecodingContainer {",
          "",
          "[Removed Lines]",
          "377:             return _Decoder(data: data, codingPath: self.codingPath + [BasicCodingKey.index(self.currentIndex)], configuration: self.configuration)",
          "382:         return SingleValueContainer(data: self.data, codingPath: self.codingPath, configuration: self.configuration)",
          "",
          "[Added Lines]",
          "419:             return _Decoder(",
          "420:                 data: data,",
          "421:                 codingPath: self.codingPath + [BasicCodingKey.index(self.currentIndex)],",
          "422:                 configuration: self.configuration",
          "423:             )",
          "428:         SingleValueContainer(data: self.data, codingPath: self.codingPath, configuration: self.configuration)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "401:             self.data.values.isEmpty",
          "402:         }",
          "407:                 return try self.configuration.decodeDate(from: self.data, codingPath: self.codingPath, forKey: nil) as! T",
          "411:                     throw DecodingError.valueNotFound(T.self, at: self.codingPath)",
          "412:                 }",
          "416:                     throw DecodingError.typeMismatch(T.self, at: self.codingPath)",
          "417:                 }",
          "418:             } else {",
          "420:                 return try T(from: decoder)",
          "421:             }",
          "422:         }",
          "",
          "[Removed Lines]",
          "404:         func decode<T>(_ type: T.Type) throws -> T where T: Decodable {",
          "406:             guard !(T.self is Date.Type) else {",
          "408:             }",
          "409:             if let convertible = T.self as? URLQueryFragmentConvertible.Type {",
          "410:               guard let value = self.data.values.last else {",
          "413:                 if let result = convertible.init(urlQueryFragmentValue: value) {",
          "414:                     return result as! T",
          "415:                 } else {",
          "419:                 let decoder = _Decoder(data: self.data, codingPath: self.codingPath, configuration: self.configuration)",
          "",
          "[Added Lines]",
          "450:         func decode<T: Decodable>(_: T.Type) throws -> T {",
          "451:             if T.self is Date.Type {",
          "453:             } else if let convertible = T.self as? URLQueryFragmentConvertible.Type {",
          "454:                 guard let value = self.data.values.last else {",
          "457:                 guard let result = convertible.init(urlQueryFragmentValue: value) else {",
          "461:                 return result as! T",
          "463:                 let decoder = _Decoder(",
          "464:                     data: self.data,",
          "465:                     codingPath: self.codingPath,",
          "466:                     configuration: self.configuration",
          "467:                 )",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "426: private extension URLEncodedFormDecoder.Configuration {",
          "427:     func decodeDate(from data: URLEncodedFormData, codingPath: [CodingKey], forKey key: CodingKey?) throws -> Date {",
          "428:         let newCodingPath = codingPath + (key.map { [$0] } ?? [])",
          "430:         case .secondsSince1970:",
          "431:             guard let value = data.values.last else {",
          "432:                 throw DecodingError.valueNotFound(Date.self, at: newCodingPath)",
          "433:             }",
          "437:                 throw DecodingError.typeMismatch(Date.self, at: newCodingPath)",
          "438:             }",
          "439:         case .iso8601:",
          "440:             let decoder = _Decoder(data: data, codingPath: newCodingPath, configuration: self)",
          "441:             let container = try decoder.singleValueContainer()",
          "446:             }",
          "447:         case .custom(let callback):",
          "448:             let decoder = _Decoder(data: data, codingPath: newCodingPath, configuration: self)",
          "449:             return try callback(decoder)",
          "450:         }",
          "451:     }",
          "",
          "[Removed Lines]",
          "429:         switch dateDecodingStrategy {",
          "434:             if let result = Date.init(urlQueryFragmentValue: value) {",
          "435:                 return result",
          "436:             } else {",
          "442:             if let date = ISO8601DateFormatter.threadSpecific.date(from: try container.decode(String.self)) {",
          "443:                 return date",
          "444:             } else {",
          "445:                 throw DecodingError.dataCorrupted(.init(codingPath: newCodingPath, debugDescription: \"Unable to decode date. Expecting ISO8601 formatted date\"))",
          "",
          "[Added Lines]",
          "479:         switch self.dateDecodingStrategy {",
          "484:             guard let result = Date(urlQueryFragmentValue: value) else {",
          "488:             return result",
          "493:             guard let date = ISO8601DateFormatter.threadSpecific.date(from: try container.decode(String.self)) else {",
          "494:                 throw DecodingError.dataCorrupted(.init(codingPath: newCodingPath, debugDescription: \"Unable to decode ISO-8601 date.\"))",
          "496:             return date",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "458: private extension DecodingError {",
          "459:     static func typeMismatch(_ type: Any.Type, at path: [CodingKey]) -> DecodingError {",
          "461:         let context = DecodingError.Context(",
          "462:             codingPath: path,",
          "463:             debugDescription: \"Data found at '\\(pathString)' was not \\(type)\"",
          "464:         )",
          "466:     }",
          "468:     static func valueNotFound(_ type: Any.Type, at path: [CodingKey]) -> DecodingError {",
          "470:         let context = DecodingError.Context(",
          "471:             codingPath: path,",
          "472:             debugDescription: \"No \\(type) was found at '\\(pathString)'\"",
          "473:         )",
          "475:     }",
          "476: }",
          "",
          "[Removed Lines]",
          "460:         let pathString = path.map { $0.stringValue }.joined(separator: \".\")",
          "465:         return Swift.DecodingError.typeMismatch(type, context)",
          "469:         let pathString = path.map { $0.stringValue }.joined(separator: \".\")",
          "474:         return Swift.DecodingError.valueNotFound(type, context)",
          "",
          "[Added Lines]",
          "511:         let pathString = path.map(\\.stringValue).joined(separator: \".\")",
          "517:         return .typeMismatch(type, context)",
          "521:         let pathString = path.map(\\.stringValue).joined(separator: \".\")",
          "527:         return .valueNotFound(type, context)",
          "",
          "---------------"
        ],
        "Sources/Vapor/URLEncodedForm/URLEncodedFormEncoder.swift||Sources/Vapor/URLEncodedForm/URLEncodedFormEncoder.swift": [
          "File: Sources/Vapor/URLEncodedForm/URLEncodedFormEncoder.swift -> Sources/Vapor/URLEncodedForm/URLEncodedFormEncoder.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:         public var arrayEncoding: ArrayEncoding",
          "45:         public var dateEncodingStrategy: DateEncodingStrategy",
          "",
          "[Removed Lines]",
          "46:         public var userInfo: [CodingUserInfoKey: Any]",
          "",
          "[Added Lines]",
          "46:         public var userInfo: [CodingUserInfoKey: Sendable]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53:         public init(",
          "54:             arrayEncoding: ArrayEncoding = .bracket,",
          "55:             dateEncodingStrategy: DateEncodingStrategy = .secondsSince1970,",
          "57:         ) {",
          "58:             self.arrayEncoding = arrayEncoding",
          "59:             self.dateEncodingStrategy = dateEncodingStrategy",
          "",
          "[Removed Lines]",
          "56:             userInfo: [CodingUserInfoKey: Any] = [:]",
          "",
          "[Added Lines]",
          "56:             userInfo: [CodingUserInfoKey: Sendable] = [:]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "81:     }",
          "85:         where E: Encodable",
          "86:     {",
          "87:         headers.contentType = .urlEncodedForm",
          "",
          "[Removed Lines]",
          "84:     public func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders, userInfo: [CodingUserInfoKey: Any]) throws",
          "",
          "[Added Lines]",
          "84:     public func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders, userInfo: [CodingUserInfoKey: Sendable]) throws",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "96:     }",
          "100:         where E: Encodable",
          "101:     {",
          "102:         url.query = try self.encode(encodable, userInfo: userInfo)",
          "",
          "[Removed Lines]",
          "99:     public func encode<E>(_ encodable: E, to url: inout URI, userInfo: [CodingUserInfoKey: Any]) throws",
          "",
          "[Added Lines]",
          "99:     public func encode<E>(_ encodable: E, to url: inout URI, userInfo: [CodingUserInfoKey: Sendable]) throws",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "117:         where E: Encodable",
          "118:     {",
          "119:         var configuration = self.configuration  // Changing a coder's userInfo is a thread-unsafe mutation, operate on a copy",
          "",
          "[Removed Lines]",
          "116:     public func encode<E>(_ encodable: E, userInfo: [CodingUserInfoKey: Any] = [:]) throws -> String",
          "",
          "[Added Lines]",
          "116:     public func encode<E>(_ encodable: E, userInfo: [CodingUserInfoKey: Sendable] = [:]) throws -> String",
          "",
          "---------------"
        ],
        "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift": [
          "File: Sources/Vapor/Utilities/URI.swift -> Sources/Vapor/Utilities/URI.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:     private var components: URLComponents?",
          "35:     public init(string: String = \"/\") {",
          "36:         self.components = URL(string: string).flatMap { .init(url: $0, resolvingAgainstBaseURL: true) }",
          "37:     }",
          "43:     public init(",
          "44:         scheme: String?,",
          "45:         userinfo: String?,",
          "",
          "[Removed Lines]",
          "32: public struct URI: Sendable, ExpressibleByStringInterpolation, CustomStringConvertible {",
          "39:     public var description: String {",
          "40:         self.string",
          "41:     }",
          "",
          "[Added Lines]",
          "34: public struct URI: CustomStringConvertible, ExpressibleByStringInterpolation, Hashable, Codable, Sendable {",
          "37:     public init(from decoder: any Decoder) throws {",
          "38:         let container = try decoder.singleValueContainer()",
          "39:         let string = try container.decode(String.self)",
          "41:         self.init(string: string)",
          "42:     }",
          "44:     public func encode(to encoder: any Encoder) throws {",
          "45:         var container = encoder.singleValueContainer()",
          "46:         try container.encode(self.string)",
          "47:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "93:         if scheme.value == nil, userinfo == nil, host == nil, port == nil, query == nil, fragment == nil {",
          "96:         } else {",
          "",
          "[Removed Lines]",
          "95:             components = URL(string: path).flatMap { .init(url: $0, resolvingAgainstBaseURL: true) }",
          "",
          "[Added Lines]",
          "109:             components = URL(string: \"/\\(path.drop(while: { $0 == \"/\" }))\").flatMap { .init(url: $0, resolvingAgainstBaseURL: true) }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "131:         self.components = components",
          "132:     }",
          "138:     public var scheme: String? {",
          "139:         get { self.components?.scheme }",
          "140:         set { self.components?.scheme = newValue }",
          "141:     }",
          "143:     public var userinfo: String? {",
          "145:         set {",
          "146:             if let userinfoData = newValue?.split(separator: \":\", maxSplits: 1, omittingEmptySubsequences: false) {",
          "149:             } else {",
          "151:             }",
          "152:         }",
          "153:     }",
          "155:     public var host: String? {",
          "158:     }",
          "160:     public var port: Int? {",
          "",
          "[Removed Lines]",
          "134:     public init(stringLiteral value: String) {",
          "135:         self.init(string: value)",
          "136:     }",
          "144:         get { self.components?.user.map { \"\\($0)\\(self.components?.password.map { \":\\($0)\" } ?? \"\")\" } }",
          "147:                 self.components?.user = .init(userinfoData[0])",
          "148:                 self.components?.password = userinfoData.count > 1 ? .init(userinfoData[1]) : nil",
          "150:                 self.components?.user = nil",
          "156:         get { self.components?.host }",
          "157:         set { self.components?.host = newValue }",
          "",
          "[Added Lines]",
          "154:         get { self.components?.percentEncodedUser.map { \"\\($0)\\(self.components?.percentEncodedPassword.map { \":\\($0)\" } ?? \"\")\" } }",
          "157:                 self.components?.percentEncodedUser = .init(userinfoData[0])",
          "158:                 self.components?.percentEncodedPassword = userinfoData.count > 1 ? .init(userinfoData[1]) : nil",
          "160:                 self.components?.percentEncodedUser = nil",
          "166:         get { self.components?.percentEncodedHost }",
          "167:         set { self.components?.percentEncodedHost = newValue }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "163:     }",
          "165:     public var path: String {",
          "168:     }",
          "170:     public var query: String? {",
          "173:     }",
          "175:     public var fragment: String? {",
          "178:     }",
          "180:     public var string: String {",
          "",
          "[Removed Lines]",
          "166:         get { self.components?.path ?? \"/\" }",
          "167:         set { self.components?.path = newValue }",
          "171:         get { self.components?.query }",
          "172:         set { self.components?.query = newValue }",
          "176:         get { self.components?.fragment }",
          "177:         set { self.components?.fragment = newValue }",
          "",
          "[Added Lines]",
          "176:         get { self.components?.percentEncodedPath.replacingOccurrences(of: \"%3B\", with: \";\", options: .literal) ?? \"/\" }",
          "177:         set { self.components?.percentEncodedPath = newValue.withAllowedUrlDelimitersEncoded }",
          "181:         get { self.components?.percentEncodedQuery }",
          "182:         set { self.components?.percentEncodedQuery = newValue?.withAllowedUrlDelimitersEncoded }",
          "186:         get { self.components?.percentEncodedFragment }",
          "187:         set { self.components?.percentEncodedFragment = newValue?.withAllowedUrlDelimitersEncoded }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "186:         #endif",
          "187:     }",
          "189: }",
          "191: extension URI {",
          "198:         public let value: String?",
          "",
          "[Removed Lines]",
          "196:     public struct Scheme {",
          "",
          "[Added Lines]",
          "200:     public init(stringLiteral value: String) {",
          "201:         self.init(string: value)",
          "202:     }",
          "205:     public var description: String {",
          "206:         self.string",
          "207:     }",
          "217:     public struct Scheme: CustomStringConvertible, ExpressibleByStringInterpolation, Hashable, Codable, Sendable {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "250:         public static let httpsUnixDomainSocket: Self = \"https+unix\"",
          "253:     }",
          "254: }",
          "264: }",
          "268: extension CharacterSet {",
          "",
          "[Removed Lines]",
          "256: extension URI.Scheme: ExpressibleByStringInterpolation {",
          "258:     public init(stringLiteral value: String) { self.init(value) }",
          "259: }",
          "261: extension URI.Scheme: CustomStringConvertible {",
          "263:     public var description: String { self.value ?? \"\" }",
          "266: extension URI.Scheme: Sendable {}",
          "",
          "[Added Lines]",
          "276:         public init(stringLiteral value: String) { self.init(value) }",
          "279:         public var description: String { self.value ?? \"\" }",
          "285: extension StringProtocol {",
          "301:     fileprivate var withAllowedUrlDelimitersEncoded: String {",
          "302:         self.replacingOccurrences(of: \"[\", with: \"%5B\", options: .literal)",
          "303:             .replacingOccurrences(of: \"]\", with: \"%5D\", options: .literal)",
          "304:     }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "272:     fileprivate static var urlSchemeAllowed: Self {",
          "276:     }",
          "",
          "[Removed Lines]",
          "275:         Self.urlHostAllowed.intersection(Self.alphanumerics.union(.init(charactersIn: \"+-.\")))",
          "",
          "[Added Lines]",
          "314:         .urlHostAllowed.intersection(.alphanumerics.union(.init(charactersIn: \"+-.\")))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "284:     fileprivate static var urlCorrectPathAllowed: Self {",
          "288:         .urlPathAllowed.union(.init(charactersIn: \";\"))",
          "290:     }",
          "291: }",
          "",
          "[Removed Lines]",
          "285:         #if canImport(Darwin)",
          "286:         .urlPathAllowed",
          "287:         #else",
          "289:         #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Tests/AsyncTests/AsyncCommandsTests.swift||Tests/AsyncTests/AsyncCommandsTests.swift": [
          "File: Tests/AsyncTests/AsyncCommandsTests.swift -> Tests/AsyncTests/AsyncCommandsTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: import Vapor",
          "4: final class AsyncCommandsTests: XCTestCase {",
          "6:         let app = Application(.testing)",
          "7:         defer { app.shutdown() }",
          "",
          "[Removed Lines]",
          "5:     func testAsyncCommands() throws {",
          "",
          "[Added Lines]",
          "5:     func testAsyncCommands() async throws {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "11:         app.environment.arguments = [\"vapor\", \"foo\", \"bar\"]",
          "15:         XCTAssertTrue(app.storage[TestStorageKey.self] ?? false)",
          "16:     }",
          "",
          "[Removed Lines]",
          "13:         XCTAssertNoThrow(try app.start())",
          "",
          "[Added Lines]",
          "13:         try await app.startup()",
          "",
          "---------------"
        ],
        "Tests/AsyncTests/AsyncRequestTests.swift||Tests/AsyncTests/AsyncRequestTests.swift": [
          "File: Tests/AsyncTests/AsyncRequestTests.swift -> Tests/AsyncTests/AsyncRequestTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "46:         }",
          "48:         app.environment.arguments = [\"serve\"]",
          "51:         XCTAssertNotNil(app.http.server.shared.localAddress)",
          "52:         guard let localAddress = app.http.server.shared.localAddress,",
          "",
          "[Removed Lines]",
          "49:         XCTAssertNoThrow(try app.start())",
          "",
          "[Added Lines]",
          "49:         try await app.startup()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:         }",
          "81:         app.environment.arguments = [\"serve\"]",
          "84:         XCTAssertNotNil(app.http.server.shared.localAddress)",
          "85:         guard let localAddress = app.http.server.shared.localAddress,",
          "",
          "[Removed Lines]",
          "82:         XCTAssertNoThrow(try app.start())",
          "",
          "[Added Lines]",
          "82:         try await app.startup()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "94:         var request = HTTPClientRequest(url: \"http://\\(ip):\\(port)/hello\")",
          "95:         request.method = .POST",
          "96:         request.body = .stream(oneMB.async, length: .known(oneMB.count))",
          "101:     }",
          "",
          "[Removed Lines]",
          "97:         let response = try await app.http.client.shared.execute(request, timeout: .seconds(5))",
          "99:         XCTAssertGreaterThan(bytesTheServerRead.load(ordering: .relaxed), 0)",
          "100:         XCTAssertEqual(response.status, .internalServerError)",
          "",
          "[Added Lines]",
          "97:         if let response = try? await app.http.client.shared.execute(request, timeout: .seconds(5)) {",
          "98:             XCTAssertGreaterThan(bytesTheServerRead.load(ordering: .relaxed), 0)",
          "99:             XCTAssertEqual(response.status, .internalServerError)",
          "100:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "140:         }",
          "142:         app.environment.arguments = [\"serve\"]",
          "145:         XCTAssertNotNil(app.http.server.shared.localAddress)",
          "146:         guard let localAddress = app.http.server.shared.localAddress,",
          "",
          "[Removed Lines]",
          "143:         XCTAssertNoThrow(try app.start())",
          "",
          "[Added Lines]",
          "143:         try await app.startup()",
          "",
          "---------------"
        ],
        "Tests/VaporTests/ClientTests.swift||Tests/VaporTests/ClientTests.swift": [
          "File: Tests/VaporTests/ClientTests.swift -> Tests/VaporTests/ClientTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "156:         defer { app.shutdown() }",
          "157:         try app.boot()",
          "161:             XCTAssertTrue(type(of: $0) == HTTPClientError.self, \"\\(type(of: $0)) is not a \\(HTTPClientError.self)\")",
          "162:             XCTAssertEqual($0 as? HTTPClientError, .deadlineExceeded)",
          "163:         }",
          "",
          "[Removed Lines]",
          "159:         XCTAssertNoThrow(try app.client.get(\"http://localhost:\\(remoteAppPort!)/json\") { $0.timeout = .seconds(2) }.wait())",
          "160:         XCTAssertThrowsError(try app.client.get(\"http://localhost:\\(remoteAppPort!)/stalling\") { $0.timeout = .seconds(2) }.wait()) {",
          "",
          "[Added Lines]",
          "159:         XCTAssertNoThrow(try app.client.get(\"http://localhost:\\(remoteAppPort!)/json\") { $0.timeout = .seconds(1) }.wait())",
          "160:         XCTAssertThrowsError(try app.client.get(\"http://localhost:\\(remoteAppPort!)/stalling\") { $0.timeout = .seconds(1) }.wait()) {",
          "",
          "---------------"
        ],
        "Tests/VaporTests/ContentTests.swift||Tests/VaporTests/ContentTests.swift": [
          "File: Tests/VaporTests/ContentTests.swift -> Tests/VaporTests/ContentTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:         let request = Request(",
          "56:             application: app,",
          "57:             collectedBody: .init(string: complexJSON),",
          "59:         )",
          "60:         request.headers.contentType = .json",
          "61:         try XCTAssertEqual(request.content.get(at: \"batters\", \"batter\", 1, \"type\"), \"Chocolate\")",
          "",
          "[Removed Lines]",
          "58:             on: app.eventLoopGroup.next()",
          "",
          "[Added Lines]",
          "58:             on: app.eventLoopGroup.any()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "500:         let request = Request(",
          "501:             application: app,",
          "502:             collectedBody: .init(string:\"\"),",
          "504:         )",
          "505:         request.url.query = \"name=before+decode\"",
          "506:         request.headers.contentType = .json",
          "",
          "[Removed Lines]",
          "503:             on: EmbeddedEventLoop()",
          "",
          "[Added Lines]",
          "503:             on: app.eventLoopGroup.any()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "511:         XCTAssertEqual(request.url.query, \"name=new%20name\")",
          "512:     }",
          "514:     func testSnakeCaseCodingKeyError() throws {",
          "515:         let app = Application()",
          "516:         defer { app.shutdown() }",
          "519:         try req.content.encode([",
          "520:             \"title\": \"The title\"",
          "521:         ], as: .json)",
          "",
          "[Removed Lines]",
          "518:         let req = Request(application: app, on: app.eventLoopGroup.next())",
          "",
          "[Added Lines]",
          "515:     func testDecodePercentEncodedQuery() throws {",
          "516:         let app = Application()",
          "517:         defer { app.shutdown() }",
          "519:         let request = Request(",
          "520:             application: app,",
          "521:             collectedBody: .init(string: \"\"),",
          "522:             on: app.eventLoopGroup.any()",
          "523:         )",
          "524:         request.url = .init(string: \"/?name=value%20has%201%25%20of%20its%20percents\")",
          "525:         request.headers.contentType = .urlEncodedForm",
          "527:         XCTAssertEqual(try request.query.get(String.self, at: \"name\"), \"value has 1% of its percents\")",
          "528:     }",
          "531:     func testEncodePercentEncodedQuery() throws {",
          "532:         let app = Application()",
          "533:         defer { app.shutdown() }",
          "535:         struct Foo: Content {",
          "536:             var status: String",
          "537:         }",
          "539:         var request = ClientRequest(url: .init(scheme: \"https\", host: \"example.com\", path: \"/api\"))",
          "540:         try request.query.encode(Foo(status:",
          "541:             \"\u2b06\ufe0f taylorswift just released swift-mongodb v0.10.1 \u2013 use BSON and MongoDB in pure Swift\\n\\nhttps://swiftpackageindex.com/tayloraswift/swift-mongodb#releases\"",
          "542:         ))",
          "544:         XCTAssertEqual(request.url.string, \"https://example.com/api?status=%E2%AC%86%EF%B8%8F%20taylorswift%20just%20released%20swift-mongodb%20v0.10.1%20%E2%80%93%20use%20BSON%20and%20MongoDB%20in%20pure%20Swift%0A%0Ahttps://swiftpackageindex.com/tayloraswift/swift-mongodb%23releases\")",
          "545:     }",
          "551:         let req = Request(application: app, on: app.eventLoopGroup.any())",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "546:             url: URI(string: \"https://vapor.codes\"),",
          "547:             headersNoUpdate: [\"Content-Type\": \"application/json\"],",
          "548:             collectedBody: ByteBuffer(string: #\"{\"badJson: \"Key doesn't have a trailing quote\"}\"#),",
          "550:         )",
          "552:         struct DecodeModel: Content {",
          "",
          "[Removed Lines]",
          "549:             on: app.eventLoopGroup.next()",
          "",
          "[Added Lines]",
          "582:             on: app.eventLoopGroup.any()",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "564:         let app = Application()",
          "565:         defer { app.shutdown() }",
          "568:         try req.content.encode([",
          "569:             \"items\": [\"1\"]",
          "570:         ], as: .json)",
          "",
          "[Removed Lines]",
          "567:         let req = Request(application: app, on: app.eventLoopGroup.next())",
          "",
          "[Added Lines]",
          "600:         let req = Request(application: app, on: app.eventLoopGroup.any())",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "593:         let app = Application()",
          "594:         defer { app.shutdown() }",
          "597:         try req.content.encode([",
          "598:             \"item\": [",
          "599:                 \"title\": \"The title\"",
          "",
          "[Removed Lines]",
          "596:         let req = Request(application: app, on: app.eventLoopGroup.next())",
          "",
          "[Added Lines]",
          "629:         let req = Request(application: app, on: app.eventLoopGroup.any())",
          "",
          "---------------"
        ],
        "Tests/VaporTests/RouteTests.swift||Tests/VaporTests/RouteTests.swift": [
          "File: Tests/VaporTests/RouteTests.swift -> Tests/VaporTests/RouteTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "429:             XCTAssertEqual(res.status.code, 500)",
          "430:         }",
          "431:     }",
          "432: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "434:     func testDoubleSlashRouteAccess() throws {",
          "435:         let app = Application(.testing)",
          "436:         defer { app.shutdown() }",
          "438:         app.get(\"foo\", \"bar\", \"buz\") { req -> String in",
          "439:             try req.query.get(at: \"v\")",
          "440:         }",
          "442:         try app.testable().test(.GET, \"/foo/bar/buz?v=M%26M\") { res in",
          "443:             XCTAssertEqual(res.status, .ok)",
          "444:             XCTAssertEqual(res.body.string, #\"M&M\"#)",
          "445:         }.test(.GET, \"//foo/bar/buz?v=M%26M\") { res in",
          "446:             XCTAssertEqual(res.status, .ok)",
          "447:             XCTAssertEqual(res.body.string, #\"M&M\"#)",
          "448:         }",
          "449:     }",
          "",
          "---------------"
        ],
        "Tests/VaporTests/ServerTests.swift||Tests/VaporTests/ServerTests.swift": [
          "File: Tests/VaporTests/ServerTests.swift -> Tests/VaporTests/ServerTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:         let app = Application(env)",
          "43:         defer { app.shutdown() }",
          "48:         try app.start()",
          "51:         XCTAssertEqual(res.body?.string, \"bar\")",
          "55:     }",
          "57:     func testIncompatibleStartupOptions() throws {",
          "",
          "[Removed Lines]",
          "45:         app.get(\"foo\") { req in",
          "46:             return \"bar\"",
          "47:         }",
          "50:         let res = try app.client.get(.init(scheme: .httpUnixDomainSocket, host: socketPath, path: \"/foo\")).wait()",
          "54:         XCTAssertThrowsError(try app.client.get(\"http://127.0.0.1:8080/foo\").wait())",
          "",
          "[Added Lines]",
          "45:         app.get(\"foo\") { _ in \"bar\" }",
          "48:         let res = try app.client.get(.init(scheme: .httpUnixDomainSocket, host: socketPath, path: \"/foo\")) { $0.timeout = .milliseconds(500) }.wait()",
          "52:         XCTAssertThrowsError(try app.client.get(\"http://127.0.0.1:8080/foo\") { $0.timeout = .milliseconds(500) }.wait())",
          "",
          "---------------"
        ],
        "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift": [
          "File: Tests/VaporTests/URITests.swift -> Tests/VaporTests/URITests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: import NIOCore",
          "5: import Algorithms",
          "30: @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)",
          "31: func XCTAssertURIComponents(",
          "32:        scheme: @autoclosure () throws -> URI.Scheme?,",
          "",
          "[Removed Lines]",
          "7: @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)",
          "8: extension RangeReplaceableCollection where Self.SubSequence == Substring, Self: StringProtocol {",
          "9:     #if compiler(>=5.9)",
          "10:     #if hasFeature(BareSlashRegexLiterals)",
          "11:     private static var percentEncodingPattern: Regex<Substring> { /(?:%\\p{AHex}{2})+/ }",
          "12:     #else",
          "13:     private static var percentEncodingPattern: Regex<Substring> { try! Regex(\"(?:%\\\\p{AHex}{2})+\") }",
          "14:     #endif",
          "15:     #else",
          "16:     private static var percentEncodingPattern: Regex<Substring> { try! Regex(\"(?:%\\\\p{AHex}{2})+\") }",
          "17:     #endif",
          "22:     var safelyUrlDecoded: Self {",
          "23:         self.replacing(",
          "24:             Self.percentEncodingPattern,",
          "25:             with: { Self(decoding: $0.0.split(separator: \"%\").map { .init($0, radix: 16)! }, as: UTF8.self) }",
          "26:         )",
          "27:     }",
          "28: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65:     _ message: @autoclosure () -> String = \"\", file: StaticString = #filePath, line: UInt = #line",
          "66: ) {",
          "67:     do {",
          "69:             path = try path(), query = try query(), fragment = try fragment()",
          "83:     } catch {",
          "85:     }",
          "86: }",
          "",
          "[Removed Lines]",
          "68:         let scheme = try scheme(), userinfo = try userinfo(), host = try host(), port = try port(),",
          "70:         let uri = URI(scheme: scheme, userinfo: userinfo, host: host, port: port, path: path, query: query, fragment: fragment)",
          "73:         XCTAssertEqual(uri.scheme,   scheme?.safelyUrlDecoded,   \"(scheme) \\(message())\", file: file, line: line)",
          "74:         XCTAssertEqual(uri.userinfo, userinfo?.safelyUrlDecoded, \"(userinfo) \\(message())\", file: file, line: line)",
          "75:         XCTAssertEqual(uri.host,     host?.safelyUrlDecoded,     \"(host) \\(message())\", file: file, line: line)",
          "76:         XCTAssertEqual(uri.port,     port,                       \"(port) \\(message())\", file: file, line: line)",
          "77:         XCTAssertEqual(uri.path,     \"/\\(path.safelyUrlDecoded.trimmingPrefix(\"/\"))\", \"(path) \\(message())\", file: file, line: line)",
          "78:         XCTAssertEqual(uri.query,    query?.safelyUrlDecoded,    \"(query) \\(message())\", file: file, line: line)",
          "79:         XCTAssertEqual(uri.fragment, fragment?.safelyUrlDecoded, \"(fragment) \\(message())\", file: file, line: line)",
          "82:         XCTAssertEqual(uri.string,   try expected(),             \"(string) \\(message())\", file: file, line: line)",
          "84:         XCTAssertEqual(try { throw error }(), false,             message(), file: file, line: line)",
          "",
          "[Added Lines]",
          "45:         let scheme = try scheme(), rawuserinfo = try userinfo(), host = try host(), port = try port(),",
          "47:         let uri = URI(scheme: scheme, userinfo: rawuserinfo, host: host, port: port, path: path, query: query, fragment: fragment)",
          "49:         let userinfo = rawuserinfo.map {",
          "50:             !$0.contains(\":\") ? $0 :",
          "51:                 $0.split(separator: \":\", maxSplits: 1, omittingEmptySubsequences: false).enumerated()",
          "52:                   .map { $1.addingPercentEncoding(withAllowedCharacters: $0 == 0 ? .urlUserAllowed : .urlPasswordAllowed)! }",
          "53:                   .joined(separator: \":\")",
          "54:         }",
          "57:         XCTAssertEqual(uri.scheme,   scheme,   \"(scheme) \\(message())\", file: file, line: line)",
          "58:         XCTAssertEqual(uri.userinfo, userinfo, \"(userinfo) \\(message())\", file: file, line: line)",
          "59:         XCTAssertEqual(uri.host,     host?.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed),     \"(host) \\(message())\", file: file, line: line)",
          "60:         XCTAssertEqual(uri.port,     port,     \"(port) \\(message())\", file: file, line: line)",
          "61:         XCTAssertEqual(uri.path,     path.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed),     \"(path) \\(message())\", file: file, line: line)",
          "62:         XCTAssertEqual(uri.query,    query?.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed),    \"(query) \\(message())\", file: file, line: line)",
          "63:         XCTAssertEqual(uri.fragment, fragment?.addingPercentEncoding(withAllowedCharacters: .urlFragmentAllowed), \"(fragment) \\(message())\", file: file, line: line)",
          "66:         XCTAssertEqual(uri.string,   try expected(), \"(string) \\(message())\", file: file, line: line)",
          "68:         XCTAssertEqual(try { throw error }(), false, message(), file: file, line: line)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "103:         let uri = URI(string: string)",
          "115:         if try exact() {",
          "117:         }",
          "118:     } catch {",
          "120:     }",
          "121: }",
          "",
          "[Removed Lines]",
          "106:         XCTAssertEqual(uri.scheme,   try scheme()?.safelyUrlDecoded,   \"(scheme) \\(message())\", file: file, line: line)",
          "107:         XCTAssertEqual(uri.userinfo, try userinfo()?.safelyUrlDecoded, \"(userinfo) \\(message())\", file: file, line: line)",
          "108:         XCTAssertEqual(uri.host,     try host()?.safelyUrlDecoded,     \"(host) \\(message())\", file: file, line: line)",
          "109:         XCTAssertEqual(uri.port,     try port(),                       \"(port) \\(message())\", file: file, line: line)",
          "110:         XCTAssertEqual(uri.path,     try path().safelyUrlDecoded,      \"(path) \\(message())\", file: file, line: line)",
          "111:         XCTAssertEqual(uri.query,    try query()?.safelyUrlDecoded,    \"(query) \\(message())\", file: file, line: line)",
          "112:         XCTAssertEqual(uri.fragment, try fragment()?.safelyUrlDecoded, \"(fragment) \\(message())\", file: file, line: line)",
          "116:             XCTAssertEqual(uri.string,   string,                       \"(string) \\(message())\", file: file, line: line)",
          "119:         XCTAssertEqual(try { throw error }(), false,                   message(), file: file, line: line)",
          "",
          "[Added Lines]",
          "90:         XCTAssertEqual(uri.scheme,   try scheme(),   \"(scheme) \\(message())\", file: file, line: line)",
          "91:         XCTAssertEqual(uri.userinfo, try userinfo(), \"(userinfo) \\(message())\", file: file, line: line)",
          "92:         XCTAssertEqual(uri.host,     try host(),     \"(host) \\(message())\", file: file, line: line)",
          "93:         XCTAssertEqual(uri.port,     try port(),     \"(port) \\(message())\", file: file, line: line)",
          "94:         XCTAssertEqual(uri.path,     try path(),     \"(path) \\(message())\", file: file, line: line)",
          "95:         XCTAssertEqual(uri.query,    try query(),    \"(query) \\(message())\", file: file, line: line)",
          "96:         XCTAssertEqual(uri.fragment, try fragment(), \"(fragment) \\(message())\", file: file, line: line)",
          "100:             XCTAssertEqual(uri.string,   string,     \"(string) \\(message())\", file: file, line: line)",
          "103:         XCTAssertEqual(try { throw error }(), false, message(), file: file, line: line)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "192:         XCTAssertURIComponents(",
          "194:             generate: \"//host:1/test?query#fragment\"",
          "195:         )",
          "196:         XCTAssertURIComponents(",
          "198:             generate: \"http+unix://%2Fpath/test\"",
          "199:         )",
          "200:         XCTAssertURIComponents(",
          "202:             generate: \"http+unix://%2Fpath/test#fragment\"",
          "203:         )",
          "204:         XCTAssertURIComponents(",
          "206:             generate: \"http+unix://%2Fpath/test?query#fragment\"",
          "207:         )",
          "208:     }",
          "",
          "[Removed Lines]",
          "193:             host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\",",
          "197:             scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\",",
          "201:             scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\", fragment: \"fragment\",",
          "205:             scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\", query: \"query\", fragment: \"fragment\",",
          "",
          "[Added Lines]",
          "177:             host: \"host\", port: 1, path: \"/test\", query: \"query\", fragment: \"fragment\",",
          "181:             scheme: .httpUnixDomainSocket, host: \"/path\", path: \"/test\",",
          "185:             scheme: .httpUnixDomainSocket, host: \"/path\", path: \"/test\", fragment: \"fragment\",",
          "189:             scheme: .httpUnixDomainSocket, host: \"/path\", path: \"/test\", query: \"query\", fragment: \"fragment\",",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "216:         let zeros = String(repeating: \"0\", count: 65_512)",
          "217:         let untrustedInput = \"[https://vapor.codes.somewhere-else.test:](https://vapor.codes.somewhere-else.test/\\(zeros)443)[\\(zeros)](https://vapor.codes.somewhere-else.test/\\(zeros)443)[443](https://vapor.codes.somewhere-else.test/\\(zeros)443)\"",
          "219:         if #available(macOS 14, iOS 17, watchOS 10, tvOS 17, *) {",
          "221:         } else {",
          "223:         }",
          "224:     }",
          "",
          "[Removed Lines]",
          "220:             XCTAssertURIString(untrustedInput, hasHost: nil, hasPath: untrustedInput, hasEqualString: false)",
          "222:             XCTAssertURIString(untrustedInput, hasHost: nil, hasPath: \"/\", hasEqualString: false)",
          "",
          "[Added Lines]",
          "203:         let readableInAssertionOutput = untrustedInput",
          "204:             .replacingOccurrences(of: zeros, with: \"00...00\")",
          "205:             .addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!",
          "206:         let uri = URI(string: untrustedInput)",
          "208:         XCTAssertNil(uri.scheme)",
          "209:         XCTAssertNil(uri.userinfo)",
          "210:         XCTAssertNil(uri.host)",
          "211:         XCTAssertNil(uri.port)",
          "212:         XCTAssertNil(uri.query)",
          "213:         XCTAssertNil(uri.fragment)",
          "216:             XCTAssertEqual(",
          "217:                 uri.path.replacingOccurrences(of: zeros, with: \"00...00\").replacing(\"%3A\", with: \":\", maxReplacements: 1),",
          "218:                 readableInAssertionOutput.replacing(\"%3A\", with: \":\", maxReplacements: 1)",
          "219:             )",
          "221:             XCTAssertEqual(uri.path, \"/\")",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "289:             hasScheme: \"scheme\", hasUserinfo: \"user:pass\", hasHost: \"host\", hasPort: 1, hasPath: \"/path/path2/file.html;params\",",
          "290:             hasQuery: \"query\", hasFragment: \"fragment\", hasEqualString: false",
          "291:         )",
          "297:         XCTAssertURIString(\"file:///?\", hasScheme: \"file\", hasPath: \"/\", hasQuery: \"\")",
          "298:         XCTAssertURIString(\"file:///&\", hasScheme: \"file\", hasPath: \"/&\")",
          "299:         XCTAssertURIString(\"file:///x\", hasScheme: \"file\", hasPath: \"/x\")",
          "302:         XCTAssertURIString(\"http:///?\", hasScheme: \"http\", hasPath: \"/\", hasQuery: \"\")",
          "303:         XCTAssertURIString(\"http:///&\", hasScheme: \"http\", hasPath: \"/&\")",
          "304:         XCTAssertURIString(\"http:///x\", hasScheme: \"http\", hasPath: \"/x\")",
          "307:         XCTAssertURIString(\"glorb:///?\", hasScheme: \"glorb\", hasPath: \"/\", hasQuery: \"\")",
          "308:         XCTAssertURIString(\"glorb:///&\", hasScheme: \"glorb\", hasPath: \"/&\")",
          "309:         XCTAssertURIString(\"glorb:///x\", hasScheme: \"glorb\", hasPath: \"/x\")",
          "310:         XCTAssertURIString(\"uahsfcncvuhrtgvnahr\", hasHost: nil, hasPath: \"uahsfcncvuhrtgvnahr\")",
          "311:         XCTAssertURIString(\"http://[fe80::20a:27ff:feae:8b9e]/\", hasScheme: \"http\", hasHost: \"[fe80::20a:27ff:feae:8b9e]\", hasPath: \"/\")",
          "313:         XCTAssertURIString(\"http://host.com/foo/bar/../index.html\", hasScheme: \"http\", hasHost: \"host.com\", hasPath: \"/foo/bar/../index.html\")",
          "314:         XCTAssertURIString(\"http://host.com/foo/bar/./index.html\", hasScheme: \"http\", hasHost: \"host.com\", hasPath: \"/foo/bar/./index.html\")",
          "315:         XCTAssertURIString(\"http:/cgi-bin/Count.cgi?ft=0\", hasScheme: \"http\", hasHost: nil, hasPath: \"/cgi-bin/Count.cgi\", hasQuery: \"ft=0\")",
          "",
          "[Removed Lines]",
          "292:         XCTAssertURIString(\"http://test.com/a%20space\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/a space\")",
          "293:         XCTAssertURIString(\"http://test.com/aBrace%7B\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/aBrace{\")",
          "294:         XCTAssertURIString(\"http://test.com/aJ%4a\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/aJJ\")",
          "295:         XCTAssertURIString(\"file:///%3F\", hasScheme: \"file\", hasPath: \"/?\")",
          "296:         XCTAssertURIString(\"file:///%78\", hasScheme: \"file\", hasPath: \"/x\")",
          "300:         XCTAssertURIString(\"http:///%3F\", hasScheme: \"http\", hasPath: \"/?\")",
          "301:         XCTAssertURIString(\"http:///%78\", hasScheme: \"http\", hasPath: \"/x\")",
          "305:         XCTAssertURIString(\"glorb:///%3F\", hasScheme: \"glorb\", hasPath: \"/?\")",
          "306:         XCTAssertURIString(\"glorb:///%78\", hasScheme: \"glorb\", hasPath: \"/x\")",
          "312:         XCTAssertURIString(\"http://[fe80::20a:27ff:feae:8b9e%25en0]/\", hasScheme: \"http\", hasHost: \"[fe80::20a:27ff:feae:8b9e%en0]\", hasPath: \"/\")",
          "",
          "[Added Lines]",
          "291:         XCTAssertURIString(\"http://test.com/a%20space\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/a%20space\")",
          "292:         XCTAssertURIString(\"http://test.com/aBrace%7B\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/aBrace%7B\")",
          "293:         XCTAssertURIString(\"http://test.com/aJ%4a\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/aJ%4a\")",
          "294:         XCTAssertURIString(\"file:///%3F\", hasScheme: \"file\", hasPath: \"/%3F\")",
          "295:         XCTAssertURIString(\"file:///%78\", hasScheme: \"file\", hasPath: \"/%78\")",
          "299:         XCTAssertURIString(\"http:///%3F\", hasScheme: \"http\", hasPath: \"/%3F\")",
          "300:         XCTAssertURIString(\"http:///%78\", hasScheme: \"http\", hasPath: \"/%78\")",
          "304:         XCTAssertURIString(\"glorb:///%3F\", hasScheme: \"glorb\", hasPath: \"/%3F\")",
          "305:         XCTAssertURIString(\"glorb:///%78\", hasScheme: \"glorb\", hasPath: \"/%78\")",
          "311:         XCTAssertURIString(\"http://[fe80::20a:27ff:feae:8b9e%25en0]/\", hasScheme: \"http\", hasHost: \"[fe80::20a:27ff:feae:8b9e%25en0]\", hasPath: \"/\")",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7aa836b77626bf07e71d5f50b9ad87cbe439ed81",
      "candidate_info": {
        "commit_hash": "7aa836b77626bf07e71d5f50b9ad87cbe439ed81",
        "repo": "vapor/vapor",
        "commit_url": "https://github.com/vapor/vapor/commit/7aa836b77626bf07e71d5f50b9ad87cbe439ed81",
        "files": [
          "Package.swift",
          "Package@swift-5.9.swift",
          "Sources/Vapor/Commands/ServeCommand.swift",
          "Sources/Vapor/Content/JSONCoders+Content.swift",
          "Sources/Vapor/Content/PlaintextDecoder.swift",
          "Sources/Vapor/Content/PlaintextEncoder.swift",
          "Sources/Vapor/HTTP/Headers/HTTPHeaderCacheControl.swift",
          "Sources/Vapor/Logging/LoggingSystem+Environment.swift",
          "Sources/Vapor/Sessions/MemorySessions.swift",
          "Sources/Vapor/Utilities/RFC1123.swift",
          "Sources/Vapor/Utilities/URI.swift",
          "Sources/Vapor/Validation/Validators/CharacterSet.swift",
          "Tests/VaporTests/ClientTests.swift",
          "Tests/VaporTests/ContentTests.swift",
          "Tests/VaporTests/ServerTests.swift",
          "Tests/VaporTests/URITests.swift"
        ],
        "message": "Support Swift 6 (#3225)\n\n* Fix some test warnings\n\n* Manifest changes\n\n* Drop 5.7 support\n\n* Fix some warnings\n\n* Workaround a Sendable issue in time\n\n* Fix some preconcurrency warnings in Swift 6\n\n* Latest Swift 6 changes\n\n* Disable tests on Swift 6 until they're fixed in Foundation\n\n* Another test using the broken scheme\n\n* Last test",
        "before_after_code_files": [
          "Package.swift||Package.swift",
          "Package@swift-5.9.swift||Package@swift-5.9.swift",
          "Sources/Vapor/Commands/ServeCommand.swift||Sources/Vapor/Commands/ServeCommand.swift",
          "Sources/Vapor/Content/JSONCoders+Content.swift||Sources/Vapor/Content/JSONCoders+Content.swift",
          "Sources/Vapor/Content/PlaintextDecoder.swift||Sources/Vapor/Content/PlaintextDecoder.swift",
          "Sources/Vapor/Content/PlaintextEncoder.swift||Sources/Vapor/Content/PlaintextEncoder.swift",
          "Sources/Vapor/HTTP/Headers/HTTPHeaderCacheControl.swift||Sources/Vapor/HTTP/Headers/HTTPHeaderCacheControl.swift",
          "Sources/Vapor/Logging/LoggingSystem+Environment.swift||Sources/Vapor/Logging/LoggingSystem+Environment.swift",
          "Sources/Vapor/Sessions/MemorySessions.swift||Sources/Vapor/Sessions/MemorySessions.swift",
          "Sources/Vapor/Utilities/RFC1123.swift||Sources/Vapor/Utilities/RFC1123.swift",
          "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift",
          "Sources/Vapor/Validation/Validators/CharacterSet.swift||Sources/Vapor/Validation/Validators/CharacterSet.swift",
          "Tests/VaporTests/ClientTests.swift||Tests/VaporTests/ClientTests.swift",
          "Tests/VaporTests/ContentTests.swift||Tests/VaporTests/ContentTests.swift",
          "Tests/VaporTests/ServerTests.swift||Tests/VaporTests/ServerTests.swift",
          "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Package.swift||Package.swift",
            "Package@swift-5.9.swift||Package@swift-5.9.swift",
            "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift",
            "Tests/VaporTests/ClientTests.swift||Tests/VaporTests/ClientTests.swift",
            "Tests/VaporTests/ServerTests.swift||Tests/VaporTests/ServerTests.swift",
            "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift"
          ],
          "candidate": [
            "Package.swift||Package.swift",
            "Package@swift-5.9.swift||Package@swift-5.9.swift",
            "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift",
            "Tests/VaporTests/ClientTests.swift||Tests/VaporTests/ClientTests.swift",
            "Tests/VaporTests/ServerTests.swift||Tests/VaporTests/ServerTests.swift",
            "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift"
          ]
        }
      },
      "candidate_diff": {
        "Package.swift||Package.swift": [
          "File: Package.swift -> Package.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "49:         .package(url: \"https://github.com/apple/swift-log.git\", from: \"1.0.0\"),",
          "55:         .package(url: \"https://github.com/apple/swift-algorithms.git\", from: \"1.0.0\"),",
          "",
          "[Removed Lines]",
          "52:         .package(url: \"https://github.com/apple/swift-metrics.git\", from: \"2.0.0\"),",
          "",
          "[Added Lines]",
          "52:         .package(url: \"https://github.com/apple/swift-metrics.git\", from: \"2.5.0\"),",
          "",
          "---------------"
        ],
        "Package@swift-5.9.swift||Package@swift-5.9.swift": [
          "File: Package@swift-5.9.swift -> Package@swift-5.9.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "46:         .package(url: \"https://github.com/apple/swift-log.git\", from: \"1.0.0\"),",
          "52:         .package(url: \"https://github.com/apple/swift-algorithms.git\", from: \"1.0.0\"),",
          "",
          "[Removed Lines]",
          "49:         .package(url: \"https://github.com/apple/swift-metrics.git\", from: \"2.0.0\"),",
          "",
          "[Added Lines]",
          "49:         .package(url: \"https://github.com/apple/swift-metrics.git\", from: \"2.5.0\"),",
          "",
          "---------------"
        ],
        "Sources/Vapor/Commands/ServeCommand.swift||Sources/Vapor/Commands/ServeCommand.swift": [
          "File: Sources/Vapor/Commands/ServeCommand.swift -> Sources/Vapor/Commands/ServeCommand.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: import ConsoleKit",
          "3: import NIOConcurrencyHelpers",
          "",
          "[Removed Lines]",
          "1: @preconcurrency import Foundation",
          "",
          "[Added Lines]",
          "1: #if os(Linux)",
          "2: @preconcurrency import Dispatch",
          "3: #endif",
          "4: import Foundation",
          "",
          "---------------"
        ],
        "Sources/Vapor/Content/JSONCoders+Content.swift||Sources/Vapor/Content/JSONCoders+Content.swift": [
          "File: Sources/Vapor/Content/JSONCoders+Content.swift -> Sources/Vapor/Content/JSONCoders+Content.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: import NIOCore",
          "3: import NIOHTTP1",
          "5: extension Foundation.JSONEncoder: @unchecked Swift.Sendable {}",
          "6: extension Foundation.JSONDecoder: @unchecked Swift.Sendable {}",
          "8: extension JSONEncoder: ContentEncoder {",
          "9:     public func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders) throws",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: #if compiler(<6.0)",
          "8: #endif",
          "",
          "---------------"
        ],
        "Sources/Vapor/Content/PlaintextDecoder.swift||Sources/Vapor/Content/PlaintextDecoder.swift": [
          "File: Sources/Vapor/Content/PlaintextDecoder.swift -> Sources/Vapor/Content/PlaintextDecoder.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "73:     func decode<T>(_: T.Type) throws -> T where T : Decodable {",
          "74:         if let convertible = T.self as? LosslessStringConvertible.Type {",
          "80:             return try self.losslessDecode(convertible) as! T",
          "82:         }",
          "83:         throw DecodingError.typeMismatch(T.self, .init(codingPath: self.codingPath, debugDescription: \"Plaintext decoding does not support complex types.\"))",
          "84:     }",
          "",
          "[Removed Lines]",
          "75: #if swift(<5.7)",
          "76:             guard let value = self.plaintext else { throw DecodingError.valueNotFound(T.self, .init(codingPath: self.codingPath, debugDescription: \"Missing value of type \\(T.self)\")) }",
          "77:             guard let result = convertible.init(value) else { throw DecodingError.dataCorruptedError(in: self, debugDescription: \"Could not decode \\(T.self) from \\\"\\(value)\\\"\") }",
          "78:             return result as! T",
          "79: #else",
          "81: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Sources/Vapor/Content/PlaintextEncoder.swift||Sources/Vapor/Content/PlaintextEncoder.swift": [
          "File: Sources/Vapor/Content/PlaintextEncoder.swift -> Sources/Vapor/Content/PlaintextEncoder.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "73:     func encode<T>(_ value: T) throws where T: Encodable {",
          "74:         if let data = value as? Data {",
          "77:             let utf8Maybe = data.withUnsafeBytes({ $0.withMemoryRebound(to: CChar.self, { String(validatingUTF8: $0.baseAddress!) }) })",
          "81:             if let utf8 = utf8Maybe {",
          "82:                 self.plaintext = utf8",
          "83:             } else {",
          "",
          "[Removed Lines]",
          "76: #if swift(>=5.7.2)",
          "78: #else",
          "79:             let utf8Maybe = data.withUnsafeBytes({ String(validatingUTF8: $0.bindMemory(to: CChar.self).baseAddress!) })",
          "80: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Sources/Vapor/HTTP/Headers/HTTPHeaderCacheControl.swift||Sources/Vapor/HTTP/Headers/HTTPHeaderCacheControl.swift": [
          "File: Sources/Vapor/HTTP/Headers/HTTPHeaderCacheControl.swift -> Sources/Vapor/HTTP/Headers/HTTPHeaderCacheControl.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:             public var seconds: Int?",
          "16:         }",
          "",
          "[Removed Lines]",
          "9:     public struct CacheControl {",
          "13:         public struct MaxStale {",
          "",
          "[Added Lines]",
          "9:     public struct CacheControl: Sendable {",
          "13:         public struct MaxStale: Sendable {",
          "",
          "---------------"
        ],
        "Sources/Vapor/Logging/LoggingSystem+Environment.swift||Sources/Vapor/Logging/LoggingSystem+Environment.swift": [
          "File: Sources/Vapor/Logging/LoggingSystem+Environment.swift -> Sources/Vapor/Logging/LoggingSystem+Environment.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: import ConsoleKit",
          "4: extension LoggingSystem {",
          "6:         let level = try Logger.Level.detect(from: &environment)",
          "",
          "[Removed Lines]",
          "5:     public static func bootstrap(from environment: inout Environment, _ factory: (Logger.Level) -> (String) -> LogHandler) throws {",
          "",
          "[Added Lines]",
          "5:     @preconcurrency",
          "6:     public static func bootstrap(from environment: inout Environment, _ factory: @Sendable (Logger.Level) -> (@Sendable (String) -> LogHandler)) throws {",
          "",
          "---------------"
        ],
        "Sources/Vapor/Sessions/MemorySessions.swift||Sources/Vapor/Sessions/MemorySessions.swift": [
          "File: Sources/Vapor/Sessions/MemorySessions.swift -> Sources/Vapor/Sessions/MemorySessions.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: @preconcurrency import Foundation",
          "4: #else",
          "5: import Foundation",
          "",
          "[Removed Lines]",
          "1: #if os(Linux)",
          "",
          "[Added Lines]",
          "1: #if os(Linux) && compiler(<6.0)",
          "",
          "---------------"
        ],
        "Sources/Vapor/Utilities/RFC1123.swift||Sources/Vapor/Utilities/RFC1123.swift": [
          "File: Sources/Vapor/Utilities/RFC1123.swift -> Sources/Vapor/Utilities/RFC1123.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: #if canImport(Darwin)",
          "3: @preconcurrency import Darwin",
          "4: #elseif canImport(Glibc)",
          "5: @preconcurrency import Glibc",
          "6: #elseif canImport(Musl)",
          "7: @preconcurrency import Musl",
          "8: #elseif canImport(WinSDK)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: #if compiler(>=6.0)",
          "6: import Glibc",
          "7: #else",
          "9: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "178: ]",
          "180: private let secondsInDay = 60 * 60 * 24",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "186: #if compiler(>=6.0)",
          "187: extension tm: @retroactive @unchecked Sendable {}",
          "188: #endif",
          "",
          "---------------"
        ],
        "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift": [
          "File: Sources/Vapor/Utilities/URI.swift -> Sources/Vapor/Utilities/URI.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: @preconcurrency import struct Foundation.URLComponents",
          "3: #else",
          "4: import struct Foundation.URLComponents",
          "",
          "[Removed Lines]",
          "1: #if !canImport(Darwin)",
          "",
          "[Added Lines]",
          "1: #if !canImport(Darwin) && compiler(<6.0)",
          "",
          "---------------"
        ],
        "Sources/Vapor/Validation/Validators/CharacterSet.swift||Sources/Vapor/Validation/Validators/CharacterSet.swift": [
          "File: Sources/Vapor/Validation/Validators/CharacterSet.swift -> Sources/Vapor/Validation/Validators/CharacterSet.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: @preconcurrency import Foundation",
          "4: #else",
          "5: import Foundation",
          "",
          "[Removed Lines]",
          "1: #if os(Linux)",
          "",
          "[Added Lines]",
          "1: #if os(Linux) && compiler(<6.0)",
          "",
          "---------------"
        ],
        "Tests/VaporTests/ClientTests.swift||Tests/VaporTests/ClientTests.swift": [
          "File: Tests/VaporTests/ClientTests.swift -> Tests/VaporTests/ClientTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #if !canImport(Darwin)",
          "2: @preconcurrency import Dispatch",
          "3: #endif",
          "4: import Foundation",
          "5: import XCTest",
          "6: import Vapor",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: #if compiler(>=6.0)",
          "3: import Dispatch",
          "4: #else",
          "7: #endif",
          "",
          "---------------"
        ],
        "Tests/VaporTests/ContentTests.swift||Tests/VaporTests/ContentTests.swift": [
          "File: Tests/VaporTests/ContentTests.swift -> Tests/VaporTests/ContentTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "587:             let badJson: String",
          "588:         }",
          "589:         XCTAssertThrowsError(try req.content.decode(DecodeModel.self)) { error in",
          "590:             XCTAssertContains(",
          "591:                 (error as? AbortError)?.reason,",
          "592:                 #\"Data corrupted at path ''. The given data was not valid JSON. Underlying error: \"#",
          "593:             )",
          "594:         }",
          "595:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "590:             #if compiler(>=6.0)",
          "591:             XCTAssertContains(",
          "592:                 (error as? AbortError)?.reason,",
          "593:                 #\"Data corrupted at path ''. The given data was not valid JSON\"#",
          "594:             )",
          "595:             #else",
          "600:             #endif",
          "",
          "---------------"
        ],
        "Tests/VaporTests/ServerTests.swift||Tests/VaporTests/ServerTests.swift": [
          "File: Tests/VaporTests/ServerTests.swift -> Tests/VaporTests/ServerTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #if !canImport(Darwin)",
          "2: @preconcurrency import Dispatch",
          "3: #endif",
          "4: import Foundation",
          "5: import Vapor",
          "6: import XCTest",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: #if compiler(>=6.0)",
          "3: import Dispatch",
          "4: #else",
          "7: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "42:         XCTAssertEqual(res.body?.string, \"bar\")",
          "43:     }",
          "45:     func testSocketPathOverride() throws {",
          "46:         let socketPath = \"/tmp/\\(UUID().uuidString).vapor.socket\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50:     #if compiler(<6.0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "63:         XCTAssertThrowsError(try app.client.get(\"http://127.0.0.1:8080/foo\") { $0.timeout = .milliseconds(500) }.wait())",
          "64:     }",
          "66:     func testIncompatibleStartupOptions() throws {",
          "67:         func checkForError(_ app: Application) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "71:     #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "349:             )",
          "350:         }",
          "355:         XCTAssertNotNil(app.http.server.shared.localAddress)",
          "356:         guard let localAddress = app.http.server.shared.localAddress,",
          "",
          "[Removed Lines]",
          "352:         try app.server.start()",
          "353:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "359:         try await app.server.start(address: nil)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "411:         } else {",
          "412:             XCTFail(\"Missing supportedCompressedResponse.body\")",
          "413:         }",
          "414:     }",
          "416:     func testHTTP2RequestDecompression() async throws {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "421:         await app.server.shutdown()",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "466:             )",
          "467:         }",
          "472:         XCTAssertNotNil(app.http.server.shared.localAddress)",
          "473:         guard let localAddress = app.http.server.shared.localAddress,",
          "",
          "[Removed Lines]",
          "469:         try app.server.start()",
          "470:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "477:         try await app.server.start(address: nil)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "528:         } else {",
          "529:             XCTFail(\"Missing supportedCompressedResponse.body\")",
          "530:         }",
          "531:     }",
          "533:     func testHTTP1ResponseDecompression() async throws {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "539:         await app.server.shutdown()",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "546:         app.get(\"compressed\") { _ in compressiblePayload }",
          "551:         XCTAssertNotNil(app.http.server.shared.localAddress)",
          "552:         guard let localAddress = app.http.server.shared.localAddress,",
          "",
          "[Removed Lines]",
          "548:         try app.server.start()",
          "549:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "557:         try await app.server.start(address: nil)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "584:         XCTAssertEqual(supportedCompressedResponse.headers.first(name: .contentEncoding), \"gzip\")",
          "585:         XCTAssertNotEqual(supportedCompressedResponse.headers.first(name: .contentLength), \"\\(compressiblePayload.count)\")",
          "586:         XCTAssertEqual(supportedCompressedResponse.body?.string, compressiblePayload)",
          "587:     }",
          "589:     func testHTTP2ResponseDecompression() async throws {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "596:         await app.server.shutdown()",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "627:         app.get(\"compressed\") { _ in compressiblePayload }",
          "632:         XCTAssertNotNil(app.http.server.shared.localAddress)",
          "633:         guard let localAddress = app.http.server.shared.localAddress,",
          "",
          "[Removed Lines]",
          "629:         try app.server.start()",
          "630:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "639:         try await app.server.start(address: nil)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "665:         XCTAssertEqual(supportedCompressedResponse.headers.first(name: .contentEncoding), \"gzip\")",
          "666:         XCTAssertNotEqual(supportedCompressedResponse.headers.first(name: .contentLength), \"\\(compressiblePayload.count)\")",
          "667:         XCTAssertEqual(supportedCompressedResponse.body?.string, compressiblePayload)",
          "668:     }",
          "670:     func testRequestBodyStreamGetsFinalisedEvenIfClientAbandonsConnection() throws {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "678:         await app.server.shutdown()",
          "",
          "---------------"
        ],
        "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift": [
          "File: Tests/VaporTests/URITests.swift -> Tests/VaporTests/URITests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "183:         XCTAssertEqual(uri.string, \"foobar://host:1/test?query#fragment\")",
          "184:     }",
          "186:     func testVariousSchemesAndWeirdHosts() {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "187:     #if compiler(<6.0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "203:             generate: \"http+unix://%2Fpath/test?query#fragment\"",
          "204:         )",
          "205:     }",
          "207:     func testDefaultInitializer() {",
          "208:         let uri = URI.init()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "209:     #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "58969a794f374403c838e3df88bf1db0be02b7d8",
      "candidate_info": {
        "commit_hash": "58969a794f374403c838e3df88bf1db0be02b7d8",
        "repo": "vapor/vapor",
        "commit_url": "https://github.com/vapor/vapor/commit/58969a794f374403c838e3df88bf1db0be02b7d8",
        "files": [
          "Tests/VaporTests/URITests.swift"
        ],
        "message": "Additional tests fixes",
        "before_after_code_files": [
          "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift"
          ],
          "candidate": [
            "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift"
          ]
        }
      },
      "candidate_diff": {
        "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift": [
          "File: Tests/VaporTests/URITests.swift -> Tests/VaporTests/URITests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:     }",
          "28: }",
          "30: func XCTAssertURIComponents(",
          "31:        scheme: @autoclosure () throws -> URI.Scheme?,",
          "32:      userinfo: @autoclosure () throws -> String? = nil,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "286:         )",
          "287:         XCTAssertURIString(\"scheme://user:pass@host:1/path/path2/file.html;params?query#fragment\",",
          "288:             hasScheme: \"scheme\", hasUserinfo: \"user:pass\", hasHost: \"host\", hasPort: 1, hasPath: \"/path/path2/file.html;params\",",
          "290:         )",
          "291:         XCTAssertURIString(\"http://test.com/a%20space\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/a space\")",
          "292:         XCTAssertURIString(\"http://test.com/aBrace%7B\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/aBrace{\")",
          "",
          "[Removed Lines]",
          "289:             hasQuery: \"query\", hasFragment: \"fragment\"",
          "",
          "[Added Lines]",
          "290:             hasQuery: \"query\", hasFragment: \"fragment\", hasEqualString: false",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "341:         XCTAssertURIString(\"http://a/b/c/./g/.\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./g/.\")",
          "342:         XCTAssertURIString(\"http://a/b/c/g/./h\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g/./h\")",
          "343:         XCTAssertURIString(\"http://a/b/c/g/../h\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g/../h\")",
          "346:         XCTAssertURIString(\"http://a/b/c/g?y/./x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g\", hasQuery: \"y/./x\")",
          "347:         XCTAssertURIString(\"http://a/b/c/g?y/../x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g\", hasQuery: \"y/../x\")",
          "348:         XCTAssertURIString(\"http://a/b/c/g#s/./x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g\", hasFragment: \"s/./x\")",
          "",
          "[Removed Lines]",
          "344:         XCTAssertURIString(\"http://a/b/c/g;x=1/./y\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g;x=1/./y\")",
          "345:         XCTAssertURIString(\"http://a/b/c/g;x=1/../y\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g;x=1/../y\")",
          "",
          "[Added Lines]",
          "345:         XCTAssertURIString(\"http://a/b/c/g;x=1/./y\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g;x=1/./y\", hasEqualString: false)",
          "346:         XCTAssertURIString(\"http://a/b/c/g;x=1/../y\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g;x=1/../y\", hasEqualString: false)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4c80aab7a46860920022e03ced012bca3a71b06b",
      "candidate_info": {
        "commit_hash": "4c80aab7a46860920022e03ced012bca3a71b06b",
        "repo": "vapor/vapor",
        "commit_url": "https://github.com/vapor/vapor/commit/4c80aab7a46860920022e03ced012bca3a71b06b",
        "files": [
          "Package.swift",
          "Package@swift-5.9.swift",
          "Sources/Vapor/Concurrency/FileIO+Concurrency.swift",
          "Sources/Vapor/Utilities/FileIO.swift",
          "Tests/VaporTests/FileTests.swift",
          "Tests/VaporTests/Utilities/long-test-file.txt"
        ],
        "message": "Migrate to Async NIOFileIO APIs (#3167)\n\n* Add tests\n\n* Update NIO dependency\n\n* Migrate over to async APIs for FileIO\n\n* Add AsyncSequence-based file read method (#3170)\n\n* Add AsyncSequence-based file read method\n\n* Add `NIOFileSystem` dependency to standard manifest\n\n* Update test\n\n* Add long test file\n\n* Migrate new API to use NIOFileSystem\n\n* Fix mess up\n\n---------\n\nCo-authored-by: Paul Toffoloni <69189821+ptoffy@users.noreply.github.com>",
        "before_after_code_files": [
          "Package.swift||Package.swift",
          "Package@swift-5.9.swift||Package@swift-5.9.swift",
          "Sources/Vapor/Concurrency/FileIO+Concurrency.swift||Sources/Vapor/Concurrency/FileIO+Concurrency.swift",
          "Sources/Vapor/Utilities/FileIO.swift||Sources/Vapor/Utilities/FileIO.swift",
          "Tests/VaporTests/FileTests.swift||Tests/VaporTests/FileTests.swift"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Package.swift||Package.swift",
            "Package@swift-5.9.swift||Package@swift-5.9.swift"
          ],
          "candidate": [
            "Package.swift||Package.swift",
            "Package@swift-5.9.swift||Package@swift-5.9.swift"
          ]
        }
      },
      "candidate_diff": {
        "Package.swift||Package.swift": [
          "File: Package.swift -> Package.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:         .package(url: \"https://github.com/swift-server/swift-backtrace.git\", from: \"1.1.1\"),",
          "40:         .package(url: \"https://github.com/apple/swift-nio-ssl.git\", from: \"2.8.0\"),",
          "",
          "[Removed Lines]",
          "37:         .package(url: \"https://github.com/apple/swift-nio.git\", from: \"2.62.0\"),",
          "",
          "[Added Lines]",
          "37:         .package(url: \"https://github.com/apple/swift-nio.git\", from: \"2.63.0\"),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "92:             .product(name: \"WebSocketKit\", package: \"websocket-kit\"),",
          "93:             .product(name: \"MultipartKit\", package: \"multipart-kit\"),",
          "94:             .product(name: \"Atomics\", package: \"swift-atomics\"),",
          "95:         ]),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "96:             .product(name: \"_NIOFileSystem\", package: \"swift-nio\"),",
          "",
          "---------------"
        ],
        "Package@swift-5.9.swift||Package@swift-5.9.swift": [
          "File: Package@swift-5.9.swift -> Package@swift-5.9.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "31:         .package(url: \"https://github.com/vapor/routing-kit.git\", from: \"4.9.0\"),",
          "37:         .package(url: \"https://github.com/apple/swift-nio-ssl.git\", from: \"2.8.0\"),",
          "",
          "[Removed Lines]",
          "34:         .package(url: \"https://github.com/apple/swift-nio.git\", from: \"2.62.0\"),",
          "",
          "[Added Lines]",
          "34:         .package(url: \"https://github.com/apple/swift-nio.git\", from: \"2.63.0\"),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "90:                 .product(name: \"WebSocketKit\", package: \"websocket-kit\"),",
          "91:                 .product(name: \"MultipartKit\", package: \"multipart-kit\"),",
          "92:                 .product(name: \"Atomics\", package: \"swift-atomics\"),",
          "93:             ],",
          "94:             swiftSettings: [.enableExperimentalFeature(\"StrictConcurrency=complete\")]",
          "95:         ),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94:                 .product(name: \"_NIOFileSystem\", package: \"swift-nio\"),",
          "",
          "---------------"
        ],
        "Sources/Vapor/Concurrency/FileIO+Concurrency.swift||Sources/Vapor/Concurrency/FileIO+Concurrency.swift": [
          "File: Sources/Vapor/Concurrency/FileIO+Concurrency.swift -> Sources/Vapor/Concurrency/FileIO+Concurrency.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Sources/Vapor/Utilities/FileIO.swift||Sources/Vapor/Utilities/FileIO.swift": [
          "File: Sources/Vapor/Utilities/FileIO.swift -> Sources/Vapor/Utilities/FileIO.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import Foundation",
          "2: import NIOCore",
          "3: import NIOHTTP1",
          "4: import NIOPosix",
          "5: import Logging",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: import NIOFileSystem",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "51:     let request: Request",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52:     let fileSystem: FileSystem = .shared",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "383:         }",
          "384:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "388:     private func read(",
          "389:         path: String,",
          "390:         fromOffset offset: Int64,",
          "391:         byteCount: Int",
          "392:     ) async throws -> ByteBuffer {",
          "393:         let fd = try NIOFileHandle(path: path)",
          "394:         defer {",
          "395:             try? fd.close()",
          "396:         }",
          "397:         return try await self.io.read(fileHandle: fd, fromOffset: offset, byteCount: byteCount, allocator: allocator)",
          "398:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "424:                 request.application.storage[FileMiddleware.ETagHashes.self]?[path] = FileMiddleware.ETagHashes.FileHash(lastModified: lastModified, digestHex: digest.hex)",
          "426:                 return digest.hex",
          "427:             }",
          "428:         }",
          "429:     }",
          "430: }",
          "432: extension HTTPHeaders.Range.Value {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "454:     public func collectFile(at path: String) async throws -> ByteBuffer {",
          "455:         guard let fileSize = try await FileSystem.shared.info(forFileAt: .init(path))?.size else {",
          "456:             throw Abort(.internalServerError)",
          "457:         }",
          "458:         return try await self.read(path: path, fromOffset: 0, byteCount: Int(fileSize))",
          "459:     }",
          "463:     public struct FileChunks: AsyncSequence {",
          "464:         public typealias Element = ByteBuffer",
          "465:         private let fileHandle: NIOFileSystem.FileHandleProtocol",
          "466:         private let fileChunks: NIOFileSystem.FileChunks",
          "468:         init(fileChunks: NIOFileSystem.FileChunks, fileHandle: some NIOFileSystem.FileHandleProtocol) {",
          "469:             self.fileChunks = fileChunks",
          "470:             self.fileHandle = fileHandle",
          "471:         }",
          "473:         public struct FileChunksIterator: AsyncIteratorProtocol {",
          "474:             private var iterator: NIOFileSystem.FileChunks.AsyncIterator",
          "475:             private let fileHandle: NIOFileSystem.FileHandleProtocol",
          "477:             fileprivate init(wrapping iterator: NIOFileSystem.FileChunks.AsyncIterator, fileHandle: some NIOFileSystem.FileHandleProtocol) {",
          "478:                 self.iterator = iterator",
          "479:                 self.fileHandle = fileHandle",
          "480:             }",
          "482:             public mutating func next() async throws -> ByteBuffer? {",
          "483:                 let chunk = try await iterator.next()",
          "484:                 if chunk == nil {",
          "485:                     try await fileHandle.close()",
          "486:                 }",
          "487:                 return chunk",
          "488:             }",
          "489:         }",
          "491:         public func makeAsyncIterator() -> FileChunksIterator {",
          "492:             FileChunksIterator(wrapping: fileChunks.makeAsyncIterator(), fileHandle: fileHandle)",
          "493:         }",
          "494:     }",
          "506:     public func readFile(",
          "507:         at path: String,",
          "508:         chunkSize: Int = NonBlockingFileIO.defaultChunkSize",
          "509:     ) async throws -> FileChunks {",
          "510:         let filePath = FilePath(path)",
          "512:         let readHandle = try await fileSystem.openFile(forReadingAt: filePath)",
          "513:         let chunks = readHandle.readChunks(chunkLength: .bytes(Int64(chunkSize)))",
          "515:         return FileChunks(fileChunks: chunks, fileHandle: readHandle)",
          "516:     }",
          "527:     public func writeFile(_ buffer: ByteBuffer, at path: String) async throws {",
          "528:         let fd = try NIOFileHandle(path: path, mode: .write, flags: .allowFileCreation())",
          "529:         defer {",
          "530:             try? fd.close()",
          "531:         }",
          "532:         try await self.io.write(fileHandle: fd, buffer: buffer)",
          "533:     }",
          "",
          "---------------"
        ],
        "Tests/VaporTests/FileTests.swift||Tests/VaporTests/FileTests.swift": [
          "File: Tests/VaporTests/FileTests.swift -> Tests/VaporTests/FileTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "537:             XCTAssertEqual(res.status, .badRequest)",
          "538:         }",
          "539:     }",
          "540: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "541:     func testAsyncFileWrite() async throws {",
          "542:         let app = Application(.testing)",
          "543:         defer { app.shutdown() }",
          "545:         let request = Request(application: app, on: app.eventLoopGroup.next())",
          "547:         let data = \"Hello\"",
          "548:         let path = \"/tmp/fileio_write.txt\"",
          "550:         try await request.fileio.writeFile(ByteBuffer(string: data), at: path)",
          "551:         defer { try? FileManager.default.removeItem(atPath: path) }",
          "553:         let result = try String(contentsOfFile: path)",
          "554:         XCTAssertEqual(result, data)",
          "555:     }",
          "557:     func testAsyncFileRead() async throws {",
          "558:         let app = Application(.testing)",
          "559:         defer { app.shutdown() }",
          "561:         let request = Request(application: app, on: app.eventLoopGroup.next())",
          "563:         let path = \"/\" + #filePath.split(separator: \"/\").dropLast().joined(separator: \"/\") + \"/Utilities/long-test-file.txt\"",
          "565:         let content = try String(contentsOfFile: path)",
          "567:         var readContent = \"\"",
          "568:         let file = try await request.fileio.readFile(at: path, chunkSize: 16 * 1024) // 32Kb, ~5 chunks",
          "569:         for try await chunk in file {",
          "570:             readContent += String(buffer: chunk)",
          "571:         }",
          "573:         XCTAssertEqual(readContent, content, \"The content read from the file does not match the expected content.\")",
          "574:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
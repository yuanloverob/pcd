{
  "cve_id": "CVE-2024-5642",
  "cve_desc": "CPython 3.9 and earlier doesn't disallow configuring an empty list (\"[]\") for SSLContext.set_npn_protocols() which is an invalid value for the underlying OpenSSL API. This results in a buffer over-read when NPN is used (see CVE-2024-5535 for OpenSSL). This vulnerability is of low severity due to NPN being not widely used and specifying an empty list likely being uncommon in-practice (typically a protocol name would be configured).",
  "repo": "python/cpython",
  "patch_hash": "39258d3595300bc7b952854c915f63ae2d4b9c3e",
  "patch_info": {
    "commit_hash": "39258d3595300bc7b952854c915f63ae2d4b9c3e",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/39258d3595300bc7b952854c915f63ae2d4b9c3e",
    "files": [
      ".github/workflows/build.yml",
      "Doc/using/unix.rst",
      "Doc/whatsnew/3.10.rst",
      "Lib/ssl.py",
      "Lib/test/test_ssl.py",
      "Misc/NEWS.d/next/Build/2021-03-30-14-19-39.bpo-43669.lWMUYx.rst",
      "Modules/Setup",
      "Modules/_hashopenssl.c",
      "Modules/_ssl.c",
      "Modules/_ssl/debughelpers.c",
      "Modules/clinic/_hashopenssl.c.h",
      "Modules/clinic/_ssl.c.h",
      "Tools/ssl/multissltests.py",
      "configure",
      "configure.ac",
      "pyconfig.h.in",
      "setup.py"
    ],
    "message": "bpo-43669: PEP 644: Require OpenSSL 1.1.1 or newer (GH-23014)\n\n- Remove HAVE_X509_VERIFY_PARAM_SET1_HOST check\n- Update hashopenssl to require OpenSSL 1.1.1\n- multissltests only OpenSSL > 1.1.0\n- ALPN is always supported\n- SNI is always supported\n- Remove deprecated NPN code. Python wrappers are no-op.\n- ECDH is always supported\n- Remove OPENSSL_VERSION_1_1 macro\n- Remove locking callbacks\n- Drop PY_OPENSSL_1_1_API macro\n- Drop HAVE_SSL_CTX_CLEAR_OPTIONS macro\n- SSL_CTRL_GET_MAX_PROTO_VERSION is always defined now\n- security level is always available now\n- get_num_tickets is available with TLS 1.3\n- X509_V_ERR MISMATCH is always available now\n- Always set SSL_MODE_RELEASE_BUFFERS\n- X509_V_FLAG_TRUSTED_FIRST is always available\n- get_ciphers is always supported\n- SSL_CTX_set_keylog_callback is always available\n- Update Modules/Setup with static link example\n- Mention PEP in whatsnew\n- Drop 1.0.2 and 1.1.0 from GHA tests",
    "before_after_code_files": [
      "Lib/ssl.py||Lib/ssl.py",
      "Lib/test/test_ssl.py||Lib/test/test_ssl.py",
      "Modules/_hashopenssl.c||Modules/_hashopenssl.c",
      "Modules/_ssl.c||Modules/_ssl.c",
      "Modules/_ssl/debughelpers.c||Modules/_ssl/debughelpers.c",
      "Modules/clinic/_hashopenssl.c.h||Modules/clinic/_hashopenssl.c.h",
      "Modules/clinic/_ssl.c.h||Modules/clinic/_ssl.c.h",
      "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py",
      "configure.ac||configure.ac",
      "pyconfig.h.in||pyconfig.h.in",
      "setup.py||setup.py"
    ]
  },
  "patch_diff": {
    "Lib/ssl.py||Lib/ssl.py": [
      "File: Lib/ssl.py -> Lib/ssl.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "909:         \"\"\"Return the currently selected NPN protocol as a string, or ``None``",
      "910:         if a next protocol was not negotiated or if NPN is not supported by one",
      "911:         of the peers.\"\"\"",
      "915:     def selected_alpn_protocol(self):",
      "916:         \"\"\"Return the currently selected ALPN protocol as a string, or ``None``",
      "917:         if a next protocol was not negotiated or if ALPN is not supported by one",
      "918:         of the peers.\"\"\"",
      "922:     def cipher(self):",
      "923:         \"\"\"Return the currently selected cipher as a 3-tuple ``(name,",
      "",
      "[Removed Lines]",
      "912:         if _ssl.HAS_NPN:",
      "913:             return self._sslobj.selected_npn_protocol()",
      "919:         if _ssl.HAS_ALPN:",
      "920:             return self._sslobj.selected_alpn_protocol()",
      "",
      "[Added Lines]",
      "917:         return self._sslobj.selected_alpn_protocol()",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1126:     @_sslcopydoc",
      "1127:     def selected_npn_protocol(self):",
      "1128:         self._checkClosed()",
      "1134:     @_sslcopydoc",
      "1135:     def selected_alpn_protocol(self):",
      "",
      "[Removed Lines]",
      "1129:         if self._sslobj is None or not _ssl.HAS_NPN:",
      "1130:             return None",
      "1131:         else:",
      "1132:             return self._sslobj.selected_npn_protocol()",
      "",
      "[Added Lines]",
      "1126:         return None",
      "",
      "---------------"
    ],
    "Lib/test/test_ssl.py||Lib/test/test_ssl.py": [
      "File: Lib/test/test_ssl.py -> Lib/test/test_ssl.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "40: PROTOCOLS = sorted(ssl._PROTOCOL_NAMES)",
      "41: HOST = socket_helper.HOST",
      "42: IS_LIBRESSL = ssl.OPENSSL_VERSION.startswith('LibreSSL')",
      "44: IS_OPENSSL_1_1_1 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (1, 1, 1)",
      "45: IS_OPENSSL_3_0_0 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (3, 0, 0)",
      "46: PY_SSL_DEFAULT_CIPHERS = sysconfig.get_config_var('PY_SSL_DEFAULT_CIPHERS')",
      "",
      "[Removed Lines]",
      "43: IS_OPENSSL_1_1_0 = not IS_LIBRESSL and ssl.OPENSSL_VERSION_INFO >= (1, 1, 0)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "270:     if support.verbose:",
      "271:         sys.stdout.write(prefix + exc_format)",
      "285: def _have_secp_curves():",
      "286:     if not ssl.HAS_ECDH:",
      "287:         return False",
      "",
      "[Removed Lines]",
      "273: def can_clear_options():",
      "274:     # 0.9.8m or higher",
      "275:     return ssl._OPENSSL_API_VERSION >= (0, 9, 8, 13, 15)",
      "277: def no_sslv2_implies_sslv3_hello():",
      "278:     # 0.9.7h or higher",
      "279:     return ssl.OPENSSL_VERSION_INFO >= (0, 9, 7, 8, 15)",
      "281: def have_verify_flags():",
      "282:     # 0.9.8 or higher",
      "283:     return ssl.OPENSSL_VERSION_INFO >= (0, 9, 8, 0, 15)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "372:         ssl.OP_SINGLE_DH_USE",
      "373:         if ssl.HAS_ECDH:",
      "374:             ssl.OP_SINGLE_ECDH_USE",
      "377:         self.assertIn(ssl.HAS_SNI, {True, False})",
      "378:         self.assertIn(ssl.HAS_ECDH, {True, False})",
      "379:         ssl.OP_NO_SSLv2",
      "380:         ssl.OP_NO_SSLv3",
      "381:         ssl.OP_NO_TLSv1",
      "382:         ssl.OP_NO_TLSv1_3",
      "386:         self.assertEqual(ssl.PROTOCOL_TLS, ssl.PROTOCOL_SSLv23)",
      "388:     def test_private_init(self):",
      "",
      "[Removed Lines]",
      "375:         if ssl.OPENSSL_VERSION_INFO >= (1, 0):",
      "376:             ssl.OP_NO_COMPRESSION",
      "383:         if ssl.OPENSSL_VERSION_INFO >= (1, 0, 1):",
      "384:             ssl.OP_NO_TLSv1_1",
      "385:             ssl.OP_NO_TLSv1_2",
      "",
      "[Added Lines]",
      "362:         ssl.OP_NO_COMPRESSION",
      "369:         ssl.OP_NO_TLSv1_1",
      "370:         ssl.OP_NO_TLSv1_2",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1161:             self.assertNotIn(\"RC4\", name)",
      "1162:             self.assertNotIn(\"3DES\", name)",
      "1165:     def test_get_ciphers(self):",
      "1166:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)",
      "1167:         ctx.set_ciphers('AESGCM')",
      "",
      "[Removed Lines]",
      "1164:     @unittest.skipIf(ssl.OPENSSL_VERSION_INFO < (1, 0, 2, 0, 0), 'OpenSSL too old')",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1181:         self.assertEqual(default, ctx.options)",
      "1182:         ctx.options |= ssl.OP_NO_TLSv1",
      "1183:         self.assertEqual(default | ssl.OP_NO_TLSv1, ctx.options)",
      "1194:     def test_verify_mode_protocol(self):",
      "1195:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS)",
      "",
      "[Removed Lines]",
      "1184:         if can_clear_options():",
      "1185:             ctx.options = (ctx.options & ~ssl.OP_NO_TLSv1)",
      "1186:             self.assertEqual(default, ctx.options)",
      "1187:             ctx.options = 0",
      "1188:             # Ubuntu has OP_NO_SSLv3 forced on by default",
      "1189:             self.assertEqual(0, ctx.options & ~ssl.OP_NO_SSLv3)",
      "1190:         else:",
      "1191:             with self.assertRaises(ValueError):",
      "1192:                 ctx.options = 0",
      "",
      "[Added Lines]",
      "1168:         ctx.options = (ctx.options & ~ssl.OP_NO_TLSv1)",
      "1169:         self.assertEqual(default, ctx.options)",
      "1170:         ctx.options = 0",
      "1171:         # Ubuntu has OP_NO_SSLv3 forced on by default",
      "1172:         self.assertEqual(0, ctx.options & ~ssl.OP_NO_SSLv3)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1327:         }",
      "1328:         self.assertIn(ctx.security_level, security_level_range)",
      "1332:     def test_verify_flags(self):",
      "1333:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
      "1334:         # default value",
      "",
      "[Removed Lines]",
      "1330:     @unittest.skipUnless(have_verify_flags(),",
      "1331:                          \"verify_flags need OpenSSL > 0.9.8\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1797:         obj = ctx.wrap_bio(ssl.MemoryBIO(), ssl.MemoryBIO())",
      "1798:         self.assertIsInstance(obj, MySSLObject)",
      "1801:     def test_num_tickest(self):",
      "1802:         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
      "1803:         self.assertEqual(ctx.num_tickets, 2)",
      "",
      "[Removed Lines]",
      "1800:     @unittest.skipUnless(IS_OPENSSL_1_1_1, \"Test requires OpenSSL 1.1.1\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2956:                 after = ssl.cert_time_to_seconds(cert['notAfter'])",
      "2957:                 self.assertLess(before, after)",
      "2961:     def test_crl_check(self):",
      "2962:         if support.verbose:",
      "2963:             sys.stdout.write(\"\\n\")",
      "",
      "[Removed Lines]",
      "2959:     @unittest.skipUnless(have_verify_flags(),",
      "2960:                         \"verify_flags need OpenSSL > 0.9.8\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "3859:                 self.assertIs(s.version(), None)",
      "3860:                 self.assertIs(s._sslobj, None)",
      "3861:                 s.connect((HOST, server.port))",
      "3868:             self.assertIs(s._sslobj, None)",
      "3869:             self.assertIs(s.version(), None)",
      "",
      "[Removed Lines]",
      "3862:                 if IS_OPENSSL_1_1_1 and has_tls_version('TLSv1_3'):",
      "3863:                     self.assertEqual(s.version(), 'TLSv1.3')",
      "3864:                 elif ssl.OPENSSL_VERSION_INFO >= (1, 0, 2):",
      "3865:                     self.assertEqual(s.version(), 'TLSv1.2')",
      "3866:                 else:  # 0.9.8 to 1.0.1",
      "3867:                     self.assertIn(s.version(), ('TLSv1', 'TLSv1.2'))",
      "",
      "[Added Lines]",
      "3837:                 self.assertEqual(s.version(), 'TLSv1.3')",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "3966:         # explicitly using the 'ECCdraft' cipher alias.  Otherwise,",
      "3967:         # our default cipher list should prefer ECDH-based ciphers",
      "3968:         # automatically.",
      "3971:         with ThreadedEchoServer(context=context) as server:",
      "3972:             with context.wrap_socket(socket.socket()) as s:",
      "3973:                 s.connect((HOST, server.port))",
      "",
      "[Removed Lines]",
      "3969:         if ssl.OPENSSL_VERSION_INFO < (1, 0, 0):",
      "3970:             context.set_ciphers(\"ECCdraft:ECDH\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "4099:         server_context.set_ciphers(\"ECDHE:!eNULL:!aNULL\")",
      "4100:         server_context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1",
      "4101:         try:",
      "4105:         except ssl.SSLError:",
      "4112:     def test_selected_alpn_protocol(self):",
      "4113:         # selected_alpn_protocol() is None unless ALPN is used.",
      "",
      "[Removed Lines]",
      "4102:             stats = server_params_test(client_context, server_context,",
      "4103:                                        chatty=True, connectionchatty=True,",
      "4104:                                        sni_name=hostname)",
      "4106:             pass",
      "4107:         else:",
      "4108:             # OpenSSL 1.0.2 does not fail although it should.",
      "4109:             if IS_OPENSSL_1_1_0:",
      "4110:                 self.fail(\"mismatch curve did not fail\")",
      "",
      "[Added Lines]",
      "4070:             server_params_test(client_context, server_context,",
      "4071:                                chatty=True, connectionchatty=True,",
      "4072:                                sni_name=hostname)",
      "4074:             self.fail(\"mismatch curve did not fail\")",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "4117:                                    sni_name=hostname)",
      "4118:         self.assertIs(stats['client_alpn_protocol'], None)",
      "4121:     def test_selected_alpn_protocol_if_server_uses_alpn(self):",
      "4122:         # selected_alpn_protocol() is None unless ALPN is used by the client.",
      "4123:         client_context, server_context, hostname = testing_context()",
      "",
      "[Removed Lines]",
      "4120:     @unittest.skipUnless(ssl.HAS_ALPN, \"ALPN support required\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "4127:                                    sni_name=hostname)",
      "4128:         self.assertIs(stats['client_alpn_protocol'], None)",
      "4131:     def test_alpn_protocols(self):",
      "4132:         server_protocols = ['foo', 'bar', 'milkshake']",
      "4133:         protocol_tests = [",
      "",
      "[Removed Lines]",
      "4130:     @unittest.skipUnless(ssl.HAS_ALPN, \"ALPN support needed for this test\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "4150:             except ssl.SSLError as e:",
      "4151:                 stats = e",
      "4170:     def test_selected_npn_protocol(self):",
      "4171:         # selected_npn_protocol() is None unless NPN is used",
      "",
      "[Removed Lines]",
      "4153:             if (expected is None and IS_OPENSSL_1_1_0",
      "4154:                     and ssl.OPENSSL_VERSION_INFO < (1, 1, 0, 6)):",
      "4155:                 # OpenSSL 1.1.0 to 1.1.0e raises handshake error",
      "4156:                 self.assertIsInstance(stats, ssl.SSLError)",
      "4157:             else:",
      "4158:                 msg = \"failed trying %s (s) and %s (c).\\n\" \\",
      "4159:                     \"was expecting %s, but got %%s from the %%s\" \\",
      "4160:                         % (str(server_protocols), str(client_protocols),",
      "4161:                             str(expected))",
      "4162:                 client_result = stats['client_alpn_protocol']",
      "4163:                 self.assertEqual(client_result, expected,",
      "4164:                                  msg % (client_result, \"client\"))",
      "4165:                 server_result = stats['server_alpn_protocols'][-1] \\",
      "4166:                     if len(stats['server_alpn_protocols']) else 'nothing'",
      "4167:                 self.assertEqual(server_result, expected,",
      "4168:                                  msg % (server_result, \"server\"))",
      "",
      "[Added Lines]",
      "4115:             msg = \"failed trying %s (s) and %s (c).\\n\" \\",
      "4116:                 \"was expecting %s, but got %%s from the %%s\" \\",
      "4117:                     % (str(server_protocols), str(client_protocols),",
      "4118:                         str(expected))",
      "4119:             client_result = stats['client_alpn_protocol']",
      "4120:             self.assertEqual(client_result, expected,",
      "4121:                              msg % (client_result, \"client\"))",
      "4122:             server_result = stats['server_alpn_protocols'][-1] \\",
      "4123:                 if len(stats['server_alpn_protocols']) else 'nothing'",
      "4124:             self.assertEqual(server_result, expected,",
      "4125:                              msg % (server_result, \"server\"))",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "4175:                                    sni_name=hostname)",
      "4176:         self.assertIs(stats['client_npn_protocol'], None)",
      "4179:     def test_npn_protocols(self):",
      "4204:     def sni_contexts(self):",
      "4205:         server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
      "",
      "[Removed Lines]",
      "4178:     @unittest.skipUnless(ssl.HAS_NPN, \"NPN support needed for this test\")",
      "4180:         server_protocols = ['http/1.1', 'spdy/2']",
      "4181:         protocol_tests = [",
      "4182:             (['http/1.1', 'spdy/2'], 'http/1.1'),",
      "4183:             (['spdy/2', 'http/1.1'], 'http/1.1'),",
      "4184:             (['spdy/2', 'test'], 'spdy/2'),",
      "4185:             (['abc', 'def'], 'abc')",
      "4186:         ]",
      "4187:         for client_protocols, expected in protocol_tests:",
      "4188:             client_context, server_context, hostname = testing_context()",
      "4189:             server_context.set_npn_protocols(server_protocols)",
      "4190:             client_context.set_npn_protocols(client_protocols)",
      "4191:             stats = server_params_test(client_context, server_context,",
      "4192:                                        chatty=True, connectionchatty=True,",
      "4193:                                        sni_name=hostname)",
      "4194:             msg = \"failed trying %s (s) and %s (c).\\n\" \\",
      "4195:                   \"was expecting %s, but got %%s from the %%s\" \\",
      "4196:                       % (str(server_protocols), str(client_protocols),",
      "4197:                          str(expected))",
      "4198:             client_result = stats['client_npn_protocol']",
      "4199:             self.assertEqual(client_result, expected, msg % (client_result, \"client\"))",
      "4200:             server_result = stats['server_npn_protocols'][-1] \\",
      "4201:                 if len(stats['server_npn_protocols']) else 'nothing'",
      "4202:             self.assertEqual(server_result, expected, msg % (server_result, \"server\"))",
      "",
      "[Added Lines]",
      "4136:         assert not ssl.HAS_NPN",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "4369:         self.assertGreater(session.time, 0)",
      "4370:         self.assertGreater(session.timeout, 0)",
      "4371:         self.assertTrue(session.has_ticket)",
      "4374:         self.assertFalse(stats['session_reused'])",
      "4375:         sess_stat = server_context.session_stats()",
      "4376:         self.assertEqual(sess_stat['accept'], 1)",
      "",
      "[Removed Lines]",
      "4372:         if ssl.OPENSSL_VERSION_INFO > (1, 0, 1):",
      "4373:             self.assertGreater(session.ticket_lifetime_hint, 0)",
      "",
      "[Added Lines]",
      "4306:         self.assertGreater(session.ticket_lifetime_hint, 0)",
      "",
      "---------------"
    ],
    "Modules/_hashopenssl.c||Modules/_hashopenssl.c": [
      "File: Modules/_hashopenssl.c -> Modules/_hashopenssl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "38: #  error \"OPENSSL_THREADS is not defined, Python requires thread-safe OpenSSL\"",
      "39: #endif",
      "73: #define MUNCH_SIZE INT_MAX",
      "76: #define PY_OPENSSL_HAS_SHA3 1",
      "80: #define PY_OPENSSL_HAS_SHAKE 1",
      "84: #define PY_OPENSSL_HAS_BLAKE2 1",
      "87: static PyModuleDef _hashlibmodule;",
      "",
      "[Removed Lines]",
      "41: #if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)",
      "43: #define EVP_MD_CTX_new EVP_MD_CTX_create",
      "44: #define EVP_MD_CTX_free EVP_MD_CTX_destroy",
      "46: HMAC_CTX *",
      "47: HMAC_CTX_new(void)",
      "48: {",
      "49:     HMAC_CTX *ctx = OPENSSL_malloc(sizeof(HMAC_CTX));",
      "50:     if (ctx != NULL) {",
      "51:         memset(ctx, 0, sizeof(HMAC_CTX));",
      "52:         HMAC_CTX_init(ctx);",
      "53:     }",
      "54:     return ctx;",
      "55: }",
      "57: void",
      "58: HMAC_CTX_free(HMAC_CTX *ctx)",
      "59: {",
      "60:     if (ctx != NULL) {",
      "61:         HMAC_CTX_cleanup(ctx);",
      "62:         OPENSSL_free(ctx);",
      "63:     }",
      "64: }",
      "66: const EVP_MD *",
      "67: HMAC_CTX_get_md(const HMAC_CTX *ctx)",
      "68: {",
      "69:     return ctx->md;",
      "70: }",
      "71: #endif",
      "75: #ifdef NID_sha3_224",
      "77: #endif",
      "79: #if defined(EVP_MD_FLAG_XOF) && defined(NID_shake128)",
      "81: #endif",
      "83: #if defined(NID_blake2b512) && !defined(OPENSSL_NO_BLAKE2)",
      "85: #endif",
      "",
      "[Added Lines]",
      "43: #define PY_OPENSSL_HAS_SCRYPT 1",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1252:     return key_obj;",
      "1253: }",
      "1259:    They are optional in the Argument Clinic declaration only due to a",
      "",
      "[Removed Lines]",
      "1255: #if OPENSSL_VERSION_NUMBER > 0x10100000L && !defined(OPENSSL_NO_SCRYPT) && !defined(LIBRESSL_VERSION_NUMBER)",
      "1256: #define PY_SCRYPT 1",
      "",
      "[Added Lines]",
      "1216: #ifdef PY_OPENSSL_HAS_SCRYPT",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1376:     }",
      "1377:     return key_obj;",
      "1378: }",
      "",
      "[Removed Lines]",
      "1379: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1844:     return 0;",
      "1845: }",
      "1854: _hashlib.get_fips_mode -> int",
      "",
      "[Removed Lines]",
      "1848:    https://marc.info/?l=openbsd-misc&m=139819485423701&w=2",
      "1850:    Ted Unangst wrote: \"I figured I should mention our current libressl policy",
      "1852: #ifndef LIBRESSL_VERSION_NUMBER",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1887:     return result;",
      "1888: #endif",
      "1889: }",
      "1893: static int",
      "",
      "[Removed Lines]",
      "1890: #endif  // !LIBRESSL_VERSION_NUMBER",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2067: }",
      "2081: static int",
      "2082: hashlib_init_evptype(PyObject *module)",
      "2083: {",
      "",
      "[Removed Lines]",
      "2070: static int",
      "2071: hashlib_openssl_legacy_init(PyObject *module)",
      "2072: {",
      "2073: #if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)",
      "2075:     OPENSSL_add_all_algorithms_noconf();",
      "2076:     ERR_load_crypto_strings();",
      "2077: #endif",
      "2078:     return 0;",
      "2079: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2202: static PyModuleDef_Slot hashlib_slots[] = {",
      "2205:     {Py_mod_exec, hashlib_init_evptype},",
      "2206:     {Py_mod_exec, hashlib_init_evpxoftype},",
      "2207:     {Py_mod_exec, hashlib_init_hmactype},",
      "",
      "[Removed Lines]",
      "2204:     {Py_mod_exec, hashlib_openssl_legacy_init},",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Modules/_ssl.c||Modules/_ssl.c": [
      "File: Modules/_ssl.c -> Modules/_ssl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "29: #define _PySSL_FIX_ERRNO",
      "31: #define PySSL_BEGIN_ALLOW_THREADS_S(save) \\",
      "33: #define PySSL_END_ALLOW_THREADS_S(save) \\",
      "35: #define PySSL_BEGIN_ALLOW_THREADS { \\",
      "36:             PyThreadState *_save = NULL;  \\",
      "37:             PySSL_BEGIN_ALLOW_THREADS_S(_save);",
      "",
      "[Removed Lines]",
      "32:     do { if (_ssl_locks_count>0) { (save) = PyEval_SaveThread(); } } while (0)",
      "34:     do { if (_ssl_locks_count>0) { PyEval_RestoreThread(save); } _PySSL_FIX_ERRNO; } while (0)",
      "",
      "[Added Lines]",
      "32:     do { (save) = PyEval_SaveThread(); } while(0)",
      "34:     do { PyEval_RestoreThread(save); _PySSL_FIX_ERRNO; } while(0)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "62: #include \"openssl/bio.h\"",
      "63: #include \"openssl/dh.h\"",
      "75: #ifndef OPENSSL_THREADS",
      "76: #  error \"OPENSSL_THREADS is not defined, Python requires thread-safe OpenSSL\"",
      "77: #endif",
      "",
      "[Removed Lines]",
      "65: #ifndef HAVE_X509_VERIFY_PARAM_SET1_HOST",
      "66: #  ifdef LIBRESSL_VERSION_NUMBER",
      "67: #    error \"LibreSSL is missing X509_VERIFY_PARAM_set1_host(), see https://github.com/libressl-portable/portable/issues/381\"",
      "68: #  elif OPENSSL_VERSION_NUMBER > 0x1000200fL",
      "69: #    define HAVE_X509_VERIFY_PARAM_SET1_HOST",
      "70: #  else",
      "71: #    error \"libssl is too old and does not support X509_VERIFY_PARAM_set1_host()\"",
      "72: #  endif",
      "73: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "142: #include \"_ssl_data.h\"",
      "143: #endif",
      "154: #ifndef OPENSSL_NO_TLS1_METHOD",
      "155: extern const SSL_METHOD *TLSv1_method(void);",
      "156: #endif",
      "",
      "[Removed Lines]",
      "145: #if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "146: #  define OPENSSL_VERSION_1_1 1",
      "147: #  define PY_OPENSSL_1_1_API 1",
      "148: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "161: extern const SSL_METHOD *TLSv1_2_method(void);",
      "162: #endif",
      "205: #define INVALID_SOCKET (-1)",
      "206: #endif",
      "214: #define OPENSSL_NO_SSL2",
      "289: #ifndef PY_SSL_DEFAULT_CIPHERS",
      "",
      "[Removed Lines]",
      "165: #if defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER >= 0x2070000fL",
      "166: #  define PY_OPENSSL_1_1_API 1",
      "167: #endif",
      "172: #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME",
      "173: # define HAVE_SNI 1",
      "174: #else",
      "175: # define HAVE_SNI 0",
      "176: #endif",
      "178: #ifdef TLSEXT_TYPE_application_layer_protocol_negotiation",
      "179: # define HAVE_ALPN 1",
      "180: #else",
      "181: # define HAVE_ALPN 0",
      "182: #endif",
      "190: #ifdef OPENSSL_NO_NEXTPROTONEG",
      "191: # define HAVE_NPN 0",
      "192: #elif (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "193: # define HAVE_NPN 0",
      "194: #elif defined(TLSEXT_TYPE_next_proto_neg)",
      "195: # define HAVE_NPN 1",
      "196: #else",
      "197: # define HAVE_NPN 0",
      "198: #endif",
      "200: #if (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "201: #define HAVE_OPENSSL_KEYLOG 1",
      "202: #endif",
      "209: #ifndef OPENSSL_VERSION_1_1",
      "210: #define HAVE_OPENSSL_CRYPTO_LOCK",
      "211: #endif",
      "213: #if defined(OPENSSL_VERSION_1_1) && !defined(OPENSSL_NO_SSL2)",
      "215: #endif",
      "217: #ifndef PY_OPENSSL_1_1_API",
      "220: #define TLS_method SSLv23_method",
      "221: #define TLS_client_method SSLv23_client_method",
      "222: #define TLS_server_method SSLv23_server_method",
      "223: #define ASN1_STRING_get0_data ASN1_STRING_data",
      "224: #define X509_get0_notBefore X509_get_notBefore",
      "225: #define X509_get0_notAfter X509_get_notAfter",
      "226: #define OpenSSL_version_num SSLeay",
      "227: #define OpenSSL_version SSLeay_version",
      "228: #define OPENSSL_VERSION SSLEAY_VERSION",
      "230: static int X509_NAME_ENTRY_set(const X509_NAME_ENTRY *ne)",
      "231: {",
      "232:     return ne->set;",
      "233: }",
      "235: #ifndef OPENSSL_NO_COMP",
      "237: static int COMP_get_type(const COMP_METHOD *meth)",
      "238: {",
      "239:     return meth->type;",
      "240: }",
      "242: #endif",
      "244: static pem_password_cb *SSL_CTX_get_default_passwd_cb(SSL_CTX *ctx)",
      "245: {",
      "246:     return ctx->default_passwd_callback;",
      "247: }",
      "249: static void *SSL_CTX_get_default_passwd_cb_userdata(SSL_CTX *ctx)",
      "250: {",
      "251:     return ctx->default_passwd_callback_userdata;",
      "252: }",
      "254: static int X509_OBJECT_get_type(X509_OBJECT *x)",
      "255: {",
      "256:     return x->type;",
      "257: }",
      "259: static X509 *X509_OBJECT_get0_X509(X509_OBJECT *x)",
      "260: {",
      "261:     return x->data.x509;",
      "262: }",
      "264: static int BIO_up_ref(BIO *b)",
      "265: {",
      "266:     CRYPTO_add(&b->references, 1, CRYPTO_LOCK_BIO);",
      "267:     return 1;",
      "268: }",
      "270: static STACK_OF(X509_OBJECT) *X509_STORE_get0_objects(X509_STORE *store) {",
      "271:     return store->objs;",
      "272: }",
      "274: static int",
      "275: SSL_SESSION_has_ticket(const SSL_SESSION *s)",
      "276: {",
      "277:     return (s->tlsext_ticklen > 0) ? 1 : 0;",
      "278: }",
      "280: static unsigned long",
      "281: SSL_SESSION_get_ticket_lifetime_hint(const SSL_SESSION *s)",
      "282: {",
      "283:     return s->tlsext_tick_lifetime_hint;",
      "284: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "395: #endif",
      "396: };",
      "406: #define X509_NAME_MAXLEN 256",
      "",
      "[Removed Lines]",
      "402: static unsigned int _ssl_locks_count = 0;",
      "411: #if OPENSSL_VERSION_NUMBER >= 0x009080dfL && OPENSSL_VERSION_NUMBER != 0x00909000L",
      "412: # define HAVE_SSL_CTX_CLEAR_OPTIONS",
      "413: #else",
      "414: # undef HAVE_SSL_CTX_CLEAR_OPTIONS",
      "415: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "422: typedef struct {",
      "423:     PyObject_HEAD",
      "424:     SSL_CTX *ctx;",
      "430:     unsigned char *alpn_protocols;",
      "431:     unsigned int alpn_protocols_len;",
      "434:     PyObject *set_sni_cb;",
      "436:     int check_hostname;",
      "",
      "[Removed Lines]",
      "425: #if HAVE_NPN",
      "426:     unsigned char *npn_protocols;",
      "427:     int npn_protocols_len;",
      "428: #endif",
      "429: #if HAVE_ALPN",
      "432: #endif",
      "433: #ifndef OPENSSL_NO_TLSEXT",
      "435: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "443:     int post_handshake_auth;",
      "444: #endif",
      "445:     PyObject *msg_cb;",
      "447:     PyObject *keylog_filename;",
      "448:     BIO *keylog_bio;",
      "450: } PySSLContext;",
      "452: typedef struct {",
      "",
      "[Removed Lines]",
      "446: #ifdef HAVE_OPENSSL_KEYLOG",
      "449: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "652:         }",
      "654:         switch (verify_code) {",
      "657:         case X509_V_ERR_HOSTNAME_MISMATCH:",
      "658:             verify_obj = PyUnicode_FromFormat(",
      "659:                 \"Hostname mismatch, certificate is not valid for '%S'.\",",
      "660:                 sslsock->server_hostname",
      "661:             );",
      "662:             break;",
      "665:         case X509_V_ERR_IP_ADDRESS_MISMATCH:",
      "666:             verify_obj = PyUnicode_FromFormat(",
      "667:                 \"IP address mismatch, certificate is not valid for '%S'.\",",
      "668:                 sslsock->server_hostname",
      "669:             );",
      "670:             break;",
      "672:         default:",
      "673:             verify_str = X509_verify_cert_error_string(verify_code);",
      "674:             if (verify_str != NULL) {",
      "",
      "[Removed Lines]",
      "655: #ifdef X509_V_ERR_HOSTNAME_MISMATCH",
      "663: #endif",
      "664: #ifdef X509_V_ERR_IP_ADDRESS_MISMATCH",
      "671: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1995:     return NULL;",
      "1996: }",
      "1999: static PyObject *",
      "2000: cipher_to_dict(const SSL_CIPHER *cipher)",
      "2001: {",
      "",
      "[Removed Lines]",
      "1998: #if OPENSSL_VERSION_NUMBER >= 0x10002000UL",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "2004:     unsigned long cipher_id;",
      "2005:     int alg_bits, strength_bits, len;",
      "2006:     char buf[512] = {0};",
      "2008:     int aead, nid;",
      "2009:     const char *skcipher = NULL, *digest = NULL, *kx = NULL, *auth = NULL;",
      "2013:     cipher_name = SSL_CIPHER_get_name(cipher);",
      "",
      "[Removed Lines]",
      "2007: #if OPENSSL_VERSION_1_1",
      "2010: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "2020:         buf[len-1] = '\\0';",
      "2021:     strength_bits = SSL_CIPHER_get_bits(cipher, &alg_bits);",
      "2024:     aead = SSL_CIPHER_is_aead(cipher);",
      "2025:     nid = SSL_CIPHER_get_cipher_nid(cipher);",
      "2026:     skcipher = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;",
      "",
      "[Removed Lines]",
      "2023: #if OPENSSL_VERSION_1_1",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "2030:     kx = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;",
      "2031:     nid = SSL_CIPHER_get_auth_nid(cipher);",
      "2032:     auth = nid != NID_undef ? OBJ_nid2ln(nid) : NULL;",
      "2035:     return Py_BuildValue(",
      "2036:         \"{sksssssssisi\"",
      "2038:         \"sOssssssss\"",
      "2040:         \"}\",",
      "2041:         \"id\", cipher_id,",
      "2042:         \"name\", cipher_name,",
      "",
      "[Removed Lines]",
      "2033: #endif",
      "2037: #if OPENSSL_VERSION_1_1",
      "2039: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "2044:         \"description\", buf,",
      "2045:         \"strength_bits\", strength_bits,",
      "2046:         \"alg_bits\", alg_bits",
      "2048:         ,\"aead\", aead ? Py_True : Py_False,",
      "2049:         \"symmetric\", skcipher,",
      "2050:         \"digest\", digest,",
      "2051:         \"kea\", kx,",
      "2052:         \"auth\", auth",
      "2054:        );",
      "2055: }",
      "2059: _ssl._SSLSocket.shared_ciphers",
      "",
      "[Removed Lines]",
      "2047: #if OPENSSL_VERSION_1_1",
      "2053: #endif",
      "2056: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "2124:     return PyUnicode_FromString(version);",
      "2125: }",
      "2150: _ssl._SSLSocket.selected_alpn_protocol",
      "",
      "[Removed Lines]",
      "2127: #if HAVE_NPN",
      "2129: _ssl._SSLSocket.selected_npn_protocol",
      "2132: static PyObject *",
      "2133: _ssl__SSLSocket_selected_npn_protocol_impl(PySSLSocket *self)",
      "2135: {",
      "2136:     const unsigned char *out;",
      "2137:     unsigned int outlen;",
      "2139:     SSL_get0_next_proto_negotiated(self->ssl,",
      "2140:                                    &out, &outlen);",
      "2142:     if (out == NULL)",
      "2143:         Py_RETURN_NONE;",
      "2144:     return PyUnicode_FromStringAndSize((char *)out, outlen);",
      "2145: }",
      "2146: #endif",
      "2148: #if HAVE_ALPN",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "2163:         Py_RETURN_NONE;",
      "2164:     return PyUnicode_FromStringAndSize((char *)out, outlen);",
      "2165: }",
      "2169: _ssl._SSLSocket.compression",
      "",
      "[Removed Lines]",
      "2166: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "2200:                                    void *closure) {",
      "2202:     if (PyObject_TypeCheck(value, PySSLContext_Type)) {",
      "2208:         Py_INCREF(value);",
      "2209:         Py_SETREF(self->ctx, (PySSLContext *)value);",
      "2210:         SSL_set_SSL_CTX(self->ssl, self->ctx->ctx);",
      "",
      "[Removed Lines]",
      "2203: #if !HAVE_SNI",
      "2204:         PyErr_SetString(PyExc_NotImplementedError, \"setting a socket's \"",
      "2205:                         \"context is not supported by your OpenSSL library\");",
      "2206:         return -1;",
      "2207: #else",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "2213:             self->ssl,",
      "2214:             self->ctx->msg_cb ? _PySSL_msg_callback : NULL",
      "2215:         );",
      "2217:     } else {",
      "2218:         PyErr_SetString(PyExc_TypeError, \"The value must be a SSLContext\");",
      "2219:         return -1;",
      "",
      "[Removed Lines]",
      "2216: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "2840: #endif",
      "2841: }",
      "2845: static SSL_SESSION*",
      "2846: _ssl_session_dup(SSL_SESSION *session) {",
      "2847:     SSL_SESSION *newsession = NULL;",
      "",
      "[Removed Lines]",
      "2843: #ifdef OPENSSL_VERSION_1_1",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "2882:     }",
      "2883:     return NULL;",
      "2884: }",
      "2887: static PyObject *",
      "2888: PySSL_get_session(PySSLSocket *self, void *closure) {",
      "",
      "[Removed Lines]",
      "2885: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "2891:     PySSLSession *pysess;",
      "2892:     SSL_SESSION *session;",
      "",
      "[Removed Lines]",
      "2894: #ifdef OPENSSL_VERSION_1_1",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "2901:     if ((session = _ssl_session_dup(session)) == NULL) {",
      "2902:         return NULL;",
      "2903:     }",
      "2905:     session = SSL_get1_session(self->ssl);",
      "2906:     if (session == NULL) {",
      "2907:         Py_RETURN_NONE;",
      "2908:     }",
      "2910:     pysess = PyObject_GC_New(PySSLSession, PySSLSession_Type);",
      "2911:     if (pysess == NULL) {",
      "2912:         SSL_SESSION_free(session);",
      "",
      "[Removed Lines]",
      "2904: #else",
      "2909: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "2925:                              void *closure)",
      "2926:                               {",
      "2927:     PySSLSession *pysess;",
      "2929:     SSL_SESSION *session;",
      "2931:     int result;",
      "2933:     if (!PySSLSession_Check(value)) {",
      "",
      "[Removed Lines]",
      "2928: #ifdef OPENSSL_VERSION_1_1",
      "2930: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "2951:                         \"Cannot set session after handshake.\");",
      "2952:         return -1;",
      "2953:     }",
      "2956:     if ((session = _ssl_session_dup(pysess->session)) == NULL) {",
      "2957:         return -1;",
      "",
      "[Removed Lines]",
      "2954: #ifdef OPENSSL_VERSION_1_1",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "2959:     result = SSL_set_session(self->ssl, session);",
      "2961:     SSL_SESSION_free(session);",
      "2965:     if (result == 0) {",
      "2966:         _setSSLError(NULL, 0, __FILE__, __LINE__);",
      "2967:         return -1;",
      "",
      "[Removed Lines]",
      "2962: #else",
      "2963:     result = SSL_set_session(self->ssl, pysess->session);",
      "2964: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "3012:     _SSL__SSLSOCKET_CIPHER_METHODDEF",
      "3013:     _SSL__SSLSOCKET_SHARED_CIPHERS_METHODDEF",
      "3014:     _SSL__SSLSOCKET_VERSION_METHODDEF",
      "3016:     _SSL__SSLSOCKET_SELECTED_ALPN_PROTOCOL_METHODDEF",
      "3017:     _SSL__SSLSOCKET_COMPRESSION_METHODDEF",
      "3018:     _SSL__SSLSOCKET_SHUTDOWN_METHODDEF",
      "",
      "[Removed Lines]",
      "3015:     _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 26 ---",
      "[Context before]",
      "3089:     SSL_CTX *ctx = NULL;",
      "3090:     X509_VERIFY_PARAM *params;",
      "3091:     int result;",
      "3096:     PySSL_BEGIN_ALLOW_THREADS",
      "3097:     switch(proto_version) {",
      "",
      "[Removed Lines]",
      "3092: #if defined(SSL_MODE_RELEASE_BUFFERS)",
      "3093:     unsigned long libver;",
      "3094: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 27 ---",
      "[Context before]",
      "3156:     self->hostflags = X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS;",
      "3157:     self->protocol = proto_version;",
      "3158:     self->msg_cb = NULL;",
      "3160:     self->keylog_filename = NULL;",
      "3161:     self->keylog_bio = NULL;",
      "3167:     self->alpn_protocols = NULL;",
      "3170:     self->set_sni_cb = NULL;",
      "3173:     if (proto_version == PY_SSL_VERSION_TLS_CLIENT) {",
      "3174:         self->check_hostname = 1;",
      "",
      "[Removed Lines]",
      "3159: #ifdef HAVE_OPENSSL_KEYLOG",
      "3162: #endif",
      "3163: #if HAVE_NPN",
      "3164:     self->npn_protocols = NULL;",
      "3165: #endif",
      "3166: #if HAVE_ALPN",
      "3168: #endif",
      "3169: #ifndef OPENSSL_NO_TLSEXT",
      "3171: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 28 ---",
      "[Context before]",
      "3230:         return NULL;",
      "3231:     }",
      "3265: #define SID_CTX \"Python\"",
      "3266:     SSL_CTX_set_session_id_context(self->ctx, (const unsigned char *) SID_CTX,",
      "",
      "[Removed Lines]",
      "3233: #if defined(SSL_MODE_RELEASE_BUFFERS)",
      "3235:        usage for no cost at all. However, don't do this for OpenSSL versions",
      "3236:        between 1.0.1 and 1.0.1h or 1.0.0 and 1.0.0m, which are affected by CVE",
      "3237:        2014-0198. I can't find exactly which beta fixed this CVE, so be",
      "3238:        conservative and assume it wasn't fixed until release. We do this check",
      "3239:        at runtime to avoid problems from the dynamic linker.",
      "3241:     libver = OpenSSL_version_num();",
      "3242:     if (!(libver >= 0x10001000UL && libver < 0x1000108fUL) &&",
      "3243:         !(libver >= 0x10000000UL && libver < 0x100000dfUL)) {",
      "3244:         SSL_CTX_set_mode(self->ctx, SSL_MODE_RELEASE_BUFFERS);",
      "3245:     }",
      "3246: #endif",
      "3249: #if !defined(OPENSSL_NO_ECDH) && !defined(OPENSSL_VERSION_1_1)",
      "3251:        prime256v1 by default.  This is Apache mod_ssl's initialization",
      "3252:        policy, so we should be safe. OpenSSL 1.1 has it enabled by default.",
      "3254: #if defined(SSL_CTX_set_ecdh_auto)",
      "3255:     SSL_CTX_set_ecdh_auto(self->ctx, 1);",
      "3256: #else",
      "3257:     {",
      "3258:         EC_KEY *key = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);",
      "3259:         SSL_CTX_set_tmp_ecdh(self->ctx, key);",
      "3260:         EC_KEY_free(key);",
      "3261:     }",
      "3262: #endif",
      "3263: #endif",
      "",
      "[Added Lines]",
      "3007:     SSL_CTX_set_mode(self->ctx, SSL_MODE_RELEASE_BUFFERS);",
      "",
      "---------------",
      "--- Hunk 29 ---",
      "[Context before]",
      "3268: #undef SID_CTX",
      "3270:     params = SSL_CTX_get0_param(self->ctx);",
      "3274:     X509_VERIFY_PARAM_set_flags(params, X509_V_FLAG_TRUSTED_FIRST);",
      "3276:     X509_VERIFY_PARAM_set_hostflags(params, self->hostflags);",
      "3278: #ifdef TLS1_3_VERSION",
      "",
      "[Removed Lines]",
      "3271: #ifdef X509_V_FLAG_TRUSTED_FIRST",
      "3275: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 30 ---",
      "[Context before]",
      "3286: static int",
      "3287: context_traverse(PySSLContext *self, visitproc visit, void *arg)",
      "3288: {",
      "3290:     Py_VISIT(self->set_sni_cb);",
      "3292:     Py_VISIT(self->msg_cb);",
      "3293:     return 0;",
      "3294: }",
      "",
      "[Removed Lines]",
      "3289: #ifndef OPENSSL_NO_TLSEXT",
      "3291: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 31 ---",
      "[Context before]",
      "3296: static int",
      "3297: context_clear(PySSLContext *self)",
      "3298: {",
      "3300:     Py_CLEAR(self->set_sni_cb);",
      "3302:     Py_CLEAR(self->msg_cb);",
      "3304:     Py_CLEAR(self->keylog_filename);",
      "3305:     if (self->keylog_bio != NULL) {",
      "3306:         PySSL_BEGIN_ALLOW_THREADS",
      "",
      "[Removed Lines]",
      "3299: #ifndef OPENSSL_NO_TLSEXT",
      "3301: #endif",
      "3303: #ifdef HAVE_OPENSSL_KEYLOG",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 32 ---",
      "[Context before]",
      "3308:         PySSL_END_ALLOW_THREADS",
      "3309:         self->keylog_bio = NULL;",
      "3310:     }",
      "3312:     return 0;",
      "3313: }",
      "",
      "[Removed Lines]",
      "3311: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 33 ---",
      "[Context before]",
      "3320:     PyObject_GC_UnTrack(self);",
      "3321:     context_clear(self);",
      "3322:     SSL_CTX_free(self->ctx);",
      "3329:     Py_TYPE(self)->tp_free(self);",
      "3330:     Py_DECREF(tp);",
      "3331: }",
      "",
      "[Removed Lines]",
      "3323: #if HAVE_NPN",
      "3324:     PyMem_Free(self->npn_protocols);",
      "3325: #endif",
      "3326: #if HAVE_ALPN",
      "3327:     PyMem_Free(self->alpn_protocols);",
      "3328: #endif",
      "",
      "[Added Lines]",
      "3059:     PyMem_FREE(self->alpn_protocols);",
      "",
      "---------------",
      "--- Hunk 34 ---",
      "[Context before]",
      "3353:     Py_RETURN_NONE;",
      "3354: }",
      "3358: _ssl._SSLContext.get_ciphers",
      "",
      "[Removed Lines]",
      "3356: #if OPENSSL_VERSION_NUMBER >= 0x10002000UL",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 35 ---",
      "[Context before]",
      "3396:     return result;",
      "3398: }",
      "3403: static int",
      "3404: do_protocol_selection(int alpn, unsigned char **out, unsigned char *outlen,",
      "3405:                       const unsigned char *server_protocols, unsigned int server_protocols_len,",
      "",
      "[Removed Lines]",
      "3399: #endif",
      "3402: #if HAVE_NPN || HAVE_ALPN",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 36 ---",
      "[Context before]",
      "3424:     return SSL_TLSEXT_ERR_OK;",
      "3425: }",
      "3497: static int",
      "3498: _selectALPN_cb(SSL *s,",
      "3499:               const unsigned char **out, unsigned char *outlen,",
      "",
      "[Removed Lines]",
      "3426: #endif",
      "3428: #if HAVE_NPN",
      "3430: static int",
      "3431: _advertiseNPN_cb(SSL *s,",
      "3432:                  const unsigned char **data, unsigned int *len,",
      "3433:                  void *args)",
      "3434: {",
      "3435:     PySSLContext *ssl_ctx = (PySSLContext *) args;",
      "3437:     if (ssl_ctx->npn_protocols == NULL) {",
      "3440:     } else {",
      "3443:     }",
      "3445:     return SSL_TLSEXT_ERR_OK;",
      "3446: }",
      "3448: static int",
      "3449: _selectNPN_cb(SSL *s,",
      "3450:               unsigned char **out, unsigned char *outlen,",
      "3451:               const unsigned char *server, unsigned int server_len,",
      "3452:               void *args)",
      "3453: {",
      "3454:     PySSLContext *ctx = (PySSLContext *)args;",
      "3455:     return do_protocol_selection(0, out, outlen, server, server_len,",
      "3456:                                  ctx->npn_protocols, ctx->npn_protocols_len);",
      "3457: }",
      "3458: #endif",
      "3461: _ssl._SSLContext._set_npn_protocols",
      "3462:     protos: Py_buffer",
      "3463:     /",
      "3466: static PyObject *",
      "3467: _ssl__SSLContext__set_npn_protocols_impl(PySSLContext *self,",
      "3468:                                          Py_buffer *protos)",
      "3470: {",
      "3471: #if HAVE_NPN",
      "3472:     PyMem_Free(self->npn_protocols);",
      "3473:     self->npn_protocols = PyMem_Malloc(protos->len);",
      "3474:     if (self->npn_protocols == NULL)",
      "3475:         return PyErr_NoMemory();",
      "3476:     memcpy(self->npn_protocols, protos->buf, protos->len);",
      "3477:     self->npn_protocols_len = (int) protos->len;",
      "3481:     SSL_CTX_set_next_protos_advertised_cb(self->ctx,",
      "3482:                                           _advertiseNPN_cb,",
      "3483:                                           self);",
      "3484:     SSL_CTX_set_next_proto_select_cb(self->ctx,",
      "3485:                                      _selectNPN_cb,",
      "3486:                                      self);",
      "3488:     Py_RETURN_NONE;",
      "3489: #else",
      "3490:     PyErr_SetString(PyExc_NotImplementedError,",
      "3491:                     \"The NPN extension requires OpenSSL 1.0.1 or later.\");",
      "3492:     return NULL;",
      "3493: #endif",
      "3494: }",
      "3496: #if HAVE_ALPN",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 37 ---",
      "[Context before]",
      "3505:                                  ctx->alpn_protocols, ctx->alpn_protocols_len,",
      "3506:                                  client_protocols, client_protocols_len);",
      "3507: }",
      "3511: _ssl._SSLContext._set_alpn_protocols",
      "",
      "[Removed Lines]",
      "3508: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 38 ---",
      "[Context before]",
      "3518:                                           Py_buffer *protos)",
      "3520: {",
      "3522:     if ((size_t)protos->len > UINT_MAX) {",
      "3523:         PyErr_Format(PyExc_OverflowError,",
      "3524:             \"protocols longer than %u bytes\", UINT_MAX);",
      "",
      "[Removed Lines]",
      "3521: #if HAVE_ALPN",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 39 ---",
      "[Context before]",
      "3537:     SSL_CTX_set_alpn_select_cb(self->ctx, _selectALPN_cb, self);",
      "3539:     Py_RETURN_NONE;",
      "3545: }",
      "3547: static PyObject *",
      "",
      "[Removed Lines]",
      "3540: #else",
      "3541:     PyErr_SetString(PyExc_NotImplementedError,",
      "3542:                     \"The ALPN extension requires OpenSSL 1.0.2 or later.\");",
      "3543:     return NULL;",
      "3544: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 40 ---",
      "[Context before]",
      "3617: }",
      "3623: static int",
      "3624: set_min_max_proto_version(PySSLContext *self, PyObject *arg, int what)",
      "3625: {",
      "",
      "[Removed Lines]",
      "3620: #if defined(SSL_CTRL_GET_MAX_PROTO_VERSION)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 41 ---",
      "[Context before]",
      "3714: {",
      "3715:     return set_min_max_proto_version(self, arg, 1);",
      "3716: }",
      "3720: static PyObject *",
      "3721: get_num_tickets(PySSLContext *self, void *c)",
      "3722: {",
      "",
      "[Removed Lines]",
      "3719: #if (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "",
      "[Added Lines]",
      "3366: #ifdef TLS1_3_VERSION",
      "",
      "---------------",
      "--- Hunk 42 ---",
      "[Context before]",
      "3748: PyDoc_STRVAR(PySSLContext_num_tickets_doc,",
      "3749: \"Control the number of TLSv1.3 session tickets\");",
      "3753: static PyObject *",
      "3754: get_security_level(PySSLContext *self, void *c)",
      "3755: {",
      "3756:     return PyLong_FromLong(SSL_CTX_get_security_level(self->ctx));",
      "3757: }",
      "3758: PyDoc_STRVAR(PySSLContext_security_level_doc, \"The current security level\");",
      "3761: static PyObject *",
      "3762: get_options(PySSLContext *self, void *c)",
      "",
      "[Removed Lines]",
      "3752: #if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 43 ---",
      "[Context before]",
      "3774:     clear = opts & ~new_opts;",
      "3775:     set = ~opts & new_opts;",
      "3776:     if (clear) {",
      "3778:         SSL_CTX_clear_options(self->ctx, clear);",
      "3784:     }",
      "3785:     if (set)",
      "3786:         SSL_CTX_set_options(self->ctx, set);",
      "",
      "[Removed Lines]",
      "3777: #ifdef HAVE_SSL_CTX_CLEAR_OPTIONS",
      "3779: #else",
      "3780:         PyErr_SetString(PyExc_ValueError,",
      "3781:                         \"can't clear options before OpenSSL 0.9.8m\");",
      "3782:         return -1;",
      "3783: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 44 ---",
      "[Context before]",
      "4468:     Py_RETURN_NONE;",
      "4469: }",
      "4473: _ssl._SSLContext.set_ecdh_curve",
      "4474:     name: object",
      "",
      "[Removed Lines]",
      "4471: #ifndef OPENSSL_NO_ECDH",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 45 ---",
      "[Context before]",
      "4503:     EC_KEY_free(key);",
      "4504:     Py_RETURN_NONE;",
      "4505: }",
      "4509: static int",
      "4510: _servername_callback(SSL *s, int *al, void *args)",
      "4511: {",
      "",
      "[Removed Lines]",
      "4506: #endif",
      "4508: #if HAVE_SNI && !defined(OPENSSL_NO_TLSEXT)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 46 ---",
      "[Context before]",
      "4609:     PyGILState_Release(gstate);",
      "4610:     return ret;",
      "4611: }",
      "4614: static PyObject *",
      "4615: get_sni_callback(PySSLContext *self, void *c)",
      "",
      "[Removed Lines]",
      "4612: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 47 ---",
      "[Context before]",
      "4630:                         \"sni_callback cannot be set on TLS_CLIENT context\");",
      "4631:         return -1;",
      "4632:     }",
      "4634:     Py_CLEAR(self->set_sni_cb);",
      "4635:     if (arg == Py_None) {",
      "4636:         SSL_CTX_set_tlsext_servername_callback(self->ctx, NULL);",
      "",
      "[Removed Lines]",
      "4633: #if HAVE_SNI && !defined(OPENSSL_NO_TLSEXT)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 48 ---",
      "[Context before]",
      "4648:         SSL_CTX_set_tlsext_servername_arg(self->ctx, self);",
      "4649:     }",
      "4650:     return 0;",
      "4658: }",
      "4660: PyDoc_STRVAR(PySSLContext_sni_callback_doc,",
      "",
      "[Removed Lines]",
      "4651: #else",
      "4652:     PyErr_SetString(PyExc_NotImplementedError,",
      "4653:                     \"The TLS extension servername callback, \"",
      "4654:                     \"SSL_CTX_set_tlsext_servername_callback, \"",
      "4655:                     \"is not in the current OpenSSL library.\");",
      "4656:     return -1;",
      "4657: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 49 ---",
      "[Context before]",
      "4779:                        (setter) set_check_hostname, NULL},",
      "4780:     {\"_host_flags\", (getter) get_host_flags,",
      "4781:                     (setter) set_host_flags, NULL},",
      "4783:     {\"minimum_version\", (getter) get_minimum_version,",
      "4784:                         (setter) set_minimum_version, NULL},",
      "4785:     {\"maximum_version\", (getter) get_maximum_version,",
      "4786:                         (setter) set_maximum_version, NULL},",
      "4789:     {\"keylog_filename\", (getter) _PySSLContext_get_keylog_filename,",
      "4790:                         (setter) _PySSLContext_set_keylog_filename, NULL},",
      "4792:     {\"_msg_callback\", (getter) _PySSLContext_get_msg_callback,",
      "4793:                       (setter) _PySSLContext_set_msg_callback, NULL},",
      "4794:     {\"sni_callback\", (getter) get_sni_callback,",
      "4795:                      (setter) set_sni_callback, PySSLContext_sni_callback_doc},",
      "4797:     {\"num_tickets\", (getter) get_num_tickets,",
      "4798:                     (setter) set_num_tickets, PySSLContext_num_tickets_doc},",
      "4799: #endif",
      "",
      "[Removed Lines]",
      "4782: #if SSL_CTRL_GET_MAX_PROTO_VERSION",
      "4787: #endif",
      "4788: #ifdef HAVE_OPENSSL_KEYLOG",
      "4791: #endif",
      "4796: #if (OPENSSL_VERSION_NUMBER >= 0x10101000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "",
      "[Added Lines]",
      "4419: #ifdef TLS1_3_VERSION",
      "",
      "---------------",
      "--- Hunk 50 ---",
      "[Context before]",
      "4812:                      (setter) set_verify_flags, NULL},",
      "4813:     {\"verify_mode\", (getter) get_verify_mode,",
      "4814:                     (setter) set_verify_mode, NULL},",
      "4816:     {\"security_level\", (getter) get_security_level,",
      "4817:                        NULL, PySSLContext_security_level_doc},",
      "4820: };",
      "",
      "[Removed Lines]",
      "4815: #if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "4818: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 51 ---",
      "[Context before]",
      "4824:     _SSL__SSLCONTEXT__WRAP_BIO_METHODDEF",
      "4825:     _SSL__SSLCONTEXT_SET_CIPHERS_METHODDEF",
      "4826:     _SSL__SSLCONTEXT__SET_ALPN_PROTOCOLS_METHODDEF",
      "4828:     _SSL__SSLCONTEXT_LOAD_CERT_CHAIN_METHODDEF",
      "4829:     _SSL__SSLCONTEXT_LOAD_DH_PARAMS_METHODDEF",
      "4830:     _SSL__SSLCONTEXT_LOAD_VERIFY_LOCATIONS_METHODDEF",
      "",
      "[Removed Lines]",
      "4827:     _SSL__SSLCONTEXT__SET_NPN_PROTOCOLS_METHODDEF",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 52 ---",
      "[Context before]",
      "5281:     if (bytes == NULL)",
      "5282:         return NULL;",
      "5283:     if (pseudo) {",
      "5285:         ok = RAND_bytes((unsigned char*)PyBytes_AS_STRING(bytes), len);",
      "5289:         if (ok == 0 || ok == 1)",
      "5290:             return Py_BuildValue(\"NO\", bytes, ok == 1 ? Py_True : Py_False);",
      "5291:     }",
      "",
      "[Removed Lines]",
      "5284: #ifdef PY_OPENSSL_1_1_API",
      "5286: #else",
      "5287:         ok = RAND_pseudo_bytes((unsigned char*)PyBytes_AS_STRING(bytes), len);",
      "5288: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 53 ---",
      "[Context before]",
      "5840: };",
      "5929: static int",
      "5930: sslmodule_init_types(PyObject *module)",
      "5931: {",
      "",
      "[Removed Lines]",
      "5843: #ifdef HAVE_OPENSSL_CRYPTO_LOCK",
      "5850: static PyThread_type_lock *_ssl_locks = NULL;",
      "5852: #if OPENSSL_VERSION_NUMBER >= 0x10000000",
      "5854: static void",
      "5855: _ssl_threadid_callback(CRYPTO_THREADID *id)",
      "5856: {",
      "5857:     CRYPTO_THREADID_set_numeric(id, PyThread_get_thread_ident());",
      "5858: }",
      "5859: #else",
      "5861: static unsigned long",
      "5862: _ssl_thread_id_function (void) {",
      "5863:     return PyThread_get_thread_ident();",
      "5864: }",
      "5865: #endif",
      "5867: static void _ssl_thread_locking_function",
      "5868:     (int mode, int n, const char *file, int line) {",
      "5870:        structures. (Note that OpenSSL uses a number of global data",
      "5871:        structures that will be implicitly shared whenever multiple",
      "5872:        threads use OpenSSL.) Multi-threaded applications will",
      "5873:        crash at random if it is not set.",
      "5875:        locking_function() must be able to handle up to",
      "5876:        CRYPTO_num_locks() different mutex locks. It sets the n-th",
      "5877:        lock if mode & CRYPTO_LOCK, and releases it otherwise.",
      "5879:        file and line are the file number of the function setting the",
      "5880:        lock. They can be useful for debugging.",
      "5883:     if ((_ssl_locks == NULL) ||",
      "5884:         (n < 0) || ((unsigned)n >= _ssl_locks_count))",
      "5885:         return;",
      "5887:     if (mode & CRYPTO_LOCK) {",
      "5888:         PyThread_acquire_lock(_ssl_locks[n], 1);",
      "5889:     } else {",
      "5890:         PyThread_release_lock(_ssl_locks[n]);",
      "5891:     }",
      "5892: }",
      "5894: static int _setup_ssl_threads(void) {",
      "5896:     unsigned int i;",
      "5898:     if (_ssl_locks == NULL) {",
      "5899:         _ssl_locks_count = CRYPTO_num_locks();",
      "5900:         _ssl_locks = PyMem_Calloc(_ssl_locks_count,",
      "5901:                                   sizeof(PyThread_type_lock));",
      "5902:         if (_ssl_locks == NULL) {",
      "5903:             PyErr_NoMemory();",
      "5904:             return 0;",
      "5905:         }",
      "5906:         for (i = 0;  i < _ssl_locks_count;  i++) {",
      "5907:             _ssl_locks[i] = PyThread_allocate_lock();",
      "5908:             if (_ssl_locks[i] == NULL) {",
      "5909:                 unsigned int j;",
      "5910:                 for (j = 0;  j < i;  j++) {",
      "5911:                     PyThread_free_lock(_ssl_locks[j]);",
      "5912:                 }",
      "5913:                 PyMem_Free(_ssl_locks);",
      "5914:                 return 0;",
      "5915:             }",
      "5916:         }",
      "5917:         CRYPTO_set_locking_callback(_ssl_thread_locking_function);",
      "5918: #if OPENSSL_VERSION_NUMBER >= 0x10000000",
      "5919:         CRYPTO_THREADID_set_callback(_ssl_threadid_callback);",
      "5920: #else",
      "5921:         CRYPTO_set_id_callback(_ssl_thread_id_function);",
      "5922: #endif",
      "5923:     }",
      "5924:     return 1;",
      "5925: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 54 ---",
      "[Context before]",
      "6205:                             X509_V_FLAG_X509_STRICT);",
      "6206:     PyModule_AddIntConstant(m, \"VERIFY_ALLOW_PROXY_CERTS\",",
      "6207:                             X509_V_FLAG_ALLOW_PROXY_CERTS);",
      "6209:     PyModule_AddIntConstant(m, \"VERIFY_X509_TRUSTED_FIRST\",",
      "6210:                             X509_V_FLAG_TRUSTED_FIRST);",
      "",
      "[Removed Lines]",
      "6208: #ifdef X509_V_FLAG_TRUSTED_FIRST",
      "6211: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 55 ---",
      "[Context before]",
      "6365:         PyModule_AddObject((m), (key), bool_obj); \\",
      "6366:     } while (0)",
      "6369:     addbool(m, \"HAS_SNI\", 1);",
      "6374:     addbool(m, \"HAS_TLS_UNIQUE\", 1);",
      "6377:     addbool(m, \"HAS_ECDH\", 1);",
      "6385:     addbool(m, \"HAS_NPN\", 0);",
      "6389:     addbool(m, \"HAS_ALPN\", 1);",
      "6394: #if defined(SSL2_VERSION) && !defined(OPENSSL_NO_SSL2)",
      "6395:     addbool(m, \"HAS_SSLv2\", 1);",
      "",
      "[Removed Lines]",
      "6368: #if HAVE_SNI",
      "6370: #else",
      "6371:     addbool(m, \"HAS_SNI\", 0);",
      "6372: #endif",
      "6376: #ifndef OPENSSL_NO_ECDH",
      "6378: #else",
      "6379:     addbool(m, \"HAS_ECDH\", 0);",
      "6380: #endif",
      "6382: #if HAVE_NPN",
      "6383:     addbool(m, \"HAS_NPN\", 1);",
      "6384: #else",
      "6386: #endif",
      "6388: #if HAVE_ALPN",
      "6390: #else",
      "6391:     addbool(m, \"HAS_ALPN\", 0);",
      "6392: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 56 ---",
      "[Context before]",
      "6430:     return 0;",
      "6431: }",
      "6456: PyDoc_STRVAR(module_doc,",
      "6457: \"Implementation module for SSL socket operations.  See the socket module\\n\\",
      "6458: for documentation.\");",
      "",
      "[Removed Lines]",
      "6433: static int",
      "6434: sslmodule_legacy(PyObject *module)",
      "6435: {",
      "6436: #ifndef OPENSSL_VERSION_1_1",
      "6438:     OPENSSL_add_all_algorithms_noconf();",
      "6440:     SSL_load_error_strings();",
      "6441:     SSL_library_init();",
      "6442: #endif",
      "6444: #ifdef HAVE_OPENSSL_CRYPTO_LOCK",
      "6446:     if (!_setup_ssl_threads()) {",
      "6447:         return 0;",
      "6448:     }",
      "6449: #elif OPENSSL_VERSION_1_1",
      "6451:     _ssl_locks_count++;",
      "6452: #endif",
      "6453:     return 0;",
      "6454: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 57 ---",
      "[Context before]",
      "6491:         return NULL;",
      "6492:     if (sslmodule_init_versioninfo(m) != 0)",
      "6493:         return NULL;",
      "6497:     return m;",
      "6498: }",
      "",
      "[Removed Lines]",
      "6494:     if (sslmodule_legacy(m) != 0)",
      "6495:         return NULL;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Modules/_ssl/debughelpers.c||Modules/_ssl/debughelpers.c": [
      "File: Modules/_ssl/debughelpers.c -> Modules/_ssl/debughelpers.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "114:     return 0;",
      "115: }",
      "119: static void",
      "120: _PySSL_keylog_callback(const SSL *ssl, const char *line)",
      "121: {",
      "",
      "[Removed Lines]",
      "117: #ifdef HAVE_OPENSSL_KEYLOG",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "219:     SSL_CTX_set_keylog_callback(self->ctx, _PySSL_keylog_callback);",
      "220:     return 0;",
      "221: }",
      "",
      "[Removed Lines]",
      "223: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Modules/clinic/_hashopenssl.c.h||Modules/clinic/_hashopenssl.c.h": [
      "File: Modules/clinic/_hashopenssl.c.h -> Modules/clinic/_hashopenssl.c.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "950:     return return_value;",
      "951: }",
      "955: PyDoc_STRVAR(_hashlib_scrypt__doc__,",
      "956: \"scrypt($module, /, password, *, salt=None, n=None, r=None, p=None,\\n\"",
      "",
      "[Removed Lines]",
      "953: #if (OPENSSL_VERSION_NUMBER > 0x10100000L && !defined(OPENSSL_NO_SCRYPT) && !defined(LIBRESSL_VERSION_NUMBER))",
      "",
      "[Added Lines]",
      "953: #if defined(PY_OPENSSL_HAS_SCRYPT)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1275:     return _hashlib_HMAC_hexdigest_impl(self);",
      "1276: }",
      "1280: PyDoc_STRVAR(_hashlib_get_fips_mode__doc__,",
      "1281: \"get_fips_mode($module, /)\\n\"",
      "1282: \"--\\n\"",
      "",
      "[Removed Lines]",
      "1278: #if !defined(LIBRESSL_VERSION_NUMBER)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1389: #ifndef _HASHLIB_SCRYPT_METHODDEF",
      "1390:     #define _HASHLIB_SCRYPT_METHODDEF",
      "",
      "[Removed Lines]",
      "1393: #ifndef _HASHLIB_GET_FIPS_MODE_METHODDEF",
      "1394:     #define _HASHLIB_GET_FIPS_MODE_METHODDEF",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Modules/clinic/_ssl.c.h||Modules/clinic/_ssl.c.h": [
      "File: Modules/clinic/_ssl.c.h -> Modules/clinic/_ssl.c.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "139:     return _ssl__SSLSocket_version_impl(self);",
      "140: }",
      "165: PyDoc_STRVAR(_ssl__SSLSocket_selected_alpn_protocol__doc__,",
      "166: \"selected_alpn_protocol($self, /)\\n\"",
      "167: \"--\\n\"",
      "",
      "[Removed Lines]",
      "142: #if (HAVE_NPN)",
      "144: PyDoc_STRVAR(_ssl__SSLSocket_selected_npn_protocol__doc__,",
      "145: \"selected_npn_protocol($self, /)\\n\"",
      "146: \"--\\n\"",
      "147: \"\\n\");",
      "149: #define _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF    \\",
      "150:     {\"selected_npn_protocol\", (PyCFunction)_ssl__SSLSocket_selected_npn_protocol, METH_NOARGS, _ssl__SSLSocket_selected_npn_protocol__doc__},",
      "152: static PyObject *",
      "153: _ssl__SSLSocket_selected_npn_protocol_impl(PySSLSocket *self);",
      "155: static PyObject *",
      "156: _ssl__SSLSocket_selected_npn_protocol(PySSLSocket *self, PyObject *Py_UNUSED(ignored))",
      "157: {",
      "158:     return _ssl__SSLSocket_selected_npn_protocol_impl(self);",
      "159: }",
      "163: #if (HAVE_ALPN)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "452:     return return_value;",
      "453: }",
      "457: PyDoc_STRVAR(_ssl__SSLContext_get_ciphers__doc__,",
      "458: \"get_ciphers($self, /)\\n\"",
      "459: \"--\\n\"",
      "",
      "[Removed Lines]",
      "455: #if (OPENSSL_VERSION_NUMBER >= 0x10002000UL)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "471:     return _ssl__SSLContext_get_ciphers_impl(self);",
      "472: }",
      "512: PyDoc_STRVAR(_ssl__SSLContext__set_alpn_protocols__doc__,",
      "513: \"_set_alpn_protocols($self, protos, /)\\n\"",
      "514: \"--\\n\"",
      "",
      "[Removed Lines]",
      "476: PyDoc_STRVAR(_ssl__SSLContext__set_npn_protocols__doc__,",
      "477: \"_set_npn_protocols($self, protos, /)\\n\"",
      "478: \"--\\n\"",
      "479: \"\\n\");",
      "481: #define _SSL__SSLCONTEXT__SET_NPN_PROTOCOLS_METHODDEF    \\",
      "482:     {\"_set_npn_protocols\", (PyCFunction)_ssl__SSLContext__set_npn_protocols, METH_O, _ssl__SSLContext__set_npn_protocols__doc__},",
      "484: static PyObject *",
      "485: _ssl__SSLContext__set_npn_protocols_impl(PySSLContext *self,",
      "486:                                          Py_buffer *protos);",
      "488: static PyObject *",
      "489: _ssl__SSLContext__set_npn_protocols(PySSLContext *self, PyObject *arg)",
      "490: {",
      "491:     PyObject *return_value = NULL;",
      "492:     Py_buffer protos = {NULL, NULL};",
      "494:     if (PyObject_GetBuffer(arg, &protos, PyBUF_SIMPLE) != 0) {",
      "495:         goto exit;",
      "496:     }",
      "497:     if (!PyBuffer_IsContiguous(&protos, 'C')) {",
      "498:         _PyArg_BadArgument(\"_set_npn_protocols\", \"argument\", \"contiguous buffer\", arg);",
      "499:         goto exit;",
      "500:     }",
      "501:     return_value = _ssl__SSLContext__set_npn_protocols_impl(self, &protos);",
      "503: exit:",
      "505:     if (protos.obj) {",
      "506:        PyBuffer_Release(&protos);",
      "507:     }",
      "509:     return return_value;",
      "510: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "829:     return _ssl__SSLContext_set_default_verify_paths_impl(self);",
      "830: }",
      "834: PyDoc_STRVAR(_ssl__SSLContext_set_ecdh_curve__doc__,",
      "835: \"set_ecdh_curve($self, name, /)\\n\"",
      "836: \"--\\n\"",
      "",
      "[Removed Lines]",
      "832: #if !defined(OPENSSL_NO_ECDH)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1439: #ifndef _SSL_RAND_EGD_METHODDEF",
      "1440:     #define _SSL_RAND_EGD_METHODDEF",
      "",
      "[Removed Lines]",
      "1423: #ifndef _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF",
      "1424:     #define _SSL__SSLSOCKET_SELECTED_NPN_PROTOCOL_METHODDEF",
      "1427: #ifndef _SSL__SSLSOCKET_SELECTED_ALPN_PROTOCOL_METHODDEF",
      "1428:     #define _SSL__SSLSOCKET_SELECTED_ALPN_PROTOCOL_METHODDEF",
      "1431: #ifndef _SSL__SSLCONTEXT_GET_CIPHERS_METHODDEF",
      "1432:     #define _SSL__SSLCONTEXT_GET_CIPHERS_METHODDEF",
      "1435: #ifndef _SSL__SSLCONTEXT_SET_ECDH_CURVE_METHODDEF",
      "1436:     #define _SSL__SSLCONTEXT_SET_ECDH_CURVE_METHODDEF",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py": [
      "File: Tools/ssl/multissltests.py -> Tools/ssl/multissltests.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "43: log = logging.getLogger(\"multissl\")",
      "45: OPENSSL_OLD_VERSIONS = [",
      "48: ]",
      "50: OPENSSL_RECENT_VERSIONS = [",
      "51:     \"1.1.1k\",",
      "53: ]",
      "55: LIBRESSL_OLD_VERSIONS = [",
      "57: ]",
      "59: LIBRESSL_RECENT_VERSIONS = [",
      "61: ]",
      "63: # store files in ../multissl",
      "",
      "[Removed Lines]",
      "46:     \"1.0.2u\",",
      "47:     \"1.1.0l\",",
      "52:     # \"3.0.0-alpha14\"",
      "56:     \"2.9.2\",",
      "60:     \"3.2.4\",",
      "",
      "[Added Lines]",
      "50:     \"3.0.0-alpha14\"",
      "",
      "---------------"
    ],
    "configure.ac||configure.ac": [
      "File: configure.ac -> configure.ac",
      "--- Hunk 1 ---",
      "[Context before]",
      "5781: # Check for usable OpenSSL",
      "5782: AX_CHECK_OPENSSL([have_openssl=yes],[have_openssl=no])",
      "5820: # rpath to libssl and libcrypto",
      "5821: AC_MSG_CHECKING(for --with-openssl-rpath)",
      "5822: AC_ARG_WITH(openssl-rpath,",
      "",
      "[Removed Lines]",
      "5784: if test \"$have_openssl\" = yes; then",
      "5785:     AC_MSG_CHECKING([for X509_VERIFY_PARAM_set1_host in libssl])",
      "5787:     save_LIBS=\"$LIBS\"",
      "5788:     save_LDFLAGS=\"$LDFLAGS\"",
      "5789:     save_CPPFLAGS=\"$CPPFLAGS\"",
      "5790:     LDFLAGS=\"$LDFLAGS $OPENSSL_LDFLAGS\"",
      "5791:     LIBS=\"$OPENSSL_LIBS $LIBS\"",
      "5792:     CPPFLAGS=\"$OPENSSL_INCLUDES $CPPFLAGS\"",
      "5794:     AC_LINK_IFELSE([AC_LANG_PROGRAM([",
      "5795:         [#include <openssl/x509_vfy.h>]",
      "5796:     ], [",
      "5797:         [X509_VERIFY_PARAM *p = X509_VERIFY_PARAM_new();]",
      "5798:         [X509_VERIFY_PARAM_set1_host(p, \"localhost\", 0);]",
      "5799:         [X509_VERIFY_PARAM_set1_ip_asc(p, \"127.0.0.1\");]",
      "5800:         [X509_VERIFY_PARAM_set_hostflags(p, 0);]",
      "5801:     ])",
      "5802:     ],",
      "5803:     [",
      "5804:         ac_cv_has_x509_verify_param_set1_host=yes",
      "5805:     ],",
      "5806:     [",
      "5807:         ac_cv_has_x509_verify_param_set1_host=no",
      "5808:     ])",
      "5809:     AC_MSG_RESULT($ac_cv_has_x509_verify_param_set1_host)",
      "5810:     if test \"$ac_cv_has_x509_verify_param_set1_host\" = \"yes\"; then",
      "5811:         AC_DEFINE(HAVE_X509_VERIFY_PARAM_SET1_HOST, 1,",
      "5812:         [Define if libssl has X509_VERIFY_PARAM_set1_host and related function])",
      "5813:     fi",
      "5815:     CPPFLAGS=\"$save_CPPFLAGS\"",
      "5816:     LDFLAGS=\"$save_LDFLAGS\"",
      "5817:     LIBS=\"$save_LIBS\"",
      "5818: fi",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "pyconfig.h.in||pyconfig.h.in": [
      "File: pyconfig.h.in -> pyconfig.h.in",
      "--- Hunk 1 ---",
      "[Context before]",
      "1357: #undef HAVE_WRITEV",
      "1363: #undef HAVE_ZLIB_COPY",
      "",
      "[Removed Lines]",
      "1360: #undef HAVE_X509_VERIFY_PARAM_SET1_HOST",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "setup.py||setup.py": [
      "File: setup.py -> setup.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "551:                for l in (self.missing, self.failed, self.failed_on_import)):",
      "552:             print()",
      "553:             print(\"Could not build the ssl module!\")",
      "558:             if sysconfig.get_config_var(\"OPENSSL_LDFLAGS\"):",
      "559:                 print(\"Custom linker flags may require --with-openssl-rpath=auto\")",
      "560:             print()",
      "",
      "[Removed Lines]",
      "554:             print(\"Python requires an OpenSSL 1.0.2 or 1.1 compatible \"",
      "555:                   \"libssl with X509_VERIFY_PARAM_set1_host().\")",
      "556:             print(\"LibreSSL 2.6.4 and earlier do not provide the necessary \"",
      "557:                   \"APIs, https://github.com/libressl-portable/portable/issues/381\")",
      "",
      "[Added Lines]",
      "554:             print(\"Python requires a OpenSSL 1.1.1 or newer\")",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2431:             self.missing.extend(['_ssl', '_hashlib'])",
      "2432:             return None, None",
      "2438:         )",
      "2442:         if openssl_rpath == 'auto':",
      "2443:             runtime_library_dirs = openssl_libdirs[:]",
      "",
      "[Removed Lines]",
      "2434:         # OpenSSL 1.0.2 uses Kerberos for KRB5 ciphers",
      "2435:         krb5_h = find_file(",
      "2436:             'krb5.h', self.inc_dirs,",
      "2437:             ['/usr/kerberos/include']",
      "2439:         if krb5_h:",
      "2440:             ssl_incs.extend(krb5_h)",
      "",
      "[Added Lines]",
      "2431:         self.add(Extension(",
      "2432:             '_ssl', ['_ssl.c'],",
      "2433:             include_dirs=openssl_includes,",
      "2434:             library_dirs=openssl_libdirs,",
      "2435:             libraries=openssl_libs,",
      "2436:             depends=['socketmodule.h', '_ssl/debughelpers.c'])",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2468:             # don't link OpenSSL shared libraries.",
      "2469:             openssl_extension_kwargs[\"libraries\"] = []",
      "2485:             )",
      "2489:         self.add(",
      "2490:             Extension(",
      "2491:                 '_hashlib',",
      "",
      "[Removed Lines]",
      "2471:         if config_vars.get(\"HAVE_X509_VERIFY_PARAM_SET1_HOST\"):",
      "2472:             self.add(",
      "2473:                 Extension(",
      "2474:                     '_ssl',",
      "2475:                     ['_ssl.c'],",
      "2476:                     depends=[",
      "2477:                         'socketmodule.h',",
      "2478:                         '_ssl/debughelpers.c',",
      "2479:                         '_ssl_data.h',",
      "2480:                         '_ssl_data_111.h',",
      "2481:                         '_ssl_data_300.h',",
      "2482:                     ],",
      "2484:                 )",
      "2486:         else:",
      "2487:             self.missing.append('_ssl')",
      "",
      "[Added Lines]",
      "2468:         self.add(",
      "2469:             Extension(",
      "2470:                 '_ssl',",
      "2471:                 ['_ssl.c'],",
      "2472:                 depends=['socketmodule.h', '_ssl/debughelpers.c'],",
      "2475:         )",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "dc46f4c9846ad16567ab293b405efc3ed10ab9d5",
      "candidate_info": {
        "commit_hash": "dc46f4c9846ad16567ab293b405efc3ed10ab9d5",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/dc46f4c9846ad16567ab293b405efc3ed10ab9d5",
        "files": [
          "Tools/ssl/multissltests.py"
        ],
        "message": "bpo-45007: Update multissl to openssl 1.1.1l as well (GH-28044)\n\nThis was missed while upgrading CI.\n(cherry picked from commit d6cb5dd9e19210f5963ff8beadde7ca2fda71574)\n\nCo-authored-by: \u0141ukasz Langa <lukasz@langa.pl>",
        "before_after_code_files": [
          "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ],
          "candidate": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ]
        }
      },
      "candidate_diff": {
        "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py": [
          "File: Tools/ssl/multissltests.py -> Tools/ssl/multissltests.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: ]",
          "49: OPENSSL_RECENT_VERSIONS = [",
          "51:     \"3.0.0-beta1\"",
          "52: ]",
          "",
          "[Removed Lines]",
          "50:     \"1.1.1k\",",
          "",
          "[Added Lines]",
          "50:     \"1.1.1l\",",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cf96c279ac960f2a5025e2ac887f9b932a4f1474",
      "candidate_info": {
        "commit_hash": "cf96c279ac960f2a5025e2ac887f9b932a4f1474",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/cf96c279ac960f2a5025e2ac887f9b932a4f1474",
        "files": [
          ".azure-pipelines/ci.yml",
          ".azure-pipelines/pr.yml",
          ".github/workflows/build.yml",
          "Mac/BuildScript/0001-Darwin-platform-allows-to-build-on-releases-before-Y.patch",
          "Mac/BuildScript/build-installer.py",
          "Misc/NEWS.d/next/Build/2021-12-20-07-10-41.bpo-46106.5qcv3L.rst",
          "PCbuild/get_externals.bat",
          "PCbuild/python.props",
          "Tools/ssl/multissltests.py"
        ],
        "message": "bpo-46106: Update OpenSSL to 1.1.1m (GH-30211) (GH-30224)\n\nCo-authored-by: Ned Deily <nad@python.org>\nCo-authored-by: Kumar Aditya <59607654+kumaraditya303@users.noreply.github.com>",
        "before_after_code_files": [
          "Mac/BuildScript/build-installer.py||Mac/BuildScript/build-installer.py",
          "PCbuild/get_externals.bat||PCbuild/get_externals.bat",
          "PCbuild/python.props||PCbuild/python.props",
          "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ],
          "candidate": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ]
        }
      },
      "candidate_diff": {
        "Mac/BuildScript/build-installer.py||Mac/BuildScript/build-installer.py": [
          "File: Mac/BuildScript/build-installer.py -> Mac/BuildScript/build-installer.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "247:     result.extend([",
          "248:           dict(",
          "253:               buildrecipe=build_universal_openssl,",
          "254:               configure=None,",
          "255:               install=None,",
          "",
          "[Removed Lines]",
          "249:               name=\"OpenSSL 1.1.1l\",",
          "250:               url=\"https://www.openssl.org/source/openssl-1.1.1l.tar.gz\",",
          "251:               checksum='ac0d4387f3ba0ad741b0580dd45f6ff3',",
          "252:               patches=['0001-Darwin-platform-allows-to-build-on-releases-before-Y.patch'],",
          "",
          "[Added Lines]",
          "249:               name=\"OpenSSL 1.1.1m\",",
          "250:               url=\"https://www.openssl.org/source/openssl-1.1.1m.tar.gz\",",
          "251:               checksum='8ec70f665c145c3103f6e330f538a9db',",
          "",
          "---------------"
        ],
        "PCbuild/get_externals.bat||PCbuild/get_externals.bat": [
          "File: PCbuild/get_externals.bat -> PCbuild/get_externals.bat",
          "--- Hunk 1 ---",
          "[Context before]",
          "53: set libraries=",
          "54: set libraries=%libraries%                                       bzip2-1.0.6",
          "55: if NOT \"%IncludeLibffiSrc%\"==\"false\" set libraries=%libraries%  libffi-3.3.0",
          "57: set libraries=%libraries%                                       sqlite-3.35.5.0",
          "58: if NOT \"%IncludeTkinterSrc%\"==\"false\" set libraries=%libraries% tcl-core-8.6.12.0",
          "59: if NOT \"%IncludeTkinterSrc%\"==\"false\" set libraries=%libraries% tk-8.6.12.0",
          "",
          "[Removed Lines]",
          "56: if NOT \"%IncludeSSLSrc%\"==\"false\" set libraries=%libraries%     openssl-1.1.1l",
          "",
          "[Added Lines]",
          "56: if NOT \"%IncludeSSLSrc%\"==\"false\" set libraries=%libraries%     openssl-1.1.1m",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78: set binaries=",
          "79: if NOT \"%IncludeLibffi%\"==\"false\"  set binaries=%binaries% libffi-3.3.0",
          "81: if NOT \"%IncludeTkinter%\"==\"false\" set binaries=%binaries% tcltk-8.6.12.0",
          "82: if NOT \"%IncludeSSLSrc%\"==\"false\"  set binaries=%binaries% nasm-2.11.06",
          "",
          "[Removed Lines]",
          "80: if NOT \"%IncludeSSL%\"==\"false\"     set binaries=%binaries% openssl-bin-1.1.1l",
          "",
          "[Added Lines]",
          "80: if NOT \"%IncludeSSL%\"==\"false\"     set binaries=%binaries% openssl-bin-1.1.1m",
          "",
          "---------------"
        ],
        "PCbuild/python.props||PCbuild/python.props": [
          "File: PCbuild/python.props -> PCbuild/python.props",
          "--- Hunk 1 ---",
          "[Context before]",
          "63:     <libffiDir>$(ExternalsDir)libffi-3.3.0\\</libffiDir>",
          "64:     <libffiOutDir>$(ExternalsDir)libffi-3.3.0\\$(ArchName)\\</libffiOutDir>",
          "65:     <libffiIncludeDir>$(libffiOutDir)include</libffiIncludeDir>",
          "68:     <opensslIncludeDir>$(opensslOutDir)include</opensslIncludeDir>",
          "69:     <nasmDir>$(ExternalsDir)\\nasm-2.11.06\\</nasmDir>",
          "70:     <zlibDir>$(ExternalsDir)\\zlib-1.2.11\\</zlibDir>",
          "",
          "[Removed Lines]",
          "66:     <opensslDir>$(ExternalsDir)openssl-1.1.1l\\</opensslDir>",
          "67:     <opensslOutDir>$(ExternalsDir)openssl-bin-1.1.1l\\$(ArchName)\\</opensslOutDir>",
          "",
          "[Added Lines]",
          "66:     <opensslDir>$(ExternalsDir)openssl-1.1.1m\\</opensslDir>",
          "67:     <opensslOutDir>$(ExternalsDir)openssl-bin-1.1.1m\\$(ArchName)\\</opensslOutDir>",
          "",
          "---------------"
        ],
        "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py": [
          "File: Tools/ssl/multissltests.py -> Tools/ssl/multissltests.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: ]",
          "49: OPENSSL_RECENT_VERSIONS = [",
          "51:     \"3.0.1\"",
          "52: ]",
          "",
          "[Removed Lines]",
          "50:     \"1.1.1l\",",
          "",
          "[Added Lines]",
          "50:     \"1.1.1m\",",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a59ac1e7d20713573c15c5259c83e998a73e9094",
      "candidate_info": {
        "commit_hash": "a59ac1e7d20713573c15c5259c83e998a73e9094",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/a59ac1e7d20713573c15c5259c83e998a73e9094",
        "files": [
          ".azure-pipelines/ci.yml",
          ".azure-pipelines/pr.yml",
          ".github/workflows/build.yml",
          "Mac/BuildScript/build-installer.py",
          "Misc/NEWS.d/next/Build/2022-03-15-09-28-55.bpo-47024.t7-dcu.rst",
          "PCbuild/get_externals.bat",
          "PCbuild/python.props",
          "Tools/ssl/multissltests.py"
        ],
        "message": "[3.10] bpo-47024: Update OpenSSL to 1.1.1n (GH-31895) (GH-31916)\n\nCo-authored-by: Zachary Ware <zachary.ware@gmail.com>.\nCo-authored-by: Christian Heimes <christian@python.org>",
        "before_after_code_files": [
          "Mac/BuildScript/build-installer.py||Mac/BuildScript/build-installer.py",
          "PCbuild/get_externals.bat||PCbuild/get_externals.bat",
          "PCbuild/python.props||PCbuild/python.props",
          "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ],
          "candidate": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ]
        }
      },
      "candidate_diff": {
        "Mac/BuildScript/build-installer.py||Mac/BuildScript/build-installer.py": [
          "File: Mac/BuildScript/build-installer.py -> Mac/BuildScript/build-installer.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "247:     result.extend([",
          "248:           dict(",
          "252:               buildrecipe=build_universal_openssl,",
          "253:               configure=None,",
          "254:               install=None,",
          "",
          "[Removed Lines]",
          "249:               name=\"OpenSSL 1.1.1m\",",
          "250:               url=\"https://www.openssl.org/source/openssl-1.1.1m.tar.gz\",",
          "251:               checksum='8ec70f665c145c3103f6e330f538a9db',",
          "",
          "[Added Lines]",
          "249:               name=\"OpenSSL 1.1.1n\",",
          "250:               url=\"https://www.openssl.org/source/openssl-1.1.1n.tar.gz\",",
          "251:               checksum='2aad5635f9bb338bc2c6b7d19cbc9676',",
          "",
          "---------------"
        ],
        "PCbuild/get_externals.bat||PCbuild/get_externals.bat": [
          "File: PCbuild/get_externals.bat -> PCbuild/get_externals.bat",
          "--- Hunk 1 ---",
          "[Context before]",
          "53: set libraries=",
          "54: set libraries=%libraries%                                       bzip2-1.0.8",
          "55: if NOT \"%IncludeLibffiSrc%\"==\"false\" set libraries=%libraries%  libffi-3.3.0",
          "57: set libraries=%libraries%                                       sqlite-3.37.2.0",
          "58: if NOT \"%IncludeTkinterSrc%\"==\"false\" set libraries=%libraries% tcl-core-8.6.12.0",
          "59: if NOT \"%IncludeTkinterSrc%\"==\"false\" set libraries=%libraries% tk-8.6.12.0",
          "",
          "[Removed Lines]",
          "56: if NOT \"%IncludeSSLSrc%\"==\"false\" set libraries=%libraries%     openssl-1.1.1m",
          "",
          "[Added Lines]",
          "56: if NOT \"%IncludeSSLSrc%\"==\"false\" set libraries=%libraries%     openssl-1.1.1n",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78: set binaries=",
          "79: if NOT \"%IncludeLibffi%\"==\"false\"  set binaries=%binaries% libffi-3.3.0",
          "81: if NOT \"%IncludeTkinter%\"==\"false\" set binaries=%binaries% tcltk-8.6.12.0",
          "82: if NOT \"%IncludeSSLSrc%\"==\"false\"  set binaries=%binaries% nasm-2.11.06",
          "",
          "[Removed Lines]",
          "80: if NOT \"%IncludeSSL%\"==\"false\"     set binaries=%binaries% openssl-bin-1.1.1m",
          "",
          "[Added Lines]",
          "80: if NOT \"%IncludeSSL%\"==\"false\"     set binaries=%binaries% openssl-bin-1.1.1n",
          "",
          "---------------"
        ],
        "PCbuild/python.props||PCbuild/python.props": [
          "File: PCbuild/python.props -> PCbuild/python.props",
          "--- Hunk 1 ---",
          "[Context before]",
          "63:     <libffiDir>$(ExternalsDir)libffi-3.3.0\\</libffiDir>",
          "64:     <libffiOutDir>$(ExternalsDir)libffi-3.3.0\\$(ArchName)\\</libffiOutDir>",
          "65:     <libffiIncludeDir>$(libffiOutDir)include</libffiIncludeDir>",
          "68:     <opensslIncludeDir>$(opensslOutDir)include</opensslIncludeDir>",
          "69:     <nasmDir>$(ExternalsDir)\\nasm-2.11.06\\</nasmDir>",
          "70:     <zlibDir>$(ExternalsDir)\\zlib-1.2.11\\</zlibDir>",
          "",
          "[Removed Lines]",
          "66:     <opensslDir>$(ExternalsDir)openssl-1.1.1m\\</opensslDir>",
          "67:     <opensslOutDir>$(ExternalsDir)openssl-bin-1.1.1m\\$(ArchName)\\</opensslOutDir>",
          "",
          "[Added Lines]",
          "66:     <opensslDir>$(ExternalsDir)openssl-1.1.1n\\</opensslDir>",
          "67:     <opensslOutDir>$(ExternalsDir)openssl-bin-1.1.1n\\$(ArchName)\\</opensslOutDir>",
          "",
          "---------------"
        ],
        "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py": [
          "File: Tools/ssl/multissltests.py -> Tools/ssl/multissltests.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: ]",
          "49: OPENSSL_RECENT_VERSIONS = [",
          "52: ]",
          "54: LIBRESSL_OLD_VERSIONS = [",
          "",
          "[Removed Lines]",
          "50:     \"1.1.1m\",",
          "51:     \"3.0.1\"",
          "",
          "[Added Lines]",
          "50:     \"1.1.1n\",",
          "51:     \"3.0.2\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "666991fc598bc312d72aff0078ecb553f0a968f1",
      "candidate_info": {
        "commit_hash": "666991fc598bc312d72aff0078ecb553f0a968f1",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/666991fc598bc312d72aff0078ecb553f0a968f1",
        "files": [
          "Lib/test/test_ssl.py",
          "Misc/NEWS.d/next/Library/2020-11-19-09-52-24.bpo-18369.qzvYH2.rst",
          "Modules/_ssl.c",
          "Modules/_ssl.h",
          "Modules/_ssl/cert.c",
          "Modules/_ssl/clinic/cert.c.h",
          "Modules/_ssl/misc.c",
          "Modules/clinic/_ssl.c.h",
          "setup.py"
        ],
        "message": "bpo-18233: Add internal methods to access peer chain (GH-25467)\n\nThe internal `_ssl._SSLSocket` object now provides methods to retrieve\nthe peer cert chain and verified cert chain as a list of Certificate\nobjects. Certificate objects have methods to convert the cert to a dict,\nPEM, or DER (ASN.1).\n\nThese are private APIs for now. There is a slim chance to stabilize the\napproach and provide a public API for 3.10. Otherwise I'll provide a\nstable API in 3.11.\n\nSigned-off-by: Christian Heimes <christian@python.org>",
        "before_after_code_files": [
          "Lib/test/test_ssl.py||Lib/test/test_ssl.py",
          "Modules/_ssl.c||Modules/_ssl.c",
          "Modules/_ssl.h||Modules/_ssl.h",
          "Modules/_ssl/cert.c||Modules/_ssl/cert.c",
          "Modules/_ssl/clinic/cert.c.h||Modules/_ssl/clinic/cert.c.h",
          "Modules/_ssl/misc.c||Modules/_ssl/misc.c",
          "Modules/clinic/_ssl.c.h||Modules/clinic/_ssl.c.h",
          "setup.py||setup.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Lib/test/test_ssl.py||Lib/test/test_ssl.py",
            "Modules/_ssl.c||Modules/_ssl.c",
            "Modules/clinic/_ssl.c.h||Modules/clinic/_ssl.c.h",
            "setup.py||setup.py"
          ],
          "candidate": [
            "Lib/test/test_ssl.py||Lib/test/test_ssl.py",
            "Modules/_ssl.c||Modules/_ssl.c",
            "Modules/clinic/_ssl.c.h||Modules/clinic/_ssl.c.h",
            "setup.py||setup.py"
          ]
        }
      },
      "candidate_diff": {
        "Lib/test/test_ssl.py||Lib/test/test_ssl.py": [
          "File: Lib/test/test_ssl.py -> Lib/test/test_ssl.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "32:     ctypes = None",
          "34: ssl = import_helper.import_module(\"ssl\")",
          "36: from ssl import TLSVersion, _TLSContentType, _TLSMessageType, _TLSAlertType",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: import _ssl",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "297:     return context.wrap_socket(sock, **kwargs)",
          "301:     \"\"\"Create context",
          "303:     client_context, server_context, hostname = testing_context()",
          "",
          "[Removed Lines]",
          "300: def testing_context(server_cert=SIGNED_CERTFILE):",
          "",
          "[Added Lines]",
          "301: def testing_context(server_cert=SIGNED_CERTFILE, *, server_chain=True):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "317:     server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)",
          "318:     server_context.load_cert_chain(server_cert)",
          "321:     return client_context, server_context, hostname",
          "",
          "[Removed Lines]",
          "319:     server_context.load_verify_locations(SIGNING_CA)",
          "",
          "[Added Lines]",
          "320:     if server_chain:",
          "321:         server_context.load_verify_locations(SIGNING_CA)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2482:                     elif stripped == b'GETCERT':",
          "2483:                         cert = self.sslconn.getpeercert()",
          "2484:                         self.write(repr(cert).encode(\"us-ascii\") + b\"\\n\")",
          "2485:                     else:",
          "2486:                         if (support.verbose and",
          "2487:                             self.server.connectionchatty):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2487:                     elif stripped == b'VERIFIEDCHAIN':",
          "2488:                         certs = self.sslconn._sslobj.get_verified_chain()",
          "2489:                         self.write(len(certs).to_bytes(1, \"big\") + b\"\\n\")",
          "2490:                     elif stripped == b'UNVERIFIEDCHAIN':",
          "2491:                         certs = self.sslconn._sslobj.get_unverified_chain()",
          "2492:                         self.write(len(certs).to_bytes(1, \"big\") + b\"\\n\")",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4567:                 # server cert has not been validated",
          "4568:                 self.assertEqual(s.getpeercert(), {})",
          "4571: HAS_KEYLOG = hasattr(ssl.SSLContext, 'keylog_filename')",
          "4572: requires_keylog = unittest.skipUnless(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4578:     def test_internal_chain_client(self):",
          "4579:         client_context, server_context, hostname = testing_context(",
          "4580:             server_chain=False",
          "4581:         )",
          "4582:         server = ThreadedEchoServer(context=server_context, chatty=False)",
          "4583:         with server:",
          "4584:             with client_context.wrap_socket(",
          "4585:                 socket.socket(),",
          "4586:                 server_hostname=hostname",
          "4587:             ) as s:",
          "4588:                 s.connect((HOST, server.port))",
          "4589:                 vc = s._sslobj.get_verified_chain()",
          "4590:                 self.assertEqual(len(vc), 2)",
          "4591:                 ee, ca = vc",
          "4592:                 uvc = s._sslobj.get_unverified_chain()",
          "4593:                 self.assertEqual(len(uvc), 1)",
          "4595:                 self.assertEqual(ee, uvc[0])",
          "4596:                 self.assertEqual(hash(ee), hash(uvc[0]))",
          "4597:                 self.assertEqual(repr(ee), repr(uvc[0]))",
          "4599:                 self.assertNotEqual(ee, ca)",
          "4600:                 self.assertNotEqual(hash(ee), hash(ca))",
          "4601:                 self.assertNotEqual(repr(ee), repr(ca))",
          "4602:                 self.assertNotEqual(ee.get_info(), ca.get_info())",
          "4603:                 self.assertIn(\"CN=localhost\", repr(ee))",
          "4604:                 self.assertIn(\"CN=our-ca-server\", repr(ca))",
          "4606:                 pem = ee.public_bytes(_ssl.ENCODING_PEM)",
          "4607:                 der = ee.public_bytes(_ssl.ENCODING_DER)",
          "4608:                 self.assertIsInstance(pem, str)",
          "4609:                 self.assertIn(\"-----BEGIN CERTIFICATE-----\", pem)",
          "4610:                 self.assertIsInstance(der, bytes)",
          "4611:                 self.assertEqual(",
          "4612:                     ssl.PEM_cert_to_DER_cert(pem), der",
          "4613:                 )",
          "4615:     def test_internal_chain_server(self):",
          "4616:         client_context, server_context, hostname = testing_context()",
          "4617:         client_context.load_cert_chain(SIGNED_CERTFILE)",
          "4618:         server_context.verify_mode = ssl.CERT_REQUIRED",
          "4619:         server_context.maximum_version = ssl.TLSVersion.TLSv1_2",
          "4621:         server = ThreadedEchoServer(context=server_context, chatty=False)",
          "4622:         with server:",
          "4623:             with client_context.wrap_socket(",
          "4624:                 socket.socket(),",
          "4625:                 server_hostname=hostname",
          "4626:             ) as s:",
          "4627:                 s.connect((HOST, server.port))",
          "4628:                 s.write(b'VERIFIEDCHAIN\\n')",
          "4629:                 res = s.recv(1024)",
          "4630:                 self.assertEqual(res, b'\\x02\\n')",
          "4631:                 s.write(b'UNVERIFIEDCHAIN\\n')",
          "4632:                 res = s.recv(1024)",
          "4633:                 self.assertEqual(res, b'\\x02\\n')",
          "",
          "---------------"
        ],
        "Modules/_ssl.c||Modules/_ssl.c": [
          "File: Modules/_ssl.c -> Modules/_ssl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1706:     return retval;",
          "1707: }",
          "1710: _ssl._test_decode_cert",
          "1711:     path: object(converter=\"PyUnicode_FSConverter\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1709: #include \"_ssl/misc.c\"",
          "1710: #include \"_ssl/cert.c\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1798:     return result;",
          "1799: }",
          "1801: static PyObject *",
          "1802: cipher_to_tuple(const SSL_CIPHER *cipher)",
          "1803: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1805: _ssl._SSLSocket.get_verified_chain",
          "1809: static PyObject *",
          "1810: _ssl__SSLSocket_get_verified_chain_impl(PySSLSocket *self)",
          "1812: {",
          "1814:     STACK_OF(X509) *chain = SSL_get0_verified_chain(self->ssl);",
          "1815:     if (chain == NULL) {",
          "1816:         Py_RETURN_NONE;",
          "1817:     }",
          "1818:     return _PySSL_CertificateFromX509Stack(self->ctx->state, chain, 1);",
          "1819: }",
          "1822: _ssl._SSLSocket.get_unverified_chain",
          "1826: static PyObject *",
          "1827: _ssl__SSLSocket_get_unverified_chain_impl(PySSLSocket *self)",
          "1829: {",
          "1830:     PyObject *retval;",
          "1833:     STACK_OF(X509) *chain = SSL_get_peer_cert_chain(self->ssl);",
          "1834:     if (chain == NULL) {",
          "1835:         Py_RETURN_NONE;",
          "1836:     }",
          "1837:     retval = _PySSL_CertificateFromX509Stack(self->ctx->state, chain, 1);",
          "1838:     if (retval == NULL) {",
          "1839:         return NULL;",
          "1840:     }",
          "1842:     if (self->socket_type == PY_SSL_SERVER) {",
          "1843:         PyObject *peerobj = NULL;",
          "1844:         X509 *peer = SSL_get_peer_certificate(self->ssl);",
          "1846:         if (peer == NULL) {",
          "1847:             peerobj = Py_None;",
          "1848:             Py_INCREF(peerobj);",
          "1849:         } else {",
          "1851:             peerobj = _PySSL_CertificateFromX509(self->ctx->state, peer, 0);",
          "1852:             if (peerobj == NULL) {",
          "1853:                 X509_free(peer);",
          "1854:                 Py_DECREF(retval);",
          "1855:                 return NULL;",
          "1856:             }",
          "1857:         }",
          "1858:         int res = PyList_Insert(retval, 0, peerobj);",
          "1859:         Py_DECREF(peerobj);",
          "1860:         if (res < 0) {",
          "1861:             Py_DECREF(retval);",
          "1862:             return NULL;",
          "1863:         }",
          "1864:     }",
          "1865:     return retval;",
          "1866: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2809:     _SSL__SSLSOCKET_COMPRESSION_METHODDEF",
          "2810:     _SSL__SSLSOCKET_SHUTDOWN_METHODDEF",
          "2811:     _SSL__SSLSOCKET_VERIFY_CLIENT_POST_HANDSHAKE_METHODDEF",
          "2812:     {NULL, NULL}",
          "2813: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2879:     _SSL__SSLSOCKET_GET_UNVERIFIED_CHAIN_METHODDEF",
          "2880:     _SSL__SSLSOCKET_GET_VERIFIED_CHAIN_METHODDEF",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5784:                             X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS);",
          "5785: #endif",
          "5788:     PyModule_AddIntConstant(m, \"PROTO_MINIMUM_SUPPORTED\",",
          "5789:                             PY_PROTO_MINIMUM_SUPPORTED);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5857:     PyModule_AddIntConstant(m, \"ENCODING_PEM\", PY_SSL_ENCODING_PEM);",
          "5858:     PyModule_AddIntConstant(m, \"ENCODING_DER\", PY_SSL_ENCODING_DER);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "5986:     if (state->PySSLSession_Type == NULL)",
          "5987:         return -1;",
          "5989:     if (PyModule_AddType(module, state->PySSLContext_Type))",
          "5990:         return -1;",
          "5991:     if (PyModule_AddType(module, state->PySSLSocket_Type))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6062:     state->PySSLCertificate_Type = (PyTypeObject *)PyType_FromModuleAndSpec(",
          "6063:         module, &PySSLCertificate_spec, NULL",
          "6064:     );",
          "6065:     if (state->PySSLCertificate_Type == NULL)",
          "6066:         return -1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5994:         return -1;",
          "5995:     if (PyModule_AddType(module, state->PySSLSession_Type))",
          "5996:         return -1;",
          "5998:     return 0;",
          "5999: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6076:     if (PyModule_AddType(module, state->PySSLCertificate_Type))",
          "6077:         return -1;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "6017:     Py_VISIT(state->PySSLSocket_Type);",
          "6018:     Py_VISIT(state->PySSLMemoryBIO_Type);",
          "6019:     Py_VISIT(state->PySSLSession_Type);",
          "6020:     Py_VISIT(state->PySSLErrorObject);",
          "6021:     Py_VISIT(state->PySSLCertVerificationErrorObject);",
          "6022:     Py_VISIT(state->PySSLZeroReturnErrorObject);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6100:     Py_VISIT(state->PySSLCertificate_Type);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6041:     Py_CLEAR(state->PySSLSocket_Type);",
          "6042:     Py_CLEAR(state->PySSLMemoryBIO_Type);",
          "6043:     Py_CLEAR(state->PySSLSession_Type);",
          "6044:     Py_CLEAR(state->PySSLErrorObject);",
          "6045:     Py_CLEAR(state->PySSLCertVerificationErrorObject);",
          "6046:     Py_CLEAR(state->PySSLZeroReturnErrorObject);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6125:     Py_CLEAR(state->PySSLCertificate_Type);",
          "",
          "---------------"
        ],
        "Modules/_ssl.h||Modules/_ssl.h": [
          "File: Modules/_ssl.h -> Modules/_ssl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #ifndef Py_SSL_H",
          "2: #define Py_SSL_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: #include \"openssl/evp.h\"",
          "6: #include \"openssl/x509.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "10:     PyTypeObject *PySSLSocket_Type;",
          "11:     PyTypeObject *PySSLMemoryBIO_Type;",
          "12:     PyTypeObject *PySSLSession_Type;",
          "14:     PyObject *PySSLErrorObject;",
          "15:     PyObject *PySSLCertVerificationErrorObject;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17:     PyTypeObject *PySSLCertificate_Type;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "40:     (get_ssl_state(_PyType_GetModuleByDef(type, &_sslmodule_def)))",
          "41: #define get_state_ctx(c) (((PySSLContext *)(c))->state)",
          "42: #define get_state_sock(s) (((PySSLSocket *)(s))->ctx->state)",
          "",
          "[Removed Lines]",
          "43: #define get_state_mbio(b) ((_sslmodulestate *)PyType_GetModuleState(Py_TYPE(b)))",
          "",
          "[Added Lines]",
          "48: #define get_state_obj(o) ((_sslmodulestate *)PyType_GetModuleState(Py_TYPE(o)))",
          "49: #define get_state_mbio(b) get_state_obj(b)",
          "50: #define get_state_cert(c) get_state_obj(c)",
          "56: enum py_ssl_encoding {",
          "57:     PY_SSL_ENCODING_PEM=X509_FILETYPE_PEM,",
          "58:     PY_SSL_ENCODING_DER=X509_FILETYPE_ASN1,",
          "59:     PY_SSL_ENCODING_PEM_AUX=X509_FILETYPE_PEM + 0x100,",
          "60: };",
          "62: typedef struct {",
          "63:     PyObject_HEAD",
          "64:     X509 *cert;",
          "65:     Py_hash_t hash;",
          "66: } PySSLCertificate;",
          "71: static PyObject *_PySSL_BytesFromBIO(_sslmodulestate *state, BIO *bio);",
          "72: static PyObject *_PySSL_UnicodeFromBIO(_sslmodulestate *state, BIO *bio, const char *error);",
          "",
          "---------------"
        ],
        "Modules/_ssl/cert.c||Modules/_ssl/cert.c": [
          "File: Modules/_ssl/cert.c -> Modules/_ssl/cert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"Python.h\"",
          "2: #include \"../_ssl.h\"",
          "4: #include \"openssl/err.h\"",
          "5: #include \"openssl/bio.h\"",
          "6: #include \"openssl/pem.h\"",
          "7: #include \"openssl/x509.h\"",
          "10: module _ssl",
          "11: class _ssl.Certificate \"PySSLCertificate *\" \"PySSLCertificate_Type\"",
          "15: #include \"clinic/cert.c.h\"",
          "17: static PyObject *",
          "18: newCertificate(PyTypeObject *type, X509 *cert, int upref)",
          "19: {",
          "20:     PySSLCertificate *self;",
          "22:     assert(type != NULL && type->tp_alloc != NULL);",
          "23:     assert(cert != NULL);",
          "25:     self = (PySSLCertificate *) type->tp_alloc(type, 0);",
          "26:     if (self == NULL) {",
          "27:         return NULL;",
          "28:     }",
          "29:     if (upref == 1) {",
          "30:         X509_up_ref(cert);",
          "31:     }",
          "32:     self->cert = cert;",
          "33:     self->hash = -1;",
          "35:     return (PyObject *) self;",
          "36: }",
          "38: static PyObject *",
          "39: _PySSL_CertificateFromX509(_sslmodulestate *state, X509 *cert, int upref)",
          "40: {",
          "41:     return newCertificate(state->PySSLCertificate_Type, cert, upref);",
          "42: }",
          "44: static PyObject*",
          "45: _PySSL_CertificateFromX509Stack(_sslmodulestate *state, STACK_OF(X509) *stack, int upref)",
          "46: {",
          "47:     int len, i;",
          "48:     PyObject *result = NULL;",
          "50:     len = sk_X509_num(stack);",
          "51:     result = PyList_New(len);",
          "52:     if (result == NULL) {",
          "53:         return NULL;",
          "54:     }",
          "55:     for (i = 0; i < len; i++) {",
          "56:         X509 *cert = sk_X509_value(stack, i);",
          "57:         PyObject *ocert = _PySSL_CertificateFromX509(state, cert, upref);",
          "58:         if (ocert == NULL) {",
          "59:             Py_DECREF(result);",
          "60:             return NULL;",
          "61:         }",
          "62:         PyList_SetItem(result, i, ocert);",
          "63:     }",
          "64:     return result;",
          "65: }",
          "68: _ssl.Certificate.public_bytes",
          "69:     format: int(c_default=\"PY_SSL_ENCODING_PEM\") = Encoding.PEM",
          "73: static PyObject *",
          "74: _ssl_Certificate_public_bytes_impl(PySSLCertificate *self, int format)",
          "76: {",
          "77:     BIO *bio;",
          "78:     int retcode;",
          "79:     PyObject *result;",
          "80:     _sslmodulestate *state = get_state_cert(self);",
          "82:     bio = BIO_new(BIO_s_mem());",
          "83:     if (bio == NULL) {",
          "84:         PyErr_SetString(state->PySSLErrorObject,",
          "85:                         \"failed to allocate BIO\");",
          "86:         return NULL;",
          "87:     }",
          "88:     switch(format) {",
          "89:     case PY_SSL_ENCODING_PEM:",
          "90:         retcode = PEM_write_bio_X509(bio, self->cert);",
          "91:         break;",
          "92:     case PY_SSL_ENCODING_PEM_AUX:",
          "93:         retcode = PEM_write_bio_X509_AUX(bio, self->cert);",
          "94:         break;",
          "95:     case PY_SSL_ENCODING_DER:",
          "96:         retcode = i2d_X509_bio(bio, self->cert);",
          "97:         break;",
          "98:     default:",
          "99:         PyErr_SetString(PyExc_ValueError, \"Unsupported format\");",
          "100:         BIO_free(bio);",
          "101:         return NULL;",
          "102:     }",
          "103:     if (retcode != 1) {",
          "104:         BIO_free(bio);",
          "105:         _setSSLError(state, NULL, 0, __FILE__, __LINE__);",
          "106:         return NULL;",
          "107:     }",
          "108:     if (format == PY_SSL_ENCODING_DER) {",
          "109:         result = _PySSL_BytesFromBIO(state, bio);",
          "110:     } else {",
          "111:         result = _PySSL_UnicodeFromBIO(state, bio, \"error\");",
          "112:     }",
          "113:     BIO_free(bio);",
          "114:     return result;",
          "115: }",
          "119: _ssl.Certificate.get_info",
          "123: static PyObject *",
          "124: _ssl_Certificate_get_info_impl(PySSLCertificate *self)",
          "126: {",
          "127:     return _decode_certificate(get_state_cert(self), self->cert);",
          "128: }",
          "130: static PyObject*",
          "131: _x509name_print(_sslmodulestate *state, X509_NAME *name, int indent, unsigned long flags)",
          "132: {",
          "133:     PyObject *res;",
          "134:     BIO *biobuf;",
          "136:     biobuf = BIO_new(BIO_s_mem());",
          "137:     if (biobuf == NULL) {",
          "138:         PyErr_SetString(PyExc_MemoryError, \"failed to allocate BIO\");",
          "139:         return NULL;",
          "140:     }",
          "142:     if (X509_NAME_print_ex(biobuf, name, indent, flags) <= 0) {",
          "143:         _setSSLError(state, NULL, 0, __FILE__, __LINE__);",
          "144:         BIO_free(biobuf);",
          "145:         return NULL;",
          "146:     }",
          "147:     res = _PySSL_UnicodeFromBIO(state, biobuf, \"strict\");",
          "148:     BIO_free(biobuf);",
          "149:     return res;",
          "150: }",
          "156: static PyObject *",
          "157: certificate_repr(PySSLCertificate *self)",
          "158: {",
          "159:     PyObject *osubject, *result;",
          "162:     osubject = _x509name_print(",
          "163:         get_state_cert(self),",
          "164:         X509_get_subject_name(self->cert),",
          "165:         0,",
          "166:         XN_FLAG_RFC2253",
          "167:     );",
          "168:     if (osubject == NULL)",
          "169:         return NULL;",
          "170:     result = PyUnicode_FromFormat(",
          "171:         \"<%s '%U'>\",",
          "172:         Py_TYPE(self)->tp_name, osubject",
          "173:     );",
          "174:     Py_DECREF(osubject);",
          "175:     return result;",
          "176: }",
          "178: static Py_hash_t",
          "179: certificate_hash(PySSLCertificate *self)",
          "180: {",
          "181:     if (self->hash == (Py_hash_t)-1) {",
          "182:         unsigned long hash;",
          "183:         hash = X509_subject_name_hash(self->cert);",
          "184:         if ((Py_hash_t)hash == (Py_hash_t)-1) {",
          "185:             self->hash = -2;",
          "186:         } else {",
          "187:             self->hash = (Py_hash_t)hash;",
          "188:         }",
          "189:     }",
          "190:     return self->hash;",
          "191: }",
          "193: static PyObject *",
          "194: certificate_richcompare(PySSLCertificate *self, PyObject *other, int op)",
          "195: {",
          "196:     int cmp;",
          "197:     _sslmodulestate *state = get_state_cert(self);",
          "199:     if (Py_TYPE(other) != state->PySSLCertificate_Type) {",
          "200:         Py_RETURN_NOTIMPLEMENTED;",
          "201:     }",
          "203:     if ((op != Py_EQ) && (op != Py_NE)) {",
          "204:         Py_RETURN_NOTIMPLEMENTED;",
          "205:     }",
          "206:     cmp = X509_cmp(self->cert, ((PySSLCertificate*)other)->cert);",
          "207:     if (((op == Py_EQ) && (cmp == 0)) || ((op == Py_NE) && (cmp != 0))) {",
          "208:         Py_RETURN_TRUE;",
          "209:     } else {",
          "210:         Py_RETURN_FALSE;",
          "211:     }",
          "212: }",
          "214: static void",
          "215: certificate_dealloc(PySSLCertificate *self)",
          "216: {",
          "217:     PyTypeObject *tp = Py_TYPE(self);",
          "218:     X509_free(self->cert);",
          "219:     Py_TYPE(self)->tp_free(self);",
          "220:     Py_DECREF(tp);",
          "221: }",
          "223: static PyMethodDef certificate_methods[] = {",
          "225:     _SSL_CERTIFICATE_PUBLIC_BYTES_METHODDEF",
          "226:     _SSL_CERTIFICATE_GET_INFO_METHODDEF",
          "227:     {NULL, NULL}",
          "228: };",
          "230: static PyType_Slot PySSLCertificate_slots[] = {",
          "231:     {Py_tp_dealloc, certificate_dealloc},",
          "232:     {Py_tp_repr, certificate_repr},",
          "233:     {Py_tp_hash, certificate_hash},",
          "234:     {Py_tp_richcompare, certificate_richcompare},",
          "235:     {Py_tp_methods, certificate_methods},",
          "236:     {0, 0},",
          "237: };",
          "239: static PyType_Spec PySSLCertificate_spec = {",
          "240:     \"_ssl.Certificate\",",
          "241:     sizeof(PySSLCertificate),",
          "242:     0,",
          "243:     Py_TPFLAGS_DEFAULT,",
          "244:     PySSLCertificate_slots,",
          "245: };",
          "",
          "---------------"
        ],
        "Modules/_ssl/clinic/cert.c.h||Modules/_ssl/clinic/cert.c.h": [
          "File: Modules/_ssl/clinic/cert.c.h -> Modules/_ssl/clinic/cert.c.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: preserve",
          "5: PyDoc_STRVAR(_ssl_Certificate_public_bytes__doc__,",
          "6: \"public_bytes($self, /, format=Encoding.PEM)\\n\"",
          "7: \"--\\n\"",
          "8: \"\\n\");",
          "10: #define _SSL_CERTIFICATE_PUBLIC_BYTES_METHODDEF    \\",
          "11:     {\"public_bytes\", (PyCFunction)(void(*)(void))_ssl_Certificate_public_bytes, METH_FASTCALL|METH_KEYWORDS, _ssl_Certificate_public_bytes__doc__},",
          "13: static PyObject *",
          "14: _ssl_Certificate_public_bytes_impl(PySSLCertificate *self, int format);",
          "16: static PyObject *",
          "17: _ssl_Certificate_public_bytes(PySSLCertificate *self, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)",
          "18: {",
          "19:     PyObject *return_value = NULL;",
          "20:     static const char * const _keywords[] = {\"format\", NULL};",
          "21:     static _PyArg_Parser _parser = {NULL, _keywords, \"public_bytes\", 0};",
          "22:     PyObject *argsbuf[1];",
          "23:     Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;",
          "24:     int format = PY_SSL_ENCODING_PEM;",
          "26:     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 1, 0, argsbuf);",
          "27:     if (!args) {",
          "28:         goto exit;",
          "29:     }",
          "30:     if (!noptargs) {",
          "31:         goto skip_optional_pos;",
          "32:     }",
          "33:     format = _PyLong_AsInt(args[0]);",
          "34:     if (format == -1 && PyErr_Occurred()) {",
          "35:         goto exit;",
          "36:     }",
          "37: skip_optional_pos:",
          "38:     return_value = _ssl_Certificate_public_bytes_impl(self, format);",
          "40: exit:",
          "41:     return return_value;",
          "42: }",
          "44: PyDoc_STRVAR(_ssl_Certificate_get_info__doc__,",
          "45: \"get_info($self, /)\\n\"",
          "46: \"--\\n\"",
          "47: \"\\n\");",
          "49: #define _SSL_CERTIFICATE_GET_INFO_METHODDEF    \\",
          "50:     {\"get_info\", (PyCFunction)_ssl_Certificate_get_info, METH_NOARGS, _ssl_Certificate_get_info__doc__},",
          "52: static PyObject *",
          "53: _ssl_Certificate_get_info_impl(PySSLCertificate *self);",
          "55: static PyObject *",
          "56: _ssl_Certificate_get_info(PySSLCertificate *self, PyObject *Py_UNUSED(ignored))",
          "57: {",
          "58:     return _ssl_Certificate_get_info_impl(self);",
          "59: }",
          "",
          "---------------"
        ],
        "Modules/_ssl/misc.c||Modules/_ssl/misc.c": [
          "File: Modules/_ssl/misc.c -> Modules/_ssl/misc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include \"Python.h\"",
          "2: #include \"../_ssl.h\"",
          "4: #include \"openssl/bio.h\"",
          "8: static PyObject *",
          "9: _PySSL_BytesFromBIO(_sslmodulestate *state, BIO *bio)",
          "10: {",
          "11:     long size;",
          "12:     char *data = NULL;",
          "13:     size = BIO_get_mem_data(bio, &data);",
          "14:     if (data == NULL || size < 0) {",
          "15:         PyErr_SetString(PyExc_ValueError, \"Not a memory BIO\");",
          "16:         return NULL;",
          "17:     }",
          "18:     return PyBytes_FromStringAndSize(data, size);",
          "19: }",
          "23: static PyObject *",
          "24: _PySSL_UnicodeFromBIO(_sslmodulestate *state, BIO *bio, const char *error)",
          "25: {",
          "26:     long size;",
          "27:     char *data = NULL;",
          "28:     size = BIO_get_mem_data(bio, &data);",
          "29:     if (data == NULL || size < 0) {",
          "30:         PyErr_SetString(PyExc_ValueError, \"Not a memory BIO\");",
          "31:         return NULL;",
          "32:     }",
          "33:     return PyUnicode_DecodeUTF8(data, size, error);",
          "34: }",
          "",
          "---------------"
        ],
        "Modules/clinic/_ssl.c.h||Modules/clinic/_ssl.c.h": [
          "File: Modules/clinic/_ssl.c.h -> Modules/clinic/_ssl.c.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "88:     return return_value;",
          "89: }",
          "91: PyDoc_STRVAR(_ssl__SSLSocket_shared_ciphers__doc__,",
          "92: \"shared_ciphers($self, /)\\n\"",
          "93: \"--\\n\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "91: PyDoc_STRVAR(_ssl__SSLSocket_get_verified_chain__doc__,",
          "92: \"get_verified_chain($self, /)\\n\"",
          "93: \"--\\n\"",
          "94: \"\\n\");",
          "96: #define _SSL__SSLSOCKET_GET_VERIFIED_CHAIN_METHODDEF    \\",
          "97:     {\"get_verified_chain\", (PyCFunction)_ssl__SSLSocket_get_verified_chain, METH_NOARGS, _ssl__SSLSocket_get_verified_chain__doc__},",
          "99: static PyObject *",
          "100: _ssl__SSLSocket_get_verified_chain_impl(PySSLSocket *self);",
          "102: static PyObject *",
          "103: _ssl__SSLSocket_get_verified_chain(PySSLSocket *self, PyObject *Py_UNUSED(ignored))",
          "104: {",
          "105:     return _ssl__SSLSocket_get_verified_chain_impl(self);",
          "106: }",
          "108: PyDoc_STRVAR(_ssl__SSLSocket_get_unverified_chain__doc__,",
          "109: \"get_unverified_chain($self, /)\\n\"",
          "110: \"--\\n\"",
          "111: \"\\n\");",
          "113: #define _SSL__SSLSOCKET_GET_UNVERIFIED_CHAIN_METHODDEF    \\",
          "114:     {\"get_unverified_chain\", (PyCFunction)_ssl__SSLSocket_get_unverified_chain, METH_NOARGS, _ssl__SSLSocket_get_unverified_chain__doc__},",
          "116: static PyObject *",
          "117: _ssl__SSLSocket_get_unverified_chain_impl(PySSLSocket *self);",
          "119: static PyObject *",
          "120: _ssl__SSLSocket_get_unverified_chain(PySSLSocket *self, PyObject *Py_UNUSED(ignored))",
          "121: {",
          "122:     return _ssl__SSLSocket_get_unverified_chain_impl(self);",
          "123: }",
          "",
          "---------------"
        ],
        "setup.py||setup.py": [
          "File: setup.py -> setup.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2472:             Extension(",
          "2473:                 '_ssl',",
          "2474:                 ['_ssl.c'],",
          "2477:             )",
          "2478:         )",
          "",
          "[Removed Lines]",
          "2475:                 depends=['socketmodule.h', '_ssl/debughelpers.c', '_ssl.h'],",
          "",
          "[Added Lines]",
          "2475:                 depends=[",
          "2476:                     'socketmodule.h',",
          "2477:                     '_ssl.h',",
          "2478:                     '_ssl/debughelpers.c',",
          "2479:                     '_ssl/misc.c',",
          "2480:                     '_ssl/cert.c',",
          "2481:                 ],",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dcf658157df11de198a98e3db2a3050dd4f6b973",
      "candidate_info": {
        "commit_hash": "dcf658157df11de198a98e3db2a3050dd4f6b973",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/dcf658157df11de198a98e3db2a3050dd4f6b973",
        "files": [
          ".github/workflows/build.yml",
          "Tools/ssl/multissltests.py"
        ],
        "message": "bpo-38820: Test with OpenSSL 3.0.0-alpha15 (GH-25537)\n\nSigned-off-by: Christian Heimes <christian@python.org>",
        "before_after_code_files": [
          "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ],
          "candidate": [
            "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py"
          ]
        }
      },
      "candidate_diff": {
        "Tools/ssl/multissltests.py||Tools/ssl/multissltests.py": [
          "File: Tools/ssl/multissltests.py -> Tools/ssl/multissltests.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: OPENSSL_RECENT_VERSIONS = [",
          "49:     \"1.1.1k\",",
          "51: ]",
          "53: LIBRESSL_OLD_VERSIONS = [",
          "",
          "[Removed Lines]",
          "50:     \"3.0.0-alpha14\"",
          "",
          "[Added Lines]",
          "50:     \"3.0.0-alpha15\"",
          "",
          "---------------"
        ]
      }
    }
  ]
}
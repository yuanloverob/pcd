{
  "cve_id": "CVE-2023-34188",
  "cve_desc": "The HTTP server in Mongoose before 7.10 accepts requests containing negative Content-Length headers. By sending a single attack payload over TCP, an attacker can cause an infinite loop in which the server continuously reparses that payload, and does not respond to any other requests.",
  "repo": "cesanta/mongoose",
  "patch_hash": "4663090a8fb036146dfe77718cff612b0101cb0f",
  "patch_info": {
    "commit_hash": "4663090a8fb036146dfe77718cff612b0101cb0f",
    "repo": "cesanta/mongoose",
    "commit_url": "https://github.com/cesanta/mongoose/commit/4663090a8fb036146dfe77718cff612b0101cb0f",
    "files": [
      "mongoose.c",
      "src/http.c",
      "test/unit_test.c"
    ],
    "message": "Added check for negative value for HTTP Content-Length header",
    "before_after_code_files": [
      "mongoose.c||mongoose.c",
      "src/http.c||src/http.c",
      "test/unit_test.c||test/unit_test.c"
    ]
  },
  "patch_diff": {
    "mongoose.c||mongoose.c": [
      "File: mongoose.c -> mongoose.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1463:   mg_http_parse_headers(s, end, hm->headers,",
      "1464:                         sizeof(hm->headers) / sizeof(hm->headers[0]));",
      "1465:   if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {",
      "1467:     hm->message.len = (size_t) req_len + hm->body.len;",
      "1468:   }",
      "",
      "[Removed Lines]",
      "1466:     hm->body.len = (size_t) mg_to64(*cl);",
      "",
      "[Added Lines]",
      "1466:     int64_t content_len = mg_to64(*cl);",
      "1467:     if(content_len < 0) return -1;",
      "1468:     hm->body.len = (size_t) content_len;",
      "",
      "---------------"
    ],
    "src/http.c||src/http.c": [
      "File: src/http.c -> src/http.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "231:   mg_http_parse_headers(s, end, hm->headers,",
      "232:                         sizeof(hm->headers) / sizeof(hm->headers[0]));",
      "233:   if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {",
      "235:     hm->message.len = (size_t) req_len + hm->body.len;",
      "236:   }",
      "",
      "[Removed Lines]",
      "234:     hm->body.len = (size_t) mg_to64(*cl);",
      "",
      "[Added Lines]",
      "234:     int64_t content_len = mg_to64(*cl);",
      "235:     if(content_len < 0) return -1;",
      "236:     hm->body.len = (size_t) content_len;",
      "",
      "---------------"
    ],
    "test/unit_test.c||test/unit_test.c": [
      "File: test/unit_test.c -> test/unit_test.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "790:   ASSERT(fetch(&mgr, buf, url, \"GET /..ddot HTTP/1.0\\n\\n\") == 301);",
      "791:   ASSERT(fetch(&mgr, buf, url, \"GET /..ddot/ HTTP/1.0\\n\\n\") == 200);",
      "792:   ASSERT(cmpbody(buf, \"hi\\n\") == 0);",
      "794:   {",
      "795:     extern char *mg_http_etag(char *, size_t, size_t, time_t);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "793:   ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\"",
      "794:         \"Content-Length: -123\\n\\n\") == 0);",
      "795:   ASSERT(fetch(&mgr, buf, url, \"POST /a.txt HTTP/1.0\\n\"",
      "796:                \"Content-Length: -123\\n\\n\") == 0);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "eda1e8a40267f43d7ce8c9409cdfaf9c401f18f5",
      "candidate_info": {
        "commit_hash": "eda1e8a40267f43d7ce8c9409cdfaf9c401f18f5",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/eda1e8a40267f43d7ce8c9409cdfaf9c401f18f5",
        "files": [
          "mongoose.c",
          "src/http.c"
        ],
        "message": "fix header truncation",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "src/http.c||src/http.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1431:   return NULL;",
          "1432: }",
          "1435:                                   struct mg_http_header *h, int max_headers) {",
          "1436:   int i;",
          "1437:   for (i = 0; i < max_headers; i++) {",
          "1438:     struct mg_str k, v, tmp;",
          "1440:     s = skip(s, he, \": \\r\\n\", &k);",
          "1441:     s = skip(s, he, \"\\r\\n\", &v);",
          "1442:     if (k.len == tmp.len) continue;",
          "1443:     while (v.len > 0 && v.ptr[v.len - 1] == ' ') v.len--;  // Trim spaces",
          "1447:     h[i].name = k;",
          "1448:     h[i].value = v;",
          "1449:   }",
          "1450: }",
          "1452: int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {",
          "",
          "[Removed Lines]",
          "1434: static void mg_http_parse_headers(const char *s, const char *end,",
          "1439:     const char *he = skip(s, end, \"\\n\", &tmp);",
          "1444:     if (k.len == 0) break;",
          "",
          "[Added Lines]",
          "1434: static bool mg_http_parse_headers(const char *s, const char *end,",
          "1439:     const char *he = skip(s, end, \"\\r\\n\", &tmp);",
          "1440:     if (tmp.len == 0) break;  // empty header = EOH",
          "1445:     if (k.len == 0) return false;                          // empty name",
          "1451:   return true;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1478:     hm->uri.len = (size_t) (qs - hm->uri.ptr);",
          "1479:   }",
          "1483:   if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {",
          "1484:     if (mg_to_size_t(*cl, &hm->body.len) == false) return -1;",
          "1485:     hm->message.len = (size_t) req_len + hm->body.len;",
          "",
          "[Removed Lines]",
          "1481:   mg_http_parse_headers(s, end, hm->headers,",
          "1482:                         sizeof(hm->headers) / sizeof(hm->headers[0]));",
          "",
          "[Added Lines]",
          "1483:   if (!mg_http_parse_headers(s, end, hm->headers,",
          "1484:                              sizeof(hm->headers) / sizeof(hm->headers[0])))",
          "1485:     return -1;  // error when parsing",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "199:   return NULL;",
          "200: }",
          "203:                                   struct mg_http_header *h, int max_headers) {",
          "204:   int i;",
          "205:   for (i = 0; i < max_headers; i++) {",
          "206:     struct mg_str k, v, tmp;",
          "208:     s = skip(s, he, \": \\r\\n\", &k);",
          "209:     s = skip(s, he, \"\\r\\n\", &v);",
          "210:     if (k.len == tmp.len) continue;",
          "211:     while (v.len > 0 && v.ptr[v.len - 1] == ' ') v.len--;  // Trim spaces",
          "215:     h[i].name = k;",
          "216:     h[i].value = v;",
          "217:   }",
          "218: }",
          "220: int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {",
          "",
          "[Removed Lines]",
          "202: static void mg_http_parse_headers(const char *s, const char *end,",
          "207:     const char *he = skip(s, end, \"\\n\", &tmp);",
          "212:     if (k.len == 0) break;",
          "",
          "[Added Lines]",
          "202: static bool mg_http_parse_headers(const char *s, const char *end,",
          "207:     const char *he = skip(s, end, \"\\r\\n\", &tmp);",
          "208:     if (tmp.len == 0) break;  // empty header = EOH",
          "213:     if (k.len == 0) return false;                          // empty name",
          "219:   return true;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "246:     hm->uri.len = (size_t) (qs - hm->uri.ptr);",
          "247:   }",
          "251:   if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {",
          "252:     if (mg_to_size_t(*cl, &hm->body.len) == false) return -1;",
          "253:     hm->message.len = (size_t) req_len + hm->body.len;",
          "",
          "[Removed Lines]",
          "249:   mg_http_parse_headers(s, end, hm->headers,",
          "250:                         sizeof(hm->headers) / sizeof(hm->headers[0]));",
          "",
          "[Added Lines]",
          "251:   if (!mg_http_parse_headers(s, end, hm->headers,",
          "252:                              sizeof(hm->headers) / sizeof(hm->headers[0])))",
          "253:     return -1;  // error when parsing",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fa54a22aedd79854b6139680bc6c590c8a666454",
      "candidate_info": {
        "commit_hash": "fa54a22aedd79854b6139680bc6c590c8a666454",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/fa54a22aedd79854b6139680bc6c590c8a666454",
        "files": [
          "Makefile",
          "examples/device-dashboard/net.c",
          "examples/device-dashboard/web_root/main.js",
          "examples/stm32/nucleo-h563zi-make-baremetal-builtin/mongoose_custom.h",
          "examples/stm32/nucleo-h743zi-make-baremetal-builtin/mongoose_custom.h",
          "mongoose.c",
          "mongoose.h",
          "src/device.h",
          "src/device_dummy.c",
          "src/device_flash.c",
          "src/device_stm32h5.c",
          "src/device_stm32h7.c",
          "src/ota_flash.c"
        ],
        "message": "OTA API refactoring: renamed files and defines",
        "before_after_code_files": [
          "examples/device-dashboard/net.c||examples/device-dashboard/net.c",
          "examples/device-dashboard/web_root/main.js||examples/device-dashboard/web_root/main.js",
          "examples/stm32/nucleo-h563zi-make-baremetal-builtin/mongoose_custom.h||examples/stm32/nucleo-h563zi-make-baremetal-builtin/mongoose_custom.h",
          "examples/stm32/nucleo-h743zi-make-baremetal-builtin/mongoose_custom.h||examples/stm32/nucleo-h743zi-make-baremetal-builtin/mongoose_custom.h",
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h",
          "src/sys.h||src/device.h",
          "src/sys_dummy.c||src/device_dummy.c",
          "src/sys_flash.c||src/device_flash.c",
          "src/sys_stm32h5.c||src/device_stm32h5.c",
          "src/sys_stm32h7.c||src/device_stm32h7.c",
          "src/ota_flash.c||src/ota_flash.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c"
          ]
        }
      },
      "candidate_diff": {
        "examples/device-dashboard/net.c||examples/device-dashboard/net.c": [
          "File: examples/device-dashboard/net.c -> examples/device-dashboard/net.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "222:     mg_http_reply(c, 200, s_json_header, \"true\\n\");",
          "223:     if (data.len == 0) {",
          "226:     }",
          "227:   }",
          "228: }",
          "",
          "[Removed Lines]",
          "225:       mg_timer_add(c->mgr, 500, 0, (void (*)(void *)) mg_sys_reset, NULL);",
          "",
          "[Added Lines]",
          "225:       mg_timer_add(c->mgr, 500, 0, (void (*)(void *)) mg_device_reset, NULL);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "250:                 MG_FIRMWARE_CURRENT, print_status, MG_FIRMWARE_PREVIOUS);",
          "251: }",
          "254:   mg_http_reply(c, 200, s_json_header, \"true\\n\");",
          "256: }",
          "",
          "[Removed Lines]",
          "253: static void handle_sys_reset(struct mg_connection *c) {",
          "255:   mg_timer_add(c->mgr, 500, 0, (void (*)(void *)) mg_sys_reset, NULL);",
          "",
          "[Added Lines]",
          "253: static void handle_device_reset(struct mg_connection *c) {",
          "255:   mg_timer_add(c->mgr, 500, 0, (void (*)(void *)) mg_device_reset, NULL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "292:       handle_firmware_rollback(c);",
          "293:     } else if (mg_http_match_uri(hm, \"/api/firmware/status\")) {",
          "294:       handle_firmware_status(c);",
          "297:     } else {",
          "298:       struct mg_http_serve_opts opts;",
          "299:       memset(&opts, 0, sizeof(opts));",
          "",
          "[Removed Lines]",
          "295:     } else if (mg_http_match_uri(hm, \"/api/sys/reset\")) {",
          "296:       handle_sys_reset(c);",
          "",
          "[Added Lines]",
          "295:     } else if (mg_http_match_uri(hm, \"/api/device/reset\")) {",
          "296:       handle_device_reset(c);",
          "",
          "---------------"
        ],
        "examples/device-dashboard/web_root/main.js||examples/device-dashboard/web_root/main.js": [
          "File: examples/device-dashboard/web_root/main.js -> examples/device-dashboard/web_root/main.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "211:   const oncommit = ev => fetch('api/firmware/commit')",
          "212:     .then(r => r.json())",
          "213:     .then(refresh);",
          "215:     .then(r => r.json())",
          "216:     .then(r => new Promise(r => setTimeout(ev => { refresh(); r(); }, 3000)));",
          "217:   const onrollback = ev => fetch('api/firmware/rollback')",
          "",
          "[Removed Lines]",
          "214:   const onreboot = ev => fetch('api/sys/reset')",
          "",
          "[Added Lines]",
          "214:   const onreboot = ev => fetch('api/device/reset')",
          "",
          "---------------"
        ],
        "examples/stm32/nucleo-h563zi-make-baremetal-builtin/mongoose_custom.h||examples/stm32/nucleo-h563zi-make-baremetal-builtin/mongoose_custom.h": [
          "File: examples/stm32/nucleo-h563zi-make-baremetal-builtin/mongoose_custom.h -> examples/stm32/nucleo-h563zi-make-baremetal-builtin/mongoose_custom.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #define MG_ARCH MG_ARCH_NEWLIB",
          "4: #define MG_OTA MG_OTA_FLASH",
          "7: #define MG_ENABLE_TCPIP 1",
          "8: #define MG_ENABLE_CUSTOM_MILLIS 1",
          "",
          "[Removed Lines]",
          "5: #define MG_SYS MG_SYS_STM32H5",
          "",
          "[Added Lines]",
          "5: #define MG_DEVICE MG_DEVICE_STM32H5",
          "",
          "---------------"
        ],
        "examples/stm32/nucleo-h743zi-make-baremetal-builtin/mongoose_custom.h||examples/stm32/nucleo-h743zi-make-baremetal-builtin/mongoose_custom.h": [
          "File: examples/stm32/nucleo-h743zi-make-baremetal-builtin/mongoose_custom.h -> examples/stm32/nucleo-h743zi-make-baremetal-builtin/mongoose_custom.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #define MG_ARCH MG_ARCH_NEWLIB",
          "4: #define MG_OTA MG_OTA_FLASH",
          "7: #define MG_ENABLE_TCPIP 1",
          "8: #define MG_ENABLE_CUSTOM_MILLIS 1",
          "",
          "[Removed Lines]",
          "5: #define MG_SYS MG_SYS_STM32H7",
          "",
          "[Added Lines]",
          "5: #define MG_DEVICE MG_DEVICE_STM32H7",
          "",
          "---------------"
        ],
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "113: }",
          "115: #ifdef MG_ENABLE_LINES",
          "117: #endif",
          "139: }",
          "147:   }",
          "148: }",
          "162:     }",
          "171:     }",
          "176:     }",
          "182:   }",
          "185: }",
          "252: }",
          "310: }",
          "337: }",
          "369: }",
          "382: }",
          "398: }",
          "409: }",
          "420: }",
          "432: }",
          "441: }",
          "451: }",
          "485:   } else {",
          "502:     }",
          "503:   }",
          "532: }",
          "539: }",
          "548: }",
          "636: }",
          "638: #ifdef MG_ENABLE_LINES",
          "640: #endif",
          "683: }",
          "700:   }",
          "702: }",
          "714: }",
          "732: }",
          "747: }",
          "759: }",
          "771:   } else {",
          "799:   }",
          "801: }",
          "808: }",
          "818:   }",
          "825: }",
          "830: }",
          "859: };",
          "895: }",
          "915:   }",
          "916: }",
          "927:   }",
          "941: }",
          "946: }",
          "968: }",
          "1007:     }",
          "1008:   }",
          "1017: }",
          "1043:   }",
          "1046: }",
          "1065:   }",
          "1067: }",
          "1088:     }",
          "1089:   }",
          "1099:   } else {",
          "1102:   }",
          "1104: }",
          "1121:   } else {",
          "1123:   }",
          "1125: }",
          "1141: #endif",
          "1167: }",
          "1232: }",
          "1238: #ifdef MG_ENABLE_LINES",
          "1240: #endif",
          "1266:   }",
          "1272: }",
          "1317:   }",
          "1327: }",
          "1353: }",
          "1361:     }",
          "1362:   }",
          "1364: }",
          "1381:     }",
          "1382:   }",
          "1384: }",
          "1389: }",
          "1400:       } else {",
          "1402:       }",
          "1407:     }",
          "1408:   }",
          "1415: }",
          "1432:   }",
          "1444: }",
          "1454: }",
          "1505:   }",
          "1517:   }",
          "1537:   }",
          "1544:   }",
          "1548: }",
          "1559:   }",
          "1561: }",
          "1568: }",
          "1575: }",
          "1645: }",
          "1664: }",
          "1672: }",
          "1736: };",
          "1756:   }",
          "1759: }",
          "1773:   }",
          "1775: }",
          "1783:   size_t size = 0;",
          "1799:   }",
          "1862:     }",
          "1863:   }",
          "1864: }",
          "1871: };",
          "1888:   } else {",
          "1892:     } else {",
          "1894:     }",
          "1901:     }",
          "1904: #endif",
          "1911:   }",
          "1912: }",
          "1979: }",
          "2040: }",
          "2054: }",
          "2066: #else",
          "2068: #endif",
          "2075: }",
          "2080: }",
          "2098: }",
          "2120: }",
          "2143: }",
          "2147: }",
          "2183: }",
          "2187: }",
          "2192: }",
          "2217: }",
          "2223: }",
          "2229: }",
          "2265: }",
          "2289: }",
          "2430: }",
          "2445: }",
          "2451:   }",
          "2453: }",
          "2464:     }",
          "2465:   }",
          "2467: }",
          "2478:   }",
          "2494:     }",
          "2496:   }",
          "2509:   }",
          "2513: }",
          "2654:   }",
          "2664:   }",
          "2666: }",
          "2673:   }",
          "2675: }",
          "2700: }",
          "2712:   }",
          "2714: }",
          "2724:   }",
          "2726: }",
          "2738: }",
          "2745: }",
          "2771: }",
          "2776: }",
          "2792:   }",
          "2819:     }",
          "2823:   }",
          "2826: }",
          "2844:   } else {",
          "2846:   }",
          "2847: }",
          "2951: }",
          "2969:     }",
          "2975:   }",
          "2983:   }",
          "2986: }",
          "3003:   } else {",
          "3005:   }",
          "3016: }",
          "3081: }",
          "3085: }",
          "3089: }",
          "3098: }",
          "3111: }",
          "3123:   }",
          "3126: }",
          "3132:   }",
          "3134: }",
          "3164:         break;",
          "3167:     }",
          "3168:   }",
          "3179: }",
          "3219:     }",
          "3220:   }",
          "3221: }",
          "3275: }",
          "3341: }",
          "3358:   }",
          "3363: }",
          "3378: }",
          "3399:   }",
          "3443:     }",
          "3446:   }",
          "3448: }",
          "3516:     }",
          "3517:   }",
          "3552:   }",
          "3561: }",
          "3578: }",
          "3587: }",
          "3595: }",
          "3615:     } else {",
          "3617:     }",
          "3618:   }",
          "3623: }",
          "3632:   }",
          "3641: }",
          "3670:   }",
          "3675:   }",
          "3679: }",
          "3685: }",
          "3696: }",
          "3713: }",
          "3722:   } else {",
          "3732:   }",
          "3734: }",
          "3756: }",
          "3770: }",
          "3778:   }",
          "3780: }",
          "3795: #endif",
          "3975: }",
          "4021: }",
          "4110: }",
          "4121: }",
          "4131: }",
          "4146: }",
          "4201: }",
          "4247:   }",
          "4249: }",
          "4285:   }",
          "4286: }",
          "4306:     }",
          "4307:   }",
          "4338: }",
          "4347: }",
          "4355:   }",
          "4374: }",
          "4386:   }",
          "4392:   }",
          "4399:   }",
          "4420:   }",
          "4422: }",
          "4431: }",
          "4451:       }",
          "4470:     }",
          "4513:         }",
          "4514:       }",
          "4519:     }",
          "4520:   }",
          "4521: }",
          "4614: }",
          "4630: }",
          "4674: }",
          "4755: }",
          "4768:   }",
          "4769: }",
          "4800: }",
          "4805: }",
          "4811: }",
          "4821: }",
          "4861: }",
          "4866: }",
          "4874:   }",
          "4875: }",
          "4888:   }",
          "4889: }",
          "4900: }",
          "4919:   }",
          "4921: }",
          "4935:   } else {",
          "4937:   }",
          "4981: }",
          "5023:     }",
          "5024:   }",
          "5026: }",
          "5032:   } else {",
          "5042:     }",
          "5046:   }",
          "5048: }",
          "5069: }",
          "5105: }",
          "5111: #endif",
          "5115: #endif",
          "5125:   } else {",
          "5128:   }",
          "5139: }",
          "5149:   }",
          "5150: }",
          "5232: }",
          "5238:   }",
          "5240: }",
          "5255:     }",
          "5256:   }",
          "5273:   }",
          "5285:   }",
          "5332: }",
          "5340: }",
          "5346: }",
          "5359: }",
          "5369:   }",
          "5373: }",
          "5380: }",
          "5385: }",
          "5400: }",
          "5412:   }",
          "5413: }",
          "5421:   } else {",
          "5423:   }",
          "5424: }",
          "5468: }",
          "5475: }",
          "5486: }",
          "5490: }",
          "5492: #ifdef MG_ENABLE_LINES",
          "5494: #endif",
          "5503: };",
          "5509:   } else {",
          "5512:   }",
          "5514: }",
          "5649: }",
          "5658: }",
          "5678: }",
          "5702: }",
          "5704: #ifdef MG_ENABLE_LINES",
          "5706: #endif",
          "5720: }",
          "5743:   }",
          "5745: }",
          "5763: }",
          "5778: }",
          "5786: }",
          "5821: #endif",
          "5835: #endif",
          "5860: }",
          "5872: }",
          "5880: }",
          "5907:     }",
          "5908:   }",
          "5909: }",
          "5925: }",
          "5937: }",
          "5967: #endif",
          "6020:     } else {",
          "6026:     }",
          "6027:   }",
          "6030: }",
          "6039:   } else {",
          "6041:   }",
          "6046: }",
          "6057:   } else {",
          "6065:   }",
          "6066: }",
          "6076: }",
          "6089: }",
          "6102:   }",
          "6103: }",
          "6120: }",
          "6155:   }",
          "6156: }",
          "6166: }",
          "6186: #endif",
          "6190:   } else {",
          "6208:   }",
          "6209: }",
          "6213: }",
          "6222: }",
          "6308:   }",
          "6328:   }",
          "6339:   }",
          "6350: #endif",
          "6384:     }",
          "6388:   }",
          "6389: }",
          "6392: #ifdef MG_ENABLE_LINES",
          "6394: #endif",
          "6405: #endif",
          "6492: #endif",
          "6496: #endif",
          "6525: }",
          "6532: }",
          "6539: }",
          "6550:     }",
          "6551:   }",
          "6553: }",
          "6563:   }",
          "6567: }",
          "6578:   }",
          "6580: }",
          "6584: }",
          "6614:     } else {",
          "6626: }",
          "6639: }",
          "6649: }",
          "6653: }",
          "6662:   }",
          "6671: }",
          "6677: }",
          "6684: }",
          "6691:     }",
          "6692:   }",
          "6694: }",
          "6729: }",
          "6734: #endif",
          "6756:   }",
          "6758: }",
          "6766: }",
          "6793: }",
          "6806:     }",
          "6807:   }",
          "6811:   }",
          "6833:       }",
          "6834:     }",
          "6838:   }",
          "6845:     }",
          "6846:   }",
          "6848: }",
          "6880:     } else {",
          "6882:     }",
          "6883:   }",
          "6894: }",
          "6895: #endif",
          "6897: #ifdef MG_ENABLE_LINES",
          "6899: #endif",
          "6981:     }",
          "6990:   }",
          "7004: }",
          "7035: }",
          "7040: }",
          "7041: #endif",
          "7043: #ifdef MG_ENABLE_LINES",
          "7045: #endif",
          "7064: }",
          "7067: }",
          "7070: }",
          "7073: }",
          "7076: }",
          "7088:   }",
          "7089: }",
          "7095: }",
          "7099: }",
          "7103: }",
          "7108: }",
          "7112: }",
          "7118: }",
          "7142:   }",
          "7144: }",
          "7157: }",
          "7179:   }",
          "7187: }",
          "7192: }",
          "7195: #ifdef MG_ENABLE_LINES",
          "7196: #line 1 \"src/timer.c\"",
          "",
          "[Removed Lines]",
          "116: #line 1 \"src/dns.c\"",
          "126: struct dns_data {",
          "127:   struct dns_data *next;",
          "128:   struct mg_connection *c;",
          "129:   uint64_t expire;",
          "130:   uint16_t txnid;",
          "131: };",
          "133: static void mg_sendnsreq(struct mg_connection *, struct mg_str *, int,",
          "134:                          struct mg_dns *, bool);",
          "136: static void mg_dns_free(struct dns_data **head, struct dns_data *d) {",
          "137:   LIST_DELETE(struct dns_data, head, d);",
          "138:   free(d);",
          "141: void mg_resolve_cancel(struct mg_connection *c) {",
          "142:   struct dns_data *tmp, *d;",
          "143:   struct dns_data **head = (struct dns_data **) &c->mgr->active_dns_requests;",
          "144:   for (d = *head; d != NULL; d = tmp) {",
          "145:     tmp = d->next;",
          "146:     if (d->c == c) mg_dns_free(head, d);",
          "150: static size_t mg_dns_parse_name_depth(const uint8_t *s, size_t len, size_t ofs,",
          "151:                                       char *to, size_t tolen, size_t j,",
          "152:                                       int depth) {",
          "153:   size_t i = 0;",
          "154:   if (tolen > 0 && depth == 0) to[0] = '\\0';",
          "155:   if (depth > 5) return 0;",
          "157:   while (ofs + i + 1 < len) {",
          "158:     size_t n = s[ofs + i];",
          "159:     if (n == 0) {",
          "160:       i++;",
          "161:       break;",
          "163:     if (n & 0xc0) {",
          "164:       size_t ptr = (((n & 0x3f) << 8) | s[ofs + i + 1]);  // 12 is hdr len",
          "166:       if (ptr + 1 < len && (s[ptr] & 0xc0) == 0 &&",
          "167:           mg_dns_parse_name_depth(s, len, ptr, to, tolen, j, depth + 1) == 0)",
          "168:         return 0;",
          "169:       i += 2;",
          "170:       break;",
          "172:     if (ofs + i + n + 1 >= len) return 0;",
          "173:     if (j > 0) {",
          "174:       if (j < tolen) to[j] = '.';",
          "175:       j++;",
          "177:     if (j + n < tolen) memcpy(&to[j], &s[ofs + i + 1], n);",
          "178:     j += n;",
          "179:     i += n + 1;",
          "180:     if (j < tolen) to[j] = '\\0';  // Zero-terminate this chunk",
          "183:   if (tolen > 0) to[tolen - 1] = '\\0';  // Make sure make sure it is nul-term",
          "184:   return i;",
          "187: static size_t mg_dns_parse_name(const uint8_t *s, size_t n, size_t ofs,",
          "188:                                 char *dst, size_t dstlen) {",
          "189:   return mg_dns_parse_name_depth(s, n, ofs, dst, dstlen, 0, 0);",
          "190: }",
          "192: size_t mg_dns_parse_rr(const uint8_t *buf, size_t len, size_t ofs,",
          "193:                        bool is_question, struct mg_dns_rr *rr) {",
          "194:   const uint8_t *s = buf + ofs, *e = &buf[len];",
          "196:   memset(rr, 0, sizeof(*rr));",
          "197:   if (len < sizeof(struct mg_dns_header)) return 0;  // Too small",
          "198:   if (len > 512) return 0;  //  Too large, we don't expect that",
          "199:   if (s >= e) return 0;     //  Overflow",
          "201:   if ((rr->nlen = (uint16_t) mg_dns_parse_name(buf, len, ofs, NULL, 0)) == 0)",
          "202:     return 0;",
          "203:   s += rr->nlen + 4;",
          "204:   if (s > e) return 0;",
          "205:   rr->atype = (uint16_t) (((uint16_t) s[-4] << 8) | s[-3]);",
          "206:   rr->aclass = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);",
          "207:   if (is_question) return (size_t) (rr->nlen + 4);",
          "209:   s += 6;",
          "210:   if (s > e) return 0;",
          "211:   rr->alen = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);",
          "212:   if (s + rr->alen > e) return 0;",
          "213:   return (size_t) (rr->nlen + rr->alen + 10);",
          "214: }",
          "216: bool mg_dns_parse(const uint8_t *buf, size_t len, struct mg_dns_message *dm) {",
          "217:   const struct mg_dns_header *h = (struct mg_dns_header *) buf;",
          "218:   struct mg_dns_rr rr;",
          "219:   size_t i, n, ofs = sizeof(*h);",
          "220:   memset(dm, 0, sizeof(*dm));",
          "222:   if (len < sizeof(*h)) return 0;                // Too small, headers dont fit",
          "223:   if (mg_ntohs(h->num_questions) > 1) return 0;  // Sanity",
          "224:   if (mg_ntohs(h->num_answers) > 10) return 0;   // Sanity",
          "225:   dm->txnid = mg_ntohs(h->txnid);",
          "227:   for (i = 0; i < mg_ntohs(h->num_questions); i++) {",
          "228:     if ((n = mg_dns_parse_rr(buf, len, ofs, true, &rr)) == 0) return false;",
          "230:     ofs += n;",
          "231:   }",
          "232:   for (i = 0; i < mg_ntohs(h->num_answers); i++) {",
          "233:     if ((n = mg_dns_parse_rr(buf, len, ofs, false, &rr)) == 0) return false;",
          "236:     mg_dns_parse_name(buf, len, ofs, dm->name, sizeof(dm->name));",
          "237:     ofs += n;",
          "239:     if (rr.alen == 4 && rr.atype == 1 && rr.aclass == 1) {",
          "240:       dm->addr.is_ip6 = false;",
          "241:       memcpy(&dm->addr.ip, &buf[ofs - 4], 4);",
          "242:       dm->resolved = true;",
          "243:       break;  // Return success",
          "244:     } else if (rr.alen == 16 && rr.atype == 28 && rr.aclass == 1) {",
          "245:       dm->addr.is_ip6 = true;",
          "246:       memcpy(&dm->addr.ip, &buf[ofs - 16], 16);",
          "247:       dm->resolved = true;",
          "248:       break;  // Return success",
          "249:     }",
          "250:   }",
          "251:   return true;",
          "254: static void dns_cb(struct mg_connection *c, int ev, void *ev_data,",
          "255:                    void *fn_data) {",
          "256:   struct dns_data *d, *tmp;",
          "257:   struct dns_data **head = (struct dns_data **) &c->mgr->active_dns_requests;",
          "258:   if (ev == MG_EV_POLL) {",
          "259:     uint64_t now = *(uint64_t *) ev_data;",
          "260:     for (d = *head; d != NULL; d = tmp) {",
          "261:       tmp = d->next;",
          "263:       if (now > d->expire) mg_error(d->c, \"DNS timeout\");",
          "264:     }",
          "265:   } else if (ev == MG_EV_READ) {",
          "266:     struct mg_dns_message dm;",
          "267:     int resolved = 0;",
          "268:     if (mg_dns_parse(c->recv.buf, c->recv.len, &dm) == false) {",
          "269:       MG_ERROR((\"Unexpected DNS response:\"));",
          "270:       mg_hexdump(c->recv.buf, c->recv.len);",
          "271:     } else {",
          "273:       for (d = *head; d != NULL; d = tmp) {",
          "274:         tmp = d->next;",
          "276:         if (dm.txnid != d->txnid) continue;",
          "277:         if (d->c->is_resolving) {",
          "278:           if (dm.resolved) {",
          "279:             dm.addr.port = d->c->rem.port;  // Save port",
          "280:             d->c->rem = dm.addr;            // Copy resolved address",
          "281:             MG_DEBUG(",
          "282:                 (\"%lu %s is %M\", d->c->id, dm.name, mg_print_ip, &d->c->rem));",
          "283:             mg_connect_resolved(d->c);",
          "284: #if MG_ENABLE_IPV6",
          "285:           } else if (dm.addr.is_ip6 == false && dm.name[0] != '\\0' &&",
          "286:                      c->mgr->use_dns6 == false) {",
          "287:             struct mg_str x = mg_str(dm.name);",
          "288:             mg_sendnsreq(d->c, &x, c->mgr->dnstimeout, &c->mgr->dns6, true);",
          "289: #endif",
          "290:           } else {",
          "291:             mg_error(d->c, \"%s DNS lookup failed\", dm.name);",
          "292:           }",
          "293:         } else {",
          "294:           MG_ERROR((\"%lu already resolved\", d->c->id));",
          "295:         }",
          "296:         mg_dns_free(head, d);",
          "297:         resolved = 1;",
          "298:       }",
          "299:     }",
          "300:     if (!resolved) MG_ERROR((\"stray DNS reply\"));",
          "301:     c->recv.len = 0;",
          "302:   } else if (ev == MG_EV_CLOSE) {",
          "303:     for (d = *head; d != NULL; d = tmp) {",
          "304:       tmp = d->next;",
          "305:       mg_error(d->c, \"DNS error\");",
          "306:       mg_dns_free(head, d);",
          "307:     }",
          "308:   }",
          "309:   (void) fn_data;",
          "312: static bool mg_dns_send(struct mg_connection *c, const struct mg_str *name,",
          "313:                         uint16_t txnid, bool ipv6) {",
          "314:   struct {",
          "315:     struct mg_dns_header header;",
          "316:     uint8_t data[256];",
          "317:   } pkt;",
          "318:   size_t i, n;",
          "319:   memset(&pkt, 0, sizeof(pkt));",
          "320:   pkt.header.txnid = mg_htons(txnid);",
          "321:   pkt.header.flags = mg_htons(0x100);",
          "322:   pkt.header.num_questions = mg_htons(1);",
          "323:   for (i = n = 0; i < sizeof(pkt.data) - 5; i++) {",
          "324:     if (name->ptr[i] == '.' || i >= name->len) {",
          "325:       pkt.data[n] = (uint8_t) (i - n);",
          "326:       memcpy(&pkt.data[n + 1], name->ptr + n, i - n);",
          "327:       n = i + 1;",
          "328:     }",
          "329:     if (i >= name->len) break;",
          "330:   }",
          "331:   memcpy(&pkt.data[n], \"\\x00\\x00\\x01\\x00\\x01\", 5);  // A query",
          "332:   n += 5;",
          "333:   if (ipv6) pkt.data[n - 3] = 0x1c;  // AAAA query",
          "336:   return mg_send(c, &pkt, sizeof(pkt.header) + n);",
          "339: static void mg_sendnsreq(struct mg_connection *c, struct mg_str *name, int ms,",
          "340:                          struct mg_dns *dnsc, bool ipv6) {",
          "341:   struct dns_data *d = NULL;",
          "342:   if (dnsc->url == NULL) {",
          "343:     mg_error(c, \"DNS server URL is NULL. Call mg_mgr_init()\");",
          "344:   } else if (dnsc->c == NULL) {",
          "345:     dnsc->c = mg_connect(c->mgr, dnsc->url, NULL, NULL);",
          "346:     if (dnsc->c != NULL) {",
          "347:       dnsc->c->pfn = dns_cb;",
          "349:     }",
          "350:   }",
          "351:   if (dnsc->c == NULL) {",
          "352:     mg_error(c, \"resolver\");",
          "353:   } else if ((d = (struct dns_data *) calloc(1, sizeof(*d))) == NULL) {",
          "354:     mg_error(c, \"resolve OOM\");",
          "355:   } else {",
          "356:     struct dns_data *reqs = (struct dns_data *) c->mgr->active_dns_requests;",
          "357:     d->txnid = reqs ? (uint16_t) (reqs->txnid + 1) : 1;",
          "358:     d->next = (struct dns_data *) c->mgr->active_dns_requests;",
          "359:     c->mgr->active_dns_requests = d;",
          "360:     d->expire = mg_millis() + (uint64_t) ms;",
          "361:     d->c = c;",
          "362:     c->is_resolving = 1;",
          "363:     MG_VERBOSE((\"%lu resolving %.*s @ %s, txnid %hu\", c->id, (int) name->len,",
          "364:                 name->ptr, dnsc->url, d->txnid));",
          "365:     if (!mg_dns_send(dnsc->c, name, d->txnid, ipv6)) {",
          "366:       mg_error(dnsc->c, \"DNS send\");",
          "367:     }",
          "368:   }",
          "371: void mg_resolve(struct mg_connection *c, const char *url) {",
          "372:   struct mg_str host = mg_url_host(url);",
          "373:   c->rem.port = mg_htons(mg_url_port(url));",
          "374:   if (mg_aton(host, &c->rem)) {",
          "376:     mg_connect_resolved(c);",
          "377:   } else {",
          "379:     struct mg_dns *dns = c->mgr->use_dns6 ? &c->mgr->dns6 : &c->mgr->dns4;",
          "380:     mg_sendnsreq(c, &host, c->mgr->dnstimeout, dns, c->mgr->use_dns6);",
          "381:   }",
          "384: #ifdef MG_ENABLE_LINES",
          "385: #line 1 \"src/event.c\"",
          "386: #endif",
          "392: void mg_call(struct mg_connection *c, int ev, void *ev_data) {",
          "396:   if (c->fn != NULL) c->fn(c, ev, ev_data, c->fn_data);",
          "397:   if (c->pfn != NULL) c->pfn(c, ev, ev_data, c->pfn_data);",
          "400: void mg_error(struct mg_connection *c, const char *fmt, ...) {",
          "401:   char buf[64];",
          "402:   va_list ap;",
          "403:   va_start(ap, fmt);",
          "404:   mg_vsnprintf(buf, sizeof(buf), fmt, &ap);",
          "405:   va_end(ap);",
          "406:   MG_ERROR((\"%lu %ld %s\", c->id, c->fd, buf));",
          "407:   c->is_closing = 1;             // Set is_closing before sending MG_EV_CALL",
          "408:   mg_call(c, MG_EV_ERROR, buf);  // Let user handler to override it",
          "411: #ifdef MG_ENABLE_LINES",
          "412: #line 1 \"src/fmt.c\"",
          "413: #endif",
          "418: static bool is_digit(int c) {",
          "419:   return c >= '0' && c <= '9';",
          "422: static int addexp(char *buf, int e, int sign) {",
          "423:   int n = 0;",
          "424:   buf[n++] = 'e';",
          "425:   buf[n++] = (char) sign;",
          "426:   if (e > 400) return 0;",
          "427:   if (e < 10) buf[n++] = '0';",
          "428:   if (e >= 100) buf[n++] = (char) (e / 100 + '0'), e -= 100 * (e / 100);",
          "429:   if (e >= 10) buf[n++] = (char) (e / 10 + '0'), e -= 10 * (e / 10);",
          "430:   buf[n++] = (char) (e + '0');",
          "431:   return n;",
          "434: static int xisinf(double x) {",
          "435:   union {",
          "436:     double f;",
          "437:     uint64_t u;",
          "438:   } ieee754 = {x};",
          "439:   return ((unsigned) (ieee754.u >> 32) & 0x7fffffff) == 0x7ff00000 &&",
          "440:          ((unsigned) ieee754.u == 0);",
          "443: static int xisnan(double x) {",
          "444:   union {",
          "445:     double f;",
          "446:     uint64_t u;",
          "447:   } ieee754 = {x};",
          "448:   return ((unsigned) (ieee754.u >> 32) & 0x7fffffff) +",
          "449:              ((unsigned) ieee754.u != 0) >",
          "450:          0x7ff00000;",
          "453: static size_t mg_dtoa(char *dst, size_t dstlen, double d, int width, bool tz) {",
          "454:   char buf[40];",
          "455:   int i, s = 0, n = 0, e = 0;",
          "456:   double t, mul, saved;",
          "457:   if (d == 0.0) return mg_snprintf(dst, dstlen, \"%s\", \"0\");",
          "458:   if (xisinf(d)) return mg_snprintf(dst, dstlen, \"%s\", d > 0 ? \"inf\" : \"-inf\");",
          "459:   if (xisnan(d)) return mg_snprintf(dst, dstlen, \"%s\", \"nan\");",
          "460:   if (d < 0.0) d = -d, buf[s++] = '-';",
          "463:   saved = d;",
          "464:   mul = 1.0;",
          "465:   while (d >= 10.0 && d / mul >= 10.0) mul *= 10.0;",
          "466:   while (d <= 1.0 && d / mul <= 1.0) mul /= 10.0;",
          "467:   for (i = 0, t = mul * 5; i < width; i++) t /= 10.0;",
          "468:   d += t;",
          "470:   mul = 1.0;",
          "471:   while (d >= 10.0 && d / mul >= 10.0) mul *= 10.0, e++;",
          "472:   while (d < 1.0 && d / mul < 1.0) mul /= 10.0, e--;",
          "475:   if (e >= width && width > 1) {",
          "476:     n = (int) mg_dtoa(buf, sizeof(buf), saved / mul, width, tz);",
          "478:     n += addexp(buf + s + n, e, '+');",
          "479:     return mg_snprintf(dst, dstlen, \"%.*s\", n, buf);",
          "480:   } else if (e <= -width && width > 1) {",
          "481:     n = (int) mg_dtoa(buf, sizeof(buf), saved / mul, width, tz);",
          "483:     n += addexp(buf + s + n, -e, '-');",
          "484:     return mg_snprintf(dst, dstlen, \"%.*s\", n, buf);",
          "486:     for (i = 0, t = mul; t >= 1.0 && s + n < (int) sizeof(buf); i++) {",
          "487:       int ch = (int) (d / t);",
          "488:       if (n > 0 || ch > 0) buf[s + n++] = (char) (ch + '0');",
          "489:       d -= ch * t;",
          "490:       t /= 10.0;",
          "491:     }",
          "493:     if (n == 0) buf[s++] = '0';",
          "494:     while (t >= 1.0 && n + s < (int) sizeof(buf)) buf[n++] = '0', t /= 10.0;",
          "495:     if (s + n < (int) sizeof(buf)) buf[n + s++] = '.';",
          "497:     for (i = 0, t = 0.1; s + n < (int) sizeof(buf) && n < width; i++) {",
          "498:       int ch = (int) (d / t);",
          "499:       buf[s + n++] = (char) (ch + '0');",
          "500:       d -= ch * t;",
          "501:       t /= 10.0;",
          "504:   while (tz && n > 0 && buf[s + n - 1] == '0') n--;  // Trim trailing zeroes",
          "505:   if (n > 0 && buf[s + n - 1] == '.') n--;           // Trim trailing dot",
          "506:   n += s;",
          "507:   if (n >= (int) sizeof(buf)) n = (int) sizeof(buf) - 1;",
          "508:   buf[n] = '\\0';",
          "509:   return mg_snprintf(dst, dstlen, \"%s\", buf);",
          "510: }",
          "512: static size_t mg_lld(char *buf, int64_t val, bool is_signed, bool is_hex) {",
          "513:   const char *letters = \"0123456789abcdef\";",
          "514:   uint64_t v = (uint64_t) val;",
          "515:   size_t s = 0, n, i;",
          "516:   if (is_signed && val < 0) buf[s++] = '-', v = (uint64_t) (-val);",
          "520:   if (is_hex) {",
          "521:     for (n = 0; v; v >>= 4) buf[s + n++] = letters[v & 15];",
          "522:   } else {",
          "523:     for (n = 0; v; v /= 10) buf[s + n++] = letters[v % 10];",
          "524:   }",
          "526:   for (i = 0; i < n / 2; i++) {",
          "527:     char t = buf[s + i];",
          "528:     buf[s + i] = buf[s + n - i - 1], buf[s + n - i - 1] = t;",
          "529:   }",
          "530:   if (val == 0) buf[n++] = '0';  // Handle special case",
          "531:   return n + s;",
          "534: static size_t scpy(void (*out)(char, void *), void *ptr, char *buf,",
          "535:                           size_t len) {",
          "536:   size_t i = 0;",
          "537:   while (i < len && buf[i] != '\\0') out(buf[i++], ptr);",
          "538:   return i;",
          "541: size_t mg_xprintf(void (*out)(char, void *), void *ptr, const char *fmt, ...) {",
          "542:   size_t len = 0;",
          "543:   va_list ap;",
          "544:   va_start(ap, fmt);",
          "545:   len = mg_vxprintf(out, ptr, fmt, &ap);",
          "546:   va_end(ap);",
          "547:   return len;",
          "550: size_t mg_vxprintf(void (*out)(char, void *), void *param, const char *fmt,",
          "551:                    va_list *ap) {",
          "552:   size_t i = 0, n = 0;",
          "553:   while (fmt[i] != '\\0') {",
          "554:     if (fmt[i] == '%') {",
          "555:       size_t j, k, x = 0, is_long = 0, w = 0 /* width */, pr = ~0U /* prec */;",
          "556:       char pad = ' ', minus = 0, c = fmt[++i];",
          "557:       if (c == '#') x++, c = fmt[++i];",
          "558:       if (c == '-') minus++, c = fmt[++i];",
          "559:       if (c == '0') pad = '0', c = fmt[++i];",
          "560:       while (is_digit(c)) w *= 10, w += (size_t) (c - '0'), c = fmt[++i];",
          "561:       if (c == '.') {",
          "562:         c = fmt[++i];",
          "563:         if (c == '*') {",
          "564:           pr = (size_t) va_arg(*ap, int);",
          "565:           c = fmt[++i];",
          "566:         } else {",
          "567:           pr = 0;",
          "568:           while (is_digit(c)) pr *= 10, pr += (size_t) (c - '0'), c = fmt[++i];",
          "569:         }",
          "570:       }",
          "571:       while (c == 'h') c = fmt[++i];  // Treat h and hh as int",
          "572:       if (c == 'l') {",
          "573:         is_long++, c = fmt[++i];",
          "574:         if (c == 'l') is_long++, c = fmt[++i];",
          "575:       }",
          "576:       if (c == 'p') x = 1, is_long = 1;",
          "577:       if (c == 'd' || c == 'u' || c == 'x' || c == 'X' || c == 'p' ||",
          "578:           c == 'g' || c == 'f') {",
          "579:         bool s = (c == 'd'), h = (c == 'x' || c == 'X' || c == 'p');",
          "580:         char tmp[40];",
          "581:         size_t xl = x ? 2 : 0;",
          "582:         if (c == 'g' || c == 'f') {",
          "583:           double v = va_arg(*ap, double);",
          "584:           if (pr == ~0U) pr = 6;",
          "585:           k = mg_dtoa(tmp, sizeof(tmp), v, (int) pr, c == 'g');",
          "586:         } else if (is_long == 2) {",
          "587:           int64_t v = va_arg(*ap, int64_t);",
          "588:           k = mg_lld(tmp, v, s, h);",
          "589:         } else if (is_long == 1) {",
          "590:           long v = va_arg(*ap, long);",
          "591:           k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned long) v, s, h);",
          "592:         } else {",
          "593:           int v = va_arg(*ap, int);",
          "594:           k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned) v, s, h);",
          "595:         }",
          "596:         for (j = 0; j < xl && w > 0; j++) w--;",
          "597:         for (j = 0; pad == ' ' && !minus && k < w && j + k < w; j++)",
          "598:           n += scpy(out, param, &pad, 1);",
          "599:         n += scpy(out, param, (char *) \"0x\", xl);",
          "600:         for (j = 0; pad == '0' && k < w && j + k < w; j++)",
          "601:           n += scpy(out, param, &pad, 1);",
          "602:         n += scpy(out, param, tmp, k);",
          "603:         for (j = 0; pad == ' ' && minus && k < w && j + k < w; j++)",
          "604:           n += scpy(out, param, &pad, 1);",
          "605:       } else if (c == 'm' || c == 'M') {",
          "606:         mg_pm_t f = va_arg(*ap, mg_pm_t);",
          "607:         if (c == 'm') out('\"', param);",
          "608:         n += f(out, param, ap);",
          "609:         if (c == 'm') n += 2, out('\"', param);",
          "610:       } else if (c == 'c') {",
          "611:         int ch = va_arg(*ap, int);",
          "612:         out((char) ch, param);",
          "613:         n++;",
          "614:       } else if (c == 's') {",
          "615:         char *p = va_arg(*ap, char *);",
          "616:         if (pr == ~0U) pr = p == NULL ? 0 : strlen(p);",
          "617:         for (j = 0; !minus && pr < w && j + pr < w; j++)",
          "618:           n += scpy(out, param, &pad, 1);",
          "619:         n += scpy(out, param, p, pr);",
          "620:         for (j = 0; minus && pr < w && j + pr < w; j++)",
          "621:           n += scpy(out, param, &pad, 1);",
          "622:       } else if (c == '%') {",
          "623:         out('%', param);",
          "624:         n++;",
          "625:       } else {",
          "626:         out('%', param);",
          "627:         out(c, param);",
          "628:         n += 2;",
          "629:       }",
          "630:       i++;",
          "631:     } else {",
          "632:       out(fmt[i], param), n++, i++;",
          "633:     }",
          "634:   }",
          "635:   return n;",
          "639: #line 1 \"src/fs.c\"",
          "644: struct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags) {",
          "645:   struct mg_fd *fd = (struct mg_fd *) calloc(1, sizeof(*fd));",
          "646:   if (fd != NULL) {",
          "647:     fd->fd = fs->op(path, flags);",
          "648:     fd->fs = fs;",
          "649:     if (fd->fd == NULL) {",
          "650:       free(fd);",
          "651:       fd = NULL;",
          "652:     }",
          "653:   }",
          "654:   return fd;",
          "655: }",
          "657: void mg_fs_close(struct mg_fd *fd) {",
          "658:   if (fd != NULL) {",
          "659:     fd->fs->cl(fd->fd);",
          "660:     free(fd);",
          "661:   }",
          "662: }",
          "664: char *mg_file_read(struct mg_fs *fs, const char *path, size_t *sizep) {",
          "665:   struct mg_fd *fd;",
          "666:   char *data = NULL;",
          "667:   size_t size = 0;",
          "668:   fs->st(path, &size, NULL);",
          "669:   if ((fd = mg_fs_open(fs, path, MG_FS_READ)) != NULL) {",
          "670:     data = (char *) calloc(1, size + 1);",
          "671:     if (data != NULL) {",
          "672:       if (fs->rd(fd->fd, data, size) != size) {",
          "673:         free(data);",
          "674:         data = NULL;",
          "675:       } else {",
          "676:         data[size] = '\\0';",
          "677:         if (sizep != NULL) *sizep = size;",
          "678:       }",
          "679:     }",
          "680:     mg_fs_close(fd);",
          "681:   }",
          "682:   return data;",
          "685: bool mg_file_write(struct mg_fs *fs, const char *path, const void *buf,",
          "686:                    size_t len) {",
          "687:   bool result = false;",
          "688:   struct mg_fd *fd;",
          "689:   char tmp[MG_PATH_MAX];",
          "690:   mg_snprintf(tmp, sizeof(tmp), \"%s..%d\", path, rand());",
          "691:   if ((fd = mg_fs_open(fs, tmp, MG_FS_WRITE)) != NULL) {",
          "692:     result = fs->wr(fd->fd, buf, len) == len;",
          "693:     mg_fs_close(fd);",
          "694:     if (result) {",
          "695:       fs->rm(path);",
          "696:       fs->mv(tmp, path);",
          "697:     } else {",
          "698:       fs->rm(tmp);",
          "699:     }",
          "701:   return result;",
          "704: bool mg_file_printf(struct mg_fs *fs, const char *path, const char *fmt, ...) {",
          "705:   va_list ap;",
          "706:   char *data;",
          "707:   bool result = false;",
          "708:   va_start(ap, fmt);",
          "709:   data = mg_vmprintf(fmt, &ap);",
          "710:   va_end(ap);",
          "711:   result = mg_file_write(fs, path, data, strlen(data));",
          "712:   free(data);",
          "713:   return result;",
          "716: #ifdef MG_ENABLE_LINES",
          "717: #line 1 \"src/fs_fat.c\"",
          "718: #endif",
          "722: #if MG_ENABLE_FATFS",
          "723: #include <ff.h>",
          "725: static int mg_days_from_epoch(int y, int m, int d) {",
          "726:   y -= m <= 2;",
          "727:   int era = y / 400;",
          "728:   int yoe = y - era * 400;",
          "729:   int doy = (153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1;",
          "730:   int doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;",
          "731:   return era * 146097 + doe - 719468;",
          "734: static time_t mg_timegm(const struct tm *t) {",
          "735:   int year = t->tm_year + 1900;",
          "736:   int month = t->tm_mon;  // 0-11",
          "737:   if (month > 11) {",
          "738:     year += month / 12;",
          "739:     month %= 12;",
          "740:   } else if (month < 0) {",
          "741:     int years_diff = (11 - month) / 12;",
          "742:     year -= years_diff;",
          "743:     month += 12 * years_diff;",
          "744:   }",
          "745:   int x = mg_days_from_epoch(year, month + 1, t->tm_mday);",
          "746:   return 60 * (60 * (24L * x + t->tm_hour) + t->tm_min) + t->tm_sec;",
          "749: static time_t ff_time_to_epoch(uint16_t fdate, uint16_t ftime) {",
          "750:   struct tm tm;",
          "751:   memset(&tm, 0, sizeof(struct tm));",
          "752:   tm.tm_sec = (ftime << 1) & 0x3e;",
          "753:   tm.tm_min = ((ftime >> 5) & 0x3f);",
          "754:   tm.tm_hour = ((ftime >> 11) & 0x1f);",
          "755:   tm.tm_mday = (fdate & 0x1f);",
          "756:   tm.tm_mon = ((fdate >> 5) & 0x0f) - 1;",
          "757:   tm.tm_year = ((fdate >> 9) & 0x7f) + 80;",
          "758:   return mg_timegm(&tm);",
          "761: static int ff_stat(const char *path, size_t *size, time_t *mtime) {",
          "762:   FILINFO fi;",
          "763:   if (path[0] == '\\0') {",
          "764:     if (size) *size = 0;",
          "765:     if (mtime) *mtime = 0;",
          "766:     return MG_FS_DIR;",
          "767:   } else if (f_stat(path, &fi) == 0) {",
          "768:     if (size) *size = (size_t) fi.fsize;",
          "769:     if (mtime) *mtime = ff_time_to_epoch(fi.fdate, fi.ftime);",
          "770:     return MG_FS_READ | MG_FS_WRITE | ((fi.fattrib & AM_DIR) ? MG_FS_DIR : 0);",
          "772:     return 0;",
          "773:   }",
          "774: }",
          "776: static void ff_list(const char *dir, void (*fn)(const char *, void *),",
          "777:                     void *userdata) {",
          "778:   DIR d;",
          "779:   FILINFO fi;",
          "780:   if (f_opendir(&d, dir) == FR_OK) {",
          "781:     while (f_readdir(&d, &fi) == FR_OK && fi.fname[0] != '\\0') {",
          "782:       if (!strcmp(fi.fname, \".\") || !strcmp(fi.fname, \"..\")) continue;",
          "783:       fn(fi.fname, userdata);",
          "784:     }",
          "785:     f_closedir(&d);",
          "786:   }",
          "787: }",
          "789: static void *ff_open(const char *path, int flags) {",
          "790:   FIL f;",
          "791:   unsigned char mode = FA_READ;",
          "792:   if (flags & MG_FS_WRITE) mode |= FA_WRITE | FA_OPEN_ALWAYS | FA_OPEN_APPEND;",
          "793:   if (f_open(&f, path, mode) == 0) {",
          "794:     FIL *fp;",
          "795:     if ((fp = calloc(1, sizeof(*fp))) != NULL) {",
          "796:       memcpy(fp, &f, sizeof(*fp));",
          "797:       return fp;",
          "798:     }",
          "800:   return NULL;",
          "803: static void ff_close(void *fp) {",
          "804:   if (fp != NULL) {",
          "805:     f_close((FIL *) fp);",
          "806:     free(fp);",
          "807:   }",
          "810: static size_t ff_read(void *fp, void *buf, size_t len) {",
          "811:   UINT n = 0, misalign = ((size_t) buf) & 3;",
          "812:   if (misalign) {",
          "813:     char aligned[4];",
          "814:     f_read((FIL *) fp, aligned, len > misalign ? misalign : len, &n);",
          "815:     memcpy(buf, aligned, n);",
          "816:   } else {",
          "817:     f_read((FIL *) fp, buf, len, &n);",
          "819:   return n;",
          "820: }",
          "822: static size_t ff_write(void *fp, const void *buf, size_t len) {",
          "823:   UINT n = 0;",
          "824:   return f_write((FIL *) fp, (char *) buf, len, &n) == FR_OK ? n : 0;",
          "827: static size_t ff_seek(void *fp, size_t offset) {",
          "828:   f_lseek((FIL *) fp, offset);",
          "829:   return offset;",
          "832: static bool ff_rename(const char *from, const char *to) {",
          "833:   return f_rename(from, to) == FR_OK;",
          "834: }",
          "836: static bool ff_remove(const char *path) {",
          "837:   return f_unlink(path) == FR_OK;",
          "838: }",
          "840: static bool ff_mkdir(const char *path) {",
          "841:   return f_mkdir(path) == FR_OK;",
          "842: }",
          "844: struct mg_fs mg_fs_fat = {ff_stat,  ff_list, ff_open,   ff_close,  ff_read,",
          "845:                           ff_write, ff_seek, ff_rename, ff_remove, ff_mkdir};",
          "846: #endif",
          "848: #ifdef MG_ENABLE_LINES",
          "849: #line 1 \"src/fs_packed.c\"",
          "850: #endif",
          "855: struct packed_file {",
          "856:   const char *data;",
          "857:   size_t size;",
          "858:   size_t pos;",
          "861: #if MG_ENABLE_PACKED_FS",
          "862: #else",
          "863: const char *mg_unpack(const char *path, size_t *size, time_t *mtime) {",
          "865:   (void) path;",
          "866:   return NULL;",
          "867: }",
          "868: const char *mg_unlist(size_t no) {",
          "869:   (void) no;",
          "870:   return NULL;",
          "871: }",
          "872: #endif",
          "874: struct mg_str mg_unpacked(const char *path) {",
          "875:   size_t len = 0;",
          "876:   const char *buf = mg_unpack(path, &len, NULL);",
          "877:   return mg_str_n(buf, len);",
          "878: }",
          "880: static int is_dir_prefix(const char *prefix, size_t n, const char *path) {",
          "882:   return n < strlen(path) && strncmp(prefix, path, n) == 0 &&",
          "883:          (n == 0 || path[n] == '/' || path[n - 1] == '/');",
          "884: }",
          "886: static int packed_stat(const char *path, size_t *size, time_t *mtime) {",
          "887:   const char *p;",
          "888:   size_t i, n = strlen(path);",
          "889:   if (mg_unpack(path, size, mtime)) return MG_FS_READ;  // Regular file",
          "891:   for (i = 0; (p = mg_unlist(i)) != NULL; i++) {",
          "892:     if (is_dir_prefix(path, n, p)) return MG_FS_DIR;",
          "893:   }",
          "894:   return 0;",
          "897: static void packed_list(const char *dir, void (*fn)(const char *, void *),",
          "898:                         void *userdata) {",
          "899:   char buf[MG_PATH_MAX], tmp[sizeof(buf)];",
          "900:   const char *path, *begin, *end;",
          "901:   size_t i, n = strlen(dir);",
          "902:   tmp[0] = '\\0';  // Previously listed entry",
          "903:   for (i = 0; (path = mg_unlist(i)) != NULL; i++) {",
          "904:     if (!is_dir_prefix(dir, n, path)) continue;",
          "905:     begin = &path[n + 1];",
          "906:     end = strchr(begin, '/');",
          "907:     if (end == NULL) end = begin + strlen(begin);",
          "908:     mg_snprintf(buf, sizeof(buf), \"%.*s\", (int) (end - begin), begin);",
          "909:     buf[sizeof(buf) - 1] = '\\0';",
          "912:     if (strcmp(buf, tmp) == 0) continue;",
          "913:     fn(buf, userdata);  // Not yet listed, call user function",
          "914:     strcpy(tmp, buf);   // And save this entry as listed",
          "918: static void *packed_open(const char *path, int flags) {",
          "919:   size_t size = 0;",
          "920:   const char *data = mg_unpack(path, &size, NULL);",
          "921:   struct packed_file *fp = NULL;",
          "922:   if (data == NULL) return NULL;",
          "923:   if (flags & MG_FS_WRITE) return NULL;",
          "924:   if ((fp = (struct packed_file *) calloc(1, sizeof(*fp))) != NULL) {",
          "925:     fp->size = size;",
          "926:     fp->data = data;",
          "928:   return (void *) fp;",
          "929: }",
          "931: static void packed_close(void *fp) {",
          "932:   if (fp != NULL) free(fp);",
          "933: }",
          "935: static size_t packed_read(void *fd, void *buf, size_t len) {",
          "936:   struct packed_file *fp = (struct packed_file *) fd;",
          "937:   if (fp->pos + len > fp->size) len = fp->size - fp->pos;",
          "938:   memcpy(buf, &fp->data[fp->pos], len);",
          "939:   fp->pos += len;",
          "940:   return len;",
          "943: static size_t packed_write(void *fd, const void *buf, size_t len) {",
          "944:   (void) fd, (void) buf, (void) len;",
          "945:   return 0;",
          "948: static size_t packed_seek(void *fd, size_t offset) {",
          "949:   struct packed_file *fp = (struct packed_file *) fd;",
          "950:   fp->pos = offset;",
          "951:   if (fp->pos > fp->size) fp->pos = fp->size;",
          "952:   return fp->pos;",
          "953: }",
          "955: static bool packed_rename(const char *from, const char *to) {",
          "956:   (void) from, (void) to;",
          "957:   return false;",
          "958: }",
          "960: static bool packed_remove(const char *path) {",
          "961:   (void) path;",
          "962:   return false;",
          "963: }",
          "965: static bool packed_mkdir(const char *path) {",
          "966:   (void) path;",
          "967:   return false;",
          "970: struct mg_fs mg_fs_packed = {",
          "971:     packed_stat,  packed_list, packed_open,   packed_close,  packed_read,",
          "972:     packed_write, packed_seek, packed_rename, packed_remove, packed_mkdir};",
          "974: #ifdef MG_ENABLE_LINES",
          "975: #line 1 \"src/fs_posix.c\"",
          "976: #endif",
          "979: #if MG_ENABLE_FILE",
          "981: #ifndef MG_STAT_STRUCT",
          "982: #define MG_STAT_STRUCT stat",
          "983: #endif",
          "985: #ifndef MG_STAT_FUNC",
          "986: #define MG_STAT_FUNC stat",
          "987: #endif",
          "989: static int p_stat(const char *path, size_t *size, time_t *mtime) {",
          "990: #if !defined(S_ISDIR)",
          "991:   MG_ERROR((\"stat() API is not supported. %p %p %p\", path, size, mtime));",
          "992:   return 0;",
          "993: #else",
          "994: #if MG_ARCH == MG_ARCH_WIN32",
          "995:   struct _stati64 st;",
          "996:   wchar_t tmp[MG_PATH_MAX];",
          "997:   MultiByteToWideChar(CP_UTF8, 0, path, -1, tmp, sizeof(tmp) / sizeof(tmp[0]));",
          "998:   if (_wstati64(tmp, &st) != 0) return 0;",
          "1001:   if (st.st_size == 0 && (st.st_mode & _S_IFREG)) {",
          "1002:     FILE *fp = _wfopen(tmp, L\"rb\");",
          "1003:     if (fp != NULL) {",
          "1004:       fseek(fp, 0, SEEK_END);",
          "1005:       if (ftell(fp) > 0) st.st_size = ftell(fp);  // Use _ftelli64 on win10+",
          "1006:       fclose(fp);",
          "1009: #else",
          "1010:   struct MG_STAT_STRUCT st;",
          "1011:   if (MG_STAT_FUNC(path, &st) != 0) return 0;",
          "1012: #endif",
          "1013:   if (size) *size = (size_t) st.st_size;",
          "1014:   if (mtime) *mtime = st.st_mtime;",
          "1015:   return MG_FS_READ | MG_FS_WRITE | (S_ISDIR(st.st_mode) ? MG_FS_DIR : 0);",
          "1016: #endif",
          "1019: #if MG_ARCH == MG_ARCH_WIN32",
          "1020: struct dirent {",
          "1021:   char d_name[MAX_PATH];",
          "1022: };",
          "1024: typedef struct win32_dir {",
          "1025:   HANDLE handle;",
          "1026:   WIN32_FIND_DATAW info;",
          "1027:   struct dirent result;",
          "1028: } DIR;",
          "1030: int gettimeofday(struct timeval *tv, void *tz) {",
          "1031:   FILETIME ft;",
          "1032:   unsigned __int64 tmpres = 0;",
          "1034:   if (tv != NULL) {",
          "1035:     GetSystemTimeAsFileTime(&ft);",
          "1036:     tmpres |= ft.dwHighDateTime;",
          "1037:     tmpres <<= 32;",
          "1038:     tmpres |= ft.dwLowDateTime;",
          "1039:     tmpres /= 10;  // convert into microseconds",
          "1040:     tmpres -= (int64_t) 11644473600000000;",
          "1041:     tv->tv_sec = (long) (tmpres / 1000000UL);",
          "1042:     tv->tv_usec = (long) (tmpres % 1000000UL);",
          "1044:   (void) tz;",
          "1045:   return 0;",
          "1048: static int to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {",
          "1049:   int ret;",
          "1050:   char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;",
          "1051:   strncpy(buf, path, sizeof(buf));",
          "1052:   buf[sizeof(buf) - 1] = '\\0';",
          "1054:   p = buf + strlen(buf) - 1;",
          "1055:   while (p > buf && p[-1] != ':' && (p[0] == '\\\\' || p[0] == '/')) *p-- = '\\0';",
          "1056:   memset(wbuf, 0, wbuf_len * sizeof(wchar_t));",
          "1057:   ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);",
          "1060:   WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),",
          "1061:                       NULL, NULL);",
          "1062:   if (strcmp(buf, buf2) != 0) {",
          "1063:     wbuf[0] = L'\\0';",
          "1064:     ret = 0;",
          "1066:   return ret;",
          "1069: DIR *opendir(const char *name) {",
          "1070:   DIR *d = NULL;",
          "1071:   wchar_t wpath[MAX_PATH];",
          "1072:   DWORD attrs;",
          "1074:   if (name == NULL) {",
          "1075:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "1076:   } else if ((d = (DIR *) calloc(1, sizeof(*d))) == NULL) {",
          "1077:     SetLastError(ERROR_NOT_ENOUGH_MEMORY);",
          "1078:   } else {",
          "1079:     to_wchar(name, wpath, sizeof(wpath) / sizeof(wpath[0]));",
          "1080:     attrs = GetFileAttributesW(wpath);",
          "1081:     if (attrs != 0Xffffffff && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {",
          "1082:       (void) wcscat(wpath, L\"\\\\*\");",
          "1083:       d->handle = FindFirstFileW(wpath, &d->info);",
          "1084:       d->result.d_name[0] = '\\0';",
          "1085:     } else {",
          "1086:       free(d);",
          "1087:       d = NULL;",
          "1090:   return d;",
          "1091: }",
          "1093: int closedir(DIR *d) {",
          "1094:   int result = 0;",
          "1095:   if (d != NULL) {",
          "1096:     if (d->handle != INVALID_HANDLE_VALUE)",
          "1097:       result = FindClose(d->handle) ? 0 : -1;",
          "1098:     free(d);",
          "1100:     result = -1;",
          "1101:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "1103:   return result;",
          "1106: struct dirent *readdir(DIR *d) {",
          "1107:   struct dirent *result = NULL;",
          "1108:   if (d != NULL) {",
          "1109:     memset(&d->result, 0, sizeof(d->result));",
          "1110:     if (d->handle != INVALID_HANDLE_VALUE) {",
          "1111:       result = &d->result;",
          "1112:       WideCharToMultiByte(CP_UTF8, 0, d->info.cFileName, -1, result->d_name,",
          "1113:                           sizeof(result->d_name), NULL, NULL);",
          "1114:       if (!FindNextFileW(d->handle, &d->info)) {",
          "1115:         FindClose(d->handle);",
          "1116:         d->handle = INVALID_HANDLE_VALUE;",
          "1117:       }",
          "1118:     } else {",
          "1119:       SetLastError(ERROR_FILE_NOT_FOUND);",
          "1120:     }",
          "1122:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "1124:   return result;",
          "1126: #endif",
          "1128: static void p_list(const char *dir, void (*fn)(const char *, void *),",
          "1129:                    void *userdata) {",
          "1130: #if MG_ENABLE_DIRLIST",
          "1131:   struct dirent *dp;",
          "1132:   DIR *dirp;",
          "1133:   if ((dirp = (opendir(dir))) == NULL) return;",
          "1134:   while ((dp = readdir(dirp)) != NULL) {",
          "1135:     if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) continue;",
          "1136:     fn(dp->d_name, userdata);",
          "1137:   }",
          "1138:   closedir(dirp);",
          "1139: #else",
          "1140:   (void) dir, (void) fn, (void) userdata;",
          "1142: }",
          "1144: static void *p_open(const char *path, int flags) {",
          "1145: #if MG_ARCH == MG_ARCH_WIN32",
          "1146:   const char *mode = flags == MG_FS_READ ? \"rb\" : \"a+b\";",
          "1147:   wchar_t b1[MG_PATH_MAX], b2[10];",
          "1148:   MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));",
          "1149:   MultiByteToWideChar(CP_UTF8, 0, mode, -1, b2, sizeof(b2) / sizeof(b2[0]));",
          "1150:   return (void *) _wfopen(b1, b2);",
          "1151: #else",
          "1152:   const char *mode = flags == MG_FS_READ ? \"rbe\" : \"a+be\";  // e for CLOEXEC",
          "1153:   return (void *) fopen(path, mode);",
          "1154: #endif",
          "1155: }",
          "1157: static void p_close(void *fp) {",
          "1158:   fclose((FILE *) fp);",
          "1159: }",
          "1161: static size_t p_read(void *fp, void *buf, size_t len) {",
          "1162:   return fread(buf, 1, len, (FILE *) fp);",
          "1163: }",
          "1165: static size_t p_write(void *fp, const void *buf, size_t len) {",
          "1166:   return fwrite(buf, 1, len, (FILE *) fp);",
          "1169: static size_t p_seek(void *fp, size_t offset) {",
          "1170: #if (defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64) ||  \\",
          "1171:     (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200112L) || \\",
          "1172:     (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 600)",
          "1173:   if (fseeko((FILE *) fp, (off_t) offset, SEEK_SET) != 0) (void) 0;",
          "1174: #else",
          "1175:   if (fseek((FILE *) fp, (long) offset, SEEK_SET) != 0) (void) 0;",
          "1176: #endif",
          "1177:   return (size_t) ftell((FILE *) fp);",
          "1178: }",
          "1180: static bool p_rename(const char *from, const char *to) {",
          "1181:   return rename(from, to) == 0;",
          "1182: }",
          "1184: static bool p_remove(const char *path) {",
          "1185:   return remove(path) == 0;",
          "1186: }",
          "1188: static bool p_mkdir(const char *path) {",
          "1189:   return mkdir(path, 0775) == 0;",
          "1190: }",
          "1192: #else",
          "1194: static int p_stat(const char *path, size_t *size, time_t *mtime) {",
          "1195:   (void) path, (void) size, (void) mtime;",
          "1196:   return 0;",
          "1197: }",
          "1198: static void p_list(const char *path, void (*fn)(const char *, void *),",
          "1199:                    void *userdata) {",
          "1200:   (void) path, (void) fn, (void) userdata;",
          "1201: }",
          "1202: static void *p_open(const char *path, int flags) {",
          "1203:   (void) path, (void) flags;",
          "1204:   return NULL;",
          "1205: }",
          "1206: static void p_close(void *fp) {",
          "1207:   (void) fp;",
          "1208: }",
          "1209: static size_t p_read(void *fd, void *buf, size_t len) {",
          "1210:   (void) fd, (void) buf, (void) len;",
          "1211:   return 0;",
          "1212: }",
          "1213: static size_t p_write(void *fd, const void *buf, size_t len) {",
          "1214:   (void) fd, (void) buf, (void) len;",
          "1215:   return 0;",
          "1216: }",
          "1217: static size_t p_seek(void *fd, size_t offset) {",
          "1218:   (void) fd, (void) offset;",
          "1219:   return (size_t) ~0;",
          "1220: }",
          "1221: static bool p_rename(const char *from, const char *to) {",
          "1222:   (void) from, (void) to;",
          "1223:   return false;",
          "1224: }",
          "1225: static bool p_remove(const char *path) {",
          "1226:   (void) path;",
          "1227:   return false;",
          "1228: }",
          "1229: static bool p_mkdir(const char *path) {",
          "1230:   (void) path;",
          "1231:   return false;",
          "1233: #endif",
          "1235: struct mg_fs mg_fs_posix = {p_stat,  p_list, p_open,   p_close,  p_read,",
          "1236:                             p_write, p_seek, p_rename, p_remove, p_mkdir};",
          "1239: #line 1 \"src/http.c\"",
          "1254: bool mg_to_size_t(struct mg_str str, size_t *val);",
          "1255: bool mg_to_size_t(struct mg_str str, size_t *val) {",
          "1256:   size_t i = 0, max = (size_t) -1, max2 = max / 10, result = 0, ndigits = 0;",
          "1257:   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;",
          "1258:   if (i < str.len && str.ptr[i] == '-') return false;",
          "1259:   while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {",
          "1260:     size_t digit = (size_t) (str.ptr[i] - '0');",
          "1261:     if (result > max2) return false;  // Overflow",
          "1262:     result *= 10;",
          "1263:     if (result > max - digit) return false;  // Overflow",
          "1264:     result += digit;",
          "1265:     i++, ndigits++;",
          "1267:   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;",
          "1268:   if (ndigits == 0) return false;  // #2322: Content-Length = 1 * DIGIT",
          "1269:   if (i != str.len) return false;  // Ditto",
          "1271:   return true;",
          "1275: #define MG_DMARK ((size_t) 1 << (sizeof(size_t) * 8 - 1))",
          "1289: size_t mg_http_next_multipart(struct mg_str body, size_t ofs,",
          "1290:                               struct mg_http_part *part) {",
          "1291:   struct mg_str cd = mg_str_n(\"Content-Disposition\", 19);",
          "1292:   const char *s = body.ptr;",
          "1293:   size_t b = ofs, h1, h2, b1, b2, max = body.len;",
          "1296:   if (part != NULL) part->name = part->filename = part->body = mg_str_n(0, 0);",
          "1299:   while (b + 2 < max && s[b] != '\\r' && s[b + 1] != '\\n') b++;",
          "1300:   if (b <= ofs || b + 2 >= max) return 0;",
          "1304:   h1 = h2 = b + 2;",
          "1305:   for (;;) {",
          "1306:     while (h2 + 2 < max && s[h2] != '\\r' && s[h2 + 1] != '\\n') h2++;",
          "1307:     if (h2 == h1) break;",
          "1308:     if (h2 + 2 >= max) return 0;",
          "1310:     if (part != NULL && h1 + cd.len + 2 < h2 && s[h1 + cd.len] == ':' &&",
          "1311:         mg_ncasecmp(&s[h1], cd.ptr, cd.len) == 0) {",
          "1312:       struct mg_str v = mg_str_n(&s[h1 + cd.len + 2], h2 - (h1 + cd.len + 2));",
          "1313:       part->name = mg_http_get_header_var(v, mg_str_n(\"name\", 4));",
          "1314:       part->filename = mg_http_get_header_var(v, mg_str_n(\"filename\", 8));",
          "1315:     }",
          "1316:     h1 = h2 = h2 + 2;",
          "1318:   b1 = b2 = h2 + 2;",
          "1319:   while (b2 + 2 + (b - ofs) + 2 < max && !(s[b2] == '\\r' && s[b2 + 1] == '\\n' &&",
          "1320:                                            memcmp(&s[b2 + 2], s, b - ofs) == 0))",
          "1321:     b2++;",
          "1323:   if (b2 + 2 >= max) return 0;",
          "1324:   if (part != NULL) part->body = mg_str_n(&s[b1], b2 - b1);",
          "1326:   return b2 + 2;",
          "1329: void mg_http_bauth(struct mg_connection *c, const char *user,",
          "1330:                    const char *pass) {",
          "1331:   struct mg_str u = mg_str(user), p = mg_str(pass);",
          "1332:   size_t need = c->send.len + 36 + (u.len + p.len) * 2;",
          "1333:   if (c->send.size < need) mg_iobuf_resize(&c->send, need);",
          "1334:   if (c->send.size >= need) {",
          "1335:     size_t i, n = 0;",
          "1336:     char *buf = (char *) &c->send.buf[c->send.len];",
          "1337:     memcpy(buf, \"Authorization: Basic \", 21);  // DON'T use mg_send!",
          "1338:     for (i = 0; i < u.len; i++) {",
          "1339:       n = mg_base64_update(((unsigned char *) u.ptr)[i], buf + 21, n);",
          "1340:     }",
          "1341:     if (p.len > 0) {",
          "1342:       n = mg_base64_update(':', buf + 21, n);",
          "1343:       for (i = 0; i < p.len; i++) {",
          "1344:         n = mg_base64_update(((unsigned char *) p.ptr)[i], buf + 21, n);",
          "1345:       }",
          "1346:     }",
          "1347:     n = mg_base64_final(buf + 21, n);",
          "1348:     c->send.len += 21 + (size_t) n + 2;",
          "1349:     memcpy(&c->send.buf[c->send.len - 2], \"\\r\\n\", 2);",
          "1350:   } else {",
          "1351:     MG_ERROR((\"%lu oom %d->%d \", c->id, (int) c->send.size, (int) need));",
          "1352:   }",
          "1355: struct mg_str mg_http_var(struct mg_str buf, struct mg_str name) {",
          "1356:   struct mg_str k, v, result = mg_str_n(NULL, 0);",
          "1357:   while (mg_split(&buf, &k, &v, '&')) {",
          "1358:     if (name.len == k.len && mg_ncasecmp(name.ptr, k.ptr, k.len) == 0) {",
          "1359:       result = v;",
          "1360:       break;",
          "1363:   return result;",
          "1366: int mg_http_get_var(const struct mg_str *buf, const char *name, char *dst,",
          "1367:                     size_t dst_len) {",
          "1368:   int len;",
          "1369:   if (dst == NULL || dst_len == 0) {",
          "1370:     len = -2;  // Bad destination",
          "1371:   } else if (buf->ptr == NULL || name == NULL || buf->len == 0) {",
          "1372:     len = -1;  // Bad source",
          "1373:     dst[0] = '\\0';",
          "1374:   } else {",
          "1375:     struct mg_str v = mg_http_var(*buf, mg_str(name));",
          "1376:     if (v.ptr == NULL) {",
          "1377:       len = -4;  // Name does not exist",
          "1378:     } else {",
          "1379:       len = mg_url_decode(v.ptr, v.len, dst, dst_len, 1);",
          "1380:       if (len < 0) len = -3;  // Failed to decode",
          "1383:   return len;",
          "1386: static bool isx(int c) {",
          "1387:   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||",
          "1388:          (c >= 'A' && c <= 'F');",
          "1391: int mg_url_decode(const char *src, size_t src_len, char *dst, size_t dst_len,",
          "1392:                   int is_form_url_encoded) {",
          "1393:   size_t i, j;",
          "1394:   for (i = j = 0; i < src_len && j + 1 < dst_len; i++, j++) {",
          "1395:     if (src[i] == '%') {",
          "1397:       if (i + 2 < src_len && isx(src[i + 1]) && isx(src[i + 2])) {",
          "1398:         mg_unhex(src + i + 1, 2, (uint8_t *) &dst[j]);",
          "1399:         i += 2;",
          "1401:         return -1;",
          "1403:     } else if (is_form_url_encoded && src[i] == '+') {",
          "1404:       dst[j] = ' ';",
          "1405:     } else {",
          "1406:       dst[j] = src[i];",
          "1409:   if (j < dst_len) dst[j] = '\\0';  // Null-terminate the destination",
          "1410:   return i >= src_len && j < dst_len ? (int) j : -1;",
          "1411: }",
          "1413: static bool isok(uint8_t c) {",
          "1414:   return c == '\\n' || c == '\\r' || c >= ' ';",
          "1417: int mg_http_get_request_len(const unsigned char *buf, size_t buf_len) {",
          "1418:   size_t i;",
          "1419:   for (i = 0; i < buf_len; i++) {",
          "1420:     if (!isok(buf[i])) return -1;",
          "1421:     if ((i > 0 && buf[i] == '\\n' && buf[i - 1] == '\\n') ||",
          "1422:         (i > 3 && buf[i] == '\\n' && buf[i - 1] == '\\r' && buf[i - 2] == '\\n'))",
          "1423:       return (int) i + 1;",
          "1424:   }",
          "1425:   return 0;",
          "1426: }",
          "1427: struct mg_str *mg_http_get_header(struct mg_http_message *h, const char *name) {",
          "1428:   size_t i, n = strlen(name), max = sizeof(h->headers) / sizeof(h->headers[0]);",
          "1429:   for (i = 0; i < max && h->headers[i].name.len > 0; i++) {",
          "1430:     struct mg_str *k = &h->headers[i].name, *v = &h->headers[i].value;",
          "1431:     if (n == k->len && mg_ncasecmp(k->ptr, name, n) == 0) return v;",
          "1433:   return NULL;",
          "1434: }",
          "1437: static size_t clen(const char *s) {",
          "1438:   uint8_t c = *(uint8_t *) s;",
          "1439:   if (c > ' ' && c < '~') return 1;  // Usual ascii printed char",
          "1440:   if ((c & 0xe0) == 0xc0) return 2;  // 2-byte UTF8",
          "1441:   if ((c & 0xf0) == 0xe0) return 3;  // 3-byte UTF8",
          "1442:   if ((c & 0xf8) == 0xf0) return 4;  // 4-byte UTF8",
          "1443:   return 0;",
          "1447: static const char *skiptorn(const char *s, const char *end, struct mg_str *v) {",
          "1448:   v->ptr = s;",
          "1449:   while (s < end && s[0] != '\\n' && s[0] != '\\r') s++, v->len++;  // To newline",
          "1450:   if (s >= end || (s[0] == '\\r' && s[1] != '\\n')) return NULL;    // Stray \\r",
          "1451:   if (s < end && s[0] == '\\r') s++;                               // Skip \\r",
          "1452:   if (s >= end || *s++ != '\\n') return NULL;                      // Skip \\n",
          "1453:   return s;",
          "1456: static bool mg_http_parse_headers(const char *s, const char *end,",
          "1457:                                   struct mg_http_header *h, size_t max_hdrs) {",
          "1458:   size_t i, n;",
          "1459:   for (i = 0; i < max_hdrs; i++) {",
          "1460:     struct mg_str k = {NULL, 0}, v = {NULL, 0};",
          "1461:     if (s >= end) return false;",
          "1462:     if (s[0] == '\\n' || (s[0] == '\\r' && s[1] == '\\n')) break;",
          "1463:     k.ptr = s;",
          "1464:     while (s < end && s[0] != ':' && (n = clen(s)) > 0) s += n, k.len += n;",
          "1465:     if (k.len == 0) return false;               // Empty name",
          "1466:     if (s >= end || *s++ != ':') return false;  // Invalid, not followed by :",
          "1467:     while (s < end && s[0] == ' ') s++;         // Skip spaces",
          "1468:     if ((s = skiptorn(s, end, &v)) == NULL) return false;",
          "1469:     while (v.len > 0 && v.ptr[v.len - 1] == ' ') v.len--;  // Trim spaces",
          "1471:     h[i].name = k, h[i].value = v;  // Success. Assign values",
          "1472:   }",
          "1473:   return true;",
          "1474: }",
          "1476: int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {",
          "1477:   int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);",
          "1478:   const char *end = s == NULL ? NULL : s + req_len, *qs;  // Cannot add to NULL",
          "1479:   struct mg_str *cl;",
          "1480:   size_t n;",
          "1482:   memset(hm, 0, sizeof(*hm));",
          "1483:   if (req_len <= 0) return req_len;",
          "1485:   hm->message.ptr = hm->head.ptr = s;",
          "1486:   hm->body.ptr = end;",
          "1487:   hm->head.len = (size_t) req_len;",
          "1488:   hm->chunk.ptr = end;",
          "1489:   hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite",
          "1492:   hm->method.ptr = s;",
          "1493:   while (s < end && (n = clen(s)) > 0) s += n, hm->method.len += n;",
          "1494:   while (s < end && s[0] == ' ') s++;  // Skip spaces",
          "1495:   hm->uri.ptr = s;",
          "1496:   while (s < end && (n = clen(s)) > 0) s += n, hm->uri.len += n;",
          "1497:   while (s < end && s[0] == ' ') s++;  // Skip spaces",
          "1498:   if ((s = skiptorn(s, end, &hm->proto)) == NULL) return false;",
          "1501:   if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {",
          "1502:     hm->query.ptr = qs + 1;",
          "1503:     hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));",
          "1504:     hm->uri.len = (size_t) (qs - hm->uri.ptr);",
          "1509:   if (hm->method.len == 0 || hm->uri.len == 0) return -1;",
          "1511:   if (!mg_http_parse_headers(s, end, hm->headers,",
          "1512:                              sizeof(hm->headers) / sizeof(hm->headers[0])))",
          "1513:     return -1;  // error when parsing",
          "1514:   if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {",
          "1515:     if (mg_to_size_t(*cl, &hm->body.len) == false) return -1;",
          "1516:     hm->message.len = (size_t) req_len + hm->body.len;",
          "1531:   is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;",
          "1532:   if (hm->body.len == (size_t) ~0 && !is_response &&",
          "1533:       mg_vcasecmp(&hm->method, \"PUT\") != 0 &&",
          "1534:       mg_vcasecmp(&hm->method, \"POST\") != 0) {",
          "1535:     hm->body.len = 0;",
          "1536:     hm->message.len = (size_t) req_len;",
          "1540:   if (hm->body.len == (size_t) ~0 && is_response &&",
          "1541:       mg_vcasecmp(&hm->uri, \"204\") == 0) {",
          "1542:     hm->body.len = 0;",
          "1543:     hm->message.len = (size_t) req_len;",
          "1545:   if (hm->message.len < (size_t) req_len) return -1;  // Overflow protection",
          "1547:   return req_len;",
          "1550: static void mg_http_vprintf_chunk(struct mg_connection *c, const char *fmt,",
          "1551:                                   va_list *ap) {",
          "1552:   size_t len = c->send.len;",
          "1553:   mg_send(c, \"        \\r\\n\", 10);",
          "1554:   mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);",
          "1555:   if (c->send.len >= len + 10) {",
          "1556:     mg_snprintf((char *) c->send.buf + len, 9, \"%08lx\", c->send.len - len - 10);",
          "1557:     c->send.buf[len + 8] = '\\r';",
          "1558:     if (c->send.len == len + 10) c->is_resp = 0;  // Last chunk, reset marker",
          "1560:   mg_send(c, \"\\r\\n\", 2);",
          "1563: void mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...) {",
          "1564:   va_list ap;",
          "1565:   va_start(ap, fmt);",
          "1566:   mg_http_vprintf_chunk(c, fmt, &ap);",
          "1567:   va_end(ap);",
          "1570: void mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len) {",
          "1571:   mg_printf(c, \"%lx\\r\\n\", (unsigned long) len);",
          "1572:   mg_send(c, buf, len);",
          "1573:   mg_send(c, \"\\r\\n\", 2);",
          "1574:   if (len == 0) c->is_resp = 0;",
          "1578: static const char *mg_http_status_code_str(int status_code) {",
          "1579:   switch (status_code) {",
          "1580:     case 100: return \"Continue\";",
          "1581:     case 101: return \"Switching Protocols\";",
          "1582:     case 102: return \"Processing\";",
          "1583:     case 200: return \"OK\";",
          "1584:     case 201: return \"Created\";",
          "1585:     case 202: return \"Accepted\";",
          "1586:     case 203: return \"Non-authoritative Information\";",
          "1587:     case 204: return \"No Content\";",
          "1588:     case 205: return \"Reset Content\";",
          "1589:     case 206: return \"Partial Content\";",
          "1590:     case 207: return \"Multi-Status\";",
          "1591:     case 208: return \"Already Reported\";",
          "1592:     case 226: return \"IM Used\";",
          "1593:     case 300: return \"Multiple Choices\";",
          "1594:     case 301: return \"Moved Permanently\";",
          "1595:     case 302: return \"Found\";",
          "1596:     case 303: return \"See Other\";",
          "1597:     case 304: return \"Not Modified\";",
          "1598:     case 305: return \"Use Proxy\";",
          "1599:     case 307: return \"Temporary Redirect\";",
          "1600:     case 308: return \"Permanent Redirect\";",
          "1601:     case 400: return \"Bad Request\";",
          "1602:     case 401: return \"Unauthorized\";",
          "1603:     case 402: return \"Payment Required\";",
          "1604:     case 403: return \"Forbidden\";",
          "1605:     case 404: return \"Not Found\";",
          "1606:     case 405: return \"Method Not Allowed\";",
          "1607:     case 406: return \"Not Acceptable\";",
          "1608:     case 407: return \"Proxy Authentication Required\";",
          "1609:     case 408: return \"Request Timeout\";",
          "1610:     case 409: return \"Conflict\";",
          "1611:     case 410: return \"Gone\";",
          "1612:     case 411: return \"Length Required\";",
          "1613:     case 412: return \"Precondition Failed\";",
          "1614:     case 413: return \"Payload Too Large\";",
          "1615:     case 414: return \"Request-URI Too Long\";",
          "1616:     case 415: return \"Unsupported Media Type\";",
          "1617:     case 416: return \"Requested Range Not Satisfiable\";",
          "1618:     case 417: return \"Expectation Failed\";",
          "1619:     case 418: return \"I'm a teapot\";",
          "1620:     case 421: return \"Misdirected Request\";",
          "1621:     case 422: return \"Unprocessable Entity\";",
          "1622:     case 423: return \"Locked\";",
          "1623:     case 424: return \"Failed Dependency\";",
          "1624:     case 426: return \"Upgrade Required\";",
          "1625:     case 428: return \"Precondition Required\";",
          "1626:     case 429: return \"Too Many Requests\";",
          "1627:     case 431: return \"Request Header Fields Too Large\";",
          "1628:     case 444: return \"Connection Closed Without Response\";",
          "1629:     case 451: return \"Unavailable For Legal Reasons\";",
          "1630:     case 499: return \"Client Closed Request\";",
          "1631:     case 500: return \"Internal Server Error\";",
          "1632:     case 501: return \"Not Implemented\";",
          "1633:     case 502: return \"Bad Gateway\";",
          "1634:     case 503: return \"Service Unavailable\";",
          "1635:     case 504: return \"Gateway Timeout\";",
          "1636:     case 505: return \"HTTP Version Not Supported\";",
          "1637:     case 506: return \"Variant Also Negotiates\";",
          "1638:     case 507: return \"Insufficient Storage\";",
          "1639:     case 508: return \"Loop Detected\";",
          "1640:     case 510: return \"Not Extended\";",
          "1641:     case 511: return \"Network Authentication Required\";",
          "1642:     case 599: return \"Network Connect Timeout Error\";",
          "1643:     default: return \"\";",
          "1644:   }",
          "1648: void mg_http_reply(struct mg_connection *c, int code, const char *headers,",
          "1649:                    const char *fmt, ...) {",
          "1650:   va_list ap;",
          "1651:   size_t len;",
          "1652:   mg_printf(c, \"HTTP/1.1 %d %s\\r\\n%sContent-Length:            \\r\\n\\r\\n\", code,",
          "1653:             mg_http_status_code_str(code), headers == NULL ? \"\" : headers);",
          "1654:   len = c->send.len;",
          "1655:   va_start(ap, fmt);",
          "1656:   mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, &ap);",
          "1657:   va_end(ap);",
          "1658:   if (c->send.len > 16) {",
          "1659:     size_t n = mg_snprintf((char *) &c->send.buf[len - 15], 11, \"%-10lu\",",
          "1660:                            (unsigned long) (c->send.len - len));",
          "1661:     c->send.buf[len - 15 + n] = ' ';  // Change ending 0 to space",
          "1662:   }",
          "1663:   c->is_resp = 0;",
          "1666: static void http_cb(struct mg_connection *, int, void *, void *);",
          "1667: static void restore_http_cb(struct mg_connection *c) {",
          "1668:   mg_fs_close((struct mg_fd *) c->pfn_data);",
          "1669:   c->pfn_data = NULL;",
          "1670:   c->pfn = http_cb;",
          "1671:   c->is_resp = 0;",
          "1674: char *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime);",
          "1675: char *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {",
          "1676:   mg_snprintf(buf, len, \"\\\"%lld.%lld\\\"\", (int64_t) mtime, (int64_t) size);",
          "1677:   return buf;",
          "1678: }",
          "1680: static void static_cb(struct mg_connection *c, int ev, void *ev_data,",
          "1681:                       void *fn_data) {",
          "1682:   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {",
          "1683:     struct mg_fd *fd = (struct mg_fd *) fn_data;",
          "1685:     size_t n, max = MG_IO_SIZE, space;",
          "1686:     size_t *cl = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /",
          "1687:                                      sizeof(size_t) * sizeof(size_t)];",
          "1688:     if (c->send.size < max) mg_iobuf_resize(&c->send, max);",
          "1689:     if (c->send.len >= c->send.size) return;  // Rate limit",
          "1690:     if ((space = c->send.size - c->send.len) > *cl) space = *cl;",
          "1691:     n = fd->fs->rd(fd->fd, c->send.buf + c->send.len, space);",
          "1692:     c->send.len += n;",
          "1694:     if (n == 0) restore_http_cb(c);",
          "1695:   } else if (ev == MG_EV_CLOSE) {",
          "1696:     restore_http_cb(c);",
          "1697:   }",
          "1698:   (void) ev_data;",
          "1699: }",
          "1704: static struct mg_str s_known_types[] = {",
          "1705:     MG_C_STR(\"html\"), MG_C_STR(\"text/html; charset=utf-8\"),",
          "1706:     MG_C_STR(\"htm\"), MG_C_STR(\"text/html; charset=utf-8\"),",
          "1707:     MG_C_STR(\"css\"), MG_C_STR(\"text/css; charset=utf-8\"),",
          "1708:     MG_C_STR(\"js\"), MG_C_STR(\"text/javascript; charset=utf-8\"),",
          "1709:     MG_C_STR(\"gif\"), MG_C_STR(\"image/gif\"),",
          "1710:     MG_C_STR(\"png\"), MG_C_STR(\"image/png\"),",
          "1711:     MG_C_STR(\"jpg\"), MG_C_STR(\"image/jpeg\"),",
          "1712:     MG_C_STR(\"jpeg\"), MG_C_STR(\"image/jpeg\"),",
          "1713:     MG_C_STR(\"woff\"), MG_C_STR(\"font/woff\"),",
          "1714:     MG_C_STR(\"ttf\"), MG_C_STR(\"font/ttf\"),",
          "1715:     MG_C_STR(\"svg\"), MG_C_STR(\"image/svg+xml\"),",
          "1716:     MG_C_STR(\"txt\"), MG_C_STR(\"text/plain; charset=utf-8\"),",
          "1717:     MG_C_STR(\"avi\"), MG_C_STR(\"video/x-msvideo\"),",
          "1718:     MG_C_STR(\"csv\"), MG_C_STR(\"text/csv\"),",
          "1719:     MG_C_STR(\"doc\"), MG_C_STR(\"application/msword\"),",
          "1720:     MG_C_STR(\"exe\"), MG_C_STR(\"application/octet-stream\"),",
          "1721:     MG_C_STR(\"gz\"), MG_C_STR(\"application/gzip\"),",
          "1722:     MG_C_STR(\"ico\"), MG_C_STR(\"image/x-icon\"),",
          "1723:     MG_C_STR(\"json\"), MG_C_STR(\"application/json\"),",
          "1724:     MG_C_STR(\"mov\"), MG_C_STR(\"video/quicktime\"),",
          "1725:     MG_C_STR(\"mp3\"), MG_C_STR(\"audio/mpeg\"),",
          "1726:     MG_C_STR(\"mp4\"), MG_C_STR(\"video/mp4\"),",
          "1727:     MG_C_STR(\"mpeg\"), MG_C_STR(\"video/mpeg\"),",
          "1728:     MG_C_STR(\"pdf\"), MG_C_STR(\"application/pdf\"),",
          "1729:     MG_C_STR(\"shtml\"), MG_C_STR(\"text/html; charset=utf-8\"),",
          "1730:     MG_C_STR(\"tgz\"), MG_C_STR(\"application/tar-gz\"),",
          "1731:     MG_C_STR(\"wav\"), MG_C_STR(\"audio/wav\"),",
          "1732:     MG_C_STR(\"webp\"), MG_C_STR(\"image/webp\"),",
          "1733:     MG_C_STR(\"zip\"), MG_C_STR(\"application/zip\"),",
          "1734:     MG_C_STR(\"3gp\"), MG_C_STR(\"video/3gpp\"),",
          "1735:     {0, 0},",
          "1739: static struct mg_str guess_content_type(struct mg_str path, const char *extra) {",
          "1740:   struct mg_str k, v, s = mg_str(extra);",
          "1741:   size_t i = 0;",
          "1744:   while (i < path.len && path.ptr[path.len - i - 1] != '.') i++;",
          "1745:   path.ptr += path.len - i;",
          "1746:   path.len = i;",
          "1749:   while (mg_commalist(&s, &k, &v)) {",
          "1750:     if (mg_strcmp(path, k) == 0) return v;",
          "1751:   }",
          "1754:   for (i = 0; s_known_types[i].ptr != NULL; i += 2) {",
          "1755:     if (mg_strcmp(path, s_known_types[i]) == 0) return s_known_types[i + 1];",
          "1758:   return mg_str(\"text/plain; charset=utf-8\");",
          "1761: static int getrange(struct mg_str *s, size_t *a, size_t *b) {",
          "1762:   size_t i, numparsed = 0;",
          "1763:   for (i = 0; i + 6 < s->len; i++) {",
          "1764:     struct mg_str k, v = mg_str_n(s->ptr + i + 6, s->len - i - 6);",
          "1765:     if (memcmp(&s->ptr[i], \"bytes=\", 6) != 0) continue;",
          "1766:     if (mg_split(&v, &k, NULL, '-')) {",
          "1767:       if (mg_to_size_t(k, a)) numparsed++;",
          "1768:       if (v.len > 0 && mg_to_size_t(v, b)) numparsed++;",
          "1769:     } else {",
          "1770:       if (mg_to_size_t(v, a)) numparsed++;",
          "1771:     }",
          "1772:     break;",
          "1774:   return (int) numparsed;",
          "1777: void mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,",
          "1778:                         const char *path,",
          "1779:                         const struct mg_http_serve_opts *opts) {",
          "1780:   char etag[64], tmp[MG_PATH_MAX];",
          "1781:   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;",
          "1782:   struct mg_fd *fd = NULL;",
          "1784:   time_t mtime = 0;",
          "1785:   struct mg_str *inm = NULL;",
          "1786:   struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);",
          "1787:   bool gzip = false;",
          "1789:   if (path != NULL) {",
          "1791:     struct mg_str *ae = mg_http_get_header(hm, \"Accept-Encoding\");",
          "1792:     if (ae != NULL && mg_strstr(*ae, mg_str(\"gzip\")) != NULL) {",
          "1793:       mg_snprintf(tmp, sizeof(tmp), \"%s.gz\", path);",
          "1794:       fd = mg_fs_open(fs, tmp, MG_FS_READ);",
          "1795:       if (fd != NULL) gzip = true, path = tmp;",
          "1796:     }",
          "1798:     if (fd == NULL) fd = mg_fs_open(fs, path, MG_FS_READ);",
          "1802:   if (fd == NULL && opts->page404 != NULL) {",
          "1803:     fd = mg_fs_open(fs, opts->page404, MG_FS_READ);",
          "1804:     mime = guess_content_type(mg_str(path), opts->mime_types);",
          "1805:     path = opts->page404;",
          "1806:   }",
          "1808:   if (fd == NULL || fs->st(path, &size, &mtime) == 0) {",
          "1809:     mg_http_reply(c, 404, opts->extra_headers, \"Not found\\n\");",
          "1810:     mg_fs_close(fd);",
          "1812:   } else if (mg_http_etag(etag, sizeof(etag), size, mtime) != NULL &&",
          "1813:              (inm = mg_http_get_header(hm, \"If-None-Match\")) != NULL &&",
          "1814:              mg_vcasecmp(inm, etag) == 0) {",
          "1815:     mg_fs_close(fd);",
          "1816:     mg_http_reply(c, 304, opts->extra_headers, \"\");",
          "1817:   } else {",
          "1818:     int n, status = 200;",
          "1819:     char range[100];",
          "1820:     size_t r1 = 0, r2 = 0, cl = size;",
          "1823:     struct mg_str *rh = mg_http_get_header(hm, \"Range\");",
          "1824:     range[0] = '\\0';",
          "1825:     if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0) {",
          "1827:       if (n == 1) r2 = cl - 1;",
          "1828:       if (r1 > r2 || r2 >= cl) {",
          "1829:         status = 416;",
          "1830:         cl = 0;",
          "1831:         mg_snprintf(range, sizeof(range), \"Content-Range: bytes */%lld\\r\\n\",",
          "1832:                     (int64_t) size);",
          "1833:       } else {",
          "1834:         status = 206;",
          "1835:         cl = r2 - r1 + 1;",
          "1836:         mg_snprintf(range, sizeof(range),",
          "1837:                     \"Content-Range: bytes %llu-%llu/%llu\\r\\n\", (uint64_t) r1,",
          "1838:                     (uint64_t) (r1 + cl - 1), (uint64_t) size);",
          "1839:         fs->sk(fd->fd, r1);",
          "1840:       }",
          "1841:     }",
          "1842:     mg_printf(c,",
          "1843:               \"HTTP/1.1 %d %s\\r\\n\"",
          "1844:               \"Content-Type: %.*s\\r\\n\"",
          "1845:               \"Etag: %s\\r\\n\"",
          "1846:               \"Content-Length: %llu\\r\\n\"",
          "1847:               \"%s%s%s\\r\\n\",",
          "1848:               status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,",
          "1849:               etag, (uint64_t) cl, gzip ? \"Content-Encoding: gzip\\r\\n\" : \"\",",
          "1850:               range, opts->extra_headers ? opts->extra_headers : \"\");",
          "1851:     if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {",
          "1852:       c->is_draining = 1;",
          "1853:       c->is_resp = 0;",
          "1854:       mg_fs_close(fd);",
          "1855:     } else {",
          "1857:       size_t *clp = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /",
          "1858:                                         sizeof(size_t) * sizeof(size_t)];",
          "1859:       c->pfn = static_cb;",
          "1860:       c->pfn_data = fd;",
          "1866: struct printdirentrydata {",
          "1867:   struct mg_connection *c;",
          "1868:   struct mg_http_message *hm;",
          "1869:   const struct mg_http_serve_opts *opts;",
          "1870:   const char *dir;",
          "1873: #if MG_ENABLE_DIRLIST",
          "1874: static void printdirentry(const char *name, void *userdata) {",
          "1875:   struct printdirentrydata *d = (struct printdirentrydata *) userdata;",
          "1876:   struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;",
          "1877:   size_t size = 0;",
          "1878:   time_t t = 0;",
          "1879:   char path[MG_PATH_MAX], sz[40], mod[40];",
          "1880:   int flags, n = 0;",
          "1883:   if (mg_snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) >",
          "1884:       sizeof(path)) {",
          "1885:     MG_ERROR((\"%s truncated\", name));",
          "1886:   } else if ((flags = fs->st(path, &size, &t)) == 0) {",
          "1887:     MG_ERROR((\"%lu stat(%s): %d\", d->c->id, path, errno));",
          "1889:     const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";",
          "1890:     if (flags & MG_FS_DIR) {",
          "1891:       mg_snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");",
          "1893:       mg_snprintf(sz, sizeof(sz), \"%lld\", (uint64_t) size);",
          "1895: #if defined(MG_HTTP_DIRLIST_TIME_FMT)",
          "1896:     {",
          "1897:       char time_str[40];",
          "1898:       struct tm *time_info = localtime(&t);",
          "1899:       strftime(time_str, sizeof time_str, \"%Y/%m/%d %H:%M:%S\", time_info);",
          "1900:       mg_snprintf(mod, sizeof(mod), \"%s\", time_str);",
          "1902: #else",
          "1903:     mg_snprintf(mod, sizeof(mod), \"%lu\", (unsigned long) t);",
          "1905:     n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));",
          "1906:     mg_printf(d->c,",
          "1907:               \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"",
          "1908:               \"<td name=%lu>%s</td><td name=%lld>%s</td></tr>\\n\",",
          "1909:               n, path, slash, name, slash, (unsigned long) t, mod,",
          "1910:               flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);",
          "1914: static void listdir(struct mg_connection *c, struct mg_http_message *hm,",
          "1915:                     const struct mg_http_serve_opts *opts, char *dir) {",
          "1916:   const char *sort_js_code =",
          "1917:       \"<script>function srt(tb, sc, so, d) {\"",
          "1918:       \"var tr = Array.prototype.slice.call(tb.rows, 0),\"",
          "1919:       \"tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],\"",
          "1920:       \"n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), \"",
          "1921:       \"t1 = a.cells[2].getAttribute('name'), \"",
          "1922:       \"t2 = b.cells[2].getAttribute('name'); \"",
          "1923:       \"return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : \"",
          "1924:       \"n1 ? parseInt(n2) - parseInt(n1) : \"",
          "1925:       \"c1.textContent.trim().localeCompare(c2.textContent.trim())); });\";",
          "1926:   const char *sort_js_code2 =",
          "1927:       \"for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); \"",
          "1928:       \"if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); \"",
          "1929:       \"};\"",
          "1930:       \"window.onload = function() {\"",
          "1931:       \"var tb = document.getElementById('tb');\"",
          "1932:       \"var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];\"",
          "1933:       \"var sc = m[1], so = m[2]; document.onclick = function(ev) { \"",
          "1934:       \"var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); \"",
          "1935:       \"sc = c; ev.preventDefault();}};\"",
          "1936:       \"srt(tb, sc, so, true);\"",
          "1937:       \"}\"",
          "1938:       \"</script>\";",
          "1939:   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;",
          "1940:   struct printdirentrydata d = {c, hm, opts, dir};",
          "1941:   char tmp[10], buf[MG_PATH_MAX];",
          "1942:   size_t off, n;",
          "1943:   int len = mg_url_decode(hm->uri.ptr, hm->uri.len, buf, sizeof(buf), 0);",
          "1944:   struct mg_str uri = len > 0 ? mg_str_n(buf, (size_t) len) : hm->uri;",
          "1946:   mg_printf(c,",
          "1947:             \"HTTP/1.1 200 OK\\r\\n\"",
          "1948:             \"Content-Type: text/html; charset=utf-8\\r\\n\"",
          "1949:             \"%s\"",
          "1950:             \"Content-Length:         \\r\\n\\r\\n\",",
          "1951:             opts->extra_headers == NULL ? \"\" : opts->extra_headers);",
          "1952:   off = c->send.len;  // Start of body",
          "1953:   mg_printf(c,",
          "1954:             \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"",
          "1955:             \"<style>th,td {text-align: left; padding-right: 1em; \"",
          "1956:             \"font-family: monospace; }</style></head>\"",
          "1957:             \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"",
          "1958:             \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"",
          "1959:             \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"",
          "1960:             \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"",
          "1961:             \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"",
          "1962:             \"</thead>\"",
          "1963:             \"<tbody id=\\\"tb\\\">\\n\",",
          "1964:             (int) uri.len, uri.ptr, sort_js_code, sort_js_code2, (int) uri.len,",
          "1965:             uri.ptr);",
          "1966:   mg_printf(c, \"%s\",",
          "1967:             \"  <tr><td><a href=\\\"..\\\">..</a></td>\"",
          "1968:             \"<td name=-1></td><td name=-1>[DIR]</td></tr>\\n\");",
          "1970:   fs->ls(dir, printdirentry, &d);",
          "1971:   mg_printf(c,",
          "1972:             \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"",
          "1973:             \"</table><address>Mongoose v.%s</address></body></html>\\n\",",
          "1974:             MG_VERSION);",
          "1975:   n = mg_snprintf(tmp, sizeof(tmp), \"%lu\", (unsigned long) (c->send.len - off));",
          "1976:   if (n > sizeof(tmp)) n = 0;",
          "1977:   memcpy(c->send.buf + off - 12, tmp, n);  // Set content length",
          "1978:   c->is_resp = 0;                          // Mark response end",
          "1980: #endif",
          "1983: static int uri_to_path2(struct mg_connection *c, struct mg_http_message *hm,",
          "1984:                         struct mg_fs *fs, struct mg_str url, struct mg_str dir,",
          "1985:                         char *path, size_t path_size) {",
          "1986:   int flags, tmp;",
          "1988:   size_t n = mg_snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);",
          "1989:   if (n + 2 >= path_size) {",
          "1990:     mg_http_reply(c, 400, \"\", \"Exceeded path size\");",
          "1991:     return -1;",
          "1992:   }",
          "1993:   path[path_size - 1] = '\\0';",
          "1995:   if (n > 0 && path[n - 1] != '/') path[n++] = '/', path[n] = '\\0';",
          "1996:   if (url.len < hm->uri.len) {",
          "1997:     mg_url_decode(hm->uri.ptr + url.len, hm->uri.len - url.len, path + n,",
          "1998:                   path_size - n, 0);",
          "1999:   }",
          "2000:   path[path_size - 1] = '\\0';  // Double-check",
          "2001:   if (!mg_path_is_sane(path)) {",
          "2002:     mg_http_reply(c, 400, \"\", \"Invalid path\");",
          "2003:     return -1;",
          "2004:   }",
          "2005:   n = strlen(path);",
          "2006:   while (n > 1 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes",
          "2007:   flags = mg_vcmp(&hm->uri, \"/\") == 0 ? MG_FS_DIR : fs->st(path, NULL, NULL);",
          "2008:   MG_VERBOSE((\"%lu %.*s -> %s %d\", c->id, (int) hm->uri.len, hm->uri.ptr, path,",
          "2009:               flags));",
          "2010:   if (flags == 0) {",
          "2012:   } else if ((flags & MG_FS_DIR) && hm->uri.len > 0 &&",
          "2013:              hm->uri.ptr[hm->uri.len - 1] != '/') {",
          "2014:     mg_printf(c,",
          "2015:               \"HTTP/1.1 301 Moved\\r\\n\"",
          "2016:               \"Location: %.*s/\\r\\n\"",
          "2017:               \"Content-Length: 0\\r\\n\"",
          "2018:               \"\\r\\n\",",
          "2019:               (int) hm->uri.len, hm->uri.ptr);",
          "2020:     c->is_resp = 0;",
          "2021:     flags = -1;",
          "2022:   } else if (flags & MG_FS_DIR) {",
          "2023:     if (((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&",
          "2024:           (tmp = fs->st(path, NULL, NULL)) != 0) ||",
          "2025:          (mg_snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&",
          "2026:           (tmp = fs->st(path, NULL, NULL)) != 0))) {",
          "2027:       flags = tmp;",
          "2028:     } else if ((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX \".gz\") >",
          "2029:                     0 &&",
          "2030:                 (tmp = fs->st(path, NULL, NULL)) !=",
          "2031:                     0)) {  // check for gzipped index",
          "2032:       flags = tmp;",
          "2033:       path[n + 1 + strlen(MG_HTTP_INDEX)] =",
          "2034:           '\\0';  // Remove appended .gz in index file name",
          "2035:     } else {",
          "2036:       path[n] = '\\0';  // Remove appended index file name",
          "2037:     }",
          "2038:   }",
          "2039:   return flags;",
          "2042: static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,",
          "2043:                        const struct mg_http_serve_opts *opts, char *path,",
          "2044:                        size_t path_size) {",
          "2045:   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;",
          "2046:   struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};",
          "2047:   while (mg_commalist(&s, &k, &v)) {",
          "2048:     if (v.len == 0) v = k, k = mg_str(\"/\"), u = k, p = v;",
          "2049:     if (hm->uri.len < k.len) continue;",
          "2050:     if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;",
          "2051:     u = k, p = v;",
          "2052:   }",
          "2053:   return uri_to_path2(c, hm, fs, u, p, path, path_size);",
          "2056: void mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,",
          "2057:                        const struct mg_http_serve_opts *opts) {",
          "2058:   char path[MG_PATH_MAX];",
          "2059:   const char *sp = opts->ssi_pattern;",
          "2060:   int flags = uri_to_path(c, hm, opts, path, sizeof(path));",
          "2061:   if (flags < 0) {",
          "2063:   } else if (flags & MG_FS_DIR) {",
          "2064: #if MG_ENABLE_DIRLIST",
          "2065:     listdir(c, hm, opts, path);",
          "2067:     mg_http_reply(c, 403, \"\", \"Forbidden\\n\");",
          "2069:   } else if (flags && sp != NULL &&",
          "2070:              mg_globmatch(sp, strlen(sp), path, strlen(path))) {",
          "2071:     mg_http_serve_ssi(c, opts->root_dir, path);",
          "2072:   } else {",
          "2073:     mg_http_serve_file(c, hm, path, opts);",
          "2074:   }",
          "2077: static bool mg_is_url_safe(int c) {",
          "2078:   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||",
          "2079:          (c >= 'A' && c <= 'Z') || c == '.' || c == '_' || c == '-' || c == '~';",
          "2082: size_t mg_url_encode(const char *s, size_t sl, char *buf, size_t len) {",
          "2083:   size_t i, n = 0;",
          "2084:   for (i = 0; i < sl; i++) {",
          "2085:     int c = *(unsigned char *) &s[i];",
          "2086:     if (n + 4 >= len) return 0;",
          "2087:     if (mg_is_url_safe(c)) {",
          "2088:       buf[n++] = s[i];",
          "2089:     } else {",
          "2090:       buf[n++] = '%';",
          "2091:       mg_hex(&s[i], 1, &buf[n]);",
          "2092:       n += 2;",
          "2093:     }",
          "2094:   }",
          "2095:   if (len > 0 && n < len - 1) buf[n] = '\\0';  // Null-terminate the destination",
          "2096:   if (len > 0) buf[len - 1] = '\\0';           // Always.",
          "2097:   return n;",
          "2100: void mg_http_creds(struct mg_http_message *hm, char *user, size_t userlen,",
          "2101:                    char *pass, size_t passlen) {",
          "2102:   struct mg_str *v = mg_http_get_header(hm, \"Authorization\");",
          "2103:   user[0] = pass[0] = '\\0';",
          "2104:   if (v != NULL && v->len > 6 && memcmp(v->ptr, \"Basic \", 6) == 0) {",
          "2105:     char buf[256];",
          "2106:     size_t n = mg_base64_decode(v->ptr + 6, v->len - 6, buf, sizeof(buf));",
          "2107:     const char *p = (const char *) memchr(buf, ':', n > 0 ? n : 0);",
          "2108:     if (p != NULL) {",
          "2109:       mg_snprintf(user, userlen, \"%.*s\", p - buf, buf);",
          "2110:       mg_snprintf(pass, passlen, \"%.*s\", n - (size_t) (p - buf) - 1, p + 1);",
          "2111:     }",
          "2112:   } else if (v != NULL && v->len > 7 && memcmp(v->ptr, \"Bearer \", 7) == 0) {",
          "2113:     mg_snprintf(pass, passlen, \"%.*s\", (int) v->len - 7, v->ptr + 7);",
          "2114:   } else if ((v = mg_http_get_header(hm, \"Cookie\")) != NULL) {",
          "2115:     struct mg_str t = mg_http_get_header_var(*v, mg_str_n(\"access_token\", 12));",
          "2116:     if (t.len > 0) mg_snprintf(pass, passlen, \"%.*s\", (int) t.len, t.ptr);",
          "2117:   } else {",
          "2118:     mg_http_get_var(&hm->query, \"access_token\", pass, passlen);",
          "2119:   }",
          "2122: static struct mg_str stripquotes(struct mg_str s) {",
          "2123:   return s.len > 1 && s.ptr[0] == '\"' && s.ptr[s.len - 1] == '\"'",
          "2124:              ? mg_str_n(s.ptr + 1, s.len - 2)",
          "2125:              : s;",
          "2126: }",
          "2128: struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {",
          "2129:   size_t i;",
          "2130:   for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {",
          "2131:     if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {",
          "2132:       const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];",
          "2133:       int q = p < x && *p == '\"' ? 1 : 0;",
          "2134:       while (p < x &&",
          "2135:              (q ? p == b || *p != '\"' : *p != ';' && *p != ' ' && *p != ','))",
          "2136:         p++;",
          "2139:       return stripquotes(mg_str_n(b, (size_t) (p - b + q)));",
          "2140:     }",
          "2141:   }",
          "2142:   return mg_str_n(NULL, 0);",
          "2145: bool mg_http_match_uri(const struct mg_http_message *hm, const char *glob) {",
          "2146:   return mg_match(hm->uri, mg_str(glob), NULL);",
          "2149: long mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
          "2150:                     struct mg_fs *fs, const char *path, size_t max_size) {",
          "2151:   char buf[20] = \"0\";",
          "2152:   long res = 0, offset;",
          "2153:   mg_http_get_var(&hm->query, \"offset\", buf, sizeof(buf));",
          "2154:   offset = strtol(buf, NULL, 0);",
          "2155:   if (hm->body.len == 0) {",
          "2156:     mg_http_reply(c, 200, \"\", \"%ld\", res);  // Nothing to write",
          "2157:   } else {",
          "2158:     struct mg_fd *fd;",
          "2159:     size_t current_size = 0;",
          "2160:     MG_DEBUG((\"%s -> %d bytes @ %ld\", path, (int) hm->body.len, offset));",
          "2161:     if (offset == 0) fs->rm(path);  // If offset if 0, truncate file",
          "2162:     fs->st(path, &current_size, NULL);",
          "2163:     if (offset < 0) {",
          "2164:       mg_http_reply(c, 400, \"\", \"offset required\");",
          "2165:       res = -1;",
          "2166:     } else if (offset > 0 && current_size != (size_t) offset) {",
          "2167:       mg_http_reply(c, 400, \"\", \"%s: offset mismatch\", path);",
          "2168:       res = -2;",
          "2169:     } else if ((size_t) offset + hm->body.len > max_size) {",
          "2170:       mg_http_reply(c, 400, \"\", \"%s: over max size of %lu\", path,",
          "2171:                     (unsigned long) max_size);",
          "2172:       res = -3;",
          "2173:     } else if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {",
          "2174:       mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);",
          "2175:       res = -4;",
          "2176:     } else {",
          "2177:       res = offset + (long) fs->wr(fd->fd, hm->body.ptr, hm->body.len);",
          "2178:       mg_fs_close(fd);",
          "2179:       mg_http_reply(c, 200, \"\", \"%ld\", res);",
          "2180:     }",
          "2181:   }",
          "2182:   return res;",
          "2185: int mg_http_status(const struct mg_http_message *hm) {",
          "2186:   return atoi(hm->uri.ptr);",
          "2189: static bool is_hex_digit(int c) {",
          "2190:   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||",
          "2191:          (c >= 'A' && c <= 'F');",
          "2206: static bool getchunk(struct mg_str s, size_t *prefixlen, size_t *datalen) {",
          "2207:   size_t i = 0, n;",
          "2208:   while (i < s.len && is_hex_digit(s.ptr[i])) i++;",
          "2209:   n = mg_unhexn(s.ptr, i);",
          "2211:   if (s.len < i + n + 4) return false;  // Chunk not yet fully buffered",
          "2212:   if (s.ptr[i] != '\\r' || s.ptr[i + 1] != '\\n') return false;",
          "2213:   if (s.ptr[i + n + 2] != '\\r' || s.ptr[i + n + 3] != '\\n') return false;",
          "2216:   return true;",
          "2219: static bool mg_is_chunked(struct mg_http_message *hm) {",
          "2220:   const char *needle = \"chunked\";",
          "2221:   struct mg_str *te = mg_http_get_header(hm, \"Transfer-Encoding\");",
          "2222:   return te != NULL && mg_vcasecmp(te, needle) == 0;",
          "2225: void mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm) {",
          "2226:   size_t ofs = (size_t) (hm->chunk.ptr - (char *) c->recv.buf);",
          "2227:   mg_iobuf_del(&c->recv, ofs, hm->chunk.len);",
          "2228:   c->pfn_data = (void *) ((size_t) c->pfn_data | MG_DMARK);",
          "2231: static void deliver_chunked_chunks(struct mg_connection *c, size_t hlen,",
          "2232:                                    struct mg_http_message *hm, bool *next) {",
          "2236:   char *buf = (char *) &c->recv.buf[hlen], *p = buf;",
          "2237:   size_t len = c->recv.len - hlen;",
          "2238:   size_t processed = ((size_t) c->pfn_data) & ~MG_DMARK;",
          "2239:   size_t mark, pl, dl, del = 0, ofs = 0;",
          "2240:   bool last = false;",
          "2241:   if (processed <= len) len -= processed, buf += processed;",
          "2242:   while (!last && getchunk(mg_str_n(buf + ofs, len - ofs), &pl, &dl)) {",
          "2243:     size_t saved = c->recv.len;",
          "2244:     memmove(p + processed, buf + ofs + pl, dl);",
          "2246:     hm->chunk = mg_str_n(p + processed, dl);",
          "2247:     mg_call(c, MG_EV_HTTP_CHUNK, hm);",
          "2248:     ofs += pl + dl + 2, del += pl + 2;  // 2 is for \\r\\n suffix",
          "2249:     processed += dl;",
          "2250:     if (c->recv.len != saved) processed -= dl, buf -= dl;",
          "2252:     last = (dl == 0);",
          "2253:   }",
          "2254:   mg_iobuf_del(&c->recv, hlen + processed, del);",
          "2255:   mark = ((size_t) c->pfn_data) & MG_DMARK;",
          "2256:   c->pfn_data = (void *) (processed | mark);",
          "2257:   if (last) {",
          "2258:     hm->body.len = processed;",
          "2259:     hm->message.len = hlen + processed;",
          "2260:     c->pfn_data = NULL;",
          "2261:     if (mark) mg_iobuf_del(&c->recv, 0, hlen), *next = true;",
          "2264:   }",
          "2267: static void deliver_normal_chunks(struct mg_connection *c, size_t hlen,",
          "2268:                                   struct mg_http_message *hm, bool *next) {",
          "2269:   size_t left, processed = ((size_t) c->pfn_data) & ~MG_DMARK;",
          "2270:   size_t deleted = ((size_t) c->pfn_data) & MG_DMARK;",
          "2271:   hm->chunk = mg_str_n((char *) &c->recv.buf[hlen], c->recv.len - hlen);",
          "2272:   if (processed <= hm->chunk.len && !deleted) {",
          "2273:     hm->chunk.len -= processed;",
          "2274:     hm->chunk.ptr += processed;",
          "2275:   }",
          "2276:   left = hm->body.len < processed ? 0 : hm->body.len - processed;",
          "2277:   if (hm->chunk.len > left) hm->chunk.len = left;",
          "2278:   if (hm->chunk.len > 0) mg_call(c, MG_EV_HTTP_CHUNK, hm);",
          "2279:   processed += hm->chunk.len;",
          "2280:   deleted = ((size_t) c->pfn_data) & MG_DMARK;  // Re-evaluate after user call",
          "2281:   if (processed >= hm->body.len) {              // Last, 0-len chunk",
          "2282:     hm->chunk.len = 0;                          // Reset length",
          "2283:     mg_call(c, MG_EV_HTTP_CHUNK, hm);           // Call user handler",
          "2284:     c->pfn_data = NULL;                         // Reset processed counter",
          "2285:     if (processed && deleted) mg_iobuf_del(&c->recv, 0, hlen), *next = true;",
          "2286:   } else {",
          "2287:     c->pfn_data = (void *) (processed | deleted);  // if it is set",
          "2288:   }",
          "2291: static void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {",
          "2292:   if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {",
          "2293:     struct mg_http_message hm;",
          "2294:     while (c->recv.buf != NULL && c->recv.len > 0) {",
          "2295:       bool next = false;",
          "2296:       int hlen = mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);",
          "2297:       if (hlen < 0) {",
          "2298:         mg_error(c, \"HTTP parse:\\n%.*s\", (int) c->recv.len, c->recv.buf);",
          "2299:         break;",
          "2300:       }",
          "2301:       if (c->is_resp) break;           // Response is still generated",
          "2302:       if (hlen == 0) break;            // Request is not buffered yet",
          "2303:       if (ev == MG_EV_CLOSE) {         // If client did not set Content-Length",
          "2304:         hm.message.len = c->recv.len;  // and closes now, deliver a MSG",
          "2305:         hm.body.len = hm.message.len - (size_t) (hm.body.ptr - hm.message.ptr);",
          "2306:       }",
          "2307:       if (mg_is_chunked(&hm)) {",
          "2308:         deliver_chunked_chunks(c, (size_t) hlen, &hm, &next);",
          "2309:       } else {",
          "2310:         deliver_normal_chunks(c, (size_t) hlen, &hm, &next);",
          "2311:       }",
          "2312:       if (next) continue;  // Chunks & request were deleted",
          "2314:       if (c->recv.len < hm.message.len) break;",
          "2315:       if (c->is_accepted) c->is_resp = 1;  // Start generating response",
          "2316:       mg_call(c, MG_EV_HTTP_MSG, &hm);     // User handler can clear is_resp",
          "2317:       mg_iobuf_del(&c->recv, 0, hm.message.len);",
          "2318:     }",
          "2319:   }",
          "2320:   (void) evd, (void) fnd;",
          "2321: }",
          "2323: static void mg_hfn(struct mg_connection *c, int ev, void *ev_data, void *fnd) {",
          "2324:   if (ev == MG_EV_HTTP_MSG) {",
          "2325:     struct mg_http_message *hm = (struct mg_http_message *) ev_data;",
          "2326:     if (mg_http_match_uri(hm, \"/quit\")) {",
          "2327:       mg_http_reply(c, 200, \"\", \"ok\\n\");",
          "2328:       c->is_draining = 1;",
          "2329:       c->data[0] = 'X';",
          "2330:     } else if (mg_http_match_uri(hm, \"/debug\")) {",
          "2331:       int level = (int) mg_json_get_long(hm->body, \"$.level\", MG_LL_DEBUG);",
          "2332:       mg_log_set(level);",
          "2333:       mg_http_reply(c, 200, \"\", \"Debug level set to %d\\n\", level);",
          "2334:     } else {",
          "2335:       mg_http_reply(c, 200, \"\", \"hi\\n\");",
          "2336:     }",
          "2337:   } else if (ev == MG_EV_CLOSE) {",
          "2338:     if (c->data[0] == 'X') *(bool *) fnd = true;",
          "2339:   }",
          "2340: }",
          "2342: void mg_hello(const char *url) {",
          "2343:   struct mg_mgr mgr;",
          "2344:   bool done = false;",
          "2345:   mg_mgr_init(&mgr);",
          "2346:   if (mg_http_listen(&mgr, url, mg_hfn, &done) == NULL) done = true;",
          "2347:   while (done == false) mg_mgr_poll(&mgr, 100);",
          "2348:   mg_mgr_free(&mgr);",
          "2349: }",
          "2351: struct mg_connection *mg_http_connect(struct mg_mgr *mgr, const char *url,",
          "2352:                                       mg_event_handler_t fn, void *fn_data) {",
          "2353:   struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);",
          "2354:   if (c != NULL) c->pfn = http_cb;",
          "2355:   return c;",
          "2356: }",
          "2358: struct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url,",
          "2359:                                      mg_event_handler_t fn, void *fn_data) {",
          "2360:   struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);",
          "2361:   if (c != NULL) c->pfn = http_cb;",
          "2362:   return c;",
          "2363: }",
          "2365: #ifdef MG_ENABLE_LINES",
          "2366: #line 1 \"src/iobuf.c\"",
          "2367: #endif",
          "2373: static size_t roundup(size_t size, size_t align) {",
          "2374:   return align == 0 ? size : (size + align - 1) / align * align;",
          "2375: }",
          "2377: int mg_iobuf_resize(struct mg_iobuf *io, size_t new_size) {",
          "2378:   int ok = 1;",
          "2379:   new_size = roundup(new_size, io->align);",
          "2380:   if (new_size == 0) {",
          "2381:     mg_bzero(io->buf, io->size);",
          "2382:     free(io->buf);",
          "2383:     io->buf = NULL;",
          "2384:     io->len = io->size = 0;",
          "2385:   } else if (new_size != io->size) {",
          "2388:     void *p = calloc(1, new_size);",
          "2389:     if (p != NULL) {",
          "2390:       size_t len = new_size < io->len ? new_size : io->len;",
          "2391:       if (len > 0 && io->buf != NULL) memmove(p, io->buf, len);",
          "2392:       mg_bzero(io->buf, io->size);",
          "2393:       free(io->buf);",
          "2394:       io->buf = (unsigned char *) p;",
          "2395:       io->size = new_size;",
          "2396:     } else {",
          "2397:       ok = 0;",
          "2398:       MG_ERROR((\"%lld->%lld\", (uint64_t) io->size, (uint64_t) new_size));",
          "2399:     }",
          "2400:   }",
          "2401:   return ok;",
          "2402: }",
          "2404: int mg_iobuf_init(struct mg_iobuf *io, size_t size, size_t align) {",
          "2405:   io->buf = NULL;",
          "2406:   io->align = align;",
          "2407:   io->size = io->len = 0;",
          "2408:   return mg_iobuf_resize(io, size);",
          "2409: }",
          "2411: size_t mg_iobuf_add(struct mg_iobuf *io, size_t ofs, const void *buf,",
          "2412:                     size_t len) {",
          "2413:   size_t new_size = roundup(io->len + len, io->align);",
          "2414:   mg_iobuf_resize(io, new_size);      // Attempt to resize",
          "2415:   if (new_size != io->size) len = 0;  // Resize failure, append nothing",
          "2416:   if (ofs < io->len) memmove(io->buf + ofs + len, io->buf + ofs, io->len - ofs);",
          "2417:   if (buf != NULL) memmove(io->buf + ofs, buf, len);",
          "2418:   if (ofs > io->len) io->len += ofs - io->len;",
          "2419:   io->len += len;",
          "2420:   return len;",
          "2421: }",
          "2423: size_t mg_iobuf_del(struct mg_iobuf *io, size_t ofs, size_t len) {",
          "2424:   if (ofs > io->len) ofs = io->len;",
          "2425:   if (ofs + len > io->len) len = io->len - ofs;",
          "2426:   if (io->buf) memmove(io->buf + ofs, io->buf + ofs + len, io->len - ofs - len);",
          "2427:   if (io->buf) mg_bzero(io->buf + io->len - len, len);",
          "2428:   io->len -= len;",
          "2429:   return len;",
          "2432: void mg_iobuf_free(struct mg_iobuf *io) {",
          "2433:   mg_iobuf_resize(io, 0);",
          "2434: }",
          "2436: #ifdef MG_ENABLE_LINES",
          "2437: #line 1 \"src/json.c\"",
          "2438: #endif",
          "2443: static const char *escapeseq(int esc) {",
          "2444:   return esc ? \"\\b\\f\\n\\r\\t\\\\\\\"\" : \"bfnrt\\\\\\\"\";",
          "2447: static char json_esc(int c, int esc) {",
          "2448:   const char *p, *esc1 = escapeseq(esc), *esc2 = escapeseq(!esc);",
          "2449:   for (p = esc1; *p != '\\0'; p++) {",
          "2450:     if (*p == c) return esc2[p - esc1];",
          "2452:   return 0;",
          "2455: static int mg_pass_string(const char *s, int len) {",
          "2456:   int i;",
          "2457:   for (i = 0; i < len; i++) {",
          "2458:     if (s[i] == '\\\\' && i + 1 < len && json_esc(s[i + 1], 1)) {",
          "2459:       i++;",
          "2460:     } else if (s[i] == '\\0') {",
          "2461:       return MG_JSON_INVALID;",
          "2462:     } else if (s[i] == '\"') {",
          "2463:       return i;",
          "2466:   return MG_JSON_INVALID;",
          "2469: static double mg_atod(const char *p, int len, int *numlen) {",
          "2470:   double d = 0.0;",
          "2471:   int i = 0, sign = 1;",
          "2474:   if (i < len && *p == '-') {",
          "2475:     sign = -1, i++;",
          "2476:   } else if (i < len && *p == '+') {",
          "2477:     i++;",
          "2481:   for (; i < len && p[i] >= '0' && p[i] <= '9'; i++) {",
          "2482:     d *= 10.0;",
          "2483:     d += p[i] - '0';",
          "2484:   }",
          "2485:   d *= sign;",
          "2488:   if (i < len && p[i] == '.') {",
          "2489:     double frac = 0.0, base = 0.1;",
          "2490:     i++;",
          "2491:     for (; i < len && p[i] >= '0' && p[i] <= '9'; i++) {",
          "2492:       frac += base * (p[i] - '0');",
          "2493:       base /= 10.0;",
          "2495:     d += frac * sign;",
          "2499:   if (i < len && (p[i] == 'e' || p[i] == 'E')) {",
          "2500:     int j, exp = 0, minus = 0;",
          "2501:     i++;",
          "2502:     if (i < len && p[i] == '-') minus = 1, i++;",
          "2503:     if (i < len && p[i] == '+') i++;",
          "2504:     while (i < len && p[i] >= '0' && p[i] <= '9' && exp < 308)",
          "2505:       exp = exp * 10 + (p[i++] - '0');",
          "2506:     if (minus) exp = -exp;",
          "2507:     for (j = 0; j < exp; j++) d *= 10.0;",
          "2508:     for (j = 0; j < -exp; j++) d /= 10.0;",
          "2511:   if (numlen != NULL) *numlen = i;",
          "2512:   return d;",
          "2515: int mg_json_get(struct mg_str json, const char *path, int *toklen) {",
          "2516:   const char *s = json.ptr;",
          "2517:   int len = (int) json.len;",
          "2518:   enum { S_VALUE, S_KEY, S_COLON, S_COMMA_OR_EOO } expecting = S_VALUE;",
          "2519:   unsigned char nesting[MG_JSON_MAX_DEPTH];",
          "2520:   int i = 0;             // Current offset in `s`",
          "2521:   int j = 0;             // Offset in `s` we're looking for (return value)",
          "2522:   int depth = 0;         // Current depth (nesting level)",
          "2523:   int ed = 0;            // Expected depth",
          "2524:   int pos = 1;           // Current position in `path`",
          "2525:   int ci = -1, ei = -1;  // Current and expected index in array",
          "2527:   if (toklen) *toklen = 0;",
          "2528:   if (path[0] != '$') return MG_JSON_INVALID;",
          "2530: #define MG_CHECKRET(x)                                  \\",
          "2531:   do {                                                  \\",
          "2532:     if (depth == ed && path[pos] == '\\0' && ci == ei) { \\",
          "2533:       if (toklen) *toklen = i - j + 1;                  \\",
          "2534:       return j;                                         \\",
          "2535:     }                                                   \\",
          "2536:   } while (0)",
          "2540: #define MG_EOO(x)                                            \\",
          "2541:   do {                                                       \\",
          "2542:     if (depth == ed && ci != ei) return MG_JSON_NOT_FOUND;   \\",
          "2543:     if (c != nesting[depth - 1] + 2) return MG_JSON_INVALID; \\",
          "2544:     depth--;                                                 \\",
          "2545:     MG_CHECKRET(x);                                          \\",
          "2546:   } while (0)",
          "2548:   for (i = 0; i < len; i++) {",
          "2549:     unsigned char c = ((unsigned char *) s)[i];",
          "2550:     if (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') continue;",
          "2551:     switch (expecting) {",
          "2552:       case S_VALUE:",
          "2554:         if (depth == ed) j = i;",
          "2555:         if (c == '{') {",
          "2556:           if (depth >= (int) sizeof(nesting)) return MG_JSON_TOO_DEEP;",
          "2557:           if (depth == ed && path[pos] == '.' && ci == ei) {",
          "2559:             ed++, pos++, ci = ei = -1;",
          "2560:           }",
          "2561:           nesting[depth++] = c;",
          "2562:           expecting = S_KEY;",
          "2563:           break;",
          "2564:         } else if (c == '[') {",
          "2565:           if (depth >= (int) sizeof(nesting)) return MG_JSON_TOO_DEEP;",
          "2566:           if (depth == ed && path[pos] == '[' && ei == ci) {",
          "2567:             ed++, pos++, ci = 0;",
          "2568:             for (ei = 0; path[pos] != ']' && path[pos] != '\\0'; pos++) {",
          "2569:               ei *= 10;",
          "2570:               ei += path[pos] - '0';",
          "2571:             }",
          "2572:             if (path[pos] != 0) pos++;",
          "2573:           }",
          "2574:           nesting[depth++] = c;",
          "2575:           break;",
          "2576:         } else if (c == ']' && depth > 0) {  // Empty array",
          "2577:           MG_EOO(']');",
          "2578:         } else if (c == 't' && i + 3 < len && memcmp(&s[i], \"true\", 4) == 0) {",
          "2579:           i += 3;",
          "2580:         } else if (c == 'n' && i + 3 < len && memcmp(&s[i], \"null\", 4) == 0) {",
          "2581:           i += 3;",
          "2582:         } else if (c == 'f' && i + 4 < len && memcmp(&s[i], \"false\", 5) == 0) {",
          "2583:           i += 4;",
          "2584:         } else if (c == '-' || ((c >= '0' && c <= '9'))) {",
          "2585:           int numlen = 0;",
          "2586:           mg_atod(&s[i], len - i, &numlen);",
          "2587:           i += numlen - 1;",
          "2588:         } else if (c == '\"') {",
          "2589:           int n = mg_pass_string(&s[i + 1], len - i - 1);",
          "2590:           if (n < 0) return n;",
          "2591:           i += n + 1;",
          "2592:         } else {",
          "2593:           return MG_JSON_INVALID;",
          "2594:         }",
          "2595:         MG_CHECKRET('V');",
          "2596:         if (depth == ed && ei >= 0) ci++;",
          "2597:         expecting = S_COMMA_OR_EOO;",
          "2598:         break;",
          "2600:       case S_KEY:",
          "2601:         if (c == '\"') {",
          "2602:           int n = mg_pass_string(&s[i + 1], len - i - 1);",
          "2603:           if (n < 0) return n;",
          "2604:           if (i + 1 + n >= len) return MG_JSON_NOT_FOUND;",
          "2605:           if (depth < ed) return MG_JSON_NOT_FOUND;",
          "2606:           if (depth == ed && path[pos - 1] != '.') return MG_JSON_NOT_FOUND;",
          "2612:           if (depth == ed && path[pos - 1] == '.' &&",
          "2613:               strncmp(&s[i + 1], &path[pos], (size_t) n) == 0 &&",
          "2614:               (path[pos + n] == '\\0' || path[pos + n] == '.' ||",
          "2615:                path[pos + n] == '[')) {",
          "2616:             pos += n;",
          "2617:           }",
          "2618:           i += n + 1;",
          "2619:           expecting = S_COLON;",
          "2620:         } else if (c == '}') {  // Empty object",
          "2621:           MG_EOO('}');",
          "2622:           expecting = S_COMMA_OR_EOO;",
          "2623:           if (depth == ed && ei >= 0) ci++;",
          "2624:         } else {",
          "2625:           return MG_JSON_INVALID;",
          "2626:         }",
          "2627:         break;",
          "2629:       case S_COLON:",
          "2630:         if (c == ':') {",
          "2631:           expecting = S_VALUE;",
          "2632:         } else {",
          "2633:           return MG_JSON_INVALID;",
          "2634:         }",
          "2635:         break;",
          "2637:       case S_COMMA_OR_EOO:",
          "2638:         if (depth <= 0) {",
          "2639:           return MG_JSON_INVALID;",
          "2640:         } else if (c == ',') {",
          "2641:           expecting = (nesting[depth - 1] == '{') ? S_KEY : S_VALUE;",
          "2642:         } else if (c == ']' || c == '}') {",
          "2643:           if (depth == ed && c == '}' && path[pos - 1] == '.')",
          "2644:             return MG_JSON_NOT_FOUND;",
          "2645:           if (depth == ed && c == ']' && path[pos - 1] == ',')",
          "2646:             return MG_JSON_NOT_FOUND;",
          "2647:           MG_EOO('O');",
          "2648:           if (depth == ed && ei >= 0) ci++;",
          "2649:         } else {",
          "2650:           return MG_JSON_INVALID;",
          "2651:         }",
          "2652:         break;",
          "2653:     }",
          "2655:   return MG_JSON_NOT_FOUND;",
          "2656: }",
          "2658: bool mg_json_get_num(struct mg_str json, const char *path, double *v) {",
          "2659:   int n, toklen, found = 0;",
          "2660:   if ((n = mg_json_get(json, path, &toklen)) >= 0 &&",
          "2661:       (json.ptr[n] == '-' || (json.ptr[n] >= '0' && json.ptr[n] <= '9'))) {",
          "2662:     if (v != NULL) *v = mg_atod(json.ptr + n, toklen, NULL);",
          "2663:     found = 1;",
          "2665:   return found;",
          "2668: bool mg_json_get_bool(struct mg_str json, const char *path, bool *v) {",
          "2669:   int found = 0, off = mg_json_get(json, path, NULL);",
          "2670:   if (off >= 0 && (json.ptr[off] == 't' || json.ptr[off] == 'f')) {",
          "2671:     if (v != NULL) *v = json.ptr[off] == 't';",
          "2672:     found = 1;",
          "2674:   return found;",
          "2677: bool mg_json_unescape(struct mg_str s, char *to, size_t n) {",
          "2678:   size_t i, j;",
          "2679:   for (i = 0, j = 0; i < s.len && j < n; i++, j++) {",
          "2680:     if (s.ptr[i] == '\\\\' && i + 5 < s.len && s.ptr[i + 1] == 'u') {",
          "2684:       if (s.ptr[i + 2] != '0' || s.ptr[i + 3] != '0') return false;  // Give up",
          "2685:       ((unsigned char *) to)[j] = (unsigned char) mg_unhexn(s.ptr + i + 4, 2);",
          "2687:       i += 5;",
          "2688:     } else if (s.ptr[i] == '\\\\' && i + 1 < s.len) {",
          "2689:       char c = json_esc(s.ptr[i + 1], 0);",
          "2690:       if (c == 0) return false;",
          "2691:       to[j] = c;",
          "2692:       i++;",
          "2693:     } else {",
          "2694:       to[j] = s.ptr[i];",
          "2695:     }",
          "2696:   }",
          "2697:   if (j >= n) return false;",
          "2698:   if (n > 0) to[j] = '\\0';",
          "2699:   return true;",
          "2702: char *mg_json_get_str(struct mg_str json, const char *path) {",
          "2703:   char *result = NULL;",
          "2704:   int len = 0, off = mg_json_get(json, path, &len);",
          "2705:   if (off >= 0 && len > 1 && json.ptr[off] == '\"') {",
          "2706:     if ((result = (char *) calloc(1, (size_t) len)) != NULL &&",
          "2707:         !mg_json_unescape(mg_str_n(json.ptr + off + 1, (size_t) (len - 2)),",
          "2708:                           result, (size_t) len)) {",
          "2709:       free(result);",
          "2710:       result = NULL;",
          "2711:     }",
          "2713:   return result;",
          "2716: char *mg_json_get_b64(struct mg_str json, const char *path, int *slen) {",
          "2717:   char *result = NULL;",
          "2718:   int len = 0, off = mg_json_get(json, path, &len);",
          "2719:   if (off >= 0 && json.ptr[off] == '\"' && len > 1 &&",
          "2720:       (result = (char *) calloc(1, (size_t) len)) != NULL) {",
          "2721:     size_t k = mg_base64_decode(json.ptr + off + 1, (size_t) (len - 2), result,",
          "2722:                                 (size_t) len);",
          "2723:     if (slen != NULL) *slen = (int) k;",
          "2725:   return result;",
          "2728: char *mg_json_get_hex(struct mg_str json, const char *path, int *slen) {",
          "2729:   char *result = NULL;",
          "2730:   int len = 0, off = mg_json_get(json, path, &len);",
          "2731:   if (off >= 0 && json.ptr[off] == '\"' && len > 1 &&",
          "2732:       (result = (char *) calloc(1, (size_t) len / 2)) != NULL) {",
          "2733:     mg_unhex(json.ptr + off + 1, (size_t) (len - 2), (uint8_t *) result);",
          "2734:     result[len / 2 - 1] = '\\0';",
          "2735:     if (slen != NULL) *slen = len / 2 - 1;",
          "2736:   }",
          "2737:   return result;",
          "2740: long mg_json_get_long(struct mg_str json, const char *path, long dflt) {",
          "2741:   double dv;",
          "2742:   long result = dflt;",
          "2743:   if (mg_json_get_num(json, path, &dv)) result = (long) dv;",
          "2744:   return result;",
          "2747: #ifdef MG_ENABLE_LINES",
          "2748: #line 1 \"src/log.c\"",
          "2749: #endif",
          "2755: static int s_level = MG_LL_INFO;",
          "2756: static mg_pfn_t s_log_func = mg_pfn_stdout;",
          "2757: static void *s_log_func_param = NULL;",
          "2759: void mg_log_set_fn(mg_pfn_t fn, void *param) {",
          "2760:   s_log_func = fn;",
          "2761:   s_log_func_param = param;",
          "2762: }",
          "2764: static void logc(unsigned char c) {",
          "2765:   s_log_func((char) c, s_log_func_param);",
          "2766: }",
          "2768: static void logs(const char *buf, size_t len) {",
          "2769:   size_t i;",
          "2770:   for (i = 0; i < len; i++) logc(((unsigned char *) buf)[i]);",
          "2773: void mg_log_set(int log_level) {",
          "2774:   MG_DEBUG((\"Setting log level to %d\", log_level));",
          "2775:   s_level = log_level;",
          "2778: bool mg_log_prefix(int level, const char *file, int line, const char *fname) {",
          "2779:   if (level <= s_level) {",
          "2780:     const char *p = strrchr(file, '/');",
          "2781:     char buf[41];",
          "2782:     size_t n;",
          "2783:     if (p == NULL) p = strrchr(file, '\\\\');",
          "2784:     n = mg_snprintf(buf, sizeof(buf), \"%-6llx %d %s:%d:%s\", mg_millis(), level,",
          "2785:                     p == NULL ? file : p + 1, line, fname);",
          "2786:     if (n > sizeof(buf) - 2) n = sizeof(buf) - 2;",
          "2787:     while (n < sizeof(buf)) buf[n++] = ' ';",
          "2788:     logs(buf, n - 1);",
          "2789:     return true;",
          "2790:   } else {",
          "2791:     return false;",
          "2793: }",
          "2795: void mg_log(const char *fmt, ...) {",
          "2796:   va_list ap;",
          "2797:   va_start(ap, fmt);",
          "2798:   mg_vxprintf(s_log_func, s_log_func_param, fmt, &ap);",
          "2799:   va_end(ap);",
          "2800:   logs(\"\\r\\n\", 2);",
          "2801: }",
          "2803: static unsigned char nibble(unsigned c) {",
          "2804:   return (unsigned char) (c < 10 ? c + '0' : c + 'W');",
          "2805: }",
          "2807: #define ISPRINT(x) ((x) >= ' ' && (x) <= '~')",
          "2808: void mg_hexdump(const void *buf, size_t len) {",
          "2809:   const unsigned char *p = (const unsigned char *) buf;",
          "2810:   unsigned char ascii[16], alen = 0;",
          "2811:   size_t i;",
          "2812:   for (i = 0; i < len; i++) {",
          "2813:     if ((i % 16) == 0) {",
          "2815:       if (i > 0) logs(\"  \", 2), logs((char *) ascii, 16), logc('\\n'), alen = 0;",
          "2817:       logc(nibble((i >> 12) & 15)), logc(nibble((i >> 8) & 15)),",
          "2818:           logc(nibble((i >> 4) & 15)), logc('0'), logs(\"   \", 3);",
          "2820:     logc(nibble(p[i] >> 4)), logc(nibble(p[i] & 15));  // Two nibbles, e.g. c5",
          "2821:     logc(' ');                                         // Space after hex number",
          "2822:     ascii[alen++] = ISPRINT(p[i]) ? p[i] : '.';        // Add to the ascii buf",
          "2824:   while (alen < 16) logs(\"   \", 3), ascii[alen++] = ' ';",
          "2825:   logs(\"  \", 2), logs((char *) ascii, 16), logc('\\n');",
          "2828: #ifdef MG_ENABLE_LINES",
          "2829: #line 1 \"src/md5.c\"",
          "2830: #endif",
          "2834: #if defined(MG_ENABLE_MD5) && MG_ENABLE_MD5",
          "2836: static void mg_byte_reverse(unsigned char *buf, unsigned longs) {",
          "2837:   if (MG_BIG_ENDIAN) {",
          "2838:     do {",
          "2839:       uint32_t t = (uint32_t) ((unsigned) buf[3] << 8 | buf[2]) << 16 |",
          "2840:                    ((unsigned) buf[1] << 8 | buf[0]);",
          "2842:       buf += 4;",
          "2843:     } while (--longs);",
          "2845:     (void) buf, (void) longs;  // Little endian. Do nothing",
          "2849: #define F1(x, y, z) (z ^ (x & (y ^ z)))",
          "2850: #define F2(x, y, z) F1(z, x, y)",
          "2851: #define F3(x, y, z) (x ^ y ^ z)",
          "2852: #define F4(x, y, z) (y ^ (x | ~z))",
          "2854: #define MD5STEP(f, w, x, y, z, data, s) \\",
          "2855:   (w += f(x, y, z) + data, w = w << s | w >> (32 - s), w += x)",
          "2861: void mg_md5_init(mg_md5_ctx *ctx) {",
          "2862:   ctx->buf[0] = 0x67452301;",
          "2863:   ctx->buf[1] = 0xefcdab89;",
          "2864:   ctx->buf[2] = 0x98badcfe;",
          "2865:   ctx->buf[3] = 0x10325476;",
          "2867:   ctx->bits[0] = 0;",
          "2868:   ctx->bits[1] = 0;",
          "2869: }",
          "2871: static void mg_md5_transform(uint32_t buf[4], uint32_t const in[16]) {",
          "2872:   uint32_t a, b, c, d;",
          "2874:   a = buf[0];",
          "2875:   b = buf[1];",
          "2876:   c = buf[2];",
          "2877:   d = buf[3];",
          "2879:   MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);",
          "2880:   MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);",
          "2881:   MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);",
          "2882:   MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);",
          "2883:   MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);",
          "2884:   MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);",
          "2885:   MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);",
          "2886:   MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);",
          "2887:   MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);",
          "2888:   MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);",
          "2889:   MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);",
          "2890:   MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);",
          "2891:   MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);",
          "2892:   MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);",
          "2893:   MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);",
          "2894:   MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);",
          "2896:   MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);",
          "2897:   MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);",
          "2898:   MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);",
          "2899:   MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);",
          "2900:   MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);",
          "2901:   MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);",
          "2902:   MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);",
          "2903:   MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);",
          "2904:   MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);",
          "2905:   MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);",
          "2906:   MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);",
          "2907:   MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);",
          "2908:   MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);",
          "2909:   MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);",
          "2910:   MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);",
          "2911:   MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);",
          "2913:   MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);",
          "2914:   MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);",
          "2915:   MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);",
          "2916:   MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);",
          "2917:   MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);",
          "2918:   MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);",
          "2919:   MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);",
          "2920:   MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);",
          "2921:   MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);",
          "2922:   MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);",
          "2923:   MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);",
          "2924:   MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);",
          "2925:   MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);",
          "2926:   MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);",
          "2927:   MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);",
          "2928:   MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);",
          "2930:   MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);",
          "2931:   MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);",
          "2932:   MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);",
          "2933:   MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);",
          "2934:   MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);",
          "2935:   MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);",
          "2936:   MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);",
          "2937:   MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);",
          "2938:   MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);",
          "2939:   MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);",
          "2940:   MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);",
          "2941:   MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);",
          "2942:   MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);",
          "2943:   MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);",
          "2944:   MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);",
          "2945:   MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);",
          "2947:   buf[0] += a;",
          "2948:   buf[1] += b;",
          "2949:   buf[2] += c;",
          "2950:   buf[3] += d;",
          "2953: void mg_md5_update(mg_md5_ctx *ctx, const unsigned char *buf, size_t len) {",
          "2954:   uint32_t t;",
          "2956:   t = ctx->bits[0];",
          "2957:   if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t) ctx->bits[1]++;",
          "2958:   ctx->bits[1] += (uint32_t) len >> 29;",
          "2960:   t = (t >> 3) & 0x3f;",
          "2962:   if (t) {",
          "2963:     unsigned char *p = (unsigned char *) ctx->in + t;",
          "2965:     t = 64 - t;",
          "2966:     if (len < t) {",
          "2967:       memcpy(p, buf, len);",
          "2968:       return;",
          "2970:     memcpy(p, buf, t);",
          "2971:     mg_byte_reverse(ctx->in, 16);",
          "2972:     mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);",
          "2973:     buf += t;",
          "2974:     len -= t;",
          "2977:   while (len >= 64) {",
          "2978:     memcpy(ctx->in, buf, 64);",
          "2979:     mg_byte_reverse(ctx->in, 16);",
          "2980:     mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);",
          "2981:     buf += 64;",
          "2982:     len -= 64;",
          "2985:   memcpy(ctx->in, buf, len);",
          "2988: void mg_md5_final(mg_md5_ctx *ctx, unsigned char digest[16]) {",
          "2989:   unsigned count;",
          "2990:   unsigned char *p;",
          "2991:   uint32_t *a;",
          "2993:   count = (ctx->bits[0] >> 3) & 0x3F;",
          "2995:   p = ctx->in + count;",
          "2997:   count = 64 - 1 - count;",
          "2998:   if (count < 8) {",
          "2999:     memset(p, 0, count);",
          "3000:     mg_byte_reverse(ctx->in, 16);",
          "3001:     mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);",
          "3002:     memset(ctx->in, 0, 56);",
          "3004:     memset(p, 0, count - 8);",
          "3006:   mg_byte_reverse(ctx->in, 14);",
          "3008:   a = (uint32_t *) ctx->in;",
          "3009:   a[14] = ctx->bits[0];",
          "3010:   a[15] = ctx->bits[1];",
          "3012:   mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);",
          "3013:   mg_byte_reverse((unsigned char *) ctx->buf, 4);",
          "3014:   memcpy(digest, ctx->buf, 16);",
          "3015:   memset((char *) ctx, 0, sizeof(*ctx));",
          "3017: #endif",
          "3019: #ifdef MG_ENABLE_LINES",
          "3020: #line 1 \"src/mqtt.c\"",
          "3021: #endif",
          "3030: #define MQTT_CLEAN_SESSION 0x02",
          "3031: #define MQTT_HAS_WILL 0x04",
          "3032: #define MQTT_WILL_RETAIN 0x20",
          "3033: #define MQTT_HAS_PASSWORD 0x40",
          "3034: #define MQTT_HAS_USER_NAME 0x80",
          "3036: struct mg_mqtt_pmap {",
          "3037:   uint8_t id;",
          "3038:   uint8_t type;",
          "3039: };",
          "3041: static const struct mg_mqtt_pmap s_prop_map[] = {",
          "3042:     {MQTT_PROP_PAYLOAD_FORMAT_INDICATOR, MQTT_PROP_TYPE_BYTE},",
          "3043:     {MQTT_PROP_MESSAGE_EXPIRY_INTERVAL, MQTT_PROP_TYPE_INT},",
          "3044:     {MQTT_PROP_CONTENT_TYPE, MQTT_PROP_TYPE_STRING},",
          "3045:     {MQTT_PROP_RESPONSE_TOPIC, MQTT_PROP_TYPE_STRING},",
          "3046:     {MQTT_PROP_CORRELATION_DATA, MQTT_PROP_TYPE_BINARY_DATA},",
          "3047:     {MQTT_PROP_SUBSCRIPTION_IDENTIFIER, MQTT_PROP_TYPE_VARIABLE_INT},",
          "3048:     {MQTT_PROP_SESSION_EXPIRY_INTERVAL, MQTT_PROP_TYPE_INT},",
          "3049:     {MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, MQTT_PROP_TYPE_STRING},",
          "3050:     {MQTT_PROP_SERVER_KEEP_ALIVE, MQTT_PROP_TYPE_SHORT},",
          "3051:     {MQTT_PROP_AUTHENTICATION_METHOD, MQTT_PROP_TYPE_STRING},",
          "3052:     {MQTT_PROP_AUTHENTICATION_DATA, MQTT_PROP_TYPE_BINARY_DATA},",
          "3053:     {MQTT_PROP_REQUEST_PROBLEM_INFORMATION, MQTT_PROP_TYPE_BYTE},",
          "3054:     {MQTT_PROP_WILL_DELAY_INTERVAL, MQTT_PROP_TYPE_INT},",
          "3055:     {MQTT_PROP_REQUEST_RESPONSE_INFORMATION, MQTT_PROP_TYPE_BYTE},",
          "3056:     {MQTT_PROP_RESPONSE_INFORMATION, MQTT_PROP_TYPE_STRING},",
          "3057:     {MQTT_PROP_SERVER_REFERENCE, MQTT_PROP_TYPE_STRING},",
          "3058:     {MQTT_PROP_REASON_STRING, MQTT_PROP_TYPE_STRING},",
          "3059:     {MQTT_PROP_RECEIVE_MAXIMUM, MQTT_PROP_TYPE_SHORT},",
          "3060:     {MQTT_PROP_TOPIC_ALIAS_MAXIMUM, MQTT_PROP_TYPE_SHORT},",
          "3061:     {MQTT_PROP_TOPIC_ALIAS, MQTT_PROP_TYPE_SHORT},",
          "3062:     {MQTT_PROP_MAXIMUM_QOS, MQTT_PROP_TYPE_BYTE},",
          "3063:     {MQTT_PROP_RETAIN_AVAILABLE, MQTT_PROP_TYPE_BYTE},",
          "3064:     {MQTT_PROP_USER_PROPERTY, MQTT_PROP_TYPE_STRING_PAIR},",
          "3065:     {MQTT_PROP_MAXIMUM_PACKET_SIZE, MQTT_PROP_TYPE_INT},",
          "3066:     {MQTT_PROP_WILDCARD_SUBSCRIPTION_AVAILABLE, MQTT_PROP_TYPE_BYTE},",
          "3067:     {MQTT_PROP_SUBSCRIPTION_IDENTIFIER_AVAILABLE, MQTT_PROP_TYPE_BYTE},",
          "3068:     {MQTT_PROP_SHARED_SUBSCRIPTION_AVAILABLE, MQTT_PROP_TYPE_BYTE}};",
          "3070: void mg_mqtt_send_header(struct mg_connection *c, uint8_t cmd, uint8_t flags,",
          "3071:                          uint32_t len) {",
          "3072:   uint8_t buf[1 + sizeof(len)], *vlen = &buf[1];",
          "3073:   buf[0] = (uint8_t) ((cmd << 4) | flags);",
          "3074:   do {",
          "3076:     len /= 0x80;",
          "3077:     if (len > 0) *vlen |= 0x80;",
          "3078:     vlen++;",
          "3079:   } while (len > 0 && vlen < &buf[sizeof(buf)]);",
          "3080:   mg_send(c, buf, (size_t) (vlen - buf));",
          "3083: static void mg_send_u16(struct mg_connection *c, uint16_t value) {",
          "3084:   mg_send(c, &value, sizeof(value));",
          "3087: static void mg_send_u32(struct mg_connection *c, uint32_t value) {",
          "3088:   mg_send(c, &value, sizeof(value));",
          "3091: static uint8_t varint_size(size_t length) {",
          "3092:   uint8_t bytes_needed = 0;",
          "3093:   do {",
          "3094:     bytes_needed++;",
          "3095:     length /= 0x80;",
          "3096:   } while (length > 0);",
          "3097:   return bytes_needed;",
          "3100: static size_t encode_varint(uint8_t *buf, size_t value) {",
          "3101:   size_t len = 0;",
          "3103:   do {",
          "3104:     uint8_t byte = (uint8_t) (value % 128);",
          "3105:     value /= 128;",
          "3106:     if (value > 0) byte |= 0x80;",
          "3107:     buf[len++] = byte;",
          "3108:   } while (value > 0);",
          "3110:   return len;",
          "3113: static size_t decode_varint(const uint8_t *buf, size_t len, size_t *value) {",
          "3114:   size_t multiplier = 1, offset;",
          "3117:   for (offset = 0; offset < 4 && offset < len; offset++) {",
          "3118:     uint8_t encoded_byte = buf[offset];",
          "3120:     multiplier *= 128;",
          "3122:     if ((encoded_byte & 0x80) == 0) return offset + 1;",
          "3125:   return 0;",
          "3128: static int mqtt_prop_type_by_id(uint8_t prop_id) {",
          "3129:   size_t i, num_properties = sizeof(s_prop_map) / sizeof(s_prop_map[0]);",
          "3130:   for (i = 0; i < num_properties; ++i) {",
          "3131:     if (s_prop_map[i].id == prop_id) return s_prop_map[i].type;",
          "3133:   return -1;  // Property ID not found",
          "3138: static size_t get_properties_length(struct mg_mqtt_prop *props, size_t count) {",
          "3139:   size_t i, size = 0;",
          "3140:   for (i = 0; i < count; i++) {",
          "3141:     size++;  // identifier",
          "3142:     switch (mqtt_prop_type_by_id(props[i].id)) {",
          "3143:       case MQTT_PROP_TYPE_STRING_PAIR:",
          "3144:         size += (uint32_t) (props[i].val.len + props[i].key.len +",
          "3145:                             2 * sizeof(uint16_t));",
          "3146:         break;",
          "3147:       case MQTT_PROP_TYPE_STRING:",
          "3148:         size += (uint32_t) (props[i].val.len + sizeof(uint16_t));",
          "3149:         break;",
          "3150:       case MQTT_PROP_TYPE_BINARY_DATA:",
          "3151:         size += (uint32_t) (props[i].val.len + sizeof(uint16_t));",
          "3152:         break;",
          "3153:       case MQTT_PROP_TYPE_VARIABLE_INT:",
          "3154:         size += varint_size((uint32_t) props[i].iv);",
          "3155:         break;",
          "3156:       case MQTT_PROP_TYPE_INT:",
          "3157:         size += (uint32_t) sizeof(uint32_t);",
          "3158:         break;",
          "3159:       case MQTT_PROP_TYPE_SHORT:",
          "3160:         size += (uint32_t) sizeof(uint16_t);",
          "3161:         break;",
          "3162:       case MQTT_PROP_TYPE_BYTE:",
          "3163:         size += (uint32_t) sizeof(uint8_t);",
          "3165:       default:",
          "3166:         return size;  // cannot parse further down",
          "3170:   return size;",
          "3171: }",
          "3175: static size_t get_props_size(struct mg_mqtt_prop *props, size_t count) {",
          "3176:   size_t size = get_properties_length(props, count);",
          "3177:   size += varint_size(size);",
          "3178:   return size;",
          "3181: static void mg_send_mqtt_properties(struct mg_connection *c,",
          "3182:                                     struct mg_mqtt_prop *props, size_t nprops) {",
          "3183:   size_t total_size = get_properties_length(props, nprops);",
          "3184:   uint8_t buf_v[4] = {0, 0, 0, 0};",
          "3185:   uint8_t buf[4] = {0, 0, 0, 0};",
          "3186:   size_t i, len = encode_varint(buf, total_size);",
          "3188:   mg_send(c, buf, (size_t) len);",
          "3189:   for (i = 0; i < nprops; i++) {",
          "3190:     mg_send(c, &props[i].id, sizeof(props[i].id));",
          "3191:     switch (mqtt_prop_type_by_id(props[i].id)) {",
          "3192:       case MQTT_PROP_TYPE_STRING_PAIR:",
          "3193:         mg_send_u16(c, mg_htons((uint16_t) props[i].key.len));",
          "3194:         mg_send(c, props[i].key.ptr, props[i].key.len);",
          "3195:         mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));",
          "3196:         mg_send(c, props[i].val.ptr, props[i].val.len);",
          "3197:         break;",
          "3198:       case MQTT_PROP_TYPE_BYTE:",
          "3199:         mg_send(c, &props[i].iv, sizeof(uint8_t));",
          "3200:         break;",
          "3201:       case MQTT_PROP_TYPE_SHORT:",
          "3202:         mg_send_u16(c, mg_htons((uint16_t) props[i].iv));",
          "3203:         break;",
          "3204:       case MQTT_PROP_TYPE_INT:",
          "3205:         mg_send_u32(c, mg_htonl((uint32_t) props[i].iv));",
          "3206:         break;",
          "3207:       case MQTT_PROP_TYPE_STRING:",
          "3208:         mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));",
          "3209:         mg_send(c, props[i].val.ptr, props[i].val.len);",
          "3210:         break;",
          "3211:       case MQTT_PROP_TYPE_BINARY_DATA:",
          "3212:         mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));",
          "3213:         mg_send(c, props[i].val.ptr, props[i].val.len);",
          "3214:         break;",
          "3215:       case MQTT_PROP_TYPE_VARIABLE_INT:",
          "3216:         len = encode_varint(buf_v, props[i].iv);",
          "3217:         mg_send(c, buf_v, (size_t) len);",
          "3218:         break;",
          "3223: size_t mg_mqtt_next_prop(struct mg_mqtt_message *msg, struct mg_mqtt_prop *prop,",
          "3224:                          size_t ofs) {",
          "3225:   uint8_t *i = (uint8_t *) msg->dgram.ptr + msg->props_start + ofs;",
          "3226:   uint8_t *end = (uint8_t *) msg->dgram.ptr + msg->dgram.len;",
          "3227:   size_t new_pos = ofs, len;",
          "3228:   prop->id = i[0];",
          "3230:   if (ofs >= msg->dgram.len || ofs >= msg->props_start + msg->props_size)",
          "3231:     return 0;",
          "3232:   i++, new_pos++;",
          "3234:   switch (mqtt_prop_type_by_id(prop->id)) {",
          "3235:     case MQTT_PROP_TYPE_STRING_PAIR:",
          "3236:       prop->key.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);",
          "3237:       prop->key.ptr = (char *) i + 2;",
          "3238:       i += 2 + prop->key.len;",
          "3239:       prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);",
          "3240:       prop->val.ptr = (char *) i + 2;",
          "3241:       new_pos += 2 * sizeof(uint16_t) + prop->val.len + prop->key.len;",
          "3242:       break;",
          "3243:     case MQTT_PROP_TYPE_BYTE:",
          "3244:       prop->iv = (uint8_t) i[0];",
          "3245:       new_pos++;",
          "3246:       break;",
          "3247:     case MQTT_PROP_TYPE_SHORT:",
          "3248:       prop->iv = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);",
          "3249:       new_pos += sizeof(uint16_t);",
          "3250:       break;",
          "3251:     case MQTT_PROP_TYPE_INT:",
          "3252:       prop->iv = ((uint32_t) i[0] << 24) | ((uint32_t) i[1] << 16) |",
          "3253:                  ((uint32_t) i[2] << 8) | i[3];",
          "3254:       new_pos += sizeof(uint32_t);",
          "3255:       break;",
          "3256:     case MQTT_PROP_TYPE_STRING:",
          "3257:       prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);",
          "3258:       prop->val.ptr = (char *) i + 2;",
          "3259:       new_pos += 2 + prop->val.len;",
          "3260:       break;",
          "3261:     case MQTT_PROP_TYPE_BINARY_DATA:",
          "3262:       prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);",
          "3263:       prop->val.ptr = (char *) i + 2;",
          "3264:       new_pos += 2 + prop->val.len;",
          "3265:       break;",
          "3266:     case MQTT_PROP_TYPE_VARIABLE_INT:",
          "3267:       len = decode_varint(i, (size_t) (end - i), (size_t *) &prop->iv);",
          "3268:       new_pos = (!len) ? 0 : new_pos + len;",
          "3269:       break;",
          "3270:     default:",
          "3271:       new_pos = 0;",
          "3272:   }",
          "3274:   return new_pos;",
          "3277: void mg_mqtt_login(struct mg_connection *c, const struct mg_mqtt_opts *opts) {",
          "3278:   char rnd[10], client_id[21];",
          "3279:   struct mg_str cid = opts->client_id;",
          "3280:   size_t total_len = 7 + 1 + 2 + 2;",
          "3281:   uint8_t hdr[8] = {0, 4, 'M', 'Q', 'T', 'T', opts->version, 0};",
          "3283:   if (cid.len == 0) {",
          "3284:     mg_random(rnd, sizeof(rnd));",
          "3285:     mg_hex(rnd, sizeof(rnd), client_id);",
          "3286:     client_id[sizeof(client_id) - 1] = '\\0';",
          "3287:     cid = mg_str(client_id);",
          "3288:   }",
          "3290:   if (hdr[6] == 0) hdr[6] = 4;  // If version is not set, use 4 (3.1.1)",
          "3291:   c->is_mqtt5 = hdr[6] == 5;    // Set version 5 flag",
          "3292:   hdr[7] = (uint8_t) ((opts->qos & 3) << 3);  // Connection flags",
          "3293:   if (opts->user.len > 0) {",
          "3294:     total_len += 2 + (uint32_t) opts->user.len;",
          "3295:     hdr[7] |= MQTT_HAS_USER_NAME;",
          "3296:   }",
          "3297:   if (opts->pass.len > 0) {",
          "3298:     total_len += 2 + (uint32_t) opts->pass.len;",
          "3299:     hdr[7] |= MQTT_HAS_PASSWORD;",
          "3300:   }",
          "3301:   if (opts->topic.len > 0 && opts->message.len > 0) {",
          "3302:     total_len += 4 + (uint32_t) opts->topic.len + (uint32_t) opts->message.len;",
          "3303:     hdr[7] |= MQTT_HAS_WILL;",
          "3304:   }",
          "3305:   if (opts->clean || cid.len == 0) hdr[7] |= MQTT_CLEAN_SESSION;",
          "3306:   if (opts->retain) hdr[7] |= MQTT_WILL_RETAIN;",
          "3307:   total_len += (uint32_t) cid.len;",
          "3308:   if (c->is_mqtt5) {",
          "3309:     total_len += get_props_size(opts->props, opts->num_props);",
          "3310:     if (hdr[7] & MQTT_HAS_WILL)",
          "3311:       total_len += get_props_size(opts->will_props, opts->num_will_props);",
          "3312:   }",
          "3314:   mg_mqtt_send_header(c, MQTT_CMD_CONNECT, 0, (uint32_t) total_len);",
          "3315:   mg_send(c, hdr, sizeof(hdr));",
          "3317:   mg_send_u16(c, mg_htons((uint16_t) opts->keepalive));",
          "3319:   if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);",
          "3321:   mg_send_u16(c, mg_htons((uint16_t) cid.len));",
          "3322:   mg_send(c, cid.ptr, cid.len);",
          "3324:   if (hdr[7] & MQTT_HAS_WILL) {",
          "3325:     if (c->is_mqtt5)",
          "3326:       mg_send_mqtt_properties(c, opts->will_props, opts->num_will_props);",
          "3328:     mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));",
          "3329:     mg_send(c, opts->topic.ptr, opts->topic.len);",
          "3330:     mg_send_u16(c, mg_htons((uint16_t) opts->message.len));",
          "3331:     mg_send(c, opts->message.ptr, opts->message.len);",
          "3332:   }",
          "3333:   if (opts->user.len > 0) {",
          "3334:     mg_send_u16(c, mg_htons((uint16_t) opts->user.len));",
          "3335:     mg_send(c, opts->user.ptr, opts->user.len);",
          "3336:   }",
          "3337:   if (opts->pass.len > 0) {",
          "3338:     mg_send_u16(c, mg_htons((uint16_t) opts->pass.len));",
          "3339:     mg_send(c, opts->pass.ptr, opts->pass.len);",
          "3340:   }",
          "3343: void mg_mqtt_pub(struct mg_connection *c, const struct mg_mqtt_opts *opts) {",
          "3344:   uint8_t flags = (uint8_t) (((opts->qos & 3) << 1) | (opts->retain ? 1 : 0));",
          "3345:   size_t len = 2 + opts->topic.len + opts->message.len;",
          "3346:   MG_DEBUG((\"%lu [%.*s] -> [%.*s]\", c->id, (int) opts->topic.len,",
          "3347:             (char *) opts->topic.ptr, (int) opts->message.len,",
          "3348:             (char *) opts->message.ptr));",
          "3349:   if (opts->qos > 0) len += 2;",
          "3350:   if (c->is_mqtt5) len += get_props_size(opts->props, opts->num_props);",
          "3352:   mg_mqtt_send_header(c, MQTT_CMD_PUBLISH, flags, (uint32_t) len);",
          "3353:   mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));",
          "3354:   mg_send(c, opts->topic.ptr, opts->topic.len);",
          "3355:   if (opts->qos > 0) {",
          "3356:     if (++c->mgr->mqtt_id == 0) ++c->mgr->mqtt_id;",
          "3357:     mg_send_u16(c, mg_htons(c->mgr->mqtt_id));",
          "3360:   if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);",
          "3362:   mg_send(c, opts->message.ptr, opts->message.len);",
          "3365: void mg_mqtt_sub(struct mg_connection *c, const struct mg_mqtt_opts *opts) {",
          "3366:   uint8_t qos_ = opts->qos & 3;",
          "3367:   size_t plen = c->is_mqtt5 ? get_props_size(opts->props, opts->num_props) : 0;",
          "3368:   size_t len = 2 + opts->topic.len + 2 + 1 + plen;",
          "3370:   mg_mqtt_send_header(c, MQTT_CMD_SUBSCRIBE, 2, (uint32_t) len);",
          "3371:   if (++c->mgr->mqtt_id == 0) ++c->mgr->mqtt_id;",
          "3372:   mg_send_u16(c, mg_htons(c->mgr->mqtt_id));",
          "3373:   if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);",
          "3375:   mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));",
          "3376:   mg_send(c, opts->topic.ptr, opts->topic.len);",
          "3377:   mg_send(c, &qos_, sizeof(qos_));",
          "3380: int mg_mqtt_parse(const uint8_t *buf, size_t len, uint8_t version,",
          "3381:                   struct mg_mqtt_message *m) {",
          "3382:   uint8_t lc = 0, *p, *end;",
          "3383:   uint32_t n = 0, len_len = 0;",
          "3385:   memset(m, 0, sizeof(*m));",
          "3386:   m->dgram.ptr = (char *) buf;",
          "3387:   if (len < 2) return MQTT_INCOMPLETE;",
          "3388:   m->cmd = (uint8_t) (buf[0] >> 4);",
          "3389:   m->qos = (buf[0] >> 1) & 3;",
          "3391:   n = len_len = 0;",
          "3392:   p = (uint8_t *) buf + 1;",
          "3393:   while ((size_t) (p - buf) < len) {",
          "3394:     lc = *((uint8_t *) p++);",
          "3395:     n += (uint32_t) ((lc & 0x7f) << 7 * len_len);",
          "3396:     len_len++;",
          "3397:     if (!(lc & 0x80)) break;",
          "3398:     if (len_len >= 4) return MQTT_MALFORMED;",
          "3400:   end = p + n;",
          "3401:   if ((lc & 0x80) || (end > buf + len)) return MQTT_INCOMPLETE;",
          "3402:   m->dgram.len = (size_t) (end - buf);",
          "3404:   switch (m->cmd) {",
          "3405:     case MQTT_CMD_CONNACK:",
          "3406:       if (end - p < 2) return MQTT_MALFORMED;",
          "3407:       m->ack = p[1];",
          "3408:       break;",
          "3409:     case MQTT_CMD_PUBACK:",
          "3410:     case MQTT_CMD_PUBREC:",
          "3411:     case MQTT_CMD_PUBREL:",
          "3412:     case MQTT_CMD_PUBCOMP:",
          "3413:     case MQTT_CMD_SUBSCRIBE:",
          "3414:     case MQTT_CMD_SUBACK:",
          "3415:     case MQTT_CMD_UNSUBSCRIBE:",
          "3416:     case MQTT_CMD_UNSUBACK:",
          "3417:       if (p + 2 > end) return MQTT_MALFORMED;",
          "3418:       m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);",
          "3419:       p += 2;",
          "3420:       break;",
          "3421:     case MQTT_CMD_PUBLISH: {",
          "3422:       if (p + 2 > end) return MQTT_MALFORMED;",
          "3423:       m->topic.len = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);",
          "3424:       m->topic.ptr = (char *) p + 2;",
          "3425:       p += 2 + m->topic.len;",
          "3426:       if (p > end) return MQTT_MALFORMED;",
          "3427:       if (m->qos > 0) {",
          "3428:         if (p + 2 > end) return MQTT_MALFORMED;",
          "3429:         m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);",
          "3430:         p += 2;",
          "3431:       }",
          "3432:       if (p > end) return MQTT_MALFORMED;",
          "3433:       if (version == 5 && p + 2 < end) {",
          "3434:         len_len = (uint32_t) decode_varint(p, (size_t) (end - p), &m->props_size);",
          "3435:         if (!len_len) return MQTT_MALFORMED;",
          "3436:         m->props_start = (size_t) (p + len_len - buf);",
          "3437:         p += len_len + m->props_size;",
          "3438:       }",
          "3439:       if (p > end) return MQTT_MALFORMED;",
          "3440:       m->data.ptr = (char *) p;",
          "3441:       m->data.len = (size_t) (end - p);",
          "3442:       break;",
          "3444:     default:",
          "3445:       break;",
          "3447:   return MQTT_OK;",
          "3450: static void mqtt_cb(struct mg_connection *c, int ev, void *ev_data,",
          "3451:                     void *fn_data) {",
          "3452:   if (ev == MG_EV_READ) {",
          "3453:     for (;;) {",
          "3454:       uint8_t version = c->is_mqtt5 ? 5 : 4;",
          "3455:       struct mg_mqtt_message mm;",
          "3456:       int rc = mg_mqtt_parse(c->recv.buf, c->recv.len, version, &mm);",
          "3457:       if (rc == MQTT_MALFORMED) {",
          "3458:         MG_ERROR((\"%lu MQTT malformed message\", c->id));",
          "3459:         c->is_closing = 1;",
          "3460:         break;",
          "3461:       } else if (rc == MQTT_OK) {",
          "3462:         MG_VERBOSE((\"%lu MQTT CMD %d len %d [%.*s]\", c->id, mm.cmd,",
          "3463:                     (int) mm.dgram.len, (int) mm.data.len, mm.data.ptr));",
          "3464:         switch (mm.cmd) {",
          "3465:           case MQTT_CMD_CONNACK:",
          "3466:             mg_call(c, MG_EV_MQTT_OPEN, &mm.ack);",
          "3467:             if (mm.ack == 0) {",
          "3468:               MG_DEBUG((\"%lu Connected\", c->id));",
          "3469:             } else {",
          "3470:               MG_ERROR((\"%lu MQTT auth failed, code %d\", c->id, mm.ack));",
          "3471:               c->is_closing = 1;",
          "3472:             }",
          "3473:             break;",
          "3474:           case MQTT_CMD_PUBLISH: {",
          "3475:             MG_DEBUG((\"%lu [%.*s] -> [%.*s]\", c->id, (int) mm.topic.len,",
          "3476:                       mm.topic.ptr, (int) mm.data.len, mm.data.ptr));",
          "3477:             if (mm.qos > 0) {",
          "3478:               uint16_t id = mg_ntohs(mm.id);",
          "3479:               uint32_t remaining_len = sizeof(id);",
          "3480:               if (c->is_mqtt5) remaining_len += 2;  // 3.4.2",
          "3482:               mg_mqtt_send_header(",
          "3483:                   c,",
          "3484:                   (uint8_t) (mm.qos == 2 ? MQTT_CMD_PUBREC : MQTT_CMD_PUBACK),",
          "3485:                   0, remaining_len);",
          "3486:               mg_send(c, &id, sizeof(id));",
          "3488:               if (c->is_mqtt5) {",
          "3489:                 uint16_t zero = 0;",
          "3490:                 mg_send(c, &zero, sizeof(zero));",
          "3491:               }",
          "3492:             }",
          "3493:             mg_call(c, MG_EV_MQTT_MSG, &mm);  // let the app handle qos stuff",
          "3494:             break;",
          "3495:           }",
          "3496:           case MQTT_CMD_PUBREC: {  // MQTT5: 3.5.2-1 TODO(): variable header rc",
          "3497:             uint16_t id = mg_ntohs(mm.id);",
          "3498:             uint32_t remaining_len = sizeof(id);  // MQTT5 3.6.2-1",
          "3499:             mg_mqtt_send_header(c, MQTT_CMD_PUBREL, 2, remaining_len);",
          "3500:             mg_send(c, &id, sizeof(id));  // MQTT5 3.6.1-1, flags = 2",
          "3501:             break;",
          "3502:           }",
          "3503:           case MQTT_CMD_PUBREL: {  // MQTT5: 3.6.2-1 TODO(): variable header rc",
          "3504:             uint16_t id = mg_ntohs(mm.id);",
          "3505:             uint32_t remaining_len = sizeof(id);  // MQTT5 3.7.2-1",
          "3506:             mg_mqtt_send_header(c, MQTT_CMD_PUBCOMP, 0, remaining_len);",
          "3507:             mg_send(c, &id, sizeof(id));",
          "3508:             break;",
          "3509:           }",
          "3510:         }",
          "3511:         mg_call(c, MG_EV_MQTT_CMD, &mm);",
          "3512:         mg_iobuf_del(&c->recv, 0, mm.dgram.len);",
          "3513:       } else {",
          "3514:         break;",
          "3515:       }",
          "3518:   (void) ev_data;",
          "3519:   (void) fn_data;",
          "3520: }",
          "3522: void mg_mqtt_ping(struct mg_connection *nc) {",
          "3523:   mg_mqtt_send_header(nc, MQTT_CMD_PINGREQ, 0, 0);",
          "3524: }",
          "3526: void mg_mqtt_pong(struct mg_connection *nc) {",
          "3527:   mg_mqtt_send_header(nc, MQTT_CMD_PINGRESP, 0, 0);",
          "3528: }",
          "3530: void mg_mqtt_disconnect(struct mg_connection *c,",
          "3531:                         const struct mg_mqtt_opts *opts) {",
          "3532:   size_t len = 0;",
          "3533:   if (c->is_mqtt5) len = 1 + get_props_size(opts->props, opts->num_props);",
          "3534:   mg_mqtt_send_header(c, MQTT_CMD_DISCONNECT, 0, (uint32_t) len);",
          "3536:   if (c->is_mqtt5) {",
          "3537:     uint8_t zero = 0;",
          "3538:     mg_send(c, &zero, sizeof(zero));  // reason code",
          "3539:     mg_send_mqtt_properties(c, opts->props, opts->num_props);",
          "3540:   }",
          "3541: }",
          "3543: struct mg_connection *mg_mqtt_connect(struct mg_mgr *mgr, const char *url,",
          "3544:                                       const struct mg_mqtt_opts *opts,",
          "3545:                                       mg_event_handler_t fn, void *fn_data) {",
          "3546:   struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);",
          "3547:   if (c != NULL) {",
          "3548:     struct mg_mqtt_opts empty;",
          "3549:     memset(&empty, 0, sizeof(empty));",
          "3550:     mg_mqtt_login(c, opts == NULL ? &empty : opts);",
          "3551:     c->pfn = mqtt_cb;",
          "3553:   return c;",
          "3554: }",
          "3556: struct mg_connection *mg_mqtt_listen(struct mg_mgr *mgr, const char *url,",
          "3557:                                      mg_event_handler_t fn, void *fn_data) {",
          "3558:   struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);",
          "3559:   if (c != NULL) c->pfn = mqtt_cb, c->pfn_data = mgr;",
          "3560:   return c;",
          "3563: #ifdef MG_ENABLE_LINES",
          "3564: #line 1 \"src/net.c\"",
          "3565: #endif",
          "3574: size_t mg_vprintf(struct mg_connection *c, const char *fmt, va_list *ap) {",
          "3575:   size_t old = c->send.len;",
          "3576:   mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);",
          "3577:   return c->send.len - old;",
          "3580: size_t mg_printf(struct mg_connection *c, const char *fmt, ...) {",
          "3581:   size_t len = 0;",
          "3582:   va_list ap;",
          "3583:   va_start(ap, fmt);",
          "3584:   len = mg_vprintf(c, fmt, &ap);",
          "3585:   va_end(ap);",
          "3586:   return len;",
          "3589: static bool mg_atonl(struct mg_str str, struct mg_addr *addr) {",
          "3590:   uint32_t localhost = mg_htonl(0x7f000001);",
          "3591:   if (mg_vcasecmp(&str, \"localhost\") != 0) return false;",
          "3592:   memcpy(addr->ip, &localhost, sizeof(uint32_t));",
          "3593:   addr->is_ip6 = false;",
          "3594:   return true;",
          "3597: static bool mg_atone(struct mg_str str, struct mg_addr *addr) {",
          "3598:   if (str.len > 0) return false;",
          "3599:   memset(addr->ip, 0, sizeof(addr->ip));",
          "3600:   addr->is_ip6 = false;",
          "3601:   return true;",
          "3602: }",
          "3604: static bool mg_aton4(struct mg_str str, struct mg_addr *addr) {",
          "3605:   uint8_t data[4] = {0, 0, 0, 0};",
          "3606:   size_t i, num_dots = 0;",
          "3607:   for (i = 0; i < str.len; i++) {",
          "3608:     if (str.ptr[i] >= '0' && str.ptr[i] <= '9') {",
          "3609:       int octet = data[num_dots] * 10 + (str.ptr[i] - '0');",
          "3610:       if (octet > 255) return false;",
          "3611:       data[num_dots] = (uint8_t) octet;",
          "3612:     } else if (str.ptr[i] == '.') {",
          "3613:       if (num_dots >= 3 || i == 0 || str.ptr[i - 1] == '.') return false;",
          "3614:       num_dots++;",
          "3616:       return false;",
          "3619:   if (num_dots != 3 || str.ptr[i - 1] == '.') return false;",
          "3620:   memcpy(&addr->ip, data, sizeof(data));",
          "3621:   addr->is_ip6 = false;",
          "3622:   return true;",
          "3625: static bool mg_v4mapped(struct mg_str str, struct mg_addr *addr) {",
          "3626:   int i;",
          "3627:   uint32_t ipv4;",
          "3628:   if (str.len < 14) return false;",
          "3629:   if (str.ptr[0] != ':' || str.ptr[1] != ':' || str.ptr[6] != ':') return false;",
          "3630:   for (i = 2; i < 6; i++) {",
          "3631:     if (str.ptr[i] != 'f' && str.ptr[i] != 'F') return false;",
          "3634:   if (!mg_aton4(mg_str_n(&str.ptr[7], str.len - 7), addr)) return false;",
          "3635:   memcpy(&ipv4, addr->ip, sizeof(ipv4));",
          "3636:   memset(addr->ip, 0, sizeof(addr->ip));",
          "3637:   addr->ip[10] = addr->ip[11] = 255;",
          "3638:   memcpy(&addr->ip[12], &ipv4, 4);",
          "3639:   addr->is_ip6 = true;",
          "3640:   return true;",
          "3643: static bool mg_aton6(struct mg_str str, struct mg_addr *addr) {",
          "3644:   size_t i, j = 0, n = 0, dc = 42;",
          "3645:   if (str.len > 2 && str.ptr[0] == '[') str.ptr++, str.len -= 2;",
          "3646:   if (mg_v4mapped(str, addr)) return true;",
          "3647:   for (i = 0; i < str.len; i++) {",
          "3648:     if ((str.ptr[i] >= '0' && str.ptr[i] <= '9') ||",
          "3649:         (str.ptr[i] >= 'a' && str.ptr[i] <= 'f') ||",
          "3650:         (str.ptr[i] >= 'A' && str.ptr[i] <= 'F')) {",
          "3651:       unsigned long val;",
          "3652:       if (i > j + 3) return false;",
          "3654:       val = mg_unhexn(&str.ptr[j], i - j + 1);",
          "3655:       addr->ip[n] = (uint8_t) ((val >> 8) & 255);",
          "3656:       addr->ip[n + 1] = (uint8_t) (val & 255);",
          "3657:     } else if (str.ptr[i] == ':') {",
          "3658:       j = i + 1;",
          "3659:       if (i > 0 && str.ptr[i - 1] == ':') {",
          "3660:         dc = n;  // Double colon",
          "3661:         if (i > 1 && str.ptr[i - 2] == ':') return false;",
          "3662:       } else if (i > 0) {",
          "3663:         n += 2;",
          "3664:       }",
          "3665:       if (n > 14) return false;",
          "3666:       addr->ip[n] = addr->ip[n + 1] = 0;  // For trailing ::",
          "3667:     } else {",
          "3668:       return false;",
          "3669:     }",
          "3671:   if (n < 14 && dc == 42) return false;",
          "3672:   if (n < 14) {",
          "3673:     memmove(&addr->ip[dc + (14 - n)], &addr->ip[dc], n - dc + 2);",
          "3674:     memset(&addr->ip[dc], 0, 14 - n);",
          "3677:   addr->is_ip6 = true;",
          "3678:   return true;",
          "3681: bool mg_aton(struct mg_str str, struct mg_addr *addr) {",
          "3683:   return mg_atone(str, addr) || mg_atonl(str, addr) || mg_aton4(str, addr) ||",
          "3684:          mg_aton6(str, addr);",
          "3687: struct mg_connection *mg_alloc_conn(struct mg_mgr *mgr) {",
          "3688:   struct mg_connection *c =",
          "3689:       (struct mg_connection *) calloc(1, sizeof(*c) + mgr->extraconnsize);",
          "3690:   if (c != NULL) {",
          "3691:     c->mgr = mgr;",
          "3692:     c->send.align = c->recv.align = MG_IO_SIZE;",
          "3693:     c->id = ++mgr->nextid;",
          "3694:   }",
          "3695:   return c;",
          "3698: void mg_close_conn(struct mg_connection *c) {",
          "3699:   mg_resolve_cancel(c);  // Close any pending DNS query",
          "3700:   LIST_DELETE(struct mg_connection, &c->mgr->conns, c);",
          "3701:   if (c == c->mgr->dns4.c) c->mgr->dns4.c = NULL;",
          "3702:   if (c == c->mgr->dns6.c) c->mgr->dns6.c = NULL;",
          "3705:   mg_call(c, MG_EV_CLOSE, NULL);",
          "3706:   MG_DEBUG((\"%lu %ld closed\", c->id, c->fd));",
          "3708:   mg_tls_free(c);",
          "3709:   mg_iobuf_free(&c->recv);",
          "3710:   mg_iobuf_free(&c->send);",
          "3711:   mg_bzero((unsigned char *) c, sizeof(*c));",
          "3712:   free(c);",
          "3715: struct mg_connection *mg_connect(struct mg_mgr *mgr, const char *url,",
          "3716:                                  mg_event_handler_t fn, void *fn_data) {",
          "3717:   struct mg_connection *c = NULL;",
          "3718:   if (url == NULL || url[0] == '\\0') {",
          "3719:     MG_ERROR((\"null url\"));",
          "3720:   } else if ((c = mg_alloc_conn(mgr)) == NULL) {",
          "3721:     MG_ERROR((\"OOM\"));",
          "3723:     LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);",
          "3724:     c->is_udp = (strncmp(url, \"udp:\", 4) == 0);",
          "3725:     c->fd = (void *) (size_t) MG_INVALID_SOCKET;",
          "3726:     c->fn = fn;",
          "3727:     c->is_client = true;",
          "3728:     c->fn_data = fn_data;",
          "3729:     MG_DEBUG((\"%lu %ld %s\", c->id, c->fd, url));",
          "3730:     mg_call(c, MG_EV_OPEN, (void *) url);",
          "3731:     mg_resolve(c, url);",
          "3733:   return c;",
          "3736: struct mg_connection *mg_listen(struct mg_mgr *mgr, const char *url,",
          "3737:                                 mg_event_handler_t fn, void *fn_data) {",
          "3738:   struct mg_connection *c = NULL;",
          "3739:   if ((c = mg_alloc_conn(mgr)) == NULL) {",
          "3740:     MG_ERROR((\"OOM %s\", url));",
          "3741:   } else if (!mg_open_listener(c, url)) {",
          "3742:     MG_ERROR((\"Failed: %s, errno %d\", url, errno));",
          "3743:     free(c);",
          "3744:     c = NULL;",
          "3745:   } else {",
          "3746:     c->is_listening = 1;",
          "3747:     c->is_udp = strncmp(url, \"udp:\", 4) == 0;",
          "3748:     LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);",
          "3749:     c->fn = fn;",
          "3750:     c->fn_data = fn_data;",
          "3751:     mg_call(c, MG_EV_OPEN, NULL);",
          "3752:     if (mg_url_is_ssl(url)) c->is_tls = 1;  // Accepted connection must",
          "3753:     MG_DEBUG((\"%lu %ld %s\", c->id, c->fd, url));",
          "3754:   }",
          "3755:   return c;",
          "3758: struct mg_connection *mg_wrapfd(struct mg_mgr *mgr, int fd,",
          "3759:                                 mg_event_handler_t fn, void *fn_data) {",
          "3760:   struct mg_connection *c = mg_alloc_conn(mgr);",
          "3761:   if (c != NULL) {",
          "3762:     c->fd = (void *) (size_t) fd;",
          "3763:     c->fn = fn;",
          "3764:     c->fn_data = fn_data;",
          "3765:     MG_EPOLL_ADD(c);",
          "3766:     mg_call(c, MG_EV_OPEN, NULL);",
          "3767:     LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);",
          "3768:   }",
          "3769:   return c;",
          "3772: struct mg_timer *mg_timer_add(struct mg_mgr *mgr, uint64_t milliseconds,",
          "3773:                               unsigned flags, void (*fn)(void *), void *arg) {",
          "3774:   struct mg_timer *t = (struct mg_timer *) calloc(1, sizeof(*t));",
          "3775:   if (t != NULL) {",
          "3776:     mg_timer_init(&mgr->timers, t, milliseconds, flags, fn, arg);",
          "3777:     t->id = mgr->timerid++;",
          "3779:   return t;",
          "3782: void mg_mgr_free(struct mg_mgr *mgr) {",
          "3783:   struct mg_connection *c;",
          "3784:   struct mg_timer *tmp, *t = mgr->timers;",
          "3785:   while (t != NULL) tmp = t->next, free(t), t = tmp;",
          "3786:   mgr->timers = NULL;  // Important. Next call to poll won't touch timers",
          "3787:   for (c = mgr->conns; c != NULL; c = c->next) c->is_closing = 1;",
          "3788:   mg_mgr_poll(mgr, 0);",
          "3789: #if MG_ENABLE_FREERTOS_TCP",
          "3790:   FreeRTOS_DeleteSocketSet(mgr->ss);",
          "3791: #endif",
          "3792:   MG_DEBUG((\"All connections closed\"));",
          "3793: #if MG_ENABLE_EPOLL",
          "3794:   if (mgr->epoll_fd >= 0) close(mgr->epoll_fd), mgr->epoll_fd = -1;",
          "3796:   mg_tls_ctx_free(mgr);",
          "3797: }",
          "3799: void mg_mgr_init(struct mg_mgr *mgr) {",
          "3800:   memset(mgr, 0, sizeof(*mgr));",
          "3801: #if MG_ENABLE_EPOLL",
          "3802:   if ((mgr->epoll_fd = epoll_create1(EPOLL_CLOEXEC)) < 0)",
          "3803:     MG_ERROR((\"epoll_create1 errno %d\", errno));",
          "3804: #else",
          "3805:   mgr->epoll_fd = -1;",
          "3806: #endif",
          "3807: #if MG_ARCH == MG_ARCH_WIN32 && MG_ENABLE_WINSOCK",
          "3809:   { WSADATA data; WSAStartup(MAKEWORD(2, 2), &data); }",
          "3811: #elif MG_ENABLE_FREERTOS_TCP",
          "3812:   mgr->ss = FreeRTOS_CreateSocketSet();",
          "3813: #elif defined(__unix) || defined(__unix__) || defined(__APPLE__)",
          "3816:   signal(SIGPIPE, SIG_IGN);",
          "3817: #endif",
          "3818:   mgr->dnstimeout = 3000;",
          "3819:   mgr->dns4.url = \"udp://8.8.8.8:53\";",
          "3820:   mgr->dns6.url = \"udp://[2001:4860:4860::8888]:53\";",
          "3821:   mg_tls_ctx_init(mgr);",
          "3822: }",
          "3824: #ifdef MG_ENABLE_LINES",
          "3825: #line 1 \"src/net_builtin.c\"",
          "3826: #endif",
          "3829: #if defined(MG_ENABLE_TCPIP) && MG_ENABLE_TCPIP",
          "3830: #define MG_EPHEMERAL_PORT_BASE 32768",
          "3831: #define PDIFF(a, b) ((size_t) (((char *) (b)) - ((char *) (a))))",
          "3833: #ifndef MIP_TCP_KEEPALIVE_MS",
          "3834: #define MIP_TCP_KEEPALIVE_MS 45000  // TCP keep-alive period, ms",
          "3835: #endif",
          "3837: #define MIP_TCP_ACK_MS 150    // Timeout for ACKing",
          "3838: #define MIP_TCP_ARP_MS 100    // Timeout for ARP response",
          "3839: #define MIP_TCP_SYN_MS 15000  // Timeout for connection establishment",
          "3840: #define MIP_TCP_FIN_MS 1000   // Timeout for closing connection",
          "3842: struct connstate {",
          "3843:   uint32_t seq, ack;           // TCP seq/ack counters",
          "3844:   uint64_t timer;              // TCP keep-alive / ACK timer",
          "3845:   uint8_t mac[6];              // Peer MAC address",
          "3846:   uint8_t ttype;               // Timer type. 0: ack, 1: keep-alive",
          "3847: #define MIP_TTYPE_KEEPALIVE 0  // Connection is idle for long, send keepalive",
          "3848: #define MIP_TTYPE_ACK 1        // Peer sent us data, we have to ack it soon",
          "3849: #define MIP_TTYPE_ARP 2        // ARP resolve sent, waiting for response",
          "3850: #define MIP_TTYPE_SYN 3        // SYN sent, waiting for response",
          "3851: #define MIP_TTYPE_FIN 4  // FIN sent, waiting until terminating the connection",
          "3852:   uint8_t tmiss;         // Number of keep-alive misses",
          "3853:   struct mg_iobuf raw;   // For TLS only. Incoming raw data",
          "3854: };",
          "3856: #pragma pack(push, 1)",
          "3858: struct lcp {",
          "3859:   uint8_t addr, ctrl, proto[2], code, id, len[2];",
          "3860: };",
          "3862: struct eth {",
          "3863:   uint8_t dst[6];  // Destination MAC address",
          "3864:   uint8_t src[6];  // Source MAC address",
          "3865:   uint16_t type;   // Ethernet type",
          "3866: };",
          "3868: struct ip {",
          "3869:   uint8_t ver;    // Version",
          "3870:   uint8_t tos;    // Unused",
          "3871:   uint16_t len;   // Length",
          "3872:   uint16_t id;    // Unused",
          "3873:   uint16_t frag;  // Fragmentation",
          "3874: #define IP_FRAG_OFFSET_MSK 0xFF1F",
          "3875: #define IP_MORE_FRAGS_MSK 0x20",
          "3876:   uint8_t ttl;    // Time to live",
          "3877:   uint8_t proto;  // Upper level protocol",
          "3878:   uint16_t csum;  // Checksum",
          "3879:   uint32_t src;   // Source IP",
          "3880:   uint32_t dst;   // Destination IP",
          "3881: };",
          "3883: struct ip6 {",
          "3884:   uint8_t ver;      // Version",
          "3885:   uint8_t opts[3];  // Options",
          "3886:   uint16_t len;     // Length",
          "3887:   uint8_t proto;    // Upper level protocol",
          "3888:   uint8_t ttl;      // Time to live",
          "3889:   uint8_t src[16];  // Source IP",
          "3890:   uint8_t dst[16];  // Destination IP",
          "3891: };",
          "3893: struct icmp {",
          "3894:   uint8_t type;",
          "3895:   uint8_t code;",
          "3896:   uint16_t csum;",
          "3897: };",
          "3899: struct arp {",
          "3900:   uint16_t fmt;    // Format of hardware address",
          "3901:   uint16_t pro;    // Format of protocol address",
          "3902:   uint8_t hlen;    // Length of hardware address",
          "3903:   uint8_t plen;    // Length of protocol address",
          "3904:   uint16_t op;     // Operation",
          "3905:   uint8_t sha[6];  // Sender hardware address",
          "3906:   uint32_t spa;    // Sender protocol address",
          "3907:   uint8_t tha[6];  // Target hardware address",
          "3908:   uint32_t tpa;    // Target protocol address",
          "3909: };",
          "3911: struct tcp {",
          "3912:   uint16_t sport;  // Source port",
          "3913:   uint16_t dport;  // Destination port",
          "3914:   uint32_t seq;    // Sequence number",
          "3915:   uint32_t ack;    // Acknowledgement number",
          "3916:   uint8_t off;     // Data offset",
          "3917:   uint8_t flags;   // TCP flags",
          "3918: #define TH_FIN 0x01",
          "3919: #define TH_SYN 0x02",
          "3920: #define TH_RST 0x04",
          "3921: #define TH_PUSH 0x08",
          "3922: #define TH_ACK 0x10",
          "3923: #define TH_URG 0x20",
          "3924: #define TH_ECE 0x40",
          "3925: #define TH_CWR 0x80",
          "3926:   uint16_t win;   // Window",
          "3927:   uint16_t csum;  // Checksum",
          "3928:   uint16_t urp;   // Urgent pointer",
          "3929: };",
          "3931: struct udp {",
          "3932:   uint16_t sport;  // Source port",
          "3933:   uint16_t dport;  // Destination port",
          "3934:   uint16_t len;    // UDP length",
          "3935:   uint16_t csum;   // UDP checksum",
          "3936: };",
          "3938: struct dhcp {",
          "3939:   uint8_t op, htype, hlen, hops;",
          "3940:   uint32_t xid;",
          "3941:   uint16_t secs, flags;",
          "3942:   uint32_t ciaddr, yiaddr, siaddr, giaddr;",
          "3943:   uint8_t hwaddr[208];",
          "3944:   uint32_t magic;",
          "3945:   uint8_t options[32];",
          "3946: };",
          "3948: #pragma pack(pop)",
          "3950: struct pkt {",
          "3951:   struct mg_str raw;  // Raw packet data",
          "3952:   struct mg_str pay;  // Payload data",
          "3953:   struct eth *eth;",
          "3954:   struct llc *llc;",
          "3955:   struct arp *arp;",
          "3956:   struct ip *ip;",
          "3957:   struct ip6 *ip6;",
          "3958:   struct icmp *icmp;",
          "3959:   struct tcp *tcp;",
          "3960:   struct udp *udp;",
          "3961:   struct dhcp *dhcp;",
          "3962: };",
          "3964: static void send_syn(struct mg_connection *c);",
          "3966: static void mkpay(struct pkt *pkt, void *p) {",
          "3967:   pkt->pay =",
          "3968:       mg_str_n((char *) p, (size_t) (&pkt->raw.ptr[pkt->raw.len] - (char *) p));",
          "3969: }",
          "3971: static uint32_t csumup(uint32_t sum, const void *buf, size_t len) {",
          "3972:   const uint8_t *p = (const uint8_t *) buf;",
          "3973:   for (size_t i = 0; i < len; i++) sum += i & 1 ? p[i] : (uint32_t) (p[i] << 8);",
          "3974:   return sum;",
          "3977: static uint16_t csumfin(uint32_t sum) {",
          "3978:   while (sum >> 16) sum = (sum & 0xffff) + (sum >> 16);",
          "3979:   return mg_htons(~sum & 0xffff);",
          "3980: }",
          "3982: static uint16_t ipcsum(const void *buf, size_t len) {",
          "3983:   uint32_t sum = csumup(0, buf, len);",
          "3984:   return csumfin(sum);",
          "3985: }",
          "3987: static void settmout(struct mg_connection *c, uint8_t type) {",
          "3988:   struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;",
          "3989:   struct connstate *s = (struct connstate *) (c + 1);",
          "3990:   unsigned n = type == MIP_TTYPE_ACK   ? MIP_TCP_ACK_MS",
          "3991:                : type == MIP_TTYPE_ARP ? MIP_TCP_ARP_MS",
          "3992:                : type == MIP_TTYPE_SYN ? MIP_TCP_SYN_MS",
          "3993:                : type == MIP_TTYPE_FIN ? MIP_TCP_FIN_MS",
          "3994:                                        : MIP_TCP_KEEPALIVE_MS;",
          "3995:   s->timer = ifp->now + n;",
          "3996:   s->ttype = type;",
          "3997:   MG_VERBOSE((\"%lu %d -> %llx\", c->id, type, s->timer));",
          "3998: }",
          "4000: static size_t ether_output(struct mg_tcpip_if *ifp, size_t len) {",
          "4004:   size_t n = ifp->driver->tx(ifp->tx.ptr, len, ifp);",
          "4005:   if (n == len) ifp->nsent++;",
          "4006:   return n;",
          "4007: }",
          "4009: static void arp_ask(struct mg_tcpip_if *ifp, uint32_t ip) {",
          "4010:   struct eth *eth = (struct eth *) ifp->tx.ptr;",
          "4011:   struct arp *arp = (struct arp *) (eth + 1);",
          "4012:   memset(eth->dst, 255, sizeof(eth->dst));",
          "4013:   memcpy(eth->src, ifp->mac, sizeof(eth->src));",
          "4014:   eth->type = mg_htons(0x806);",
          "4015:   memset(arp, 0, sizeof(*arp));",
          "4016:   arp->fmt = mg_htons(1), arp->pro = mg_htons(0x800), arp->hlen = 6,",
          "4017:   arp->plen = 4;",
          "4018:   arp->op = mg_htons(1), arp->tpa = ip, arp->spa = ifp->ip;",
          "4019:   memcpy(arp->sha, ifp->mac, sizeof(arp->sha));",
          "4020:   ether_output(ifp, PDIFF(eth, arp + 1));",
          "4023: static void onstatechange(struct mg_tcpip_if *ifp) {",
          "4024:   if (ifp->state == MG_TCPIP_STATE_READY) {",
          "4025:     MG_INFO((\"READY, IP: %M\", mg_print_ip4, &ifp->ip));",
          "4026:     MG_INFO((\"       GW: %M\", mg_print_ip4, &ifp->gw));",
          "4027:     MG_INFO((\"      MAC: %M\", mg_print_mac, &ifp->mac));",
          "4028:     arp_ask(ifp, ifp->gw);",
          "4029:   } else if (ifp->state == MG_TCPIP_STATE_UP) {",
          "4030:     MG_ERROR((\"Link up\"));",
          "4031:     srand((unsigned int) mg_millis());",
          "4032:   } else if (ifp->state == MG_TCPIP_STATE_DOWN) {",
          "4033:     MG_ERROR((\"Link down\"));",
          "4034:   }",
          "4035: }",
          "4037: static struct ip *tx_ip(struct mg_tcpip_if *ifp, uint8_t *mac_dst,",
          "4038:                         uint8_t proto, uint32_t ip_src, uint32_t ip_dst,",
          "4039:                         size_t plen) {",
          "4040:   struct eth *eth = (struct eth *) ifp->tx.ptr;",
          "4041:   struct ip *ip = (struct ip *) (eth + 1);",
          "4042:   memcpy(eth->dst, mac_dst, sizeof(eth->dst));",
          "4043:   memcpy(eth->src, ifp->mac, sizeof(eth->src));  // Use our MAC",
          "4044:   eth->type = mg_htons(0x800);",
          "4045:   memset(ip, 0, sizeof(*ip));",
          "4046:   ip->ver = 0x45;   // Version 4, header length 5 words",
          "4047:   ip->frag = 0x40;  // Don't fragment",
          "4048:   ip->len = mg_htons((uint16_t) (sizeof(*ip) + plen));",
          "4049:   ip->ttl = 64;",
          "4050:   ip->proto = proto;",
          "4051:   ip->src = ip_src;",
          "4052:   ip->dst = ip_dst;",
          "4053:   ip->csum = ipcsum(ip, sizeof(*ip));",
          "4054:   return ip;",
          "4055: }",
          "4057: static void tx_udp(struct mg_tcpip_if *ifp, uint8_t *mac_dst, uint32_t ip_src,",
          "4058:                    uint16_t sport, uint32_t ip_dst, uint16_t dport,",
          "4059:                    const void *buf, size_t len) {",
          "4060:   struct ip *ip =",
          "4061:       tx_ip(ifp, mac_dst, 17, ip_src, ip_dst, len + sizeof(struct udp));",
          "4062:   struct udp *udp = (struct udp *) (ip + 1);",
          "4064:   udp->sport = sport;",
          "4065:   udp->dport = dport;",
          "4066:   udp->len = mg_htons((uint16_t) (sizeof(*udp) + len));",
          "4067:   udp->csum = 0;",
          "4068:   uint32_t cs = csumup(0, udp, sizeof(*udp));",
          "4069:   cs = csumup(cs, buf, len);",
          "4070:   cs = csumup(cs, &ip->src, sizeof(ip->src));",
          "4071:   cs = csumup(cs, &ip->dst, sizeof(ip->dst));",
          "4072:   cs += (uint32_t) (ip->proto + sizeof(*udp) + len);",
          "4073:   udp->csum = csumfin(cs);",
          "4074:   memmove(udp + 1, buf, len);",
          "4076:   ether_output(ifp, sizeof(struct eth) + sizeof(*ip) + sizeof(*udp) + len);",
          "4077: }",
          "4079: static void tx_dhcp(struct mg_tcpip_if *ifp, uint8_t *mac_dst, uint32_t ip_src,",
          "4080:                     uint32_t ip_dst, uint8_t *opts, size_t optslen,",
          "4081:                     bool ciaddr) {",
          "4083:   struct dhcp dhcp = {1, 1, 6, 0, 0, 0, 0, 0, 0, 0, 0, {0}, 0, {0}};",
          "4084:   dhcp.magic = mg_htonl(0x63825363);",
          "4085:   memcpy(&dhcp.hwaddr, ifp->mac, sizeof(ifp->mac));",
          "4086:   memcpy(&dhcp.xid, ifp->mac + 2, sizeof(dhcp.xid));",
          "4087:   memcpy(&dhcp.options, opts, optslen);",
          "4088:   if (ciaddr) dhcp.ciaddr = ip_src;",
          "4089:   tx_udp(ifp, mac_dst, ip_src, mg_htons(68), ip_dst, mg_htons(67), &dhcp,",
          "4090:          sizeof(dhcp));",
          "4091: }",
          "4093: static const uint8_t broadcast[] = {255, 255, 255, 255, 255, 255};",
          "4096: static void tx_dhcp_request_sel(struct mg_tcpip_if *ifp, uint32_t ip_req,",
          "4097:                                 uint32_t ip_srv) {",
          "4098:   uint8_t opts[] = {",
          "4099:       53, 1, 3,                 // Type: DHCP request",
          "4100:       55, 2, 1,   3,            // GW and mask",
          "4101:       12, 3, 'm', 'i', 'p',     // Host name: \"mip\"",
          "4102:       54, 4, 0,   0,   0,   0,  // DHCP server ID",
          "4103:       50, 4, 0,   0,   0,   0,  // Requested IP",
          "4104:       255                       // End of options",
          "4105:   };",
          "4106:   memcpy(opts + 14, &ip_srv, sizeof(ip_srv));",
          "4107:   memcpy(opts + 20, &ip_req, sizeof(ip_req));",
          "4108:   tx_dhcp(ifp, (uint8_t *) broadcast, 0, 0xffffffff, opts, sizeof(opts), false);",
          "4109:   MG_DEBUG((\"DHCP req sent\"));",
          "4113: static void tx_dhcp_request_re(struct mg_tcpip_if *ifp, uint8_t *mac_dst,",
          "4114:                                uint32_t ip_src, uint32_t ip_dst) {",
          "4115:   uint8_t opts[] = {",
          "4116:       53, 1, 3,  // Type: DHCP request",
          "4117:       255        // End of options",
          "4118:   };",
          "4119:   tx_dhcp(ifp, mac_dst, ip_src, ip_dst, opts, sizeof(opts), true);",
          "4120:   MG_DEBUG((\"DHCP req sent\"));",
          "4123: static void tx_dhcp_discover(struct mg_tcpip_if *ifp) {",
          "4124:   uint8_t opts[] = {",
          "4125:       53, 1, 1,     // Type: DHCP discover",
          "4126:       55, 2, 1, 3,  // Parameters: ip, mask",
          "4127:       255           // End of options",
          "4128:   };",
          "4129:   tx_dhcp(ifp, (uint8_t *) broadcast, 0, 0xffffffff, opts, sizeof(opts), false);",
          "4130:   MG_DEBUG((\"DHCP discover sent. Our MAC: %M\", mg_print_mac, ifp->mac));",
          "4133: static struct mg_connection *getpeer(struct mg_mgr *mgr, struct pkt *pkt,",
          "4134:                                      bool lsn) {",
          "4135:   struct mg_connection *c = NULL;",
          "4136:   for (c = mgr->conns; c != NULL; c = c->next) {",
          "4137:     if (c->is_arplooking && pkt->arp &&",
          "4138:         memcmp(&pkt->arp->spa, c->rem.ip, sizeof(pkt->arp->spa)) == 0)",
          "4139:       break;",
          "4140:     if (c->is_udp && pkt->udp && c->loc.port == pkt->udp->dport) break;",
          "4141:     if (!c->is_udp && pkt->tcp && c->loc.port == pkt->tcp->dport &&",
          "4142:         lsn == c->is_listening && (lsn || c->rem.port == pkt->tcp->sport))",
          "4143:       break;",
          "4144:   }",
          "4145:   return c;",
          "4148: static void rx_arp(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "4149:   if (pkt->arp->op == mg_htons(1) && pkt->arp->tpa == ifp->ip) {",
          "4153:     struct eth *eth = (struct eth *) ifp->tx.ptr;",
          "4154:     struct arp *arp = (struct arp *) (eth + 1);",
          "4155:     memcpy(eth->dst, pkt->eth->src, sizeof(eth->dst));",
          "4156:     memcpy(eth->src, ifp->mac, sizeof(eth->src));",
          "4157:     eth->type = mg_htons(0x806);",
          "4159:     arp->op = mg_htons(2);",
          "4160:     memcpy(arp->tha, pkt->arp->sha, sizeof(pkt->arp->tha));",
          "4161:     memcpy(arp->sha, ifp->mac, sizeof(pkt->arp->sha));",
          "4162:     arp->tpa = pkt->arp->spa;",
          "4163:     arp->spa = ifp->ip;",
          "4164:     MG_DEBUG((\"ARP: tell %M we're %M\", mg_print_ip4, &arp->tpa, mg_print_mac,",
          "4165:               &ifp->mac));",
          "4166:     ether_output(ifp, PDIFF(eth, arp + 1));",
          "4167:   } else if (pkt->arp->op == mg_htons(2)) {",
          "4168:     if (memcmp(pkt->arp->tha, ifp->mac, sizeof(pkt->arp->tha)) != 0) return;",
          "4169:     if (pkt->arp->spa == ifp->gw) {",
          "4171:       memcpy(ifp->gwmac, pkt->arp->sha, sizeof(ifp->gwmac));",
          "4172:     } else {",
          "4173:       struct mg_connection *c = getpeer(ifp->mgr, pkt, false);",
          "4174:       if (c != NULL && c->is_arplooking) {",
          "4175:         struct connstate *s = (struct connstate *) (c + 1);",
          "4176:         memcpy(s->mac, pkt->arp->sha, sizeof(s->mac));",
          "4177:         MG_DEBUG((\"%lu ARP resolved %M -> %M\", c->id, mg_print_ip4, c->rem.ip,",
          "4178:                   mg_print_mac, s->mac));",
          "4179:         c->is_arplooking = 0;",
          "4180:         send_syn(c);",
          "4181:         settmout(c, MIP_TTYPE_SYN);",
          "4182:       }",
          "4183:     }",
          "4184:   }",
          "4185: }",
          "4187: static void rx_icmp(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "4189:   if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip) {",
          "4190:     size_t hlen = sizeof(struct eth) + sizeof(struct ip) + sizeof(struct icmp);",
          "4191:     size_t space = ifp->tx.len - hlen, plen = pkt->pay.len;",
          "4192:     if (plen > space) plen = space;",
          "4193:     struct ip *ip = tx_ip(ifp, pkt->eth->src, 1, ifp->ip, pkt->ip->src,",
          "4194:                           sizeof(struct icmp) + plen);",
          "4195:     struct icmp *icmp = (struct icmp *) (ip + 1);",
          "4196:     memset(icmp, 0, sizeof(*icmp));        // Set csum to 0",
          "4197:     memcpy(icmp + 1, pkt->pay.ptr, plen);  // Copy RX payload to TX",
          "4198:     icmp->csum = ipcsum(icmp, sizeof(*icmp) + plen);",
          "4199:     ether_output(ifp, hlen + plen);",
          "4200:   }",
          "4203: static void rx_dhcp_client(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "4204:   uint32_t ip = 0, gw = 0, mask = 0, lease = 0;",
          "4205:   uint8_t msgtype = 0, state = ifp->state;",
          "4207:   uint8_t *p = pkt->dhcp->options,",
          "4209:   if (end < (uint8_t *) (pkt->dhcp + 1)) return;",
          "4210:   if (memcmp(&pkt->dhcp->xid, ifp->mac + 2, sizeof(pkt->dhcp->xid))) return;",
          "4211:   while (p + 1 < end && p[0] != 255) {  // Parse options RFC-1533 #9",
          "4212:     if (p[0] == 1 && p[1] == sizeof(ifp->mask) && p + 6 < end) {  // Mask",
          "4213:       memcpy(&mask, p + 2, sizeof(mask));",
          "4214:     } else if (p[0] == 3 && p[1] == sizeof(ifp->gw) && p + 6 < end) {  // GW",
          "4215:       memcpy(&gw, p + 2, sizeof(gw));",
          "4216:       ip = pkt->dhcp->yiaddr;",
          "4217:     } else if (p[0] == 51 && p[1] == 4 && p + 6 < end) {  // Lease",
          "4218:       memcpy(&lease, p + 2, sizeof(lease));",
          "4219:       lease = mg_ntohl(lease);",
          "4220:     } else if (p[0] == 53 && p[1] == 1 && p + 6 < end) {  // Msg Type",
          "4221:       msgtype = p[2];",
          "4222:     }",
          "4223:     p += p[1] + 2;",
          "4224:   }",
          "4226:   if (msgtype == 6 && ifp->ip == ip) {  // DHCPNACK, release IP",
          "4227:     ifp->state = MG_TCPIP_STATE_UP, ifp->ip = 0;",
          "4228:   } else if (msgtype == 2 && ifp->state == MG_TCPIP_STATE_UP && ip && gw &&",
          "4229:              lease) {                                 // DHCPOFFER",
          "4230:     tx_dhcp_request_sel(ifp, ip, pkt->dhcp->siaddr);  // select IP, (4.4.1)",
          "4231:     ifp->state = MG_TCPIP_STATE_REQ;                  // REQUESTING state",
          "4232:   } else if (msgtype == 5) {                          // DHCPACK",
          "4233:     if (ifp->state == MG_TCPIP_STATE_REQ && ip && gw && lease) {  // got an IP",
          "4234:       ifp->lease_expire = ifp->now + lease * 1000;",
          "4235:       MG_INFO((\"Lease: %u sec (%lld)\", lease, ifp->lease_expire / 1000));",
          "4237:       memcpy(ifp->gwmac, pkt->eth->src, sizeof(ifp->gwmac));",
          "4238:       ifp->ip = ip, ifp->gw = gw, ifp->mask = mask;",
          "4239:       ifp->state = MG_TCPIP_STATE_READY;  // BOUND state",
          "4240:       uint64_t rand;",
          "4241:       mg_random(&rand, sizeof(rand));",
          "4242:       srand((unsigned int) (rand + mg_millis()));",
          "4243:     } else if (ifp->state == MG_TCPIP_STATE_READY && ifp->ip == ip) {  // renew",
          "4244:       ifp->lease_expire = ifp->now + lease * 1000;",
          "4245:       MG_INFO((\"Lease: %u sec (%lld)\", lease, ifp->lease_expire / 1000));",
          "4246:     }  // TODO(): accept provided T1/T2 and store server IP for renewal (4.4)",
          "4248:   if (ifp->state != state) onstatechange(ifp);",
          "4252: static void rx_dhcp_server(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "4253:   uint8_t op = 0, *p = pkt->dhcp->options,",
          "4255:   if (end < (uint8_t *) (pkt->dhcp + 1)) return;",
          "4257:   struct dhcp res = {2, 1, 6, 0, 0, 0, 0, 0, 0, 0, 0, {0}, 0, {0}};",
          "4258:   res.yiaddr = ifp->ip;",
          "4259:   ((uint8_t *) (&res.yiaddr))[3]++;                // Offer our IP + 1",
          "4260:   while (p + 1 < end && p[0] != 255) {             // Parse options",
          "4261:     if (p[0] == 53 && p[1] == 1 && p + 2 < end) {  // Message type",
          "4262:       op = p[2];",
          "4263:     }",
          "4264:     p += p[1] + 2;",
          "4265:   }",
          "4266:   if (op == 1 || op == 3) {         // DHCP Discover or DHCP Request",
          "4267:     uint8_t msg = op == 1 ? 2 : 5;  // Message type: DHCP OFFER or DHCP ACK",
          "4268:     uint8_t opts[] = {",
          "4269:         53, 1, msg,                 // Message type",
          "4270:         1,  4, 0,   0,   0,   0,    // Subnet mask",
          "4271:         54, 4, 0,   0,   0,   0,    // Server ID",
          "4272:         12, 3, 'm', 'i', 'p',       // Host name: \"mip\"",
          "4273:         51, 4, 255, 255, 255, 255,  // Lease time",
          "4274:         255                         // End of options",
          "4275:     };",
          "4276:     memcpy(&res.hwaddr, pkt->dhcp->hwaddr, 6);",
          "4277:     memcpy(opts + 5, &ifp->mask, sizeof(ifp->mask));",
          "4278:     memcpy(opts + 11, &ifp->ip, sizeof(ifp->ip));",
          "4279:     memcpy(&res.options, opts, sizeof(opts));",
          "4280:     res.magic = pkt->dhcp->magic;",
          "4281:     res.xid = pkt->dhcp->xid;",
          "4283:     tx_udp(ifp, pkt->eth->src, ifp->ip, mg_htons(67),",
          "4284:            op == 1 ? ~0U : res.yiaddr, mg_htons(68), &res, sizeof(res));",
          "4288: static void rx_udp(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "4289:   struct mg_connection *c = getpeer(ifp->mgr, pkt, true);",
          "4290:   if (c == NULL) {",
          "4292:   } else {",
          "4293:     c->rem.port = pkt->udp->sport;",
          "4294:     memcpy(c->rem.ip, &pkt->ip->src, sizeof(uint32_t));",
          "4295:     struct connstate *s = (struct connstate *) (c + 1);",
          "4296:     memcpy(s->mac, pkt->eth->src, sizeof(s->mac));",
          "4297:     if (c->recv.len >= MG_MAX_RECV_SIZE) {",
          "4298:       mg_error(c, \"max_recv_buf_size reached\");",
          "4299:     } else if (c->recv.size - c->recv.len < pkt->pay.len &&",
          "4300:                !mg_iobuf_resize(&c->recv, c->recv.len + pkt->pay.len)) {",
          "4301:       mg_error(c, \"oom\");",
          "4302:     } else {",
          "4303:       memcpy(&c->recv.buf[c->recv.len], pkt->pay.ptr, pkt->pay.len);",
          "4304:       c->recv.len += pkt->pay.len;",
          "4305:       mg_call(c, MG_EV_READ, &pkt->pay.len);",
          "4308: }",
          "4310: static size_t tx_tcp(struct mg_tcpip_if *ifp, uint8_t *dst_mac, uint32_t dst_ip,",
          "4311:                      uint8_t flags, uint16_t sport, uint16_t dport,",
          "4312:                      uint32_t seq, uint32_t ack, const void *buf, size_t len) {",
          "4313:   struct ip *ip =",
          "4314:       tx_ip(ifp, dst_mac, 6, ifp->ip, dst_ip, sizeof(struct tcp) + len);",
          "4315:   struct tcp *tcp = (struct tcp *) (ip + 1);",
          "4316:   memset(tcp, 0, sizeof(*tcp));",
          "4317:   if (buf != NULL && len) memmove(tcp + 1, buf, len);",
          "4318:   tcp->sport = sport;",
          "4319:   tcp->dport = dport;",
          "4320:   tcp->seq = seq;",
          "4321:   tcp->ack = ack;",
          "4322:   tcp->flags = flags;",
          "4323:   tcp->win = mg_htons(8192);",
          "4324:   tcp->off = (uint8_t) (sizeof(*tcp) / 4 << 4);",
          "4325:   uint32_t cs = 0;",
          "4326:   uint16_t n = (uint16_t) (sizeof(*tcp) + len);",
          "4327:   uint8_t pseudo[] = {0, ip->proto, (uint8_t) (n >> 8), (uint8_t) (n & 255)};",
          "4328:   cs = csumup(cs, tcp, n);",
          "4329:   cs = csumup(cs, &ip->src, sizeof(ip->src));",
          "4330:   cs = csumup(cs, &ip->dst, sizeof(ip->dst));",
          "4331:   cs = csumup(cs, pseudo, sizeof(pseudo));",
          "4332:   tcp->csum = csumfin(cs);",
          "4333:   MG_VERBOSE((\"TCP %M:%hu -> %M:%hu fl %x len %u\", mg_print_ip4, &ip->src,",
          "4334:               mg_ntohs(tcp->sport), mg_print_ip4, &ip->dst,",
          "4335:               mg_ntohs(tcp->dport), tcp->flags, (int) len));",
          "4337:   return ether_output(ifp, PDIFF(ifp->tx.ptr, tcp + 1) + len);",
          "4340: static size_t tx_tcp_pkt(struct mg_tcpip_if *ifp, struct pkt *pkt,",
          "4341:                          uint8_t flags, uint32_t seq, const void *buf,",
          "4342:                          size_t len) {",
          "4343:   uint32_t delta = (pkt->tcp->flags & (TH_SYN | TH_FIN)) ? 1 : 0;",
          "4344:   return tx_tcp(ifp, pkt->eth->src, pkt->ip->src, flags, pkt->tcp->dport,",
          "4345:                 pkt->tcp->sport, seq, mg_htonl(mg_ntohl(pkt->tcp->seq) + delta),",
          "4346:                 buf, len);",
          "4349: static struct mg_connection *accept_conn(struct mg_connection *lsn,",
          "4350:                                          struct pkt *pkt) {",
          "4351:   struct mg_connection *c = mg_alloc_conn(lsn->mgr);",
          "4352:   if (c == NULL) {",
          "4353:     MG_ERROR((\"OOM\"));",
          "4354:     return NULL;",
          "4356:   struct connstate *s = (struct connstate *) (c + 1);",
          "4357:   s->seq = mg_ntohl(pkt->tcp->ack), s->ack = mg_ntohl(pkt->tcp->seq);",
          "4358:   memcpy(s->mac, pkt->eth->src, sizeof(s->mac));",
          "4359:   settmout(c, MIP_TTYPE_KEEPALIVE);",
          "4360:   memcpy(c->rem.ip, &pkt->ip->src, sizeof(uint32_t));",
          "4361:   c->rem.port = pkt->tcp->sport;",
          "4362:   MG_DEBUG((\"%lu accepted %M\", c->id, mg_print_ip_port, &c->rem));",
          "4363:   LIST_ADD_HEAD(struct mg_connection, &lsn->mgr->conns, c);",
          "4364:   c->is_accepted = 1;",
          "4365:   c->is_hexdumping = lsn->is_hexdumping;",
          "4366:   c->pfn = lsn->pfn;",
          "4367:   c->loc = lsn->loc;",
          "4368:   c->pfn_data = lsn->pfn_data;",
          "4369:   c->fn = lsn->fn;",
          "4370:   c->fn_data = lsn->fn_data;",
          "4371:   mg_call(c, MG_EV_OPEN, NULL);",
          "4372:   mg_call(c, MG_EV_ACCEPT, NULL);",
          "4373:   return c;",
          "4376: static size_t trim_len(struct mg_connection *c, size_t len) {",
          "4377:   struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;",
          "4378:   size_t eth_h_len = 14, ip_max_h_len = 24, tcp_max_h_len = 60, udp_h_len = 8;",
          "4379:   size_t max_headers_len = eth_h_len + ip_max_h_len +",
          "4380:                           (c->is_udp ? udp_h_len : tcp_max_h_len);",
          "4381:   size_t min_mtu = c->is_udp ? 68 /* RFC-791 */ : max_headers_len - eth_h_len;",
          "4384:   if (len + max_headers_len > ifp->tx.len) {",
          "4385:     len = ifp->tx.len - max_headers_len;",
          "4388:   if (ifp->mtu < min_mtu) {",
          "4389:     MG_ERROR((\"MTU is lower than minimum possible value. Setting it to %d.\",",
          "4390:               min_mtu));",
          "4391:     ifp->mtu = (uint16_t) min_mtu;",
          "4394:   if (len + max_headers_len - eth_h_len > ifp->mtu) {",
          "4395:     len = ifp->mtu - max_headers_len + eth_h_len;",
          "4396:     if (c->is_udp) {",
          "4397:       MG_ERROR((\"UDP datagram exceeds MTU. Truncating it.\"));",
          "4398:     }",
          "4401:   return len;",
          "4402: }",
          "4404: long mg_io_send(struct mg_connection *c, const void *buf, size_t len) {",
          "4405:   struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;",
          "4406:   struct connstate *s = (struct connstate *) (c + 1);",
          "4407:   uint32_t rem_ip;",
          "4408:   memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "4409:   len = trim_len(c, len);",
          "4410:   if (c->is_udp) {",
          "4411:     tx_udp(ifp, s->mac, ifp->ip, c->loc.port, rem_ip, c->rem.port, buf, len);",
          "4412:   } else {",
          "4413:     if (tx_tcp(ifp, s->mac, rem_ip, TH_PUSH | TH_ACK, c->loc.port, c->rem.port,",
          "4414:                mg_htonl(s->seq), mg_htonl(s->ack), buf, len) > 0) {",
          "4415:       s->seq += (uint32_t) len;",
          "4416:       if (s->ttype == MIP_TTYPE_ACK) settmout(c, MIP_TTYPE_KEEPALIVE);",
          "4417:     } else {",
          "4418:       return MG_IO_ERR;",
          "4419:     }",
          "4421:   return (long) len;",
          "4424: long mg_io_recv(struct mg_connection *c, void *buf, size_t len) {",
          "4425:   struct connstate *s = (struct connstate *) (c + 1);",
          "4426:   if (s->raw.len == 0) return MG_IO_WAIT;",
          "4427:   if (len > s->raw.len) len = s->raw.len;",
          "4428:   memcpy(buf, s->raw.buf, len);",
          "4429:   mg_iobuf_del(&s->raw, 0, len);",
          "4430:   return (long) len;",
          "4433: static void read_conn(struct mg_connection *c, struct pkt *pkt) {",
          "4434:   struct connstate *s = (struct connstate *) (c + 1);",
          "4435:   struct mg_iobuf *io = c->is_tls ? &s->raw : &c->recv;",
          "4436:   uint32_t seq = mg_ntohl(pkt->tcp->seq);",
          "4437:   s->raw.align = c->recv.align;",
          "4438:   uint32_t rem_ip;",
          "4439:   memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "4440:   if (pkt->tcp->flags & TH_FIN) {",
          "4444:     uint8_t flags = TH_ACK;",
          "4445:     s->ack = (uint32_t) (mg_htonl(pkt->tcp->seq) + pkt->pay.len + 1);",
          "4446:     if (c->is_draining && s->ttype == MIP_TTYPE_FIN) {",
          "4447:       if (s->seq == mg_htonl(pkt->tcp->ack)) {  // Simultaneous closure ?",
          "4448:         s->seq++;                               // Yes. Increment our SEQ",
          "4449:       } else {                                  // Otherwise,",
          "4450:         s->seq = mg_htonl(pkt->tcp->ack);       // Set to peer's ACK",
          "4452:     } else {",
          "4453:       flags |= TH_FIN;",
          "4454:       c->is_draining = 1;",
          "4455:       settmout(c, MIP_TTYPE_FIN);",
          "4456:     }",
          "4457:     tx_tcp((struct mg_tcpip_if *) c->mgr->priv, s->mac, rem_ip, flags,",
          "4458:            c->loc.port, c->rem.port, mg_htonl(s->seq), mg_htonl(s->ack), \"\", 0);",
          "4459:   } else if (pkt->pay.len == 0) {",
          "4461:   } else if (seq != s->ack) {",
          "4462:     uint32_t ack = (uint32_t) (mg_htonl(pkt->tcp->seq) + pkt->pay.len);",
          "4463:     if (s->ack == ack) {",
          "4464:       MG_VERBOSE((\"ignoring duplicate pkt\"));",
          "4465:     } else {",
          "4466:       MG_VERBOSE((\"SEQ != ACK: %x %x %x\", seq, s->ack, ack));",
          "4467:       tx_tcp((struct mg_tcpip_if *) c->mgr->priv, s->mac, rem_ip, TH_ACK,",
          "4468:              c->loc.port, c->rem.port, mg_htonl(s->seq), mg_htonl(s->ack), \"\",",
          "4469:              0);",
          "4471:   } else if (io->size - io->len < pkt->pay.len &&",
          "4472:              !mg_iobuf_resize(io, io->len + pkt->pay.len)) {",
          "4473:     mg_error(c, \"oom\");",
          "4474:   } else {",
          "4480:     memcpy(&io->buf[io->len], pkt->pay.ptr, pkt->pay.len);",
          "4481:     io->len += pkt->pay.len;",
          "4483:     MG_VERBOSE((\"%lu SEQ %x -> %x\", c->id, mg_htonl(pkt->tcp->seq), s->ack));",
          "4485:     s->ack = (uint32_t) (mg_htonl(pkt->tcp->seq) + pkt->pay.len);",
          "4486: #if 0",
          "4488:     uint32_t rem_ip;",
          "4489:     memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "4490:     MG_DEBUG((\"  imm ACK\", c->id, mg_htonl(pkt->tcp->seq), s->ack));",
          "4491:     tx_tcp((struct mg_tcpip_if *) c->mgr->priv, s->mac, rem_ip, TH_ACK, c->loc.port,",
          "4492:            c->rem.port, mg_htonl(s->seq), mg_htonl(s->ack), \"\", 0);",
          "4493: #else",
          "4495:     if (s->ttype != MIP_TTYPE_ACK) settmout(c, MIP_TTYPE_ACK);",
          "4496: #endif",
          "4498:     if (c->is_tls) {",
          "4500:       io = &c->recv;",
          "4501:       if (io->size - io->len < pkt->pay.len &&",
          "4502:           !mg_iobuf_resize(io, io->len + pkt->pay.len)) {",
          "4503:         mg_error(c, \"oom\");",
          "4504:       } else {",
          "4506:         long n = mg_tls_recv(c, &io->buf[io->len], io->size - io->len);",
          "4507:         if (n == MG_IO_ERR) {",
          "4508:           mg_error(c, \"TLS recv error\");",
          "4509:         } else if (n > 0) {",
          "4511:           io->len += (size_t) n;",
          "4512:           mg_call(c, MG_EV_READ, &n);",
          "4515:     } else {",
          "4518:       mg_call(c, MG_EV_READ, &pkt->pay.len);",
          "4523: static void rx_tcp(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "4524:   struct mg_connection *c = getpeer(ifp->mgr, pkt, false);",
          "4525:   struct connstate *s = c == NULL ? NULL : (struct connstate *) (c + 1);",
          "4526: #if 0",
          "4527:   MG_INFO((\"%lu %hhu %d\", c ? c->id : 0, pkt->tcp->flags, (int) pkt->pay.len));",
          "4528: #endif",
          "4529:   if (c != NULL && c->is_connecting && pkt->tcp->flags == (TH_SYN | TH_ACK)) {",
          "4530:     s->seq = mg_ntohl(pkt->tcp->ack), s->ack = mg_ntohl(pkt->tcp->seq) + 1;",
          "4531:     tx_tcp_pkt(ifp, pkt, TH_ACK, pkt->tcp->ack, NULL, 0);",
          "4532:     c->is_connecting = 0;  // Client connected",
          "4533:     settmout(c, MIP_TTYPE_KEEPALIVE);",
          "4534:     mg_call(c, MG_EV_CONNECT, NULL);  // Let user know",
          "4535:   } else if (c != NULL && c->is_connecting && pkt->tcp->flags != TH_ACK) {",
          "4537:     tx_tcp_pkt(ifp, pkt, TH_RST | TH_ACK, pkt->tcp->ack, NULL, 0);",
          "4538:   } else if (c != NULL && pkt->tcp->flags & TH_RST) {",
          "4539:     mg_error(c, \"peer RST\");  // RFC-1122 4.2.2.13",
          "4540:   } else if (c != NULL) {",
          "4541: #if 0",
          "4542:     MG_DEBUG((\"%lu %d %M:%hu -> %M:%hu\", c->id, (int) pkt->raw.len,",
          "4543:               mg_print_ip4, &pkt->ip->src, mg_ntohs(pkt->tcp->sport),",
          "4544:               mg_print_ip4, &pkt->ip->dst, mg_ntohs(pkt->tcp->dport)));",
          "4545:     mg_hexdump(pkt->pay.ptr, pkt->pay.len);",
          "4546: #endif",
          "4547:     s->tmiss = 0;                         // Reset missed keep-alive counter",
          "4548:     if (s->ttype == MIP_TTYPE_KEEPALIVE)  // Advance keep-alive timer",
          "4549:       settmout(c,",
          "4550:                MIP_TTYPE_KEEPALIVE);  // unless a former ACK timeout is pending",
          "4551:     read_conn(c, pkt);  // Override timer with ACK timeout if needed",
          "4552:   } else if ((c = getpeer(ifp->mgr, pkt, true)) == NULL) {",
          "4553:     tx_tcp_pkt(ifp, pkt, TH_RST | TH_ACK, pkt->tcp->ack, NULL, 0);",
          "4554:   } else if (pkt->tcp->flags & TH_RST) {",
          "4555:     if (c->is_accepted) mg_error(c, \"peer RST\");  // RFC-1122 4.2.2.13",
          "4557:   } else if (pkt->tcp->flags & TH_SYN) {",
          "4559:     uint32_t isn = mg_htonl((uint32_t) mg_ntohs(pkt->tcp->sport));",
          "4560:     tx_tcp_pkt(ifp, pkt, TH_SYN | TH_ACK, isn, NULL, 0);",
          "4561:   } else if (pkt->tcp->flags & TH_FIN) {",
          "4562:     tx_tcp_pkt(ifp, pkt, TH_FIN | TH_ACK, pkt->tcp->ack, NULL, 0);",
          "4563:   } else if (mg_htonl(pkt->tcp->ack) == mg_htons(pkt->tcp->sport) + 1U) {",
          "4564:     accept_conn(c, pkt);",
          "4565:   } else if (!c->is_accepted) {  // no peer",
          "4566:     tx_tcp_pkt(ifp, pkt, TH_RST | TH_ACK, pkt->tcp->ack, NULL, 0);",
          "4567:   } else {",
          "4569:   }",
          "4570: }",
          "4572: static void rx_ip(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "4573:   if (pkt->ip->frag & IP_MORE_FRAGS_MSK ||",
          "4574:         pkt->ip->frag & IP_FRAG_OFFSET_MSK) {",
          "4575:     if (pkt->ip->proto == 17) pkt->udp = (struct udp *) (pkt->ip + 1);",
          "4576:     if (pkt->ip->proto == 6) pkt->tcp = (struct tcp *) (pkt->ip + 1);",
          "4577:     struct mg_connection *c = getpeer(ifp->mgr, pkt, false);",
          "4578:     if (c)  mg_error(c, \"Received fragmented packet\");",
          "4579:   } else if (pkt->ip->proto == 1) {",
          "4580:     pkt->icmp = (struct icmp *) (pkt->ip + 1);",
          "4581:     if (pkt->pay.len < sizeof(*pkt->icmp)) return;",
          "4582:     mkpay(pkt, pkt->icmp + 1);",
          "4583:     rx_icmp(ifp, pkt);",
          "4584:   } else if (pkt->ip->proto == 17) {",
          "4585:     pkt->udp = (struct udp *) (pkt->ip + 1);",
          "4586:     if (pkt->pay.len < sizeof(*pkt->udp)) return;",
          "4587:     mkpay(pkt, pkt->udp + 1);",
          "4588:     MG_VERBOSE((\"UDP %M:%hu -> %M:%hu len %u\", mg_print_ip4, &pkt->ip->src,",
          "4589:                 mg_ntohs(pkt->udp->sport), mg_print_ip4, &pkt->ip->dst,",
          "4590:                 mg_ntohs(pkt->udp->dport), (int) pkt->pay.len));",
          "4591:     if (ifp->enable_dhcp_client && pkt->udp->dport == mg_htons(68)) {",
          "4592:       pkt->dhcp = (struct dhcp *) (pkt->udp + 1);",
          "4593:       mkpay(pkt, pkt->dhcp + 1);",
          "4594:       rx_dhcp_client(ifp, pkt);",
          "4595:     } else if (ifp->enable_dhcp_server && pkt->udp->dport == mg_htons(67)) {",
          "4596:       pkt->dhcp = (struct dhcp *) (pkt->udp + 1);",
          "4597:       mkpay(pkt, pkt->dhcp + 1);",
          "4598:       rx_dhcp_server(ifp, pkt);",
          "4599:     } else {",
          "4600:       rx_udp(ifp, pkt);",
          "4601:     }",
          "4602:   } else if (pkt->ip->proto == 6) {",
          "4603:     pkt->tcp = (struct tcp *) (pkt->ip + 1);",
          "4604:     if (pkt->pay.len < sizeof(*pkt->tcp)) return;",
          "4605:     mkpay(pkt, pkt->tcp + 1);",
          "4606:     uint16_t iplen = mg_ntohs(pkt->ip->len);",
          "4607:     uint16_t off = (uint16_t) (sizeof(*pkt->ip) + ((pkt->tcp->off >> 4) * 4U));",
          "4608:     if (iplen >= off) pkt->pay.len = (size_t) (iplen - off);",
          "4609:     MG_VERBOSE((\"TCP %M:%hu -> %M:%hu len %u\", mg_print_ip4, &pkt->ip->src,",
          "4610:                 mg_ntohs(pkt->tcp->sport), mg_print_ip4, &pkt->ip->dst,",
          "4611:                 mg_ntohs(pkt->tcp->dport), (int) pkt->pay.len));",
          "4612:     rx_tcp(ifp, pkt);",
          "4613:   }",
          "4616: static void rx_ip6(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "4618:   if (pkt->ip6->proto == 1 || pkt->ip6->proto == 58) {",
          "4619:     pkt->icmp = (struct icmp *) (pkt->ip6 + 1);",
          "4620:     if (pkt->pay.len < sizeof(*pkt->icmp)) return;",
          "4621:     mkpay(pkt, pkt->icmp + 1);",
          "4622:     rx_icmp(ifp, pkt);",
          "4623:   } else if (pkt->ip6->proto == 17) {",
          "4624:     pkt->udp = (struct udp *) (pkt->ip6 + 1);",
          "4625:     if (pkt->pay.len < sizeof(*pkt->udp)) return;",
          "4628:     mkpay(pkt, pkt->udp + 1);",
          "4629:   }",
          "4632: static void mg_tcpip_rx(struct mg_tcpip_if *ifp, void *buf, size_t len) {",
          "4633:   struct pkt pkt;",
          "4634:   memset(&pkt, 0, sizeof(pkt));",
          "4635:   pkt.raw.ptr = (char *) buf;",
          "4636:   pkt.raw.len = len;",
          "4637:   pkt.eth = (struct eth *) buf;",
          "4639:   if (pkt.raw.len < sizeof(*pkt.eth)) return;  // Truncated - runt?",
          "4640:   if (ifp->enable_mac_check &&",
          "4641:       memcmp(pkt.eth->dst, ifp->mac, sizeof(pkt.eth->dst)) != 0 &&",
          "4642:       memcmp(pkt.eth->dst, broadcast, sizeof(pkt.eth->dst)) != 0)",
          "4643:     return;",
          "4644:   if (ifp->enable_crc32_check && len > 4) {",
          "4645:     len -= 4;  // TODO(scaprile): check on bigendian",
          "4646:     uint32_t crc = mg_crc32(0, (const char *) buf, len);",
          "4647:     if (memcmp((void *) ((size_t) buf + len), &crc, sizeof(crc))) return;",
          "4648:   }",
          "4649:   if (pkt.eth->type == mg_htons(0x806)) {",
          "4650:     pkt.arp = (struct arp *) (pkt.eth + 1);",
          "4651:     if (sizeof(*pkt.eth) + sizeof(*pkt.arp) > pkt.raw.len) return;  // Truncated",
          "4652:     rx_arp(ifp, &pkt);",
          "4653:   } else if (pkt.eth->type == mg_htons(0x86dd)) {",
          "4654:     pkt.ip6 = (struct ip6 *) (pkt.eth + 1);",
          "4655:     if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip6)) return;  // Truncated",
          "4656:     if ((pkt.ip6->ver >> 4) != 0x6) return;                         // Not IP",
          "4657:     mkpay(&pkt, pkt.ip6 + 1);",
          "4658:     rx_ip6(ifp, &pkt);",
          "4659:   } else if (pkt.eth->type == mg_htons(0x800)) {",
          "4660:     pkt.ip = (struct ip *) (pkt.eth + 1);",
          "4661:     if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip)) return;  // Truncated",
          "4663:     if ((size_t) mg_ntohs(pkt.ip->len) + sizeof(struct eth) < pkt.raw.len) {",
          "4664:       pkt.raw.len = (size_t) mg_ntohs(pkt.ip->len) + sizeof(struct eth);",
          "4665:     }",
          "4666:     if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip)) return;  // Truncated",
          "4667:     if ((pkt.ip->ver >> 4) != 4) return;                           // Not IP",
          "4668:     mkpay(&pkt, pkt.ip + 1);",
          "4669:     rx_ip(ifp, &pkt);",
          "4670:   } else {",
          "4671:     MG_DEBUG((\"Unknown eth type %x\", mg_htons(pkt.eth->type)));",
          "4672:     mg_hexdump(buf, len >= 32 ? 32 : len);",
          "4673:   }",
          "4676: static void mg_tcpip_poll(struct mg_tcpip_if *ifp, uint64_t uptime_ms) {",
          "4677:   if (ifp == NULL || ifp->driver == NULL) return;",
          "4678:   bool expired_1000ms = mg_timer_expired(&ifp->timer_1000ms, 1000, uptime_ms);",
          "4679:   ifp->now = uptime_ms;",
          "4682:   if (expired_1000ms && ifp->driver->up) {",
          "4683:     bool up = ifp->driver->up(ifp);",
          "4684:     bool current = ifp->state != MG_TCPIP_STATE_DOWN;",
          "4685:     if (up != current) {",
          "4686:       ifp->state = up == false               ? MG_TCPIP_STATE_DOWN",
          "4687:                    : ifp->enable_dhcp_client ? MG_TCPIP_STATE_UP",
          "4688:                                              : MG_TCPIP_STATE_READY;",
          "4689:       if (!up && ifp->enable_dhcp_client) ifp->ip = 0;",
          "4690:       onstatechange(ifp);",
          "4691:     }",
          "4692:   }",
          "4693:   if (ifp->state == MG_TCPIP_STATE_DOWN) return;",
          "4696:   if (ifp->state == MG_TCPIP_STATE_UP && expired_1000ms) {",
          "4697:     tx_dhcp_discover(ifp);  // INIT (4.4.1)",
          "4698:   } else if (expired_1000ms && ifp->state == MG_TCPIP_STATE_READY &&",
          "4699:              ifp->lease_expire > 0) {  // BOUND / RENEWING / REBINDING",
          "4700:     if (ifp->now >= ifp->lease_expire) {",
          "4701:       ifp->state = MG_TCPIP_STATE_UP, ifp->ip = 0;  // expired, release IP",
          "4702:       onstatechange(ifp);",
          "4703:     } else if (ifp->now + 30UL * 60UL * 1000UL > ifp->lease_expire &&",
          "4704:                ((ifp->now / 1000) % 60) == 0) {",
          "4706:       tx_dhcp_request_re(ifp, (uint8_t *) broadcast, ifp->ip, 0xffffffff);",
          "4707:     }  // TODO(): Handle T1 (RENEWING) and T2 (REBINDING) (4.4.5)",
          "4708:   }",
          "4711:   if (ifp->driver->rx != NULL) {  // Polling driver. We must call it",
          "4712:     size_t len =",
          "4713:         ifp->driver->rx(ifp->recv_queue.buf, ifp->recv_queue.size, ifp);",
          "4714:     if (len > 0) mg_tcpip_rx(ifp, ifp->recv_queue.buf, len);",
          "4715:   } else {  // Interrupt-based driver. Fills recv queue itself",
          "4716:     char *buf;",
          "4717:     size_t len = mg_queue_next(&ifp->recv_queue, &buf);",
          "4718:     if (len > 0) {",
          "4719:       mg_tcpip_rx(ifp, buf, len);",
          "4720:       mg_queue_del(&ifp->recv_queue, len);",
          "4721:     }",
          "4722:   }",
          "4725:   for (struct mg_connection *c = ifp->mgr->conns; c != NULL; c = c->next) {",
          "4726:     if (c->is_udp || c->is_listening || c->is_resolving) continue;",
          "4727:     struct connstate *s = (struct connstate *) (c + 1);",
          "4728:     uint32_t rem_ip;",
          "4729:     memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "4730:     if (uptime_ms > s->timer) {",
          "4731:       if (s->ttype == MIP_TTYPE_ACK) {",
          "4732:         MG_VERBOSE((\"%lu ack %x %x\", c->id, s->seq, s->ack));",
          "4733:         tx_tcp(ifp, s->mac, rem_ip, TH_ACK, c->loc.port, c->rem.port,",
          "4734:                mg_htonl(s->seq), mg_htonl(s->ack), \"\", 0);",
          "4735:       } else if (s->ttype == MIP_TTYPE_ARP) {",
          "4736:         mg_error(c, \"ARP timeout\");",
          "4737:       } else if (s->ttype == MIP_TTYPE_SYN) {",
          "4738:         mg_error(c, \"Connection timeout\");",
          "4739:       } else if (s->ttype == MIP_TTYPE_FIN) {",
          "4740:         c->is_closing = 1;",
          "4741:         continue;",
          "4742:       } else {",
          "4743:         if (s->tmiss++ > 2) {",
          "4744:           mg_error(c, \"keepalive\");",
          "4745:         } else {",
          "4746:           MG_VERBOSE((\"%lu keepalive\", c->id));",
          "4747:           tx_tcp(ifp, s->mac, rem_ip, TH_ACK, c->loc.port, c->rem.port,",
          "4748:                  mg_htonl(s->seq - 1), mg_htonl(s->ack), \"\", 0);",
          "4749:         }",
          "4750:       }",
          "4752:       settmout(c, MIP_TTYPE_KEEPALIVE);",
          "4753:     }",
          "4754:   }",
          "4760: void mg_tcpip_qwrite(void *buf, size_t len, struct mg_tcpip_if *ifp) {",
          "4761:   char *p;",
          "4762:   if (mg_queue_book(&ifp->recv_queue, &p, len) >= len) {",
          "4763:     memcpy(p, buf, len);",
          "4764:     mg_queue_add(&ifp->recv_queue, len);",
          "4765:     ifp->nrecv++;",
          "4766:   } else {",
          "4767:     ifp->ndrop++;",
          "4771: void mg_tcpip_init(struct mg_mgr *mgr, struct mg_tcpip_if *ifp) {",
          "4773:   if (ifp->mac[0] == 0 && ifp->mac[1] == 0 && ifp->mac[2] == 0 &&",
          "4774:       ifp->mac[3] == 0 && ifp->mac[4] == 0 && ifp->mac[5] == 0) {",
          "4775:     ifp->mac[0] = 0x02;  // Locally administered, unicast",
          "4776:     mg_random(&ifp->mac[1], sizeof(ifp->mac) - 1);",
          "4777:     MG_INFO((\"MAC not set. Generated random: %M\", mg_print_mac, ifp->mac));",
          "4778:   }",
          "4780:   if (ifp->driver->init && !ifp->driver->init(ifp)) {",
          "4781:     MG_ERROR((\"driver init failed\"));",
          "4782:   } else {",
          "4783:     size_t framesize = 1540;",
          "4784:     ifp->tx.ptr = (char *) calloc(1, framesize), ifp->tx.len = framesize;",
          "4785:     if (ifp->recv_queue.size == 0)",
          "4786:       ifp->recv_queue.size = ifp->driver->rx ? framesize : 8192;",
          "4787:     ifp->recv_queue.buf = (char *) calloc(1, ifp->recv_queue.size);",
          "4788:     ifp->timer_1000ms = mg_millis();",
          "4789:     mgr->priv = ifp;",
          "4790:     ifp->mgr = mgr;",
          "4791:     ifp->mtu = MG_TCPIP_MTU_DEFAULT;",
          "4792:     mgr->extraconnsize = sizeof(struct connstate);",
          "4793:     if (ifp->ip == 0) ifp->enable_dhcp_client = true;",
          "4794:     memset(ifp->gwmac, 255, sizeof(ifp->gwmac));  // Set to broadcast",
          "4795:     mg_random(&ifp->eport, sizeof(ifp->eport));   // Random from 0 to 65535",
          "4796:     ifp->eport |= MG_EPHEMERAL_PORT_BASE;         // Random from",
          "4798:     if (ifp->tx.ptr == NULL || ifp->recv_queue.buf == NULL) MG_ERROR((\"OOM\"));",
          "4799:   }",
          "4802: void mg_tcpip_free(struct mg_tcpip_if *ifp) {",
          "4803:   free(ifp->recv_queue.buf);",
          "4804:   free((char *) ifp->tx.ptr);",
          "4807: int mg_mkpipe(struct mg_mgr *m, mg_event_handler_t fn, void *d, bool udp) {",
          "4808:   (void) m, (void) fn, (void) d, (void) udp;",
          "4809:   MG_ERROR((\"Not implemented\"));",
          "4810:   return -1;",
          "4813: static void send_syn(struct mg_connection *c) {",
          "4814:   struct connstate *s = (struct connstate *) (c + 1);",
          "4815:   uint32_t isn = mg_htonl((uint32_t) mg_ntohs(c->loc.port));",
          "4816:   struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;",
          "4817:   uint32_t rem_ip;",
          "4818:   memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "4819:   tx_tcp(ifp, s->mac, rem_ip, TH_SYN, c->loc.port, c->rem.port, isn, 0, NULL,",
          "4820:          0);",
          "4823: void mg_connect_resolved(struct mg_connection *c) {",
          "4824:   struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;",
          "4825:   uint32_t rem_ip;",
          "4826:   memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "4827:   c->is_resolving = 0;",
          "4828:   if (ifp->eport < MG_EPHEMERAL_PORT_BASE) ifp->eport = MG_EPHEMERAL_PORT_BASE;",
          "4829:   memcpy(c->loc.ip, &ifp->ip, sizeof(uint32_t));",
          "4830:   c->loc.port = mg_htons(ifp->eport++);",
          "4831:   MG_DEBUG((\"%lu %M -> %M\", c->id, mg_print_ip_port, &c->loc, mg_print_ip_port,",
          "4832:             &c->rem));",
          "4833:   mg_call(c, MG_EV_RESOLVE, NULL);",
          "4834:   if (((rem_ip & ifp->mask) == (ifp->ip & ifp->mask))) {",
          "4836:     MG_DEBUG((\"%lu ARP lookup...\", c->id));",
          "4837:     arp_ask(ifp, rem_ip);",
          "4838:     settmout(c, MIP_TTYPE_ARP);",
          "4839:     c->is_arplooking = 1;",
          "4840:     c->is_connecting = 1;",
          "4841:   } else if (rem_ip == (ifp->ip | ~ifp->mask)) {",
          "4842:     struct connstate *s = (struct connstate *) (c + 1);",
          "4843:     memset(s->mac, 0xFF, sizeof(s->mac));  // local broadcast",
          "4844:   } else if ((*((uint8_t *) &rem_ip) & 0xE0) == 0xE0) {",
          "4845:     struct connstate *s = (struct connstate *) (c + 1);  // 224 to 239, E0 to EF",
          "4846:     uint8_t mcastp[3] = {0x01, 0x00, 0x5E};              // multicast group",
          "4847:     memcpy(s->mac, mcastp, 3);",
          "4848:     memcpy(s->mac + 3, ((uint8_t *) &rem_ip) + 1, 3);  // 23 LSb",
          "4849:     s->mac[3] &= 0x7F;",
          "4850:   } else {",
          "4851:     struct connstate *s = (struct connstate *) (c + 1);",
          "4852:     memcpy(s->mac, ifp->gwmac, sizeof(ifp->gwmac));",
          "4853:     if (c->is_udp) {",
          "4854:       mg_call(c, MG_EV_CONNECT, NULL);",
          "4855:     } else {",
          "4856:       send_syn(c);",
          "4857:       settmout(c, MIP_TTYPE_SYN);",
          "4858:       c->is_connecting = 1;",
          "4859:     }",
          "4860:   }",
          "4863: bool mg_open_listener(struct mg_connection *c, const char *url) {",
          "4864:   c->loc.port = mg_htons(mg_url_port(url));",
          "4865:   return true;",
          "4868: static void write_conn(struct mg_connection *c) {",
          "4869:   long len = c->is_tls ? mg_tls_send(c, c->send.buf, c->send.len)",
          "4870:                        : mg_io_send(c, c->send.buf, c->send.len);",
          "4871:   if (len > 0) {",
          "4872:     mg_iobuf_del(&c->send, 0, (size_t) len);",
          "4873:     mg_call(c, MG_EV_WRITE, &len);",
          "4877: static void init_closure(struct mg_connection *c) {",
          "4878:   struct connstate *s = (struct connstate *) (c + 1);",
          "4879:   if (c->is_udp == false && c->is_listening == false &&",
          "4880:       c->is_connecting == false) {  // For TCP conns,",
          "4881:     struct mg_tcpip_if *ifp =",
          "4882:         (struct mg_tcpip_if *) c->mgr->priv;  // send TCP FIN",
          "4883:     uint32_t rem_ip;",
          "4884:     memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "4885:     tx_tcp(ifp, s->mac, rem_ip, TH_FIN | TH_ACK, c->loc.port, c->rem.port,",
          "4886:            mg_htonl(s->seq), mg_htonl(s->ack), NULL, 0);",
          "4887:     settmout(c, MIP_TTYPE_FIN);",
          "4891: static void close_conn(struct mg_connection *c) {",
          "4892:   struct connstate *s = (struct connstate *) (c + 1);",
          "4893:   mg_iobuf_free(&s->raw);  // For TLS connections, release raw data",
          "4894:   mg_close_conn(c);",
          "4895: }",
          "4897: static bool can_write(struct mg_connection *c) {",
          "4898:   return c->is_connecting == 0 && c->is_resolving == 0 && c->send.len > 0 &&",
          "4899:          c->is_tls_hs == 0 && c->is_arplooking == 0;",
          "4902: void mg_mgr_poll(struct mg_mgr *mgr, int ms) {",
          "4903:   struct mg_connection *c, *tmp;",
          "4904:   uint64_t now = mg_millis();",
          "4905:   mg_tcpip_poll((struct mg_tcpip_if *) mgr->priv, now);",
          "4906:   mg_timer_poll(&mgr->timers, now);",
          "4907:   for (c = mgr->conns; c != NULL; c = tmp) {",
          "4908:     tmp = c->next;",
          "4909:     struct connstate *s = (struct connstate *) (c + 1);",
          "4910:     mg_call(c, MG_EV_POLL, &now);",
          "4911:     MG_VERBOSE((\"%lu .. %c%c%c%c%c\", c->id, c->is_tls ? 'T' : 't',",
          "4912:                 c->is_connecting ? 'C' : 'c', c->is_tls_hs ? 'H' : 'h',",
          "4913:                 c->is_resolving ? 'R' : 'r', c->is_closing ? 'C' : 'c'));",
          "4914:     if (c->is_tls_hs) mg_tls_handshake(c);",
          "4915:     if (can_write(c)) write_conn(c);",
          "4916:     if (c->is_draining && c->send.len == 0 && s->ttype != MIP_TTYPE_FIN)",
          "4917:       init_closure(c);",
          "4918:     if (c->is_closing) close_conn(c);",
          "4920:   (void) ms;",
          "4923: bool mg_send(struct mg_connection *c, const void *buf, size_t len) {",
          "4924:   struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;",
          "4925:   bool res = false;",
          "4926:   uint32_t rem_ip;",
          "4927:   memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "4928:   if (ifp->ip == 0 || ifp->state != MG_TCPIP_STATE_READY) {",
          "4929:     mg_error(c, \"net down\");",
          "4930:   } else if (c->is_udp) {",
          "4931:     struct connstate *s = (struct connstate *) (c + 1);",
          "4932:     len = trim_len(c, len);   // Trimming length if necessary",
          "4933:     tx_udp(ifp, s->mac, ifp->ip, c->loc.port, rem_ip, c->rem.port, buf, len);",
          "4934:     res = true;",
          "4936:     res = mg_iobuf_add(&c->send, c->send.len, buf, len);",
          "4938:   return res;",
          "4939: }",
          "4940: #endif  // MG_ENABLE_TCPIP",
          "4942: #ifdef MG_ENABLE_LINES",
          "4943: #line 1 \"src/ota_dummy.c\"",
          "4944: #endif",
          "4948: #if MG_OTA == MG_OTA_NONE",
          "4949: bool mg_ota_begin(size_t new_firmware_size) {",
          "4950:   (void) new_firmware_size;",
          "4951:   return true;",
          "4952: }",
          "4953: bool mg_ota_write(const void *buf, size_t len) {",
          "4954:   (void) buf, (void) len;",
          "4955:   return true;",
          "4956: }",
          "4957: bool mg_ota_end(void) {",
          "4958:   return true;",
          "4959: }",
          "4960: bool mg_ota_commit(void) {",
          "4961:   return true;",
          "4962: }",
          "4963: bool mg_ota_rollback(void) {",
          "4964:   return true;",
          "4965: }",
          "4966: int mg_ota_status(int fw) {",
          "4967:   (void) fw;",
          "4968:   return 0;",
          "4969: }",
          "4970: uint32_t mg_ota_crc32(int fw) {",
          "4971:   (void) fw;",
          "4972:   return 0;",
          "4973: }",
          "4974: uint32_t mg_ota_timestamp(int fw) {",
          "4975:   (void) fw;",
          "4976:   return 0;",
          "4977: }",
          "4978: size_t mg_ota_size(int fw) {",
          "4979:   (void) fw;",
          "4980:   return 0;",
          "4982: #endif",
          "4984: #ifdef MG_ENABLE_LINES",
          "4985: #line 1 \"src/ota_flash.c\"",
          "4986: #endif",
          "4996: #if MG_OTA == MG_OTA_FLASH",
          "4998: #define MG_OTADATA_KEY 0xb07afed0",
          "5000: static char *s_addr;      // Current address to write to",
          "5001: static size_t s_size;     // Firmware size to flash. In-progress indicator",
          "5002: static uint32_t s_crc32;  // Firmware checksum",
          "5004: struct mg_otadata {",
          "5005:   uint32_t crc32, size, timestamp, status;",
          "5006: };",
          "5008: bool mg_ota_begin(size_t new_firmware_size) {",
          "5009:   bool ok = false;",
          "5010:   if (s_size) {",
          "5011:     MG_ERROR((\"OTA already in progress. Call mg_ota_end()\"));",
          "5012:   } else {",
          "5013:     size_t half = mg_flash_size() / 2, max = half - mg_flash_sector_size();",
          "5014:     s_crc32 = 0;",
          "5015:     s_addr = (char *) mg_flash_start() + half;",
          "5016:     MG_DEBUG((\"Firmware %lu bytes, max %lu\", s_size, max));",
          "5017:     if (new_firmware_size < max) {",
          "5018:       ok = true;",
          "5019:       s_size = new_firmware_size;",
          "5020:       MG_INFO((\"Starting OTA, firmware size %lu\", s_size));",
          "5021:     } else {",
          "5022:       MG_ERROR((\"Firmware %lu is too big to fit %lu\", new_firmware_size, max));",
          "5025:   return ok;",
          "5028: bool mg_ota_write(const void *buf, size_t len) {",
          "5029:   bool ok = false;",
          "5030:   if (s_size == 0) {",
          "5031:     MG_ERROR((\"OTA is not started, call mg_ota_begin()\"));",
          "5033:     size_t align = mg_flash_write_align();",
          "5034:     size_t len_aligned_down = MG_ROUND_DOWN(len, align);",
          "5035:     if (len_aligned_down) ok = mg_flash_write(s_addr, buf, len_aligned_down);",
          "5036:     if (len_aligned_down < len) {",
          "5037:       size_t left = len - len_aligned_down;",
          "5038:       char tmp[align];",
          "5039:       memset(tmp, 0xff, sizeof(tmp));",
          "5040:       memcpy(tmp, (char *) buf + len_aligned_down, left);",
          "5041:       ok = mg_flash_write(s_addr + len_aligned_down, tmp, sizeof(tmp));",
          "5043:     s_crc32 = mg_crc32(s_crc32, (char *) buf, len);  // Update CRC",
          "5044:     MG_DEBUG((\"%#x %p %lu -> %d\", s_addr - len, buf, len, ok));",
          "5045:     s_addr += len;",
          "5047:   return ok;",
          "5050: bool mg_ota_end(void) {",
          "5051:   char *base = (char *) mg_flash_start() + mg_flash_size() / 2;",
          "5052:   bool ok = false;",
          "5053:   if (s_size) {",
          "5054:     size_t size = s_addr - base;",
          "5055:     uint32_t crc32 = mg_crc32(0, base, s_size);",
          "5056:     if (size == s_size && crc32 == s_crc32) {",
          "5057:       uint32_t now = (uint32_t) (mg_now() / 1000);",
          "5058:       struct mg_otadata od = {crc32, size, now, MG_OTA_FIRST_BOOT};",
          "5059:       uint32_t key = MG_OTADATA_KEY + (mg_flash_bank() == 2 ? 1 : 2);",
          "5060:       ok = mg_flash_save(NULL, key, &od, sizeof(od));",
          "5061:     }",
          "5062:     MG_DEBUG((\"CRC: %x/%x, size: %lu/%lu, status: %s\", s_crc32, crc32, s_size,",
          "5063:               size, ok ? \"ok\" : \"fail\"));",
          "5064:     s_size = 0;",
          "5065:     if (ok) ok = mg_flash_swap_bank();",
          "5066:   }",
          "5067:   MG_INFO((\"Finishing OTA: %s\", ok ? \"ok\" : \"fail\"));",
          "5068:   return ok;",
          "5071: static struct mg_otadata mg_otadata(int fw) {",
          "5072:   struct mg_otadata od = {};",
          "5073:   int bank = mg_flash_bank();",
          "5074:   uint32_t key = MG_OTADATA_KEY + 1;",
          "5075:   if ((fw == MG_FIRMWARE_CURRENT && bank == 2)) key++;",
          "5076:   if ((fw == MG_FIRMWARE_PREVIOUS && bank == 1)) key++;",
          "5077:   mg_flash_load(NULL, key, &od, sizeof(od));",
          "5080:   return od;",
          "5081: }",
          "5083: int mg_ota_status(int fw) {",
          "5084:   struct mg_otadata od = mg_otadata(fw);",
          "5085:   return od.status;",
          "5086: }",
          "5087: uint32_t mg_ota_crc32(int fw) {",
          "5088:   struct mg_otadata od = mg_otadata(fw);",
          "5089:   return od.crc32;",
          "5090: }",
          "5091: uint32_t mg_ota_timestamp(int fw) {",
          "5092:   struct mg_otadata od = mg_otadata(fw);",
          "5093:   return od.timestamp;",
          "5094: }",
          "5095: size_t mg_ota_size(int fw) {",
          "5096:   struct mg_otadata od = mg_otadata(fw);",
          "5097:   return od.size;",
          "5098: }",
          "5100: bool mg_ota_commit(void) {",
          "5101:   struct mg_otadata od = mg_otadata(MG_FIRMWARE_CURRENT);",
          "5102:   od.status = MG_OTA_COMMITTED;",
          "5103:   uint32_t key = MG_OTADATA_KEY + mg_flash_bank();",
          "5104:   return mg_flash_save(NULL, key, &od, sizeof(od));",
          "5107: bool mg_ota_rollback(void) {",
          "5108:   MG_DEBUG((\"Rolling firmware back\"));",
          "5109:   return mg_flash_swap_bank();",
          "5110: }",
          "5113: #ifdef MG_ENABLE_LINES",
          "5114: #line 1 \"src/printf.c\"",
          "5120: size_t mg_queue_vprintf(struct mg_queue *q, const char *fmt, va_list *ap) {",
          "5121:   size_t len = mg_snprintf(NULL, 0, fmt, ap);",
          "5122:   char *buf;",
          "5123:   if (len == 0 || mg_queue_book(q, &buf, len + 1) < len + 1) {",
          "5124:     len = 0;  // Nah. Not enough space",
          "5126:     len = mg_vsnprintf((char *) buf, len + 1, fmt, ap);",
          "5127:     mg_queue_add(q, len);",
          "5129:   return len;",
          "5130: }",
          "5132: size_t mg_queue_printf(struct mg_queue *q, const char *fmt, ...) {",
          "5133:   va_list ap;",
          "5134:   size_t len;",
          "5135:   va_start(ap, fmt);",
          "5136:   len = mg_queue_vprintf(q, fmt, &ap);",
          "5137:   va_end(ap);",
          "5138:   return len;",
          "5141: static void mg_pfn_iobuf_private(char ch, void *param, bool expand) {",
          "5142:   struct mg_iobuf *io = (struct mg_iobuf *) param;",
          "5143:   if (expand && io->len + 2 > io->size) mg_iobuf_resize(io, io->len + 2);",
          "5144:   if (io->len + 2 <= io->size) {",
          "5145:     io->buf[io->len++] = (uint8_t) ch;",
          "5146:     io->buf[io->len] = 0;",
          "5147:   } else if (io->len < io->size) {",
          "5148:     io->buf[io->len++] = 0;  // Guarantee to 0-terminate",
          "5152: static void mg_putchar_iobuf_static(char ch, void *param) {",
          "5153:   mg_pfn_iobuf_private(ch, param, false);",
          "5154: }",
          "5156: void mg_pfn_iobuf(char ch, void *param) {",
          "5157:   mg_pfn_iobuf_private(ch, param, true);",
          "5158: }",
          "5160: size_t mg_vsnprintf(char *buf, size_t len, const char *fmt, va_list *ap) {",
          "5161:   struct mg_iobuf io = {(uint8_t *) buf, len, 0, 0};",
          "5162:   size_t n = mg_vxprintf(mg_putchar_iobuf_static, &io, fmt, ap);",
          "5163:   if (n < len) buf[n] = '\\0';",
          "5164:   return n;",
          "5165: }",
          "5167: size_t mg_snprintf(char *buf, size_t len, const char *fmt, ...) {",
          "5168:   va_list ap;",
          "5169:   size_t n;",
          "5170:   va_start(ap, fmt);",
          "5171:   n = mg_vsnprintf(buf, len, fmt, &ap);",
          "5172:   va_end(ap);",
          "5173:   return n;",
          "5174: }",
          "5176: char *mg_vmprintf(const char *fmt, va_list *ap) {",
          "5177:   struct mg_iobuf io = {0, 0, 0, 256};",
          "5178:   mg_vxprintf(mg_pfn_iobuf, &io, fmt, ap);",
          "5179:   return (char *) io.buf;",
          "5180: }",
          "5182: char *mg_mprintf(const char *fmt, ...) {",
          "5183:   char *s;",
          "5184:   va_list ap;",
          "5185:   va_start(ap, fmt);",
          "5186:   s = mg_vmprintf(fmt, &ap);",
          "5187:   va_end(ap);",
          "5188:   return s;",
          "5189: }",
          "5191: void mg_pfn_stdout(char c, void *param) {",
          "5192:   putchar(c);",
          "5193:   (void) param;",
          "5194: }",
          "5196: static size_t print_ip4(void (*out)(char, void *), void *arg, uint8_t *p) {",
          "5197:   return mg_xprintf(out, arg, \"%d.%d.%d.%d\", p[0], p[1], p[2], p[3]);",
          "5198: }",
          "5200: static size_t print_ip6(void (*out)(char, void *), void *arg, uint16_t *p) {",
          "5201:   return mg_xprintf(out, arg, \"[%x:%x:%x:%x:%x:%x:%x:%x]\", mg_ntohs(p[0]),",
          "5202:                     mg_ntohs(p[1]), mg_ntohs(p[2]), mg_ntohs(p[3]),",
          "5203:                     mg_ntohs(p[4]), mg_ntohs(p[5]), mg_ntohs(p[6]),",
          "5204:                     mg_ntohs(p[7]));",
          "5205: }",
          "5207: size_t mg_print_ip4(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5208:   uint8_t *p = va_arg(*ap, uint8_t *);",
          "5209:   return print_ip4(out, arg, p);",
          "5210: }",
          "5212: size_t mg_print_ip6(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5213:   uint16_t *p = va_arg(*ap, uint16_t *);",
          "5214:   return print_ip6(out, arg, p);",
          "5215: }",
          "5217: size_t mg_print_ip(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5218:   struct mg_addr *addr = va_arg(*ap, struct mg_addr *);",
          "5219:   if (addr->is_ip6) return print_ip6(out, arg, (uint16_t *) addr->ip);",
          "5220:   return print_ip4(out, arg, (uint8_t *) &addr->ip);",
          "5221: }",
          "5223: size_t mg_print_ip_port(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5224:   struct mg_addr *a = va_arg(*ap, struct mg_addr *);",
          "5225:   return mg_xprintf(out, arg, \"%M:%hu\", mg_print_ip, a, mg_ntohs(a->port));",
          "5226: }",
          "5228: size_t mg_print_mac(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5229:   uint8_t *p = va_arg(*ap, uint8_t *);",
          "5230:   return mg_xprintf(out, arg, \"%02x:%02x:%02x:%02x:%02x:%02x\", p[0], p[1], p[2],",
          "5231:                     p[3], p[4], p[5]);",
          "5234: static char mg_esc(int c, bool esc) {",
          "5235:   const char *p, *esc1 = \"\\b\\f\\n\\r\\t\\\\\\\"\", *esc2 = \"bfnrt\\\\\\\"\";",
          "5236:   for (p = esc ? esc1 : esc2; *p != '\\0'; p++) {",
          "5237:     if (*p == c) return esc ? esc2[p - esc1] : esc1[p - esc2];",
          "5239:   return 0;",
          "5242: static char mg_escape(int c) {",
          "5243:   return mg_esc(c, true);",
          "5244: }",
          "5246: static size_t qcpy(void (*out)(char, void *), void *ptr, char *buf,",
          "5247:                    size_t len) {",
          "5248:   size_t i = 0, extra = 0;",
          "5249:   for (i = 0; i < len && buf[i] != '\\0'; i++) {",
          "5250:     char c = mg_escape(buf[i]);",
          "5251:     if (c) {",
          "5252:       out('\\\\', ptr), out(c, ptr), extra++;",
          "5253:     } else {",
          "5254:       out(buf[i], ptr);",
          "5257:   return i + extra;",
          "5258: }",
          "5260: static size_t bcpy(void (*out)(char, void *), void *arg, uint8_t *buf,",
          "5261:                    size_t len) {",
          "5262:   size_t i, j, n = 0;",
          "5263:   const char *t =",
          "5264:       \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";",
          "5265:   for (i = 0; i < len; i += 3) {",
          "5266:     uint8_t c1 = buf[i], c2 = i + 1 < len ? buf[i + 1] : 0,",
          "5267:             c3 = i + 2 < len ? buf[i + 2] : 0;",
          "5268:     char tmp[4] = {t[c1 >> 2], t[(c1 & 3) << 4 | (c2 >> 4)], '=', '='};",
          "5269:     if (i + 1 < len) tmp[2] = t[(c2 & 15) << 2 | (c3 >> 6)];",
          "5270:     if (i + 2 < len) tmp[3] = t[c3 & 63];",
          "5271:     for (j = 0; j < sizeof(tmp) && tmp[j] != '\\0'; j++) out(tmp[j], arg);",
          "5272:     n += j;",
          "5274:   return n;",
          "5275: }",
          "5277: size_t mg_print_hex(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5278:   size_t bl = (size_t) va_arg(*ap, int);",
          "5279:   uint8_t *p = va_arg(*ap, uint8_t *);",
          "5280:   const char *hex = \"0123456789abcdef\";",
          "5281:   size_t j;",
          "5282:   for (j = 0; j < bl; j++) {",
          "5283:     out(hex[(p[j] >> 4) & 0x0F], arg);",
          "5284:     out(hex[p[j] & 0x0F], arg);",
          "5286:   return 2 * bl;",
          "5287: }",
          "5288: size_t mg_print_base64(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5289:   size_t len = (size_t) va_arg(*ap, int);",
          "5290:   uint8_t *buf = va_arg(*ap, uint8_t *);",
          "5291:   return bcpy(out, arg, buf, len);",
          "5292: }",
          "5294: size_t mg_print_esc(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5295:   size_t len = (size_t) va_arg(*ap, int);",
          "5296:   char *p = va_arg(*ap, char *);",
          "5297:   if (len == 0) len = p == NULL ? 0 : strlen(p);",
          "5298:   return qcpy(out, arg, p, len);",
          "5299: }",
          "5301: #ifdef MG_ENABLE_LINES",
          "5302: #line 1 \"src/queue.c\"",
          "5303: #endif",
          "5307: #if defined(__GNUC__) || defined(__clang__)",
          "5308: #define MG_MEMORY_BARRIER() __sync_synchronize()",
          "5309: #elif defined(_MSC_VER) && _MSC_VER >= 1700",
          "5310: #define MG_MEMORY_BARRIER() MemoryBarrier()",
          "5311: #elif !defined(MG_MEMORY_BARRIER)",
          "5312: #define MG_MEMORY_BARRIER()",
          "5313: #endif",
          "5328: void mg_queue_init(struct mg_queue *q, char *buf, size_t size) {",
          "5329:   q->size = size;",
          "5330:   q->buf = buf;",
          "5331:   q->head = q->tail = 0;",
          "5334: static size_t mg_queue_read_len(struct mg_queue *q) {",
          "5335:   uint32_t n = 0;",
          "5336:   MG_MEMORY_BARRIER();",
          "5337:   memcpy(&n, q->buf + q->tail, sizeof(n));",
          "5338:   assert(q->tail + n + sizeof(n) <= q->size);",
          "5339:   return n;",
          "5342: static void mg_queue_write_len(struct mg_queue *q, size_t len) {",
          "5343:   uint32_t n = (uint32_t) len;",
          "5344:   memcpy(q->buf + q->head, &n, sizeof(n));",
          "5345:   MG_MEMORY_BARRIER();",
          "5348: size_t mg_queue_book(struct mg_queue *q, char **buf, size_t len) {",
          "5349:   size_t space = 0, hs = sizeof(uint32_t) * 2;  // *2 is for the 0 marker",
          "5350:   if (q->head >= q->tail && q->head + len + hs <= q->size) {",
          "5351:     space = q->size - q->head - hs;  // There is enough space",
          "5352:   } else if (q->head >= q->tail && q->tail > hs) {",
          "5353:     mg_queue_write_len(q, 0);  // Not enough space ahead",
          "5354:     q->head = 0;               // Wrap head to the beginning",
          "5355:   }",
          "5356:   if (q->head + hs + len < q->tail) space = q->tail - q->head - hs;",
          "5357:   if (buf != NULL) *buf = q->buf + q->head + sizeof(uint32_t);",
          "5358:   return space;",
          "5361: size_t mg_queue_next(struct mg_queue *q, char **buf) {",
          "5362:   size_t len = 0;",
          "5363:   if (q->tail != q->head) {",
          "5364:     len = mg_queue_read_len(q);",
          "5365:     if (len == 0) {  // Zero (head wrapped) ?",
          "5366:       q->tail = 0;   // Reset tail to the start",
          "5367:       if (q->head > q->tail) len = mg_queue_read_len(q);  // Read again",
          "5368:     }",
          "5370:   if (buf != NULL) *buf = q->buf + q->tail + sizeof(uint32_t);",
          "5371:   assert(q->tail + len <= q->size);",
          "5372:   return len;",
          "5375: void mg_queue_add(struct mg_queue *q, size_t len) {",
          "5376:   assert(len > 0);",
          "5377:   mg_queue_write_len(q, len);",
          "5378:   assert(q->head + sizeof(uint32_t) * 2 + len <= q->size);",
          "5379:   q->head += len + sizeof(uint32_t);",
          "5382: void mg_queue_del(struct mg_queue *q, size_t len) {",
          "5383:   q->tail += len + sizeof(uint32_t);",
          "5384:   assert(q->tail + sizeof(uint32_t) <= q->size);",
          "5387: #ifdef MG_ENABLE_LINES",
          "5388: #line 1 \"src/rpc.c\"",
          "5389: #endif",
          "5393: void mg_rpc_add(struct mg_rpc **head, struct mg_str method,",
          "5394:                 void (*fn)(struct mg_rpc_req *), void *fn_data) {",
          "5395:   struct mg_rpc *rpc = (struct mg_rpc *) calloc(1, sizeof(*rpc));",
          "5396:   if (rpc != NULL) {",
          "5397:     rpc->method = mg_strdup(method), rpc->fn = fn, rpc->fn_data = fn_data;",
          "5398:     rpc->next = *head, *head = rpc;",
          "5399:   }",
          "5402: void mg_rpc_del(struct mg_rpc **head, void (*fn)(struct mg_rpc_req *)) {",
          "5403:   struct mg_rpc *r;",
          "5404:   while ((r = *head) != NULL) {",
          "5405:     if (r->fn == fn || fn == NULL) {",
          "5407:       free((void *) r->method.ptr);",
          "5408:       free(r);",
          "5409:     } else {",
          "5410:       head = &(*head)->next;",
          "5411:     }",
          "5415: static void mg_rpc_call(struct mg_rpc_req *r, struct mg_str method) {",
          "5416:   struct mg_rpc *h = r->head == NULL ? NULL : *r->head;",
          "5417:   while (h != NULL && !mg_match(method, h->method, NULL)) h = h->next;",
          "5418:   if (h != NULL) {",
          "5419:     r->rpc = h;",
          "5420:     h->fn(r);",
          "5422:     mg_rpc_err(r, -32601, \"\\\"%.*s not found\\\"\", (int) method.len, method.ptr);",
          "5426: void mg_rpc_process(struct mg_rpc_req *r) {",
          "5427:   int len, off = mg_json_get(r->frame, \"$.method\", &len);",
          "5428:   if (off > 0 && r->frame.ptr[off] == '\"') {",
          "5429:     struct mg_str method = mg_str_n(&r->frame.ptr[off + 1], (size_t) len - 2);",
          "5430:     mg_rpc_call(r, method);",
          "5431:   } else if ((off = mg_json_get(r->frame, \"$.result\", &len)) > 0 ||",
          "5432:              (off = mg_json_get(r->frame, \"$.error\", &len)) > 0) {",
          "5433:     mg_rpc_call(r, mg_str(\"\"));  // JSON response! call \"\" method handler",
          "5434:   } else {",
          "5435:     mg_rpc_err(r, -32700, \"%m\", mg_print_esc, (int) r->frame.len,",
          "5436:                r->frame.ptr);  // Invalid",
          "5437:   }",
          "5438: }",
          "5440: void mg_rpc_vok(struct mg_rpc_req *r, const char *fmt, va_list *ap) {",
          "5441:   int len, off = mg_json_get(r->frame, \"$.id\", &len);",
          "5442:   if (off > 0) {",
          "5443:     mg_xprintf(r->pfn, r->pfn_data, \"{%m:%.*s,%m:\", mg_print_esc, 0, \"id\", len,",
          "5444:                &r->frame.ptr[off], mg_print_esc, 0, \"result\");",
          "5445:     mg_vxprintf(r->pfn, r->pfn_data, fmt == NULL ? \"null\" : fmt, ap);",
          "5446:     mg_xprintf(r->pfn, r->pfn_data, \"}\");",
          "5447:   }",
          "5448: }",
          "5450: void mg_rpc_ok(struct mg_rpc_req *r, const char *fmt, ...) {",
          "5451:   va_list ap;",
          "5452:   va_start(ap, fmt);",
          "5453:   mg_rpc_vok(r, fmt, &ap);",
          "5454:   va_end(ap);",
          "5455: }",
          "5457: void mg_rpc_verr(struct mg_rpc_req *r, int code, const char *fmt, va_list *ap) {",
          "5458:   int len, off = mg_json_get(r->frame, \"$.id\", &len);",
          "5459:   mg_xprintf(r->pfn, r->pfn_data, \"{\");",
          "5460:   if (off > 0) {",
          "5461:     mg_xprintf(r->pfn, r->pfn_data, \"%m:%.*s,\", mg_print_esc, 0, \"id\", len,",
          "5462:                &r->frame.ptr[off]);",
          "5463:   }",
          "5464:   mg_xprintf(r->pfn, r->pfn_data, \"%m:{%m:%d,%m:\", mg_print_esc, 0, \"error\",",
          "5465:              mg_print_esc, 0, \"code\", code, mg_print_esc, 0, \"message\");",
          "5466:   mg_vxprintf(r->pfn, r->pfn_data, fmt == NULL ? \"null\" : fmt, ap);",
          "5467:   mg_xprintf(r->pfn, r->pfn_data, \"}}\");",
          "5470: void mg_rpc_err(struct mg_rpc_req *r, int code, const char *fmt, ...) {",
          "5471:   va_list ap;",
          "5472:   va_start(ap, fmt);",
          "5473:   mg_rpc_verr(r, code, fmt, &ap);",
          "5474:   va_end(ap);",
          "5477: static size_t print_methods(mg_pfn_t pfn, void *pfn_data, va_list *ap) {",
          "5478:   struct mg_rpc *h, **head = (struct mg_rpc **) va_arg(*ap, void **);",
          "5479:   size_t len = 0;",
          "5480:   for (h = *head; h != NULL; h = h->next) {",
          "5481:     if (h->method.len == 0) continue;  // Ignore response handler",
          "5482:     len += mg_xprintf(pfn, pfn_data, \"%s%m\", h == *head ? \"\" : \",\",",
          "5483:                       mg_print_esc, (int) h->method.len, h->method.ptr);",
          "5484:   }",
          "5485:   return len;",
          "5488: void mg_rpc_list(struct mg_rpc_req *r) {",
          "5489:   mg_rpc_ok(r, \"[%M]\", print_methods, r->head);",
          "5493: #line 1 \"src/sha1.c\"",
          "5500: union char64long16 {",
          "5501:   unsigned char c[64];",
          "5502:   uint32_t l[16];",
          "5505: #define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))",
          "5507: static uint32_t blk0(union char64long16 *block, int i) {",
          "5508:   if (MG_BIG_ENDIAN) {",
          "5510:     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |",
          "5511:                   (rol(block->l[i], 8) & 0x00FF00FF);",
          "5513:   return block->l[i];",
          "5517: #undef blk",
          "5518: #undef R0",
          "5519: #undef R1",
          "5520: #undef R2",
          "5521: #undef R3",
          "5522: #undef R4",
          "5524: #define blk(i)                                                               \\",
          "5525:   (block->l[i & 15] = rol(block->l[(i + 13) & 15] ^ block->l[(i + 8) & 15] ^ \\",
          "5526:                               block->l[(i + 2) & 15] ^ block->l[i & 15],     \\",
          "5527:                           1))",
          "5528: #define R0(v, w, x, y, z, i)                                          \\",
          "5529:   z += ((w & (x ^ y)) ^ y) + blk0(block, i) + 0x5A827999 + rol(v, 5); \\",
          "5530:   w = rol(w, 30);",
          "5531: #define R1(v, w, x, y, z, i)                                  \\",
          "5532:   z += ((w & (x ^ y)) ^ y) + blk(i) + 0x5A827999 + rol(v, 5); \\",
          "5533:   w = rol(w, 30);",
          "5534: #define R2(v, w, x, y, z, i)                          \\",
          "5535:   z += (w ^ x ^ y) + blk(i) + 0x6ED9EBA1 + rol(v, 5); \\",
          "5536:   w = rol(w, 30);",
          "5537: #define R3(v, w, x, y, z, i)                                        \\",
          "5538:   z += (((w | x) & y) | (w & x)) + blk(i) + 0x8F1BBCDC + rol(v, 5); \\",
          "5539:   w = rol(w, 30);",
          "5540: #define R4(v, w, x, y, z, i)                          \\",
          "5541:   z += (w ^ x ^ y) + blk(i) + 0xCA62C1D6 + rol(v, 5); \\",
          "5542:   w = rol(w, 30);",
          "5544: static void mg_sha1_transform(uint32_t state[5],",
          "5545:                               const unsigned char *buffer) {",
          "5546:   uint32_t a, b, c, d, e;",
          "5547:   union char64long16 block[1];",
          "5549:   memcpy(block, buffer, 64);",
          "5550:   a = state[0];",
          "5551:   b = state[1];",
          "5552:   c = state[2];",
          "5553:   d = state[3];",
          "5554:   e = state[4];",
          "5555:   R0(a, b, c, d, e, 0);",
          "5556:   R0(e, a, b, c, d, 1);",
          "5557:   R0(d, e, a, b, c, 2);",
          "5558:   R0(c, d, e, a, b, 3);",
          "5559:   R0(b, c, d, e, a, 4);",
          "5560:   R0(a, b, c, d, e, 5);",
          "5561:   R0(e, a, b, c, d, 6);",
          "5562:   R0(d, e, a, b, c, 7);",
          "5563:   R0(c, d, e, a, b, 8);",
          "5564:   R0(b, c, d, e, a, 9);",
          "5565:   R0(a, b, c, d, e, 10);",
          "5566:   R0(e, a, b, c, d, 11);",
          "5567:   R0(d, e, a, b, c, 12);",
          "5568:   R0(c, d, e, a, b, 13);",
          "5569:   R0(b, c, d, e, a, 14);",
          "5570:   R0(a, b, c, d, e, 15);",
          "5571:   R1(e, a, b, c, d, 16);",
          "5572:   R1(d, e, a, b, c, 17);",
          "5573:   R1(c, d, e, a, b, 18);",
          "5574:   R1(b, c, d, e, a, 19);",
          "5575:   R2(a, b, c, d, e, 20);",
          "5576:   R2(e, a, b, c, d, 21);",
          "5577:   R2(d, e, a, b, c, 22);",
          "5578:   R2(c, d, e, a, b, 23);",
          "5579:   R2(b, c, d, e, a, 24);",
          "5580:   R2(a, b, c, d, e, 25);",
          "5581:   R2(e, a, b, c, d, 26);",
          "5582:   R2(d, e, a, b, c, 27);",
          "5583:   R2(c, d, e, a, b, 28);",
          "5584:   R2(b, c, d, e, a, 29);",
          "5585:   R2(a, b, c, d, e, 30);",
          "5586:   R2(e, a, b, c, d, 31);",
          "5587:   R2(d, e, a, b, c, 32);",
          "5588:   R2(c, d, e, a, b, 33);",
          "5589:   R2(b, c, d, e, a, 34);",
          "5590:   R2(a, b, c, d, e, 35);",
          "5591:   R2(e, a, b, c, d, 36);",
          "5592:   R2(d, e, a, b, c, 37);",
          "5593:   R2(c, d, e, a, b, 38);",
          "5594:   R2(b, c, d, e, a, 39);",
          "5595:   R3(a, b, c, d, e, 40);",
          "5596:   R3(e, a, b, c, d, 41);",
          "5597:   R3(d, e, a, b, c, 42);",
          "5598:   R3(c, d, e, a, b, 43);",
          "5599:   R3(b, c, d, e, a, 44);",
          "5600:   R3(a, b, c, d, e, 45);",
          "5601:   R3(e, a, b, c, d, 46);",
          "5602:   R3(d, e, a, b, c, 47);",
          "5603:   R3(c, d, e, a, b, 48);",
          "5604:   R3(b, c, d, e, a, 49);",
          "5605:   R3(a, b, c, d, e, 50);",
          "5606:   R3(e, a, b, c, d, 51);",
          "5607:   R3(d, e, a, b, c, 52);",
          "5608:   R3(c, d, e, a, b, 53);",
          "5609:   R3(b, c, d, e, a, 54);",
          "5610:   R3(a, b, c, d, e, 55);",
          "5611:   R3(e, a, b, c, d, 56);",
          "5612:   R3(d, e, a, b, c, 57);",
          "5613:   R3(c, d, e, a, b, 58);",
          "5614:   R3(b, c, d, e, a, 59);",
          "5615:   R4(a, b, c, d, e, 60);",
          "5616:   R4(e, a, b, c, d, 61);",
          "5617:   R4(d, e, a, b, c, 62);",
          "5618:   R4(c, d, e, a, b, 63);",
          "5619:   R4(b, c, d, e, a, 64);",
          "5620:   R4(a, b, c, d, e, 65);",
          "5621:   R4(e, a, b, c, d, 66);",
          "5622:   R4(d, e, a, b, c, 67);",
          "5623:   R4(c, d, e, a, b, 68);",
          "5624:   R4(b, c, d, e, a, 69);",
          "5625:   R4(a, b, c, d, e, 70);",
          "5626:   R4(e, a, b, c, d, 71);",
          "5627:   R4(d, e, a, b, c, 72);",
          "5628:   R4(c, d, e, a, b, 73);",
          "5629:   R4(b, c, d, e, a, 74);",
          "5630:   R4(a, b, c, d, e, 75);",
          "5631:   R4(e, a, b, c, d, 76);",
          "5632:   R4(d, e, a, b, c, 77);",
          "5633:   R4(c, d, e, a, b, 78);",
          "5634:   R4(b, c, d, e, a, 79);",
          "5635:   state[0] += a;",
          "5636:   state[1] += b;",
          "5637:   state[2] += c;",
          "5638:   state[3] += d;",
          "5639:   state[4] += e;",
          "5642:   memset(block, 0, sizeof(block));",
          "5643:   a = b = c = d = e = 0;",
          "5644:   (void) a;",
          "5645:   (void) b;",
          "5646:   (void) c;",
          "5647:   (void) d;",
          "5648:   (void) e;",
          "5651: void mg_sha1_init(mg_sha1_ctx *context) {",
          "5652:   context->state[0] = 0x67452301;",
          "5653:   context->state[1] = 0xEFCDAB89;",
          "5654:   context->state[2] = 0x98BADCFE;",
          "5655:   context->state[3] = 0x10325476;",
          "5656:   context->state[4] = 0xC3D2E1F0;",
          "5657:   context->count[0] = context->count[1] = 0;",
          "5660: void mg_sha1_update(mg_sha1_ctx *context, const unsigned char *data,",
          "5661:                     size_t len) {",
          "5662:   size_t i, j;",
          "5664:   j = context->count[0];",
          "5665:   if ((context->count[0] += (uint32_t) len << 3) < j) context->count[1]++;",
          "5666:   context->count[1] += (uint32_t) (len >> 29);",
          "5667:   j = (j >> 3) & 63;",
          "5668:   if ((j + len) > 63) {",
          "5669:     memcpy(&context->buffer[j], data, (i = 64 - j));",
          "5670:     mg_sha1_transform(context->state, context->buffer);",
          "5671:     for (; i + 63 < len; i += 64) {",
          "5672:       mg_sha1_transform(context->state, &data[i]);",
          "5673:     }",
          "5674:     j = 0;",
          "5675:   } else",
          "5676:     i = 0;",
          "5677:   memcpy(&context->buffer[j], &data[i], len - i);",
          "5680: void mg_sha1_final(unsigned char digest[20], mg_sha1_ctx *context) {",
          "5681:   unsigned i;",
          "5682:   unsigned char finalcount[8], c;",
          "5684:   for (i = 0; i < 8; i++) {",
          "5685:     finalcount[i] = (unsigned char) ((context->count[(i >= 4 ? 0 : 1)] >>",
          "5686:                                       ((3 - (i & 3)) * 8)) &",
          "5687:                                      255);",
          "5688:   }",
          "5689:   c = 0200;",
          "5690:   mg_sha1_update(context, &c, 1);",
          "5691:   while ((context->count[0] & 504) != 448) {",
          "5692:     c = 0000;",
          "5693:     mg_sha1_update(context, &c, 1);",
          "5694:   }",
          "5695:   mg_sha1_update(context, finalcount, 8);",
          "5696:   for (i = 0; i < 20; i++) {",
          "5697:     digest[i] =",
          "5698:         (unsigned char) ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);",
          "5699:   }",
          "5700:   memset(context, '\\0', sizeof(*context));",
          "5701:   memset(&finalcount, '\\0', sizeof(finalcount));",
          "5705: #line 1 \"src/sntp.c\"",
          "5713: #define SNTP_TIME_OFFSET 2208988800U  // (1970 - 1900) in seconds",
          "5714: #define SNTP_MAX_FRAC 4294967295.0    // 2 ** 32 - 1",
          "5716: static int64_t gettimestamp(const uint32_t *data) {",
          "5717:   uint32_t sec = mg_ntohl(data[0]), frac = mg_ntohl(data[1]);",
          "5718:   if (sec) sec -= SNTP_TIME_OFFSET;",
          "5719:   return ((int64_t) sec) * 1000 + (int64_t) (frac / SNTP_MAX_FRAC * 1000.0);",
          "5722: int64_t mg_sntp_parse(const unsigned char *buf, size_t len) {",
          "5723:   int64_t res = -1;",
          "5724:   int mode = len > 0 ? buf[0] & 7 : 0;",
          "5725:   int version = len > 0 ? (buf[0] >> 3) & 7 : 0;",
          "5726:   if (len < 48) {",
          "5727:     MG_ERROR((\"%s\", \"corrupt packet\"));",
          "5728:   } else if (mode != 4 && mode != 5) {",
          "5729:     MG_ERROR((\"%s\", \"not a server reply\"));",
          "5730:   } else if (buf[1] == 0) {",
          "5731:     MG_ERROR((\"%s\", \"server sent a kiss of death\"));",
          "5732:   } else if (version == 4 || version == 3) {",
          "5734:     int64_t t0 = gettimestamp((uint32_t *) &buf[24]);",
          "5735:     int64_t t1 = gettimestamp((uint32_t *) &buf[32]);",
          "5736:     int64_t t2 = gettimestamp((uint32_t *) &buf[40]);",
          "5737:     int64_t t3 = (int64_t) mg_millis();",
          "5738:     int64_t delta = (t3 - t0) - (t2 - t1);",
          "5739:     MG_VERBOSE((\"%lld %lld %lld %lld delta:%lld\", t0, t1, t2, t3, delta));",
          "5740:     res = t2 + delta / 2;",
          "5741:   } else {",
          "5742:     MG_ERROR((\"unexpected version: %d\", version));",
          "5744:   return res;",
          "5747: static void sntp_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {",
          "5748:   if (ev == MG_EV_READ) {",
          "5749:     int64_t milliseconds = mg_sntp_parse(c->recv.buf, c->recv.len);",
          "5750:     if (milliseconds > 0) {",
          "5751:       MG_INFO((\"%lu got time: %lld ms from epoch\", c->id, milliseconds));",
          "5752:       mg_call(c, MG_EV_SNTP_TIME, (uint64_t *) &milliseconds);",
          "5753:       MG_VERBOSE((\"%u.%u\", (unsigned) (milliseconds / 1000),",
          "5754:                   (unsigned) (milliseconds % 1000)));",
          "5755:     }",
          "5756:     mg_iobuf_del(&c->recv, 0, c->recv.len);  // Free receive buffer",
          "5757:   } else if (ev == MG_EV_CONNECT) {",
          "5758:     mg_sntp_request(c);",
          "5759:   } else if (ev == MG_EV_CLOSE) {",
          "5760:   }",
          "5761:   (void) fnd;",
          "5762:   (void) evd;",
          "5765: void mg_sntp_request(struct mg_connection *c) {",
          "5766:   if (c->is_resolving) {",
          "5767:     MG_ERROR((\"%lu wait until resolved\", c->id));",
          "5768:   } else {",
          "5769:     int64_t now = (int64_t) mg_millis();  // Use int64_t, for vc98",
          "5770:     uint8_t buf[48] = {0};",
          "5771:     uint32_t *t = (uint32_t *) &buf[40];",
          "5772:     double frac = ((double) (now % 1000)) / 1000.0 * SNTP_MAX_FRAC;",
          "5773:     buf[0] = (0 << 6) | (4 << 3) | 3;",
          "5774:     t[0] = mg_htonl((uint32_t) (now / 1000) + SNTP_TIME_OFFSET);",
          "5775:     t[1] = mg_htonl((uint32_t) frac);",
          "5776:     mg_send(c, buf, sizeof(buf));",
          "5777:   }",
          "5780: struct mg_connection *mg_sntp_connect(struct mg_mgr *mgr, const char *url,",
          "5781:                                       mg_event_handler_t fn, void *fnd) {",
          "5782:   struct mg_connection *c = NULL;",
          "5783:   if (url == NULL) url = \"udp://time.google.com:123\";",
          "5784:   if ((c = mg_connect(mgr, url, fn, fnd)) != NULL) c->pfn = sntp_cb;",
          "5785:   return c;",
          "5788: #ifdef MG_ENABLE_LINES",
          "5789: #line 1 \"src/sock.c\"",
          "5790: #endif",
          "5802: #if MG_ENABLE_SOCKET",
          "5804: #ifndef closesocket",
          "5805: #define closesocket(x) close(x)",
          "5806: #endif",
          "5808: #define FD(c_) ((MG_SOCKET_TYPE) (size_t) (c_)->fd)",
          "5809: #define S2PTR(s_) ((void *) (size_t) (s_))",
          "5811: #ifndef MSG_NONBLOCKING",
          "5812: #define MSG_NONBLOCKING 0",
          "5813: #endif",
          "5815: #ifndef AF_INET6",
          "5816: #define AF_INET6 10",
          "5817: #endif",
          "5819: #ifndef MG_SOCK_ERR",
          "5820: #define MG_SOCK_ERR(errcode) ((errcode) < 0 ? errno : 0)",
          "5823: #ifndef MG_SOCK_INTR",
          "5824: #define MG_SOCK_INTR(fd) (fd == MG_INVALID_SOCKET && MG_SOCK_ERR(-1) == EINTR)",
          "5825: #endif",
          "5827: #ifndef MG_SOCK_PENDING",
          "5828: #define MG_SOCK_PENDING(errcode) \\",
          "5829:   (((errcode) < 0) && (errno == EINPROGRESS || errno == EWOULDBLOCK))",
          "5830: #endif",
          "5832: #ifndef MG_SOCK_RESET",
          "5833: #define MG_SOCK_RESET(errcode) \\",
          "5834:   (((errcode) < 0) && (errno == EPIPE || errno == ECONNRESET))",
          "5837: union usa {",
          "5838:   struct sockaddr sa;",
          "5839:   struct sockaddr_in sin;",
          "5840: #if MG_ENABLE_IPV6",
          "5841:   struct sockaddr_in6 sin6;",
          "5842: #endif",
          "5843: };",
          "5845: static socklen_t tousa(struct mg_addr *a, union usa *usa) {",
          "5846:   socklen_t len = sizeof(usa->sin);",
          "5847:   memset(usa, 0, sizeof(*usa));",
          "5848:   usa->sin.sin_family = AF_INET;",
          "5849:   usa->sin.sin_port = a->port;",
          "5850:   memcpy(&usa->sin.sin_addr, a->ip, sizeof(uint32_t));",
          "5851: #if MG_ENABLE_IPV6",
          "5852:   if (a->is_ip6) {",
          "5853:     usa->sin.sin_family = AF_INET6;",
          "5854:     usa->sin6.sin6_port = a->port;",
          "5855:     memcpy(&usa->sin6.sin6_addr, a->ip, sizeof(a->ip));",
          "5856:     len = sizeof(usa->sin6);",
          "5857:   }",
          "5858: #endif",
          "5859:   return len;",
          "5862: static void tomgaddr(union usa *usa, struct mg_addr *a, bool is_ip6) {",
          "5863:   a->is_ip6 = is_ip6;",
          "5864:   a->port = usa->sin.sin_port;",
          "5865:   memcpy(&a->ip, &usa->sin.sin_addr, sizeof(uint32_t));",
          "5866: #if MG_ENABLE_IPV6",
          "5867:   if (is_ip6) {",
          "5868:     memcpy(a->ip, &usa->sin6.sin6_addr, sizeof(a->ip));",
          "5869:     a->port = usa->sin6.sin6_port;",
          "5870:   }",
          "5871: #endif",
          "5874: static void setlocaddr(MG_SOCKET_TYPE fd, struct mg_addr *addr) {",
          "5875:   union usa usa;",
          "5876:   socklen_t n = sizeof(usa);",
          "5877:   if (getsockname(fd, &usa.sa, &n) == 0) {",
          "5878:     tomgaddr(&usa, addr, n != sizeof(usa.sin));",
          "5879:   }",
          "5882: static void iolog(struct mg_connection *c, char *buf, long n, bool r) {",
          "5883:   if (n == MG_IO_WAIT) {",
          "5885:   } else if (n <= 0) {",
          "5886:     c->is_closing = 1;  // Termination. Don't call mg_error(): #1529",
          "5887:   } else if (n > 0) {",
          "5888:     if (c->is_hexdumping) {",
          "5889:       union usa usa;",
          "5890:       socklen_t slen = sizeof(usa.sin);",
          "5891:       if (getsockname(FD(c), &usa.sa, &slen) < 0) (void) 0;  // Ignore result",
          "5892:       MG_INFO((\"\\n-- %lu %M %s %M %ld\", c->id, mg_print_ip_port, &c->loc,",
          "5893:                r ? \"<-\" : \"->\", mg_print_ip_port, &c->rem, n));",
          "5895:       mg_hexdump(buf, (size_t) n);",
          "5896:     }",
          "5897:     if (r) {",
          "5898:       c->recv.len += (size_t) n;",
          "5899:       mg_call(c, MG_EV_READ, &n);",
          "5900:     } else {",
          "5901:       mg_iobuf_del(&c->send, 0, (size_t) n);",
          "5903:       if (c->send.len == 0) {",
          "5904:         MG_EPOLL_MOD(c, 0);",
          "5905:       }",
          "5906:       mg_call(c, MG_EV_WRITE, &n);",
          "5911: long mg_io_send(struct mg_connection *c, const void *buf, size_t len) {",
          "5912:   long n;",
          "5913:   if (c->is_udp) {",
          "5914:     union usa usa;",
          "5915:     socklen_t slen = tousa(&c->rem, &usa);",
          "5916:     n = sendto(FD(c), (char *) buf, len, 0, &usa.sa, slen);",
          "5917:     if (n > 0) setlocaddr(FD(c), &c->loc);",
          "5918:   } else {",
          "5919:     n = send(FD(c), (char *) buf, len, MSG_NONBLOCKING);",
          "5920:   }",
          "5921:   if (MG_SOCK_PENDING(n)) return MG_IO_WAIT;",
          "5922:   if (MG_SOCK_RESET(n)) return MG_IO_RESET;",
          "5923:   if (n <= 0) return MG_IO_ERR;",
          "5924:   return n;",
          "5927: bool mg_send(struct mg_connection *c, const void *buf, size_t len) {",
          "5928:   if (c->is_udp) {",
          "5929:     long n = mg_io_send(c, buf, len);",
          "5930:     MG_DEBUG((\"%lu %ld %d:%d %ld err %d\", c->id, c->fd, (int) c->send.len,",
          "5931:               (int) c->recv.len, n, MG_SOCK_ERR(n)));",
          "5932:     iolog(c, (char *) buf, n, false);",
          "5933:     return n > 0;",
          "5934:   } else {",
          "5935:     return mg_iobuf_add(&c->send, c->send.len, buf, len);",
          "5936:   }",
          "5939: static void mg_set_non_blocking_mode(MG_SOCKET_TYPE fd) {",
          "5940: #if defined(MG_CUSTOM_NONBLOCK)",
          "5941:   MG_CUSTOM_NONBLOCK(fd);",
          "5942: #elif MG_ARCH == MG_ARCH_WIN32 && MG_ENABLE_WINSOCK",
          "5943:   unsigned long on = 1;",
          "5944:   ioctlsocket(fd, FIONBIO, &on);",
          "5945: #elif MG_ENABLE_RL",
          "5946:   unsigned long on = 1;",
          "5947:   ioctlsocket(fd, FIONBIO, &on);",
          "5948: #elif MG_ENABLE_FREERTOS_TCP",
          "5949:   const BaseType_t off = 0;",
          "5950:   if (setsockopt(fd, 0, FREERTOS_SO_RCVTIMEO, &off, sizeof(off)) != 0) (void) 0;",
          "5951:   if (setsockopt(fd, 0, FREERTOS_SO_SNDTIMEO, &off, sizeof(off)) != 0) (void) 0;",
          "5952: #elif MG_ENABLE_LWIP",
          "5953:   lwip_fcntl(fd, F_SETFL, O_NONBLOCK);",
          "5954: #elif MG_ARCH == MG_ARCH_AZURERTOS",
          "5955:   fcntl(fd, F_SETFL, O_NONBLOCK);",
          "5956: #elif MG_ARCH == MG_ARCH_TIRTOS",
          "5957:   int val = 0;",
          "5958:   setsockopt(fd, SOL_SOCKET, SO_BLOCKING, &val, sizeof(val));",
          "5960:   int sz = sizeof(val);",
          "5961:   getsockopt(fd, SOL_SOCKET, SO_SNDBUF, &val, &sz);",
          "5962:   val /= 2;  // set send low-water mark at half send buffer size",
          "5963:   setsockopt(fd, SOL_SOCKET, SO_SNDLOWAT, &val, sizeof(val));",
          "5964: #else",
          "5965:   fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);  // Non-blocking mode",
          "5966:   fcntl(fd, F_SETFD, FD_CLOEXEC);                          // Set close-on-exec",
          "5968: }",
          "5970: bool mg_open_listener(struct mg_connection *c, const char *url) {",
          "5971:   MG_SOCKET_TYPE fd = MG_INVALID_SOCKET;",
          "5972:   bool success = false;",
          "5973:   c->loc.port = mg_htons(mg_url_port(url));",
          "5974:   if (!mg_aton(mg_url_host(url), &c->loc)) {",
          "5975:     MG_ERROR((\"invalid listening URL: %s\", url));",
          "5976:   } else {",
          "5977:     union usa usa;",
          "5978:     socklen_t slen = tousa(&c->loc, &usa);",
          "5979:     int rc, on = 1, af = c->loc.is_ip6 ? AF_INET6 : AF_INET;",
          "5980:     int type = strncmp(url, \"udp:\", 4) == 0 ? SOCK_DGRAM : SOCK_STREAM;",
          "5981:     int proto = type == SOCK_DGRAM ? IPPROTO_UDP : IPPROTO_TCP;",
          "5982:     (void) on;",
          "5984:     if ((fd = socket(af, type, proto)) == MG_INVALID_SOCKET) {",
          "5985:       MG_ERROR((\"socket: %d\", MG_SOCK_ERR(-1)));",
          "5986: #if defined(SO_EXCLUSIVEADDRUSE)",
          "5987:     } else if ((rc = setsockopt(fd, SOL_SOCKET, SO_EXCLUSIVEADDRUSE,",
          "5988:                                 (char *) &on, sizeof(on))) != 0) {",
          "5990:       MG_ERROR((\"setsockopt(SO_EXCLUSIVEADDRUSE): %d %d\", on, MG_SOCK_ERR(rc)));",
          "5991: #elif defined(SO_REUSEADDR) && (!defined(LWIP_SOCKET) || SO_REUSE)",
          "5992:     } else if ((rc = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on,",
          "5993:                                 sizeof(on))) != 0) {",
          "6003:       MG_ERROR((\"setsockopt(SO_REUSEADDR): %d\", MG_SOCK_ERR(rc)));",
          "6004: #endif",
          "6005: #if MG_IPV6_V6ONLY",
          "6007:     } else if (c->loc.is_ip6 &&",
          "6008:                (rc = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &on,",
          "6009:                                 sizeof(on))) != 0) {",
          "6011:       MG_ERROR((\"setsockopt(IPV6_V6ONLY): %d\", MG_SOCK_ERR(rc)));",
          "6012: #endif",
          "6013:     } else if ((rc = bind(fd, &usa.sa, slen)) != 0) {",
          "6014:       MG_ERROR((\"bind: %d\", MG_SOCK_ERR(rc)));",
          "6015:     } else if ((type == SOCK_STREAM &&",
          "6016:                 (rc = listen(fd, MG_SOCK_LISTEN_BACKLOG_SIZE)) != 0)) {",
          "6019:       MG_ERROR((\"listen: %d\", MG_SOCK_ERR(rc)));",
          "6021:       setlocaddr(fd, &c->loc);",
          "6022:       mg_set_non_blocking_mode(fd);",
          "6023:       c->fd = S2PTR(fd);",
          "6024:       MG_EPOLL_ADD(c);",
          "6025:       success = true;",
          "6028:   if (success == false && fd != MG_INVALID_SOCKET) closesocket(fd);",
          "6029:   return success;",
          "6032: long mg_io_recv(struct mg_connection *c, void *buf, size_t len) {",
          "6033:   long n = 0;",
          "6034:   if (c->is_udp) {",
          "6035:     union usa usa;",
          "6036:     socklen_t slen = tousa(&c->rem, &usa);",
          "6037:     n = recvfrom(FD(c), (char *) buf, len, 0, &usa.sa, &slen);",
          "6038:     if (n > 0) tomgaddr(&usa, &c->rem, slen != sizeof(usa.sin));",
          "6040:     n = recv(FD(c), (char *) buf, len, MSG_NONBLOCKING);",
          "6042:   if (MG_SOCK_PENDING(n)) return MG_IO_WAIT;",
          "6043:   if (MG_SOCK_RESET(n)) return MG_IO_RESET;",
          "6044:   if (n <= 0) return MG_IO_ERR;",
          "6045:   return n;",
          "6050: static void read_conn(struct mg_connection *c) {",
          "6051:   long n = -1;",
          "6052:   if (c->recv.len >= MG_MAX_RECV_SIZE) {",
          "6053:     mg_error(c, \"max_recv_buf_size reached\");",
          "6054:   } else if (c->recv.size <= c->recv.len &&",
          "6055:              !mg_iobuf_resize(&c->recv, c->recv.size + MG_IO_SIZE)) {",
          "6056:     mg_error(c, \"oom\");",
          "6058:     char *buf = (char *) &c->recv.buf[c->recv.len];",
          "6059:     size_t len = c->recv.size - c->recv.len;",
          "6060:     n = c->is_tls ? mg_tls_recv(c, buf, len) : mg_io_recv(c, buf, len);",
          "6061:     MG_DEBUG((\"%lu %ld snd %ld/%ld rcv %ld/%ld n=%ld err=%d\", c->id, c->fd,",
          "6062:               (long) c->send.len, (long) c->send.size, (long) c->recv.len,",
          "6063:               (long) c->recv.size, n, MG_SOCK_ERR(n)));",
          "6064:     iolog(c, buf, n, true);",
          "6068: static void write_conn(struct mg_connection *c) {",
          "6069:   char *buf = (char *) c->send.buf;",
          "6070:   size_t len = c->send.len;",
          "6071:   long n = c->is_tls ? mg_tls_send(c, buf, len) : mg_io_send(c, buf, len);",
          "6072:   MG_DEBUG((\"%lu %ld snd %ld/%ld rcv %ld/%ld n=%ld err=%d\", c->id, c->fd,",
          "6073:             (long) c->send.len, (long) c->send.size, (long) c->recv.len,",
          "6074:             (long) c->recv.size, n, MG_SOCK_ERR(n)));",
          "6075:   iolog(c, buf, n, false);",
          "6078: static void close_conn(struct mg_connection *c) {",
          "6079:   if (FD(c) != MG_INVALID_SOCKET) {",
          "6080: #if MG_ENABLE_EPOLL",
          "6081:     epoll_ctl(c->mgr->epoll_fd, EPOLL_CTL_DEL, FD(c), NULL);",
          "6082: #endif",
          "6083:     closesocket(FD(c));",
          "6084: #if MG_ENABLE_FREERTOS_TCP",
          "6085:     FreeRTOS_FD_CLR(c->fd, c->mgr->ss, eSELECT_ALL);",
          "6086: #endif",
          "6087:   }",
          "6088:   mg_close_conn(c);",
          "6091: static void connect_conn(struct mg_connection *c) {",
          "6092:   union usa usa;",
          "6093:   socklen_t n = sizeof(usa);",
          "6095:   if (getpeername(FD(c), &usa.sa, &n) == 0) {",
          "6096:     c->is_connecting = 0;",
          "6097:     mg_call(c, MG_EV_CONNECT, NULL);",
          "6098:     MG_EPOLL_MOD(c, 0);",
          "6099:     if (c->is_tls_hs) mg_tls_handshake(c);",
          "6100:   } else {",
          "6101:     mg_error(c, \"socket error\");",
          "6105: static void setsockopts(struct mg_connection *c) {",
          "6106: #if MG_ENABLE_FREERTOS_TCP || MG_ARCH == MG_ARCH_AZURERTOS || \\",
          "6107:     MG_ARCH == MG_ARCH_TIRTOS",
          "6108:   (void) c;",
          "6109: #else",
          "6110:   int on = 1;",
          "6111: #if !defined(SOL_TCP)",
          "6112: #define SOL_TCP IPPROTO_TCP",
          "6113: #endif",
          "6114:   if (setsockopt(FD(c), SOL_TCP, TCP_NODELAY, (char *) &on, sizeof(on)) != 0)",
          "6115:     (void) 0;",
          "6116:   if (setsockopt(FD(c), SOL_SOCKET, SO_KEEPALIVE, (char *) &on, sizeof(on)) !=",
          "6117:       0)",
          "6118:     (void) 0;",
          "6119: #endif",
          "6122: void mg_connect_resolved(struct mg_connection *c) {",
          "6123:   int type = c->is_udp ? SOCK_DGRAM : SOCK_STREAM;",
          "6124:   int rc, af = c->rem.is_ip6 ? AF_INET6 : AF_INET;  // c->rem has resolved IP",
          "6125:   c->fd = S2PTR(socket(af, type, 0));               // Create outbound socket",
          "6126:   c->is_resolving = 0;                              // Clear resolving flag",
          "6127:   if (FD(c) == MG_INVALID_SOCKET) {",
          "6128:     mg_error(c, \"socket(): %d\", MG_SOCK_ERR(-1));",
          "6129:   } else if (c->is_udp) {",
          "6130:     MG_EPOLL_ADD(c);",
          "6131: #if MG_ARCH == MG_ARCH_TIRTOS",
          "6132:     union usa usa;  // TI-RTOS NDK requires binding to receive on UDP sockets",
          "6133:     socklen_t slen = tousa(&c->loc, &usa);",
          "6134:     if ((rc = bind(c->fd, &usa.sa, slen)) != 0)",
          "6135:       MG_ERROR((\"bind: %d\", MG_SOCK_ERR(rc)));",
          "6136: #endif",
          "6137:     mg_call(c, MG_EV_RESOLVE, NULL);",
          "6138:     mg_call(c, MG_EV_CONNECT, NULL);",
          "6139:   } else {",
          "6140:     union usa usa;",
          "6141:     socklen_t slen = tousa(&c->rem, &usa);",
          "6142:     mg_set_non_blocking_mode(FD(c));",
          "6143:     setsockopts(c);",
          "6144:     MG_EPOLL_ADD(c);",
          "6145:     mg_call(c, MG_EV_RESOLVE, NULL);",
          "6146:     rc = connect(FD(c), &usa.sa, slen);  // Attempt to connect",
          "6147:     if (rc == 0) {                       // Success",
          "6148:       mg_call(c, MG_EV_CONNECT, NULL);   // Send MG_EV_CONNECT to the user",
          "6149:     } else if (MG_SOCK_PENDING(rc)) {    // Need to wait for TCP handshake",
          "6150:       MG_DEBUG((\"%lu %ld -> %M pend\", c->id, c->fd, mg_print_ip_port, &c->rem));",
          "6151:       c->is_connecting = 1;",
          "6152:     } else {",
          "6153:       mg_error(c, \"connect: %d\", MG_SOCK_ERR(rc));",
          "6154:     }",
          "6158: static MG_SOCKET_TYPE raccept(MG_SOCKET_TYPE sock, union usa *usa,",
          "6159:                               socklen_t *len) {",
          "6160:   MG_SOCKET_TYPE fd = MG_INVALID_SOCKET;",
          "6161:   do {",
          "6162:     memset(usa, 0, sizeof(*usa));",
          "6163:     fd = accept(sock, &usa->sa, len);",
          "6164:   } while (MG_SOCK_INTR(fd));",
          "6165:   return fd;",
          "6168: static void accept_conn(struct mg_mgr *mgr, struct mg_connection *lsn) {",
          "6169:   struct mg_connection *c = NULL;",
          "6170:   union usa usa;",
          "6171:   socklen_t sa_len = sizeof(usa);",
          "6172:   MG_SOCKET_TYPE fd = raccept(FD(lsn), &usa, &sa_len);",
          "6173:   if (fd == MG_INVALID_SOCKET) {",
          "6174: #if MG_ARCH == MG_ARCH_AZURERTOS",
          "6178:     if (errno != EAGAIN)",
          "6179: #endif",
          "6180:       MG_ERROR((\"%lu accept failed, errno %d\", lsn->id, MG_SOCK_ERR(-1)));",
          "6181: #if (MG_ARCH != MG_ARCH_WIN32) && !MG_ENABLE_FREERTOS_TCP && \\",
          "6182:     (MG_ARCH != MG_ARCH_TIRTOS) && !MG_ENABLE_POLL && !MG_ENABLE_EPOLL",
          "6183:   } else if ((long) fd >= FD_SETSIZE) {",
          "6184:     MG_ERROR((\"%ld > %ld\", (long) fd, (long) FD_SETSIZE));",
          "6185:     closesocket(fd);",
          "6187:   } else if ((c = mg_alloc_conn(mgr)) == NULL) {",
          "6188:     MG_ERROR((\"%lu OOM\", lsn->id));",
          "6189:     closesocket(fd);",
          "6191:     tomgaddr(&usa, &c->rem, sa_len != sizeof(usa.sin));",
          "6192:     LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);",
          "6193:     c->fd = S2PTR(fd);",
          "6194:     MG_EPOLL_ADD(c);",
          "6195:     mg_set_non_blocking_mode(FD(c));",
          "6196:     setsockopts(c);",
          "6197:     c->is_accepted = 1;",
          "6198:     c->is_hexdumping = lsn->is_hexdumping;",
          "6199:     c->loc = lsn->loc;",
          "6200:     c->pfn = lsn->pfn;",
          "6201:     c->pfn_data = lsn->pfn_data;",
          "6202:     c->fn = lsn->fn;",
          "6203:     c->fn_data = lsn->fn_data;",
          "6204:     MG_DEBUG((\"%lu %ld accepted %M -> %M\", c->id, c->fd, mg_print_ip_port,",
          "6205:               &c->rem, mg_print_ip_port, &c->loc));",
          "6206:     mg_call(c, MG_EV_OPEN, NULL);",
          "6207:     mg_call(c, MG_EV_ACCEPT, NULL);",
          "6211: static bool can_read(const struct mg_connection *c) {",
          "6212:   return c->is_full == false;",
          "6215: static bool can_write(const struct mg_connection *c) {",
          "6216:   return c->is_connecting || (c->send.len > 0 && c->is_tls_hs == 0);",
          "6217: }",
          "6219: static bool skip_iotest(const struct mg_connection *c) {",
          "6220:   return (c->is_closing || c->is_resolving || FD(c) == MG_INVALID_SOCKET) ||",
          "6221:          (can_read(c) == false && can_write(c) == false);",
          "6224: static void mg_iotest(struct mg_mgr *mgr, int ms) {",
          "6225: #if MG_ENABLE_FREERTOS_TCP",
          "6226:   struct mg_connection *c;",
          "6227:   for (c = mgr->conns; c != NULL; c = c->next) {",
          "6228:     c->is_readable = c->is_writable = 0;",
          "6229:     if (skip_iotest(c)) continue;",
          "6230:     if (can_read(c))",
          "6231:       FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_READ | eSELECT_EXCEPT);",
          "6232:     if (can_write(c)) FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_WRITE);",
          "6233:   }",
          "6234:   FreeRTOS_select(mgr->ss, pdMS_TO_TICKS(ms));",
          "6235:   for (c = mgr->conns; c != NULL; c = c->next) {",
          "6236:     EventBits_t bits = FreeRTOS_FD_ISSET(c->fd, mgr->ss);",
          "6237:     c->is_readable = bits & (eSELECT_READ | eSELECT_EXCEPT) ? 1U : 0;",
          "6238:     c->is_writable = bits & eSELECT_WRITE ? 1U : 0;",
          "6239:     if (c->fd != MG_INVALID_SOCKET)",
          "6240:       FreeRTOS_FD_CLR(c->fd, mgr->ss,",
          "6241:                       eSELECT_READ | eSELECT_EXCEPT | eSELECT_WRITE);",
          "6242:   }",
          "6243: #elif MG_ENABLE_EPOLL",
          "6244:   size_t max = 1;",
          "6245:   for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {",
          "6246:     c->is_readable = c->is_writable = 0;",
          "6247:     if (mg_tls_pending(c) > 0) ms = 1, c->is_readable = 1;",
          "6248:     if (can_write(c)) MG_EPOLL_MOD(c, 1);",
          "6249:     max++;",
          "6250:   }",
          "6251:   struct epoll_event *evs = (struct epoll_event *) alloca(max * sizeof(evs[0]));",
          "6252:   int n = epoll_wait(mgr->epoll_fd, evs, (int) max, ms);",
          "6253:   for (int i = 0; i < n; i++) {",
          "6254:     struct mg_connection *c = (struct mg_connection *) evs[i].data.ptr;",
          "6255:     if (evs[i].events & EPOLLERR) {",
          "6256:       mg_error(c, \"socket error\");",
          "6257:     } else if (c->is_readable == 0) {",
          "6258:       bool rd = evs[i].events & (EPOLLIN | EPOLLHUP);",
          "6259:       bool wr = evs[i].events & EPOLLOUT;",
          "6260:       c->is_readable = can_read(c) && rd ? 1U : 0;",
          "6261:       c->is_writable = can_write(c) && wr ? 1U : 0;",
          "6262:     }",
          "6263:   }",
          "6264:   (void) skip_iotest;",
          "6265: #elif MG_ENABLE_POLL",
          "6266:   nfds_t n = 0;",
          "6267:   for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) n++;",
          "6268:   struct pollfd *fds = (struct pollfd *) alloca(n * sizeof(fds[0]));",
          "6269:   memset(fds, 0, n * sizeof(fds[0]));",
          "6270:   n = 0;",
          "6271:   for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {",
          "6272:     c->is_readable = c->is_writable = 0;",
          "6273:     if (skip_iotest(c)) {",
          "6275:     } else if (mg_tls_pending(c) > 0) {",
          "6276:       ms = 1;  // Don't wait if TLS is ready",
          "6277:     } else {",
          "6278:       fds[n].fd = FD(c);",
          "6279:       if (can_read(c)) fds[n].events |= POLLIN;",
          "6280:       if (can_write(c)) fds[n].events |= POLLOUT;",
          "6281:       n++;",
          "6282:     }",
          "6283:   }",
          "6286:   if (poll(fds, n, ms) < 0) {",
          "6287: #if MG_ARCH == MG_ARCH_WIN32",
          "6288:     if (n == 0) Sleep(ms);  // On Windows, poll fails if no sockets",
          "6289: #endif",
          "6290:     memset(fds, 0, n * sizeof(fds[0]));",
          "6291:   }",
          "6292:   n = 0;",
          "6293:   for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {",
          "6294:     if (skip_iotest(c)) {",
          "6296:     } else if (mg_tls_pending(c) > 0) {",
          "6297:       c->is_readable = 1;",
          "6298:     } else {",
          "6299:       if (fds[n].revents & POLLERR) {",
          "6300:         mg_error(c, \"socket error\");",
          "6301:       } else {",
          "6302:         c->is_readable =",
          "6303:             (unsigned) (fds[n].revents & (POLLIN | POLLHUP) ? 1 : 0);",
          "6304:         c->is_writable = (unsigned) (fds[n].revents & POLLOUT ? 1 : 0);",
          "6305:       }",
          "6306:       n++;",
          "6307:     }",
          "6309: #else",
          "6310:   struct timeval tv = {ms / 1000, (ms % 1000) * 1000}, tv_zero = {0, 0}, *tvp;",
          "6311:   struct mg_connection *c;",
          "6312:   fd_set rset, wset, eset;",
          "6313:   MG_SOCKET_TYPE maxfd = 0;",
          "6314:   int rc;",
          "6316:   FD_ZERO(&rset);",
          "6317:   FD_ZERO(&wset);",
          "6318:   FD_ZERO(&eset);",
          "6319:   tvp = ms < 0 ? NULL : &tv;",
          "6320:   for (c = mgr->conns; c != NULL; c = c->next) {",
          "6321:     c->is_readable = c->is_writable = 0;",
          "6322:     if (skip_iotest(c)) continue;",
          "6323:     FD_SET(FD(c), &eset);",
          "6324:     if (can_read(c)) FD_SET(FD(c), &rset);",
          "6325:     if (can_write(c)) FD_SET(FD(c), &wset);",
          "6326:     if (mg_tls_pending(c) > 0) tvp = &tv_zero;",
          "6327:     if (FD(c) > maxfd) maxfd = FD(c);",
          "6330:   if ((rc = select((int) maxfd + 1, &rset, &wset, &eset, tvp)) < 0) {",
          "6331: #if MG_ARCH == MG_ARCH_WIN32",
          "6332:     if (maxfd == 0) Sleep(ms);  // On Windows, select fails if no sockets",
          "6333: #else",
          "6334:     MG_ERROR((\"select: %d %d\", rc, MG_SOCK_ERR(rc)));",
          "6335: #endif",
          "6336:     FD_ZERO(&rset);",
          "6337:     FD_ZERO(&wset);",
          "6338:     FD_ZERO(&eset);",
          "6341:   for (c = mgr->conns; c != NULL; c = c->next) {",
          "6342:     if (FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &eset)) {",
          "6343:       mg_error(c, \"socket error\");",
          "6344:     } else {",
          "6345:       c->is_readable = FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &rset);",
          "6346:       c->is_writable = FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &wset);",
          "6347:       if (mg_tls_pending(c) > 0) c->is_readable = 1;",
          "6348:     }",
          "6349:   }",
          "6351: }",
          "6353: void mg_mgr_poll(struct mg_mgr *mgr, int ms) {",
          "6354:   struct mg_connection *c, *tmp;",
          "6355:   uint64_t now;",
          "6357:   mg_iotest(mgr, ms);",
          "6358:   now = mg_millis();",
          "6359:   mg_timer_poll(&mgr->timers, now);",
          "6361:   for (c = mgr->conns; c != NULL; c = tmp) {",
          "6362:     bool is_resp = c->is_resp;",
          "6363:     tmp = c->next;",
          "6364:     mg_call(c, MG_EV_POLL, &now);",
          "6365:     if (is_resp && !c->is_resp) {",
          "6366:       long n = 0;",
          "6367:       mg_call(c, MG_EV_READ, &n);",
          "6368:     }",
          "6369:     MG_VERBOSE((\"%lu %c%c %c%c%c%c%c\", c->id, c->is_readable ? 'r' : '-',",
          "6370:                 c->is_writable ? 'w' : '-', c->is_tls ? 'T' : 't',",
          "6371:                 c->is_connecting ? 'C' : 'c', c->is_tls_hs ? 'H' : 'h',",
          "6372:                 c->is_resolving ? 'R' : 'r', c->is_closing ? 'C' : 'c'));",
          "6373:     if (c->is_resolving || c->is_closing) {",
          "6375:     } else if (c->is_listening && c->is_udp == 0) {",
          "6376:       if (c->is_readable) accept_conn(mgr, c);",
          "6377:     } else if (c->is_connecting) {",
          "6378:       if (c->is_readable || c->is_writable) connect_conn(c);",
          "6379:     } else if (c->is_tls_hs) {",
          "6380:       if ((c->is_readable || c->is_writable)) mg_tls_handshake(c);",
          "6381:     } else {",
          "6382:       if (c->is_readable) read_conn(c);",
          "6383:       if (c->is_writable) write_conn(c);",
          "6386:     if (c->is_draining && c->send.len == 0) c->is_closing = 1;",
          "6387:     if (c->is_closing) close_conn(c);",
          "6390: #endif",
          "6393: #line 1 \"src/ssi.c\"",
          "6399: #ifndef MG_MAX_SSI_DEPTH",
          "6400: #define MG_MAX_SSI_DEPTH 5",
          "6401: #endif",
          "6403: #ifndef MG_SSI_BUFSIZ",
          "6404: #define MG_SSI_BUFSIZ 1024",
          "6407: #if MG_ENABLE_SSI",
          "6408: static char *mg_ssi(const char *path, const char *root, int depth) {",
          "6409:   struct mg_iobuf b = {NULL, 0, 0, MG_IO_SIZE};",
          "6410:   FILE *fp = fopen(path, \"rb\");",
          "6411:   if (fp != NULL) {",
          "6412:     char buf[MG_SSI_BUFSIZ], arg[sizeof(buf)];",
          "6413:     int ch, intag = 0;",
          "6414:     size_t len = 0;",
          "6415:     buf[0] = arg[0] = '\\0';",
          "6416:     while ((ch = fgetc(fp)) != EOF) {",
          "6417:       if (intag && ch == '>' && buf[len - 1] == '-' && buf[len - 2] == '-') {",
          "6418:         buf[len++] = (char) (ch & 0xff);",
          "6419:         buf[len] = '\\0';",
          "6420:         if (sscanf(buf, \"<!--#include file=\\\"%[^\\\"]\", arg)) {",
          "6421:           char tmp[MG_PATH_MAX + MG_SSI_BUFSIZ + 10],",
          "6423:           while (p > path && p[-1] != MG_DIRSEP && p[-1] != '/') p--;",
          "6424:           mg_snprintf(tmp, sizeof(tmp), \"%.*s%s\", (int) (p - path), path, arg);",
          "6425:           if (depth < MG_MAX_SSI_DEPTH &&",
          "6426:               (data = mg_ssi(tmp, root, depth + 1)) != NULL) {",
          "6427:             mg_iobuf_add(&b, b.len, data, strlen(data));",
          "6428:             free(data);",
          "6429:           } else {",
          "6430:             MG_ERROR((\"%s: file=%s error or too deep\", path, arg));",
          "6431:           }",
          "6432:         } else if (sscanf(buf, \"<!--#include virtual=\\\"%[^\\\"]\", arg)) {",
          "6433:           char tmp[MG_PATH_MAX + MG_SSI_BUFSIZ + 10], *data;",
          "6434:           mg_snprintf(tmp, sizeof(tmp), \"%s%s\", root, arg);",
          "6435:           if (depth < MG_MAX_SSI_DEPTH &&",
          "6436:               (data = mg_ssi(tmp, root, depth + 1)) != NULL) {",
          "6437:             mg_iobuf_add(&b, b.len, data, strlen(data));",
          "6438:             free(data);",
          "6439:           } else {",
          "6440:             MG_ERROR((\"%s: virtual=%s error or too deep\", path, arg));",
          "6441:           }",
          "6442:         } else {",
          "6444:           MG_ERROR((\"Unknown SSI tag: %.*s\", (int) len, buf));",
          "6445:           mg_iobuf_add(&b, b.len, buf, len);",
          "6446:         }",
          "6447:         intag = 0;",
          "6448:         len = 0;",
          "6449:       } else if (ch == '<') {",
          "6450:         intag = 1;",
          "6451:         if (len > 0) mg_iobuf_add(&b, b.len, buf, len);",
          "6452:         len = 0;",
          "6453:         buf[len++] = (char) (ch & 0xff);",
          "6454:       } else if (intag) {",
          "6455:         if (len == 5 && strncmp(buf, \"<!--#\", 5) != 0) {",
          "6456:           intag = 0;",
          "6457:         } else if (len >= sizeof(buf) - 2) {",
          "6458:           MG_ERROR((\"%s: SSI tag is too large\", path));",
          "6459:           len = 0;",
          "6460:         }",
          "6461:         buf[len++] = (char) (ch & 0xff);",
          "6462:       } else {",
          "6463:         buf[len++] = (char) (ch & 0xff);",
          "6464:         if (len >= sizeof(buf)) {",
          "6465:           mg_iobuf_add(&b, b.len, buf, len);",
          "6466:           len = 0;",
          "6467:         }",
          "6468:       }",
          "6469:     }",
          "6470:     if (len > 0) mg_iobuf_add(&b, b.len, buf, len);",
          "6471:     if (b.len > 0) mg_iobuf_add(&b, b.len, \"\", 1);  // nul-terminate",
          "6472:     fclose(fp);",
          "6473:   }",
          "6474:   (void) depth;",
          "6475:   (void) root;",
          "6476:   return (char *) b.buf;",
          "6477: }",
          "6479: void mg_http_serve_ssi(struct mg_connection *c, const char *root,",
          "6480:                        const char *fullpath) {",
          "6481:   const char *headers = \"Content-Type: text/html; charset=utf-8\\r\\n\";",
          "6482:   char *data = mg_ssi(fullpath, root, 0);",
          "6483:   mg_http_reply(c, 200, headers, \"%s\", data == NULL ? \"\" : data);",
          "6484:   free(data);",
          "6485: }",
          "6486: #else",
          "6487: void mg_http_serve_ssi(struct mg_connection *c, const char *root,",
          "6488:                        const char *fullpath) {",
          "6489:   mg_http_reply(c, 501, NULL, \"SSI not enabled\");",
          "6490:   (void) root, (void) fullpath;",
          "6491: }",
          "6494: #ifdef MG_ENABLE_LINES",
          "6495: #line 1 \"src/str.c\"",
          "6499: struct mg_str mg_str_s(const char *s) {",
          "6500:   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};",
          "6501:   return str;",
          "6502: }",
          "6504: struct mg_str mg_str_n(const char *s, size_t n) {",
          "6505:   struct mg_str str = {s, n};",
          "6506:   return str;",
          "6507: }",
          "6509: int mg_lower(const char *s) {",
          "6510:   int c = *s;",
          "6511:   if (c >= 'A' && c <= 'Z') c += 'a' - 'A';",
          "6512:   return c;",
          "6513: }",
          "6515: int mg_ncasecmp(const char *s1, const char *s2, size_t len) {",
          "6516:   int diff = 0;",
          "6517:   if (len > 0) do {",
          "6518:       diff = mg_lower(s1++) - mg_lower(s2++);",
          "6519:     } while (diff == 0 && s1[-1] != '\\0' && --len > 0);",
          "6520:   return diff;",
          "6521: }",
          "6523: int mg_casecmp(const char *s1, const char *s2) {",
          "6524:   return mg_ncasecmp(s1, s2, (size_t) ~0);",
          "6527: int mg_vcmp(const struct mg_str *s1, const char *s2) {",
          "6528:   size_t n2 = strlen(s2), n1 = s1->len;",
          "6529:   int r = strncmp(s1->ptr, s2, (n1 < n2) ? n1 : n2);",
          "6530:   if (r == 0) return (int) (n1 - n2);",
          "6531:   return r;",
          "6534: int mg_vcasecmp(const struct mg_str *str1, const char *str2) {",
          "6535:   size_t n2 = strlen(str2), n1 = str1->len;",
          "6536:   int r = mg_ncasecmp(str1->ptr, str2, (n1 < n2) ? n1 : n2);",
          "6537:   if (r == 0) return (int) (n1 - n2);",
          "6538:   return r;",
          "6541: struct mg_str mg_strdup(const struct mg_str s) {",
          "6542:   struct mg_str r = {NULL, 0};",
          "6543:   if (s.len > 0 && s.ptr != NULL) {",
          "6544:     char *sc = (char *) calloc(1, s.len + 1);",
          "6545:     if (sc != NULL) {",
          "6546:       memcpy(sc, s.ptr, s.len);",
          "6547:       sc[s.len] = '\\0';",
          "6548:       r.ptr = sc;",
          "6549:       r.len = s.len;",
          "6552:   return r;",
          "6555: int mg_strcmp(const struct mg_str str1, const struct mg_str str2) {",
          "6556:   size_t i = 0;",
          "6557:   while (i < str1.len && i < str2.len) {",
          "6558:     int c1 = str1.ptr[i];",
          "6559:     int c2 = str2.ptr[i];",
          "6560:     if (c1 < c2) return -1;",
          "6561:     if (c1 > c2) return 1;",
          "6562:     i++;",
          "6564:   if (i < str1.len) return 1;",
          "6565:   if (i < str2.len) return -1;",
          "6566:   return 0;",
          "6569: const char *mg_strstr(const struct mg_str haystack,",
          "6570:                       const struct mg_str needle) {",
          "6571:   size_t i;",
          "6572:   if (needle.len > haystack.len) return NULL;",
          "6573:   if (needle.len == 0) return haystack.ptr;",
          "6574:   for (i = 0; i <= haystack.len - needle.len; i++) {",
          "6575:     if (memcmp(haystack.ptr + i, needle.ptr, needle.len) == 0) {",
          "6576:       return haystack.ptr + i;",
          "6577:     }",
          "6579:   return NULL;",
          "6582: static bool is_space(int c) {",
          "6583:   return c == ' ' || c == '\\r' || c == '\\n' || c == '\\t';",
          "6586: struct mg_str mg_strstrip(struct mg_str s) {",
          "6587:   while (s.len > 0 && is_space((int) *s.ptr)) s.ptr++, s.len--;",
          "6588:   while (s.len > 0 && is_space((int) *(s.ptr + s.len - 1))) s.len--;",
          "6589:   return s;",
          "6590: }",
          "6592: bool mg_match(struct mg_str s, struct mg_str p, struct mg_str *caps) {",
          "6593:   size_t i = 0, j = 0, ni = 0, nj = 0;",
          "6594:   if (caps) caps->ptr = NULL, caps->len = 0;",
          "6595:   while (i < p.len || j < s.len) {",
          "6596:     if (i < p.len && j < s.len && (p.ptr[i] == '?' || s.ptr[j] == p.ptr[i])) {",
          "6597:       if (caps == NULL) {",
          "6598:       } else if (p.ptr[i] == '?') {",
          "6599:         caps->ptr = &s.ptr[j], caps->len = 1;     // Finalize `?` cap",
          "6600:         caps++, caps->ptr = NULL, caps->len = 0;  // Init next cap",
          "6601:       } else if (caps->ptr != NULL && caps->len == 0) {",
          "6602:         caps->len = (size_t) (&s.ptr[j] - caps->ptr);  // Finalize current cap",
          "6603:         caps++, caps->len = 0, caps->ptr = NULL;       // Init next cap",
          "6604:       }",
          "6605:       i++, j++;",
          "6606:     } else if (i < p.len && (p.ptr[i] == '*' || p.ptr[i] == '#')) {",
          "6607:       if (caps && !caps->ptr) caps->len = 0, caps->ptr = &s.ptr[j];  // Init cap",
          "6608:       ni = i++, nj = j + 1;",
          "6609:     } else if (nj > 0 && nj <= s.len && (p.ptr[ni] == '#' || s.ptr[j] != '/')) {",
          "6610:       i = ni, j = nj;",
          "6611:       if (caps && caps->ptr == NULL && caps->len == 0) {",
          "6612:         caps--, caps->len = 0;  // Restart previous cap",
          "6613:       }",
          "6615:       return false;",
          "6616:     }",
          "6617:   }",
          "6618:   if (caps && caps->ptr && caps->len == 0) {",
          "6619:     caps->len = (size_t) (&s.ptr[j] - caps->ptr);",
          "6620:   }",
          "6621:   return true;",
          "6622: }",
          "6624: bool mg_globmatch(const char *s1, size_t n1, const char *s2, size_t n2) {",
          "6625:   return mg_match(mg_str_n(s2, n2), mg_str_n(s1, n1), NULL);",
          "6628: static size_t mg_nce(const char *s, size_t n, size_t ofs, size_t *koff,",
          "6629:                      size_t *klen, size_t *voff, size_t *vlen, char delim) {",
          "6630:   size_t kvlen, kl;",
          "6631:   for (kvlen = 0; ofs + kvlen < n && s[ofs + kvlen] != delim;) kvlen++;",
          "6632:   for (kl = 0; kl < kvlen && s[ofs + kl] != '=';) kl++;",
          "6633:   if (koff != NULL) *koff = ofs;",
          "6634:   if (klen != NULL) *klen = kl;",
          "6635:   if (voff != NULL) *voff = kl < kvlen ? ofs + kl + 1 : 0;",
          "6636:   if (vlen != NULL) *vlen = kl < kvlen ? kvlen - kl - 1 : 0;",
          "6637:   ofs += kvlen + 1;",
          "6638:   return ofs > n ? n : ofs;",
          "6641: bool mg_split(struct mg_str *s, struct mg_str *k, struct mg_str *v, char sep) {",
          "6642:   size_t koff = 0, klen = 0, voff = 0, vlen = 0, off = 0;",
          "6643:   if (s->ptr == NULL || s->len == 0) return 0;",
          "6644:   off = mg_nce(s->ptr, s->len, 0, &koff, &klen, &voff, &vlen, sep);",
          "6645:   if (k != NULL) *k = mg_str_n(s->ptr + koff, klen);",
          "6646:   if (v != NULL) *v = mg_str_n(s->ptr + voff, vlen);",
          "6648:   return off > 0;",
          "6651: bool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v) {",
          "6652:   return mg_split(s, k, v, ',');",
          "6655: char *mg_hex(const void *buf, size_t len, char *to) {",
          "6656:   const unsigned char *p = (const unsigned char *) buf;",
          "6657:   const char *hex = \"0123456789abcdef\";",
          "6658:   size_t i = 0;",
          "6659:   for (; len--; p++) {",
          "6660:     to[i++] = hex[p[0] >> 4];",
          "6661:     to[i++] = hex[p[0] & 0x0f];",
          "6663:   to[i] = '\\0';",
          "6664:   return to;",
          "6665: }",
          "6667: static unsigned char mg_unhex_nimble(unsigned char c) {",
          "6668:   return (c >= '0' && c <= '9')   ? (unsigned char) (c - '0')",
          "6669:          : (c >= 'A' && c <= 'F') ? (unsigned char) (c - '7')",
          "6670:                                   : (unsigned char) (c - 'W');",
          "6673: unsigned long mg_unhexn(const char *s, size_t len) {",
          "6674:   unsigned long i = 0, v = 0;",
          "6675:   for (i = 0; i < len; i++) v <<= 4, v |= mg_unhex_nimble(((uint8_t *) s)[i]);",
          "6676:   return v;",
          "6679: void mg_unhex(const char *buf, size_t len, unsigned char *to) {",
          "6680:   size_t i;",
          "6681:   for (i = 0; i < len; i += 2) {",
          "6682:     to[i >> 1] = (unsigned char) mg_unhexn(&buf[i], 2);",
          "6683:   }",
          "6686: bool mg_path_is_sane(const char *path) {",
          "6687:   const char *s = path;",
          "6688:   for (; s[0] != '\\0'; s++) {",
          "6689:     if (s == path || s[0] == '/' || s[0] == '\\\\') {  // Subdir?",
          "6690:       if (s[1] == '.' && s[2] == '.') return false;  // Starts with ..",
          "6693:   return true;",
          "6696: #ifdef MG_ENABLE_LINES",
          "6697: #line 1 \"src/sys_dummy.c\"",
          "6698: #endif",
          "6701: #if MG_SYS == MG_SYS_NONE",
          "6702: void *mg_flash_start(void) {",
          "6703:   return NULL;",
          "6704: }",
          "6705: size_t mg_flash_size(void) {",
          "6706:   return 0;",
          "6707: }",
          "6708: size_t mg_flash_sector_size(void) {",
          "6709:   return 0;",
          "6710: }",
          "6711: size_t mg_flash_write_align(void) {",
          "6712:   return 0;",
          "6713: }",
          "6714: int mg_flash_bank(void) {",
          "6715:   return 0;",
          "6716: }",
          "6717: bool mg_flash_erase(void *location) {",
          "6718:   (void) location;",
          "6719:   return false;",
          "6720: }",
          "6721: bool mg_flash_swap_bank(void) {",
          "6722:   return true;",
          "6723: }",
          "6724: bool mg_flash_write(void *addr, const void *buf, size_t len) {",
          "6725:   (void) addr, (void) buf, (void) len;",
          "6726:   return false;",
          "6727: }",
          "6728: void mg_sys_reset(void) {",
          "6730: #endif",
          "6732: #ifdef MG_ENABLE_LINES",
          "6733: #line 1 \"src/sys_flash.c\"",
          "6737: #if MG_SYS == MG_SYS_STM32H7 || MG_SYS == MG_SYS_STM32H5",
          "6748: size_t mg_flash_next(char *p, char *end, uint32_t *key, size_t *size) {",
          "6749:   size_t aligned_size = 0, align = mg_flash_write_align(), left = end - p;",
          "6750:   uint32_t *p32 = (uint32_t *) p, min_size = sizeof(uint32_t) * 2;",
          "6751:   if (p32[0] != 0xffffffff && left > MG_ROUND_UP(min_size, align)) {",
          "6752:     if (size) *size = (size_t) p32[0];",
          "6753:     if (key) *key = p32[1];",
          "6754:     aligned_size = MG_ROUND_UP(p32[0] + sizeof(uint32_t) * 2, align);",
          "6755:     if (left < aligned_size) aligned_size = 0;  // Out of bounds, fail",
          "6757:   return aligned_size;",
          "6761: static char *flash_last_sector(void) {",
          "6762:   size_t ss = mg_flash_sector_size(), size = mg_flash_size();",
          "6763:   char *base = (char *) mg_flash_start(), *last = base + size - ss;",
          "6764:   if (mg_flash_bank() == 2) last -= size / 2;",
          "6765:   return last;",
          "6769: bool mg_flash_load(void *sector, uint32_t key, void *buf, size_t len) {",
          "6770:   char *base = (char *) mg_flash_start(), *s = (char *) sector, *res = NULL;",
          "6771:   size_t ss = mg_flash_sector_size(), ofs = 0, n, sz;",
          "6772:   bool ok = false;",
          "6773:   if (s == NULL) s = flash_last_sector();",
          "6774:   if (s < base || s >= base + mg_flash_size()) {",
          "6775:     MG_ERROR((\"%p is outsize of flash\", sector));",
          "6776:   } else if (((s - base) % ss) != 0) {",
          "6777:     MG_ERROR((\"%p is not a sector boundary\", sector));",
          "6778:   } else {",
          "6779:     uint32_t k, scanned = 0;",
          "6780:     while ((n = mg_flash_next(s + ofs, s + ss, &k, &sz)) > 0) {",
          "6783:       if (k == key && sz == len) {",
          "6784:         res = s + ofs + sizeof(uint32_t) * 2;",
          "6785:         memcpy(buf, res, len);  // Copy object",
          "6786:         ok = true;              // Keep scanning for the newer versions of it",
          "6787:       }",
          "6788:       ofs += n, scanned++;",
          "6789:     }",
          "6790:     MG_DEBUG((\"Scanned %u objects, key %x is @ %p\", scanned, key, res));",
          "6791:   }",
          "6792:   return ok;",
          "6795: static bool mg_flash_writev(char *location, struct mg_str *strings, size_t n) {",
          "6796:   size_t align = mg_flash_write_align(), i, j, k = 0, nwritten = 0;",
          "6797:   char buf[align];",
          "6798:   bool ok = true;",
          "6799:   for (i = 0; ok && i < n; i++) {",
          "6800:     for (j = 0; ok && j < strings[i].len; j++) {",
          "6801:       buf[k++] = strings[i].ptr[j];",
          "6802:       if (k >= sizeof(buf)) {",
          "6803:         ok = mg_flash_write(location + nwritten, buf, sizeof(buf));",
          "6804:         k = 0, nwritten += sizeof(buf);",
          "6805:       }",
          "6808:   if (k > 0) {",
          "6809:     while (k < sizeof(buf)) buf[k++] = 0xff;",
          "6810:     ok = mg_flash_write(location + nwritten, buf, sizeof(buf));",
          "6812:   return ok;",
          "6813: }",
          "6816: static void mg_flash_sector_cleanup(char *sector) {",
          "6819:   struct mg_iobuf io = {0, 0, 0, 2048};",
          "6820:   size_t ss = mg_flash_sector_size();",
          "6821:   size_t n, size, size2, ofs = 0, hs = sizeof(uint32_t) * 2;",
          "6822:   uint32_t key;",
          "6824:   MG_DEBUG((\"Cleaning up sector %p\", sector));",
          "6825:   while ((n = mg_flash_next(sector + ofs, sector + ss, &key, &size)) > 0) {",
          "6827:     for (size_t o = 0; o < io.len; o += size2 + hs) {",
          "6828:       uint32_t k = *(uint32_t *) (io.buf + o + sizeof(uint32_t));",
          "6829:       size2 = *(uint32_t *) (io.buf + o);",
          "6830:       if (k == key) {",
          "6831:         mg_iobuf_del(&io, o, size2 + hs);",
          "6832:         break;",
          "6836:     mg_iobuf_add(&io, io.len, sector + ofs, size + hs);",
          "6837:     ofs += n;",
          "6840:   if (mg_flash_erase(sector)) {  // Erase sector. If successful,",
          "6841:     for (ofs = 0; ofs < io.len; ofs += size + hs) {  // Traverse cached objects",
          "6842:       size = *(uint32_t *) (io.buf + ofs);",
          "6843:       key = *(uint32_t *) (io.buf + ofs + sizeof(uint32_t));",
          "6844:       mg_flash_save(sector, key, io.buf + ofs + hs, size);  // Save to flash",
          "6847:   mg_iobuf_free(&io);",
          "6851: bool mg_flash_save(void *sector, uint32_t key, const void *buf, size_t len) {",
          "6852:   char *base = (char *) mg_flash_start(), *s = (char *) sector;",
          "6853:   size_t ss = mg_flash_sector_size(), ofs = 0, n;",
          "6854:   bool ok = false;",
          "6855:   if (s == NULL) s = flash_last_sector();",
          "6856:   if (s < base || s >= base + mg_flash_size()) {",
          "6857:     MG_ERROR((\"%p is outsize of flash\", sector));",
          "6858:   } else if (((s - base) % ss) != 0) {",
          "6859:     MG_ERROR((\"%p is not a sector boundary\", sector));",
          "6860:   } else {",
          "6861:     size_t needed = sizeof(uint32_t) * 2 + len;",
          "6862:     size_t needed_aligned = MG_ROUND_UP(needed, mg_flash_write_align());",
          "6863:     while ((n = mg_flash_next(s + ofs, s + ss, NULL, NULL)) > 0) ofs += n;",
          "6866:     if (ofs + needed_aligned > ss) {",
          "6867:       mg_flash_sector_cleanup(s);",
          "6868:       ofs = 0;",
          "6869:       while ((n = mg_flash_next(s + ofs, s + ss, NULL, NULL)) > 0) ofs += n;",
          "6870:     }",
          "6872:     if (ofs + needed_aligned <= ss) {",
          "6874:       uint32_t hdr[2] = {(uint32_t) len, key};",
          "6875:       struct mg_str data[] = {mg_str_n((char *) hdr, sizeof(hdr)),",
          "6876:                               mg_str_n(buf, len)};",
          "6877:       ok = mg_flash_writev(s + ofs, data, 2);",
          "6878:       MG_DEBUG((\"Saving %lu bytes @ %p, key %x: %d\", len, s + ofs, key, ok));",
          "6879:       MG_DEBUG((\"Sector space left: %lu bytes\", ss - ofs - needed_aligned));",
          "6881:       MG_ERROR((\"Sector is full\"));",
          "6884:   return ok;",
          "6885: }",
          "6886: #else",
          "6887: bool mg_flash_save(void *sector, uint32_t key, const void *buf, size_t len) {",
          "6888:   (void) sector, (void) key, (void) buf, (void) len;",
          "6889:   return false;",
          "6890: }",
          "6891: bool mg_flash_load(void *sector, uint32_t key, void *buf, size_t len) {",
          "6892:   (void) sector, (void) key, (void) buf, (void) len;",
          "6893:   return false;",
          "6898: #line 1 \"src/sys_stm32h5.c\"",
          "6903: #if MG_SYS == MG_SYS_STM32H5",
          "6905: #define FLASH_BASE 0x40022000          // Base address of the flash controller",
          "6906: #define FLASH_KEYR (FLASH_BASE + 0x4)  // See RM0481 7.11",
          "6907: #define FLASH_OPTKEYR (FLASH_BASE + 0xc)",
          "6908: #define FLASH_OPTCR (FLASH_BASE + 0x1c)",
          "6909: #define FLASH_NSSR (FLASH_BASE + 0x20)",
          "6910: #define FLASH_NSCR (FLASH_BASE + 0x28)",
          "6911: #define FLASH_NSCCR (FLASH_BASE + 0x30)",
          "6912: #define FLASH_OPTSR_CUR (FLASH_BASE + 0x50)",
          "6913: #define FLASH_OPTSR_PRG (FLASH_BASE + 0x54)",
          "6915: void *mg_flash_start(void) {",
          "6916:   return (void *) 0x08000000;",
          "6917: }",
          "6918: size_t mg_flash_size(void) {",
          "6919:   return 2 * 1024 * 1024;  // 2Mb",
          "6920: }",
          "6921: size_t mg_flash_sector_size(void) {",
          "6922:   return 8 * 1024;  // 8k",
          "6923: }",
          "6924: size_t mg_flash_write_align(void) {",
          "6925:   return 16;  // 128 bit",
          "6926: }",
          "6927: int mg_flash_bank(void) {",
          "6928:   return MG_REG(FLASH_OPTCR) & MG_BIT(31) ? 2 : 1;",
          "6929: }",
          "6931: static void flash_unlock(void) {",
          "6932:   static bool unlocked = false;",
          "6933:   if (unlocked == false) {",
          "6934:     MG_REG(FLASH_KEYR) = 0x45670123;",
          "6935:     MG_REG(FLASH_KEYR) = 0Xcdef89ab;",
          "6936:     MG_REG(FLASH_OPTKEYR) = 0x08192a3b;",
          "6937:     MG_REG(FLASH_OPTKEYR) = 0x4c5d6e7f;",
          "6938:     unlocked = true;",
          "6939:   }",
          "6940: }",
          "6942: static int flash_page_start(volatile uint32_t *dst) {",
          "6943:   char *base = (char *) mg_flash_start(), *end = base + mg_flash_size();",
          "6944:   volatile char *p = (char *) dst;",
          "6945:   return p >= base && p < end && ((p - base) % mg_flash_sector_size()) == 0;",
          "6946: }",
          "6948: static bool flash_is_err(void) {",
          "6949:   return MG_REG(FLASH_NSSR) & ((MG_BIT(8) - 1) << 17);  // RM0481 7.11.9",
          "6950: }",
          "6952: static void flash_wait(void) {",
          "6953:   while ((MG_REG(FLASH_NSSR) & MG_BIT(0)) &&",
          "6954:          (MG_REG(FLASH_NSSR) & MG_BIT(16)) == 0) {",
          "6955:     (void) 0;",
          "6956:   }",
          "6957: }",
          "6959: static void flash_clear_err(void) {",
          "6960:   flash_wait();                                    // Wait until ready",
          "6961:   MG_REG(FLASH_NSCCR) = ((MG_BIT(9) - 1) << 16U);  // Clear all errors",
          "6962: }",
          "6964: static bool flash_bank_is_swapped(void) {",
          "6965:   return MG_REG(FLASH_OPTCR) & MG_BIT(31);  // RM0481 7.11.8",
          "6966: }",
          "6968: bool mg_flash_erase(void *location) {",
          "6969:   bool ok = false;",
          "6970:   if (flash_page_start(location) == false) {",
          "6971:     MG_ERROR((\"%p is not on a sector boundary\"));",
          "6972:   } else {",
          "6973:     uintptr_t diff = (char *) location - (char *) mg_flash_start();",
          "6974:     uint32_t sector = diff / mg_flash_sector_size();",
          "6975:     flash_unlock();",
          "6976:     flash_clear_err();",
          "6977:     MG_REG(FLASH_NSCR) = 0;",
          "6978:     if ((sector < 128 && flash_bank_is_swapped()) ||",
          "6979:         (sector > 127 && !flash_bank_is_swapped())) {",
          "6980:       MG_REG(FLASH_NSCR) |= MG_BIT(31);  // Set FLASH_CR_BKSEL",
          "6982:     if (sector > 127) sector -= 128;",
          "6983:     MG_REG(FLASH_NSCR) |= MG_BIT(2) | (sector << 6);  // Erase | sector_num",
          "6984:     MG_REG(FLASH_NSCR) |= MG_BIT(5);                  // Start erasing",
          "6985:     flash_wait();",
          "6986:     ok = !flash_is_err();",
          "6987:     MG_DEBUG((\"Erase sector %lu @ %p: %s. CR %#lx SR %#lx\", sector, location,",
          "6988:               ok ? \"ok\" : \"fail\", MG_REG(FLASH_NSCR), MG_REG(FLASH_NSSR)));",
          "6991:   return ok;",
          "6992: }",
          "6994: bool mg_flash_swap_bank(void) {",
          "6995:   uint32_t desired = flash_bank_is_swapped() ? 0 : MG_BIT(31);",
          "6996:   flash_unlock();",
          "6997:   flash_clear_err();",
          "6999:   MG_SET_BITS(MG_REG(FLASH_OPTSR_PRG), MG_BIT(31), desired);",
          "7001:   MG_REG(FLASH_OPTCR) |= MG_BIT(1);  // OPTSTART",
          "7002:   while ((MG_REG(FLASH_OPTSR_CUR) & MG_BIT(31)) != desired) (void) 0;",
          "7003:   return true;",
          "7006: bool mg_flash_write(void *addr, const void *buf, size_t len) {",
          "7007:   if ((len % mg_flash_write_align()) != 0) {",
          "7008:     MG_ERROR((\"%lu is not aligned to %lu\", len, mg_flash_write_align()));",
          "7009:     return false;",
          "7010:   }",
          "7011:   uint32_t *dst = (uint32_t *) addr;",
          "7012:   uint32_t *src = (uint32_t *) buf;",
          "7013:   uint32_t *end = (uint32_t *) ((char *) buf + len);",
          "7014:   bool ok = true;",
          "7015:   flash_unlock();",
          "7016:   flash_clear_err();",
          "7017:   MG_ARM_DISABLE_IRQ();",
          "7019:   while (ok && src < end) {",
          "7020:     if (flash_page_start(dst) && mg_flash_erase(dst) == false) break;",
          "7021:     MG_REG(FLASH_NSCR) = MG_BIT(1);  // Set programming flag",
          "7023:     flash_wait();",
          "7024:     if (flash_is_err()) ok = false;",
          "7025:   }",
          "7026:   MG_DEBUG((\"Flash write %lu bytes @ %p: %s. CR %#lx SR %#lx\", len, dst,",
          "7027:             flash_is_err() ? \"fail\" : \"ok\", MG_REG(FLASH_NSCR),",
          "7028:             MG_REG(FLASH_NSSR)));",
          "7029:   if (flash_is_err()) ok = false;",
          "7032:   MG_REG(FLASH_NSCR) = 0;  // Clear flags",
          "7033:   MG_ARM_ENABLE_IRQ();",
          "7034:   return ok;",
          "7037: void mg_sys_reset(void) {",
          "7044: #line 1 \"src/sys_stm32h7.c\"",
          "7049: #if MG_SYS == MG_SYS_STM32H7",
          "7051: #define FLASH_BASE1 0x52002000  // Base address for bank1",
          "7052: #define FLASH_BASE2 0x52002100  // Base address for bank2",
          "7053: #define FLASH_KEYR 0x04         // See RM0433 4.9.2",
          "7054: #define FLASH_OPTKEYR 0x08",
          "7055: #define FLASH_OPTCR 0x18",
          "7056: #define FLASH_SR 0x10",
          "7057: #define FLASH_CR 0x0c",
          "7058: #define FLASH_CCR 0x14",
          "7059: #define FLASH_OPTSR_CUR 0x1c",
          "7060: #define FLASH_OPTSR_PRG 0x20",
          "7062: void *mg_flash_start(void) {",
          "7063:   return (void *) 0x08000000;",
          "7065: size_t mg_flash_size(void) {",
          "7066:   return 2 * 1024 * 1024;  // 2Mb",
          "7068: size_t mg_flash_sector_size(void) {",
          "7069:   return 128 * 1024;  // 128k",
          "7071: size_t mg_flash_write_align(void) {",
          "7072:   return 32;  // 256 bit",
          "7074: int mg_flash_bank(void) {",
          "7075:   return MG_REG(FLASH_BASE1 + FLASH_OPTCR) & MG_BIT(31) ? 2 : 1;",
          "7078: static void flash_unlock(void) {",
          "7079:   static bool unlocked = false;",
          "7080:   if (unlocked == false) {",
          "7081:     MG_REG(FLASH_BASE1 + FLASH_KEYR) = 0x45670123;",
          "7082:     MG_REG(FLASH_BASE1 + FLASH_KEYR) = 0xcdef89ab;",
          "7083:     MG_REG(FLASH_BASE2 + FLASH_KEYR) = 0x45670123;",
          "7084:     MG_REG(FLASH_BASE2 + FLASH_KEYR) = 0xcdef89ab;",
          "7085:     MG_REG(FLASH_BASE1 + FLASH_OPTKEYR) = 0x08192a3b;  // opt reg is \"shared\"",
          "7086:     MG_REG(FLASH_BASE1 + FLASH_OPTKEYR) = 0x4c5d6e7f;  // thus unlock once",
          "7087:     unlocked = true;",
          "7091: static bool flash_page_start(volatile uint32_t *dst) {",
          "7092:   char *base = (char *) mg_flash_start(), *end = base + mg_flash_size();",
          "7093:   volatile char *p = (char *) dst;",
          "7094:   return p >= base && p < end && ((p - base) % mg_flash_sector_size()) == 0;",
          "7097: static bool flash_is_err(uint32_t bank) {",
          "7098:   return MG_REG(bank + FLASH_SR) & ((MG_BIT(11) - 1) << 17);  // RM0433 4.9.5",
          "7101: static void flash_wait(uint32_t bank) {",
          "7102:   while (MG_REG(bank + FLASH_SR) & (MG_BIT(0) | MG_BIT(2))) (void) 0;",
          "7105: static void flash_clear_err(uint32_t bank) {",
          "7106:   flash_wait(bank);                                      // Wait until ready",
          "7107:   MG_REG(bank + FLASH_CCR) = ((MG_BIT(11) - 1) << 16U);  // Clear all errors",
          "7110: static bool flash_bank_is_swapped(uint32_t bank) {",
          "7111:   return MG_REG(bank + FLASH_OPTCR) & MG_BIT(31);  // RM0433 4.9.7",
          "7115: static uint32_t flash_bank(void *addr) {",
          "7116:   size_t ofs = (char *) addr - (char *) mg_flash_start();",
          "7117:   return ofs < mg_flash_size() / 2 ? FLASH_BASE1 : FLASH_BASE2;",
          "7120: bool mg_flash_erase(void *addr) {",
          "7121:   bool ok = false;",
          "7122:   if (flash_page_start(addr) == false) {",
          "7123:     MG_ERROR((\"%p is not on a sector boundary\", addr));",
          "7124:   } else {",
          "7125:     uintptr_t diff = (char *) addr - (char *) mg_flash_start();",
          "7126:     uint32_t sector = diff / mg_flash_sector_size();",
          "7127:     uint32_t bank = flash_bank(addr);",
          "7129:     flash_unlock();",
          "7130:     if (sector > 7) sector -= 8;",
          "7133:     flash_clear_err(bank);",
          "7134:     MG_REG(bank + FLASH_CR) |= (sector & 7U) << 8U;  // Sector to erase",
          "7135:     MG_REG(bank + FLASH_CR) |= MG_BIT(2);            // Sector erase bit",
          "7136:     MG_REG(bank + FLASH_CR) |= MG_BIT(7);            // Start erasing",
          "7137:     ok = !flash_is_err(bank);",
          "7138:     MG_DEBUG((\"Erase sector %lu @ %p %s. CR %#lx SR %#lx\", sector, addr,",
          "7139:               ok ? \"ok\" : \"fail\", MG_REG(bank + FLASH_CR),",
          "7140:               MG_REG(bank + FLASH_SR)));",
          "7143:   return ok;",
          "7146: bool mg_flash_swap_bank() {",
          "7147:   uint32_t bank = FLASH_BASE1;",
          "7148:   uint32_t desired = flash_bank_is_swapped(bank) ? 0 : MG_BIT(31);",
          "7149:   flash_unlock();",
          "7150:   flash_clear_err(bank);",
          "7152:   MG_SET_BITS(MG_REG(bank + FLASH_OPTSR_PRG), MG_BIT(31), desired);",
          "7154:   MG_REG(bank + FLASH_OPTCR) |= MG_BIT(1);  // OPTSTART",
          "7155:   while ((MG_REG(bank + FLASH_OPTSR_CUR) & MG_BIT(31)) != desired) (void) 0;",
          "7156:   return true;",
          "7159: bool mg_flash_write(void *addr, const void *buf, size_t len) {",
          "7160:   if ((len % mg_flash_write_align()) != 0) {",
          "7161:     MG_ERROR((\"%lu is not aligned to %lu\", len, mg_flash_write_align()));",
          "7162:     return false;",
          "7163:   }",
          "7164:   uint32_t bank = flash_bank(addr);",
          "7165:   uint32_t *dst = (uint32_t *) addr;",
          "7166:   uint32_t *src = (uint32_t *) buf;",
          "7167:   uint32_t *end = (uint32_t *) ((char *) buf + len);",
          "7168:   bool ok = true;",
          "7169:   flash_unlock();",
          "7170:   flash_clear_err(bank);",
          "7171:   MG_ARM_DISABLE_IRQ();",
          "7172:   MG_REG(bank + FLASH_CR) = MG_BIT(1);  // Set programming flag",
          "7174:   while (ok && src < end) {",
          "7175:     if (flash_page_start(dst) && mg_flash_erase(dst) == false) break;",
          "7177:     flash_wait(bank);",
          "7178:     if (flash_is_err(bank)) ok = false;",
          "7180:   MG_DEBUG((\"Flash write %lu bytes @ %p: %s. CR %#lx SR %#lx\", len, dst,",
          "7181:             ok ? \"ok\" : \"fail\", MG_REG(bank + FLASH_CR),",
          "7182:             MG_REG(bank + FLASH_SR)));",
          "7184:   MG_REG(bank + FLASH_CR) &= ~MG_BIT(1);  // Clear programming flag",
          "7185:   MG_ARM_ENABLE_IRQ();",
          "7186:   return ok;",
          "7189: void mg_sys_reset(void) {",
          "7193: #endif",
          "",
          "[Added Lines]",
          "116: #line 1 \"src/device_dummy.c\"",
          "120: #if MG_DEVICE == MG_DEVICE_NONE",
          "121: void *mg_flash_start(void) {",
          "122:   return NULL;",
          "123: }",
          "124: size_t mg_flash_size(void) {",
          "125:   return 0;",
          "126: }",
          "127: size_t mg_flash_sector_size(void) {",
          "128:   return 0;",
          "129: }",
          "130: size_t mg_flash_write_align(void) {",
          "131:   return 0;",
          "132: }",
          "133: int mg_flash_bank(void) {",
          "134:   return 0;",
          "135: }",
          "136: bool mg_flash_erase(void *location) {",
          "137:   (void) location;",
          "138:   return false;",
          "139: }",
          "140: bool mg_flash_swap_bank(void) {",
          "141:   return true;",
          "142: }",
          "143: bool mg_flash_write(void *addr, const void *buf, size_t len) {",
          "144:   (void) addr, (void) buf, (void) len;",
          "145:   return false;",
          "146: }",
          "147: void mg_device_reset(void) {",
          "148: }",
          "149: #endif",
          "151: #ifdef MG_ENABLE_LINES",
          "152: #line 1 \"src/device_flash.c\"",
          "153: #endif",
          "156: #if MG_DEVICE == MG_DEVICE_STM32H7 || MG_DEVICE == MG_DEVICE_STM32H5",
          "167: size_t mg_flash_next(char *p, char *end, uint32_t *key, size_t *size) {",
          "168:   size_t aligned_size = 0, align = mg_flash_write_align(), left = end - p;",
          "169:   uint32_t *p32 = (uint32_t *) p, min_size = sizeof(uint32_t) * 2;",
          "170:   if (p32[0] != 0xffffffff && left > MG_ROUND_UP(min_size, align)) {",
          "171:     if (size) *size = (size_t) p32[0];",
          "172:     if (key) *key = p32[1];",
          "173:     aligned_size = MG_ROUND_UP(p32[0] + sizeof(uint32_t) * 2, align);",
          "174:     if (left < aligned_size) aligned_size = 0;  // Out of bounds, fail",
          "175:   }",
          "176:   return aligned_size;",
          "177: }",
          "180: static char *flash_last_sector(void) {",
          "181:   size_t ss = mg_flash_sector_size(), size = mg_flash_size();",
          "182:   char *base = (char *) mg_flash_start(), *last = base + size - ss;",
          "183:   if (mg_flash_bank() == 2) last -= size / 2;",
          "184:   return last;",
          "188: bool mg_flash_load(void *sector, uint32_t key, void *buf, size_t len) {",
          "189:   char *base = (char *) mg_flash_start(), *s = (char *) sector, *res = NULL;",
          "190:   size_t ss = mg_flash_sector_size(), ofs = 0, n, sz;",
          "191:   bool ok = false;",
          "192:   if (s == NULL) s = flash_last_sector();",
          "193:   if (s < base || s >= base + mg_flash_size()) {",
          "194:     MG_ERROR((\"%p is outsize of flash\", sector));",
          "195:   } else if (((s - base) % ss) != 0) {",
          "196:     MG_ERROR((\"%p is not a sector boundary\", sector));",
          "197:   } else {",
          "198:     uint32_t k, scanned = 0;",
          "199:     while ((n = mg_flash_next(s + ofs, s + ss, &k, &sz)) > 0) {",
          "202:       if (k == key && sz == len) {",
          "203:         res = s + ofs + sizeof(uint32_t) * 2;",
          "204:         memcpy(buf, res, len);  // Copy object",
          "205:         ok = true;              // Keep scanning for the newer versions of it",
          "206:       }",
          "207:       ofs += n, scanned++;",
          "208:     }",
          "209:     MG_DEBUG((\"Scanned %u objects, key %x is @ %p\", scanned, key, res));",
          "211:   return ok;",
          "214: static bool mg_flash_writev(char *location, struct mg_str *strings, size_t n) {",
          "215:   size_t align = mg_flash_write_align(), i, j, k = 0, nwritten = 0;",
          "216:   char buf[align];",
          "217:   bool ok = true;",
          "218:   for (i = 0; ok && i < n; i++) {",
          "219:     for (j = 0; ok && j < strings[i].len; j++) {",
          "220:       buf[k++] = strings[i].ptr[j];",
          "221:       if (k >= sizeof(buf)) {",
          "222:         ok = mg_flash_write(location + nwritten, buf, sizeof(buf));",
          "223:         k = 0, nwritten += sizeof(buf);",
          "224:       }",
          "226:   }",
          "227:   if (k > 0) {",
          "228:     while (k < sizeof(buf)) buf[k++] = 0xff;",
          "229:     ok = mg_flash_write(location + nwritten, buf, sizeof(buf));",
          "230:   }",
          "231:   return ok;",
          "232: }",
          "235: static void mg_flash_sector_cleanup(char *sector) {",
          "238:   struct mg_iobuf io = {0, 0, 0, 2048};",
          "239:   size_t ss = mg_flash_sector_size();",
          "240:   size_t n, size, size2, ofs = 0, hs = sizeof(uint32_t) * 2;",
          "241:   uint32_t key;",
          "243:   MG_DEBUG((\"Cleaning up sector %p\", sector));",
          "244:   while ((n = mg_flash_next(sector + ofs, sector + ss, &key, &size)) > 0) {",
          "246:     for (size_t o = 0; o < io.len; o += size2 + hs) {",
          "247:       uint32_t k = *(uint32_t *) (io.buf + o + sizeof(uint32_t));",
          "248:       size2 = *(uint32_t *) (io.buf + o);",
          "249:       if (k == key) {",
          "250:         mg_iobuf_del(&io, o, size2 + hs);",
          "251:         break;",
          "252:       }",
          "255:     mg_iobuf_add(&io, io.len, sector + ofs, size + hs);",
          "256:     ofs += n;",
          "257:   }",
          "259:   if (mg_flash_erase(sector)) {  // Erase sector. If successful,",
          "260:     for (ofs = 0; ofs < io.len; ofs += size + hs) {  // Traverse cached objects",
          "261:       size = *(uint32_t *) (io.buf + ofs);",
          "262:       key = *(uint32_t *) (io.buf + ofs + sizeof(uint32_t));",
          "263:       mg_flash_save(sector, key, io.buf + ofs + hs, size);  // Save to flash",
          "266:   mg_iobuf_free(&io);",
          "270: bool mg_flash_save(void *sector, uint32_t key, const void *buf, size_t len) {",
          "271:   char *base = (char *) mg_flash_start(), *s = (char *) sector;",
          "272:   size_t ss = mg_flash_sector_size(), ofs = 0, n;",
          "273:   bool ok = false;",
          "274:   if (s == NULL) s = flash_last_sector();",
          "275:   if (s < base || s >= base + mg_flash_size()) {",
          "276:     MG_ERROR((\"%p is outsize of flash\", sector));",
          "277:   } else if (((s - base) % ss) != 0) {",
          "278:     MG_ERROR((\"%p is not a sector boundary\", sector));",
          "279:   } else {",
          "280:     size_t needed = sizeof(uint32_t) * 2 + len;",
          "281:     size_t needed_aligned = MG_ROUND_UP(needed, mg_flash_write_align());",
          "282:     while ((n = mg_flash_next(s + ofs, s + ss, NULL, NULL)) > 0) ofs += n;",
          "285:     if (ofs + needed_aligned > ss) {",
          "286:       mg_flash_sector_cleanup(s);",
          "287:       ofs = 0;",
          "288:       while ((n = mg_flash_next(s + ofs, s + ss, NULL, NULL)) > 0) ofs += n;",
          "289:     }",
          "291:     if (ofs + needed_aligned <= ss) {",
          "293:       uint32_t hdr[2] = {(uint32_t) len, key};",
          "294:       struct mg_str data[] = {mg_str_n((char *) hdr, sizeof(hdr)),",
          "295:                               mg_str_n(buf, len)};",
          "296:       ok = mg_flash_writev(s + ofs, data, 2);",
          "297:       MG_DEBUG((\"Saving %lu bytes @ %p, key %x: %d\", len, s + ofs, key, ok));",
          "298:       MG_DEBUG((\"Sector space left: %lu bytes\", ss - ofs - needed_aligned));",
          "299:     } else {",
          "300:       MG_ERROR((\"Sector is full\"));",
          "301:     }",
          "302:   }",
          "303:   return ok;",
          "304: }",
          "305: #else",
          "306: bool mg_flash_save(void *sector, uint32_t key, const void *buf, size_t len) {",
          "307:   (void) sector, (void) key, (void) buf, (void) len;",
          "308:   return false;",
          "309: }",
          "310: bool mg_flash_load(void *sector, uint32_t key, void *buf, size_t len) {",
          "311:   (void) sector, (void) key, (void) buf, (void) len;",
          "312:   return false;",
          "313: }",
          "314: #endif",
          "316: #ifdef MG_ENABLE_LINES",
          "317: #line 1 \"src/device_stm32h5.c\"",
          "318: #endif",
          "322: #if MG_DEVICE == MG_DEVICE_STM32H5",
          "324: #define FLASH_BASE 0x40022000          // Base address of the flash controller",
          "325: #define FLASH_KEYR (FLASH_BASE + 0x4)  // See RM0481 7.11",
          "326: #define FLASH_OPTKEYR (FLASH_BASE + 0xc)",
          "327: #define FLASH_OPTCR (FLASH_BASE + 0x1c)",
          "328: #define FLASH_NSSR (FLASH_BASE + 0x20)",
          "329: #define FLASH_NSCR (FLASH_BASE + 0x28)",
          "330: #define FLASH_NSCCR (FLASH_BASE + 0x30)",
          "331: #define FLASH_OPTSR_CUR (FLASH_BASE + 0x50)",
          "332: #define FLASH_OPTSR_PRG (FLASH_BASE + 0x54)",
          "334: void *mg_flash_start(void) {",
          "335:   return (void *) 0x08000000;",
          "337: size_t mg_flash_size(void) {",
          "338:   return 2 * 1024 * 1024;  // 2Mb",
          "340: size_t mg_flash_sector_size(void) {",
          "341:   return 8 * 1024;  // 8k",
          "343: size_t mg_flash_write_align(void) {",
          "344:   return 16;  // 128 bit",
          "346: int mg_flash_bank(void) {",
          "347:   return MG_REG(FLASH_OPTCR) & MG_BIT(31) ? 2 : 1;",
          "350: static void flash_unlock(void) {",
          "351:   static bool unlocked = false;",
          "352:   if (unlocked == false) {",
          "353:     MG_REG(FLASH_KEYR) = 0x45670123;",
          "354:     MG_REG(FLASH_KEYR) = 0Xcdef89ab;",
          "355:     MG_REG(FLASH_OPTKEYR) = 0x08192a3b;",
          "356:     MG_REG(FLASH_OPTKEYR) = 0x4c5d6e7f;",
          "357:     unlocked = true;",
          "358:   }",
          "361: static int flash_page_start(volatile uint32_t *dst) {",
          "362:   char *base = (char *) mg_flash_start(), *end = base + mg_flash_size();",
          "363:   volatile char *p = (char *) dst;",
          "364:   return p >= base && p < end && ((p - base) % mg_flash_sector_size()) == 0;",
          "367: static bool flash_is_err(void) {",
          "368:   return MG_REG(FLASH_NSSR) & ((MG_BIT(8) - 1) << 17);  // RM0481 7.11.9",
          "371: static void flash_wait(void) {",
          "372:   while ((MG_REG(FLASH_NSSR) & MG_BIT(0)) &&",
          "373:          (MG_REG(FLASH_NSSR) & MG_BIT(16)) == 0) {",
          "374:     (void) 0;",
          "375:   }",
          "378: static void flash_clear_err(void) {",
          "379:   flash_wait();                                    // Wait until ready",
          "380:   MG_REG(FLASH_NSCCR) = ((MG_BIT(9) - 1) << 16U);  // Clear all errors",
          "383: static bool flash_bank_is_swapped(void) {",
          "384:   return MG_REG(FLASH_OPTCR) & MG_BIT(31);  // RM0481 7.11.8",
          "387: bool mg_flash_erase(void *location) {",
          "388:   bool ok = false;",
          "389:   if (flash_page_start(location) == false) {",
          "390:     MG_ERROR((\"%p is not on a sector boundary\"));",
          "392:     uintptr_t diff = (char *) location - (char *) mg_flash_start();",
          "393:     uint32_t sector = diff / mg_flash_sector_size();",
          "394:     flash_unlock();",
          "395:     flash_clear_err();",
          "396:     MG_REG(FLASH_NSCR) = 0;",
          "397:     if ((sector < 128 && flash_bank_is_swapped()) ||",
          "398:         (sector > 127 && !flash_bank_is_swapped())) {",
          "399:       MG_REG(FLASH_NSCR) |= MG_BIT(31);  // Set FLASH_CR_BKSEL",
          "401:     if (sector > 127) sector -= 128;",
          "402:     MG_REG(FLASH_NSCR) |= MG_BIT(2) | (sector << 6);  // Erase | sector_num",
          "403:     MG_REG(FLASH_NSCR) |= MG_BIT(5);                  // Start erasing",
          "404:     flash_wait();",
          "405:     ok = !flash_is_err();",
          "406:     MG_DEBUG((\"Erase sector %lu @ %p: %s. CR %#lx SR %#lx\", sector, location,",
          "407:               ok ? \"ok\" : \"fail\", MG_REG(FLASH_NSCR), MG_REG(FLASH_NSSR)));",
          "410:   return ok;",
          "413: bool mg_flash_swap_bank(void) {",
          "414:   uint32_t desired = flash_bank_is_swapped() ? 0 : MG_BIT(31);",
          "415:   flash_unlock();",
          "416:   flash_clear_err();",
          "418:   MG_SET_BITS(MG_REG(FLASH_OPTSR_PRG), MG_BIT(31), desired);",
          "420:   MG_REG(FLASH_OPTCR) |= MG_BIT(1);  // OPTSTART",
          "421:   while ((MG_REG(FLASH_OPTSR_CUR) & MG_BIT(31)) != desired) (void) 0;",
          "422:   return true;",
          "425: bool mg_flash_write(void *addr, const void *buf, size_t len) {",
          "426:   if ((len % mg_flash_write_align()) != 0) {",
          "427:     MG_ERROR((\"%lu is not aligned to %lu\", len, mg_flash_write_align()));",
          "428:     return false;",
          "429:   }",
          "430:   uint32_t *dst = (uint32_t *) addr;",
          "431:   uint32_t *src = (uint32_t *) buf;",
          "432:   uint32_t *end = (uint32_t *) ((char *) buf + len);",
          "433:   bool ok = true;",
          "434:   flash_unlock();",
          "435:   flash_clear_err();",
          "436:   MG_ARM_DISABLE_IRQ();",
          "438:   while (ok && src < end) {",
          "439:     if (flash_page_start(dst) && mg_flash_erase(dst) == false) break;",
          "440:     MG_REG(FLASH_NSCR) = MG_BIT(1);  // Set programming flag",
          "442:     flash_wait();",
          "443:     if (flash_is_err()) ok = false;",
          "444:   }",
          "445:   MG_DEBUG((\"Flash write %lu bytes @ %p: %s. CR %#lx SR %#lx\", len, dst,",
          "446:             flash_is_err() ? \"fail\" : \"ok\", MG_REG(FLASH_NSCR),",
          "447:             MG_REG(FLASH_NSSR)));",
          "448:   if (flash_is_err()) ok = false;",
          "451:   MG_REG(FLASH_NSCR) = 0;  // Clear flags",
          "452:   MG_ARM_ENABLE_IRQ();",
          "453:   return ok;",
          "456: void mg_device_reset(void) {",
          "460: #endif",
          "463: #line 1 \"src/device_stm32h7.c\"",
          "468: #if MG_DEVICE == MG_DEVICE_STM32H7",
          "470: #define FLASH_BASE1 0x52002000  // Base address for bank1",
          "471: #define FLASH_BASE2 0x52002100  // Base address for bank2",
          "472: #define FLASH_KEYR 0x04         // See RM0433 4.9.2",
          "473: #define FLASH_OPTKEYR 0x08",
          "474: #define FLASH_OPTCR 0x18",
          "475: #define FLASH_SR 0x10",
          "476: #define FLASH_CR 0x0c",
          "477: #define FLASH_CCR 0x14",
          "478: #define FLASH_OPTSR_CUR 0x1c",
          "479: #define FLASH_OPTSR_PRG 0x20",
          "481: void *mg_flash_start(void) {",
          "482:   return (void *) 0x08000000;",
          "483: }",
          "484: size_t mg_flash_size(void) {",
          "485:   return 2 * 1024 * 1024;  // 2Mb",
          "486: }",
          "487: size_t mg_flash_sector_size(void) {",
          "488:   return 128 * 1024;  // 128k",
          "489: }",
          "490: size_t mg_flash_write_align(void) {",
          "491:   return 32;  // 256 bit",
          "492: }",
          "493: int mg_flash_bank(void) {",
          "494:   return MG_REG(FLASH_BASE1 + FLASH_OPTCR) & MG_BIT(31) ? 2 : 1;",
          "497: static void flash_unlock(void) {",
          "498:   static bool unlocked = false;",
          "499:   if (unlocked == false) {",
          "500:     MG_REG(FLASH_BASE1 + FLASH_KEYR) = 0x45670123;",
          "501:     MG_REG(FLASH_BASE1 + FLASH_KEYR) = 0xcdef89ab;",
          "502:     MG_REG(FLASH_BASE2 + FLASH_KEYR) = 0x45670123;",
          "503:     MG_REG(FLASH_BASE2 + FLASH_KEYR) = 0xcdef89ab;",
          "504:     MG_REG(FLASH_BASE1 + FLASH_OPTKEYR) = 0x08192a3b;  // opt reg is \"shared\"",
          "505:     MG_REG(FLASH_BASE1 + FLASH_OPTKEYR) = 0x4c5d6e7f;  // thus unlock once",
          "506:     unlocked = true;",
          "510: static bool flash_page_start(volatile uint32_t *dst) {",
          "511:   char *base = (char *) mg_flash_start(), *end = base + mg_flash_size();",
          "512:   volatile char *p = (char *) dst;",
          "513:   return p >= base && p < end && ((p - base) % mg_flash_sector_size()) == 0;",
          "516: static bool flash_is_err(uint32_t bank) {",
          "517:   return MG_REG(bank + FLASH_SR) & ((MG_BIT(11) - 1) << 17);  // RM0433 4.9.5",
          "518: }",
          "520: static void flash_wait(uint32_t bank) {",
          "521:   while (MG_REG(bank + FLASH_SR) & (MG_BIT(0) | MG_BIT(2))) (void) 0;",
          "522: }",
          "524: static void flash_clear_err(uint32_t bank) {",
          "525:   flash_wait(bank);                                      // Wait until ready",
          "526:   MG_REG(bank + FLASH_CCR) = ((MG_BIT(11) - 1) << 16U);  // Clear all errors",
          "529: static bool flash_bank_is_swapped(uint32_t bank) {",
          "530:   return MG_REG(bank + FLASH_OPTCR) & MG_BIT(31);  // RM0433 4.9.7",
          "534: static uint32_t flash_bank(void *addr) {",
          "535:   size_t ofs = (char *) addr - (char *) mg_flash_start();",
          "536:   return ofs < mg_flash_size() / 2 ? FLASH_BASE1 : FLASH_BASE2;",
          "539: bool mg_flash_erase(void *addr) {",
          "540:   bool ok = false;",
          "541:   if (flash_page_start(addr) == false) {",
          "542:     MG_ERROR((\"%p is not on a sector boundary\", addr));",
          "544:     uintptr_t diff = (char *) addr - (char *) mg_flash_start();",
          "545:     uint32_t sector = diff / mg_flash_sector_size();",
          "546:     uint32_t bank = flash_bank(addr);",
          "548:     flash_unlock();",
          "549:     if (sector > 7) sector -= 8;",
          "552:     flash_clear_err(bank);",
          "553:     MG_REG(bank + FLASH_CR) |= (sector & 7U) << 8U;  // Sector to erase",
          "554:     MG_REG(bank + FLASH_CR) |= MG_BIT(2);            // Sector erase bit",
          "555:     MG_REG(bank + FLASH_CR) |= MG_BIT(7);            // Start erasing",
          "556:     ok = !flash_is_err(bank);",
          "557:     MG_DEBUG((\"Erase sector %lu @ %p %s. CR %#lx SR %#lx\", sector, addr,",
          "558:               ok ? \"ok\" : \"fail\", MG_REG(bank + FLASH_CR),",
          "559:               MG_REG(bank + FLASH_SR)));",
          "562:   return ok;",
          "565: bool mg_flash_swap_bank() {",
          "566:   uint32_t bank = FLASH_BASE1;",
          "567:   uint32_t desired = flash_bank_is_swapped(bank) ? 0 : MG_BIT(31);",
          "568:   flash_unlock();",
          "569:   flash_clear_err(bank);",
          "571:   MG_SET_BITS(MG_REG(bank + FLASH_OPTSR_PRG), MG_BIT(31), desired);",
          "573:   MG_REG(bank + FLASH_OPTCR) |= MG_BIT(1);  // OPTSTART",
          "574:   while ((MG_REG(bank + FLASH_OPTSR_CUR) & MG_BIT(31)) != desired) (void) 0;",
          "575:   return true;",
          "578: bool mg_flash_write(void *addr, const void *buf, size_t len) {",
          "579:   if ((len % mg_flash_write_align()) != 0) {",
          "580:     MG_ERROR((\"%lu is not aligned to %lu\", len, mg_flash_write_align()));",
          "581:     return false;",
          "583:   uint32_t bank = flash_bank(addr);",
          "584:   uint32_t *dst = (uint32_t *) addr;",
          "585:   uint32_t *src = (uint32_t *) buf;",
          "586:   uint32_t *end = (uint32_t *) ((char *) buf + len);",
          "587:   bool ok = true;",
          "588:   flash_unlock();",
          "589:   flash_clear_err(bank);",
          "590:   MG_ARM_DISABLE_IRQ();",
          "591:   MG_REG(bank + FLASH_CR) = MG_BIT(1);  // Set programming flag",
          "593:   while (ok && src < end) {",
          "594:     if (flash_page_start(dst) && mg_flash_erase(dst) == false) break;",
          "596:     flash_wait(bank);",
          "597:     if (flash_is_err(bank)) ok = false;",
          "598:   }",
          "599:   MG_DEBUG((\"Flash write %lu bytes @ %p: %s. CR %#lx SR %#lx\", len, dst,",
          "600:             ok ? \"ok\" : \"fail\", MG_REG(bank + FLASH_CR),",
          "601:             MG_REG(bank + FLASH_SR)));",
          "603:   MG_REG(bank + FLASH_CR) &= ~MG_BIT(1);  // Clear programming flag",
          "604:   MG_ARM_ENABLE_IRQ();",
          "605:   return ok;",
          "608: void mg_device_reset(void) {",
          "612: #endif",
          "614: #ifdef MG_ENABLE_LINES",
          "615: #line 1 \"src/dns.c\"",
          "616: #endif",
          "625: struct dns_data {",
          "626:   struct dns_data *next;",
          "627:   struct mg_connection *c;",
          "628:   uint64_t expire;",
          "629:   uint16_t txnid;",
          "632: static void mg_sendnsreq(struct mg_connection *, struct mg_str *, int,",
          "633:                          struct mg_dns *, bool);",
          "635: static void mg_dns_free(struct dns_data **head, struct dns_data *d) {",
          "636:   LIST_DELETE(struct dns_data, head, d);",
          "637:   free(d);",
          "640: void mg_resolve_cancel(struct mg_connection *c) {",
          "641:   struct dns_data *tmp, *d;",
          "642:   struct dns_data **head = (struct dns_data **) &c->mgr->active_dns_requests;",
          "643:   for (d = *head; d != NULL; d = tmp) {",
          "644:     tmp = d->next;",
          "645:     if (d->c == c) mg_dns_free(head, d);",
          "649: static size_t mg_dns_parse_name_depth(const uint8_t *s, size_t len, size_t ofs,",
          "650:                                       char *to, size_t tolen, size_t j,",
          "651:                                       int depth) {",
          "652:   size_t i = 0;",
          "653:   if (tolen > 0 && depth == 0) to[0] = '\\0';",
          "654:   if (depth > 5) return 0;",
          "656:   while (ofs + i + 1 < len) {",
          "657:     size_t n = s[ofs + i];",
          "658:     if (n == 0) {",
          "659:       i++;",
          "660:       break;",
          "661:     }",
          "662:     if (n & 0xc0) {",
          "663:       size_t ptr = (((n & 0x3f) << 8) | s[ofs + i + 1]);  // 12 is hdr len",
          "665:       if (ptr + 1 < len && (s[ptr] & 0xc0) == 0 &&",
          "666:           mg_dns_parse_name_depth(s, len, ptr, to, tolen, j, depth + 1) == 0)",
          "667:         return 0;",
          "668:       i += 2;",
          "669:       break;",
          "670:     }",
          "671:     if (ofs + i + n + 1 >= len) return 0;",
          "672:     if (j > 0) {",
          "673:       if (j < tolen) to[j] = '.';",
          "674:       j++;",
          "675:     }",
          "676:     if (j + n < tolen) memcpy(&to[j], &s[ofs + i + 1], n);",
          "677:     j += n;",
          "678:     i += n + 1;",
          "679:     if (j < tolen) to[j] = '\\0';  // Zero-terminate this chunk",
          "682:   if (tolen > 0) to[tolen - 1] = '\\0';  // Make sure make sure it is nul-term",
          "683:   return i;",
          "686: static size_t mg_dns_parse_name(const uint8_t *s, size_t n, size_t ofs,",
          "687:                                 char *dst, size_t dstlen) {",
          "688:   return mg_dns_parse_name_depth(s, n, ofs, dst, dstlen, 0, 0);",
          "691: size_t mg_dns_parse_rr(const uint8_t *buf, size_t len, size_t ofs,",
          "692:                        bool is_question, struct mg_dns_rr *rr) {",
          "693:   const uint8_t *s = buf + ofs, *e = &buf[len];",
          "695:   memset(rr, 0, sizeof(*rr));",
          "696:   if (len < sizeof(struct mg_dns_header)) return 0;  // Too small",
          "697:   if (len > 512) return 0;  //  Too large, we don't expect that",
          "698:   if (s >= e) return 0;     //  Overflow",
          "700:   if ((rr->nlen = (uint16_t) mg_dns_parse_name(buf, len, ofs, NULL, 0)) == 0)",
          "701:     return 0;",
          "702:   s += rr->nlen + 4;",
          "703:   if (s > e) return 0;",
          "704:   rr->atype = (uint16_t) (((uint16_t) s[-4] << 8) | s[-3]);",
          "705:   rr->aclass = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);",
          "706:   if (is_question) return (size_t) (rr->nlen + 4);",
          "708:   s += 6;",
          "709:   if (s > e) return 0;",
          "710:   rr->alen = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);",
          "711:   if (s + rr->alen > e) return 0;",
          "712:   return (size_t) (rr->nlen + rr->alen + 10);",
          "715: bool mg_dns_parse(const uint8_t *buf, size_t len, struct mg_dns_message *dm) {",
          "716:   const struct mg_dns_header *h = (struct mg_dns_header *) buf;",
          "717:   struct mg_dns_rr rr;",
          "718:   size_t i, n, ofs = sizeof(*h);",
          "719:   memset(dm, 0, sizeof(*dm));",
          "721:   if (len < sizeof(*h)) return 0;                // Too small, headers dont fit",
          "722:   if (mg_ntohs(h->num_questions) > 1) return 0;  // Sanity",
          "723:   if (mg_ntohs(h->num_answers) > 10) return 0;   // Sanity",
          "724:   dm->txnid = mg_ntohs(h->txnid);",
          "726:   for (i = 0; i < mg_ntohs(h->num_questions); i++) {",
          "727:     if ((n = mg_dns_parse_rr(buf, len, ofs, true, &rr)) == 0) return false;",
          "729:     ofs += n;",
          "730:   }",
          "731:   for (i = 0; i < mg_ntohs(h->num_answers); i++) {",
          "732:     if ((n = mg_dns_parse_rr(buf, len, ofs, false, &rr)) == 0) return false;",
          "735:     mg_dns_parse_name(buf, len, ofs, dm->name, sizeof(dm->name));",
          "736:     ofs += n;",
          "738:     if (rr.alen == 4 && rr.atype == 1 && rr.aclass == 1) {",
          "739:       dm->addr.is_ip6 = false;",
          "740:       memcpy(&dm->addr.ip, &buf[ofs - 4], 4);",
          "741:       dm->resolved = true;",
          "742:       break;  // Return success",
          "743:     } else if (rr.alen == 16 && rr.atype == 28 && rr.aclass == 1) {",
          "744:       dm->addr.is_ip6 = true;",
          "745:       memcpy(&dm->addr.ip, &buf[ofs - 16], 16);",
          "746:       dm->resolved = true;",
          "747:       break;  // Return success",
          "750:   return true;",
          "753: static void dns_cb(struct mg_connection *c, int ev, void *ev_data,",
          "754:                    void *fn_data) {",
          "755:   struct dns_data *d, *tmp;",
          "756:   struct dns_data **head = (struct dns_data **) &c->mgr->active_dns_requests;",
          "757:   if (ev == MG_EV_POLL) {",
          "758:     uint64_t now = *(uint64_t *) ev_data;",
          "759:     for (d = *head; d != NULL; d = tmp) {",
          "760:       tmp = d->next;",
          "762:       if (now > d->expire) mg_error(d->c, \"DNS timeout\");",
          "763:     }",
          "764:   } else if (ev == MG_EV_READ) {",
          "765:     struct mg_dns_message dm;",
          "766:     int resolved = 0;",
          "767:     if (mg_dns_parse(c->recv.buf, c->recv.len, &dm) == false) {",
          "768:       MG_ERROR((\"Unexpected DNS response:\"));",
          "769:       mg_hexdump(c->recv.buf, c->recv.len);",
          "770:     } else {",
          "772:       for (d = *head; d != NULL; d = tmp) {",
          "773:         tmp = d->next;",
          "775:         if (dm.txnid != d->txnid) continue;",
          "776:         if (d->c->is_resolving) {",
          "777:           if (dm.resolved) {",
          "778:             dm.addr.port = d->c->rem.port;  // Save port",
          "779:             d->c->rem = dm.addr;            // Copy resolved address",
          "780:             MG_DEBUG(",
          "781:                 (\"%lu %s is %M\", d->c->id, dm.name, mg_print_ip, &d->c->rem));",
          "782:             mg_connect_resolved(d->c);",
          "783: #if MG_ENABLE_IPV6",
          "784:           } else if (dm.addr.is_ip6 == false && dm.name[0] != '\\0' &&",
          "785:                      c->mgr->use_dns6 == false) {",
          "786:             struct mg_str x = mg_str(dm.name);",
          "787:             mg_sendnsreq(d->c, &x, c->mgr->dnstimeout, &c->mgr->dns6, true);",
          "788: #endif",
          "789:           } else {",
          "790:             mg_error(d->c, \"%s DNS lookup failed\", dm.name);",
          "791:           }",
          "792:         } else {",
          "793:           MG_ERROR((\"%lu already resolved\", d->c->id));",
          "794:         }",
          "795:         mg_dns_free(head, d);",
          "796:         resolved = 1;",
          "797:       }",
          "798:     }",
          "799:     if (!resolved) MG_ERROR((\"stray DNS reply\"));",
          "800:     c->recv.len = 0;",
          "801:   } else if (ev == MG_EV_CLOSE) {",
          "802:     for (d = *head; d != NULL; d = tmp) {",
          "803:       tmp = d->next;",
          "804:       mg_error(d->c, \"DNS error\");",
          "805:       mg_dns_free(head, d);",
          "806:     }",
          "808:   (void) fn_data;",
          "811: static bool mg_dns_send(struct mg_connection *c, const struct mg_str *name,",
          "812:                         uint16_t txnid, bool ipv6) {",
          "813:   struct {",
          "814:     struct mg_dns_header header;",
          "815:     uint8_t data[256];",
          "816:   } pkt;",
          "817:   size_t i, n;",
          "818:   memset(&pkt, 0, sizeof(pkt));",
          "819:   pkt.header.txnid = mg_htons(txnid);",
          "820:   pkt.header.flags = mg_htons(0x100);",
          "821:   pkt.header.num_questions = mg_htons(1);",
          "822:   for (i = n = 0; i < sizeof(pkt.data) - 5; i++) {",
          "823:     if (name->ptr[i] == '.' || i >= name->len) {",
          "824:       pkt.data[n] = (uint8_t) (i - n);",
          "825:       memcpy(&pkt.data[n + 1], name->ptr + n, i - n);",
          "826:       n = i + 1;",
          "827:     }",
          "828:     if (i >= name->len) break;",
          "830:   memcpy(&pkt.data[n], \"\\x00\\x00\\x01\\x00\\x01\", 5);  // A query",
          "831:   n += 5;",
          "832:   if (ipv6) pkt.data[n - 3] = 0x1c;  // AAAA query",
          "835:   return mg_send(c, &pkt, sizeof(pkt.header) + n);",
          "838: static void mg_sendnsreq(struct mg_connection *c, struct mg_str *name, int ms,",
          "839:                          struct mg_dns *dnsc, bool ipv6) {",
          "840:   struct dns_data *d = NULL;",
          "841:   if (dnsc->url == NULL) {",
          "842:     mg_error(c, \"DNS server URL is NULL. Call mg_mgr_init()\");",
          "843:   } else if (dnsc->c == NULL) {",
          "844:     dnsc->c = mg_connect(c->mgr, dnsc->url, NULL, NULL);",
          "845:     if (dnsc->c != NULL) {",
          "846:       dnsc->c->pfn = dns_cb;",
          "850:   if (dnsc->c == NULL) {",
          "851:     mg_error(c, \"resolver\");",
          "852:   } else if ((d = (struct dns_data *) calloc(1, sizeof(*d))) == NULL) {",
          "853:     mg_error(c, \"resolve OOM\");",
          "855:     struct dns_data *reqs = (struct dns_data *) c->mgr->active_dns_requests;",
          "856:     d->txnid = reqs ? (uint16_t) (reqs->txnid + 1) : 1;",
          "857:     d->next = (struct dns_data *) c->mgr->active_dns_requests;",
          "858:     c->mgr->active_dns_requests = d;",
          "859:     d->expire = mg_millis() + (uint64_t) ms;",
          "860:     d->c = c;",
          "861:     c->is_resolving = 1;",
          "862:     MG_VERBOSE((\"%lu resolving %.*s @ %s, txnid %hu\", c->id, (int) name->len,",
          "863:                 name->ptr, dnsc->url, d->txnid));",
          "864:     if (!mg_dns_send(dnsc->c, name, d->txnid, ipv6)) {",
          "865:       mg_error(dnsc->c, \"DNS send\");",
          "866:     }",
          "870: void mg_resolve(struct mg_connection *c, const char *url) {",
          "871:   struct mg_str host = mg_url_host(url);",
          "872:   c->rem.port = mg_htons(mg_url_port(url));",
          "873:   if (mg_aton(host, &c->rem)) {",
          "875:     mg_connect_resolved(c);",
          "878:     struct mg_dns *dns = c->mgr->use_dns6 ? &c->mgr->dns6 : &c->mgr->dns4;",
          "879:     mg_sendnsreq(c, &host, c->mgr->dnstimeout, dns, c->mgr->use_dns6);",
          "883: #ifdef MG_ENABLE_LINES",
          "884: #line 1 \"src/event.c\"",
          "891: void mg_call(struct mg_connection *c, int ev, void *ev_data) {",
          "895:   if (c->fn != NULL) c->fn(c, ev, ev_data, c->fn_data);",
          "896:   if (c->pfn != NULL) c->pfn(c, ev, ev_data, c->pfn_data);",
          "899: void mg_error(struct mg_connection *c, const char *fmt, ...) {",
          "900:   char buf[64];",
          "901:   va_list ap;",
          "902:   va_start(ap, fmt);",
          "903:   mg_vsnprintf(buf, sizeof(buf), fmt, &ap);",
          "904:   va_end(ap);",
          "905:   MG_ERROR((\"%lu %ld %s\", c->id, c->fd, buf));",
          "906:   c->is_closing = 1;             // Set is_closing before sending MG_EV_CALL",
          "907:   mg_call(c, MG_EV_ERROR, buf);  // Let user handler to override it",
          "911: #line 1 \"src/fmt.c\"",
          "917: static bool is_digit(int c) {",
          "918:   return c >= '0' && c <= '9';",
          "919: }",
          "921: static int addexp(char *buf, int e, int sign) {",
          "922:   int n = 0;",
          "923:   buf[n++] = 'e';",
          "924:   buf[n++] = (char) sign;",
          "925:   if (e > 400) return 0;",
          "926:   if (e < 10) buf[n++] = '0';",
          "927:   if (e >= 100) buf[n++] = (char) (e / 100 + '0'), e -= 100 * (e / 100);",
          "928:   if (e >= 10) buf[n++] = (char) (e / 10 + '0'), e -= 10 * (e / 10);",
          "929:   buf[n++] = (char) (e + '0');",
          "930:   return n;",
          "931: }",
          "933: static int xisinf(double x) {",
          "934:   union {",
          "935:     double f;",
          "936:     uint64_t u;",
          "937:   } ieee754 = {x};",
          "938:   return ((unsigned) (ieee754.u >> 32) & 0x7fffffff) == 0x7ff00000 &&",
          "939:          ((unsigned) ieee754.u == 0);",
          "940: }",
          "942: static int xisnan(double x) {",
          "943:   union {",
          "944:     double f;",
          "945:     uint64_t u;",
          "946:   } ieee754 = {x};",
          "947:   return ((unsigned) (ieee754.u >> 32) & 0x7fffffff) +",
          "948:              ((unsigned) ieee754.u != 0) >",
          "949:          0x7ff00000;",
          "950: }",
          "952: static size_t mg_dtoa(char *dst, size_t dstlen, double d, int width, bool tz) {",
          "953:   char buf[40];",
          "954:   int i, s = 0, n = 0, e = 0;",
          "955:   double t, mul, saved;",
          "956:   if (d == 0.0) return mg_snprintf(dst, dstlen, \"%s\", \"0\");",
          "957:   if (xisinf(d)) return mg_snprintf(dst, dstlen, \"%s\", d > 0 ? \"inf\" : \"-inf\");",
          "958:   if (xisnan(d)) return mg_snprintf(dst, dstlen, \"%s\", \"nan\");",
          "959:   if (d < 0.0) d = -d, buf[s++] = '-';",
          "962:   saved = d;",
          "963:   mul = 1.0;",
          "964:   while (d >= 10.0 && d / mul >= 10.0) mul *= 10.0;",
          "965:   while (d <= 1.0 && d / mul <= 1.0) mul /= 10.0;",
          "966:   for (i = 0, t = mul * 5; i < width; i++) t /= 10.0;",
          "967:   d += t;",
          "969:   mul = 1.0;",
          "970:   while (d >= 10.0 && d / mul >= 10.0) mul *= 10.0, e++;",
          "971:   while (d < 1.0 && d / mul < 1.0) mul /= 10.0, e--;",
          "974:   if (e >= width && width > 1) {",
          "975:     n = (int) mg_dtoa(buf, sizeof(buf), saved / mul, width, tz);",
          "977:     n += addexp(buf + s + n, e, '+');",
          "978:     return mg_snprintf(dst, dstlen, \"%.*s\", n, buf);",
          "979:   } else if (e <= -width && width > 1) {",
          "980:     n = (int) mg_dtoa(buf, sizeof(buf), saved / mul, width, tz);",
          "982:     n += addexp(buf + s + n, -e, '-');",
          "983:     return mg_snprintf(dst, dstlen, \"%.*s\", n, buf);",
          "984:   } else {",
          "985:     for (i = 0, t = mul; t >= 1.0 && s + n < (int) sizeof(buf); i++) {",
          "986:       int ch = (int) (d / t);",
          "987:       if (n > 0 || ch > 0) buf[s + n++] = (char) (ch + '0');",
          "988:       d -= ch * t;",
          "989:       t /= 10.0;",
          "990:     }",
          "992:     if (n == 0) buf[s++] = '0';",
          "993:     while (t >= 1.0 && n + s < (int) sizeof(buf)) buf[n++] = '0', t /= 10.0;",
          "994:     if (s + n < (int) sizeof(buf)) buf[n + s++] = '.';",
          "996:     for (i = 0, t = 0.1; s + n < (int) sizeof(buf) && n < width; i++) {",
          "997:       int ch = (int) (d / t);",
          "998:       buf[s + n++] = (char) (ch + '0');",
          "999:       d -= ch * t;",
          "1000:       t /= 10.0;",
          "1001:     }",
          "1003:   while (tz && n > 0 && buf[s + n - 1] == '0') n--;  // Trim trailing zeroes",
          "1004:   if (n > 0 && buf[s + n - 1] == '.') n--;           // Trim trailing dot",
          "1005:   n += s;",
          "1006:   if (n >= (int) sizeof(buf)) n = (int) sizeof(buf) - 1;",
          "1007:   buf[n] = '\\0';",
          "1008:   return mg_snprintf(dst, dstlen, \"%s\", buf);",
          "1011: static size_t mg_lld(char *buf, int64_t val, bool is_signed, bool is_hex) {",
          "1012:   const char *letters = \"0123456789abcdef\";",
          "1013:   uint64_t v = (uint64_t) val;",
          "1014:   size_t s = 0, n, i;",
          "1015:   if (is_signed && val < 0) buf[s++] = '-', v = (uint64_t) (-val);",
          "1019:   if (is_hex) {",
          "1020:     for (n = 0; v; v >>= 4) buf[s + n++] = letters[v & 15];",
          "1021:   } else {",
          "1022:     for (n = 0; v; v /= 10) buf[s + n++] = letters[v % 10];",
          "1025:   for (i = 0; i < n / 2; i++) {",
          "1026:     char t = buf[s + i];",
          "1027:     buf[s + i] = buf[s + n - i - 1], buf[s + n - i - 1] = t;",
          "1028:   }",
          "1029:   if (val == 0) buf[n++] = '0';  // Handle special case",
          "1030:   return n + s;",
          "1031: }",
          "1033: static size_t scpy(void (*out)(char, void *), void *ptr, char *buf,",
          "1034:                           size_t len) {",
          "1035:   size_t i = 0;",
          "1036:   while (i < len && buf[i] != '\\0') out(buf[i++], ptr);",
          "1037:   return i;",
          "1040: size_t mg_xprintf(void (*out)(char, void *), void *ptr, const char *fmt, ...) {",
          "1041:   size_t len = 0;",
          "1042:   va_list ap;",
          "1043:   va_start(ap, fmt);",
          "1044:   len = mg_vxprintf(out, ptr, fmt, &ap);",
          "1045:   va_end(ap);",
          "1046:   return len;",
          "1049: size_t mg_vxprintf(void (*out)(char, void *), void *param, const char *fmt,",
          "1050:                    va_list *ap) {",
          "1051:   size_t i = 0, n = 0;",
          "1052:   while (fmt[i] != '\\0') {",
          "1053:     if (fmt[i] == '%') {",
          "1054:       size_t j, k, x = 0, is_long = 0, w = 0 /* width */, pr = ~0U /* prec */;",
          "1055:       char pad = ' ', minus = 0, c = fmt[++i];",
          "1056:       if (c == '#') x++, c = fmt[++i];",
          "1057:       if (c == '-') minus++, c = fmt[++i];",
          "1058:       if (c == '0') pad = '0', c = fmt[++i];",
          "1059:       while (is_digit(c)) w *= 10, w += (size_t) (c - '0'), c = fmt[++i];",
          "1060:       if (c == '.') {",
          "1061:         c = fmt[++i];",
          "1062:         if (c == '*') {",
          "1063:           pr = (size_t) va_arg(*ap, int);",
          "1064:           c = fmt[++i];",
          "1065:         } else {",
          "1066:           pr = 0;",
          "1067:           while (is_digit(c)) pr *= 10, pr += (size_t) (c - '0'), c = fmt[++i];",
          "1068:         }",
          "1069:       }",
          "1070:       while (c == 'h') c = fmt[++i];  // Treat h and hh as int",
          "1071:       if (c == 'l') {",
          "1072:         is_long++, c = fmt[++i];",
          "1073:         if (c == 'l') is_long++, c = fmt[++i];",
          "1074:       }",
          "1075:       if (c == 'p') x = 1, is_long = 1;",
          "1076:       if (c == 'd' || c == 'u' || c == 'x' || c == 'X' || c == 'p' ||",
          "1077:           c == 'g' || c == 'f') {",
          "1078:         bool s = (c == 'd'), h = (c == 'x' || c == 'X' || c == 'p');",
          "1079:         char tmp[40];",
          "1080:         size_t xl = x ? 2 : 0;",
          "1081:         if (c == 'g' || c == 'f') {",
          "1082:           double v = va_arg(*ap, double);",
          "1083:           if (pr == ~0U) pr = 6;",
          "1084:           k = mg_dtoa(tmp, sizeof(tmp), v, (int) pr, c == 'g');",
          "1085:         } else if (is_long == 2) {",
          "1086:           int64_t v = va_arg(*ap, int64_t);",
          "1087:           k = mg_lld(tmp, v, s, h);",
          "1088:         } else if (is_long == 1) {",
          "1089:           long v = va_arg(*ap, long);",
          "1090:           k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned long) v, s, h);",
          "1091:         } else {",
          "1092:           int v = va_arg(*ap, int);",
          "1093:           k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned) v, s, h);",
          "1094:         }",
          "1095:         for (j = 0; j < xl && w > 0; j++) w--;",
          "1096:         for (j = 0; pad == ' ' && !minus && k < w && j + k < w; j++)",
          "1097:           n += scpy(out, param, &pad, 1);",
          "1098:         n += scpy(out, param, (char *) \"0x\", xl);",
          "1099:         for (j = 0; pad == '0' && k < w && j + k < w; j++)",
          "1100:           n += scpy(out, param, &pad, 1);",
          "1101:         n += scpy(out, param, tmp, k);",
          "1102:         for (j = 0; pad == ' ' && minus && k < w && j + k < w; j++)",
          "1103:           n += scpy(out, param, &pad, 1);",
          "1104:       } else if (c == 'm' || c == 'M') {",
          "1105:         mg_pm_t f = va_arg(*ap, mg_pm_t);",
          "1106:         if (c == 'm') out('\"', param);",
          "1107:         n += f(out, param, ap);",
          "1108:         if (c == 'm') n += 2, out('\"', param);",
          "1109:       } else if (c == 'c') {",
          "1110:         int ch = va_arg(*ap, int);",
          "1111:         out((char) ch, param);",
          "1112:         n++;",
          "1113:       } else if (c == 's') {",
          "1114:         char *p = va_arg(*ap, char *);",
          "1115:         if (pr == ~0U) pr = p == NULL ? 0 : strlen(p);",
          "1116:         for (j = 0; !minus && pr < w && j + pr < w; j++)",
          "1117:           n += scpy(out, param, &pad, 1);",
          "1118:         n += scpy(out, param, p, pr);",
          "1119:         for (j = 0; minus && pr < w && j + pr < w; j++)",
          "1120:           n += scpy(out, param, &pad, 1);",
          "1121:       } else if (c == '%') {",
          "1122:         out('%', param);",
          "1123:         n++;",
          "1124:       } else {",
          "1125:         out('%', param);",
          "1126:         out(c, param);",
          "1127:         n += 2;",
          "1128:       }",
          "1129:       i++;",
          "1130:     } else {",
          "1131:       out(fmt[i], param), n++, i++;",
          "1134:   return n;",
          "1137: #ifdef MG_ENABLE_LINES",
          "1138: #line 1 \"src/fs.c\"",
          "1139: #endif",
          "1143: struct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags) {",
          "1144:   struct mg_fd *fd = (struct mg_fd *) calloc(1, sizeof(*fd));",
          "1145:   if (fd != NULL) {",
          "1146:     fd->fd = fs->op(path, flags);",
          "1147:     fd->fs = fs;",
          "1148:     if (fd->fd == NULL) {",
          "1149:       free(fd);",
          "1150:       fd = NULL;",
          "1153:   return fd;",
          "1156: void mg_fs_close(struct mg_fd *fd) {",
          "1157:   if (fd != NULL) {",
          "1158:     fd->fs->cl(fd->fd);",
          "1159:     free(fd);",
          "1160:   }",
          "1163: char *mg_file_read(struct mg_fs *fs, const char *path, size_t *sizep) {",
          "1164:   struct mg_fd *fd;",
          "1165:   char *data = NULL;",
          "1166:   size_t size = 0;",
          "1167:   fs->st(path, &size, NULL);",
          "1168:   if ((fd = mg_fs_open(fs, path, MG_FS_READ)) != NULL) {",
          "1169:     data = (char *) calloc(1, size + 1);",
          "1170:     if (data != NULL) {",
          "1171:       if (fs->rd(fd->fd, data, size) != size) {",
          "1172:         free(data);",
          "1173:         data = NULL;",
          "1175:         data[size] = '\\0';",
          "1176:         if (sizep != NULL) *sizep = size;",
          "1179:     mg_fs_close(fd);",
          "1181:   return data;",
          "1184: bool mg_file_write(struct mg_fs *fs, const char *path, const void *buf,",
          "1185:                    size_t len) {",
          "1186:   bool result = false;",
          "1187:   struct mg_fd *fd;",
          "1188:   char tmp[MG_PATH_MAX];",
          "1189:   mg_snprintf(tmp, sizeof(tmp), \"%s..%d\", path, rand());",
          "1190:   if ((fd = mg_fs_open(fs, tmp, MG_FS_WRITE)) != NULL) {",
          "1191:     result = fs->wr(fd->fd, buf, len) == len;",
          "1192:     mg_fs_close(fd);",
          "1193:     if (result) {",
          "1194:       fs->rm(path);",
          "1195:       fs->mv(tmp, path);",
          "1196:     } else {",
          "1197:       fs->rm(tmp);",
          "1198:     }",
          "1200:   return result;",
          "1203: bool mg_file_printf(struct mg_fs *fs, const char *path, const char *fmt, ...) {",
          "1204:   va_list ap;",
          "1205:   char *data;",
          "1206:   bool result = false;",
          "1207:   va_start(ap, fmt);",
          "1208:   data = mg_vmprintf(fmt, &ap);",
          "1209:   va_end(ap);",
          "1210:   result = mg_file_write(fs, path, data, strlen(data));",
          "1211:   free(data);",
          "1212:   return result;",
          "1215: #ifdef MG_ENABLE_LINES",
          "1216: #line 1 \"src/fs_fat.c\"",
          "1217: #endif",
          "1221: #if MG_ENABLE_FATFS",
          "1222: #include <ff.h>",
          "1224: static int mg_days_from_epoch(int y, int m, int d) {",
          "1225:   y -= m <= 2;",
          "1226:   int era = y / 400;",
          "1227:   int yoe = y - era * 400;",
          "1228:   int doy = (153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1;",
          "1229:   int doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;",
          "1230:   return era * 146097 + doe - 719468;",
          "1231: }",
          "1233: static time_t mg_timegm(const struct tm *t) {",
          "1234:   int year = t->tm_year + 1900;",
          "1235:   int month = t->tm_mon;  // 0-11",
          "1236:   if (month > 11) {",
          "1237:     year += month / 12;",
          "1238:     month %= 12;",
          "1239:   } else if (month < 0) {",
          "1240:     int years_diff = (11 - month) / 12;",
          "1241:     year -= years_diff;",
          "1242:     month += 12 * years_diff;",
          "1244:   int x = mg_days_from_epoch(year, month + 1, t->tm_mday);",
          "1245:   return 60 * (60 * (24L * x + t->tm_hour) + t->tm_min) + t->tm_sec;",
          "1246: }",
          "1248: static time_t ff_time_to_epoch(uint16_t fdate, uint16_t ftime) {",
          "1249:   struct tm tm;",
          "1250:   memset(&tm, 0, sizeof(struct tm));",
          "1251:   tm.tm_sec = (ftime << 1) & 0x3e;",
          "1252:   tm.tm_min = ((ftime >> 5) & 0x3f);",
          "1253:   tm.tm_hour = ((ftime >> 11) & 0x1f);",
          "1254:   tm.tm_mday = (fdate & 0x1f);",
          "1255:   tm.tm_mon = ((fdate >> 5) & 0x0f) - 1;",
          "1256:   tm.tm_year = ((fdate >> 9) & 0x7f) + 80;",
          "1257:   return mg_timegm(&tm);",
          "1258: }",
          "1260: static int ff_stat(const char *path, size_t *size, time_t *mtime) {",
          "1261:   FILINFO fi;",
          "1262:   if (path[0] == '\\0') {",
          "1263:     if (size) *size = 0;",
          "1264:     if (mtime) *mtime = 0;",
          "1265:     return MG_FS_DIR;",
          "1266:   } else if (f_stat(path, &fi) == 0) {",
          "1267:     if (size) *size = (size_t) fi.fsize;",
          "1268:     if (mtime) *mtime = ff_time_to_epoch(fi.fdate, fi.ftime);",
          "1269:     return MG_FS_READ | MG_FS_WRITE | ((fi.fattrib & AM_DIR) ? MG_FS_DIR : 0);",
          "1270:   } else {",
          "1271:     return 0;",
          "1273: }",
          "1275: static void ff_list(const char *dir, void (*fn)(const char *, void *),",
          "1276:                     void *userdata) {",
          "1277:   DIR d;",
          "1278:   FILINFO fi;",
          "1279:   if (f_opendir(&d, dir) == FR_OK) {",
          "1280:     while (f_readdir(&d, &fi) == FR_OK && fi.fname[0] != '\\0') {",
          "1281:       if (!strcmp(fi.fname, \".\") || !strcmp(fi.fname, \"..\")) continue;",
          "1282:       fn(fi.fname, userdata);",
          "1283:     }",
          "1284:     f_closedir(&d);",
          "1286: }",
          "1288: static void *ff_open(const char *path, int flags) {",
          "1289:   FIL f;",
          "1290:   unsigned char mode = FA_READ;",
          "1291:   if (flags & MG_FS_WRITE) mode |= FA_WRITE | FA_OPEN_ALWAYS | FA_OPEN_APPEND;",
          "1292:   if (f_open(&f, path, mode) == 0) {",
          "1293:     FIL *fp;",
          "1294:     if ((fp = calloc(1, sizeof(*fp))) != NULL) {",
          "1295:       memcpy(fp, &f, sizeof(*fp));",
          "1296:       return fp;",
          "1297:     }",
          "1299:   return NULL;",
          "1300: }",
          "1302: static void ff_close(void *fp) {",
          "1303:   if (fp != NULL) {",
          "1304:     f_close((FIL *) fp);",
          "1305:     free(fp);",
          "1306:   }",
          "1309: static size_t ff_read(void *fp, void *buf, size_t len) {",
          "1310:   UINT n = 0, misalign = ((size_t) buf) & 3;",
          "1311:   if (misalign) {",
          "1312:     char aligned[4];",
          "1313:     f_read((FIL *) fp, aligned, len > misalign ? misalign : len, &n);",
          "1314:     memcpy(buf, aligned, n);",
          "1315:   } else {",
          "1316:     f_read((FIL *) fp, buf, len, &n);",
          "1318:   return n;",
          "1321: static size_t ff_write(void *fp, const void *buf, size_t len) {",
          "1322:   UINT n = 0;",
          "1323:   return f_write((FIL *) fp, (char *) buf, len, &n) == FR_OK ? n : 0;",
          "1326: static size_t ff_seek(void *fp, size_t offset) {",
          "1327:   f_lseek((FIL *) fp, offset);",
          "1328:   return offset;",
          "1331: static bool ff_rename(const char *from, const char *to) {",
          "1332:   return f_rename(from, to) == FR_OK;",
          "1335: static bool ff_remove(const char *path) {",
          "1336:   return f_unlink(path) == FR_OK;",
          "1339: static bool ff_mkdir(const char *path) {",
          "1340:   return f_mkdir(path) == FR_OK;",
          "1343: struct mg_fs mg_fs_fat = {ff_stat,  ff_list, ff_open,   ff_close,  ff_read,",
          "1344:                           ff_write, ff_seek, ff_rename, ff_remove, ff_mkdir};",
          "1345: #endif",
          "1347: #ifdef MG_ENABLE_LINES",
          "1348: #line 1 \"src/fs_packed.c\"",
          "1349: #endif",
          "1354: struct packed_file {",
          "1355:   const char *data;",
          "1356:   size_t size;",
          "1357:   size_t pos;",
          "1360: #if MG_ENABLE_PACKED_FS",
          "1361: #else",
          "1362: const char *mg_unpack(const char *path, size_t *size, time_t *mtime) {",
          "1364:   (void) path;",
          "1365:   return NULL;",
          "1366: }",
          "1367: const char *mg_unlist(size_t no) {",
          "1368:   (void) no;",
          "1369:   return NULL;",
          "1370: }",
          "1371: #endif",
          "1373: struct mg_str mg_unpacked(const char *path) {",
          "1374:   size_t len = 0;",
          "1375:   const char *buf = mg_unpack(path, &len, NULL);",
          "1376:   return mg_str_n(buf, len);",
          "1377: }",
          "1379: static int is_dir_prefix(const char *prefix, size_t n, const char *path) {",
          "1381:   return n < strlen(path) && strncmp(prefix, path, n) == 0 &&",
          "1382:          (n == 0 || path[n] == '/' || path[n - 1] == '/');",
          "1383: }",
          "1385: static int packed_stat(const char *path, size_t *size, time_t *mtime) {",
          "1386:   const char *p;",
          "1387:   size_t i, n = strlen(path);",
          "1388:   if (mg_unpack(path, size, mtime)) return MG_FS_READ;  // Regular file",
          "1390:   for (i = 0; (p = mg_unlist(i)) != NULL; i++) {",
          "1391:     if (is_dir_prefix(path, n, p)) return MG_FS_DIR;",
          "1393:   return 0;",
          "1396: static void packed_list(const char *dir, void (*fn)(const char *, void *),",
          "1397:                         void *userdata) {",
          "1398:   char buf[MG_PATH_MAX], tmp[sizeof(buf)];",
          "1399:   const char *path, *begin, *end;",
          "1400:   size_t i, n = strlen(dir);",
          "1401:   tmp[0] = '\\0';  // Previously listed entry",
          "1402:   for (i = 0; (path = mg_unlist(i)) != NULL; i++) {",
          "1403:     if (!is_dir_prefix(dir, n, path)) continue;",
          "1404:     begin = &path[n + 1];",
          "1405:     end = strchr(begin, '/');",
          "1406:     if (end == NULL) end = begin + strlen(begin);",
          "1407:     mg_snprintf(buf, sizeof(buf), \"%.*s\", (int) (end - begin), begin);",
          "1408:     buf[sizeof(buf) - 1] = '\\0';",
          "1411:     if (strcmp(buf, tmp) == 0) continue;",
          "1412:     fn(buf, userdata);  // Not yet listed, call user function",
          "1413:     strcpy(tmp, buf);   // And save this entry as listed",
          "1417: static void *packed_open(const char *path, int flags) {",
          "1419:   const char *data = mg_unpack(path, &size, NULL);",
          "1420:   struct packed_file *fp = NULL;",
          "1421:   if (data == NULL) return NULL;",
          "1422:   if (flags & MG_FS_WRITE) return NULL;",
          "1423:   if ((fp = (struct packed_file *) calloc(1, sizeof(*fp))) != NULL) {",
          "1424:     fp->size = size;",
          "1425:     fp->data = data;",
          "1427:   return (void *) fp;",
          "1428: }",
          "1430: static void packed_close(void *fp) {",
          "1431:   if (fp != NULL) free(fp);",
          "1432: }",
          "1434: static size_t packed_read(void *fd, void *buf, size_t len) {",
          "1435:   struct packed_file *fp = (struct packed_file *) fd;",
          "1436:   if (fp->pos + len > fp->size) len = fp->size - fp->pos;",
          "1437:   memcpy(buf, &fp->data[fp->pos], len);",
          "1438:   fp->pos += len;",
          "1439:   return len;",
          "1440: }",
          "1442: static size_t packed_write(void *fd, const void *buf, size_t len) {",
          "1443:   (void) fd, (void) buf, (void) len;",
          "1444:   return 0;",
          "1445: }",
          "1447: static size_t packed_seek(void *fd, size_t offset) {",
          "1448:   struct packed_file *fp = (struct packed_file *) fd;",
          "1449:   fp->pos = offset;",
          "1450:   if (fp->pos > fp->size) fp->pos = fp->size;",
          "1451:   return fp->pos;",
          "1452: }",
          "1454: static bool packed_rename(const char *from, const char *to) {",
          "1455:   (void) from, (void) to;",
          "1456:   return false;",
          "1457: }",
          "1459: static bool packed_remove(const char *path) {",
          "1460:   (void) path;",
          "1461:   return false;",
          "1462: }",
          "1464: static bool packed_mkdir(const char *path) {",
          "1465:   (void) path;",
          "1466:   return false;",
          "1467: }",
          "1469: struct mg_fs mg_fs_packed = {",
          "1470:     packed_stat,  packed_list, packed_open,   packed_close,  packed_read,",
          "1471:     packed_write, packed_seek, packed_rename, packed_remove, packed_mkdir};",
          "1473: #ifdef MG_ENABLE_LINES",
          "1474: #line 1 \"src/fs_posix.c\"",
          "1475: #endif",
          "1478: #if MG_ENABLE_FILE",
          "1480: #ifndef MG_STAT_STRUCT",
          "1481: #define MG_STAT_STRUCT stat",
          "1482: #endif",
          "1484: #ifndef MG_STAT_FUNC",
          "1485: #define MG_STAT_FUNC stat",
          "1486: #endif",
          "1488: static int p_stat(const char *path, size_t *size, time_t *mtime) {",
          "1489: #if !defined(S_ISDIR)",
          "1490:   MG_ERROR((\"stat() API is not supported. %p %p %p\", path, size, mtime));",
          "1491:   return 0;",
          "1492: #else",
          "1493: #if MG_ARCH == MG_ARCH_WIN32",
          "1494:   struct _stati64 st;",
          "1495:   wchar_t tmp[MG_PATH_MAX];",
          "1496:   MultiByteToWideChar(CP_UTF8, 0, path, -1, tmp, sizeof(tmp) / sizeof(tmp[0]));",
          "1497:   if (_wstati64(tmp, &st) != 0) return 0;",
          "1500:   if (st.st_size == 0 && (st.st_mode & _S_IFREG)) {",
          "1501:     FILE *fp = _wfopen(tmp, L\"rb\");",
          "1502:     if (fp != NULL) {",
          "1503:       fseek(fp, 0, SEEK_END);",
          "1504:       if (ftell(fp) > 0) st.st_size = ftell(fp);  // Use _ftelli64 on win10+",
          "1505:       fclose(fp);",
          "1508: #else",
          "1509:   struct MG_STAT_STRUCT st;",
          "1510:   if (MG_STAT_FUNC(path, &st) != 0) return 0;",
          "1511: #endif",
          "1512:   if (size) *size = (size_t) st.st_size;",
          "1513:   if (mtime) *mtime = st.st_mtime;",
          "1514:   return MG_FS_READ | MG_FS_WRITE | (S_ISDIR(st.st_mode) ? MG_FS_DIR : 0);",
          "1515: #endif",
          "1518: #if MG_ARCH == MG_ARCH_WIN32",
          "1519: struct dirent {",
          "1520:   char d_name[MAX_PATH];",
          "1523: typedef struct win32_dir {",
          "1524:   HANDLE handle;",
          "1525:   WIN32_FIND_DATAW info;",
          "1526:   struct dirent result;",
          "1527: } DIR;",
          "1529: int gettimeofday(struct timeval *tv, void *tz) {",
          "1530:   FILETIME ft;",
          "1531:   unsigned __int64 tmpres = 0;",
          "1533:   if (tv != NULL) {",
          "1534:     GetSystemTimeAsFileTime(&ft);",
          "1535:     tmpres |= ft.dwHighDateTime;",
          "1536:     tmpres <<= 32;",
          "1537:     tmpres |= ft.dwLowDateTime;",
          "1538:     tmpres /= 10;  // convert into microseconds",
          "1539:     tmpres -= (int64_t) 11644473600000000;",
          "1540:     tv->tv_sec = (long) (tmpres / 1000000UL);",
          "1541:     tv->tv_usec = (long) (tmpres % 1000000UL);",
          "1542:   }",
          "1543:   (void) tz;",
          "1544:   return 0;",
          "1545: }",
          "1547: static int to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {",
          "1548:   int ret;",
          "1549:   char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;",
          "1550:   strncpy(buf, path, sizeof(buf));",
          "1551:   buf[sizeof(buf) - 1] = '\\0';",
          "1553:   p = buf + strlen(buf) - 1;",
          "1554:   while (p > buf && p[-1] != ':' && (p[0] == '\\\\' || p[0] == '/')) *p-- = '\\0';",
          "1555:   memset(wbuf, 0, wbuf_len * sizeof(wchar_t));",
          "1556:   ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);",
          "1559:   WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),",
          "1560:                       NULL, NULL);",
          "1561:   if (strcmp(buf, buf2) != 0) {",
          "1562:     wbuf[0] = L'\\0';",
          "1563:     ret = 0;",
          "1564:   }",
          "1565:   return ret;",
          "1566: }",
          "1568: DIR *opendir(const char *name) {",
          "1569:   DIR *d = NULL;",
          "1570:   wchar_t wpath[MAX_PATH];",
          "1571:   DWORD attrs;",
          "1573:   if (name == NULL) {",
          "1574:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "1575:   } else if ((d = (DIR *) calloc(1, sizeof(*d))) == NULL) {",
          "1576:     SetLastError(ERROR_NOT_ENOUGH_MEMORY);",
          "1578:     to_wchar(name, wpath, sizeof(wpath) / sizeof(wpath[0]));",
          "1579:     attrs = GetFileAttributesW(wpath);",
          "1580:     if (attrs != 0Xffffffff && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {",
          "1581:       (void) wcscat(wpath, L\"\\\\*\");",
          "1582:       d->handle = FindFirstFileW(wpath, &d->info);",
          "1583:       d->result.d_name[0] = '\\0';",
          "1585:       free(d);",
          "1586:       d = NULL;",
          "1588:   }",
          "1589:   return d;",
          "1590: }",
          "1592: int closedir(DIR *d) {",
          "1593:   int result = 0;",
          "1594:   if (d != NULL) {",
          "1595:     if (d->handle != INVALID_HANDLE_VALUE)",
          "1596:       result = FindClose(d->handle) ? 0 : -1;",
          "1597:     free(d);",
          "1598:   } else {",
          "1599:     result = -1;",
          "1600:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "1601:   }",
          "1602:   return result;",
          "1603: }",
          "1605: struct dirent *readdir(DIR *d) {",
          "1606:   struct dirent *result = NULL;",
          "1607:   if (d != NULL) {",
          "1608:     memset(&d->result, 0, sizeof(d->result));",
          "1609:     if (d->handle != INVALID_HANDLE_VALUE) {",
          "1610:       result = &d->result;",
          "1611:       WideCharToMultiByte(CP_UTF8, 0, d->info.cFileName, -1, result->d_name,",
          "1612:                           sizeof(result->d_name), NULL, NULL);",
          "1613:       if (!FindNextFileW(d->handle, &d->info)) {",
          "1614:         FindClose(d->handle);",
          "1615:         d->handle = INVALID_HANDLE_VALUE;",
          "1616:       }",
          "1617:     } else {",
          "1618:       SetLastError(ERROR_FILE_NOT_FOUND);",
          "1620:   } else {",
          "1621:     SetLastError(ERROR_BAD_ARGUMENTS);",
          "1622:   }",
          "1623:   return result;",
          "1624: }",
          "1627: static void p_list(const char *dir, void (*fn)(const char *, void *),",
          "1628:                    void *userdata) {",
          "1629: #if MG_ENABLE_DIRLIST",
          "1630:   struct dirent *dp;",
          "1631:   DIR *dirp;",
          "1632:   if ((dirp = (opendir(dir))) == NULL) return;",
          "1633:   while ((dp = readdir(dirp)) != NULL) {",
          "1634:     if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) continue;",
          "1635:     fn(dp->d_name, userdata);",
          "1637:   closedir(dirp);",
          "1638: #else",
          "1639:   (void) dir, (void) fn, (void) userdata;",
          "1640: #endif",
          "1643: static void *p_open(const char *path, int flags) {",
          "1644: #if MG_ARCH == MG_ARCH_WIN32",
          "1645:   const char *mode = flags == MG_FS_READ ? \"rb\" : \"a+b\";",
          "1646:   wchar_t b1[MG_PATH_MAX], b2[10];",
          "1647:   MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));",
          "1648:   MultiByteToWideChar(CP_UTF8, 0, mode, -1, b2, sizeof(b2) / sizeof(b2[0]));",
          "1649:   return (void *) _wfopen(b1, b2);",
          "1650: #else",
          "1651:   const char *mode = flags == MG_FS_READ ? \"rbe\" : \"a+be\";  // e for CLOEXEC",
          "1652:   return (void *) fopen(path, mode);",
          "1653: #endif",
          "1654: }",
          "1656: static void p_close(void *fp) {",
          "1657:   fclose((FILE *) fp);",
          "1660: static size_t p_read(void *fp, void *buf, size_t len) {",
          "1661:   return fread(buf, 1, len, (FILE *) fp);",
          "1664: static size_t p_write(void *fp, const void *buf, size_t len) {",
          "1665:   return fwrite(buf, 1, len, (FILE *) fp);",
          "1668: static size_t p_seek(void *fp, size_t offset) {",
          "1669: #if (defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64) ||  \\",
          "1670:     (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200112L) || \\",
          "1671:     (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 600)",
          "1672:   if (fseeko((FILE *) fp, (off_t) offset, SEEK_SET) != 0) (void) 0;",
          "1674:   if (fseek((FILE *) fp, (long) offset, SEEK_SET) != 0) (void) 0;",
          "1676:   return (size_t) ftell((FILE *) fp);",
          "1679: static bool p_rename(const char *from, const char *to) {",
          "1680:   return rename(from, to) == 0;",
          "1683: static bool p_remove(const char *path) {",
          "1684:   return remove(path) == 0;",
          "1687: static bool p_mkdir(const char *path) {",
          "1688:   return mkdir(path, 0775) == 0;",
          "1691: #else",
          "1693: static int p_stat(const char *path, size_t *size, time_t *mtime) {",
          "1694:   (void) path, (void) size, (void) mtime;",
          "1695:   return 0;",
          "1697: static void p_list(const char *path, void (*fn)(const char *, void *),",
          "1698:                    void *userdata) {",
          "1699:   (void) path, (void) fn, (void) userdata;",
          "1701: static void *p_open(const char *path, int flags) {",
          "1702:   (void) path, (void) flags;",
          "1703:   return NULL;",
          "1705: static void p_close(void *fp) {",
          "1706:   (void) fp;",
          "1708: static size_t p_read(void *fd, void *buf, size_t len) {",
          "1709:   (void) fd, (void) buf, (void) len;",
          "1710:   return 0;",
          "1712: static size_t p_write(void *fd, const void *buf, size_t len) {",
          "1713:   (void) fd, (void) buf, (void) len;",
          "1714:   return 0;",
          "1716: static size_t p_seek(void *fd, size_t offset) {",
          "1717:   (void) fd, (void) offset;",
          "1718:   return (size_t) ~0;",
          "1720: static bool p_rename(const char *from, const char *to) {",
          "1721:   (void) from, (void) to;",
          "1722:   return false;",
          "1724: static bool p_remove(const char *path) {",
          "1725:   (void) path;",
          "1726:   return false;",
          "1728: static bool p_mkdir(const char *path) {",
          "1729:   (void) path;",
          "1730:   return false;",
          "1732: #endif",
          "1734: struct mg_fs mg_fs_posix = {p_stat,  p_list, p_open,   p_close,  p_read,",
          "1735:                             p_write, p_seek, p_rename, p_remove, p_mkdir};",
          "1737: #ifdef MG_ENABLE_LINES",
          "1738: #line 1 \"src/http.c\"",
          "1739: #endif",
          "1753: bool mg_to_size_t(struct mg_str str, size_t *val);",
          "1754: bool mg_to_size_t(struct mg_str str, size_t *val) {",
          "1755:   size_t i = 0, max = (size_t) -1, max2 = max / 10, result = 0, ndigits = 0;",
          "1756:   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;",
          "1757:   if (i < str.len && str.ptr[i] == '-') return false;",
          "1758:   while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {",
          "1759:     size_t digit = (size_t) (str.ptr[i] - '0');",
          "1760:     if (result > max2) return false;  // Overflow",
          "1761:     result *= 10;",
          "1762:     if (result > max - digit) return false;  // Overflow",
          "1763:     result += digit;",
          "1764:     i++, ndigits++;",
          "1765:   }",
          "1766:   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;",
          "1767:   if (ndigits == 0) return false;  // #2322: Content-Length = 1 * DIGIT",
          "1768:   if (i != str.len) return false;  // Ditto",
          "1770:   return true;",
          "1774: #define MG_DMARK ((size_t) 1 << (sizeof(size_t) * 8 - 1))",
          "1788: size_t mg_http_next_multipart(struct mg_str body, size_t ofs,",
          "1789:                               struct mg_http_part *part) {",
          "1790:   struct mg_str cd = mg_str_n(\"Content-Disposition\", 19);",
          "1791:   const char *s = body.ptr;",
          "1792:   size_t b = ofs, h1, h2, b1, b2, max = body.len;",
          "1795:   if (part != NULL) part->name = part->filename = part->body = mg_str_n(0, 0);",
          "1798:   while (b + 2 < max && s[b] != '\\r' && s[b + 1] != '\\n') b++;",
          "1799:   if (b <= ofs || b + 2 >= max) return 0;",
          "1803:   h1 = h2 = b + 2;",
          "1804:   for (;;) {",
          "1805:     while (h2 + 2 < max && s[h2] != '\\r' && s[h2 + 1] != '\\n') h2++;",
          "1806:     if (h2 == h1) break;",
          "1807:     if (h2 + 2 >= max) return 0;",
          "1809:     if (part != NULL && h1 + cd.len + 2 < h2 && s[h1 + cd.len] == ':' &&",
          "1810:         mg_ncasecmp(&s[h1], cd.ptr, cd.len) == 0) {",
          "1811:       struct mg_str v = mg_str_n(&s[h1 + cd.len + 2], h2 - (h1 + cd.len + 2));",
          "1812:       part->name = mg_http_get_header_var(v, mg_str_n(\"name\", 4));",
          "1813:       part->filename = mg_http_get_header_var(v, mg_str_n(\"filename\", 8));",
          "1814:     }",
          "1815:     h1 = h2 = h2 + 2;",
          "1816:   }",
          "1817:   b1 = b2 = h2 + 2;",
          "1818:   while (b2 + 2 + (b - ofs) + 2 < max && !(s[b2] == '\\r' && s[b2 + 1] == '\\n' &&",
          "1819:                                            memcmp(&s[b2 + 2], s, b - ofs) == 0))",
          "1820:     b2++;",
          "1822:   if (b2 + 2 >= max) return 0;",
          "1823:   if (part != NULL) part->body = mg_str_n(&s[b1], b2 - b1);",
          "1825:   return b2 + 2;",
          "1828: void mg_http_bauth(struct mg_connection *c, const char *user,",
          "1829:                    const char *pass) {",
          "1830:   struct mg_str u = mg_str(user), p = mg_str(pass);",
          "1831:   size_t need = c->send.len + 36 + (u.len + p.len) * 2;",
          "1832:   if (c->send.size < need) mg_iobuf_resize(&c->send, need);",
          "1833:   if (c->send.size >= need) {",
          "1834:     size_t i, n = 0;",
          "1835:     char *buf = (char *) &c->send.buf[c->send.len];",
          "1836:     memcpy(buf, \"Authorization: Basic \", 21);  // DON'T use mg_send!",
          "1837:     for (i = 0; i < u.len; i++) {",
          "1838:       n = mg_base64_update(((unsigned char *) u.ptr)[i], buf + 21, n);",
          "1839:     }",
          "1840:     if (p.len > 0) {",
          "1841:       n = mg_base64_update(':', buf + 21, n);",
          "1842:       for (i = 0; i < p.len; i++) {",
          "1843:         n = mg_base64_update(((unsigned char *) p.ptr)[i], buf + 21, n);",
          "1844:       }",
          "1845:     }",
          "1846:     n = mg_base64_final(buf + 21, n);",
          "1847:     c->send.len += 21 + (size_t) n + 2;",
          "1848:     memcpy(&c->send.buf[c->send.len - 2], \"\\r\\n\", 2);",
          "1849:   } else {",
          "1850:     MG_ERROR((\"%lu oom %d->%d \", c->id, (int) c->send.size, (int) need));",
          "1854: struct mg_str mg_http_var(struct mg_str buf, struct mg_str name) {",
          "1855:   struct mg_str k, v, result = mg_str_n(NULL, 0);",
          "1856:   while (mg_split(&buf, &k, &v, '&')) {",
          "1857:     if (name.len == k.len && mg_ncasecmp(name.ptr, k.ptr, k.len) == 0) {",
          "1858:       result = v;",
          "1859:       break;",
          "1862:   return result;",
          "1865: int mg_http_get_var(const struct mg_str *buf, const char *name, char *dst,",
          "1866:                     size_t dst_len) {",
          "1867:   int len;",
          "1868:   if (dst == NULL || dst_len == 0) {",
          "1869:     len = -2;  // Bad destination",
          "1870:   } else if (buf->ptr == NULL || name == NULL || buf->len == 0) {",
          "1871:     len = -1;  // Bad source",
          "1872:     dst[0] = '\\0';",
          "1873:   } else {",
          "1874:     struct mg_str v = mg_http_var(*buf, mg_str(name));",
          "1875:     if (v.ptr == NULL) {",
          "1876:       len = -4;  // Name does not exist",
          "1877:     } else {",
          "1878:       len = mg_url_decode(v.ptr, v.len, dst, dst_len, 1);",
          "1879:       if (len < 0) len = -3;  // Failed to decode",
          "1880:     }",
          "1882:   return len;",
          "1883: }",
          "1885: static bool isx(int c) {",
          "1886:   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||",
          "1887:          (c >= 'A' && c <= 'F');",
          "1888: }",
          "1890: int mg_url_decode(const char *src, size_t src_len, char *dst, size_t dst_len,",
          "1891:                   int is_form_url_encoded) {",
          "1892:   size_t i, j;",
          "1893:   for (i = j = 0; i < src_len && j + 1 < dst_len; i++, j++) {",
          "1894:     if (src[i] == '%') {",
          "1896:       if (i + 2 < src_len && isx(src[i + 1]) && isx(src[i + 2])) {",
          "1897:         mg_unhex(src + i + 1, 2, (uint8_t *) &dst[j]);",
          "1898:         i += 2;",
          "1899:       } else {",
          "1900:         return -1;",
          "1901:       }",
          "1902:     } else if (is_form_url_encoded && src[i] == '+') {",
          "1903:       dst[j] = ' ';",
          "1904:     } else {",
          "1905:       dst[j] = src[i];",
          "1908:   if (j < dst_len) dst[j] = '\\0';  // Null-terminate the destination",
          "1909:   return i >= src_len && j < dst_len ? (int) j : -1;",
          "1910: }",
          "1912: static bool isok(uint8_t c) {",
          "1913:   return c == '\\n' || c == '\\r' || c >= ' ';",
          "1914: }",
          "1916: int mg_http_get_request_len(const unsigned char *buf, size_t buf_len) {",
          "1917:   size_t i;",
          "1918:   for (i = 0; i < buf_len; i++) {",
          "1919:     if (!isok(buf[i])) return -1;",
          "1920:     if ((i > 0 && buf[i] == '\\n' && buf[i - 1] == '\\n') ||",
          "1921:         (i > 3 && buf[i] == '\\n' && buf[i - 1] == '\\r' && buf[i - 2] == '\\n'))",
          "1922:       return (int) i + 1;",
          "1923:   }",
          "1924:   return 0;",
          "1925: }",
          "1926: struct mg_str *mg_http_get_header(struct mg_http_message *h, const char *name) {",
          "1927:   size_t i, n = strlen(name), max = sizeof(h->headers) / sizeof(h->headers[0]);",
          "1928:   for (i = 0; i < max && h->headers[i].name.len > 0; i++) {",
          "1929:     struct mg_str *k = &h->headers[i].name, *v = &h->headers[i].value;",
          "1930:     if (n == k->len && mg_ncasecmp(k->ptr, name, n) == 0) return v;",
          "1932:   return NULL;",
          "1933: }",
          "1936: static size_t clen(const char *s) {",
          "1937:   uint8_t c = *(uint8_t *) s;",
          "1938:   if (c > ' ' && c < '~') return 1;  // Usual ascii printed char",
          "1939:   if ((c & 0xe0) == 0xc0) return 2;  // 2-byte UTF8",
          "1940:   if ((c & 0xf0) == 0xe0) return 3;  // 3-byte UTF8",
          "1941:   if ((c & 0xf8) == 0xf0) return 4;  // 4-byte UTF8",
          "1942:   return 0;",
          "1946: static const char *skiptorn(const char *s, const char *end, struct mg_str *v) {",
          "1947:   v->ptr = s;",
          "1948:   while (s < end && s[0] != '\\n' && s[0] != '\\r') s++, v->len++;  // To newline",
          "1949:   if (s >= end || (s[0] == '\\r' && s[1] != '\\n')) return NULL;    // Stray \\r",
          "1950:   if (s < end && s[0] == '\\r') s++;                               // Skip \\r",
          "1951:   if (s >= end || *s++ != '\\n') return NULL;                      // Skip \\n",
          "1952:   return s;",
          "1953: }",
          "1955: static bool mg_http_parse_headers(const char *s, const char *end,",
          "1956:                                   struct mg_http_header *h, size_t max_hdrs) {",
          "1957:   size_t i, n;",
          "1958:   for (i = 0; i < max_hdrs; i++) {",
          "1959:     struct mg_str k = {NULL, 0}, v = {NULL, 0};",
          "1960:     if (s >= end) return false;",
          "1961:     if (s[0] == '\\n' || (s[0] == '\\r' && s[1] == '\\n')) break;",
          "1962:     k.ptr = s;",
          "1963:     while (s < end && s[0] != ':' && (n = clen(s)) > 0) s += n, k.len += n;",
          "1964:     if (k.len == 0) return false;               // Empty name",
          "1965:     if (s >= end || *s++ != ':') return false;  // Invalid, not followed by :",
          "1966:     while (s < end && s[0] == ' ') s++;         // Skip spaces",
          "1967:     if ((s = skiptorn(s, end, &v)) == NULL) return false;",
          "1968:     while (v.len > 0 && v.ptr[v.len - 1] == ' ') v.len--;  // Trim spaces",
          "1970:     h[i].name = k, h[i].value = v;  // Success. Assign values",
          "1971:   }",
          "1972:   return true;",
          "1973: }",
          "1975: int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {",
          "1976:   int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);",
          "1977:   const char *end = s == NULL ? NULL : s + req_len, *qs;  // Cannot add to NULL",
          "1978:   struct mg_str *cl;",
          "1979:   size_t n;",
          "1981:   memset(hm, 0, sizeof(*hm));",
          "1982:   if (req_len <= 0) return req_len;",
          "1984:   hm->message.ptr = hm->head.ptr = s;",
          "1985:   hm->body.ptr = end;",
          "1986:   hm->head.len = (size_t) req_len;",
          "1987:   hm->chunk.ptr = end;",
          "1988:   hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite",
          "1991:   hm->method.ptr = s;",
          "1992:   while (s < end && (n = clen(s)) > 0) s += n, hm->method.len += n;",
          "1993:   while (s < end && s[0] == ' ') s++;  // Skip spaces",
          "1994:   hm->uri.ptr = s;",
          "1995:   while (s < end && (n = clen(s)) > 0) s += n, hm->uri.len += n;",
          "1996:   while (s < end && s[0] == ' ') s++;  // Skip spaces",
          "1997:   if ((s = skiptorn(s, end, &hm->proto)) == NULL) return false;",
          "2000:   if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {",
          "2001:     hm->query.ptr = qs + 1;",
          "2002:     hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));",
          "2003:     hm->uri.len = (size_t) (qs - hm->uri.ptr);",
          "2004:   }",
          "2008:   if (hm->method.len == 0 || hm->uri.len == 0) return -1;",
          "2010:   if (!mg_http_parse_headers(s, end, hm->headers,",
          "2011:                              sizeof(hm->headers) / sizeof(hm->headers[0])))",
          "2012:     return -1;  // error when parsing",
          "2013:   if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {",
          "2014:     if (mg_to_size_t(*cl, &hm->body.len) == false) return -1;",
          "2015:     hm->message.len = (size_t) req_len + hm->body.len;",
          "2030:   is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;",
          "2031:   if (hm->body.len == (size_t) ~0 && !is_response &&",
          "2032:       mg_vcasecmp(&hm->method, \"PUT\") != 0 &&",
          "2033:       mg_vcasecmp(&hm->method, \"POST\") != 0) {",
          "2034:     hm->body.len = 0;",
          "2035:     hm->message.len = (size_t) req_len;",
          "2039:   if (hm->body.len == (size_t) ~0 && is_response &&",
          "2040:       mg_vcasecmp(&hm->uri, \"204\") == 0) {",
          "2041:     hm->body.len = 0;",
          "2042:     hm->message.len = (size_t) req_len;",
          "2043:   }",
          "2044:   if (hm->message.len < (size_t) req_len) return -1;  // Overflow protection",
          "2046:   return req_len;",
          "2049: static void mg_http_vprintf_chunk(struct mg_connection *c, const char *fmt,",
          "2050:                                   va_list *ap) {",
          "2051:   size_t len = c->send.len;",
          "2052:   mg_send(c, \"        \\r\\n\", 10);",
          "2053:   mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);",
          "2054:   if (c->send.len >= len + 10) {",
          "2055:     mg_snprintf((char *) c->send.buf + len, 9, \"%08lx\", c->send.len - len - 10);",
          "2056:     c->send.buf[len + 8] = '\\r';",
          "2057:     if (c->send.len == len + 10) c->is_resp = 0;  // Last chunk, reset marker",
          "2059:   mg_send(c, \"\\r\\n\", 2);",
          "2062: void mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...) {",
          "2063:   va_list ap;",
          "2064:   va_start(ap, fmt);",
          "2065:   mg_http_vprintf_chunk(c, fmt, &ap);",
          "2066:   va_end(ap);",
          "2067: }",
          "2069: void mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len) {",
          "2070:   mg_printf(c, \"%lx\\r\\n\", (unsigned long) len);",
          "2071:   mg_send(c, buf, len);",
          "2072:   mg_send(c, \"\\r\\n\", 2);",
          "2073:   if (len == 0) c->is_resp = 0;",
          "2077: static const char *mg_http_status_code_str(int status_code) {",
          "2078:   switch (status_code) {",
          "2079:     case 100: return \"Continue\";",
          "2080:     case 101: return \"Switching Protocols\";",
          "2081:     case 102: return \"Processing\";",
          "2082:     case 200: return \"OK\";",
          "2083:     case 201: return \"Created\";",
          "2084:     case 202: return \"Accepted\";",
          "2085:     case 203: return \"Non-authoritative Information\";",
          "2086:     case 204: return \"No Content\";",
          "2087:     case 205: return \"Reset Content\";",
          "2088:     case 206: return \"Partial Content\";",
          "2089:     case 207: return \"Multi-Status\";",
          "2090:     case 208: return \"Already Reported\";",
          "2091:     case 226: return \"IM Used\";",
          "2092:     case 300: return \"Multiple Choices\";",
          "2093:     case 301: return \"Moved Permanently\";",
          "2094:     case 302: return \"Found\";",
          "2095:     case 303: return \"See Other\";",
          "2096:     case 304: return \"Not Modified\";",
          "2097:     case 305: return \"Use Proxy\";",
          "2098:     case 307: return \"Temporary Redirect\";",
          "2099:     case 308: return \"Permanent Redirect\";",
          "2100:     case 400: return \"Bad Request\";",
          "2101:     case 401: return \"Unauthorized\";",
          "2102:     case 402: return \"Payment Required\";",
          "2103:     case 403: return \"Forbidden\";",
          "2104:     case 404: return \"Not Found\";",
          "2105:     case 405: return \"Method Not Allowed\";",
          "2106:     case 406: return \"Not Acceptable\";",
          "2107:     case 407: return \"Proxy Authentication Required\";",
          "2108:     case 408: return \"Request Timeout\";",
          "2109:     case 409: return \"Conflict\";",
          "2110:     case 410: return \"Gone\";",
          "2111:     case 411: return \"Length Required\";",
          "2112:     case 412: return \"Precondition Failed\";",
          "2113:     case 413: return \"Payload Too Large\";",
          "2114:     case 414: return \"Request-URI Too Long\";",
          "2115:     case 415: return \"Unsupported Media Type\";",
          "2116:     case 416: return \"Requested Range Not Satisfiable\";",
          "2117:     case 417: return \"Expectation Failed\";",
          "2118:     case 418: return \"I'm a teapot\";",
          "2119:     case 421: return \"Misdirected Request\";",
          "2120:     case 422: return \"Unprocessable Entity\";",
          "2121:     case 423: return \"Locked\";",
          "2122:     case 424: return \"Failed Dependency\";",
          "2123:     case 426: return \"Upgrade Required\";",
          "2124:     case 428: return \"Precondition Required\";",
          "2125:     case 429: return \"Too Many Requests\";",
          "2126:     case 431: return \"Request Header Fields Too Large\";",
          "2127:     case 444: return \"Connection Closed Without Response\";",
          "2128:     case 451: return \"Unavailable For Legal Reasons\";",
          "2129:     case 499: return \"Client Closed Request\";",
          "2130:     case 500: return \"Internal Server Error\";",
          "2131:     case 501: return \"Not Implemented\";",
          "2132:     case 502: return \"Bad Gateway\";",
          "2133:     case 503: return \"Service Unavailable\";",
          "2134:     case 504: return \"Gateway Timeout\";",
          "2135:     case 505: return \"HTTP Version Not Supported\";",
          "2136:     case 506: return \"Variant Also Negotiates\";",
          "2137:     case 507: return \"Insufficient Storage\";",
          "2138:     case 508: return \"Loop Detected\";",
          "2139:     case 510: return \"Not Extended\";",
          "2140:     case 511: return \"Network Authentication Required\";",
          "2141:     case 599: return \"Network Connect Timeout Error\";",
          "2142:     default: return \"\";",
          "2147: void mg_http_reply(struct mg_connection *c, int code, const char *headers,",
          "2148:                    const char *fmt, ...) {",
          "2149:   va_list ap;",
          "2150:   size_t len;",
          "2151:   mg_printf(c, \"HTTP/1.1 %d %s\\r\\n%sContent-Length:            \\r\\n\\r\\n\", code,",
          "2152:             mg_http_status_code_str(code), headers == NULL ? \"\" : headers);",
          "2153:   len = c->send.len;",
          "2154:   va_start(ap, fmt);",
          "2155:   mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, &ap);",
          "2156:   va_end(ap);",
          "2157:   if (c->send.len > 16) {",
          "2158:     size_t n = mg_snprintf((char *) &c->send.buf[len - 15], 11, \"%-10lu\",",
          "2159:                            (unsigned long) (c->send.len - len));",
          "2160:     c->send.buf[len - 15 + n] = ' ';  // Change ending 0 to space",
          "2162:   c->is_resp = 0;",
          "2165: static void http_cb(struct mg_connection *, int, void *, void *);",
          "2166: static void restore_http_cb(struct mg_connection *c) {",
          "2167:   mg_fs_close((struct mg_fd *) c->pfn_data);",
          "2168:   c->pfn_data = NULL;",
          "2169:   c->pfn = http_cb;",
          "2170:   c->is_resp = 0;",
          "2173: char *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime);",
          "2174: char *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {",
          "2175:   mg_snprintf(buf, len, \"\\\"%lld.%lld\\\"\", (int64_t) mtime, (int64_t) size);",
          "2176:   return buf;",
          "2179: static void static_cb(struct mg_connection *c, int ev, void *ev_data,",
          "2180:                       void *fn_data) {",
          "2181:   if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {",
          "2182:     struct mg_fd *fd = (struct mg_fd *) fn_data;",
          "2184:     size_t n, max = MG_IO_SIZE, space;",
          "2185:     size_t *cl = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /",
          "2186:                                      sizeof(size_t) * sizeof(size_t)];",
          "2187:     if (c->send.size < max) mg_iobuf_resize(&c->send, max);",
          "2188:     if (c->send.len >= c->send.size) return;  // Rate limit",
          "2189:     if ((space = c->send.size - c->send.len) > *cl) space = *cl;",
          "2190:     n = fd->fs->rd(fd->fd, c->send.buf + c->send.len, space);",
          "2191:     c->send.len += n;",
          "2193:     if (n == 0) restore_http_cb(c);",
          "2194:   } else if (ev == MG_EV_CLOSE) {",
          "2195:     restore_http_cb(c);",
          "2196:   }",
          "2197:   (void) ev_data;",
          "2198: }",
          "2203: static struct mg_str s_known_types[] = {",
          "2204:     MG_C_STR(\"html\"), MG_C_STR(\"text/html; charset=utf-8\"),",
          "2205:     MG_C_STR(\"htm\"), MG_C_STR(\"text/html; charset=utf-8\"),",
          "2206:     MG_C_STR(\"css\"), MG_C_STR(\"text/css; charset=utf-8\"),",
          "2207:     MG_C_STR(\"js\"), MG_C_STR(\"text/javascript; charset=utf-8\"),",
          "2208:     MG_C_STR(\"gif\"), MG_C_STR(\"image/gif\"),",
          "2209:     MG_C_STR(\"png\"), MG_C_STR(\"image/png\"),",
          "2210:     MG_C_STR(\"jpg\"), MG_C_STR(\"image/jpeg\"),",
          "2211:     MG_C_STR(\"jpeg\"), MG_C_STR(\"image/jpeg\"),",
          "2212:     MG_C_STR(\"woff\"), MG_C_STR(\"font/woff\"),",
          "2213:     MG_C_STR(\"ttf\"), MG_C_STR(\"font/ttf\"),",
          "2214:     MG_C_STR(\"svg\"), MG_C_STR(\"image/svg+xml\"),",
          "2215:     MG_C_STR(\"txt\"), MG_C_STR(\"text/plain; charset=utf-8\"),",
          "2216:     MG_C_STR(\"avi\"), MG_C_STR(\"video/x-msvideo\"),",
          "2217:     MG_C_STR(\"csv\"), MG_C_STR(\"text/csv\"),",
          "2218:     MG_C_STR(\"doc\"), MG_C_STR(\"application/msword\"),",
          "2219:     MG_C_STR(\"exe\"), MG_C_STR(\"application/octet-stream\"),",
          "2220:     MG_C_STR(\"gz\"), MG_C_STR(\"application/gzip\"),",
          "2221:     MG_C_STR(\"ico\"), MG_C_STR(\"image/x-icon\"),",
          "2222:     MG_C_STR(\"json\"), MG_C_STR(\"application/json\"),",
          "2223:     MG_C_STR(\"mov\"), MG_C_STR(\"video/quicktime\"),",
          "2224:     MG_C_STR(\"mp3\"), MG_C_STR(\"audio/mpeg\"),",
          "2225:     MG_C_STR(\"mp4\"), MG_C_STR(\"video/mp4\"),",
          "2226:     MG_C_STR(\"mpeg\"), MG_C_STR(\"video/mpeg\"),",
          "2227:     MG_C_STR(\"pdf\"), MG_C_STR(\"application/pdf\"),",
          "2228:     MG_C_STR(\"shtml\"), MG_C_STR(\"text/html; charset=utf-8\"),",
          "2229:     MG_C_STR(\"tgz\"), MG_C_STR(\"application/tar-gz\"),",
          "2230:     MG_C_STR(\"wav\"), MG_C_STR(\"audio/wav\"),",
          "2231:     MG_C_STR(\"webp\"), MG_C_STR(\"image/webp\"),",
          "2232:     MG_C_STR(\"zip\"), MG_C_STR(\"application/zip\"),",
          "2233:     MG_C_STR(\"3gp\"), MG_C_STR(\"video/3gpp\"),",
          "2234:     {0, 0},",
          "2235: };",
          "2238: static struct mg_str guess_content_type(struct mg_str path, const char *extra) {",
          "2239:   struct mg_str k, v, s = mg_str(extra);",
          "2240:   size_t i = 0;",
          "2243:   while (i < path.len && path.ptr[path.len - i - 1] != '.') i++;",
          "2244:   path.ptr += path.len - i;",
          "2245:   path.len = i;",
          "2248:   while (mg_commalist(&s, &k, &v)) {",
          "2249:     if (mg_strcmp(path, k) == 0) return v;",
          "2250:   }",
          "2253:   for (i = 0; s_known_types[i].ptr != NULL; i += 2) {",
          "2254:     if (mg_strcmp(path, s_known_types[i]) == 0) return s_known_types[i + 1];",
          "2255:   }",
          "2257:   return mg_str(\"text/plain; charset=utf-8\");",
          "2260: static int getrange(struct mg_str *s, size_t *a, size_t *b) {",
          "2261:   size_t i, numparsed = 0;",
          "2262:   for (i = 0; i + 6 < s->len; i++) {",
          "2263:     struct mg_str k, v = mg_str_n(s->ptr + i + 6, s->len - i - 6);",
          "2264:     if (memcmp(&s->ptr[i], \"bytes=\", 6) != 0) continue;",
          "2265:     if (mg_split(&v, &k, NULL, '-')) {",
          "2266:       if (mg_to_size_t(k, a)) numparsed++;",
          "2267:       if (v.len > 0 && mg_to_size_t(v, b)) numparsed++;",
          "2268:     } else {",
          "2269:       if (mg_to_size_t(v, a)) numparsed++;",
          "2270:     }",
          "2271:     break;",
          "2272:   }",
          "2273:   return (int) numparsed;",
          "2276: void mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,",
          "2277:                         const char *path,",
          "2278:                         const struct mg_http_serve_opts *opts) {",
          "2279:   char etag[64], tmp[MG_PATH_MAX];",
          "2280:   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;",
          "2281:   struct mg_fd *fd = NULL;",
          "2282:   size_t size = 0;",
          "2283:   time_t mtime = 0;",
          "2284:   struct mg_str *inm = NULL;",
          "2285:   struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);",
          "2286:   bool gzip = false;",
          "2288:   if (path != NULL) {",
          "2290:     struct mg_str *ae = mg_http_get_header(hm, \"Accept-Encoding\");",
          "2291:     if (ae != NULL && mg_strstr(*ae, mg_str(\"gzip\")) != NULL) {",
          "2292:       mg_snprintf(tmp, sizeof(tmp), \"%s.gz\", path);",
          "2293:       fd = mg_fs_open(fs, tmp, MG_FS_READ);",
          "2294:       if (fd != NULL) gzip = true, path = tmp;",
          "2295:     }",
          "2297:     if (fd == NULL) fd = mg_fs_open(fs, path, MG_FS_READ);",
          "2301:   if (fd == NULL && opts->page404 != NULL) {",
          "2302:     fd = mg_fs_open(fs, opts->page404, MG_FS_READ);",
          "2303:     mime = guess_content_type(mg_str(path), opts->mime_types);",
          "2304:     path = opts->page404;",
          "2305:   }",
          "2307:   if (fd == NULL || fs->st(path, &size, &mtime) == 0) {",
          "2308:     mg_http_reply(c, 404, opts->extra_headers, \"Not found\\n\");",
          "2309:     mg_fs_close(fd);",
          "2311:   } else if (mg_http_etag(etag, sizeof(etag), size, mtime) != NULL &&",
          "2312:              (inm = mg_http_get_header(hm, \"If-None-Match\")) != NULL &&",
          "2313:              mg_vcasecmp(inm, etag) == 0) {",
          "2314:     mg_fs_close(fd);",
          "2315:     mg_http_reply(c, 304, opts->extra_headers, \"\");",
          "2316:   } else {",
          "2317:     int n, status = 200;",
          "2318:     char range[100];",
          "2319:     size_t r1 = 0, r2 = 0, cl = size;",
          "2322:     struct mg_str *rh = mg_http_get_header(hm, \"Range\");",
          "2323:     range[0] = '\\0';",
          "2324:     if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0) {",
          "2326:       if (n == 1) r2 = cl - 1;",
          "2327:       if (r1 > r2 || r2 >= cl) {",
          "2328:         status = 416;",
          "2329:         cl = 0;",
          "2330:         mg_snprintf(range, sizeof(range), \"Content-Range: bytes */%lld\\r\\n\",",
          "2331:                     (int64_t) size);",
          "2332:       } else {",
          "2333:         status = 206;",
          "2334:         cl = r2 - r1 + 1;",
          "2335:         mg_snprintf(range, sizeof(range),",
          "2336:                     \"Content-Range: bytes %llu-%llu/%llu\\r\\n\", (uint64_t) r1,",
          "2337:                     (uint64_t) (r1 + cl - 1), (uint64_t) size);",
          "2338:         fs->sk(fd->fd, r1);",
          "2339:       }",
          "2340:     }",
          "2341:     mg_printf(c,",
          "2342:               \"HTTP/1.1 %d %s\\r\\n\"",
          "2343:               \"Content-Type: %.*s\\r\\n\"",
          "2344:               \"Etag: %s\\r\\n\"",
          "2345:               \"Content-Length: %llu\\r\\n\"",
          "2346:               \"%s%s%s\\r\\n\",",
          "2347:               status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,",
          "2348:               etag, (uint64_t) cl, gzip ? \"Content-Encoding: gzip\\r\\n\" : \"\",",
          "2349:               range, opts->extra_headers ? opts->extra_headers : \"\");",
          "2350:     if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {",
          "2351:       c->is_draining = 1;",
          "2352:       c->is_resp = 0;",
          "2353:       mg_fs_close(fd);",
          "2354:     } else {",
          "2356:       size_t *clp = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /",
          "2357:                                         sizeof(size_t) * sizeof(size_t)];",
          "2358:       c->pfn = static_cb;",
          "2359:       c->pfn_data = fd;",
          "2365: struct printdirentrydata {",
          "2366:   struct mg_connection *c;",
          "2367:   struct mg_http_message *hm;",
          "2368:   const struct mg_http_serve_opts *opts;",
          "2369:   const char *dir;",
          "2370: };",
          "2372: #if MG_ENABLE_DIRLIST",
          "2373: static void printdirentry(const char *name, void *userdata) {",
          "2374:   struct printdirentrydata *d = (struct printdirentrydata *) userdata;",
          "2375:   struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;",
          "2376:   size_t size = 0;",
          "2377:   time_t t = 0;",
          "2378:   char path[MG_PATH_MAX], sz[40], mod[40];",
          "2379:   int flags, n = 0;",
          "2382:   if (mg_snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) >",
          "2383:       sizeof(path)) {",
          "2384:     MG_ERROR((\"%s truncated\", name));",
          "2385:   } else if ((flags = fs->st(path, &size, &t)) == 0) {",
          "2386:     MG_ERROR((\"%lu stat(%s): %d\", d->c->id, path, errno));",
          "2388:     const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";",
          "2389:     if (flags & MG_FS_DIR) {",
          "2390:       mg_snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");",
          "2391:     } else {",
          "2392:       mg_snprintf(sz, sizeof(sz), \"%lld\", (uint64_t) size);",
          "2393:     }",
          "2394: #if defined(MG_HTTP_DIRLIST_TIME_FMT)",
          "2395:     {",
          "2396:       char time_str[40];",
          "2397:       struct tm *time_info = localtime(&t);",
          "2398:       strftime(time_str, sizeof time_str, \"%Y/%m/%d %H:%M:%S\", time_info);",
          "2399:       mg_snprintf(mod, sizeof(mod), \"%s\", time_str);",
          "2400:     }",
          "2401: #else",
          "2402:     mg_snprintf(mod, sizeof(mod), \"%lu\", (unsigned long) t);",
          "2403: #endif",
          "2404:     n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));",
          "2405:     mg_printf(d->c,",
          "2406:               \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"",
          "2407:               \"<td name=%lu>%s</td><td name=%lld>%s</td></tr>\\n\",",
          "2408:               n, path, slash, name, slash, (unsigned long) t, mod,",
          "2409:               flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);",
          "2413: static void listdir(struct mg_connection *c, struct mg_http_message *hm,",
          "2414:                     const struct mg_http_serve_opts *opts, char *dir) {",
          "2415:   const char *sort_js_code =",
          "2416:       \"<script>function srt(tb, sc, so, d) {\"",
          "2417:       \"var tr = Array.prototype.slice.call(tb.rows, 0),\"",
          "2418:       \"tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],\"",
          "2419:       \"n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), \"",
          "2420:       \"t1 = a.cells[2].getAttribute('name'), \"",
          "2421:       \"t2 = b.cells[2].getAttribute('name'); \"",
          "2422:       \"return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : \"",
          "2423:       \"n1 ? parseInt(n2) - parseInt(n1) : \"",
          "2424:       \"c1.textContent.trim().localeCompare(c2.textContent.trim())); });\";",
          "2425:   const char *sort_js_code2 =",
          "2426:       \"for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); \"",
          "2427:       \"if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); \"",
          "2428:       \"};\"",
          "2429:       \"window.onload = function() {\"",
          "2430:       \"var tb = document.getElementById('tb');\"",
          "2431:       \"var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];\"",
          "2432:       \"var sc = m[1], so = m[2]; document.onclick = function(ev) { \"",
          "2433:       \"var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); \"",
          "2434:       \"sc = c; ev.preventDefault();}};\"",
          "2435:       \"srt(tb, sc, so, true);\"",
          "2436:       \"}\"",
          "2437:       \"</script>\";",
          "2438:   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;",
          "2439:   struct printdirentrydata d = {c, hm, opts, dir};",
          "2440:   char tmp[10], buf[MG_PATH_MAX];",
          "2441:   size_t off, n;",
          "2442:   int len = mg_url_decode(hm->uri.ptr, hm->uri.len, buf, sizeof(buf), 0);",
          "2443:   struct mg_str uri = len > 0 ? mg_str_n(buf, (size_t) len) : hm->uri;",
          "2445:   mg_printf(c,",
          "2446:             \"HTTP/1.1 200 OK\\r\\n\"",
          "2447:             \"Content-Type: text/html; charset=utf-8\\r\\n\"",
          "2448:             \"%s\"",
          "2449:             \"Content-Length:         \\r\\n\\r\\n\",",
          "2450:             opts->extra_headers == NULL ? \"\" : opts->extra_headers);",
          "2451:   off = c->send.len;  // Start of body",
          "2452:   mg_printf(c,",
          "2453:             \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"",
          "2454:             \"<style>th,td {text-align: left; padding-right: 1em; \"",
          "2455:             \"font-family: monospace; }</style></head>\"",
          "2456:             \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"",
          "2457:             \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"",
          "2458:             \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"",
          "2459:             \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"",
          "2460:             \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"",
          "2461:             \"</thead>\"",
          "2462:             \"<tbody id=\\\"tb\\\">\\n\",",
          "2463:             (int) uri.len, uri.ptr, sort_js_code, sort_js_code2, (int) uri.len,",
          "2464:             uri.ptr);",
          "2465:   mg_printf(c, \"%s\",",
          "2466:             \"  <tr><td><a href=\\\"..\\\">..</a></td>\"",
          "2467:             \"<td name=-1></td><td name=-1>[DIR]</td></tr>\\n\");",
          "2469:   fs->ls(dir, printdirentry, &d);",
          "2470:   mg_printf(c,",
          "2471:             \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"",
          "2472:             \"</table><address>Mongoose v.%s</address></body></html>\\n\",",
          "2473:             MG_VERSION);",
          "2474:   n = mg_snprintf(tmp, sizeof(tmp), \"%lu\", (unsigned long) (c->send.len - off));",
          "2475:   if (n > sizeof(tmp)) n = 0;",
          "2476:   memcpy(c->send.buf + off - 12, tmp, n);  // Set content length",
          "2477:   c->is_resp = 0;                          // Mark response end",
          "2479: #endif",
          "2482: static int uri_to_path2(struct mg_connection *c, struct mg_http_message *hm,",
          "2483:                         struct mg_fs *fs, struct mg_str url, struct mg_str dir,",
          "2484:                         char *path, size_t path_size) {",
          "2485:   int flags, tmp;",
          "2487:   size_t n = mg_snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);",
          "2488:   if (n + 2 >= path_size) {",
          "2489:     mg_http_reply(c, 400, \"\", \"Exceeded path size\");",
          "2490:     return -1;",
          "2491:   }",
          "2492:   path[path_size - 1] = '\\0';",
          "2494:   if (n > 0 && path[n - 1] != '/') path[n++] = '/', path[n] = '\\0';",
          "2495:   if (url.len < hm->uri.len) {",
          "2496:     mg_url_decode(hm->uri.ptr + url.len, hm->uri.len - url.len, path + n,",
          "2497:                   path_size - n, 0);",
          "2498:   }",
          "2499:   path[path_size - 1] = '\\0';  // Double-check",
          "2500:   if (!mg_path_is_sane(path)) {",
          "2501:     mg_http_reply(c, 400, \"\", \"Invalid path\");",
          "2502:     return -1;",
          "2503:   }",
          "2504:   n = strlen(path);",
          "2505:   while (n > 1 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes",
          "2506:   flags = mg_vcmp(&hm->uri, \"/\") == 0 ? MG_FS_DIR : fs->st(path, NULL, NULL);",
          "2507:   MG_VERBOSE((\"%lu %.*s -> %s %d\", c->id, (int) hm->uri.len, hm->uri.ptr, path,",
          "2508:               flags));",
          "2509:   if (flags == 0) {",
          "2511:   } else if ((flags & MG_FS_DIR) && hm->uri.len > 0 &&",
          "2512:              hm->uri.ptr[hm->uri.len - 1] != '/') {",
          "2513:     mg_printf(c,",
          "2514:               \"HTTP/1.1 301 Moved\\r\\n\"",
          "2515:               \"Location: %.*s/\\r\\n\"",
          "2516:               \"Content-Length: 0\\r\\n\"",
          "2517:               \"\\r\\n\",",
          "2518:               (int) hm->uri.len, hm->uri.ptr);",
          "2519:     c->is_resp = 0;",
          "2520:     flags = -1;",
          "2521:   } else if (flags & MG_FS_DIR) {",
          "2522:     if (((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&",
          "2523:           (tmp = fs->st(path, NULL, NULL)) != 0) ||",
          "2524:          (mg_snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&",
          "2525:           (tmp = fs->st(path, NULL, NULL)) != 0))) {",
          "2526:       flags = tmp;",
          "2527:     } else if ((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX \".gz\") >",
          "2528:                     0 &&",
          "2529:                 (tmp = fs->st(path, NULL, NULL)) !=",
          "2530:                     0)) {  // check for gzipped index",
          "2531:       flags = tmp;",
          "2532:       path[n + 1 + strlen(MG_HTTP_INDEX)] =",
          "2533:           '\\0';  // Remove appended .gz in index file name",
          "2534:     } else {",
          "2535:       path[n] = '\\0';  // Remove appended index file name",
          "2538:   return flags;",
          "2539: }",
          "2541: static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,",
          "2542:                        const struct mg_http_serve_opts *opts, char *path,",
          "2543:                        size_t path_size) {",
          "2544:   struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;",
          "2545:   struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};",
          "2546:   while (mg_commalist(&s, &k, &v)) {",
          "2547:     if (v.len == 0) v = k, k = mg_str(\"/\"), u = k, p = v;",
          "2548:     if (hm->uri.len < k.len) continue;",
          "2549:     if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;",
          "2550:     u = k, p = v;",
          "2552:   return uri_to_path2(c, hm, fs, u, p, path, path_size);",
          "2555: void mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,",
          "2556:                        const struct mg_http_serve_opts *opts) {",
          "2557:   char path[MG_PATH_MAX];",
          "2558:   const char *sp = opts->ssi_pattern;",
          "2559:   int flags = uri_to_path(c, hm, opts, path, sizeof(path));",
          "2560:   if (flags < 0) {",
          "2562:   } else if (flags & MG_FS_DIR) {",
          "2563: #if MG_ENABLE_DIRLIST",
          "2564:     listdir(c, hm, opts, path);",
          "2565: #else",
          "2566:     mg_http_reply(c, 403, \"\", \"Forbidden\\n\");",
          "2567: #endif",
          "2568:   } else if (flags && sp != NULL &&",
          "2569:              mg_globmatch(sp, strlen(sp), path, strlen(path))) {",
          "2570:     mg_http_serve_ssi(c, opts->root_dir, path);",
          "2572:     mg_http_serve_file(c, hm, path, opts);",
          "2576: static bool mg_is_url_safe(int c) {",
          "2577:   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||",
          "2578:          (c >= 'A' && c <= 'Z') || c == '.' || c == '_' || c == '-' || c == '~';",
          "2579: }",
          "2581: size_t mg_url_encode(const char *s, size_t sl, char *buf, size_t len) {",
          "2582:   size_t i, n = 0;",
          "2583:   for (i = 0; i < sl; i++) {",
          "2584:     int c = *(unsigned char *) &s[i];",
          "2585:     if (n + 4 >= len) return 0;",
          "2586:     if (mg_is_url_safe(c)) {",
          "2587:       buf[n++] = s[i];",
          "2588:     } else {",
          "2589:       buf[n++] = '%';",
          "2590:       mg_hex(&s[i], 1, &buf[n]);",
          "2591:       n += 2;",
          "2592:     }",
          "2593:   }",
          "2594:   if (len > 0 && n < len - 1) buf[n] = '\\0';  // Null-terminate the destination",
          "2595:   if (len > 0) buf[len - 1] = '\\0';           // Always.",
          "2596:   return n;",
          "2597: }",
          "2599: void mg_http_creds(struct mg_http_message *hm, char *user, size_t userlen,",
          "2600:                    char *pass, size_t passlen) {",
          "2601:   struct mg_str *v = mg_http_get_header(hm, \"Authorization\");",
          "2602:   user[0] = pass[0] = '\\0';",
          "2603:   if (v != NULL && v->len > 6 && memcmp(v->ptr, \"Basic \", 6) == 0) {",
          "2604:     char buf[256];",
          "2605:     size_t n = mg_base64_decode(v->ptr + 6, v->len - 6, buf, sizeof(buf));",
          "2606:     const char *p = (const char *) memchr(buf, ':', n > 0 ? n : 0);",
          "2607:     if (p != NULL) {",
          "2608:       mg_snprintf(user, userlen, \"%.*s\", p - buf, buf);",
          "2609:       mg_snprintf(pass, passlen, \"%.*s\", n - (size_t) (p - buf) - 1, p + 1);",
          "2610:     }",
          "2611:   } else if (v != NULL && v->len > 7 && memcmp(v->ptr, \"Bearer \", 7) == 0) {",
          "2612:     mg_snprintf(pass, passlen, \"%.*s\", (int) v->len - 7, v->ptr + 7);",
          "2613:   } else if ((v = mg_http_get_header(hm, \"Cookie\")) != NULL) {",
          "2614:     struct mg_str t = mg_http_get_header_var(*v, mg_str_n(\"access_token\", 12));",
          "2615:     if (t.len > 0) mg_snprintf(pass, passlen, \"%.*s\", (int) t.len, t.ptr);",
          "2616:   } else {",
          "2617:     mg_http_get_var(&hm->query, \"access_token\", pass, passlen);",
          "2618:   }",
          "2619: }",
          "2621: static struct mg_str stripquotes(struct mg_str s) {",
          "2622:   return s.len > 1 && s.ptr[0] == '\"' && s.ptr[s.len - 1] == '\"'",
          "2623:              ? mg_str_n(s.ptr + 1, s.len - 2)",
          "2624:              : s;",
          "2627: struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {",
          "2628:   size_t i;",
          "2629:   for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {",
          "2630:     if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {",
          "2631:       const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];",
          "2632:       int q = p < x && *p == '\"' ? 1 : 0;",
          "2633:       while (p < x &&",
          "2634:              (q ? p == b || *p != '\"' : *p != ';' && *p != ' ' && *p != ','))",
          "2635:         p++;",
          "2638:       return stripquotes(mg_str_n(b, (size_t) (p - b + q)));",
          "2639:     }",
          "2640:   }",
          "2641:   return mg_str_n(NULL, 0);",
          "2644: bool mg_http_match_uri(const struct mg_http_message *hm, const char *glob) {",
          "2645:   return mg_match(hm->uri, mg_str(glob), NULL);",
          "2648: long mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,",
          "2649:                     struct mg_fs *fs, const char *path, size_t max_size) {",
          "2650:   char buf[20] = \"0\";",
          "2651:   long res = 0, offset;",
          "2652:   mg_http_get_var(&hm->query, \"offset\", buf, sizeof(buf));",
          "2653:   offset = strtol(buf, NULL, 0);",
          "2654:   if (hm->body.len == 0) {",
          "2655:     mg_http_reply(c, 200, \"\", \"%ld\", res);  // Nothing to write",
          "2656:   } else {",
          "2657:     struct mg_fd *fd;",
          "2658:     size_t current_size = 0;",
          "2659:     MG_DEBUG((\"%s -> %d bytes @ %ld\", path, (int) hm->body.len, offset));",
          "2660:     if (offset == 0) fs->rm(path);  // If offset if 0, truncate file",
          "2661:     fs->st(path, &current_size, NULL);",
          "2662:     if (offset < 0) {",
          "2663:       mg_http_reply(c, 400, \"\", \"offset required\");",
          "2664:       res = -1;",
          "2665:     } else if (offset > 0 && current_size != (size_t) offset) {",
          "2666:       mg_http_reply(c, 400, \"\", \"%s: offset mismatch\", path);",
          "2667:       res = -2;",
          "2668:     } else if ((size_t) offset + hm->body.len > max_size) {",
          "2669:       mg_http_reply(c, 400, \"\", \"%s: over max size of %lu\", path,",
          "2670:                     (unsigned long) max_size);",
          "2671:       res = -3;",
          "2672:     } else if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {",
          "2673:       mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);",
          "2674:       res = -4;",
          "2675:     } else {",
          "2676:       res = offset + (long) fs->wr(fd->fd, hm->body.ptr, hm->body.len);",
          "2677:       mg_fs_close(fd);",
          "2678:       mg_http_reply(c, 200, \"\", \"%ld\", res);",
          "2679:     }",
          "2680:   }",
          "2681:   return res;",
          "2684: int mg_http_status(const struct mg_http_message *hm) {",
          "2685:   return atoi(hm->uri.ptr);",
          "2686: }",
          "2688: static bool is_hex_digit(int c) {",
          "2689:   return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||",
          "2690:          (c >= 'A' && c <= 'F');",
          "2691: }",
          "2705: static bool getchunk(struct mg_str s, size_t *prefixlen, size_t *datalen) {",
          "2706:   size_t i = 0, n;",
          "2707:   while (i < s.len && is_hex_digit(s.ptr[i])) i++;",
          "2708:   n = mg_unhexn(s.ptr, i);",
          "2710:   if (s.len < i + n + 4) return false;  // Chunk not yet fully buffered",
          "2711:   if (s.ptr[i] != '\\r' || s.ptr[i + 1] != '\\n') return false;",
          "2712:   if (s.ptr[i + n + 2] != '\\r' || s.ptr[i + n + 3] != '\\n') return false;",
          "2715:   return true;",
          "2718: static bool mg_is_chunked(struct mg_http_message *hm) {",
          "2719:   const char *needle = \"chunked\";",
          "2720:   struct mg_str *te = mg_http_get_header(hm, \"Transfer-Encoding\");",
          "2721:   return te != NULL && mg_vcasecmp(te, needle) == 0;",
          "2722: }",
          "2724: void mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm) {",
          "2725:   size_t ofs = (size_t) (hm->chunk.ptr - (char *) c->recv.buf);",
          "2726:   mg_iobuf_del(&c->recv, ofs, hm->chunk.len);",
          "2727:   c->pfn_data = (void *) ((size_t) c->pfn_data | MG_DMARK);",
          "2728: }",
          "2730: static void deliver_chunked_chunks(struct mg_connection *c, size_t hlen,",
          "2731:                                    struct mg_http_message *hm, bool *next) {",
          "2735:   char *buf = (char *) &c->recv.buf[hlen], *p = buf;",
          "2736:   size_t len = c->recv.len - hlen;",
          "2737:   size_t processed = ((size_t) c->pfn_data) & ~MG_DMARK;",
          "2738:   size_t mark, pl, dl, del = 0, ofs = 0;",
          "2739:   bool last = false;",
          "2740:   if (processed <= len) len -= processed, buf += processed;",
          "2741:   while (!last && getchunk(mg_str_n(buf + ofs, len - ofs), &pl, &dl)) {",
          "2742:     size_t saved = c->recv.len;",
          "2743:     memmove(p + processed, buf + ofs + pl, dl);",
          "2745:     hm->chunk = mg_str_n(p + processed, dl);",
          "2746:     mg_call(c, MG_EV_HTTP_CHUNK, hm);",
          "2747:     ofs += pl + dl + 2, del += pl + 2;  // 2 is for \\r\\n suffix",
          "2748:     processed += dl;",
          "2749:     if (c->recv.len != saved) processed -= dl, buf -= dl;",
          "2751:     last = (dl == 0);",
          "2752:   }",
          "2753:   mg_iobuf_del(&c->recv, hlen + processed, del);",
          "2754:   mark = ((size_t) c->pfn_data) & MG_DMARK;",
          "2755:   c->pfn_data = (void *) (processed | mark);",
          "2756:   if (last) {",
          "2757:     hm->body.len = processed;",
          "2758:     hm->message.len = hlen + processed;",
          "2759:     c->pfn_data = NULL;",
          "2760:     if (mark) mg_iobuf_del(&c->recv, 0, hlen), *next = true;",
          "2766: static void deliver_normal_chunks(struct mg_connection *c, size_t hlen,",
          "2767:                                   struct mg_http_message *hm, bool *next) {",
          "2768:   size_t left, processed = ((size_t) c->pfn_data) & ~MG_DMARK;",
          "2769:   size_t deleted = ((size_t) c->pfn_data) & MG_DMARK;",
          "2770:   hm->chunk = mg_str_n((char *) &c->recv.buf[hlen], c->recv.len - hlen);",
          "2771:   if (processed <= hm->chunk.len && !deleted) {",
          "2772:     hm->chunk.len -= processed;",
          "2773:     hm->chunk.ptr += processed;",
          "2774:   }",
          "2775:   left = hm->body.len < processed ? 0 : hm->body.len - processed;",
          "2776:   if (hm->chunk.len > left) hm->chunk.len = left;",
          "2777:   if (hm->chunk.len > 0) mg_call(c, MG_EV_HTTP_CHUNK, hm);",
          "2778:   processed += hm->chunk.len;",
          "2779:   deleted = ((size_t) c->pfn_data) & MG_DMARK;  // Re-evaluate after user call",
          "2780:   if (processed >= hm->body.len) {              // Last, 0-len chunk",
          "2781:     hm->chunk.len = 0;                          // Reset length",
          "2782:     mg_call(c, MG_EV_HTTP_CHUNK, hm);           // Call user handler",
          "2783:     c->pfn_data = NULL;                         // Reset processed counter",
          "2784:     if (processed && deleted) mg_iobuf_del(&c->recv, 0, hlen), *next = true;",
          "2785:   } else {",
          "2786:     c->pfn_data = (void *) (processed | deleted);  // if it is set",
          "2790: static void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {",
          "2791:   if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {",
          "2792:     struct mg_http_message hm;",
          "2793:     while (c->recv.buf != NULL && c->recv.len > 0) {",
          "2794:       bool next = false;",
          "2795:       int hlen = mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);",
          "2796:       if (hlen < 0) {",
          "2797:         mg_error(c, \"HTTP parse:\\n%.*s\", (int) c->recv.len, c->recv.buf);",
          "2799:       }",
          "2800:       if (c->is_resp) break;           // Response is still generated",
          "2801:       if (hlen == 0) break;            // Request is not buffered yet",
          "2802:       if (ev == MG_EV_CLOSE) {         // If client did not set Content-Length",
          "2803:         hm.message.len = c->recv.len;  // and closes now, deliver a MSG",
          "2804:         hm.body.len = hm.message.len - (size_t) (hm.body.ptr - hm.message.ptr);",
          "2805:       }",
          "2806:       if (mg_is_chunked(&hm)) {",
          "2807:         deliver_chunked_chunks(c, (size_t) hlen, &hm, &next);",
          "2808:       } else {",
          "2809:         deliver_normal_chunks(c, (size_t) hlen, &hm, &next);",
          "2810:       }",
          "2811:       if (next) continue;  // Chunks & request were deleted",
          "2813:       if (c->recv.len < hm.message.len) break;",
          "2814:       if (c->is_accepted) c->is_resp = 1;  // Start generating response",
          "2815:       mg_call(c, MG_EV_HTTP_MSG, &hm);     // User handler can clear is_resp",
          "2816:       mg_iobuf_del(&c->recv, 0, hm.message.len);",
          "2819:   (void) evd, (void) fnd;",
          "2822: static void mg_hfn(struct mg_connection *c, int ev, void *ev_data, void *fnd) {",
          "2823:   if (ev == MG_EV_HTTP_MSG) {",
          "2824:     struct mg_http_message *hm = (struct mg_http_message *) ev_data;",
          "2825:     if (mg_http_match_uri(hm, \"/quit\")) {",
          "2826:       mg_http_reply(c, 200, \"\", \"ok\\n\");",
          "2827:       c->is_draining = 1;",
          "2828:       c->data[0] = 'X';",
          "2829:     } else if (mg_http_match_uri(hm, \"/debug\")) {",
          "2830:       int level = (int) mg_json_get_long(hm->body, \"$.level\", MG_LL_DEBUG);",
          "2831:       mg_log_set(level);",
          "2832:       mg_http_reply(c, 200, \"\", \"Debug level set to %d\\n\", level);",
          "2833:     } else {",
          "2834:       mg_http_reply(c, 200, \"\", \"hi\\n\");",
          "2836:   } else if (ev == MG_EV_CLOSE) {",
          "2837:     if (c->data[0] == 'X') *(bool *) fnd = true;",
          "2841: void mg_hello(const char *url) {",
          "2842:   struct mg_mgr mgr;",
          "2843:   bool done = false;",
          "2844:   mg_mgr_init(&mgr);",
          "2845:   if (mg_http_listen(&mgr, url, mg_hfn, &done) == NULL) done = true;",
          "2846:   while (done == false) mg_mgr_poll(&mgr, 100);",
          "2847:   mg_mgr_free(&mgr);",
          "2850: struct mg_connection *mg_http_connect(struct mg_mgr *mgr, const char *url,",
          "2851:                                       mg_event_handler_t fn, void *fn_data) {",
          "2852:   struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);",
          "2853:   if (c != NULL) c->pfn = http_cb;",
          "2854:   return c;",
          "2855: }",
          "2857: struct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url,",
          "2858:                                      mg_event_handler_t fn, void *fn_data) {",
          "2859:   struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);",
          "2860:   if (c != NULL) c->pfn = http_cb;",
          "2861:   return c;",
          "2862: }",
          "2864: #ifdef MG_ENABLE_LINES",
          "2865: #line 1 \"src/iobuf.c\"",
          "2866: #endif",
          "2872: static size_t roundup(size_t size, size_t align) {",
          "2873:   return align == 0 ? size : (size + align - 1) / align * align;",
          "2876: int mg_iobuf_resize(struct mg_iobuf *io, size_t new_size) {",
          "2877:   int ok = 1;",
          "2878:   new_size = roundup(new_size, io->align);",
          "2879:   if (new_size == 0) {",
          "2880:     mg_bzero(io->buf, io->size);",
          "2881:     free(io->buf);",
          "2882:     io->buf = NULL;",
          "2883:     io->len = io->size = 0;",
          "2884:   } else if (new_size != io->size) {",
          "2887:     void *p = calloc(1, new_size);",
          "2888:     if (p != NULL) {",
          "2889:       size_t len = new_size < io->len ? new_size : io->len;",
          "2890:       if (len > 0 && io->buf != NULL) memmove(p, io->buf, len);",
          "2891:       mg_bzero(io->buf, io->size);",
          "2892:       free(io->buf);",
          "2893:       io->buf = (unsigned char *) p;",
          "2894:       io->size = new_size;",
          "2895:     } else {",
          "2896:       ok = 0;",
          "2897:       MG_ERROR((\"%lld->%lld\", (uint64_t) io->size, (uint64_t) new_size));",
          "2898:     }",
          "2900:   return ok;",
          "2901: }",
          "2903: int mg_iobuf_init(struct mg_iobuf *io, size_t size, size_t align) {",
          "2904:   io->buf = NULL;",
          "2905:   io->align = align;",
          "2906:   io->size = io->len = 0;",
          "2907:   return mg_iobuf_resize(io, size);",
          "2910: size_t mg_iobuf_add(struct mg_iobuf *io, size_t ofs, const void *buf,",
          "2911:                     size_t len) {",
          "2912:   size_t new_size = roundup(io->len + len, io->align);",
          "2913:   mg_iobuf_resize(io, new_size);      // Attempt to resize",
          "2914:   if (new_size != io->size) len = 0;  // Resize failure, append nothing",
          "2915:   if (ofs < io->len) memmove(io->buf + ofs + len, io->buf + ofs, io->len - ofs);",
          "2916:   if (buf != NULL) memmove(io->buf + ofs, buf, len);",
          "2917:   if (ofs > io->len) io->len += ofs - io->len;",
          "2918:   io->len += len;",
          "2919:   return len;",
          "2920: }",
          "2922: size_t mg_iobuf_del(struct mg_iobuf *io, size_t ofs, size_t len) {",
          "2923:   if (ofs > io->len) ofs = io->len;",
          "2924:   if (ofs + len > io->len) len = io->len - ofs;",
          "2925:   if (io->buf) memmove(io->buf + ofs, io->buf + ofs + len, io->len - ofs - len);",
          "2926:   if (io->buf) mg_bzero(io->buf + io->len - len, len);",
          "2927:   io->len -= len;",
          "2928:   return len;",
          "2929: }",
          "2931: void mg_iobuf_free(struct mg_iobuf *io) {",
          "2932:   mg_iobuf_resize(io, 0);",
          "2935: #ifdef MG_ENABLE_LINES",
          "2936: #line 1 \"src/json.c\"",
          "2937: #endif",
          "2942: static const char *escapeseq(int esc) {",
          "2943:   return esc ? \"\\b\\f\\n\\r\\t\\\\\\\"\" : \"bfnrt\\\\\\\"\";",
          "2944: }",
          "2946: static char json_esc(int c, int esc) {",
          "2947:   const char *p, *esc1 = escapeseq(esc), *esc2 = escapeseq(!esc);",
          "2948:   for (p = esc1; *p != '\\0'; p++) {",
          "2949:     if (*p == c) return esc2[p - esc1];",
          "2951:   return 0;",
          "2952: }",
          "2954: static int mg_pass_string(const char *s, int len) {",
          "2955:   int i;",
          "2956:   for (i = 0; i < len; i++) {",
          "2957:     if (s[i] == '\\\\' && i + 1 < len && json_esc(s[i + 1], 1)) {",
          "2958:       i++;",
          "2959:     } else if (s[i] == '\\0') {",
          "2960:       return MG_JSON_INVALID;",
          "2961:     } else if (s[i] == '\"') {",
          "2962:       return i;",
          "2965:   return MG_JSON_INVALID;",
          "2968: static double mg_atod(const char *p, int len, int *numlen) {",
          "2969:   double d = 0.0;",
          "2970:   int i = 0, sign = 1;",
          "2973:   if (i < len && *p == '-') {",
          "2974:     sign = -1, i++;",
          "2975:   } else if (i < len && *p == '+') {",
          "2976:     i++;",
          "2977:   }",
          "2980:   for (; i < len && p[i] >= '0' && p[i] <= '9'; i++) {",
          "2981:     d *= 10.0;",
          "2982:     d += p[i] - '0';",
          "2983:   }",
          "2984:   d *= sign;",
          "2987:   if (i < len && p[i] == '.') {",
          "2988:     double frac = 0.0, base = 0.1;",
          "2989:     i++;",
          "2990:     for (; i < len && p[i] >= '0' && p[i] <= '9'; i++) {",
          "2991:       frac += base * (p[i] - '0');",
          "2992:       base /= 10.0;",
          "2994:     d += frac * sign;",
          "2998:   if (i < len && (p[i] == 'e' || p[i] == 'E')) {",
          "2999:     int j, exp = 0, minus = 0;",
          "3000:     i++;",
          "3001:     if (i < len && p[i] == '-') minus = 1, i++;",
          "3002:     if (i < len && p[i] == '+') i++;",
          "3003:     while (i < len && p[i] >= '0' && p[i] <= '9' && exp < 308)",
          "3004:       exp = exp * 10 + (p[i++] - '0');",
          "3005:     if (minus) exp = -exp;",
          "3006:     for (j = 0; j < exp; j++) d *= 10.0;",
          "3007:     for (j = 0; j < -exp; j++) d /= 10.0;",
          "3010:   if (numlen != NULL) *numlen = i;",
          "3011:   return d;",
          "3014: int mg_json_get(struct mg_str json, const char *path, int *toklen) {",
          "3015:   const char *s = json.ptr;",
          "3016:   int len = (int) json.len;",
          "3017:   enum { S_VALUE, S_KEY, S_COLON, S_COMMA_OR_EOO } expecting = S_VALUE;",
          "3018:   unsigned char nesting[MG_JSON_MAX_DEPTH];",
          "3019:   int i = 0;             // Current offset in `s`",
          "3020:   int j = 0;             // Offset in `s` we're looking for (return value)",
          "3021:   int depth = 0;         // Current depth (nesting level)",
          "3022:   int ed = 0;            // Expected depth",
          "3023:   int pos = 1;           // Current position in `path`",
          "3024:   int ci = -1, ei = -1;  // Current and expected index in array",
          "3026:   if (toklen) *toklen = 0;",
          "3027:   if (path[0] != '$') return MG_JSON_INVALID;",
          "3029: #define MG_CHECKRET(x)                                  \\",
          "3030:   do {                                                  \\",
          "3031:     if (depth == ed && path[pos] == '\\0' && ci == ei) { \\",
          "3032:       if (toklen) *toklen = i - j + 1;                  \\",
          "3033:       return j;                                         \\",
          "3034:     }                                                   \\",
          "3035:   } while (0)",
          "3039: #define MG_EOO(x)                                            \\",
          "3040:   do {                                                       \\",
          "3041:     if (depth == ed && ci != ei) return MG_JSON_NOT_FOUND;   \\",
          "3042:     if (c != nesting[depth - 1] + 2) return MG_JSON_INVALID; \\",
          "3043:     depth--;                                                 \\",
          "3044:     MG_CHECKRET(x);                                          \\",
          "3045:   } while (0)",
          "3047:   for (i = 0; i < len; i++) {",
          "3048:     unsigned char c = ((unsigned char *) s)[i];",
          "3049:     if (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') continue;",
          "3050:     switch (expecting) {",
          "3051:       case S_VALUE:",
          "3053:         if (depth == ed) j = i;",
          "3054:         if (c == '{') {",
          "3055:           if (depth >= (int) sizeof(nesting)) return MG_JSON_TOO_DEEP;",
          "3056:           if (depth == ed && path[pos] == '.' && ci == ei) {",
          "3058:             ed++, pos++, ci = ei = -1;",
          "3059:           }",
          "3060:           nesting[depth++] = c;",
          "3061:           expecting = S_KEY;",
          "3062:           break;",
          "3063:         } else if (c == '[') {",
          "3064:           if (depth >= (int) sizeof(nesting)) return MG_JSON_TOO_DEEP;",
          "3065:           if (depth == ed && path[pos] == '[' && ei == ci) {",
          "3066:             ed++, pos++, ci = 0;",
          "3067:             for (ei = 0; path[pos] != ']' && path[pos] != '\\0'; pos++) {",
          "3068:               ei *= 10;",
          "3069:               ei += path[pos] - '0';",
          "3070:             }",
          "3071:             if (path[pos] != 0) pos++;",
          "3072:           }",
          "3073:           nesting[depth++] = c;",
          "3074:           break;",
          "3075:         } else if (c == ']' && depth > 0) {  // Empty array",
          "3076:           MG_EOO(']');",
          "3077:         } else if (c == 't' && i + 3 < len && memcmp(&s[i], \"true\", 4) == 0) {",
          "3078:           i += 3;",
          "3079:         } else if (c == 'n' && i + 3 < len && memcmp(&s[i], \"null\", 4) == 0) {",
          "3080:           i += 3;",
          "3081:         } else if (c == 'f' && i + 4 < len && memcmp(&s[i], \"false\", 5) == 0) {",
          "3082:           i += 4;",
          "3083:         } else if (c == '-' || ((c >= '0' && c <= '9'))) {",
          "3084:           int numlen = 0;",
          "3085:           mg_atod(&s[i], len - i, &numlen);",
          "3086:           i += numlen - 1;",
          "3087:         } else if (c == '\"') {",
          "3088:           int n = mg_pass_string(&s[i + 1], len - i - 1);",
          "3089:           if (n < 0) return n;",
          "3090:           i += n + 1;",
          "3091:         } else {",
          "3092:           return MG_JSON_INVALID;",
          "3093:         }",
          "3094:         MG_CHECKRET('V');",
          "3095:         if (depth == ed && ei >= 0) ci++;",
          "3096:         expecting = S_COMMA_OR_EOO;",
          "3097:         break;",
          "3099:       case S_KEY:",
          "3100:         if (c == '\"') {",
          "3101:           int n = mg_pass_string(&s[i + 1], len - i - 1);",
          "3102:           if (n < 0) return n;",
          "3103:           if (i + 1 + n >= len) return MG_JSON_NOT_FOUND;",
          "3104:           if (depth < ed) return MG_JSON_NOT_FOUND;",
          "3105:           if (depth == ed && path[pos - 1] != '.') return MG_JSON_NOT_FOUND;",
          "3111:           if (depth == ed && path[pos - 1] == '.' &&",
          "3112:               strncmp(&s[i + 1], &path[pos], (size_t) n) == 0 &&",
          "3113:               (path[pos + n] == '\\0' || path[pos + n] == '.' ||",
          "3114:                path[pos + n] == '[')) {",
          "3115:             pos += n;",
          "3116:           }",
          "3117:           i += n + 1;",
          "3118:           expecting = S_COLON;",
          "3119:         } else if (c == '}') {  // Empty object",
          "3120:           MG_EOO('}');",
          "3121:           expecting = S_COMMA_OR_EOO;",
          "3122:           if (depth == ed && ei >= 0) ci++;",
          "3123:         } else {",
          "3124:           return MG_JSON_INVALID;",
          "3125:         }",
          "3126:         break;",
          "3128:       case S_COLON:",
          "3129:         if (c == ':') {",
          "3130:           expecting = S_VALUE;",
          "3131:         } else {",
          "3132:           return MG_JSON_INVALID;",
          "3133:         }",
          "3134:         break;",
          "3136:       case S_COMMA_OR_EOO:",
          "3137:         if (depth <= 0) {",
          "3138:           return MG_JSON_INVALID;",
          "3139:         } else if (c == ',') {",
          "3140:           expecting = (nesting[depth - 1] == '{') ? S_KEY : S_VALUE;",
          "3141:         } else if (c == ']' || c == '}') {",
          "3142:           if (depth == ed && c == '}' && path[pos - 1] == '.')",
          "3143:             return MG_JSON_NOT_FOUND;",
          "3144:           if (depth == ed && c == ']' && path[pos - 1] == ',')",
          "3145:             return MG_JSON_NOT_FOUND;",
          "3146:           MG_EOO('O');",
          "3147:           if (depth == ed && ei >= 0) ci++;",
          "3148:         } else {",
          "3149:           return MG_JSON_INVALID;",
          "3150:         }",
          "3151:         break;",
          "3152:     }",
          "3153:   }",
          "3154:   return MG_JSON_NOT_FOUND;",
          "3157: bool mg_json_get_num(struct mg_str json, const char *path, double *v) {",
          "3158:   int n, toklen, found = 0;",
          "3159:   if ((n = mg_json_get(json, path, &toklen)) >= 0 &&",
          "3160:       (json.ptr[n] == '-' || (json.ptr[n] >= '0' && json.ptr[n] <= '9'))) {",
          "3161:     if (v != NULL) *v = mg_atod(json.ptr + n, toklen, NULL);",
          "3162:     found = 1;",
          "3163:   }",
          "3164:   return found;",
          "3167: bool mg_json_get_bool(struct mg_str json, const char *path, bool *v) {",
          "3168:   int found = 0, off = mg_json_get(json, path, NULL);",
          "3169:   if (off >= 0 && (json.ptr[off] == 't' || json.ptr[off] == 'f')) {",
          "3170:     if (v != NULL) *v = json.ptr[off] == 't';",
          "3171:     found = 1;",
          "3172:   }",
          "3173:   return found;",
          "3176: bool mg_json_unescape(struct mg_str s, char *to, size_t n) {",
          "3177:   size_t i, j;",
          "3178:   for (i = 0, j = 0; i < s.len && j < n; i++, j++) {",
          "3179:     if (s.ptr[i] == '\\\\' && i + 5 < s.len && s.ptr[i + 1] == 'u') {",
          "3183:       if (s.ptr[i + 2] != '0' || s.ptr[i + 3] != '0') return false;  // Give up",
          "3184:       ((unsigned char *) to)[j] = (unsigned char) mg_unhexn(s.ptr + i + 4, 2);",
          "3186:       i += 5;",
          "3187:     } else if (s.ptr[i] == '\\\\' && i + 1 < s.len) {",
          "3188:       char c = json_esc(s.ptr[i + 1], 0);",
          "3189:       if (c == 0) return false;",
          "3190:       to[j] = c;",
          "3191:       i++;",
          "3193:       to[j] = s.ptr[i];",
          "3196:   if (j >= n) return false;",
          "3197:   if (n > 0) to[j] = '\\0';",
          "3198:   return true;",
          "3201: char *mg_json_get_str(struct mg_str json, const char *path) {",
          "3202:   char *result = NULL;",
          "3203:   int len = 0, off = mg_json_get(json, path, &len);",
          "3204:   if (off >= 0 && len > 1 && json.ptr[off] == '\"') {",
          "3205:     if ((result = (char *) calloc(1, (size_t) len)) != NULL &&",
          "3206:         !mg_json_unescape(mg_str_n(json.ptr + off + 1, (size_t) (len - 2)),",
          "3207:                           result, (size_t) len)) {",
          "3208:       free(result);",
          "3209:       result = NULL;",
          "3210:     }",
          "3212:   return result;",
          "3215: char *mg_json_get_b64(struct mg_str json, const char *path, int *slen) {",
          "3216:   char *result = NULL;",
          "3217:   int len = 0, off = mg_json_get(json, path, &len);",
          "3218:   if (off >= 0 && json.ptr[off] == '\"' && len > 1 &&",
          "3219:       (result = (char *) calloc(1, (size_t) len)) != NULL) {",
          "3220:     size_t k = mg_base64_decode(json.ptr + off + 1, (size_t) (len - 2), result,",
          "3221:                                 (size_t) len);",
          "3222:     if (slen != NULL) *slen = (int) k;",
          "3224:   return result;",
          "3225: }",
          "3227: char *mg_json_get_hex(struct mg_str json, const char *path, int *slen) {",
          "3228:   char *result = NULL;",
          "3229:   int len = 0, off = mg_json_get(json, path, &len);",
          "3230:   if (off >= 0 && json.ptr[off] == '\"' && len > 1 &&",
          "3231:       (result = (char *) calloc(1, (size_t) len / 2)) != NULL) {",
          "3232:     mg_unhex(json.ptr + off + 1, (size_t) (len - 2), (uint8_t *) result);",
          "3233:     result[len / 2 - 1] = '\\0';",
          "3234:     if (slen != NULL) *slen = len / 2 - 1;",
          "3236:   return result;",
          "3237: }",
          "3239: long mg_json_get_long(struct mg_str json, const char *path, long dflt) {",
          "3240:   double dv;",
          "3241:   long result = dflt;",
          "3242:   if (mg_json_get_num(json, path, &dv)) result = (long) dv;",
          "3243:   return result;",
          "3246: #ifdef MG_ENABLE_LINES",
          "3247: #line 1 \"src/log.c\"",
          "3248: #endif",
          "3254: static int s_level = MG_LL_INFO;",
          "3255: static mg_pfn_t s_log_func = mg_pfn_stdout;",
          "3256: static void *s_log_func_param = NULL;",
          "3258: void mg_log_set_fn(mg_pfn_t fn, void *param) {",
          "3259:   s_log_func = fn;",
          "3260:   s_log_func_param = param;",
          "3263: static void logc(unsigned char c) {",
          "3264:   s_log_func((char) c, s_log_func_param);",
          "3267: static void logs(const char *buf, size_t len) {",
          "3268:   size_t i;",
          "3269:   for (i = 0; i < len; i++) logc(((unsigned char *) buf)[i]);",
          "3270: }",
          "3272: void mg_log_set(int log_level) {",
          "3273:   MG_DEBUG((\"Setting log level to %d\", log_level));",
          "3274:   s_level = log_level;",
          "3277: bool mg_log_prefix(int level, const char *file, int line, const char *fname) {",
          "3278:   if (level <= s_level) {",
          "3279:     const char *p = strrchr(file, '/');",
          "3280:     char buf[41];",
          "3281:     size_t n;",
          "3282:     if (p == NULL) p = strrchr(file, '\\\\');",
          "3283:     n = mg_snprintf(buf, sizeof(buf), \"%-6llx %d %s:%d:%s\", mg_millis(), level,",
          "3284:                     p == NULL ? file : p + 1, line, fname);",
          "3285:     if (n > sizeof(buf) - 2) n = sizeof(buf) - 2;",
          "3286:     while (n < sizeof(buf)) buf[n++] = ' ';",
          "3287:     logs(buf, n - 1);",
          "3288:     return true;",
          "3290:     return false;",
          "3294: void mg_log(const char *fmt, ...) {",
          "3295:   va_list ap;",
          "3296:   va_start(ap, fmt);",
          "3297:   mg_vxprintf(s_log_func, s_log_func_param, fmt, &ap);",
          "3298:   va_end(ap);",
          "3299:   logs(\"\\r\\n\", 2);",
          "3302: static unsigned char nibble(unsigned c) {",
          "3303:   return (unsigned char) (c < 10 ? c + '0' : c + 'W');",
          "3306: #define ISPRINT(x) ((x) >= ' ' && (x) <= '~')",
          "3307: void mg_hexdump(const void *buf, size_t len) {",
          "3308:   const unsigned char *p = (const unsigned char *) buf;",
          "3309:   unsigned char ascii[16], alen = 0;",
          "3310:   size_t i;",
          "3311:   for (i = 0; i < len; i++) {",
          "3312:     if ((i % 16) == 0) {",
          "3314:       if (i > 0) logs(\"  \", 2), logs((char *) ascii, 16), logc('\\n'), alen = 0;",
          "3316:       logc(nibble((i >> 12) & 15)), logc(nibble((i >> 8) & 15)),",
          "3317:           logc(nibble((i >> 4) & 15)), logc('0'), logs(\"   \", 3);",
          "3318:     }",
          "3319:     logc(nibble(p[i] >> 4)), logc(nibble(p[i] & 15));  // Two nibbles, e.g. c5",
          "3320:     logc(' ');                                         // Space after hex number",
          "3321:     ascii[alen++] = ISPRINT(p[i]) ? p[i] : '.';        // Add to the ascii buf",
          "3323:   while (alen < 16) logs(\"   \", 3), ascii[alen++] = ' ';",
          "3324:   logs(\"  \", 2), logs((char *) ascii, 16), logc('\\n');",
          "3327: #ifdef MG_ENABLE_LINES",
          "3328: #line 1 \"src/md5.c\"",
          "3333: #if defined(MG_ENABLE_MD5) && MG_ENABLE_MD5",
          "3335: static void mg_byte_reverse(unsigned char *buf, unsigned longs) {",
          "3336:   if (MG_BIG_ENDIAN) {",
          "3337:     do {",
          "3338:       uint32_t t = (uint32_t) ((unsigned) buf[3] << 8 | buf[2]) << 16 |",
          "3339:                    ((unsigned) buf[1] << 8 | buf[0]);",
          "3341:       buf += 4;",
          "3342:     } while (--longs);",
          "3343:   } else {",
          "3344:     (void) buf, (void) longs;  // Little endian. Do nothing",
          "3345:   }",
          "3346: }",
          "3348: #define F1(x, y, z) (z ^ (x & (y ^ z)))",
          "3349: #define F2(x, y, z) F1(z, x, y)",
          "3350: #define F3(x, y, z) (x ^ y ^ z)",
          "3351: #define F4(x, y, z) (y ^ (x | ~z))",
          "3353: #define MD5STEP(f, w, x, y, z, data, s) \\",
          "3354:   (w += f(x, y, z) + data, w = w << s | w >> (32 - s), w += x)",
          "3360: void mg_md5_init(mg_md5_ctx *ctx) {",
          "3361:   ctx->buf[0] = 0x67452301;",
          "3362:   ctx->buf[1] = 0xefcdab89;",
          "3363:   ctx->buf[2] = 0x98badcfe;",
          "3364:   ctx->buf[3] = 0x10325476;",
          "3366:   ctx->bits[0] = 0;",
          "3367:   ctx->bits[1] = 0;",
          "3368: }",
          "3370: static void mg_md5_transform(uint32_t buf[4], uint32_t const in[16]) {",
          "3371:   uint32_t a, b, c, d;",
          "3373:   a = buf[0];",
          "3374:   b = buf[1];",
          "3375:   c = buf[2];",
          "3376:   d = buf[3];",
          "3378:   MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);",
          "3379:   MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);",
          "3380:   MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);",
          "3381:   MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);",
          "3382:   MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);",
          "3383:   MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);",
          "3384:   MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);",
          "3385:   MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);",
          "3386:   MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);",
          "3387:   MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);",
          "3388:   MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);",
          "3389:   MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);",
          "3390:   MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);",
          "3391:   MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);",
          "3392:   MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);",
          "3393:   MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);",
          "3395:   MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);",
          "3396:   MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);",
          "3397:   MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);",
          "3398:   MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);",
          "3399:   MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);",
          "3400:   MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);",
          "3401:   MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);",
          "3402:   MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);",
          "3403:   MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);",
          "3404:   MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);",
          "3405:   MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);",
          "3406:   MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);",
          "3407:   MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);",
          "3408:   MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);",
          "3409:   MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);",
          "3410:   MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);",
          "3412:   MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);",
          "3413:   MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);",
          "3414:   MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);",
          "3415:   MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);",
          "3416:   MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);",
          "3417:   MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);",
          "3418:   MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);",
          "3419:   MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);",
          "3420:   MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);",
          "3421:   MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);",
          "3422:   MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);",
          "3423:   MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);",
          "3424:   MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);",
          "3425:   MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);",
          "3426:   MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);",
          "3427:   MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);",
          "3429:   MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);",
          "3430:   MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);",
          "3431:   MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);",
          "3432:   MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);",
          "3433:   MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);",
          "3434:   MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);",
          "3435:   MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);",
          "3436:   MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);",
          "3437:   MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);",
          "3438:   MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);",
          "3439:   MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);",
          "3440:   MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);",
          "3441:   MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);",
          "3442:   MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);",
          "3443:   MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);",
          "3444:   MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);",
          "3446:   buf[0] += a;",
          "3447:   buf[1] += b;",
          "3448:   buf[2] += c;",
          "3449:   buf[3] += d;",
          "3450: }",
          "3452: void mg_md5_update(mg_md5_ctx *ctx, const unsigned char *buf, size_t len) {",
          "3453:   uint32_t t;",
          "3455:   t = ctx->bits[0];",
          "3456:   if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t) ctx->bits[1]++;",
          "3457:   ctx->bits[1] += (uint32_t) len >> 29;",
          "3459:   t = (t >> 3) & 0x3f;",
          "3461:   if (t) {",
          "3462:     unsigned char *p = (unsigned char *) ctx->in + t;",
          "3464:     t = 64 - t;",
          "3465:     if (len < t) {",
          "3466:       memcpy(p, buf, len);",
          "3467:       return;",
          "3468:     }",
          "3469:     memcpy(p, buf, t);",
          "3470:     mg_byte_reverse(ctx->in, 16);",
          "3471:     mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);",
          "3472:     buf += t;",
          "3473:     len -= t;",
          "3474:   }",
          "3476:   while (len >= 64) {",
          "3477:     memcpy(ctx->in, buf, 64);",
          "3478:     mg_byte_reverse(ctx->in, 16);",
          "3479:     mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);",
          "3480:     buf += 64;",
          "3481:     len -= 64;",
          "3482:   }",
          "3484:   memcpy(ctx->in, buf, len);",
          "3487: void mg_md5_final(mg_md5_ctx *ctx, unsigned char digest[16]) {",
          "3488:   unsigned count;",
          "3489:   unsigned char *p;",
          "3490:   uint32_t *a;",
          "3492:   count = (ctx->bits[0] >> 3) & 0x3F;",
          "3494:   p = ctx->in + count;",
          "3496:   count = 64 - 1 - count;",
          "3497:   if (count < 8) {",
          "3498:     memset(p, 0, count);",
          "3499:     mg_byte_reverse(ctx->in, 16);",
          "3500:     mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);",
          "3501:     memset(ctx->in, 0, 56);",
          "3502:   } else {",
          "3503:     memset(p, 0, count - 8);",
          "3504:   }",
          "3505:   mg_byte_reverse(ctx->in, 14);",
          "3507:   a = (uint32_t *) ctx->in;",
          "3508:   a[14] = ctx->bits[0];",
          "3509:   a[15] = ctx->bits[1];",
          "3511:   mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);",
          "3512:   mg_byte_reverse((unsigned char *) ctx->buf, 4);",
          "3513:   memcpy(digest, ctx->buf, 16);",
          "3514:   memset((char *) ctx, 0, sizeof(*ctx));",
          "3516: #endif",
          "3518: #ifdef MG_ENABLE_LINES",
          "3519: #line 1 \"src/mqtt.c\"",
          "3520: #endif",
          "3529: #define MQTT_CLEAN_SESSION 0x02",
          "3530: #define MQTT_HAS_WILL 0x04",
          "3531: #define MQTT_WILL_RETAIN 0x20",
          "3532: #define MQTT_HAS_PASSWORD 0x40",
          "3533: #define MQTT_HAS_USER_NAME 0x80",
          "3535: struct mg_mqtt_pmap {",
          "3536:   uint8_t id;",
          "3537:   uint8_t type;",
          "3538: };",
          "3540: static const struct mg_mqtt_pmap s_prop_map[] = {",
          "3541:     {MQTT_PROP_PAYLOAD_FORMAT_INDICATOR, MQTT_PROP_TYPE_BYTE},",
          "3542:     {MQTT_PROP_MESSAGE_EXPIRY_INTERVAL, MQTT_PROP_TYPE_INT},",
          "3543:     {MQTT_PROP_CONTENT_TYPE, MQTT_PROP_TYPE_STRING},",
          "3544:     {MQTT_PROP_RESPONSE_TOPIC, MQTT_PROP_TYPE_STRING},",
          "3545:     {MQTT_PROP_CORRELATION_DATA, MQTT_PROP_TYPE_BINARY_DATA},",
          "3546:     {MQTT_PROP_SUBSCRIPTION_IDENTIFIER, MQTT_PROP_TYPE_VARIABLE_INT},",
          "3547:     {MQTT_PROP_SESSION_EXPIRY_INTERVAL, MQTT_PROP_TYPE_INT},",
          "3548:     {MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, MQTT_PROP_TYPE_STRING},",
          "3549:     {MQTT_PROP_SERVER_KEEP_ALIVE, MQTT_PROP_TYPE_SHORT},",
          "3550:     {MQTT_PROP_AUTHENTICATION_METHOD, MQTT_PROP_TYPE_STRING},",
          "3551:     {MQTT_PROP_AUTHENTICATION_DATA, MQTT_PROP_TYPE_BINARY_DATA},",
          "3552:     {MQTT_PROP_REQUEST_PROBLEM_INFORMATION, MQTT_PROP_TYPE_BYTE},",
          "3553:     {MQTT_PROP_WILL_DELAY_INTERVAL, MQTT_PROP_TYPE_INT},",
          "3554:     {MQTT_PROP_REQUEST_RESPONSE_INFORMATION, MQTT_PROP_TYPE_BYTE},",
          "3555:     {MQTT_PROP_RESPONSE_INFORMATION, MQTT_PROP_TYPE_STRING},",
          "3556:     {MQTT_PROP_SERVER_REFERENCE, MQTT_PROP_TYPE_STRING},",
          "3557:     {MQTT_PROP_REASON_STRING, MQTT_PROP_TYPE_STRING},",
          "3558:     {MQTT_PROP_RECEIVE_MAXIMUM, MQTT_PROP_TYPE_SHORT},",
          "3559:     {MQTT_PROP_TOPIC_ALIAS_MAXIMUM, MQTT_PROP_TYPE_SHORT},",
          "3560:     {MQTT_PROP_TOPIC_ALIAS, MQTT_PROP_TYPE_SHORT},",
          "3561:     {MQTT_PROP_MAXIMUM_QOS, MQTT_PROP_TYPE_BYTE},",
          "3562:     {MQTT_PROP_RETAIN_AVAILABLE, MQTT_PROP_TYPE_BYTE},",
          "3563:     {MQTT_PROP_USER_PROPERTY, MQTT_PROP_TYPE_STRING_PAIR},",
          "3564:     {MQTT_PROP_MAXIMUM_PACKET_SIZE, MQTT_PROP_TYPE_INT},",
          "3565:     {MQTT_PROP_WILDCARD_SUBSCRIPTION_AVAILABLE, MQTT_PROP_TYPE_BYTE},",
          "3566:     {MQTT_PROP_SUBSCRIPTION_IDENTIFIER_AVAILABLE, MQTT_PROP_TYPE_BYTE},",
          "3567:     {MQTT_PROP_SHARED_SUBSCRIPTION_AVAILABLE, MQTT_PROP_TYPE_BYTE}};",
          "3569: void mg_mqtt_send_header(struct mg_connection *c, uint8_t cmd, uint8_t flags,",
          "3570:                          uint32_t len) {",
          "3571:   uint8_t buf[1 + sizeof(len)], *vlen = &buf[1];",
          "3572:   buf[0] = (uint8_t) ((cmd << 4) | flags);",
          "3573:   do {",
          "3575:     len /= 0x80;",
          "3576:     if (len > 0) *vlen |= 0x80;",
          "3577:     vlen++;",
          "3578:   } while (len > 0 && vlen < &buf[sizeof(buf)]);",
          "3579:   mg_send(c, buf, (size_t) (vlen - buf));",
          "3582: static void mg_send_u16(struct mg_connection *c, uint16_t value) {",
          "3583:   mg_send(c, &value, sizeof(value));",
          "3586: static void mg_send_u32(struct mg_connection *c, uint32_t value) {",
          "3587:   mg_send(c, &value, sizeof(value));",
          "3590: static uint8_t varint_size(size_t length) {",
          "3591:   uint8_t bytes_needed = 0;",
          "3592:   do {",
          "3593:     bytes_needed++;",
          "3594:     length /= 0x80;",
          "3595:   } while (length > 0);",
          "3596:   return bytes_needed;",
          "3599: static size_t encode_varint(uint8_t *buf, size_t value) {",
          "3600:   size_t len = 0;",
          "3602:   do {",
          "3603:     uint8_t byte = (uint8_t) (value % 128);",
          "3604:     value /= 128;",
          "3605:     if (value > 0) byte |= 0x80;",
          "3606:     buf[len++] = byte;",
          "3607:   } while (value > 0);",
          "3609:   return len;",
          "3612: static size_t decode_varint(const uint8_t *buf, size_t len, size_t *value) {",
          "3613:   size_t multiplier = 1, offset;",
          "3616:   for (offset = 0; offset < 4 && offset < len; offset++) {",
          "3617:     uint8_t encoded_byte = buf[offset];",
          "3619:     multiplier *= 128;",
          "3621:     if ((encoded_byte & 0x80) == 0) return offset + 1;",
          "3624:   return 0;",
          "3627: static int mqtt_prop_type_by_id(uint8_t prop_id) {",
          "3628:   size_t i, num_properties = sizeof(s_prop_map) / sizeof(s_prop_map[0]);",
          "3629:   for (i = 0; i < num_properties; ++i) {",
          "3630:     if (s_prop_map[i].id == prop_id) return s_prop_map[i].type;",
          "3632:   return -1;  // Property ID not found",
          "3637: static size_t get_properties_length(struct mg_mqtt_prop *props, size_t count) {",
          "3638:   size_t i, size = 0;",
          "3639:   for (i = 0; i < count; i++) {",
          "3640:     size++;  // identifier",
          "3641:     switch (mqtt_prop_type_by_id(props[i].id)) {",
          "3642:       case MQTT_PROP_TYPE_STRING_PAIR:",
          "3643:         size += (uint32_t) (props[i].val.len + props[i].key.len +",
          "3644:                             2 * sizeof(uint16_t));",
          "3645:         break;",
          "3646:       case MQTT_PROP_TYPE_STRING:",
          "3647:         size += (uint32_t) (props[i].val.len + sizeof(uint16_t));",
          "3648:         break;",
          "3649:       case MQTT_PROP_TYPE_BINARY_DATA:",
          "3650:         size += (uint32_t) (props[i].val.len + sizeof(uint16_t));",
          "3651:         break;",
          "3652:       case MQTT_PROP_TYPE_VARIABLE_INT:",
          "3653:         size += varint_size((uint32_t) props[i].iv);",
          "3654:         break;",
          "3655:       case MQTT_PROP_TYPE_INT:",
          "3656:         size += (uint32_t) sizeof(uint32_t);",
          "3657:         break;",
          "3658:       case MQTT_PROP_TYPE_SHORT:",
          "3659:         size += (uint32_t) sizeof(uint16_t);",
          "3660:         break;",
          "3661:       case MQTT_PROP_TYPE_BYTE:",
          "3662:         size += (uint32_t) sizeof(uint8_t);",
          "3663:         break;",
          "3664:       default:",
          "3665:         return size;  // cannot parse further down",
          "3669:   return size;",
          "3674: static size_t get_props_size(struct mg_mqtt_prop *props, size_t count) {",
          "3675:   size_t size = get_properties_length(props, count);",
          "3676:   size += varint_size(size);",
          "3677:   return size;",
          "3680: static void mg_send_mqtt_properties(struct mg_connection *c,",
          "3681:                                     struct mg_mqtt_prop *props, size_t nprops) {",
          "3682:   size_t total_size = get_properties_length(props, nprops);",
          "3683:   uint8_t buf_v[4] = {0, 0, 0, 0};",
          "3684:   uint8_t buf[4] = {0, 0, 0, 0};",
          "3685:   size_t i, len = encode_varint(buf, total_size);",
          "3687:   mg_send(c, buf, (size_t) len);",
          "3688:   for (i = 0; i < nprops; i++) {",
          "3689:     mg_send(c, &props[i].id, sizeof(props[i].id));",
          "3690:     switch (mqtt_prop_type_by_id(props[i].id)) {",
          "3691:       case MQTT_PROP_TYPE_STRING_PAIR:",
          "3692:         mg_send_u16(c, mg_htons((uint16_t) props[i].key.len));",
          "3693:         mg_send(c, props[i].key.ptr, props[i].key.len);",
          "3694:         mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));",
          "3695:         mg_send(c, props[i].val.ptr, props[i].val.len);",
          "3696:         break;",
          "3697:       case MQTT_PROP_TYPE_BYTE:",
          "3698:         mg_send(c, &props[i].iv, sizeof(uint8_t));",
          "3699:         break;",
          "3700:       case MQTT_PROP_TYPE_SHORT:",
          "3701:         mg_send_u16(c, mg_htons((uint16_t) props[i].iv));",
          "3702:         break;",
          "3703:       case MQTT_PROP_TYPE_INT:",
          "3704:         mg_send_u32(c, mg_htonl((uint32_t) props[i].iv));",
          "3705:         break;",
          "3706:       case MQTT_PROP_TYPE_STRING:",
          "3707:         mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));",
          "3708:         mg_send(c, props[i].val.ptr, props[i].val.len);",
          "3709:         break;",
          "3710:       case MQTT_PROP_TYPE_BINARY_DATA:",
          "3711:         mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));",
          "3712:         mg_send(c, props[i].val.ptr, props[i].val.len);",
          "3713:         break;",
          "3714:       case MQTT_PROP_TYPE_VARIABLE_INT:",
          "3715:         len = encode_varint(buf_v, props[i].iv);",
          "3716:         mg_send(c, buf_v, (size_t) len);",
          "3717:         break;",
          "3718:     }",
          "3722: size_t mg_mqtt_next_prop(struct mg_mqtt_message *msg, struct mg_mqtt_prop *prop,",
          "3723:                          size_t ofs) {",
          "3724:   uint8_t *i = (uint8_t *) msg->dgram.ptr + msg->props_start + ofs;",
          "3725:   uint8_t *end = (uint8_t *) msg->dgram.ptr + msg->dgram.len;",
          "3726:   size_t new_pos = ofs, len;",
          "3727:   prop->id = i[0];",
          "3729:   if (ofs >= msg->dgram.len || ofs >= msg->props_start + msg->props_size)",
          "3730:     return 0;",
          "3731:   i++, new_pos++;",
          "3733:   switch (mqtt_prop_type_by_id(prop->id)) {",
          "3734:     case MQTT_PROP_TYPE_STRING_PAIR:",
          "3735:       prop->key.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);",
          "3736:       prop->key.ptr = (char *) i + 2;",
          "3737:       i += 2 + prop->key.len;",
          "3738:       prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);",
          "3739:       prop->val.ptr = (char *) i + 2;",
          "3740:       new_pos += 2 * sizeof(uint16_t) + prop->val.len + prop->key.len;",
          "3741:       break;",
          "3742:     case MQTT_PROP_TYPE_BYTE:",
          "3743:       prop->iv = (uint8_t) i[0];",
          "3744:       new_pos++;",
          "3745:       break;",
          "3746:     case MQTT_PROP_TYPE_SHORT:",
          "3747:       prop->iv = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);",
          "3748:       new_pos += sizeof(uint16_t);",
          "3749:       break;",
          "3750:     case MQTT_PROP_TYPE_INT:",
          "3751:       prop->iv = ((uint32_t) i[0] << 24) | ((uint32_t) i[1] << 16) |",
          "3752:                  ((uint32_t) i[2] << 8) | i[3];",
          "3753:       new_pos += sizeof(uint32_t);",
          "3754:       break;",
          "3755:     case MQTT_PROP_TYPE_STRING:",
          "3756:       prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);",
          "3757:       prop->val.ptr = (char *) i + 2;",
          "3758:       new_pos += 2 + prop->val.len;",
          "3759:       break;",
          "3760:     case MQTT_PROP_TYPE_BINARY_DATA:",
          "3761:       prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);",
          "3762:       prop->val.ptr = (char *) i + 2;",
          "3763:       new_pos += 2 + prop->val.len;",
          "3764:       break;",
          "3765:     case MQTT_PROP_TYPE_VARIABLE_INT:",
          "3766:       len = decode_varint(i, (size_t) (end - i), (size_t *) &prop->iv);",
          "3767:       new_pos = (!len) ? 0 : new_pos + len;",
          "3768:       break;",
          "3769:     default:",
          "3770:       new_pos = 0;",
          "3773:   return new_pos;",
          "3774: }",
          "3776: void mg_mqtt_login(struct mg_connection *c, const struct mg_mqtt_opts *opts) {",
          "3777:   char rnd[10], client_id[21];",
          "3778:   struct mg_str cid = opts->client_id;",
          "3779:   size_t total_len = 7 + 1 + 2 + 2;",
          "3780:   uint8_t hdr[8] = {0, 4, 'M', 'Q', 'T', 'T', opts->version, 0};",
          "3782:   if (cid.len == 0) {",
          "3783:     mg_random(rnd, sizeof(rnd));",
          "3784:     mg_hex(rnd, sizeof(rnd), client_id);",
          "3785:     client_id[sizeof(client_id) - 1] = '\\0';",
          "3786:     cid = mg_str(client_id);",
          "3789:   if (hdr[6] == 0) hdr[6] = 4;  // If version is not set, use 4 (3.1.1)",
          "3790:   c->is_mqtt5 = hdr[6] == 5;    // Set version 5 flag",
          "3791:   hdr[7] = (uint8_t) ((opts->qos & 3) << 3);  // Connection flags",
          "3792:   if (opts->user.len > 0) {",
          "3793:     total_len += 2 + (uint32_t) opts->user.len;",
          "3794:     hdr[7] |= MQTT_HAS_USER_NAME;",
          "3795:   }",
          "3796:   if (opts->pass.len > 0) {",
          "3797:     total_len += 2 + (uint32_t) opts->pass.len;",
          "3798:     hdr[7] |= MQTT_HAS_PASSWORD;",
          "3799:   }",
          "3800:   if (opts->topic.len > 0 && opts->message.len > 0) {",
          "3801:     total_len += 4 + (uint32_t) opts->topic.len + (uint32_t) opts->message.len;",
          "3802:     hdr[7] |= MQTT_HAS_WILL;",
          "3803:   }",
          "3804:   if (opts->clean || cid.len == 0) hdr[7] |= MQTT_CLEAN_SESSION;",
          "3805:   if (opts->retain) hdr[7] |= MQTT_WILL_RETAIN;",
          "3806:   total_len += (uint32_t) cid.len;",
          "3807:   if (c->is_mqtt5) {",
          "3808:     total_len += get_props_size(opts->props, opts->num_props);",
          "3809:     if (hdr[7] & MQTT_HAS_WILL)",
          "3810:       total_len += get_props_size(opts->will_props, opts->num_will_props);",
          "3813:   mg_mqtt_send_header(c, MQTT_CMD_CONNECT, 0, (uint32_t) total_len);",
          "3814:   mg_send(c, hdr, sizeof(hdr));",
          "3816:   mg_send_u16(c, mg_htons((uint16_t) opts->keepalive));",
          "3818:   if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);",
          "3820:   mg_send_u16(c, mg_htons((uint16_t) cid.len));",
          "3821:   mg_send(c, cid.ptr, cid.len);",
          "3823:   if (hdr[7] & MQTT_HAS_WILL) {",
          "3824:     if (c->is_mqtt5)",
          "3825:       mg_send_mqtt_properties(c, opts->will_props, opts->num_will_props);",
          "3827:     mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));",
          "3828:     mg_send(c, opts->topic.ptr, opts->topic.len);",
          "3829:     mg_send_u16(c, mg_htons((uint16_t) opts->message.len));",
          "3830:     mg_send(c, opts->message.ptr, opts->message.len);",
          "3831:   }",
          "3832:   if (opts->user.len > 0) {",
          "3833:     mg_send_u16(c, mg_htons((uint16_t) opts->user.len));",
          "3834:     mg_send(c, opts->user.ptr, opts->user.len);",
          "3835:   }",
          "3836:   if (opts->pass.len > 0) {",
          "3837:     mg_send_u16(c, mg_htons((uint16_t) opts->pass.len));",
          "3838:     mg_send(c, opts->pass.ptr, opts->pass.len);",
          "3842: void mg_mqtt_pub(struct mg_connection *c, const struct mg_mqtt_opts *opts) {",
          "3843:   uint8_t flags = (uint8_t) (((opts->qos & 3) << 1) | (opts->retain ? 1 : 0));",
          "3844:   size_t len = 2 + opts->topic.len + opts->message.len;",
          "3845:   MG_DEBUG((\"%lu [%.*s] -> [%.*s]\", c->id, (int) opts->topic.len,",
          "3846:             (char *) opts->topic.ptr, (int) opts->message.len,",
          "3847:             (char *) opts->message.ptr));",
          "3848:   if (opts->qos > 0) len += 2;",
          "3849:   if (c->is_mqtt5) len += get_props_size(opts->props, opts->num_props);",
          "3851:   mg_mqtt_send_header(c, MQTT_CMD_PUBLISH, flags, (uint32_t) len);",
          "3852:   mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));",
          "3853:   mg_send(c, opts->topic.ptr, opts->topic.len);",
          "3854:   if (opts->qos > 0) {",
          "3855:     if (++c->mgr->mqtt_id == 0) ++c->mgr->mqtt_id;",
          "3856:     mg_send_u16(c, mg_htons(c->mgr->mqtt_id));",
          "3857:   }",
          "3859:   if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);",
          "3861:   mg_send(c, opts->message.ptr, opts->message.len);",
          "3864: void mg_mqtt_sub(struct mg_connection *c, const struct mg_mqtt_opts *opts) {",
          "3865:   uint8_t qos_ = opts->qos & 3;",
          "3866:   size_t plen = c->is_mqtt5 ? get_props_size(opts->props, opts->num_props) : 0;",
          "3867:   size_t len = 2 + opts->topic.len + 2 + 1 + plen;",
          "3869:   mg_mqtt_send_header(c, MQTT_CMD_SUBSCRIBE, 2, (uint32_t) len);",
          "3870:   if (++c->mgr->mqtt_id == 0) ++c->mgr->mqtt_id;",
          "3871:   mg_send_u16(c, mg_htons(c->mgr->mqtt_id));",
          "3872:   if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);",
          "3874:   mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));",
          "3875:   mg_send(c, opts->topic.ptr, opts->topic.len);",
          "3876:   mg_send(c, &qos_, sizeof(qos_));",
          "3877: }",
          "3879: int mg_mqtt_parse(const uint8_t *buf, size_t len, uint8_t version,",
          "3880:                   struct mg_mqtt_message *m) {",
          "3881:   uint8_t lc = 0, *p, *end;",
          "3882:   uint32_t n = 0, len_len = 0;",
          "3884:   memset(m, 0, sizeof(*m));",
          "3885:   m->dgram.ptr = (char *) buf;",
          "3886:   if (len < 2) return MQTT_INCOMPLETE;",
          "3887:   m->cmd = (uint8_t) (buf[0] >> 4);",
          "3888:   m->qos = (buf[0] >> 1) & 3;",
          "3890:   n = len_len = 0;",
          "3891:   p = (uint8_t *) buf + 1;",
          "3892:   while ((size_t) (p - buf) < len) {",
          "3893:     lc = *((uint8_t *) p++);",
          "3894:     n += (uint32_t) ((lc & 0x7f) << 7 * len_len);",
          "3895:     len_len++;",
          "3896:     if (!(lc & 0x80)) break;",
          "3897:     if (len_len >= 4) return MQTT_MALFORMED;",
          "3898:   }",
          "3899:   end = p + n;",
          "3900:   if ((lc & 0x80) || (end > buf + len)) return MQTT_INCOMPLETE;",
          "3901:   m->dgram.len = (size_t) (end - buf);",
          "3903:   switch (m->cmd) {",
          "3904:     case MQTT_CMD_CONNACK:",
          "3905:       if (end - p < 2) return MQTT_MALFORMED;",
          "3906:       m->ack = p[1];",
          "3907:       break;",
          "3908:     case MQTT_CMD_PUBACK:",
          "3909:     case MQTT_CMD_PUBREC:",
          "3910:     case MQTT_CMD_PUBREL:",
          "3911:     case MQTT_CMD_PUBCOMP:",
          "3912:     case MQTT_CMD_SUBSCRIBE:",
          "3913:     case MQTT_CMD_SUBACK:",
          "3914:     case MQTT_CMD_UNSUBSCRIBE:",
          "3915:     case MQTT_CMD_UNSUBACK:",
          "3916:       if (p + 2 > end) return MQTT_MALFORMED;",
          "3917:       m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);",
          "3918:       p += 2;",
          "3919:       break;",
          "3920:     case MQTT_CMD_PUBLISH: {",
          "3921:       if (p + 2 > end) return MQTT_MALFORMED;",
          "3922:       m->topic.len = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);",
          "3923:       m->topic.ptr = (char *) p + 2;",
          "3924:       p += 2 + m->topic.len;",
          "3925:       if (p > end) return MQTT_MALFORMED;",
          "3926:       if (m->qos > 0) {",
          "3927:         if (p + 2 > end) return MQTT_MALFORMED;",
          "3928:         m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);",
          "3929:         p += 2;",
          "3931:       if (p > end) return MQTT_MALFORMED;",
          "3932:       if (version == 5 && p + 2 < end) {",
          "3933:         len_len = (uint32_t) decode_varint(p, (size_t) (end - p), &m->props_size);",
          "3934:         if (!len_len) return MQTT_MALFORMED;",
          "3935:         m->props_start = (size_t) (p + len_len - buf);",
          "3936:         p += len_len + m->props_size;",
          "3937:       }",
          "3938:       if (p > end) return MQTT_MALFORMED;",
          "3939:       m->data.ptr = (char *) p;",
          "3940:       m->data.len = (size_t) (end - p);",
          "3941:       break;",
          "3943:     default:",
          "3944:       break;",
          "3945:   }",
          "3946:   return MQTT_OK;",
          "3947: }",
          "3949: static void mqtt_cb(struct mg_connection *c, int ev, void *ev_data,",
          "3950:                     void *fn_data) {",
          "3951:   if (ev == MG_EV_READ) {",
          "3952:     for (;;) {",
          "3953:       uint8_t version = c->is_mqtt5 ? 5 : 4;",
          "3954:       struct mg_mqtt_message mm;",
          "3955:       int rc = mg_mqtt_parse(c->recv.buf, c->recv.len, version, &mm);",
          "3956:       if (rc == MQTT_MALFORMED) {",
          "3957:         MG_ERROR((\"%lu MQTT malformed message\", c->id));",
          "3958:         c->is_closing = 1;",
          "3959:         break;",
          "3960:       } else if (rc == MQTT_OK) {",
          "3961:         MG_VERBOSE((\"%lu MQTT CMD %d len %d [%.*s]\", c->id, mm.cmd,",
          "3962:                     (int) mm.dgram.len, (int) mm.data.len, mm.data.ptr));",
          "3963:         switch (mm.cmd) {",
          "3964:           case MQTT_CMD_CONNACK:",
          "3965:             mg_call(c, MG_EV_MQTT_OPEN, &mm.ack);",
          "3966:             if (mm.ack == 0) {",
          "3967:               MG_DEBUG((\"%lu Connected\", c->id));",
          "3968:             } else {",
          "3969:               MG_ERROR((\"%lu MQTT auth failed, code %d\", c->id, mm.ack));",
          "3970:               c->is_closing = 1;",
          "3971:             }",
          "3972:             break;",
          "3973:           case MQTT_CMD_PUBLISH: {",
          "3974:             MG_DEBUG((\"%lu [%.*s] -> [%.*s]\", c->id, (int) mm.topic.len,",
          "3975:                       mm.topic.ptr, (int) mm.data.len, mm.data.ptr));",
          "3976:             if (mm.qos > 0) {",
          "3977:               uint16_t id = mg_ntohs(mm.id);",
          "3978:               uint32_t remaining_len = sizeof(id);",
          "3979:               if (c->is_mqtt5) remaining_len += 2;  // 3.4.2",
          "3981:               mg_mqtt_send_header(",
          "3982:                   c,",
          "3983:                   (uint8_t) (mm.qos == 2 ? MQTT_CMD_PUBREC : MQTT_CMD_PUBACK),",
          "3984:                   0, remaining_len);",
          "3985:               mg_send(c, &id, sizeof(id));",
          "3987:               if (c->is_mqtt5) {",
          "3988:                 uint16_t zero = 0;",
          "3989:                 mg_send(c, &zero, sizeof(zero));",
          "3990:               }",
          "3991:             }",
          "3992:             mg_call(c, MG_EV_MQTT_MSG, &mm);  // let the app handle qos stuff",
          "3993:             break;",
          "3994:           }",
          "3995:           case MQTT_CMD_PUBREC: {  // MQTT5: 3.5.2-1 TODO(): variable header rc",
          "3996:             uint16_t id = mg_ntohs(mm.id);",
          "3997:             uint32_t remaining_len = sizeof(id);  // MQTT5 3.6.2-1",
          "3998:             mg_mqtt_send_header(c, MQTT_CMD_PUBREL, 2, remaining_len);",
          "3999:             mg_send(c, &id, sizeof(id));  // MQTT5 3.6.1-1, flags = 2",
          "4000:             break;",
          "4001:           }",
          "4002:           case MQTT_CMD_PUBREL: {  // MQTT5: 3.6.2-1 TODO(): variable header rc",
          "4003:             uint16_t id = mg_ntohs(mm.id);",
          "4004:             uint32_t remaining_len = sizeof(id);  // MQTT5 3.7.2-1",
          "4005:             mg_mqtt_send_header(c, MQTT_CMD_PUBCOMP, 0, remaining_len);",
          "4006:             mg_send(c, &id, sizeof(id));",
          "4007:             break;",
          "4008:           }",
          "4010:         mg_call(c, MG_EV_MQTT_CMD, &mm);",
          "4011:         mg_iobuf_del(&c->recv, 0, mm.dgram.len);",
          "4012:       } else {",
          "4013:         break;",
          "4017:   (void) ev_data;",
          "4018:   (void) fn_data;",
          "4019: }",
          "4021: void mg_mqtt_ping(struct mg_connection *nc) {",
          "4022:   mg_mqtt_send_header(nc, MQTT_CMD_PINGREQ, 0, 0);",
          "4023: }",
          "4025: void mg_mqtt_pong(struct mg_connection *nc) {",
          "4026:   mg_mqtt_send_header(nc, MQTT_CMD_PINGRESP, 0, 0);",
          "4027: }",
          "4029: void mg_mqtt_disconnect(struct mg_connection *c,",
          "4030:                         const struct mg_mqtt_opts *opts) {",
          "4031:   size_t len = 0;",
          "4032:   if (c->is_mqtt5) len = 1 + get_props_size(opts->props, opts->num_props);",
          "4033:   mg_mqtt_send_header(c, MQTT_CMD_DISCONNECT, 0, (uint32_t) len);",
          "4035:   if (c->is_mqtt5) {",
          "4036:     uint8_t zero = 0;",
          "4037:     mg_send(c, &zero, sizeof(zero));  // reason code",
          "4038:     mg_send_mqtt_properties(c, opts->props, opts->num_props);",
          "4039:   }",
          "4040: }",
          "4042: struct mg_connection *mg_mqtt_connect(struct mg_mgr *mgr, const char *url,",
          "4043:                                       const struct mg_mqtt_opts *opts,",
          "4044:                                       mg_event_handler_t fn, void *fn_data) {",
          "4045:   struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);",
          "4046:   if (c != NULL) {",
          "4047:     struct mg_mqtt_opts empty;",
          "4048:     memset(&empty, 0, sizeof(empty));",
          "4049:     mg_mqtt_login(c, opts == NULL ? &empty : opts);",
          "4050:     c->pfn = mqtt_cb;",
          "4051:   }",
          "4052:   return c;",
          "4055: struct mg_connection *mg_mqtt_listen(struct mg_mgr *mgr, const char *url,",
          "4056:                                      mg_event_handler_t fn, void *fn_data) {",
          "4057:   struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);",
          "4058:   if (c != NULL) c->pfn = mqtt_cb, c->pfn_data = mgr;",
          "4059:   return c;",
          "4060: }",
          "4062: #ifdef MG_ENABLE_LINES",
          "4063: #line 1 \"src/net.c\"",
          "4064: #endif",
          "4073: size_t mg_vprintf(struct mg_connection *c, const char *fmt, va_list *ap) {",
          "4074:   size_t old = c->send.len;",
          "4075:   mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);",
          "4076:   return c->send.len - old;",
          "4077: }",
          "4079: size_t mg_printf(struct mg_connection *c, const char *fmt, ...) {",
          "4080:   size_t len = 0;",
          "4081:   va_list ap;",
          "4082:   va_start(ap, fmt);",
          "4083:   len = mg_vprintf(c, fmt, &ap);",
          "4084:   va_end(ap);",
          "4085:   return len;",
          "4086: }",
          "4088: static bool mg_atonl(struct mg_str str, struct mg_addr *addr) {",
          "4089:   uint32_t localhost = mg_htonl(0x7f000001);",
          "4090:   if (mg_vcasecmp(&str, \"localhost\") != 0) return false;",
          "4091:   memcpy(addr->ip, &localhost, sizeof(uint32_t));",
          "4092:   addr->is_ip6 = false;",
          "4093:   return true;",
          "4094: }",
          "4096: static bool mg_atone(struct mg_str str, struct mg_addr *addr) {",
          "4097:   if (str.len > 0) return false;",
          "4098:   memset(addr->ip, 0, sizeof(addr->ip));",
          "4099:   addr->is_ip6 = false;",
          "4100:   return true;",
          "4101: }",
          "4103: static bool mg_aton4(struct mg_str str, struct mg_addr *addr) {",
          "4104:   uint8_t data[4] = {0, 0, 0, 0};",
          "4105:   size_t i, num_dots = 0;",
          "4106:   for (i = 0; i < str.len; i++) {",
          "4107:     if (str.ptr[i] >= '0' && str.ptr[i] <= '9') {",
          "4108:       int octet = data[num_dots] * 10 + (str.ptr[i] - '0');",
          "4109:       if (octet > 255) return false;",
          "4110:       data[num_dots] = (uint8_t) octet;",
          "4111:     } else if (str.ptr[i] == '.') {",
          "4112:       if (num_dots >= 3 || i == 0 || str.ptr[i - 1] == '.') return false;",
          "4113:       num_dots++;",
          "4114:     } else {",
          "4115:       return false;",
          "4116:     }",
          "4117:   }",
          "4118:   if (num_dots != 3 || str.ptr[i - 1] == '.') return false;",
          "4119:   memcpy(&addr->ip, data, sizeof(data));",
          "4120:   addr->is_ip6 = false;",
          "4121:   return true;",
          "4122: }",
          "4124: static bool mg_v4mapped(struct mg_str str, struct mg_addr *addr) {",
          "4125:   int i;",
          "4126:   uint32_t ipv4;",
          "4127:   if (str.len < 14) return false;",
          "4128:   if (str.ptr[0] != ':' || str.ptr[1] != ':' || str.ptr[6] != ':') return false;",
          "4129:   for (i = 2; i < 6; i++) {",
          "4130:     if (str.ptr[i] != 'f' && str.ptr[i] != 'F') return false;",
          "4131:   }",
          "4133:   if (!mg_aton4(mg_str_n(&str.ptr[7], str.len - 7), addr)) return false;",
          "4134:   memcpy(&ipv4, addr->ip, sizeof(ipv4));",
          "4135:   memset(addr->ip, 0, sizeof(addr->ip));",
          "4136:   addr->ip[10] = addr->ip[11] = 255;",
          "4137:   memcpy(&addr->ip[12], &ipv4, 4);",
          "4138:   addr->is_ip6 = true;",
          "4139:   return true;",
          "4140: }",
          "4142: static bool mg_aton6(struct mg_str str, struct mg_addr *addr) {",
          "4143:   size_t i, j = 0, n = 0, dc = 42;",
          "4144:   if (str.len > 2 && str.ptr[0] == '[') str.ptr++, str.len -= 2;",
          "4145:   if (mg_v4mapped(str, addr)) return true;",
          "4146:   for (i = 0; i < str.len; i++) {",
          "4147:     if ((str.ptr[i] >= '0' && str.ptr[i] <= '9') ||",
          "4148:         (str.ptr[i] >= 'a' && str.ptr[i] <= 'f') ||",
          "4149:         (str.ptr[i] >= 'A' && str.ptr[i] <= 'F')) {",
          "4150:       unsigned long val;",
          "4151:       if (i > j + 3) return false;",
          "4153:       val = mg_unhexn(&str.ptr[j], i - j + 1);",
          "4154:       addr->ip[n] = (uint8_t) ((val >> 8) & 255);",
          "4155:       addr->ip[n + 1] = (uint8_t) (val & 255);",
          "4156:     } else if (str.ptr[i] == ':') {",
          "4157:       j = i + 1;",
          "4158:       if (i > 0 && str.ptr[i - 1] == ':') {",
          "4159:         dc = n;  // Double colon",
          "4160:         if (i > 1 && str.ptr[i - 2] == ':') return false;",
          "4161:       } else if (i > 0) {",
          "4162:         n += 2;",
          "4163:       }",
          "4164:       if (n > 14) return false;",
          "4165:       addr->ip[n] = addr->ip[n + 1] = 0;  // For trailing ::",
          "4166:     } else {",
          "4167:       return false;",
          "4168:     }",
          "4169:   }",
          "4170:   if (n < 14 && dc == 42) return false;",
          "4171:   if (n < 14) {",
          "4172:     memmove(&addr->ip[dc + (14 - n)], &addr->ip[dc], n - dc + 2);",
          "4173:     memset(&addr->ip[dc], 0, 14 - n);",
          "4174:   }",
          "4176:   addr->is_ip6 = true;",
          "4177:   return true;",
          "4178: }",
          "4180: bool mg_aton(struct mg_str str, struct mg_addr *addr) {",
          "4182:   return mg_atone(str, addr) || mg_atonl(str, addr) || mg_aton4(str, addr) ||",
          "4183:          mg_aton6(str, addr);",
          "4184: }",
          "4186: struct mg_connection *mg_alloc_conn(struct mg_mgr *mgr) {",
          "4187:   struct mg_connection *c =",
          "4188:       (struct mg_connection *) calloc(1, sizeof(*c) + mgr->extraconnsize);",
          "4189:   if (c != NULL) {",
          "4190:     c->mgr = mgr;",
          "4191:     c->send.align = c->recv.align = MG_IO_SIZE;",
          "4192:     c->id = ++mgr->nextid;",
          "4193:   }",
          "4194:   return c;",
          "4195: }",
          "4197: void mg_close_conn(struct mg_connection *c) {",
          "4198:   mg_resolve_cancel(c);  // Close any pending DNS query",
          "4199:   LIST_DELETE(struct mg_connection, &c->mgr->conns, c);",
          "4200:   if (c == c->mgr->dns4.c) c->mgr->dns4.c = NULL;",
          "4201:   if (c == c->mgr->dns6.c) c->mgr->dns6.c = NULL;",
          "4204:   mg_call(c, MG_EV_CLOSE, NULL);",
          "4205:   MG_DEBUG((\"%lu %ld closed\", c->id, c->fd));",
          "4207:   mg_tls_free(c);",
          "4208:   mg_iobuf_free(&c->recv);",
          "4209:   mg_iobuf_free(&c->send);",
          "4210:   mg_bzero((unsigned char *) c, sizeof(*c));",
          "4211:   free(c);",
          "4212: }",
          "4214: struct mg_connection *mg_connect(struct mg_mgr *mgr, const char *url,",
          "4215:                                  mg_event_handler_t fn, void *fn_data) {",
          "4216:   struct mg_connection *c = NULL;",
          "4217:   if (url == NULL || url[0] == '\\0') {",
          "4218:     MG_ERROR((\"null url\"));",
          "4219:   } else if ((c = mg_alloc_conn(mgr)) == NULL) {",
          "4220:     MG_ERROR((\"OOM\"));",
          "4221:   } else {",
          "4222:     LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);",
          "4223:     c->is_udp = (strncmp(url, \"udp:\", 4) == 0);",
          "4224:     c->fd = (void *) (size_t) MG_INVALID_SOCKET;",
          "4225:     c->fn = fn;",
          "4226:     c->is_client = true;",
          "4227:     c->fn_data = fn_data;",
          "4228:     MG_DEBUG((\"%lu %ld %s\", c->id, c->fd, url));",
          "4229:     mg_call(c, MG_EV_OPEN, (void *) url);",
          "4230:     mg_resolve(c, url);",
          "4231:   }",
          "4232:   return c;",
          "4233: }",
          "4235: struct mg_connection *mg_listen(struct mg_mgr *mgr, const char *url,",
          "4236:                                 mg_event_handler_t fn, void *fn_data) {",
          "4237:   struct mg_connection *c = NULL;",
          "4238:   if ((c = mg_alloc_conn(mgr)) == NULL) {",
          "4239:     MG_ERROR((\"OOM %s\", url));",
          "4240:   } else if (!mg_open_listener(c, url)) {",
          "4241:     MG_ERROR((\"Failed: %s, errno %d\", url, errno));",
          "4242:     free(c);",
          "4243:     c = NULL;",
          "4244:   } else {",
          "4245:     c->is_listening = 1;",
          "4246:     c->is_udp = strncmp(url, \"udp:\", 4) == 0;",
          "4247:     LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);",
          "4248:     c->fn = fn;",
          "4249:     c->fn_data = fn_data;",
          "4250:     mg_call(c, MG_EV_OPEN, NULL);",
          "4251:     if (mg_url_is_ssl(url)) c->is_tls = 1;  // Accepted connection must",
          "4252:     MG_DEBUG((\"%lu %ld %s\", c->id, c->fd, url));",
          "4253:   }",
          "4254:   return c;",
          "4255: }",
          "4257: struct mg_connection *mg_wrapfd(struct mg_mgr *mgr, int fd,",
          "4258:                                 mg_event_handler_t fn, void *fn_data) {",
          "4259:   struct mg_connection *c = mg_alloc_conn(mgr);",
          "4260:   if (c != NULL) {",
          "4261:     c->fd = (void *) (size_t) fd;",
          "4262:     c->fn = fn;",
          "4263:     c->fn_data = fn_data;",
          "4264:     MG_EPOLL_ADD(c);",
          "4265:     mg_call(c, MG_EV_OPEN, NULL);",
          "4266:     LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);",
          "4267:   }",
          "4268:   return c;",
          "4269: }",
          "4271: struct mg_timer *mg_timer_add(struct mg_mgr *mgr, uint64_t milliseconds,",
          "4272:                               unsigned flags, void (*fn)(void *), void *arg) {",
          "4273:   struct mg_timer *t = (struct mg_timer *) calloc(1, sizeof(*t));",
          "4274:   if (t != NULL) {",
          "4275:     mg_timer_init(&mgr->timers, t, milliseconds, flags, fn, arg);",
          "4276:     t->id = mgr->timerid++;",
          "4277:   }",
          "4278:   return t;",
          "4279: }",
          "4281: void mg_mgr_free(struct mg_mgr *mgr) {",
          "4282:   struct mg_connection *c;",
          "4283:   struct mg_timer *tmp, *t = mgr->timers;",
          "4284:   while (t != NULL) tmp = t->next, free(t), t = tmp;",
          "4285:   mgr->timers = NULL;  // Important. Next call to poll won't touch timers",
          "4286:   for (c = mgr->conns; c != NULL; c = c->next) c->is_closing = 1;",
          "4287:   mg_mgr_poll(mgr, 0);",
          "4288: #if MG_ENABLE_FREERTOS_TCP",
          "4289:   FreeRTOS_DeleteSocketSet(mgr->ss);",
          "4290: #endif",
          "4291:   MG_DEBUG((\"All connections closed\"));",
          "4292: #if MG_ENABLE_EPOLL",
          "4293:   if (mgr->epoll_fd >= 0) close(mgr->epoll_fd), mgr->epoll_fd = -1;",
          "4294: #endif",
          "4295:   mg_tls_ctx_free(mgr);",
          "4296: }",
          "4298: void mg_mgr_init(struct mg_mgr *mgr) {",
          "4299:   memset(mgr, 0, sizeof(*mgr));",
          "4300: #if MG_ENABLE_EPOLL",
          "4301:   if ((mgr->epoll_fd = epoll_create1(EPOLL_CLOEXEC)) < 0)",
          "4302:     MG_ERROR((\"epoll_create1 errno %d\", errno));",
          "4303: #else",
          "4304:   mgr->epoll_fd = -1;",
          "4305: #endif",
          "4306: #if MG_ARCH == MG_ARCH_WIN32 && MG_ENABLE_WINSOCK",
          "4308:   { WSADATA data; WSAStartup(MAKEWORD(2, 2), &data); }",
          "4310: #elif MG_ENABLE_FREERTOS_TCP",
          "4311:   mgr->ss = FreeRTOS_CreateSocketSet();",
          "4312: #elif defined(__unix) || defined(__unix__) || defined(__APPLE__)",
          "4315:   signal(SIGPIPE, SIG_IGN);",
          "4316: #endif",
          "4317:   mgr->dnstimeout = 3000;",
          "4318:   mgr->dns4.url = \"udp://8.8.8.8:53\";",
          "4319:   mgr->dns6.url = \"udp://[2001:4860:4860::8888]:53\";",
          "4320:   mg_tls_ctx_init(mgr);",
          "4321: }",
          "4323: #ifdef MG_ENABLE_LINES",
          "4324: #line 1 \"src/net_builtin.c\"",
          "4325: #endif",
          "4328: #if defined(MG_ENABLE_TCPIP) && MG_ENABLE_TCPIP",
          "4329: #define MG_EPHEMERAL_PORT_BASE 32768",
          "4330: #define PDIFF(a, b) ((size_t) (((char *) (b)) - ((char *) (a))))",
          "4332: #ifndef MIP_TCP_KEEPALIVE_MS",
          "4333: #define MIP_TCP_KEEPALIVE_MS 45000  // TCP keep-alive period, ms",
          "4334: #endif",
          "4336: #define MIP_TCP_ACK_MS 150    // Timeout for ACKing",
          "4337: #define MIP_TCP_ARP_MS 100    // Timeout for ARP response",
          "4338: #define MIP_TCP_SYN_MS 15000  // Timeout for connection establishment",
          "4339: #define MIP_TCP_FIN_MS 1000   // Timeout for closing connection",
          "4341: struct connstate {",
          "4342:   uint32_t seq, ack;           // TCP seq/ack counters",
          "4343:   uint64_t timer;              // TCP keep-alive / ACK timer",
          "4344:   uint8_t mac[6];              // Peer MAC address",
          "4345:   uint8_t ttype;               // Timer type. 0: ack, 1: keep-alive",
          "4346: #define MIP_TTYPE_KEEPALIVE 0  // Connection is idle for long, send keepalive",
          "4347: #define MIP_TTYPE_ACK 1        // Peer sent us data, we have to ack it soon",
          "4348: #define MIP_TTYPE_ARP 2        // ARP resolve sent, waiting for response",
          "4349: #define MIP_TTYPE_SYN 3        // SYN sent, waiting for response",
          "4350: #define MIP_TTYPE_FIN 4  // FIN sent, waiting until terminating the connection",
          "4351:   uint8_t tmiss;         // Number of keep-alive misses",
          "4352:   struct mg_iobuf raw;   // For TLS only. Incoming raw data",
          "4353: };",
          "4355: #pragma pack(push, 1)",
          "4357: struct lcp {",
          "4358:   uint8_t addr, ctrl, proto[2], code, id, len[2];",
          "4359: };",
          "4361: struct eth {",
          "4362:   uint8_t dst[6];  // Destination MAC address",
          "4363:   uint8_t src[6];  // Source MAC address",
          "4364:   uint16_t type;   // Ethernet type",
          "4365: };",
          "4367: struct ip {",
          "4368:   uint8_t ver;    // Version",
          "4369:   uint8_t tos;    // Unused",
          "4370:   uint16_t len;   // Length",
          "4371:   uint16_t id;    // Unused",
          "4372:   uint16_t frag;  // Fragmentation",
          "4373: #define IP_FRAG_OFFSET_MSK 0xFF1F",
          "4374: #define IP_MORE_FRAGS_MSK 0x20",
          "4375:   uint8_t ttl;    // Time to live",
          "4376:   uint8_t proto;  // Upper level protocol",
          "4377:   uint16_t csum;  // Checksum",
          "4378:   uint32_t src;   // Source IP",
          "4379:   uint32_t dst;   // Destination IP",
          "4380: };",
          "4382: struct ip6 {",
          "4383:   uint8_t ver;      // Version",
          "4384:   uint8_t opts[3];  // Options",
          "4385:   uint16_t len;     // Length",
          "4386:   uint8_t proto;    // Upper level protocol",
          "4387:   uint8_t ttl;      // Time to live",
          "4388:   uint8_t src[16];  // Source IP",
          "4389:   uint8_t dst[16];  // Destination IP",
          "4390: };",
          "4392: struct icmp {",
          "4393:   uint8_t type;",
          "4394:   uint8_t code;",
          "4395:   uint16_t csum;",
          "4396: };",
          "4398: struct arp {",
          "4399:   uint16_t fmt;    // Format of hardware address",
          "4400:   uint16_t pro;    // Format of protocol address",
          "4401:   uint8_t hlen;    // Length of hardware address",
          "4402:   uint8_t plen;    // Length of protocol address",
          "4403:   uint16_t op;     // Operation",
          "4404:   uint8_t sha[6];  // Sender hardware address",
          "4405:   uint32_t spa;    // Sender protocol address",
          "4406:   uint8_t tha[6];  // Target hardware address",
          "4407:   uint32_t tpa;    // Target protocol address",
          "4408: };",
          "4410: struct tcp {",
          "4411:   uint16_t sport;  // Source port",
          "4412:   uint16_t dport;  // Destination port",
          "4413:   uint32_t seq;    // Sequence number",
          "4414:   uint32_t ack;    // Acknowledgement number",
          "4415:   uint8_t off;     // Data offset",
          "4416:   uint8_t flags;   // TCP flags",
          "4417: #define TH_FIN 0x01",
          "4418: #define TH_SYN 0x02",
          "4419: #define TH_RST 0x04",
          "4420: #define TH_PUSH 0x08",
          "4421: #define TH_ACK 0x10",
          "4422: #define TH_URG 0x20",
          "4423: #define TH_ECE 0x40",
          "4424: #define TH_CWR 0x80",
          "4425:   uint16_t win;   // Window",
          "4426:   uint16_t csum;  // Checksum",
          "4427:   uint16_t urp;   // Urgent pointer",
          "4428: };",
          "4430: struct udp {",
          "4431:   uint16_t sport;  // Source port",
          "4432:   uint16_t dport;  // Destination port",
          "4433:   uint16_t len;    // UDP length",
          "4434:   uint16_t csum;   // UDP checksum",
          "4435: };",
          "4437: struct dhcp {",
          "4438:   uint8_t op, htype, hlen, hops;",
          "4439:   uint32_t xid;",
          "4440:   uint16_t secs, flags;",
          "4441:   uint32_t ciaddr, yiaddr, siaddr, giaddr;",
          "4442:   uint8_t hwaddr[208];",
          "4443:   uint32_t magic;",
          "4444:   uint8_t options[32];",
          "4445: };",
          "4447: #pragma pack(pop)",
          "4449: struct pkt {",
          "4450:   struct mg_str raw;  // Raw packet data",
          "4451:   struct mg_str pay;  // Payload data",
          "4452:   struct eth *eth;",
          "4453:   struct llc *llc;",
          "4454:   struct arp *arp;",
          "4455:   struct ip *ip;",
          "4456:   struct ip6 *ip6;",
          "4457:   struct icmp *icmp;",
          "4458:   struct tcp *tcp;",
          "4459:   struct udp *udp;",
          "4460:   struct dhcp *dhcp;",
          "4461: };",
          "4463: static void send_syn(struct mg_connection *c);",
          "4465: static void mkpay(struct pkt *pkt, void *p) {",
          "4466:   pkt->pay =",
          "4467:       mg_str_n((char *) p, (size_t) (&pkt->raw.ptr[pkt->raw.len] - (char *) p));",
          "4470: static uint32_t csumup(uint32_t sum, const void *buf, size_t len) {",
          "4471:   const uint8_t *p = (const uint8_t *) buf;",
          "4472:   for (size_t i = 0; i < len; i++) sum += i & 1 ? p[i] : (uint32_t) (p[i] << 8);",
          "4473:   return sum;",
          "4476: static uint16_t csumfin(uint32_t sum) {",
          "4477:   while (sum >> 16) sum = (sum & 0xffff) + (sum >> 16);",
          "4478:   return mg_htons(~sum & 0xffff);",
          "4481: static uint16_t ipcsum(const void *buf, size_t len) {",
          "4482:   uint32_t sum = csumup(0, buf, len);",
          "4483:   return csumfin(sum);",
          "4484: }",
          "4486: static void settmout(struct mg_connection *c, uint8_t type) {",
          "4487:   struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;",
          "4488:   struct connstate *s = (struct connstate *) (c + 1);",
          "4489:   unsigned n = type == MIP_TTYPE_ACK   ? MIP_TCP_ACK_MS",
          "4490:                : type == MIP_TTYPE_ARP ? MIP_TCP_ARP_MS",
          "4491:                : type == MIP_TTYPE_SYN ? MIP_TCP_SYN_MS",
          "4492:                : type == MIP_TTYPE_FIN ? MIP_TCP_FIN_MS",
          "4493:                                        : MIP_TCP_KEEPALIVE_MS;",
          "4494:   s->timer = ifp->now + n;",
          "4495:   s->ttype = type;",
          "4496:   MG_VERBOSE((\"%lu %d -> %llx\", c->id, type, s->timer));",
          "4497: }",
          "4499: static size_t ether_output(struct mg_tcpip_if *ifp, size_t len) {",
          "4503:   size_t n = ifp->driver->tx(ifp->tx.ptr, len, ifp);",
          "4504:   if (n == len) ifp->nsent++;",
          "4505:   return n;",
          "4506: }",
          "4508: static void arp_ask(struct mg_tcpip_if *ifp, uint32_t ip) {",
          "4509:   struct eth *eth = (struct eth *) ifp->tx.ptr;",
          "4510:   struct arp *arp = (struct arp *) (eth + 1);",
          "4511:   memset(eth->dst, 255, sizeof(eth->dst));",
          "4512:   memcpy(eth->src, ifp->mac, sizeof(eth->src));",
          "4513:   eth->type = mg_htons(0x806);",
          "4514:   memset(arp, 0, sizeof(*arp));",
          "4515:   arp->fmt = mg_htons(1), arp->pro = mg_htons(0x800), arp->hlen = 6,",
          "4516:   arp->plen = 4;",
          "4517:   arp->op = mg_htons(1), arp->tpa = ip, arp->spa = ifp->ip;",
          "4518:   memcpy(arp->sha, ifp->mac, sizeof(arp->sha));",
          "4519:   ether_output(ifp, PDIFF(eth, arp + 1));",
          "4522: static void onstatechange(struct mg_tcpip_if *ifp) {",
          "4523:   if (ifp->state == MG_TCPIP_STATE_READY) {",
          "4524:     MG_INFO((\"READY, IP: %M\", mg_print_ip4, &ifp->ip));",
          "4525:     MG_INFO((\"       GW: %M\", mg_print_ip4, &ifp->gw));",
          "4526:     MG_INFO((\"      MAC: %M\", mg_print_mac, &ifp->mac));",
          "4527:     arp_ask(ifp, ifp->gw);",
          "4528:   } else if (ifp->state == MG_TCPIP_STATE_UP) {",
          "4529:     MG_ERROR((\"Link up\"));",
          "4530:     srand((unsigned int) mg_millis());",
          "4531:   } else if (ifp->state == MG_TCPIP_STATE_DOWN) {",
          "4532:     MG_ERROR((\"Link down\"));",
          "4536: static struct ip *tx_ip(struct mg_tcpip_if *ifp, uint8_t *mac_dst,",
          "4537:                         uint8_t proto, uint32_t ip_src, uint32_t ip_dst,",
          "4538:                         size_t plen) {",
          "4539:   struct eth *eth = (struct eth *) ifp->tx.ptr;",
          "4540:   struct ip *ip = (struct ip *) (eth + 1);",
          "4541:   memcpy(eth->dst, mac_dst, sizeof(eth->dst));",
          "4542:   memcpy(eth->src, ifp->mac, sizeof(eth->src));  // Use our MAC",
          "4543:   eth->type = mg_htons(0x800);",
          "4544:   memset(ip, 0, sizeof(*ip));",
          "4545:   ip->ver = 0x45;   // Version 4, header length 5 words",
          "4546:   ip->frag = 0x40;  // Don't fragment",
          "4547:   ip->len = mg_htons((uint16_t) (sizeof(*ip) + plen));",
          "4548:   ip->ttl = 64;",
          "4549:   ip->proto = proto;",
          "4550:   ip->src = ip_src;",
          "4551:   ip->dst = ip_dst;",
          "4552:   ip->csum = ipcsum(ip, sizeof(*ip));",
          "4553:   return ip;",
          "4554: }",
          "4556: static void tx_udp(struct mg_tcpip_if *ifp, uint8_t *mac_dst, uint32_t ip_src,",
          "4557:                    uint16_t sport, uint32_t ip_dst, uint16_t dport,",
          "4558:                    const void *buf, size_t len) {",
          "4559:   struct ip *ip =",
          "4560:       tx_ip(ifp, mac_dst, 17, ip_src, ip_dst, len + sizeof(struct udp));",
          "4561:   struct udp *udp = (struct udp *) (ip + 1);",
          "4563:   udp->sport = sport;",
          "4564:   udp->dport = dport;",
          "4565:   udp->len = mg_htons((uint16_t) (sizeof(*udp) + len));",
          "4566:   udp->csum = 0;",
          "4567:   uint32_t cs = csumup(0, udp, sizeof(*udp));",
          "4568:   cs = csumup(cs, buf, len);",
          "4569:   cs = csumup(cs, &ip->src, sizeof(ip->src));",
          "4570:   cs = csumup(cs, &ip->dst, sizeof(ip->dst));",
          "4571:   cs += (uint32_t) (ip->proto + sizeof(*udp) + len);",
          "4572:   udp->csum = csumfin(cs);",
          "4573:   memmove(udp + 1, buf, len);",
          "4575:   ether_output(ifp, sizeof(struct eth) + sizeof(*ip) + sizeof(*udp) + len);",
          "4578: static void tx_dhcp(struct mg_tcpip_if *ifp, uint8_t *mac_dst, uint32_t ip_src,",
          "4579:                     uint32_t ip_dst, uint8_t *opts, size_t optslen,",
          "4580:                     bool ciaddr) {",
          "4582:   struct dhcp dhcp = {1, 1, 6, 0, 0, 0, 0, 0, 0, 0, 0, {0}, 0, {0}};",
          "4583:   dhcp.magic = mg_htonl(0x63825363);",
          "4584:   memcpy(&dhcp.hwaddr, ifp->mac, sizeof(ifp->mac));",
          "4585:   memcpy(&dhcp.xid, ifp->mac + 2, sizeof(dhcp.xid));",
          "4586:   memcpy(&dhcp.options, opts, optslen);",
          "4587:   if (ciaddr) dhcp.ciaddr = ip_src;",
          "4588:   tx_udp(ifp, mac_dst, ip_src, mg_htons(68), ip_dst, mg_htons(67), &dhcp,",
          "4589:          sizeof(dhcp));",
          "4592: static const uint8_t broadcast[] = {255, 255, 255, 255, 255, 255};",
          "4595: static void tx_dhcp_request_sel(struct mg_tcpip_if *ifp, uint32_t ip_req,",
          "4596:                                 uint32_t ip_srv) {",
          "4597:   uint8_t opts[] = {",
          "4598:       53, 1, 3,                 // Type: DHCP request",
          "4599:       55, 2, 1,   3,            // GW and mask",
          "4600:       12, 3, 'm', 'i', 'p',     // Host name: \"mip\"",
          "4601:       54, 4, 0,   0,   0,   0,  // DHCP server ID",
          "4602:       50, 4, 0,   0,   0,   0,  // Requested IP",
          "4603:       255                       // End of options",
          "4604:   };",
          "4605:   memcpy(opts + 14, &ip_srv, sizeof(ip_srv));",
          "4606:   memcpy(opts + 20, &ip_req, sizeof(ip_req));",
          "4607:   tx_dhcp(ifp, (uint8_t *) broadcast, 0, 0xffffffff, opts, sizeof(opts), false);",
          "4608:   MG_DEBUG((\"DHCP req sent\"));",
          "4612: static void tx_dhcp_request_re(struct mg_tcpip_if *ifp, uint8_t *mac_dst,",
          "4613:                                uint32_t ip_src, uint32_t ip_dst) {",
          "4614:   uint8_t opts[] = {",
          "4615:       53, 1, 3,  // Type: DHCP request",
          "4616:       255        // End of options",
          "4617:   };",
          "4618:   tx_dhcp(ifp, mac_dst, ip_src, ip_dst, opts, sizeof(opts), true);",
          "4619:   MG_DEBUG((\"DHCP req sent\"));",
          "4622: static void tx_dhcp_discover(struct mg_tcpip_if *ifp) {",
          "4623:   uint8_t opts[] = {",
          "4624:       53, 1, 1,     // Type: DHCP discover",
          "4625:       55, 2, 1, 3,  // Parameters: ip, mask",
          "4626:       255           // End of options",
          "4627:   };",
          "4628:   tx_dhcp(ifp, (uint8_t *) broadcast, 0, 0xffffffff, opts, sizeof(opts), false);",
          "4629:   MG_DEBUG((\"DHCP discover sent. Our MAC: %M\", mg_print_mac, ifp->mac));",
          "4632: static struct mg_connection *getpeer(struct mg_mgr *mgr, struct pkt *pkt,",
          "4633:                                      bool lsn) {",
          "4634:   struct mg_connection *c = NULL;",
          "4635:   for (c = mgr->conns; c != NULL; c = c->next) {",
          "4636:     if (c->is_arplooking && pkt->arp &&",
          "4637:         memcmp(&pkt->arp->spa, c->rem.ip, sizeof(pkt->arp->spa)) == 0)",
          "4638:       break;",
          "4639:     if (c->is_udp && pkt->udp && c->loc.port == pkt->udp->dport) break;",
          "4640:     if (!c->is_udp && pkt->tcp && c->loc.port == pkt->tcp->dport &&",
          "4641:         lsn == c->is_listening && (lsn || c->rem.port == pkt->tcp->sport))",
          "4642:       break;",
          "4643:   }",
          "4644:   return c;",
          "4647: static void rx_arp(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "4648:   if (pkt->arp->op == mg_htons(1) && pkt->arp->tpa == ifp->ip) {",
          "4652:     struct eth *eth = (struct eth *) ifp->tx.ptr;",
          "4653:     struct arp *arp = (struct arp *) (eth + 1);",
          "4654:     memcpy(eth->dst, pkt->eth->src, sizeof(eth->dst));",
          "4655:     memcpy(eth->src, ifp->mac, sizeof(eth->src));",
          "4656:     eth->type = mg_htons(0x806);",
          "4658:     arp->op = mg_htons(2);",
          "4659:     memcpy(arp->tha, pkt->arp->sha, sizeof(pkt->arp->tha));",
          "4660:     memcpy(arp->sha, ifp->mac, sizeof(pkt->arp->sha));",
          "4661:     arp->tpa = pkt->arp->spa;",
          "4662:     arp->spa = ifp->ip;",
          "4663:     MG_DEBUG((\"ARP: tell %M we're %M\", mg_print_ip4, &arp->tpa, mg_print_mac,",
          "4664:               &ifp->mac));",
          "4665:     ether_output(ifp, PDIFF(eth, arp + 1));",
          "4666:   } else if (pkt->arp->op == mg_htons(2)) {",
          "4667:     if (memcmp(pkt->arp->tha, ifp->mac, sizeof(pkt->arp->tha)) != 0) return;",
          "4668:     if (pkt->arp->spa == ifp->gw) {",
          "4670:       memcpy(ifp->gwmac, pkt->arp->sha, sizeof(ifp->gwmac));",
          "4671:     } else {",
          "4672:       struct mg_connection *c = getpeer(ifp->mgr, pkt, false);",
          "4673:       if (c != NULL && c->is_arplooking) {",
          "4674:         struct connstate *s = (struct connstate *) (c + 1);",
          "4675:         memcpy(s->mac, pkt->arp->sha, sizeof(s->mac));",
          "4676:         MG_DEBUG((\"%lu ARP resolved %M -> %M\", c->id, mg_print_ip4, c->rem.ip,",
          "4677:                   mg_print_mac, s->mac));",
          "4678:         c->is_arplooking = 0;",
          "4679:         send_syn(c);",
          "4680:         settmout(c, MIP_TTYPE_SYN);",
          "4681:       }",
          "4682:     }",
          "4686: static void rx_icmp(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "4688:   if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip) {",
          "4689:     size_t hlen = sizeof(struct eth) + sizeof(struct ip) + sizeof(struct icmp);",
          "4690:     size_t space = ifp->tx.len - hlen, plen = pkt->pay.len;",
          "4691:     if (plen > space) plen = space;",
          "4692:     struct ip *ip = tx_ip(ifp, pkt->eth->src, 1, ifp->ip, pkt->ip->src,",
          "4693:                           sizeof(struct icmp) + plen);",
          "4694:     struct icmp *icmp = (struct icmp *) (ip + 1);",
          "4695:     memset(icmp, 0, sizeof(*icmp));        // Set csum to 0",
          "4696:     memcpy(icmp + 1, pkt->pay.ptr, plen);  // Copy RX payload to TX",
          "4697:     icmp->csum = ipcsum(icmp, sizeof(*icmp) + plen);",
          "4698:     ether_output(ifp, hlen + plen);",
          "4702: static void rx_dhcp_client(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "4703:   uint32_t ip = 0, gw = 0, mask = 0, lease = 0;",
          "4704:   uint8_t msgtype = 0, state = ifp->state;",
          "4706:   uint8_t *p = pkt->dhcp->options,",
          "4708:   if (end < (uint8_t *) (pkt->dhcp + 1)) return;",
          "4709:   if (memcmp(&pkt->dhcp->xid, ifp->mac + 2, sizeof(pkt->dhcp->xid))) return;",
          "4710:   while (p + 1 < end && p[0] != 255) {  // Parse options RFC-1533 #9",
          "4711:     if (p[0] == 1 && p[1] == sizeof(ifp->mask) && p + 6 < end) {  // Mask",
          "4712:       memcpy(&mask, p + 2, sizeof(mask));",
          "4713:     } else if (p[0] == 3 && p[1] == sizeof(ifp->gw) && p + 6 < end) {  // GW",
          "4714:       memcpy(&gw, p + 2, sizeof(gw));",
          "4715:       ip = pkt->dhcp->yiaddr;",
          "4716:     } else if (p[0] == 51 && p[1] == 4 && p + 6 < end) {  // Lease",
          "4717:       memcpy(&lease, p + 2, sizeof(lease));",
          "4718:       lease = mg_ntohl(lease);",
          "4719:     } else if (p[0] == 53 && p[1] == 1 && p + 6 < end) {  // Msg Type",
          "4720:       msgtype = p[2];",
          "4721:     }",
          "4722:     p += p[1] + 2;",
          "4723:   }",
          "4725:   if (msgtype == 6 && ifp->ip == ip) {  // DHCPNACK, release IP",
          "4726:     ifp->state = MG_TCPIP_STATE_UP, ifp->ip = 0;",
          "4727:   } else if (msgtype == 2 && ifp->state == MG_TCPIP_STATE_UP && ip && gw &&",
          "4728:              lease) {                                 // DHCPOFFER",
          "4729:     tx_dhcp_request_sel(ifp, ip, pkt->dhcp->siaddr);  // select IP, (4.4.1)",
          "4730:     ifp->state = MG_TCPIP_STATE_REQ;                  // REQUESTING state",
          "4731:   } else if (msgtype == 5) {                          // DHCPACK",
          "4732:     if (ifp->state == MG_TCPIP_STATE_REQ && ip && gw && lease) {  // got an IP",
          "4733:       ifp->lease_expire = ifp->now + lease * 1000;",
          "4734:       MG_INFO((\"Lease: %u sec (%lld)\", lease, ifp->lease_expire / 1000));",
          "4736:       memcpy(ifp->gwmac, pkt->eth->src, sizeof(ifp->gwmac));",
          "4737:       ifp->ip = ip, ifp->gw = gw, ifp->mask = mask;",
          "4738:       ifp->state = MG_TCPIP_STATE_READY;  // BOUND state",
          "4739:       uint64_t rand;",
          "4740:       mg_random(&rand, sizeof(rand));",
          "4741:       srand((unsigned int) (rand + mg_millis()));",
          "4742:     } else if (ifp->state == MG_TCPIP_STATE_READY && ifp->ip == ip) {  // renew",
          "4743:       ifp->lease_expire = ifp->now + lease * 1000;",
          "4744:       MG_INFO((\"Lease: %u sec (%lld)\", lease, ifp->lease_expire / 1000));",
          "4745:     }  // TODO(): accept provided T1/T2 and store server IP for renewal (4.4)",
          "4746:   }",
          "4747:   if (ifp->state != state) onstatechange(ifp);",
          "4751: static void rx_dhcp_server(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "4752:   uint8_t op = 0, *p = pkt->dhcp->options,",
          "4754:   if (end < (uint8_t *) (pkt->dhcp + 1)) return;",
          "4756:   struct dhcp res = {2, 1, 6, 0, 0, 0, 0, 0, 0, 0, 0, {0}, 0, {0}};",
          "4757:   res.yiaddr = ifp->ip;",
          "4758:   ((uint8_t *) (&res.yiaddr))[3]++;                // Offer our IP + 1",
          "4759:   while (p + 1 < end && p[0] != 255) {             // Parse options",
          "4760:     if (p[0] == 53 && p[1] == 1 && p + 2 < end) {  // Message type",
          "4761:       op = p[2];",
          "4762:     }",
          "4763:     p += p[1] + 2;",
          "4764:   }",
          "4765:   if (op == 1 || op == 3) {         // DHCP Discover or DHCP Request",
          "4766:     uint8_t msg = op == 1 ? 2 : 5;  // Message type: DHCP OFFER or DHCP ACK",
          "4767:     uint8_t opts[] = {",
          "4768:         53, 1, msg,                 // Message type",
          "4769:         1,  4, 0,   0,   0,   0,    // Subnet mask",
          "4770:         54, 4, 0,   0,   0,   0,    // Server ID",
          "4771:         12, 3, 'm', 'i', 'p',       // Host name: \"mip\"",
          "4772:         51, 4, 255, 255, 255, 255,  // Lease time",
          "4773:         255                         // End of options",
          "4774:     };",
          "4775:     memcpy(&res.hwaddr, pkt->dhcp->hwaddr, 6);",
          "4776:     memcpy(opts + 5, &ifp->mask, sizeof(ifp->mask));",
          "4777:     memcpy(opts + 11, &ifp->ip, sizeof(ifp->ip));",
          "4778:     memcpy(&res.options, opts, sizeof(opts));",
          "4779:     res.magic = pkt->dhcp->magic;",
          "4780:     res.xid = pkt->dhcp->xid;",
          "4782:     tx_udp(ifp, pkt->eth->src, ifp->ip, mg_htons(67),",
          "4783:            op == 1 ? ~0U : res.yiaddr, mg_htons(68), &res, sizeof(res));",
          "4787: static void rx_udp(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "4788:   struct mg_connection *c = getpeer(ifp->mgr, pkt, true);",
          "4789:   if (c == NULL) {",
          "4792:     c->rem.port = pkt->udp->sport;",
          "4793:     memcpy(c->rem.ip, &pkt->ip->src, sizeof(uint32_t));",
          "4794:     struct connstate *s = (struct connstate *) (c + 1);",
          "4795:     memcpy(s->mac, pkt->eth->src, sizeof(s->mac));",
          "4796:     if (c->recv.len >= MG_MAX_RECV_SIZE) {",
          "4797:       mg_error(c, \"max_recv_buf_size reached\");",
          "4798:     } else if (c->recv.size - c->recv.len < pkt->pay.len &&",
          "4799:                !mg_iobuf_resize(&c->recv, c->recv.len + pkt->pay.len)) {",
          "4800:       mg_error(c, \"oom\");",
          "4801:     } else {",
          "4802:       memcpy(&c->recv.buf[c->recv.len], pkt->pay.ptr, pkt->pay.len);",
          "4803:       c->recv.len += pkt->pay.len;",
          "4804:       mg_call(c, MG_EV_READ, &pkt->pay.len);",
          "4805:     }",
          "4809: static size_t tx_tcp(struct mg_tcpip_if *ifp, uint8_t *dst_mac, uint32_t dst_ip,",
          "4810:                      uint8_t flags, uint16_t sport, uint16_t dport,",
          "4811:                      uint32_t seq, uint32_t ack, const void *buf, size_t len) {",
          "4812:   struct ip *ip =",
          "4813:       tx_ip(ifp, dst_mac, 6, ifp->ip, dst_ip, sizeof(struct tcp) + len);",
          "4814:   struct tcp *tcp = (struct tcp *) (ip + 1);",
          "4815:   memset(tcp, 0, sizeof(*tcp));",
          "4816:   if (buf != NULL && len) memmove(tcp + 1, buf, len);",
          "4817:   tcp->sport = sport;",
          "4818:   tcp->dport = dport;",
          "4819:   tcp->seq = seq;",
          "4820:   tcp->ack = ack;",
          "4821:   tcp->flags = flags;",
          "4822:   tcp->win = mg_htons(8192);",
          "4823:   tcp->off = (uint8_t) (sizeof(*tcp) / 4 << 4);",
          "4824:   uint32_t cs = 0;",
          "4825:   uint16_t n = (uint16_t) (sizeof(*tcp) + len);",
          "4826:   uint8_t pseudo[] = {0, ip->proto, (uint8_t) (n >> 8), (uint8_t) (n & 255)};",
          "4827:   cs = csumup(cs, tcp, n);",
          "4828:   cs = csumup(cs, &ip->src, sizeof(ip->src));",
          "4829:   cs = csumup(cs, &ip->dst, sizeof(ip->dst));",
          "4830:   cs = csumup(cs, pseudo, sizeof(pseudo));",
          "4831:   tcp->csum = csumfin(cs);",
          "4832:   MG_VERBOSE((\"TCP %M:%hu -> %M:%hu fl %x len %u\", mg_print_ip4, &ip->src,",
          "4833:               mg_ntohs(tcp->sport), mg_print_ip4, &ip->dst,",
          "4834:               mg_ntohs(tcp->dport), tcp->flags, (int) len));",
          "4836:   return ether_output(ifp, PDIFF(ifp->tx.ptr, tcp + 1) + len);",
          "4837: }",
          "4839: static size_t tx_tcp_pkt(struct mg_tcpip_if *ifp, struct pkt *pkt,",
          "4840:                          uint8_t flags, uint32_t seq, const void *buf,",
          "4841:                          size_t len) {",
          "4842:   uint32_t delta = (pkt->tcp->flags & (TH_SYN | TH_FIN)) ? 1 : 0;",
          "4843:   return tx_tcp(ifp, pkt->eth->src, pkt->ip->src, flags, pkt->tcp->dport,",
          "4844:                 pkt->tcp->sport, seq, mg_htonl(mg_ntohl(pkt->tcp->seq) + delta),",
          "4845:                 buf, len);",
          "4846: }",
          "4848: static struct mg_connection *accept_conn(struct mg_connection *lsn,",
          "4849:                                          struct pkt *pkt) {",
          "4850:   struct mg_connection *c = mg_alloc_conn(lsn->mgr);",
          "4851:   if (c == NULL) {",
          "4852:     MG_ERROR((\"OOM\"));",
          "4853:     return NULL;",
          "4854:   }",
          "4855:   struct connstate *s = (struct connstate *) (c + 1);",
          "4856:   s->seq = mg_ntohl(pkt->tcp->ack), s->ack = mg_ntohl(pkt->tcp->seq);",
          "4857:   memcpy(s->mac, pkt->eth->src, sizeof(s->mac));",
          "4858:   settmout(c, MIP_TTYPE_KEEPALIVE);",
          "4859:   memcpy(c->rem.ip, &pkt->ip->src, sizeof(uint32_t));",
          "4860:   c->rem.port = pkt->tcp->sport;",
          "4861:   MG_DEBUG((\"%lu accepted %M\", c->id, mg_print_ip_port, &c->rem));",
          "4862:   LIST_ADD_HEAD(struct mg_connection, &lsn->mgr->conns, c);",
          "4863:   c->is_accepted = 1;",
          "4864:   c->is_hexdumping = lsn->is_hexdumping;",
          "4865:   c->pfn = lsn->pfn;",
          "4866:   c->loc = lsn->loc;",
          "4867:   c->pfn_data = lsn->pfn_data;",
          "4868:   c->fn = lsn->fn;",
          "4869:   c->fn_data = lsn->fn_data;",
          "4870:   mg_call(c, MG_EV_OPEN, NULL);",
          "4871:   mg_call(c, MG_EV_ACCEPT, NULL);",
          "4872:   return c;",
          "4873: }",
          "4875: static size_t trim_len(struct mg_connection *c, size_t len) {",
          "4876:   struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;",
          "4877:   size_t eth_h_len = 14, ip_max_h_len = 24, tcp_max_h_len = 60, udp_h_len = 8;",
          "4878:   size_t max_headers_len = eth_h_len + ip_max_h_len +",
          "4879:                           (c->is_udp ? udp_h_len : tcp_max_h_len);",
          "4880:   size_t min_mtu = c->is_udp ? 68 /* RFC-791 */ : max_headers_len - eth_h_len;",
          "4883:   if (len + max_headers_len > ifp->tx.len) {",
          "4884:     len = ifp->tx.len - max_headers_len;",
          "4885:   }",
          "4887:   if (ifp->mtu < min_mtu) {",
          "4888:     MG_ERROR((\"MTU is lower than minimum possible value. Setting it to %d.\",",
          "4889:               min_mtu));",
          "4890:     ifp->mtu = (uint16_t) min_mtu;",
          "4891:   }",
          "4893:   if (len + max_headers_len - eth_h_len > ifp->mtu) {",
          "4894:     len = ifp->mtu - max_headers_len + eth_h_len;",
          "4895:     if (c->is_udp) {",
          "4896:       MG_ERROR((\"UDP datagram exceeds MTU. Truncating it.\"));",
          "4900:   return len;",
          "4903: long mg_io_send(struct mg_connection *c, const void *buf, size_t len) {",
          "4904:   struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;",
          "4905:   struct connstate *s = (struct connstate *) (c + 1);",
          "4906:   uint32_t rem_ip;",
          "4907:   memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "4908:   len = trim_len(c, len);",
          "4909:   if (c->is_udp) {",
          "4910:     tx_udp(ifp, s->mac, ifp->ip, c->loc.port, rem_ip, c->rem.port, buf, len);",
          "4912:     if (tx_tcp(ifp, s->mac, rem_ip, TH_PUSH | TH_ACK, c->loc.port, c->rem.port,",
          "4913:                mg_htonl(s->seq), mg_htonl(s->ack), buf, len) > 0) {",
          "4914:       s->seq += (uint32_t) len;",
          "4915:       if (s->ttype == MIP_TTYPE_ACK) settmout(c, MIP_TTYPE_KEEPALIVE);",
          "4916:     } else {",
          "4917:       return MG_IO_ERR;",
          "4920:   return (long) len;",
          "4923: long mg_io_recv(struct mg_connection *c, void *buf, size_t len) {",
          "4924:   struct connstate *s = (struct connstate *) (c + 1);",
          "4925:   if (s->raw.len == 0) return MG_IO_WAIT;",
          "4926:   if (len > s->raw.len) len = s->raw.len;",
          "4927:   memcpy(buf, s->raw.buf, len);",
          "4928:   mg_iobuf_del(&s->raw, 0, len);",
          "4929:   return (long) len;",
          "4932: static void read_conn(struct mg_connection *c, struct pkt *pkt) {",
          "4933:   struct connstate *s = (struct connstate *) (c + 1);",
          "4934:   struct mg_iobuf *io = c->is_tls ? &s->raw : &c->recv;",
          "4935:   uint32_t seq = mg_ntohl(pkt->tcp->seq);",
          "4936:   s->raw.align = c->recv.align;",
          "4937:   uint32_t rem_ip;",
          "4938:   memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "4939:   if (pkt->tcp->flags & TH_FIN) {",
          "4943:     uint8_t flags = TH_ACK;",
          "4944:     s->ack = (uint32_t) (mg_htonl(pkt->tcp->seq) + pkt->pay.len + 1);",
          "4945:     if (c->is_draining && s->ttype == MIP_TTYPE_FIN) {",
          "4946:       if (s->seq == mg_htonl(pkt->tcp->ack)) {  // Simultaneous closure ?",
          "4947:         s->seq++;                               // Yes. Increment our SEQ",
          "4948:       } else {                                  // Otherwise,",
          "4949:         s->seq = mg_htonl(pkt->tcp->ack);       // Set to peer's ACK",
          "4950:       }",
          "4951:     } else {",
          "4952:       flags |= TH_FIN;",
          "4953:       c->is_draining = 1;",
          "4954:       settmout(c, MIP_TTYPE_FIN);",
          "4955:     }",
          "4956:     tx_tcp((struct mg_tcpip_if *) c->mgr->priv, s->mac, rem_ip, flags,",
          "4957:            c->loc.port, c->rem.port, mg_htonl(s->seq), mg_htonl(s->ack), \"\", 0);",
          "4958:   } else if (pkt->pay.len == 0) {",
          "4960:   } else if (seq != s->ack) {",
          "4961:     uint32_t ack = (uint32_t) (mg_htonl(pkt->tcp->seq) + pkt->pay.len);",
          "4962:     if (s->ack == ack) {",
          "4963:       MG_VERBOSE((\"ignoring duplicate pkt\"));",
          "4964:     } else {",
          "4965:       MG_VERBOSE((\"SEQ != ACK: %x %x %x\", seq, s->ack, ack));",
          "4966:       tx_tcp((struct mg_tcpip_if *) c->mgr->priv, s->mac, rem_ip, TH_ACK,",
          "4967:              c->loc.port, c->rem.port, mg_htonl(s->seq), mg_htonl(s->ack), \"\",",
          "4968:              0);",
          "4969:     }",
          "4970:   } else if (io->size - io->len < pkt->pay.len &&",
          "4971:              !mg_iobuf_resize(io, io->len + pkt->pay.len)) {",
          "4972:     mg_error(c, \"oom\");",
          "4973:   } else {",
          "4979:     memcpy(&io->buf[io->len], pkt->pay.ptr, pkt->pay.len);",
          "4980:     io->len += pkt->pay.len;",
          "4982:     MG_VERBOSE((\"%lu SEQ %x -> %x\", c->id, mg_htonl(pkt->tcp->seq), s->ack));",
          "4984:     s->ack = (uint32_t) (mg_htonl(pkt->tcp->seq) + pkt->pay.len);",
          "4985: #if 0",
          "4987:     uint32_t rem_ip;",
          "4988:     memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "4989:     MG_DEBUG((\"  imm ACK\", c->id, mg_htonl(pkt->tcp->seq), s->ack));",
          "4990:     tx_tcp((struct mg_tcpip_if *) c->mgr->priv, s->mac, rem_ip, TH_ACK, c->loc.port,",
          "4991:            c->rem.port, mg_htonl(s->seq), mg_htonl(s->ack), \"\", 0);",
          "4992: #else",
          "4994:     if (s->ttype != MIP_TTYPE_ACK) settmout(c, MIP_TTYPE_ACK);",
          "4995: #endif",
          "4997:     if (c->is_tls) {",
          "4999:       io = &c->recv;",
          "5000:       if (io->size - io->len < pkt->pay.len &&",
          "5001:           !mg_iobuf_resize(io, io->len + pkt->pay.len)) {",
          "5002:         mg_error(c, \"oom\");",
          "5003:       } else {",
          "5005:         long n = mg_tls_recv(c, &io->buf[io->len], io->size - io->len);",
          "5006:         if (n == MG_IO_ERR) {",
          "5007:           mg_error(c, \"TLS recv error\");",
          "5008:         } else if (n > 0) {",
          "5010:           io->len += (size_t) n;",
          "5011:           mg_call(c, MG_EV_READ, &n);",
          "5012:         }",
          "5013:       }",
          "5014:     } else {",
          "5017:       mg_call(c, MG_EV_READ, &pkt->pay.len);",
          "5018:     }",
          "5019:   }",
          "5022: static void rx_tcp(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "5023:   struct mg_connection *c = getpeer(ifp->mgr, pkt, false);",
          "5024:   struct connstate *s = c == NULL ? NULL : (struct connstate *) (c + 1);",
          "5025: #if 0",
          "5026:   MG_INFO((\"%lu %hhu %d\", c ? c->id : 0, pkt->tcp->flags, (int) pkt->pay.len));",
          "5028:   if (c != NULL && c->is_connecting && pkt->tcp->flags == (TH_SYN | TH_ACK)) {",
          "5029:     s->seq = mg_ntohl(pkt->tcp->ack), s->ack = mg_ntohl(pkt->tcp->seq) + 1;",
          "5030:     tx_tcp_pkt(ifp, pkt, TH_ACK, pkt->tcp->ack, NULL, 0);",
          "5031:     c->is_connecting = 0;  // Client connected",
          "5032:     settmout(c, MIP_TTYPE_KEEPALIVE);",
          "5033:     mg_call(c, MG_EV_CONNECT, NULL);  // Let user know",
          "5034:   } else if (c != NULL && c->is_connecting && pkt->tcp->flags != TH_ACK) {",
          "5036:     tx_tcp_pkt(ifp, pkt, TH_RST | TH_ACK, pkt->tcp->ack, NULL, 0);",
          "5037:   } else if (c != NULL && pkt->tcp->flags & TH_RST) {",
          "5038:     mg_error(c, \"peer RST\");  // RFC-1122 4.2.2.13",
          "5039:   } else if (c != NULL) {",
          "5040: #if 0",
          "5041:     MG_DEBUG((\"%lu %d %M:%hu -> %M:%hu\", c->id, (int) pkt->raw.len,",
          "5042:               mg_print_ip4, &pkt->ip->src, mg_ntohs(pkt->tcp->sport),",
          "5043:               mg_print_ip4, &pkt->ip->dst, mg_ntohs(pkt->tcp->dport)));",
          "5044:     mg_hexdump(pkt->pay.ptr, pkt->pay.len);",
          "5046:     s->tmiss = 0;                         // Reset missed keep-alive counter",
          "5047:     if (s->ttype == MIP_TTYPE_KEEPALIVE)  // Advance keep-alive timer",
          "5048:       settmout(c,",
          "5049:                MIP_TTYPE_KEEPALIVE);  // unless a former ACK timeout is pending",
          "5050:     read_conn(c, pkt);  // Override timer with ACK timeout if needed",
          "5051:   } else if ((c = getpeer(ifp->mgr, pkt, true)) == NULL) {",
          "5052:     tx_tcp_pkt(ifp, pkt, TH_RST | TH_ACK, pkt->tcp->ack, NULL, 0);",
          "5053:   } else if (pkt->tcp->flags & TH_RST) {",
          "5054:     if (c->is_accepted) mg_error(c, \"peer RST\");  // RFC-1122 4.2.2.13",
          "5056:   } else if (pkt->tcp->flags & TH_SYN) {",
          "5058:     uint32_t isn = mg_htonl((uint32_t) mg_ntohs(pkt->tcp->sport));",
          "5059:     tx_tcp_pkt(ifp, pkt, TH_SYN | TH_ACK, isn, NULL, 0);",
          "5060:   } else if (pkt->tcp->flags & TH_FIN) {",
          "5061:     tx_tcp_pkt(ifp, pkt, TH_FIN | TH_ACK, pkt->tcp->ack, NULL, 0);",
          "5062:   } else if (mg_htonl(pkt->tcp->ack) == mg_htons(pkt->tcp->sport) + 1U) {",
          "5063:     accept_conn(c, pkt);",
          "5064:   } else if (!c->is_accepted) {  // no peer",
          "5065:     tx_tcp_pkt(ifp, pkt, TH_RST | TH_ACK, pkt->tcp->ack, NULL, 0);",
          "5071: static void rx_ip(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "5072:   if (pkt->ip->frag & IP_MORE_FRAGS_MSK ||",
          "5073:         pkt->ip->frag & IP_FRAG_OFFSET_MSK) {",
          "5074:     if (pkt->ip->proto == 17) pkt->udp = (struct udp *) (pkt->ip + 1);",
          "5075:     if (pkt->ip->proto == 6) pkt->tcp = (struct tcp *) (pkt->ip + 1);",
          "5076:     struct mg_connection *c = getpeer(ifp->mgr, pkt, false);",
          "5077:     if (c)  mg_error(c, \"Received fragmented packet\");",
          "5078:   } else if (pkt->ip->proto == 1) {",
          "5079:     pkt->icmp = (struct icmp *) (pkt->ip + 1);",
          "5080:     if (pkt->pay.len < sizeof(*pkt->icmp)) return;",
          "5081:     mkpay(pkt, pkt->icmp + 1);",
          "5082:     rx_icmp(ifp, pkt);",
          "5083:   } else if (pkt->ip->proto == 17) {",
          "5084:     pkt->udp = (struct udp *) (pkt->ip + 1);",
          "5085:     if (pkt->pay.len < sizeof(*pkt->udp)) return;",
          "5086:     mkpay(pkt, pkt->udp + 1);",
          "5087:     MG_VERBOSE((\"UDP %M:%hu -> %M:%hu len %u\", mg_print_ip4, &pkt->ip->src,",
          "5088:                 mg_ntohs(pkt->udp->sport), mg_print_ip4, &pkt->ip->dst,",
          "5089:                 mg_ntohs(pkt->udp->dport), (int) pkt->pay.len));",
          "5090:     if (ifp->enable_dhcp_client && pkt->udp->dport == mg_htons(68)) {",
          "5091:       pkt->dhcp = (struct dhcp *) (pkt->udp + 1);",
          "5092:       mkpay(pkt, pkt->dhcp + 1);",
          "5093:       rx_dhcp_client(ifp, pkt);",
          "5094:     } else if (ifp->enable_dhcp_server && pkt->udp->dport == mg_htons(67)) {",
          "5095:       pkt->dhcp = (struct dhcp *) (pkt->udp + 1);",
          "5096:       mkpay(pkt, pkt->dhcp + 1);",
          "5097:       rx_dhcp_server(ifp, pkt);",
          "5098:     } else {",
          "5099:       rx_udp(ifp, pkt);",
          "5100:     }",
          "5101:   } else if (pkt->ip->proto == 6) {",
          "5102:     pkt->tcp = (struct tcp *) (pkt->ip + 1);",
          "5103:     if (pkt->pay.len < sizeof(*pkt->tcp)) return;",
          "5104:     mkpay(pkt, pkt->tcp + 1);",
          "5105:     uint16_t iplen = mg_ntohs(pkt->ip->len);",
          "5106:     uint16_t off = (uint16_t) (sizeof(*pkt->ip) + ((pkt->tcp->off >> 4) * 4U));",
          "5107:     if (iplen >= off) pkt->pay.len = (size_t) (iplen - off);",
          "5108:     MG_VERBOSE((\"TCP %M:%hu -> %M:%hu len %u\", mg_print_ip4, &pkt->ip->src,",
          "5109:                 mg_ntohs(pkt->tcp->sport), mg_print_ip4, &pkt->ip->dst,",
          "5110:                 mg_ntohs(pkt->tcp->dport), (int) pkt->pay.len));",
          "5111:     rx_tcp(ifp, pkt);",
          "5115: static void rx_ip6(struct mg_tcpip_if *ifp, struct pkt *pkt) {",
          "5117:   if (pkt->ip6->proto == 1 || pkt->ip6->proto == 58) {",
          "5118:     pkt->icmp = (struct icmp *) (pkt->ip6 + 1);",
          "5119:     if (pkt->pay.len < sizeof(*pkt->icmp)) return;",
          "5120:     mkpay(pkt, pkt->icmp + 1);",
          "5121:     rx_icmp(ifp, pkt);",
          "5122:   } else if (pkt->ip6->proto == 17) {",
          "5123:     pkt->udp = (struct udp *) (pkt->ip6 + 1);",
          "5124:     if (pkt->pay.len < sizeof(*pkt->udp)) return;",
          "5127:     mkpay(pkt, pkt->udp + 1);",
          "5128:   }",
          "5131: static void mg_tcpip_rx(struct mg_tcpip_if *ifp, void *buf, size_t len) {",
          "5132:   struct pkt pkt;",
          "5133:   memset(&pkt, 0, sizeof(pkt));",
          "5134:   pkt.raw.ptr = (char *) buf;",
          "5135:   pkt.raw.len = len;",
          "5136:   pkt.eth = (struct eth *) buf;",
          "5138:   if (pkt.raw.len < sizeof(*pkt.eth)) return;  // Truncated - runt?",
          "5139:   if (ifp->enable_mac_check &&",
          "5140:       memcmp(pkt.eth->dst, ifp->mac, sizeof(pkt.eth->dst)) != 0 &&",
          "5141:       memcmp(pkt.eth->dst, broadcast, sizeof(pkt.eth->dst)) != 0)",
          "5142:     return;",
          "5143:   if (ifp->enable_crc32_check && len > 4) {",
          "5144:     len -= 4;  // TODO(scaprile): check on bigendian",
          "5145:     uint32_t crc = mg_crc32(0, (const char *) buf, len);",
          "5146:     if (memcmp((void *) ((size_t) buf + len), &crc, sizeof(crc))) return;",
          "5147:   }",
          "5148:   if (pkt.eth->type == mg_htons(0x806)) {",
          "5149:     pkt.arp = (struct arp *) (pkt.eth + 1);",
          "5150:     if (sizeof(*pkt.eth) + sizeof(*pkt.arp) > pkt.raw.len) return;  // Truncated",
          "5151:     rx_arp(ifp, &pkt);",
          "5152:   } else if (pkt.eth->type == mg_htons(0x86dd)) {",
          "5153:     pkt.ip6 = (struct ip6 *) (pkt.eth + 1);",
          "5154:     if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip6)) return;  // Truncated",
          "5155:     if ((pkt.ip6->ver >> 4) != 0x6) return;                         // Not IP",
          "5156:     mkpay(&pkt, pkt.ip6 + 1);",
          "5157:     rx_ip6(ifp, &pkt);",
          "5158:   } else if (pkt.eth->type == mg_htons(0x800)) {",
          "5159:     pkt.ip = (struct ip *) (pkt.eth + 1);",
          "5160:     if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip)) return;  // Truncated",
          "5162:     if ((size_t) mg_ntohs(pkt.ip->len) + sizeof(struct eth) < pkt.raw.len) {",
          "5163:       pkt.raw.len = (size_t) mg_ntohs(pkt.ip->len) + sizeof(struct eth);",
          "5164:     }",
          "5165:     if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip)) return;  // Truncated",
          "5166:     if ((pkt.ip->ver >> 4) != 4) return;                           // Not IP",
          "5167:     mkpay(&pkt, pkt.ip + 1);",
          "5168:     rx_ip(ifp, &pkt);",
          "5169:   } else {",
          "5170:     MG_DEBUG((\"Unknown eth type %x\", mg_htons(pkt.eth->type)));",
          "5171:     mg_hexdump(buf, len >= 32 ? 32 : len);",
          "5175: static void mg_tcpip_poll(struct mg_tcpip_if *ifp, uint64_t uptime_ms) {",
          "5176:   if (ifp == NULL || ifp->driver == NULL) return;",
          "5177:   bool expired_1000ms = mg_timer_expired(&ifp->timer_1000ms, 1000, uptime_ms);",
          "5178:   ifp->now = uptime_ms;",
          "5181:   if (expired_1000ms && ifp->driver->up) {",
          "5182:     bool up = ifp->driver->up(ifp);",
          "5183:     bool current = ifp->state != MG_TCPIP_STATE_DOWN;",
          "5184:     if (up != current) {",
          "5185:       ifp->state = up == false               ? MG_TCPIP_STATE_DOWN",
          "5186:                    : ifp->enable_dhcp_client ? MG_TCPIP_STATE_UP",
          "5187:                                              : MG_TCPIP_STATE_READY;",
          "5188:       if (!up && ifp->enable_dhcp_client) ifp->ip = 0;",
          "5189:       onstatechange(ifp);",
          "5192:   if (ifp->state == MG_TCPIP_STATE_DOWN) return;",
          "5195:   if (ifp->state == MG_TCPIP_STATE_UP && expired_1000ms) {",
          "5196:     tx_dhcp_discover(ifp);  // INIT (4.4.1)",
          "5197:   } else if (expired_1000ms && ifp->state == MG_TCPIP_STATE_READY &&",
          "5198:              ifp->lease_expire > 0) {  // BOUND / RENEWING / REBINDING",
          "5199:     if (ifp->now >= ifp->lease_expire) {",
          "5200:       ifp->state = MG_TCPIP_STATE_UP, ifp->ip = 0;  // expired, release IP",
          "5201:       onstatechange(ifp);",
          "5202:     } else if (ifp->now + 30UL * 60UL * 1000UL > ifp->lease_expire &&",
          "5203:                ((ifp->now / 1000) % 60) == 0) {",
          "5205:       tx_dhcp_request_re(ifp, (uint8_t *) broadcast, ifp->ip, 0xffffffff);",
          "5206:     }  // TODO(): Handle T1 (RENEWING) and T2 (REBINDING) (4.4.5)",
          "5210:   if (ifp->driver->rx != NULL) {  // Polling driver. We must call it",
          "5211:     size_t len =",
          "5212:         ifp->driver->rx(ifp->recv_queue.buf, ifp->recv_queue.size, ifp);",
          "5213:     if (len > 0) mg_tcpip_rx(ifp, ifp->recv_queue.buf, len);",
          "5214:   } else {  // Interrupt-based driver. Fills recv queue itself",
          "5215:     char *buf;",
          "5216:     size_t len = mg_queue_next(&ifp->recv_queue, &buf);",
          "5217:     if (len > 0) {",
          "5218:       mg_tcpip_rx(ifp, buf, len);",
          "5219:       mg_queue_del(&ifp->recv_queue, len);",
          "5220:     }",
          "5224:   for (struct mg_connection *c = ifp->mgr->conns; c != NULL; c = c->next) {",
          "5225:     if (c->is_udp || c->is_listening || c->is_resolving) continue;",
          "5226:     struct connstate *s = (struct connstate *) (c + 1);",
          "5227:     uint32_t rem_ip;",
          "5228:     memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "5229:     if (uptime_ms > s->timer) {",
          "5230:       if (s->ttype == MIP_TTYPE_ACK) {",
          "5231:         MG_VERBOSE((\"%lu ack %x %x\", c->id, s->seq, s->ack));",
          "5232:         tx_tcp(ifp, s->mac, rem_ip, TH_ACK, c->loc.port, c->rem.port,",
          "5233:                mg_htonl(s->seq), mg_htonl(s->ack), \"\", 0);",
          "5234:       } else if (s->ttype == MIP_TTYPE_ARP) {",
          "5235:         mg_error(c, \"ARP timeout\");",
          "5236:       } else if (s->ttype == MIP_TTYPE_SYN) {",
          "5237:         mg_error(c, \"Connection timeout\");",
          "5238:       } else if (s->ttype == MIP_TTYPE_FIN) {",
          "5239:         c->is_closing = 1;",
          "5240:         continue;",
          "5241:       } else {",
          "5242:         if (s->tmiss++ > 2) {",
          "5243:           mg_error(c, \"keepalive\");",
          "5244:         } else {",
          "5245:           MG_VERBOSE((\"%lu keepalive\", c->id));",
          "5246:           tx_tcp(ifp, s->mac, rem_ip, TH_ACK, c->loc.port, c->rem.port,",
          "5247:                  mg_htonl(s->seq - 1), mg_htonl(s->ack), \"\", 0);",
          "5248:         }",
          "5249:       }",
          "5251:       settmout(c, MIP_TTYPE_KEEPALIVE);",
          "5252:     }",
          "5253:   }",
          "5254: }",
          "5259: void mg_tcpip_qwrite(void *buf, size_t len, struct mg_tcpip_if *ifp) {",
          "5260:   char *p;",
          "5261:   if (mg_queue_book(&ifp->recv_queue, &p, len) >= len) {",
          "5262:     memcpy(p, buf, len);",
          "5263:     mg_queue_add(&ifp->recv_queue, len);",
          "5264:     ifp->nrecv++;",
          "5265:   } else {",
          "5266:     ifp->ndrop++;",
          "5267:   }",
          "5268: }",
          "5270: void mg_tcpip_init(struct mg_mgr *mgr, struct mg_tcpip_if *ifp) {",
          "5272:   if (ifp->mac[0] == 0 && ifp->mac[1] == 0 && ifp->mac[2] == 0 &&",
          "5273:       ifp->mac[3] == 0 && ifp->mac[4] == 0 && ifp->mac[5] == 0) {",
          "5274:     ifp->mac[0] = 0x02;  // Locally administered, unicast",
          "5275:     mg_random(&ifp->mac[1], sizeof(ifp->mac) - 1);",
          "5276:     MG_INFO((\"MAC not set. Generated random: %M\", mg_print_mac, ifp->mac));",
          "5277:   }",
          "5279:   if (ifp->driver->init && !ifp->driver->init(ifp)) {",
          "5280:     MG_ERROR((\"driver init failed\"));",
          "5281:   } else {",
          "5282:     size_t framesize = 1540;",
          "5283:     ifp->tx.ptr = (char *) calloc(1, framesize), ifp->tx.len = framesize;",
          "5284:     if (ifp->recv_queue.size == 0)",
          "5285:       ifp->recv_queue.size = ifp->driver->rx ? framesize : 8192;",
          "5286:     ifp->recv_queue.buf = (char *) calloc(1, ifp->recv_queue.size);",
          "5287:     ifp->timer_1000ms = mg_millis();",
          "5288:     mgr->priv = ifp;",
          "5289:     ifp->mgr = mgr;",
          "5290:     ifp->mtu = MG_TCPIP_MTU_DEFAULT;",
          "5291:     mgr->extraconnsize = sizeof(struct connstate);",
          "5292:     if (ifp->ip == 0) ifp->enable_dhcp_client = true;",
          "5293:     memset(ifp->gwmac, 255, sizeof(ifp->gwmac));  // Set to broadcast",
          "5294:     mg_random(&ifp->eport, sizeof(ifp->eport));   // Random from 0 to 65535",
          "5295:     ifp->eport |= MG_EPHEMERAL_PORT_BASE;         // Random from",
          "5297:     if (ifp->tx.ptr == NULL || ifp->recv_queue.buf == NULL) MG_ERROR((\"OOM\"));",
          "5298:   }",
          "5299: }",
          "5301: void mg_tcpip_free(struct mg_tcpip_if *ifp) {",
          "5302:   free(ifp->recv_queue.buf);",
          "5303:   free((char *) ifp->tx.ptr);",
          "5304: }",
          "5306: int mg_mkpipe(struct mg_mgr *m, mg_event_handler_t fn, void *d, bool udp) {",
          "5307:   (void) m, (void) fn, (void) d, (void) udp;",
          "5308:   MG_ERROR((\"Not implemented\"));",
          "5309:   return -1;",
          "5312: static void send_syn(struct mg_connection *c) {",
          "5313:   struct connstate *s = (struct connstate *) (c + 1);",
          "5314:   uint32_t isn = mg_htonl((uint32_t) mg_ntohs(c->loc.port));",
          "5315:   struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;",
          "5316:   uint32_t rem_ip;",
          "5317:   memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "5318:   tx_tcp(ifp, s->mac, rem_ip, TH_SYN, c->loc.port, c->rem.port, isn, 0, NULL,",
          "5319:          0);",
          "5322: void mg_connect_resolved(struct mg_connection *c) {",
          "5323:   struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;",
          "5324:   uint32_t rem_ip;",
          "5325:   memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "5326:   c->is_resolving = 0;",
          "5327:   if (ifp->eport < MG_EPHEMERAL_PORT_BASE) ifp->eport = MG_EPHEMERAL_PORT_BASE;",
          "5328:   memcpy(c->loc.ip, &ifp->ip, sizeof(uint32_t));",
          "5329:   c->loc.port = mg_htons(ifp->eport++);",
          "5330:   MG_DEBUG((\"%lu %M -> %M\", c->id, mg_print_ip_port, &c->loc, mg_print_ip_port,",
          "5331:             &c->rem));",
          "5332:   mg_call(c, MG_EV_RESOLVE, NULL);",
          "5333:   if (((rem_ip & ifp->mask) == (ifp->ip & ifp->mask))) {",
          "5335:     MG_DEBUG((\"%lu ARP lookup...\", c->id));",
          "5336:     arp_ask(ifp, rem_ip);",
          "5337:     settmout(c, MIP_TTYPE_ARP);",
          "5338:     c->is_arplooking = 1;",
          "5339:     c->is_connecting = 1;",
          "5340:   } else if (rem_ip == (ifp->ip | ~ifp->mask)) {",
          "5341:     struct connstate *s = (struct connstate *) (c + 1);",
          "5342:     memset(s->mac, 0xFF, sizeof(s->mac));  // local broadcast",
          "5343:   } else if ((*((uint8_t *) &rem_ip) & 0xE0) == 0xE0) {",
          "5344:     struct connstate *s = (struct connstate *) (c + 1);  // 224 to 239, E0 to EF",
          "5345:     uint8_t mcastp[3] = {0x01, 0x00, 0x5E};              // multicast group",
          "5346:     memcpy(s->mac, mcastp, 3);",
          "5347:     memcpy(s->mac + 3, ((uint8_t *) &rem_ip) + 1, 3);  // 23 LSb",
          "5348:     s->mac[3] &= 0x7F;",
          "5349:   } else {",
          "5350:     struct connstate *s = (struct connstate *) (c + 1);",
          "5351:     memcpy(s->mac, ifp->gwmac, sizeof(ifp->gwmac));",
          "5352:     if (c->is_udp) {",
          "5353:       mg_call(c, MG_EV_CONNECT, NULL);",
          "5354:     } else {",
          "5355:       send_syn(c);",
          "5356:       settmout(c, MIP_TTYPE_SYN);",
          "5357:       c->is_connecting = 1;",
          "5358:     }",
          "5359:   }",
          "5362: bool mg_open_listener(struct mg_connection *c, const char *url) {",
          "5363:   c->loc.port = mg_htons(mg_url_port(url));",
          "5364:   return true;",
          "5367: static void write_conn(struct mg_connection *c) {",
          "5368:   long len = c->is_tls ? mg_tls_send(c, c->send.buf, c->send.len)",
          "5369:                        : mg_io_send(c, c->send.buf, c->send.len);",
          "5370:   if (len > 0) {",
          "5371:     mg_iobuf_del(&c->send, 0, (size_t) len);",
          "5372:     mg_call(c, MG_EV_WRITE, &len);",
          "5376: static void init_closure(struct mg_connection *c) {",
          "5377:   struct connstate *s = (struct connstate *) (c + 1);",
          "5378:   if (c->is_udp == false && c->is_listening == false &&",
          "5379:       c->is_connecting == false) {  // For TCP conns,",
          "5380:     struct mg_tcpip_if *ifp =",
          "5381:         (struct mg_tcpip_if *) c->mgr->priv;  // send TCP FIN",
          "5382:     uint32_t rem_ip;",
          "5383:     memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "5384:     tx_tcp(ifp, s->mac, rem_ip, TH_FIN | TH_ACK, c->loc.port, c->rem.port,",
          "5385:            mg_htonl(s->seq), mg_htonl(s->ack), NULL, 0);",
          "5386:     settmout(c, MIP_TTYPE_FIN);",
          "5387:   }",
          "5390: static void close_conn(struct mg_connection *c) {",
          "5391:   struct connstate *s = (struct connstate *) (c + 1);",
          "5392:   mg_iobuf_free(&s->raw);  // For TLS connections, release raw data",
          "5393:   mg_close_conn(c);",
          "5396: static bool can_write(struct mg_connection *c) {",
          "5397:   return c->is_connecting == 0 && c->is_resolving == 0 && c->send.len > 0 &&",
          "5398:          c->is_tls_hs == 0 && c->is_arplooking == 0;",
          "5401: void mg_mgr_poll(struct mg_mgr *mgr, int ms) {",
          "5402:   struct mg_connection *c, *tmp;",
          "5403:   uint64_t now = mg_millis();",
          "5404:   mg_tcpip_poll((struct mg_tcpip_if *) mgr->priv, now);",
          "5405:   mg_timer_poll(&mgr->timers, now);",
          "5406:   for (c = mgr->conns; c != NULL; c = tmp) {",
          "5407:     tmp = c->next;",
          "5408:     struct connstate *s = (struct connstate *) (c + 1);",
          "5409:     mg_call(c, MG_EV_POLL, &now);",
          "5410:     MG_VERBOSE((\"%lu .. %c%c%c%c%c\", c->id, c->is_tls ? 'T' : 't',",
          "5411:                 c->is_connecting ? 'C' : 'c', c->is_tls_hs ? 'H' : 'h',",
          "5412:                 c->is_resolving ? 'R' : 'r', c->is_closing ? 'C' : 'c'));",
          "5413:     if (c->is_tls_hs) mg_tls_handshake(c);",
          "5414:     if (can_write(c)) write_conn(c);",
          "5415:     if (c->is_draining && c->send.len == 0 && s->ttype != MIP_TTYPE_FIN)",
          "5416:       init_closure(c);",
          "5417:     if (c->is_closing) close_conn(c);",
          "5419:   (void) ms;",
          "5422: bool mg_send(struct mg_connection *c, const void *buf, size_t len) {",
          "5423:   struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;",
          "5424:   bool res = false;",
          "5425:   uint32_t rem_ip;",
          "5426:   memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));",
          "5427:   if (ifp->ip == 0 || ifp->state != MG_TCPIP_STATE_READY) {",
          "5428:     mg_error(c, \"net down\");",
          "5429:   } else if (c->is_udp) {",
          "5430:     struct connstate *s = (struct connstate *) (c + 1);",
          "5431:     len = trim_len(c, len);   // Trimming length if necessary",
          "5432:     tx_udp(ifp, s->mac, ifp->ip, c->loc.port, rem_ip, c->rem.port, buf, len);",
          "5433:     res = true;",
          "5435:     res = mg_iobuf_add(&c->send, c->send.len, buf, len);",
          "5437:   return res;",
          "5439: #endif  // MG_ENABLE_TCPIP",
          "5441: #ifdef MG_ENABLE_LINES",
          "5442: #line 1 \"src/ota_dummy.c\"",
          "5443: #endif",
          "5447: #if MG_OTA == MG_OTA_NONE",
          "5448: bool mg_ota_begin(size_t new_firmware_size) {",
          "5449:   (void) new_firmware_size;",
          "5450:   return true;",
          "5452: bool mg_ota_write(const void *buf, size_t len) {",
          "5453:   (void) buf, (void) len;",
          "5454:   return true;",
          "5456: bool mg_ota_end(void) {",
          "5457:   return true;",
          "5459: bool mg_ota_commit(void) {",
          "5460:   return true;",
          "5461: }",
          "5462: bool mg_ota_rollback(void) {",
          "5463:   return true;",
          "5464: }",
          "5465: int mg_ota_status(int fw) {",
          "5466:   (void) fw;",
          "5467:   return 0;",
          "5468: }",
          "5469: uint32_t mg_ota_crc32(int fw) {",
          "5470:   (void) fw;",
          "5471:   return 0;",
          "5472: }",
          "5473: uint32_t mg_ota_timestamp(int fw) {",
          "5474:   (void) fw;",
          "5475:   return 0;",
          "5476: }",
          "5477: size_t mg_ota_size(int fw) {",
          "5478:   (void) fw;",
          "5479:   return 0;",
          "5481: #endif",
          "5484: #line 1 \"src/ota_flash.c\"",
          "5495: #if MG_OTA == MG_OTA_FLASH",
          "5497: #define MG_OTADATA_KEY 0xb07afed0",
          "5499: static char *s_addr;      // Current address to write to",
          "5500: static size_t s_size;     // Firmware size to flash. In-progress indicator",
          "5501: static uint32_t s_crc32;  // Firmware checksum",
          "5503: struct mg_otadata {",
          "5504:   uint32_t crc32, size, timestamp, status;",
          "5507: bool mg_ota_begin(size_t new_firmware_size) {",
          "5508:   bool ok = false;",
          "5509:   if (s_size) {",
          "5510:     MG_ERROR((\"OTA already in progress. Call mg_ota_end()\"));",
          "5511:   } else {",
          "5512:     size_t half = mg_flash_size() / 2, max = half - mg_flash_sector_size();",
          "5513:     s_crc32 = 0;",
          "5514:     s_addr = (char *) mg_flash_start() + half;",
          "5515:     MG_DEBUG((\"Firmware %lu bytes, max %lu\", s_size, max));",
          "5516:     if (new_firmware_size < max) {",
          "5517:       ok = true;",
          "5518:       s_size = new_firmware_size;",
          "5519:       MG_INFO((\"Starting OTA, firmware size %lu\", s_size));",
          "5520:     } else {",
          "5521:       MG_ERROR((\"Firmware %lu is too big to fit %lu\", new_firmware_size, max));",
          "5522:     }",
          "5523:   }",
          "5524:   return ok;",
          "5525: }",
          "5527: bool mg_ota_write(const void *buf, size_t len) {",
          "5528:   bool ok = false;",
          "5529:   if (s_size == 0) {",
          "5530:     MG_ERROR((\"OTA is not started, call mg_ota_begin()\"));",
          "5532:     size_t align = mg_flash_write_align();",
          "5533:     size_t len_aligned_down = MG_ROUND_DOWN(len, align);",
          "5534:     if (len_aligned_down) ok = mg_flash_write(s_addr, buf, len_aligned_down);",
          "5535:     if (len_aligned_down < len) {",
          "5536:       size_t left = len - len_aligned_down;",
          "5537:       char tmp[align];",
          "5538:       memset(tmp, 0xff, sizeof(tmp));",
          "5539:       memcpy(tmp, (char *) buf + len_aligned_down, left);",
          "5540:       ok = mg_flash_write(s_addr + len_aligned_down, tmp, sizeof(tmp));",
          "5541:     }",
          "5542:     s_crc32 = mg_crc32(s_crc32, (char *) buf, len);  // Update CRC",
          "5543:     MG_DEBUG((\"%#x %p %lu -> %d\", s_addr - len, buf, len, ok));",
          "5544:     s_addr += len;",
          "5546:   return ok;",
          "5549: bool mg_ota_end(void) {",
          "5550:   char *base = (char *) mg_flash_start() + mg_flash_size() / 2;",
          "5551:   bool ok = false;",
          "5552:   if (s_size) {",
          "5553:     size_t size = s_addr - base;",
          "5554:     uint32_t crc32 = mg_crc32(0, base, s_size);",
          "5555:     if (size == s_size && crc32 == s_crc32) {",
          "5556:       uint32_t now = (uint32_t) (mg_now() / 1000);",
          "5557:       struct mg_otadata od = {crc32, size, now, MG_OTA_FIRST_BOOT};",
          "5558:       uint32_t key = MG_OTADATA_KEY + (mg_flash_bank() == 2 ? 1 : 2);",
          "5559:       ok = mg_flash_save(NULL, key, &od, sizeof(od));",
          "5560:     }",
          "5561:     MG_DEBUG((\"CRC: %x/%x, size: %lu/%lu, status: %s\", s_crc32, crc32, s_size,",
          "5562:               size, ok ? \"ok\" : \"fail\"));",
          "5563:     s_size = 0;",
          "5564:     if (ok) ok = mg_flash_swap_bank();",
          "5565:   }",
          "5566:   MG_INFO((\"Finishing OTA: %s\", ok ? \"ok\" : \"fail\"));",
          "5567:   return ok;",
          "5570: static struct mg_otadata mg_otadata(int fw) {",
          "5571:   struct mg_otadata od = {};",
          "5572:   int bank = mg_flash_bank();",
          "5573:   uint32_t key = MG_OTADATA_KEY + 1;",
          "5574:   if ((fw == MG_FIRMWARE_CURRENT && bank == 2)) key++;",
          "5575:   if ((fw == MG_FIRMWARE_PREVIOUS && bank == 1)) key++;",
          "5576:   mg_flash_load(NULL, key, &od, sizeof(od));",
          "5579:   return od;",
          "5582: int mg_ota_status(int fw) {",
          "5583:   struct mg_otadata od = mg_otadata(fw);",
          "5584:   return od.status;",
          "5585: }",
          "5586: uint32_t mg_ota_crc32(int fw) {",
          "5587:   struct mg_otadata od = mg_otadata(fw);",
          "5588:   return od.crc32;",
          "5589: }",
          "5590: uint32_t mg_ota_timestamp(int fw) {",
          "5591:   struct mg_otadata od = mg_otadata(fw);",
          "5592:   return od.timestamp;",
          "5593: }",
          "5594: size_t mg_ota_size(int fw) {",
          "5595:   struct mg_otadata od = mg_otadata(fw);",
          "5596:   return od.size;",
          "5599: bool mg_ota_commit(void) {",
          "5600:   struct mg_otadata od = mg_otadata(MG_FIRMWARE_CURRENT);",
          "5601:   od.status = MG_OTA_COMMITTED;",
          "5602:   uint32_t key = MG_OTADATA_KEY + mg_flash_bank();",
          "5603:   return mg_flash_save(NULL, key, &od, sizeof(od));",
          "5604: }",
          "5606: bool mg_ota_rollback(void) {",
          "5607:   MG_DEBUG((\"Rolling firmware back\"));",
          "5608:   return mg_flash_swap_bank();",
          "5610: #endif",
          "5613: #line 1 \"src/printf.c\"",
          "5619: size_t mg_queue_vprintf(struct mg_queue *q, const char *fmt, va_list *ap) {",
          "5620:   size_t len = mg_snprintf(NULL, 0, fmt, ap);",
          "5621:   char *buf;",
          "5622:   if (len == 0 || mg_queue_book(q, &buf, len + 1) < len + 1) {",
          "5623:     len = 0;  // Nah. Not enough space",
          "5624:   } else {",
          "5625:     len = mg_vsnprintf((char *) buf, len + 1, fmt, ap);",
          "5626:     mg_queue_add(q, len);",
          "5627:   }",
          "5628:   return len;",
          "5629: }",
          "5631: size_t mg_queue_printf(struct mg_queue *q, const char *fmt, ...) {",
          "5632:   va_list ap;",
          "5633:   size_t len;",
          "5634:   va_start(ap, fmt);",
          "5635:   len = mg_queue_vprintf(q, fmt, &ap);",
          "5636:   va_end(ap);",
          "5637:   return len;",
          "5640: static void mg_pfn_iobuf_private(char ch, void *param, bool expand) {",
          "5641:   struct mg_iobuf *io = (struct mg_iobuf *) param;",
          "5642:   if (expand && io->len + 2 > io->size) mg_iobuf_resize(io, io->len + 2);",
          "5643:   if (io->len + 2 <= io->size) {",
          "5644:     io->buf[io->len++] = (uint8_t) ch;",
          "5645:     io->buf[io->len] = 0;",
          "5646:   } else if (io->len < io->size) {",
          "5647:     io->buf[io->len++] = 0;  // Guarantee to 0-terminate",
          "5651: static void mg_putchar_iobuf_static(char ch, void *param) {",
          "5652:   mg_pfn_iobuf_private(ch, param, false);",
          "5655: void mg_pfn_iobuf(char ch, void *param) {",
          "5656:   mg_pfn_iobuf_private(ch, param, true);",
          "5659: size_t mg_vsnprintf(char *buf, size_t len, const char *fmt, va_list *ap) {",
          "5660:   struct mg_iobuf io = {(uint8_t *) buf, len, 0, 0};",
          "5661:   size_t n = mg_vxprintf(mg_putchar_iobuf_static, &io, fmt, ap);",
          "5662:   if (n < len) buf[n] = '\\0';",
          "5663:   return n;",
          "5666: size_t mg_snprintf(char *buf, size_t len, const char *fmt, ...) {",
          "5667:   va_list ap;",
          "5668:   size_t n;",
          "5669:   va_start(ap, fmt);",
          "5670:   n = mg_vsnprintf(buf, len, fmt, &ap);",
          "5671:   va_end(ap);",
          "5672:   return n;",
          "5673: }",
          "5675: char *mg_vmprintf(const char *fmt, va_list *ap) {",
          "5676:   struct mg_iobuf io = {0, 0, 0, 256};",
          "5677:   mg_vxprintf(mg_pfn_iobuf, &io, fmt, ap);",
          "5678:   return (char *) io.buf;",
          "5679: }",
          "5681: char *mg_mprintf(const char *fmt, ...) {",
          "5682:   char *s;",
          "5683:   va_list ap;",
          "5684:   va_start(ap, fmt);",
          "5685:   s = mg_vmprintf(fmt, &ap);",
          "5686:   va_end(ap);",
          "5687:   return s;",
          "5688: }",
          "5690: void mg_pfn_stdout(char c, void *param) {",
          "5691:   putchar(c);",
          "5692:   (void) param;",
          "5693: }",
          "5695: static size_t print_ip4(void (*out)(char, void *), void *arg, uint8_t *p) {",
          "5696:   return mg_xprintf(out, arg, \"%d.%d.%d.%d\", p[0], p[1], p[2], p[3]);",
          "5697: }",
          "5699: static size_t print_ip6(void (*out)(char, void *), void *arg, uint16_t *p) {",
          "5700:   return mg_xprintf(out, arg, \"[%x:%x:%x:%x:%x:%x:%x:%x]\", mg_ntohs(p[0]),",
          "5701:                     mg_ntohs(p[1]), mg_ntohs(p[2]), mg_ntohs(p[3]),",
          "5702:                     mg_ntohs(p[4]), mg_ntohs(p[5]), mg_ntohs(p[6]),",
          "5703:                     mg_ntohs(p[7]));",
          "5704: }",
          "5706: size_t mg_print_ip4(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5707:   uint8_t *p = va_arg(*ap, uint8_t *);",
          "5708:   return print_ip4(out, arg, p);",
          "5709: }",
          "5711: size_t mg_print_ip6(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5712:   uint16_t *p = va_arg(*ap, uint16_t *);",
          "5713:   return print_ip6(out, arg, p);",
          "5714: }",
          "5716: size_t mg_print_ip(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5717:   struct mg_addr *addr = va_arg(*ap, struct mg_addr *);",
          "5718:   if (addr->is_ip6) return print_ip6(out, arg, (uint16_t *) addr->ip);",
          "5719:   return print_ip4(out, arg, (uint8_t *) &addr->ip);",
          "5720: }",
          "5722: size_t mg_print_ip_port(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5723:   struct mg_addr *a = va_arg(*ap, struct mg_addr *);",
          "5724:   return mg_xprintf(out, arg, \"%M:%hu\", mg_print_ip, a, mg_ntohs(a->port));",
          "5725: }",
          "5727: size_t mg_print_mac(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5728:   uint8_t *p = va_arg(*ap, uint8_t *);",
          "5729:   return mg_xprintf(out, arg, \"%02x:%02x:%02x:%02x:%02x:%02x\", p[0], p[1], p[2],",
          "5730:                     p[3], p[4], p[5]);",
          "5731: }",
          "5733: static char mg_esc(int c, bool esc) {",
          "5734:   const char *p, *esc1 = \"\\b\\f\\n\\r\\t\\\\\\\"\", *esc2 = \"bfnrt\\\\\\\"\";",
          "5735:   for (p = esc ? esc1 : esc2; *p != '\\0'; p++) {",
          "5736:     if (*p == c) return esc ? esc2[p - esc1] : esc1[p - esc2];",
          "5737:   }",
          "5738:   return 0;",
          "5739: }",
          "5741: static char mg_escape(int c) {",
          "5742:   return mg_esc(c, true);",
          "5743: }",
          "5745: static size_t qcpy(void (*out)(char, void *), void *ptr, char *buf,",
          "5746:                    size_t len) {",
          "5747:   size_t i = 0, extra = 0;",
          "5748:   for (i = 0; i < len && buf[i] != '\\0'; i++) {",
          "5749:     char c = mg_escape(buf[i]);",
          "5750:     if (c) {",
          "5751:       out('\\\\', ptr), out(c, ptr), extra++;",
          "5752:     } else {",
          "5753:       out(buf[i], ptr);",
          "5754:     }",
          "5755:   }",
          "5756:   return i + extra;",
          "5757: }",
          "5759: static size_t bcpy(void (*out)(char, void *), void *arg, uint8_t *buf,",
          "5760:                    size_t len) {",
          "5761:   size_t i, j, n = 0;",
          "5762:   const char *t =",
          "5763:       \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";",
          "5764:   for (i = 0; i < len; i += 3) {",
          "5765:     uint8_t c1 = buf[i], c2 = i + 1 < len ? buf[i + 1] : 0,",
          "5766:             c3 = i + 2 < len ? buf[i + 2] : 0;",
          "5767:     char tmp[4] = {t[c1 >> 2], t[(c1 & 3) << 4 | (c2 >> 4)], '=', '='};",
          "5768:     if (i + 1 < len) tmp[2] = t[(c2 & 15) << 2 | (c3 >> 6)];",
          "5769:     if (i + 2 < len) tmp[3] = t[c3 & 63];",
          "5770:     for (j = 0; j < sizeof(tmp) && tmp[j] != '\\0'; j++) out(tmp[j], arg);",
          "5771:     n += j;",
          "5772:   }",
          "5773:   return n;",
          "5774: }",
          "5776: size_t mg_print_hex(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5777:   size_t bl = (size_t) va_arg(*ap, int);",
          "5778:   uint8_t *p = va_arg(*ap, uint8_t *);",
          "5779:   const char *hex = \"0123456789abcdef\";",
          "5780:   size_t j;",
          "5781:   for (j = 0; j < bl; j++) {",
          "5782:     out(hex[(p[j] >> 4) & 0x0F], arg);",
          "5783:     out(hex[p[j] & 0x0F], arg);",
          "5784:   }",
          "5785:   return 2 * bl;",
          "5786: }",
          "5787: size_t mg_print_base64(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5788:   size_t len = (size_t) va_arg(*ap, int);",
          "5789:   uint8_t *buf = va_arg(*ap, uint8_t *);",
          "5790:   return bcpy(out, arg, buf, len);",
          "5791: }",
          "5793: size_t mg_print_esc(void (*out)(char, void *), void *arg, va_list *ap) {",
          "5794:   size_t len = (size_t) va_arg(*ap, int);",
          "5795:   char *p = va_arg(*ap, char *);",
          "5796:   if (len == 0) len = p == NULL ? 0 : strlen(p);",
          "5797:   return qcpy(out, arg, p, len);",
          "5798: }",
          "5800: #ifdef MG_ENABLE_LINES",
          "5801: #line 1 \"src/queue.c\"",
          "5806: #if defined(__GNUC__) || defined(__clang__)",
          "5807: #define MG_MEMORY_BARRIER() __sync_synchronize()",
          "5808: #elif defined(_MSC_VER) && _MSC_VER >= 1700",
          "5809: #define MG_MEMORY_BARRIER() MemoryBarrier()",
          "5810: #elif !defined(MG_MEMORY_BARRIER)",
          "5811: #define MG_MEMORY_BARRIER()",
          "5827: void mg_queue_init(struct mg_queue *q, char *buf, size_t size) {",
          "5828:   q->size = size;",
          "5829:   q->buf = buf;",
          "5830:   q->head = q->tail = 0;",
          "5833: static size_t mg_queue_read_len(struct mg_queue *q) {",
          "5834:   uint32_t n = 0;",
          "5835:   MG_MEMORY_BARRIER();",
          "5836:   memcpy(&n, q->buf + q->tail, sizeof(n));",
          "5837:   assert(q->tail + n + sizeof(n) <= q->size);",
          "5838:   return n;",
          "5841: static void mg_queue_write_len(struct mg_queue *q, size_t len) {",
          "5842:   uint32_t n = (uint32_t) len;",
          "5843:   memcpy(q->buf + q->head, &n, sizeof(n));",
          "5844:   MG_MEMORY_BARRIER();",
          "5847: size_t mg_queue_book(struct mg_queue *q, char **buf, size_t len) {",
          "5848:   size_t space = 0, hs = sizeof(uint32_t) * 2;  // *2 is for the 0 marker",
          "5849:   if (q->head >= q->tail && q->head + len + hs <= q->size) {",
          "5850:     space = q->size - q->head - hs;  // There is enough space",
          "5851:   } else if (q->head >= q->tail && q->tail > hs) {",
          "5852:     mg_queue_write_len(q, 0);  // Not enough space ahead",
          "5853:     q->head = 0;               // Wrap head to the beginning",
          "5854:   }",
          "5855:   if (q->head + hs + len < q->tail) space = q->tail - q->head - hs;",
          "5856:   if (buf != NULL) *buf = q->buf + q->head + sizeof(uint32_t);",
          "5857:   return space;",
          "5858: }",
          "5860: size_t mg_queue_next(struct mg_queue *q, char **buf) {",
          "5861:   size_t len = 0;",
          "5862:   if (q->tail != q->head) {",
          "5863:     len = mg_queue_read_len(q);",
          "5864:     if (len == 0) {  // Zero (head wrapped) ?",
          "5865:       q->tail = 0;   // Reset tail to the start",
          "5866:       if (q->head > q->tail) len = mg_queue_read_len(q);  // Read again",
          "5869:   if (buf != NULL) *buf = q->buf + q->tail + sizeof(uint32_t);",
          "5870:   assert(q->tail + len <= q->size);",
          "5871:   return len;",
          "5874: void mg_queue_add(struct mg_queue *q, size_t len) {",
          "5875:   assert(len > 0);",
          "5876:   mg_queue_write_len(q, len);",
          "5877:   assert(q->head + sizeof(uint32_t) * 2 + len <= q->size);",
          "5878:   q->head += len + sizeof(uint32_t);",
          "5881: void mg_queue_del(struct mg_queue *q, size_t len) {",
          "5882:   q->tail += len + sizeof(uint32_t);",
          "5883:   assert(q->tail + sizeof(uint32_t) <= q->size);",
          "5886: #ifdef MG_ENABLE_LINES",
          "5887: #line 1 \"src/rpc.c\"",
          "5892: void mg_rpc_add(struct mg_rpc **head, struct mg_str method,",
          "5893:                 void (*fn)(struct mg_rpc_req *), void *fn_data) {",
          "5894:   struct mg_rpc *rpc = (struct mg_rpc *) calloc(1, sizeof(*rpc));",
          "5895:   if (rpc != NULL) {",
          "5896:     rpc->method = mg_strdup(method), rpc->fn = fn, rpc->fn_data = fn_data;",
          "5897:     rpc->next = *head, *head = rpc;",
          "5898:   }",
          "5899: }",
          "5901: void mg_rpc_del(struct mg_rpc **head, void (*fn)(struct mg_rpc_req *)) {",
          "5902:   struct mg_rpc *r;",
          "5903:   while ((r = *head) != NULL) {",
          "5904:     if (r->fn == fn || fn == NULL) {",
          "5906:       free((void *) r->method.ptr);",
          "5907:       free(r);",
          "5909:       head = &(*head)->next;",
          "5914: static void mg_rpc_call(struct mg_rpc_req *r, struct mg_str method) {",
          "5915:   struct mg_rpc *h = r->head == NULL ? NULL : *r->head;",
          "5916:   while (h != NULL && !mg_match(method, h->method, NULL)) h = h->next;",
          "5917:   if (h != NULL) {",
          "5918:     r->rpc = h;",
          "5919:     h->fn(r);",
          "5921:     mg_rpc_err(r, -32601, \"\\\"%.*s not found\\\"\", (int) method.len, method.ptr);",
          "5925: void mg_rpc_process(struct mg_rpc_req *r) {",
          "5926:   int len, off = mg_json_get(r->frame, \"$.method\", &len);",
          "5927:   if (off > 0 && r->frame.ptr[off] == '\"') {",
          "5928:     struct mg_str method = mg_str_n(&r->frame.ptr[off + 1], (size_t) len - 2);",
          "5929:     mg_rpc_call(r, method);",
          "5930:   } else if ((off = mg_json_get(r->frame, \"$.result\", &len)) > 0 ||",
          "5931:              (off = mg_json_get(r->frame, \"$.error\", &len)) > 0) {",
          "5932:     mg_rpc_call(r, mg_str(\"\"));  // JSON response! call \"\" method handler",
          "5934:     mg_rpc_err(r, -32700, \"%m\", mg_print_esc, (int) r->frame.len,",
          "5935:                r->frame.ptr);  // Invalid",
          "5939: void mg_rpc_vok(struct mg_rpc_req *r, const char *fmt, va_list *ap) {",
          "5940:   int len, off = mg_json_get(r->frame, \"$.id\", &len);",
          "5941:   if (off > 0) {",
          "5942:     mg_xprintf(r->pfn, r->pfn_data, \"{%m:%.*s,%m:\", mg_print_esc, 0, \"id\", len,",
          "5943:                &r->frame.ptr[off], mg_print_esc, 0, \"result\");",
          "5944:     mg_vxprintf(r->pfn, r->pfn_data, fmt == NULL ? \"null\" : fmt, ap);",
          "5945:     mg_xprintf(r->pfn, r->pfn_data, \"}\");",
          "5946:   }",
          "5949: void mg_rpc_ok(struct mg_rpc_req *r, const char *fmt, ...) {",
          "5950:   va_list ap;",
          "5951:   va_start(ap, fmt);",
          "5952:   mg_rpc_vok(r, fmt, &ap);",
          "5953:   va_end(ap);",
          "5956: void mg_rpc_verr(struct mg_rpc_req *r, int code, const char *fmt, va_list *ap) {",
          "5957:   int len, off = mg_json_get(r->frame, \"$.id\", &len);",
          "5958:   mg_xprintf(r->pfn, r->pfn_data, \"{\");",
          "5959:   if (off > 0) {",
          "5960:     mg_xprintf(r->pfn, r->pfn_data, \"%m:%.*s,\", mg_print_esc, 0, \"id\", len,",
          "5961:                &r->frame.ptr[off]);",
          "5963:   mg_xprintf(r->pfn, r->pfn_data, \"%m:{%m:%d,%m:\", mg_print_esc, 0, \"error\",",
          "5964:              mg_print_esc, 0, \"code\", code, mg_print_esc, 0, \"message\");",
          "5965:   mg_vxprintf(r->pfn, r->pfn_data, fmt == NULL ? \"null\" : fmt, ap);",
          "5966:   mg_xprintf(r->pfn, r->pfn_data, \"}}\");",
          "5969: void mg_rpc_err(struct mg_rpc_req *r, int code, const char *fmt, ...) {",
          "5970:   va_list ap;",
          "5971:   va_start(ap, fmt);",
          "5972:   mg_rpc_verr(r, code, fmt, &ap);",
          "5973:   va_end(ap);",
          "5976: static size_t print_methods(mg_pfn_t pfn, void *pfn_data, va_list *ap) {",
          "5977:   struct mg_rpc *h, **head = (struct mg_rpc **) va_arg(*ap, void **);",
          "5978:   size_t len = 0;",
          "5979:   for (h = *head; h != NULL; h = h->next) {",
          "5980:     if (h->method.len == 0) continue;  // Ignore response handler",
          "5981:     len += mg_xprintf(pfn, pfn_data, \"%s%m\", h == *head ? \"\" : \",\",",
          "5982:                       mg_print_esc, (int) h->method.len, h->method.ptr);",
          "5984:   return len;",
          "5987: void mg_rpc_list(struct mg_rpc_req *r) {",
          "5988:   mg_rpc_ok(r, \"[%M]\", print_methods, r->head);",
          "5991: #ifdef MG_ENABLE_LINES",
          "5992: #line 1 \"src/sha1.c\"",
          "5999: union char64long16 {",
          "6000:   unsigned char c[64];",
          "6001:   uint32_t l[16];",
          "6002: };",
          "6004: #define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))",
          "6006: static uint32_t blk0(union char64long16 *block, int i) {",
          "6007:   if (MG_BIG_ENDIAN) {",
          "6009:     block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |",
          "6010:                   (rol(block->l[i], 8) & 0x00FF00FF);",
          "6012:   return block->l[i];",
          "6013: }",
          "6016: #undef blk",
          "6017: #undef R0",
          "6018: #undef R1",
          "6019: #undef R2",
          "6020: #undef R3",
          "6021: #undef R4",
          "6023: #define blk(i)                                                               \\",
          "6024:   (block->l[i & 15] = rol(block->l[(i + 13) & 15] ^ block->l[(i + 8) & 15] ^ \\",
          "6025:                               block->l[(i + 2) & 15] ^ block->l[i & 15],     \\",
          "6026:                           1))",
          "6027: #define R0(v, w, x, y, z, i)                                          \\",
          "6028:   z += ((w & (x ^ y)) ^ y) + blk0(block, i) + 0x5A827999 + rol(v, 5); \\",
          "6029:   w = rol(w, 30);",
          "6030: #define R1(v, w, x, y, z, i)                                  \\",
          "6031:   z += ((w & (x ^ y)) ^ y) + blk(i) + 0x5A827999 + rol(v, 5); \\",
          "6032:   w = rol(w, 30);",
          "6033: #define R2(v, w, x, y, z, i)                          \\",
          "6034:   z += (w ^ x ^ y) + blk(i) + 0x6ED9EBA1 + rol(v, 5); \\",
          "6035:   w = rol(w, 30);",
          "6036: #define R3(v, w, x, y, z, i)                                        \\",
          "6037:   z += (((w | x) & y) | (w & x)) + blk(i) + 0x8F1BBCDC + rol(v, 5); \\",
          "6038:   w = rol(w, 30);",
          "6039: #define R4(v, w, x, y, z, i)                          \\",
          "6040:   z += (w ^ x ^ y) + blk(i) + 0xCA62C1D6 + rol(v, 5); \\",
          "6041:   w = rol(w, 30);",
          "6043: static void mg_sha1_transform(uint32_t state[5],",
          "6044:                               const unsigned char *buffer) {",
          "6045:   uint32_t a, b, c, d, e;",
          "6046:   union char64long16 block[1];",
          "6048:   memcpy(block, buffer, 64);",
          "6049:   a = state[0];",
          "6050:   b = state[1];",
          "6051:   c = state[2];",
          "6052:   d = state[3];",
          "6053:   e = state[4];",
          "6054:   R0(a, b, c, d, e, 0);",
          "6055:   R0(e, a, b, c, d, 1);",
          "6056:   R0(d, e, a, b, c, 2);",
          "6057:   R0(c, d, e, a, b, 3);",
          "6058:   R0(b, c, d, e, a, 4);",
          "6059:   R0(a, b, c, d, e, 5);",
          "6060:   R0(e, a, b, c, d, 6);",
          "6061:   R0(d, e, a, b, c, 7);",
          "6062:   R0(c, d, e, a, b, 8);",
          "6063:   R0(b, c, d, e, a, 9);",
          "6064:   R0(a, b, c, d, e, 10);",
          "6065:   R0(e, a, b, c, d, 11);",
          "6066:   R0(d, e, a, b, c, 12);",
          "6067:   R0(c, d, e, a, b, 13);",
          "6068:   R0(b, c, d, e, a, 14);",
          "6069:   R0(a, b, c, d, e, 15);",
          "6070:   R1(e, a, b, c, d, 16);",
          "6071:   R1(d, e, a, b, c, 17);",
          "6072:   R1(c, d, e, a, b, 18);",
          "6073:   R1(b, c, d, e, a, 19);",
          "6074:   R2(a, b, c, d, e, 20);",
          "6075:   R2(e, a, b, c, d, 21);",
          "6076:   R2(d, e, a, b, c, 22);",
          "6077:   R2(c, d, e, a, b, 23);",
          "6078:   R2(b, c, d, e, a, 24);",
          "6079:   R2(a, b, c, d, e, 25);",
          "6080:   R2(e, a, b, c, d, 26);",
          "6081:   R2(d, e, a, b, c, 27);",
          "6082:   R2(c, d, e, a, b, 28);",
          "6083:   R2(b, c, d, e, a, 29);",
          "6084:   R2(a, b, c, d, e, 30);",
          "6085:   R2(e, a, b, c, d, 31);",
          "6086:   R2(d, e, a, b, c, 32);",
          "6087:   R2(c, d, e, a, b, 33);",
          "6088:   R2(b, c, d, e, a, 34);",
          "6089:   R2(a, b, c, d, e, 35);",
          "6090:   R2(e, a, b, c, d, 36);",
          "6091:   R2(d, e, a, b, c, 37);",
          "6092:   R2(c, d, e, a, b, 38);",
          "6093:   R2(b, c, d, e, a, 39);",
          "6094:   R3(a, b, c, d, e, 40);",
          "6095:   R3(e, a, b, c, d, 41);",
          "6096:   R3(d, e, a, b, c, 42);",
          "6097:   R3(c, d, e, a, b, 43);",
          "6098:   R3(b, c, d, e, a, 44);",
          "6099:   R3(a, b, c, d, e, 45);",
          "6100:   R3(e, a, b, c, d, 46);",
          "6101:   R3(d, e, a, b, c, 47);",
          "6102:   R3(c, d, e, a, b, 48);",
          "6103:   R3(b, c, d, e, a, 49);",
          "6104:   R3(a, b, c, d, e, 50);",
          "6105:   R3(e, a, b, c, d, 51);",
          "6106:   R3(d, e, a, b, c, 52);",
          "6107:   R3(c, d, e, a, b, 53);",
          "6108:   R3(b, c, d, e, a, 54);",
          "6109:   R3(a, b, c, d, e, 55);",
          "6110:   R3(e, a, b, c, d, 56);",
          "6111:   R3(d, e, a, b, c, 57);",
          "6112:   R3(c, d, e, a, b, 58);",
          "6113:   R3(b, c, d, e, a, 59);",
          "6114:   R4(a, b, c, d, e, 60);",
          "6115:   R4(e, a, b, c, d, 61);",
          "6116:   R4(d, e, a, b, c, 62);",
          "6117:   R4(c, d, e, a, b, 63);",
          "6118:   R4(b, c, d, e, a, 64);",
          "6119:   R4(a, b, c, d, e, 65);",
          "6120:   R4(e, a, b, c, d, 66);",
          "6121:   R4(d, e, a, b, c, 67);",
          "6122:   R4(c, d, e, a, b, 68);",
          "6123:   R4(b, c, d, e, a, 69);",
          "6124:   R4(a, b, c, d, e, 70);",
          "6125:   R4(e, a, b, c, d, 71);",
          "6126:   R4(d, e, a, b, c, 72);",
          "6127:   R4(c, d, e, a, b, 73);",
          "6128:   R4(b, c, d, e, a, 74);",
          "6129:   R4(a, b, c, d, e, 75);",
          "6130:   R4(e, a, b, c, d, 76);",
          "6131:   R4(d, e, a, b, c, 77);",
          "6132:   R4(c, d, e, a, b, 78);",
          "6133:   R4(b, c, d, e, a, 79);",
          "6134:   state[0] += a;",
          "6135:   state[1] += b;",
          "6136:   state[2] += c;",
          "6137:   state[3] += d;",
          "6138:   state[4] += e;",
          "6141:   memset(block, 0, sizeof(block));",
          "6142:   a = b = c = d = e = 0;",
          "6143:   (void) a;",
          "6144:   (void) b;",
          "6145:   (void) c;",
          "6146:   (void) d;",
          "6147:   (void) e;",
          "6150: void mg_sha1_init(mg_sha1_ctx *context) {",
          "6151:   context->state[0] = 0x67452301;",
          "6152:   context->state[1] = 0xEFCDAB89;",
          "6153:   context->state[2] = 0x98BADCFE;",
          "6154:   context->state[3] = 0x10325476;",
          "6155:   context->state[4] = 0xC3D2E1F0;",
          "6156:   context->count[0] = context->count[1] = 0;",
          "6159: void mg_sha1_update(mg_sha1_ctx *context, const unsigned char *data,",
          "6160:                     size_t len) {",
          "6161:   size_t i, j;",
          "6163:   j = context->count[0];",
          "6164:   if ((context->count[0] += (uint32_t) len << 3) < j) context->count[1]++;",
          "6165:   context->count[1] += (uint32_t) (len >> 29);",
          "6166:   j = (j >> 3) & 63;",
          "6167:   if ((j + len) > 63) {",
          "6168:     memcpy(&context->buffer[j], data, (i = 64 - j));",
          "6169:     mg_sha1_transform(context->state, context->buffer);",
          "6170:     for (; i + 63 < len; i += 64) {",
          "6171:       mg_sha1_transform(context->state, &data[i]);",
          "6172:     }",
          "6173:     j = 0;",
          "6174:   } else",
          "6175:     i = 0;",
          "6176:   memcpy(&context->buffer[j], &data[i], len - i);",
          "6179: void mg_sha1_final(unsigned char digest[20], mg_sha1_ctx *context) {",
          "6180:   unsigned i;",
          "6181:   unsigned char finalcount[8], c;",
          "6183:   for (i = 0; i < 8; i++) {",
          "6184:     finalcount[i] = (unsigned char) ((context->count[(i >= 4 ? 0 : 1)] >>",
          "6185:                                       ((3 - (i & 3)) * 8)) &",
          "6186:                                      255);",
          "6188:   c = 0200;",
          "6189:   mg_sha1_update(context, &c, 1);",
          "6190:   while ((context->count[0] & 504) != 448) {",
          "6191:     c = 0000;",
          "6192:     mg_sha1_update(context, &c, 1);",
          "6194:   mg_sha1_update(context, finalcount, 8);",
          "6195:   for (i = 0; i < 20; i++) {",
          "6196:     digest[i] =",
          "6197:         (unsigned char) ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);",
          "6199:   memset(context, '\\0', sizeof(*context));",
          "6200:   memset(&finalcount, '\\0', sizeof(finalcount));",
          "6201: }",
          "6203: #ifdef MG_ENABLE_LINES",
          "6204: #line 1 \"src/sntp.c\"",
          "6212: #define SNTP_TIME_OFFSET 2208988800U  // (1970 - 1900) in seconds",
          "6213: #define SNTP_MAX_FRAC 4294967295.0    // 2 ** 32 - 1",
          "6215: static int64_t gettimestamp(const uint32_t *data) {",
          "6216:   uint32_t sec = mg_ntohl(data[0]), frac = mg_ntohl(data[1]);",
          "6217:   if (sec) sec -= SNTP_TIME_OFFSET;",
          "6218:   return ((int64_t) sec) * 1000 + (int64_t) (frac / SNTP_MAX_FRAC * 1000.0);",
          "6219: }",
          "6221: int64_t mg_sntp_parse(const unsigned char *buf, size_t len) {",
          "6222:   int64_t res = -1;",
          "6223:   int mode = len > 0 ? buf[0] & 7 : 0;",
          "6224:   int version = len > 0 ? (buf[0] >> 3) & 7 : 0;",
          "6225:   if (len < 48) {",
          "6226:     MG_ERROR((\"%s\", \"corrupt packet\"));",
          "6227:   } else if (mode != 4 && mode != 5) {",
          "6228:     MG_ERROR((\"%s\", \"not a server reply\"));",
          "6229:   } else if (buf[1] == 0) {",
          "6230:     MG_ERROR((\"%s\", \"server sent a kiss of death\"));",
          "6231:   } else if (version == 4 || version == 3) {",
          "6233:     int64_t t0 = gettimestamp((uint32_t *) &buf[24]);",
          "6234:     int64_t t1 = gettimestamp((uint32_t *) &buf[32]);",
          "6235:     int64_t t2 = gettimestamp((uint32_t *) &buf[40]);",
          "6236:     int64_t t3 = (int64_t) mg_millis();",
          "6237:     int64_t delta = (t3 - t0) - (t2 - t1);",
          "6238:     MG_VERBOSE((\"%lld %lld %lld %lld delta:%lld\", t0, t1, t2, t3, delta));",
          "6239:     res = t2 + delta / 2;",
          "6240:   } else {",
          "6241:     MG_ERROR((\"unexpected version: %d\", version));",
          "6242:   }",
          "6243:   return res;",
          "6244: }",
          "6246: static void sntp_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {",
          "6247:   if (ev == MG_EV_READ) {",
          "6248:     int64_t milliseconds = mg_sntp_parse(c->recv.buf, c->recv.len);",
          "6249:     if (milliseconds > 0) {",
          "6250:       MG_INFO((\"%lu got time: %lld ms from epoch\", c->id, milliseconds));",
          "6251:       mg_call(c, MG_EV_SNTP_TIME, (uint64_t *) &milliseconds);",
          "6252:       MG_VERBOSE((\"%u.%u\", (unsigned) (milliseconds / 1000),",
          "6253:                   (unsigned) (milliseconds % 1000)));",
          "6255:     mg_iobuf_del(&c->recv, 0, c->recv.len);  // Free receive buffer",
          "6256:   } else if (ev == MG_EV_CONNECT) {",
          "6257:     mg_sntp_request(c);",
          "6258:   } else if (ev == MG_EV_CLOSE) {",
          "6259:   }",
          "6260:   (void) fnd;",
          "6261:   (void) evd;",
          "6262: }",
          "6264: void mg_sntp_request(struct mg_connection *c) {",
          "6265:   if (c->is_resolving) {",
          "6266:     MG_ERROR((\"%lu wait until resolved\", c->id));",
          "6267:   } else {",
          "6268:     int64_t now = (int64_t) mg_millis();  // Use int64_t, for vc98",
          "6269:     uint8_t buf[48] = {0};",
          "6270:     uint32_t *t = (uint32_t *) &buf[40];",
          "6271:     double frac = ((double) (now % 1000)) / 1000.0 * SNTP_MAX_FRAC;",
          "6272:     buf[0] = (0 << 6) | (4 << 3) | 3;",
          "6273:     t[0] = mg_htonl((uint32_t) (now / 1000) + SNTP_TIME_OFFSET);",
          "6274:     t[1] = mg_htonl((uint32_t) frac);",
          "6275:     mg_send(c, buf, sizeof(buf));",
          "6279: struct mg_connection *mg_sntp_connect(struct mg_mgr *mgr, const char *url,",
          "6280:                                       mg_event_handler_t fn, void *fnd) {",
          "6281:   struct mg_connection *c = NULL;",
          "6282:   if (url == NULL) url = \"udp://time.google.com:123\";",
          "6283:   if ((c = mg_connect(mgr, url, fn, fnd)) != NULL) c->pfn = sntp_cb;",
          "6284:   return c;",
          "6285: }",
          "6288: #line 1 \"src/sock.c\"",
          "6301: #if MG_ENABLE_SOCKET",
          "6303: #ifndef closesocket",
          "6304: #define closesocket(x) close(x)",
          "6307: #define FD(c_) ((MG_SOCKET_TYPE) (size_t) (c_)->fd)",
          "6308: #define S2PTR(s_) ((void *) (size_t) (s_))",
          "6310: #ifndef MSG_NONBLOCKING",
          "6311: #define MSG_NONBLOCKING 0",
          "6314: #ifndef AF_INET6",
          "6315: #define AF_INET6 10",
          "6318: #ifndef MG_SOCK_ERR",
          "6319: #define MG_SOCK_ERR(errcode) ((errcode) < 0 ? errno : 0)",
          "6320: #endif",
          "6322: #ifndef MG_SOCK_INTR",
          "6323: #define MG_SOCK_INTR(fd) (fd == MG_INVALID_SOCKET && MG_SOCK_ERR(-1) == EINTR)",
          "6324: #endif",
          "6326: #ifndef MG_SOCK_PENDING",
          "6327: #define MG_SOCK_PENDING(errcode) \\",
          "6328:   (((errcode) < 0) && (errno == EINPROGRESS || errno == EWOULDBLOCK))",
          "6329: #endif",
          "6331: #ifndef MG_SOCK_RESET",
          "6332: #define MG_SOCK_RESET(errcode) \\",
          "6333:   (((errcode) < 0) && (errno == EPIPE || errno == ECONNRESET))",
          "6334: #endif",
          "6336: union usa {",
          "6337:   struct sockaddr sa;",
          "6338:   struct sockaddr_in sin;",
          "6339: #if MG_ENABLE_IPV6",
          "6340:   struct sockaddr_in6 sin6;",
          "6341: #endif",
          "6342: };",
          "6344: static socklen_t tousa(struct mg_addr *a, union usa *usa) {",
          "6345:   socklen_t len = sizeof(usa->sin);",
          "6346:   memset(usa, 0, sizeof(*usa));",
          "6347:   usa->sin.sin_family = AF_INET;",
          "6348:   usa->sin.sin_port = a->port;",
          "6349:   memcpy(&usa->sin.sin_addr, a->ip, sizeof(uint32_t));",
          "6350: #if MG_ENABLE_IPV6",
          "6351:   if (a->is_ip6) {",
          "6352:     usa->sin.sin_family = AF_INET6;",
          "6353:     usa->sin6.sin6_port = a->port;",
          "6354:     memcpy(&usa->sin6.sin6_addr, a->ip, sizeof(a->ip));",
          "6355:     len = sizeof(usa->sin6);",
          "6356:   }",
          "6357: #endif",
          "6358:   return len;",
          "6361: static void tomgaddr(union usa *usa, struct mg_addr *a, bool is_ip6) {",
          "6362:   a->is_ip6 = is_ip6;",
          "6363:   a->port = usa->sin.sin_port;",
          "6364:   memcpy(&a->ip, &usa->sin.sin_addr, sizeof(uint32_t));",
          "6365: #if MG_ENABLE_IPV6",
          "6366:   if (is_ip6) {",
          "6367:     memcpy(a->ip, &usa->sin6.sin6_addr, sizeof(a->ip));",
          "6368:     a->port = usa->sin6.sin6_port;",
          "6369:   }",
          "6370: #endif",
          "6373: static void setlocaddr(MG_SOCKET_TYPE fd, struct mg_addr *addr) {",
          "6374:   union usa usa;",
          "6375:   socklen_t n = sizeof(usa);",
          "6376:   if (getsockname(fd, &usa.sa, &n) == 0) {",
          "6377:     tomgaddr(&usa, addr, n != sizeof(usa.sin));",
          "6378:   }",
          "6381: static void iolog(struct mg_connection *c, char *buf, long n, bool r) {",
          "6382:   if (n == MG_IO_WAIT) {",
          "6384:   } else if (n <= 0) {",
          "6385:     c->is_closing = 1;  // Termination. Don't call mg_error(): #1529",
          "6386:   } else if (n > 0) {",
          "6387:     if (c->is_hexdumping) {",
          "6388:       union usa usa;",
          "6389:       socklen_t slen = sizeof(usa.sin);",
          "6390:       if (getsockname(FD(c), &usa.sa, &slen) < 0) (void) 0;  // Ignore result",
          "6391:       MG_INFO((\"\\n-- %lu %M %s %M %ld\", c->id, mg_print_ip_port, &c->loc,",
          "6392:                r ? \"<-\" : \"->\", mg_print_ip_port, &c->rem, n));",
          "6394:       mg_hexdump(buf, (size_t) n);",
          "6395:     }",
          "6396:     if (r) {",
          "6397:       c->recv.len += (size_t) n;",
          "6398:       mg_call(c, MG_EV_READ, &n);",
          "6399:     } else {",
          "6400:       mg_iobuf_del(&c->send, 0, (size_t) n);",
          "6402:       if (c->send.len == 0) {",
          "6403:         MG_EPOLL_MOD(c, 0);",
          "6404:       }",
          "6405:       mg_call(c, MG_EV_WRITE, &n);",
          "6410: long mg_io_send(struct mg_connection *c, const void *buf, size_t len) {",
          "6411:   long n;",
          "6412:   if (c->is_udp) {",
          "6413:     union usa usa;",
          "6414:     socklen_t slen = tousa(&c->rem, &usa);",
          "6415:     n = sendto(FD(c), (char *) buf, len, 0, &usa.sa, slen);",
          "6416:     if (n > 0) setlocaddr(FD(c), &c->loc);",
          "6417:   } else {",
          "6418:     n = send(FD(c), (char *) buf, len, MSG_NONBLOCKING);",
          "6420:   if (MG_SOCK_PENDING(n)) return MG_IO_WAIT;",
          "6421:   if (MG_SOCK_RESET(n)) return MG_IO_RESET;",
          "6422:   if (n <= 0) return MG_IO_ERR;",
          "6423:   return n;",
          "6426: bool mg_send(struct mg_connection *c, const void *buf, size_t len) {",
          "6427:   if (c->is_udp) {",
          "6428:     long n = mg_io_send(c, buf, len);",
          "6429:     MG_DEBUG((\"%lu %ld %d:%d %ld err %d\", c->id, c->fd, (int) c->send.len,",
          "6430:               (int) c->recv.len, n, MG_SOCK_ERR(n)));",
          "6431:     iolog(c, (char *) buf, n, false);",
          "6432:     return n > 0;",
          "6433:   } else {",
          "6434:     return mg_iobuf_add(&c->send, c->send.len, buf, len);",
          "6438: static void mg_set_non_blocking_mode(MG_SOCKET_TYPE fd) {",
          "6439: #if defined(MG_CUSTOM_NONBLOCK)",
          "6440:   MG_CUSTOM_NONBLOCK(fd);",
          "6441: #elif MG_ARCH == MG_ARCH_WIN32 && MG_ENABLE_WINSOCK",
          "6442:   unsigned long on = 1;",
          "6443:   ioctlsocket(fd, FIONBIO, &on);",
          "6444: #elif MG_ENABLE_RL",
          "6445:   unsigned long on = 1;",
          "6446:   ioctlsocket(fd, FIONBIO, &on);",
          "6447: #elif MG_ENABLE_FREERTOS_TCP",
          "6448:   const BaseType_t off = 0;",
          "6449:   if (setsockopt(fd, 0, FREERTOS_SO_RCVTIMEO, &off, sizeof(off)) != 0) (void) 0;",
          "6450:   if (setsockopt(fd, 0, FREERTOS_SO_SNDTIMEO, &off, sizeof(off)) != 0) (void) 0;",
          "6451: #elif MG_ENABLE_LWIP",
          "6452:   lwip_fcntl(fd, F_SETFL, O_NONBLOCK);",
          "6453: #elif MG_ARCH == MG_ARCH_AZURERTOS",
          "6454:   fcntl(fd, F_SETFL, O_NONBLOCK);",
          "6455: #elif MG_ARCH == MG_ARCH_TIRTOS",
          "6456:   int val = 0;",
          "6457:   setsockopt(fd, SOL_SOCKET, SO_BLOCKING, &val, sizeof(val));",
          "6459:   int sz = sizeof(val);",
          "6460:   getsockopt(fd, SOL_SOCKET, SO_SNDBUF, &val, &sz);",
          "6461:   val /= 2;  // set send low-water mark at half send buffer size",
          "6462:   setsockopt(fd, SOL_SOCKET, SO_SNDLOWAT, &val, sizeof(val));",
          "6463: #else",
          "6464:   fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);  // Non-blocking mode",
          "6465:   fcntl(fd, F_SETFD, FD_CLOEXEC);                          // Set close-on-exec",
          "6466: #endif",
          "6469: bool mg_open_listener(struct mg_connection *c, const char *url) {",
          "6470:   MG_SOCKET_TYPE fd = MG_INVALID_SOCKET;",
          "6471:   bool success = false;",
          "6472:   c->loc.port = mg_htons(mg_url_port(url));",
          "6473:   if (!mg_aton(mg_url_host(url), &c->loc)) {",
          "6474:     MG_ERROR((\"invalid listening URL: %s\", url));",
          "6475:   } else {",
          "6476:     union usa usa;",
          "6477:     socklen_t slen = tousa(&c->loc, &usa);",
          "6478:     int rc, on = 1, af = c->loc.is_ip6 ? AF_INET6 : AF_INET;",
          "6479:     int type = strncmp(url, \"udp:\", 4) == 0 ? SOCK_DGRAM : SOCK_STREAM;",
          "6480:     int proto = type == SOCK_DGRAM ? IPPROTO_UDP : IPPROTO_TCP;",
          "6481:     (void) on;",
          "6483:     if ((fd = socket(af, type, proto)) == MG_INVALID_SOCKET) {",
          "6484:       MG_ERROR((\"socket: %d\", MG_SOCK_ERR(-1)));",
          "6485: #if defined(SO_EXCLUSIVEADDRUSE)",
          "6486:     } else if ((rc = setsockopt(fd, SOL_SOCKET, SO_EXCLUSIVEADDRUSE,",
          "6487:                                 (char *) &on, sizeof(on))) != 0) {",
          "6489:       MG_ERROR((\"setsockopt(SO_EXCLUSIVEADDRUSE): %d %d\", on, MG_SOCK_ERR(rc)));",
          "6490: #elif defined(SO_REUSEADDR) && (!defined(LWIP_SOCKET) || SO_REUSE)",
          "6491:     } else if ((rc = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on,",
          "6492:                                 sizeof(on))) != 0) {",
          "6502:       MG_ERROR((\"setsockopt(SO_REUSEADDR): %d\", MG_SOCK_ERR(rc)));",
          "6503: #endif",
          "6504: #if MG_IPV6_V6ONLY",
          "6506:     } else if (c->loc.is_ip6 &&",
          "6507:                (rc = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &on,",
          "6508:                                 sizeof(on))) != 0) {",
          "6510:       MG_ERROR((\"setsockopt(IPV6_V6ONLY): %d\", MG_SOCK_ERR(rc)));",
          "6511: #endif",
          "6512:     } else if ((rc = bind(fd, &usa.sa, slen)) != 0) {",
          "6513:       MG_ERROR((\"bind: %d\", MG_SOCK_ERR(rc)));",
          "6514:     } else if ((type == SOCK_STREAM &&",
          "6515:                 (rc = listen(fd, MG_SOCK_LISTEN_BACKLOG_SIZE)) != 0)) {",
          "6518:       MG_ERROR((\"listen: %d\", MG_SOCK_ERR(rc)));",
          "6520:       setlocaddr(fd, &c->loc);",
          "6521:       mg_set_non_blocking_mode(fd);",
          "6522:       c->fd = S2PTR(fd);",
          "6523:       MG_EPOLL_ADD(c);",
          "6524:       success = true;",
          "6525:     }",
          "6526:   }",
          "6527:   if (success == false && fd != MG_INVALID_SOCKET) closesocket(fd);",
          "6528:   return success;",
          "6531: long mg_io_recv(struct mg_connection *c, void *buf, size_t len) {",
          "6532:   long n = 0;",
          "6533:   if (c->is_udp) {",
          "6534:     union usa usa;",
          "6535:     socklen_t slen = tousa(&c->rem, &usa);",
          "6536:     n = recvfrom(FD(c), (char *) buf, len, 0, &usa.sa, &slen);",
          "6537:     if (n > 0) tomgaddr(&usa, &c->rem, slen != sizeof(usa.sin));",
          "6538:   } else {",
          "6539:     n = recv(FD(c), (char *) buf, len, MSG_NONBLOCKING);",
          "6540:   }",
          "6541:   if (MG_SOCK_PENDING(n)) return MG_IO_WAIT;",
          "6542:   if (MG_SOCK_RESET(n)) return MG_IO_RESET;",
          "6543:   if (n <= 0) return MG_IO_ERR;",
          "6544:   return n;",
          "6549: static void read_conn(struct mg_connection *c) {",
          "6550:   long n = -1;",
          "6551:   if (c->recv.len >= MG_MAX_RECV_SIZE) {",
          "6552:     mg_error(c, \"max_recv_buf_size reached\");",
          "6553:   } else if (c->recv.size <= c->recv.len &&",
          "6554:              !mg_iobuf_resize(&c->recv, c->recv.size + MG_IO_SIZE)) {",
          "6555:     mg_error(c, \"oom\");",
          "6556:   } else {",
          "6557:     char *buf = (char *) &c->recv.buf[c->recv.len];",
          "6558:     size_t len = c->recv.size - c->recv.len;",
          "6559:     n = c->is_tls ? mg_tls_recv(c, buf, len) : mg_io_recv(c, buf, len);",
          "6560:     MG_DEBUG((\"%lu %ld snd %ld/%ld rcv %ld/%ld n=%ld err=%d\", c->id, c->fd,",
          "6561:               (long) c->send.len, (long) c->send.size, (long) c->recv.len,",
          "6562:               (long) c->recv.size, n, MG_SOCK_ERR(n)));",
          "6563:     iolog(c, buf, n, true);",
          "6564:   }",
          "6567: static void write_conn(struct mg_connection *c) {",
          "6568:   char *buf = (char *) c->send.buf;",
          "6569:   size_t len = c->send.len;",
          "6570:   long n = c->is_tls ? mg_tls_send(c, buf, len) : mg_io_send(c, buf, len);",
          "6571:   MG_DEBUG((\"%lu %ld snd %ld/%ld rcv %ld/%ld n=%ld err=%d\", c->id, c->fd,",
          "6572:             (long) c->send.len, (long) c->send.size, (long) c->recv.len,",
          "6573:             (long) c->recv.size, n, MG_SOCK_ERR(n)));",
          "6574:   iolog(c, buf, n, false);",
          "6577: static void close_conn(struct mg_connection *c) {",
          "6578:   if (FD(c) != MG_INVALID_SOCKET) {",
          "6579: #if MG_ENABLE_EPOLL",
          "6580:     epoll_ctl(c->mgr->epoll_fd, EPOLL_CTL_DEL, FD(c), NULL);",
          "6581: #endif",
          "6582:     closesocket(FD(c));",
          "6583: #if MG_ENABLE_FREERTOS_TCP",
          "6584:     FreeRTOS_FD_CLR(c->fd, c->mgr->ss, eSELECT_ALL);",
          "6585: #endif",
          "6587:   mg_close_conn(c);",
          "6590: static void connect_conn(struct mg_connection *c) {",
          "6591:   union usa usa;",
          "6592:   socklen_t n = sizeof(usa);",
          "6594:   if (getpeername(FD(c), &usa.sa, &n) == 0) {",
          "6595:     c->is_connecting = 0;",
          "6596:     mg_call(c, MG_EV_CONNECT, NULL);",
          "6597:     MG_EPOLL_MOD(c, 0);",
          "6598:     if (c->is_tls_hs) mg_tls_handshake(c);",
          "6599:   } else {",
          "6600:     mg_error(c, \"socket error\");",
          "6601:   }",
          "6604: static void setsockopts(struct mg_connection *c) {",
          "6605: #if MG_ENABLE_FREERTOS_TCP || MG_ARCH == MG_ARCH_AZURERTOS || \\",
          "6606:     MG_ARCH == MG_ARCH_TIRTOS",
          "6607:   (void) c;",
          "6608: #else",
          "6609:   int on = 1;",
          "6610: #if !defined(SOL_TCP)",
          "6611: #define SOL_TCP IPPROTO_TCP",
          "6612: #endif",
          "6613:   if (setsockopt(FD(c), SOL_TCP, TCP_NODELAY, (char *) &on, sizeof(on)) != 0)",
          "6614:     (void) 0;",
          "6615:   if (setsockopt(FD(c), SOL_SOCKET, SO_KEEPALIVE, (char *) &on, sizeof(on)) !=",
          "6616:       0)",
          "6617:     (void) 0;",
          "6618: #endif",
          "6621: void mg_connect_resolved(struct mg_connection *c) {",
          "6622:   int type = c->is_udp ? SOCK_DGRAM : SOCK_STREAM;",
          "6623:   int rc, af = c->rem.is_ip6 ? AF_INET6 : AF_INET;  // c->rem has resolved IP",
          "6624:   c->fd = S2PTR(socket(af, type, 0));               // Create outbound socket",
          "6625:   c->is_resolving = 0;                              // Clear resolving flag",
          "6626:   if (FD(c) == MG_INVALID_SOCKET) {",
          "6627:     mg_error(c, \"socket(): %d\", MG_SOCK_ERR(-1));",
          "6628:   } else if (c->is_udp) {",
          "6629:     MG_EPOLL_ADD(c);",
          "6630: #if MG_ARCH == MG_ARCH_TIRTOS",
          "6631:     union usa usa;  // TI-RTOS NDK requires binding to receive on UDP sockets",
          "6632:     socklen_t slen = tousa(&c->loc, &usa);",
          "6633:     if ((rc = bind(c->fd, &usa.sa, slen)) != 0)",
          "6634:       MG_ERROR((\"bind: %d\", MG_SOCK_ERR(rc)));",
          "6635: #endif",
          "6636:     mg_call(c, MG_EV_RESOLVE, NULL);",
          "6637:     mg_call(c, MG_EV_CONNECT, NULL);",
          "6638:   } else {",
          "6639:     union usa usa;",
          "6640:     socklen_t slen = tousa(&c->rem, &usa);",
          "6641:     mg_set_non_blocking_mode(FD(c));",
          "6642:     setsockopts(c);",
          "6643:     MG_EPOLL_ADD(c);",
          "6644:     mg_call(c, MG_EV_RESOLVE, NULL);",
          "6645:     rc = connect(FD(c), &usa.sa, slen);  // Attempt to connect",
          "6646:     if (rc == 0) {                       // Success",
          "6647:       mg_call(c, MG_EV_CONNECT, NULL);   // Send MG_EV_CONNECT to the user",
          "6648:     } else if (MG_SOCK_PENDING(rc)) {    // Need to wait for TCP handshake",
          "6649:       MG_DEBUG((\"%lu %ld -> %M pend\", c->id, c->fd, mg_print_ip_port, &c->rem));",
          "6650:       c->is_connecting = 1;",
          "6651:     } else {",
          "6652:       mg_error(c, \"connect: %d\", MG_SOCK_ERR(rc));",
          "6657: static MG_SOCKET_TYPE raccept(MG_SOCKET_TYPE sock, union usa *usa,",
          "6658:                               socklen_t *len) {",
          "6659:   MG_SOCKET_TYPE fd = MG_INVALID_SOCKET;",
          "6660:   do {",
          "6661:     memset(usa, 0, sizeof(*usa));",
          "6662:     fd = accept(sock, &usa->sa, len);",
          "6663:   } while (MG_SOCK_INTR(fd));",
          "6664:   return fd;",
          "6667: static void accept_conn(struct mg_mgr *mgr, struct mg_connection *lsn) {",
          "6668:   struct mg_connection *c = NULL;",
          "6669:   union usa usa;",
          "6670:   socklen_t sa_len = sizeof(usa);",
          "6671:   MG_SOCKET_TYPE fd = raccept(FD(lsn), &usa, &sa_len);",
          "6672:   if (fd == MG_INVALID_SOCKET) {",
          "6673: #if MG_ARCH == MG_ARCH_AZURERTOS",
          "6677:     if (errno != EAGAIN)",
          "6679:       MG_ERROR((\"%lu accept failed, errno %d\", lsn->id, MG_SOCK_ERR(-1)));",
          "6680: #if (MG_ARCH != MG_ARCH_WIN32) && !MG_ENABLE_FREERTOS_TCP && \\",
          "6681:     (MG_ARCH != MG_ARCH_TIRTOS) && !MG_ENABLE_POLL && !MG_ENABLE_EPOLL",
          "6682:   } else if ((long) fd >= FD_SETSIZE) {",
          "6683:     MG_ERROR((\"%ld > %ld\", (long) fd, (long) FD_SETSIZE));",
          "6684:     closesocket(fd);",
          "6685: #endif",
          "6686:   } else if ((c = mg_alloc_conn(mgr)) == NULL) {",
          "6687:     MG_ERROR((\"%lu OOM\", lsn->id));",
          "6688:     closesocket(fd);",
          "6689:   } else {",
          "6690:     tomgaddr(&usa, &c->rem, sa_len != sizeof(usa.sin));",
          "6691:     LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);",
          "6692:     c->fd = S2PTR(fd);",
          "6693:     MG_EPOLL_ADD(c);",
          "6694:     mg_set_non_blocking_mode(FD(c));",
          "6695:     setsockopts(c);",
          "6696:     c->is_accepted = 1;",
          "6697:     c->is_hexdumping = lsn->is_hexdumping;",
          "6698:     c->loc = lsn->loc;",
          "6699:     c->pfn = lsn->pfn;",
          "6700:     c->pfn_data = lsn->pfn_data;",
          "6701:     c->fn = lsn->fn;",
          "6702:     c->fn_data = lsn->fn_data;",
          "6703:     MG_DEBUG((\"%lu %ld accepted %M -> %M\", c->id, c->fd, mg_print_ip_port,",
          "6704:               &c->rem, mg_print_ip_port, &c->loc));",
          "6705:     mg_call(c, MG_EV_OPEN, NULL);",
          "6706:     mg_call(c, MG_EV_ACCEPT, NULL);",
          "6710: static bool can_read(const struct mg_connection *c) {",
          "6711:   return c->is_full == false;",
          "6714: static bool can_write(const struct mg_connection *c) {",
          "6715:   return c->is_connecting || (c->send.len > 0 && c->is_tls_hs == 0);",
          "6718: static bool skip_iotest(const struct mg_connection *c) {",
          "6719:   return (c->is_closing || c->is_resolving || FD(c) == MG_INVALID_SOCKET) ||",
          "6720:          (can_read(c) == false && can_write(c) == false);",
          "6721: }",
          "6723: static void mg_iotest(struct mg_mgr *mgr, int ms) {",
          "6724: #if MG_ENABLE_FREERTOS_TCP",
          "6725:   struct mg_connection *c;",
          "6726:   for (c = mgr->conns; c != NULL; c = c->next) {",
          "6727:     c->is_readable = c->is_writable = 0;",
          "6728:     if (skip_iotest(c)) continue;",
          "6729:     if (can_read(c))",
          "6730:       FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_READ | eSELECT_EXCEPT);",
          "6731:     if (can_write(c)) FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_WRITE);",
          "6732:   }",
          "6733:   FreeRTOS_select(mgr->ss, pdMS_TO_TICKS(ms));",
          "6734:   for (c = mgr->conns; c != NULL; c = c->next) {",
          "6735:     EventBits_t bits = FreeRTOS_FD_ISSET(c->fd, mgr->ss);",
          "6736:     c->is_readable = bits & (eSELECT_READ | eSELECT_EXCEPT) ? 1U : 0;",
          "6737:     c->is_writable = bits & eSELECT_WRITE ? 1U : 0;",
          "6738:     if (c->fd != MG_INVALID_SOCKET)",
          "6739:       FreeRTOS_FD_CLR(c->fd, mgr->ss,",
          "6740:                       eSELECT_READ | eSELECT_EXCEPT | eSELECT_WRITE);",
          "6741:   }",
          "6742: #elif MG_ENABLE_EPOLL",
          "6743:   size_t max = 1;",
          "6744:   for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {",
          "6745:     c->is_readable = c->is_writable = 0;",
          "6746:     if (mg_tls_pending(c) > 0) ms = 1, c->is_readable = 1;",
          "6747:     if (can_write(c)) MG_EPOLL_MOD(c, 1);",
          "6748:     max++;",
          "6749:   }",
          "6750:   struct epoll_event *evs = (struct epoll_event *) alloca(max * sizeof(evs[0]));",
          "6751:   int n = epoll_wait(mgr->epoll_fd, evs, (int) max, ms);",
          "6752:   for (int i = 0; i < n; i++) {",
          "6753:     struct mg_connection *c = (struct mg_connection *) evs[i].data.ptr;",
          "6754:     if (evs[i].events & EPOLLERR) {",
          "6755:       mg_error(c, \"socket error\");",
          "6756:     } else if (c->is_readable == 0) {",
          "6757:       bool rd = evs[i].events & (EPOLLIN | EPOLLHUP);",
          "6758:       bool wr = evs[i].events & EPOLLOUT;",
          "6759:       c->is_readable = can_read(c) && rd ? 1U : 0;",
          "6760:       c->is_writable = can_write(c) && wr ? 1U : 0;",
          "6763:   (void) skip_iotest;",
          "6764: #elif MG_ENABLE_POLL",
          "6765:   nfds_t n = 0;",
          "6766:   for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) n++;",
          "6767:   struct pollfd *fds = (struct pollfd *) alloca(n * sizeof(fds[0]));",
          "6768:   memset(fds, 0, n * sizeof(fds[0]));",
          "6769:   n = 0;",
          "6770:   for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {",
          "6771:     c->is_readable = c->is_writable = 0;",
          "6772:     if (skip_iotest(c)) {",
          "6774:     } else if (mg_tls_pending(c) > 0) {",
          "6775:       ms = 1;  // Don't wait if TLS is ready",
          "6776:     } else {",
          "6777:       fds[n].fd = FD(c);",
          "6778:       if (can_read(c)) fds[n].events |= POLLIN;",
          "6779:       if (can_write(c)) fds[n].events |= POLLOUT;",
          "6780:       n++;",
          "6781:     }",
          "6785:   if (poll(fds, n, ms) < 0) {",
          "6786: #if MG_ARCH == MG_ARCH_WIN32",
          "6787:     if (n == 0) Sleep(ms);  // On Windows, poll fails if no sockets",
          "6788: #endif",
          "6789:     memset(fds, 0, n * sizeof(fds[0]));",
          "6790:   }",
          "6791:   n = 0;",
          "6792:   for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {",
          "6793:     if (skip_iotest(c)) {",
          "6795:     } else if (mg_tls_pending(c) > 0) {",
          "6796:       c->is_readable = 1;",
          "6797:     } else {",
          "6798:       if (fds[n].revents & POLLERR) {",
          "6799:         mg_error(c, \"socket error\");",
          "6800:       } else {",
          "6801:         c->is_readable =",
          "6802:             (unsigned) (fds[n].revents & (POLLIN | POLLHUP) ? 1 : 0);",
          "6803:         c->is_writable = (unsigned) (fds[n].revents & POLLOUT ? 1 : 0);",
          "6805:       n++;",
          "6808: #else",
          "6809:   struct timeval tv = {ms / 1000, (ms % 1000) * 1000}, tv_zero = {0, 0}, *tvp;",
          "6810:   struct mg_connection *c;",
          "6811:   fd_set rset, wset, eset;",
          "6812:   MG_SOCKET_TYPE maxfd = 0;",
          "6813:   int rc;",
          "6815:   FD_ZERO(&rset);",
          "6816:   FD_ZERO(&wset);",
          "6817:   FD_ZERO(&eset);",
          "6818:   tvp = ms < 0 ? NULL : &tv;",
          "6819:   for (c = mgr->conns; c != NULL; c = c->next) {",
          "6820:     c->is_readable = c->is_writable = 0;",
          "6821:     if (skip_iotest(c)) continue;",
          "6822:     FD_SET(FD(c), &eset);",
          "6823:     if (can_read(c)) FD_SET(FD(c), &rset);",
          "6824:     if (can_write(c)) FD_SET(FD(c), &wset);",
          "6825:     if (mg_tls_pending(c) > 0) tvp = &tv_zero;",
          "6826:     if (FD(c) > maxfd) maxfd = FD(c);",
          "6827:   }",
          "6829:   if ((rc = select((int) maxfd + 1, &rset, &wset, &eset, tvp)) < 0) {",
          "6830: #if MG_ARCH == MG_ARCH_WIN32",
          "6831:     if (maxfd == 0) Sleep(ms);  // On Windows, select fails if no sockets",
          "6832: #else",
          "6833:     MG_ERROR((\"select: %d %d\", rc, MG_SOCK_ERR(rc)));",
          "6834: #endif",
          "6835:     FD_ZERO(&rset);",
          "6836:     FD_ZERO(&wset);",
          "6837:     FD_ZERO(&eset);",
          "6838:   }",
          "6840:   for (c = mgr->conns; c != NULL; c = c->next) {",
          "6841:     if (FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &eset)) {",
          "6842:       mg_error(c, \"socket error\");",
          "6843:     } else {",
          "6844:       c->is_readable = FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &rset);",
          "6845:       c->is_writable = FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &wset);",
          "6846:       if (mg_tls_pending(c) > 0) c->is_readable = 1;",
          "6849: #endif",
          "6852: void mg_mgr_poll(struct mg_mgr *mgr, int ms) {",
          "6853:   struct mg_connection *c, *tmp;",
          "6854:   uint64_t now;",
          "6856:   mg_iotest(mgr, ms);",
          "6857:   now = mg_millis();",
          "6858:   mg_timer_poll(&mgr->timers, now);",
          "6860:   for (c = mgr->conns; c != NULL; c = tmp) {",
          "6861:     bool is_resp = c->is_resp;",
          "6862:     tmp = c->next;",
          "6863:     mg_call(c, MG_EV_POLL, &now);",
          "6864:     if (is_resp && !c->is_resp) {",
          "6865:       long n = 0;",
          "6866:       mg_call(c, MG_EV_READ, &n);",
          "6867:     }",
          "6868:     MG_VERBOSE((\"%lu %c%c %c%c%c%c%c\", c->id, c->is_readable ? 'r' : '-',",
          "6869:                 c->is_writable ? 'w' : '-', c->is_tls ? 'T' : 't',",
          "6870:                 c->is_connecting ? 'C' : 'c', c->is_tls_hs ? 'H' : 'h',",
          "6871:                 c->is_resolving ? 'R' : 'r', c->is_closing ? 'C' : 'c'));",
          "6872:     if (c->is_resolving || c->is_closing) {",
          "6874:     } else if (c->is_listening && c->is_udp == 0) {",
          "6875:       if (c->is_readable) accept_conn(mgr, c);",
          "6876:     } else if (c->is_connecting) {",
          "6877:       if (c->is_readable || c->is_writable) connect_conn(c);",
          "6878:     } else if (c->is_tls_hs) {",
          "6879:       if ((c->is_readable || c->is_writable)) mg_tls_handshake(c);",
          "6881:       if (c->is_readable) read_conn(c);",
          "6882:       if (c->is_writable) write_conn(c);",
          "6885:     if (c->is_draining && c->send.len == 0) c->is_closing = 1;",
          "6886:     if (c->is_closing) close_conn(c);",
          "6892: #line 1 \"src/ssi.c\"",
          "6898: #ifndef MG_MAX_SSI_DEPTH",
          "6899: #define MG_MAX_SSI_DEPTH 5",
          "6900: #endif",
          "6902: #ifndef MG_SSI_BUFSIZ",
          "6903: #define MG_SSI_BUFSIZ 1024",
          "6904: #endif",
          "6906: #if MG_ENABLE_SSI",
          "6907: static char *mg_ssi(const char *path, const char *root, int depth) {",
          "6908:   struct mg_iobuf b = {NULL, 0, 0, MG_IO_SIZE};",
          "6909:   FILE *fp = fopen(path, \"rb\");",
          "6910:   if (fp != NULL) {",
          "6911:     char buf[MG_SSI_BUFSIZ], arg[sizeof(buf)];",
          "6912:     int ch, intag = 0;",
          "6913:     size_t len = 0;",
          "6914:     buf[0] = arg[0] = '\\0';",
          "6915:     while ((ch = fgetc(fp)) != EOF) {",
          "6916:       if (intag && ch == '>' && buf[len - 1] == '-' && buf[len - 2] == '-') {",
          "6917:         buf[len++] = (char) (ch & 0xff);",
          "6918:         buf[len] = '\\0';",
          "6919:         if (sscanf(buf, \"<!--#include file=\\\"%[^\\\"]\", arg)) {",
          "6920:           char tmp[MG_PATH_MAX + MG_SSI_BUFSIZ + 10],",
          "6922:           while (p > path && p[-1] != MG_DIRSEP && p[-1] != '/') p--;",
          "6923:           mg_snprintf(tmp, sizeof(tmp), \"%.*s%s\", (int) (p - path), path, arg);",
          "6924:           if (depth < MG_MAX_SSI_DEPTH &&",
          "6925:               (data = mg_ssi(tmp, root, depth + 1)) != NULL) {",
          "6926:             mg_iobuf_add(&b, b.len, data, strlen(data));",
          "6927:             free(data);",
          "6928:           } else {",
          "6929:             MG_ERROR((\"%s: file=%s error or too deep\", path, arg));",
          "6930:           }",
          "6931:         } else if (sscanf(buf, \"<!--#include virtual=\\\"%[^\\\"]\", arg)) {",
          "6932:           char tmp[MG_PATH_MAX + MG_SSI_BUFSIZ + 10], *data;",
          "6933:           mg_snprintf(tmp, sizeof(tmp), \"%s%s\", root, arg);",
          "6934:           if (depth < MG_MAX_SSI_DEPTH &&",
          "6935:               (data = mg_ssi(tmp, root, depth + 1)) != NULL) {",
          "6936:             mg_iobuf_add(&b, b.len, data, strlen(data));",
          "6937:             free(data);",
          "6938:           } else {",
          "6939:             MG_ERROR((\"%s: virtual=%s error or too deep\", path, arg));",
          "6940:           }",
          "6941:         } else {",
          "6943:           MG_ERROR((\"Unknown SSI tag: %.*s\", (int) len, buf));",
          "6944:           mg_iobuf_add(&b, b.len, buf, len);",
          "6945:         }",
          "6946:         intag = 0;",
          "6947:         len = 0;",
          "6948:       } else if (ch == '<') {",
          "6949:         intag = 1;",
          "6950:         if (len > 0) mg_iobuf_add(&b, b.len, buf, len);",
          "6951:         len = 0;",
          "6952:         buf[len++] = (char) (ch & 0xff);",
          "6953:       } else if (intag) {",
          "6954:         if (len == 5 && strncmp(buf, \"<!--#\", 5) != 0) {",
          "6955:           intag = 0;",
          "6956:         } else if (len >= sizeof(buf) - 2) {",
          "6957:           MG_ERROR((\"%s: SSI tag is too large\", path));",
          "6958:           len = 0;",
          "6959:         }",
          "6960:         buf[len++] = (char) (ch & 0xff);",
          "6961:       } else {",
          "6962:         buf[len++] = (char) (ch & 0xff);",
          "6963:         if (len >= sizeof(buf)) {",
          "6964:           mg_iobuf_add(&b, b.len, buf, len);",
          "6965:           len = 0;",
          "6966:         }",
          "6967:       }",
          "6969:     if (len > 0) mg_iobuf_add(&b, b.len, buf, len);",
          "6970:     if (b.len > 0) mg_iobuf_add(&b, b.len, \"\", 1);  // nul-terminate",
          "6971:     fclose(fp);",
          "6973:   (void) depth;",
          "6974:   (void) root;",
          "6975:   return (char *) b.buf;",
          "6978: void mg_http_serve_ssi(struct mg_connection *c, const char *root,",
          "6979:                        const char *fullpath) {",
          "6980:   const char *headers = \"Content-Type: text/html; charset=utf-8\\r\\n\";",
          "6981:   char *data = mg_ssi(fullpath, root, 0);",
          "6982:   mg_http_reply(c, 200, headers, \"%s\", data == NULL ? \"\" : data);",
          "6983:   free(data);",
          "6985: #else",
          "6986: void mg_http_serve_ssi(struct mg_connection *c, const char *root,",
          "6987:                        const char *fullpath) {",
          "6988:   mg_http_reply(c, 501, NULL, \"SSI not enabled\");",
          "6989:   (void) root, (void) fullpath;",
          "6994: #line 1 \"src/str.c\"",
          "6998: struct mg_str mg_str_s(const char *s) {",
          "6999:   struct mg_str str = {s, s == NULL ? 0 : strlen(s)};",
          "7000:   return str;",
          "7001: }",
          "7003: struct mg_str mg_str_n(const char *s, size_t n) {",
          "7004:   struct mg_str str = {s, n};",
          "7005:   return str;",
          "7006: }",
          "7008: int mg_lower(const char *s) {",
          "7009:   int c = *s;",
          "7010:   if (c >= 'A' && c <= 'Z') c += 'a' - 'A';",
          "7011:   return c;",
          "7014: int mg_ncasecmp(const char *s1, const char *s2, size_t len) {",
          "7015:   int diff = 0;",
          "7016:   if (len > 0) do {",
          "7017:       diff = mg_lower(s1++) - mg_lower(s2++);",
          "7018:     } while (diff == 0 && s1[-1] != '\\0' && --len > 0);",
          "7019:   return diff;",
          "7022: int mg_casecmp(const char *s1, const char *s2) {",
          "7023:   return mg_ncasecmp(s1, s2, (size_t) ~0);",
          "7026: int mg_vcmp(const struct mg_str *s1, const char *s2) {",
          "7027:   size_t n2 = strlen(s2), n1 = s1->len;",
          "7028:   int r = strncmp(s1->ptr, s2, (n1 < n2) ? n1 : n2);",
          "7029:   if (r == 0) return (int) (n1 - n2);",
          "7030:   return r;",
          "7033: int mg_vcasecmp(const struct mg_str *str1, const char *str2) {",
          "7034:   size_t n2 = strlen(str2), n1 = str1->len;",
          "7035:   int r = mg_ncasecmp(str1->ptr, str2, (n1 < n2) ? n1 : n2);",
          "7036:   if (r == 0) return (int) (n1 - n2);",
          "7037:   return r;",
          "7040: struct mg_str mg_strdup(const struct mg_str s) {",
          "7041:   struct mg_str r = {NULL, 0};",
          "7042:   if (s.len > 0 && s.ptr != NULL) {",
          "7043:     char *sc = (char *) calloc(1, s.len + 1);",
          "7044:     if (sc != NULL) {",
          "7045:       memcpy(sc, s.ptr, s.len);",
          "7046:       sc[s.len] = '\\0';",
          "7047:       r.ptr = sc;",
          "7048:       r.len = s.len;",
          "7049:     }",
          "7051:   return r;",
          "7054: int mg_strcmp(const struct mg_str str1, const struct mg_str str2) {",
          "7055:   size_t i = 0;",
          "7056:   while (i < str1.len && i < str2.len) {",
          "7057:     int c1 = str1.ptr[i];",
          "7058:     int c2 = str2.ptr[i];",
          "7059:     if (c1 < c2) return -1;",
          "7060:     if (c1 > c2) return 1;",
          "7061:     i++;",
          "7062:   }",
          "7063:   if (i < str1.len) return 1;",
          "7064:   if (i < str2.len) return -1;",
          "7065:   return 0;",
          "7068: const char *mg_strstr(const struct mg_str haystack,",
          "7069:                       const struct mg_str needle) {",
          "7070:   size_t i;",
          "7071:   if (needle.len > haystack.len) return NULL;",
          "7072:   if (needle.len == 0) return haystack.ptr;",
          "7073:   for (i = 0; i <= haystack.len - needle.len; i++) {",
          "7074:     if (memcmp(haystack.ptr + i, needle.ptr, needle.len) == 0) {",
          "7075:       return haystack.ptr + i;",
          "7076:     }",
          "7077:   }",
          "7078:   return NULL;",
          "7081: static bool is_space(int c) {",
          "7082:   return c == ' ' || c == '\\r' || c == '\\n' || c == '\\t';",
          "7085: struct mg_str mg_strstrip(struct mg_str s) {",
          "7086:   while (s.len > 0 && is_space((int) *s.ptr)) s.ptr++, s.len--;",
          "7087:   while (s.len > 0 && is_space((int) *(s.ptr + s.len - 1))) s.len--;",
          "7088:   return s;",
          "7091: bool mg_match(struct mg_str s, struct mg_str p, struct mg_str *caps) {",
          "7092:   size_t i = 0, j = 0, ni = 0, nj = 0;",
          "7093:   if (caps) caps->ptr = NULL, caps->len = 0;",
          "7094:   while (i < p.len || j < s.len) {",
          "7095:     if (i < p.len && j < s.len && (p.ptr[i] == '?' || s.ptr[j] == p.ptr[i])) {",
          "7096:       if (caps == NULL) {",
          "7097:       } else if (p.ptr[i] == '?') {",
          "7098:         caps->ptr = &s.ptr[j], caps->len = 1;     // Finalize `?` cap",
          "7099:         caps++, caps->ptr = NULL, caps->len = 0;  // Init next cap",
          "7100:       } else if (caps->ptr != NULL && caps->len == 0) {",
          "7101:         caps->len = (size_t) (&s.ptr[j] - caps->ptr);  // Finalize current cap",
          "7102:         caps++, caps->len = 0, caps->ptr = NULL;       // Init next cap",
          "7103:       }",
          "7104:       i++, j++;",
          "7105:     } else if (i < p.len && (p.ptr[i] == '*' || p.ptr[i] == '#')) {",
          "7106:       if (caps && !caps->ptr) caps->len = 0, caps->ptr = &s.ptr[j];  // Init cap",
          "7107:       ni = i++, nj = j + 1;",
          "7108:     } else if (nj > 0 && nj <= s.len && (p.ptr[ni] == '#' || s.ptr[j] != '/')) {",
          "7109:       i = ni, j = nj;",
          "7110:       if (caps && caps->ptr == NULL && caps->len == 0) {",
          "7111:         caps--, caps->len = 0;  // Restart previous cap",
          "7112:       }",
          "7113:     } else {",
          "7114:       return false;",
          "7115:     }",
          "7116:   }",
          "7117:   if (caps && caps->ptr && caps->len == 0) {",
          "7118:     caps->len = (size_t) (&s.ptr[j] - caps->ptr);",
          "7119:   }",
          "7120:   return true;",
          "7123: bool mg_globmatch(const char *s1, size_t n1, const char *s2, size_t n2) {",
          "7124:   return mg_match(mg_str_n(s2, n2), mg_str_n(s1, n1), NULL);",
          "7127: static size_t mg_nce(const char *s, size_t n, size_t ofs, size_t *koff,",
          "7128:                      size_t *klen, size_t *voff, size_t *vlen, char delim) {",
          "7129:   size_t kvlen, kl;",
          "7130:   for (kvlen = 0; ofs + kvlen < n && s[ofs + kvlen] != delim;) kvlen++;",
          "7131:   for (kl = 0; kl < kvlen && s[ofs + kl] != '=';) kl++;",
          "7132:   if (koff != NULL) *koff = ofs;",
          "7133:   if (klen != NULL) *klen = kl;",
          "7134:   if (voff != NULL) *voff = kl < kvlen ? ofs + kl + 1 : 0;",
          "7135:   if (vlen != NULL) *vlen = kl < kvlen ? kvlen - kl - 1 : 0;",
          "7136:   ofs += kvlen + 1;",
          "7137:   return ofs > n ? n : ofs;",
          "7138: }",
          "7140: bool mg_split(struct mg_str *s, struct mg_str *k, struct mg_str *v, char sep) {",
          "7141:   size_t koff = 0, klen = 0, voff = 0, vlen = 0, off = 0;",
          "7142:   if (s->ptr == NULL || s->len == 0) return 0;",
          "7143:   off = mg_nce(s->ptr, s->len, 0, &koff, &klen, &voff, &vlen, sep);",
          "7144:   if (k != NULL) *k = mg_str_n(s->ptr + koff, klen);",
          "7145:   if (v != NULL) *v = mg_str_n(s->ptr + voff, vlen);",
          "7147:   return off > 0;",
          "7148: }",
          "7150: bool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v) {",
          "7151:   return mg_split(s, k, v, ',');",
          "7152: }",
          "7154: char *mg_hex(const void *buf, size_t len, char *to) {",
          "7155:   const unsigned char *p = (const unsigned char *) buf;",
          "7156:   const char *hex = \"0123456789abcdef\";",
          "7157:   size_t i = 0;",
          "7158:   for (; len--; p++) {",
          "7159:     to[i++] = hex[p[0] >> 4];",
          "7160:     to[i++] = hex[p[0] & 0x0f];",
          "7162:   to[i] = '\\0';",
          "7163:   return to;",
          "7166: static unsigned char mg_unhex_nimble(unsigned char c) {",
          "7167:   return (c >= '0' && c <= '9')   ? (unsigned char) (c - '0')",
          "7168:          : (c >= 'A' && c <= 'F') ? (unsigned char) (c - '7')",
          "7169:                                   : (unsigned char) (c - 'W');",
          "7172: unsigned long mg_unhexn(const char *s, size_t len) {",
          "7173:   unsigned long i = 0, v = 0;",
          "7174:   for (i = 0; i < len; i++) v <<= 4, v |= mg_unhex_nimble(((uint8_t *) s)[i]);",
          "7175:   return v;",
          "7176: }",
          "7178: void mg_unhex(const char *buf, size_t len, unsigned char *to) {",
          "7179:   size_t i;",
          "7180:   for (i = 0; i < len; i += 2) {",
          "7181:     to[i >> 1] = (unsigned char) mg_unhexn(&buf[i], 2);",
          "7185: bool mg_path_is_sane(const char *path) {",
          "7186:   const char *s = path;",
          "7187:   for (; s[0] != '\\0'; s++) {",
          "7188:     if (s == path || s[0] == '/' || s[0] == '\\\\') {  // Subdir?",
          "7189:       if (s[1] == '.' && s[2] == '.') return false;  // Starts with ..",
          "7190:     }",
          "7191:   }",
          "7192:   return true;",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1711: #endif",
          "",
          "[Removed Lines]",
          "1704: #define MG_SYS_NONE 0      // Dummy system",
          "1705: #define MG_SYS_STM32H5 1   // STM32 H5",
          "1706: #define MG_SYS_STM32H7 2   // STM32 H7",
          "1707: #define MG_SYS_CUSTOM 100  // Custom implementation",
          "1709: #ifndef MG_SYS",
          "1710: #define MG_SYS MG_SYS_NONE",
          "",
          "[Added Lines]",
          "1704: #define MG_DEVICE_NONE 0      // Dummy system",
          "1705: #define MG_DEVICE_STM32H5 1   // STM32 H5",
          "1706: #define MG_DEVICE_STM32H7 2   // STM32 H7",
          "1707: #define MG_DEVICE_CUSTOM 100  // Custom implementation",
          "1709: #ifndef MG_DEVICE",
          "1710: #define MG_DEVICE MG_DEVICE_NONE",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1727: bool mg_flash_load(void *sector, uint32_t key, void *buf, size_t len);",
          "1728: bool mg_flash_save(void *sector, uint32_t key, const void *buf, size_t len);",
          "",
          "[Removed Lines]",
          "1730: void mg_sys_reset(void);  // Reboot device immediately",
          "",
          "[Added Lines]",
          "1730: void mg_device_reset(void);  // Reboot device immediately",
          "",
          "---------------"
        ],
        "src/sys.h||src/device.h": [
          "File: src/sys.h -> src/device.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #include \"arch.h\"",
          "15: #endif",
          "",
          "[Removed Lines]",
          "8: #define MG_SYS_NONE 0      // Dummy system",
          "9: #define MG_SYS_STM32H5 1   // STM32 H5",
          "10: #define MG_SYS_STM32H7 2   // STM32 H7",
          "11: #define MG_SYS_CUSTOM 100  // Custom implementation",
          "13: #ifndef MG_SYS",
          "14: #define MG_SYS MG_SYS_NONE",
          "",
          "[Added Lines]",
          "8: #define MG_DEVICE_NONE 0      // Dummy system",
          "9: #define MG_DEVICE_STM32H5 1   // STM32 H5",
          "10: #define MG_DEVICE_STM32H7 2   // STM32 H7",
          "11: #define MG_DEVICE_CUSTOM 100  // Custom implementation",
          "13: #ifndef MG_DEVICE",
          "14: #define MG_DEVICE MG_DEVICE_NONE",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "31: bool mg_flash_load(void *sector, uint32_t key, void *buf, size_t len);",
          "32: bool mg_flash_save(void *sector, uint32_t key, const void *buf, size_t len);",
          "",
          "[Removed Lines]",
          "34: void mg_sys_reset(void);  // Reboot device immediately",
          "",
          "[Added Lines]",
          "34: void mg_device_reset(void);  // Reboot device immediately",
          "",
          "---------------"
        ],
        "src/sys_dummy.c||src/device_dummy.c": [
          "File: src/sys_dummy.c -> src/device_dummy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: void *mg_flash_start(void) {",
          "5:   return NULL;",
          "6: }",
          "",
          "[Removed Lines]",
          "1: #include \"sys.h\"",
          "3: #if MG_SYS == MG_SYS_NONE",
          "",
          "[Added Lines]",
          "1: #include \"device.h\"",
          "3: #if MG_DEVICE == MG_DEVICE_NONE",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "27:   (void) addr, (void) buf, (void) len;",
          "28:   return false;",
          "29: }",
          "31: }",
          "32: #endif",
          "",
          "[Removed Lines]",
          "30: void mg_sys_reset(void) {",
          "",
          "[Added Lines]",
          "30: void mg_device_reset(void) {",
          "",
          "---------------"
        ],
        "src/sys_flash.c||src/device_flash.c": [
          "File: src/sys_flash.c -> src/device_flash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: #include \"sys.h\"",
          "3: #if MG_SYS == MG_SYS_STM32H7 || MG_SYS == MG_SYS_STM32H5",
          "",
          "[Added Lines]",
          "1: #include \"device.h\"",
          "3: #if MG_DEVICE == MG_DEVICE_STM32H7 || MG_DEVICE == MG_DEVICE_STM32H5",
          "",
          "---------------"
        ],
        "src/sys_stm32h5.c||src/device_stm32h5.c": [
          "File: src/sys_stm32h5.c -> src/device_stm32h5.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"log.h\"",
          "6: #define FLASH_BASE 0x40022000          // Base address of the flash controller",
          "7: #define FLASH_KEYR (FLASH_BASE + 0x4)  // See RM0481 7.11",
          "",
          "[Removed Lines]",
          "2: #include \"sys.h\"",
          "4: #if MG_SYS == MG_SYS_STM32H5",
          "",
          "[Added Lines]",
          "2: #include \"device.h\"",
          "4: #if MG_DEVICE == MG_DEVICE_STM32H5",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "135:   return ok;",
          "136: }",
          "141: }",
          "",
          "[Removed Lines]",
          "138: void mg_sys_reset(void) {",
          "",
          "[Added Lines]",
          "138: void mg_device_reset(void) {",
          "",
          "---------------"
        ],
        "src/sys_stm32h7.c||src/device_stm32h7.c": [
          "File: src/sys_stm32h7.c -> src/device_stm32h7.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"log.h\"",
          "6: #define FLASH_BASE1 0x52002000  // Base address for bank1",
          "7: #define FLASH_BASE2 0x52002100  // Base address for bank2",
          "",
          "[Removed Lines]",
          "2: #include \"sys.h\"",
          "4: #if MG_SYS == MG_SYS_STM32H7",
          "",
          "[Added Lines]",
          "2: #include \"device.h\"",
          "4: #if MG_DEVICE == MG_DEVICE_STM32H7",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "141:   return ok;",
          "142: }",
          "147: }",
          "",
          "[Removed Lines]",
          "144: void mg_sys_reset(void) {",
          "",
          "[Added Lines]",
          "144: void mg_device_reset(void) {",
          "",
          "---------------"
        ],
        "src/ota_flash.c||src/ota_flash.c": [
          "File: src/ota_flash.c -> src/ota_flash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"arch.h\"",
          "2: #include \"log.h\"",
          "3: #include \"ota.h\"",
          "",
          "[Removed Lines]",
          "4: #include \"sys.h\"",
          "",
          "[Added Lines]",
          "4: #include \"device.h\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "26699914ccd4314903626afeb46621e066622fa0",
      "candidate_info": {
        "commit_hash": "26699914ccd4314903626afeb46621e066622fa0",
        "repo": "cesanta/mongoose",
        "commit_url": "https://github.com/cesanta/mongoose/commit/26699914ccd4314903626afeb46621e066622fa0",
        "files": [
          "mongoose.c",
          "mongoose.h",
          "src/http.c",
          "src/str.c",
          "src/str.h",
          "test/unit_test.c"
        ],
        "message": "improve negative Content-length handling",
        "before_after_code_files": [
          "mongoose.c||mongoose.c",
          "mongoose.h||mongoose.h",
          "src/http.c||src/http.c",
          "src/str.c||src/str.c",
          "src/str.h||src/str.h",
          "test/unit_test.c||test/unit_test.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ],
          "candidate": [
            "mongoose.c||mongoose.c",
            "src/http.c||src/http.c",
            "test/unit_test.c||test/unit_test.c"
          ]
        }
      },
      "candidate_diff": {
        "mongoose.c||mongoose.c": [
          "File: mongoose.c -> mongoose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1247: #define MG_DMARK ((size_t) 1 << (sizeof(size_t) * 8 - 1))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1246: bool mg_to_size_t(struct mg_str str, size_t *val);",
          "1247: bool mg_to_size_t(struct mg_str str, size_t *val) {",
          "1248:   uint64_t result = 0, max = 1844674407370955160 /* (UINT64_MAX-9)/10 */;",
          "1249:   size_t i = 0;",
          "1250:   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;",
          "1251:   if (i < str.len && str.ptr[i] == '-') return false;",
          "1252:   while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {",
          "1253:     if (result > max) return false;",
          "1254:     result *= 10;",
          "1255:     result += (unsigned) (str.ptr[i] - '0');",
          "1256:     i++;",
          "1257:   }",
          "1259:   return true;",
          "1260: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1382:   return i >= src_len && j < dst_len ? (int) j : -1;",
          "1383: }",
          "1387: int mg_http_get_request_len(const unsigned char *buf, size_t buf_len) {",
          "1388:   size_t i;",
          "",
          "[Removed Lines]",
          "1385: static bool isok(uint8_t c) { return c == '\\n' || c == '\\r' || c >= ' '; }",
          "",
          "[Added Lines]",
          "1401: static bool isok(uint8_t c) {",
          "1402:   return c == '\\n' || c == '\\r' || c >= ' ';",
          "1403: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1463:   mg_http_parse_headers(s, end, hm->headers,",
          "1464:                         sizeof(hm->headers) / sizeof(hm->headers[0]));",
          "1465:   if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {",
          "1469:     hm->message.len = (size_t) req_len + hm->body.len;",
          "1470:   }",
          "",
          "[Removed Lines]",
          "1466:     int64_t content_len = mg_to64(*cl);",
          "1467:     if(content_len < 0) return -1;",
          "1468:     hm->body.len = (size_t) content_len;",
          "",
          "[Added Lines]",
          "1484:     if (mg_to_size_t(*cl, &hm->body.len) == false) return -1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1662:   return mg_str(\"text/plain; charset=utf-8\");",
          "1663: }",
          "1666:   size_t i, numparsed = 0;",
          "1668:   for (i = 0; i + 6 < s->len; i++) {",
          "1669:     if (memcmp(&s->ptr[i], \"bytes=\", 6) == 0) {",
          "1670:       struct mg_str p = mg_str_n(s->ptr + i + 6, s->len - i - 6);",
          "1671:       if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;",
          "1674:       while (p.len && p.ptr[0] >= '0' && p.ptr[0] <= '9') p.ptr++, p.len--;",
          "1675:       if (p.len && p.ptr[0] == '-') p.ptr++, p.len--;",
          "1677:       if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;",
          "1679:       break;",
          "",
          "[Removed Lines]",
          "1665: static int getrange(struct mg_str *s, int64_t *a, int64_t *b) {",
          "",
          "[Added Lines]",
          "1681: static int getrange(struct mg_str *s, size_t *a, size_t *b) {",
          "1688:       if (!mg_to_size_t(p, a)) return 0;",
          "1692:       if (!mg_to_size_t(p, b)) return 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1725:   } else {",
          "1726:     int n, status = 200;",
          "1727:     char range[100];",
          "1731:     struct mg_str *rh = mg_http_get_header(hm, \"Range\");",
          "1732:     range[0] = '\\0';",
          "1735:       if (n == 1) r2 = cl - 1;",
          "1736:       if (r1 > r2 || r2 >= cl) {",
          "",
          "[Removed Lines]",
          "1728:     int64_t r1 = 0, r2 = 0, cl = (int64_t) size;",
          "1733:     if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0 && r1 >= 0 && r2 >= 0) {",
          "",
          "[Added Lines]",
          "1744:     size_t r1 = 0, r2 = 0, cl = size;",
          "1749:     if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1742:         status = 206;",
          "1743:         cl = r2 - r1 + 1;",
          "1744:         mg_snprintf(range, sizeof(range),",
          "1748:       }",
          "1749:     }",
          "1750:     mg_printf(c,",
          "",
          "[Removed Lines]",
          "1745:                     \"Content-Range: bytes %lld-%lld/%lld\\r\\n\", r1, r1 + cl - 1,",
          "1746:                     (int64_t) size);",
          "1747:         fs->sk(fd->fd, (size_t) r1);",
          "",
          "[Added Lines]",
          "1761:                     \"Content-Range: bytes %llu-%llu/%llu\\r\\n\", (uint64_t) r1,",
          "1762:                     (uint64_t) (r1 + cl - 1), (uint64_t) size);",
          "1763:         fs->sk(fd->fd, r1);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1754:               \"Content-Length: %llu\\r\\n\"",
          "1755:               \"%s%s%s\\r\\n\",",
          "1756:               status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,",
          "1759:     if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {",
          "1760:       c->is_draining = 1;",
          "1761:       c->is_resp = 0;",
          "",
          "[Removed Lines]",
          "1757:               etag, cl, gzip ? \"Content-Encoding: gzip\\r\\n\" : \"\", range,",
          "1758:               opts->extra_headers ? opts->extra_headers : \"\");",
          "",
          "[Added Lines]",
          "1773:               etag, (uint64_t) cl, gzip ? \"Content-Encoding: gzip\\r\\n\" : \"\",",
          "1774:               range, opts->extra_headers ? opts->extra_headers : \"\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "5307:   }",
          "5308: }",
          "5336: char *mg_remove_double_dots(char *s) {",
          "5337:   char *saved = s, *p = s;",
          "5338:   while (*s != '\\0') {",
          "",
          "[Removed Lines]",
          "5310: uint64_t mg_tou64(struct mg_str str) {",
          "5311:   uint64_t result = 0;",
          "5312:   size_t i = 0;",
          "5313:   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;",
          "5314:   while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {",
          "5315:     result *= 10;",
          "5316:     result += (unsigned) (str.ptr[i] - '0');",
          "5317:     i++;",
          "5318:   }",
          "5319:   return result;",
          "5320: }",
          "5322: int64_t mg_to64(struct mg_str str) {",
          "5323:   int64_t result = 0, neg = 1, max = 922337203685477570 /* INT64_MAX/10-10 */;",
          "5324:   size_t i = 0;",
          "5325:   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;",
          "5326:   if (i < str.len && str.ptr[i] == '-') neg = -1, i++;",
          "5327:   while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {",
          "5328:     if (result > max) return 0;",
          "5329:     result *= 10;",
          "5330:     result += (str.ptr[i] - '0');",
          "5331:     i++;",
          "5332:   }",
          "5333:   return result * neg;",
          "5334: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "mongoose.h||mongoose.h": [
          "File: mongoose.h -> mongoose.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "825: void mg_unhex(const char *buf, size_t len, unsigned char *to);",
          "826: unsigned long mg_unhexn(const char *s, size_t len);",
          "827: int mg_check_ip_acl(struct mg_str acl, uint32_t remote_ip);",
          "830: char *mg_remove_double_dots(char *s);",
          "",
          "[Removed Lines]",
          "828: int64_t mg_to64(struct mg_str str);",
          "829: uint64_t mg_tou64(struct mg_str str);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/http.c||src/http.c": [
          "File: src/http.c -> src/http.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"arch.h\"",
          "2: #include \"base64.h\"",
          "3: #include \"fmt.h\"",
          "5: #include \"json.h\"",
          "6: #include \"log.h\"",
          "7: #include \"net.h\"",
          "",
          "[Removed Lines]",
          "4: #include \"http.h\"",
          "",
          "[Added Lines]",
          "1: #include \"http.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "11: #include \"version.h\"",
          "12: #include \"ws.h\"",
          "15: #define MG_DMARK ((size_t) 1 << (sizeof(size_t) * 8 - 1))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: bool mg_to_size_t(struct mg_str str, size_t *val);",
          "15: bool mg_to_size_t(struct mg_str str, size_t *val) {",
          "16:   uint64_t result = 0, max = 1844674407370955160 /* (UINT64_MAX-9)/10 */;",
          "17:   size_t i = 0;",
          "18:   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;",
          "19:   if (i < str.len && str.ptr[i] == '-') return false;",
          "20:   while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {",
          "21:     if (result > max) return false;",
          "22:     result *= 10;",
          "23:     result += (unsigned) (str.ptr[i] - '0');",
          "24:     i++;",
          "25:   }",
          "27:   return true;",
          "28: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "150:   return i >= src_len && j < dst_len ? (int) j : -1;",
          "151: }",
          "155: int mg_http_get_request_len(const unsigned char *buf, size_t buf_len) {",
          "156:   size_t i;",
          "",
          "[Removed Lines]",
          "153: static bool isok(uint8_t c) { return c == '\\n' || c == '\\r' || c >= ' '; }",
          "",
          "[Added Lines]",
          "169: static bool isok(uint8_t c) {",
          "170:   return c == '\\n' || c == '\\r' || c >= ' ';",
          "171: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "231:   mg_http_parse_headers(s, end, hm->headers,",
          "232:                         sizeof(hm->headers) / sizeof(hm->headers[0]));",
          "233:   if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {",
          "237:     hm->message.len = (size_t) req_len + hm->body.len;",
          "238:   }",
          "",
          "[Removed Lines]",
          "234:     int64_t content_len = mg_to64(*cl);",
          "235:     if(content_len < 0) return -1;",
          "236:     hm->body.len = (size_t) content_len;",
          "",
          "[Added Lines]",
          "252:     if (mg_to_size_t(*cl, &hm->body.len) == false) return -1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "430:   return mg_str(\"text/plain; charset=utf-8\");",
          "431: }",
          "434:   size_t i, numparsed = 0;",
          "436:   for (i = 0; i + 6 < s->len; i++) {",
          "437:     if (memcmp(&s->ptr[i], \"bytes=\", 6) == 0) {",
          "438:       struct mg_str p = mg_str_n(s->ptr + i + 6, s->len - i - 6);",
          "439:       if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;",
          "442:       while (p.len && p.ptr[0] >= '0' && p.ptr[0] <= '9') p.ptr++, p.len--;",
          "443:       if (p.len && p.ptr[0] == '-') p.ptr++, p.len--;",
          "445:       if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;",
          "447:       break;",
          "",
          "[Removed Lines]",
          "433: static int getrange(struct mg_str *s, int64_t *a, int64_t *b) {",
          "",
          "[Added Lines]",
          "449: static int getrange(struct mg_str *s, size_t *a, size_t *b) {",
          "456:       if (!mg_to_size_t(p, a)) return 0;",
          "460:       if (!mg_to_size_t(p, b)) return 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "493:   } else {",
          "494:     int n, status = 200;",
          "495:     char range[100];",
          "499:     struct mg_str *rh = mg_http_get_header(hm, \"Range\");",
          "500:     range[0] = '\\0';",
          "503:       if (n == 1) r2 = cl - 1;",
          "504:       if (r1 > r2 || r2 >= cl) {",
          "",
          "[Removed Lines]",
          "496:     int64_t r1 = 0, r2 = 0, cl = (int64_t) size;",
          "501:     if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0 && r1 >= 0 && r2 >= 0) {",
          "",
          "[Added Lines]",
          "512:     size_t r1 = 0, r2 = 0, cl = size;",
          "517:     if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "510:         status = 206;",
          "511:         cl = r2 - r1 + 1;",
          "512:         mg_snprintf(range, sizeof(range),",
          "516:       }",
          "517:     }",
          "518:     mg_printf(c,",
          "",
          "[Removed Lines]",
          "513:                     \"Content-Range: bytes %lld-%lld/%lld\\r\\n\", r1, r1 + cl - 1,",
          "514:                     (int64_t) size);",
          "515:         fs->sk(fd->fd, (size_t) r1);",
          "",
          "[Added Lines]",
          "529:                     \"Content-Range: bytes %llu-%llu/%llu\\r\\n\", (uint64_t) r1,",
          "530:                     (uint64_t) (r1 + cl - 1), (uint64_t) size);",
          "531:         fs->sk(fd->fd, r1);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "522:               \"Content-Length: %llu\\r\\n\"",
          "523:               \"%s%s%s\\r\\n\",",
          "524:               status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,",
          "527:     if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {",
          "528:       c->is_draining = 1;",
          "529:       c->is_resp = 0;",
          "",
          "[Removed Lines]",
          "525:               etag, cl, gzip ? \"Content-Encoding: gzip\\r\\n\" : \"\", range,",
          "526:               opts->extra_headers ? opts->extra_headers : \"\");",
          "",
          "[Added Lines]",
          "541:               etag, (uint64_t) cl, gzip ? \"Content-Encoding: gzip\\r\\n\" : \"\",",
          "542:               range, opts->extra_headers ? opts->extra_headers : \"\");",
          "",
          "---------------"
        ],
        "src/str.c||src/str.c": [
          "File: src/str.c -> src/str.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "187:   }",
          "188: }",
          "216: char *mg_remove_double_dots(char *s) {",
          "217:   char *saved = s, *p = s;",
          "218:   while (*s != '\\0') {",
          "",
          "[Removed Lines]",
          "190: uint64_t mg_tou64(struct mg_str str) {",
          "191:   uint64_t result = 0;",
          "192:   size_t i = 0;",
          "193:   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;",
          "194:   while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {",
          "195:     result *= 10;",
          "196:     result += (unsigned) (str.ptr[i] - '0');",
          "197:     i++;",
          "198:   }",
          "199:   return result;",
          "200: }",
          "202: int64_t mg_to64(struct mg_str str) {",
          "203:   int64_t result = 0, neg = 1, max = 922337203685477570 /* INT64_MAX/10-10 */;",
          "204:   size_t i = 0;",
          "205:   while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;",
          "206:   if (i < str.len && str.ptr[i] == '-') neg = -1, i++;",
          "207:   while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {",
          "208:     if (result > max) return 0;",
          "209:     result *= 10;",
          "210:     result += (str.ptr[i] - '0');",
          "211:     i++;",
          "212:   }",
          "213:   return result * neg;",
          "214: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/str.h||src/str.h": [
          "File: src/str.h -> src/str.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: void mg_unhex(const char *buf, size_t len, unsigned char *to);",
          "36: unsigned long mg_unhexn(const char *s, size_t len);",
          "37: int mg_check_ip_acl(struct mg_str acl, uint32_t remote_ip);",
          "40: char *mg_remove_double_dots(char *s);",
          "",
          "[Removed Lines]",
          "38: int64_t mg_to64(struct mg_str str);",
          "39: uint64_t mg_tou64(struct mg_str str);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/unit_test.c||test/unit_test.c": [
          "File: test/unit_test.c -> test/unit_test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "790:   ASSERT(fetch(&mgr, buf, url, \"GET /..ddot HTTP/1.0\\n\\n\") == 301);",
          "791:   ASSERT(fetch(&mgr, buf, url, \"GET /..ddot/ HTTP/1.0\\n\\n\") == 200);",
          "792:   ASSERT(cmpbody(buf, \"hi\\n\") == 0);",
          "796:                \"Content-Length: -123\\n\\n\") == 0);",
          "798:   {",
          "799:     extern char *mg_http_etag(char *, size_t, size_t, time_t);",
          "",
          "[Removed Lines]",
          "793:   ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\"",
          "794:         \"Content-Length: -123\\n\\n\") == 0);",
          "795:   ASSERT(fetch(&mgr, buf, url, \"POST /a.txt HTTP/1.0\\n\"",
          "",
          "[Added Lines]",
          "793:   ASSERT(fetch(&mgr, buf, url,",
          "794:                \"GET /a.txt HTTP/1.0\\n\"",
          "795:                \"Content-Length: -123\\n\\n\") == 0);",
          "796:   ASSERT(fetch(&mgr, buf, url,",
          "797:                \"POST /a.txt HTTP/1.0\\n\"",
          "799:   ASSERT(fetch(&mgr, buf, url,",
          "800:                \"GET /a.txt HTTP/1.0\\n\"",
          "801:                \"Content-Length: 19000000000000000000\\n\\n\") == 0);",
          "802:   ASSERT(fetch(&mgr, buf, url,",
          "803:                \"POST /a.txt HTTP/1.0\\n\"",
          "804:                \"Content-Length: 19000000000000000000\\n\\n\") == 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1405:   ASSERT(mgr.conns == NULL);",
          "1406: }",
          "1410: static void test_timer(void) {",
          "1411:   int v1 = 0, v2 = 0, v3 = 0;",
          "",
          "[Removed Lines]",
          "1408: static void f1(void *arg) { (*(int *) arg)++; }",
          "",
          "[Added Lines]",
          "1416: static void f1(void *arg) {",
          "1417:   (*(int *) arg)++;",
          "1418: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1964:     free(s);",
          "1965:   }",
          "1976:   {",
          "1977:     size_t i;",
          "",
          "[Removed Lines]",
          "1967:   ASSERT(mg_to64(mg_str(\"-9223372036854775809\")) == 0);",
          "1968:   ASSERT(mg_to64(mg_str(\"9223372036854775800\")) == 0);",
          "1969:   ASSERT(mg_to64(mg_str(\"9223372036854775700\")) > 0);",
          "1970:   ASSERT(mg_tou64(mg_str(\"0\")) == 0);",
          "1971:   ASSERT(mg_tou64(mg_str(\"123\")) == 123);",
          "1972:   ASSERT(mg_tou64(mg_str(\"\")) == 0);",
          "1973:   ASSERT(mg_tou64(mg_str(\"-\")) == 0);",
          "1974:   ASSERT(mg_tou64(mg_str(\"18446744073709551615\")) == 18446744073709551615U);",
          "",
          "[Added Lines]",
          "1977:   {",
          "1978:     extern bool mg_to_size_t(struct mg_str, size_t *);",
          "1979:     size_t val = 1;",
          "1980:     ASSERT(mg_to_size_t(mg_str(\"0\"), &val) && val == 0);",
          "1981:     ASSERT(mg_to_size_t(mg_str(\"123\"), &val) && val == 123);",
          "1982:     ASSERT(mg_to_size_t(mg_str(\"\"), &val) && val == 0);",
          "1983:     ASSERT(mg_to_size_t(mg_str(\"-\"), &val) == false);",
          "1984:     ASSERT(mg_to_size_t(mg_str(\"18446744073709551616\"), &val) ==",
          "1985:            false);  // range +1",
          "1986:     ASSERT(mg_to_size_t(mg_str(\"18446744073709551610\"), &val) == false);",
          "1989:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2863:   pthread_attr_destroy(&attr);",
          "2864: }",
          "2865: #else",
          "2867: #endif",
          "2869: static void test_queue(void) {",
          "",
          "[Removed Lines]",
          "2866: static void start_thread(void (*f)(void *), void *p) { (void) f, (void) p; }",
          "",
          "[Added Lines]",
          "2881: static void start_thread(void (*f)(void *), void *p) {",
          "2882:   (void) f, (void) p;",
          "2883: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
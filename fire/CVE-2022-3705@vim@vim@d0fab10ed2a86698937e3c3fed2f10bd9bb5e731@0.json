{
  "cve_id": "CVE-2022-3705",
  "cve_desc": "A vulnerability was found in vim and classified as problematic. Affected by this issue is the function qf_update_buffer of the file quickfix.c of the component autocmd Handler. The manipulation leads to use after free. The attack may be launched remotely. Upgrading to version 9.0.0805 is able to address this issue. The name of the patch is d0fab10ed2a86698937e3c3fed2f10bd9bb5e731. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-212324.",
  "repo": "vim/vim",
  "patch_hash": "d0fab10ed2a86698937e3c3fed2f10bd9bb5e731",
  "patch_info": {
    "commit_hash": "d0fab10ed2a86698937e3c3fed2f10bd9bb5e731",
    "repo": "vim/vim",
    "commit_url": "https://github.com/vim/vim/commit/d0fab10ed2a86698937e3c3fed2f10bd9bb5e731",
    "files": [
      "src/quickfix.c",
      "src/testdir/test_quickfix.vim",
      "src/version.c"
    ],
    "message": "patch 9.0.0805: filetype autocmd may cause freed memory access\n\nProblem:    Filetype autocmd may cause freed memory access.\nSolution:   Set the quickfix-busy flag while filling the buffer.",
    "before_after_code_files": [
      "src/quickfix.c||src/quickfix.c",
      "src/testdir/test_quickfix.vim||src/testdir/test_quickfix.vim",
      "src/version.c||src/version.c"
    ]
  },
  "patch_diff": {
    "src/quickfix.c||src/quickfix.c": [
      "File: src/quickfix.c -> src/quickfix.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4595:      qf_winid = win->w_id;",
      "4596:  }",
      "4598:  if (old_last == NULL)",
      "4600:      aucmd_prepbuf(&aco, buf);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4599:  incr_quickfix_busy();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4617:  if ((win = qf_find_win(qi)) != NULL && old_line_count < win->w_botline)",
      "4618:      redraw_buf_later(buf, UPD_NOT_VALID);",
      "4619:     }",
      "4620: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4624:  decr_quickfix_busy();",
      "",
      "---------------"
    ],
    "src/testdir/test_quickfix.vim||src/testdir/test_quickfix.vim": [
      "File: src/testdir/test_quickfix.vim -> src/testdir/test_quickfix.vim",
      "--- Hunk 1 ---",
      "[Context before]",
      "3455:   endtry",
      "3456: endfunc",
      "3458: func Test_vimgrep_with_textlock()",
      "3459:   new",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3458: func Test_filetype_autocmd()",
      "3459:   \" this changes the location list while it is in use to fill a buffer",
      "3460:   lexpr ''",
      "3461:   lopen",
      "3462:   augroup FT_loclist",
      "3463:     au FileType * call setloclist(0, [], 'f')",
      "3464:   augroup END",
      "3465:   silent! lolder",
      "3466:   lexpr ''",
      "3468:   augroup FT_loclist",
      "3469:     au! FileType",
      "3470:   augroup END",
      "3471: endfunc",
      "",
      "---------------"
    ],
    "src/version.c||src/version.c": [
      "File: src/version.c -> src/version.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "696: static int included_patches[] =",
      "699:     804,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "699:     805,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f97a295ccaa9803367f3714cdefce4e2283c771d",
      "candidate_info": {
        "commit_hash": "f97a295ccaa9803367f3714cdefce4e2283c771d",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/f97a295ccaa9803367f3714cdefce4e2283c771d",
        "files": [
          "src/popupmenu.c",
          "src/popupwin.c",
          "src/profiler.c",
          "src/quickfix.c",
          "src/regexp.c",
          "src/regexp_bt.c",
          "src/regexp_nfa.c",
          "src/register.c",
          "src/version.c"
        ],
        "message": "patch 9.0.1221: code is indented more than necessary\n\nProblem:    Code is indented more than necessary.\nSolution:   Use an early return where it makes sense. (Yegappan Lakshmanan,\n            closes #11833)",
        "before_after_code_files": [
          "src/popupmenu.c||src/popupmenu.c",
          "src/popupwin.c||src/popupwin.c",
          "src/profiler.c||src/profiler.c",
          "src/quickfix.c||src/quickfix.c",
          "src/regexp.c||src/regexp.c",
          "src/regexp_bt.c||src/regexp_bt.c",
          "src/regexp_nfa.c||src/regexp_nfa.c",
          "src/register.c||src/register.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/quickfix.c||src/quickfix.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/quickfix.c||src/quickfix.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/popupmenu.c||src/popupmenu.c": [
          "File: src/popupmenu.c -> src/popupmenu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1367:     void",
          "1368: ui_remove_balloon(void)",
          "1369: {",
          "1377: }",
          "",
          "[Removed Lines]",
          "1370:     if (balloon_array != NULL)",
          "1371:     {",
          "1372:  pum_undisplay();",
          "1373:  while (balloon_arraysize > 0)",
          "1374:      vim_free(balloon_array[--balloon_arraysize].pum_text);",
          "1375:  VIM_CLEAR(balloon_array);",
          "1376:     }",
          "",
          "[Added Lines]",
          "1370:     if (balloon_array == NULL)",
          "1371:  return;",
          "1373:     pum_undisplay();",
          "1374:     while (balloon_arraysize > 0)",
          "1375:  vim_free(balloon_array[--balloon_arraysize].pum_text);",
          "1376:     VIM_CLEAR(balloon_array);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1410:     else",
          "1411:  balloon_arraysize = split_message(mesg, &balloon_array);",
          "1426: }",
          "",
          "[Removed Lines]",
          "1413:     if (balloon_arraysize > 0)",
          "1414:     {",
          "1415:  pum_array = balloon_array;",
          "1416:  pum_size = balloon_arraysize;",
          "1417:  pum_compute_size();",
          "1418:  pum_scrollbar = 0;",
          "1419:  pum_height = balloon_arraysize;",
          "1421:  pum_position_at_mouse(BALLOON_MIN_WIDTH);",
          "1422:  pum_selected = -1;",
          "1423:  pum_first = 0;",
          "1424:  pum_redraw();",
          "1425:     }",
          "",
          "[Added Lines]",
          "1413:     if (balloon_arraysize <= 0)",
          "1414:  return;",
          "1416:     pum_array = balloon_array;",
          "1417:     pum_size = balloon_arraysize;",
          "1418:     pum_compute_size();",
          "1419:     pum_scrollbar = 0;",
          "1420:     pum_height = balloon_arraysize;",
          "1422:     pum_position_at_mouse(BALLOON_MIN_WIDTH);",
          "1423:     pum_selected = -1;",
          "1424:     pum_first = 0;",
          "1425:     pum_redraw();",
          "",
          "---------------"
        ],
        "src/popupwin.c||src/popupwin.c": [
          "File: src/popupwin.c -> src/popupwin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "98:     dictitem_T *di;",
          "100:     di = dict_find(dict, (char_u *)name, -1);",
          "102:     {",
          "126:     }",
          "127: }",
          "",
          "[Removed Lines]",
          "101:     if (di != NULL)",
          "103:  if (di->di_tv.v_type != VAR_LIST)",
          "104:      emsg(_(e_list_required));",
          "105:  else",
          "106:  {",
          "107:      list_T *list = di->di_tv.vval.v_list;",
          "108:      listitem_T *li;",
          "109:      int  i;",
          "110:      int  nr;",
          "112:      for (i = 0; i < 4; ++i)",
          "113:   array[i] = 1;",
          "114:      if (list != NULL)",
          "115:      {",
          "116:   CHECK_LIST_MATERIALIZE(list);",
          "117:   for (i = 0, li = list->lv_first; i < 4 && i < list->lv_len;",
          "118:         ++i, li = li->li_next)",
          "119:   {",
          "120:       nr = (int)tv_get_number(&li->li_tv);",
          "121:       if (nr >= 0)",
          "122:    array[i] = nr > max_val ? max_val : nr;",
          "123:   }",
          "124:      }",
          "125:  }",
          "",
          "[Added Lines]",
          "101:     if (di == NULL)",
          "102:  return;",
          "104:     if (di->di_tv.v_type != VAR_LIST)",
          "106:  emsg(_(e_list_required));",
          "107:  return;",
          "108:     }",
          "110:     list_T *list = di->di_tv.vval.v_list;",
          "111:     listitem_T *li;",
          "112:     int  i;",
          "113:     int  nr;",
          "115:     for (i = 0; i < 4; ++i)",
          "116:  array[i] = 1;",
          "117:     if (list == NULL)",
          "118:  return;",
          "120:     CHECK_LIST_MATERIALIZE(list);",
          "121:     for (i = 0, li = list->lv_first; i < 4 && i < list->lv_len;",
          "122:      ++i, li = li->li_next)",
          "123:     {",
          "124:  nr = (int)tv_get_number(&li->li_tv);",
          "125:  if (nr >= 0)",
          "126:      array[i] = nr > max_val ? max_val : nr;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "147:     char_u *ptr;",
          "148:     int  len = find_ident_under_cursor(&ptr, flags | FIND_NOERROR);",
          "155: }",
          "",
          "[Removed Lines]",
          "150:     if (len > 0)",
          "151:     {",
          "152:  wp->w_popup_mincol = (int)(ptr - ml_get_curline());",
          "153:  wp->w_popup_maxcol = wp->w_popup_mincol + len - 1;",
          "154:     }",
          "",
          "[Added Lines]",
          "151:     if (len <= 0)",
          "152:  return;",
          "154:     wp->w_popup_mincol = (int)(ptr - ml_get_curline());",
          "155:     wp->w_popup_maxcol = wp->w_popup_mincol + len - 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "169: update_popup_uses_mouse_move(void)",
          "170: {",
          "171:     popup_uses_mouse_move = FALSE;",
          "189: }",
          "",
          "[Removed Lines]",
          "172:     if (popup_visible)",
          "173:     {",
          "174:  win_T *wp;",
          "176:  FOR_ALL_POPUPWINS(wp)",
          "177:      if (wp->w_popup_mouse_row != 0)",
          "178:      {",
          "179:   popup_uses_mouse_move = TRUE;",
          "180:   return;",
          "181:      }",
          "182:  FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)",
          "183:      if (wp->w_popup_mouse_row != 0)",
          "184:      {",
          "185:   popup_uses_mouse_move = TRUE;",
          "186:   return;",
          "187:      }",
          "188:     }",
          "",
          "[Added Lines]",
          "173:     if (!popup_visible)",
          "174:  return;",
          "176:     win_T *wp;",
          "178:     FOR_ALL_POPUPWINS(wp)",
          "179:  if (wp->w_popup_mouse_row != 0)",
          "180:  {",
          "181:      popup_uses_mouse_move = TRUE;",
          "182:      return;",
          "183:  }",
          "184:     FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)",
          "185:  if (wp->w_popup_mouse_row != 0)",
          "186:  {",
          "187:      popup_uses_mouse_move = TRUE;",
          "188:      return;",
          "189:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "201:     colnr_T mcol;",
          "203:     if (find_word_under_cursor(mouse_row, mouse_col, TRUE, flags,",
          "217: }",
          "",
          "[Removed Lines]",
          "204:       &textwp, &pos.lnum, &text, NULL, &col) == OK)",
          "205:     {",
          "207:  pos.col = col;",
          "208:  pos.coladd = 0;",
          "209:  getvcol(textwp, &pos, &mcol, NULL, NULL);",
          "210:  wp->w_popup_mouse_mincol = mcol;",
          "212:  pos.col = col + (colnr_T)STRLEN(text) - 1;",
          "213:  getvcol(textwp, &pos, NULL, NULL, &mcol);",
          "214:  wp->w_popup_mouse_maxcol = mcol;",
          "215:  vim_free(text);",
          "216:     }",
          "",
          "[Added Lines]",
          "205:       &textwp, &pos.lnum, &text, NULL, &col) != OK)",
          "206:  return;",
          "209:     pos.col = col;",
          "210:     pos.coladd = 0;",
          "211:     getvcol(textwp, &pos, &mcol, NULL, NULL);",
          "212:     wp->w_popup_mouse_mincol = mcol;",
          "214:     pos.col = col + (colnr_T)STRLEN(text) - 1;",
          "215:     getvcol(textwp, &pos, NULL, NULL, &mcol);",
          "216:     wp->w_popup_mouse_maxcol = mcol;",
          "217:     vim_free(text);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "390:     void",
          "391: popup_handle_scrollbar_click(win_T *wp, int row, int col)",
          "392: {",
          "394:     {",
          "399:  {",
          "403:  }",
          "408:  {",
          "425:  }",
          "426:     }",
          "427: }",
          "429: #if defined(FEAT_TIMERS)",
          "",
          "[Removed Lines]",
          "393:     if (popup_is_in_scrollbar(wp, row, col))",
          "395:  int     height = popup_height(wp);",
          "396:  int     new_topline = wp->w_topline;",
          "398:  if (row >= height / 2)",
          "401:      if (wp->w_topline < wp->w_buffer->b_ml.ml_line_count)",
          "402:   ++new_topline;",
          "404:  else if (wp->w_topline > 1)",
          "406:      --new_topline;",
          "407:  if (new_topline != wp->w_topline)",
          "409:      set_topline(wp, new_topline);",
          "410:      if (wp == curwin)",
          "411:      {",
          "412:   if (wp->w_cursor.lnum < wp->w_topline)",
          "413:   {",
          "414:       wp->w_cursor.lnum = wp->w_topline;",
          "415:       check_cursor();",
          "416:   }",
          "417:   else if (wp->w_cursor.lnum >= wp->w_botline)",
          "418:   {",
          "419:       wp->w_cursor.lnum = wp->w_botline - 1;",
          "420:       check_cursor();",
          "421:   }",
          "422:      }",
          "423:      popup_set_firstline(wp);",
          "424:      redraw_win_later(wp, UPD_NOT_VALID);",
          "",
          "[Added Lines]",
          "394:     if (!popup_is_in_scrollbar(wp, row, col))",
          "395:  return;",
          "397:     int     height = popup_height(wp);",
          "398:     int     new_topline = wp->w_topline;",
          "400:     if (row >= height / 2)",
          "403:  if (wp->w_topline < wp->w_buffer->b_ml.ml_line_count)",
          "404:      ++new_topline;",
          "405:     }",
          "406:     else if (wp->w_topline > 1)",
          "408:  --new_topline;",
          "410:     if (new_topline == wp->w_topline)",
          "411:  return;",
          "413:     set_topline(wp, new_topline);",
          "414:     if (wp == curwin)",
          "415:     {",
          "416:  if (wp->w_cursor.lnum < wp->w_topline)",
          "418:      wp->w_cursor.lnum = wp->w_topline;",
          "419:      check_cursor();",
          "421:  else if (wp->w_cursor.lnum >= wp->w_botline)",
          "423:      wp->w_cursor.lnum = wp->w_botline - 1;",
          "424:      check_cursor();",
          "427:     popup_set_firstline(wp);",
          "428:     redraw_win_later(wp, UPD_NOT_VALID);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "441:     vim_snprintf((char *)cbbuf, sizeof(cbbuf),",
          "442:   close ? \"(_) => popup_close(%d)\" : \"(_) => popup_hide(%d)\",",
          "443:   wp->w_id);",
          "445:     {",
          "455:     }",
          "456: }",
          "457: #endif",
          "",
          "[Removed Lines]",
          "444:     if (get_lambda_tv_and_compile(&ptr, &tv, FALSE, &EVALARG_EVALUATE) == OK)",
          "446:  wp->w_popup_timer = create_timer(time, 0);",
          "447:  callback_T cb = get_callback(&tv);",
          "448:  if (cb.cb_name != NULL && !cb.cb_free_name)",
          "449:  {",
          "450:      cb.cb_name = vim_strsave(cb.cb_name);",
          "451:      cb.cb_free_name = TRUE;",
          "452:  }",
          "453:  wp->w_popup_timer->tr_callback = cb;",
          "454:  clear_tv(&tv);",
          "",
          "[Added Lines]",
          "446:     if (get_lambda_tv_and_compile(&ptr, &tv, FALSE, &EVALARG_EVALUATE) != OK)",
          "447:  return;",
          "449:     wp->w_popup_timer = create_timer(time, 0);",
          "450:     callback_T cb = get_callback(&tv);",
          "451:     if (cb.cb_name != NULL && !cb.cb_free_name)",
          "453:  cb.cb_name = vim_strsave(cb.cb_name);",
          "454:  cb.cb_free_name = TRUE;",
          "456:     wp->w_popup_timer->tr_callback = cb;",
          "457:     clear_tv(&tv);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "619:     char_u *str;",
          "621:     di = dict_find(dict, (char_u *)name, -1);",
          "623:     {",
          "632:     }",
          "633: }",
          "",
          "[Removed Lines]",
          "622:     if (di != NULL)",
          "624:  if (di->di_tv.v_type != VAR_STRING)",
          "625:      semsg(_(e_invalid_value_for_argument_str), name);",
          "626:  else",
          "627:  {",
          "628:      str = tv_get_string(&di->di_tv);",
          "629:      if (*str != NUL)",
          "631:  }",
          "",
          "[Added Lines]",
          "624:     if (di == NULL)",
          "625:  return;",
          "627:     if (di->di_tv.v_type != VAR_STRING)",
          "628:  semsg(_(e_invalid_value_for_argument_str), name);",
          "629:     else",
          "631:  str = tv_get_string(&di->di_tv);",
          "632:  if (*str != NUL)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "990:     }",
          "992:     di = dict_find(dict, (char_u *)\"callback\", -1);",
          "1005: }",
          "",
          "[Removed Lines]",
          "993:     if (di != NULL)",
          "994:     {",
          "995:  callback_T callback = get_callback(&di->di_tv);",
          "997:  if (callback.cb_name != NULL)",
          "998:  {",
          "999:      free_callback(&wp->w_close_cb);",
          "1000:      set_callback(&wp->w_close_cb, &callback);",
          "1001:      if (callback.cb_free_name)",
          "1002:   vim_free(callback.cb_name);",
          "1003:  }",
          "1004:     }",
          "",
          "[Added Lines]",
          "995:     if (di == NULL)",
          "996:  return;",
          "998:     callback_T callback = get_callback(&di->di_tv);",
          "999:     if (callback.cb_name == NULL)",
          "1000:  return;",
          "1002:     free_callback(&wp->w_close_cb);",
          "1003:     set_callback(&wp->w_close_cb, &callback);",
          "1004:     if (callback.cb_free_name)",
          "1005:  vim_free(callback.cb_name);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2715:     if (error_if_term_popup_window())",
          "2716:  return;",
          "2717: #endif",
          "2725: }",
          "",
          "[Removed Lines]",
          "2718:     if ((wp->w_popup_flags & POPF_HIDDEN) == 0)",
          "2719:     {",
          "2720:  wp->w_popup_flags |= POPF_HIDDEN;",
          "2722:  redraw_all_later(UPD_NOT_VALID);",
          "2723:  popup_mask_refresh = TRUE;",
          "2724:     }",
          "",
          "[Added Lines]",
          "2719:     if ((wp->w_popup_flags & POPF_HIDDEN) != 0)",
          "2720:  return;",
          "2722:     wp->w_popup_flags |= POPF_HIDDEN;",
          "2724:     redraw_all_later(UPD_NOT_VALID);",
          "2725:     popup_mask_refresh = TRUE;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2739:     id = (int)tv_get_number(argvars);",
          "2740:     wp = find_popup_win(id);",
          "2746: }",
          "2748:     void",
          "2749: popup_show(win_T *wp)",
          "2750: {",
          "2757: }",
          "",
          "[Removed Lines]",
          "2741:     if (wp != NULL)",
          "2742:     {",
          "2743:  popup_hide(wp);",
          "2744:  wp->w_popup_flags |= POPF_HIDDEN_FORCE;",
          "2745:     }",
          "2751:     if ((wp->w_popup_flags & POPF_HIDDEN) != 0)",
          "2752:     {",
          "2753:  wp->w_popup_flags &= ~POPF_HIDDEN;",
          "2754:  redraw_all_later(UPD_NOT_VALID);",
          "2755:  popup_mask_refresh = TRUE;",
          "2756:     }",
          "",
          "[Added Lines]",
          "2742:     if (wp == NULL)",
          "2743:  return;",
          "2745:     popup_hide(wp);",
          "2746:     wp->w_popup_flags |= POPF_HIDDEN_FORCE;",
          "2752:     if ((wp->w_popup_flags & POPF_HIDDEN) == 0)",
          "2753:  return;",
          "2755:     wp->w_popup_flags &= ~POPF_HIDDEN;",
          "2756:     redraw_all_later(UPD_NOT_VALID);",
          "2757:     popup_mask_refresh = TRUE;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2771:     id = (int)tv_get_number(argvars);",
          "2772:     wp = find_popup_win(id);",
          "2777: #ifdef FEAT_QUICKFIX",
          "2780: #endif",
          "2782: }",
          "",
          "[Removed Lines]",
          "2773:     if (wp != NULL)",
          "2774:     {",
          "2775:  wp->w_popup_flags &= ~POPF_HIDDEN_FORCE;",
          "2776:  popup_show(wp);",
          "2778:  if (wp->w_popup_flags & POPF_INFO)",
          "2779:      pum_position_info_popup(wp);",
          "2781:     }",
          "",
          "[Added Lines]",
          "2774:     if (wp == NULL)",
          "2775:  return;",
          "2777:     wp->w_popup_flags &= ~POPF_HIDDEN_FORCE;",
          "2778:     popup_show(wp);",
          "2780:     if (wp->w_popup_flags & POPF_INFO)",
          "2781:  pum_position_info_popup(wp);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2798:     id = (int)tv_get_number(&argvars[0]);",
          "2799:     wp = find_popup_win(id);",
          "2809: }",
          "2811:     static void",
          "",
          "[Removed Lines]",
          "2800:     if (wp != NULL)",
          "2801:     {",
          "2802:  if (check_for_string_or_list_arg(argvars, 1) != FAIL)",
          "2803:  {",
          "2804:      popup_set_buffer_text(wp->w_buffer, argvars[1]);",
          "2805:      redraw_win_later(wp, UPD_NOT_VALID);",
          "2806:      popup_adjust_position(wp);",
          "2807:  }",
          "2808:     }",
          "",
          "[Added Lines]",
          "2801:     if (wp == NULL)",
          "2802:  return;",
          "2804:     if (check_for_string_or_list_arg(argvars, 1) == FAIL)",
          "2805:  return;",
          "2807:     popup_set_buffer_text(wp->w_buffer, argvars[1]);",
          "2808:     redraw_win_later(wp, UPD_NOT_VALID);",
          "2809:     popup_adjust_position(wp);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3011:     int  top_extra;",
          "3012:     int  left_extra;",
          "3050: }",
          "",
          "[Removed Lines]",
          "3014:     if (rettv_dict_alloc(rettv) == OK)",
          "3015:     {",
          "3016:  if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)",
          "3017:      return;",
          "3019:  id = (int)tv_get_number(argvars);",
          "3020:  wp = find_popup_win(id);",
          "3021:  if (wp == NULL)",
          "3022:      return;  // invalid {id}",
          "3023:  top_extra = popup_top_extra(wp);",
          "3024:  left_extra = wp->w_popup_border[3] + wp->w_popup_padding[3];",
          "3027:  dict = rettv->vval.v_dict;",
          "3028:  hash_lock_size(&dict->dv_hashtab, 11);",
          "3030:  dict_add_number(dict, \"line\", wp->w_winrow + 1);",
          "3031:  dict_add_number(dict, \"col\", wp->w_wincol + 1);",
          "3032:  dict_add_number(dict, \"width\", wp->w_width + left_extra",
          "3033:         + wp->w_popup_border[1] + wp->w_popup_padding[1]);",
          "3034:  dict_add_number(dict, \"height\", wp->w_height + top_extra",
          "3035:         + wp->w_popup_border[2] + wp->w_popup_padding[2]);",
          "3037:  dict_add_number(dict, \"core_line\", wp->w_winrow + 1 + top_extra);",
          "3038:  dict_add_number(dict, \"core_col\", wp->w_wincol + 1 + left_extra);",
          "3039:  dict_add_number(dict, \"core_width\", wp->w_width);",
          "3040:  dict_add_number(dict, \"core_height\", wp->w_height);",
          "3042:  dict_add_number(dict, \"scrollbar\", wp->w_has_scrollbar);",
          "3043:  dict_add_number(dict, \"firstline\", wp->w_topline);",
          "3044:  dict_add_number(dict, \"lastline\", wp->w_botline - 1);",
          "3045:  dict_add_number(dict, \"visible\",",
          "3046:         win_valid(wp) && (wp->w_popup_flags & POPF_HIDDEN) == 0);",
          "3048:  hash_unlock(&dict->dv_hashtab);",
          "3049:     }",
          "",
          "[Added Lines]",
          "3015:     if (rettv_dict_alloc(rettv) == FAIL)",
          "3016:  return;",
          "3018:     if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)",
          "3019:  return;",
          "3021:     id = (int)tv_get_number(argvars);",
          "3022:     wp = find_popup_win(id);",
          "3023:     if (wp == NULL)",
          "3024:  return;  // invalid {id}",
          "3025:     top_extra = popup_top_extra(wp);",
          "3026:     left_extra = wp->w_popup_border[3] + wp->w_popup_padding[3];",
          "3029:     dict = rettv->vval.v_dict;",
          "3030:     hash_lock_size(&dict->dv_hashtab, 11);",
          "3032:     dict_add_number(dict, \"line\", wp->w_winrow + 1);",
          "3033:     dict_add_number(dict, \"col\", wp->w_wincol + 1);",
          "3034:     dict_add_number(dict, \"width\", wp->w_width + left_extra",
          "3035:      + wp->w_popup_border[1] + wp->w_popup_padding[1]);",
          "3036:     dict_add_number(dict, \"height\", wp->w_height + top_extra",
          "3037:      + wp->w_popup_border[2] + wp->w_popup_padding[2]);",
          "3039:     dict_add_number(dict, \"core_line\", wp->w_winrow + 1 + top_extra);",
          "3040:     dict_add_number(dict, \"core_col\", wp->w_wincol + 1 + left_extra);",
          "3041:     dict_add_number(dict, \"core_width\", wp->w_width);",
          "3042:     dict_add_number(dict, \"core_height\", wp->w_height);",
          "3044:     dict_add_number(dict, \"scrollbar\", wp->w_has_scrollbar);",
          "3045:     dict_add_number(dict, \"firstline\", wp->w_topline);",
          "3046:     dict_add_number(dict, \"lastline\", wp->w_botline - 1);",
          "3047:     dict_add_number(dict, \"visible\",",
          "3048:      win_valid(wp) && (wp->w_popup_flags & POPF_HIDDEN) == 0);",
          "3050:     hash_unlock(&dict->dv_hashtab);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3102:  return;",
          "3104:     list = list_alloc();",
          "3112: }",
          "",
          "[Removed Lines]",
          "3105:     if (list != NULL)",
          "3106:     {",
          "3107:  dict_add_list(dict, name, list);",
          "3108:  if (array[0] != 1 || array[1] != 1 || array[2] != 1 || array[3] != 1)",
          "3109:      for (i = 0; i < 4; ++i)",
          "3110:   list_append_number(list, array[i]);",
          "3111:     }",
          "",
          "[Added Lines]",
          "3106:     if (list == NULL)",
          "3107:  return;",
          "3109:     dict_add_list(dict, name, list);",
          "3110:     if (array[0] != 1 || array[1] != 1 || array[2] != 1 || array[3] != 1)",
          "3111:  for (i = 0; i < 4; ++i)",
          "3112:      list_append_number(list, array[i]);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3127:  return;",
          "3129:     list = list_alloc();",
          "3136: }",
          "",
          "[Removed Lines]",
          "3130:     if (list != NULL)",
          "3131:     {",
          "3132:  dict_add_list(dict, \"borderhighlight\", list);",
          "3133:  for (i = 0; i < 4; ++i)",
          "3134:      list_append_string(list, wp->w_border_highlight[i], -1);",
          "3135:     }",
          "",
          "[Added Lines]",
          "3131:     if (list == NULL)",
          "3132:  return;",
          "3134:     dict_add_list(dict, \"borderhighlight\", list);",
          "3135:     for (i = 0; i < 4; ++i)",
          "3136:  list_append_string(list, wp->w_border_highlight[i], -1);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "3153:  return;",
          "3155:     list = list_alloc();",
          "3157:     {",
          "3164:     }",
          "3165: }",
          "",
          "[Removed Lines]",
          "3156:     if (list != NULL)",
          "3158:  dict_add_list(dict, \"borderchars\", list);",
          "3159:  for (i = 0; i < 8; ++i)",
          "3160:  {",
          "3161:      len = mb_char2bytes(wp->w_border_char[i], buf);",
          "3162:      list_append_string(list, buf, len);",
          "3163:  }",
          "",
          "[Added Lines]",
          "3157:     if (list == NULL)",
          "3158:  return;",
          "3160:     dict_add_list(dict, \"borderchars\", list);",
          "3161:     for (i = 0; i < 8; ++i)",
          "3163:  len = mb_char2bytes(wp->w_border_char[i], buf);",
          "3164:  list_append_string(list, buf, len);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "3181:  list_append_number(list, wp->w_popup_maxcol);",
          "3182:     }",
          "3183:     list = list_alloc();",
          "3191: }",
          "",
          "[Removed Lines]",
          "3184:     if (list != NULL)",
          "3185:     {",
          "3186:  dict_add_list(dict, \"mousemoved\", list);",
          "3187:  list_append_number(list, wp->w_popup_mouse_row);",
          "3188:  list_append_number(list, wp->w_popup_mouse_mincol);",
          "3189:  list_append_number(list, wp->w_popup_mouse_maxcol);",
          "3190:     }",
          "",
          "[Added Lines]",
          "3185:     if (list == NULL)",
          "3186:  return;",
          "3188:     dict_add_list(dict, \"mousemoved\", list);",
          "3189:     list_append_number(list, wp->w_popup_mouse_row);",
          "3190:     list_append_number(list, wp->w_popup_mouse_mincol);",
          "3191:     list_append_number(list, wp->w_popup_mouse_maxcol);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "3202:     tabpage_T *tp;",
          "3203:     int  i;",
          "3266:   break;",
          "3268:  }",
          "3298: # if defined(FEAT_TIMERS)",
          "3301: # endif",
          "3303: }",
          "3305: # if defined(FEAT_TERMINAL) || defined(PROTO)",
          "",
          "[Removed Lines]",
          "3205:     if (rettv_dict_alloc(rettv) == OK)",
          "3206:     {",
          "3207:  if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)",
          "3208:      return;",
          "3210:  id = (int)tv_get_number(argvars);",
          "3211:  wp = find_popup_win(id);",
          "3212:  if (wp == NULL)",
          "3213:      return;",
          "3215:  dict = rettv->vval.v_dict;",
          "3216:  dict_add_number(dict, \"line\", wp->w_wantline);",
          "3217:  dict_add_number(dict, \"col\", wp->w_wantcol);",
          "3218:  dict_add_number(dict, \"minwidth\", wp->w_minwidth);",
          "3219:  dict_add_number(dict, \"minheight\", wp->w_minheight);",
          "3220:  dict_add_number(dict, \"maxheight\", wp->w_maxheight);",
          "3221:  dict_add_number(dict, \"maxwidth\", wp->w_maxwidth);",
          "3222:  dict_add_number(dict, \"firstline\", wp->w_firstline);",
          "3223:  dict_add_number(dict, \"scrollbar\", wp->w_want_scrollbar);",
          "3224:  dict_add_number(dict, \"zindex\", wp->w_zindex);",
          "3225:  dict_add_number(dict, \"fixed\", wp->w_popup_fixed);",
          "3226:  if (wp->w_popup_prop_type && win_valid_any_tab(wp->w_popup_prop_win))",
          "3227:  {",
          "3228:      proptype_T *pt = text_prop_type_by_id(",
          "3229:      wp->w_popup_prop_win->w_buffer,",
          "3230:      wp->w_popup_prop_type);",
          "3232:      if (pt != NULL)",
          "3233:   dict_add_string(dict, \"textprop\", pt->pt_name);",
          "3234:      dict_add_number(dict, \"textpropwin\", wp->w_popup_prop_win->w_id);",
          "3235:      dict_add_number(dict, \"textpropid\", wp->w_popup_prop_id);",
          "3236:  }",
          "3237:  dict_add_string(dict, \"title\", wp->w_popup_title);",
          "3238:  dict_add_number(dict, \"wrap\", wp->w_p_wrap);",
          "3239:  dict_add_number(dict, \"drag\", (wp->w_popup_flags & POPF_DRAG) != 0);",
          "3240:  dict_add_number(dict, \"dragall\",",
          "3241:           (wp->w_popup_flags & POPF_DRAGALL) != 0);",
          "3242:  dict_add_number(dict, \"mapping\",",
          "3243:           (wp->w_popup_flags & POPF_MAPPING) != 0);",
          "3244:  dict_add_number(dict, \"resize\", (wp->w_popup_flags & POPF_RESIZE) != 0);",
          "3245:  dict_add_number(dict, \"posinvert\",",
          "3246:         (wp->w_popup_flags & POPF_POSINVERT) != 0);",
          "3247:  dict_add_number(dict, \"cursorline\",",
          "3248:        (wp->w_popup_flags & POPF_CURSORLINE) != 0);",
          "3249:  dict_add_string(dict, \"highlight\", wp->w_p_wcr);",
          "3250:  if (wp->w_scrollbar_highlight != NULL)",
          "3251:      dict_add_string(dict, \"scrollbarhighlight\",",
          "3252:           wp->w_scrollbar_highlight);",
          "3253:  if (wp->w_thumb_highlight != NULL)",
          "3254:      dict_add_string(dict, \"thumbhighlight\", wp->w_thumb_highlight);",
          "3257:  i = 1;",
          "3258:  FOR_ALL_TABPAGES(tp)",
          "3259:  {",
          "3260:      win_T *twp;",
          "3262:      FOR_ALL_POPUPWINS_IN_TAB(tp, twp)",
          "3263:   if (twp->w_id == id)",
          "3264:       break;",
          "3265:      if (twp != NULL)",
          "3267:      ++i;",
          "3269:  if (tp == NULL)",
          "3270:      i = -1;  // must be global",
          "3271:  else if (tp == curtab)",
          "3272:      i = 0;",
          "3273:  dict_add_number(dict, \"tabpage\", i);",
          "3275:  get_padding_border(dict, wp->w_popup_padding, \"padding\");",
          "3276:  get_padding_border(dict, wp->w_popup_border, \"border\");",
          "3277:  get_borderhighlight(dict, wp);",
          "3278:  get_borderchars(dict, wp);",
          "3279:  get_moved_list(dict, wp);",
          "3281:  if (wp->w_filter_cb.cb_name != NULL)",
          "3282:      dict_add_callback(dict, \"filter\", &wp->w_filter_cb);",
          "3283:  if (wp->w_close_cb.cb_name != NULL)",
          "3284:      dict_add_callback(dict, \"callback\", &wp->w_close_cb);",
          "3286:  for (i = 0; i < (int)ARRAY_LENGTH(poppos_entries); ++i)",
          "3287:      if (wp->w_popup_pos == poppos_entries[i].pp_val)",
          "3288:      {",
          "3289:   dict_add_string(dict, \"pos\",",
          "3290:        (char_u *)poppos_entries[i].pp_name);",
          "3291:   break;",
          "3292:      }",
          "3294:  dict_add_string(dict, \"close\", (char_u *)(",
          "3295:       wp->w_popup_close == POPCLOSE_BUTTON ? \"button\"",
          "3296:       : wp->w_popup_close == POPCLOSE_CLICK ? \"click\" : \"none\"));",
          "3299:  dict_add_number(dict, \"time\", wp->w_popup_timer != NULL",
          "3300:      ?  (long)wp->w_popup_timer->tr_interval : 0L);",
          "3302:     }",
          "",
          "[Added Lines]",
          "3206:     if (rettv_dict_alloc(rettv) == FAIL)",
          "3207:  return;",
          "3209:     if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)",
          "3210:  return;",
          "3212:     id = (int)tv_get_number(argvars);",
          "3213:     wp = find_popup_win(id);",
          "3214:     if (wp == NULL)",
          "3215:  return;",
          "3217:     dict = rettv->vval.v_dict;",
          "3218:     dict_add_number(dict, \"line\", wp->w_wantline);",
          "3219:     dict_add_number(dict, \"col\", wp->w_wantcol);",
          "3220:     dict_add_number(dict, \"minwidth\", wp->w_minwidth);",
          "3221:     dict_add_number(dict, \"minheight\", wp->w_minheight);",
          "3222:     dict_add_number(dict, \"maxheight\", wp->w_maxheight);",
          "3223:     dict_add_number(dict, \"maxwidth\", wp->w_maxwidth);",
          "3224:     dict_add_number(dict, \"firstline\", wp->w_firstline);",
          "3225:     dict_add_number(dict, \"scrollbar\", wp->w_want_scrollbar);",
          "3226:     dict_add_number(dict, \"zindex\", wp->w_zindex);",
          "3227:     dict_add_number(dict, \"fixed\", wp->w_popup_fixed);",
          "3228:     if (wp->w_popup_prop_type && win_valid_any_tab(wp->w_popup_prop_win))",
          "3229:     {",
          "3230:  proptype_T *pt = text_prop_type_by_id(",
          "3231:   wp->w_popup_prop_win->w_buffer,",
          "3232:   wp->w_popup_prop_type);",
          "3234:  if (pt != NULL)",
          "3235:      dict_add_string(dict, \"textprop\", pt->pt_name);",
          "3236:  dict_add_number(dict, \"textpropwin\", wp->w_popup_prop_win->w_id);",
          "3237:  dict_add_number(dict, \"textpropid\", wp->w_popup_prop_id);",
          "3238:     }",
          "3239:     dict_add_string(dict, \"title\", wp->w_popup_title);",
          "3240:     dict_add_number(dict, \"wrap\", wp->w_p_wrap);",
          "3241:     dict_add_number(dict, \"drag\", (wp->w_popup_flags & POPF_DRAG) != 0);",
          "3242:     dict_add_number(dict, \"dragall\",",
          "3243:      (wp->w_popup_flags & POPF_DRAGALL) != 0);",
          "3244:     dict_add_number(dict, \"mapping\",",
          "3245:      (wp->w_popup_flags & POPF_MAPPING) != 0);",
          "3246:     dict_add_number(dict, \"resize\", (wp->w_popup_flags & POPF_RESIZE) != 0);",
          "3247:     dict_add_number(dict, \"posinvert\",",
          "3248:      (wp->w_popup_flags & POPF_POSINVERT) != 0);",
          "3249:     dict_add_number(dict, \"cursorline\",",
          "3250:      (wp->w_popup_flags & POPF_CURSORLINE) != 0);",
          "3251:     dict_add_string(dict, \"highlight\", wp->w_p_wcr);",
          "3252:     if (wp->w_scrollbar_highlight != NULL)",
          "3253:  dict_add_string(dict, \"scrollbarhighlight\",",
          "3254:   wp->w_scrollbar_highlight);",
          "3255:     if (wp->w_thumb_highlight != NULL)",
          "3256:  dict_add_string(dict, \"thumbhighlight\", wp->w_thumb_highlight);",
          "3259:     i = 1;",
          "3260:     FOR_ALL_TABPAGES(tp)",
          "3261:     {",
          "3262:  win_T *twp;",
          "3264:  FOR_ALL_POPUPWINS_IN_TAB(tp, twp)",
          "3265:      if (twp->w_id == id)",
          "3267:  if (twp != NULL)",
          "3268:      break;",
          "3269:  ++i;",
          "3270:     }",
          "3271:     if (tp == NULL)",
          "3272:  i = -1;  // must be global",
          "3273:     else if (tp == curtab)",
          "3274:  i = 0;",
          "3275:     dict_add_number(dict, \"tabpage\", i);",
          "3277:     get_padding_border(dict, wp->w_popup_padding, \"padding\");",
          "3278:     get_padding_border(dict, wp->w_popup_border, \"border\");",
          "3279:     get_borderhighlight(dict, wp);",
          "3280:     get_borderchars(dict, wp);",
          "3281:     get_moved_list(dict, wp);",
          "3283:     if (wp->w_filter_cb.cb_name != NULL)",
          "3284:  dict_add_callback(dict, \"filter\", &wp->w_filter_cb);",
          "3285:     if (wp->w_close_cb.cb_name != NULL)",
          "3286:  dict_add_callback(dict, \"callback\", &wp->w_close_cb);",
          "3288:     for (i = 0; i < (int)ARRAY_LENGTH(poppos_entries); ++i)",
          "3289:  if (wp->w_popup_pos == poppos_entries[i].pp_val)",
          "3290:  {",
          "3291:      dict_add_string(dict, \"pos\",",
          "3292:       (char_u *)poppos_entries[i].pp_name);",
          "3293:      break;",
          "3296:     dict_add_string(dict, \"close\", (char_u *)(",
          "3297:   wp->w_popup_close == POPCLOSE_BUTTON ? \"button\"",
          "3298:   : wp->w_popup_close == POPCLOSE_CLICK ? \"click\" : \"none\"));",
          "3301:     dict_add_number(dict, \"time\", wp->w_popup_timer != NULL",
          "3302:      ?  (long)wp->w_popup_timer->tr_interval : 0L);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "3640:     static void",
          "3641: update_popup_transparent(win_T *wp, int val)",
          "3642: {",
          "3644:     {",
          "3686:     }",
          "3687: }",
          "",
          "[Removed Lines]",
          "3643:     if (wp->w_popup_mask != NULL)",
          "3645:  int  width = popup_width(wp);",
          "3646:  int  height = popup_height(wp);",
          "3647:  listitem_T *lio, *li;",
          "3648:  int  cols, cole;",
          "3649:  int  lines, linee;",
          "3650:  int  col, line;",
          "3652:  FOR_ALL_LIST_ITEMS(wp->w_popup_mask, lio)",
          "3653:  {",
          "3654:      li = lio->li_tv.vval.v_list->lv_first;",
          "3655:      cols = tv_get_number(&li->li_tv);",
          "3656:      if (cols < 0)",
          "3657:   cols = width + cols + 1;",
          "3658:      li = li->li_next;",
          "3659:      cole = tv_get_number(&li->li_tv);",
          "3660:      if (cole < 0)",
          "3661:   cole = width + cole + 1;",
          "3662:      li = li->li_next;",
          "3663:      lines = tv_get_number(&li->li_tv);",
          "3664:      if (lines < 0)",
          "3665:   lines = height + lines + 1;",
          "3666:      li = li->li_next;",
          "3667:      linee = tv_get_number(&li->li_tv);",
          "3668:      if (linee < 0)",
          "3669:   linee = height + linee + 1;",
          "3671:      --cols;",
          "3672:      cols -= wp->w_popup_leftoff;",
          "3673:      if (cols < 0)",
          "3674:   cols = 0;",
          "3675:      cole -= wp->w_popup_leftoff;",
          "3676:      --lines;",
          "3677:      if (lines < 0)",
          "3678:   lines = 0;",
          "3679:      for (line = lines; line < linee",
          "3680:       && line + wp->w_winrow < screen_Rows; ++line)",
          "3681:   for (col = cols; col < cole",
          "3682:     && col + wp->w_wincol < screen_Columns; ++col)",
          "3683:       popup_transparent[(line + wp->w_winrow) * screen_Columns",
          "3684:          + col + wp->w_wincol] = val;",
          "3685:  }",
          "",
          "[Added Lines]",
          "3644:     if (wp->w_popup_mask == NULL)",
          "3645:  return;",
          "3647:     int  width = popup_width(wp);",
          "3648:     int  height = popup_height(wp);",
          "3649:     listitem_T *lio, *li;",
          "3650:     int  cols, cole;",
          "3651:     int  lines, linee;",
          "3652:     int  col, line;",
          "3654:     FOR_ALL_LIST_ITEMS(wp->w_popup_mask, lio)",
          "3656:  li = lio->li_tv.vval.v_list->lv_first;",
          "3657:  cols = tv_get_number(&li->li_tv);",
          "3658:  if (cols < 0)",
          "3659:      cols = width + cols + 1;",
          "3660:  li = li->li_next;",
          "3661:  cole = tv_get_number(&li->li_tv);",
          "3662:  if (cole < 0)",
          "3663:      cole = width + cole + 1;",
          "3664:  li = li->li_next;",
          "3665:  lines = tv_get_number(&li->li_tv);",
          "3666:  if (lines < 0)",
          "3667:      lines = height + lines + 1;",
          "3668:  li = li->li_next;",
          "3669:  linee = tv_get_number(&li->li_tv);",
          "3670:  if (linee < 0)",
          "3671:      linee = height + linee + 1;",
          "3673:  --cols;",
          "3674:  cols -= wp->w_popup_leftoff;",
          "3675:  if (cols < 0)",
          "3676:      cols = 0;",
          "3677:  cole -= wp->w_popup_leftoff;",
          "3678:  --lines;",
          "3679:  if (lines < 0)",
          "3680:      lines = 0;",
          "3681:  for (line = lines; line < linee",
          "3682:   && line + wp->w_winrow < screen_Rows; ++line)",
          "3683:      for (col = cols; col < cole",
          "3684:       && col + wp->w_wincol < screen_Columns; ++col)",
          "3685:   popup_transparent[(line + wp->w_winrow) * screen_Columns",
          "3686:       + col + wp->w_wincol] = val;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "4508:     win_T *",
          "4509: popup_get_message_win(void)",
          "4510: {",
          "4538:     return message_win;",
          "4539: }",
          "",
          "[Removed Lines]",
          "4511:     if (message_win == NULL)",
          "4512:     {",
          "4513:  int i;",
          "4515:  message_win = popup_create(NULL, NULL, TYPE_MESSAGE_WIN);",
          "4517:  if (message_win == NULL)",
          "4518:      return NULL;",
          "4521:  message_win->w_width = Columns;",
          "4524:  message_win->w_popup_pos = POPPOS_BOTTOM;",
          "4525:  message_win->w_wantcol = 1;",
          "4526:  message_win->w_minwidth = 9999;",
          "4527:  message_win->w_firstline = -1;",
          "4530:  for (i = 0; i < 4; ++i)",
          "4531:      message_win->w_popup_padding[i] = 0;",
          "4532:  for (i = 1; i < 4; ++i)",
          "4533:      message_win->w_popup_border[i] = 0;",
          "4535:  if (message_win->w_popup_timer != NULL)",
          "4536:      message_win->w_popup_timer->tr_keep = TRUE;",
          "4537:     }",
          "",
          "[Added Lines]",
          "4512:     if (message_win != NULL)",
          "4513:  return message_win;",
          "4515:     int i;",
          "4517:     message_win = popup_create(NULL, NULL, TYPE_MESSAGE_WIN);",
          "4519:     if (message_win == NULL)",
          "4520:  return NULL;",
          "4523:     message_win->w_width = Columns;",
          "4526:     message_win->w_popup_pos = POPPOS_BOTTOM;",
          "4527:     message_win->w_wantcol = 1;",
          "4528:     message_win->w_minwidth = 9999;",
          "4529:     message_win->w_firstline = -1;",
          "4532:     for (i = 0; i < 4; ++i)",
          "4533:  message_win->w_popup_padding[i] = 0;",
          "4534:     for (i = 1; i < 4; ++i)",
          "4535:  message_win->w_popup_border[i] = 0;",
          "4537:     if (message_win->w_popup_timer != NULL)",
          "4538:  message_win->w_popup_timer->tr_keep = TRUE;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "4545:     void",
          "4546: popup_show_message_win(void)",
          "4547: {",
          "4549:     {",
          "4557:     }",
          "4558: }",
          "4560:     static void",
          "",
          "[Removed Lines]",
          "4548:     if (message_win != NULL)",
          "4550:  if ((message_win->w_popup_flags & POPF_HIDDEN) != 0)",
          "4551:  {",
          "4553:      popup_update_color(message_win, TYPE_MESSAGE_WIN);",
          "4554:      popup_show(message_win);",
          "4555:  }",
          "4556:  start_message_win_timer = TRUE;",
          "",
          "[Added Lines]",
          "4549:     if (message_win == NULL)",
          "4550:  return;",
          "4552:     if ((message_win->w_popup_flags & POPF_HIDDEN) != 0)",
          "4555:  popup_update_color(message_win, TYPE_MESSAGE_WIN);",
          "4556:  popup_show(message_win);",
          "4558:     start_message_win_timer = TRUE;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "4664:     void",
          "4665: popup_set_title(win_T *wp)",
          "4666: {",
          "4683: }",
          "4685: # if defined(FEAT_QUICKFIX) || defined(PROTO)",
          "",
          "[Removed Lines]",
          "4667:     if (wp->w_buffer->b_fname != NULL)",
          "4668:     {",
          "4669:  char_u dirname[MAXPATHL];",
          "4670:  size_t len;",
          "4672:  mch_dirname(dirname, MAXPATHL);",
          "4673:  shorten_buf_fname(wp->w_buffer, dirname, FALSE);",
          "4675:  vim_free(wp->w_popup_title);",
          "4676:  len = STRLEN(wp->w_buffer->b_fname) + 3;",
          "4677:  wp->w_popup_title = alloc((int)len);",
          "4678:  if (wp->w_popup_title != NULL)",
          "4679:      vim_snprintf((char *)wp->w_popup_title, len, \" %s \",",
          "4680:        wp->w_buffer->b_fname);",
          "4681:  redraw_win_later(wp, UPD_VALID);",
          "4682:     }",
          "",
          "[Added Lines]",
          "4668:     if (wp->w_buffer->b_fname == NULL)",
          "4669:  return;",
          "4671:     char_u dirname[MAXPATHL];",
          "4672:     size_t len;",
          "4674:     mch_dirname(dirname, MAXPATHL);",
          "4675:     shorten_buf_fname(wp->w_buffer, dirname, FALSE);",
          "4677:     vim_free(wp->w_popup_title);",
          "4678:     len = STRLEN(wp->w_buffer->b_fname) + 3;",
          "4679:     wp->w_popup_title = alloc((int)len);",
          "4680:     if (wp->w_popup_title != NULL)",
          "4681:  vim_snprintf((char *)wp->w_popup_title, len, \" %s \",",
          "4682:   wp->w_buffer->b_fname);",
          "4683:     redraw_win_later(wp, UPD_VALID);",
          "",
          "---------------"
        ],
        "src/profiler.c||src/profiler.c": [
          "File: src/profiler.c -> src/profiler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "910: {",
          "911:     scriptitem_T    *si;",
          "914:     {",
          "923:     }",
          "924: }",
          "",
          "[Removed Lines]",
          "913:     if (SCRIPT_ID_VALID(current_sctx.sc_sid))",
          "915:  si = SCRIPT_ITEM(current_sctx.sc_sid);",
          "916:  if (si->sn_prof_on && --si->sn_pr_nest == 0)",
          "917:  {",
          "918:      profile_end(&si->sn_pr_child);",
          "919:      profile_sub_wait(tm, &si->sn_pr_child); // don't count wait time",
          "920:      profile_add(&si->sn_pr_children, &si->sn_pr_child);",
          "921:      profile_add(&si->sn_prl_children, &si->sn_pr_child);",
          "922:  }",
          "",
          "[Added Lines]",
          "913:     if (!SCRIPT_ID_VALID(current_sctx.sc_sid))",
          "914:  return;",
          "916:     si = SCRIPT_ITEM(current_sctx.sc_sid);",
          "917:     if (si->sn_prof_on && --si->sn_pr_nest == 0)",
          "919:  profile_end(&si->sn_pr_child);",
          "920:  profile_sub_wait(tm, &si->sn_pr_child); // don't count wait time",
          "921:  profile_add(&si->sn_pr_children, &si->sn_pr_child);",
          "922:  profile_add(&si->sn_prl_children, &si->sn_pr_child);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1009: {",
          "1010:     FILE *fd;",
          "1013:     {",
          "1023:     }",
          "1024: }",
          "",
          "[Removed Lines]",
          "1012:     if (profile_fname != NULL)",
          "1014:  fd = mch_fopen((char *)profile_fname, \"w\");",
          "1015:  if (fd == NULL)",
          "1016:      semsg(_(e_cant_open_file_str), profile_fname);",
          "1017:  else",
          "1018:  {",
          "1019:      script_dump_profile(fd);",
          "1020:      func_dump_profile(fd);",
          "1021:      fclose(fd);",
          "1022:  }",
          "",
          "[Added Lines]",
          "1012:     if (profile_fname == NULL)",
          "1013:  return;",
          "1015:     fd = mch_fopen((char *)profile_fname, \"w\");",
          "1016:     if (fd == NULL)",
          "1017:  semsg(_(e_cant_open_file_str), profile_fname);",
          "1018:     else",
          "1020:  script_dump_profile(fd);",
          "1021:  func_dump_profile(fd);",
          "1022:  fclose(fd);",
          "",
          "---------------"
        ],
        "src/quickfix.c||src/quickfix.c": [
          "File: src/quickfix.c -> src/quickfix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1898: {",
          "1899:     VIM_CLEAR(qfl->qf_title);",
          "1909: }",
          "",
          "[Removed Lines]",
          "1901:     if (title != NULL)",
          "1902:     {",
          "1903:  char_u *p = alloc_id(STRLEN(title) + 2, aid_qf_title);",
          "1905:  qfl->qf_title = p;",
          "1906:  if (p != NULL)",
          "1907:      STRCPY(p, title);",
          "1908:     }",
          "",
          "[Added Lines]",
          "1901:     if (title == NULL)",
          "1902:  return;",
          "1904:     char_u *p = alloc_id(STRLEN(title) + 2, aid_qf_title);",
          "1906:     qfl->qf_title = p;",
          "1907:     if (p != NULL)",
          "1908:  STRCPY(p, title);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1976:     qf_delq_T *q;",
          "1978:     q = ALLOC_ONE(qf_delq_T);",
          "1985: }",
          "",
          "[Removed Lines]",
          "1979:     if (q != NULL)",
          "1980:     {",
          "1981:  q->qi = qi;",
          "1982:  q->next = qf_delq_head;",
          "1983:  qf_delq_head = q;",
          "1984:     }",
          "",
          "[Added Lines]",
          "1979:     if (q == NULL)",
          "1980:  return;",
          "1982:     q->qi = qi;",
          "1983:     q->next = qf_delq_head;",
          "1984:     qf_delq_head = q;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2002: {",
          "2003:     buf_T *qfbuf;",
          "2006:     {",
          "2015:     }",
          "2016: }",
          "",
          "[Removed Lines]",
          "2005:     if (qi->qf_bufnr != INVALID_QFBUFNR)",
          "2007:  qfbuf = buflist_findnr(qi->qf_bufnr);",
          "2008:  if (qfbuf != NULL && qfbuf->b_nwindows == 0)",
          "2009:  {",
          "2012:      close_buffer(NULL, qfbuf, DOBUF_WIPE, FALSE, FALSE);",
          "2013:      qi->qf_bufnr = INVALID_QFBUFNR;",
          "2014:  }",
          "",
          "[Added Lines]",
          "2005:     if (qi->qf_bufnr == INVALID_QFBUFNR)",
          "2006:  return;",
          "2008:     qfbuf = buflist_findnr(qi->qf_bufnr);",
          "2009:     if (qfbuf != NULL && qfbuf->b_nwindows == 0)",
          "2013:  close_buffer(NULL, qfbuf, DOBUF_WIPE, FALSE, FALSE);",
          "2014:  qi->qf_bufnr = INVALID_QFBUFNR;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2231:     qf_info_T *qi;",
          "2233:     qi = ALLOC_CLEAR_ONE_ID(qf_info_T, aid_qf_qfinfo);",
          "2240:     return qi;",
          "2241: }",
          "",
          "[Removed Lines]",
          "2234:     if (qi != NULL)",
          "2235:     {",
          "2236:  qi->qf_refcount++;",
          "2237:  qi->qfl_type = qfltype;",
          "2238:  qi->qf_bufnr = INVALID_QFBUFNR;",
          "2239:     }",
          "",
          "[Added Lines]",
          "2234:     if (qi == NULL)",
          "2235:  return NULL;",
          "2237:     qi->qf_refcount++;",
          "2238:     qi->qfl_type = qfltype;",
          "2239:     qi->qf_bufnr = INVALID_QFBUFNR;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4575:     buf = qf_find_buf(qi);",
          "4582:  {",
          "4596:  }",
          "4624:  }",
          "4634: }",
          "",
          "[Removed Lines]",
          "4576:     if (buf != NULL)",
          "4577:     {",
          "4578:  linenr_T old_line_count = buf->b_ml.ml_line_count;",
          "4579:  int  qf_winid = 0;",
          "4581:  if (IS_LL_STACK(qi))",
          "4583:      if (curwin->w_llist == qi)",
          "4584:   win = curwin;",
          "4585:      else",
          "4586:      {",
          "4588:   win = qf_find_win_with_loclist(qi);",
          "4589:   if (win == NULL)",
          "4591:       win = qf_find_win(qi);",
          "4592:   if (win == NULL)",
          "4593:       return;",
          "4594:      }",
          "4595:      qf_winid = win->w_id;",
          "4599:  incr_quickfix_busy();",
          "4601:  int do_fill = TRUE;",
          "4602:  if (old_last == NULL)",
          "4603:  {",
          "4605:      aucmd_prepbuf(&aco, buf);",
          "4606:      if (curbuf != buf)",
          "4607:   do_fill = FALSE;  // failed to find a window for \"buf\"",
          "4608:  }",
          "4610:  if (do_fill)",
          "4611:  {",
          "4612:      qf_update_win_titlevar(qi);",
          "4614:      qf_fill_buffer(qf_get_curlist(qi), buf, old_last, qf_winid);",
          "4615:      ++CHANGEDTICK(buf);",
          "4617:      if (old_last == NULL)",
          "4618:      {",
          "4619:   (void)qf_win_pos_update(qi, 0);",
          "4622:   aucmd_restbuf(&aco);",
          "4623:      }",
          "4628:  if ((win = qf_find_win(qi)) != NULL && old_line_count < win->w_botline)",
          "4629:      redraw_buf_later(buf, UPD_NOT_VALID);",
          "4632:  decr_quickfix_busy();",
          "4633:     }",
          "",
          "[Added Lines]",
          "4576:     if (buf == NULL)",
          "4577:  return;",
          "4579:     linenr_T old_line_count = buf->b_ml.ml_line_count;",
          "4580:     int  qf_winid = 0;",
          "4582:     if (IS_LL_STACK(qi))",
          "4583:     {",
          "4584:  if (curwin->w_llist == qi)",
          "4585:      win = curwin;",
          "4586:  else",
          "4589:      win = qf_find_win_with_loclist(qi);",
          "4590:      if (win == NULL)",
          "4592:   win = qf_find_win(qi);",
          "4593:      if (win == NULL)",
          "4594:   return;",
          "4596:  qf_winid = win->w_id;",
          "4597:     }",
          "4600:     incr_quickfix_busy();",
          "4602:     int do_fill = TRUE;",
          "4603:     if (old_last == NULL)",
          "4604:     {",
          "4606:  aucmd_prepbuf(&aco, buf);",
          "4607:  if (curbuf != buf)",
          "4608:      do_fill = FALSE;  // failed to find a window for \"buf\"",
          "4609:     }",
          "4611:     if (do_fill)",
          "4612:     {",
          "4613:  qf_update_win_titlevar(qi);",
          "4615:  qf_fill_buffer(qf_get_curlist(qi), buf, old_last, qf_winid);",
          "4616:  ++CHANGEDTICK(buf);",
          "4618:  if (old_last == NULL)",
          "4619:  {",
          "4620:      (void)qf_win_pos_update(qi, 0);",
          "4623:      aucmd_restbuf(&aco);",
          "4625:     }",
          "4629:     if ((win = qf_find_win(qi)) != NULL && old_line_count < win->w_botline)",
          "4630:  redraw_buf_later(buf, UPD_NOT_VALID);",
          "4633:     decr_quickfix_busy();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4924: {",
          "4925:     int curlist;",
          "4935:     return OK;",
          "4936: }",
          "",
          "[Removed Lines]",
          "4927:     if (qf_get_curlist(qi)->qf_id != save_qfid)",
          "4928:     {",
          "4929:  curlist = qf_id2nr(qi, save_qfid);",
          "4930:  if (curlist < 0)",
          "4932:      return FAIL;",
          "4933:  qi->qf_curlist = curlist;",
          "4934:     }",
          "",
          "[Added Lines]",
          "4927:     if (qf_get_curlist(qi)->qf_id == save_qfid)",
          "4928:  return OK;",
          "4930:     curlist = qf_id2nr(qi, save_qfid);",
          "4931:     if (curlist < 0)",
          "4933:  return FAIL;",
          "4934:     qi->qf_curlist = curlist;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "6544: {",
          "6545:     char_u *dirname_now = alloc(MAXPATHL);",
          "6548:     {",
          "6562:     }",
          "6563: }",
          "",
          "[Removed Lines]",
          "6547:     if (NULL != dirname_now)",
          "6549:  mch_dirname(dirname_now, MAXPATHL);",
          "6550:  if (STRCMP(dirname_start, dirname_now) != 0)",
          "6551:  {",
          "6554:      exarg_T ea;",
          "6556:      CLEAR_FIELD(ea);",
          "6557:      ea.arg = dirname_start;",
          "6558:      ea.cmdidx = (curwin->w_localdir == NULL) ? CMD_cd : CMD_lcd;",
          "6559:      ex_cd(&ea);",
          "6560:  }",
          "6561:  vim_free(dirname_now);",
          "",
          "[Added Lines]",
          "6547:     if (dirname_now == NULL)",
          "6548:  return;",
          "6550:     mch_dirname(dirname_now, MAXPATHL);",
          "6551:     if (STRCMP(dirname_start, dirname_now) != 0)",
          "6555:  exarg_T ea;",
          "6557:  CLEAR_FIELD(ea);",
          "6558:  ea.arg = dirname_start;",
          "6559:  ea.cmdidx = (curwin->w_localdir == NULL) ? CMD_cd : CMD_lcd;",
          "6560:  ex_cd(&ea);",
          "6562:     vim_free(dirname_now);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6723:     static void",
          "6724: unload_dummy_buffer(buf_T *buf, char_u *dirname_start)",
          "6725: {",
          "6733: }",
          "6735: #if defined(FEAT_EVAL) || defined(PROTO)",
          "",
          "[Removed Lines]",
          "6726:     if (curbuf != buf)  // safety check",
          "6727:     {",
          "6728:  close_buffer(NULL, buf, DOBUF_UNLOAD, FALSE, TRUE);",
          "6731:  restore_start_dir(dirname_start);",
          "6732:     }",
          "",
          "[Added Lines]",
          "6726:     if (curbuf == buf)  // safety check",
          "6727:  return;",
          "6729:     close_buffer(NULL, buf, DOBUF_UNLOAD, FALSE, TRUE);",
          "6732:     restore_start_dir(dirname_start);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6862:     list_T *l;",
          "6879:      return FAIL;",
          "6883:  {",
          "6891:  }",
          "6894:     }",
          "6896:     return status;",
          "6897: }",
          "",
          "[Removed Lines]",
          "6865:     if (di->di_tv.v_type == VAR_LIST && di->di_tv.vval.v_list != NULL)",
          "6866:     {",
          "6869:  if ((efm_di = dict_find(what, (char_u *)\"efm\", -1)) != NULL)",
          "6870:  {",
          "6871:      if (efm_di->di_tv.v_type != VAR_STRING ||",
          "6872:       efm_di->di_tv.vval.v_string == NULL)",
          "6873:   return FAIL;",
          "6874:      errorformat = efm_di->di_tv.vval.v_string;",
          "6875:  }",
          "6877:  l = list_alloc();",
          "6878:  if (l == NULL)",
          "6881:  qi = qf_alloc_stack(QFLT_INTERNAL);",
          "6882:  if (qi != NULL)",
          "6884:      if (qf_init_ext(qi, 0, NULL, NULL, &di->di_tv, errorformat,",
          "6885:    TRUE, (linenr_T)0, (linenr_T)0, NULL, NULL) > 0)",
          "6886:      {",
          "6887:   (void)get_errorlist(qi, NULL, 0, 0, l);",
          "6888:   qf_free(&qi->qf_lists[0]);",
          "6889:      }",
          "6890:      free(qi);",
          "6892:  dict_add_list(retdict, \"items\", l);",
          "6893:  status = OK;",
          "",
          "[Added Lines]",
          "6865:     if (di->di_tv.v_type != VAR_LIST || di->di_tv.vval.v_list == NULL)",
          "6866:  return FAIL;",
          "6870:     if ((efm_di = dict_find(what, (char_u *)\"efm\", -1)) != NULL)",
          "6871:     {",
          "6872:  if (efm_di->di_tv.v_type != VAR_STRING ||",
          "6873:   efm_di->di_tv.vval.v_string == NULL)",
          "6875:  errorformat = efm_di->di_tv.vval.v_string;",
          "6876:     }",
          "6878:     l = list_alloc();",
          "6879:     if (l == NULL)",
          "6880:  return FAIL;",
          "6882:     qi = qf_alloc_stack(QFLT_INTERNAL);",
          "6883:     if (qi != NULL)",
          "6884:     {",
          "6885:  if (qf_init_ext(qi, 0, NULL, NULL, &di->di_tv, errorformat,",
          "6886:       TRUE, (linenr_T)0, (linenr_T)0, NULL, NULL) > 0)",
          "6888:      (void)get_errorlist(qi, NULL, 0, 0, l);",
          "6889:      qf_free(&qi->qf_lists[0]);",
          "6891:  free(qi);",
          "6893:     dict_add_list(retdict, \"items\", l);",
          "6894:     status = OK;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "7633:     free_callback(&qfl->qf_qftf_cb);",
          "7634:     cb = get_callback(&di->di_tv);",
          "7642:     return OK;",
          "7643: }",
          "",
          "[Removed Lines]",
          "7635:     if (cb.cb_name != NULL && *cb.cb_name != NUL)",
          "7636:     {",
          "7637:  set_callback(&qfl->qf_qftf_cb, &cb);",
          "7638:  if (cb.cb_free_name)",
          "7639:      vim_free(cb.cb_name);",
          "7640:     }",
          "",
          "[Added Lines]",
          "7635:     if (cb.cb_name == NULL || *cb.cb_name == NUL)",
          "7636:  return OK;",
          "7638:     set_callback(&qfl->qf_qftf_cb, &cb);",
          "7639:     if (cb.cb_free_name)",
          "7640:  vim_free(cb.cb_name);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "8128:     tv = eval_expr(eap->arg, eap);",
          "8134: }",
          "8135: #endif",
          "",
          "[Removed Lines]",
          "8129:     if (tv != NULL)",
          "8130:     {",
          "8131:  (void)cexpr_core(eap, tv);",
          "8132:  free_tv(tv);",
          "8133:     }",
          "",
          "[Added Lines]",
          "8129:     if (tv == NULL)",
          "8130:  return;",
          "8132:     (void)cexpr_core(eap, tv);",
          "8133:     free_tv(tv);",
          "",
          "---------------"
        ],
        "src/regexp.c||src/regexp.c": [
          "File: src/regexp.c -> src/regexp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "710: {",
          "711:     static int after_slash = FALSE;",
          "714:     {",
          "717:  case '.':",
          "718:  case '[':",
          "719:  case '~':",
          "",
          "[Removed Lines]",
          "713:     if (curchr == -1)",
          "715:  switch (curchr = regparse[0])",
          "716:  {",
          "",
          "[Added Lines]",
          "713:     if (curchr != -1)",
          "714:  return curchr;",
          "716:     switch (curchr = regparse[0])",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "790:   while (p[0] == '\\\\' && (p[1] == 'c' || p[1] == 'C'",
          "793:   {",
          "794:       if (p[1] == 'v')",
          "795:    is_magic_all = TRUE;",
          "",
          "[Removed Lines]",
          "791:     || p[1] == 'm' || p[1] == 'M'",
          "792:     || p[1] == 'v' || p[1] == 'V' || p[1] == 'Z'))",
          "",
          "[Added Lines]",
          "792:        || p[1] == 'm' || p[1] == 'M'",
          "793:        || p[1] == 'v' || p[1] == 'V' || p[1] == 'Z'))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "802:        && (p[1] == '|' || p[1] == '&' || p[1] == ')'",
          "803:     || p[1] == 'n'))",
          "804:    || (is_magic_all",
          "806:    || reg_magic == MAGIC_ALL)",
          "807:       curchr = Magic('$');",
          "808:      }",
          "",
          "[Removed Lines]",
          "805:           && (p[0] == '|' || p[0] == '&' || p[0] == ')'))",
          "",
          "[Added Lines]",
          "806:        && (p[0] == '|' || p[0] == '&' || p[0] == ')'))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "858:  default:",
          "859:      if (has_mbyte)",
          "860:   curchr = (*mb_ptr2char)(regparse);",
          "862:     }",
          "864:     return curchr;",
          "",
          "[Removed Lines]",
          "861:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1384:     static void",
          "1385: cleanup_subexpr(void)",
          "1386: {",
          "1388:     {",
          "1401:     }",
          "1402: }",
          "1404: #ifdef FEAT_SYN_HL",
          "1405:     static void",
          "1406: cleanup_zsubexpr(void)",
          "1407: {",
          "1409:     {",
          "1422:     }",
          "1423: }",
          "1424: #endif",
          "",
          "[Removed Lines]",
          "1387:     if (rex.need_clear_subexpr)",
          "1389:  if (REG_MULTI)",
          "1390:  {",
          "1392:      vim_memset(rex.reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);",
          "1393:      vim_memset(rex.reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);",
          "1394:  }",
          "1395:  else",
          "1396:  {",
          "1397:      vim_memset(rex.reg_startp, 0, sizeof(char_u *) * NSUBEXP);",
          "1398:      vim_memset(rex.reg_endp, 0, sizeof(char_u *) * NSUBEXP);",
          "1399:  }",
          "1400:  rex.need_clear_subexpr = FALSE;",
          "1408:     if (rex.need_clear_zsubexpr)",
          "1410:  if (REG_MULTI)",
          "1411:  {",
          "1413:      vim_memset(reg_startzpos, 0xff, sizeof(lpos_T) * NSUBEXP);",
          "1414:      vim_memset(reg_endzpos, 0xff, sizeof(lpos_T) * NSUBEXP);",
          "1415:  }",
          "1416:  else",
          "1417:  {",
          "1418:      vim_memset(reg_startzp, 0, sizeof(char_u *) * NSUBEXP);",
          "1419:      vim_memset(reg_endzp, 0, sizeof(char_u *) * NSUBEXP);",
          "1420:  }",
          "1421:  rex.need_clear_zsubexpr = FALSE;",
          "",
          "[Added Lines]",
          "1387:     if (!rex.need_clear_subexpr)",
          "1388:  return;",
          "1390:     if (REG_MULTI)",
          "1393:  vim_memset(rex.reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);",
          "1394:  vim_memset(rex.reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);",
          "1396:     else",
          "1397:     {",
          "1398:  vim_memset(rex.reg_startp, 0, sizeof(char_u *) * NSUBEXP);",
          "1399:  vim_memset(rex.reg_endp, 0, sizeof(char_u *) * NSUBEXP);",
          "1400:     }",
          "1401:     rex.need_clear_subexpr = FALSE;",
          "1408:     if (!rex.need_clear_zsubexpr)",
          "1409:  return;",
          "1411:     if (REG_MULTI)",
          "1414:  vim_memset(reg_startzpos, 0xff, sizeof(lpos_T) * NSUBEXP);",
          "1415:  vim_memset(reg_endzpos, 0xff, sizeof(lpos_T) * NSUBEXP);",
          "1416:     }",
          "1417:     else",
          "1418:     {",
          "1419:  vim_memset(reg_startzp, 0, sizeof(char_u *) * NSUBEXP);",
          "1420:  vim_memset(reg_endzp, 0, sizeof(char_u *) * NSUBEXP);",
          "1422:     rex.need_clear_zsubexpr = FALSE;",
          "",
          "---------------"
        ],
        "src/regexp_bt.c||src/regexp_bt.c": [
          "File: src/regexp_bt.c -> src/regexp_bt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3189:     bp->save_need_clear_subexpr = rex.need_clear_subexpr;",
          "3191:     {",
          "3193:  {",
          "3204:  }",
          "3205:     }",
          "3206: }",
          "",
          "[Removed Lines]",
          "3190:     if (!rex.need_clear_subexpr)",
          "3192:  for (i = 0; i < NSUBEXP; ++i)",
          "3194:      if (REG_MULTI)",
          "3195:      {",
          "3196:   bp->save_start[i].se_u.pos = rex.reg_startpos[i];",
          "3197:   bp->save_end[i].se_u.pos = rex.reg_endpos[i];",
          "3198:      }",
          "3199:      else",
          "3200:      {",
          "3201:   bp->save_start[i].se_u.ptr = rex.reg_startp[i];",
          "3202:   bp->save_end[i].se_u.ptr = rex.reg_endp[i];",
          "3203:      }",
          "",
          "[Added Lines]",
          "3190:     if (rex.need_clear_subexpr)",
          "3191:  return;",
          "3193:     for (i = 0; i < NSUBEXP; ++i)",
          "3195:  if (REG_MULTI)",
          "3197:      bp->save_start[i].se_u.pos = rex.reg_startpos[i];",
          "3198:      bp->save_end[i].se_u.pos = rex.reg_endpos[i];",
          "3199:  }",
          "3200:  else",
          "3201:  {",
          "3202:      bp->save_start[i].se_u.ptr = rex.reg_startp[i];",
          "3203:      bp->save_end[i].se_u.ptr = rex.reg_endp[i];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3217:     rex.need_clear_subexpr = bp->save_need_clear_subexpr;",
          "3219:     {",
          "3221:  {",
          "3232:  }",
          "3233:     }",
          "3234: }",
          "",
          "[Removed Lines]",
          "3218:     if (!rex.need_clear_subexpr)",
          "3220:  for (i = 0; i < NSUBEXP; ++i)",
          "3222:      if (REG_MULTI)",
          "3223:      {",
          "3224:   rex.reg_startpos[i] = bp->save_start[i].se_u.pos;",
          "3225:   rex.reg_endpos[i] = bp->save_end[i].se_u.pos;",
          "3226:      }",
          "3227:      else",
          "3228:      {",
          "3229:   rex.reg_startp[i] = bp->save_start[i].se_u.ptr;",
          "3230:   rex.reg_endp[i] = bp->save_end[i].se_u.ptr;",
          "3231:      }",
          "",
          "[Added Lines]",
          "3218:     if (rex.need_clear_subexpr)",
          "3219:  return;",
          "3221:     for (i = 0; i < NSUBEXP; ++i)",
          "3223:  if (REG_MULTI)",
          "3225:      rex.reg_startpos[i] = bp->save_start[i].se_u.pos;",
          "3226:      rex.reg_endpos[i] = bp->save_end[i].se_u.pos;",
          "3227:  }",
          "3228:  else",
          "3229:  {",
          "3230:      rex.reg_startp[i] = bp->save_start[i].se_u.ptr;",
          "3231:      rex.reg_endp[i] = bp->save_end[i].se_u.ptr;",
          "",
          "---------------"
        ],
        "src/regexp_nfa.c||src/regexp_nfa.c": [
          "File: src/regexp_nfa.c -> src/regexp_nfa.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "487:  return NULL;",
          "489:     ret = alloc(len);",
          "491:     {",
          "503:     }",
          "504:     return ret;",
          "505: }",
          "",
          "[Removed Lines]",
          "490:     if (ret != NULL)",
          "492:  p = start->out->out; // skip first char, it goes into regstart",
          "493:  s = ret;",
          "494:  while (p->c > 0)",
          "495:  {",
          "496:      if (has_mbyte)",
          "497:   s += (*mb_char2bytes)(p->c, s);",
          "498:      else",
          "500:      p = p->out;",
          "501:  }",
          "",
          "[Added Lines]",
          "490:     if (ret == NULL)",
          "491:  return NULL;",
          "493:     p = start->out->out; // skip first char, it goes into regstart",
          "494:     s = ret;",
          "495:     while (p->c > 0)",
          "497:  if (has_mbyte)",
          "498:      s += (*mb_char2bytes)(p->c, s);",
          "499:  else",
          "501:  p = p->out;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2782:     FILE *f;",
          "2784:     f = fopen(NFA_REGEXP_DUMP_LOG, \"a\");",
          "2786:     {",
          "2803:     }",
          "2804: }",
          "",
          "[Removed Lines]",
          "2785:     if (f != NULL)",
          "2787:  fprintf(f, \"\\n-------------------------\\n\");",
          "2788:  if (retval == FAIL)",
          "2789:      fprintf(f, \">>> NFA engine failed... \\n\");",
          "2790:  else if (retval == OK)",
          "2791:      fprintf(f, \">>> NFA engine succeeded !\\n\");",
          "2792:  fprintf(f, \"Regexp: \\\"%s\\\"\\nPostfix notation (char): \\\"\", expr);",
          "2793:  for (p = post_start; *p && p < post_ptr; p++)",
          "2794:  {",
          "2795:      nfa_set_code(*p);",
          "2796:      fprintf(f, \"%s, \", code);",
          "2797:  }",
          "2798:  fprintf(f, \"\\\"\\nPostfix notation (int): \");",
          "2799:  for (p = post_start; *p && p < post_ptr; p++)",
          "2800:   fprintf(f, \"%d \", *p);",
          "2801:  fprintf(f, \"\\n\\n\");",
          "2802:  fclose(f);",
          "",
          "[Added Lines]",
          "2785:     if (f == NULL)",
          "2786:  return;",
          "2788:     fprintf(f, \"\\n-------------------------\\n\");",
          "2789:     if (retval == FAIL)",
          "2790:  fprintf(f, \">>> NFA engine failed... \\n\");",
          "2791:     else if (retval == OK)",
          "2792:  fprintf(f, \">>> NFA engine succeeded !\\n\");",
          "2793:     fprintf(f, \"Regexp: \\\"%s\\\"\\nPostfix notation (char): \\\"\", expr);",
          "2794:     for (p = post_start; *p && p < post_ptr; p++)",
          "2796:  nfa_set_code(*p);",
          "2797:  fprintf(f, \"%s, \", code);",
          "2799:     fprintf(f, \"\\\"\\nPostfix notation (int): \");",
          "2800:     for (p = post_start; *p && p < post_ptr; p++)",
          "2801:  fprintf(f, \"%d \", *p);",
          "2802:     fprintf(f, \"\\n\\n\");",
          "2803:     fclose(f);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2883: {",
          "2884:     FILE *debugf = fopen(NFA_REGEXP_DUMP_LOG, \"a\");",
          "2900: }",
          "2901: #endif     // ENABLE_LOG",
          "2902: #endif     // DEBUG",
          "",
          "[Removed Lines]",
          "2886:     if (debugf != NULL)",
          "2887:     {",
          "2888:  nfa_print_state(debugf, prog->start);",
          "2890:  if (prog->reganch)",
          "2891:      fprintf(debugf, \"reganch: %d\\n\", prog->reganch);",
          "2892:  if (prog->regstart != NUL)",
          "2893:      fprintf(debugf, \"regstart: %c (decimal: %d)\\n\",",
          "2894:            prog->regstart, prog->regstart);",
          "2895:  if (prog->match_text != NULL)",
          "2896:      fprintf(debugf, \"match_text: \\\"%s\\\"\\n\", prog->match_text);",
          "2898:  fclose(debugf);",
          "2899:     }",
          "",
          "[Added Lines]",
          "2886:     if (debugf == NULL)",
          "2887:  return;",
          "2889:     nfa_print_state(debugf, prog->start);",
          "2891:     if (prog->reganch)",
          "2892:  fprintf(debugf, \"reganch: %d\\n\", prog->reganch);",
          "2893:     if (prog->regstart != NUL)",
          "2894:  fprintf(debugf, \"regstart: %c (decimal: %d)\\n\",",
          "2895:   prog->regstart, prog->regstart);",
          "2896:     if (prog->match_text != NULL)",
          "2897:  fprintf(debugf, \"match_text: \\\"%s\\\"\\n\", prog->match_text);",
          "2899:     fclose(debugf);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4096: copy_sub(regsub_T *to, regsub_T *from)",
          "4097: {",
          "4098:     to->in_use = from->in_use;",
          "4100:     {",
          "4113:     }",
          "4114: }",
          "",
          "[Removed Lines]",
          "4099:     if (from->in_use > 0)",
          "4102:  if (REG_MULTI)",
          "4103:  {",
          "4104:      mch_memmove(&to->list.multi[0],",
          "4105:    &from->list.multi[0],",
          "4106:    sizeof(struct multipos) * from->in_use);",
          "4107:      to->orig_start_col = from->orig_start_col;",
          "4108:  }",
          "4109:  else",
          "4110:      mch_memmove(&to->list.line[0],",
          "4111:    &from->list.line[0],",
          "4112:    sizeof(struct linepos) * from->in_use);",
          "",
          "[Added Lines]",
          "4099:     if (from->in_use <= 0)",
          "4100:  return;",
          "4103:     if (REG_MULTI)",
          "4105:  mch_memmove(&to->list.multi[0],",
          "4106:   &from->list.multi[0],",
          "4107:   sizeof(struct multipos) * from->in_use);",
          "4108:  to->orig_start_col = from->orig_start_col;",
          "4110:     else",
          "4111:  mch_memmove(&to->list.line[0],",
          "4112:   &from->list.line[0],",
          "4113:   sizeof(struct linepos) * from->in_use);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4121: {",
          "4122:     if (to->in_use < from->in_use)",
          "4123:  to->in_use = from->in_use;",
          "4136: }",
          "",
          "[Removed Lines]",
          "4124:     if (from->in_use > 1)",
          "4125:     {",
          "4127:  if (REG_MULTI)",
          "4128:      mch_memmove(&to->list.multi[1],",
          "4129:    &from->list.multi[1],",
          "4130:    sizeof(struct multipos) * (from->in_use - 1));",
          "4131:  else",
          "4132:      mch_memmove(&to->list.line[1],",
          "4133:    &from->list.line[1],",
          "4134:    sizeof(struct linepos) * (from->in_use - 1));",
          "4135:     }",
          "",
          "[Added Lines]",
          "4124:     if (from->in_use <= 1)",
          "4125:  return;",
          "4128:     if (REG_MULTI)",
          "4129:  mch_memmove(&to->list.multi[1],",
          "4130:   &from->list.multi[1],",
          "4131:   sizeof(struct multipos) * (from->in_use - 1));",
          "4132:     else",
          "4133:  mch_memmove(&to->list.line[1],",
          "4134:   &from->list.line[1],",
          "4135:   sizeof(struct linepos) * (from->in_use - 1));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4141:     static void",
          "4142: copy_ze_off(regsub_T *to, regsub_T *from)",
          "4143: {",
          "4145:     {",
          "4147:  {",
          "4158:  }",
          "4159:     }",
          "4160: }",
          "",
          "[Removed Lines]",
          "4144:     if (rex.nfa_has_zend)",
          "4146:  if (REG_MULTI)",
          "4148:      if (from->list.multi[0].end_lnum >= 0)",
          "4149:      {",
          "4150:   to->list.multi[0].end_lnum = from->list.multi[0].end_lnum;",
          "4151:   to->list.multi[0].end_col = from->list.multi[0].end_col;",
          "4152:      }",
          "4153:  }",
          "4154:  else",
          "4155:  {",
          "4156:      if (from->list.line[0].end != NULL)",
          "4157:   to->list.line[0].end = from->list.line[0].end;",
          "",
          "[Added Lines]",
          "4144:     if (!rex.nfa_has_zend)",
          "4145:  return;",
          "4147:     if (REG_MULTI)",
          "4149:  if (from->list.multi[0].end_lnum >= 0)",
          "4151:      to->list.multi[0].end_lnum = from->list.multi[0].end_lnum;",
          "4152:      to->list.multi[0].end_col = from->list.multi[0].end_col;",
          "4155:     else",
          "4156:     {",
          "4157:  if (from->list.line[0].end != NULL)",
          "4158:      to->list.line[0].end = from->list.line[0].end;",
          "4159:     }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "7568:     static void",
          "7569: nfa_regfree(regprog_T *prog)",
          "7570: {",
          "7577: }",
          "",
          "[Removed Lines]",
          "7571:     if (prog != NULL)",
          "7572:     {",
          "7573:  vim_free(((nfa_regprog_T *)prog)->match_text);",
          "7574:  vim_free(((nfa_regprog_T *)prog)->pattern);",
          "7575:  vim_free(prog);",
          "7576:     }",
          "",
          "[Added Lines]",
          "7571:     if (prog == NULL)",
          "7572:  return;",
          "7574:     vim_free(((nfa_regprog_T *)prog)->match_text);",
          "7575:     vim_free(((nfa_regprog_T *)prog)->pattern);",
          "7576:     vim_free(prog);",
          "",
          "---------------"
        ],
        "src/register.c||src/register.c": [
          "File: src/register.c -> src/register.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "295:     get_yank_register(name, 0);",
          "296:     reg = ALLOC_ONE(yankreg_T);",
          "298:     {",
          "301:  {",
          "312:  }",
          "315:     }",
          "316:     return (void *)reg;",
          "317: }",
          "",
          "[Removed Lines]",
          "297:     if (reg != NULL)",
          "300:  if (copy)",
          "303:      if (reg->y_size == 0)",
          "304:   reg->y_array = NULL;",
          "305:      else",
          "306:   reg->y_array = ALLOC_MULT(char_u *, reg->y_size);",
          "307:      if (reg->y_array != NULL)",
          "308:      {",
          "309:   for (i = 0; i < reg->y_size; ++i)",
          "310:       reg->y_array[i] = vim_strsave(y_current->y_array[i]);",
          "311:      }",
          "313:  else",
          "314:      y_current->y_array = NULL;",
          "",
          "[Added Lines]",
          "297:     if (reg == NULL)",
          "298:  return (void *)NULL;",
          "301:     if (copy)",
          "304:  if (reg->y_size == 0)",
          "305:      reg->y_array = NULL;",
          "306:  else",
          "307:      reg->y_array = ALLOC_MULT(char_u *, reg->y_size);",
          "308:  if (reg->y_array != NULL)",
          "310:      for (i = 0; i < reg->y_size; ++i)",
          "311:   reg->y_array[i] = vim_strsave(y_current->y_array[i]);",
          "314:     else",
          "315:  y_current->y_array = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "716: {",
          "717:     char_u buf[3];",
          "720:     {",
          "734:     }",
          "735: }",
          "",
          "[Removed Lines]",
          "719:     if (restart_edit != NUL)",
          "721:  if (restart_edit == 'V')",
          "722:  {",
          "723:      buf[0] = 'g';",
          "724:      buf[1] = 'R';",
          "725:      buf[2] = NUL;",
          "726:  }",
          "727:  else",
          "728:  {",
          "729:      buf[0] = restart_edit == 'I' ? 'i' : restart_edit;",
          "730:      buf[1] = NUL;",
          "731:  }",
          "732:  if (ins_typebuf(buf, REMAP_NONE, 0, TRUE, silent) == OK)",
          "733:      restart_edit = NUL;",
          "",
          "[Added Lines]",
          "719:     if (restart_edit == NUL)",
          "720:  return;",
          "722:     if (restart_edit == 'V')",
          "724:  buf[0] = 'g';",
          "725:  buf[1] = 'R';",
          "726:  buf[2] = NUL;",
          "727:     }",
          "728:     else",
          "729:     {",
          "730:  buf[0] = restart_edit == 'I' ? 'i' : restart_edit;",
          "731:  buf[1] = NUL;",
          "733:     if (ins_typebuf(buf, REMAP_NONE, 0, TRUE, silent) == OK)",
          "734:  restart_edit = NUL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1097:     static void",
          "1098: free_yank(long n)",
          "1099: {",
          "1108: }",
          "1110:     void",
          "",
          "[Removed Lines]",
          "1100:     if (y_current->y_array != NULL)",
          "1101:     {",
          "1102:  long     i;",
          "1104:  for (i = n; --i >= 0; )",
          "1105:      vim_free(y_current->y_array[i]);",
          "1106:  VIM_CLEAR(y_current->y_array);",
          "1107:     }",
          "",
          "[Added Lines]",
          "1100:     if (y_current->y_array == NULL)",
          "1101:  return;",
          "1103:     long     i;",
          "1105:     for (i = n; --i >= 0; )",
          "1106:  vim_free(y_current->y_array[i]);",
          "1107:     VIM_CLEAR(y_current->y_array);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2695:     }",
          "2697:     retval = alloc(len + 1);",
          "2701:     {",
          "2714:     }",
          "2716:     return retval;",
          "2717: }",
          "",
          "[Removed Lines]",
          "2700:     if (retval != NULL)",
          "2702:  len = 0;",
          "2703:  for (i = 0; i < y_current->y_size; ++i)",
          "2704:  {",
          "2705:      STRCPY(retval + len, y_current->y_array[i]);",
          "2706:      len += (long)STRLEN(retval + len);",
          "2710:      if (y_current->y_type == MLINE || i < y_current->y_size - 1)",
          "2711:   retval[len++] = '\\n';",
          "2712:  }",
          "2713:  retval[len] = NUL;",
          "",
          "[Added Lines]",
          "2698:     if (retval == NULL)",
          "2699:  return NULL;",
          "2702:     len = 0;",
          "2703:     for (i = 0; i < y_current->y_size; ++i)",
          "2705:  STRCPY(retval + len, y_current->y_array[i]);",
          "2706:  len += (long)STRLEN(retval + len);",
          "2710:  if (y_current->y_type == MLINE || i < y_current->y_size - 1)",
          "2711:      retval[len++] = '\\n';",
          "2713:     retval[len] = NUL;",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "696: static int included_patches[] =",
          "699:     1220,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "699:     1221,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
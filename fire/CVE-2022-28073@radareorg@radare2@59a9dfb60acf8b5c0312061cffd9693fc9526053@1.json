{
  "cve_id": "CVE-2022-28073",
  "cve_desc": "A use after free in r_reg_set_value function in radare2 5.4.2 and 5.4.0.",
  "repo": "radareorg/radare2",
  "patch_hash": "59a9dfb60acf8b5c0312061cffd9693fc9526053",
  "patch_info": {
    "commit_hash": "59a9dfb60acf8b5c0312061cffd9693fc9526053",
    "repo": "radareorg/radare2",
    "commit_url": "https://github.com/radareorg/radare2/commit/59a9dfb60acf8b5c0312061cffd9693fc9526053",
    "files": [
      "libr/core/anal_tp.c",
      "libr/core/cmd_anal.c",
      "libr/reg/rvalue.c"
    ],
    "message": "Fix uaf crash in aaft (tests_64927) ##crash\n\nReported by giantbranch of NSFOCUS TIANJI Lab",
    "before_after_code_files": [
      "libr/core/anal_tp.c||libr/core/anal_tp.c",
      "libr/core/cmd_anal.c||libr/core/cmd_anal.c",
      "libr/reg/rvalue.c||libr/reg/rvalue.c"
    ]
  },
  "patch_diff": {
    "libr/core/anal_tp.c||libr/core/anal_tp.c": [
      "File: libr/core/anal_tp.c -> libr/core/anal_tp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "510:   return;",
      "511:  }",
      "512:  char *pc = strdup (_pc);",
      "518:  r_cons_break_push (NULL, NULL);",
      "519:  r_list_sort (fcn->bbs, bb_cmpaddr); // TODO: The algorithm can be more accurate if blocks are followed by their jmp/fail, not just by address",
      "520:  r_list_foreach (fcn->bbs, it, bb) {",
      "521:   ut64 addr = bb->addr;",
      "522:   int i = 0;",
      "523:   r_reg_set_value (core->dbg->reg, r, addr);",
      "524:   while (1) {",
      "525:    if (r_cons_is_breaked ()) {",
      "",
      "[Removed Lines]",
      "513:  RRegItem *r = r_reg_get (core->dbg->reg, pc, -1);",
      "514:  if (!r) {",
      "515:   free (buf);",
      "516:   return;",
      "517:  }",
      "",
      "[Added Lines]",
      "518:   RRegItem *r = r_reg_get (core->dbg->reg, pc, -1);",
      "519:   if (!r) {",
      "520:    free (buf);",
      "521:    return;",
      "522:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "549:    }",
      "550:    sdb_num_set (anal->esil->trace->db, sdb_fmt (\"0x%\"PFMT64x\".count\", addr), loop_count + 1, 0);",
      "551:    if (r_anal_op_nonlinear (aop.type)) {   // skip the instr",
      "552:     r_reg_set_value (core->dbg->reg, r, addr + ret);",
      "553:    } else {",
      "554:     r_core_esil_step (core, UT64_MAX, NULL, NULL, false);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "552:     RRegItem *r = r_reg_get (core->dbg->reg, pc, -1);",
      "553:     if (!r) {",
      "554:      free (buf);",
      "555:      return;",
      "556:     }",
      "",
      "---------------"
    ],
    "libr/core/cmd_anal.c||libr/core/cmd_anal.c": [
      "File: libr/core/cmd_anal.c -> libr/core/cmd_anal.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4766:  int size = 0, i, type = R_REG_TYPE_GPR;",
      "4767:  int bits = (core->anal->bits & R_SYS_BITS_64)? 64: 32;",
      "4768:  int use_colors = r_config_get_i (core->config, \"scr.color\");",
      "4770:  const char *use_color;",
      "4771:  const char *name;",
      "4772:  char *arg;",
      "",
      "[Removed Lines]",
      "4769:  RRegItem *r;",
      "",
      "[Added Lines]",
      "4769:  RRegItem *r = NULL;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "5098:   arg = strchr (str + 1, '=');",
      "5099:   if (arg) {",
      "5101:    char *ostr = r_str_trim_dup (str + 1);",
      "5102:    char *regname = r_str_trim_nc (ostr);",
      "5103:    r = r_reg_get (core->dbg->reg, regname, -1);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5101:    ut64 n = r_num_math (core->num, arg + 1);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "5113:    if (r) {",
      "5118:     r_debug_reg_sync (core->dbg, R_REG_TYPE_ALL, true);",
      "",
      "[Removed Lines]",
      "5116:     r_reg_set_value (core->dbg->reg, r,",
      "5117:       r_num_math (core->num, arg + 1));",
      "",
      "[Added Lines]",
      "5117:     r_reg_set_value (core->dbg->reg, r, n);",
      "",
      "---------------"
    ],
    "libr/reg/rvalue.c||libr/reg/rvalue.c": [
      "File: libr/reg/rvalue.c -> libr/reg/rvalue.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "141: }",
      "143: R_API bool r_reg_set_value(RReg *reg, RRegItem *item, ut64 value) {",
      "144:  ut8 bytes[12];",
      "145:  ut8 *src = bytes;",
      "148:  if (r_reg_is_readonly (reg, item)) {",
      "149:   return true;",
      "",
      "[Removed Lines]",
      "146:  r_return_val_if_fail (reg && item, false);",
      "",
      "[Added Lines]",
      "144:  r_return_val_if_fail (reg && item, false);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0fa18220f351413dc7e082913bd03af949724930",
      "candidate_info": {
        "commit_hash": "0fa18220f351413dc7e082913bd03af949724930",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/0fa18220f351413dc7e082913bd03af949724930",
        "files": [
          "libr/core/anal_tp.c",
          "libr/core/cmd_anal.c"
        ],
        "message": "Optimize 'aaft' command, still far from fully optimized ##anal\n\n* aaa takes 1.8s instead of 2.1s in /bin/ls",
        "before_after_code_files": [
          "libr/core/anal_tp.c||libr/core/anal_tp.c",
          "libr/core/cmd_anal.c||libr/core/cmd_anal.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/core/anal_tp.c||libr/core/anal_tp.c",
            "libr/core/cmd_anal.c||libr/core/cmd_anal.c"
          ],
          "candidate": [
            "libr/core/anal_tp.c||libr/core/anal_tp.c",
            "libr/core/cmd_anal.c||libr/core/cmd_anal.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/core/anal_tp.c||libr/core/anal_tp.c": [
          "File: libr/core/anal_tp.c -> libr/core/anal_tp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "286:  RAnal *anal = core->anal;",
          "287:  RList *types = NULL;",
          "288:  int idx = sdb_num_get (trace, \"idx\", 0);",
          "290:  bool stack_rev = false, in_stack = false, format = false;",
          "292:  if (!fcn_name || !cc) {",
          "",
          "[Removed Lines]",
          "289:  bool verbose = r_config_get_i (core->config, \"anal.types.verbose\");",
          "",
          "[Added Lines]",
          "289:  bool verbose = r_config_get_b (core->config, \"anal.types.verbose\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "304:   in_stack = true;",
          "305:  }",
          "306:  if (verbose && !strncmp (fcn_name, \"sym.imp.\", 8)) {",
          "308:  }",
          "309:  if (!max) {",
          "310:   if (!in_stack) {",
          "",
          "[Removed Lines]",
          "307:   eprintf (\"%s missing function definition\\n\", fcn_name + 8);",
          "",
          "[Added Lines]",
          "307:   eprintf (\"Warning: Missing function definition for '%s'\\n\", fcn_name + 8);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "313:    max = DEFAULT_MAX;",
          "314:   }",
          "315:  }",
          "316:  for (i = 0; i < max; i++) {",
          "317:   int arg_num = stack_rev ? (max - 1 - i) : i;",
          "318:   char *type = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "317:  if (max > 7) {",
          "318:   max = DEFAULT_MAX;",
          "319:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "448:  return a->addr > b->addr ? 1 : (a->addr < b->addr ? -1 : 0);",
          "449: }",
          "451: R_API void r_core_anal_type_match(RCore *core, RAnalFunction *fcn) {",
          "452:  RAnalBlock *bb;",
          "453:  RListIter *it;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "455: #define SLOW_STEP 1",
          "456: static bool fast_step(RCore *core, RAnalOp *aop) {",
          "457: #if SLOW_STEP",
          "458:  return r_core_esil_step (core, UT64_MAX, NULL, NULL, false);",
          "459: #else",
          "460:  RAnalEsil *esil = core->anal->esil;",
          "461:  const char *e = R_STRBUF_SAFEGET (&aop->esil);",
          "462:  if (R_STR_ISEMPTY (e)) {",
          "463:   return false;",
          "464:  }",
          "465:  if (!esil) {",
          "466:   r_core_cmd0 (core, \"aei\");",
          "468:   esil = core->anal->esil;",
          "469:   if (!esil) {",
          "470:    return false;",
          "471:   }",
          "472:  } else {",
          "473:   esil->trap = 0;",
          "475:  }",
          "478:  int ret = (aop->type == R_ANAL_OP_TYPE_ILL) ? -1: aop->size;",
          "482:  esil = core->anal->esil;",
          "483:  if (aop->size < 1 || ret < 1) {",
          "484:   return false;",
          "485:  }",
          "487: #if 1",
          "488:  RReg *reg = core->dbg->reg;",
          "489:  core->dbg->reg = core->anal->reg;",
          "490:  r_anal_esil_set_pc (esil, aop->addr);",
          "491:  r_debug_trace_op (core->dbg, aop); // calls esil.parse() internally",
          "492:  core->dbg->reg = reg;",
          "493: #else",
          "494:  r_debug_trace_op (core->dbg, aop); // calls esil.parse() internally",
          "495: #endif",
          "497:  const char *pcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);",
          "498:  r_reg_setv (core->anal->reg, pcname, aop->addr + aop->size);",
          "499:  r_anal_esil_stack_free (esil);",
          "500:  return true;",
          "501: #endif",
          "502: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "464:  RAnal *anal = core->anal;",
          "465:  Sdb *TDB = anal->sdb_types;",
          "468:  const int mininstrsz = r_anal_archinfo (anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);",
          "469:  const int minopcode = R_MAX (1, mininstrsz);",
          "470:  int cur_idx , prev_idx = 0;",
          "",
          "[Removed Lines]",
          "466:  bool chk_constraint = r_config_get_i (core->config, \"anal.types.constraint\");",
          "467:  int ret, bsize = R_MAX (64, core->blocksize);",
          "",
          "[Added Lines]",
          "519:  bool chk_constraint = r_config_get_b (core->config, \"anal.types.constraint\");",
          "520:  int ret;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "478:   anal_emul_restore (core, hc, dt, et);",
          "479:   return;",
          "480:  }",
          "488:  Sdb *etracedb = core->anal->esil->trace->db;",
          "489:  HtPPOptions opt = etracedb->ht->opt;",
          "",
          "[Removed Lines]",
          "481:  ut8 *buf = malloc (bsize);",
          "482:  if (!buf) {",
          "483:   anal_emul_restore (core, hc, dt, et);",
          "484:   return;",
          "485:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "506:  char *ret_reg = NULL;",
          "507:  const char *_pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);",
          "508:  if (!_pc) {",
          "510:   return;",
          "511:  }",
          "512:  char *pc = strdup (_pc);",
          "",
          "[Removed Lines]",
          "509:   free (buf);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "514:  r_list_sort (fcn->bbs, bb_cmpaddr); // TODO: The algorithm can be more accurate if blocks are followed by their jmp/fail, not just by address",
          "515:  r_list_foreach (fcn->bbs, it, bb) {",
          "516:   ut64 addr = bb->addr;",
          "522:   }",
          "524:   while (1) {",
          "525:    if (r_cons_is_breaked ()) {",
          "526:     goto out_function;",
          "527:    }",
          "530:    }",
          "531:    ut64 pcval = r_reg_getv (anal->reg, pc);",
          "532:    if ((addr >= bb->addr + bb->size) || (addr < bb->addr) || pcval != addr) {",
          "533:     break;",
          "534:    }",
          "539:    if (ret <= 0) {",
          "540:     i += minopcode;",
          "541:     addr += minopcode;",
          "542:     r_anal_op_fini (&aop);",
          "543:     continue;",
          "544:    }",
          "",
          "[Removed Lines]",
          "517:   int i = 0;",
          "518:   RRegItem *r = r_reg_get (core->dbg->reg, pc, -1);",
          "519:   if (!r) {",
          "520:    free (buf);",
          "521:    return;",
          "523:   r_reg_set_value (core->dbg->reg, r, addr);",
          "528:    if (i >= (bsize - 32)) {",
          "529:     i = 0;",
          "535:    if (!i) {",
          "536:     r_io_read_at (core->io, addr, buf, bsize);",
          "537:    }",
          "538:    ret = r_anal_op (anal, &aop, addr, buf + i, bsize - i, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_VAL);",
          "",
          "[Added Lines]",
          "563:   ut8 *buf = calloc (bb->size + 32, 1);",
          "564:   if (!buf) {",
          "565:    break;",
          "567:   r_io_read_at (core->io, addr, buf, bb->size);",
          "568:   int i = 0;",
          "569:   r_reg_setv (core->dbg->reg, pc, addr);",
          "574:    if (i >= bb->size) {",
          "575:     break;",
          "582:    ret = r_anal_op (anal, &aop, addr, buf + i, bb->size - i, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_HINT);",
          "586:     r_reg_setv (core->dbg->reg, pc, addr);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "549:    }",
          "550:    sdb_num_set (anal->esil->trace->db, sdb_fmt (\"0x%\"PFMT64x\".count\", addr), loop_count + 1, 0);",
          "551:    if (r_anal_op_nonlinear (aop.type)) {   // skip the instr",
          "558:    } else {",
          "560:    }",
          "561:    bool userfnc = false;",
          "562:    Sdb *trace = anal->esil->trace->db;",
          "",
          "[Removed Lines]",
          "552:     RRegItem *r = r_reg_get (core->dbg->reg, pc, -1);",
          "553:     if (!r) {",
          "554:      free (buf);",
          "555:      return;",
          "556:     }",
          "557:     r_reg_set_value (core->dbg->reg, r, addr + ret);",
          "559:     r_core_esil_step (core, UT64_MAX, NULL, NULL, false);",
          "",
          "[Added Lines]",
          "598:     r_reg_setv (core->dbg->reg, pc, addr + ret);",
          "600:     fast_step (core, &aop);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "757:    addr += ret;",
          "758:    r_anal_op_free (next_op);",
          "759:    r_anal_op_fini (&aop);",
          "761:   }",
          "762:  }",
          "764:  RList *list = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_REG);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "802:   free (buf);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "781: out_function:",
          "782:  R_FREE (ret_reg);",
          "783:  R_FREE (ret_type);",
          "785:  r_cons_break_pop();",
          "786:  anal_emul_restore (core, hc, dt, et);",
          "787:  free (pc);",
          "",
          "[Removed Lines]",
          "784:  free (buf);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libr/core/cmd_anal.c||libr/core/cmd_anal.c": [
          "File: libr/core/cmd_anal.c -> libr/core/cmd_anal.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5233:  RAnalEsil *esil = core->anal->esil;",
          "5234:  const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);",
          "5235:  ut64 addr = r_reg_getv (core->anal->reg, name);",
          "5237:  int esiltimeout = r_config_get_i (core->config, \"esil.timeout\");",
          "5238:  ut64 startTime;",
          "",
          "[Removed Lines]",
          "5236:  bool breakoninvalid = r_config_get_i (core->config, \"esil.breakoninvalid\");",
          "",
          "[Added Lines]",
          "5236:  bool r2wars = r_config_get_b (core->config, \"cfg.r2wars\");",
          "5237:  bool breakoninvalid = r_config_get_b (core->config, \"esil.breakoninvalid\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5336:     return 1;",
          "5337:    }",
          "5338:   }",
          "5341:    ut64 vECX = r_reg_getv (core->anal->reg, \"ecx\");",
          "5342:    if (op.prefix  & R_ANAL_OP_PREFIX_REP && vECX > 1) {",
          "",
          "[Removed Lines]",
          "5339:   if (r_config_get_i (core->config, \"cfg.r2wars\")) {",
          "",
          "[Added Lines]",
          "5340:   if (r2wars) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
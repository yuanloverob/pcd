{
  "cve_id": "CVE-2024-32867",
  "cve_desc": "Suricata is a network Intrusion Detection System, Intrusion Prevention System and Network Security Monitoring engine. Prior to 7.0.5 and 6.0.19, various problems in handling of fragmentation anomalies can lead to mis-detection of rules and policy. This vulnerability is fixed in 7.0.5 or 6.0.19.",
  "repo": "OISF/suricata",
  "patch_hash": "d13bd2ae217a6d2ceb347f74d27cbfcd37b9bda9",
  "patch_info": {
    "commit_hash": "d13bd2ae217a6d2ceb347f74d27cbfcd37b9bda9",
    "repo": "OISF/suricata",
    "commit_url": "https://github.com/OISF/suricata/commit/d13bd2ae217a6d2ceb347f74d27cbfcd37b9bda9",
    "files": [
      "src/defrag.c"
    ],
    "message": "defrag: fix check for complete packet\n\nThe list of fragments may still contain overlaps, so adding up the\nfragment lengths is flawed. Instead track the largest size of\ncontiguous data that can be re-assembled.\n\nBug: #6675\n(cherry picked from commit d226d0a3fce8837936e1bdfaee496c80d417e0a5)",
    "before_after_code_files": [
      "src/defrag.c||src/defrag.c"
    ]
  },
  "patch_diff": {
    "src/defrag.c||src/defrag.c": [
      "File: src/defrag.c -> src/defrag.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "248:             goto done;",
      "249:         } else {",
      "251:         }",
      "252:     }",
      "",
      "[Removed Lines]",
      "250:             len += frag->data_len;",
      "",
      "[Added Lines]",
      "251:             len = MAX(len, frag->offset + frag->data_len);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "398:                 goto done;",
      "399:             } else {",
      "401:             }",
      "402:         }",
      "403:     }",
      "",
      "[Removed Lines]",
      "400:                 len += frag->data_len;",
      "",
      "[Added Lines]",
      "401:                 len = MAX(len, frag->offset + frag->data_len);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2922:     PASS;",
      "2923: }",
      "2927: void DefragRegisterTests(void)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2937: static int DefragBsdPeose173Ipv4Test(void)",
      "2938: {",
      "2939:     DefragInit();",
      "2940:     default_policy = DEFRAG_POLICY_BSD;",
      "2941:     Packet *packets[5];",
      "2943:     packets[0] = BuildIpv4TestPacketWithContent(",
      "2944:             IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);",
      "2946:     packets[1] =",
      "2947:             BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);",
      "2949:     packets[2] = BuildIpv4TestPacketWithContent(",
      "2950:             IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);",
      "2953:     packets[3] = BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);",
      "2955:     packets[4] =",
      "2956:             BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);",
      "2958:     Packet *r = Defrag(NULL, NULL, packets[0]);",
      "2959:     FAIL_IF_NOT_NULL(r);",
      "2961:     r = Defrag(NULL, NULL, packets[1]);",
      "2962:     FAIL_IF_NOT_NULL(r);",
      "2964:     r = Defrag(NULL, NULL, packets[2]);",
      "2965:     FAIL_IF_NOT_NULL(r);",
      "2967:     r = Defrag(NULL, NULL, packets[3]);",
      "2968:     FAIL_IF_NOT_NULL(r);",
      "2970:     r = Defrag(NULL, NULL, packets[4]);",
      "2971:     FAIL_IF_NOT_NULL(r);",
      "2973: #if 0",
      "2974:     PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);",
      "2975: #endif",
      "2977:     for (int i = 0; i < 5; i++) {",
      "2978:         SCFree(packets[i]);",
      "2979:     }",
      "2981:     DefragDestroy();",
      "2983:     PASS;",
      "2984: }",
      "2986: static int DefragBsdPeose173Ipv6Test(void)",
      "2987: {",
      "2988:     DefragInit();",
      "2989:     default_policy = DEFRAG_POLICY_BSD;",
      "2990:     Packet *packets[5];",
      "2992:     packets[0] = BuildIpv6TestPacketWithContent(",
      "2993:             IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);",
      "2995:     packets[1] =",
      "2996:             BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);",
      "2998:     packets[2] = BuildIpv6TestPacketWithContent(",
      "2999:             IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);",
      "3002:     packets[3] = BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);",
      "3004:     packets[4] =",
      "3005:             BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);",
      "3007:     Packet *r = Defrag(NULL, NULL, packets[0]);",
      "3008:     FAIL_IF_NOT_NULL(r);",
      "3010:     r = Defrag(NULL, NULL, packets[1]);",
      "3011:     FAIL_IF_NOT_NULL(r);",
      "3013:     r = Defrag(NULL, NULL, packets[2]);",
      "3014:     FAIL_IF_NOT_NULL(r);",
      "3016:     r = Defrag(NULL, NULL, packets[3]);",
      "3017:     FAIL_IF_NOT_NULL(r);",
      "3019:     r = Defrag(NULL, NULL, packets[4]);",
      "3020:     FAIL_IF_NOT_NULL(r);",
      "3022: #if 0",
      "3023:     PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);",
      "3024: #endif",
      "3026:     for (int i = 0; i < 5; i++) {",
      "3027:         SCFree(packets[i]);",
      "3028:     }",
      "3030:     DefragDestroy();",
      "3032:     PASS;",
      "3033: }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2968:             DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2);",
      "2969:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2\",",
      "2970:             DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2);",
      "2972: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3081:     UtRegisterTest(\"DefragBsdPeose173Ipv4Test\", DefragBsdPeose173Ipv4Test);",
      "3082:     UtRegisterTest(\"DefragBsdPeose173Ipv6Test\", DefragBsdPeose173Ipv6Test);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d226d0a3fce8837936e1bdfaee496c80d417e0a5",
      "candidate_info": {
        "commit_hash": "d226d0a3fce8837936e1bdfaee496c80d417e0a5",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/d226d0a3fce8837936e1bdfaee496c80d417e0a5",
        "files": [
          "src/defrag.c"
        ],
        "message": "defrag: fix check for complete packet\n\nThe list of fragments may still contain overlaps, so adding up the\nfragment lengths is flawed. Instead track the largest size of\ncontiguous data that can be re-assembled.\n\nBug: #6675",
        "before_after_code_files": [
          "src/defrag.c||src/defrag.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/defrag.c||src/defrag.c"
          ],
          "candidate": [
            "src/defrag.c||src/defrag.c"
          ]
        }
      },
      "candidate_diff": {
        "src/defrag.c||src/defrag.c": [
          "File: src/defrag.c -> src/defrag.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "256:             goto done;",
          "257:         }",
          "258:         else {",
          "260:         }",
          "261:     }",
          "",
          "[Removed Lines]",
          "259:             len += frag->data_len;",
          "",
          "[Added Lines]",
          "260:             len = MAX(len, frag->offset + frag->data_len);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "414:                 goto done;",
          "415:             }",
          "416:             else {",
          "418:             }",
          "419:         }",
          "420:     }",
          "",
          "[Removed Lines]",
          "417:                 len += frag->data_len;",
          "",
          "[Added Lines]",
          "418:                 len = MAX(len, frag->offset + frag->data_len);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3057:     PASS;",
          "3058: }",
          "3062: void DefragRegisterTests(void)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3072: static int DefragBsdMissingFragmentIpv4Test(void)",
          "3073: {",
          "3074:     DefragInit();",
          "3075:     default_policy = DEFRAG_POLICY_BSD;",
          "3076:     Packet *packets[5];",
          "3078:     FAIL_IF_NOT(BuildIpv4TestPacketWithContent(",
          "3079:             &packets[0], IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16));",
          "3081:     FAIL_IF_NOT(BuildIpv4TestPacketWithContent(",
          "3082:             &packets[1], IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8));",
          "3084:     FAIL_IF_NOT(BuildIpv4TestPacketWithContent(",
          "3085:             &packets[2], IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16));",
          "3088:     FAIL_IF_NOT(BuildIpv4TestPacketWithContent(",
          "3089:             &packets[3], IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8));",
          "3091:     FAIL_IF_NOT(BuildIpv4TestPacketWithContent(",
          "3092:             &packets[4], IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8));",
          "3094:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "3095:     FAIL_IF_NOT_NULL(r);",
          "3097:     r = Defrag(NULL, NULL, packets[1]);",
          "3098:     FAIL_IF_NOT_NULL(r);",
          "3100:     r = Defrag(NULL, NULL, packets[2]);",
          "3101:     FAIL_IF_NOT_NULL(r);",
          "3103:     r = Defrag(NULL, NULL, packets[3]);",
          "3104:     FAIL_IF_NOT_NULL(r);",
          "3106:     r = Defrag(NULL, NULL, packets[4]);",
          "3107:     FAIL_IF_NOT_NULL(r);",
          "3109: #if 0",
          "3110:     PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);",
          "3111: #endif",
          "3113:     for (int i = 0; i < 5; i++) {",
          "3114:         SCFree(packets[i]);",
          "3115:     }",
          "3117:     DefragDestroy();",
          "3119:     PASS;",
          "3120: }",
          "3122: static int DefragBsdMissingFragmentIpv6Test(void)",
          "3123: {",
          "3124:     DefragInit();",
          "3125:     default_policy = DEFRAG_POLICY_BSD;",
          "3126:     Packet *packets[5];",
          "3128:     packets[0] = BuildIpv6TestPacketWithContent(",
          "3129:             IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);",
          "3131:     packets[1] =",
          "3132:             BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);",
          "3134:     packets[2] = BuildIpv6TestPacketWithContent(",
          "3135:             IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);",
          "3138:     packets[3] = BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);",
          "3140:     packets[4] =",
          "3141:             BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);",
          "3143:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "3144:     FAIL_IF_NOT_NULL(r);",
          "3146:     r = Defrag(NULL, NULL, packets[1]);",
          "3147:     FAIL_IF_NOT_NULL(r);",
          "3149:     r = Defrag(NULL, NULL, packets[2]);",
          "3150:     FAIL_IF_NOT_NULL(r);",
          "3152:     r = Defrag(NULL, NULL, packets[3]);",
          "3153:     FAIL_IF_NOT_NULL(r);",
          "3155:     r = Defrag(NULL, NULL, packets[4]);",
          "3156:     FAIL_IF_NOT_NULL(r);",
          "3158: #if 0",
          "3159:     PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);",
          "3160: #endif",
          "3162:     for (int i = 0; i < 5; i++) {",
          "3163:         SCFree(packets[i]);",
          "3164:     }",
          "3166:     DefragDestroy();",
          "3168:     PASS;",
          "3169: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3107:             DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2);",
          "3108:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2\",",
          "3109:             DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2);",
          "3111: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3221:     UtRegisterTest(\"DefragBsdMissingFragmentIpv4Test\", DefragBsdMissingFragmentIpv4Test);",
          "3222:     UtRegisterTest(\"DefragBsdMissingFragmentIpv6Test\", DefragBsdMissingFragmentIpv6Test);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e6267758ed5da27f804f0c1c07f9423bdf4d72b8",
      "candidate_info": {
        "commit_hash": "e6267758ed5da27f804f0c1c07f9423bdf4d72b8",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/e6267758ed5da27f804f0c1c07f9423bdf4d72b8",
        "files": [
          "src/defrag.c"
        ],
        "message": "defrag: fix check for complete packet\n\nThe list of fragments may still contain overlaps, so adding up the\nfragment lengths is flawed. Instead track the largest size of\ncontiguous data that can be re-assembled.\n\nBug: #6675\n(cherry picked from commit d226d0a3fce8837936e1bdfaee496c80d417e0a5)",
        "before_after_code_files": [
          "src/defrag.c||src/defrag.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/defrag.c||src/defrag.c"
          ],
          "candidate": [
            "src/defrag.c||src/defrag.c"
          ]
        }
      },
      "candidate_diff": {
        "src/defrag.c||src/defrag.c": [
          "File: src/defrag.c -> src/defrag.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "256:             goto done;",
          "257:         }",
          "258:         else {",
          "260:         }",
          "261:     }",
          "",
          "[Removed Lines]",
          "259:             len += frag->data_len;",
          "",
          "[Added Lines]",
          "260:             len = MAX(len, frag->offset + frag->data_len);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "414:                 goto done;",
          "415:             }",
          "416:             else {",
          "418:             }",
          "419:         }",
          "420:     }",
          "",
          "[Removed Lines]",
          "417:                 len += frag->data_len;",
          "",
          "[Added Lines]",
          "418:                 len = MAX(len, frag->offset + frag->data_len);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3011:     PASS;",
          "3012: }",
          "3016: void DefragRegisterTests(void)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3026: static int DefragBsdMissingFragmentIpv4Test(void)",
          "3027: {",
          "3028:     DefragInit();",
          "3029:     default_policy = DEFRAG_POLICY_BSD;",
          "3030:     Packet *packets[5];",
          "3032:     packets[0] = BuildIpv4TestPacketWithContent(",
          "3033:             IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);",
          "3035:     packets[1] =",
          "3036:             BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);",
          "3038:     packets[2] = BuildIpv4TestPacketWithContent(",
          "3039:             IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);",
          "3042:     packets[3] = BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);",
          "3044:     packets[4] =",
          "3045:             BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);",
          "3047:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "3048:     FAIL_IF_NOT_NULL(r);",
          "3050:     r = Defrag(NULL, NULL, packets[1]);",
          "3051:     FAIL_IF_NOT_NULL(r);",
          "3053:     r = Defrag(NULL, NULL, packets[2]);",
          "3054:     FAIL_IF_NOT_NULL(r);",
          "3056:     r = Defrag(NULL, NULL, packets[3]);",
          "3057:     FAIL_IF_NOT_NULL(r);",
          "3059:     r = Defrag(NULL, NULL, packets[4]);",
          "3060:     FAIL_IF_NOT_NULL(r);",
          "3062: #if 0",
          "3063:     PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);",
          "3064: #endif",
          "3066:     for (int i = 0; i < 5; i++) {",
          "3067:         SCFree(packets[i]);",
          "3068:     }",
          "3070:     DefragDestroy();",
          "3072:     PASS;",
          "3073: }",
          "3075: static int DefragBsdMissingFragmentIpv6Test(void)",
          "3076: {",
          "3077:     DefragInit();",
          "3078:     default_policy = DEFRAG_POLICY_BSD;",
          "3079:     Packet *packets[5];",
          "3081:     packets[0] = BuildIpv6TestPacketWithContent(",
          "3082:             IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);",
          "3084:     packets[1] =",
          "3085:             BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);",
          "3087:     packets[2] = BuildIpv6TestPacketWithContent(",
          "3088:             IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);",
          "3091:     packets[3] = BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);",
          "3093:     packets[4] =",
          "3094:             BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);",
          "3096:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "3097:     FAIL_IF_NOT_NULL(r);",
          "3099:     r = Defrag(NULL, NULL, packets[1]);",
          "3100:     FAIL_IF_NOT_NULL(r);",
          "3102:     r = Defrag(NULL, NULL, packets[2]);",
          "3103:     FAIL_IF_NOT_NULL(r);",
          "3105:     r = Defrag(NULL, NULL, packets[3]);",
          "3106:     FAIL_IF_NOT_NULL(r);",
          "3108:     r = Defrag(NULL, NULL, packets[4]);",
          "3109:     FAIL_IF_NOT_NULL(r);",
          "3111: #if 0",
          "3112:     PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);",
          "3113: #endif",
          "3115:     for (int i = 0; i < 5; i++) {",
          "3116:         SCFree(packets[i]);",
          "3117:     }",
          "3119:     DefragDestroy();",
          "3121:     PASS;",
          "3122: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3059:             DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test);",
          "3060:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2\", DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2);",
          "3061:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2\", DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2);",
          "3063: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3172:     UtRegisterTest(\"DefragBsdMissingFragmentIpv4Test\", DefragBsdMissingFragmentIpv4Test);",
          "3173:     UtRegisterTest(\"DefragBsdMissingFragmentIpv6Test\", DefragBsdMissingFragmentIpv6Test);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "414f97c6695c5a2e1d378a36a6f50d7288767634",
      "candidate_info": {
        "commit_hash": "414f97c6695c5a2e1d378a36a6f50d7288767634",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/414f97c6695c5a2e1d378a36a6f50d7288767634",
        "files": [
          "src/defrag.c"
        ],
        "message": "defrag: fix subsequent overlap of start of original (bsd)\n\nFix the BSD policy case where a subsequent fragment starts before an\noriginal fragment and overlaps the beginning of the original\nfragment. In this case the overlapping data from the new fragment is\npreferred.\n\nSuricata was preferring the data from the original fragment, but it\nshould only do that when the original fragment has an offset <= to the\nnew fragment.\n\n- Adds tests for this case\n\nBug: #6669\n(cherry picked from commit f1709ea551124e1a64fdc509993ad022ab27aa77)",
        "before_after_code_files": [
          "src/defrag.c||src/defrag.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/defrag.c||src/defrag.c"
          ],
          "candidate": [
            "src/defrag.c||src/defrag.c"
          ]
        }
      },
      "candidate_diff": {
        "src/defrag.c||src/defrag.c": [
          "File: src/defrag.c -> src/defrag.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "112: {",
          "113:     if (frag->pkt != NULL)",
          "114:         SCFree(frag->pkt);",
          "",
          "[Removed Lines]",
          "110: static void",
          "111: DefragFragReset(Frag *frag)",
          "",
          "[Added Lines]",
          "110: static void DefragFragReset(Frag *frag)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "123: {",
          "124:     Frag *frag = data;",
          "",
          "[Removed Lines]",
          "121: static int",
          "122: DefragFragInit(void *data, void *initdata)",
          "",
          "[Added Lines]",
          "120: static int DefragFragInit(void *data, void *initdata)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "135: {",
          "136:     Frag *frag, *tmp;",
          "139:     SCMutexLock(&defrag_context->frag_pool_lock);",
          "142:         RB_REMOVE(IP_FRAGMENTS, &tracker->fragment_tree, frag);",
          "143:         DefragFragReset(frag);",
          "144:         PoolReturn(defrag_context->frag_pool, frag);",
          "",
          "[Removed Lines]",
          "133: void",
          "134: DefragTrackerFreeFrags(DefragTracker *tracker)",
          "141:     RB_FOREACH_SAFE(frag, IP_FRAGMENTS, &tracker->fragment_tree, tmp) {",
          "",
          "[Added Lines]",
          "131: void DefragTrackerFreeFrags(DefragTracker *tracker)",
          "138:     RB_FOREACH_SAFE (frag, IP_FRAGMENTS, &tracker->fragment_tree, tmp) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "158: {",
          "159:     DefragContext *dc;",
          "",
          "[Removed Lines]",
          "156: static DefragContext *",
          "157: DefragContextNew(void)",
          "",
          "[Added Lines]",
          "153: static DefragContext *DefragContextNew(void)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "174:         frag_pool_size = DEFAULT_DEFRAG_POOL_SIZE;",
          "175:     }",
          "176:     intmax_t frag_pool_prealloc = frag_pool_size / 2;",
          "180:     if (dc->frag_pool == NULL) {",
          "183:     }",
          "184:     if (SCMutexInit(&dc->frag_pool_lock, NULL) != 0) {",
          "187:     }",
          "190:     intmax_t timeout;",
          "191:     if (!ConfGetInt(\"defrag.timeout\", &timeout)) {",
          "192:         dc->timeout = TIMEOUT_DEFAULT;",
          "195:         if (timeout < TIMEOUT_MIN) {",
          "202:         }",
          "203:         dc->timeout = timeout;",
          "204:     }",
          "206:     SCLogDebug(\"Defrag Initialized:\");",
          "213:     return dc;",
          "214: }",
          "218: {",
          "219:     if (dc == NULL)",
          "220:         return;",
          "",
          "[Removed Lines]",
          "177:     dc->frag_pool = PoolInit(frag_pool_size, frag_pool_prealloc,",
          "178:         sizeof(Frag),",
          "179:         NULL, DefragFragInit, dc, NULL, NULL);",
          "181:             FatalError(SC_ERR_FATAL,",
          "182:                        \"Defrag: Failed to initialize fragment pool.\");",
          "185:             FatalError(SC_ERR_FATAL,",
          "186:                        \"Defrag: Failed to initialize frag pool mutex.\");",
          "193:     }",
          "194:     else {",
          "196:                 FatalError(SC_ERR_FATAL,",
          "197:                            \"defrag: Timeout less than minimum allowed value.\");",
          "198:         }",
          "199:         else if (timeout > TIMEOUT_MAX) {",
          "200:                 FatalError(SC_ERR_FATAL,",
          "201:                            \"defrag: Tiemout greater than maximum allowed value.\");",
          "207:     SCLogDebug(\"\\tTimeout: %\"PRIuMAX, (uintmax_t)dc->timeout);",
          "208:     SCLogDebug(\"\\tMaximum defrag trackers: %\"PRIuMAX, tracker_pool_size);",
          "209:     SCLogDebug(\"\\tPreallocated defrag trackers: %\"PRIuMAX, tracker_pool_size);",
          "210:     SCLogDebug(\"\\tMaximum fragments: %\"PRIuMAX, (uintmax_t)frag_pool_size);",
          "211:     SCLogDebug(\"\\tPreallocated fragments: %\"PRIuMAX, (uintmax_t)frag_pool_prealloc);",
          "216: static void",
          "217: DefragContextDestroy(DefragContext *dc)",
          "",
          "[Added Lines]",
          "173:     dc->frag_pool = PoolInit(",
          "174:             frag_pool_size, frag_pool_prealloc, sizeof(Frag), NULL, DefragFragInit, dc, NULL, NULL);",
          "176:         FatalError(SC_ERR_FATAL, \"Defrag: Failed to initialize fragment pool.\");",
          "179:         FatalError(SC_ERR_FATAL, \"Defrag: Failed to initialize frag pool mutex.\");",
          "186:     } else {",
          "188:             FatalError(SC_ERR_FATAL, \"defrag: Timeout less than minimum allowed value.\");",
          "189:         } else if (timeout > TIMEOUT_MAX) {",
          "190:             FatalError(SC_ERR_FATAL, \"defrag: Tiemout greater than maximum allowed value.\");",
          "196:     SCLogDebug(\"\\tTimeout: %\" PRIuMAX, (uintmax_t)dc->timeout);",
          "197:     SCLogDebug(\"\\tMaximum defrag trackers: %\" PRIuMAX, tracker_pool_size);",
          "198:     SCLogDebug(\"\\tPreallocated defrag trackers: %\" PRIuMAX, tracker_pool_size);",
          "199:     SCLogDebug(\"\\tMaximum fragments: %\" PRIuMAX, (uintmax_t)frag_pool_size);",
          "200:     SCLogDebug(\"\\tPreallocated fragments: %\" PRIuMAX, (uintmax_t)frag_pool_prealloc);",
          "205: static void DefragContextDestroy(DefragContext *dc)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "233: {",
          "234:     Packet *rp = NULL;",
          "",
          "[Removed Lines]",
          "231: static Packet *",
          "232: Defrag4Reassemble(ThreadVars *tv, DefragTracker *tracker, Packet *p)",
          "",
          "[Added Lines]",
          "219: static Packet *Defrag4Reassemble(ThreadVars *tv, DefragTracker *tracker, Packet *p)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "255:     Frag *frag = NULL;",
          "256:     size_t len = 0;",
          "258:         if (frag->offset > len) {",
          "261:             goto done;",
          "264:             len += frag->data_len;",
          "265:         }",
          "266:     }",
          "",
          "[Removed Lines]",
          "257:     RB_FOREACH_FROM(frag, IP_FRAGMENTS, first) {",
          "262:         }",
          "263:         else {",
          "",
          "[Added Lines]",
          "244:     RB_FOREACH_FROM (frag, IP_FRAGMENTS, first) {",
          "249:         } else {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "270:     rp = PacketDefragPktSetup(p, NULL, 0, IPV4_GET_IPPROTO(p));",
          "271:     if (rp == NULL) {",
          "272:         SCLogError(SC_ERR_MEM_ALLOC, \"Failed to allocate packet for \"",
          "274:         goto error_remove_tracker;",
          "275:     }",
          "276:     PKT_SET_SRC(rp, PKT_SRC_DEFRAG);",
          "",
          "[Removed Lines]",
          "273:                    \"fragmentation re-assembly, dumping fragments.\");",
          "",
          "[Added Lines]",
          "259:                                      \"fragmentation re-assembly, dumping fragments.\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "286:     uint16_t prev_offset = 0;",
          "287:     bool more_frags = 1;",
          "",
          "[Removed Lines]",
          "289:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree) {",
          "290:         SCLogDebug(\"frag %p, data_len %u, offset %u, pcap_cnt %\"PRIu64,",
          "291:                 frag, frag->data_len, frag->offset, frag->pcap_cnt);",
          "",
          "[Added Lines]",
          "275:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree)",
          "276:     {",
          "277:         SCLogDebug(\"frag %p, data_len %u, offset %u, pcap_cnt %\" PRIu64, frag, frag->data_len,",
          "278:                 frag->offset, frag->pcap_cnt);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "314:             fragmentable_offset = frag->ip_hdr_offset + frag->hlen;",
          "315:             fragmentable_len = frag->data_len;",
          "318:             int pkt_end = fragmentable_offset + frag->offset + frag->data_len;",
          "319:             if (pkt_end > (int)MAX_PAYLOAD_SIZE) {",
          "321:                         \"fragmented packet, exceeds size of packet buffer.\");",
          "322:                 goto error_remove_tracker;",
          "323:             }",
          "328:                 goto error_remove_tracker;",
          "329:             }",
          "330:             if (frag->offset + frag->data_len > fragmentable_len)",
          "",
          "[Removed Lines]",
          "316:         }",
          "317:         else {",
          "320:                 SCLogWarning(SC_ERR_REASSEMBLY, \"Failed re-assemble \"",
          "324:             if (PacketCopyDataOffset(rp,",
          "325:                     fragmentable_offset + frag->offset + frag->ltrim,",
          "326:                     frag->pkt + frag->data_offset + frag->ltrim,",
          "327:                     frag->data_len - frag->ltrim) == -1) {",
          "",
          "[Added Lines]",
          "303:         } else {",
          "306:                 SCLogWarning(SC_ERR_REASSEMBLY,",
          "307:                         \"Failed re-assemble \"",
          "311:             if (PacketCopyDataOffset(rp, fragmentable_offset + frag->offset + frag->ltrim,",
          "312:                         frag->pkt + frag->data_offset + frag->ltrim,",
          "313:                         frag->data_len - frag->ltrim) == -1) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "343:         prev_offset = frag->offset;",
          "344:     }",
          "349:     rp->ip4h = (IPV4Hdr *)(GET_PKT_DATA(rp) + ip_hdr_offset);",
          "350:     int old = rp->ip4h->ip_len + rp->ip4h->ip_off;",
          "351:     rp->ip4h->ip_len = htons(fragmentable_len + hlen);",
          "352:     rp->ip4h->ip_off = 0;",
          "355:     SET_PKT_LEN(rp, ip_hdr_offset + hlen + fragmentable_len);",
          "357:     tracker->remove = 1;",
          "",
          "[Removed Lines]",
          "346:     SCLogDebug(\"ip_hdr_offset %u, hlen %u, fragmentable_len %u\",",
          "347:             ip_hdr_offset, hlen, fragmentable_len);",
          "353:     rp->ip4h->ip_csum = FixChecksum(rp->ip4h->ip_csum,",
          "354:         old, rp->ip4h->ip_len + rp->ip4h->ip_off);",
          "",
          "[Added Lines]",
          "332:     SCLogDebug(\"ip_hdr_offset %u, hlen %u, fragmentable_len %u\", ip_hdr_offset, hlen,",
          "333:             fragmentable_len);",
          "339:     rp->ip4h->ip_csum = FixChecksum(rp->ip4h->ip_csum, old, rp->ip4h->ip_len + rp->ip4h->ip_off);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "377: {",
          "378:     Packet *rp = NULL;",
          "",
          "[Removed Lines]",
          "375: static Packet *",
          "376: Defrag6Reassemble(ThreadVars *tv, DefragTracker *tracker, Packet *p)",
          "",
          "[Added Lines]",
          "360: static Packet *Defrag6Reassemble(ThreadVars *tv, DefragTracker *tracker, Packet *p)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "398:     size_t len = 0;",
          "399:     Frag *frag = NULL;",
          "401:         if (frag->skip) {",
          "402:             continue;",
          "403:         }",
          "",
          "[Removed Lines]",
          "400:     RB_FOREACH_FROM(frag, IP_FRAGMENTS, first) {",
          "",
          "[Added Lines]",
          "384:     RB_FOREACH_FROM (frag, IP_FRAGMENTS, first) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "407:                 goto done;",
          "408:             }",
          "409:             len = frag->data_len;",
          "412:             if (frag->offset > len) {",
          "415:                 goto done;",
          "418:                 len += frag->data_len;",
          "419:             }",
          "420:         }",
          "",
          "[Removed Lines]",
          "410:         }",
          "411:         else {",
          "416:             }",
          "417:             else {",
          "",
          "[Added Lines]",
          "394:         } else {",
          "399:             } else {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "427:     if (rp == NULL) {",
          "428:         SCLogError(SC_ERR_MEM_ALLOC, \"Failed to allocate packet for \"",
          "430:         goto error_remove_tracker;",
          "431:     }",
          "432:     PKT_SET_SRC(rp, PKT_SRC_DEFRAG);",
          "",
          "[Removed Lines]",
          "425:     rp = PacketDefragPktSetup(p, (uint8_t *)p->ip6h,",
          "426:             IPV6_GET_PLEN(p) + sizeof(IPV6Hdr), 0);",
          "429:                 \"fragmentation re-assembly, dumping fragments.\");",
          "",
          "[Added Lines]",
          "407:     rp = PacketDefragPktSetup(p, (uint8_t *)p->ip6h, IPV6_GET_PLEN(p) + sizeof(IPV6Hdr), 0);",
          "410:                                      \"fragmentation re-assembly, dumping fragments.\");",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "443:     uint16_t prev_offset = 0;",
          "444:     bool more_frags = 1;",
          "447:         if (!more_frags && frag->offset > prev_offset) {",
          "448:             break;",
          "449:         }",
          "",
          "[Removed Lines]",
          "446:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree) {",
          "",
          "[Added Lines]",
          "427:     RB_FOREACH(frag, IP_FRAGMENTS, &tracker->fragment_tree)",
          "428:     {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "452:         if (frag->data_len - frag->ltrim <= 0)",
          "453:             continue;",
          "454:         if (frag->offset == 0) {",
          "457:             next_hdr = frag_hdr->ip6fh_nxt;",
          "",
          "[Removed Lines]",
          "455:             IPV6FragHdr *frag_hdr = (IPV6FragHdr *)(frag->pkt +",
          "456:                 frag->frag_hdr_offset);",
          "",
          "[Added Lines]",
          "437:             IPV6FragHdr *frag_hdr = (IPV6FragHdr *)(frag->pkt + frag->frag_hdr_offset);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "462:             if (PacketCopyData(rp, frag->pkt, frag->frag_hdr_offset) == -1)",
          "463:                 goto error_remove_tracker;",
          "464:             if (PacketCopyDataOffset(rp, frag->frag_hdr_offset,",
          "467:                 goto error_remove_tracker;",
          "468:             ip_hdr_offset = frag->ip_hdr_offset;",
          "",
          "[Removed Lines]",
          "465:                 frag->pkt + frag->frag_hdr_offset + sizeof(IPV6FragHdr),",
          "466:                 frag->data_len) == -1)",
          "",
          "[Added Lines]",
          "446:                         frag->pkt + frag->frag_hdr_offset + sizeof(IPV6FragHdr),",
          "447:                         frag->data_len) == -1)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "478:             unfragmentable_len = (fragmentable_offset - ip_hdr_offset) - IPV6_HEADER_LEN;",
          "479:             if (unfragmentable_len >= fragmentable_offset)",
          "480:                 goto error_remove_tracker;",
          "483:             if (PacketCopyDataOffset(rp, fragmentable_offset + frag->offset + frag->ltrim,",
          "486:                 goto error_remove_tracker;",
          "487:             if (frag->offset + frag->data_len > fragmentable_len)",
          "488:                 fragmentable_len = frag->offset + frag->data_len;",
          "",
          "[Removed Lines]",
          "481:         }",
          "482:         else {",
          "484:                 frag->pkt + frag->data_offset + frag->ltrim,",
          "485:                 frag->data_len - frag->ltrim) == -1)",
          "",
          "[Added Lines]",
          "462:         } else {",
          "464:                         frag->pkt + frag->data_offset + frag->ltrim,",
          "465:                         frag->data_len - frag->ltrim) == -1)",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "509:     if (unfragmentable_len == 0)",
          "510:         rp->ip6h->s_ip6_nxt = next_hdr;",
          "514:     tracker->remove = 1;",
          "515:     DefragTrackerFreeFrags(tracker);",
          "",
          "[Removed Lines]",
          "511:     SET_PKT_LEN(rp, ip_hdr_offset + sizeof(IPV6Hdr) +",
          "512:             unfragmentable_len + fragmentable_len);",
          "",
          "[Added Lines]",
          "491:     SET_PKT_LEN(rp, ip_hdr_offset + sizeof(IPV6Hdr) + unfragmentable_len + fragmentable_len);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "535:     if (a->offset < b->offset) {",
          "536:         return -1;",
          "537:     }",
          "",
          "[Removed Lines]",
          "534: int DefragRbFragCompare(struct Frag_ *a, struct Frag_ *b) {",
          "",
          "[Added Lines]",
          "513: int DefragRbFragCompare(struct Frag_ *a, struct Frag_ *b)",
          "514: {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "548: {",
          "549:     Packet *r = NULL;",
          "550:     int ltrim = 0;",
          "",
          "[Removed Lines]",
          "546: static Packet *",
          "547: DefragInsertFrag(ThreadVars *tv, DecodeThreadVars *dtv, DefragTracker *tracker, Packet *p)",
          "",
          "[Added Lines]",
          "526: static Packet *DefragInsertFrag(",
          "527:         ThreadVars *tv, DecodeThreadVars *dtv, DefragTracker *tracker, Packet *p)",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "599:             ENGINE_SET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE);",
          "600:             return NULL;",
          "601:         }",
          "604:         more_frags = IPV6_EXTHDR_GET_FH_FLAG(p);",
          "605:         frag_offset = IPV6_EXTHDR_GET_FH_OFFSET(p);",
          "606:         data_offset = p->ip6eh.fh_data_offset;",
          "",
          "[Removed Lines]",
          "602:     }",
          "603:     else if (tracker->af == AF_INET6) {",
          "",
          "[Added Lines]",
          "582:     } else if (tracker->af == AF_INET6) {",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "610:         frag_hdr_offset = p->ip6eh.fh_header_offset;",
          "612:         SCLogDebug(\"mf %s frag_offset %u data_offset %u, data_len %u, \"",
          "618:         if (ip_hdr_offset + IPV6_HEADER_LEN < frag_hdr_offset) {",
          "",
          "[Removed Lines]",
          "613:                 \"frag_end %u, ip_hdr_offset %u, frag_hdr_offset %u\",",
          "614:                 more_frags ? \"true\" : \"false\", frag_offset, data_offset,",
          "615:                 data_len, frag_end, ip_hdr_offset, frag_hdr_offset);",
          "",
          "[Added Lines]",
          "592:                    \"frag_end %u, ip_hdr_offset %u, frag_hdr_offset %u\",",
          "593:                 more_frags ? \"true\" : \"false\", frag_offset, data_offset, data_len, frag_end,",
          "594:                 ip_hdr_offset, frag_hdr_offset);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "634:             ENGINE_SET_EVENT(p, IPV6_FRAG_PKT_TOO_LARGE);",
          "635:             return NULL;",
          "636:         }",
          "639:         DEBUG_VALIDATE_BUG_ON(1);",
          "640:         return NULL;",
          "641:     }",
          "",
          "[Removed Lines]",
          "637:     }",
          "638:     else {",
          "",
          "[Added Lines]",
          "616:     } else {",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "672:             }",
          "674:             switch (tracker->policy) {",
          "682:                     }",
          "686:                     }",
          "770:                     }",
          "774:                     }",
          "795:                     }",
          "801:             }",
          "803:         next:",
          "",
          "[Removed Lines]",
          "675:             case DEFRAG_POLICY_BSD:",
          "676:                 if (frag_offset < prev->offset + prev->data_len) {",
          "677:                     if (frag_offset >= prev->offset) {",
          "678:                         ltrim = prev->offset + prev->data_len - frag_offset;",
          "679:                     }",
          "680:                     if ((next != NULL) && (frag_end > next->offset)) {",
          "681:                         next->ltrim = frag_end - next->offset;",
          "683:                     if ((frag_offset < prev->offset) &&",
          "684:                         (frag_end >= prev->offset + prev->data_len)) {",
          "685:                         prev->skip = 1;",
          "687:                     goto insert;",
          "688:                 }",
          "689:                 break;",
          "690:             case DEFRAG_POLICY_LINUX:",
          "698:                 if (prev->offset + prev->ltrim < frag_offset + ltrim &&",
          "699:                         prev->offset + prev->data_len > frag_offset + ltrim) {",
          "700:                     ltrim += prev->offset + prev->data_len - frag_offset;",
          "701:                 }",
          "711:                 if (frag_offset + ltrim < prev->offset + prev->ltrim &&",
          "712:                         frag_end > prev->offset + prev->ltrim) {",
          "713:                     prev->ltrim += frag_end - (prev->offset + prev->ltrim);",
          "714:                     goto insert;",
          "715:                 }",
          "722:                 if (frag_offset + ltrim <= prev->offset + prev->ltrim &&",
          "723:                         frag_end >= prev->offset + prev->data_len) {",
          "724:                     prev->skip = 1;",
          "725:                     goto insert;",
          "726:                 }",
          "728:                 break;",
          "729:             case DEFRAG_POLICY_WINDOWS:",
          "731:                 if (frag_offset + ltrim >= prev->offset + ltrim &&",
          "732:                         frag_end <= prev->offset + prev->data_len) {",
          "733:                     goto done;",
          "734:                 }",
          "738:                 if (frag_offset + ltrim < prev->offset + ltrim &&",
          "739:                         frag_end > prev->offset + prev->data_len) {",
          "740:                     prev->skip = 1;",
          "741:                     goto insert;",
          "742:                 }",
          "751:                 if (frag_offset + ltrim > prev->offset + prev->ltrim &&",
          "752:                         frag_offset + ltrim < prev->offset + prev->data_len) {",
          "753:                     ltrim += prev->offset + prev->data_len - frag_offset;",
          "754:                     goto insert;",
          "755:                 }",
          "760:                 if (frag_offset + ltrim == prev->offset + ltrim &&",
          "761:                         frag_end > prev->offset + prev->data_len) {",
          "762:                     ltrim += prev->offset + prev->data_len - frag_offset;",
          "763:                     goto insert;",
          "764:                 }",
          "765:                 break;",
          "766:             case DEFRAG_POLICY_SOLARIS:",
          "767:                 if (frag_offset < prev->offset + prev->data_len) {",
          "768:                     if (frag_offset >= prev->offset) {",
          "769:                         ltrim = prev->offset + prev->data_len - frag_offset;",
          "771:                     if ((frag_offset < prev->offset) &&",
          "772:                         (frag_end >= prev->offset + prev->data_len)) {",
          "773:                         prev->skip = 1;",
          "775:                     goto insert;",
          "776:                 }",
          "777:                 break;",
          "778:             case DEFRAG_POLICY_FIRST:",
          "779:                 if ((frag_offset >= prev->offset) &&",
          "780:                     (frag_end <= prev->offset + prev->data_len)) {",
          "781:                     goto done;",
          "782:                 }",
          "783:                 if (frag_offset < prev->offset) {",
          "784:                     goto insert;",
          "785:                 }",
          "786:                 if (frag_offset < prev->offset + prev->data_len) {",
          "787:                     ltrim = prev->offset + prev->data_len - frag_offset;",
          "788:                     goto insert;",
          "789:                 }",
          "790:                 break;",
          "791:             case DEFRAG_POLICY_LAST:",
          "792:                 if (frag_offset <= prev->offset) {",
          "793:                     if (frag_end > prev->offset) {",
          "794:                         prev->ltrim = frag_end - prev->offset;",
          "796:                     goto insert;",
          "797:                 }",
          "798:                 break;",
          "799:             default:",
          "800:                 break;",
          "",
          "[Added Lines]",
          "653:                 case DEFRAG_POLICY_BSD:",
          "654:                     if (frag_offset < prev->offset + prev->data_len) {",
          "655:                         if (prev->offset <= frag_offset) {",
          "660:                             uint16_t prev_end = prev->offset + prev->data_len;",
          "661:                             if (prev_end > frag_end) {",
          "664:                                 goto done;",
          "665:                             }",
          "666:                             ltrim = prev_end - frag_offset;",
          "668:                             if ((next != NULL) && (frag_end > next->offset)) {",
          "669:                                 next->ltrim = frag_end - next->offset;",
          "670:                             }",
          "672:                             goto insert;",
          "673:                         }",
          "683:                         if (frag_offset <= prev->offset && frag_end > prev->offset + prev->ltrim) {",
          "684:                             uint16_t prev_ltrim = frag_end - prev->offset;",
          "685:                             if (prev_ltrim > prev->ltrim) {",
          "686:                                 prev->ltrim = prev_ltrim;",
          "687:                             }",
          "688:                         }",
          "690:                         if ((next != NULL) && (frag_end > next->offset)) {",
          "691:                             next->ltrim = frag_end - next->offset;",
          "692:                         }",
          "694:                         goto insert;",
          "696:                     break;",
          "697:                 case DEFRAG_POLICY_LINUX:",
          "705:                     if (prev->offset + prev->ltrim < frag_offset + ltrim &&",
          "706:                             prev->offset + prev->data_len > frag_offset + ltrim) {",
          "707:                         ltrim += prev->offset + prev->data_len - frag_offset;",
          "718:                     if (frag_offset + ltrim < prev->offset + prev->ltrim &&",
          "719:                             frag_end > prev->offset + prev->ltrim) {",
          "720:                         prev->ltrim += frag_end - (prev->offset + prev->ltrim);",
          "721:                         goto insert;",
          "722:                     }",
          "729:                     if (frag_offset + ltrim <= prev->offset + prev->ltrim &&",
          "730:                             frag_end >= prev->offset + prev->data_len) {",
          "731:                         prev->skip = 1;",
          "732:                         goto insert;",
          "733:                     }",
          "735:                     break;",
          "736:                 case DEFRAG_POLICY_WINDOWS:",
          "738:                     if (frag_offset + ltrim >= prev->offset + ltrim &&",
          "739:                             frag_end <= prev->offset + prev->data_len) {",
          "740:                         goto done;",
          "741:                     }",
          "745:                     if (frag_offset + ltrim < prev->offset + ltrim &&",
          "746:                             frag_end > prev->offset + prev->data_len) {",
          "747:                         prev->skip = 1;",
          "748:                         goto insert;",
          "749:                     }",
          "758:                     if (frag_offset + ltrim > prev->offset + prev->ltrim &&",
          "759:                             frag_offset + ltrim < prev->offset + prev->data_len) {",
          "760:                         ltrim += prev->offset + prev->data_len - frag_offset;",
          "761:                         goto insert;",
          "762:                     }",
          "767:                     if (frag_offset + ltrim == prev->offset + ltrim &&",
          "768:                             frag_end > prev->offset + prev->data_len) {",
          "769:                         ltrim += prev->offset + prev->data_len - frag_offset;",
          "770:                         goto insert;",
          "772:                     break;",
          "773:                 case DEFRAG_POLICY_SOLARIS:",
          "774:                     if (frag_offset < prev->offset + prev->data_len) {",
          "775:                         if (frag_offset >= prev->offset) {",
          "776:                             ltrim = prev->offset + prev->data_len - frag_offset;",
          "777:                         }",
          "778:                         if ((frag_offset < prev->offset) &&",
          "779:                                 (frag_end >= prev->offset + prev->data_len)) {",
          "780:                             prev->skip = 1;",
          "781:                         }",
          "782:                         goto insert;",
          "784:                     break;",
          "785:                 case DEFRAG_POLICY_FIRST:",
          "786:                     if ((frag_offset >= prev->offset) &&",
          "787:                             (frag_end <= prev->offset + prev->data_len)) {",
          "788:                         goto done;",
          "790:                     if (frag_offset < prev->offset) {",
          "791:                         goto insert;",
          "792:                     }",
          "793:                     if (frag_offset < prev->offset + prev->data_len) {",
          "794:                         ltrim = prev->offset + prev->data_len - frag_offset;",
          "795:                         goto insert;",
          "796:                     }",
          "797:                     break;",
          "798:                 case DEFRAG_POLICY_LAST:",
          "799:                     if (frag_offset <= prev->offset) {",
          "800:                         if (frag_end > prev->offset) {",
          "801:                             prev->ltrim = frag_end - prev->offset;",
          "802:                         }",
          "803:                         goto insert;",
          "804:                     }",
          "805:                     break;",
          "806:                 default:",
          "807:                     break;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "890:             r = Defrag4Reassemble(tv, tracker, p);",
          "891:             if (r != NULL && tv != NULL && dtv != NULL) {",
          "892:                 StatsIncr(tv, dtv->counter_defrag_ipv4_reassembled);",
          "896:                     UNSET_TUNNEL_PKT(r);",
          "897:                     r->root = NULL;",
          "",
          "[Removed Lines]",
          "893:                 if (DecodeIPV4(tv, dtv, r, (void *)r->ip4h,",
          "894:                                IPV4_GET_IPLEN(r)) != TM_ECODE_OK) {",
          "",
          "[Added Lines]",
          "900:                 if (DecodeIPV4(tv, dtv, r, (void *)r->ip4h, IPV4_GET_IPLEN(r)) != TM_ECODE_OK) {",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "901:                     PacketDefragPktSetupParent(p);",
          "902:                 }",
          "903:             }",
          "906:             r = Defrag6Reassemble(tv, tracker, p);",
          "907:             if (r != NULL && tv != NULL && dtv != NULL) {",
          "908:                 StatsIncr(tv, dtv->counter_defrag_ipv6_reassembled);",
          "909:                 if (DecodeIPV6(tv, dtv, r, (uint8_t *)r->ip6h,",
          "913:                     UNSET_TUNNEL_PKT(r);",
          "914:                     r->root = NULL;",
          "",
          "[Removed Lines]",
          "904:         }",
          "905:         else if (tracker->af == AF_INET6) {",
          "910:                                IPV6_GET_PLEN(r) + IPV6_HEADER_LEN)",
          "911:                                != TM_ECODE_OK) {",
          "",
          "[Added Lines]",
          "910:         } else if (tracker->af == AF_INET6) {",
          "915:                             IPV6_GET_PLEN(r) + IPV6_HEADER_LEN) != TM_ECODE_OK) {",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "921:         }",
          "922:     }",
          "925: done:",
          "926:     if (overlap) {",
          "927:         if (af == AF_INET) {",
          "928:             ENGINE_SET_EVENT(p, IPV4_FRAG_OVERLAP);",
          "931:             ENGINE_SET_EVENT(p, IPV6_FRAG_OVERLAP);",
          "932:         }",
          "933:     }",
          "",
          "[Removed Lines]",
          "929:         }",
          "930:         else {",
          "",
          "[Added Lines]",
          "932:         } else {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "947: {",
          "948:     int policy = -1;",
          "950:     if (PKT_IS_IPV4(p)) {",
          "951:         policy = SCHInfoGetIPv4HostOSFlavour((uint8_t *)GET_IPV4_DST_ADDR_PTR(p));",
          "954:         policy = SCHInfoGetIPv6HostOSFlavour((uint8_t *)GET_IPV6_DST_ADDR(p));",
          "955:     }",
          "",
          "[Removed Lines]",
          "945: uint8_t",
          "946: DefragGetOsPolicy(Packet *p)",
          "952:     }",
          "953:     else if (PKT_IS_IPV6(p)) {",
          "",
          "[Added Lines]",
          "947: uint8_t DefragGetOsPolicy(Packet *p)",
          "953:     } else if (PKT_IS_IPV6(p)) {",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "963:     switch (policy) {",
          "1002:     }",
          "1003: }",
          "1010: {",
          "1011:     return DefragGetTrackerFromHash(p);",
          "1012: }",
          "",
          "[Removed Lines]",
          "965:     case OS_POLICY_BSD:",
          "966:     case OS_POLICY_HPUX10:",
          "967:     case OS_POLICY_IRIX:",
          "968:         return DEFRAG_POLICY_BSD;",
          "971:     case OS_POLICY_BSD_RIGHT:",
          "972:         return DEFRAG_POLICY_BSD_RIGHT;",
          "975:     case OS_POLICY_OLD_LINUX:",
          "976:     case OS_POLICY_LINUX:",
          "977:         return DEFRAG_POLICY_LINUX;",
          "980:     case OS_POLICY_OLD_SOLARIS:",
          "981:     case OS_POLICY_HPUX11:",
          "982:     case OS_POLICY_MACOS:",
          "983:     case OS_POLICY_FIRST:",
          "984:         return DEFRAG_POLICY_FIRST;",
          "987:     case OS_POLICY_SOLARIS:",
          "988:         return DEFRAG_POLICY_SOLARIS;",
          "991:     case OS_POLICY_WINDOWS:",
          "992:     case OS_POLICY_VISTA:",
          "993:     case OS_POLICY_WINDOWS2K3:",
          "994:         return DEFRAG_POLICY_WINDOWS;",
          "997:     case OS_POLICY_LAST:",
          "998:         return DEFRAG_POLICY_LAST;",
          "1000:     default:",
          "1001:         return default_policy;",
          "1008: static DefragTracker *",
          "1009: DefragGetTracker(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p)",
          "",
          "[Added Lines]",
          "965:         case OS_POLICY_BSD:",
          "966:         case OS_POLICY_HPUX10:",
          "967:         case OS_POLICY_IRIX:",
          "968:             return DEFRAG_POLICY_BSD;",
          "971:         case OS_POLICY_BSD_RIGHT:",
          "972:             return DEFRAG_POLICY_BSD_RIGHT;",
          "975:         case OS_POLICY_OLD_LINUX:",
          "976:         case OS_POLICY_LINUX:",
          "977:             return DEFRAG_POLICY_LINUX;",
          "980:         case OS_POLICY_OLD_SOLARIS:",
          "981:         case OS_POLICY_HPUX11:",
          "982:         case OS_POLICY_MACOS:",
          "983:         case OS_POLICY_FIRST:",
          "984:             return DEFRAG_POLICY_FIRST;",
          "987:         case OS_POLICY_SOLARIS:",
          "988:             return DEFRAG_POLICY_SOLARIS;",
          "991:         case OS_POLICY_WINDOWS:",
          "992:         case OS_POLICY_VISTA:",
          "993:         case OS_POLICY_WINDOWS2K3:",
          "994:             return DEFRAG_POLICY_WINDOWS;",
          "997:         case OS_POLICY_LAST:",
          "998:             return DEFRAG_POLICY_LAST;",
          "1000:         default:",
          "1001:             return default_policy;",
          "1008: static DefragTracker *DefragGetTracker(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p)",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1026: {",
          "1027:     uint16_t frag_offset;",
          "1028:     uint8_t more_frags;",
          "",
          "[Removed Lines]",
          "1024: Packet *",
          "1025: Defrag(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p)",
          "",
          "[Added Lines]",
          "1023: Packet *Defrag(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p)",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1033:         af = AF_INET;",
          "1034:         more_frags = IPV4_GET_MF(p);",
          "1035:         frag_offset = IPV4_GET_IPOFFSET(p);",
          "1038:         af = AF_INET6;",
          "1039:         frag_offset = IPV6_EXTHDR_GET_FH_OFFSET(p);",
          "1040:         more_frags = IPV6_EXTHDR_GET_FH_FLAG(p);",
          "1043:         return NULL;",
          "1044:     }",
          "",
          "[Removed Lines]",
          "1036:     }",
          "1037:     else if (PKT_IS_IPV6(p)) {",
          "1041:     }",
          "1042:     else {",
          "",
          "[Added Lines]",
          "1034:     } else if (PKT_IS_IPV6(p)) {",
          "1038:     } else {",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1050:     if (tv != NULL && dtv != NULL) {",
          "1051:         if (af == AF_INET) {",
          "1052:             StatsIncr(tv, dtv->counter_defrag_ipv4_fragments);",
          "1055:             StatsIncr(tv, dtv->counter_defrag_ipv6_fragments);",
          "1056:         }",
          "1057:     }",
          "",
          "[Removed Lines]",
          "1053:         }",
          "1054:         else if (af == AF_INET6) {",
          "",
          "[Added Lines]",
          "1049:         } else if (af == AF_INET6) {",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1071:     return rp;",
          "1072: }",
          "1076: {",
          "1077:     intmax_t tracker_pool_size;",
          "1078:     if (!ConfGetInt(\"defrag.trackers\", &tracker_pool_size)) {",
          "",
          "[Removed Lines]",
          "1074: void",
          "1075: DefragInit(void)",
          "",
          "[Added Lines]",
          "1069: void DefragInit(void)",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1086:     defrag_context = DefragContextNew();",
          "1087:     if (defrag_context == NULL) {",
          "1090:     }",
          "1092:     DefragSetDefaultTimeout(defrag_context->timeout);",
          "",
          "[Removed Lines]",
          "1088:             FatalError(SC_ERR_FATAL,",
          "1089:                        \"Failed to allocate memory for the Defrag module.\");",
          "",
          "[Added Lines]",
          "1082:         FatalError(SC_ERR_FATAL, \"Failed to allocate memory for the Defrag module.\");",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1180:     return NULL;",
          "1181: }",
          "1183: static Packet *BuildIpv6TestPacket(",
          "1184:         uint8_t proto, uint32_t id, uint16_t off, int mf, const uint8_t content, int content_len)",
          "1185: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1180: static Packet *BuildIpv4TestPacketWithContent(",
          "1181:         uint8_t proto, uint16_t id, uint16_t off, int mf, const uint8_t *content, int content_len)",
          "1182: {",
          "1183:     Packet *p = NULL;",
          "1184:     int hlen = 20;",
          "1185:     int ttl = 64;",
          "1186:     IPV4Hdr ip4h;",
          "1188:     p = SCCalloc(1, sizeof(*p) + default_packet_size);",
          "1189:     if (unlikely(p == NULL))",
          "1190:         return NULL;",
          "1192:     PACKET_INITIALIZE(p);",
          "1194:     gettimeofday(&p->ts, NULL);",
          "1195:     ip4h.ip_verhl = 4 << 4;",
          "1196:     ip4h.ip_verhl |= hlen >> 2;",
          "1197:     ip4h.ip_len = htons(hlen + content_len);",
          "1198:     ip4h.ip_id = htons(id);",
          "1199:     if (mf)",
          "1200:         ip4h.ip_off = htons(IP_MF | off);",
          "1201:     else",
          "1202:         ip4h.ip_off = htons(off);",
          "1203:     ip4h.ip_ttl = ttl;",
          "1204:     ip4h.ip_proto = proto;",
          "1210:     PacketCopyData(p, (uint8_t *)&ip4h, sizeof(ip4h));",
          "1211:     p->ip4h = (IPV4Hdr *)GET_PKT_DATA(p);",
          "1212:     SET_IPV4_SRC_ADDR(p, &p->src);",
          "1213:     SET_IPV4_DST_ADDR(p, &p->dst);",
          "1215:     PacketCopyDataOffset(p, hlen, content, content_len);",
          "1216:     SET_PKT_LEN(p, hlen + content_len);",
          "1218:     p->ip4h->ip_csum = IPV4Checksum((uint16_t *)GET_PKT_DATA(p), hlen, 0);",
          "1221:     if (IPV4_GET_VER(p) != 4)",
          "1222:         goto error;",
          "1223:     if (IPV4_GET_HLEN(p) != hlen)",
          "1224:         goto error;",
          "1225:     if (IPV4_GET_IPLEN(p) != hlen + content_len)",
          "1226:         goto error;",
          "1227:     if (IPV4_GET_IPID(p) != id)",
          "1228:         goto error;",
          "1229:     if (IPV4_GET_IPOFFSET(p) != off)",
          "1230:         goto error;",
          "1231:     if (IPV4_GET_MF(p) != mf)",
          "1232:         goto error;",
          "1233:     if (IPV4_GET_IPTTL(p) != ttl)",
          "1234:         goto error;",
          "1235:     if (IPV4_GET_IPPROTO(p) != proto)",
          "1236:         goto error;",
          "1238:     return p;",
          "1239: error:",
          "1240:     if (p != NULL)",
          "1241:         SCFree(p);",
          "1242:     return NULL;",
          "1243: }",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1249:     return NULL;",
          "1250: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1314: static Packet *BuildIpv6TestPacketWithContent(",
          "1315:         uint8_t proto, uint32_t id, uint16_t off, int mf, const uint8_t *content, int content_len)",
          "1316: {",
          "1317:     Packet *p = NULL;",
          "1318:     IPV6Hdr ip6h;",
          "1320:     p = SCCalloc(1, sizeof(*p) + default_packet_size);",
          "1321:     if (unlikely(p == NULL))",
          "1322:         return NULL;",
          "1324:     PACKET_INITIALIZE(p);",
          "1326:     gettimeofday(&p->ts, NULL);",
          "1328:     ip6h.s_ip6_nxt = 44;",
          "1329:     ip6h.s_ip6_hlim = 2;",
          "1332:     ip6h.s_ip6_src[0] = 0x01010101;",
          "1333:     ip6h.s_ip6_src[1] = 0x01010101;",
          "1334:     ip6h.s_ip6_src[2] = 0x01010101;",
          "1335:     ip6h.s_ip6_src[3] = 0x01010101;",
          "1336:     ip6h.s_ip6_dst[0] = 0x02020202;",
          "1337:     ip6h.s_ip6_dst[1] = 0x02020202;",
          "1338:     ip6h.s_ip6_dst[2] = 0x02020202;",
          "1339:     ip6h.s_ip6_dst[3] = 0x02020202;",
          "1342:     PacketCopyData(p, (uint8_t *)&ip6h, sizeof(IPV6Hdr));",
          "1344:     p->ip6h = (IPV6Hdr *)GET_PKT_DATA(p);",
          "1345:     IPV6_SET_RAW_VER(p->ip6h, 6);",
          "1347:     IPV6FragHdr *fh = (IPV6FragHdr *)(GET_PKT_DATA(p) + sizeof(IPV6Hdr));",
          "1348:     fh->ip6fh_nxt = proto;",
          "1349:     fh->ip6fh_ident = htonl(id);",
          "1350:     fh->ip6fh_offlg = htons((off << 3) | mf);",
          "1352:     DecodeIPV6FragHeader(p, (uint8_t *)fh, 8, 8 + content_len, 0);",
          "1354:     PacketCopyDataOffset(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr), content, content_len);",
          "1355:     SET_PKT_LEN(p, sizeof(IPV6Hdr) + sizeof(IPV6FragHdr) + content_len);",
          "1357:     p->ip6h->s_ip6_plen = htons(sizeof(IPV6FragHdr) + content_len);",
          "1359:     SET_IPV6_SRC_ADDR(p, &p->src);",
          "1360:     SET_IPV6_DST_ADDR(p, &p->dst);",
          "1363:     if (IPV6_GET_VER(p) != 6)",
          "1364:         goto error;",
          "1365:     if (IPV6_GET_NH(p) != 44)",
          "1366:         goto error;",
          "1367:     if (IPV6_GET_PLEN(p) != sizeof(IPV6FragHdr) + content_len)",
          "1368:         goto error;",
          "1370:     return p;",
          "1371: error:",
          "1372:     if (p != NULL)",
          "1373:         SCFree(p);",
          "1374:     return NULL;",
          "1375: }",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1554:     FAIL_IF(IPV4_GET_IPLEN(reassembled) != 20 + 192);",
          "1555:     FAIL_IF(expected_len != 192);",
          "1558:     SCFree(reassembled);",
          "",
          "[Removed Lines]",
          "1557:     FAIL_IF(memcmp(GET_PKT_DATA(reassembled) + 20, expected, expected_len) != 0);",
          "",
          "[Added Lines]",
          "1682:     if (memcmp(expected, GET_PKT_DATA(reassembled) + 20, expected_len) != 0) {",
          "1683:         printf(\"Expected:\\n\");",
          "1684:         PrintRawDataFp(stdout, expected, expected_len);",
          "1685:         printf(\"Got:\\n\");",
          "1686:         PrintRawDataFp(stdout, GET_PKT_DATA(reassembled) + 20, GET_PKT_LEN(reassembled) - 20);",
          "1687:         FAIL;",
          "1688:     }",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1703: #define D_10  'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'",
          "1704: #define D_11  'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q', 'Q'",
          "1708: {",
          "1710:     uint8_t expected[] = {",
          "",
          "[Removed Lines]",
          "1706: static int",
          "1707: DefragSturgesNovakBsdTest(void)",
          "",
          "[Added Lines]",
          "1837: static int DefragSturgesNovakBsdTest(void)",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1734:         D_11,",
          "1735:     };",
          "1739:     PASS;",
          "1740: }",
          "",
          "[Removed Lines]",
          "1737:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_BSD, expected,",
          "1738:                     sizeof(expected)));",
          "",
          "[Added Lines]",
          "1867:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_BSD, expected, sizeof(expected)));",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1803:         D_11,",
          "1804:     };",
          "1808:     PASS;",
          "1809: }",
          "",
          "[Removed Lines]",
          "1806:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_LINUX, expected,",
          "1807:                     sizeof(expected)));",
          "",
          "[Added Lines]",
          "1935:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_LINUX, expected, sizeof(expected)));",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1872:         D_11,",
          "1873:     };",
          "1877:     PASS;",
          "1878: }",
          "",
          "[Removed Lines]",
          "1875:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_WINDOWS, expected,",
          "1876:                     sizeof(expected)));",
          "",
          "[Added Lines]",
          "2003:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_WINDOWS, expected, sizeof(expected)));",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1941:         D_11,",
          "1942:     };",
          "1946:     PASS;",
          "1947: }",
          "",
          "[Removed Lines]",
          "1944:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_SOLARIS, expected,",
          "1945:                     sizeof(expected)));",
          "",
          "[Added Lines]",
          "2071:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_SOLARIS, expected, sizeof(expected)));",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "2010:         D_11,",
          "2011:     };",
          "2015:     PASS;",
          "2016: }",
          "",
          "[Removed Lines]",
          "2013:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_FIRST, expected,",
          "2014:                     sizeof(expected)));",
          "",
          "[Added Lines]",
          "2139:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_FIRST, expected, sizeof(expected)));",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "2048:     return DefragDoSturgesNovakIpv6Test(DEFRAG_POLICY_FIRST, expected, sizeof(expected));",
          "2049: }",
          "2053: {",
          "2055:     uint8_t expected[] = {",
          "",
          "[Removed Lines]",
          "2051: static int",
          "2052: DefragSturgesNovakLastTest(void)",
          "",
          "[Added Lines]",
          "2176: static int DefragSturgesNovakLastTest(void)",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "2079:         D_11,",
          "2080:     };",
          "2084:     PASS;",
          "2085: }",
          "",
          "[Removed Lines]",
          "2082:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_LAST, expected,",
          "2083:                     sizeof(expected)));",
          "",
          "[Added Lines]",
          "2206:     FAIL_IF_NOT(DefragDoSturgesNovakTest(DEFRAG_POLICY_LAST, expected, sizeof(expected)));",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "2603:     PASS;",
          "2604: }",
          "2608: void DefragRegisterTests(void)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2739: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2(void)",
          "2740: {",
          "2741:     DefragInit();",
          "2742:     default_policy = DEFRAG_POLICY_BSD;",
          "2743:     Packet *packets[4];",
          "2746:     packets[0] = BuildIpv4TestPacketWithContent(",
          "2747:             IPPROTO_ICMP, 6, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);",
          "2750:     packets[1] = BuildIpv4TestPacketWithContent(",
          "2751:             IPPROTO_ICMP, 6, 8 >> 3, 1, (uint8_t *)\"AACCBBDDAACCDDBB\", 16);",
          "2754:     packets[2] = BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 6, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);",
          "2757:     packets[3] =",
          "2758:             BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 6, 32 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);",
          "2760:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2761:     FAIL_IF_NOT_NULL(r);",
          "2763:     r = Defrag(NULL, NULL, packets[1]);",
          "2764:     FAIL_IF_NOT_NULL(r);",
          "2766:     r = Defrag(NULL, NULL, packets[2]);",
          "2767:     FAIL_IF_NOT_NULL(r);",
          "2769:     r = Defrag(NULL, NULL, packets[3]);",
          "2770:     FAIL_IF_NULL(r);",
          "2773:     const uint8_t expected[] = {",
          "2778:  'A', 'A', 'C', 'C', 'B', 'B', 'D', 'D',",
          "2779:  'A', 'A', 'C', 'C', 'D', 'D', 'B', 'B',",
          "2780:  'A', 'A', 'B', 'B', 'D', 'D', 'C', 'C',",
          "2781:  'D', 'D', 'C', 'C', 'B', 'B', 'A', 'A',",
          "2782:     };",
          "2785:     FAIL_IF(memcmp(expected, GET_PKT_DATA(r) + 20 + 8, sizeof(expected)) != 0);",
          "2787:     DefragDestroy();",
          "2788:     PASS;",
          "2789: }",
          "2791: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2(void)",
          "2792: {",
          "2793:     DefragInit();",
          "2794:     default_policy = DEFRAG_POLICY_BSD;",
          "2795:     Packet *packets[4];",
          "2798:     packets[0] = BuildIpv6TestPacketWithContent(",
          "2799:             IPPROTO_ICMP, 6, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);",
          "2802:     packets[1] = BuildIpv6TestPacketWithContent(",
          "2803:             IPPROTO_ICMP, 6, 8 >> 3, 1, (uint8_t *)\"AACCBBDDAACCDDBB\", 16);",
          "2806:     packets[2] = BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 6, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);",
          "2809:     packets[3] =",
          "2810:             BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 6, 32 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);",
          "2812:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2813:     FAIL_IF_NOT_NULL(r);",
          "2815:     r = Defrag(NULL, NULL, packets[1]);",
          "2816:     FAIL_IF_NOT_NULL(r);",
          "2818:     r = Defrag(NULL, NULL, packets[2]);",
          "2819:     FAIL_IF_NOT_NULL(r);",
          "2821:     r = Defrag(NULL, NULL, packets[3]);",
          "2822:     FAIL_IF_NULL(r);",
          "2825:     const uint8_t expected[] = {",
          "2830:  'A', 'A', 'C', 'C', 'B', 'B', 'D', 'D',",
          "2831:  'A', 'A', 'C', 'C', 'D', 'D', 'B', 'B',",
          "2832:  'A', 'A', 'B', 'B', 'D', 'D', 'C', 'C',",
          "2833:  'D', 'D', 'C', 'C', 'B', 'B', 'A', 'A',",
          "2834:     };",
          "2837:     FAIL_IF(memcmp(expected, GET_PKT_DATA(r) + 40 + 8, sizeof(expected)) != 0);",
          "2839:     DefragDestroy();",
          "2840:     PASS;",
          "2841: }",
          "2855: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test(void)",
          "2856: {",
          "2857:     DefragInit();",
          "2858:     default_policy = DEFRAG_POLICY_BSD;",
          "2859:     Packet *packets[2];",
          "2861:     packets[0] = BuildIpv4TestPacket(IPPROTO_ICMP, 1, 8 >> 3, 0, 'E', 24);",
          "2862:     packets[1] = BuildIpv4TestPacket(IPPROTO_ICMP, 1, 0, 1, 'M', 24);",
          "2864:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2865:     FAIL_IF_NOT_NULL(r);",
          "2867:     r = Defrag(NULL, NULL, packets[1]);",
          "2868:     FAIL_IF_NULL(r);",
          "2871:     const uint8_t expected[] = {",
          "2872:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "2873:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "2874:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "2875:  'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E',",
          "2876:     };",
          "2879:     if (memcmp(expected, GET_PKT_DATA(r) + 20, sizeof(expected)) != 0) {",
          "2880:         printf(\"Expected:\\n\");",
          "2881:         PrintRawDataFp(stdout, expected, sizeof(expected));",
          "2882:         printf(\"Got:\\n\");",
          "2883:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);",
          "2884:         FAIL;",
          "2885:     }",
          "2887:     PASS;",
          "2888: }",
          "2890: static int DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test(void)",
          "2891: {",
          "2892:     DefragInit();",
          "2893:     default_policy = DEFRAG_POLICY_BSD;",
          "2894:     Packet *packets[2];",
          "2896:     packets[0] = BuildIpv6TestPacket(IPPROTO_ICMP, 1, 8 >> 3, 0, 'E', 24);",
          "2897:     packets[1] = BuildIpv6TestPacket(IPPROTO_ICMP, 1, 0, 1, 'M', 24);",
          "2899:     Packet *r = Defrag(NULL, NULL, packets[0]);",
          "2900:     FAIL_IF_NOT_NULL(r);",
          "2902:     r = Defrag(NULL, NULL, packets[1]);",
          "2903:     FAIL_IF_NULL(r);",
          "2906:     const uint8_t expected[] = {",
          "2907:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "2908:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "2909:  'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M',",
          "2910:  'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E',",
          "2911:     };",
          "2914:     if (memcmp(expected, GET_PKT_DATA(r) + 40, sizeof(expected)) != 0) {",
          "2915:         printf(\"Expected:\\n\");",
          "2916:         PrintRawDataFp(stdout, expected, sizeof(expected));",
          "2917:         printf(\"Got:\\n\");",
          "2918:         PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);",
          "2919:         FAIL;",
          "2920:     }",
          "2922:     PASS;",
          "2923: }",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "2611:     UtRegisterTest(\"DefragInOrderSimpleTest\", DefragInOrderSimpleTest);",
          "2612:     UtRegisterTest(\"DefragReverseSimpleTest\", DefragReverseSimpleTest);",
          "2613:     UtRegisterTest(\"DefragSturgesNovakBsdTest\", DefragSturgesNovakBsdTest);",
          "2620:     UtRegisterTest(\"DefragSturgesNovakFirstTest\", DefragSturgesNovakFirstTest);",
          "2621:     UtRegisterTest(\"DefragSturgesNovakLastTest\", DefragSturgesNovakLastTest);",
          "",
          "[Removed Lines]",
          "2614:     UtRegisterTest(\"DefragSturgesNovakLinuxIpv4Test\",",
          "2615:             DefragSturgesNovakLinuxIpv4Test);",
          "2616:     UtRegisterTest(\"DefragSturgesNovakWindowsIpv4Test\",",
          "2617:                    DefragSturgesNovakWindowsIpv4Test);",
          "2618:     UtRegisterTest(\"DefragSturgesNovakSolarisTest\",",
          "2619:                    DefragSturgesNovakSolarisTest);",
          "",
          "[Added Lines]",
          "2933:     UtRegisterTest(\"DefragSturgesNovakLinuxIpv4Test\", DefragSturgesNovakLinuxIpv4Test);",
          "2934:     UtRegisterTest(\"DefragSturgesNovakWindowsIpv4Test\", DefragSturgesNovakWindowsIpv4Test);",
          "2935:     UtRegisterTest(\"DefragSturgesNovakSolarisTest\", DefragSturgesNovakSolarisTest);",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "2645:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv4Test\", DefragBsdFragmentAfterNoMfIpv4Test);",
          "2646:     UtRegisterTest(\"DefragBsdFragmentAfterNoMfIpv6Test\", DefragBsdFragmentAfterNoMfIpv6Test);",
          "2648: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2963:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test\",",
          "2964:             DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test);",
          "2965:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test\",",
          "2966:             DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test);",
          "2967:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2\",",
          "2968:             DefragBsdSubsequentOverlapsStartOfOriginalIpv4Test_2);",
          "2969:     UtRegisterTest(\"DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2\",",
          "2970:             DefragBsdSubsequentOverlapsStartOfOriginalIpv6Test_2);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
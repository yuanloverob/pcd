{
  "cve_id": "CVE-2019-15164",
  "cve_desc": "rpcapd/daemon.c in libpcap before 1.9.1 allows SSRF because a URL may be provided as a capture source.",
  "repo": "the-tcpdump-group/libpcap",
  "patch_hash": "33834cb2a4d035b52aa2a26742f832a112e90a0a",
  "patch_info": {
    "commit_hash": "33834cb2a4d035b52aa2a26742f832a112e90a0a",
    "repo": "the-tcpdump-group/libpcap",
    "commit_url": "https://github.com/the-tcpdump-group/libpcap/commit/33834cb2a4d035b52aa2a26742f832a112e90a0a",
    "files": [
      "rpcapd/daemon.c"
    ],
    "message": "In the open request, reject capture sources that are URLs.\n\nYou shouldn't be able to ask a server to open a remote device on some\n*other* server; just open it yourself.\n\nThis addresses Include Security issue F13: [libpcap] Remote Packet\nCapture Daemon Allows Opening Capture URLs.",
    "before_after_code_files": [
      "rpcapd/daemon.c||rpcapd/daemon.c"
    ]
  },
  "patch_diff": {
    "rpcapd/daemon.c||rpcapd/daemon.c": [
      "File: rpcapd/daemon.c -> rpcapd/daemon.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "156: static int rpcapd_discard(SOCKET sock, uint32 len);",
      "157: static void session_close(struct session *);",
      "159: int",
      "160: daemon_serviceloop(SOCKET sockctrl, int isactive, char *passiveClients,",
      "161:     int nullAuthAllowed)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "159: static int is_url(const char *source);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1554:  source[nread] = '\\0';",
      "1555:  plen -= nread;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1561:  if (is_url(source))",
      "1562:  {",
      "1563:   pcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string refers to a remote device\");",
      "1564:   goto error;",
      "1565:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2647:   session->fp = NULL;",
      "2648:  }",
      "2649: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2663: static int",
      "2664: is_url(const char *source)",
      "2665: {",
      "2666:  char *colonp;",
      "2688:  colonp = strchr(source, ':');",
      "2689:  if (colonp == NULL)",
      "2690:  {",
      "2694:   return (0);",
      "2695:  }",
      "2707:  if (strncmp(colonp + 1, \"//\", 2) != 0)",
      "2708:  {",
      "2712:   return (0);",
      "2713:  }",
      "2718:  return (1);",
      "2719: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9df01dba7d4a698dbfec57e678e5a73dae93fa6d",
      "candidate_info": {
        "commit_hash": "9df01dba7d4a698dbfec57e678e5a73dae93fa6d",
        "repo": "the-tcpdump-group/libpcap",
        "commit_url": "https://github.com/the-tcpdump-group/libpcap/commit/9df01dba7d4a698dbfec57e678e5a73dae93fa6d",
        "files": [
          "rpcapd/daemon.c"
        ],
        "message": "In the open request, reject capture sources that are URLs.\n\nYou shouldn't be able to ask a server to open a remote device on some\n*other* server; just open it yourself.\n\nThis addresses Include Security issue F13: [libpcap] Remote Packet\nCapture Daemon Allows Opening Capture URLs.",
        "before_after_code_files": [
          "rpcapd/daemon.c||rpcapd/daemon.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "rpcapd/daemon.c||rpcapd/daemon.c"
          ],
          "candidate": [
            "rpcapd/daemon.c||rpcapd/daemon.c"
          ]
        }
      },
      "candidate_diff": {
        "rpcapd/daemon.c||rpcapd/daemon.c": [
          "File: rpcapd/daemon.c -> rpcapd/daemon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "197: #define TLS_ALERT_LEVEL_FATAL  2",
          "198: #define TLS_ALERT_HANDSHAKE_FAILURE 40",
          "200: int",
          "201: daemon_serviceloop(SOCKET sockctrl, int isactive, char *passiveClients,",
          "202:     int nullAuthAllowed, int uses_ssl)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "200: static int is_url(const char *source);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1791:  source[nread] = '\\0';",
          "1792:  plen -= nread;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1798:  if (is_url(source))",
          "1799:  {",
          "1800:   snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string refers to a remote device\");",
          "1801:   goto error;",
          "1802:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2950:   session->fp = NULL;",
          "2951:  }",
          "2952: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2966: static int",
          "2967: is_url(const char *source)",
          "2968: {",
          "2969:  char *colonp;",
          "2991:  colonp = strchr(source, ':');",
          "2992:  if (colonp == NULL)",
          "2993:  {",
          "2997:   return (0);",
          "2998:  }",
          "3010:  if (strncmp(colonp + 1, \"//\", 2) != 0)",
          "3011:  {",
          "3015:   return (0);",
          "3016:  }",
          "3021:  return (1);",
          "3022: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
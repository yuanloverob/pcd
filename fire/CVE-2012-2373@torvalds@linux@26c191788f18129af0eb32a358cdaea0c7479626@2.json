{
  "cve_id": "CVE-2012-2373",
  "cve_desc": "The Linux kernel before 3.4.5 on the x86 platform, when Physical Address Extension (PAE) is enabled, does not properly use the Page Middle Directory (PMD), which allows local users to cause a denial of service (panic) via a crafted application that triggers a race condition.",
  "repo": "torvalds/linux",
  "patch_hash": "26c191788f18129af0eb32a358cdaea0c7479626",
  "patch_info": {
    "commit_hash": "26c191788f18129af0eb32a358cdaea0c7479626",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/26c191788f18129af0eb32a358cdaea0c7479626",
    "files": [
      "arch/x86/include/asm/pgtable-3level.h",
      "include/asm-generic/pgtable.h"
    ],
    "message": "mm: pmd_read_atomic: fix 32bit PAE pmd walk vs pmd_populate SMP race condition\n\nWhen holding the mmap_sem for reading, pmd_offset_map_lock should only\nrun on a pmd_t that has been read atomically from the pmdp pointer,\notherwise we may read only half of it leading to this crash.\n\nPID: 11679  TASK: f06e8000  CPU: 3   COMMAND: \"do_race_2_panic\"\n #0 [f06a9dd8] crash_kexec at c049b5ec\n #1 [f06a9e2c] oops_end at c083d1c2\n #2 [f06a9e40] no_context at c0433ded\n #3 [f06a9e64] bad_area_nosemaphore at c043401a\n #4 [f06a9e6c] __do_page_fault at c0434493\n #5 [f06a9eec] do_page_fault at c083eb45\n #6 [f06a9f04] error_code (via page_fault) at c083c5d5\n    EAX: 01fb470c EBX: fff35000 ECX: 00000003 EDX: 00000100 EBP:\n    00000000\n    DS:  007b     ESI: 9e201000 ES:  007b     EDI: 01fb4700 GS:  00e0\n    CS:  0060     EIP: c083bc14 ERR: ffffffff EFLAGS: 00010246\n #7 [f06a9f38] _spin_lock at c083bc14\n #8 [f06a9f44] sys_mincore at c0507b7d\n #9 [f06a9fb0] system_call at c083becd\n                         start           len\n    EAX: ffffffda  EBX: 9e200000  ECX: 00001000  EDX: 6228537f\n    DS:  007b      ESI: 00000000  ES:  007b      EDI: 003d0f00\n    SS:  007b      ESP: 62285354  EBP: 62285388  GS:  0033\n    CS:  0073      EIP: 00291416  ERR: 000000da  EFLAGS: 00000286\n\nThis should be a longstanding bug affecting x86 32bit PAE without THP.\nOnly archs with 64bit large pmd_t and 32bit unsigned long should be\naffected.\n\nWith THP enabled the barrier() in pmd_none_or_trans_huge_or_clear_bad()\nwould partly hide the bug when the pmd transition from none to stable,\nby forcing a re-read of the *pmd in pmd_offset_map_lock, but when THP is\nenabled a new set of problem arises by the fact could then transition\nfreely in any of the none, pmd_trans_huge or pmd_trans_stable states.\nSo making the barrier in pmd_none_or_trans_huge_or_clear_bad()\nunconditional isn't good idea and it would be a flakey solution.\n\nThis should be fully fixed by introducing a pmd_read_atomic that reads\nthe pmd in order with THP disabled, or by reading the pmd atomically\nwith cmpxchg8b with THP enabled.\n\nLuckily this new race condition only triggers in the places that must\nalready be covered by pmd_none_or_trans_huge_or_clear_bad() so the fix\nis localized there but this bug is not related to THP.\n\nNOTE: this can trigger on x86 32bit systems with PAE enabled with more\nthan 4G of ram, otherwise the high part of the pmd will never risk to be\ntruncated because it would be zero at all times, in turn so hiding the\nSMP race.\n\nThis bug was discovered and fully debugged by Ulrich, quote:\n\n----\n[..]\npmd_none_or_trans_huge_or_clear_bad() loads the content of edx and\neax.\n\n    496 static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t\n    *pmd)\n    497 {\n    498         /* depend on compiler for an atomic pmd read */\n    499         pmd_t pmdval = *pmd;\n\n                                // edi = pmd pointer\n0xc0507a74 <sys_mincore+548>:   mov    0x8(%esp),%edi\n...\n                                // edx = PTE page table high address\n0xc0507a84 <sys_mincore+564>:   mov    0x4(%edi),%edx\n...\n                                // eax = PTE page table low address\n0xc0507a8e <sys_mincore+574>:   mov    (%edi),%eax\n\n[..]\n\nPlease note that the PMD is not read atomically. These are two \"mov\"\ninstructions where the high order bits of the PMD entry are fetched\nfirst. Hence, the above machine code is prone to the following race.\n\n-  The PMD entry {high|low} is 0x0000000000000000.\n   The \"mov\" at 0xc0507a84 loads 0x00000000 into edx.\n\n-  A page fault (on another CPU) sneaks in between the two \"mov\"\n   instructions and instantiates the PMD.\n\n-  The PMD entry {high|low} is now 0x00000003fda38067.\n   The \"mov\" at 0xc0507a8e loads 0xfda38067 into eax.\n----\n\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Larry Woodman <lwoodman@redhat.com>\nCc: Petr Matousek <pmatouse@redhat.com>\nCc: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "arch/x86/include/asm/pgtable-3level.h||arch/x86/include/asm/pgtable-3level.h",
      "include/asm-generic/pgtable.h||include/asm-generic/pgtable.h"
    ]
  },
  "patch_diff": {
    "arch/x86/include/asm/pgtable-3level.h||arch/x86/include/asm/pgtable-3level.h": [
      "File: arch/x86/include/asm/pgtable-3level.h -> arch/x86/include/asm/pgtable-3level.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "31:  ptep->pte_low = pte.pte_low;",
      "32: }",
      "34: static inline void native_set_pte_atomic(pte_t *ptep, pte_t pte)",
      "35: {",
      "36:  set_64bit((unsigned long long *)(ptep), native_pte_val(pte));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "34: #define pmd_read_atomic pmd_read_atomic",
      "59: #ifndef CONFIG_TRANSPARENT_HUGEPAGE",
      "60: static inline pmd_t pmd_read_atomic(pmd_t *pmdp)",
      "61: {",
      "62:  pmdval_t ret;",
      "63:  u32 *tmp = (u32 *)pmdp;",
      "65:  ret = (pmdval_t) (*tmp);",
      "66:  if (ret) {",
      "71:   smp_rmb();",
      "72:   ret |= ((pmdval_t)*(tmp + 1)) << 32;",
      "73:  }",
      "75:  return (pmd_t) { ret };",
      "76: }",
      "78: static inline pmd_t pmd_read_atomic(pmd_t *pmdp)",
      "79: {",
      "80:  return (pmd_t) { atomic64_read((atomic64_t *)pmdp) };",
      "81: }",
      "",
      "---------------"
    ],
    "include/asm-generic/pgtable.h||include/asm-generic/pgtable.h": [
      "File: include/asm-generic/pgtable.h -> include/asm-generic/pgtable.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "448: #ifndef pmd_read_atomic",
      "449: static inline pmd_t pmd_read_atomic(pmd_t *pmdp)",
      "450: {",
      "456:  return *pmdp;",
      "457: }",
      "458: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "462: static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)",
      "463: {",
      "",
      "[Removed Lines]",
      "465:  pmd_t pmdval = *pmd;",
      "",
      "[Added Lines]",
      "483:  pmd_t pmdval = pmd_read_atomic(pmd);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5963e317b1e9d2a4511503916d8fd664bb8fa8fb",
      "candidate_info": {
        "commit_hash": "5963e317b1e9d2a4511503916d8fd664bb8fa8fb",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5963e317b1e9d2a4511503916d8fd664bb8fa8fb",
        "files": [
          "arch/x86/kernel/entry_64.S"
        ],
        "message": "ftrace/x86: Do not change stacks in DEBUG when calling lockdep\n\nWhen both DYNAMIC_FTRACE and LOCKDEP are set, the TRACE_IRQS_ON/OFF\nwill call into the lockdep code. The lockdep code can call lots of\nfunctions that may be traced by ftrace. When ftrace is updating its\ncode and hits a breakpoint, the breakpoint handler will call into\nlockdep. If lockdep happens to call a function that also has a breakpoint\nattached, it will jump back into the breakpoint handler resetting\nthe stack to the debug stack and corrupt the contents currently on\nthat stack.\n\nThe 'do_sym' call that calls do_int3() is protected by modifying the\nIST table to point to a different location if another breakpoint is\nhit. But the TRACE_IRQS_OFF/ON are outside that protection, and if\na breakpoint is hit from those, the stack will get corrupted, and\nthe kernel will crash:\n\n[ 1013.243754] BUG: unable to handle kernel NULL pointer dereference at 0000000000000002\n[ 1013.272665] IP: [<ffff880145cc0000>] 0xffff880145cbffff\n[ 1013.285186] PGD 1401b2067 PUD 14324c067 PMD 0\n[ 1013.298832] Oops: 0010 [#1] PREEMPT SMP\n[ 1013.310600] CPU 2\n[ 1013.317904] Modules linked in: ip6t_REJECT nf_conntrack_ipv6 nf_defrag_ipv6 xt_state nf_conntrack ip6table_filter ip6_tables crc32c_intel ghash_clmulni_intel microcode usb_debug serio_raw pcspkr iTCO_wdt i2c_i801 iTCO_vendor_support e1000e nfsd nfs_acl auth_rpcgss lockd sunrpc i915 video i2c_algo_bit drm_kms_helper drm i2c_core [last unloaded: scsi_wait_scan]\n[ 1013.401848]\n[ 1013.407399] Pid: 112, comm: kworker/2:1 Not tainted 3.4.0+ #30\n[ 1013.437943] RIP: 8eb8:[<ffff88014630a000>]  [<ffff88014630a000>] 0xffff880146309fff\n[ 1013.459871] RSP: ffffffff8165e919:ffff88014780f408  EFLAGS: 00010046\n[ 1013.477909] RAX: 0000000000000001 RBX: ffffffff81104020 RCX: 0000000000000000\n[ 1013.499458] RDX: ffff880148008ea8 RSI: ffffffff8131ef40 RDI: ffffffff82203b20\n[ 1013.521612] RBP: ffffffff81005751 R08: 0000000000000000 R09: 0000000000000000\n[ 1013.543121] R10: ffffffff82cdc318 R11: 0000000000000000 R12: ffff880145cc0000\n[ 1013.564614] R13: ffff880148008eb8 R14: 0000000000000002 R15: ffff88014780cb40\n[ 1013.586108] FS:  0000000000000000(0000) GS:ffff880148000000(0000) knlGS:0000000000000000\n[ 1013.609458] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n[ 1013.627420] CR2: 0000000000000002 CR3: 0000000141f10000 CR4: 00000000001407e0\n[ 1013.649051] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ 1013.670724] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n[ 1013.692376] Process kworker/2:1 (pid: 112, threadinfo ffff88013fe0e000, task ffff88014020a6a0)\n[ 1013.717028] Stack:\n[ 1013.724131]  ffff88014780f570 ffff880145cc0000 0000400000004000 0000000000000000\n[ 1013.745918]  cccccccccccccccc ffff88014780cca8 ffffffff811072bb ffffffff81651627\n[ 1013.767870]  ffffffff8118f8a7 ffffffff811072bb ffffffff81f2b6c5 ffffffff81f11bdb\n[ 1013.790021] Call Trace:\n[ 1013.800701] Code: 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a <e7> d7 64 81 ff ff ff ff 01 00 00 00 00 00 00 00 65 d9 64 81 ff\n[ 1013.861443] RIP  [<ffff88014630a000>] 0xffff880146309fff\n[ 1013.884466]  RSP <ffff88014780f408>\n[ 1013.901507] CR2: 0000000000000002\n\nThe solution was to reuse the NMI functions that change the IDT table to make the debug\nstack keep its current stack (in kernel mode) when hitting a breakpoint:\n\n  call debug_stack_set_zero\n  TRACE_IRQS_ON\n  call debug_stack_reset\n\nIf the TRACE_IRQS_ON happens to hit a breakpoint then it will keep the current stack\nand not crash the box.\n\nReported-by: Dave Jones <davej@redhat.com>\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>",
        "before_after_code_files": [
          "arch/x86/kernel/entry_64.S||arch/x86/kernel/entry_64.S"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/x86/kernel/entry_64.S||arch/x86/kernel/entry_64.S": [
          "File: arch/x86/kernel/entry_64.S -> arch/x86/kernel/entry_64.S",
          "--- Hunk 1 ---",
          "[Context before]",
          "190: #endif",
          "191: .endm",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "204: #if defined(CONFIG_DYNAMIC_FTRACE) && defined(CONFIG_TRACE_IRQFLAGS)",
          "206: .macro TRACE_IRQS_OFF_DEBUG",
          "207:  call debug_stack_set_zero",
          "208:  TRACE_IRQS_OFF",
          "209:  call debug_stack_reset",
          "210: .endm",
          "212: .macro TRACE_IRQS_ON_DEBUG",
          "213:  call debug_stack_set_zero",
          "214:  TRACE_IRQS_ON",
          "215:  call debug_stack_reset",
          "216: .endm",
          "218: .macro TRACE_IRQS_IRETQ_DEBUG offset=ARGOFFSET",
          "220:  jnc  1f",
          "221:  TRACE_IRQS_ON_DEBUG",
          "222: 1:",
          "223: .endm",
          "225: #else",
          "226: # define TRACE_IRQS_OFF_DEBUG  TRACE_IRQS_OFF",
          "227: # define TRACE_IRQS_ON_DEBUG  TRACE_IRQS_ON",
          "228: # define TRACE_IRQS_IRETQ_DEBUG  TRACE_IRQS_IRETQ",
          "229: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1098:  subq $ORIG_RAX-R15, %rsp",
          "1099:  CFI_ADJUST_CFA_OFFSET ORIG_RAX-R15",
          "1100:  call save_paranoid",
          "1104:  subq $EXCEPTION_STKSZ, INIT_TSS_IST(\\ist)",
          "",
          "[Removed Lines]",
          "1101:  TRACE_IRQS_OFF",
          "",
          "[Added Lines]",
          "1139:  TRACE_IRQS_OFF_DEBUG",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1393: ENTRY(paranoid_exit)",
          "1394:  DEFAULT_FRAME",
          "1395:  DISABLE_INTERRUPTS(CLBR_NONE)",
          "1398:  jnz paranoid_restore",
          "1399:  testl $3,CS(%rsp)",
          "",
          "[Removed Lines]",
          "1396:  TRACE_IRQS_OFF",
          "",
          "[Added Lines]",
          "1434:  TRACE_IRQS_OFF_DEBUG",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1404:  RESTORE_ALL 8",
          "1405:  jmp irq_return",
          "1406: paranoid_restore:",
          "1408:  RESTORE_ALL 8",
          "1409:  jmp irq_return",
          "1410: paranoid_userspace:",
          "",
          "[Removed Lines]",
          "1407:  TRACE_IRQS_IRETQ 0",
          "",
          "[Added Lines]",
          "1445:  TRACE_IRQS_IRETQ_DEBUG 0",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ffea73fc723a12fdde4c9fb3fcce5d154d1104a1",
      "candidate_info": {
        "commit_hash": "ffea73fc723a12fdde4c9fb3fcce5d154d1104a1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ffea73fc723a12fdde4c9fb3fcce5d154d1104a1",
        "files": [
          "block/cfq-iosched.c"
        ],
        "message": "block: blkcg_policy_cfq shouldn't be used if !CONFIG_CFQ_GROUP_IOSCHED\n\ncfq may be built w/ or w/o blkcg support depending on\nCONFIG_CFQ_CGROUP_IOSCHED.  If blkcg support is disabled, most of\nrelated code is ifdef'd out but some part is left dangling -\nblkcg_policy_cfq is left zero-filled and blkcg_policy_[un]register()\ncalls are made on it.\n\nFeeding zero filled policy to blkcg_policy_register() is incorrect and\ntriggers the following WARN_ON() if CONFIG_BLK_CGROUP &&\n!CONFIG_CFQ_GROUP_IOSCHED.\n\n ------------[ cut here ]------------\n WARNING: at block/blk-cgroup.c:867\n Modules linked in:\n Modules linked in:\n CPU: 3 Not tainted 3.4.0-09547-gfb21aff #1\n Process swapper/0 (pid: 1, task: 000000003ff80000, ksp: 000000003ff7f8b8)\n Krnl PSW : 0704100180000000 00000000003d76ca (blkcg_policy_register+0xca/0xe0)\n\t    R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:0 CC:1 PM:0 EA:3\n Krnl GPRS: 0000000000000000 00000000014b85ec 00000000014b85b0 0000000000000000\n\t    000000000096fb60 0000000000000000 00000000009a8e78 0000000000000048\n\t    000000000099c070 0000000000b6f000 0000000000000000 000000000099c0b8\n\t    00000000014b85b0 0000000000667580 000000003ff7fd98 000000003ff7fd70\n Krnl Code: 00000000003d76be: a7280001           lhi     %r2,1\n\t    00000000003d76c2: a7f4ffdf           brc     15,3d7680\n\t   #00000000003d76c6: a7f40001           brc     15,3d76c8\n\t   >00000000003d76ca: a7c8ffea           lhi     %r12,-22\n\t    00000000003d76ce: a7f4ffce           brc     15,3d766a\n\t    00000000003d76d2: a7f40001           brc     15,3d76d4\n\t    00000000003d76d6: a7c80000           lhi     %r12,0\n\t    00000000003d76da: a7f4ffc2           brc     15,3d765e\n Call Trace:\n ([<0000000000b6f000>] initcall_debug+0x0/0x4)\n  [<0000000000989e8a>] cfq_init+0x62/0xd4\n  [<00000000001000ba>] do_one_initcall+0x3a/0x170\n  [<000000000096fb60>] kernel_init+0x214/0x2bc\n  [<0000000000623202>] kernel_thread_starter+0x6/0xc\n  [<00000000006231fc>] kernel_thread_starter+0x0/0xc\n no locks held by swapper/0/1.\n Last Breaking-Event-Address:\n  [<00000000003d76c6>] blkcg_policy_register+0xc6/0xe0\n ---[ end trace b8ef4903fcbf9dd3 ]---\n\nThis patch fixes the problem by ensuring all blkcg support code is\ninside CONFIG_CFQ_GROUP_IOSCHED.\n\n* blkcg_policy_cfq declaration and blkg_to_cfqg() definition are moved\n  inside the first CONFIG_CFQ_GROUP_IOSCHED block.  __maybe_unused is\n  dropped from blkcg_policy_cfq decl.\n\n* blkcg_deactivate_poilcy() invocation is moved inside ifdef.  This\n  also makes the activation logic match cfq_init_queue().\n\n* All blkcg_policy_[un]register() invocations are moved inside ifdef.\n\nSigned-off-by: Tejun Heo <tj@kernel.org>\nReported-by: Heiko Carstens <heiko.carstens@de.ibm.com>\nLKML-Reference: <20120601112954.GC3535@osiris.boeblingen.de.ibm.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "block/cfq-iosched.c||block/cfq-iosched.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "block/cfq-iosched.c||block/cfq-iosched.c": [
          "File: block/cfq-iosched.c -> block/cfq-iosched.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #include \"blk.h\"",
          "18: #include \"blk-cgroup.h\"",
          "",
          "[Removed Lines]",
          "20: static struct blkcg_policy blkcg_policy_cfq __maybe_unused;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "418:  return pd ? container_of(pd, struct cfq_group, pd) : NULL;",
          "419: }",
          "426: static inline struct blkcg_gq *cfqg_to_blkg(struct cfq_group *cfqg)",
          "427: {",
          "428:  return pd_to_blkg(&cfqg->pd);",
          "",
          "[Removed Lines]",
          "421: static inline struct cfq_group *blkg_to_cfqg(struct blkcg_gq *blkg)",
          "422: {",
          "423:  return pd_to_cfqg(blkg_to_pd(blkg, &blkcg_policy_cfq));",
          "424: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "573: #ifdef CONFIG_CFQ_GROUP_IOSCHED",
          "575: static inline void cfqg_get(struct cfq_group *cfqg)",
          "576: {",
          "577:  return blkg_get(cfqg_to_blkg(cfqg));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "568: static struct blkcg_policy blkcg_policy_cfq;",
          "570: static inline struct cfq_group *blkg_to_cfqg(struct blkcg_gq *blkg)",
          "571: {",
          "572:  return pd_to_cfqg(blkg_to_pd(blkg, &blkcg_policy_cfq));",
          "573: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3952:  cfq_shutdown_timer_wq(cfqd);",
          "3955:  kfree(cfqd->root_group);",
          "3956: #endif",
          "3958:  kfree(cfqd);",
          "3959: }",
          "",
          "[Removed Lines]",
          "3954: #ifndef CONFIG_CFQ_GROUP_IOSCHED",
          "3957:  blkcg_deactivate_policy(q, &blkcg_policy_cfq);",
          "",
          "[Added Lines]",
          "3954: #ifdef CONFIG_CFQ_GROUP_IOSCHED",
          "3955:  blkcg_deactivate_policy(q, &blkcg_policy_cfq);",
          "3956: #else",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4194: #ifdef CONFIG_CFQ_GROUP_IOSCHED",
          "4195:  if (!cfq_group_idle)",
          "4196:   cfq_group_idle = 1;",
          "4201:  ret = blkcg_policy_register(&blkcg_policy_cfq);",
          "4202:  if (ret)",
          "4203:   return ret;",
          "4205:  ret = -ENOMEM;",
          "4206:  cfq_pool = KMEM_CACHE(cfq_queue, 0);",
          "",
          "[Removed Lines]",
          "4197: #else",
          "4198:   cfq_group_idle = 0;",
          "4199: #endif",
          "",
          "[Added Lines]",
          "4202: #else",
          "4203:  cfq_group_idle = 0;",
          "4204: #endif",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4216: err_free_pool:",
          "4217:  kmem_cache_destroy(cfq_pool);",
          "4218: err_pol_unreg:",
          "4219:  blkcg_policy_unregister(&blkcg_policy_cfq);",
          "4220:  return ret;",
          "4221: }",
          "4223: static void __exit cfq_exit(void)",
          "4224: {",
          "4225:  blkcg_policy_unregister(&blkcg_policy_cfq);",
          "4226:  elv_unregister(&iosched_cfq);",
          "4227:  kmem_cache_destroy(cfq_pool);",
          "4228: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4220: #ifdef CONFIG_CFQ_GROUP_IOSCHED",
          "4222: #endif",
          "4228: #ifdef CONFIG_CFQ_GROUP_IOSCHED",
          "4230: #endif",
          "",
          "---------------"
        ]
      }
    }
  ]
}
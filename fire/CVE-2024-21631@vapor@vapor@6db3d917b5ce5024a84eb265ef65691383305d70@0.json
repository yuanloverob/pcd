{
  "cve_id": "CVE-2024-21631",
  "cve_desc": "Vapor is an HTTP web framework for Swift. Prior to version 4.90.0, Vapor's `vapor_urlparser_parse` function uses `uint16_t` indexes when parsing a URI's components, which may cause integer overflows when parsing untrusted inputs. This vulnerability does not affect Vapor directly but could impact applications relying on the URI type for validating user input. The URI type is used in several places in Vapor. A developer may decide to use URI to represent a URL in their application (especially if that URL is then passed to the HTTP Client) and rely on its public properties and methods. However, URI may fail to properly parse a valid (albeit abnormally long) URL, due to string ranges being converted to 16-bit integers. An attacker may use this behavior to trick the application into accepting a URL to an untrusted destination. By padding the port number with zeros, an attacker can cause an integer overflow to occur when the URL authority is parsed and, as a result, spoof the host. Version 4.90.0 contains a patch for this issue. As a workaround, validate user input before parsing as a URI or, if possible, use Foundation's `URL` and `URLComponents` utilities.\n",
  "repo": "vapor/vapor",
  "patch_hash": "6db3d917b5ce5024a84eb265ef65691383305d70",
  "patch_info": {
    "commit_hash": "6db3d917b5ce5024a84eb265ef65691383305d70",
    "repo": "vapor/vapor",
    "commit_url": "https://github.com/vapor/vapor/commit/6db3d917b5ce5024a84eb265ef65691383305d70",
    "files": [
      "Package.swift",
      "Package@swift-5.9.swift",
      "Sources/CVaporURLParser/include/urlparser.h",
      "Sources/CVaporURLParser/urlparser.c",
      "Sources/Vapor/HTTP/EndpointCache.swift",
      "Sources/Vapor/HTTP/Headers/HTTPCookies.swift",
      "Sources/Vapor/Response/Response+Body.swift",
      "Sources/Vapor/Utilities/URI.swift",
      "Tests/VaporTests/ClientTests.swift",
      "Tests/VaporTests/RequestTests.swift",
      "Tests/VaporTests/ServerTests.swift",
      "Tests/VaporTests/URITests.swift",
      "Tests/VaporTests/ValidationTests.swift"
    ],
    "message": "Merge pull request from GHSA-r6r4-5pr8-gjcp\n\n* Replace the ancient CVaporURLParser code with use of Foundation's URLComponents\n\n* Fixes for weird macOS behaviors\n\n* Tests fixup\n\n* Add test for extreme-length untrusted input which triggered failures in the old implementation.\n\n* Fix Sendable warnings across multiple Swift versions\n\n* Indirect through URL to get to URLComponents so parsing is consistent on Linux.\n\n* A couple more test fixes.",
    "before_after_code_files": [
      "Package.swift||Package.swift",
      "Package@swift-5.9.swift||Package@swift-5.9.swift",
      "Sources/CVaporURLParser/include/urlparser.h||Sources/CVaporURLParser/include/urlparser.h",
      "Sources/CVaporURLParser/urlparser.c||Sources/CVaporURLParser/urlparser.c",
      "Sources/Vapor/HTTP/EndpointCache.swift||Sources/Vapor/HTTP/EndpointCache.swift",
      "Sources/Vapor/HTTP/Headers/HTTPCookies.swift||Sources/Vapor/HTTP/Headers/HTTPCookies.swift",
      "Sources/Vapor/Response/Response+Body.swift||Sources/Vapor/Response/Response+Body.swift",
      "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift",
      "Tests/VaporTests/ClientTests.swift||Tests/VaporTests/ClientTests.swift",
      "Tests/VaporTests/RequestTests.swift||Tests/VaporTests/RequestTests.swift",
      "Tests/VaporTests/ServerTests.swift||Tests/VaporTests/ServerTests.swift",
      "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift",
      "Tests/VaporTests/ValidationTests.swift||Tests/VaporTests/ValidationTests.swift"
    ]
  },
  "patch_diff": {
    "Package.swift||Package.swift": [
      "File: Package.swift -> Package.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "66:     targets: [",
      "68:         .target(name: \"CVaporBcrypt\"),",
      "72:         .target(name: \"Vapor\", dependencies: [",
      "",
      "[Removed Lines]",
      "69:         .target(name: \"CVaporURLParser\"),",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "74:             .product(name: \"AsyncKit\", package: \"async-kit\"),",
      "75:             .product(name: \"Backtrace\", package: \"swift-backtrace\"),",
      "76:             .target(name: \"CVaporBcrypt\"),",
      "78:             .product(name: \"ConsoleKit\", package: \"console-kit\"),",
      "79:             .product(name: \"Logging\", package: \"swift-log\"),",
      "80:             .product(name: \"Metrics\", package: \"swift-metrics\"),",
      "",
      "[Removed Lines]",
      "77:             .target(name: \"CVaporURLParser\"),",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Package@swift-5.9.swift||Package@swift-5.9.swift": [
      "File: Package@swift-5.9.swift -> Package@swift-5.9.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "63:     targets: [",
      "65:         .target(name: \"CVaporBcrypt\"),",
      "69:         .target(",
      "70:             name: \"Vapor\",",
      "",
      "[Removed Lines]",
      "66:         .target(name: \"CVaporURLParser\"),",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "72:                 .product(name: \"AsyncHTTPClient\", package: \"async-http-client\"),",
      "73:                 .product(name: \"AsyncKit\", package: \"async-kit\"),",
      "74:                 .target(name: \"CVaporBcrypt\"),",
      "76:                 .product(name: \"ConsoleKit\", package: \"console-kit\"),",
      "77:                 .product(name: \"Logging\", package: \"swift-log\"),",
      "78:                 .product(name: \"Metrics\", package: \"swift-metrics\"),",
      "",
      "[Removed Lines]",
      "75:                 .target(name: \"CVaporURLParser\"),",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "130:                 .copy(\"Utilities/expired.crt\"),",
      "131:                 .copy(\"Utilities/expired.key\"),",
      "132:             ],",
      "134:         ),",
      "135:         .testTarget(",
      "136:             name: \"AsyncTests\",",
      "",
      "[Removed Lines]",
      "133:             swiftSettings: [.enableExperimentalFeature(\"StrictConcurrency=complete\")]",
      "",
      "[Added Lines]",
      "131:             swiftSettings: [",
      "132:                 .enableUpcomingFeature(\"BareSlashRegexLiterals\"),",
      "133:                 .enableExperimentalFeature(\"StrictConcurrency=complete\"),",
      "134:             ]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "138:                 .product(name: \"NIOTestUtils\", package: \"swift-nio\"),",
      "139:                 .target(name: \"XCTVapor\"),",
      "140:             ],",
      "142:         ),",
      "143:     ]",
      "144: )",
      "",
      "[Removed Lines]",
      "141:             swiftSettings: [.enableExperimentalFeature(\"StrictConcurrency=complete\")]",
      "",
      "[Added Lines]",
      "142:             swiftSettings: [",
      "143:                 .enableUpcomingFeature(\"BareSlashRegexLiterals\"),",
      "144:                 .enableExperimentalFeature(\"StrictConcurrency=complete\"),",
      "145:             ]",
      "",
      "---------------"
    ],
    "Sources/CVaporURLParser/include/urlparser.h||Sources/CVaporURLParser/include/urlparser.h": [
      "File: Sources/CVaporURLParser/include/urlparser.h -> Sources/CVaporURLParser/include/urlparser.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Sources/CVaporURLParser/urlparser.c||Sources/CVaporURLParser/urlparser.c": [
      "File: Sources/CVaporURLParser/urlparser.c -> Sources/CVaporURLParser/urlparser.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Sources/Vapor/HTTP/EndpointCache.swift||Sources/Vapor/HTTP/EndpointCache.swift": [
      "File: Sources/Vapor/HTTP/EndpointCache.swift -> Sources/Vapor/HTTP/EndpointCache.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: import Foundation",
      "2: import NIOConcurrencyHelpers",
      "3: import NIOCore",
      "4: import Logging",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #if !canImport(Darwin) && swift(<5.9)",
      "2: @preconcurrency import Foundation",
      "3: #else",
      "5: #endif",
      "",
      "---------------"
    ],
    "Sources/Vapor/HTTP/Headers/HTTPCookies.swift||Sources/Vapor/HTTP/Headers/HTTPCookies.swift": [
      "File: Sources/Vapor/HTTP/Headers/HTTPCookies.swift -> Sources/Vapor/HTTP/Headers/HTTPCookies.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: import Foundation",
      "2: import NIOHTTP1",
      "4: extension HTTPHeaders {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #if !canImport(Darwin) && swift(<5.9)",
      "2: @preconcurrency import Foundation",
      "3: #else",
      "5: #endif",
      "",
      "---------------"
    ],
    "Sources/Vapor/Response/Response+Body.swift||Sources/Vapor/Response/Response+Body.swift": [
      "File: Sources/Vapor/Response/Response+Body.swift -> Sources/Vapor/Response/Response+Body.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: @preconcurrency import Dispatch",
      "2: import Foundation",
      "3: import NIOCore",
      "4: import NIOConcurrencyHelpers",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: #if !canImport(Darwin) && swift(<5.9)",
      "3: @preconcurrency import Foundation",
      "4: #else",
      "6: #endif",
      "",
      "---------------"
    ],
    "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift": [
      "File: Sources/Vapor/Utilities/URI.swift -> Sources/Vapor/Utilities/URI.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "3: public struct URI: Sendable, ExpressibleByStringInterpolation, CustomStringConvertible {",
      "39:     public init(string: String = \"/\") {",
      "41:     }",
      "43:     public var description: String {",
      "45:     }",
      "47:     public init(",
      "48:         scheme: String?,",
      "49:         host: String? = nil,",
      "50:         port: Int? = nil,",
      "51:         path: String,",
      "",
      "[Removed Lines]",
      "1: import CVaporURLParser",
      "5:     public struct Scheme: Sendable, ExpressibleByStringInterpolation {",
      "7:         public static let http: Self = \"http\"",
      "10:         public static let https: Self = \"https\"",
      "17:         public static let httpUnixDomainSocket: Self = \"http+unix\"",
      "24:         public static let httpsUnixDomainSocket: Self = \"https+unix\"",
      "26:         public let value: String?",
      "28:         public init(stringLiteral value: String) {",
      "29:             self.value = value",
      "30:         }",
      "32:         public init(_ value: String? = nil) {",
      "33:             self.value = value",
      "34:         }",
      "35:     }",
      "37:     public var string: String",
      "40:         self.string = string",
      "44:         return self.string",
      "",
      "[Added Lines]",
      "1: #if !canImport(Darwin)",
      "2: @preconcurrency import struct Foundation.URLComponents",
      "3: #else",
      "4: import struct Foundation.URLComponents",
      "5: #endif",
      "33:     private var components: URLComponents?",
      "36:         self.components = URL(string: string).flatMap { .init(url: $0, resolvingAgainstBaseURL: true) }",
      "40:         self.string",
      "45:         userinfo: String?,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "54:     ) {",
      "55:         self.init(",
      "56:             scheme: Scheme(scheme),",
      "57:             host: host,",
      "58:             port: port,",
      "59:             path: path,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "54:             userinfo: userinfo,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "61:             fragment: fragment",
      "62:         )",
      "63:     }",
      "65:     public init(",
      "67:         host: String? = nil,",
      "68:         port: Int? = nil,",
      "69:         path: String,",
      "70:         query: String? = nil,",
      "71:         fragment: String? = nil",
      "72:     ) {",
      "85:         } else {",
      "90:         }",
      "95:     }",
      "97:     public init(stringLiteral value: String) {",
      "98:         self.init(string: value)",
      "99:     }",
      "105:     public var scheme: String? {",
      "109:         set {",
      "118:         }",
      "119:     }",
      "121:     public var host: String? {",
      "135:     }",
      "137:     public var port: Int? {",
      "151:     }",
      "153:     public var path: String {",
      "167:     }",
      "169:     public var query: String? {",
      "183:     }",
      "185:     public var fragment: String? {",
      "199:     }",
      "227:     }",
      "228: }",
      "",
      "[Removed Lines]",
      "66:         scheme: Scheme = Scheme(),",
      "73:         var string = \"\"",
      "74:         if let scheme = scheme.value {",
      "75:             string += scheme + \"://\"",
      "76:         }",
      "77:         if let host = host?.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) {",
      "78:             string += host",
      "79:         }",
      "80:         if let port = port {",
      "81:             string += \":\" + port.description",
      "82:         }",
      "83:         if path.hasPrefix(\"/\") {",
      "84:             string += path",
      "86:             string += \"/\" + path",
      "87:         }",
      "88:         if let query = query {",
      "89:             string += \"?\" + query",
      "91:         if let fragment = fragment {",
      "92:             string += \"#\" + fragment",
      "93:         }",
      "94:         self.string = string",
      "101:     private enum Component {",
      "102:         case scheme, host, port, path, query, fragment, userinfo",
      "103:     }",
      "106:         get {",
      "107:             return self.parse(.scheme)",
      "108:         }",
      "110:             self = .init(",
      "111:                 scheme: newValue,",
      "112:                 host: self.host,",
      "113:                 port: self.port,",
      "114:                 path: self.path,",
      "115:                 query: self.query,",
      "116:                 fragment: self.fragment",
      "117:             )",
      "122:         get {",
      "123:             return self.parse(.host)",
      "124:         }",
      "125:         set {",
      "126:             self = .init(",
      "127:                 scheme: self.scheme,",
      "128:                 host: newValue,",
      "129:                 port: self.port,",
      "130:                 path: self.path,",
      "131:                 query: self.query,",
      "132:                 fragment: self.fragment",
      "133:             )",
      "134:         }",
      "138:         get {",
      "139:             return self.parse(.port).flatMap(Int.init)",
      "140:         }",
      "141:         set {",
      "142:             self = .init(",
      "143:                 scheme: self.scheme,",
      "144:                 host: self.host,",
      "145:                 port: newValue,",
      "146:                 path: self.path,",
      "147:                 query: self.query,",
      "148:                 fragment: self.fragment",
      "149:             )",
      "150:         }",
      "154:         get {",
      "155:             return self.parse(.path) ?? \"\"",
      "156:         }",
      "157:         set {",
      "158:             self = .init(",
      "159:                 scheme: self.scheme,",
      "160:                 host: self.host,",
      "161:                 port: self.port,",
      "162:                 path: newValue,",
      "163:                 query: self.query,",
      "164:                 fragment: self.fragment",
      "165:             )",
      "166:         }",
      "170:         get {",
      "171:             return self.parse(.query)",
      "172:         }",
      "173:         set {",
      "174:             self = .init(",
      "175:                 scheme: self.scheme,",
      "176:                 host: self.host,",
      "177:                 port: self.port,",
      "178:                 path: self.path,",
      "179:                 query: newValue,",
      "180:                 fragment: self.fragment",
      "181:             )",
      "182:         }",
      "186:         get {",
      "187:             return self.parse(.fragment)",
      "188:         }",
      "189:         set {",
      "190:             self = .init(",
      "191:                 scheme: self.scheme,",
      "192:                 host: self.host,",
      "193:                 port: self.port,",
      "194:                 path: self.path,",
      "195:                 query: self.query,",
      "196:                 fragment: newValue",
      "197:             )",
      "198:         }",
      "201:     private func parse(_ component: Component) -> String? {",
      "202:         var url = vapor_urlparser_url()",
      "203:         vapor_urlparser_parse(self.string, self.string.count, 0, &url)",
      "204:         let data: vapor_urlparser_field_data",
      "205:         switch component {",
      "206:         case .scheme:",
      "207:             data = url.field_data.0",
      "208:         case .host:",
      "209:             data = url.field_data.1",
      "210:         case .port:",
      "211:             data = url.field_data.2",
      "212:         case .path:",
      "213:             data = url.field_data.3",
      "214:         case .query:",
      "215:             data = url.field_data.4",
      "216:         case .fragment:",
      "217:             data = url.field_data.5",
      "218:         case .userinfo:",
      "219:             data = url.field_data.6",
      "220:         }",
      "221:         if data.len == 0 {",
      "222:             return nil",
      "223:         }",
      "224:         let start = self.string.index(self.string.startIndex, offsetBy: numericCast(data.off))",
      "225:         let end = self.string.index(start, offsetBy: numericCast(data.len))",
      "226:         return String(self.string[start..<end])",
      "",
      "[Added Lines]",
      "63:     public init(scheme: String?, host: String? = nil, port: Int? = nil, path: String, query: String? = nil, fragment: String? = nil) {",
      "64:         self.init(scheme: scheme, userinfo: nil, host: host, port: port, path: path, query: query, fragment: fragment)",
      "65:     }",
      "67:     public init(scheme: Scheme = .init(), host: String? = nil, port: Int? = nil, path: String, query: String? = nil, fragment: String? = nil) {",
      "68:         self.init(scheme: scheme, userinfo: nil, host: host, port: port, path: path, query: query, fragment: fragment)",
      "69:     }",
      "82:         scheme: Scheme = .init(),",
      "83:         userinfo: String?,",
      "90:         let path = path.first == \"/\" ? path : \"/\\(path)\"",
      "91:         var components: URLComponents!",
      "93:         if scheme.value == nil, userinfo == nil, host == nil, port == nil, query == nil, fragment == nil {",
      "95:             components = URL(string: path).flatMap { .init(url: $0, resolvingAgainstBaseURL: true) }",
      "102:             components = .init()",
      "103:             components.scheme = scheme.value?.addingPercentEncoding(withAllowedCharacters: .urlSchemeAllowed)",
      "104:             if let host {",
      "105:                 if let creds = userinfo?.split(separator: \":\", maxSplits: 1, omittingEmptySubsequences: false), !creds[0].isEmpty {",
      "106:                     components.percentEncodedUser = creds[0].addingPercentEncoding(withAllowedCharacters: .urlUserAllowed)",
      "107:                     if creds.count > 1, !creds[1].isEmpty {",
      "108:                         components.percentEncodedPassword = creds[1].addingPercentEncoding(withAllowedCharacters: .urlPasswordAllowed)",
      "109:                     }",
      "110:                 }",
      "112:                 #if canImport(Darwin)",
      "113:                 if #available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *) {",
      "114:                     components.encodedHost = host.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)",
      "115:                 } else {",
      "116:                     components.percentEncodedHost = host.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)",
      "117:                 }",
      "118:                 #else",
      "119:                 components.percentEncodedHost = host.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)",
      "120:                 #endif",
      "121:                 components.port = port",
      "122:             } else {",
      "126:             }",
      "127:             components.percentEncodedPath = path.addingPercentEncoding(withAllowedCharacters: .urlCorrectPathAllowed) ?? \"/\"",
      "128:             components.percentEncodedQuery = query?.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)",
      "129:             components.percentEncodedFragment = fragment?.addingPercentEncoding(withAllowedCharacters: .urlFragmentAllowed)",
      "131:         self.components = components",
      "139:         get { self.components?.scheme }",
      "140:         set { self.components?.scheme = newValue }",
      "141:     }",
      "143:     public var userinfo: String? {",
      "144:         get { self.components?.user.map { \"\\($0)\\(self.components?.password.map { \":\\($0)\" } ?? \"\")\" } }",
      "146:             if let userinfoData = newValue?.split(separator: \":\", maxSplits: 1, omittingEmptySubsequences: false) {",
      "147:                 self.components?.user = .init(userinfoData[0])",
      "148:                 self.components?.password = userinfoData.count > 1 ? .init(userinfoData[1]) : nil",
      "149:             } else {",
      "150:                 self.components?.user = nil",
      "151:             }",
      "156:         get { self.components?.host }",
      "157:         set { self.components?.host = newValue }",
      "161:         get { self.components?.port }",
      "162:         set { self.components?.port = newValue }",
      "166:         get { self.components?.path ?? \"/\" }",
      "167:         set { self.components?.path = newValue }",
      "171:         get { self.components?.query }",
      "172:         set { self.components?.query = newValue }",
      "176:         get { self.components?.fragment }",
      "177:         set { self.components?.fragment = newValue }",
      "180:     public var string: String {",
      "181:         #if canImport(Darwin)",
      "182:         self.components?.string ?? \"\"",
      "183:         #else",
      "185:         self.components?.string?.replacingOccurrences(of: \"%3B\", with: \";\") ?? \"\"",
      "186:         #endif",
      "187:     }",
      "189: }",
      "191: extension URI {",
      "196:     public struct Scheme {",
      "198:         public let value: String?",
      "203:         public init(_ value: String? = nil) { self.value = value }",
      "210:         public static let http: Self = \"http\"",
      "215:         public static let https: Self = \"https\"",
      "228:         public static let httpUnixDomainSocket: Self = \"http+unix\"",
      "250:         public static let httpsUnixDomainSocket: Self = \"https+unix\"",
      "253:     }",
      "254: }",
      "256: extension URI.Scheme: ExpressibleByStringInterpolation {",
      "258:     public init(stringLiteral value: String) { self.init(value) }",
      "259: }",
      "261: extension URI.Scheme: CustomStringConvertible {",
      "263:     public var description: String { self.value ?? \"\" }",
      "264: }",
      "266: extension URI.Scheme: Sendable {}",
      "268: extension CharacterSet {",
      "272:     fileprivate static var urlSchemeAllowed: Self {",
      "275:         Self.urlHostAllowed.intersection(Self.alphanumerics.union(.init(charactersIn: \"+-.\")))",
      "276:     }",
      "284:     fileprivate static var urlCorrectPathAllowed: Self {",
      "285:         #if canImport(Darwin)",
      "286:         .urlPathAllowed",
      "287:         #else",
      "288:         .urlPathAllowed.union(.init(charactersIn: \";\"))",
      "289:         #endif",
      "",
      "---------------"
    ],
    "Tests/VaporTests/ClientTests.swift||Tests/VaporTests/ClientTests.swift": [
      "File: Tests/VaporTests/ClientTests.swift -> Tests/VaporTests/ClientTests.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "5: #endif",
      "6: import XCTest",
      "7: import Vapor",
      "8: import NIOCore",
      "",
      "[Removed Lines]",
      "1: #if os(Linux)",
      "2: @preconcurrency import Foundation",
      "3: #else",
      "4: import Foundation",
      "",
      "[Added Lines]",
      "1: #if !canImport(Darwin)",
      "2: @preconcurrency import Dispatch",
      "4: import Foundation",
      "",
      "---------------"
    ],
    "Tests/VaporTests/RequestTests.swift||Tests/VaporTests/RequestTests.swift": [
      "File: Tests/VaporTests/RequestTests.swift -> Tests/VaporTests/RequestTests.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "143:         }",
      "144:     }",
      "247:     func testRedirect() throws {",
      "248:         let app = Application(.testing)",
      "249:         defer { app.shutdown() }",
      "",
      "[Removed Lines]",
      "146:     func testURI() throws {",
      "147:         do {",
      "148:             var uri = URI(string: \"http://vapor.codes/foo?bar=baz#qux\")",
      "149:             XCTAssertEqual(uri.scheme, \"http\")",
      "150:             XCTAssertEqual(uri.host, \"vapor.codes\")",
      "151:             XCTAssertEqual(uri.path, \"/foo\")",
      "152:             XCTAssertEqual(uri.query, \"bar=baz\")",
      "153:             XCTAssertEqual(uri.fragment, \"qux\")",
      "154:             uri.query = \"bar=baz&test=1\"",
      "155:             XCTAssertEqual(uri.string, \"http://vapor.codes/foo?bar=baz&test=1#qux\")",
      "156:             uri.query = nil",
      "157:             XCTAssertEqual(uri.string, \"http://vapor.codes/foo#qux\")",
      "158:         }",
      "159:         do {",
      "160:             let uri = URI(string: \"/foo/bar/baz\")",
      "161:             XCTAssertEqual(uri.path, \"/foo/bar/baz\")",
      "162:         }",
      "163:         do {",
      "164:             let uri = URI(string: \"ws://echo.websocket.org/\")",
      "165:             XCTAssertEqual(uri.scheme, \"ws\")",
      "166:             XCTAssertEqual(uri.host, \"echo.websocket.org\")",
      "167:             XCTAssertEqual(uri.path, \"/\")",
      "168:         }",
      "169:         do {",
      "170:             let uri = URI(string: \"http://foo\")",
      "171:             XCTAssertEqual(uri.scheme, \"http\")",
      "172:             XCTAssertEqual(uri.host, \"foo\")",
      "173:             XCTAssertEqual(uri.path, \"\")",
      "174:         }",
      "175:         do {",
      "176:             let uri = URI(string: \"foo\")",
      "177:             XCTAssertEqual(uri.scheme, \"foo\")",
      "178:             XCTAssertEqual(uri.host, nil)",
      "179:             XCTAssertEqual(uri.path, \"\")",
      "180:         }",
      "181:         do {",
      "182:             let uri: URI = \"/foo/bar/baz\"",
      "183:             XCTAssertEqual(uri.path, \"/foo/bar/baz\")",
      "184:         }",
      "185:         do {",
      "186:             let foo = \"foo\"",
      "187:             let uri: URI = \"/\\(foo)/bar/baz\"",
      "188:             XCTAssertEqual(uri.path, \"/foo/bar/baz\")",
      "189:         }",
      "190:         do {",
      "191:             let uri = URI(scheme: \"foo\", host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "192:             XCTAssertEqual(uri.string, \"foo://host:1/test?query#fragment\")",
      "193:         }",
      "194:         do {",
      "195:             let bar = \"bar\"",
      "196:             let uri = URI(scheme: \"foo\\(bar)\", host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "197:             XCTAssertEqual(uri.string, \"foobar://host:1/test?query#fragment\")",
      "198:         }",
      "199:         do {",
      "200:             let uri = URI(scheme: \"foo\", host: \"host\", port: 1, path: \"/test\", query: \"query\", fragment: \"fragment\")",
      "201:             XCTAssertEqual(uri.string, \"foo://host:1/test?query#fragment\")",
      "202:         }",
      "203:         do {",
      "204:             let scheme = \"foo\"",
      "205:             let uri = URI(scheme: scheme, host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "206:             XCTAssertEqual(uri.string, \"foo://host:1/test?query#fragment\")",
      "207:         }",
      "208:         do {",
      "209:             let scheme: String? = \"foo\"",
      "210:             let uri = URI(scheme: scheme, host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "211:             XCTAssertEqual(uri.string, \"foo://host:1/test?query#fragment\")",
      "212:         }",
      "213:         do {",
      "214:             let uri = URI(scheme: .http, host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "215:             XCTAssertEqual(uri.string, \"http://host:1/test?query#fragment\")",
      "216:         }",
      "217:         do {",
      "218:             let uri = URI(scheme: nil, host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "219:             XCTAssertEqual(uri.string, \"host:1/test?query#fragment\")",
      "220:         }",
      "221:         do {",
      "222:             let uri = URI(scheme: URI.Scheme(), host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "223:             XCTAssertEqual(uri.string, \"host:1/test?query#fragment\")",
      "224:         }",
      "225:         do {",
      "226:             let uri = URI(host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "227:             XCTAssertEqual(uri.string, \"host:1/test?query#fragment\")",
      "228:         }",
      "229:         do {",
      "230:             let uri = URI(scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\", query: \"query\", fragment: \"fragment\")",
      "231:             XCTAssertEqual(uri.string, \"http+unix://%2Fpath/test?query#fragment\")",
      "232:         }",
      "233:         do {",
      "234:             let uri = URI(scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\", fragment: \"fragment\")",
      "235:             XCTAssertEqual(uri.string, \"http+unix://%2Fpath/test#fragment\")",
      "236:         }",
      "237:         do {",
      "238:             let uri = URI(scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\")",
      "239:             XCTAssertEqual(uri.string, \"http+unix://%2Fpath/test\")",
      "240:         }",
      "241:         do {",
      "242:             let uri = URI()",
      "243:             XCTAssertEqual(uri.string, \"/\")",
      "244:         }",
      "245:     }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "Tests/VaporTests/ServerTests.swift||Tests/VaporTests/ServerTests.swift": [
      "File: Tests/VaporTests/ServerTests.swift -> Tests/VaporTests/ServerTests.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "5: #endif",
      "6: import Vapor",
      "7: import XCTest",
      "8: import AsyncHTTPClient",
      "",
      "[Removed Lines]",
      "1: #if os(Linux)",
      "2: @preconcurrency import Foundation",
      "3: #else",
      "4: import Foundation",
      "",
      "[Added Lines]",
      "1: #if !canImport(Darwin)",
      "2: @preconcurrency import Dispatch",
      "4: import Foundation",
      "",
      "---------------"
    ],
    "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift": [
      "File: Tests/VaporTests/URITests.swift -> Tests/VaporTests/URITests.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: import XCTVapor",
      "2: import XCTest",
      "3: import Vapor",
      "4: import NIOCore",
      "5: import Algorithms",
      "7: extension RangeReplaceableCollection where Self.SubSequence == Substring, Self: StringProtocol {",
      "8:     #if compiler(>=5.9)",
      "9:     #if hasFeature(BareSlashRegexLiterals)",
      "10:     private static var percentEncodingPattern: Regex<Substring> { /(?:%\\p{AHex}{2})+/ }",
      "11:     #else",
      "12:     private static var percentEncodingPattern: Regex<Substring> { try! Regex(\"(?:%\\\\p{AHex}{2})+\") }",
      "13:     #endif",
      "14:     #else",
      "15:     private static var percentEncodingPattern: Regex<Substring> { try! Regex(\"(?:%\\\\p{AHex}{2})+\") }",
      "16:     #endif",
      "21:     var safelyUrlDecoded: Self {",
      "22:         self.replacing(",
      "23:             Self.percentEncodingPattern,",
      "24:             with: { Self(decoding: $0.0.split(separator: \"%\").map { .init($0, radix: 16)! }, as: UTF8.self) }",
      "25:         )",
      "26:     }",
      "27: }",
      "29: func XCTAssertURIComponents(",
      "30:        scheme: @autoclosure () throws -> URI.Scheme?,",
      "31:      userinfo: @autoclosure () throws -> String? = nil,",
      "32:          host: @autoclosure () throws -> String? = nil,",
      "33:          port: @autoclosure () throws -> Int?    = nil,",
      "34:          path: @autoclosure () throws -> String,",
      "35:         query: @autoclosure () throws -> String? = nil,",
      "36:      fragment: @autoclosure () throws -> String? = nil,",
      "37:      generate expected: @autoclosure () throws -> String,",
      "38:     _ message: @autoclosure () -> String = \"\", file: StaticString = #filePath, line: UInt = #line",
      "39: ) {",
      "40:     XCTAssertURIComponents(",
      "41:         scheme: try scheme()?.value,",
      "42:         userinfo: try userinfo(),",
      "43:         host: try host(),",
      "44:         port: try port(),",
      "45:         path: try path(),",
      "46:         query: try query(),",
      "47:         fragment: try fragment(),",
      "48:         generate: try expected(),",
      "49:         message(), file: file, line: line",
      "50:     )",
      "51: }",
      "53: func XCTAssertURIComponents(",
      "54:        scheme: @autoclosure () throws -> String? = nil,",
      "55:      userinfo: @autoclosure () throws -> String? = nil,",
      "56:          host: @autoclosure () throws -> String? = nil,",
      "57:          port: @autoclosure () throws -> Int?    = nil,",
      "58:          path: @autoclosure () throws -> String,",
      "59:         query: @autoclosure () throws -> String? = nil,",
      "60:      fragment: @autoclosure () throws -> String? = nil,",
      "61:      generate expected: @autoclosure () throws -> String,",
      "62:     _ message: @autoclosure () -> String = \"\", file: StaticString = #filePath, line: UInt = #line",
      "63: ) {",
      "64:     do {",
      "65:         let scheme = try scheme(), userinfo = try userinfo(), host = try host(), port = try port(),",
      "66:             path = try path(), query = try query(), fragment = try fragment()",
      "67:         let uri = URI(scheme: scheme, userinfo: userinfo, host: host, port: port, path: path, query: query, fragment: fragment)",
      "70:         XCTAssertEqual(uri.scheme,   scheme?.safelyUrlDecoded,   \"(scheme) \\(message())\", file: file, line: line)",
      "71:         XCTAssertEqual(uri.userinfo, userinfo?.safelyUrlDecoded, \"(userinfo) \\(message())\", file: file, line: line)",
      "72:         XCTAssertEqual(uri.host,     host?.safelyUrlDecoded,     \"(host) \\(message())\", file: file, line: line)",
      "73:         XCTAssertEqual(uri.port,     port,                       \"(port) \\(message())\", file: file, line: line)",
      "74:         XCTAssertEqual(uri.path,     \"/\\(path.safelyUrlDecoded.trimmingPrefix(\"/\"))\", \"(path) \\(message())\", file: file, line: line)",
      "75:         XCTAssertEqual(uri.query,    query?.safelyUrlDecoded,    \"(query) \\(message())\", file: file, line: line)",
      "76:         XCTAssertEqual(uri.fragment, fragment?.safelyUrlDecoded, \"(fragment) \\(message())\", file: file, line: line)",
      "79:         XCTAssertEqual(uri.string,   try expected(),             \"(string) \\(message())\", file: file, line: line)",
      "80:     } catch {",
      "81:         XCTAssertEqual(try { throw error }(), false,             message(), file: file, line: line)",
      "82:     }",
      "83: }",
      "85: func XCTAssertURIString(",
      "86:      _ string: @autoclosure () throws -> String,",
      "87:      hasScheme scheme:     @autoclosure () throws -> String? = nil,",
      "88:      hasUserinfo userinfo: @autoclosure () throws -> String? = nil,",
      "89:      hasHost host:         @autoclosure () throws -> String? = \"\",",
      "90:      hasPort port:         @autoclosure () throws -> Int?    = nil,",
      "91:      hasPath path:         @autoclosure () throws -> String,",
      "92:      hasQuery query:       @autoclosure () throws -> String? = nil,",
      "93:      hasFragment fragment: @autoclosure () throws -> String? = nil,",
      "94:      hasEqualString exact: @autoclosure () throws -> Bool = true,",
      "95:     _ message: @autoclosure () -> String = \"\", file: StaticString = #filePath, line: UInt = #line",
      "96: ) {",
      "97:     do {",
      "98:         let string = try string()",
      "99:         let uri = URI(string: string)",
      "102:         XCTAssertEqual(uri.scheme,   try scheme()?.safelyUrlDecoded,   \"(scheme) \\(message())\", file: file, line: line)",
      "103:         XCTAssertEqual(uri.userinfo, try userinfo()?.safelyUrlDecoded, \"(userinfo) \\(message())\", file: file, line: line)",
      "104:         XCTAssertEqual(uri.host,     try host()?.safelyUrlDecoded,     \"(host) \\(message())\", file: file, line: line)",
      "105:         XCTAssertEqual(uri.port,     try port(),                       \"(port) \\(message())\", file: file, line: line)",
      "106:         XCTAssertEqual(uri.path,     try path().safelyUrlDecoded,      \"(path) \\(message())\", file: file, line: line)",
      "107:         XCTAssertEqual(uri.query,    try query()?.safelyUrlDecoded,    \"(query) \\(message())\", file: file, line: line)",
      "108:         XCTAssertEqual(uri.fragment, try fragment()?.safelyUrlDecoded, \"(fragment) \\(message())\", file: file, line: line)",
      "111:         if try exact() {",
      "112:             XCTAssertEqual(uri.string,   string,                       \"(string) \\(message())\", file: file, line: line)",
      "113:         }",
      "114:     } catch {",
      "115:         XCTAssertEqual(try { throw error }(), false,                   message(), file: file, line: line)",
      "116:     }",
      "117: }",
      "119: final class URITests: XCTestCase {",
      "120:     func testBasicConstruction() {",
      "121:         XCTAssertURIString(",
      "122:             \"https://user:pass@vapor.codes:1234/foo?bar=baz#qux\",",
      "123:             hasScheme: \"https\",",
      "124:             hasUserinfo: \"user:pass\",",
      "125:             hasHost: \"vapor.codes\",",
      "126:             hasPort: 1234,",
      "127:             hasPath: \"/foo\",",
      "128:             hasQuery: \"bar=baz\",",
      "129:             hasFragment: \"qux\"",
      "130:         )",
      "131:         XCTAssertURIComponents(",
      "132:             scheme: \"https\",",
      "133:             userinfo: \"user:pass\",",
      "134:             host: \"vapor.codes\",",
      "135:             port: 1234,",
      "136:             path: \"/foo\",",
      "137:             query: \"bar=baz\",",
      "138:             fragment: \"qux\",",
      "139:             generate: \"https://user:pass@vapor.codes:1234/foo?bar=baz#qux\"",
      "140:         )",
      "142:         XCTAssertURIString(\"wss://echo.websocket.org/\", hasScheme: \"wss\", hasHost: \"echo.websocket.org\", hasPath: \"/\")",
      "143:         XCTAssertURIComponents(scheme: \"wss\", host: \"echo.websocket.org\", path: \"/\", generate: \"wss://echo.websocket.org/\")",
      "144:     }",
      "146:     func testMutation() {",
      "147:         var uri = URI(string: \"https://user:pass@vapor.codes:1234/foo?bar=baz#qux\")",
      "150:         uri.query = \"bar=baz&test=1\"",
      "151:         XCTAssertEqual(uri.string, \"https://user:pass@vapor.codes:1234/foo?bar=baz&test=1#qux\")",
      "154:         uri.query = nil",
      "155:         XCTAssertEqual(uri.string, \"https://user:pass@vapor.codes:1234/foo#qux\")",
      "156:     }",
      "158:     func testPathStrings() {",
      "160:         let uri = URI(string: \"/foo/bar/baz\")",
      "161:         XCTAssertEqual(uri.path, \"/foo/bar/baz\")",
      "162:     }",
      "164:     func testNonAbsolutePath() {",
      "165:         let uri = URI(string: \"foo\")",
      "170:         XCTAssertEqual(uri.scheme, nil)",
      "171:         XCTAssertEqual(uri.host, nil)",
      "172:         XCTAssertEqual(uri.path, \"foo\")",
      "173:     }",
      "175:     func testStringInterpolation() {",
      "176:         let foo = \"foo\"",
      "177:         XCTAssertEqual((\"/\\(foo)/bar/baz\" as URI).path, \"/foo/bar/baz\")",
      "179:         let bar = \"bar\"",
      "180:         let uri = URI(scheme: \"foo\\(bar)\", host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")",
      "181:         XCTAssertEqual(uri.string, \"foobar://host:1/test?query#fragment\")",
      "182:     }",
      "184:     func testVariousSchemesAndWeirdHosts() {",
      "187:         XCTAssertURIComponents(",
      "188:             host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\",",
      "189:             generate: \"//host:1/test?query#fragment\"",
      "190:         )",
      "191:         XCTAssertURIComponents(",
      "192:             scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\",",
      "193:             generate: \"http+unix://%2Fpath/test\"",
      "194:         )",
      "195:         XCTAssertURIComponents(",
      "196:             scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\", fragment: \"fragment\",",
      "197:             generate: \"http+unix://%2Fpath/test#fragment\"",
      "198:         )",
      "199:         XCTAssertURIComponents(",
      "200:             scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\", query: \"query\", fragment: \"fragment\",",
      "201:             generate: \"http+unix://%2Fpath/test?query#fragment\"",
      "202:         )",
      "203:     }",
      "205:     func testDefaultInitializer() {",
      "206:         let uri = URI.init()",
      "207:         XCTAssertEqual(uri.string, \"/\")",
      "208:     }",
      "210:     func testOverlongURIParsing() {",
      "211:         let zeros = String(repeating: \"0\", count: 65_512)",
      "212:         let untrustedInput = \"[https://vapor.codes.somewhere-else.test:](https://vapor.codes.somewhere-else.test/\\(zeros)443)[\\(zeros)](https://vapor.codes.somewhere-else.test/\\(zeros)443)[443](https://vapor.codes.somewhere-else.test/\\(zeros)443)\"",
      "214:         XCTAssertURIString(untrustedInput, hasHost: nil, hasPath: untrustedInput, hasEqualString: false)",
      "215:     }",
      "217:     func testUrlParsingVectors() {",
      "218:         XCTAssertURIString(\"file:///usr/local/bin\", hasScheme: \"file\", hasPath: \"/usr/local/bin\")",
      "219:         XCTAssertURIString(\"file:/usr/local/bin\", hasScheme: \"file\", hasHost: nil, hasPath: \"/usr/local/bin\")",
      "220:         XCTAssertURIString(\"file://localhost/usr/local/bin\", hasScheme: \"file\", hasHost: \"localhost\", hasPath: \"/usr/local/bin\")",
      "221:         XCTAssertURIString(\"file://usr/local/bin\", hasScheme: \"file\", hasHost: \"usr\", hasPath: \"/local/bin\")",
      "222:         XCTAssertURIString(\"/usr/local/bin\", hasHost: nil, hasPath: \"/usr/local/bin\")",
      "223:         XCTAssertURIString(\"file://localhost/usr/local/bin/\", hasScheme: \"file\", hasHost: \"localhost\", hasPath: \"/usr/local/bin/\")",
      "224:         XCTAssertURIString(\"file://localhost/\", hasScheme: \"file\", hasHost: \"localhost\", hasPath: \"/\")",
      "225:         XCTAssertURIString(\"file:///\", hasScheme: \"file\", hasPath: \"/\")",
      "226:         XCTAssertURIString(\"file:/\", hasScheme: \"file\", hasHost: nil, hasPath: \"/\")",
      "227:         XCTAssertURIString(\"file:///Volumes\", hasScheme: \"file\", hasPath: \"/Volumes\")",
      "228:         XCTAssertURIString(\"file:///Users/darin\", hasScheme: \"file\", hasPath: \"/Users/darin\")",
      "229:         XCTAssertURIString(\"file:/\", hasScheme: \"file\", hasHost: nil, hasPath: \"/\")",
      "230:         XCTAssertURIString(\"file:///.\", hasScheme: \"file\", hasPath: \"/.\")",
      "231:         XCTAssertURIString(\"file:///./.\", hasScheme: \"file\", hasPath: \"/./.\")",
      "232:         XCTAssertURIString(\"file:///.///.\", hasScheme: \"file\", hasPath: \"/.///.\")",
      "233:         XCTAssertURIString(\"file:///a/..\", hasScheme: \"file\", hasPath: \"/a/..\")",
      "234:         XCTAssertURIString(\"file:///a/b/..\", hasScheme: \"file\", hasPath: \"/a/b/..\")",
      "235:         XCTAssertURIString(\"file:///a/b//..\", hasScheme: \"file\", hasPath: \"/a/b//..\")",
      "236:         XCTAssertURIString(\"file:///./a/b/..\", hasScheme: \"file\", hasPath: \"/./a/b/..\")",
      "237:         XCTAssertURIString(\"file:///a/./b/..\", hasScheme: \"file\", hasPath: \"/a/./b/..\")",
      "238:         XCTAssertURIString(\"file:///a/b/./..\", hasScheme: \"file\", hasPath: \"/a/b/./..\")",
      "239:         XCTAssertURIString(\"file:///a///b//..\", hasScheme: \"file\", hasPath: \"/a///b//..\")",
      "240:         XCTAssertURIString(\"file:///a/b/../..\", hasScheme: \"file\", hasPath: \"/a/b/../..\")",
      "241:         XCTAssertURIString(\"file:///a/b/c/../..\", hasScheme: \"file\", hasPath: \"/a/b/c/../..\")",
      "242:         XCTAssertURIString(\"file:///a/../b/..\", hasScheme: \"file\", hasPath: \"/a/../b/..\")",
      "243:         XCTAssertURIString(\"file:///a/../b/../c\", hasScheme: \"file\", hasPath: \"/a/../b/../c\")",
      "244:         XCTAssertURIString(\"file:///a/../b/../c\", hasScheme: \"file\", hasPath: \"/a/../b/../c\")",
      "245:         XCTAssertURIString(\"ftp://ftp.gnu.org/\", hasScheme: \"ftp\", hasHost: \"ftp.gnu.org\", hasPath: \"/\")",
      "246:         XCTAssertURIString(\"ftp://ftp.gnu.org/pub/gnu\", hasScheme: \"ftp\", hasHost: \"ftp.gnu.org\", hasPath: \"/pub/gnu\")",
      "247:         XCTAssertURIString(\"ftp://luser@ftp.gnu.org/pub/gnu\",",
      "248:             hasScheme: \"ftp\", hasUserinfo: \"luser\", hasHost: \"ftp.gnu.org\", hasPath: \"/pub/gnu\"",
      "249:         )",
      "250:         XCTAssertURIString(\"ftp://@ftp.gnu.org/pub/gnu\", hasScheme: \"ftp\", hasUserinfo: \"\", hasHost: \"ftp.gnu.org\", hasPath: \"/pub/gnu\")",
      "251:         XCTAssertURIString(\"ftp://luser:password@ftp.gnu.org/pub/gnu\",",
      "252:             hasScheme: \"ftp\", hasUserinfo: \"luser:password\", hasHost: \"ftp.gnu.org\", hasPath: \"/pub/gnu\"",
      "253:         )",
      "254:         XCTAssertURIString(\"ftp://:password@ftp.gnu.org/pub/gnu\",",
      "255:             hasScheme: \"ftp\", hasUserinfo: \":password\", hasHost: \"ftp.gnu.org\", hasPath: \"/pub/gnu\"",
      "256:         )",
      "257:         XCTAssertURIString(\"ftp://ftp.gnu.org:72/pub/gnu\", hasScheme: \"ftp\", hasHost: \"ftp.gnu.org\", hasPort: 72, hasPath: \"/pub/gnu\")",
      "258:         XCTAssertURIString(\"ftp://:72/pub/gnu\", hasScheme: \"ftp\", hasHost: \"\", hasPort: 72, hasPath: \"/pub/gnu\")",
      "259:         XCTAssertURIString(\"http://localhost/usr/local/bin/\", hasScheme: \"http\", hasHost: \"localhost\", hasPath: \"/usr/local/bin/\")",
      "260:         XCTAssertURIString(\"http://localhost/\", hasScheme: \"http\", hasHost: \"localhost\", hasPath: \"/\")",
      "261:         XCTAssertURIString(\"http://www.apple.com/\", hasScheme: \"http\", hasHost: \"www.apple.com\", hasPath: \"/\")",
      "262:         XCTAssertURIString(\"http://www.apple.com/dir\", hasScheme: \"http\", hasHost: \"www.apple.com\", hasPath: \"/dir\")",
      "263:         XCTAssertURIString(\"http://www.apple.com/dir/\", hasScheme: \"http\", hasHost: \"www.apple.com\", hasPath: \"/dir/\")",
      "264:         XCTAssertURIString(\"http://darin:nothin@www.apple.com:42/dir/\",",
      "265:             hasScheme: \"http\", hasUserinfo: \"darin:nothin\", hasHost: \"www.apple.com\", hasPort: 42, hasPath: \"/dir/\"",
      "266:         )",
      "267:         XCTAssertURIString(\"http:/\", hasScheme: \"http\", hasHost: nil, hasPath: \"/\")",
      "268:         XCTAssertURIString(\"http://www.apple.com/query?email=darin@apple.com\",",
      "269:             hasScheme: \"http\", hasHost: \"www.apple.com\", hasPath: \"/query\", hasQuery: \"email=darin@apple.com\"",
      "270:         )",
      "271:         XCTAssertURIString(\"HTTP://WWW.ZOO.COM/\", hasScheme: \"HTTP\", hasHost: \"WWW.ZOO.COM\", hasPath: \"/\")",
      "272:         XCTAssertURIString(\"HTTP://WWW.ZOO.COM/ED\", hasScheme: \"HTTP\", hasHost: \"WWW.ZOO.COM\", hasPath: \"/ED\")",
      "273:         XCTAssertURIString(\"http://groups.google.com/groups?as_uauthors=joe@blow.com&as_scoring=d&hl=en\",",
      "274:             hasScheme: \"http\", hasHost: \"groups.google.com\", hasPath: \"/groups\", hasQuery: \"as_uauthors=joe@blow.com&as_scoring=d&hl=en\"",
      "275:         )",
      "276:         XCTAssertURIString(\"http://my.site.com/some/page.html#fragment\",",
      "277:             hasScheme: \"http\", hasHost: \"my.site.com\", hasPath: \"/some/page.html\", hasFragment: \"fragment\"",
      "278:         )",
      "279:         XCTAssertURIString(\"scheme://user:pass@host:1/path/path2/file.html;params?query#fragment\",",
      "280:             hasScheme: \"scheme\", hasUserinfo: \"user:pass\", hasHost: \"host\", hasPort: 1, hasPath: \"/path/path2/file.html;params\",",
      "281:             hasQuery: \"query\", hasFragment: \"fragment\"",
      "282:         )",
      "283:         XCTAssertURIString(\"http://test.com/a%20space\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/a space\")",
      "284:         XCTAssertURIString(\"http://test.com/aBrace%7B\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/aBrace{\")",
      "285:         XCTAssertURIString(\"http://test.com/aJ%4a\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/aJJ\")",
      "286:         XCTAssertURIString(\"file:///%3F\", hasScheme: \"file\", hasPath: \"/?\")",
      "287:         XCTAssertURIString(\"file:///%78\", hasScheme: \"file\", hasPath: \"/x\")",
      "288:         XCTAssertURIString(\"file:///?\", hasScheme: \"file\", hasPath: \"/\", hasQuery: \"\")",
      "289:         XCTAssertURIString(\"file:///&\", hasScheme: \"file\", hasPath: \"/&\")",
      "290:         XCTAssertURIString(\"file:///x\", hasScheme: \"file\", hasPath: \"/x\")",
      "291:         XCTAssertURIString(\"http:///%3F\", hasScheme: \"http\", hasPath: \"/?\")",
      "292:         XCTAssertURIString(\"http:///%78\", hasScheme: \"http\", hasPath: \"/x\")",
      "293:         XCTAssertURIString(\"http:///?\", hasScheme: \"http\", hasPath: \"/\", hasQuery: \"\")",
      "294:         XCTAssertURIString(\"http:///&\", hasScheme: \"http\", hasPath: \"/&\")",
      "295:         XCTAssertURIString(\"http:///x\", hasScheme: \"http\", hasPath: \"/x\")",
      "296:         XCTAssertURIString(\"glorb:///%3F\", hasScheme: \"glorb\", hasPath: \"/?\")",
      "297:         XCTAssertURIString(\"glorb:///%78\", hasScheme: \"glorb\", hasPath: \"/x\")",
      "298:         XCTAssertURIString(\"glorb:///?\", hasScheme: \"glorb\", hasPath: \"/\", hasQuery: \"\")",
      "299:         XCTAssertURIString(\"glorb:///&\", hasScheme: \"glorb\", hasPath: \"/&\")",
      "300:         XCTAssertURIString(\"glorb:///x\", hasScheme: \"glorb\", hasPath: \"/x\")",
      "301:         XCTAssertURIString(\"uahsfcncvuhrtgvnahr\", hasHost: nil, hasPath: \"uahsfcncvuhrtgvnahr\")",
      "302:         XCTAssertURIString(\"http://[fe80::20a:27ff:feae:8b9e]/\", hasScheme: \"http\", hasHost: \"[fe80::20a:27ff:feae:8b9e]\", hasPath: \"/\")",
      "303:         XCTAssertURIString(\"http://[fe80::20a:27ff:feae:8b9e%25en0]/\", hasScheme: \"http\", hasHost: \"[fe80::20a:27ff:feae:8b9e%en0]\", hasPath: \"/\")",
      "304:         XCTAssertURIString(\"http://host.com/foo/bar/../index.html\", hasScheme: \"http\", hasHost: \"host.com\", hasPath: \"/foo/bar/../index.html\")",
      "305:         XCTAssertURIString(\"http://host.com/foo/bar/./index.html\", hasScheme: \"http\", hasHost: \"host.com\", hasPath: \"/foo/bar/./index.html\")",
      "306:         XCTAssertURIString(\"http:/cgi-bin/Count.cgi?ft=0\", hasScheme: \"http\", hasHost: nil, hasPath: \"/cgi-bin/Count.cgi\", hasQuery: \"ft=0\")",
      "307:         XCTAssertURIString(\"file://///\", hasScheme: \"file\", hasPath: \"///\")",
      "308:         XCTAssertURIString(\"file:/Volumes\", hasScheme: \"file\", hasHost: nil, hasPath: \"/Volumes\")",
      "309:         XCTAssertURIString(\"/Volumes\", hasHost: nil, hasPath: \"/Volumes\")",
      "310:         XCTAssertURIString(\".\", hasHost: nil, hasPath: \".\")",
      "311:         XCTAssertURIString(\"./a\", hasHost: nil, hasPath: \"./a\")",
      "312:         XCTAssertURIString(\"../a\", hasHost: nil, hasPath: \"../a\")",
      "313:         XCTAssertURIString(\"../../a\", hasHost: nil, hasPath: \"../../a\")",
      "314:         XCTAssertURIString(\"/\", hasHost: nil, hasPath: \"/\")",
      "315:         XCTAssertURIString(\"http://a/b/c/./g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./g\")",
      "316:         XCTAssertURIString(\"http://a/b/c/.\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/.\")",
      "317:         XCTAssertURIString(\"http://a/b/c/./\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./\")",
      "318:         XCTAssertURIString(\"http://a/b/c/..\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/..\")",
      "319:         XCTAssertURIString(\"http://a/b/c/../\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../\")",
      "320:         XCTAssertURIString(\"http://a/b/c/../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../g\")",
      "321:         XCTAssertURIString(\"http://a/b/c/../..\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../..\")",
      "322:         XCTAssertURIString(\"http://a/b/c/../../\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../../\")",
      "323:         XCTAssertURIString(\"http://a/b/c/../../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../../g\")",
      "324:         XCTAssertURIString(\"http://a/b/c/../../../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../../../g\")",
      "325:         XCTAssertURIString(\"http://a/b/c/../../../../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../../../../g\")",
      "326:         XCTAssertURIString(\"http://a/b/c/./g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./g\")",
      "327:         XCTAssertURIString(\"http://a/b/c/../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../g\")",
      "328:         XCTAssertURIString(\"http://a/b/c/g.\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g.\")",
      "329:         XCTAssertURIString(\"http://a/b/c/.g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/.g\")",
      "330:         XCTAssertURIString(\"http://a/b/c/g..\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g..\")",
      "331:         XCTAssertURIString(\"http://a/b/c/..g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/..g\")",
      "332:         XCTAssertURIString(\"http://a/b/c/./../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./../g\")",
      "333:         XCTAssertURIString(\"http://a/b/c/./g/.\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./g/.\")",
      "334:         XCTAssertURIString(\"http://a/b/c/g/./h\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g/./h\")",
      "335:         XCTAssertURIString(\"http://a/b/c/g/../h\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g/../h\")",
      "336:         XCTAssertURIString(\"http://a/b/c/g;x=1/./y\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g;x=1/./y\")",
      "337:         XCTAssertURIString(\"http://a/b/c/g;x=1/../y\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g;x=1/../y\")",
      "338:         XCTAssertURIString(\"http://a/b/c/g?y/./x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g\", hasQuery: \"y/./x\")",
      "339:         XCTAssertURIString(\"http://a/b/c/g?y/../x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g\", hasQuery: \"y/../x\")",
      "340:         XCTAssertURIString(\"http://a/b/c/g#s/./x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g\", hasFragment: \"s/./x\")",
      "341:         XCTAssertURIString(\"http://a/b/c/g#s/../x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g\", hasFragment: \"s/../x\")",
      "342:         XCTAssertURIString(\"http://a/../../x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/../../x\")",
      "343:         XCTAssertURIString(\"http://a/..///../x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/..///../x\")",
      "344:     }",
      "345: }",
      "",
      "---------------"
    ],
    "Tests/VaporTests/ValidationTests.swift||Tests/VaporTests/ValidationTests.swift": [
      "File: Tests/VaporTests/ValidationTests.swift -> Tests/VaporTests/ValidationTests.swift",
      "--- Hunk 1 ---",
      "[Context before]",
      "161:         \"\"\"",
      "162:         XCTAssertNoThrow(try Email.validate(json: valid))",
      "165:         XCTAssertNoThrow(try Email.validate(query: validURL))",
      "168:         XCTAssertNoThrow(try Email.validate(query: validURL2))",
      "170:         let invalidUser = \"\"\"",
      "",
      "[Removed Lines]",
      "164:         let validURL: URI = \"https://tanner.xyz/email?email=\u00df@tanner.xyz\"",
      "167:         let validURL2: URI = \"https://tanner.xyz/email?email=me@\u00dfanner.xyz\"",
      "",
      "[Added Lines]",
      "166:         let validURL: URI = \"https://tanner.xyz/email?email=%C3%9F@tanner.xyz\" // \u00df",
      "169:         let validURL2: URI = \"https://tanner.xyz/email?email=me@%C3%9Fanner.xyz\"",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1466c50e4ad39072143e2fcdf13b4ba11be375a0",
      "candidate_info": {
        "commit_hash": "1466c50e4ad39072143e2fcdf13b4ba11be375a0",
        "repo": "vapor/vapor",
        "commit_url": "https://github.com/vapor/vapor/commit/1466c50e4ad39072143e2fcdf13b4ba11be375a0",
        "files": [
          ".github/workflows/test.yml",
          "Package.swift",
          "Package@swift-5.9.swift",
          "Sources/Vapor/Application.swift",
          "Sources/Vapor/Commands/ServeCommand.swift",
          "Sources/Vapor/Content/JSONCoders+Content.swift",
          "Sources/Vapor/Exports.swift",
          "Sources/Vapor/HTTP/EndpointCache.swift",
          "Sources/Vapor/HTTP/Headers/HTTPCookies.swift",
          "Sources/Vapor/Response/Response+Body.swift",
          "Sources/Vapor/Utilities/Base32.swift",
          "Sources/Vapor/Utilities/Base64.swift",
          "Sources/Vapor/Utilities/BaseN.swift",
          "Sources/XCTVapor/Exports.swift",
          "Tests/VaporTests/ConditionalResponseCompressionTests.swift"
        ],
        "message": "Drop Support for Swift 5.8 (#3240)\n\n* Drop support for Swift 5.8 and accept new version of Crypto\n\n* Tidy up some old code paths\n\n* Fix up a few warnings\n\n* Oops\n\n* Numptie\n\n* Actually use the right API\n\n* Tidy up",
        "before_after_code_files": [
          "Package.swift||Package.swift",
          "Package@swift-5.9.swift||Package@swift-5.9.swift",
          "Sources/Vapor/Application.swift||Sources/Vapor/Application.swift",
          "Sources/Vapor/Commands/ServeCommand.swift||Sources/Vapor/Commands/ServeCommand.swift",
          "Sources/Vapor/Content/JSONCoders+Content.swift||Sources/Vapor/Content/JSONCoders+Content.swift",
          "Sources/Vapor/Exports.swift||Sources/Vapor/Exports.swift",
          "Sources/Vapor/HTTP/EndpointCache.swift||Sources/Vapor/HTTP/EndpointCache.swift",
          "Sources/Vapor/HTTP/Headers/HTTPCookies.swift||Sources/Vapor/HTTP/Headers/HTTPCookies.swift",
          "Sources/Vapor/Response/Response+Body.swift||Sources/Vapor/Response/Response+Body.swift",
          "Sources/Vapor/Utilities/Base32.swift||Sources/Vapor/Utilities/Base32.swift",
          "Sources/Vapor/Utilities/Base64.swift||Sources/Vapor/Utilities/Base64.swift",
          "Sources/Vapor/Utilities/BaseN.swift||Sources/Vapor/Utilities/BaseN.swift",
          "Sources/XCTVapor/Exports.swift||Sources/XCTVapor/Exports.swift",
          "Tests/VaporTests/ConditionalResponseCompressionTests.swift||Tests/VaporTests/ConditionalResponseCompressionTests.swift"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Package.swift||Package.swift",
            "Package@swift-5.9.swift||Package@swift-5.9.swift",
            "Sources/Vapor/HTTP/EndpointCache.swift||Sources/Vapor/HTTP/EndpointCache.swift",
            "Sources/Vapor/HTTP/Headers/HTTPCookies.swift||Sources/Vapor/HTTP/Headers/HTTPCookies.swift",
            "Sources/Vapor/Response/Response+Body.swift||Sources/Vapor/Response/Response+Body.swift"
          ],
          "candidate": [
            "Package.swift||Package.swift",
            "Package@swift-5.9.swift||Package@swift-5.9.swift",
            "Sources/Vapor/HTTP/EndpointCache.swift||Sources/Vapor/HTTP/EndpointCache.swift",
            "Sources/Vapor/HTTP/Headers/HTTPCookies.swift||Sources/Vapor/HTTP/Headers/HTTPCookies.swift",
            "Sources/Vapor/Response/Response+Body.swift||Sources/Vapor/Response/Response+Body.swift"
          ]
        }
      },
      "candidate_diff": {
        "Package.swift||Package.swift": [
          "File: Package.swift -> Package.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:         .package(url: \"https://github.com/vapor/console-kit.git\", from: \"4.14.0\"),",
          "31:         .package(url: \"https://github.com/vapor/routing-kit.git\", from: \"4.9.0\"),",
          "37:         .package(url: \"https://github.com/apple/swift-nio.git\", from: \"2.67.0\"),",
          "",
          "[Removed Lines]",
          "28:         .package(url: \"https://github.com/apple/swift-crypto.git\", \"1.0.0\" ..< \"4.0.0\"),",
          "34:         .package(url: \"https://github.com/swift-server/swift-backtrace.git\", from: \"1.1.1\"),",
          "",
          "[Added Lines]",
          "28:         .package(url: \"https://github.com/apple/swift-crypto.git\", \"1.0.0\" ..< \"5.0.0\"),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "66:     targets: [",
          "68:         .target(name: \"CVaporBcrypt\"),",
          "100:         .executableTarget(",
          "",
          "[Removed Lines]",
          "71:         .target(name: \"Vapor\", dependencies: [",
          "72:             .product(name: \"AsyncHTTPClient\", package: \"async-http-client\"),",
          "73:             .product(name: \"AsyncKit\", package: \"async-kit\"),",
          "74:             .product(name: \"Backtrace\", package: \"swift-backtrace\"),",
          "75:             .target(name: \"CVaporBcrypt\"),",
          "76:             .product(name: \"ConsoleKit\", package: \"console-kit\"),",
          "77:             .product(name: \"Logging\", package: \"swift-log\"),",
          "78:             .product(name: \"Metrics\", package: \"swift-metrics\"),",
          "79:             .product(name: \"NIO\", package: \"swift-nio\"),",
          "80:             .product(name: \"NIOConcurrencyHelpers\", package: \"swift-nio\"),",
          "81:             .product(name: \"NIOCore\", package: \"swift-nio\"),",
          "82:             .product(name: \"NIOExtras\", package: \"swift-nio-extras\"),",
          "83:             .product(name: \"NIOFoundationCompat\", package: \"swift-nio\"),",
          "84:             .product(name: \"NIOHTTPCompression\", package: \"swift-nio-extras\"),",
          "85:             .product(name: \"NIOHTTP1\", package: \"swift-nio\"),",
          "86:             .product(name: \"NIOHTTP2\", package: \"swift-nio-http2\"),",
          "87:             .product(name: \"NIOSSL\", package: \"swift-nio-ssl\"),",
          "88:             .product(name: \"NIOWebSocket\", package: \"swift-nio\"),",
          "89:             .product(name: \"Crypto\", package: \"swift-crypto\"),",
          "90:             .product(name: \"Algorithms\", package: \"swift-algorithms\"),",
          "91:             .product(name: \"RoutingKit\", package: \"routing-kit\"),",
          "92:             .product(name: \"WebSocketKit\", package: \"websocket-kit\"),",
          "93:             .product(name: \"MultipartKit\", package: \"multipart-kit\"),",
          "94:             .product(name: \"Atomics\", package: \"swift-atomics\"),",
          "95:             .product(name: \"_NIOFileSystem\", package: \"swift-nio\"),",
          "96:             .product(name: \"_NIOFileSystemFoundationCompat\", package: \"swift-nio\"),",
          "97:         ]),",
          "",
          "[Added Lines]",
          "68:         .target(",
          "69:             name: \"Vapor\",",
          "70:             dependencies: [",
          "71:                 .product(name: \"AsyncHTTPClient\", package: \"async-http-client\"),",
          "72:                 .product(name: \"AsyncKit\", package: \"async-kit\"),",
          "73:                 .target(name: \"CVaporBcrypt\"),",
          "74:                 .product(name: \"ConsoleKit\", package: \"console-kit\"),",
          "75:                 .product(name: \"Logging\", package: \"swift-log\"),",
          "76:                 .product(name: \"Metrics\", package: \"swift-metrics\"),",
          "77:                 .product(name: \"NIO\", package: \"swift-nio\"),",
          "78:                 .product(name: \"NIOConcurrencyHelpers\", package: \"swift-nio\"),",
          "79:                 .product(name: \"NIOCore\", package: \"swift-nio\"),",
          "80:                 .product(name: \"NIOExtras\", package: \"swift-nio-extras\"),",
          "81:                 .product(name: \"NIOFoundationCompat\", package: \"swift-nio\"),",
          "82:                 .product(name: \"NIOHTTPCompression\", package: \"swift-nio-extras\"),",
          "83:                 .product(name: \"NIOHTTP1\", package: \"swift-nio\"),",
          "84:                 .product(name: \"NIOHTTP2\", package: \"swift-nio-http2\"),",
          "85:                 .product(name: \"NIOSSL\", package: \"swift-nio-ssl\"),",
          "86:                 .product(name: \"NIOWebSocket\", package: \"swift-nio\"),",
          "87:                 .product(name: \"Crypto\", package: \"swift-crypto\"),",
          "88:                 .product(name: \"Algorithms\", package: \"swift-algorithms\"),",
          "89:                 .product(name: \"RoutingKit\", package: \"routing-kit\"),",
          "90:                 .product(name: \"WebSocketKit\", package: \"websocket-kit\"),",
          "91:                 .product(name: \"MultipartKit\", package: \"multipart-kit\"),",
          "92:                 .product(name: \"Atomics\", package: \"swift-atomics\"),",
          "93:                 .product(name: \"_NIOFileSystem\", package: \"swift-nio\"),",
          "94:                 .product(name: \"_NIOFileSystemFoundationCompat\", package: \"swift-nio\"),",
          "95:             ],",
          "96:             swiftSettings: [.enableExperimentalFeature(\"StrictConcurrency=complete\")]",
          "97:         ),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "102:             dependencies: [",
          "103:                 .target(name: \"Vapor\"),",
          "104:             ],",
          "106:         ),",
          "126:     ]",
          "127: )",
          "",
          "[Removed Lines]",
          "105:             resources: [.copy(\"Resources\")]",
          "109:         .target(name: \"XCTVapor\", dependencies: [",
          "110:             .target(name: \"Vapor\"),",
          "111:         ]),",
          "112:         .testTarget(name: \"VaporTests\", dependencies: [",
          "113:             .product(name: \"NIOTestUtils\", package: \"swift-nio\"),",
          "114:             .target(name: \"XCTVapor\"),",
          "115:         ], resources: [",
          "116:             .copy(\"Utilities/foo.txt\"),",
          "117:             .copy(\"Utilities/index.html\"),",
          "118:             .copy(\"Utilities/SubUtilities/\"),",
          "119:             .copy(\"Utilities/foo bar.html\"),",
          "120:             .copy(\"Utilities/test.env\"),",
          "121:             .copy(\"Utilities/my-secret-env-content\"),",
          "122:             .copy(\"Utilities/expired.crt\"),",
          "123:             .copy(\"Utilities/expired.key\"),",
          "124:             .copy(\"Utilities/long-test-file.txt\"),",
          "125:         ]),",
          "",
          "[Added Lines]",
          "105:             resources: [.copy(\"Resources\")],",
          "106:             swiftSettings: [.enableExperimentalFeature(\"StrictConcurrency=complete\")]",
          "110:         .target(",
          "111:             name: \"XCTVapor\",",
          "112:             dependencies: [",
          "113:                 .target(name: \"Vapor\"),",
          "114:             ],",
          "115:             swiftSettings: [.enableExperimentalFeature(\"StrictConcurrency=complete\")]",
          "116:         ),",
          "117:         .testTarget(",
          "118:             name: \"VaporTests\",",
          "119:             dependencies: [",
          "120:                 .product(name: \"NIOTestUtils\", package: \"swift-nio\"),",
          "121:                 .target(name: \"XCTVapor\"),",
          "122:             ],",
          "123:             resources: [",
          "124:                 .copy(\"Utilities/foo.txt\"),",
          "125:                 .copy(\"Utilities/index.html\"),",
          "126:                 .copy(\"Utilities/SubUtilities/\"),",
          "127:                 .copy(\"Utilities/foo bar.html\"),",
          "128:                 .copy(\"Utilities/test.env\"),",
          "129:                 .copy(\"Utilities/my-secret-env-content\"),",
          "130:                 .copy(\"Utilities/expired.crt\"),",
          "131:                 .copy(\"Utilities/expired.key\"),",
          "132:                 .copy(\"Utilities/long-test-file.txt\"),",
          "133:             ],",
          "134:             swiftSettings: [",
          "135:                 .enableUpcomingFeature(\"BareSlashRegexLiterals\"),",
          "136:                 .enableExperimentalFeature(\"StrictConcurrency=complete\"),",
          "137:             ]",
          "138:         ),",
          "",
          "---------------"
        ],
        "Package@swift-5.9.swift||Package@swift-5.9.swift": [
          "File: Package@swift-5.9.swift -> Package@swift-5.9.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Sources/Vapor/Application.swift||Sources/Vapor/Application.swift": [
          "File: Sources/Vapor/Application.swift -> Sources/Vapor/Application.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: import NIOCore",
          "5: import NIOPosix",
          "12: public final class Application: Sendable {",
          "13:     public var environment: Environment {",
          "",
          "[Removed Lines]",
          "7: #if swift(<5.9)",
          "8:     import Backtrace",
          "9: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "128:     private init(_ environment: Environment = .development, _ eventLoopGroupProvider: EventLoopGroupProvider = .singleton, async: Bool) {",
          "132:         self._environment = .init(environment)",
          "133:         self.eventLoopGroupProvider = eventLoopGroupProvider",
          "134:         switch eventLoopGroupProvider {",
          "",
          "[Removed Lines]",
          "129:         #if swift(<5.9)",
          "130:             Backtrace.install()",
          "131:         #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Sources/Vapor/Commands/ServeCommand.swift||Sources/Vapor/Commands/ServeCommand.swift": [
          "File: Sources/Vapor/Commands/ServeCommand.swift -> Sources/Vapor/Commands/ServeCommand.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: @preconcurrency import Dispatch",
          "4: import Foundation",
          "5: import ConsoleKit",
          "6: import NIOConcurrencyHelpers",
          "",
          "[Removed Lines]",
          "1: #if os(Linux)",
          "3: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Sources/Vapor/Content/JSONCoders+Content.swift||Sources/Vapor/Content/JSONCoders+Content.swift": [
          "File: Sources/Vapor/Content/JSONCoders+Content.swift -> Sources/Vapor/Content/JSONCoders+Content.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: import NIOCore",
          "3: import NIOHTTP1",
          "6: extension Foundation.JSONEncoder: @unchecked Swift.Sendable {}",
          "7: extension Foundation.JSONDecoder: @unchecked Swift.Sendable {}",
          "8: #endif",
          "",
          "[Removed Lines]",
          "5: #if compiler(<6.0)",
          "",
          "[Added Lines]",
          "5: #if swift(<6.0)",
          "",
          "---------------"
        ],
        "Sources/Vapor/Exports.swift||Sources/Vapor/Exports.swift": [
          "File: Sources/Vapor/Exports.swift -> Sources/Vapor/Exports.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: @_documentation(visibility: internal) @_exported import AsyncKit",
          "4: @_documentation(visibility: internal) @_exported import class AsyncHTTPClient.HTTPClient",
          "5: @_documentation(visibility: internal) @_exported import struct AsyncHTTPClient.HTTPClientError",
          "",
          "[Removed Lines]",
          "1: #if swift(>=5.8)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "30: @_documentation(visibility: internal) @_exported import struct NIOSSL.TLSConfiguration",
          "31: @_documentation(visibility: internal) @_exported import WebSocketKit",
          "32: @_documentation(visibility: internal) @_exported import MultipartKit",
          "",
          "[Removed Lines]",
          "34: #else",
          "36: @_exported import AsyncKit",
          "37: @_exported import class AsyncHTTPClient.HTTPClient",
          "38: @_exported import struct AsyncHTTPClient.HTTPClientError",
          "39: @_exported import Crypto",
          "40: @_exported import RoutingKit",
          "41: @_exported import ConsoleKit",
          "42: @_exported import Foundation",
          "43: @_exported import Logging",
          "44: @_exported import struct NIOCore.ByteBuffer",
          "45: @_exported import struct NIOCore.ByteBufferAllocator",
          "46: @_exported import protocol NIOCore.Channel",
          "47: @_exported import class NIOEmbedded.EmbeddedChannel",
          "48: @_exported import class NIOEmbedded.EmbeddedEventLoop",
          "49: @_exported import protocol NIOCore.EventLoop",
          "50: @_exported import class NIOCore.EventLoopFuture",
          "51: @_exported import protocol NIOCore.EventLoopGroup",
          "52: @_exported import struct NIOCore.EventLoopPromise",
          "53: @_exported import class NIOPosix.MultiThreadedEventLoopGroup",
          "54: @_exported import struct NIOPosix.NonBlockingFileIO",
          "55: @_exported import class NIOPosix.NIOThreadPool",
          "56: @_exported import enum NIOCore.System",
          "57: @_exported import class NIOConcurrencyHelpers.Lock",
          "58: @_exported import struct NIOHTTP1.HTTPHeaders",
          "59: @_exported import enum NIOHTTP1.HTTPMethod",
          "60: @_exported import struct NIOHTTP1.HTTPVersion",
          "61: @_exported import enum NIOHTTP1.HTTPResponseStatus",
          "62: @_exported import enum NIOHTTPCompression.NIOHTTPDecompression",
          "63: @_exported import struct NIOSSL.TLSConfiguration",
          "64: @_exported import WebSocketKit",
          "65: @_exported import MultipartKit",
          "66: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Sources/Vapor/HTTP/EndpointCache.swift||Sources/Vapor/HTTP/EndpointCache.swift": [
          "File: Sources/Vapor/HTTP/EndpointCache.swift -> Sources/Vapor/HTTP/EndpointCache.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: import Foundation",
          "6: import NIOConcurrencyHelpers",
          "7: import NIOCore",
          "8: import Logging",
          "",
          "[Removed Lines]",
          "1: #if !canImport(Darwin) && swift(<5.9)",
          "2: @preconcurrency import Foundation",
          "3: #else",
          "5: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Sources/Vapor/HTTP/Headers/HTTPCookies.swift||Sources/Vapor/HTTP/Headers/HTTPCookies.swift": [
          "File: Sources/Vapor/HTTP/Headers/HTTPCookies.swift -> Sources/Vapor/HTTP/Headers/HTTPCookies.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: import Foundation",
          "6: import NIOHTTP1",
          "8: extension HTTPHeaders {",
          "",
          "[Removed Lines]",
          "1: #if !canImport(Darwin) && swift(<5.9)",
          "2: @preconcurrency import Foundation",
          "3: #else",
          "5: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Sources/Vapor/Response/Response+Body.swift||Sources/Vapor/Response/Response+Body.swift": [
          "File: Sources/Vapor/Response/Response+Body.swift -> Sources/Vapor/Response/Response+Body.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: @preconcurrency import Dispatch",
          "5: import Foundation",
          "7: import NIOCore",
          "8: import NIOConcurrencyHelpers",
          "",
          "[Removed Lines]",
          "2: #if !canImport(Darwin) && swift(<5.9)",
          "3: @preconcurrency import Foundation",
          "4: #else",
          "6: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Sources/Vapor/Utilities/Base32.swift||Sources/Vapor/Utilities/Base32.swift": [
          "File: Sources/Vapor/Utilities/Base32.swift -> Sources/Vapor/Utilities/Base32.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:             n &+= 8 &- padding",
          "35:             if let pad = pad, padding > 0 {",
          "36:                 let pn = p.baseAddress!.advanced(by: n)",
          "40:                 pn.update(repeating: pad, count: padding)",
          "42:                 n &+= padding",
          "43:             }",
          "44:         }",
          "",
          "[Removed Lines]",
          "37: #if swift(<5.8)",
          "38:                 pn.assign(repeating: pad, count: padding)",
          "39: #else",
          "41: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Sources/Vapor/Utilities/Base64.swift||Sources/Vapor/Utilities/Base64.swift": [
          "File: Sources/Vapor/Utilities/Base64.swift -> Sources/Vapor/Utilities/Base64.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "30:             n &+= 4 &- padding",
          "31:             if let pad = pad, padding > 0 {",
          "32:                 let pn = p.baseAddress!.advanced(by: n)",
          "36:                 pn.update(repeating: pad, count: padding)",
          "38:                 n &+= padding",
          "39:             }",
          "40:         }",
          "",
          "[Removed Lines]",
          "33: #if swift(<5.8)",
          "34:                 pn.assign(repeating: pad, count: padding)",
          "35: #else",
          "37: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Sources/Vapor/Utilities/BaseN.swift||Sources/Vapor/Utilities/BaseN.swift": [
          "File: Sources/Vapor/Utilities/BaseN.swift -> Sources/Vapor/Utilities/BaseN.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:                 p[n] = table[(buf &<< (bits &- bufBits)) & mask]; n &+= 1",
          "56:                 if let pad = pad {",
          "57:                     let pn = p.baseAddress!.advanced(by: n)",
          "61:                     pn.update(repeating: pad, count: padding)",
          "63:                     n &+= padding",
          "64:                 }",
          "65:             }",
          "",
          "[Removed Lines]",
          "58: #if swift(<5.8)",
          "59:                     pn.assign(repeating: pad, count: padding)",
          "60: #else",
          "62: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Sources/XCTVapor/Exports.swift||Sources/XCTVapor/Exports.swift": [
          "File: Sources/XCTVapor/Exports.swift -> Sources/XCTVapor/Exports.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: #if !BUILDING_DOCC",
          "3: @_exported import XCTest",
          "4: @_exported import Vapor",
          "6: #endif",
          "",
          "[Added Lines]",
          "1: @_documentation(visibility: internal) @_exported import XCTest",
          "2: @_documentation(visibility: internal) @_exported import Vapor",
          "",
          "---------------"
        ],
        "Tests/VaporTests/ConditionalResponseCompressionTests.swift||Tests/VaporTests/ConditionalResponseCompressionTests.swift": [
          "File: Tests/VaporTests/ConditionalResponseCompressionTests.swift -> Tests/VaporTests/ConditionalResponseCompressionTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "168:     }",
          "170:     override func tearDown() async throws {",
          "171:         try await app.asyncShutdown()",
          "172:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "171:         await app.server.shutdown()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "175:         app.get(\"resource\") { _ in compressiblePayload }",
          "177:         try app.server.start()",
          "180:         try await assertUncompressed(app.http.server.configuration.responseCompression) /// Default case",
          "181:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "178:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "206:         }",
          "208:         try app.server.start()",
          "211:         try await assertUncompressed(app.http.server.configuration.responseCompression) /// Default case",
          "212:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "209:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "237:         }",
          "239:         try app.server.start()",
          "242:         try await assertUncompressed(app.http.server.configuration.responseCompression) /// Default case",
          "243:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "240:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "268:         }",
          "270:         try app.server.start()",
          "273:         try await assertUncompressed(app.http.server.configuration.responseCompression) /// Default case",
          "274:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "271:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "299:         }",
          "301:         try app.server.start()",
          "304:         try await assertUncompressed(app.http.server.configuration.responseCompression) /// Default case",
          "305:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "302:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "331:         }",
          "333:         try app.server.start()",
          "336:         try await assertCompressed(app.http.server.configuration.responseCompression) /// Default case",
          "337:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "334:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "363:         }",
          "365:         try app.server.start()",
          "368:         try await assertUncompressed(app.http.server.configuration.responseCompression) /// Default case",
          "369:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "366:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "395:         }",
          "397:         try app.server.start()",
          "400:         try await assertCompressed(app.http.server.configuration.responseCompression) /// Default case",
          "401:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "398:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "427:         }",
          "429:         try app.server.start()",
          "432:         try await assertUncompressed(app.http.server.configuration.responseCompression) /// Default case",
          "433:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "430:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "458:         }",
          "460:         try app.server.start()",
          "463:         try await assertCompressed(app.http.server.configuration.responseCompression) /// Default case",
          "464:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "461:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "489:         }",
          "491:         try app.server.start()",
          "494:         try await assertUncompressed(app.http.server.configuration.responseCompression) /// Default case",
          "495:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "492:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "520:         }",
          "522:         try app.server.start()",
          "525:         try await assertUncompressed(app.http.server.configuration.responseCompression) /// Default case",
          "526:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "523:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "551:         }",
          "553:         try app.server.start()",
          "556:         try await assertUncompressed(app.http.server.configuration.responseCompression) /// Default case",
          "557:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "554:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "583:         }",
          "585:         try app.server.start()",
          "588:         try await assertUncompressed(app.http.server.configuration.responseCompression) /// Default case",
          "589:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "586:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "615:         }",
          "617:         try app.server.start()",
          "620:         try await assertUncompressed(app.http.server.configuration.responseCompression) /// Default case",
          "621:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "618:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "646:         }",
          "648:         try app.server.start()",
          "651:         try await assertUncompressed(app.http.server.configuration.responseCompression) /// Default case",
          "652:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "649:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "677:         }",
          "679:         try app.server.start()",
          "682:         try await assertUncompressed(app.http.server.configuration.responseCompression) /// Default case",
          "683:         try await assertUncompressed(.forceDisabled)",
          "",
          "[Removed Lines]",
          "680:         defer { app.server.shutdown() }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "12e9b41cc576165150cb236676fc94d997d3db5f",
      "candidate_info": {
        "commit_hash": "12e9b41cc576165150cb236676fc94d997d3db5f",
        "repo": "vapor/vapor",
        "commit_url": "https://github.com/vapor/vapor/commit/12e9b41cc576165150cb236676fc94d997d3db5f",
        "files": [
          "Sources/Vapor/Utilities/URI.swift",
          "Tests/VaporTests/URITests.swift"
        ],
        "message": "Exclude Query and Fragment from URI semicolon fix on Linux (#3201)\n\n* only replace url encoded semicolons in path component, not in query\n\n* unfortunately check needs to be executed at runtime\n\n* include changes from review",
        "before_after_code_files": [
          "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift",
          "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift",
            "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift"
          ],
          "candidate": [
            "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift",
            "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift"
          ]
        }
      },
      "candidate_diff": {
        "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift": [
          "File: Sources/Vapor/Utilities/URI.swift -> Sources/Vapor/Utilities/URI.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "195:     }",
          "197:     public var string: String {",
          "204:     }",
          "",
          "[Removed Lines]",
          "198:         #if canImport(Darwin)",
          "199:         self.components?.string ?? \"\"",
          "200:         #else",
          "202:         self.components?.string?.replacingOccurrences(of: \"%3B\", with: \";\") ?? \"\"",
          "203:         #endif",
          "",
          "[Added Lines]",
          "198:         if urlPathAllowedIsBroken {",
          "200:             let string = self.components?.string ?? \"\"",
          "201:             return string.replacingOccurrences(",
          "202:                 of: \"%3B\", with: \";\",",
          "203:                 options: .literal, // N.B.: `rangeOfPath` never actually returns `nil`",
          "204:                 range: self.components?.rangeOfPath ?? (string.startIndex..<string.startIndex)",
          "205:             )",
          "206:         } else {",
          "207:             return self.components?.string ?? \"\"",
          "208:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "331:         .urlPathAllowed.union(.init(charactersIn: \";\"))",
          "332:     }",
          "333: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "341: private let urlPathAllowedIsBroken: Bool = {",
          "342:     CharacterSet.urlPathAllowed != CharacterSet.urlCorrectPathAllowed",
          "343: }()",
          "",
          "---------------"
        ],
        "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift": [
          "File: Tests/VaporTests/URITests.swift -> Tests/VaporTests/URITests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "132:         XCTAssertURIComponents(scheme: \"wss\", host: \"echo.websocket.org\", path: \"/\", generate: \"wss://echo.websocket.org/\")",
          "133:     }",
          "135:     func testMutation() {",
          "136:         var uri = URI(string: \"https://user:pass@vapor.codes:1234/foo?bar=baz#qux\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "135:     func testSemicolonIsNotEncodedInPathComponent() {",
          "136:         XCTAssertURIString(",
          "137:             \"https://user:pass@vapor.codes:1234/foo;?bar=abcd%3B%C3%A4%2B;efg#qux%3B\",",
          "138:             hasScheme: \"https\",",
          "139:             hasUserinfo: \"user:pass\",",
          "140:             hasHost: \"vapor.codes\",",
          "141:             hasPort: 1234,",
          "142:             hasPath: \"/foo;\",",
          "143:             hasQuery: \"bar=abcd%3B%C3%A4%2B;efg\",",
          "144:             hasFragment: \"qux%3B\"",
          "145:         )",
          "146:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cdbbd04f8d1f7d1cfb6a764480a56a611d0abdda",
      "candidate_info": {
        "commit_hash": "cdbbd04f8d1f7d1cfb6a764480a56a611d0abdda",
        "repo": "vapor/vapor",
        "commit_url": "https://github.com/vapor/vapor/commit/cdbbd04f8d1f7d1cfb6a764480a56a611d0abdda",
        "files": [
          "Package.swift",
          "Package@swift-5.9.swift",
          "Sources/Vapor/HTTP/Server/HTTPServerHandler.swift",
          "Sources/Vapor/HTTP/Server/HTTPServerResponseEncoder.swift",
          "Sources/Vapor/Middleware/FileMiddleware.swift",
          "Sources/Vapor/Response/Response+Body.swift",
          "Sources/Vapor/Utilities/FileIO.swift",
          "Sources/XCTVapor/XCTApplication.swift",
          "Tests/VaporTests/AsyncFileTests.swift",
          "Tests/VaporTests/ContentTests.swift",
          "Tests/VaporTests/FileTests.swift",
          "Tests/VaporTests/MiddlewareTests.swift",
          "Tests/VaporTests/PipelineTests.swift",
          "Tests/VaporTests/WebSocketTests.swift"
        ],
        "message": "Provide AsyncFileStreaming API (#3184)\n\n* Provide async stream implemetation\n\n* Add AsyncFileTests\n\n* Fix double/int bug\n\n* Allow the stream writer to complete the writer promise for async streams while cascading errors thrown from the stream callback to the promise.\n\n* Use the same ordering for both stores to the isComplete atomic in ChannelResponseBodyStream\n\n* Actually call the onCompleted() callback in asyncStreamFile()\n\n* Make sure the promise is never dropped on the floor in release builds (in which assertions like the one in ChannelResponseBodyStream's deinit aren't checked).\n\n* Make completion handler async\n\n* Use NIOFilesytemFoundationCompat\n\n* Fix imports\n\n* Make sure the NIO FileHandle is always closed on error.\n\n* Make sure the onCompleted() callback is always invoked in the error case even if trying to write the error indication to the stream fails\n\n* Migrate old ELF stream file function to use async version under the hood\n\n* Migrate FileMiddleware to async\n\n* Heavily revise ChannelResponseBodyStream's logic to eliminate races, atomics, and to handle errors and the promise completions more consistently. Especially affects async streaming, but eliminates error handling issues in non-async streaming as well.\n\n* Fix off-by-one error in FileIO.readFile(at:chunkSize:offset:byteCount:) async\n\n* Use XCTAssertNoThrow() to simplify several of the AsyncFileTests\n\n* Fix testSimpleETagHeaders test\n\n* Add async versions for XCTVapor and mark wait() calls with noasync\n\n* Fix XCTVapor error messages\n\n* Try and make tests async\n\n* Fix some warnings in tests\n\n* One less test running on 8080\n\n* Fix the tests\n\n* Revert \"Fix the tests\"\n\nThis reverts commit c98f0bf1516787ddc639f59a786e2f859cb492f9.\n\n* Hook up the response body callback for async streams\n\n* Remove a couple of instances of FileManager\n\n* Remove FileManager from AsyncFileTests\n\n* Fix default file\n\n* Fix the tests\n\n* Rework it to reduce all the returns\n\n* Update Sources/Vapor/Utilities/FileIO.swift\n\nCo-authored-by: Gwynne Raskind <gwynne@vapor.codes>\n\n* PR Reviews\n\n* Fix merge issue:\n\n* Test the correct behaviour\n\n---------\n\nCo-authored-by: Gwynne Raskind <gwynne@vapor.codes>",
        "before_after_code_files": [
          "Package.swift||Package.swift",
          "Package@swift-5.9.swift||Package@swift-5.9.swift",
          "Sources/Vapor/HTTP/Server/HTTPServerHandler.swift||Sources/Vapor/HTTP/Server/HTTPServerHandler.swift",
          "Sources/Vapor/HTTP/Server/HTTPServerResponseEncoder.swift||Sources/Vapor/HTTP/Server/HTTPServerResponseEncoder.swift",
          "Sources/Vapor/Middleware/FileMiddleware.swift||Sources/Vapor/Middleware/FileMiddleware.swift",
          "Sources/Vapor/Response/Response+Body.swift||Sources/Vapor/Response/Response+Body.swift",
          "Sources/Vapor/Utilities/FileIO.swift||Sources/Vapor/Utilities/FileIO.swift",
          "Sources/XCTVapor/XCTApplication.swift||Sources/XCTVapor/XCTApplication.swift",
          "Tests/VaporTests/AsyncFileTests.swift||Tests/VaporTests/AsyncFileTests.swift",
          "Tests/VaporTests/ContentTests.swift||Tests/VaporTests/ContentTests.swift",
          "Tests/VaporTests/FileTests.swift||Tests/VaporTests/FileTests.swift",
          "Tests/VaporTests/MiddlewareTests.swift||Tests/VaporTests/MiddlewareTests.swift",
          "Tests/VaporTests/PipelineTests.swift||Tests/VaporTests/PipelineTests.swift",
          "Tests/VaporTests/WebSocketTests.swift||Tests/VaporTests/WebSocketTests.swift"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Package.swift||Package.swift",
            "Package@swift-5.9.swift||Package@swift-5.9.swift",
            "Sources/Vapor/Response/Response+Body.swift||Sources/Vapor/Response/Response+Body.swift"
          ],
          "candidate": [
            "Package.swift||Package.swift",
            "Package@swift-5.9.swift||Package@swift-5.9.swift",
            "Sources/Vapor/Response/Response+Body.swift||Sources/Vapor/Response/Response+Body.swift"
          ]
        }
      },
      "candidate_diff": {
        "Package.swift||Package.swift": [
          "File: Package.swift -> Package.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:         .package(url: \"https://github.com/swift-server/swift-backtrace.git\", from: \"1.1.1\"),",
          "40:         .package(url: \"https://github.com/apple/swift-nio-ssl.git\", from: \"2.8.0\"),",
          "",
          "[Removed Lines]",
          "37:         .package(url: \"https://github.com/apple/swift-nio.git\", from: \"2.63.0\"),",
          "",
          "[Added Lines]",
          "37:         .package(url: \"https://github.com/apple/swift-nio.git\", from: \"2.65.0\"),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "92:             .product(name: \"WebSocketKit\", package: \"websocket-kit\"),",
          "93:             .product(name: \"MultipartKit\", package: \"multipart-kit\"),",
          "94:             .product(name: \"Atomics\", package: \"swift-atomics\"),",
          "96:             .product(name: \"_NIOFileSystem\", package: \"swift-nio\"),",
          "97:         ]),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "96:             .product(name: \"_NIOFileSystemFoundationCompat\", package: \"swift-nio\"),",
          "",
          "---------------"
        ],
        "Package@swift-5.9.swift||Package@swift-5.9.swift": [
          "File: Package@swift-5.9.swift -> Package@swift-5.9.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "31:         .package(url: \"https://github.com/vapor/routing-kit.git\", from: \"4.9.0\"),",
          "37:         .package(url: \"https://github.com/apple/swift-nio-ssl.git\", from: \"2.8.0\"),",
          "",
          "[Removed Lines]",
          "34:         .package(url: \"https://github.com/apple/swift-nio.git\", from: \"2.63.0\"),",
          "",
          "[Added Lines]",
          "34:         .package(url: \"https://github.com/apple/swift-nio.git\", from: \"2.65.0\"),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "90:                 .product(name: \"WebSocketKit\", package: \"websocket-kit\"),",
          "91:                 .product(name: \"MultipartKit\", package: \"multipart-kit\"),",
          "92:                 .product(name: \"Atomics\", package: \"swift-atomics\"),",
          "94:                 .product(name: \"_NIOFileSystem\", package: \"swift-nio\"),",
          "95:             ],",
          "96:             swiftSettings: [.enableExperimentalFeature(\"StrictConcurrency=complete\")]",
          "97:         ),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94:                 .product(name: \"_NIOFileSystemFoundationCompat\", package: \"swift-nio\"),",
          "",
          "---------------"
        ],
        "Sources/Vapor/HTTP/Server/HTTPServerHandler.swift||Sources/Vapor/HTTP/Server/HTTPServerHandler.swift": [
          "File: Sources/Vapor/HTTP/Server/HTTPServerHandler.swift -> Sources/Vapor/HTTP/Server/HTTPServerHandler.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:                 case .failure(let error):",
          "60:                     if case .stream(let stream) = response.body.storage {",
          "61:                         stream.callback(ErrorBodyStreamWriter(eventLoop: request.eventLoop, error: error))",
          "62:                     }",
          "63:                     handler.errorCaught(context: context, error: error)",
          "64:                 }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62:                     } else if case .asyncStream(let stream) = response.body.storage {",
          "63:                         Task {",
          "64:                             try? await stream.callback(ErrorBodyStreamWriter(eventLoop: request.eventLoop, error: error))",
          "65:                         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77:     }",
          "78: }",
          "83:     func write(_ result: BodyStreamResult, promise: EventLoopPromise<Void>?) {",
          "84:         promise?.fail(error)",
          "85:     }",
          "86: }",
          "",
          "[Removed Lines]",
          "80: struct ErrorBodyStreamWriter: BodyStreamWriter {",
          "81:     var eventLoop: EventLoop",
          "82:     var error: Error",
          "",
          "[Added Lines]",
          "84: fileprivate struct ErrorBodyStreamWriter: BodyStreamWriter, AsyncBodyStreamWriter {",
          "85:     let eventLoop: EventLoop",
          "86:     let error: Error",
          "92:     func write(_ result: BodyStreamResult) async throws {",
          "93:         throw error",
          "94:     }",
          "",
          "---------------"
        ],
        "Sources/Vapor/HTTP/Server/HTTPServerResponseEncoder.swift||Sources/Vapor/HTTP/Server/HTTPServerResponseEncoder.swift": [
          "File: Sources/Vapor/HTTP/Server/HTTPServerResponseEncoder.swift -> Sources/Vapor/HTTP/Server/HTTPServerResponseEncoder.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import NIOCore",
          "2: import NIOHTTP1",
          "3: import NIOConcurrencyHelpers",
          "6: final class HTTPServerResponseEncoder: ChannelOutboundHandler, RemovableChannelHandler {",
          "7:     typealias OutboundIn = Response",
          "",
          "[Removed Lines]",
          "4: import Atomics",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:                 let channelStream = ChannelResponseBodyStream(",
          "75:                     context: context,",
          "76:                     handler: self,",
          "78:                     count: stream.count == -1 ? nil : stream.count",
          "79:                 )",
          "83:                 }",
          "84:             }",
          "85:         }",
          "",
          "[Removed Lines]",
          "77:                     promise: nil,",
          "81:                 promise?.completeWithTask {",
          "82:                     try await stream.callback(channelStream)",
          "",
          "[Added Lines]",
          "76:                     promise: promise,",
          "80:                 Task {",
          "81:                     do {",
          "82:                         try await stream.callback(channelStream)",
          "87:                         promise?.succeed()",
          "88:                     } catch {",
          "89:                         promise?.fail(error)",
          "90:                     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "100:     let handlerBox: NIOLoopBound<HTTPServerResponseEncoder>",
          "101:     let promise: EventLoopPromise<Void>?",
          "102:     let count: Int?",
          "105:     let eventLoop: EventLoop",
          "107:     enum Error: Swift.Error {",
          "108:         case tooManyBytes",
          "109:         case notEnoughBytes",
          "110:     }",
          "112:     init(",
          "",
          "[Removed Lines]",
          "103:     let currentCount: ManagedAtomic<Int>",
          "104:     let isComplete: ManagedAtomic<Bool>",
          "",
          "[Added Lines]",
          "111:     let currentCount: NIOLoopBoundBox<Int>",
          "112:     let isComplete: NIOLockedValueBox<Bool>",
          "118:         case apiMisuse // tried to send a buffer or end indication after already ending or erroring the stream",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "115:         promise: EventLoopPromise<Void>?,",
          "116:         count: Int?",
          "117:     ) {",
          "118:         self.contextBox = .init(context, eventLoop: context.eventLoop)",
          "119:         self.handlerBox = .init(handler, eventLoop: context.eventLoop)",
          "120:         self.promise = promise",
          "121:         self.count = count",
          "123:         self.isComplete = .init(false)",
          "124:         self.eventLoop = context.eventLoop",
          "125:     }",
          "127:     func write(_ result: BodyStreamResult) async throws {",
          "134:     }",
          "136:     func write(_ result: BodyStreamResult, promise: EventLoopPromise<Void>?) {",
          "137:         switch result {",
          "138:         case .buffer(let buffer):",
          "142:                 self.promise?.fail(Error.tooManyBytes)",
          "144:             }",
          "145:         case .end:",
          "151:             }",
          "155:         case .error(let error):",
          "160:         }",
          "161:     }",
          "163:     deinit {",
          "165:     }",
          "166: }",
          "",
          "[Removed Lines]",
          "122:         self.currentCount = .init(0)",
          "129:         try await self.eventLoop.flatSubmit { () -> EventLoopFuture<Void> in",
          "130:             let promise = self.eventLoop.makePromise(of: Void.self)",
          "131:             self.write(result, promise: promise)",
          "132:             return promise.futureResult",
          "133:         }.get()",
          "140:             self.contextBox.value.writeAndFlush(self.handlerBox.value.wrapOutboundOut(.body(.byteBuffer(buffer))), promise: promise)",
          "141:             if let count = self.count, self.currentCount.wrappingIncrementThenLoad(by: buffer.readableBytes, ordering: .sequentiallyConsistent) > count {",
          "143:                 promise?.fail(Error.notEnoughBytes)",
          "147:             self.isComplete.store(true, ordering: .sequentiallyConsistent)",
          "148:             if let count = self.count, self.currentCount.load(ordering: .sequentiallyConsistent) < count {",
          "149:                 self.promise?.fail(Error.notEnoughBytes)",
          "150:                 promise?.fail(Error.notEnoughBytes)",
          "152:             self.contextBox.value.fireUserInboundEventTriggered(HTTPServerResponseEncoder.ResponseEndSentEvent())",
          "153:             self.contextBox.value.writeAndFlush(self.handlerBox.value.wrapOutboundOut(.end(nil)), promise: promise)",
          "154:             self.promise?.succeed(())",
          "156:             self.isComplete.store(true, ordering: .relaxed)",
          "157:             self.contextBox.value.fireUserInboundEventTriggered(HTTPServerResponseEncoder.ResponseEndSentEvent())",
          "158:             self.contextBox.value.writeAndFlush(self.handlerBox.value.wrapOutboundOut(.end(nil)), promise: promise)",
          "159:             self.promise?.fail(error)",
          "164:         assert(self.isComplete.load(ordering: .sequentiallyConsistent), \"Response body stream writer deinitialized before .end or .error was sent.\")",
          "",
          "[Added Lines]",
          "127:         context.eventLoop.assertInEventLoop()",
          "133:         self.currentCount = .init(0, eventLoop: context.eventLoop)",
          "139:         let promise = self.eventLoop.makePromise(of: Void.self)",
          "141:         self.eventLoop.execute { self.write(result, promise: promise) }",
          "142:         try await promise.futureResult.get()",
          "151:         self.eventLoop.assertInEventLoop() // Only check in debug, just in case...",
          "153:         func finishStream() {",
          "154:             self.isComplete.withLockedValue { $0 = true }",
          "155:             self.contextBox.value.fireUserInboundEventTriggered(HTTPServerResponseEncoder.ResponseEndSentEvent())",
          "159:             self.contextBox.value.writeAndFlush(self.handlerBox.value.wrapOutboundOut(.end(nil)), promise: nil)",
          "160:         }",
          "165:             guard !self.isComplete.withLockedValue({ $0 }) else { // Don't try to send data if we already ended",
          "166:                 return promise?.fail(Error.apiMisuse) ?? () // self.promise is already completed, so fail the local one and bail",
          "167:             }",
          "168:             if let count = self.count, (self.currentCount.value + buffer.readableBytes) > count {",
          "170:                 promise?.fail(Error.tooManyBytes)",
          "171:             } else {",
          "172:                 self.currentCount.value += buffer.readableBytes",
          "174:                 self.contextBox.value.writeAndFlush(self.handlerBox.value.wrapOutboundOut(.body(.byteBuffer(buffer))), promise: promise)",
          "177:             if !self.isComplete.withLockedValue({ $0 }) { // Don't send the response end events more than once.",
          "178:                 finishStream()",
          "180:                 if let count = self.count, self.currentCount.value < count {",
          "181:                     self.promise?.fail(Error.notEnoughBytes)",
          "182:                     promise?.fail(Error.notEnoughBytes)",
          "183:                 } else {",
          "184:                     self.promise?.succeed()",
          "185:                     promise?.succeed()",
          "186:                 }",
          "187:             } else {",
          "188:                 promise?.fail(Error.apiMisuse) // If we already ended, fail the local promise with API misuse",
          "191:             if !self.isComplete.withLockedValue({ $0 }) { // Don't send the response end events more than once.",
          "192:                 finishStream()",
          "193:                 self.promise?.fail(error)",
          "194:             }",
          "195:             promise?.fail(error) // We want to fail the local promise regardless. Echo the error back.",
          "200:         assert(self.isComplete.withLockedValue { $0 }, \"Response body stream writer deinitialized before .end or .error was sent.\")",
          "",
          "---------------"
        ],
        "Sources/Vapor/Middleware/FileMiddleware.swift||Sources/Vapor/Middleware/FileMiddleware.swift": [
          "File: Sources/Vapor/Middleware/FileMiddleware.swift -> Sources/Vapor/Middleware/FileMiddleware.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import Foundation",
          "2: import NIOCore",
          "9:     private let publicDirectory: String",
          "10:     private let defaultFile: String?",
          "",
          "[Removed Lines]",
          "7: public final class FileMiddleware: Middleware {",
          "",
          "[Added Lines]",
          "3: import _NIOFileSystem",
          "8: public final class FileMiddleware: AsyncMiddleware {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47:         self.advancedETagComparison = advancedETagComparison",
          "48:     }",
          "52:         guard var path = request.url.path.removingPercentEncoding else {",
          "54:         }",
          "",
          "[Removed Lines]",
          "50:     public func respond(to request: Request, chainingTo next: Responder) -> EventLoopFuture<Response> {",
          "53:             return request.eventLoop.makeFailedFuture(Abort(.badRequest))",
          "",
          "[Added Lines]",
          "51:     public func respond(to request: Request, chainingTo next: any AsyncResponder) async throws -> Response {",
          "54:             throw Abort(.badRequest)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "60:         guard !path.contains(\"../\") else {",
          "62:         }",
          "65:         var absPath = self.publicDirectory + path",
          "84:                 }",
          "94:             } else {",
          "101:             }",
          "102:         }",
          "106:     }",
          "",
          "[Removed Lines]",
          "61:             return request.eventLoop.makeFailedFuture(Abort(.forbidden))",
          "68:         var isDir: ObjCBool = false",
          "69:         guard FileManager.default.fileExists(atPath: absPath, isDirectory: &isDir) else {",
          "70:             return next.respond(to: request)",
          "71:         }",
          "73:         if isDir.boolValue {",
          "74:             guard absPath.hasSuffix(\"/\") else {",
          "75:                 switch directoryAction.kind {",
          "76:                 case .redirect:",
          "77:                     var redirectUrl = request.url",
          "78:                     redirectUrl.path += \"/\"",
          "79:                     return request.eventLoop.future(",
          "80:                         request.redirect(to: redirectUrl.string, redirectType: .permanent)",
          "81:                     )",
          "82:                 case .none:",
          "83:                     return next.respond(to: request)",
          "85:             }",
          "88:             guard let defaultFile = defaultFile else {",
          "89:                 return next.respond(to: request)",
          "90:             }",
          "92:             if defaultFile.isAbsolute() {",
          "93:                 absPath = self.publicDirectory + defaultFile.removeLeadingSlashes()",
          "95:                 absPath = absPath + defaultFile",
          "96:             }",
          "99:             guard FileManager.default.fileExists(atPath: absPath) else {",
          "100:                 return next.respond(to: request)",
          "105:         return request.fileio.streamFile(at: absPath, advancedETagComparison: advancedETagComparison)",
          "",
          "[Added Lines]",
          "62:             throw Abort(.forbidden)",
          "68:         if let fileInfo = try await FileSystem.shared.info(forFileAt: .init(absPath)) {",
          "70:             if fileInfo.type == .directory {",
          "72:                 if absPath.hasSuffix(\"/\") {",
          "74:                     if let defaultFile = defaultFile {",
          "75:                         if defaultFile.isAbsolute() {",
          "76:                             absPath = self.publicDirectory + defaultFile.removeLeadingSlashes()",
          "77:                         } else {",
          "78:                             absPath = absPath + defaultFile",
          "79:                         }",
          "81:                         if try await FileSystem.shared.info(forFileAt: .init(absPath)) != nil {",
          "83:                             return try await request.fileio.asyncStreamFile(at: absPath, advancedETagComparison: advancedETagComparison)",
          "84:                         }",
          "85:                     }",
          "86:                 } else {",
          "87:                     if directoryAction.kind == .redirect {",
          "88:                         var redirectUrl = request.url",
          "89:                         redirectUrl.path += \"/\"",
          "90:                         return request.redirect(to: redirectUrl.string, redirectType: .permanent)",
          "91:                     }",
          "95:                 return try await request.fileio.asyncStreamFile(at: absPath, advancedETagComparison: advancedETagComparison)",
          "99:         return try await next.respond(to: request)",
          "",
          "---------------"
        ],
        "Sources/Vapor/Response/Response+Body.swift||Sources/Vapor/Response/Response+Body.swift": [
          "File: Sources/Vapor/Response/Response+Body.swift -> Sources/Vapor/Response/Response+Body.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "108:                 stream.callback(collector)",
          "109:                 return collector.promise.futureResult",
          "110:                     .map { $0 }",
          "111:             default:",
          "112:                 return eventLoop.makeSucceededFuture(self.buffer)",
          "113:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111:             case .asyncStream(let stream):",
          "112:                 let collector = ResponseBodyCollector(eventLoop: eventLoop, byteBufferAllocator: self.byteBufferAllocator)",
          "113:                 return eventLoop.makeFutureWithTask {",
          "114:                     try await stream.callback(collector)",
          "115:                 }.flatMap {",
          "116:                     collector.promise.futureResult.map { $0 }",
          "117:                 }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "246:     var buffer: ByteBuffer",
          "247:     let eventLoop: EventLoop",
          "248:     let promise: EventLoopPromise<ByteBuffer>",
          "",
          "[Removed Lines]",
          "245: private final class ResponseBodyCollector: BodyStreamWriter, @unchecked Sendable {",
          "",
          "[Added Lines]",
          "252: private final class ResponseBodyCollector: BodyStreamWriter, AsyncBodyStreamWriter, @unchecked Sendable {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "269:         if let promise { future.cascade(to: promise) }",
          "270:     }",
          "271: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "279:     func write(_ result: BodyStreamResult) async throws {",
          "280:         let promise = self.eventLoop.makePromise(of: Void.self)",
          "282:         self.eventLoop.execute { self.write(result, promise: promise) }",
          "283:         try await promise.futureResult.get()",
          "284:     }",
          "",
          "---------------"
        ],
        "Sources/Vapor/Utilities/FileIO.swift||Sources/Vapor/Utilities/FileIO.swift": [
          "File: Sources/Vapor/Utilities/FileIO.swift -> Sources/Vapor/Utilities/FileIO.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import Foundation",
          "2: import NIOCore",
          "4: import NIOHTTP1",
          "5: import NIOPosix",
          "6: import Logging",
          "7: import Crypto",
          "8: import NIOConcurrencyHelpers",
          "10: extension Request {",
          "11:     public var fileio: FileIO {",
          "",
          "[Removed Lines]",
          "3: import NIOFileSystem",
          "",
          "[Added Lines]",
          "3: import _NIOFileSystem",
          "9: import _NIOFileSystemFoundationCompat",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "93:         chunkSize: Int = NonBlockingFileIO.defaultChunkSize,",
          "94:         onRead: @Sendable @escaping (ByteBuffer) -> EventLoopFuture<Void>",
          "95:     ) -> EventLoopFuture<Void> {",
          "101:         }",
          "110:     }",
          "",
          "[Removed Lines]",
          "96:         guard",
          "97:             let attributes = try? FileManager.default.attributesOfItem(atPath: path),",
          "98:             let fileSize = attributes[.size] as? NSNumber",
          "99:         else {",
          "100:             return self.request.eventLoop.makeFailedFuture(Abort(.internalServerError))",
          "102:         return self.read(",
          "103:             path: path,",
          "104:             fromOffset: 0,",
          "105:             byteCount:",
          "106:             fileSize.intValue,",
          "107:             chunkSize: chunkSize,",
          "108:             onRead: onRead",
          "109:         )",
          "",
          "[Added Lines]",
          "97:         self.request.eventLoop.makeFutureWithTask {",
          "98:             guard let fileSize = try await FileSystem.shared.info(forFileAt: .init(path))?.size else {",
          "99:                 throw Abort(.internalServerError)",
          "100:             }",
          "101:             try await self.read(",
          "102:                 path: path,",
          "103:                 fromOffset: 0,",
          "104:                 byteCount: Int(fileSize),",
          "105:                 chunkSize: chunkSize,",
          "106:                 onRead: onRead",
          "107:             ).get()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "250:         onCompleted: @escaping @Sendable (Result<Void, Error>) -> () = { _ in }",
          "251:     ) -> EventLoopFuture<Response> {",
          "351:         }",
          "352:     }",
          "",
          "[Removed Lines]",
          "253:         guard",
          "254:             let attributes = try? FileManager.default.attributesOfItem(atPath: path),",
          "255:             let modifiedAt = attributes[.modificationDate] as? Date,",
          "256:             let fileSize = (attributes[.size] as? NSNumber)?.intValue",
          "257:         else {",
          "258:             return request.eventLoop.makeSucceededFuture(Response(status: .internalServerError))",
          "259:         }",
          "261:         let contentRange: HTTPHeaders.Range?",
          "262:         if let rangeFromHeaders = request.headers.range {",
          "263:             if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {",
          "264:                 contentRange = rangeFromHeaders",
          "265:             } else {",
          "266:                 contentRange = nil",
          "267:             }",
          "268:         } else if request.headers.contains(name: .range) {",
          "270:             request.logger.debug(\"Range header was provided in request but was invalid\")",
          "271:             let response = Response(status: .badRequest)",
          "272:             return request.eventLoop.makeSucceededFuture(response)",
          "273:         } else {",
          "274:             contentRange = nil",
          "275:         }",
          "277:         var eTagFuture: EventLoopFuture<String>",
          "279:         if advancedETagComparison {",
          "280:             eTagFuture = generateETagHash(path: path, lastModified: modifiedAt)",
          "281:         } else {",
          "283:             eTagFuture = request.eventLoop.makeSucceededFuture(\"\\\"\\(modifiedAt.timeIntervalSince1970)-\\(fileSize)\\\"\")",
          "284:         }",
          "286:         return eTagFuture.map { fileETag in",
          "288:             var headers: HTTPHeaders = [:]",
          "291:             headers.lastModified = HTTPHeaders.LastModified(value: modifiedAt)",
          "293:             headers.replaceOrAdd(name: .eTag, value: fileETag)",
          "296:             if fileETag == request.headers.first(name: .ifNoneMatch) {",
          "300:                 headers.replaceOrAdd(name: .contentLength, value: fileSize.description)",
          "301:                 return Response(status: .notModified, version: .http1_1, headersNoUpdate: headers, body: .empty)",
          "302:             }",
          "305:             let response = Response(status: .ok, headers: headers)",
          "306:             let offset: Int64",
          "307:             let byteCount: Int",
          "308:             if let contentRange = contentRange {",
          "309:                 response.status = .partialContent",
          "310:                 response.headers.add(name: .accept, value: contentRange.unit.serialize())",
          "311:                 if let firstRange = contentRange.ranges.first {",
          "312:                     do {",
          "313:                         let range = try firstRange.asResponseContentRange(limit: fileSize)",
          "314:                         response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)",
          "315:                         (offset, byteCount) = try firstRange.asByteBufferBounds(withMaxSize: fileSize, logger: request.logger)",
          "316:                     } catch {",
          "317:                         let response = Response(status: .badRequest)",
          "318:                         return response",
          "319:                     }",
          "320:                 } else {",
          "321:                     offset = 0",
          "322:                     byteCount = fileSize",
          "323:                 }",
          "324:             } else {",
          "325:                 offset = 0",
          "326:                 byteCount = fileSize",
          "327:             }",
          "330:             if",
          "331:                 let fileExtension = path.components(separatedBy: \".\").last,",
          "332:                 let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)",
          "333:             {",
          "334:                 response.headers.contentType = type",
          "335:             }",
          "336:             response.body = .init(stream: { stream in",
          "337:                 self.read(path: path, fromOffset: offset, byteCount: byteCount, chunkSize: chunkSize) { chunk in",
          "338:                     return stream.write(.buffer(chunk))",
          "339:                 }.whenComplete { result in",
          "340:                     switch result {",
          "341:                     case .failure(let error):",
          "342:                         stream.write(.error(error), promise: nil)",
          "343:                     case .success:",
          "344:                         stream.write(.end, promise: nil)",
          "345:                     }",
          "346:                     onCompleted(result)",
          "347:                 }",
          "348:             }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)",
          "350:             return response",
          "",
          "[Added Lines]",
          "252:         self.request.eventLoop.makeFutureWithTask {",
          "253:             try await self.asyncStreamFile(at: path, chunkSize: chunkSize, mediaType: mediaType, advancedETagComparison: advancedETagComparison, onCompleted: onCompleted)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "463:     public struct FileChunks: AsyncSequence {",
          "464:         public typealias Element = ByteBuffer",
          "469:             self.fileChunks = fileChunks",
          "470:             self.fileHandle = fileHandle",
          "471:         }",
          "473:         public struct FileChunksIterator: AsyncIteratorProtocol {",
          "478:                 self.iterator = iterator",
          "479:                 self.fileHandle = fileHandle",
          "480:             }",
          "",
          "[Removed Lines]",
          "465:         private let fileHandle: NIOFileSystem.FileHandleProtocol",
          "466:         private let fileChunks: NIOFileSystem.FileChunks",
          "468:         init(fileChunks: NIOFileSystem.FileChunks, fileHandle: some NIOFileSystem.FileHandleProtocol) {",
          "474:             private var iterator: NIOFileSystem.FileChunks.AsyncIterator",
          "475:             private let fileHandle: NIOFileSystem.FileHandleProtocol",
          "477:             fileprivate init(wrapping iterator: NIOFileSystem.FileChunks.AsyncIterator, fileHandle: some NIOFileSystem.FileHandleProtocol) {",
          "",
          "[Added Lines]",
          "368:         private let fileHandle: _NIOFileSystem.FileHandleProtocol",
          "369:         private let fileChunks: _NIOFileSystem.FileChunks",
          "371:         init(fileChunks: _NIOFileSystem.FileChunks, fileHandle: some _NIOFileSystem.FileHandleProtocol) {",
          "377:             private var iterator: _NIOFileSystem.FileChunks.AsyncIterator",
          "378:             private let fileHandle: _NIOFileSystem.FileHandleProtocol",
          "380:             fileprivate init(wrapping iterator: _NIOFileSystem.FileChunks.AsyncIterator, fileHandle: some _NIOFileSystem.FileHandleProtocol) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "482:             public mutating func next() async throws -> ByteBuffer? {",
          "483:                 let chunk = try await iterator.next()",
          "484:                 if chunk == nil {",
          "485:                     try await fileHandle.close()",
          "486:                 }",
          "487:                 return chunk",
          "488:             }",
          "489:         }",
          "491:         public func makeAsyncIterator() -> FileChunksIterator {",
          "492:             FileChunksIterator(wrapping: fileChunks.makeAsyncIterator(), fileHandle: fileHandle)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "395:         public func closeHandle() async throws {",
          "396:             try await self.fileHandle.close()",
          "397:         }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "506:     public func readFile(",
          "507:         at path: String,",
          "509:     ) async throws -> FileChunks {",
          "510:         let filePath = FilePath(path)",
          "512:         let readHandle = try await fileSystem.openFile(forReadingAt: filePath)",
          "515:         return FileChunks(fileChunks: chunks, fileHandle: readHandle)",
          "516:     }",
          "",
          "[Removed Lines]",
          "508:         chunkSize: Int = NonBlockingFileIO.defaultChunkSize",
          "513:         let chunks = readHandle.readChunks(chunkLength: .bytes(Int64(chunkSize)))",
          "",
          "[Added Lines]",
          "416:         chunkSize: Int = NonBlockingFileIO.defaultChunkSize,",
          "417:         offset: Int64? = nil,",
          "418:         byteCount: Int? = nil",
          "424:         let chunks: _NIOFileSystem.FileChunks",
          "426:         if let offset {",
          "427:             if let byteCount {",
          "428:                 chunks = readHandle.readChunks(in: offset..<(offset+Int64(byteCount)), chunkLength: .bytes(Int64(chunkSize)))",
          "429:             } else {",
          "430:                 chunks = readHandle.readChunks(in: offset..., chunkLength: .bytes(Int64(chunkSize)))",
          "431:             }",
          "432:         } else {",
          "433:             chunks = readHandle.readChunks(chunkLength: .bytes(Int64(chunkSize)))",
          "434:         }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "531:         }",
          "532:         try await self.io.write(fileHandle: fd, buffer: buffer)",
          "533:     }",
          "534: }",
          "536: extension HTTPHeaders.Range.Value {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "477:     public func asyncStreamFile(",
          "478:         at path: String,",
          "479:         chunkSize: Int = NonBlockingFileIO.defaultChunkSize,",
          "480:         mediaType: HTTPMediaType? = nil,",
          "481:         advancedETagComparison: Bool = false,",
          "482:         onCompleted: @escaping @Sendable (Result<Void, Error>) async throws -> () = { _ in }",
          "483:     ) async throws -> Response {",
          "485:         guard let fileInfo = try await FileSystem.shared.info(forFileAt: .init(path)) else {",
          "486:             throw Abort(.internalServerError)",
          "487:         }",
          "489:         let contentRange: HTTPHeaders.Range?",
          "490:         if let rangeFromHeaders = request.headers.range {",
          "491:             if rangeFromHeaders.unit == .bytes && rangeFromHeaders.ranges.count == 1 {",
          "492:                 contentRange = rangeFromHeaders",
          "493:             } else {",
          "494:                 contentRange = nil",
          "495:             }",
          "496:         } else if request.headers.contains(name: .range) {",
          "498:             request.logger.debug(\"Range header was provided in request but was invalid\")",
          "499:             throw Abort(.badRequest)",
          "500:         } else {",
          "501:             contentRange = nil",
          "502:         }",
          "504:         let eTag: String",
          "506:         if advancedETagComparison {",
          "507:             eTag = try await generateETagHash(path: path, lastModified: fileInfo.lastDataModificationTime.date).get()",
          "508:         } else {",
          "510:             eTag = \"\\\"\\(fileInfo.lastDataModificationTime.seconds)-\\(fileInfo.size)\\\"\"",
          "511:         }",
          "514:         var headers: HTTPHeaders = [:]",
          "517:         headers.lastModified = HTTPHeaders.LastModified(value: fileInfo.lastDataModificationTime.date)",
          "519:         headers.replaceOrAdd(name: .eTag, value: eTag)",
          "522:         if eTag == request.headers.first(name: .ifNoneMatch) {",
          "526:             headers.replaceOrAdd(name: .contentLength, value: fileInfo.size.description)",
          "527:             return Response(status: .notModified, version: .http1_1, headersNoUpdate: headers, body: .empty)",
          "528:         }",
          "531:         let response = Response(status: .ok, headers: headers)",
          "532:         let offset: Int64",
          "533:         let byteCount: Int",
          "534:         if let contentRange = contentRange {",
          "535:             response.status = .partialContent",
          "536:             response.headers.add(name: .accept, value: contentRange.unit.serialize())",
          "537:             if let firstRange = contentRange.ranges.first {",
          "538:                 do {",
          "539:                     let range = try firstRange.asResponseContentRange(limit: Int(fileInfo.size))",
          "540:                     response.headers.contentRange = HTTPHeaders.ContentRange(unit: contentRange.unit, range: range)",
          "541:                     (offset, byteCount) = try firstRange.asByteBufferBounds(withMaxSize: Int(fileInfo.size), logger: request.logger)",
          "542:                 } catch {",
          "543:                     throw Abort(.badRequest)",
          "544:                 }",
          "545:             } else {",
          "546:                 offset = 0",
          "547:                 byteCount = Int(fileInfo.size)",
          "548:             }",
          "549:         } else {",
          "550:             offset = 0",
          "551:             byteCount = Int(fileInfo.size)",
          "552:         }",
          "555:         if",
          "556:             let fileExtension = path.components(separatedBy: \".\").last,",
          "557:             let type = mediaType ?? HTTPMediaType.fileExtension(fileExtension)",
          "558:         {",
          "559:             response.headers.contentType = type",
          "560:         }",
          "562:         response.body = .init(asyncStream: { stream in",
          "563:             do {",
          "564:                 let chunks = try await self.readFile(at: path, chunkSize: chunkSize, offset: offset, byteCount: byteCount)",
          "565:                 do {",
          "566:                     for try await chunk in chunks {",
          "567:                         try await stream.writeBuffer(chunk)",
          "568:                     }",
          "569:                     try? await chunks.closeHandle()",
          "570:                 } catch {",
          "571:                     try? await chunks.closeHandle()",
          "572:                     throw error",
          "573:                 }",
          "574:                 try await stream.write(.end)",
          "575:                 try await onCompleted(.success(()))",
          "576:             } catch {",
          "577:                 try? await stream.write(.error(error))",
          "578:                 try await onCompleted(.failure(error))",
          "579:             }",
          "580:         }, count: byteCount, byteBufferAllocator: request.byteBufferAllocator)",
          "582:         return response",
          "583:     }",
          "",
          "---------------"
        ],
        "Sources/XCTVapor/XCTApplication.swift||Sources/XCTVapor/XCTApplication.swift": [
          "File: Sources/XCTVapor/XCTApplication.swift -> Sources/XCTVapor/XCTApplication.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: import Vapor",
          "7: extension Application: XCTApplicationTester {",
          "8:     public func performTest(request: XCTHTTPRequest) throws -> XCTHTTPResponse {",
          "9:          try self.testable().performTest(request: request)",
          "10:     }",
          "11: }",
          "13: extension Application {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8:     @available(*, noasync, message: \"Use the async method instead.\")",
          "13:     public func performTest(request: XCTHTTPRequest) async throws -> XCTHTTPResponse {",
          "14:          try await self.testable().performTest(request: request)",
          "15:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:             self.port = port",
          "45:         }",
          "47:         func performTest(request: XCTHTTPRequest) throws -> XCTHTTPResponse {",
          "48:             try app.server.start(address: .hostname(self.hostname, port: self.port))",
          "49:             defer { app.server.shutdown() }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52:         @available(*, noasync, message: \"Use the async method instead.\")",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "81:                 body: response.body ?? ByteBufferAllocator().buffer(capacity: 0)",
          "82:             )",
          "83:         }",
          "84:     }",
          "86:     private struct InMemory: XCTApplicationTester {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "91:         func performTest(request: XCTHTTPRequest) async throws -> XCTHTTPResponse {",
          "92:             try app.server.start(address: .hostname(self.hostname, port: self.port))",
          "93:             defer { app.server.shutdown() }",
          "95:             let client = HTTPClient(eventLoopGroup: MultiThreadedEventLoopGroup.singleton)",
          "96:             defer { try! client.syncShutdown() }",
          "97:             var path = request.url.path",
          "98:             path = path.hasPrefix(\"/\") ? path : \"/\\(path)\"",
          "100:             let actualPort: Int",
          "102:             if self.port == 0 {",
          "103:                 guard let portAllocated = app.http.server.shared.localAddress?.port else {",
          "104:                     throw Abort(.internalServerError, reason: \"Failed to get port from local address\")",
          "105:                 }",
          "106:                 actualPort = portAllocated",
          "107:             } else {",
          "108:                 actualPort = self.port",
          "109:             }",
          "111:             var url = \"http://\\(self.hostname):\\(actualPort)\\(path)\"",
          "112:             if let query = request.url.query {",
          "113:                 url += \"?\\(query)\"",
          "114:             }",
          "115:             var clientRequest = try HTTPClient.Request(",
          "116:                 url: url,",
          "117:                 method: request.method,",
          "118:                 headers: request.headers",
          "119:             )",
          "120:             clientRequest.body = .byteBuffer(request.body)",
          "121:             let response = try await client.execute(request: clientRequest).get()",
          "122:             return XCTHTTPResponse(",
          "123:                 status: response.status,",
          "124:                 headers: response.headers,",
          "125:                 body: response.body ?? ByteBufferAllocator().buffer(capacity: 0)",
          "126:             )",
          "127:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "89:             self.app = app",
          "90:         }",
          "92:         @discardableResult",
          "93:         public func performTest(",
          "94:             request: XCTHTTPRequest",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "136:         @available(*, noasync, message: \"Use the async method instead.\")",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "114:                 body: res.body.collect(on: request.eventLoop).wait() ?? ByteBufferAllocator().buffer(capacity: 0)",
          "115:             )",
          "116:         }",
          "117:     }",
          "118: }",
          "120: public protocol XCTApplicationTester {",
          "121:     func performTest(request: XCTHTTPRequest) throws -> XCTHTTPResponse",
          "122: }",
          "124: extension XCTApplicationTester {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "163:         @discardableResult",
          "164:         public func performTest(",
          "165:             request: XCTHTTPRequest",
          "166:         ) async throws -> XCTHTTPResponse {",
          "167:             var headers = request.headers",
          "168:             headers.replaceOrAdd(",
          "169:                 name: .contentLength,",
          "170:                 value: request.body.readableBytes.description",
          "171:             )",
          "172:             let request = Request(",
          "173:                 application: app,",
          "174:                 method: request.method,",
          "175:                 url: request.url,",
          "176:                 headers: headers,",
          "177:                 collectedBody: request.body.readableBytes == 0 ? nil : request.body,",
          "178:                 remoteAddress: nil,",
          "179:                 on: self.app.eventLoopGroup.next()",
          "180:             )",
          "181:             let res = try await self.app.responder.respond(to: request).get()",
          "182:             return try await XCTHTTPResponse(",
          "183:                 status: res.status,",
          "184:                 headers: res.headers,",
          "185:                 body: res.body.collect(on: request.eventLoop).get() ?? ByteBufferAllocator().buffer(capacity: 0)",
          "186:             )",
          "187:         }",
          "192:     @available(*, noasync, message: \"Use the async method instead.\")",
          "194:     func performTest(request: XCTHTTPRequest) async throws -> XCTHTTPResponse",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "144:         )",
          "145:     }",
          "147:     @discardableResult",
          "148:     public func test(",
          "149:         _ method: HTTPMethod,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "220:     @available(*, noasync, message: \"Use the async method instead.\")",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "185:         )",
          "186:         try await beforeRequest(&request)",
          "187:         do {",
          "189:             try await afterResponse(response)",
          "190:         } catch {",
          "192:             throw error",
          "193:         }",
          "194:         return self",
          "195:     }",
          "197:     @discardableResult",
          "198:     public func test(",
          "199:         _ method: HTTPMethod,",
          "",
          "[Removed Lines]",
          "188:             let response = try self.performTest(request: request)",
          "191:             XCTFail(\"\\(error)\", file: file, line: line)",
          "",
          "[Added Lines]",
          "262:             let response = try await self.performTest(request: request)",
          "265:             XCTFail(\"\\(String(reflecting: error))\", file: file, line: line)",
          "271:     @available(*, noasync, message: \"Use the async method instead.\")",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "216:             let response = try self.performTest(request: request)",
          "217:             try afterResponse(response)",
          "218:         } catch {",
          "220:             throw error",
          "221:         }",
          "222:         return self",
          "",
          "[Removed Lines]",
          "219:             XCTFail(\"\\(error)\", file: file, line: line)",
          "",
          "[Added Lines]",
          "294:             XCTFail(\"\\(String(reflecting: error))\", file: file, line: line)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "239:         )",
          "240:         try await beforeRequest(&request)",
          "241:         do {",
          "243:         } catch {",
          "245:             throw error",
          "246:         }",
          "247:     }",
          "249:     public func sendRequest(",
          "250:         _ method: HTTPMethod,",
          "251:         _ path: String,",
          "",
          "[Removed Lines]",
          "242:             return try self.performTest(request: request)",
          "244:             XCTFail(\"\\(error)\", file: file, line: line)",
          "",
          "[Added Lines]",
          "317:             return try await self.performTest(request: request)",
          "319:             XCTFail(\"\\(String(reflecting: error))\", file: file, line: line)",
          "324:     @available(*, noasync, message: \"Use the async method instead.\")",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "265:         do {",
          "266:             return try self.performTest(request: request)",
          "267:         } catch {",
          "269:             throw error",
          "270:         }",
          "271:     }",
          "",
          "[Removed Lines]",
          "268:             XCTFail(\"\\(error)\", file: file, line: line)",
          "",
          "[Added Lines]",
          "344:             XCTFail(\"\\(String(reflecting: error))\", file: file, line: line)",
          "",
          "---------------"
        ],
        "Tests/VaporTests/AsyncFileTests.swift||Tests/VaporTests/AsyncFileTests.swift": [
          "File: Tests/VaporTests/AsyncFileTests.swift -> Tests/VaporTests/AsyncFileTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import XCTVapor",
          "2: import XCTest",
          "3: import Vapor",
          "4: import NIOCore",
          "5: import NIOHTTP1",
          "6: import _NIOFileSystem",
          "7: import Crypto",
          "9: final class AsyncFileTests: XCTestCase, @unchecked Sendable {",
          "10:     func testStreamFile() throws {",
          "11:         let app = Application(.testing)",
          "12:         defer { app.shutdown() }",
          "14:         app.get(\"file-stream\") { req -> Response in",
          "15:             return try await req.fileio.asyncStreamFile(at: #file, advancedETagComparison: true) { result in",
          "16:                 do {",
          "17:                     try result.get()",
          "18:                 } catch {",
          "19:                     XCTFail(\"File Stream should have succeeded\")",
          "20:                 }",
          "21:             }",
          "22:         }",
          "24:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\") { res in",
          "25:             let test = \"the quick brown fox\"",
          "26:             XCTAssertNotNil(res.headers.first(name: .eTag))",
          "27:             XCTAssertContains(res.body.string, test)",
          "28:         }",
          "29:     }",
          "31:     func testStreamFileConnectionClose() throws {",
          "32:         let app = Application(.testing)",
          "33:         defer { app.shutdown() }",
          "35:         app.get(\"file-stream\") { req -> Response in",
          "36:             return try await req.fileio.asyncStreamFile(at: #file, advancedETagComparison: true)",
          "37:         }",
          "39:         var headers = HTTPHeaders()",
          "40:         headers.replaceOrAdd(name: .connection, value: \"close\")",
          "41:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headers) { res in",
          "42:             let test = \"the quick brown fox\"",
          "43:             XCTAssertNotNil(res.headers.first(name: .eTag))",
          "44:             XCTAssertContains(res.body.string, test)",
          "45:         }",
          "46:     }",
          "48:     func testStreamFileNull() throws {",
          "49:         let app = Application(.testing)",
          "50:         defer { app.shutdown() }",
          "52:         app.get(\"file-stream\") { req -> Response in",
          "53:             var tmpPath: String",
          "54:             repeat {",
          "55:                 tmpPath = try await FileSystem.shared.temporaryDirectory.appending(UUID().uuidString).string",
          "56:             } while try await self.fileExists(at: tmpPath)",
          "58:             return try await req.fileio.asyncStreamFile(at: tmpPath, advancedETagComparison: true) { result in",
          "59:                 do {",
          "60:                     try result.get()",
          "61:                     XCTFail(\"File Stream should have failed\")",
          "62:                 } catch {",
          "63:                 }",
          "64:             }",
          "65:         }",
          "67:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\") { res in",
          "68:             XCTAssertEqual(res.status, .internalServerError)",
          "69:         }",
          "70:     }",
          "72:     private func fileExists(at path: String) async throws -> Bool {",
          "73:         return try await FileSystem.shared.info(forFileAt: .init(path)) != nil",
          "74:     }",
          "76:     func testAdvancedETagHeaders() throws {",
          "77:         let app = Application(.testing)",
          "78:         defer { app.shutdown() }",
          "80:         app.get(\"file-stream\") { req -> Response in",
          "81:             return try await req.fileio.asyncStreamFile(at: #file, advancedETagComparison: true) { result in",
          "82:                 do {",
          "83:                     try result.get()",
          "84:                 } catch {",
          "85:                     XCTFail(\"File Stream should have succeeded\")",
          "86:                 }",
          "87:             }",
          "88:         }",
          "90:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\") { res in",
          "91:             let fileData = try Data(contentsOf: URL(fileURLWithPath: #file))",
          "92:             let digest = SHA256.hash(data: fileData)",
          "93:             let eTag = res.headers.first(name: \"etag\")",
          "94:             XCTAssertEqual(eTag, digest.hex)",
          "95:         }",
          "96:     }",
          "98:     func testSimpleETagHeaders() async throws {",
          "99:         let app = Application(.testing)",
          "100:         defer { app.shutdown() }",
          "102:         app.get(\"file-stream\") { req -> Response in",
          "103:             return try await req.fileio.asyncStreamFile(at: #file, advancedETagComparison: false) { result in",
          "104:                 do {",
          "105:                     try result.get()",
          "106:                 } catch {",
          "107:                     XCTFail(\"File Stream should have succeeded\")",
          "108:                 }",
          "109:             }",
          "110:         }",
          "112:         try await app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\") { res in",
          "113:             guard let fileInfo = try await FileSystem.shared.info(forFileAt: .init(#file)) else {",
          "114:                 XCTFail(\"Missing File Info\")",
          "115:                 return",
          "116:             }",
          "117:             let fileETag = \"\\\"\\(Int(fileInfo.lastDataModificationTime.date.timeIntervalSince1970))-\\(fileInfo.size)\\\"\"",
          "118:             XCTAssertEqual(res.headers.first(name: .eTag), fileETag)",
          "119:         }",
          "120:     }",
          "122:     func testStreamFileContentHeaderTail() throws {",
          "123:         let app = Application(.testing)",
          "124:         defer { app.shutdown() }",
          "126:         app.get(\"file-stream\") { req -> Response in",
          "127:             return try await req.fileio.asyncStreamFile(at: #file, advancedETagComparison: true) { result in",
          "128:                 do {",
          "129:                     try result.get()",
          "130:                 } catch {",
          "131:                     XCTFail(\"File Stream should have succeeded\")",
          "132:                 }",
          "133:             }",
          "134:         }",
          "136:         var headerRequest = HTTPHeaders()",
          "137:         headerRequest.range = .init(unit: .bytes, ranges: [.tail(value: 20)])",
          "138:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headerRequest) { res in",
          "140:             let contentRange = res.headers.first(name: \"content-range\")",
          "141:             let contentLength = res.headers.first(name: \"content-length\")",
          "143:             let lowerRange = Int((contentRange?.split(separator: \"-\")[0].split(separator: \" \")[1])!)!",
          "144:             let upperRange = Int((contentRange?.split(separator: \"-\")[1].split(separator: \"/\")[0])!)!",
          "146:             let range = upperRange - lowerRange + 1",
          "147:             let length = Int(contentLength!)!",
          "149:             XCTAssertTrue(range == length)",
          "150:         }",
          "151:     }",
          "153:     func testStreamFileContentHeaderStart() throws {",
          "154:         let app = Application(.testing)",
          "155:         defer { app.shutdown() }",
          "157:         app.get(\"file-stream\") { req -> Response in",
          "158:             return try await req.fileio.asyncStreamFile(at: #file, advancedETagComparison: true) { result in",
          "159:                 do {",
          "160:                     try result.get()",
          "161:                 } catch {",
          "162:                     XCTFail(\"File Stream should have succeeded\")",
          "163:                 }",
          "164:             }",
          "165:         }",
          "167:         var headerRequest = HTTPHeaders()",
          "168:         headerRequest.range = .init(unit: .bytes, ranges: [.start(value: 20)])",
          "169:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headerRequest) { res in",
          "171:             let contentRange = res.headers.first(name: \"content-range\")",
          "172:             let contentLength = res.headers.first(name: \"content-length\")",
          "174:             let lowerRange = Int((contentRange?.split(separator: \"-\")[0].split(separator: \" \")[1])!)!",
          "175:             let upperRange = Int((contentRange?.split(separator: \"-\")[1].split(separator: \"/\")[0])!)!",
          "177:             let range = upperRange - lowerRange + 1",
          "178:             let length = Int(contentLength!)!",
          "180:             XCTAssertTrue(range == length)",
          "181:         }",
          "182:     }",
          "184:     func testStreamFileContentHeadersWithin() throws {",
          "185:         let app = Application(.testing)",
          "186:         defer { app.shutdown() }",
          "188:         app.get(\"file-stream\") { req -> Response in",
          "189:             try await req.fileio.asyncStreamFile(at: #file, advancedETagComparison: true) { result in",
          "190:                 XCTAssertNoThrow(try result.get())",
          "191:             }",
          "192:         }",
          "194:         var headerRequest = HTTPHeaders()",
          "195:         headerRequest.range = .init(unit: .bytes, ranges: [.within(start: 20, end: 25)])",
          "196:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headerRequest) { res in",
          "198:             let contentRange = res.headers.first(name: \"content-range\")",
          "199:             let contentLength = res.headers.first(name: \"content-length\")",
          "201:             let lowerRange = Int((contentRange?.split(separator: \"-\")[0].split(separator: \" \")[1])!)!",
          "202:             let upperRange = Int((contentRange?.split(separator: \"-\")[1].split(separator: \"/\")[0])!)!",
          "204:             let range = upperRange - lowerRange + 1",
          "205:             let length = Int(contentLength!)!",
          "207:             XCTAssertTrue(range == length)",
          "208:         }",
          "209:     }",
          "211:     func testStreamFileContentHeadersOnlyFirstByte() async throws {",
          "212:         let app = Application(.testing)",
          "213:         defer { app.shutdown() }",
          "215:         app.get(\"file-stream\") { req in",
          "216:             try await req.fileio.asyncStreamFile(at: #file, advancedETagComparison: true) { result in",
          "217:                 XCTAssertNoThrow(try result.get())",
          "218:             }",
          "219:         }",
          "221:         var headers = HTTPHeaders()",
          "222:         headers.range = .init(unit: .bytes, ranges: [.within(start: 0, end: 0)])",
          "223:         try await app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headers) { res async in",
          "224:             XCTAssertEqual(res.status, .partialContent)",
          "226:             XCTAssertEqual(res.headers.first(name: .contentLength), \"1\")",
          "227:             let range = res.headers.first(name: .contentRange)!.split(separator: \"/\").first!.split(separator: \" \").last!",
          "228:             XCTAssertEqual(range, \"0-0\")",
          "230:             XCTAssertEqual(res.body.readableBytes, 1)",
          "231:         }",
          "232:     }",
          "234:     func testStreamFileContentHeadersWithinFail() throws {",
          "235:         let app = Application(.testing)",
          "236:         defer { app.shutdown() }",
          "238:         app.get(\"file-stream\") { req -> Response in",
          "239:             try await req.fileio.asyncStreamFile(at: #file, advancedETagComparison: true) { result in",
          "240:                 XCTAssertNoThrow(try result.get())",
          "241:             }",
          "242:         }",
          "244:         var headerRequest = HTTPHeaders()",
          "245:         headerRequest.range = .init(unit: .bytes, ranges: [.within(start: -20, end: 25)])",
          "246:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headerRequest) { res in",
          "247:             XCTAssertEqual(res.status, .badRequest)",
          "248:         }",
          "250:         headerRequest.range = .init(unit: .bytes, ranges: [.within(start: 10, end: 100000000)])",
          "251:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headerRequest) { res in",
          "252:             XCTAssertEqual(res.status, .badRequest)",
          "253:         }",
          "254:     }",
          "256:     func testStreamFileContentHeadersStartFail() throws {",
          "257:         let app = Application(.testing)",
          "258:         defer { app.shutdown() }",
          "260:         app.get(\"file-stream\") { req -> Response in",
          "261:             try await req.fileio.asyncStreamFile(at: #file, advancedETagComparison: true) { result in",
          "262:                 XCTAssertNoThrow(try result.get())",
          "263:             }",
          "264:         }",
          "266:         var headerRequest = HTTPHeaders()",
          "267:         headerRequest.range = .init(unit: .bytes, ranges: [.start(value: -20)])",
          "268:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headerRequest) { res in",
          "269:             XCTAssertEqual(res.status, .badRequest)",
          "270:         }",
          "272:         headerRequest.range = .init(unit: .bytes, ranges: [.start(value: 100000000)])",
          "273:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headerRequest) { res in",
          "274:             XCTAssertEqual(res.status, .badRequest)",
          "275:         }",
          "276:     }",
          "278:     func testStreamFileContentHeadersTailFail() throws {",
          "279:         let app = Application(.testing)",
          "280:         defer { app.shutdown() }",
          "282:         app.get(\"file-stream\") { req -> Response in",
          "283:             try await req.fileio.asyncStreamFile(at: #file, advancedETagComparison: true) { result in",
          "284:                 XCTAssertNoThrow(try result.get())",
          "285:             }",
          "286:         }",
          "288:         var headerRequest = HTTPHeaders()",
          "289:         headerRequest.range = .init(unit: .bytes, ranges: [.tail(value: -20)])",
          "290:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headerRequest) { res in",
          "291:             XCTAssertEqual(res.status, .badRequest)",
          "292:         }",
          "294:         headerRequest.range = .init(unit: .bytes, ranges: [.tail(value: 100000000)])",
          "295:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headerRequest) { res in",
          "296:             XCTAssertEqual(res.status, .badRequest)",
          "297:         }",
          "298:     }",
          "300:     func testFileWrite() async throws {",
          "301:         let data = \"Hello\"",
          "302:         let path = \"/tmp/fileio_write.txt\"",
          "304:         do {",
          "305:             let app = Application(.testing)",
          "306:             defer { app.shutdown() }",
          "308:             let request = Request(application: app, on: app.eventLoopGroup.next())",
          "310:             try await request.fileio.writeFile(ByteBuffer(string: data), at: path)",
          "312:             let result = try String(contentsOfFile: path)",
          "313:             XCTAssertEqual(result, data)",
          "314:         } catch {",
          "315:             try await FileSystem.shared.removeItem(at: .init(path))",
          "316:             throw error",
          "317:         }",
          "318:     }",
          "321:     func testInvalidRangeHeaderDoesNotCrash() throws {",
          "322:         let app = Application(.testing)",
          "323:         defer { app.shutdown() }",
          "325:         app.get(\"file-stream\") { req -> Response in",
          "326:             try await req.fileio.asyncStreamFile(at: #file, advancedETagComparison: true)",
          "327:         }",
          "329:         var headers = HTTPHeaders()",
          "330:         headers.replaceOrAdd(name: .range, value: \"bytes=0-9223372036854775807\")",
          "331:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headers) { res in",
          "332:             XCTAssertEqual(res.status, .badRequest)",
          "333:         }",
          "335:         headers.replaceOrAdd(name: .range, value: \"bytes=-1-10\")",
          "336:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headers) { res in",
          "337:             XCTAssertEqual(res.status, .badRequest)",
          "338:         }",
          "340:         headers.replaceOrAdd(name: .range, value: \"bytes=100-10\")",
          "341:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headers) { res in",
          "342:             XCTAssertEqual(res.status, .badRequest)",
          "343:         }",
          "345:         headers.replaceOrAdd(name: .range, value: \"bytes=10--100\")",
          "346:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headers) { res in",
          "347:             XCTAssertEqual(res.status, .badRequest)",
          "348:         }",
          "350:         headers.replaceOrAdd(name: .range, value: \"bytes=9223372036854775808-\")",
          "351:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headers) { res in",
          "352:             XCTAssertEqual(res.status, .badRequest)",
          "353:         }",
          "355:         headers.replaceOrAdd(name: .range, value: \"bytes=922337203-\")",
          "356:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headers) { res in",
          "357:             XCTAssertEqual(res.status, .badRequest)",
          "358:         }",
          "360:         headers.replaceOrAdd(name: .range, value: \"bytes=-922337203\")",
          "361:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headers) { res in",
          "362:             XCTAssertEqual(res.status, .badRequest)",
          "363:         }",
          "365:         headers.replaceOrAdd(name: .range, value: \"bytes=-9223372036854775808\")",
          "366:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headers) { res in",
          "367:             XCTAssertEqual(res.status, .badRequest)",
          "368:         }",
          "369:     }",
          "371:     func testAsyncFileRead() async throws {",
          "372:         let app = Application(.testing)",
          "373:         defer { app.shutdown() }",
          "375:         let request = Request(application: app, on: app.eventLoopGroup.next())",
          "377:         let path = \"/\" + #filePath.split(separator: \"/\").dropLast().joined(separator: \"/\") + \"/Utilities/long-test-file.txt\"",
          "379:         let content = try String(contentsOfFile: path)",
          "381:         var readContent = \"\"",
          "382:         let file = try await request.fileio.readFile(at: path, chunkSize: 16 * 1024) // 32Kb, ~5 chunks",
          "383:         for try await chunk in file {",
          "384:             readContent += String(buffer: chunk)",
          "385:         }",
          "387:         XCTAssertEqual(readContent, content, \"The content read from the file does not match the expected content.\")",
          "388:     }",
          "389: }",
          "",
          "---------------"
        ],
        "Tests/VaporTests/ContentTests.swift||Tests/VaporTests/ContentTests.swift": [
          "File: Tests/VaporTests/ContentTests.swift -> Tests/VaporTests/ContentTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "304:     func testMultipartEncode() throws {",
          "305:         struct User: Content {",
          "307:             var name: String",
          "308:             var age: Int",
          "309:             var image: File",
          "",
          "[Removed Lines]",
          "306:             static var defaultContentType: HTTPMediaType = .formData",
          "",
          "[Added Lines]",
          "306:             static let defaultContentType: HTTPMediaType = .formData",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "332:     func testMultiPartEncodeUnicode() throws {",
          "333:         struct User: Content {",
          "335:             var name: String",
          "336:             var age: Int",
          "337:             var image: File",
          "",
          "[Removed Lines]",
          "334:             static var defaultContentType: HTTPMediaType = .formData",
          "",
          "[Added Lines]",
          "334:             static let defaultContentType: HTTPMediaType = .formData",
          "",
          "---------------"
        ],
        "Tests/VaporTests/FileTests.swift||Tests/VaporTests/FileTests.swift": [
          "File: Tests/VaporTests/FileTests.swift -> Tests/VaporTests/FileTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "86:         }",
          "88:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\") { res in",
          "90:         }",
          "91:     }",
          "",
          "[Removed Lines]",
          "89:             XCTAssertTrue(res.body.string.isEmpty)",
          "",
          "[Added Lines]",
          "89:             XCTAssertEqual(res.status, .internalServerError)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "130:             let attributes = try FileManager.default.attributesOfItem(atPath: #file)",
          "131:             let modifiedAt = attributes[.modificationDate] as! Date",
          "132:             let fileSize = (attributes[.size] as? NSNumber)!.intValue",
          "135:             XCTAssertEqual(res.headers.first(name: .eTag), fileETag)",
          "136:         }",
          "",
          "[Removed Lines]",
          "133:             let fileETag = \"\\\"\\(modifiedAt.timeIntervalSince1970)-\\(fileSize)\\\"\"",
          "",
          "[Added Lines]",
          "133:             let fileETag = \"\\\"\\(Int(modifiedAt.timeIntervalSince1970))-\\(fileSize)\\\"\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "246:         var headers = HTTPHeaders()",
          "247:         headers.range = .init(unit: .bytes, ranges: [.within(start: 0, end: 0)])",
          "249:             XCTAssertEqual(res.status, .partialContent)",
          "251:             XCTAssertEqual(res.headers.first(name: .contentLength), \"1\")",
          "",
          "[Removed Lines]",
          "248:         try app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headers) { res in",
          "",
          "[Added Lines]",
          "248:         try await app.testable(method: .running(port: 0)).test(.GET, \"/file-stream\", headers: headers) { res async in",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "350:         XCTAssertEqual(result, data)",
          "351:     }",
          "354:         let app = Application(.testing)",
          "355:         defer { app.shutdown() }",
          "357:         let path = #filePath.split(separator: \"/\").dropLast().joined(separator: \"/\")",
          "358:         app.middleware.use(FileMiddleware(publicDirectory: \"/\" + path))",
          "361:             XCTAssertEqual(res.status, .ok)",
          "362:             XCTAssertEqual(res.body.string, \"<h1>Hello</h1>\\n\")",
          "363:         }",
          "364:     }",
          "367:         let app = Application(.testing)",
          "368:         defer { app.shutdown() }",
          "370:         let path = #filePath.split(separator: \"/\").dropLast().joined(separator: \"/\")",
          "371:         app.middleware.use(FileMiddleware(publicDirectory: \"/\" + path))",
          "374:             XCTAssertEqual(res.status, .forbidden)",
          "376:             XCTAssertEqual(res.status, .ok)",
          "377:             XCTAssertEqual(res.body.string, \"bar\\n\")",
          "378:         }",
          "379:     }",
          "382:         let app = Application(.testing)",
          "383:         defer { app.shutdown() }",
          "385:         let path = #filePath.split(separator: \"/\").dropLast().joined(separator: \"/\")",
          "386:         app.middleware.use(FileMiddleware(publicDirectory: \"/\" + path, defaultFile: \"index.html\"))",
          "389:             XCTAssertEqual(res.status, .ok)",
          "390:             XCTAssertEqual(res.body.string, \"<h1>Root Default</h1>\\n\")",
          "392:             XCTAssertEqual(res.status, .ok)",
          "393:             XCTAssertEqual(res.body.string, \"<h1>Subdirectory Default</h1>\\n\")",
          "394:         }",
          "395:     }",
          "398:         let app = Application(.testing)",
          "399:         defer { app.shutdown() }",
          "401:         let path = #filePath.split(separator: \"/\").dropLast().joined(separator: \"/\")",
          "402:         app.middleware.use(FileMiddleware(publicDirectory: \"/\" + path, defaultFile: \"/Utilities/index.html\"))",
          "405:             XCTAssertEqual(res.status, .ok)",
          "406:             XCTAssertEqual(res.body.string, \"<h1>Root Default</h1>\\n\")",
          "408:             XCTAssertEqual(res.status, .ok)",
          "409:             XCTAssertEqual(res.body.string, \"<h1>Root Default</h1>\\n\")",
          "410:         }",
          "",
          "[Removed Lines]",
          "353:     func testPercentDecodedFilePath() throws {",
          "360:         try app.test(.GET, \"/Utilities/foo%20bar.html\") { res in",
          "366:     func testPercentDecodedRelativePath() throws {",
          "373:         try app.test(.GET, \"%2e%2e/VaporTests/Utilities/foo.txt\") { res in",
          "375:         }.test(.GET, \"Utilities/foo.txt\") { res in",
          "381:     func testDefaultFileRelative() throws {",
          "388:         try app.test(.GET, \"Utilities/\") { res in",
          "391:         }.test(.GET, \"Utilities/SubUtilities/\") { res in",
          "397:     func testDefaultFileAbsolute() throws {",
          "404:         try app.test(.GET, \"Utilities/\") { res in",
          "407:         }.test(.GET, \"Utilities/SubUtilities/\") { res in",
          "",
          "[Added Lines]",
          "353:     func testPercentDecodedFilePath() async throws {",
          "360:         try await app.test(.GET, \"/Utilities/foo%20bar.html\") { res async in",
          "366:     func testPercentDecodedRelativePath() async throws {",
          "373:         try await app.test(.GET, \"%2e%2e/VaporTests/Utilities/foo.txt\") { res async in",
          "375:         }.test(.GET, \"Utilities/foo.txt\") { res async in",
          "381:     func testDefaultFileRelative() async throws {",
          "388:         try await app.test(.GET, \"Utilities/\") { res async in",
          "391:         }.test(.GET, \"Utilities/SubUtilities/\") { res async in",
          "397:     func testDefaultFileAbsolute() async throws {",
          "404:         try await app.test(.GET, \"Utilities/\") { res async in",
          "407:         }.test(.GET, \"Utilities/SubUtilities/\") { res async in",
          "",
          "---------------"
        ],
        "Tests/VaporTests/MiddlewareTests.swift||Tests/VaporTests/MiddlewareTests.swift": [
          "File: Tests/VaporTests/MiddlewareTests.swift -> Tests/VaporTests/MiddlewareTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "111:         }",
          "112:     }",
          "115:         var fileMiddleware: FileMiddleware!",
          "117:         XCTAssertNoThrow(fileMiddleware = try FileMiddleware(bundle: .module, publicDirectory: \"/\"), \"FileMiddleware instantiation from Bundle should not fail\")",
          "",
          "[Removed Lines]",
          "114:     func testFileMiddlewareFromBundle() throws {",
          "",
          "[Added Lines]",
          "114:     func testFileMiddlewareFromBundle() async throws {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "120:         defer { app.shutdown() }",
          "121:         app.middleware.use(fileMiddleware)",
          "124:             XCTAssertEqual(result.status, .ok)",
          "125:             XCTAssertEqual(result.body.string, \"bar\\n\")",
          "126:         }",
          "127:     }",
          "130:         var fileMiddleware: FileMiddleware!",
          "132:         XCTAssertNoThrow(fileMiddleware = try FileMiddleware(bundle: .module, publicDirectory: \"SubUtilities\"), \"FileMiddleware instantiation from Bundle should not fail\")",
          "",
          "[Removed Lines]",
          "123:         try app.testable().test(.GET, \"/foo.txt\") { result in",
          "129:     func testFileMiddlewareFromBundleSubfolder() throws {",
          "",
          "[Added Lines]",
          "123:         try await app.testable().test(.GET, \"/foo.txt\") { result in",
          "129:     func testFileMiddlewareFromBundleSubfolder() async throws {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "135:         defer { app.shutdown() }",
          "136:         app.middleware.use(fileMiddleware)",
          "139:             XCTAssertEqual(result.status, .ok)",
          "140:             XCTAssertEqual(result.body.string, \"<h1>Subdirectory Default</h1>\\n\")",
          "141:         }",
          "",
          "[Removed Lines]",
          "138:         try app.testable().test(.GET, \"/index.html\") { result in",
          "",
          "[Added Lines]",
          "138:         try await app.testable().test(.GET, \"/index.html\") { result in",
          "",
          "---------------"
        ],
        "Tests/VaporTests/PipelineTests.swift||Tests/VaporTests/PipelineTests.swift": [
          "File: Tests/VaporTests/PipelineTests.swift -> Tests/VaporTests/PipelineTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "224:             return ResponseThing(eventLoop: eventLoop)",
          "225:         }",
          "228:             XCTAssertEqual(res.status, .ok)",
          "229:         }",
          "",
          "[Removed Lines]",
          "227:         try app.test(.GET, \"dont-crash\") { res in",
          "",
          "[Added Lines]",
          "227:         try await app.test(.GET, \"dont-crash\") { res async in",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "254:             return \"OK\"",
          "255:         }",
          "258:             XCTAssertEqual(res.status, .ok)",
          "259:         }",
          "",
          "[Removed Lines]",
          "257:         try app.test(.GET, \"dont-crash\") { res in",
          "",
          "[Added Lines]",
          "257:         try await app.test(.GET, \"dont-crash\") { res async in",
          "",
          "---------------"
        ],
        "Tests/VaporTests/WebSocketTests.swift||Tests/VaporTests/WebSocketTests.swift": [
          "File: Tests/VaporTests/WebSocketTests.swift -> Tests/VaporTests/WebSocketTests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:             ws.close(promise: nil)",
          "57:         }",
          "59:         app.environment.arguments = [\"serve\"]",
          "61:         try app.start()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59:         app.http.server.configuration.port = 0",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "17c48719fe61bb92d8c5b522bfdfac6eba1d391b",
      "candidate_info": {
        "commit_hash": "17c48719fe61bb92d8c5b522bfdfac6eba1d391b",
        "repo": "vapor/vapor",
        "commit_url": "https://github.com/vapor/vapor/commit/17c48719fe61bb92d8c5b522bfdfac6eba1d391b",
        "files": [
          "Tests/VaporTests/URITests.swift"
        ],
        "message": "Fix for Apple changing things without warning.",
        "before_after_code_files": [
          "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift"
          ],
          "candidate": [
            "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift"
          ]
        }
      },
      "candidate_diff": {
        "Tests/VaporTests/URITests.swift||Tests/VaporTests/URITests.swift": [
          "File: Tests/VaporTests/URITests.swift -> Tests/VaporTests/URITests.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "215:         let zeros = String(repeating: \"0\", count: 65_512)",
          "216:         let untrustedInput = \"[https://vapor.codes.somewhere-else.test:](https://vapor.codes.somewhere-else.test/\\(zeros)443)[\\(zeros)](https://vapor.codes.somewhere-else.test/\\(zeros)443)[443](https://vapor.codes.somewhere-else.test/\\(zeros)443)\"",
          "219:     }",
          "221:     func testUrlParsingVectors() {",
          "",
          "[Removed Lines]",
          "218:         XCTAssertURIString(untrustedInput, hasHost: nil, hasPath: untrustedInput, hasEqualString: false)",
          "",
          "[Added Lines]",
          "218:         if #available(macOS 14, iOS 17, watchOS 10, tvOS 17, *) {",
          "219:             XCTAssertURIString(untrustedInput, hasHost: nil, hasPath: untrustedInput, hasEqualString: false)",
          "220:         } else {",
          "221:             XCTAssertURIString(untrustedInput, hasHost: nil, hasPath: \"/\", hasEqualString: false)",
          "222:         }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c21614670b459922737df75a6933094898802af6",
      "candidate_info": {
        "commit_hash": "c21614670b459922737df75a6933094898802af6",
        "repo": "vapor/vapor",
        "commit_url": "https://github.com/vapor/vapor/commit/c21614670b459922737df75a6933094898802af6",
        "files": [
          "Sources/Vapor/Commands/ServeCommand.swift",
          "Sources/Vapor/Content/JSONCoders+Content.swift",
          "Sources/Vapor/Utilities/RFC1123.swift",
          "Sources/Vapor/Utilities/URI.swift",
          "Sources/Vapor/Validation/Validators/CharacterSet.swift"
        ],
        "message": "Latest Swift 6 changes",
        "before_after_code_files": [
          "Sources/Vapor/Commands/ServeCommand.swift||Sources/Vapor/Commands/ServeCommand.swift",
          "Sources/Vapor/Content/JSONCoders+Content.swift||Sources/Vapor/Content/JSONCoders+Content.swift",
          "Sources/Vapor/Utilities/RFC1123.swift||Sources/Vapor/Utilities/RFC1123.swift",
          "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift",
          "Sources/Vapor/Validation/Validators/CharacterSet.swift||Sources/Vapor/Validation/Validators/CharacterSet.swift"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift"
          ],
          "candidate": [
            "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift"
          ]
        }
      },
      "candidate_diff": {
        "Sources/Vapor/Commands/ServeCommand.swift||Sources/Vapor/Commands/ServeCommand.swift": [
          "File: Sources/Vapor/Commands/ServeCommand.swift -> Sources/Vapor/Commands/ServeCommand.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: import ConsoleKit",
          "3: import NIOConcurrencyHelpers",
          "",
          "[Removed Lines]",
          "1: @preconcurrency import Foundation",
          "",
          "[Added Lines]",
          "1: #if os(Linux)",
          "2: @preconcurrency import Dispatch",
          "3: #endif",
          "4: import Foundation",
          "",
          "---------------"
        ],
        "Sources/Vapor/Content/JSONCoders+Content.swift||Sources/Vapor/Content/JSONCoders+Content.swift": [
          "File: Sources/Vapor/Content/JSONCoders+Content.swift -> Sources/Vapor/Content/JSONCoders+Content.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: import NIOCore",
          "3: import NIOHTTP1",
          "5: extension Foundation.JSONEncoder: @unchecked Swift.Sendable {}",
          "6: extension Foundation.JSONDecoder: @unchecked Swift.Sendable {}",
          "8: extension JSONEncoder: ContentEncoder {",
          "9:     public func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders) throws",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: #if compiler(<6.0)",
          "8: #endif",
          "",
          "---------------"
        ],
        "Sources/Vapor/Utilities/RFC1123.swift||Sources/Vapor/Utilities/RFC1123.swift": [
          "File: Sources/Vapor/Utilities/RFC1123.swift -> Sources/Vapor/Utilities/RFC1123.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: #if canImport(Darwin)",
          "3: @preconcurrency import Darwin",
          "4: #elseif canImport(Glibc)",
          "5: @preconcurrency import Glibc",
          "6: #elseif canImport(Musl)",
          "7: @preconcurrency import Musl",
          "8: #elseif canImport(WinSDK)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: #if compiler(>=6.0)",
          "6: import Glibc",
          "7: #else",
          "9: #endif",
          "",
          "---------------"
        ],
        "Sources/Vapor/Utilities/URI.swift||Sources/Vapor/Utilities/URI.swift": [
          "File: Sources/Vapor/Utilities/URI.swift -> Sources/Vapor/Utilities/URI.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: @preconcurrency import struct Foundation.URLComponents",
          "3: #else",
          "4: import struct Foundation.URLComponents",
          "",
          "[Removed Lines]",
          "1: #if !canImport(Darwin)",
          "",
          "[Added Lines]",
          "1: #if !canImport(Darwin) && compiler(<6.0)",
          "",
          "---------------"
        ],
        "Sources/Vapor/Validation/Validators/CharacterSet.swift||Sources/Vapor/Validation/Validators/CharacterSet.swift": [
          "File: Sources/Vapor/Validation/Validators/CharacterSet.swift -> Sources/Vapor/Validation/Validators/CharacterSet.swift",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: @preconcurrency import Foundation",
          "4: #else",
          "5: import Foundation",
          "",
          "[Removed Lines]",
          "1: #if os(Linux)",
          "",
          "[Added Lines]",
          "1: #if os(Linux) && compiler(<6.0)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
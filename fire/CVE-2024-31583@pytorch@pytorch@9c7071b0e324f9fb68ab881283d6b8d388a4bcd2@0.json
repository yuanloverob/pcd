{
  "cve_id": "CVE-2024-31583",
  "cve_desc": "Pytorch before version v2.2.0 was discovered to contain a use-after-free vulnerability in torch/csrc/jit/mobile/interpreter.cpp.",
  "repo": "pytorch/pytorch",
  "patch_hash": "9c7071b0e324f9fb68ab881283d6b8d388a4bcd2",
  "patch_info": {
    "commit_hash": "9c7071b0e324f9fb68ab881283d6b8d388a4bcd2",
    "repo": "pytorch/pytorch",
    "commit_url": "https://github.com/pytorch/pytorch/commit/9c7071b0e324f9fb68ab881283d6b8d388a4bcd2",
    "files": [
      "torch/csrc/jit/mobile/interpreter.cpp"
    ],
    "message": "[fuzzing result][fuzz_torch_jit_lite_interpreter] read-heap-use-after-free (size 8) in std::_Function_base::_M_empty() (#110289)\n\nSummary: This diff fixes a heap UAF found by fuzzing in torch/csrc/jit/mobile/interpreter.cpp\n\nTest Plan:\nCI and\n```\narc lionhead crash reproduce 1009060456885023\n```\ndoesn't crash anymore.\n\nReviewed By: malfet\n\nDifferential Revision: D49538326\n\nPull Request resolved: https://github.com/pytorch/pytorch/pull/110289\nApproved by: https://github.com/malfet",
    "before_after_code_files": [
      "torch/csrc/jit/mobile/interpreter.cpp||torch/csrc/jit/mobile/interpreter.cpp"
    ]
  },
  "patch_diff": {
    "torch/csrc/jit/mobile/interpreter.cpp||torch/csrc/jit/mobile/interpreter.cpp": [
      "File: torch/csrc/jit/mobile/interpreter.cpp -> torch/csrc/jit/mobile/interpreter.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "128:               mobile_debug_info->setOpIdx(pc);",
      "129:             }",
      "130:           }",
      "132:           RECORD_EDGE_SCOPE_WITH_DEBUG_HANDLE_AND_INPUTS(",
      "133:               code.op_names_[inst.X].name, debug_handle, stack);",
      "134:           code.operators_[inst.X](stack);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "131:           if (inst.X < 0 ||",
      "132:               static_cast<size_t>(inst.X) >= code.operators_.size()) {",
      "133:             throw JITException(\"Invalid OP Instruction\");",
      "134:           }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4fbf884f58e0a40666b8bd716f413801e2273058",
      "candidate_info": {
        "commit_hash": "4fbf884f58e0a40666b8bd716f413801e2273058",
        "repo": "pytorch/pytorch",
        "commit_url": "https://github.com/pytorch/pytorch/commit/4fbf884f58e0a40666b8bd716f413801e2273058",
        "files": [
          "torch/csrc/jit/mobile/interpreter.cpp"
        ],
        "message": "[fuzzing result][fuzz_torch_jit_lite_interpreter] read-heap-buffer-overflow-far-from-bounds (size 4) in c10::IValue::IValue() (#110453)\n\nSummary: This diff fixes an OOB read found by fuzzing in torch/../jit/mobile\n\nTest Plan:\nCI and\n```\narc lionhead crash reproduce 853835926354224\n```\ndoesn't crash anymore.\n\nDifferential Revision: D49537377\n\nPull Request resolved: https://github.com/pytorch/pytorch/pull/110453\nApproved by: https://github.com/davidberard98",
        "before_after_code_files": [
          "torch/csrc/jit/mobile/interpreter.cpp||torch/csrc/jit/mobile/interpreter.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "torch/csrc/jit/mobile/interpreter.cpp||torch/csrc/jit/mobile/interpreter.cpp"
          ],
          "candidate": [
            "torch/csrc/jit/mobile/interpreter.cpp||torch/csrc/jit/mobile/interpreter.cpp"
          ]
        }
      },
      "candidate_diff": {
        "torch/csrc/jit/mobile/interpreter.cpp||torch/csrc/jit/mobile/interpreter.cpp": [
          "File: torch/csrc/jit/mobile/interpreter.cpp -> torch/csrc/jit/mobile/interpreter.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "129:             }",
          "130:           }",
          "131:           if (inst.X < 0 ||",
          "132:               static_cast<size_t>(inst.X) >= code.operators_.size()) {",
          "134:           }",
          "135:           RECORD_EDGE_SCOPE_WITH_DEBUG_HANDLE_AND_INPUTS(",
          "136:               code.op_names_[inst.X].name, debug_handle, stack);",
          "",
          "[Removed Lines]",
          "133:             throw JITException(\"Invalid OP Instruction\");",
          "",
          "[Added Lines]",
          "132:               static_cast<size_t>(inst.X) >= code.op_names_.size() ||",
          "134:             TORCH_CHECK(false, \"Can't load op with index: \", inst.X);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "138:           frame.step();",
          "139:         } break;",
          "140:         case OPN: {",
          "141:           stack.emplace_back(inst.N);",
          "142:           RECORD_EDGE_SCOPE_WITH_DEBUG_HANDLE_AND_INPUTS(",
          "143:               code.op_names_[inst.X].name, debug_handle, stack);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "142:           if (inst.X < 0 ||",
          "143:               static_cast<size_t>(inst.X) >= code.op_names_.size() ||",
          "144:               static_cast<size_t>(inst.X) >= code.operators_.size()) {",
          "145:             TORCH_CHECK(false, \"Can't load op with index: \", inst.X);",
          "146:           }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "149:           callFunction(function, stack);",
          "150:         } break;",
          "151:         case INTERFACE_CALL: {",
          "152:           torch::jit::Function& method =",
          "153:               peek(stack, 0, inst.N)",
          "154:                   .toObject()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "158:           if (inst.X < 0 ||",
          "159:               static_cast<size_t>(inst.X) >= code.constants_.size()) {",
          "160:             TORCH_CHECK(false, \"Can't load constant with index: \", inst.X);",
          "161:           }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "185:           frame.step();",
          "186:           break;",
          "187:         case LOADC:",
          "188:           stack.emplace_back(code.constants_[inst.X]);",
          "189:           frame.step();",
          "190:           break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "198:           if (inst.X < 0 ||",
          "199:               static_cast<size_t>(inst.X) >= code.constants_.size()) {",
          "200:             TORCH_CHECK(false, \"Can't load constant with index: \", inst.X);",
          "201:           }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
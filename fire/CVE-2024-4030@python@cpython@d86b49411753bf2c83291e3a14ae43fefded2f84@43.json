{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
  "patch_info": {
    "commit_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/d86b49411753bf2c83291e3a14ae43fefded2f84",
    "files": [
      "Doc/whatsnew/3.13.rst",
      "Misc/NEWS.d/next/Security/2024-05-01-20-57-09.gh-issue-118486.K44KJG.rst"
    ],
    "message": "gh-118486: Update docs for CVE-2024-4030 reference (GH-118737)\n\nUpdate docs for CVE-2024-4030 reference",
    "before_after_code_files": []
  },
  "patch_diff": {},
  "candidates": [
    {
      "candidate_hash": "db64dae74517d094da5516b9c96d3e81e7108ebf",
      "candidate_info": {
        "commit_hash": "db64dae74517d094da5516b9c96d3e81e7108ebf",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/db64dae74517d094da5516b9c96d3e81e7108ebf",
        "files": [
          "Doc/c-api/frame.rst",
          "Doc/glossary.rst",
          "Doc/library/code.rst",
          "Doc/library/functions.rst",
          "Doc/library/pdb.rst",
          "Doc/library/profile.rst",
          "Doc/library/traceback.rst",
          "Doc/reference/datamodel.rst",
          "Doc/whatsnew/3.13.rst",
          "Lib/code.py",
          "Lib/pdb.py"
        ],
        "message": "[3.13] gh-74929: PEP 667 general docs update (gh-119291)\n\n* expand on What's New entry for PEP 667 (including porting notes)\n* define 'optimized scope' as a glossary term\n* cover comprehensions and generator expressions in locals() docs\n* review all mentions of \"locals\" in documentation (updating if needed)\n* review all mentions of \"f_locals\" in documentation (updating if needed)\n\n(cherry picked from commit e870c852c0ea96fa4e4569e9c39c7ceb80ce858d)\n\nCo-authored-by: Alyssa Coghlan <ncoghlan@gmail.com>",
        "before_after_code_files": [
          "Lib/code.py||Lib/code.py",
          "Lib/pdb.py||Lib/pdb.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/code.py||Lib/code.py": [
          "File: Lib/code.py -> Lib/code.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:     def __init__(self, locals=None):",
          "26:         \"\"\"Constructor.",
          "33:         \"\"\"",
          "34:         if locals is None:",
          "",
          "[Removed Lines]",
          "28:         The optional 'locals' argument specifies the dictionary in",
          "29:         which code will be executed; it defaults to a newly created",
          "30:         dictionary with key \"__name__\" set to \"__console__\" and key",
          "31:         \"__doc__\" set to None.",
          "",
          "[Added Lines]",
          "28:         The optional 'locals' argument specifies a mapping to use as the",
          "29:         namespace in which code will be executed; it defaults to a newly",
          "30:         created dictionary with key \"__name__\" set to \"__console__\" and",
          "31:         key \"__doc__\" set to None.",
          "",
          "---------------"
        ],
        "Lib/pdb.py||Lib/pdb.py": [
          "File: Lib/pdb.py -> Lib/pdb.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "392:             self.tb_lineno[tb.tb_frame] = lineno",
          "393:             tb = tb.tb_next",
          "394:         self.curframe = self.stack[self.curindex][0]",
          "398:         self.curframe_locals = self.curframe.f_locals",
          "399:         self.set_convenience_variable(self.curframe, '_frame', self.curframe)",
          "",
          "[Removed Lines]",
          "395:         # The f_locals dictionary is updated from the actual frame",
          "396:         # locals whenever the .f_locals accessor is called, so we",
          "397:         # cache it here to ensure that modifications are not overwritten.",
          "",
          "[Added Lines]",
          "395:         # The f_locals dictionary used to be updated from the actual frame",
          "396:         # locals whenever the .f_locals accessor was called, so it was",
          "397:         # cached here to ensure that modifications were not overwritten. While",
          "398:         # the caching is no longer required now that f_locals is a direct proxy",
          "399:         # on optimized frames, it's also harmless, so the code structure has",
          "400:         # been left unchanged.",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "56a7e0483436d1ebd2af97c02defe0e67c4bb495",
      "candidate_info": {
        "commit_hash": "56a7e0483436d1ebd2af97c02defe0e67c4bb495",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/56a7e0483436d1ebd2af97c02defe0e67c4bb495",
        "files": [
          "Doc/library/xml.etree.elementtree.rst",
          "Doc/whatsnew/3.12.rst",
          "Doc/whatsnew/3.13.rst",
          "Lib/test/test_xml_etree.py",
          "Lib/xml/etree/ElementTree.py",
          "Misc/NEWS.d/next/Library/2024-05-29-21-50-05.gh-issue-119577.S3BlKJ.rst",
          "Modules/_elementtree.c"
        ],
        "message": "[3.13] gh-119577: Adjust DeprecationWarning when testing element truth values in ElementTree (GH-119762) (GH-120189)\n\ngh-119577: Adjust DeprecationWarning when testing element truth values in ElementTree (GH-119762)\n\nAdjust DeprecationWarning when testing element truth values in ElementTree, we're planning to go with the more natural True return rather than a disruptive harder to code around exception raise, and are deferring the behavior change for a few more releases.\n(cherry picked from commit 6b606522ca97488aad6fe2f193d4511e7a8f8334)\n\nCo-authored-by: Jacob Walls <jacobtylerwalls@gmail.com>",
        "before_after_code_files": [
          "Lib/test/test_xml_etree.py||Lib/test/test_xml_etree.py",
          "Lib/xml/etree/ElementTree.py||Lib/xml/etree/ElementTree.py",
          "Modules/_elementtree.c||Modules/_elementtree.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_xml_etree.py||Lib/test/test_xml_etree.py": [
          "File: Lib/test/test_xml_etree.py -> Lib/test/test_xml_etree.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "4088:     def test_warning(self):",
          "4089:         e = ET.fromstring('<a style=\"new\"></a>')",
          "4090:         msg = (",
          "4092:             r\"future versions.  \"",
          "4093:             r\"Use specific 'len\\(elem\\)' or 'elem is not None' test instead.\")",
          "4094:         with self.assertWarnsRegex(DeprecationWarning, msg):",
          "",
          "[Removed Lines]",
          "4091:             r\"Testing an element's truth value will raise an exception in \"",
          "",
          "[Added Lines]",
          "4091:             r\"Testing an element's truth value will always return True in \"",
          "",
          "---------------"
        ],
        "Lib/xml/etree/ElementTree.py||Lib/xml/etree/ElementTree.py": [
          "File: Lib/xml/etree/ElementTree.py -> Lib/xml/etree/ElementTree.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "202:     def __bool__(self):",
          "203:         warnings.warn(",
          "205:             \"future versions.  \"",
          "206:             \"Use specific 'len(elem)' or 'elem is not None' test instead.\",",
          "207:             DeprecationWarning, stacklevel=2",
          "",
          "[Removed Lines]",
          "204:             \"Testing an element's truth value will raise an exception in \"",
          "",
          "[Added Lines]",
          "204:             \"Testing an element's truth value will always return True in \"",
          "",
          "---------------"
        ],
        "Modules/_elementtree.c||Modules/_elementtree.c": [
          "File: Modules/_elementtree.c -> Modules/_elementtree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1502: {",
          "1503:     ElementObject* self = (ElementObject*) self_;",
          "1504:     if (PyErr_WarnEx(PyExc_DeprecationWarning,",
          "1506:                      \"in future versions.  Use specific 'len(elem)' or \"",
          "1507:                      \"'elem is not None' test instead.\",",
          "1508:                      1) < 0) {",
          "",
          "[Removed Lines]",
          "1505:                      \"Testing an element's truth value will raise an exception \"",
          "",
          "[Added Lines]",
          "1505:                      \"Testing an element's truth value will always return True \"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d65e145f9d778efe28eb5154df1ab9d44e06673a",
      "candidate_info": {
        "commit_hash": "d65e145f9d778efe28eb5154df1ab9d44e06673a",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/d65e145f9d778efe28eb5154df1ab9d44e06673a",
        "files": [
          "Lib/test/pyclbr_input.py",
          "Lib/test/test_pyclbr.py"
        ],
        "message": "[3.13] gh-120449: fix ``test_pyclbr`` introspection for mangled names (GH-120450) (GH-120700)\n\ngh-120449: fix ``test_pyclbr`` introspection for mangled names (GH-120450)\n(cherry picked from commit d8cd0fa4e347f460d0f3277e2392504e61ed087d)\n\nCo-authored-by: B\u00e9n\u00e9dikt Tran <10796600+picnixz@users.noreply.github.com>",
        "before_after_code_files": [
          "Lib/test/pyclbr_input.py||Lib/test/pyclbr_input.py",
          "Lib/test/test_pyclbr.py||Lib/test/test_pyclbr.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/pyclbr_input.py||Lib/test/pyclbr_input.py": [
          "File: Lib/test/pyclbr_input.py -> Lib/test/pyclbr_input.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "12:     def bm(self): pass",
          "14: class C (B):",
          "18:     d = 10",
          "24:     #",
          "27:     def m(self): pass",
          "",
          "[Removed Lines]",
          "15:     foo = Other().foo",
          "16:     om = Other.om",
          "20:     # XXX: This causes test_pyclbr.py to fail, but only because the",
          "21:     #      introspection-based is_method() code in the test can't",
          "22:     #      distinguish between this and a genuine method function like m().",
          "23:     #      The pyclbr.py module gets this right as it parses the text.",
          "25:     #f = f",
          "",
          "[Added Lines]",
          "17:     # This one is correctly considered by both test_pyclbr.py and pyclbr.py",
          "18:     # as a non-method of C.",
          "19:     foo = Other().foo",
          "21:     # This causes test_pyclbr.py to fail, but only because the",
          "22:     # introspection-based is_method() code in the test can't",
          "23:     # distinguish between this and a genuine method function like m().",
          "25:     # The pyclbr.py module gets this right as it parses the text.",
          "26:     om = Other.om",
          "27:     f = f",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "32:     @classmethod",
          "33:     def cm(self): pass",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37: # Check that mangling is correctly handled",
          "39: class a:",
          "40:     def a(self): pass",
          "41:     def _(self): pass",
          "42:     def _a(self): pass",
          "43:     def __(self): pass",
          "44:     def ___(self): pass",
          "45:     def __a(self): pass",
          "47: class _:",
          "48:     def a(self): pass",
          "49:     def _(self): pass",
          "50:     def _a(self): pass",
          "51:     def __(self): pass",
          "52:     def ___(self): pass",
          "53:     def __a(self): pass",
          "55: class __:",
          "56:     def a(self): pass",
          "57:     def _(self): pass",
          "58:     def _a(self): pass",
          "59:     def __(self): pass",
          "60:     def ___(self): pass",
          "61:     def __a(self): pass",
          "63: class ___:",
          "64:     def a(self): pass",
          "65:     def _(self): pass",
          "66:     def _a(self): pass",
          "67:     def __(self): pass",
          "68:     def ___(self): pass",
          "69:     def __a(self): pass",
          "71: class _a:",
          "72:     def a(self): pass",
          "73:     def _(self): pass",
          "74:     def _a(self): pass",
          "75:     def __(self): pass",
          "76:     def ___(self): pass",
          "77:     def __a(self): pass",
          "79: class __a:",
          "80:     def a(self): pass",
          "81:     def _(self): pass",
          "82:     def _a(self): pass",
          "83:     def __(self): pass",
          "84:     def ___(self): pass",
          "85:     def __a(self): pass",
          "",
          "---------------"
        ],
        "Lib/test/test_pyclbr.py||Lib/test/test_pyclbr.py": [
          "File: Lib/test/test_pyclbr.py -> Lib/test/test_pyclbr.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "79:             objname = obj.__name__",
          "80:             if objname.startswith(\"__\") and not objname.endswith(\"__\"):",
          "82:             return objname == name",
          "84:         # Make sure the toplevel functions and classes are the same.",
          "",
          "[Removed Lines]",
          "81:                 objname = \"_%s%s\" % (oclass.__name__, objname)",
          "",
          "[Added Lines]",
          "81:                 if stripped_typename := oclass.__name__.lstrip('_'):",
          "82:                     objname = f\"_{stripped_typename}{objname}\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "111:                 for m in py_item.__dict__.keys():",
          "112:                     if ismethod(py_item, getattr(py_item, m), m):",
          "113:                         actualMethods.append(m)",
          "121:                 try:",
          "122:                     self.assertListEq(foundMethods, actualMethods, ignore)",
          "",
          "[Removed Lines]",
          "114:                 foundMethods = []",
          "115:                 for m in value.methods.keys():",
          "116:                     if m[:2] == '__' and m[-2:] != '__':",
          "117:                         foundMethods.append('_'+name+m)",
          "118:                     else:",
          "119:                         foundMethods.append(m)",
          "",
          "[Added Lines]",
          "116:                 if stripped_typename := name.lstrip('_'):",
          "117:                     foundMethods = []",
          "118:                     for m in value.methods.keys():",
          "119:                         if m.startswith('__') and not m.endswith('__'):",
          "120:                             foundMethods.append(f\"_{stripped_typename}{m}\")",
          "121:                         else:",
          "122:                             foundMethods.append(m)",
          "123:                 else:",
          "124:                     foundMethods = list(value.methods.keys())",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "150:                                             \"DocTestCase\", '_DocTestSuite'))",
          "151:         self.checkModule('difflib', ignore=(\"Match\",))",
          "156:     def test_nested(self):",
          "157:         mb = pyclbr",
          "",
          "[Removed Lines]",
          "153:     def test_decorators(self):",
          "154:         self.checkModule('test.pyclbr_input', ignore=['om'])",
          "",
          "[Added Lines]",
          "158:     def test_cases(self):",
          "159:         # see test.pyclbr_input for the rationale behind the ignored symbols",
          "160:         self.checkModule('test.pyclbr_input', ignore=['om', 'f'])",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "62a559ac09b0451631a07d1aae76eab79af9cbbc",
      "candidate_info": {
        "commit_hash": "62a559ac09b0451631a07d1aae76eab79af9cbbc",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/62a559ac09b0451631a07d1aae76eab79af9cbbc",
        "files": [
          "Modules/_multiprocessing/clinic/semaphore.c.h",
          "Modules/_multiprocessing/semaphore.c"
        ],
        "message": "[3.13] gh-117657: Acquire a critical section around `SemLock.__{enter,exit}__` (GH-118812) (#118856)\n\nThese methods are purely wrappers around `Semlock.{acquire,release}`,\nwhich expect a critical section to be held.\n(cherry picked from commit c30d8e5d6c6b657817d6b342f1021676d04dd5af)\n\nCo-authored-by: mpage <mpage@meta.com>",
        "before_after_code_files": [
          "Modules/_multiprocessing/clinic/semaphore.c.h||Modules/_multiprocessing/clinic/semaphore.c.h",
          "Modules/_multiprocessing/semaphore.c||Modules/_multiprocessing/semaphore.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Modules/_multiprocessing/clinic/semaphore.c.h||Modules/_multiprocessing/clinic/semaphore.c.h": [
          "File: Modules/_multiprocessing/clinic/semaphore.c.h -> Modules/_multiprocessing/clinic/semaphore.c.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "473: static PyObject *",
          "474: _multiprocessing_SemLock___enter__(SemLockObject *self, PyObject *Py_UNUSED(ignored))",
          "475: {",
          "477: }",
          "",
          "[Removed Lines]",
          "476:     return _multiprocessing_SemLock___enter___impl(self);",
          "",
          "[Added Lines]",
          "476:     PyObject *return_value = NULL;",
          "478:     Py_BEGIN_CRITICAL_SECTION(self);",
          "479:     return_value = _multiprocessing_SemLock___enter___impl(self);",
          "480:     Py_END_CRITICAL_SECTION();",
          "482:     return return_value;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "518:     }",
          "519:     exc_tb = args[2];",
          "520: skip_optional:",
          "521:     return_value = _multiprocessing_SemLock___exit___impl(self, exc_type, exc_value, exc_tb);",
          "523: exit:",
          "524:     return return_value;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "527:     Py_BEGIN_CRITICAL_SECTION(self);",
          "529:     Py_END_CRITICAL_SECTION();",
          "",
          "---------------"
        ],
        "Modules/_multiprocessing/semaphore.c||Modules/_multiprocessing/semaphore.c": [
          "File: Modules/_multiprocessing/semaphore.c -> Modules/_multiprocessing/semaphore.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "682: }",
          "685: _multiprocessing.SemLock.__enter__",
          "687: Enter the semaphore/lock.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "685: @critical_section",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "690: static PyObject *",
          "691: _multiprocessing_SemLock___enter___impl(SemLockObject *self)",
          "693: {",
          "694:     return _multiprocessing_SemLock_acquire_impl(self, 1, Py_None);",
          "695: }",
          "698: _multiprocessing.SemLock.__exit__",
          "700:     exc_type: object = None",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "699: @critical_section",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1dc7fcd8039ec09a49002827eb7f55b02741d927",
      "candidate_info": {
        "commit_hash": "1dc7fcd8039ec09a49002827eb7f55b02741d927",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/1dc7fcd8039ec09a49002827eb7f55b02741d927",
        "files": [
          "Lib/test/_test_multiprocessing.py",
          "Lib/test/test_asyncio/test_unix_events.py",
          "Lib/test/test_compileall.py",
          "Lib/test/test_configparser.py",
          "Lib/test/test_ctypes/test_loading.py",
          "Lib/test/test_fileinput.py",
          "Lib/test/test_http_cookiejar.py",
          "Lib/test/test_logging.py",
          "Lib/test/test_mimetypes.py",
          "Lib/test/test_pkgutil.py",
          "Lib/test/test_runpy.py",
          "Lib/test/test_shutil.py",
          "Lib/test/test_subprocess.py",
          "Lib/test/test_tarfile.py",
          "Lib/test/test_tempfile.py",
          "Lib/test/test_venv.py",
          "Lib/test/test_winsound.py",
          "Lib/test/test_zipapp.py",
          "Lib/test/test_zipfile/_path/test_path.py"
        ],
        "message": "[3.13] gh-119064: Use os_helper.FakePath instead of pathlib.Path in tests (GH-119065) (GH-119087)\n\n(cherry picked from commit 0152dc4ff5534fa2948b95262e70ff6b202b9b99)\n\nCo-authored-by: Serhiy Storchaka <storchaka@gmail.com>",
        "before_after_code_files": [
          "Lib/test/_test_multiprocessing.py||Lib/test/_test_multiprocessing.py",
          "Lib/test/test_asyncio/test_unix_events.py||Lib/test/test_asyncio/test_unix_events.py",
          "Lib/test/test_compileall.py||Lib/test/test_compileall.py",
          "Lib/test/test_configparser.py||Lib/test/test_configparser.py",
          "Lib/test/test_ctypes/test_loading.py||Lib/test/test_ctypes/test_loading.py",
          "Lib/test/test_fileinput.py||Lib/test/test_fileinput.py",
          "Lib/test/test_http_cookiejar.py||Lib/test/test_http_cookiejar.py",
          "Lib/test/test_logging.py||Lib/test/test_logging.py",
          "Lib/test/test_mimetypes.py||Lib/test/test_mimetypes.py",
          "Lib/test/test_pkgutil.py||Lib/test/test_pkgutil.py",
          "Lib/test/test_runpy.py||Lib/test/test_runpy.py",
          "Lib/test/test_shutil.py||Lib/test/test_shutil.py",
          "Lib/test/test_subprocess.py||Lib/test/test_subprocess.py",
          "Lib/test/test_tarfile.py||Lib/test/test_tarfile.py",
          "Lib/test/test_tempfile.py||Lib/test/test_tempfile.py",
          "Lib/test/test_venv.py||Lib/test/test_venv.py",
          "Lib/test/test_winsound.py||Lib/test/test_winsound.py",
          "Lib/test/test_zipapp.py||Lib/test/test_zipapp.py",
          "Lib/test/test_zipfile/_path/test_path.py||Lib/test/test_zipfile/_path/test_path.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/_test_multiprocessing.py||Lib/test/_test_multiprocessing.py": [
          "File: Lib/test/_test_multiprocessing.py -> Lib/test/_test_multiprocessing.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: import subprocess",
          "23: import struct",
          "24: import operator",
          "26: import pickle",
          "27: import weakref",
          "28: import warnings",
          "",
          "[Removed Lines]",
          "25: import pathlib",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "324:             self.skipTest(f'test not appropriate for {self.TYPE}')",
          "325:         paths = [",
          "326:             sys.executable,               # str",
          "329:         ]",
          "330:         for path in paths:",
          "331:             self.set_executable(path)",
          "",
          "[Removed Lines]",
          "327:             sys.executable.encode(),      # bytes",
          "328:             pathlib.Path(sys.executable)  # os.PathLike",
          "",
          "[Added Lines]",
          "326:             os.fsencode(sys.executable),  # bytes",
          "327:             os_helper.FakePath(sys.executable),  # os.PathLike",
          "328:             os_helper.FakePath(os.fsencode(sys.executable)),  # os.PathLike bytes",
          "",
          "---------------"
        ],
        "Lib/test/test_asyncio/test_unix_events.py||Lib/test/test_asyncio/test_unix_events.py": [
          "File: Lib/test/test_asyncio/test_unix_events.py -> Lib/test/test_asyncio/test_unix_events.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: import multiprocessing",
          "7: from multiprocessing.util import _cleanup_tests as multiprocessing_cleanup_tests",
          "8: import os",
          "10: import signal",
          "11: import socket",
          "12: import stat",
          "",
          "[Removed Lines]",
          "9: import pathlib",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "304:             self.loop.run_until_complete(srv.wait_closed())",
          "306:     @socket_helper.skip_unless_bind_unix_socket",
          "308:         with test_utils.unix_socket_path() as path:",
          "310:             srv_coro = self.loop.create_unix_server(lambda: None, path)",
          "311:             srv = self.loop.run_until_complete(srv_coro)",
          "312:             srv.close()",
          "313:             self.loop.run_until_complete(srv.wait_closed())",
          "316:         with test_utils.unix_socket_path() as path:",
          "318:             coro = self.loop.create_unix_connection(lambda: None, path)",
          "319:             with self.assertRaises(FileNotFoundError):",
          "321:                 # different.",
          "322:                 self.loop.run_until_complete(coro)",
          "",
          "[Removed Lines]",
          "307:     def test_create_unix_server_pathlib(self):",
          "309:             path = pathlib.Path(path)",
          "315:     def test_create_unix_connection_pathlib(self):",
          "317:             path = pathlib.Path(path)",
          "320:                 # If pathlib.Path wasn't supported, the exception would be",
          "",
          "[Added Lines]",
          "306:     def test_create_unix_server_pathlike(self):",
          "308:             path = os_helper.FakePath(path)",
          "314:     def test_create_unix_connection_pathlike(self):",
          "316:             path = os_helper.FakePath(path)",
          "319:                 # If path-like object weren't supported, the exception would be",
          "",
          "---------------"
        ],
        "Lib/test/test_compileall.py||Lib/test/test_compileall.py": [
          "File: Lib/test/test_compileall.py -> Lib/test/test_compileall.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: import importlib.util",
          "5: import io",
          "6: import os",
          "8: import py_compile",
          "9: import shutil",
          "10: import struct",
          "",
          "[Removed Lines]",
          "7: import pathlib",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "31: from test.support import script_helper",
          "32: from test.test_py_compile import without_source_date_epoch",
          "33: from test.test_py_compile import SourceDateEpochTestMeta",
          "36: def get_pyc(script, opt):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: from test.support.os_helper import FakePath",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "156:         self.assertFalse(os.path.isfile(self.bc_path))",
          "157:         # we should also test the output",
          "158:         with support.captured_stdout() as stdout:",
          "160:         self.assertRegex(stdout.getvalue(), r'Compiling ([^WindowsPath|PosixPath].*)')",
          "161:         self.assertTrue(os.path.isfile(self.bc_path))",
          "163:     def test_compile_file_pathlike_ddir(self):",
          "164:         self.assertFalse(os.path.isfile(self.bc_path))",
          "167:                                                 quiet=2))",
          "168:         self.assertTrue(os.path.isfile(self.bc_path))",
          "170:     def test_compile_file_pathlike_stripdir(self):",
          "171:         self.assertFalse(os.path.isfile(self.bc_path))",
          "174:                                                 quiet=2))",
          "175:         self.assertTrue(os.path.isfile(self.bc_path))",
          "177:     def test_compile_file_pathlike_prependdir(self):",
          "178:         self.assertFalse(os.path.isfile(self.bc_path))",
          "181:                                                 quiet=2))",
          "182:         self.assertTrue(os.path.isfile(self.bc_path))",
          "",
          "[Removed Lines]",
          "159:             self.assertTrue(compileall.compile_file(pathlib.Path(self.source_path)))",
          "165:         self.assertTrue(compileall.compile_file(pathlib.Path(self.source_path),",
          "166:                                                 ddir=pathlib.Path('ddir_path'),",
          "172:         self.assertTrue(compileall.compile_file(pathlib.Path(self.source_path),",
          "173:                                                 stripdir=pathlib.Path('stripdir_path'),",
          "179:         self.assertTrue(compileall.compile_file(pathlib.Path(self.source_path),",
          "180:                                                 prependdir=pathlib.Path('prependdir_path'),",
          "",
          "[Added Lines]",
          "159:             self.assertTrue(compileall.compile_file(FakePath(self.source_path)))",
          "165:         self.assertTrue(compileall.compile_file(FakePath(self.source_path),",
          "166:                                                 ddir=FakePath('ddir_path'),",
          "172:         self.assertTrue(compileall.compile_file(FakePath(self.source_path),",
          "173:                                                 stripdir=FakePath('stripdir_path'),",
          "179:         self.assertTrue(compileall.compile_file(FakePath(self.source_path),",
          "180:                                                 prependdir=FakePath('prependdir_path'),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "228:     def test_compile_dir_pathlike(self):",
          "229:         self.assertFalse(os.path.isfile(self.bc_path))",
          "230:         with support.captured_stdout() as stdout:",
          "232:         line = stdout.getvalue().splitlines()[0]",
          "233:         self.assertRegex(line, r'Listing ([^WindowsPath|PosixPath].*)')",
          "234:         self.assertTrue(os.path.isfile(self.bc_path))",
          "236:     def test_compile_dir_pathlike_stripdir(self):",
          "237:         self.assertFalse(os.path.isfile(self.bc_path))",
          "240:                                                quiet=2))",
          "241:         self.assertTrue(os.path.isfile(self.bc_path))",
          "243:     def test_compile_dir_pathlike_prependdir(self):",
          "244:         self.assertFalse(os.path.isfile(self.bc_path))",
          "247:                                                quiet=2))",
          "248:         self.assertTrue(os.path.isfile(self.bc_path))",
          "",
          "[Removed Lines]",
          "231:             compileall.compile_dir(pathlib.Path(self.directory))",
          "238:         self.assertTrue(compileall.compile_dir(pathlib.Path(self.directory),",
          "239:                                                stripdir=pathlib.Path('stripdir_path'),",
          "245:         self.assertTrue(compileall.compile_dir(pathlib.Path(self.directory),",
          "246:                                                prependdir=pathlib.Path('prependdir_path'),",
          "",
          "[Added Lines]",
          "231:             compileall.compile_dir(FakePath(self.directory))",
          "238:         self.assertTrue(compileall.compile_dir(FakePath(self.directory),",
          "239:                                                stripdir=FakePath('stripdir_path'),",
          "245:         self.assertTrue(compileall.compile_dir(FakePath(self.directory),",
          "246:                                                prependdir=FakePath('prependdir_path'),",
          "",
          "---------------"
        ],
        "Lib/test/test_configparser.py||Lib/test/test_configparser.py": [
          "File: Lib/test/test_configparser.py -> Lib/test/test_configparser.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: import configparser",
          "3: import io",
          "4: import os",
          "6: import textwrap",
          "7: import unittest",
          "",
          "[Removed Lines]",
          "5: import pathlib",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "745:         self.assertEqual(cf.get(\"Foo Bar\", \"foo\"), \"newbar\")",
          "746:         # check when we pass only a Path object:",
          "747:         cf = self.newconfig()",
          "749:         self.assertEqual(parsed_files, [file1])",
          "750:         self.assertEqual(cf.get(\"Foo Bar\", \"foo\"), \"newbar\")",
          "751:         # check when we passed both a filename and a Path object:",
          "752:         cf = self.newconfig()",
          "754:         self.assertEqual(parsed_files, [file1, file1])",
          "755:         self.assertEqual(cf.get(\"Foo Bar\", \"foo\"), \"newbar\")",
          "756:         # check when we pass only missing files:",
          "",
          "[Removed Lines]",
          "748:         parsed_files = cf.read(pathlib.Path(file1), encoding=\"utf-8\")",
          "753:         parsed_files = cf.read([pathlib.Path(file1), file1], encoding=\"utf-8\")",
          "",
          "[Added Lines]",
          "747:         parsed_files = cf.read(os_helper.FakePath(file1), encoding=\"utf-8\")",
          "752:         parsed_files = cf.read([os_helper.FakePath(file1), file1], encoding=\"utf-8\")",
          "",
          "---------------"
        ],
        "Lib/test/test_ctypes/test_loading.py||Lib/test/test_ctypes/test_loading.py": [
          "File: Lib/test/test_ctypes/test_loading.py -> Lib/test/test_ctypes/test_loading.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:                 self.skipTest('could not find library to load')",
          "43:         CDLL(test_lib)",
          "44:         CDLL(os.path.basename(test_lib))",
          "49:         self.assertRaises(OSError, CDLL, self.unknowndll)",
          "51:     def test_load_version(self):",
          "",
          "[Removed Lines]",
          "45:         class CTypesTestPathLikeCls:",
          "46:             def __fspath__(self):",
          "47:                 return test_lib",
          "48:         CDLL(CTypesTestPathLikeCls())",
          "",
          "[Added Lines]",
          "45:         CDLL(os_helper.FakePath(test_lib))",
          "",
          "---------------"
        ],
        "Lib/test/test_fileinput.py||Lib/test/test_fileinput.py": [
          "File: Lib/test/test_fileinput.py -> Lib/test/test_fileinput.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: from io import BytesIO, StringIO",
          "25: from fileinput import FileInput, hook_encoded",
          "28: from test.support import verbose",
          "30: from test.support.os_helper import unlink as safe_unlink",
          "31: from test.support import os_helper",
          "32: from test import support",
          "",
          "[Removed Lines]",
          "26: from pathlib import Path",
          "29: from test.support.os_helper import TESTFN",
          "",
          "[Added Lines]",
          "28: from test.support.os_helper import TESTFN, FakePath",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "478:             self.assertRaises(StopIteration, next, fi)",
          "479:             self.assertEqual(src.linesread, [])",
          "483:         with FileInput(t1, encoding=\"utf-8\") as fi:",
          "484:             line = fi.readline()",
          "486:             self.assertEqual(fi.lineno(), 1)",
          "487:             self.assertEqual(fi.filelineno(), 1)",
          "488:             self.assertEqual(fi.filename(), os.fspath(t1))",
          "492:         with FileInput(t1, inplace=True, encoding=\"utf-8\") as fi:",
          "493:             line = fi.readline()",
          "495:             print('Modified %s' % line)",
          "496:         with open(t1, encoding=\"utf-8\") as f:",
          "500: class MockFileInput:",
          "",
          "[Removed Lines]",
          "481:     def test_pathlib_file(self):",
          "482:         t1 = Path(self.writeTmp(\"Pathlib file.\"))",
          "485:             self.assertEqual(line, 'Pathlib file.')",
          "490:     def test_pathlib_file_inplace(self):",
          "491:         t1 = Path(self.writeTmp('Pathlib file.'))",
          "494:             self.assertEqual(line, 'Pathlib file.')",
          "497:             self.assertEqual(f.read(), 'Modified Pathlib file.\\n')",
          "",
          "[Added Lines]",
          "480:     def test_pathlike_file(self):",
          "481:         t1 = FakePath(self.writeTmp(\"Path-like file.\"))",
          "484:             self.assertEqual(line, 'Path-like file.')",
          "489:     def test_pathlike_file_inplace(self):",
          "490:         t1 = FakePath(self.writeTmp('Path-like file.'))",
          "493:             self.assertEqual(line, 'Path-like file.')",
          "496:             self.assertEqual(f.read(), 'Modified Path-like file.\\n')",
          "",
          "---------------"
        ],
        "Lib/test/test_http_cookiejar.py||Lib/test/test_http_cookiejar.py": [
          "File: Lib/test/test_http_cookiejar.py -> Lib/test/test_http_cookiejar.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: import time",
          "10: import unittest",
          "11: import urllib.request",
          "14: from http.cookiejar import (time2isoz, http2time, iso2time, time2netscape,",
          "15:      parse_ns_headers, join_header_words, split_header_words, Cookie,",
          "",
          "[Removed Lines]",
          "12: import pathlib",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "337:         self.assertEqual(c.filename, filename)",
          "339:     def test_constructor_with_path_like(self):",
          "344:     def test_constructor_with_none(self):",
          "345:         c = LWPCookieJar(None)",
          "",
          "[Removed Lines]",
          "340:         filename = pathlib.Path(os_helper.TESTFN)",
          "341:         c = LWPCookieJar(filename)",
          "342:         self.assertEqual(c.filename, os.fspath(filename))",
          "",
          "[Added Lines]",
          "339:         filename = os_helper.TESTFN",
          "340:         c = LWPCookieJar(os_helper.FakePath(filename))",
          "341:         self.assertEqual(c.filename, filename)",
          "",
          "---------------"
        ],
        "Lib/test/test_logging.py||Lib/test/test_logging.py": [
          "File: Lib/test/test_logging.py -> Lib/test/test_logging.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "657:         self.assertFalse(h.shouldFlush(r))",
          "658:         h.close()",
          "661:         \"\"\"",
          "664:         See Issue #27493.",
          "665:         \"\"\"",
          "666:         fn = make_temp_file()",
          "667:         os.unlink(fn)",
          "669:         cases = (",
          "670:                     (logging.FileHandler, (pfn, 'w')),",
          "671:                     (logging.handlers.RotatingFileHandler, (pfn, 'a')),",
          "",
          "[Removed Lines]",
          "660:     def test_path_objects(self):",
          "662:         Test that Path objects are accepted as filename arguments to handlers.",
          "668:         pfn = pathlib.Path(fn)",
          "",
          "[Added Lines]",
          "660:     def test_pathlike_objects(self):",
          "662:         Test that path-like objects are accepted as filename arguments to handlers.",
          "668:         pfn = os_helper.FakePath(fn)",
          "",
          "---------------"
        ],
        "Lib/test/test_mimetypes.py||Lib/test/test_mimetypes.py": [
          "File: Lib/test/test_mimetypes.py -> Lib/test/test_mimetypes.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import io",
          "2: import mimetypes",
          "3: import os",
          "5: import sys",
          "6: import unittest.mock",
          "",
          "[Removed Lines]",
          "4: import pathlib",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "84:         with os_helper.temp_dir() as directory:",
          "85:             data = \"x-application/x-unittest pyunit\\n\"",
          "88:             mime_dict = mimetypes.read_mime_types(file)",
          "89:             eq(mime_dict[\".pyunit\"], \"x-application/x-unittest\")",
          "91:         # bpo-41048: read_mime_types should read the rule file with 'utf-8' encoding.",
          "92:         # Not with locale encoding. _bootlocale has been imported because io.open(...)",
          "93:         # uses it.",
          "",
          "[Removed Lines]",
          "86:             file = pathlib.Path(directory, \"sample.mimetype\")",
          "87:             file.write_text(data, encoding=\"utf-8\")",
          "",
          "[Added Lines]",
          "85:             file = os.path.join(directory, \"sample.mimetype\")",
          "86:             with open(file, 'w', encoding=\"utf-8\") as f:",
          "87:                 f.write(data)",
          "91:             data = \"x-application/x-unittest2 pyunit2\\n\"",
          "92:             file = os.path.join(directory, \"sample2.mimetype\")",
          "93:             with open(file, 'w', encoding=\"utf-8\") as f:",
          "94:                 f.write(data)",
          "95:             mime_dict = mimetypes.read_mime_types(os_helper.FakePath(file))",
          "96:             eq(mime_dict[\".pyunit2\"], \"x-application/x-unittest2\")",
          "",
          "---------------"
        ],
        "Lib/test/test_pkgutil.py||Lib/test/test_pkgutil.py": [
          "File: Lib/test/test_pkgutil.py -> Lib/test/test_pkgutil.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: import zipfile",
          "15: from test.support.import_helper import DirsOnSysPath",
          "16: from test.test_importlib.util import uncache",
          "18: # Note: pkgutil.walk_packages is currently tested in test_runpy. This is",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: from test.support.os_helper import FakePath",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "122:             # make sure iter_modules accepts Path objects",
          "123:             names = []",
          "125:                 self.assertIsInstance(moduleinfo, pkgutil.ModuleInfo)",
          "126:                 names.append(moduleinfo.name)",
          "127:             self.assertEqual(names, [pkg])",
          "",
          "[Removed Lines]",
          "124:             for moduleinfo in pkgutil.iter_modules([Path(zip_file)]):",
          "",
          "[Added Lines]",
          "125:             for moduleinfo in pkgutil.iter_modules([FakePath(zip_file)]):",
          "",
          "---------------"
        ],
        "Lib/test/test_runpy.py||Lib/test/test_runpy.py": [
          "File: Lib/test/test_runpy.py -> Lib/test/test_runpy.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: from test.support import (infinite_recursion, no_tracing, verbose,",
          "16:                           requires_subprocess, requires_resource)",
          "17: from test.support.import_helper import forget, make_legacy_pyc, unload",
          "19: from test.support.script_helper import make_script, make_zip_script",
          "",
          "[Removed Lines]",
          "18: from test.support.os_helper import create_empty_file, temp_dir",
          "",
          "[Added Lines]",
          "18: from test.support.os_helper import create_empty_file, temp_dir, FakePath",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "657:             self._check_script(script_name, \"<run_path>\", script_name,",
          "658:                                script_name, expect_spec=False)",
          "661:         with temp_dir() as script_dir:",
          "662:             mod_name = 'script'",
          "668:                                expect_spec=False)",
          "670:     def test_basic_script_no_suffix(self):",
          "",
          "[Removed Lines]",
          "660:     def test_basic_script_with_path_object(self):",
          "663:             script_name = pathlib.Path(self._make_test_script(script_dir,",
          "664:                                                               mod_name))",
          "665:             self._check_script(script_name, \"<run_path>\",",
          "666:                                os.fsdecode(script_name),",
          "667:                                os.fsdecode(script_name),",
          "",
          "[Added Lines]",
          "660:     def test_basic_script_with_pathlike_object(self):",
          "663:             script_name = self._make_test_script(script_dir, mod_name)",
          "664:             self._check_script(FakePath(script_name), \"<run_path>\",",
          "665:                                script_name,",
          "666:                                script_name,",
          "",
          "---------------"
        ],
        "Lib/test/test_shutil.py||Lib/test/test_shutil.py": [
          "File: Lib/test/test_shutil.py -> Lib/test/test_shutil.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "914:                                     'test.txt')))",
          "916:         dst_dir = join(self.mkdtemp(), 'destination')",
          "918:         self.assertTrue(exists(join(dst_dir, 'test_dir', 'subdir',",
          "919:                                     'test.txt')))",
          "",
          "[Removed Lines]",
          "917:         shutil.copytree(pathlib.Path(src_dir), dst_dir, ignore=_ignore)",
          "",
          "[Added Lines]",
          "917:         shutil.copytree(FakePath(src_dir), dst_dir, ignore=_ignore)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2107:         self.check_unpack_archive_with_converter(",
          "2108:             format, lambda path: path, **kwargs)",
          "2109:         self.check_unpack_archive_with_converter(",
          "2111:         self.check_unpack_archive_with_converter(format, FakePath, **kwargs)",
          "2113:     def check_unpack_archive_with_converter(self, format, converter, **kwargs):",
          "",
          "[Removed Lines]",
          "2110:             format, pathlib.Path, **kwargs)",
          "",
          "[Added Lines]",
          "2110:             format, FakePath, **kwargs)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2673:     def test_move_file_to_dir_pathlike_src(self):",
          "2674:         # Move a pathlike file to another location on the same filesystem.",
          "2676:         self._check_move_file(src, self.dst_dir, self.dst_file)",
          "2678:     def test_move_file_to_dir_pathlike_dst(self):",
          "2679:         # Move a file to another pathlike location on the same filesystem.",
          "2681:         self._check_move_file(self.src_file, dst, self.dst_file)",
          "2683:     @mock_rename",
          "",
          "[Removed Lines]",
          "2675:         src = pathlib.Path(self.src_file)",
          "2680:         dst = pathlib.Path(self.dst_dir)",
          "",
          "[Added Lines]",
          "2675:         src = FakePath(self.src_file)",
          "2680:         dst = FakePath(self.dst_dir)",
          "",
          "---------------"
        ],
        "Lib/test/test_subprocess.py||Lib/test/test_subprocess.py": [
          "File: Lib/test/test_subprocess.py -> Lib/test/test_subprocess.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: import gc",
          "26: import textwrap",
          "27: import json",
          "29: from test.support.os_helper import FakePath",
          "31: try:",
          "",
          "[Removed Lines]",
          "28: import pathlib",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1522:         p.communicate(b\"x\" * 2**20)",
          "1524:     def test_repr(self):",
          "1528:         cases = [",
          "1529:             (\"ls\", True, 123, \"<Popen: returncode: 123 args: 'ls'>\"),",
          "1530:             ('a' * 100, True, 0,",
          "",
          "[Removed Lines]",
          "1525:         path_cmd = pathlib.Path(\"my-tool.py\")",
          "1526:         pathlib_cls = path_cmd.__class__.__name__",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1532:             ([\"ls\"], False, None, \"<Popen: returncode: None args: ['ls']>\"),",
          "1533:             ([\"ls\", '--my-opts', 'a' * 100], False, None,",
          "1534:              \"<Popen: returncode: None args: ['ls', '--my-opts', 'aaaaaaaaaaaaaaaaaaaaaaaa...>\"),",
          "1536:         ]",
          "1537:         with unittest.mock.patch.object(subprocess.Popen, '_execute_child'):",
          "1538:             for cmd, shell, code, sx in cases:",
          "",
          "[Removed Lines]",
          "1535:             (path_cmd, False, 7, f\"<Popen: returncode: 7 args: {pathlib_cls}('my-tool.py')>\")",
          "",
          "[Added Lines]",
          "1531:             (os_helper.FakePath(\"my-tool.py\"), False, 7,",
          "1532:              \"<Popen: returncode: 7 args: <FakePath 'my-tool.py'>>\")",
          "",
          "---------------"
        ],
        "Lib/test/test_tarfile.py||Lib/test/test_tarfile.py": [
          "File: Lib/test/test_tarfile.py -> Lib/test/test_tarfile.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "386:         self.assertFalse(tarfile.is_tarfile(tmpname))",
          "388:         # is_tarfile works on path-like objects",
          "391:         # is_tarfile works on file objects",
          "392:         with open(tmpname, \"rb\") as fobj:",
          "",
          "[Removed Lines]",
          "389:         self.assertFalse(tarfile.is_tarfile(pathlib.Path(tmpname)))",
          "",
          "[Added Lines]",
          "389:         self.assertFalse(tarfile.is_tarfile(os_helper.FakePath(tmpname)))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "400:         self.assertTrue(tarfile.is_tarfile(self.tarname))",
          "402:         # is_tarfile works on path-like objects",
          "405:         # is_tarfile works on file objects",
          "406:         with open(self.tarname, \"rb\") as fobj:",
          "",
          "[Removed Lines]",
          "403:         self.assertTrue(tarfile.is_tarfile(pathlib.Path(self.tarname)))",
          "",
          "[Added Lines]",
          "403:         self.assertTrue(tarfile.is_tarfile(os_helper.FakePath(self.tarname)))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "576:                 self.assertIsInstance(tar.name, bytes)",
          "577:                 self.assertEqual(tar.name, os.path.abspath(fobj.name))",
          "581:         with tarfile.open(tarname, mode=self.mode) as tar:",
          "584:         with self.taropen(tarname) as tar:",
          "587:         with tarfile.TarFile.open(tarname, mode=self.mode) as tar:",
          "590:         if self.suffix == '':",
          "591:             with tarfile.TarFile(tarname, mode='r') as tar:",
          "595:     def test_illegal_mode_arg(self):",
          "596:         with open(tmpname, 'wb'):",
          "",
          "[Removed Lines]",
          "579:     def test_pathlike_name(self):",
          "580:         tarname = pathlib.Path(self.tarname)",
          "582:             self.assertIsInstance(tar.name, str)",
          "583:             self.assertEqual(tar.name, os.path.abspath(os.fspath(tarname)))",
          "585:             self.assertIsInstance(tar.name, str)",
          "586:             self.assertEqual(tar.name, os.path.abspath(os.fspath(tarname)))",
          "588:             self.assertIsInstance(tar.name, str)",
          "589:             self.assertEqual(tar.name, os.path.abspath(os.fspath(tarname)))",
          "592:                 self.assertIsInstance(tar.name, str)",
          "593:                 self.assertEqual(tar.name, os.path.abspath(os.fspath(tarname)))",
          "",
          "[Added Lines]",
          "579:     def test_pathlike_name(self, tarname=None):",
          "580:         if tarname is None:",
          "581:             tarname = self.tarname",
          "582:         expected = os.path.abspath(tarname)",
          "583:         tarname = os_helper.FakePath(tarname)",
          "585:             self.assertEqual(tar.name, expected)",
          "587:             self.assertEqual(tar.name, expected)",
          "589:             self.assertEqual(tar.name, expected)",
          "592:                 self.assertEqual(tar.name, expected)",
          "594:     def test_pathlike_bytes_name(self):",
          "595:         self.test_pathlike_name(os.fsencode(self.tarname))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "761:             # check that the stacklevel of the deprecation warning is correct:",
          "762:             self.assertEqual(cm.filename, __file__)",
          "766:         with os_helper.temp_dir(DIR), \\",
          "767:              tarfile.open(tarname, encoding=\"iso8859-1\") as tar:",
          "768:             directories = [t for t in tar if t.isdir()]",
          "770:             for tarinfo in directories:",
          "772:                 self.assertEqual(os.path.getmtime(path), tarinfo.mtime)",
          "775:         dirtype = \"ustar/dirtype\"",
          "777:         with os_helper.temp_dir(DIR), \\",
          "778:              tarfile.open(tarname, encoding=\"iso8859-1\") as tar:",
          "779:             tarinfo = tar.getmember(dirtype)",
          "782:             self.assertEqual(os.path.getmtime(extracted), tarinfo.mtime)",
          "784:     def test_init_close_fobj(self):",
          "",
          "[Removed Lines]",
          "764:     def test_extractall_pathlike_name(self):",
          "765:         DIR = pathlib.Path(TEMPDIR) / \"extractall\"",
          "769:             tar.extractall(DIR, directories, filter='fully_trusted')",
          "771:                 path = DIR / tarinfo.name",
          "774:     def test_extract_pathlike_name(self):",
          "776:         DIR = pathlib.Path(TEMPDIR) / \"extractall\"",
          "780:             tar.extract(tarinfo, path=DIR, filter='fully_trusted')",
          "781:             extracted = DIR / dirtype",
          "",
          "[Added Lines]",
          "766:     def test_extractall_pathlike_dir(self):",
          "767:         DIR = os.path.join(TEMPDIR, \"extractall\")",
          "771:             tar.extractall(os_helper.FakePath(DIR), directories, filter='fully_trusted')",
          "773:                 path = os.path.join(DIR, tarinfo.name)",
          "776:     def test_extract_pathlike_dir(self):",
          "778:         DIR = os.path.join(TEMPDIR, \"extractall\")",
          "782:             tar.extract(tarinfo, path=os_helper.FakePath(DIR), filter='fully_trusted')",
          "783:             extracted = os.path.join(DIR, dirtype)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1391:     def test_gettarinfo_pathlike_name(self):",
          "1392:         with tarfile.open(tmpname, self.mode) as tar:",
          "1394:             with open(path, \"wb\") as fobj:",
          "1395:                 fobj.write(b\"aaa\")",
          "1398:             self.assertIsInstance(tarinfo.name, str)",
          "1399:             self.assertEqual(tarinfo.name, tarinfo2.name)",
          "1400:             self.assertEqual(tarinfo.size, 3)",
          "",
          "[Removed Lines]",
          "1393:             path = pathlib.Path(TEMPDIR) / \"file\"",
          "1396:             tarinfo = tar.gettarinfo(path)",
          "1397:             tarinfo2 = tar.gettarinfo(os.fspath(path))",
          "",
          "[Added Lines]",
          "1395:             path = os.path.join(TEMPDIR, \"file\")",
          "1398:             tarinfo = tar.gettarinfo(os_helper.FakePath(path))",
          "1399:             tarinfo2 = tar.gettarinfo(path)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1947:         self.assertIn(\"spameggs42\", names[0])",
          "1949:     def test_create_pathlike_name(self):",
          "1951:             self.assertIsInstance(tobj.name, str)",
          "1952:             self.assertEqual(tobj.name, os.path.abspath(tmpname))",
          "1954:             names = tobj.getnames()",
          "1955:         self.assertEqual(len(names), 1)",
          "1956:         self.assertIn('spameggs42', names[0])",
          "",
          "[Removed Lines]",
          "1950:         with tarfile.open(pathlib.Path(tmpname), self.mode) as tobj:",
          "1953:             tobj.add(pathlib.Path(self.file_path))",
          "",
          "[Added Lines]",
          "1952:         with tarfile.open(os_helper.FakePath(tmpname), self.mode) as tobj:",
          "1955:             tobj.add(os_helper.FakePath(self.file_path))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1961:         self.assertIn('spameggs42', names[0])",
          "1963:     def test_create_taropen_pathlike_name(self):",
          "1965:             self.assertIsInstance(tobj.name, str)",
          "1966:             self.assertEqual(tobj.name, os.path.abspath(tmpname))",
          "1968:             names = tobj.getnames()",
          "1969:         self.assertEqual(len(names), 1)",
          "1970:         self.assertIn('spameggs42', names[0])",
          "",
          "[Removed Lines]",
          "1964:         with self.taropen(pathlib.Path(tmpname), \"x\") as tobj:",
          "1967:             tobj.add(pathlib.Path(self.file_path))",
          "",
          "[Added Lines]",
          "1966:         with self.taropen(os_helper.FakePath(tmpname), \"x\") as tobj:",
          "1969:             tobj.add(os_helper.FakePath(self.file_path))",
          "",
          "---------------"
        ],
        "Lib/test/test_tempfile.py||Lib/test/test_tempfile.py": [
          "File: Lib/test/test_tempfile.py -> Lib/test/test_tempfile.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "63:             tempfile._infer_return_type(b'', None, '')",
          "65:     def test_infer_return_type_pathlib(self):",
          "68:     def test_infer_return_type_pathlike(self):",
          "76:         self.assertIs(str, tempfile._infer_return_type(Path('/')))",
          "77:         self.assertIs(bytes, tempfile._infer_return_type(Path(b'/')))",
          "78:         self.assertIs(str, tempfile._infer_return_type('', Path('')))",
          "",
          "[Removed Lines]",
          "66:         self.assertIs(str, tempfile._infer_return_type(pathlib.Path('/')))",
          "69:         class Path:",
          "70:             def __init__(self, path):",
          "71:                 self.path = path",
          "73:             def __fspath__(self):",
          "74:                 return self.path",
          "",
          "[Added Lines]",
          "66:         self.assertIs(str, tempfile._infer_return_type(os_helper.FakePath('/')))",
          "69:         Path = os_helper.FakePath",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "443:         dir = tempfile.mkdtemp()",
          "444:         try:",
          "445:             self.do_create(dir=dir).write(b\"blat\")",
          "447:         finally:",
          "448:             support.gc_collect()  # For PyPy or other GCs.",
          "449:             os.rmdir(dir)",
          "",
          "[Removed Lines]",
          "446:             self.do_create(dir=pathlib.Path(dir)).write(b\"blat\")",
          "",
          "[Added Lines]",
          "440:             self.do_create(dir=os_helper.FakePath(dir)).write(b\"blat\")",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "681:         dir = tempfile.mkdtemp()",
          "682:         try:",
          "683:             self.do_create(dir=dir)",
          "685:         finally:",
          "686:             os.rmdir(dir)",
          "",
          "[Removed Lines]",
          "684:             self.do_create(dir=pathlib.Path(dir))",
          "",
          "[Added Lines]",
          "678:             self.do_create(dir=os_helper.FakePath(dir))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "782:         dir = tempfile.mkdtemp()",
          "783:         try:",
          "784:             os.rmdir(self.do_create(dir=dir))",
          "786:         finally:",
          "787:             os.rmdir(dir)",
          "",
          "[Removed Lines]",
          "785:             os.rmdir(self.do_create(dir=pathlib.Path(dir)))",
          "",
          "[Added Lines]",
          "779:             os.rmdir(self.do_create(dir=os_helper.FakePath(dir)))",
          "",
          "---------------"
        ],
        "Lib/test/test_venv.py||Lib/test/test_venv.py": [
          "File: Lib/test/test_venv.py -> Lib/test/test_venv.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:                           requires_venv_with_pip, TEST_HOME_DIR,",
          "25:                           requires_resource, copy_python_src_ignore)",
          "26: from test.support.os_helper import (can_symlink, EnvironmentVarGuard, rmtree,",
          "28: import unittest",
          "29: import venv",
          "30: from unittest.mock import patch, Mock",
          "",
          "[Removed Lines]",
          "27:                                     TESTFN)",
          "",
          "[Added Lines]",
          "27:                                     TESTFN, FakePath)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:         self.run_with_capture(venv.create, self.env_dir)",
          "126:         self._check_output_of_default_create()",
          "129:         \"\"\"",
          "131:         \"\"\"",
          "132:         rmtree(self.env_dir)",
          "134:         self._check_output_of_default_create()",
          "136:     def _check_output_of_default_create(self):",
          "",
          "[Removed Lines]",
          "128:     def test_defaults_with_pathlib_path(self):",
          "130:         Test the create function with default arguments and a pathlib.Path path.",
          "133:         self.run_with_capture(venv.create, pathlib.Path(self.env_dir))",
          "",
          "[Added Lines]",
          "128:     def test_defaults_with_pathlike(self):",
          "130:         Test the create function with default arguments and a path-like path.",
          "133:         self.run_with_capture(venv.create, FakePath(self.env_dir))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "572:         rmtree(self.env_dir)",
          "573:         bad_itempath = self.env_dir + os.pathsep",
          "574:         self.assertRaises(ValueError, venv.create, bad_itempath)",
          "577:     @unittest.skipIf(os.name == 'nt', 'not relevant on Windows')",
          "578:     @requireVenvCreate",
          "",
          "[Removed Lines]",
          "575:         self.assertRaises(ValueError, venv.create, pathlib.Path(bad_itempath))",
          "",
          "[Added Lines]",
          "575:         self.assertRaises(ValueError, venv.create, FakePath(bad_itempath))",
          "",
          "---------------"
        ],
        "Lib/test/test_winsound.py||Lib/test/test_winsound.py": [
          "File: Lib/test/test_winsound.py -> Lib/test/test_winsound.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: # Ridiculously simple test of the winsound module for Windows.",
          "3: import functools",
          "5: import time",
          "6: import unittest",
          "8: from test import support",
          "9: from test.support import import_helper",
          "12: support.requires('audio')",
          "",
          "[Removed Lines]",
          "4: import pathlib",
          "",
          "[Added Lines]",
          "4: import os",
          "10: from test.support import os_helper",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "85:         safe_MessageBeep(type=winsound.MB_OK)",
          "95: class PlaySoundTest(unittest.TestCase):",
          "97:     def test_errors(self):",
          "",
          "[Removed Lines]",
          "88: # A class for testing winsound when the given path resolves",
          "89: # to bytes rather than str.",
          "90: class BytesPath(pathlib.WindowsPath):",
          "91:     def __fspath__(self):",
          "92:         return bytes(super().__fspath__(), 'UTF-8')",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "127:     def test_snd_filepath(self):",
          "128:         fn = support.findfile('pluck-pcm8.wav', subdir='audiodata')",
          "130:         safe_PlaySound(path, winsound.SND_FILENAME | winsound.SND_NODEFAULT)",
          "132:     def test_snd_filepath_as_bytes(self):",
          "",
          "[Removed Lines]",
          "129:         path = pathlib.Path(fn)",
          "",
          "[Added Lines]",
          "123:         path = os_helper.FakePath(fn)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "134:         self.assertRaises(",
          "135:             TypeError,",
          "136:             winsound.PlaySound,",
          "138:             winsound.SND_FILENAME | winsound.SND_NODEFAULT",
          "139:         )",
          "",
          "[Removed Lines]",
          "137:             BytesPath(fn),",
          "",
          "[Added Lines]",
          "131:             os_helper.FakePath(os.fsencode(fn)),",
          "",
          "---------------"
        ],
        "Lib/test/test_zipapp.py||Lib/test/test_zipapp.py": [
          "File: Lib/test/test_zipapp.py -> Lib/test/test_zipapp.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "265:         zipapp.create_archive(str(target), new_target, interpreter='python2.7')",
          "266:         self.assertTrue(new_target.getvalue().startswith(b'#!python2.7\\n'))",
          "270:         # for the source.",
          "271:         source = self.tmpdir / 'source'",
          "272:         source.mkdir()",
          "273:         (source / '__main__.py').touch()",
          "276:         zipapp.create_archive(source, target1, interpreter='python')",
          "277:         zipapp.create_archive(target1, target2, interpreter='python2.7')",
          "278:         self.assertEqual(zipapp.get_interpreter(target2), 'python2.7')",
          "",
          "[Removed Lines]",
          "268:     def test_read_from_pathobj(self):",
          "269:         # Test that we can copy an archive using a pathlib.Path object",
          "274:         target1 = self.tmpdir / 'target1.pyz'",
          "275:         target2 = self.tmpdir / 'target2.pyz'",
          "",
          "[Added Lines]",
          "268:     def test_read_from_pathlike_obj(self):",
          "269:         # Test that we can copy an archive using a path-like object",
          "274:         source = os_helper.FakePath(str(source))",
          "275:         target1 = os_helper.FakePath(str(self.tmpdir / 'target1.pyz'))",
          "276:         target2 = os_helper.FakePath(str(self.tmpdir / 'target2.pyz'))",
          "",
          "---------------"
        ],
        "Lib/test/test_zipfile/_path/test_path.py||Lib/test/test_zipfile/_path/test_path.py": [
          "File: Lib/test/test_zipfile/_path/test_path.py -> Lib/test/test_zipfile/_path/test_path.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: from ._test_params import parameterize, Invoked",
          "19: class jaraco:",
          "",
          "[Removed Lines]",
          "16: from test.support.os_helper import temp_dir",
          "",
          "[Added Lines]",
          "16: from test.support.os_helper import temp_dir, FakePath",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "264:         zipfile.Path should be constructable from a path-like object",
          "265:         \"\"\"",
          "266:         zipfile_ondisk = self.zipfile_ondisk(alpharep)",
          "268:         zipfile.Path(pathlike)",
          "270:     @pass_alpharep",
          "271:     def test_traverse_pathlike(self, alpharep):",
          "272:         root = zipfile.Path(alpharep)",
          "275:     @pass_alpharep",
          "276:     def test_parent(self, alpharep):",
          "",
          "[Removed Lines]",
          "267:         pathlike = pathlib.Path(str(zipfile_ondisk))",
          "273:         root / pathlib.Path(\"a\")",
          "",
          "[Added Lines]",
          "267:         pathlike = FakePath(str(zipfile_ondisk))",
          "273:         root / FakePath(\"a\")",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "539:         ['alpharep', 'path_type', 'subpath'],",
          "540:         itertools.product(",
          "541:             alpharep_generators,",
          "543:             ['', 'b/'],",
          "544:         ),",
          "545:     )",
          "546:     def test_pickle(self, alpharep, path_type, subpath):",
          "549:         saved_1 = pickle.dumps(zipfile.Path(zipfile_ondisk, at=subpath))",
          "550:         restored_1 = pickle.loads(saved_1)",
          "",
          "[Removed Lines]",
          "542:             [str, pathlib.Path],",
          "547:         zipfile_ondisk = path_type(self.zipfile_ondisk(alpharep))",
          "",
          "[Added Lines]",
          "542:             [str, FakePath],",
          "547:         zipfile_ondisk = path_type(str(self.zipfile_ondisk(alpharep)))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
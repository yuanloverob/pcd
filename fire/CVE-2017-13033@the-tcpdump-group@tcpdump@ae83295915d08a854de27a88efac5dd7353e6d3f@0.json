{
  "cve_id": "CVE-2017-13033",
  "cve_desc": "The VTP parser in tcpdump before 4.9.2 has a buffer over-read in print-vtp.c:vtp_print().",
  "repo": "the-tcpdump-group/tcpdump",
  "patch_hash": "ae83295915d08a854de27a88efac5dd7353e6d3f",
  "patch_info": {
    "commit_hash": "ae83295915d08a854de27a88efac5dd7353e6d3f",
    "repo": "the-tcpdump-group/tcpdump",
    "commit_url": "https://github.com/the-tcpdump-group/tcpdump/commit/ae83295915d08a854de27a88efac5dd7353e6d3f",
    "files": [
      "print-vtp.c",
      "tests/TESTLIST",
      "tests/vtp_asan-2.out",
      "tests/vtp_asan-3.out",
      "tests/vtp_asan-3.pcap"
    ],
    "message": "CVE-2017-13033/VTP: Add more bound and length checks.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.\n\nUpdate another VTP test's .out file for this change.\n\nDon't treate a TLV type or length of 0 as invalid; a type of 0 should\njust be reported as illegal if that type isn't used, and the length is\nthe length of the *value*, not the length of the entire TLV, so if it's\nzero there won't be an infinite loop.  (It's still not *legal*, as the\nvalues of all the TLVs we handle are 1 16-bit word long; we added a\ncheck for that.)\n\nUpdate some comments while we're at it, to give a new URL for one Cisco\npage and a non-Cisco URL for another former Cisco page (Cisco's UniverCD\npages don't seem to be available any more, and Cisco's robots.txt file\ndidn't allow the Wayback Machine to archive it).",
    "before_after_code_files": [
      "print-vtp.c||print-vtp.c"
    ]
  },
  "patch_diff": {
    "print-vtp.c||print-vtp.c": [
      "File: print-vtp.c -> print-vtp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "36: #define VTP_DOMAIN_NAME_LEN  32",
      "37: #define VTP_MD5_DIGEST_LEN  16",
      "38: #define VTP_UPDATE_TIMESTAMP_LEN 12",
      "41: #define VTP_SUMMARY_ADV   0x01",
      "42: #define VTP_SUBSET_ADV   0x02",
      "",
      "[Removed Lines]",
      "39: #define VTP_VLAN_INFO_OFFSET  12",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "252:      ND_TCHECK2(*tptr, len);",
      "254:      vtp_vlan = (const struct vtp_vlan_*)tptr;",
      "255:      ND_TCHECK(*vtp_vlan);",
      "256:      ND_PRINT((ndo, \"\\n\\tVLAN info status %s, type %s, VLAN-id %u, MTU %u, SAID 0x%08x, Name \",",
      "257:      tok2str(vtp_vlan_status,\"Unknown\",vtp_vlan->status),",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "254:      if (len < VTP_VLAN_INFO_FIXED_PART_LEN)",
      "255:   goto trunc;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "259:      EXTRACT_16BITS(&vtp_vlan->vlanid),",
      "260:      EXTRACT_16BITS(&vtp_vlan->mtu),",
      "261:      EXTRACT_32BITS(&vtp_vlan->index)));",
      "272:             while (len > 0) {",
      "278:                 type = *tptr;",
      "279:                 tlv_len = *(tptr+1);",
      "",
      "[Removed Lines]",
      "262:      fn_printzp(ndo, tptr + VTP_VLAN_INFO_OFFSET, vtp_vlan->name_len, NULL);",
      "267:             len  -= VTP_VLAN_INFO_OFFSET + 4*((vtp_vlan->name_len + 3)/4);",
      "268:             tptr += VTP_VLAN_INFO_OFFSET + 4*((vtp_vlan->name_len + 3)/4);",
      "",
      "[Added Lines]",
      "263:      len  -= VTP_VLAN_INFO_FIXED_PART_LEN;",
      "264:      tptr += VTP_VLAN_INFO_FIXED_PART_LEN;",
      "265:      if (len < 4*((vtp_vlan->name_len + 3)/4))",
      "266:   goto trunc;",
      "267:      ND_TCHECK2(*tptr, vtp_vlan->name_len);",
      "268:      fn_printzp(ndo, tptr, vtp_vlan->name_len, NULL);",
      "273:      len  -= 4*((vtp_vlan->name_len + 3)/4);",
      "274:      tptr += 4*((vtp_vlan->name_len + 3)/4);",
      "287:                 if (len < 2)",
      "288:                     goto trunc;",
      "289:                 ND_TCHECK2(*tptr, 2);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "282:                        tok2str(vtp_vlan_tlv_values, \"Unknown\", type),",
      "283:                        type));",
      "289:                     return;",
      "290:                 }",
      "292:                 ND_TCHECK2(*tptr, tlv_len * 2 +2);",
      "338:                 }",
      "339:                 len -= 2 + tlv_len*2;",
      "340:                 tptr += 2 + tlv_len*2;",
      "",
      "[Removed Lines]",
      "288:                 if (type == 0 || tlv_len == 0) {",
      "294:                 tlv_value = EXTRACT_16BITS(tptr+2);",
      "296:                 switch (type) {",
      "297:                 case VTP_VLAN_STE_HOP_COUNT:",
      "298:                     ND_PRINT((ndo, \", %u\", tlv_value));",
      "299:                     break;",
      "301:                 case VTP_VLAN_PRUNING:",
      "302:                     ND_PRINT((ndo, \", %s (%u)\",",
      "303:                            tlv_value == 1 ? \"Enabled\" : \"Disabled\",",
      "304:                            tlv_value));",
      "305:                     break;",
      "307:                 case VTP_VLAN_STP_TYPE:",
      "308:                     ND_PRINT((ndo, \", %s (%u)\",",
      "309:                            tok2str(vtp_stp_type_values, \"Unknown\", tlv_value),",
      "310:                            tlv_value));",
      "311:                     break;",
      "313:                 case VTP_VLAN_BRIDGE_TYPE:",
      "314:                     ND_PRINT((ndo, \", %s (%u)\",",
      "315:                            tlv_value == 1 ? \"SRB\" : \"SRT\",",
      "316:                            tlv_value));",
      "317:                     break;",
      "319:                 case VTP_VLAN_BACKUP_CRF_MODE:",
      "320:                     ND_PRINT((ndo, \", %s (%u)\",",
      "321:                            tlv_value == 1 ? \"Backup\" : \"Not backup\",",
      "322:                            tlv_value));",
      "323:                     break;",
      "330:                 case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER:",
      "331:                 case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER:",
      "332:                 case VTP_VLAN_PARENT_VLAN:",
      "333:                 case VTP_VLAN_TRANS_BRIDGED_VLAN:",
      "334:                 case VTP_VLAN_ARP_HOP_COUNT:",
      "335:                 default:",
      "336:       print_unknown_data(ndo, tptr, \"\\n\\t\\t  \", 2 + tlv_len*2);",
      "337:                     break;",
      "",
      "[Added Lines]",
      "297:                 if (len < tlv_len * 2 + 2) {",
      "298:                     ND_PRINT((ndo, \" (TLV goes past the end of the packet)\"));",
      "307:                 if (tlv_len != 1) {",
      "308:                     ND_PRINT((ndo, \" (invalid TLV length %u != 1)\", tlv_len));",
      "309:                     return;",
      "310:                 } else {",
      "311:                     tlv_value = EXTRACT_16BITS(tptr+2);",
      "313:                     switch (type) {",
      "314:                     case VTP_VLAN_STE_HOP_COUNT:",
      "315:                         ND_PRINT((ndo, \", %u\", tlv_value));",
      "316:                         break;",
      "318:                     case VTP_VLAN_PRUNING:",
      "319:                         ND_PRINT((ndo, \", %s (%u)\",",
      "320:                                tlv_value == 1 ? \"Enabled\" : \"Disabled\",",
      "321:                                tlv_value));",
      "322:                         break;",
      "324:                     case VTP_VLAN_STP_TYPE:",
      "325:                         ND_PRINT((ndo, \", %s (%u)\",",
      "326:                                tok2str(vtp_stp_type_values, \"Unknown\", tlv_value),",
      "327:                                tlv_value));",
      "328:                         break;",
      "330:                     case VTP_VLAN_BRIDGE_TYPE:",
      "331:                         ND_PRINT((ndo, \", %s (%u)\",",
      "332:                                tlv_value == 1 ? \"SRB\" : \"SRT\",",
      "333:                                tlv_value));",
      "334:                         break;",
      "336:                     case VTP_VLAN_BACKUP_CRF_MODE:",
      "337:                         ND_PRINT((ndo, \", %s (%u)\",",
      "338:                                tlv_value == 1 ? \"Backup\" : \"Not backup\",",
      "339:                                tlv_value));",
      "340:                         break;",
      "347:                     case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER:",
      "348:                     case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER:",
      "349:                     case VTP_VLAN_PARENT_VLAN:",
      "350:                     case VTP_VLAN_TRANS_BRIDGED_VLAN:",
      "351:                     case VTP_VLAN_ARP_HOP_COUNT:",
      "352:                     default:",
      "353:                         print_unknown_data(ndo, tptr, \"\\n\\t\\t  \", 2 + tlv_len*2);",
      "354:                         break;",
      "355:                     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5045cf5cb8a13e05f97e30c44ec80b92625f169d",
      "candidate_info": {
        "commit_hash": "5045cf5cb8a13e05f97e30c44ec80b92625f169d",
        "repo": "the-tcpdump-group/tcpdump",
        "commit_url": "https://github.com/the-tcpdump-group/tcpdump/commit/5045cf5cb8a13e05f97e30c44ec80b92625f169d",
        "files": [
          "print-vtp.c"
        ],
        "message": "Use nd_ types, add EXTRACT_ calls.",
        "before_after_code_files": [
          "print-vtp.c||print-vtp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "print-vtp.c||print-vtp.c"
          ],
          "candidate": [
            "print-vtp.c||print-vtp.c"
          ]
        }
      },
      "candidate_diff": {
        "print-vtp.c||print-vtp.c": [
          "File: print-vtp.c -> print-vtp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43: #define VTP_JOIN_MESSAGE  0x04",
          "45: struct vtp_vlan_ {",
          "53: };",
          "55: static const struct tok vtp_message_type_values[] = {",
          "",
          "[Removed Lines]",
          "46:     uint8_t  len;",
          "47:     uint8_t  status;",
          "48:     uint8_t  type;",
          "49:     uint8_t  name_len;",
          "50:     uint16_t vlanid;",
          "51:     uint16_t mtu;",
          "52:     uint32_t index;",
          "",
          "[Added Lines]",
          "46:     nd_uint8_t  len;",
          "47:     nd_uint8_t  status;",
          "48:     nd_uint8_t  type;",
          "49:     nd_uint8_t  name_len;",
          "50:     nd_uint16_t vlanid;",
          "51:     nd_uint16_t mtu;",
          "52:     nd_uint32_t index;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "119: vtp_print (netdissect_options *ndo,",
          "120:            const u_char *pptr, u_int length)",
          "121: {",
          "123:     const u_char *tptr;",
          "124:     const struct vtp_vlan_ *vtp_vlan;",
          "",
          "[Removed Lines]",
          "122:     int type, len, tlv_len, tlv_value, mgmtd_len;",
          "",
          "[Added Lines]",
          "122:     u_int type, len, name_len, tlv_len, tlv_value, mgmtd_len;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "146:     ND_PRINT((ndo, \"\\n\\tDomain name: \"));",
          "147:     mgmtd_len = EXTRACT_U_1(tptr + 3);",
          "148:     if (mgmtd_len < 1 ||  mgmtd_len > 32) {",
          "150:  return;",
          "151:     }",
          "152:     fn_printzp(ndo, tptr + 4, mgmtd_len, NULL);",
          "",
          "[Removed Lines]",
          "149:  ND_PRINT((ndo, \" [invalid MgmtD Len %d]\", mgmtd_len));",
          "",
          "[Added Lines]",
          "149:  ND_PRINT((ndo, \" [invalid MgmtD Len %u]\", mgmtd_len));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "255:   goto trunc;",
          "256:      ND_TCHECK(*vtp_vlan);",
          "257:      ND_PRINT((ndo, \"\\n\\tVLAN info status %s, type %s, VLAN-id %u, MTU %u, SAID 0x%08x, Name \",",
          "263:      len  -= VTP_VLAN_INFO_FIXED_PART_LEN;",
          "264:      tptr += VTP_VLAN_INFO_FIXED_PART_LEN;",
          "266:   goto trunc;",
          "",
          "[Removed Lines]",
          "258:      tok2str(vtp_vlan_status,\"Unknown\",vtp_vlan->status),",
          "259:      tok2str(vtp_vlan_type_values,\"Unknown\",vtp_vlan->type),",
          "260:      EXTRACT_BE_U_2(&vtp_vlan->vlanid),",
          "261:      EXTRACT_BE_U_2(&vtp_vlan->mtu),",
          "262:      EXTRACT_BE_U_4(&vtp_vlan->index)));",
          "265:      if (len < 4*((vtp_vlan->name_len + 3)/4))",
          "267:      ND_TCHECK_LEN(tptr, vtp_vlan->name_len);",
          "268:      fn_printzp(ndo, tptr, vtp_vlan->name_len, NULL);",
          "273:      len  -= 4*((vtp_vlan->name_len + 3)/4);",
          "274:      tptr += 4*((vtp_vlan->name_len + 3)/4);",
          "",
          "[Added Lines]",
          "258:      tok2str(vtp_vlan_status,\"Unknown\",EXTRACT_U_1(vtp_vlan->status)),",
          "259:      tok2str(vtp_vlan_type_values,\"Unknown\",EXTRACT_U_1(vtp_vlan->type)),",
          "260:      EXTRACT_BE_U_2(vtp_vlan->vlanid),",
          "261:      EXTRACT_BE_U_2(vtp_vlan->mtu),",
          "262:      EXTRACT_BE_U_4(vtp_vlan->index)));",
          "265:      name_len = EXTRACT_U_1(vtp_vlan->name_len);",
          "266:      if (len < 4*((name_len + 3)/4))",
          "268:      ND_TCHECK_LEN(tptr, name_len);",
          "269:      fn_printzp(ndo, tptr, name_len, NULL);",
          "274:      len  -= 4*((name_len + 3)/4);",
          "275:      tptr += 4*((name_len + 3)/4);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
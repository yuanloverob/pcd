{
  "cve_id": "CVE-2017-6309",
  "cve_desc": "An issue was discovered in tnef before 1.4.13. Two type confusions have been identified in the parse_file() function. These might lead to invalid read and write operations, controlled by an attacker.",
  "repo": "verdammelt/tnef",
  "patch_hash": "8dccf79857ceeb7a6d3e42c1e762e7b865d5344d",
  "patch_info": {
    "commit_hash": "8dccf79857ceeb7a6d3e42c1e762e7b865d5344d",
    "repo": "verdammelt/tnef",
    "commit_url": "https://github.com/verdammelt/tnef/commit/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d",
    "files": [
      "src/file.c",
      "src/tnef.c"
    ],
    "message": "Check types to avoid invalid reads/writes.",
    "before_after_code_files": [
      "src/file.c||src/file.c",
      "src/tnef.c||src/tnef.c"
    ]
  },
  "patch_diff": {
    "src/file.c||src/file.c": [
      "File: src/file.c -> src/file.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "173:      switch (a->name)",
      "174:      {",
      "175:      case MAPI_ATTACH_LONG_FILENAME:",
      "176:   if (file->name) XFREE(file->name);",
      "177:   file->name = strdup( (char*)a->values[0].data.buf );",
      "178:   break;",
      "180:      case MAPI_ATTACH_DATA_OBJ:",
      "181:   file->len = a->values[0].len;",
      "182:   if (file->data) XFREE (file->data);",
      "183:   file->data = CHECKED_XMALLOC (unsigned char, file->len);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "176:   assert(a->type == szMAPI_STRING);",
      "182:   assert((a->type == szMAPI_BINARY) || (a->type == szMAPI_OBJECT));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "185:   break;",
      "187:              case MAPI_ATTACH_MIME_TAG:",
      "188:   if (file->mime_type) XFREE (file->mime_type);",
      "189:   file->mime_type = CHECKED_XMALLOC (char, a->values[0].len);",
      "190:   memmove (file->mime_type, a->values[0].data.buf, a->values[0].len);",
      "191:   break;",
      "193:                 case MAPI_ATTACH_CONTENT_ID:",
      "194:                     if (file->content_id) XFREE(file->content_id);",
      "195:                     file->content_id = CHECKED_XMALLOC (char, a->values[0].len);",
      "196:                     memmove (file->content_id, a->values[0].data.buf, a->values[0].len);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "190:   assert(a->type == szMAPI_STRING);",
      "197:                     assert(a->type == szMAPI_STRING);",
      "",
      "---------------"
    ],
    "src/tnef.c||src/tnef.c": [
      "File: src/tnef.c -> src/tnef.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "166:     int j;",
      "167:     for (j = 0; j < a->num_values; j++)",
      "172:  memmove (body[j]->data, a->values[j].data.buf, body[j]->len);",
      "173:     }",
      "174:     return body;",
      "",
      "[Removed Lines]",
      "168:     {",
      "169:  body[j] = XMALLOC(VarLenData, 1);",
      "170:  body[j]->len = a->values[j].len;",
      "171:  body[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);",
      "",
      "[Added Lines]",
      "168:     {",
      "169:         if (a->type == szMAPI_BINARY) {",
      "170:       body[j] = XMALLOC(VarLenData, 1);",
      "171:      body[j]->len = a->values[j].len;",
      "172:      body[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);",
      "173:      memmove (body[j]->data, a->values[j].data.buf, body[j]->len);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "306:   {",
      "307:       int i;",
      "308:       for (i = 0; mapi_attrs[i]; i++)",
      "309:       {",
      "312:    if (a->name == MAPI_BODY_HTML)",
      "313:    {",
      "314:        body.html_bodies = get_html_data (a);",
      "316:    }",
      "317:    else if (a->name == MAPI_RTF_COMPRESSED)",
      "318:    {",
      "",
      "[Removed Lines]",
      "310:    MAPI_Attr *a = mapi_attrs[i];",
      "315:                                 html_size = a->num_values;",
      "",
      "[Added Lines]",
      "312:    MAPI_Attr *a = mapi_attrs[i];",
      "317:                                 html_size = a->num_values;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1a17af1ed0c791aec44dbdc9eab91218cc1e335a",
      "candidate_info": {
        "commit_hash": "1a17af1ed0c791aec44dbdc9eab91218cc1e335a",
        "repo": "verdammelt/tnef",
        "commit_url": "https://github.com/verdammelt/tnef/commit/1a17af1ed0c791aec44dbdc9eab91218cc1e335a",
        "files": [
          "src/mapi_attr.c"
        ],
        "message": "Use asserts on lengths to prevent invalid reads/writes.",
        "before_after_code_files": [
          "src/mapi_attr.c||src/mapi_attr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/verdammelt/tnef/pull/14"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/mapi_attr.c||src/mapi_attr.c": [
          "File: src/mapi_attr.c -> src/mapi_attr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "174:     uint32 i,j;",
          "175:     assert(len > 4);",
          "176:     uint32 num_properties = GETINT32(buf+idx);",
          "177:     MAPI_Attr** attrs = CHECKED_XMALLOC (MAPI_Attr*, (num_properties + 1));",
          "179:     idx += 4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "177:     assert((num_properties+1) != 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213:       a->names[i].data",
          "214:    = CHECKED_XMALLOC(unsigned char, a->names[i].len);",
          "215:       for (j = 0; j < (a->names[i].len >> 1); j++)",
          "216:    a->names[i].data[j] = (buf+idx)[j*2];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "216:       assert((idx+(a->names[i].len*2)) <= len);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "308:      case szMAPI_BINARY:",
          "309:   CHECKINT32(idx, len); v->len = GETINT32(buf+idx); idx += 4;",
          "311:   if (a->type == szMAPI_UNICODE_STRING)",
          "312:   {",
          "313:       v->data.buf = (unsigned char*)unicode_to_utf8(v->len, buf+idx);",
          "314:   }",
          "315:   else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "313:   assert(v->len + idx <= len);",
          "317:       assert(v->len != 0);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9c4015433ecd3177976f820f7aa524c7e64c7c92",
      "candidate_info": {
        "commit_hash": "9c4015433ecd3177976f820f7aa524c7e64c7c92",
        "repo": "verdammelt/tnef",
        "commit_url": "https://github.com/verdammelt/tnef/commit/9c4015433ecd3177976f820f7aa524c7e64c7c92",
        "files": [
          "src/file.c"
        ],
        "message": "Correct assertion with respect to UNICODE_STRING fields.",
        "before_after_code_files": [
          "src/file.c||src/file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/file.c||src/file.c"
          ],
          "candidate": [
            "src/file.c||src/file.c"
          ]
        }
      },
      "candidate_diff": {
        "src/file.c||src/file.c": [
          "File: src/file.c -> src/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "173:      switch (a->name)",
          "174:      {",
          "175:      case MAPI_ATTACH_LONG_FILENAME:",
          "177:   if (file->name) XFREE(file->name);",
          "178:   file->name = strdup( (char*)a->values[0].data.buf );",
          "179:   break;",
          "",
          "[Removed Lines]",
          "176:   assert(a->type == szMAPI_STRING);",
          "",
          "[Added Lines]",
          "176:   assert(a->type == szMAPI_STRING || a->type == szMAPI_UNICODE_STRING);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "187:   break;",
          "189:              case MAPI_ATTACH_MIME_TAG:",
          "191:   if (file->mime_type) XFREE (file->mime_type);",
          "192:   file->mime_type = CHECKED_XMALLOC (char, a->values[0].len);",
          "193:   memmove (file->mime_type, a->values[0].data.buf, a->values[0].len);",
          "194:   break;",
          "203:      default:",
          "204:   break;",
          "",
          "[Removed Lines]",
          "190:   assert(a->type == szMAPI_STRING);",
          "196:                 case MAPI_ATTACH_CONTENT_ID:",
          "197:                     assert(a->type == szMAPI_STRING);",
          "198:                     if (file->content_id) XFREE(file->content_id);",
          "199:                     file->content_id = CHECKED_XMALLOC (char, a->values[0].len);",
          "200:                     memmove (file->content_id, a->values[0].data.buf, a->values[0].len);",
          "201:                     break;",
          "",
          "[Added Lines]",
          "190:   assert(a->type == szMAPI_STRING || a->type == szMAPI_UNICODE_STRING);",
          "196:             case MAPI_ATTACH_CONTENT_ID:",
          "197:                 assert(a->type == szMAPI_STRING || a->type == szMAPI_UNICODE_STRING);",
          "198:                 if (file->content_id) XFREE(file->content_id);",
          "199:                 file->content_id = CHECKED_XMALLOC (char, a->values[0].len);",
          "200:                 memmove (file->content_id, a->values[0].data.buf, a->values[0].len);",
          "201:                 break;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "72ad8433309f30ad247629df6cf25f88f3f786c4",
      "candidate_info": {
        "commit_hash": "72ad8433309f30ad247629df6cf25f88f3f786c4",
        "repo": "verdammelt/tnef",
        "commit_url": "https://github.com/verdammelt/tnef/commit/72ad8433309f30ad247629df6cf25f88f3f786c4",
        "files": [
          "src/alloc.c",
          "src/alloc.h",
          "src/attr.c",
          "src/attr.h",
          "src/common.h",
          "src/date.c",
          "src/date.h",
          "src/debug.c",
          "src/debug.h",
          "src/file.c",
          "src/file.h",
          "src/main.c",
          "src/mapi_attr.c",
          "src/mapi_attr.h",
          "src/mkdata.awk",
          "src/options.c",
          "src/options.h",
          "src/path.c",
          "src/path.h",
          "src/replace/basename.c",
          "src/replace/malloc.c",
          "src/replace/strdup.c",
          "src/rtf.c",
          "src/tnef.c",
          "src/tnef.h",
          "src/util.c",
          "src/util.h",
          "src/xstrdup.c",
          "tests/cmdline/version.baseline"
        ],
        "message": "Update all Copyright statements for 2018.",
        "before_after_code_files": [
          "src/alloc.c||src/alloc.c",
          "src/alloc.h||src/alloc.h",
          "src/attr.c||src/attr.c",
          "src/attr.h||src/attr.h",
          "src/common.h||src/common.h",
          "src/date.c||src/date.c",
          "src/date.h||src/date.h",
          "src/debug.c||src/debug.c",
          "src/debug.h||src/debug.h",
          "src/file.c||src/file.c",
          "src/file.h||src/file.h",
          "src/main.c||src/main.c",
          "src/mapi_attr.c||src/mapi_attr.c",
          "src/mapi_attr.h||src/mapi_attr.h",
          "src/mkdata.awk||src/mkdata.awk",
          "src/options.c||src/options.c",
          "src/options.h||src/options.h",
          "src/path.c||src/path.c",
          "src/path.h||src/path.h",
          "src/replace/basename.c||src/replace/basename.c",
          "src/replace/malloc.c||src/replace/malloc.c",
          "src/replace/strdup.c||src/replace/strdup.c",
          "src/rtf.c||src/rtf.c",
          "src/tnef.c||src/tnef.c",
          "src/tnef.h||src/tnef.h",
          "src/util.c||src/util.c",
          "src/util.h||src/util.h",
          "src/xstrdup.c||src/xstrdup.c",
          "tests/cmdline/version.baseline||tests/cmdline/version.baseline"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/file.c||src/file.c",
            "src/tnef.c||src/tnef.c"
          ],
          "candidate": [
            "src/file.c||src/file.c",
            "src/tnef.c||src/tnef.c"
          ]
        }
      },
      "candidate_diff": {
        "src/alloc.c||src/alloc.c": [
          "File: src/alloc.c -> src/alloc.c"
        ],
        "src/alloc.h||src/alloc.h": [
          "File: src/alloc.h -> src/alloc.h"
        ],
        "src/attr.c||src/attr.c": [
          "File: src/attr.c -> src/attr.c"
        ],
        "src/attr.h||src/attr.h": [
          "File: src/attr.h -> src/attr.h"
        ],
        "src/common.h||src/common.h": [
          "File: src/common.h -> src/common.h"
        ],
        "src/date.c||src/date.c": [
          "File: src/date.c -> src/date.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: const char* day_of_week[] = { \"Sun\", \"Mon\", \"Tue\",",
          "35: extern const char *",
          "36: dow_str(int dow)",
          "",
          "[Removed Lines]",
          "33:          \"Wed\", \"Thu\", \"Fri\", \"Sat\" };",
          "",
          "[Added Lines]",
          "33:                               \"Wed\", \"Thu\", \"Fri\", \"Sat\" };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44: {",
          "45:     static char buf[32];",
          "46:     snprintf (buf, sizeof(buf), \"%s %04d/%02d/%02d %02d:%02d:%02d\",",
          "50:     buf[sizeof(buf)-1] = '\\0';",
          "51:     return buf;",
          "52: }",
          "",
          "[Removed Lines]",
          "47:       dow_str(dt->dow),",
          "48:       dt->year, dt->month, dt->day,",
          "49:       dt->hour, dt->min, dt->sec);",
          "",
          "[Added Lines]",
          "47:              dow_str(dt->dow),",
          "48:              dt->year, dt->month, dt->day,",
          "49:              dt->hour, dt->min, dt->sec);",
          "",
          "---------------"
        ],
        "src/date.h||src/date.h": [
          "File: src/date.h -> src/date.h"
        ],
        "src/debug.c||src/debug.c": [
          "File: src/debug.c -> src/debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: {",
          "35:     if (DEBUG_ON)",
          "36:     {",
          "43:     }",
          "44: }",
          "",
          "[Removed Lines]",
          "37:  va_list args;",
          "38:  va_start (args, fmt);",
          "39:  VPRINTF(stdout, fmt, args);",
          "40:  va_end (args);",
          "",
          "[Added Lines]",
          "37:         va_list args;",
          "38:         va_start (args, fmt);",
          "39:         VPRINTF(stdout, fmt, args);",
          "40:         va_end (args);",
          "",
          "---------------"
        ],
        "src/debug.h||src/debug.h": [
          "File: src/debug.h -> src/debug.h"
        ],
        "src/file.c||src/file.c": [
          "File: src/file.c -> src/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "41: {",
          "42:     if (INTERACTIVE)",
          "43:     {",
          "56:     }",
          "57:     return 1;",
          "58: }",
          "",
          "[Removed Lines]",
          "44:  int confirmed = 0;",
          "45:  char buf[BUFSIZ + 1];",
          "46:  va_list args;",
          "47:  va_start (args, prompt);",
          "49:  VPRINTF(stdout, prompt, args);",
          "50:  fgets (buf, BUFSIZ, stdin);",
          "51:  if (buf[0] == 'y' || buf[0] == 'Y') confirmed = 1;",
          "53:  va_end (args);",
          "55:  return confirmed;",
          "",
          "[Added Lines]",
          "44:         int confirmed = 0;",
          "45:         char buf[BUFSIZ + 1];",
          "46:         va_list args;",
          "47:         va_start (args, prompt);",
          "49:         VPRINTF(stdout, prompt, args);",
          "50:         fgets (buf, BUFSIZ, stdin);",
          "51:         if (buf[0] == 'y' || buf[0] == 'Y') confirmed = 1;",
          "53:         va_end (args);",
          "55:         return confirmed;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:     if (file->name == NULL)",
          "69:     {",
          "72:     }",
          "74:     if ( file->path == NULL )",
          "75:     {",
          "83:     }",
          "85:     path = concat_fname( directory, file->path );",
          "87:     if (path == NULL)",
          "88:     {",
          "91:     }",
          "93:     debug_print (\"%sWRITING\\t|\\t%s\\t|\\t%s\\n\",",
          "96:     if (!LIST_ONLY)",
          "97:     {",
          "134:     }",
          "136:     if (LIST_ONLY || VERBOSE_ON)",
          "137:     {",
          "150:             fprintf (stdout, \"%s\\t|\\t%s\", file->name, path);",
          "155:             fprintf (stdout, \"\\t|\\t%s\", file->content_id ? file->content_id : \"\");",
          "157:         fprintf (stdout, \"\\n\");",
          "158:     }",
          "159:     XFREE(path);",
          "",
          "[Removed Lines]",
          "70:  file->name = strdup( TNEF_DEFAULT_FILENAME );",
          "71:  debug_print (\"No file name specified, using default %s.\\n\", TNEF_DEFAULT_FILENAME);",
          "76:  file->path = munge_fname( file->name );",
          "78:  if (file->path == NULL)",
          "79:  {",
          "80:      file->path = strdup( TNEF_DEFAULT_FILENAME );",
          "81:      debug_print (\"No path name available, using default %s.\\n\", TNEF_DEFAULT_FILENAME);",
          "82:  }",
          "89:  path = strdup( TNEF_DEFAULT_FILENAME );",
          "90:  debug_print (\"No path generated, using default %s.\\n\", TNEF_DEFAULT_FILENAME);",
          "94:    ((LIST_ONLY==0)?\"\":\"NOT \"), file->name, path);",
          "98:  FILE *fp = NULL;",
          "100:  if (!confirm_action (\"extract %s?\", file->name)) return;",
          "101:  if (!OVERWRITE_FILES)",
          "102:  {",
          "103:      if (file_exists (path))",
          "104:      {",
          "105:   if (!NUMBER_FILES)",
          "106:   {",
          "107:       fprintf (stderr,",
          "108:         \"tnef: %s: Could not create file: File exists\\n\",",
          "109:         path);",
          "110:       return;",
          "111:   }",
          "112:   else",
          "113:   {",
          "114:       char *tmp = find_free_number (path);",
          "115:       debug_print (\"Renaming %s to %s\\n\", path, tmp);",
          "116:       XFREE (path);",
          "117:       path = tmp;",
          "118:   }",
          "119:      }",
          "120:  }",
          "122:  fp = fopen (path, \"wb\");",
          "123:  if (fp == NULL)",
          "124:  {",
          "125:      perror (path);",
          "126:      exit (1);",
          "127:  }",
          "128:  if (fwrite (file->data, 1, file->len, fp) != file->len)",
          "129:  {",
          "130:      perror (path);",
          "131:      exit (1);",
          "132:  }",
          "133:  fclose (fp);",
          "138:  if (LIST_ONLY && VERBOSE_ON)",
          "139:  {",
          "141:      const char *date_str = date_to_str(&file->dt);",
          "142:      fprintf (stdout, \"%11lu\\t|\\t%s\\t|\\t%s\\t|\\t%s\",",
          "143:        (unsigned long)file->len,",
          "145:        file->name,",
          "146:        path);",
          "147:  }",
          "148:  else",
          "149:  {",
          "151:  }",
          "152:  if ( SHOW_MIME )",
          "153:  {",
          "154:      fprintf (stdout, \"\\t|\\t%s\", file->mime_type ? file->mime_type : \"unknown\");",
          "156:  }",
          "",
          "[Added Lines]",
          "70:         file->name = strdup( TNEF_DEFAULT_FILENAME );",
          "71:         debug_print (\"No file name specified, using default %s.\\n\", TNEF_DEFAULT_FILENAME);",
          "76:         file->path = munge_fname( file->name );",
          "78:         if (file->path == NULL)",
          "79:         {",
          "80:             file->path = strdup( TNEF_DEFAULT_FILENAME );",
          "81:             debug_print (\"No path name available, using default %s.\\n\", TNEF_DEFAULT_FILENAME);",
          "82:         }",
          "89:         path = strdup( TNEF_DEFAULT_FILENAME );",
          "90:         debug_print (\"No path generated, using default %s.\\n\", TNEF_DEFAULT_FILENAME);",
          "94:                  ((LIST_ONLY==0)?\"\":\"NOT \"), file->name, path);",
          "98:         FILE *fp = NULL;",
          "100:         if (!confirm_action (\"extract %s?\", file->name)) return;",
          "101:         if (!OVERWRITE_FILES)",
          "102:         {",
          "103:             if (file_exists (path))",
          "104:             {",
          "105:                 if (!NUMBER_FILES)",
          "106:                 {",
          "107:                     fprintf (stderr,",
          "108:                              \"tnef: %s: Could not create file: File exists\\n\",",
          "109:                              path);",
          "110:                     return;",
          "111:                 }",
          "112:                 else",
          "113:                 {",
          "114:                     char *tmp = find_free_number (path);",
          "115:                     debug_print (\"Renaming %s to %s\\n\", path, tmp);",
          "116:                     XFREE (path);",
          "117:                     path = tmp;",
          "118:                 }",
          "119:             }",
          "120:         }",
          "122:         fp = fopen (path, \"wb\");",
          "123:         if (fp == NULL)",
          "124:         {",
          "125:             perror (path);",
          "126:             exit (1);",
          "127:         }",
          "128:         if (fwrite (file->data, 1, file->len, fp) != file->len)",
          "129:         {",
          "130:             perror (path);",
          "131:             exit (1);",
          "132:         }",
          "133:         fclose (fp);",
          "138:         if (LIST_ONLY && VERBOSE_ON)",
          "139:         {",
          "141:             const char *date_str = date_to_str(&file->dt);",
          "142:             fprintf (stdout, \"%11lu\\t|\\t%s\\t|\\t%s\\t|\\t%s\",",
          "143:                      (unsigned long)file->len,",
          "145:                      file->name,",
          "146:                      path);",
          "147:         }",
          "148:         else",
          "149:         {",
          "151:         }",
          "152:         if ( SHOW_MIME )",
          "153:         {",
          "154:             fprintf (stdout, \"\\t|\\t%s\", file->mime_type ? file->mime_type : \"unknown\");",
          "156:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "165:     int i;",
          "166:     for (i = 0; attrs[i]; i++)",
          "167:     {",
          "189:              case MAPI_ATTACH_MIME_TAG:",
          "196:             case MAPI_ATTACH_CONTENT_ID:",
          "197:                 assert(a->type == szMAPI_STRING || a->type == szMAPI_UNICODE_STRING);",
          "",
          "[Removed Lines]",
          "168:  MAPI_Attr* a = attrs[i];",
          "170:  if (a->num_values)",
          "171:  {",
          "173:      switch (a->name)",
          "174:      {",
          "175:      case MAPI_ATTACH_LONG_FILENAME:",
          "176:   assert(a->type == szMAPI_STRING || a->type == szMAPI_UNICODE_STRING);",
          "177:   if (file->name) XFREE(file->name);",
          "178:   file->name = strdup( (char*)a->values[0].data.buf );",
          "179:   break;",
          "181:      case MAPI_ATTACH_DATA_OBJ:",
          "182:   assert((a->type == szMAPI_BINARY) || (a->type == szMAPI_OBJECT));",
          "183:   file->len = a->values[0].len;",
          "184:   if (file->data) XFREE (file->data);",
          "185:   file->data = CHECKED_XMALLOC (unsigned char, file->len);",
          "186:   memmove (file->data, a->values[0].data.buf, file->len);",
          "187:   break;",
          "190:   assert(a->type == szMAPI_STRING || a->type == szMAPI_UNICODE_STRING);",
          "191:   if (file->mime_type) XFREE (file->mime_type);",
          "192:   file->mime_type = CHECKED_XMALLOC (char, a->values[0].len);",
          "193:   memmove (file->mime_type, a->values[0].data.buf, a->values[0].len);",
          "194:   break;",
          "",
          "[Added Lines]",
          "168:         MAPI_Attr* a = attrs[i];",
          "170:         if (a->num_values)",
          "171:         {",
          "173:             switch (a->name)",
          "174:             {",
          "175:             case MAPI_ATTACH_LONG_FILENAME:",
          "176:                 assert(a->type == szMAPI_STRING || a->type == szMAPI_UNICODE_STRING);",
          "177:                 if (file->name) XFREE(file->name);",
          "178:                 file->name = strdup( (char*)a->values[0].data.buf );",
          "179:                 break;",
          "181:             case MAPI_ATTACH_DATA_OBJ:",
          "182:                 assert((a->type == szMAPI_BINARY) || (a->type == szMAPI_OBJECT));",
          "183:                 file->len = a->values[0].len;",
          "184:                 if (file->data) XFREE (file->data);",
          "185:                 file->data = CHECKED_XMALLOC (unsigned char, file->len);",
          "186:                 memmove (file->data, a->values[0].data.buf, file->len);",
          "187:                 break;",
          "190:                 assert(a->type == szMAPI_STRING || a->type == szMAPI_UNICODE_STRING);",
          "191:                 if (file->mime_type) XFREE (file->mime_type);",
          "192:                 file->mime_type = CHECKED_XMALLOC (char, a->values[0].len);",
          "193:                 memmove (file->mime_type, a->values[0].data.buf, a->values[0].len);",
          "194:                 break;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "200:                 memmove (file->content_id, a->values[0].data.buf, a->values[0].len);",
          "201:                 break;",
          "207:     }",
          "208: }",
          "",
          "[Removed Lines]",
          "203:      default:",
          "204:   break;",
          "205:      }",
          "206:  }",
          "",
          "[Added Lines]",
          "203:             default:",
          "204:                 break;",
          "205:             }",
          "206:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "217:     switch (attr->name)",
          "218:     {",
          "219:     case attATTACHMODIFYDATE:",
          "223:     case attATTACHMENT:",
          "224:     {",
          "232:     }",
          "233:     break;",
          "235:     case attATTACHTITLE:",
          "239:     case attATTACHDATA:",
          "245:     default:",
          "247:     }",
          "248: }",
          "",
          "[Removed Lines]",
          "220:  copy_date_from_attr (attr, &file->dt);",
          "221:  break;",
          "225:  MAPI_Attr **mapi_attrs = mapi_attr_read (attr->len, attr->buf);",
          "226:  if (mapi_attrs)",
          "227:  {",
          "228:      file_add_mapi_attrs (file, mapi_attrs);",
          "229:      mapi_attr_free_list (mapi_attrs);",
          "230:      XFREE (mapi_attrs);",
          "231:  }",
          "236:  file->name = strdup( (char*)attr->buf );",
          "237:  break;",
          "240:  file->len = attr->len;",
          "241:  file->data = CHECKED_XMALLOC(unsigned char, attr->len);",
          "242:  memmove (file->data, attr->buf, attr->len);",
          "243:  break;",
          "246:  break;",
          "",
          "[Added Lines]",
          "220:         copy_date_from_attr (attr, &file->dt);",
          "221:         break;",
          "225:         MAPI_Attr **mapi_attrs = mapi_attr_read (attr->len, attr->buf);",
          "226:         if (mapi_attrs)",
          "227:         {",
          "228:             file_add_mapi_attrs (file, mapi_attrs);",
          "229:             mapi_attr_free_list (mapi_attrs);",
          "230:             XFREE (mapi_attrs);",
          "231:         }",
          "236:         file->name = strdup( (char*)attr->buf );",
          "237:         break;",
          "240:         file->len = attr->len;",
          "241:         file->data = CHECKED_XMALLOC(unsigned char, attr->len);",
          "242:         memmove (file->data, attr->buf, attr->len);",
          "243:         break;",
          "246:         break;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "252: {",
          "253:     if (file)",
          "254:     {",
          "258:         XFREE (file->content_id);",
          "259:         XFREE (file->path);",
          "261:     }",
          "262: }",
          "",
          "[Removed Lines]",
          "255:  XFREE (file->name);",
          "256:  XFREE (file->data);",
          "257:  XFREE (file->mime_type);",
          "260:  memset (file, '\\0', sizeof (File));",
          "",
          "[Added Lines]",
          "255:         XFREE (file->name);",
          "256:         XFREE (file->data);",
          "257:         XFREE (file->mime_type);",
          "260:         memset (file, '\\0', sizeof (File));",
          "",
          "---------------"
        ],
        "src/file.h||src/file.h": [
          "File: src/file.h -> src/file.h"
        ],
        "src/main.c||src/main.c": [
          "File: src/main.c -> src/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "251:             }",
          "252:             break;",
          "255:             fprintf (stderr, \"%s\\n\", PACKAGE_STRING);",
          "256:             fprintf (stderr,",
          "257:                      \"Copyright (C) 1999-2017 by Mark Simpson\\n\"",
          "",
          "[Removed Lines]",
          "254:         case 'V':",
          "",
          "[Added Lines]",
          "254:         case 'V':",
          "",
          "---------------"
        ],
        "src/mapi_attr.c||src/mapi_attr.c": [
          "File: src/mapi_attr.c -> src/mapi_attr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:     CHECKINT16(idx, len); guid->data2 = GETINT16(buf + idx); idx += sizeof (uint16);",
          "53:     CHECKINT16(idx, len); guid->data3 = GETINT16(buf + idx); idx += sizeof (uint16);",
          "54:     for (i = 0; i < 8; i++, idx += sizeof (uint8))",
          "56: }",
          "",
          "[Removed Lines]",
          "55:  guid->data4[i] = (uint8)(buf[idx]);",
          "",
          "[Added Lines]",
          "55:         guid->data4[i] = (uint8)(buf[idx]);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65:     size_t i;",
          "67:     fprintf (stdout, \"(MAPI) %s [type: %s] [num_values = %lu] = \\n\",",
          "69:     if (attr->guid)",
          "70:     {",
          "74:     }",
          "76:     for (i = 0; i < attr->num_names; i++)",
          "77:       fprintf (stdout, \"\\tname #%d: '%s'\\n\", (int)i, attr->names[i].data);",
          "79:     for (i = 0; i < attr->num_values; i++)",
          "80:     {",
          "146:     }",
          "148:     fflush( NULL );",
          "",
          "[Removed Lines]",
          "68:       name, type, (unsigned long)attr->num_values);",
          "71:  fprintf (stdout, \"\\tGUID: \");",
          "72:  write_guid (stdout, attr->guid);",
          "73:  fputc ('\\n', stdout);",
          "81:  fprintf (stdout, \"\\t#%lu [len: %lu] = \",",
          "82:    (unsigned long)i,",
          "83:    (unsigned long)attr->values[i].len);",
          "85:  switch (attr->type)",
          "86:  {",
          "87:  case szMAPI_NULL:",
          "88:      fprintf (stdout, \"NULL\");",
          "89:      break;",
          "91:  case szMAPI_SHORT:",
          "92:      write_int16 (stdout, (int16)attr->values[i].data.bytes2);",
          "93:      break;",
          "95:  case szMAPI_INT:",
          "96:      write_int32 (stdout, (int32)attr->values[i].data.bytes4);",
          "97:      break;",
          "99:  case szMAPI_FLOAT:",
          "100:  case szMAPI_DOUBLE:",
          "101:      write_float (stdout, (float)attr->values[i].data.bytes4);",
          "102:      break;",
          "104:  case szMAPI_BOOLEAN:",
          "105:      write_boolean (stdout, attr->values[i].data.bytes4);",
          "106:      break;",
          "108:  case szMAPI_STRING:",
          "109:  case szMAPI_UNICODE_STRING:",
          "110:      write_string (stdout, (char*)attr->values[i].data.buf);",
          "111:      break;",
          "113:  case szMAPI_SYSTIME:",
          "114:  case szMAPI_CURRENCY:",
          "115:  case szMAPI_INT8BYTE:",
          "116:  case szMAPI_APPTIME:",
          "117:      write_uint64 (stdout, attr->values[i].data.bytes8);",
          "118:      break;",
          "120:  case szMAPI_ERROR:",
          "121:      write_uint32 (stdout, attr->values[i].data.bytes4);",
          "122:      break;",
          "124:  case szMAPI_CLSID:",
          "125:      write_guid (stdout, &attr->values[i].data.guid);",
          "126:      break;",
          "128:  case szMAPI_OBJECT:",
          "129:  case szMAPI_BINARY:",
          "130:  {",
          "131:      size_t x;",
          "133:      for (x = 0; x < attr->values[i].len; x++)",
          "134:      {",
          "135:   write_byte (stdout, (uint8)attr->values[i].data.buf[x]);",
          "136:   fputc (' ', stdout);",
          "137:      }",
          "138:  }",
          "139:  break;",
          "141:  default:",
          "142:      fprintf (stdout, \"<unknown type>\");",
          "143:      break;",
          "144:  }",
          "145:  fprintf (stdout, \"\\n\");",
          "",
          "[Added Lines]",
          "68:              name, type, (unsigned long)attr->num_values);",
          "71:         fprintf (stdout, \"\\tGUID: \");",
          "72:         write_guid (stdout, attr->guid);",
          "73:         fputc ('\\n', stdout);",
          "81:         fprintf (stdout, \"\\t#%lu [len: %lu] = \",",
          "82:                  (unsigned long)i,",
          "83:                  (unsigned long)attr->values[i].len);",
          "85:         switch (attr->type)",
          "86:         {",
          "87:         case szMAPI_NULL:",
          "88:             fprintf (stdout, \"NULL\");",
          "89:             break;",
          "91:         case szMAPI_SHORT:",
          "92:             write_int16 (stdout, (int16)attr->values[i].data.bytes2);",
          "93:             break;",
          "95:         case szMAPI_INT:",
          "96:             write_int32 (stdout, (int32)attr->values[i].data.bytes4);",
          "97:             break;",
          "99:         case szMAPI_FLOAT:",
          "100:         case szMAPI_DOUBLE:",
          "101:             write_float (stdout, (float)attr->values[i].data.bytes4);",
          "102:             break;",
          "104:         case szMAPI_BOOLEAN:",
          "105:             write_boolean (stdout, attr->values[i].data.bytes4);",
          "106:             break;",
          "108:         case szMAPI_STRING:",
          "109:         case szMAPI_UNICODE_STRING:",
          "110:             write_string (stdout, (char*)attr->values[i].data.buf);",
          "111:             break;",
          "113:         case szMAPI_SYSTIME:",
          "114:         case szMAPI_CURRENCY:",
          "115:         case szMAPI_INT8BYTE:",
          "116:         case szMAPI_APPTIME:",
          "117:             write_uint64 (stdout, attr->values[i].data.bytes8);",
          "118:             break;",
          "120:         case szMAPI_ERROR:",
          "121:             write_uint32 (stdout, attr->values[i].data.bytes4);",
          "122:             break;",
          "124:         case szMAPI_CLSID:",
          "125:             write_guid (stdout, &attr->values[i].data.guid);",
          "126:             break;",
          "128:         case szMAPI_OBJECT:",
          "129:         case szMAPI_BINARY:",
          "130:         {",
          "131:             size_t x;",
          "133:             for (x = 0; x < attr->values[i].len; x++)",
          "134:             {",
          "135:                 write_byte (stdout, (uint8)attr->values[i].data.buf[x]);",
          "136:                 fputc (' ', stdout);",
          "137:             }",
          "138:         }",
          "139:         break;",
          "141:         default:",
          "142:             fprintf (stdout, \"<unknown type>\");",
          "143:             break;",
          "144:         }",
          "145:         fprintf (stdout, \"\\n\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "153: {",
          "154:     if (a && a->num_values)",
          "155:     {",
          "158:     }",
          "159:     return NULL;",
          "160: }",
          "",
          "[Removed Lines]",
          "156:  a->values = CHECKED_XCALLOC (MAPI_Value, a->num_values);",
          "157:  return a->values;",
          "",
          "[Added Lines]",
          "156:         a->values = CHECKED_XCALLOC (MAPI_Value, a->num_values);",
          "157:         return a->values;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "183:     if (!attrs) return NULL;",
          "184:     for (i = 0; i < num_properties; i++)",
          "185:     {",
          "215:                     assert(a->names[i].len != 0);",
          "216:                     assert(idx+a->names[i].len <= len);",
          "242:         else",
          "243:         {",
          "245:         }",
          "346:     }",
          "347:     attrs[i] = NULL;",
          "",
          "[Removed Lines]",
          "186:  MAPI_Attr* a = attrs[i] = CHECKED_XCALLOC(MAPI_Attr, 1);",
          "187:  MAPI_Value* v = NULL;",
          "189:  CHECKINT16(idx, len); a->type = GETINT16(buf+idx); idx += 2;",
          "190:  CHECKINT16(idx, len); a->name = GETINT16(buf+idx); idx += 2;",
          "193:  if (a->name & GUID_EXISTS_FLAG)",
          "194:  {",
          "196:      a->guid = CHECKED_XMALLOC(GUID, 1);",
          "197:      copy_guid_from_buf(a->guid, buf+idx, len-idx);",
          "198:      idx += sizeof (GUID);",
          "200:      CHECKINT32(idx, len); a->num_names = GETINT32(buf+idx); idx += 4;",
          "201:      if (a->num_names > 0)",
          "202:      {",
          "203:   size_t i;",
          "205:   a->names = CHECKED_XCALLOC(VarLenData, a->num_names);",
          "206:   assert(a->names);",
          "207:   for (i = 0; i < a->num_names; i++)",
          "208:   {",
          "209:       size_t j;",
          "211:       CHECKINT32(idx, len); a->names[i].len = GETINT32(buf+idx); idx += 4;",
          "217:       a->names[i].data = unicode_to_utf8(a->names[i].len, buf+idx);",
          "219:       idx += pad_to_4byte(a->names[i].len);",
          "220:   }",
          "221:      }",
          "222:      else",
          "223:      {",
          "225:   CHECKINT32(idx, len); a->name = GETINT32(buf+idx); idx+= 4;",
          "226:      }",
          "227:  }",
          "233:  if (a->type & MULTI_VALUE_FLAG ||",
          "234:      a->type == szMAPI_STRING ||",
          "235:      a->type == szMAPI_UNICODE_STRING ||",
          "236:      a->type == szMAPI_OBJECT ||",
          "237:      a->type == szMAPI_BINARY)",
          "238:  {",
          "239:      CHECKINT32(idx, len); a->num_values = GETINT32(buf+idx);",
          "240:      idx += 4;",
          "241:  }",
          "244:      a->num_values = 1;",
          "248:  if (a->type & MULTI_VALUE_FLAG)",
          "249:  {",
          "250:      a->type -= MULTI_VALUE_FLAG;",
          "251:  }",
          "254:  v = alloc_mapi_values (a);",
          "255:  assert(v);",
          "256:  for (j = 0; j < a->num_values; j++)",
          "257:  {",
          "258:      switch (a->type)",
          "259:      {",
          "261:   v->len = 2;",
          "262:   CHECKINT16(idx, len); v->data.bytes2 = GETINT16(buf+idx);",
          "264:   break;",
          "267:   v->len = 4;",
          "268:   CHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);",
          "269:   idx += 4;",
          "270:   v++;",
          "271:   break;",
          "275:   v->len = 4;",
          "276:   CHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);",
          "277:   idx += v->len;",
          "278:   break;",
          "281:   v->len = 8;",
          "282:   CHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);",
          "283:   CHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);",
          "284:   idx += 8;",
          "285:   v++;",
          "286:   break;",
          "289:      case szMAPI_APPTIME:",
          "290:      case szMAPI_CURRENCY:",
          "291:      case szMAPI_INT8BYTE:",
          "292:   v->len = 8;",
          "293:   CHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);",
          "294:   CHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);",
          "295:   idx += v->len;",
          "296:   break;",
          "298:      case szMAPI_CLSID:",
          "299:   v->len = sizeof (GUID);",
          "300:   copy_guid_from_buf(&v->data.guid, buf+idx, len-idx);",
          "301:   idx += v->len;",
          "302:   break;",
          "304:      case szMAPI_STRING:",
          "305:      case szMAPI_UNICODE_STRING:",
          "306:      case szMAPI_OBJECT:",
          "307:      case szMAPI_BINARY:",
          "308:   CHECKINT32(idx, len); v->len = GETINT32(buf+idx); idx += 4;",
          "310:   assert(v->len + idx <= len);",
          "312:   if (a->type == szMAPI_UNICODE_STRING)",
          "313:   {",
          "314:       assert(v->len != 0);",
          "315:       v->data.buf = (unsigned char*)unicode_to_utf8(v->len, buf+idx);",
          "316:   }",
          "317:   else",
          "318:   {",
          "319:       v->data.buf = CHECKED_XMALLOC(unsigned char, v->len);",
          "320:       memmove (v->data.buf, buf+idx, v->len);",
          "321:   }",
          "323:   idx += pad_to_4byte(v->len);",
          "324:   v++;",
          "325:   break;",
          "328:      case szMAPI_ERROR:",
          "329:      case szMAPI_UNSPECIFIED:",
          "330:   fprintf (stderr,",
          "331:     \"Invalid attribute, input file may be corrupted\\n\");",
          "332:   if (!ENCODE_SKIP) exit (1);",
          "334:   return NULL;",
          "337:   fprintf (stderr,",
          "338:     \"Undefined attribute, input file may be corrupted\\n\");",
          "339:   if (!ENCODE_SKIP) exit (1);",
          "341:   return NULL;",
          "343:      }",
          "344:      if (DEBUG_ON) mapi_attr_dump (attrs[i]);",
          "345:  }",
          "",
          "[Added Lines]",
          "186:         MAPI_Attr* a = attrs[i] = CHECKED_XCALLOC(MAPI_Attr, 1);",
          "187:         MAPI_Value* v = NULL;",
          "189:         CHECKINT16(idx, len); a->type = GETINT16(buf+idx); idx += 2;",
          "190:         CHECKINT16(idx, len); a->name = GETINT16(buf+idx); idx += 2;",
          "193:         if (a->name & GUID_EXISTS_FLAG)",
          "194:         {",
          "196:             a->guid = CHECKED_XMALLOC(GUID, 1);",
          "197:             copy_guid_from_buf(a->guid, buf+idx, len-idx);",
          "198:             idx += sizeof (GUID);",
          "200:             CHECKINT32(idx, len); a->num_names = GETINT32(buf+idx); idx += 4;",
          "201:             if (a->num_names > 0)",
          "202:             {",
          "203:                 size_t i;",
          "205:                 a->names = CHECKED_XCALLOC(VarLenData, a->num_names);",
          "206:                 assert(a->names);",
          "207:                 for (i = 0; i < a->num_names; i++)",
          "208:                 {",
          "209:                     size_t j;",
          "211:                     CHECKINT32(idx, len); a->names[i].len = GETINT32(buf+idx); idx += 4;",
          "217:                     a->names[i].data = unicode_to_utf8(a->names[i].len, buf+idx);",
          "219:                     idx += pad_to_4byte(a->names[i].len);",
          "220:                 }",
          "221:             }",
          "222:             else",
          "223:             {",
          "225:                 CHECKINT32(idx, len); a->name = GETINT32(buf+idx); idx+= 4;",
          "226:             }",
          "227:         }",
          "233:         if (a->type & MULTI_VALUE_FLAG ||",
          "234:             a->type == szMAPI_STRING ||",
          "235:             a->type == szMAPI_UNICODE_STRING ||",
          "236:             a->type == szMAPI_OBJECT ||",
          "237:             a->type == szMAPI_BINARY)",
          "238:         {",
          "239:             CHECKINT32(idx, len); a->num_values = GETINT32(buf+idx);",
          "240:             idx += 4;",
          "241:         }",
          "244:             a->num_values = 1;",
          "245:         }",
          "248:         if (a->type & MULTI_VALUE_FLAG)",
          "249:         {",
          "250:             a->type -= MULTI_VALUE_FLAG;",
          "254:         v = alloc_mapi_values (a);",
          "255:         assert(v);",
          "256:         for (j = 0; j < a->num_values; j++)",
          "257:         {",
          "258:             switch (a->type)",
          "259:             {",
          "261:                 v->len = 2;",
          "262:                 CHECKINT16(idx, len); v->data.bytes2 = GETINT16(buf+idx);",
          "264:                 break;",
          "267:                 v->len = 4;",
          "268:                 CHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);",
          "269:                 idx += 4;",
          "270:                 v++;",
          "271:                 break;",
          "275:                 v->len = 4;",
          "276:                 CHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);",
          "277:                 idx += v->len;",
          "278:                 break;",
          "281:                 v->len = 8;",
          "282:                 CHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);",
          "283:                 CHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);",
          "284:                 idx += 8;",
          "285:                 v++;",
          "286:                 break;",
          "289:             case szMAPI_APPTIME:",
          "290:             case szMAPI_CURRENCY:",
          "291:             case szMAPI_INT8BYTE:",
          "292:                 v->len = 8;",
          "293:                 CHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);",
          "294:                 CHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);",
          "295:                 idx += v->len;",
          "296:                 break;",
          "298:             case szMAPI_CLSID:",
          "299:                 v->len = sizeof (GUID);",
          "300:                 copy_guid_from_buf(&v->data.guid, buf+idx, len-idx);",
          "301:                 idx += v->len;",
          "302:                 break;",
          "304:             case szMAPI_STRING:",
          "305:             case szMAPI_UNICODE_STRING:",
          "306:             case szMAPI_OBJECT:",
          "307:             case szMAPI_BINARY:",
          "308:                 CHECKINT32(idx, len); v->len = GETINT32(buf+idx); idx += 4;",
          "310:                 assert(v->len + idx <= len);",
          "312:                 if (a->type == szMAPI_UNICODE_STRING)",
          "313:                 {",
          "314:                     assert(v->len != 0);",
          "315:                     v->data.buf = (unsigned char*)unicode_to_utf8(v->len, buf+idx);",
          "316:                 }",
          "317:                 else",
          "318:                 {",
          "319:                     v->data.buf = CHECKED_XMALLOC(unsigned char, v->len);",
          "320:                     memmove (v->data.buf, buf+idx, v->len);",
          "321:                 }",
          "323:                 idx += pad_to_4byte(v->len);",
          "324:                 v++;",
          "325:                 break;",
          "328:             case szMAPI_ERROR:",
          "329:             case szMAPI_UNSPECIFIED:",
          "330:                 fprintf (stderr,",
          "331:                          \"Invalid attribute, input file may be corrupted\\n\");",
          "332:                 if (!ENCODE_SKIP) exit (1);",
          "334:                 return NULL;",
          "337:                 fprintf (stderr,",
          "338:                          \"Undefined attribute, input file may be corrupted\\n\");",
          "339:                 if (!ENCODE_SKIP) exit (1);",
          "341:                 return NULL;",
          "343:             }",
          "344:             if (DEBUG_ON) mapi_attr_dump (attrs[i]);",
          "345:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "354: {",
          "355:     if (attr)",
          "356:     {",
          "367:         if (attr->num_names > 0) {",
          "368:             for (i = 0; i < attr->num_names; i++)",
          "369:             {",
          "",
          "[Removed Lines]",
          "357:  size_t i;",
          "358:  for (i = 0; i < attr->num_values; i++)",
          "359:  {",
          "360:      if ((attr->type == szMAPI_STRING)",
          "361:   || (attr->type == szMAPI_UNICODE_STRING)",
          "362:   || (attr->type == szMAPI_BINARY))",
          "363:      {",
          "364:   XFREE (attr->values[i].data.buf);",
          "365:      }",
          "366:  }",
          "",
          "[Added Lines]",
          "357:         size_t i;",
          "358:         for (i = 0; i < attr->num_values; i++)",
          "359:         {",
          "360:             if ((attr->type == szMAPI_STRING)",
          "361:                 || (attr->type == szMAPI_UNICODE_STRING)",
          "362:                 || (attr->type == szMAPI_BINARY))",
          "363:             {",
          "364:                 XFREE (attr->values[i].data.buf);",
          "365:             }",
          "366:         }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "371:             }",
          "372:             XFREE(attr->names);",
          "373:         }",
          "377:     }",
          "378: }",
          "",
          "[Removed Lines]",
          "374:  XFREE (attr->values);",
          "375:  XFREE (attr->guid);",
          "376:  memset (attr, '\\0', sizeof (MAPI_Attr));",
          "",
          "[Added Lines]",
          "374:         XFREE (attr->values);",
          "375:         XFREE (attr->guid);",
          "376:         memset (attr, '\\0', sizeof (MAPI_Attr));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "383:     int i;",
          "384:     for (i = 0; attrs && attrs[i]; i++)",
          "385:     {",
          "388:     }",
          "389: }",
          "",
          "[Removed Lines]",
          "386:  mapi_attr_free (attrs[i]);",
          "387:  XFREE (attrs[i]);",
          "",
          "[Added Lines]",
          "386:         mapi_attr_free (attrs[i]);",
          "387:         XFREE (attrs[i]);",
          "",
          "---------------"
        ],
        "src/mapi_attr.h||src/mapi_attr.h": [
          "File: src/mapi_attr.h -> src/mapi_attr.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:     size_t len;",
          "48:     union",
          "49:     {",
          "55:     } data;",
          "56: } MAPI_Value;",
          "",
          "[Removed Lines]",
          "50:  unsigned char *buf;",
          "51:  uint16 bytes2;",
          "52:  uint32 bytes4;",
          "53:  uint32 bytes8[2];",
          "54:  GUID guid;",
          "",
          "[Added Lines]",
          "50:         unsigned char *buf;",
          "51:         uint16 bytes2;",
          "52:         uint32 bytes4;",
          "53:         uint32 bytes8[2];",
          "54:         GUID guid;",
          "",
          "---------------"
        ],
        "src/mkdata.awk||src/mkdata.awk": [
          "File: src/mkdata.awk -> src/mkdata.awk",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: # mkdata.awk - used to generate blah.[ch] from blah.data",
          "2: #",
          "4: #",
          "5: # This program is free software; you can redistribute it and/or modify",
          "6: # it under the terms of the GNU General Public License as published by",
          "",
          "[Removed Lines]",
          "3: # Copyright (C)1999-2006 Mark Simpson <damned@world.std.com>",
          "",
          "[Added Lines]",
          "3: # Copyright (C)1999-2018 Mark Simpson <damned@world.std.com>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "27: #",
          "28: # Print headers and such.",
          "30: BEGIN {",
          "31:     HFILE = sprintf (\"%ss.h\", ENVIRON[\"TAG\"]);",
          "32:     HFILEDEF = HFILE;",
          "",
          "[Removed Lines]",
          "29: #",
          "",
          "[Added Lines]",
          "29: #",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "59:    NAME = \"\"",
          "60:    for (i = 3; i < NF + 1; i=i+1) {",
          "61:        if ( NAME ) {",
          "63:        } else {",
          "65:        }",
          "66:    }",
          "68: #   printf \"#define %-10s\\t%s\\t/* %s */\\n\", $1, $2, NAME          > HFILE;",
          "69:    printf \"\\t%-45s = %s,\\n\", $1, $2 > HFILE",
          "",
          "[Removed Lines]",
          "62:     NAME = sprintf (\"%s %s\", NAME, $(i))",
          "64:     NAME = $(i)",
          "",
          "[Added Lines]",
          "62:            NAME = sprintf (\"%s %s\", NAME, $(i))",
          "64:            NAME = $(i)",
          "",
          "---------------"
        ],
        "src/options.c||src/options.c": [
          "File: src/options.c -> src/options.c"
        ],
        "src/options.h||src/options.h": [
          "File: src/options.h -> src/options.h"
        ],
        "src/path.c||src/path.c": [
          "File: src/path.c -> src/path.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "74:     while ((len=strlen(filename)) > 0)",
          "75:     {",
          "84:     }",
          "",
          "[Removed Lines]",
          "76:  if ( filename[len-1] == '/' )",
          "77:  {",
          "78:      filename[len-1] = '\\0';",
          "79:  }",
          "80:  else",
          "81:  {",
          "82:      break;",
          "83:  }",
          "",
          "[Added Lines]",
          "76:         if ( filename[len-1] == '/' )",
          "77:         {",
          "78:             filename[len-1] = '\\0';",
          "79:         }",
          "80:         else",
          "81:         {",
          "82:             break;",
          "83:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100: char *",
          "101: find_free_number (const char *fname)",
          "102: {",
          "107:     char *tmp = CHECKED_XMALLOC (char, len);",
          "108:     int counter = 1;",
          "109:     do",
          "110:     {",
          "112:     }",
          "113:     while (file_exists(tmp));",
          "114:     return tmp;",
          "",
          "[Removed Lines]",
          "103:     size_t len = (strlen(fname)",
          "111:  sprintf (tmp, \"%s.%d\", fname, counter++);",
          "",
          "[Added Lines]",
          "103:     size_t len = (strlen(fname)",
          "111:         sprintf (tmp, \"%s.%d\", fname, counter++);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "121: static char unsanitary_windows_chars[] = {",
          "123: };",
          "127: static char unsavory_unix_chars[] = {",
          "129: };",
          "131: static int",
          "",
          "[Removed Lines]",
          "122:  '\\\\', '/', ':', '*', '?', '\"', '<', '>', '|', '\\0'",
          "128:  ' ', ';', '`', '\\'', '[', ']', '{', '}', '(', ')', '\\0'",
          "",
          "[Added Lines]",
          "122:         '\\\\', '/', ':', '*', '?', '\"', '<', '>', '|', '\\0'",
          "128:         ' ', ';', '`', '\\'', '[', ']', '{', '}', '(', ')', '\\0'",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "136:     if ( ( fname == NULL ) || ( *fname == '\\0' ) ) return 0;",
          "145:     up = rindex( fname, '\\\\' );",
          "147:     if ( up )",
          "148:     {",
          "151:     }",
          "152:     else",
          "153:     {",
          "155:     }",
          "157:     for ( up=unsanitary_windows_chars; *up; up++ )",
          "158:     {",
          "165:     }",
          "167:     for ( up=fname; *up; up++ )",
          "168:     {",
          "173:     }",
          "",
          "[Removed Lines]",
          "139:  we might be a windows path if...",
          "140:  we have at least one path separator and",
          "141:  we have no unsanitary windows chars and",
          "142:  we are reasonably printable",
          "149:  up++;",
          "161:  if ( index( fname, (int)*up ) )",
          "162:  {",
          "164:  }",
          "169:  if ( iscntrl( (int)*up ) )",
          "170:  {",
          "172:  }",
          "",
          "[Added Lines]",
          "139:         we might be a windows path if...",
          "140:         we have at least one path separator and",
          "141:         we have no unsanitary windows chars and",
          "142:         we are reasonably printable",
          "149:         up++;",
          "161:         if ( index( fname, (int)*up ) )",
          "162:         {",
          "164:         }",
          "169:         if ( iscntrl( (int)*up ) )",
          "170:         {",
          "172:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "180: }",
          "182: static unsigned char hex_digits[16] = {",
          "185: };",
          "",
          "[Removed Lines]",
          "183:  '0', '1', '2', '3', '4', '5', '6', '7',",
          "184:  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'",
          "",
          "[Added Lines]",
          "183:         '0', '1', '2', '3', '4', '5', '6', '7',",
          "184:         '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "196:     if ( ( fname == NULL ) || ( *fname == '\\0' ) )",
          "197:     {",
          "201:     }",
          "209:     buf = CHECKED_XCALLOC( char, 3*strlen(fname)+SLOP );",
          "",
          "[Removed Lines]",
          "199:  buf = CHECKED_XCALLOC( char, SLOP );",
          "200:  return buf;",
          "204:  sanitize the filename by modifying unsanitary or unsavory",
          "205:  characters using the URL escape technique of c => %XX",
          "206:  return a \"fresh and freeable\" buffer with the sanitary filename",
          "",
          "[Added Lines]",
          "199:         buf = CHECKED_XCALLOC( char, SLOP );",
          "200:         return buf;",
          "204:         sanitize the filename by modifying unsanitary or unsavory",
          "205:         characters using the URL escape technique of c => %XX",
          "206:         return a \"fresh and freeable\" buffer with the sanitary filename",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "212:     for ( cp=fname; *cp; cp++ )",
          "213:     {",
          "291:     }",
          "293:     return buf;",
          "",
          "[Removed Lines]",
          "214:  flag = 0;",
          "216:  while (1)",
          "217:  {",
          "220:      if ( iscntrl( (int)*cp ) )",
          "221:      {",
          "222:   stet = 0;",
          "223:   break;",
          "224:      }",
          "228:      for ( up=unsanitary_windows_chars; *up; up++ )",
          "229:      {",
          "230:   if ( *cp == *up )",
          "231:   {",
          "232:       flag = 1;",
          "233:       stet = 0;",
          "235:   }",
          "236:      }",
          "240:      if ( UNIX_FS )",
          "241:      {",
          "244:   if ( !isascii( (int)*cp ) )",
          "245:   {",
          "246:       stet = 0;",
          "247:       break;",
          "248:   }",
          "252:   for ( up=unsavory_unix_chars; *up; up++ )",
          "253:   {",
          "254:       if ( *cp == *up )",
          "255:       {",
          "256:    flag = 1;",
          "257:    stet = 0;",
          "259:       }",
          "260:   }",
          "263:      }",
          "267:      if ( *cp == '%' )",
          "268:      {",
          "269:   stet = 0;",
          "270:   break;",
          "271:      }",
          "275:      stet = 1;",
          "276:      break;",
          "277:  }",
          "281:  if ( stet )",
          "282:  {",
          "284:  }",
          "285:  else",
          "286:  {",
          "290:  }",
          "",
          "[Added Lines]",
          "214:         flag = 0;",
          "216:         while (1)",
          "217:         {",
          "220:             if ( iscntrl( (int)*cp ) )",
          "221:             {",
          "222:                 stet = 0;",
          "223:                 break;",
          "224:             }",
          "228:             for ( up=unsanitary_windows_chars; *up; up++ )",
          "229:             {",
          "230:                 if ( *cp == *up )",
          "231:                 {",
          "232:                     flag = 1;",
          "233:                     stet = 0;",
          "235:                 }",
          "236:             }",
          "240:             if ( UNIX_FS )",
          "241:             {",
          "244:                 if ( !isascii( (int)*cp ) )",
          "245:                 {",
          "246:                     stet = 0;",
          "247:                     break;",
          "248:                 }",
          "252:                 for ( up=unsavory_unix_chars; *up; up++ )",
          "253:                 {",
          "254:                     if ( *cp == *up )",
          "255:                     {",
          "256:                         flag = 1;",
          "257:                         stet = 0;",
          "259:                     }",
          "260:                 }",
          "263:             }",
          "267:             if ( *cp == '%' )",
          "268:             {",
          "269:                 stet = 0;",
          "270:                 break;",
          "271:             }",
          "275:             stet = 1;",
          "276:             break;",
          "277:         }",
          "281:         if ( stet )",
          "282:         {",
          "284:         }",
          "285:         else",
          "286:         {",
          "290:         }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "316:     if ( USE_PATHS )",
          "317:     {",
          "367:     }",
          "368:     else",
          "369:     {",
          "374:     }",
          "",
          "[Removed Lines]",
          "320:  if ( could_be_a_windows_path( (char *)fname ) )",
          "321:  {",
          "324:      dir =  strdup( fname ); fpd = dir;",
          "325:      base = rindex( dir, (int)'\\\\' );",
          "326:      base++;",
          "329:      base = strdup( fname ); fpb = base;",
          "330:      base = rindex( base, (int)'\\\\' );",
          "331:      base++;",
          "335:      for ( p=dir; *p; p++ )",
          "336:      {",
          "337:   if ( *p == '\\\\' ) *p = '/';",
          "338:      }",
          "342:      if ( *dir == '/' )",
          "343:      {",
          "344:   if ( ABSOLUTE_OK )",
          "345:   {",
          "346:       if (VERBOSE_ON) debug_print( \"WARNING: absolute path: %s\", fname );",
          "347:       if (DEBUG_ON) debug_print( \"!!absolute path: %s\", fname );",
          "348:   }",
          "349:   else",
          "350:   {",
          "351:       if (VERBOSE_ON) debug_print( \"WARNING: absolute path stripped: %s\", fname );",
          "352:       if (DEBUG_ON) debug_print( \"!!absolute path stripped: %s\", fname );",
          "354:       while ( *dir == '/' ) dir++;",
          "357:   }",
          "358:      }",
          "359:  }",
          "360:  else",
          "361:  {",
          "364:      dir = NULL;   fpd = NULL;",
          "365:      base = strdup( fname ); fpb = base;",
          "366:  }",
          "372:  dir = NULL;   fpd = NULL;",
          "373:  base = strdup( fname );  fpb = base;",
          "",
          "[Added Lines]",
          "320:         if ( could_be_a_windows_path( (char *)fname ) )",
          "321:         {",
          "324:             dir =  strdup( fname ); fpd = dir;",
          "325:             base = rindex( dir, (int)'\\\\' );",
          "326:             base++;",
          "329:             base = strdup( fname ); fpb = base;",
          "330:             base = rindex( base, (int)'\\\\' );",
          "331:             base++;",
          "335:             for ( p=dir; *p; p++ )",
          "336:             {",
          "337:                 if ( *p == '\\\\' ) *p = '/';",
          "338:             }",
          "342:             if ( *dir == '/' )",
          "343:             {",
          "344:                 if ( ABSOLUTE_OK )",
          "345:                 {",
          "346:                     if (VERBOSE_ON) debug_print( \"WARNING: absolute path: %s\", fname );",
          "347:                     if (DEBUG_ON) debug_print( \"!!absolute path: %s\", fname );",
          "348:                 }",
          "349:                 else",
          "350:                 {",
          "351:                     if (VERBOSE_ON) debug_print( \"WARNING: absolute path stripped: %s\", fname );",
          "352:                     if (DEBUG_ON) debug_print( \"!!absolute path stripped: %s\", fname );",
          "354:                     while ( *dir == '/' ) dir++;",
          "357:                 }",
          "358:             }",
          "359:         }",
          "360:         else",
          "361:         {",
          "364:             dir = NULL;   fpd = NULL;",
          "365:             base = strdup( fname ); fpb = base;",
          "366:         }",
          "372:         dir = NULL;   fpd = NULL;",
          "373:         base = strdup( fname );  fpb = base;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "390:     if ( p && ( *p == '\\0' ) )",
          "391:     {",
          "394:     }",
          "396:     return p;",
          "",
          "[Removed Lines]",
          "393:  p = NULL;",
          "",
          "[Added Lines]",
          "393:         p = NULL;",
          "",
          "---------------"
        ],
        "src/path.h||src/path.h": [
          "File: src/path.h -> src/path.h"
        ],
        "src/replace/basename.c||src/replace/basename.c": [
          "File: src/replace/basename.c -> src/replace/basename.c"
        ],
        "src/replace/malloc.c||src/replace/malloc.c": [
          "File: src/replace/malloc.c -> src/replace/malloc.c"
        ],
        "src/replace/strdup.c||src/replace/strdup.c": [
          "File: src/replace/strdup.c -> src/replace/strdup.c"
        ],
        "src/rtf.c||src/rtf.c": [
          "File: src/rtf.c -> src/rtf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "52: static uint32 crc_table[256] =",
          "53: {",
          "133: };",
          "135: static uint32",
          "",
          "[Removed Lines]",
          "54:  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,",
          "55:  0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,",
          "56:  0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,",
          "57:  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,",
          "59:  0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,",
          "60:  0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,",
          "61:  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,",
          "62:  0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,",
          "64:  0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,",
          "65:  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,",
          "66:  0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,",
          "67:  0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,",
          "69:  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,",
          "70:  0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,",
          "71:  0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,",
          "72:  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,",
          "74:  0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,",
          "75:  0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,",
          "76:  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,",
          "77:  0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,",
          "79:  0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,",
          "80:  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,",
          "81:  0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,",
          "82:  0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,",
          "84:  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,",
          "85:  0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,",
          "86:  0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,",
          "87:  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,",
          "89:  0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,",
          "90:  0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,",
          "91:  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,",
          "92:  0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,",
          "94:  0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,",
          "95:  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,",
          "96:  0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,",
          "97:  0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,",
          "99:  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,",
          "100:  0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,",
          "101:  0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,",
          "102:  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,",
          "104:  0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,",
          "105:  0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,",
          "106:  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,",
          "107:  0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,",
          "109:  0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,",
          "110:  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,",
          "111:  0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,",
          "112:  0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,",
          "114:  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,",
          "115:  0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,",
          "116:  0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,",
          "117:  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,",
          "119:  0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,",
          "120:  0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,",
          "121:  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,",
          "122:  0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,",
          "124:  0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,",
          "125:  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,",
          "126:  0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,",
          "127:  0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,",
          "129:  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,",
          "130:  0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,",
          "131:  0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,",
          "132:  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d",
          "",
          "[Added Lines]",
          "54:         0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,",
          "55:         0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,",
          "56:         0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,",
          "57:         0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,",
          "59:         0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,",
          "60:         0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,",
          "61:         0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,",
          "62:         0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,",
          "64:         0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,",
          "65:         0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,",
          "66:         0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,",
          "67:         0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,",
          "69:         0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,",
          "70:         0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,",
          "71:         0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,",
          "72:         0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,",
          "74:         0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,",
          "75:         0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,",
          "76:         0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,",
          "77:         0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,",
          "79:         0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,",
          "80:         0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,",
          "81:         0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,",
          "82:         0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,",
          "84:         0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,",
          "85:         0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,",
          "86:         0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,",
          "87:         0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,",
          "89:         0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,",
          "90:         0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,",
          "91:         0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,",
          "92:         0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,",
          "94:         0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,",
          "95:         0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,",
          "96:         0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,",
          "97:         0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,",
          "99:         0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,",
          "100:         0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,",
          "101:         0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,",
          "102:         0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,",
          "104:         0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,",
          "105:         0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,",
          "106:         0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,",
          "107:         0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,",
          "109:         0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,",
          "110:         0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,",
          "111:         0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,",
          "112:         0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,",
          "114:         0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,",
          "115:         0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,",
          "116:         0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,",
          "117:         0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,",
          "119:         0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,",
          "120:         0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,",
          "121:         0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,",
          "122:         0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,",
          "124:         0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,",
          "125:         0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,",
          "126:         0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,",
          "127:         0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,",
          "129:         0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,",
          "130:         0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,",
          "131:         0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,",
          "132:         0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "142:     for ( i=0; i<len; i++ )",
          "143:     {",
          "147:     }",
          "149:     return crc;",
          "",
          "[Removed Lines]",
          "144:  c = data[i];",
          "145:  j = ( crc ^ (uint32)c ) & 0xff;",
          "146:  crc = crc_table[j] ^ ( crc>>8 );",
          "",
          "[Added Lines]",
          "144:         c = data[i];",
          "145:         j = ( crc ^ (uint32)c ) & 0xff;",
          "146:         crc = crc_table[j] ^ ( crc>>8 );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "161:     uncompr_size = GETINT32(data + idx); idx += 4;",
          "162:     magic = GETINT32(data + idx); idx += 4;",
          "167:     return 0;",
          "168: }",
          "",
          "[Removed Lines]",
          "164:     if ((magic == rtf_uncompressed_magic)",
          "165:  || (magic == rtf_compressed_magic))",
          "166:  return 1;",
          "",
          "[Added Lines]",
          "164:     if ((magic == rtf_uncompressed_magic)",
          "165:         || (magic == rtf_compressed_magic))",
          "166:         return 1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "205:     while (1)",
          "206:     {",
          "221:         for ( i=0; i<8; i++ )",
          "222:         {",
          "292:     }",
          "294:     if ( endflag < 0 )",
          "295:     {",
          "297:     }",
          "299:     return dest;",
          "300: }",
          "302: static void",
          "305: {",
          "306:     size_t compr_size = 0L;",
          "307:     size_t uncompr_size = 0L;",
          "",
          "[Removed Lines]",
          "207:  if ( endflag ) break;",
          "211:  if ( cin+1 > lenc )",
          "212:  {",
          "213:      endflag = -1;",
          "215:  }",
          "217:  control = (int)src[cin++];",
          "223:      if ( endflag ) break;",
          "225:      if ( control & (1<<i) )",
          "226:      {",
          "229:   if ( cin+2 > lenc )",
          "230:   {",
          "231:       endflag = -1;",
          "233:   }",
          "235:   roff = (int)src[cin++];",
          "236:   rlen = (int)src[cin++];",
          "238:   roff = (roff<<4) + (rlen>>4);",
          "239:   rlen = (rlen&0x0f) + 2;",
          "243:   if ( roff == woff )",
          "244:   {",
          "245:       endflag = 1;",
          "247:   }",
          "251:   if ( cout+rlen > lenu )",
          "252:   {",
          "253:       endflag = -1;",
          "255:   }",
          "257:   for ( j=0; j<rlen; j++ )",
          "258:   {",
          "259:       dest[cout++] = dict[roff];",
          "260:       dict[woff++] = dict[roff++];",
          "262:       roff &= 0xfff;",
          "263:       woff &= 0xfff;",
          "264:       if ( eoff < 4096 ) eoff++;",
          "265:   }",
          "266:      }",
          "267:      else",
          "268:      {",
          "271:   if ( cin+1 > lenc )",
          "272:   {",
          "273:       endflag = -1;",
          "275:   }",
          "277:   if ( cout+1 > lenu )",
          "278:   {",
          "279:       endflag = -1;",
          "281:   }",
          "285:   dest[cout++] = src[cin];",
          "286:   dict[woff++] = src[cin++];",
          "288:   woff &= 0xfff;",
          "289:   if ( eoff < 4096 ) eoff++;",
          "290:      }",
          "291:  }",
          "296:  fprintf( stderr, \"RTF buffer overrun, input file may be corrupted\\n\" );",
          "303: get_rtf_data_from_buf (size_t len, unsigned char *data,",
          "304:          size_t *out_len, unsigned char **out_data)",
          "",
          "[Added Lines]",
          "207:         if ( endflag ) break;",
          "211:         if ( cin+1 > lenc )",
          "212:         {",
          "213:             endflag = -1;",
          "215:         }",
          "217:         control = (int)src[cin++];",
          "223:             if ( endflag ) break;",
          "225:             if ( control & (1<<i) )",
          "226:             {",
          "229:                 if ( cin+2 > lenc )",
          "230:                 {",
          "231:                     endflag = -1;",
          "233:                 }",
          "235:                 roff = (int)src[cin++];",
          "236:                 rlen = (int)src[cin++];",
          "238:                 roff = (roff<<4) + (rlen>>4);",
          "239:                 rlen = (rlen&0x0f) + 2;",
          "243:                 if ( roff == woff )",
          "244:                 {",
          "245:                     endflag = 1;",
          "247:                 }",
          "251:                 if ( cout+rlen > lenu )",
          "252:                 {",
          "253:                     endflag = -1;",
          "255:                 }",
          "257:                 for ( j=0; j<rlen; j++ )",
          "258:                 {",
          "259:                     dest[cout++] = dict[roff];",
          "260:                     dict[woff++] = dict[roff++];",
          "262:                     roff &= 0xfff;",
          "263:                     woff &= 0xfff;",
          "264:                     if ( eoff < 4096 ) eoff++;",
          "265:                 }",
          "266:             }",
          "267:             else",
          "268:             {",
          "271:                 if ( cin+1 > lenc )",
          "272:                 {",
          "273:                     endflag = -1;",
          "275:                 }",
          "277:                 if ( cout+1 > lenu )",
          "278:                 {",
          "279:                     endflag = -1;",
          "281:                 }",
          "285:                 dest[cout++] = src[cin];",
          "286:                 dict[woff++] = src[cin++];",
          "288:                 woff &= 0xfff;",
          "289:                 if ( eoff < 4096 ) eoff++;",
          "290:             }",
          "291:         }",
          "296:         fprintf( stderr, \"RTF buffer overrun, input file may be corrupted\\n\" );",
          "303: get_rtf_data_from_buf (size_t len, unsigned char *data,",
          "304:                        size_t *out_len, unsigned char **out_data)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "325:     {",
          "328:     }",
          "330:     {",
          "341:     }",
          "342: }",
          "344: VarLenData**",
          "345: get_rtf_data (MAPI_Attr *a)",
          "346: {",
          "350:     int j;",
          "351:     for (j = 0; j < a->num_values; j++)",
          "352:     {",
          "361:     }",
          "362:     return body;",
          "363: }",
          "",
          "[Removed Lines]",
          "326:  (*out_data) = CHECKED_XCALLOC(unsigned char, (*out_len));",
          "327:  memmove ((*out_data), data+4, uncompr_size);",
          "331:  if ( checksum == generate_crc( data+idx, len-idx ) )",
          "332:  {",
          "333:      (*out_data) = decompress_rtf_data (data+idx, len-idx, uncompr_size);",
          "334:  }",
          "335:  else",
          "336:  {",
          "337:      (*out_data) = CHECKED_XCALLOC(unsigned char, 4);",
          "338:      (*out_len) = 0;",
          "339:      fprintf( stderr, \"Invalid RTF CRC, input file may be corrupted\\n\" );",
          "340:  }",
          "347:     VarLenData** body",
          "348:  = (VarLenData**)CHECKED_XCALLOC(VarLenData*, a->num_values + 1);",
          "353:  if (a->values[j].len > 12 && is_rtf_data (a->values[j].data.buf))",
          "354:  {",
          "355:      body[j] = (VarLenData*)XMALLOC(VarLenData, 1);",
          "357:      get_rtf_data_from_buf (a->values[j].len,",
          "358:        a->values[j].data.buf,",
          "359:        &body[j]->len, &body[j]->data);",
          "360:  }",
          "",
          "[Added Lines]",
          "326:         (*out_data) = CHECKED_XCALLOC(unsigned char, (*out_len));",
          "327:         memmove ((*out_data), data+4, uncompr_size);",
          "331:         if ( checksum == generate_crc( data+idx, len-idx ) )",
          "332:         {",
          "333:             (*out_data) = decompress_rtf_data (data+idx, len-idx, uncompr_size);",
          "334:         }",
          "335:         else",
          "336:         {",
          "337:             (*out_data) = CHECKED_XCALLOC(unsigned char, 4);",
          "338:             (*out_len) = 0;",
          "339:             fprintf( stderr, \"Invalid RTF CRC, input file may be corrupted\\n\" );",
          "340:         }",
          "347:     VarLenData** body",
          "348:         = (VarLenData**)CHECKED_XCALLOC(VarLenData*, a->num_values + 1);",
          "353:         if (a->values[j].len > 12 && is_rtf_data (a->values[j].data.buf))",
          "354:         {",
          "355:             body[j] = (VarLenData*)XMALLOC(VarLenData, 1);",
          "357:             get_rtf_data_from_buf (a->values[j].len,",
          "358:                                    a->values[j].data.buf,",
          "359:                                    &body[j]->len, &body[j]->data);",
          "360:         }",
          "",
          "---------------"
        ],
        "src/tnef.c||src/tnef.c": [
          "File: src/tnef.c -> src/tnef.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "73:     return attr;",
          "74: }",
          "76: static void",
          "77: free_bodies(VarLenData **bodies, int len)",
          "78: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "86: }",
          "88: static File**",
          "91:   const MessageBody* body)",
          "92: {",
          "93:     File **files = NULL;",
          "",
          "[Removed Lines]",
          "89: get_body_files (const char* filename,",
          "90:   const char pref,",
          "",
          "[Added Lines]",
          "89: get_body_files (const char* filename,",
          "90:                 const char pref,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "99:     switch (pref)",
          "100:     {",
          "103:  ext = \".rtf\";",
          "105:  break;",
          "108:  ext = \".html\";",
          "110:  break;",
          "113:  ext = \".txt\";",
          "115:  break;",
          "118:  break;",
          "119:     }",
          "121:     if (data)",
          "128:  strcat (tmp, ext);",
          "130:         char *mime = CHECKED_XCALLOC(char, strlen(type) + 1);",
          "131:         strcpy (mime, type);",
          "134:  while (data[count++]);",
          "140:      files[i]->name = tmp;",
          "146:  }",
          "147:     }",
          "148:     return files;",
          "",
          "[Removed Lines]",
          "101:     case 'r':",
          "102:  data = body->rtf_bodies;",
          "104:             type = \"text/rtf\";",
          "106:     case 'h':",
          "107:  data = body->html_bodies;",
          "109:             type = \"text/html\";",
          "111:     case 't':",
          "112:  data = body->text_body;",
          "114:             type = \"text/plain\";",
          "116:     default:",
          "117:  data = NULL;",
          "122:     {",
          "123:  int count = 0;",
          "124:  char *tmp",
          "125:      = CHECKED_XCALLOC(char,",
          "126:          strlen(filename) + strlen(ext) + 1);",
          "127:  strcpy (tmp, filename);",
          "136:  files = (File**)XCALLOC(File*, count + 1);",
          "137:  for (i = 0; data[i]; i++)",
          "138:  {",
          "139:      files[i] = (File*)XCALLOC(File, 1);",
          "141:             files[i]->mime_type = mime;",
          "142:      files[i]->len = data[i]->len;",
          "143:      files[i]->data",
          "144:   = CHECKED_XMALLOC(unsigned char, data[i]->len);",
          "145:      memmove (files[i]->data, data[i]->data, data[i]->len);",
          "",
          "[Added Lines]",
          "101:     case 'r':",
          "102:         data = body->rtf_bodies;",
          "104:             type = \"text/rtf\";",
          "106:     case 'h':",
          "107:         data = body->html_bodies;",
          "109:             type = \"text/html\";",
          "111:     case 't':",
          "112:         data = body->text_body;",
          "114:             type = \"text/plain\";",
          "116:     default:",
          "117:         data = NULL;",
          "122:     {",
          "123:         int count = 0;",
          "124:         char *tmp",
          "125:             = CHECKED_XCALLOC(char,",
          "126:                               strlen(filename) + strlen(ext) + 1);",
          "127:         strcpy (tmp, filename);",
          "136:         files = (File**)XCALLOC(File*, count + 1);",
          "137:         for (i = 0; data[i]; i++)",
          "138:         {",
          "139:             files[i] = (File*)XCALLOC(File, 1);",
          "141:             files[i]->mime_type = mime;",
          "142:             files[i]->len = data[i]->len;",
          "143:             files[i]->data",
          "144:                 = CHECKED_XMALLOC(unsigned char, data[i]->len);",
          "145:             memmove (files[i]->data, data[i]->data, data[i]->len);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "168:     int j;",
          "169:     for (j = 0; j < a->num_values; j++)",
          "170:     {",
          "175:      memmove (body[j]->data, a->values[j].data.buf, body[j]->len);",
          "176:         }",
          "177:     }",
          "",
          "[Removed Lines]",
          "171:         if (a->type == szMAPI_BINARY) {",
          "172:       body[j] = XMALLOC(VarLenData, 1);",
          "173:      body[j]->len = a->values[j].len;",
          "174:      body[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);",
          "",
          "[Added Lines]",
          "171:         if (a->type == szMAPI_BINARY) {",
          "172:             body[j] = XMALLOC(VarLenData, 1);",
          "173:             body[j]->len = a->values[j].len;",
          "174:             body[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "181: int",
          "182: data_left (FILE* input_file)",
          "183: {",
          "184:     int retval = 1;",
          "186:     if (feof(input_file)) retval = 0;",
          "187:     else if (input_file != stdin)",
          "188:     {",
          "240:  }",
          "241:     }",
          "242:     return retval;",
          "",
          "[Removed Lines]",
          "190:  struct stat statbuf;",
          "191:  size_t pos, data_left;",
          "192:  fstat (fileno(input_file), &statbuf);",
          "193:  pos = ftell(input_file);",
          "194:  data_left = (statbuf.st_size - pos);",
          "196:  if (data_left > 0 && data_left < MINIMUM_ATTR_LENGTH)",
          "197:  {",
          "198:      if ( CRUFT_SKIP )",
          "199:      {",
          "202:   if ( data_left == 2 )",
          "203:   {",
          "204:       int c = fgetc( input_file );",
          "207:       {",
          "208:    fprintf( stderr, \"ERROR: confused beyond all redemption.\\n\" );",
          "209:    exit (1);",
          "210:       }",
          "212:       ungetc( c, input_file );",
          "215:       {",
          "218:    if ( VERBOSE_ON )",
          "219:        fprintf( stderr, \"WARNING: garbage at end of file (ignored)\\n\" );",
          "221:    if ( DEBUG_ON )",
          "222:        debug_print( \"!!garbage at end of file (ignored)\\n\" );",
          "223:       }",
          "224:       else",
          "225:       {",
          "226:    fprintf( stderr, \"ERROR: garbage at end of file.\\n\" );",
          "227:       }",
          "228:   }",
          "229:   else",
          "230:   {",
          "231:       fprintf (stderr, \"ERROR: garbage at end of file.\\n\");",
          "232:   }",
          "233:      }",
          "234:      else",
          "235:      {",
          "236:   fprintf (stderr, \"ERROR: garbage at end of file.\\n\");",
          "237:      }",
          "239:      retval = 0;",
          "",
          "[Added Lines]",
          "190:         struct stat statbuf;",
          "191:         size_t pos, data_left;",
          "192:         fstat (fileno(input_file), &statbuf);",
          "193:         pos = ftell(input_file);",
          "194:         data_left = (statbuf.st_size - pos);",
          "196:         if (data_left > 0 && data_left < MINIMUM_ATTR_LENGTH)",
          "197:         {",
          "198:             if ( CRUFT_SKIP )",
          "199:             {",
          "202:                 if ( data_left == 2 )",
          "203:                 {",
          "204:                     int c = fgetc( input_file );",
          "207:                     {",
          "208:                         fprintf( stderr, \"ERROR: confused beyond all redemption.\\n\" );",
          "209:                         exit (1);",
          "210:                     }",
          "212:                     ungetc( c, input_file );",
          "215:                     {",
          "218:                         if ( VERBOSE_ON )",
          "219:                             fprintf( stderr, \"WARNING: garbage at end of file (ignored)\\n\" );",
          "221:                         if ( DEBUG_ON )",
          "222:                             debug_print( \"!!garbage at end of file (ignored)\\n\" );",
          "223:                     }",
          "224:                     else",
          "225:                     {",
          "226:                         fprintf( stderr, \"ERROR: garbage at end of file.\\n\" );",
          "227:                     }",
          "228:                 }",
          "229:                 else",
          "230:                 {",
          "231:                     fprintf (stderr, \"ERROR: garbage at end of file.\\n\");",
          "232:                 }",
          "233:             }",
          "234:             else",
          "235:             {",
          "236:                 fprintf (stderr, \"ERROR: garbage at end of file.\\n\");",
          "237:             }",
          "239:             retval = 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "250:      char *body_filename, char *body_pref,",
          "251:      int flags)",
          "252: {",
          "253:     uint32 d;",
          "",
          "[Removed Lines]",
          "248: int",
          "249: parse_file (FILE* input_file, char* directory,",
          "",
          "[Added Lines]",
          "248: int",
          "249: parse_file (FILE* input_file, char* directory,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "265:     d = geti32(input_file);",
          "268:  fprintf (stdout, \"Seems not to be a TNEF file\\n\");",
          "269:  return 1;",
          "270:     }",
          "",
          "[Removed Lines]",
          "266:     if (d != TNEF_SIGNATURE)",
          "267:     {",
          "",
          "[Added Lines]",
          "266:     if (d != TNEF_SIGNATURE)",
          "267:     {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "274:     debug_print (\"TNEF Key: %hx\\n\", key);",
          "317:    {",
          "322:    {",
          "344:  attr_free (attr);",
          "345:  XFREE (attr);",
          "346:     }",
          "351:  file_free (file);",
          "352:  XFREE (file);",
          "353:     }",
          "375:       file_write(files[j], directory);",
          "381:      }",
          "382:  }",
          "383:     }",
          "",
          "[Removed Lines]",
          "277:     while ( data_left( input_file ) )",
          "278:     {",
          "279:  attr = read_object( input_file );",
          "281:  if ( attr == NULL ) break;",
          "284:  if (attr->name == attATTACHRENDDATA)",
          "285:  {",
          "286:      if (file)",
          "287:      {",
          "288:   file_write (file, directory);",
          "289:   file_free (file);",
          "290:      }",
          "291:      else",
          "292:      {",
          "293:   file = CHECKED_XCALLOC (File, 1);",
          "294:      }",
          "295:  }",
          "298:  switch (attr->lvl_type)",
          "299:  {",
          "300:  case LVL_MESSAGE:",
          "301:      if (attr->name == attBODY)",
          "302:      {",
          "303:   body.text_body = get_text_data (attr);",
          "304:      }",
          "305:      else if (attr->name == attMAPIPROPS)",
          "306:      {",
          "307:   MAPI_Attr **mapi_attrs",
          "308:       = mapi_attr_read (attr->len, attr->buf);",
          "309:   if (mapi_attrs)",
          "310:   {",
          "311:       int i;",
          "312:       for (i = 0; mapi_attrs[i]; i++)",
          "313:       {",
          "314:    MAPI_Attr *a = mapi_attrs[i];",
          "316:    if (a->type == szMAPI_BINARY && a->name == MAPI_BODY_HTML)",
          "318:        body.html_bodies = get_html_data (a);",
          "319:                                 html_size = a->num_values;",
          "320:    }",
          "321:    else if (a->type == szMAPI_BINARY && a->name == MAPI_RTF_COMPRESSED)",
          "323:        body.rtf_bodies = get_rtf_data (a);",
          "324:                                 rtf_size = a->num_values;",
          "325:    }",
          "326:       }",
          "330:       mapi_attr_free_list (mapi_attrs);",
          "331:       XFREE (mapi_attrs);",
          "332:   }",
          "333:      }",
          "334:      break;",
          "335:  case LVL_ATTACHMENT:",
          "336:      file_add_attr (file, attr);",
          "337:      break;",
          "338:  default:",
          "339:      fprintf (stderr, \"Invalid lvl type on attribute: %d\\n\",",
          "340:        attr->lvl_type);",
          "341:      return 1;",
          "342:      break;",
          "343:  }",
          "348:     if (file)",
          "349:     {",
          "350:  file_write (file, directory);",
          "356:     if (flags & SAVEBODY)",
          "357:     {",
          "358:  int i = 0;",
          "359:  int all_flag = 0;",
          "360:  if (strcmp (body_pref, \"all\") == 0)",
          "361:  {",
          "362:      all_flag = 1;",
          "363:      body_pref = \"rht\";",
          "364:  }",
          "366:  for (; i < 3; i++)",
          "367:  {",
          "368:      File **files",
          "369:   = get_body_files (body_filename, body_pref[i], &body);",
          "370:      if (files)",
          "371:      {",
          "372:   int j = 0;",
          "373:   for (; files[j]; j++)",
          "374:   {",
          "376:       file_free (files[j]);",
          "377:                     XFREE(files[j]);",
          "378:   }",
          "379:   XFREE(files);",
          "380:   if (!all_flag) break;",
          "",
          "[Added Lines]",
          "277:     while ( data_left( input_file ) )",
          "278:     {",
          "279:         attr = read_object( input_file );",
          "281:         if ( attr == NULL ) break;",
          "284:         if (attr->name == attATTACHRENDDATA)",
          "285:         {",
          "286:             if (file)",
          "287:             {",
          "288:                 file_write (file, directory);",
          "289:                 file_free (file);",
          "290:             }",
          "291:             else",
          "292:             {",
          "293:                 file = CHECKED_XCALLOC (File, 1);",
          "294:             }",
          "295:         }",
          "298:         switch (attr->lvl_type)",
          "299:         {",
          "300:         case LVL_MESSAGE:",
          "301:             if (attr->name == attBODY)",
          "302:             {",
          "303:                 body.text_body = get_text_data (attr);",
          "304:             }",
          "305:             else if (attr->name == attMAPIPROPS)",
          "306:             {",
          "307:                 MAPI_Attr **mapi_attrs",
          "308:                     = mapi_attr_read (attr->len, attr->buf);",
          "309:                 if (mapi_attrs)",
          "310:                 {",
          "311:                     int i;",
          "312:                     for (i = 0; mapi_attrs[i]; i++)",
          "313:                     {",
          "314:                         MAPI_Attr *a = mapi_attrs[i];",
          "316:                         if (a->type == szMAPI_BINARY && a->name == MAPI_BODY_HTML)",
          "318:                             body.html_bodies = get_html_data (a);",
          "319:                                 html_size = a->num_values;",
          "320:                         }",
          "321:                         else if (a->type == szMAPI_BINARY && a->name == MAPI_RTF_COMPRESSED)",
          "323:                             body.rtf_bodies = get_rtf_data (a);",
          "324:                                 rtf_size = a->num_values;",
          "325:                         }",
          "326:                     }",
          "330:                     mapi_attr_free_list (mapi_attrs);",
          "331:                     XFREE (mapi_attrs);",
          "332:                 }",
          "333:             }",
          "334:             break;",
          "335:         case LVL_ATTACHMENT:",
          "336:             file_add_attr (file, attr);",
          "337:             break;",
          "338:         default:",
          "339:             fprintf (stderr, \"Invalid lvl type on attribute: %d\\n\",",
          "340:                      attr->lvl_type);",
          "341:             return 1;",
          "342:             break;",
          "343:         }",
          "348:     if (file)",
          "349:     {",
          "350:         file_write (file, directory);",
          "356:     if (flags & SAVEBODY)",
          "357:     {",
          "358:         int i = 0;",
          "359:         int all_flag = 0;",
          "360:         if (strcmp (body_pref, \"all\") == 0)",
          "361:         {",
          "362:             all_flag = 1;",
          "363:             body_pref = \"rht\";",
          "364:         }",
          "366:         for (; i < 3; i++)",
          "367:         {",
          "368:             File **files",
          "369:                 = get_body_files (body_filename, body_pref[i], &body);",
          "370:             if (files)",
          "371:             {",
          "372:                 int j = 0;",
          "373:                 for (; files[j]; j++)",
          "374:                 {",
          "376:                     file_free (files[j]);",
          "377:                     XFREE(files[j]);",
          "378:                 }",
          "379:                 XFREE(files);",
          "380:                 if (!all_flag) break;",
          "",
          "---------------"
        ],
        "src/tnef.h||src/tnef.h": [
          "File: src/tnef.h -> src/tnef.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: extern int",
          "",
          "[Removed Lines]",
          "38: parse_file(FILE *input, char * output_dir,",
          "39:     char *body_file, char *body_pref,",
          "40:     int flags);",
          "",
          "[Added Lines]",
          "38: parse_file(FILE *input, char * output_dir,",
          "39:            char *body_file, char *body_pref,",
          "40:            int flags);",
          "",
          "---------------"
        ],
        "src/util.c||src/util.c": [
          "File: src/util.c -> src/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: uint32 GETINT32(unsigned char *p)",
          "33: {",
          "34:     return (uint32)((uint8)(p)[0]           \\",
          "38: }",
          "40: uint16 GETINT16 (unsigned char* p)",
          "",
          "[Removed Lines]",
          "35:       +((uint8)(p)[1]<<8)     \\",
          "36:       +((uint8)(p)[2]<<16)    \\",
          "37:       +((uint8)(p)[3]<<24));",
          "",
          "[Added Lines]",
          "35:                     +((uint8)(p)[1]<<8)     \\",
          "36:                     +((uint8)(p)[2]<<16)    \\",
          "37:                     +((uint8)(p)[3]<<24));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52: {",
          "53:     if (fread (buf, 1, n, fp) != n)",
          "54:     {",
          "57:     }",
          "58:     return buf;",
          "59: }",
          "",
          "[Removed Lines]",
          "55:  perror (\"Unexpected end of input\");",
          "56:  exit (1);",
          "",
          "[Added Lines]",
          "55:         perror (\"Unexpected end of input\");",
          "56:         exit (1);",
          "",
          "---------------"
        ],
        "src/util.h||src/util.h": [
          "File: src/util.h -> src/util.h"
        ],
        "src/xstrdup.c||src/xstrdup.c": [
          "File: src/xstrdup.c -> src/xstrdup.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:     char *ret = NULL;",
          "34:     if (str)",
          "35:     {",
          "38:     }",
          "39:     return ret;",
          "40: }",
          "",
          "[Removed Lines]",
          "36:  alloc_limit_assert (\"xstrdup\", strlen(str));",
          "37:  ret = strdup (str);",
          "",
          "[Added Lines]",
          "36:         alloc_limit_assert (\"xstrdup\", strlen(str));",
          "37:         ret = strdup (str);",
          "",
          "---------------"
        ],
        "tests/cmdline/version.baseline||tests/cmdline/version.baseline": [
          "File: tests/cmdline/version.baseline -> tests/cmdline/version.baseline",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: ./../../src/tnef --version",
          "2: tnef 1.4.15",
          "4: Copyright (C) 1997 by Thomas Boll (original code)",
          "5: tnef comes with ABSOLUTELY NO WARRANTY.",
          "6: You may redistribute copies of tnef under the terms of the GNU General",
          "",
          "[Removed Lines]",
          "3: Copyright (C) 1999-2017 by Mark Simpson",
          "",
          "[Added Lines]",
          "3: Copyright (C) 1999-2018 by Mark Simpson",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "10: ./../../src/tnef -V",
          "11: tnef 1.4.15",
          "13: Copyright (C) 1997 by Thomas Boll (original code)",
          "14: tnef comes with ABSOLUTELY NO WARRANTY.",
          "15: You may redistribute copies of tnef under the terms of the GNU General",
          "",
          "[Removed Lines]",
          "12: Copyright (C) 1999-2017 by Mark Simpson",
          "",
          "[Added Lines]",
          "12: Copyright (C) 1999-2018 by Mark Simpson",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
  "patch_info": {
    "commit_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/d86b49411753bf2c83291e3a14ae43fefded2f84",
    "files": [
      "Doc/whatsnew/3.13.rst",
      "Misc/NEWS.d/next/Security/2024-05-01-20-57-09.gh-issue-118486.K44KJG.rst"
    ],
    "message": "gh-118486: Update docs for CVE-2024-4030 reference (GH-118737)\n\nUpdate docs for CVE-2024-4030 reference",
    "before_after_code_files": []
  },
  "patch_diff": {},
  "candidates": [
    {
      "candidate_hash": "e6e4efcc86ffecb9884ff64d622f3c6b659b7220",
      "candidate_info": {
        "commit_hash": "e6e4efcc86ffecb9884ff64d622f3c6b659b7220",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/e6e4efcc86ffecb9884ff64d622f3c6b659b7220",
        "files": [
          "Lib/_pyrepl/completing_reader.py",
          "Lib/_pyrepl/keymap.py",
          "Lib/test/test_pyrepl/test_keymap.py"
        ],
        "message": "[3.13] gh-119357: Increase test coverage for keymap in _pyrepl (GH-119358) (#119414)\n\n(cherry picked from commit 73ab83b27f105a4509046ce26e35f20d66625195)\n\nCo-authored-by: Eugene Triguba <eugenetriguba@gmail.com>\nCo-authored-by: \u0141ukasz Langa <lukasz@langa.pl>",
        "before_after_code_files": [
          "Lib/_pyrepl/completing_reader.py||Lib/_pyrepl/completing_reader.py",
          "Lib/_pyrepl/keymap.py||Lib/_pyrepl/keymap.py",
          "Lib/test/test_pyrepl/test_keymap.py||Lib/test/test_pyrepl/test_keymap.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/_pyrepl/completing_reader.py||Lib/_pyrepl/completing_reader.py": [
          "File: Lib/_pyrepl/completing_reader.py -> Lib/_pyrepl/completing_reader.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: # types",
          "31: Command = commands.Command",
          "32: if False:",
          "36: def prefix(wordlist: list[str], j: int = 0) -> str:",
          "",
          "[Removed Lines]",
          "33:     from .types import Callback, SimpleContextManager, KeySpec, CommandName",
          "",
          "[Added Lines]",
          "33:     from .types import KeySpec, CommandName",
          "",
          "---------------"
        ],
        "Lib/_pyrepl/keymap.py||Lib/_pyrepl/keymap.py": [
          "File: Lib/_pyrepl/keymap.py -> Lib/_pyrepl/keymap.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: # CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.",
          "21: \"\"\"",
          "40: The extension to readline is that the sequence \\\\<KEY> denotes the",
          "43: Examples:",
          "46: `\\\\EOA'  - Escape - O - A (up, on my terminal)",
          "47: `\\\\<UP>' - the up arrow key",
          "49: `\\\\C-o', `\\\\c-o'  - control-o",
          "50: `\\\\M-.'  - meta-period",
          "51: `\\\\E.'   - ditto (that's how meta works for pyrepl)",
          "52: `\\\\<tab>', `\\\\<TAB>', `\\\\t', `\\\\011', '\\\\x09', '\\\\X09', '\\\\C-i', '\\\\C-I'",
          "54: \"\"\"",
          "56: _escapes = {",
          "",
          "[Removed Lines]",
          "22: functions for parsing keyspecs",
          "24: Support for turning keyspecs into appropriate sequences.",
          "26: pyrepl uses it's own bastardized keyspec format, which is meant to be",
          "27: a strict superset of readline's \\\"KEYSEQ\\\" format (which is to say",
          "28: that if you can come up with a spec readline accepts that this",
          "29: doesn't, you've found a bug and should tell me about it).",
          "31: Note that this is the `\\\\C-o' style of readline keyspec, not the",
          "32: `Control-o' sort.",
          "34: A keyspec is a string representing a sequence of keypresses that can",
          "35: be bound to a command.",
          "37: All characters other than the backslash represent themselves.  In the",
          "38: traditional manner, a backslash introduces a escape sequence.",
          "41: sequence of charaters produced by hitting KEY.",
          "45: `a'     - what you get when you hit the `a' key",
          "48: `\\\\<up>' - ditto (keynames are case insensitive)",
          "53:    - all of these are the tab character.  Can you think of any more?",
          "",
          "[Added Lines]",
          "22: Keymap contains functions for parsing keyspecs and turning keyspecs into",
          "23: appropriate sequences.",
          "25: A keyspec is a string representing a sequence of key presses that can",
          "26: be bound to a command. All characters other than the backslash represent",
          "27: themselves. In the traditional manner, a backslash introduces an escape",
          "28: sequence.",
          "30: pyrepl uses its own keyspec format that is meant to be a strict superset of",
          "31: readline's KEYSEQ format. This means that if a spec is found that readline",
          "32: accepts that this doesn't, it should be logged as a bug. Note that this means",
          "33: we're using the `\\\\C-o' style of readline's keyspec, not the `Control-o' sort.",
          "36: sequence of characters produced by hitting KEY.",
          "39: `a'      - what you get when you hit the `a' key",
          "42: `\\\\<up>' - ditto (keynames are case-insensitive)",
          "47:    - all of these are the tab character.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "111:     pass",
          "115:     ctrl = 0",
          "116:     meta = 0",
          "117:     ret = \"\"",
          "",
          "[Removed Lines]",
          "114: def _parse_key1(key, s):",
          "",
          "[Added Lines]",
          "108: def parse_keys(keys: str) -> list[str]:",
          "109:     \"\"\"Parse keys in keyspec format to a sequence of keys.\"\"\"",
          "110:     s = 0",
          "111:     r: list[str] = []",
          "112:     while s < len(keys):",
          "113:         k, s = _parse_single_key_sequence(keys, s)",
          "114:         r.extend(k)",
          "115:     return r",
          "118: def _parse_single_key_sequence(key: str, s: int) -> tuple[list[str], int]:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "183:             ret = f\"ctrl {ret}\"",
          "184:         else:",
          "185:             raise KeySpecError(\"\\\\C- followed by invalid key\")",
          "202: def compile_keymap(keymap, empty=b\"\"):",
          "",
          "[Removed Lines]",
          "186:     if meta:",
          "187:         ret = [\"\\033\", ret]",
          "188:     else:",
          "189:         ret = [ret]",
          "190:     return ret, s",
          "193: def parse_keys(key: str) -> list[str]:",
          "194:     s = 0",
          "195:     r = []",
          "196:     while s < len(key):",
          "197:         k, s = _parse_key1(key, s)",
          "198:         r.extend(k)",
          "199:     return r",
          "",
          "[Added Lines]",
          "191:     result = [ret], s",
          "192:     if meta:",
          "193:         result[0].insert(0, \"\\033\")",
          "194:     return result",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_keymap.py||Lib/test/test_pyrepl/test_keymap.py": [
          "File: Lib/test/test_pyrepl/test_keymap.py -> Lib/test/test_pyrepl/test_keymap.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import unittest",
          "6: class TestParseKeys(unittest.TestCase):",
          "7:     def test_single_character(self):",
          "12:     def test_escape_sequences(self):",
          "19:     def test_control_sequences(self):",
          "24:     def test_meta_sequences(self):",
          "25:         self.assertEqual(parse_keys(\"\\\\M-a\"), [\"\\033\", \"a\"])",
          "26:         self.assertEqual(parse_keys(\"\\\\M-b\"), [\"\\033\", \"b\"])",
          "27:         self.assertEqual(parse_keys(\"\\\\M-c\"), [\"\\033\", \"c\"])",
          "35:     def test_combinations(self):",
          "36:         self.assertEqual(parse_keys(\"\\\\C-a\\\\n\\\\<up>\"), [\"\\x01\", \"\\n\", \"up\"])",
          "37:         self.assertEqual(parse_keys(\"\\\\M-a\\\\t\\\\<down>\"), [\"\\033\", \"a\", \"\\t\", \"down\"])",
          "40: class TestCompileKeymap(unittest.TestCase):",
          "41:     def test_empty_keymap(self):",
          "",
          "[Removed Lines]",
          "3: from _pyrepl.keymap import parse_keys, compile_keymap",
          "8:         self.assertEqual(parse_keys(\"a\"), [\"a\"])",
          "9:         self.assertEqual(parse_keys(\"b\"), [\"b\"])",
          "10:         self.assertEqual(parse_keys(\"1\"), [\"1\"])",
          "13:         self.assertEqual(parse_keys(\"\\\\n\"), [\"\\n\"])",
          "14:         self.assertEqual(parse_keys(\"\\\\t\"), [\"\\t\"])",
          "15:         self.assertEqual(parse_keys(\"\\\\\\\\\"), [\"\\\\\"])",
          "16:         self.assertEqual(parse_keys(\"\\\\'\"), [\"'\"])",
          "17:         self.assertEqual(parse_keys('\\\\\"'), ['\"'])",
          "20:         self.assertEqual(parse_keys(\"\\\\C-a\"), [\"\\x01\"])",
          "21:         self.assertEqual(parse_keys(\"\\\\C-b\"), [\"\\x02\"])",
          "22:         self.assertEqual(parse_keys(\"\\\\C-c\"), [\"\\x03\"])",
          "29:     def test_keynames(self):",
          "30:         self.assertEqual(parse_keys(\"\\\\<up>\"), [\"up\"])",
          "31:         self.assertEqual(parse_keys(\"\\\\<down>\"), [\"down\"])",
          "32:         self.assertEqual(parse_keys(\"\\\\<left>\"), [\"left\"])",
          "33:         self.assertEqual(parse_keys(\"\\\\<right>\"), [\"right\"])",
          "",
          "[Added Lines]",
          "1: import string",
          "4: from _pyrepl.keymap import _keynames, _escapes, parse_keys, compile_keymap, KeySpecError",
          "9:         \"\"\"Ensure that single ascii characters or single digits are parsed as single characters.\"\"\"",
          "10:         test_cases = [(key, [key]) for key in string.ascii_letters + string.digits]",
          "11:         for test_key, expected_keys in test_cases:",
          "12:             with self.subTest(f\"{test_key} should be parsed as {expected_keys}\"):",
          "13:                 self.assertEqual(parse_keys(test_key), expected_keys)",
          "15:     def test_keynames(self):",
          "16:         \"\"\"Ensure that keynames are parsed to their corresponding mapping.",
          "18:         A keyname is expected to be of the following form: \\\\<keyname> such as \\\\<left>",
          "19:         which would get parsed as \"left\".",
          "20:         \"\"\"",
          "21:         test_cases = [(f\"\\\\<{keyname}>\", [parsed_keyname]) for keyname, parsed_keyname in _keynames.items()]",
          "22:         for test_key, expected_keys in test_cases:",
          "23:             with self.subTest(f\"{test_key} should be parsed as {expected_keys}\"):",
          "24:                 self.assertEqual(parse_keys(test_key), expected_keys)",
          "27:         \"\"\"Ensure that escaping sequences are parsed to their corresponding mapping.\"\"\"",
          "28:         test_cases = [(f\"\\\\{escape}\", [parsed_escape]) for escape, parsed_escape in _escapes.items()]",
          "29:         for test_key, expected_keys in test_cases:",
          "30:             with self.subTest(f\"{test_key} should be parsed as {expected_keys}\"):",
          "31:                 self.assertEqual(parse_keys(test_key), expected_keys)",
          "34:         \"\"\"Ensure that supported control sequences are parsed successfully.\"\"\"",
          "35:         keys = [\"@\", \"[\", \"]\", \"\\\\\", \"^\", \"_\", \"\\\\<space>\", \"\\\\<delete>\"]",
          "36:         keys.extend(string.ascii_letters)",
          "37:         test_cases = [(f\"\\\\C-{key}\", chr(ord(key) & 0x1F)) for key in []]",
          "38:         for test_key, expected_keys in test_cases:",
          "39:             with self.subTest(f\"{test_key} should be parsed as {expected_keys}\"):",
          "40:                 self.assertEqual(parse_keys(test_key), expected_keys)",
          "51:     def test_keyspec_errors(self):",
          "52:         cases = [",
          "53:             (\"\\\\Ca\", \"\\\\C must be followed by `-'\"),",
          "54:             (\"\\\\ca\", \"\\\\C must be followed by `-'\"),",
          "55:             (\"\\\\C-\\\\C-\", \"doubled \\\\C-\"),",
          "56:             (\"\\\\Ma\", \"\\\\M must be followed by `-'\"),",
          "57:             (\"\\\\ma\", \"\\\\M must be followed by `-'\"),",
          "58:             (\"\\\\M-\\\\M-\", \"doubled \\\\M-\"),",
          "59:             (\"\\\\<left\", \"unterminated \\\\<\"),",
          "60:             (\"\\\\<unsupported>\", \"unrecognised keyname\"),",
          "61:             (\"\\\\\u5927\", \"unknown backslash escape\"),",
          "62:             (\"\\\\C-\\\\<backspace>\", \"\\\\C- followed by invalid key\")",
          "63:         ]",
          "64:         for test_keys, expected_err in cases:",
          "65:             with self.subTest(f\"{test_keys} should give error {expected_err}\"):",
          "66:                 with self.assertRaises(KeySpecError) as e:",
          "67:                     parse_keys(test_keys)",
          "68:                 self.assertIn(expected_err, str(e.exception))",
          "70:     def test_index_errors(self):",
          "71:         test_cases = [\"\\\\\", \"\\\\C\", \"\\\\C-\\\\C\"]",
          "72:         for test_keys in test_cases:",
          "73:             with self.assertRaises(IndexError):",
          "74:                 parse_keys(test_keys)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "72:         keymap = {b\"a\": {b\"b\": {b\"c\": \"action\"}}}",
          "73:         result = compile_keymap(keymap)",
          "74:         self.assertEqual(result, {b\"a\": {b\"b\": {b\"c\": \"action\"}}})",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "113:     def test_clashing_definitions(self):",
          "114:         km = {b'a': 'c', b'a' + b'b': 'd'}",
          "115:         with self.assertRaises(KeySpecError):",
          "116:             compile_keymap(km)",
          "118:     def test_non_bytes_key(self):",
          "119:         with self.assertRaises(TypeError):",
          "120:             compile_keymap({123: 'a'})",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "06c62d697a87822690342cd0d99d1cdbeca4ce9d",
      "candidate_info": {
        "commit_hash": "06c62d697a87822690342cd0d99d1cdbeca4ce9d",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/06c62d697a87822690342cd0d99d1cdbeca4ce9d",
        "files": [
          "Doc/library/dataclasses.rst",
          "Lib/test/test_dataclasses/__init__.py"
        ],
        "message": "[3.13] gh-119260: Clarify is_dataclass Behavior for Subclasses in Documentation and Tests (GH-119480) (#119760)\n\ngh-119260: Clarify is_dataclass Behavior for Subclasses in Documentation and Tests (GH-119480)\n(cherry picked from commit bf4ff3ad2e362801e87c85fffd9e140b774cef26)\n\nCo-authored-by: Aditya Borikar <adityaborikar2@gmail.com>\nCo-authored-by: Carl Meyer <carl@oddbird.net>",
        "before_after_code_files": [
          "Lib/test/test_dataclasses/__init__.py||Lib/test/test_dataclasses/__init__.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_dataclasses/__init__.py||Lib/test/test_dataclasses/__init__.py": [
          "File: Lib/test/test_dataclasses/__init__.py -> Lib/test/test_dataclasses/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1547:         self.assertTrue(is_dataclass(type(a)))",
          "1548:         self.assertTrue(is_dataclass(a))",
          "1551:     def test_helper_fields_with_class_instance(self):",
          "1552:         # Check that we can call fields() on either a class or instance,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1550:     def test_is_dataclass_inheritance(self):",
          "1551:         @dataclass",
          "1552:         class X:",
          "1553:             y: int",
          "1555:         class Z(X):",
          "1556:             pass",
          "1558:         self.assertTrue(is_dataclass(X), \"X should be a dataclass\")",
          "1559:         self.assertTrue(",
          "1560:             is_dataclass(Z),",
          "1561:             \"Z should be a dataclass because it inherits from X\",",
          "1562:         )",
          "1563:         z_instance = Z(y=5)",
          "1564:         self.assertTrue(",
          "1565:             is_dataclass(z_instance),",
          "1566:             \"z_instance should be a dataclass because it is an instance of Z\",",
          "1567:         )",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "64c4139f61517cb8845b42fce0a1dad0e6ebbd9a",
      "candidate_info": {
        "commit_hash": "64c4139f61517cb8845b42fce0a1dad0e6ebbd9a",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/64c4139f61517cb8845b42fce0a1dad0e6ebbd9a",
        "files": [
          "Include/cpython/pyatomic_gcc.h"
        ],
        "message": "[3.13] gh-120593: Fix const qualifier in pyatomic.h (GH-121055) (#121057)\n\ngh-120593: Fix const qualifier in pyatomic.h (GH-121055)\n(cherry picked from commit 9cd2dcbb87fb3c35d8ca3554d9472ac283f62a64)\n\nCo-authored-by: Victor Stinner <vstinner@python.org>",
        "before_after_code_files": [
          "Include/cpython/pyatomic_gcc.h||Include/cpython/pyatomic_gcc.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Include/cpython/pyatomic_gcc.h||Include/cpython/pyatomic_gcc.h": [
          "File: Include/cpython/pyatomic_gcc.h -> Include/cpython/pyatomic_gcc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "298: static inline void *",
          "299: _Py_atomic_load_ptr(const void *obj)",
          "",
          "[Removed Lines]",
          "300: { return (void *)__atomic_load_n((void **)obj, __ATOMIC_SEQ_CST); }",
          "",
          "[Added Lines]",
          "300: { return (void *)__atomic_load_n((void * const *)obj, __ATOMIC_SEQ_CST); }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "357: static inline void *",
          "358: _Py_atomic_load_ptr_relaxed(const void *obj)",
          "361: static inline unsigned long long",
          "362: _Py_atomic_load_ullong_relaxed(const unsigned long long *obj)",
          "",
          "[Removed Lines]",
          "359: { return (void *)__atomic_load_n((const void **)obj, __ATOMIC_RELAXED); }",
          "",
          "[Added Lines]",
          "359: { return (void *)__atomic_load_n((void * const *)obj, __ATOMIC_RELAXED); }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "491: static inline void *",
          "492: _Py_atomic_load_ptr_acquire(const void *obj)",
          "495: static inline uintptr_t",
          "496: _Py_atomic_load_uintptr_acquire(const uintptr_t *obj)",
          "499: static inline void",
          "500: _Py_atomic_store_ptr_release(void *obj, void *value)",
          "",
          "[Removed Lines]",
          "493: { return (void *)__atomic_load_n((void **)obj, __ATOMIC_ACQUIRE); }",
          "497: { return (uintptr_t)__atomic_load_n((uintptr_t *)obj, __ATOMIC_ACQUIRE); }",
          "",
          "[Added Lines]",
          "493: { return (void *)__atomic_load_n((void * const *)obj, __ATOMIC_ACQUIRE); }",
          "497: { return (uintptr_t)__atomic_load_n(obj, __ATOMIC_ACQUIRE); }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6b10467fbc0b67bf217ea27956b545103c4a0ad5",
      "candidate_info": {
        "commit_hash": "6b10467fbc0b67bf217ea27956b545103c4a0ad5",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/6b10467fbc0b67bf217ea27956b545103c4a0ad5",
        "files": [
          "Lib/_pyrepl/reader.py",
          "Lib/test/test_pyrepl/test_reader.py",
          "Misc/NEWS.d/next/Library/2024-06-02-15-09-17.gh-issue-118835.KUAuz6.rst"
        ],
        "message": "[3.13] gh-118835: pyrepl: Fix prompt length computation for custom prompts containing ANSI escape codes (GH-119942) (#119990)\n\ngh-118835: pyrepl: Fix prompt length computation for custom prompts containing ANSI escape codes (GH-119942)\n(cherry picked from commit 2e0aa731aebb8ef3d89ada82f5d39b1bbac65d1f)\n\nCo-authored-by: Daniel Hollas <daniel.hollas@bristol.ac.uk>",
        "before_after_code_files": [
          "Lib/_pyrepl/reader.py||Lib/_pyrepl/reader.py",
          "Lib/test/test_pyrepl/test_reader.py||Lib/test/test_pyrepl/test_reader.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/_pyrepl/reader.py||Lib/_pyrepl/reader.py": [
          "File: Lib/_pyrepl/reader.py -> Lib/_pyrepl/reader.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: from . import commands, console, input",
          "32: from .trace import trace",
          "",
          "[Removed Lines]",
          "31: from .utils import ANSI_ESCAPE_SEQUENCE, wlen",
          "",
          "[Added Lines]",
          "31: from .utils import ANSI_ESCAPE_SEQUENCE, wlen, str_width",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "339:                 screeninfo.append((0, []))",
          "340:         return screen",
          "343:         \"\"\"Process the prompt.",
          "345:         This means calculate the length of the prompt. The character \\x01",
          "",
          "[Removed Lines]",
          "342:     def process_prompt(self, prompt: str) -> tuple[str, int]:",
          "",
          "[Added Lines]",
          "342:     @staticmethod",
          "343:     def process_prompt(prompt: str) -> tuple[str, int]:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "351:         # sequences if they were not explicitly within \\x01...\\x02.",
          "352:         # They are CSI (or ANSI) sequences  ( ESC [ ... LETTER )",
          "354:         out_prompt = \"\"",
          "355:         l = wlen(prompt)",
          "356:         pos = 0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "355:         # wlen from utils already excludes ANSI_ESCAPE_SEQUENCE chars,",
          "356:         # which breaks the logic below so we redefine it here.",
          "357:         def wlen(s: str) -> int:",
          "358:             return sum(str_width(i) for i in s)",
          "",
          "---------------"
        ],
        "Lib/test/test_pyrepl/test_reader.py||Lib/test/test_pyrepl/test_reader.py": [
          "File: Lib/test/test_pyrepl/test_reader.py -> Lib/test/test_pyrepl/test_reader.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: from .support import handle_all_events, handle_events_narrow_console, code_to_events, prepare_reader",
          "6: from _pyrepl.console import Event",
          "9: class TestReader(TestCase):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: from _pyrepl.reader import Reader",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "176:         )",
          "177:         self.assert_screen_equals(reader, expected)",
          "178:         self.assertTrue(reader.finished)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "181:     def test_prompt_length(self):",
          "182:         # Handles simple ASCII prompt",
          "183:         ps1 = \">>> \"",
          "184:         prompt, l = Reader.process_prompt(ps1)",
          "185:         self.assertEqual(prompt, ps1)",
          "186:         self.assertEqual(l, 4)",
          "188:         # Handles ANSI escape sequences",
          "189:         ps1 = \"\\033[0;32m>>> \\033[0m\"",
          "190:         prompt, l = Reader.process_prompt(ps1)",
          "191:         self.assertEqual(prompt, \"\\033[0;32m>>> \\033[0m\")",
          "192:         self.assertEqual(l, 4)",
          "194:         # Handles ANSI escape sequences bracketed in \\001 .. \\002",
          "195:         ps1 = \"\\001\\033[0;32m\\002>>> \\001\\033[0m\\002\"",
          "196:         prompt, l = Reader.process_prompt(ps1)",
          "197:         self.assertEqual(prompt, \"\\033[0;32m>>> \\033[0m\")",
          "198:         self.assertEqual(l, 4)",
          "200:         # Handles wide characters in prompt",
          "201:         ps1 = \"\u6a02>> \"",
          "202:         prompt, l = Reader.process_prompt(ps1)",
          "203:         self.assertEqual(prompt, ps1)",
          "204:         self.assertEqual(l, 5)",
          "206:         # Handles wide characters AND ANSI sequences together",
          "207:         ps1 = \"\\001\\033[0;32m\\002\u6a02>\\001\\033[0m\\002> \"",
          "208:         prompt, l = Reader.process_prompt(ps1)",
          "209:         self.assertEqual(prompt, \"\\033[0;32m\u6a02>\\033[0m> \")",
          "210:         self.assertEqual(l, 5)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3a8ab99bf796f549ffde0f1b818b54a754796978",
      "candidate_info": {
        "commit_hash": "3a8ab99bf796f549ffde0f1b818b54a754796978",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/3a8ab99bf796f549ffde0f1b818b54a754796978",
        "files": [
          "Lib/asyncio/staggered.py",
          "Lib/test/test_asyncio/test_staggered.py",
          "Misc/NEWS.d/next/Library/2024-05-19-13-05-59.gh-issue-119121.P1gnh1.rst"
        ],
        "message": "[3.13] gh-119121: Fix and test `async.staggered.staggered_race` (GH-119173) (#119206)\n\ngh-119121: Fix and test `async.staggered.staggered_race` (GH-119173)\n(cherry picked from commit 16b46ebd2b0025aa461fdfc95fbf98a4f04b49e6)\n\nCo-authored-by: Nikita Sobolev <mail@sobolevn.me>",
        "before_after_code_files": [
          "Lib/asyncio/staggered.py||Lib/asyncio/staggered.py",
          "Lib/test/test_asyncio/test_staggered.py||Lib/test/test_asyncio/test_staggered.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/asyncio/staggered.py||Lib/asyncio/staggered.py": [
          "File: Lib/asyncio/staggered.py -> Lib/asyncio/staggered.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "69:     exceptions = []",
          "70:     running_tasks = []",
          "74:         # Wait for the previous task to finish, or for delay seconds",
          "75:         if previous_failed is not None:",
          "76:             with contextlib.suppress(exceptions_mod.TimeoutError):",
          "",
          "[Removed Lines]",
          "72:     async def run_one_coro(",
          "73:             previous_failed: typing.Optional[locks.Event]) -> None:",
          "",
          "[Added Lines]",
          "72:     async def run_one_coro(previous_failed) -> None:",
          "",
          "---------------"
        ],
        "Lib/test/test_asyncio/test_staggered.py||Lib/test/test_asyncio/test_staggered.py": [
          "File: Lib/test/test_asyncio/test_staggered.py -> Lib/test/test_asyncio/test_staggered.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import asyncio",
          "2: import unittest",
          "3: from asyncio.staggered import staggered_race",
          "5: from test import support",
          "7: support.requires_working_socket(module=True)",
          "10: def tearDownModule():",
          "11:     asyncio.set_event_loop_policy(None)",
          "14: class StaggeredTests(unittest.IsolatedAsyncioTestCase):",
          "15:     async def test_empty(self):",
          "16:         winner, index, excs = await staggered_race(",
          "17:             [],",
          "18:             delay=None,",
          "19:         )",
          "21:         self.assertIs(winner, None)",
          "22:         self.assertIs(index, None)",
          "23:         self.assertEqual(excs, [])",
          "25:     async def test_one_successful(self):",
          "26:         async def coro(index):",
          "27:             return f'Res: {index}'",
          "29:         winner, index, excs = await staggered_race(",
          "30:             [",
          "31:                 lambda: coro(0),",
          "32:                 lambda: coro(1),",
          "33:             ],",
          "34:             delay=None,",
          "35:         )",
          "37:         self.assertEqual(winner, 'Res: 0')",
          "38:         self.assertEqual(index, 0)",
          "39:         self.assertEqual(excs, [None])",
          "41:     async def test_first_error_second_successful(self):",
          "42:         async def coro(index):",
          "43:             if index == 0:",
          "44:                 raise ValueError(index)",
          "45:             return f'Res: {index}'",
          "47:         winner, index, excs = await staggered_race(",
          "48:             [",
          "49:                 lambda: coro(0),",
          "50:                 lambda: coro(1),",
          "51:             ],",
          "52:             delay=None,",
          "53:         )",
          "55:         self.assertEqual(winner, 'Res: 1')",
          "56:         self.assertEqual(index, 1)",
          "57:         self.assertEqual(len(excs), 2)",
          "58:         self.assertIsInstance(excs[0], ValueError)",
          "59:         self.assertIs(excs[1], None)",
          "61:     async def test_first_timeout_second_successful(self):",
          "62:         async def coro(index):",
          "63:             if index == 0:",
          "64:                 await asyncio.sleep(10)  # much bigger than delay",
          "65:             return f'Res: {index}'",
          "67:         winner, index, excs = await staggered_race(",
          "68:             [",
          "69:                 lambda: coro(0),",
          "70:                 lambda: coro(1),",
          "71:             ],",
          "72:             delay=0.1,",
          "73:         )",
          "75:         self.assertEqual(winner, 'Res: 1')",
          "76:         self.assertEqual(index, 1)",
          "77:         self.assertEqual(len(excs), 2)",
          "78:         self.assertIsInstance(excs[0], asyncio.CancelledError)",
          "79:         self.assertIs(excs[1], None)",
          "81:     async def test_none_successful(self):",
          "82:         async def coro(index):",
          "83:             raise ValueError(index)",
          "85:         winner, index, excs = await staggered_race(",
          "86:             [",
          "87:                 lambda: coro(0),",
          "88:                 lambda: coro(1),",
          "89:             ],",
          "90:             delay=None,",
          "91:         )",
          "93:         self.assertIs(winner, None)",
          "94:         self.assertIs(index, None)",
          "95:         self.assertEqual(len(excs), 2)",
          "96:         self.assertIsInstance(excs[0], ValueError)",
          "97:         self.assertIsInstance(excs[1], ValueError)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
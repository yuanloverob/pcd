{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
  "patch_info": {
    "commit_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/d86b49411753bf2c83291e3a14ae43fefded2f84",
    "files": [
      "Doc/whatsnew/3.13.rst",
      "Misc/NEWS.d/next/Security/2024-05-01-20-57-09.gh-issue-118486.K44KJG.rst"
    ],
    "message": "gh-118486: Update docs for CVE-2024-4030 reference (GH-118737)\n\nUpdate docs for CVE-2024-4030 reference",
    "before_after_code_files": []
  },
  "patch_diff": {},
  "candidates": [
    {
      "candidate_hash": "aba5f2a4d10a7b261d4af03a54a8b1083bd83700",
      "candidate_info": {
        "commit_hash": "aba5f2a4d10a7b261d4af03a54a8b1083bd83700",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/aba5f2a4d10a7b261d4af03a54a8b1083bd83700",
        "files": [
          "Lib/test/test_unittest/testmock/support.py",
          "Lib/test/test_unittest/testmock/testpatch.py",
          "Lib/unittest/mock.py",
          "Misc/NEWS.d/next/Library/2024-06-10-14-00-40.gh-issue-119600.jJMf4C.rst"
        ],
        "message": "[3.13] gh-119600: mock: do not access attributes of original when new_callable is set (GH-119601) (#120334)\n\ngh-119600: mock: do not access attributes of original when new_callable is set (GH-119601)\n\nIn order to patch flask.g e.g. as in GH-84982, that\nproxies getattr must not be invoked. For that,\nmock must not try to read from the original\nobject. In some cases that is unavoidable, e.g.\nwhen doing autospec. However, patch(\"flask.g\",\nnew_callable=MagicMock) should be entirely safe.\n(cherry picked from commit 422c4fc855afd18bcc6415902ea1d85a50cb7ce1)\n\nCo-authored-by: Robert Collins <robert.collins@cognite.com>",
        "before_after_code_files": [
          "Lib/test/test_unittest/testmock/support.py||Lib/test/test_unittest/testmock/support.py",
          "Lib/test/test_unittest/testmock/testpatch.py||Lib/test/test_unittest/testmock/testpatch.py",
          "Lib/unittest/mock.py||Lib/unittest/mock.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_unittest/testmock/support.py||Lib/test/test_unittest/testmock/support.py": [
          "File: Lib/test/test_unittest/testmock/support.py -> Lib/test/test_unittest/testmock/support.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: class X(object):",
          "16:     pass",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: # A standin for weurkzeug.local.LocalProxy - issue 119600",
          "19: def _inaccessible(*args, **kwargs):",
          "20:     raise AttributeError",
          "23: class OpaqueProxy:",
          "24:     __getattribute__ = _inaccessible",
          "27: g = OpaqueProxy()",
          "",
          "---------------"
        ],
        "Lib/test/test_unittest/testmock/testpatch.py||Lib/test/test_unittest/testmock/testpatch.py": [
          "File: Lib/test/test_unittest/testmock/testpatch.py -> Lib/test/test_unittest/testmock/testpatch.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2045:         with self.assertRaises(TypeError):",
          "2046:             test()",
          "2049: if __name__ == '__main__':",
          "2050:     unittest.main()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2048:     def test_patch_proxy_object(self):",
          "2049:         @patch(\"test.test_unittest.testmock.support.g\", new_callable=MagicMock())",
          "2050:         def test(_):",
          "2051:             pass",
          "2053:         test()",
          "",
          "---------------"
        ],
        "Lib/unittest/mock.py||Lib/unittest/mock.py": [
          "File: Lib/unittest/mock.py -> Lib/unittest/mock.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1508:                 if isinstance(original, type):",
          "1509:                     # If we're patching out a class and there is a spec",
          "1510:                     inherit = True",
          "1516:             if new_callable is not None:",
          "1517:                 Klass = new_callable",
          "1518:             elif spec is not None or spec_set is not None:",
          "1519:                 this_spec = spec",
          "1520:                 if spec_set is not None:",
          "",
          "[Removed Lines]",
          "1511:             if spec is None and _is_async_obj(original):",
          "1512:                 Klass = AsyncMock",
          "1513:             else:",
          "1514:                 Klass = MagicMock",
          "1515:             _kwargs = {}",
          "",
          "[Added Lines]",
          "1512:             # Determine the Klass to use",
          "1515:             elif spec is None and _is_async_obj(original):",
          "1516:                 Klass = AsyncMock",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1527:                     Klass = AsyncMock",
          "1528:                 elif not_callable:",
          "1529:                     Klass = NonCallableMagicMock",
          "1531:             if spec is not None:",
          "1532:                 _kwargs['spec'] = spec",
          "1533:             if spec_set is not None:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1529:                 else:",
          "1530:                     Klass = MagicMock",
          "1531:             else:",
          "1532:                 Klass = MagicMock",
          "1534:             _kwargs = {}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dbff1f107731c76770ed279170a709a54601f8be",
      "candidate_info": {
        "commit_hash": "dbff1f107731c76770ed279170a709a54601f8be",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/dbff1f107731c76770ed279170a709a54601f8be",
        "files": [
          "Lib/_pyrepl/reader.py"
        ],
        "message": "[3.13] gh-119434: Fix culmitive errors in wrapping as lines proceed (GH-119435) (#119441)\n\nFix culmitive errors in wrapping as lines proceed\n(cherry picked from commit e3bf5381fd056d0bbdd775463e3724aab2012e45)\n\nCo-authored-by: Dino Viehland <dinoviehland@gmail.com>",
        "before_after_code_files": [
          "Lib/_pyrepl/reader.py||Lib/_pyrepl/reader.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/_pyrepl/reader.py||Lib/_pyrepl/reader.py": [
          "File: Lib/_pyrepl/reader.py -> Lib/_pyrepl/reader.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "307:                 screen.append(prompt + l)",
          "308:                 screeninfo.append((lp, l2))",
          "309:             else:",
          "311:                     prelen = lp if i == 0 else 0",
          "312:                     index_to_wrap_before = 0",
          "313:                     column = 0",
          "",
          "[Removed Lines]",
          "310:                 for i in range(wrapcount + 1):",
          "",
          "[Added Lines]",
          "310:                 i = 0",
          "311:                 while l:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "317:                         index_to_wrap_before += 1",
          "318:                         column += character_width",
          "319:                     pre = prompt if i == 0 else \"\"",
          "322:                     screen.append(pre + l[:index_to_wrap_before] + post)",
          "323:                     screeninfo.append((prelen, l2[:index_to_wrap_before] + after))",
          "324:                     l = l[index_to_wrap_before:]",
          "325:                     l2 = l2[index_to_wrap_before:]",
          "326:         self.screeninfo = screeninfo",
          "327:         self.cxy = self.pos2xy()",
          "328:         if self.msg and self.msg_at_bottom:",
          "",
          "[Removed Lines]",
          "320:                     post = \"\\\\\" if i != wrapcount else \"\"",
          "321:                     after = [1] if i != wrapcount else []",
          "",
          "[Added Lines]",
          "321:                     if len(l) > index_to_wrap_before:",
          "322:                         post = \"\\\\\"",
          "323:                         after = [1]",
          "324:                     else:",
          "325:                         post = \"\"",
          "326:                         after = []",
          "331:                     i += 1",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "09896fca2f821fdac8c2ba28ae5a4596c179ead3",
      "candidate_info": {
        "commit_hash": "09896fca2f821fdac8c2ba28ae5a4596c179ead3",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/09896fca2f821fdac8c2ba28ae5a4596c179ead3",
        "files": [
          "Lib/test/test_statistics.py"
        ],
        "message": "[3.13] [tests]: Mark ``test_statistics.test_kde_random`` with a ``requires_resource('cpu')`` decorator (GH-118801) (#118818)\n\n[tests]: Mark ``test_statistics.test_kde_random`` with a ``requires_resource('cpu')`` decorator (GH-118801)\n\nMark test_kde_random with a requires_resource('cpu') decorator\n(cherry picked from commit 027e6d88fb898b7477b822b84f791ca60e64300b)\n\nCo-authored-by: Kirill Podoprigora <kirill.bast9@mail.ru>",
        "before_after_code_files": [
          "Lib/test/test_statistics.py||Lib/test/test_statistics.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_statistics.py||Lib/test/test_statistics.py": [
          "File: Lib/test/test_statistics.py -> Lib/test/test_statistics.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2446:                 for x in xarr:",
          "2447:                     self.assertAlmostEqual(invcdf(cdf(x)), x, places=5)",
          "2449:     def test_kde_random(self):",
          "2450:         kde_random = statistics.kde_random",
          "2451:         StatisticsError = statistics.StatisticsError",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2449:     @support.requires_resource('cpu')",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9172bc35c669b7706d7122d4f0a90f065700a474",
      "candidate_info": {
        "commit_hash": "9172bc35c669b7706d7122d4f0a90f065700a474",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/9172bc35c669b7706d7122d4f0a90f065700a474",
        "files": [
          "Lib/test/test_import/__init__.py",
          "Python/import.c"
        ],
        "message": "[3.13] gh-115649: Copy the filename into main interpreter before intern in import.c (GH-120315) (#120652)\n\ngh-115649: Copy the filename into main interpreter before intern in import.c (GH-120315)\n(cherry picked from commit 28140d1f2da1766bfbb83f58779f15255c73c871)\n\nCo-authored-by: AN Long <aisk@users.noreply.github.com>\nCo-authored-by: Kumar Aditya <kumaraditya@python.org>",
        "before_after_code_files": [
          "Lib/test/test_import/__init__.py||Lib/test/test_import/__init__.py",
          "Python/import.c||Python/import.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_import/__init__.py||Lib/test/test_import/__init__.py": [
          "File: Lib/test/test_import/__init__.py -> Lib/test/test_import/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2157:             self.check_incompatible_here(module)",
          "2158:         with self.subTest(f'{module}: strict, fresh'):",
          "2159:             self.check_incompatible_fresh(module)",
          "2161:     @unittest.skipIf(_testmultiphase is None, \"test requires _testmultiphase module\")",
          "2162:     def test_multi_init_extension_compat(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2160:         with self.subTest(f'{module}: isolated, fresh'):",
          "2161:             self.check_incompatible_fresh(module, isolated=True)",
          "",
          "---------------"
        ],
        "Python/import.c||Python/import.c": [
          "File: Python/import.c -> Python/import.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1969:             if (info->filename != NULL) {",
          "1973:                 PyUnicode_InternInPlace(&filename);",
          "1974:                 if (PyModule_AddObjectRef(mod, \"__file__\", filename) < 0) {",
          "",
          "[Removed Lines]",
          "1972:                 PyObject *filename = Py_NewRef(info->filename);",
          "",
          "[Added Lines]",
          "1972:                 PyObject *filename = NULL;",
          "1973:                 if (switched) {",
          "1976:                     filename = _PyUnicode_Copy(info->filename);",
          "1977:                     if (filename == NULL) {",
          "1978:                         return NULL;",
          "1979:                     }",
          "1980:                 } else {",
          "1981:                     filename = Py_NewRef(info->filename);",
          "1982:                 }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7dc9875d558447bb71c0e87ab70399120e4aa700",
      "candidate_info": {
        "commit_hash": "7dc9875d558447bb71c0e87ab70399120e4aa700",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/7dc9875d558447bb71c0e87ab70399120e4aa700",
        "files": [
          "Doc/whatsnew/3.13.rst",
          "Lib/test/test_mmap.py",
          "Misc/NEWS.d/next/Windows/2024-04-24-05-16-32.gh-issue-118209.Ryyzlz.rst",
          "Modules/mmapmodule.c"
        ],
        "message": "gh-118209: Add Windows structured exception handling to mmap module (GH-118213)\n\n(cherry picked from commit e85e8deaf3220c8d12b69294e45645aaf20187b9)\n\nCo-authored-by: Dobatymo <Dobatymo@users.noreply.github.com>",
        "before_after_code_files": [
          "Lib/test/test_mmap.py||Lib/test/test_mmap.py",
          "Modules/mmapmodule.c||Modules/mmapmodule.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/test_mmap.py||Lib/test/test_mmap.py": [
          "File: Lib/test/test_mmap.py -> Lib/test/test_mmap.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: )",
          "4: from test.support.import_helper import import_module",
          "5: from test.support.os_helper import TESTFN, unlink",
          "6: import unittest",
          "7: import errno",
          "8: import os",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: from test.support.script_helper import assert_python_ok",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "12: import socket",
          "13: import string",
          "14: import sys",
          "15: import weakref",
          "17: # Skip test if we can't import mmap.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: import textwrap",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1058:                 with self.assertRaisesRegex(ValueError, \"mmap closed or invalid\"):",
          "1059:                     m.write_byte(X())",
          "1061: class LargeMmapTests(unittest.TestCase):",
          "1063:     def setUp(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1063:     @unittest.skipUnless(os.name == 'nt', 'requires Windows')",
          "1064:     @unittest.skipUnless(hasattr(mmap.mmap, '_protect'), 'test needs debug build')",
          "1065:     def test_access_violations(self):",
          "1066:         from test.support.os_helper import TESTFN",
          "1068:         code = textwrap.dedent(\"\"\"",
          "1069:             import faulthandler",
          "1070:             import mmap",
          "1071:             import os",
          "1072:             import sys",
          "1073:             from contextlib import suppress",
          "1075:             # Prevent logging access violations to stderr.",
          "1076:             faulthandler.disable()",
          "1078:             PAGESIZE = mmap.PAGESIZE",
          "1079:             PAGE_NOACCESS = 0x01",
          "1081:             with open(sys.argv[1], 'bw+') as f:",
          "1082:                 f.write(b'A'* PAGESIZE)",
          "1083:                 f.flush()",
          "1085:                 m = mmap.mmap(f.fileno(), PAGESIZE)",
          "1086:                 m._protect(PAGE_NOACCESS, 0, PAGESIZE)",
          "1087:                 with suppress(OSError):",
          "1088:                     m.read(PAGESIZE)",
          "1089:                     assert False, 'mmap.read() did not raise'",
          "1090:                 with suppress(OSError):",
          "1091:                     m.read_byte()",
          "1092:                     assert False, 'mmap.read_byte() did not raise'",
          "1093:                 with suppress(OSError):",
          "1094:                     m.readline()",
          "1095:                     assert False, 'mmap.readline() did not raise'",
          "1096:                 with suppress(OSError):",
          "1097:                     m.write(b'A'* PAGESIZE)",
          "1098:                     assert False, 'mmap.write() did not raise'",
          "1099:                 with suppress(OSError):",
          "1100:                     m.write_byte(0)",
          "1101:                     assert False, 'mmap.write_byte() did not raise'",
          "1102:                 with suppress(OSError):",
          "1103:                     m[0]  # test mmap_subscript",
          "1104:                     assert False, 'mmap.__getitem__() did not raise'",
          "1105:                 with suppress(OSError):",
          "1106:                     m[0:10]  # test mmap_subscript",
          "1107:                     assert False, 'mmap.__getitem__() did not raise'",
          "1108:                 with suppress(OSError):",
          "1109:                     m[0:10:2]  # test mmap_subscript",
          "1110:                     assert False, 'mmap.__getitem__() did not raise'",
          "1111:                 with suppress(OSError):",
          "1112:                     m[0] = 1",
          "1113:                     assert False, 'mmap.__setitem__() did not raise'",
          "1114:                 with suppress(OSError):",
          "1115:                     m[0:10] = b'A'* 10",
          "1116:                     assert False, 'mmap.__setitem__() did not raise'",
          "1117:                 with suppress(OSError):",
          "1118:                     m[0:10:2] = b'A'* 5",
          "1119:                     assert False, 'mmap.__setitem__() did not raise'",
          "1120:                 with suppress(OSError):",
          "1121:                     m.move(0, 10, 1)",
          "1122:                     assert False, 'mmap.move() did not raise'",
          "1123:                 with suppress(OSError):",
          "1124:                     list(m)  # test mmap_item",
          "1125:                     assert False, 'mmap.__getitem__() did not raise'",
          "1126:                 with suppress(OSError):",
          "1127:                     m.find(b'A')",
          "1128:                     assert False, 'mmap.find() did not raise'",
          "1129:                 with suppress(OSError):",
          "1130:                     m.rfind(b'A')",
          "1131:                     assert False, 'mmap.rfind() did not raise'",
          "1132:         \"\"\")",
          "1133:         rt, stdout, stderr = assert_python_ok(\"-c\", code, TESTFN)",
          "1134:         self.assertEqual(stdout.strip(), b'')",
          "1135:         self.assertEqual(stderr.strip(), b'')",
          "",
          "---------------"
        ],
        "Modules/mmapmodule.c||Modules/mmapmodule.c": [
          "File: Modules/mmapmodule.c -> Modules/mmapmodule.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: #ifdef MS_WINDOWS",
          "43: #include <windows.h>",
          "44: static int",
          "45: my_getpagesize(void)",
          "46: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "44: #include <ntsecapi.h> // LsaNtStatusToWinError",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "255: } while (0)",
          "258: static PyObject *",
          "259: mmap_read_byte_method(mmap_object *self,",
          "260:                       PyObject *Py_UNUSED(ignored))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "259: #if defined(MS_WINDOWS) && !defined(DONT_USE_SEH)",
          "260: static DWORD",
          "261: filter_page_exception(EXCEPTION_POINTERS *ptrs, EXCEPTION_RECORD *record)",
          "262: {",
          "264:     if (record->ExceptionCode == EXCEPTION_IN_PAGE_ERROR ||",
          "265:         record->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)",
          "266:     {",
          "267:         return EXCEPTION_EXECUTE_HANDLER;",
          "268:     }",
          "269:     return EXCEPTION_CONTINUE_SEARCH;",
          "270: }",
          "272: static DWORD",
          "273: filter_page_exception_method(mmap_object *self, EXCEPTION_POINTERS *ptrs,",
          "274:                              EXCEPTION_RECORD *record)",
          "275: {",
          "277:     if (record->ExceptionCode == EXCEPTION_IN_PAGE_ERROR ||",
          "278:         record->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)",
          "279:     {",
          "281:         ULONG_PTR address = record->ExceptionInformation[1];",
          "282:         if (address >= (ULONG_PTR) self->data &&",
          "283:             address < (ULONG_PTR) self->data + (ULONG_PTR) self->size)",
          "284:         {",
          "285:             return EXCEPTION_EXECUTE_HANDLER;",
          "286:         }",
          "287:     }",
          "288:     return EXCEPTION_CONTINUE_SEARCH;",
          "289: }",
          "290: #endif",
          "292: #if defined(MS_WINDOWS) && !defined(DONT_USE_SEH)",
          "293: #define HANDLE_INVALID_MEM(sourcecode)                                     \\",
          "294: do {                                                                       \\",
          "295:     EXCEPTION_RECORD record;                                               \\",
          "296:     __try {                                                                \\",
          "297:         sourcecode                                                         \\",
          "298:     }                                                                      \\",
          "299:     __except (filter_page_exception(GetExceptionInformation(), &record)) { \\",
          "300:         assert(record.ExceptionCode == EXCEPTION_IN_PAGE_ERROR ||          \\",
          "301:                record.ExceptionCode == EXCEPTION_ACCESS_VIOLATION);        \\",
          "302:         if (record.ExceptionCode == EXCEPTION_IN_PAGE_ERROR) {             \\",
          "303:             NTSTATUS status = (NTSTATUS) record.ExceptionInformation[2];   \\",
          "304:             ULONG code = LsaNtStatusToWinError(status);                    \\",
          "305:             PyErr_SetFromWindowsErr(code);                                 \\",
          "306:         }                                                                  \\",
          "307:         else if (record.ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {     \\",
          "308:             PyErr_SetFromWindowsErr(ERROR_NOACCESS);                       \\",
          "309:         }                                                                  \\",
          "310:         return -1;                                                         \\",
          "311:     }                                                                      \\",
          "312: } while (0)",
          "313: #else",
          "314: #define HANDLE_INVALID_MEM(sourcecode)                                     \\",
          "315: do {                                                                       \\",
          "316:     sourcecode                                                             \\",
          "317: } while (0)",
          "318: #endif",
          "320: #if defined(MS_WINDOWS) && !defined(DONT_USE_SEH)",
          "321: #define HANDLE_INVALID_MEM_METHOD(self, sourcecode)                           \\",
          "322: do {                                                                          \\",
          "323:     EXCEPTION_RECORD record;                                                  \\",
          "324:     __try {                                                                   \\",
          "325:         sourcecode                                                            \\",
          "326:     }                                                                         \\",
          "327:     __except (filter_page_exception_method(self, GetExceptionInformation(),   \\",
          "328:                                            &record)) {                        \\",
          "329:         assert(record.ExceptionCode == EXCEPTION_IN_PAGE_ERROR ||             \\",
          "330:                record.ExceptionCode == EXCEPTION_ACCESS_VIOLATION);           \\",
          "331:         if (record.ExceptionCode == EXCEPTION_IN_PAGE_ERROR) {                \\",
          "332:             NTSTATUS status = (NTSTATUS) record.ExceptionInformation[2];      \\",
          "333:             ULONG code = LsaNtStatusToWinError(status);                       \\",
          "334:             PyErr_SetFromWindowsErr(code);                                    \\",
          "335:         }                                                                     \\",
          "336:         else if (record.ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {        \\",
          "337:             PyErr_SetFromWindowsErr(ERROR_NOACCESS);                          \\",
          "338:         }                                                                     \\",
          "339:         return -1;                                                            \\",
          "340:     }                                                                         \\",
          "341: } while (0)",
          "342: #else",
          "343: #define HANDLE_INVALID_MEM_METHOD(self, sourcecode)                           \\",
          "344: do {                                                                          \\",
          "345:     sourcecode                                                                \\",
          "346: } while (0)",
          "347: #endif",
          "349: int",
          "350: safe_memcpy(void *dest, const void *src, size_t count)",
          "351: {",
          "352:     HANDLE_INVALID_MEM(",
          "353:         memcpy(dest, src, count);",
          "354:     );",
          "355:     return 0;",
          "356: }",
          "358: int",
          "359: safe_byte_copy(char *dest, const char *src)",
          "360: {",
          "361:     HANDLE_INVALID_MEM(",
          "363:     );",
          "364:     return 0;",
          "365: }",
          "367: int",
          "368: safe_memchr(char **out, const void *ptr, int ch, size_t count)",
          "369: {",
          "370:     HANDLE_INVALID_MEM(",
          "372:     );",
          "373:     return 0;",
          "374: }",
          "376: int",
          "377: safe_memmove(void *dest, const void *src, size_t count)",
          "378: {",
          "379:     HANDLE_INVALID_MEM(",
          "380:         memmove(dest, src, count);",
          "381:     );",
          "382:     return 0;",
          "383: }",
          "385: int",
          "386: safe_copy_from_slice(char *dest, const char *src, Py_ssize_t start,",
          "387:                      Py_ssize_t step, Py_ssize_t slicelen)",
          "388: {",
          "389:     HANDLE_INVALID_MEM(",
          "390:         size_t cur;",
          "391:         Py_ssize_t i;",
          "392:         for (cur = start, i = 0; i < slicelen; cur += step, i++) {",
          "393:             dest[cur] = src[i];",
          "394:         }",
          "395:     );",
          "396:     return 0;",
          "397: }",
          "399: int",
          "400: safe_copy_to_slice(char *dest, const char *src, Py_ssize_t start,",
          "401:                    Py_ssize_t step, Py_ssize_t slicelen)",
          "402: {",
          "403:     HANDLE_INVALID_MEM(",
          "404:         size_t cur;",
          "405:         Py_ssize_t i;",
          "406:         for (cur = start, i = 0; i < slicelen; cur += step, i++) {",
          "407:             dest[i] = src[cur];",
          "408:         }",
          "409:     );",
          "410:     return 0;",
          "411: }",
          "414: int",
          "415: _safe_PyBytes_Find(Py_ssize_t *out, mmap_object *self, const char *haystack,",
          "416:                    Py_ssize_t len_haystack, const char *needle,",
          "417:                    Py_ssize_t len_needle, Py_ssize_t offset)",
          "418: {",
          "419:     HANDLE_INVALID_MEM_METHOD(self,",
          "421:     );",
          "422:     return 0;",
          "423: }",
          "425: int",
          "426: _safe_PyBytes_ReverseFind(Py_ssize_t *out, mmap_object *self,",
          "427:                           const char *haystack, Py_ssize_t len_haystack,",
          "428:                           const char *needle, Py_ssize_t len_needle,",
          "429:                           Py_ssize_t offset)",
          "430: {",
          "431:     HANDLE_INVALID_MEM_METHOD(self,",
          "433:                                     offset);",
          "434:     );",
          "435:     return 0;",
          "436: }",
          "438: PyObject *",
          "439: _safe_PyBytes_FromStringAndSize(char *start, size_t num_bytes) {",
          "440:     if (num_bytes == 1) {",
          "441:         char dest;",
          "442:         if (safe_byte_copy(&dest, start) < 0) {",
          "443:             return NULL;",
          "444:         }",
          "445:         else {",
          "446:             return PyBytes_FromStringAndSize(&dest, 1);",
          "447:         }",
          "448:     }",
          "449:     else {",
          "450:         PyObject *result = PyBytes_FromStringAndSize(NULL, num_bytes);",
          "451:         if (result == NULL) {",
          "452:             return NULL;",
          "453:         }",
          "454:         if (safe_memcpy(PyBytes_AS_STRING(result), start, num_bytes) < 0) {",
          "455:             Py_CLEAR(result);",
          "456:         }",
          "457:         return result;",
          "458:     }",
          "459: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "264:         PyErr_SetString(PyExc_ValueError, \"read byte out of range\");",
          "265:         return NULL;",
          "266:     }",
          "268: }",
          "270: static PyObject *",
          "",
          "[Removed Lines]",
          "267:     return PyLong_FromLong((unsigned char)self->data[self->pos++]);",
          "",
          "[Added Lines]",
          "470:     char dest;",
          "471:     if (safe_byte_copy(&dest, self->data + self->pos) < 0) {",
          "472:         return NULL;",
          "473:     }",
          "474:     self->pos++;",
          "475:     return PyLong_FromLong((unsigned char) dest);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "273: {",
          "274:     Py_ssize_t remaining;",
          "275:     char *start, *eol;",
          "278:     CHECK_VALID(NULL);",
          "",
          "[Removed Lines]",
          "276:     PyObject *result;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "281:     if (!remaining)",
          "282:         return PyBytes_FromString(\"\");",
          "283:     start = self->data + self->pos;",
          "285:     if (!eol)",
          "286:         eol = self->data + self->size;",
          "287:     else",
          "291:     return result;",
          "292: }",
          "",
          "[Removed Lines]",
          "284:     eol = memchr(start, '\\n', remaining);",
          "289:     result = PyBytes_FromStringAndSize(start, (eol - start));",
          "290:     self->pos += (eol - start);",
          "",
          "[Added Lines]",
          "492:     if (safe_memchr(&eol, start, '\\n', remaining) < 0) {",
          "493:         return NULL;",
          "494:     }",
          "501:     PyObject *result = _safe_PyBytes_FromStringAndSize(start, eol - start);",
          "502:     if (result != NULL) {",
          "503:         self->pos += (eol - start);",
          "504:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "296:                  PyObject *args)",
          "297: {",
          "298:     Py_ssize_t num_bytes = PY_SSIZE_T_MAX, remaining;",
          "301:     CHECK_VALID(NULL);",
          "302:     if (!PyArg_ParseTuple(args, \"|O&:read\", _Py_convert_optional_to_ssize_t, &num_bytes))",
          "",
          "[Removed Lines]",
          "299:     PyObject *result;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "307:     remaining = (self->pos < self->size) ? self->size - self->pos : 0;",
          "308:     if (num_bytes < 0 || num_bytes > remaining)",
          "309:         num_bytes = remaining;",
          "312:     return result;",
          "313: }",
          "",
          "[Removed Lines]",
          "310:     result = PyBytes_FromStringAndSize(&self->data[self->pos], num_bytes);",
          "311:     self->pos += num_bytes;",
          "",
          "[Added Lines]",
          "524:     PyObject *result = _safe_PyBytes_FromStringAndSize(self->data + self->pos,",
          "525:                                                        num_bytes);",
          "526:     if (result != NULL) {",
          "527:         self->pos += num_bytes;",
          "528:     }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "341:         else if (end > self->size)",
          "342:             end = self->size;",
          "345:         CHECK_VALID_OR_RELEASE(NULL, view);",
          "346:         if (end < start) {",
          "348:         }",
          "349:         else if (reverse) {",
          "350:             assert(0 <= start && start <= end && end <= self->size);",
          "352:                 self->data + start, end - start,",
          "354:         }",
          "355:         else {",
          "356:             assert(0 <= start && start <= end && end <= self->size);",
          "358:                 self->data + start, end - start,",
          "360:         }",
          "361:         PyBuffer_Release(&view);",
          "363:     }",
          "364: }",
          "",
          "[Removed Lines]",
          "344:         Py_ssize_t res;",
          "347:             res = -1;",
          "351:             res = _PyBytes_ReverseFind(",
          "353:                 view.buf, view.len, start);",
          "357:             res = _PyBytes_Find(",
          "359:                 view.buf, view.len, start);",
          "362:         return PyLong_FromSsize_t(res);",
          "",
          "[Added Lines]",
          "561:         Py_ssize_t index;",
          "562:         PyObject *result;",
          "565:             result = PyLong_FromSsize_t(-1);",
          "569:             if (_safe_PyBytes_ReverseFind(&index, self,",
          "571:                 view.buf, view.len, start) < 0)",
          "572:             {",
          "573:                 result = NULL;",
          "574:             }",
          "575:             else {",
          "576:                 result = PyLong_FromSsize_t(index);",
          "577:             }",
          "581:             if (_safe_PyBytes_Find(&index, self,",
          "583:                 view.buf, view.len, start) < 0)",
          "584:             {",
          "585:                 result = NULL;",
          "586:             }",
          "587:             else {",
          "588:                 result = PyLong_FromSsize_t(index);",
          "589:             }",
          "592:         return result;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "432:     }",
          "434:     CHECK_VALID_OR_RELEASE(NULL, data);",
          "437:     PyBuffer_Release(&data);",
          "439: }",
          "441: static PyObject *",
          "",
          "[Removed Lines]",
          "435:     memcpy(&self->data[self->pos], data.buf, data.len);",
          "436:     self->pos += data.len;",
          "438:     return PyLong_FromSsize_t(data.len);",
          "",
          "[Added Lines]",
          "665:     PyObject *result;",
          "666:     if (safe_memcpy(self->data + self->pos, data.buf, data.len) < 0) {",
          "667:         result = NULL;",
          "668:     }",
          "669:     else {",
          "670:         self->pos += data.len;",
          "671:         result = PyLong_FromSsize_t(data.len);",
          "672:     }",
          "674:     return result;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "452:         return NULL;",
          "454:     CHECK_VALID(NULL);",
          "460:         PyErr_SetString(PyExc_ValueError, \"write byte out of range\");",
          "461:         return NULL;",
          "462:     }",
          "463: }",
          "465: static PyObject *",
          "",
          "[Removed Lines]",
          "455:     if (self->pos < self->size) {",
          "456:         self->data[self->pos++] = value;",
          "457:         Py_RETURN_NONE;",
          "458:     }",
          "459:     else {",
          "",
          "[Added Lines]",
          "691:     if (self->pos >= self->size) {",
          "696:     if (safe_byte_copy(self->data + self->pos, &value) < 0) {",
          "697:         return NULL;",
          "698:     }",
          "699:     self->pos++;",
          "700:     Py_RETURN_NONE;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "763:             goto bounds;",
          "765:         CHECK_VALID(NULL);",
          "768:         Py_RETURN_NONE;",
          "770:       bounds:",
          "",
          "[Removed Lines]",
          "766:         memmove(&self->data[dest], &self->data[src], cnt);",
          "",
          "[Added Lines]",
          "1004:         if (safe_memmove(self->data + dest, self->data + src, cnt) < 0) {",
          "1005:             return NULL;",
          "1006:         };",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "855: }",
          "856: #endif",
          "858: #ifdef HAVE_MADVISE",
          "859: static PyObject *",
          "860: mmap_madvise_method(mmap_object *self, PyObject *args)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1097: #if defined(MS_WINDOWS) && defined(Py_DEBUG)",
          "1098: static PyObject *",
          "1099: mmap_protect_method(mmap_object *self, PyObject *args) {",
          "1100:     DWORD flNewProtect, flOldProtect;",
          "1101:     Py_ssize_t start, length;",
          "1103:     CHECK_VALID(NULL);",
          "1105:     if (!PyArg_ParseTuple(args, \"Inn:protect\", &flNewProtect, &start, &length)) {",
          "1106:         return NULL;",
          "1107:     }",
          "1109:     if (!VirtualProtect((void *) (self->data + start), length, flNewProtect,",
          "1110:                         &flOldProtect))",
          "1111:     {",
          "1112:         PyErr_SetFromWindowsErr(GetLastError());",
          "1113:         return NULL;",
          "1114:     }",
          "1116:     Py_RETURN_NONE;",
          "1117: }",
          "1118: #endif",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "924:     {\"__exit__\",        (PyCFunction) mmap__exit__method,       METH_VARARGS},",
          "925: #ifdef MS_WINDOWS",
          "926:     {\"__sizeof__\",      (PyCFunction) mmap__sizeof__method,     METH_NOARGS},",
          "929: };",
          "",
          "[Removed Lines]",
          "927: #endif",
          "",
          "[Added Lines]",
          "1189: #ifdef Py_DEBUG",
          "1190:     {\"_protect\",        (PyCFunction) mmap_protect_method,      METH_VARARGS},",
          "1191: #endif // Py_DEBUG",
          "1192: #endif // MS_WINDOWS",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "968:         PyErr_SetString(PyExc_IndexError, \"mmap index out of range\");",
          "969:         return NULL;",
          "970:     }",
          "972: }",
          "974: static PyObject *",
          "",
          "[Removed Lines]",
          "971:     return PyBytes_FromStringAndSize(self->data + i, 1);",
          "",
          "[Added Lines]",
          "1237:     char dest;",
          "1238:     if (safe_byte_copy(&dest, self->data + i) < 0) {",
          "1239:         return NULL;",
          "1240:     }",
          "1241:     return PyBytes_FromStringAndSize(&dest, 1);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "987:             return NULL;",
          "988:         }",
          "989:         CHECK_VALID(NULL);",
          "991:     }",
          "992:     else if (PySlice_Check(item)) {",
          "993:         Py_ssize_t start, stop, step, slicelen;",
          "",
          "[Removed Lines]",
          "990:         return PyLong_FromLong(Py_CHARMASK(self->data[i]));",
          "",
          "[Added Lines]",
          "1261:         char dest;",
          "1262:         if (safe_byte_copy(&dest, self->data + i) < 0) {",
          "1263:             return NULL;",
          "1264:         }",
          "1265:         return PyLong_FromLong(Py_CHARMASK(dest));",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1001:         if (slicelen <= 0)",
          "1002:             return PyBytes_FromStringAndSize(\"\", 0);",
          "1003:         else if (step == 1)",
          "1006:         else {",
          "1007:             char *result_buf = (char *)PyMem_Malloc(slicelen);",
          "1010:             PyObject *result;",
          "1012:             if (result_buf == NULL)",
          "1013:                 return PyErr_NoMemory();",
          "1018:             }",
          "1021:             PyMem_Free(result_buf);",
          "1022:             return result;",
          "1023:         }",
          "",
          "[Removed Lines]",
          "1004:             return PyBytes_FromStringAndSize(self->data + start,",
          "1005:                                               slicelen);",
          "1008:             size_t cur;",
          "1009:             Py_ssize_t i;",
          "1015:             for (cur = start, i = 0; i < slicelen;",
          "1016:                  cur += step, i++) {",
          "1017:                 result_buf[i] = self->data[cur];",
          "1019:             result = PyBytes_FromStringAndSize(result_buf,",
          "1020:                                                 slicelen);",
          "",
          "[Added Lines]",
          "1279:             return _safe_PyBytes_FromStringAndSize(self->data + start, slicelen);",
          "1287:             if (safe_copy_to_slice(result_buf, self->data, start, step,",
          "1288:                                    slicelen) < 0)",
          "1289:             {",
          "1290:                 result = NULL;",
          "1291:             }",
          "1292:             else {",
          "1293:                 result = PyBytes_FromStringAndSize(result_buf, slicelen);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1052:     if (!is_writable(self))",
          "1053:         return -1;",
          "1054:     buf = PyBytes_AsString(v);",
          "1056:     return 0;",
          "1057: }",
          "",
          "[Removed Lines]",
          "1055:     self->data[i] = buf[0];",
          "",
          "[Added Lines]",
          "1330:     if (safe_byte_copy(self->data + i, buf) < 0) {",
          "1331:         return -1;",
          "1332:     }",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1097:             return -1;",
          "1098:         }",
          "1099:         CHECK_VALID(-1);",
          "1101:         return 0;",
          "1102:     }",
          "1103:     else if (PySlice_Check(item)) {",
          "",
          "[Removed Lines]",
          "1100:         self->data[i] = (char) v;",
          "",
          "[Added Lines]",
          "1378:         char v_char = (char) v;",
          "1379:         if (safe_byte_copy(self->data + i, &v_char) < 0) {",
          "1380:             return -1;",
          "1381:         }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1123:         }",
          "1125:         CHECK_VALID_OR_RELEASE(-1, vbuf);",
          "1126:         if (slicelen == 0) {",
          "1127:         }",
          "1128:         else if (step == 1) {",
          "1130:         }",
          "1131:         else {",
          "1138:             {",
          "1140:             }",
          "1141:         }",
          "1142:         PyBuffer_Release(&vbuf);",
          "1144:     }",
          "1145:     else {",
          "1146:         PyErr_SetString(PyExc_TypeError,",
          "",
          "[Removed Lines]",
          "1129:             memcpy(self->data + start, vbuf.buf, slicelen);",
          "1132:             size_t cur;",
          "1133:             Py_ssize_t i;",
          "1135:             for (cur = start, i = 0;",
          "1136:                  i < slicelen;",
          "1137:                  cur += step, i++)",
          "1139:                 self->data[cur] = ((char *)vbuf.buf)[i];",
          "1143:         return 0;",
          "",
          "[Added Lines]",
          "1407:         int result = 0;",
          "1411:             if (safe_memcpy(self->data + start, vbuf.buf, slicelen) < 0) {",
          "1412:                 result = -1;",
          "1413:             }",
          "1416:             if (safe_copy_from_slice(self->data, (char *)vbuf.buf, start, step,",
          "1417:                                      slicelen) < 0)",
          "1419:                 result = -1;",
          "1423:         return result;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
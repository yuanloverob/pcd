{
  "cve_id": "CVE-2024-0397",
  "cve_desc": "A defect was discovered in the Python \u201cssl\u201d module where there is a memory\nrace condition with the ssl.SSLContext methods \u201ccert_store_stats()\u201d and\n\u201cget_ca_certs()\u201d. The race condition can be triggered if the methods are\ncalled at the same time as certificates are loaded into the SSLContext,\nsuch as during the TLS handshake with a certificate directory configured.\nThis issue is fixed in CPython 3.10.14, 3.11.9, 3.12.3, and 3.13.0a5.",
  "repo": "python/cpython",
  "patch_hash": "29c97287d205bf2f410f4895ebce3f43b5160524",
  "patch_info": {
    "commit_hash": "29c97287d205bf2f410f4895ebce3f43b5160524",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/29c97287d205bf2f410f4895ebce3f43b5160524",
    "files": [
      "Misc/NEWS.d/next/Security/2024-04-19-11-21-13.gh-issue-114572.t1QMQD.rst",
      "Modules/_ssl.c"
    ],
    "message": "[3.8] gh-114572: Fix locking in cert_store_stats and get_ca_certs (#118442)\n\n(cherry picked from commit 732c7d512e7cdf656a3f02a38c329b14a14a8573)",
    "before_after_code_files": [
      "Modules/_ssl.c||Modules/_ssl.c"
    ]
  },
  "patch_diff": {
    "Modules/_ssl.c||Modules/_ssl.c": [
      "File: Modules/_ssl.c -> Modules/_ssl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "168: #  define PY_OPENSSL_1_1_API 1",
      "169: #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "171: #if (OPENSSL_VERSION_NUMBER >= 0x30300000L) && !defined(LIBRESSL_VERSION_NUMBER)",
      "172: #  define OPENSSL_VERSION_3_3 1",
      "173: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "212: #define HAVE_OPENSSL_CRYPTO_LOCK",
      "213: #endif",
      "215: #if defined(OPENSSL_VERSION_1_1) && !defined(OPENSSL_NO_SSL2)",
      "216: #define OPENSSL_NO_SSL2",
      "217: #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "220: #ifdef OPENSSL_VERSION_1_1",
      "221: #define HAVE_OPENSSL_X509_STORE_LOCK",
      "222: #endif",
      "225: #ifdef OPENSSL_VERSION_3_3",
      "226: #define HAVE_OPENSSL_X509_STORE_GET1_OBJECTS 1",
      "227: #endif",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "4678: #endif",
      "4679: }",
      "4681: PyDoc_STRVAR(PySSLContext_sni_callback_doc,",
      "4682: \"Set a callback that will be called when a server name is provided by the SSL/TLS client in the SNI extension.\\n\\",
      "4683: \\n\\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4697: #if defined(HAVE_OPENSSL_X509_STORE_LOCK) && !defined(OPENSSL_VERSION_3_3)",
      "4698: #define HAVE_OPENSSL_X509_STORE_GET1_OBJECTS 1",
      "4700: static X509_OBJECT *x509_object_dup(const X509_OBJECT *obj)",
      "4701: {",
      "4702:     int ok;",
      "4703:     X509_OBJECT *ret = X509_OBJECT_new();",
      "4704:     if (ret == NULL) {",
      "4705:         return NULL;",
      "4706:     }",
      "4707:     switch (X509_OBJECT_get_type(obj)) {",
      "4708:         case X509_LU_X509:",
      "4709:             ok = X509_OBJECT_set1_X509(ret, X509_OBJECT_get0_X509(obj));",
      "4710:             break;",
      "4711:         case X509_LU_CRL:",
      "4713:             ok = X509_OBJECT_set1_X509_CRL(",
      "4714:                 ret, X509_OBJECT_get0_X509_CRL((X509_OBJECT *)obj));",
      "4715:             break;",
      "4716:         default:",
      "4719:             ok = 1;",
      "4720:             break;",
      "4721:     }",
      "4722:     if (!ok) {",
      "4723:         X509_OBJECT_free(ret);",
      "4724:         return NULL;",
      "4725:     }",
      "4726:     return ret;",
      "4727: }",
      "4729: static STACK_OF(X509_OBJECT) *",
      "4730: X509_STORE_get1_objects(X509_STORE *store)",
      "4731: {",
      "4732:     STACK_OF(X509_OBJECT) *ret;",
      "4733:     if (!X509_STORE_lock(store)) {",
      "4734:         return NULL;",
      "4735:     }",
      "4736:     ret = sk_X509_OBJECT_deep_copy(X509_STORE_get0_objects(store),",
      "4737:                                    x509_object_dup, X509_OBJECT_free);",
      "4738:     X509_STORE_unlock(store);",
      "4739:     return ret;",
      "4740: }",
      "4741: #endif",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "4707:     int x509 = 0, crl = 0, ca = 0, i;",
      "4709:     store = SSL_CTX_get_cert_store(self->ctx);",
      "4710:     objs = X509_STORE_get0_objects(store);",
      "4711:     for (i = 0; i < sk_X509_OBJECT_num(objs); i++) {",
      "4712:         obj = sk_X509_OBJECT_value(objs, i);",
      "4713:         switch (X509_OBJECT_get_type(obj)) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4772: #if HAVE_OPENSSL_X509_STORE_GET1_OBJECTS",
      "4773:     objs = X509_STORE_get1_objects(store);",
      "4774:     if (objs == NULL) {",
      "4775:         PyErr_SetString(PyExc_MemoryError, \"failed to query cert store\");",
      "4776:         return NULL;",
      "4777:     }",
      "4778: #else",
      "4780: #endif",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "4721:                 crl++;",
      "4722:                 break;",
      "4723:             default:",
      "4727:                 break;",
      "4728:         }",
      "4729:     }",
      "4730:     return Py_BuildValue(\"{sisisi}\", \"x509\", x509, \"crl\", crl,",
      "4731:         \"x509_ca\", ca);",
      "4732: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4798: #if HAVE_OPENSSL_X509_STORE_GET1_OBJECTS",
      "4799:     sk_X509_OBJECT_pop_free(objs, X509_OBJECT_free);",
      "4800: #endif",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "4758:     }",
      "4760:     store = SSL_CTX_get_cert_store(self->ctx);",
      "4761:     objs = X509_STORE_get0_objects(store);",
      "4762:     for (i = 0; i < sk_X509_OBJECT_num(objs); i++) {",
      "4763:         X509_OBJECT *obj;",
      "4764:         X509 *cert;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4832: #if HAVE_OPENSSL_X509_STORE_GET1_OBJECTS",
      "4833:     objs = X509_STORE_get1_objects(store);",
      "4834:     if (objs == NULL) {",
      "4835:         PyErr_SetString(PyExc_MemoryError, \"failed to query cert store\");",
      "4836:         return NULL;",
      "4837:     }",
      "4838: #else",
      "4840: #endif",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "4786:         }",
      "4787:         Py_CLEAR(ci);",
      "4788:     }",
      "4789:     return rlist;",
      "4791:   error:",
      "4792:     Py_XDECREF(ci);",
      "4793:     Py_XDECREF(rlist);",
      "4794:     return NULL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4868: #if HAVE_OPENSSL_X509_STORE_GET1_OBJECTS",
      "4869:     sk_X509_OBJECT_pop_free(objs, X509_OBJECT_free);",
      "4870: #endif",
      "4874: #if HAVE_OPENSSL_X509_STORE_GET1_OBJECTS",
      "4875:     sk_X509_OBJECT_pop_free(objs, X509_OBJECT_free);",
      "4876: #endif",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "29c97287d205bf2f410f4895ebce3f43b5160524",
      "candidate_info": {
        "commit_hash": "29c97287d205bf2f410f4895ebce3f43b5160524",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/29c97287d205bf2f410f4895ebce3f43b5160524",
        "files": [
          "Misc/NEWS.d/next/Security/2024-04-19-11-21-13.gh-issue-114572.t1QMQD.rst",
          "Modules/_ssl.c"
        ],
        "message": "[3.8] gh-114572: Fix locking in cert_store_stats and get_ca_certs (#118442)\n\n(cherry picked from commit 732c7d512e7cdf656a3f02a38c329b14a14a8573)",
        "before_after_code_files": [
          "Modules/_ssl.c||Modules/_ssl.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "Modules/_ssl.c||Modules/_ssl.c"
          ],
          "candidate": [
            "Modules/_ssl.c||Modules/_ssl.c"
          ]
        }
      },
      "candidate_diff": {
        "Modules/_ssl.c||Modules/_ssl.c": [
          "File: Modules/_ssl.c -> Modules/_ssl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "168: #  define PY_OPENSSL_1_1_API 1",
          "169: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "171: #if (OPENSSL_VERSION_NUMBER >= 0x30300000L) && !defined(LIBRESSL_VERSION_NUMBER)",
          "172: #  define OPENSSL_VERSION_3_3 1",
          "173: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "212: #define HAVE_OPENSSL_CRYPTO_LOCK",
          "213: #endif",
          "215: #if defined(OPENSSL_VERSION_1_1) && !defined(OPENSSL_NO_SSL2)",
          "216: #define OPENSSL_NO_SSL2",
          "217: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "220: #ifdef OPENSSL_VERSION_1_1",
          "221: #define HAVE_OPENSSL_X509_STORE_LOCK",
          "222: #endif",
          "225: #ifdef OPENSSL_VERSION_3_3",
          "226: #define HAVE_OPENSSL_X509_STORE_GET1_OBJECTS 1",
          "227: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4678: #endif",
          "4679: }",
          "4681: PyDoc_STRVAR(PySSLContext_sni_callback_doc,",
          "4682: \"Set a callback that will be called when a server name is provided by the SSL/TLS client in the SNI extension.\\n\\",
          "4683: \\n\\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4697: #if defined(HAVE_OPENSSL_X509_STORE_LOCK) && !defined(OPENSSL_VERSION_3_3)",
          "4698: #define HAVE_OPENSSL_X509_STORE_GET1_OBJECTS 1",
          "4700: static X509_OBJECT *x509_object_dup(const X509_OBJECT *obj)",
          "4701: {",
          "4702:     int ok;",
          "4703:     X509_OBJECT *ret = X509_OBJECT_new();",
          "4704:     if (ret == NULL) {",
          "4705:         return NULL;",
          "4706:     }",
          "4707:     switch (X509_OBJECT_get_type(obj)) {",
          "4708:         case X509_LU_X509:",
          "4709:             ok = X509_OBJECT_set1_X509(ret, X509_OBJECT_get0_X509(obj));",
          "4710:             break;",
          "4711:         case X509_LU_CRL:",
          "4713:             ok = X509_OBJECT_set1_X509_CRL(",
          "4714:                 ret, X509_OBJECT_get0_X509_CRL((X509_OBJECT *)obj));",
          "4715:             break;",
          "4716:         default:",
          "4719:             ok = 1;",
          "4720:             break;",
          "4721:     }",
          "4722:     if (!ok) {",
          "4723:         X509_OBJECT_free(ret);",
          "4724:         return NULL;",
          "4725:     }",
          "4726:     return ret;",
          "4727: }",
          "4729: static STACK_OF(X509_OBJECT) *",
          "4730: X509_STORE_get1_objects(X509_STORE *store)",
          "4731: {",
          "4732:     STACK_OF(X509_OBJECT) *ret;",
          "4733:     if (!X509_STORE_lock(store)) {",
          "4734:         return NULL;",
          "4735:     }",
          "4736:     ret = sk_X509_OBJECT_deep_copy(X509_STORE_get0_objects(store),",
          "4737:                                    x509_object_dup, X509_OBJECT_free);",
          "4738:     X509_STORE_unlock(store);",
          "4739:     return ret;",
          "4740: }",
          "4741: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4707:     int x509 = 0, crl = 0, ca = 0, i;",
          "4709:     store = SSL_CTX_get_cert_store(self->ctx);",
          "4710:     objs = X509_STORE_get0_objects(store);",
          "4711:     for (i = 0; i < sk_X509_OBJECT_num(objs); i++) {",
          "4712:         obj = sk_X509_OBJECT_value(objs, i);",
          "4713:         switch (X509_OBJECT_get_type(obj)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4772: #if HAVE_OPENSSL_X509_STORE_GET1_OBJECTS",
          "4773:     objs = X509_STORE_get1_objects(store);",
          "4774:     if (objs == NULL) {",
          "4775:         PyErr_SetString(PyExc_MemoryError, \"failed to query cert store\");",
          "4776:         return NULL;",
          "4777:     }",
          "4778: #else",
          "4780: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4721:                 crl++;",
          "4722:                 break;",
          "4723:             default:",
          "4727:                 break;",
          "4728:         }",
          "4729:     }",
          "4730:     return Py_BuildValue(\"{sisisi}\", \"x509\", x509, \"crl\", crl,",
          "4731:         \"x509_ca\", ca);",
          "4732: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4798: #if HAVE_OPENSSL_X509_STORE_GET1_OBJECTS",
          "4799:     sk_X509_OBJECT_pop_free(objs, X509_OBJECT_free);",
          "4800: #endif",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4758:     }",
          "4760:     store = SSL_CTX_get_cert_store(self->ctx);",
          "4761:     objs = X509_STORE_get0_objects(store);",
          "4762:     for (i = 0; i < sk_X509_OBJECT_num(objs); i++) {",
          "4763:         X509_OBJECT *obj;",
          "4764:         X509 *cert;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4832: #if HAVE_OPENSSL_X509_STORE_GET1_OBJECTS",
          "4833:     objs = X509_STORE_get1_objects(store);",
          "4834:     if (objs == NULL) {",
          "4835:         PyErr_SetString(PyExc_MemoryError, \"failed to query cert store\");",
          "4836:         return NULL;",
          "4837:     }",
          "4838: #else",
          "4840: #endif",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4786:         }",
          "4787:         Py_CLEAR(ci);",
          "4788:     }",
          "4789:     return rlist;",
          "4791:   error:",
          "4792:     Py_XDECREF(ci);",
          "4793:     Py_XDECREF(rlist);",
          "4794:     return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4868: #if HAVE_OPENSSL_X509_STORE_GET1_OBJECTS",
          "4869:     sk_X509_OBJECT_pop_free(objs, X509_OBJECT_free);",
          "4870: #endif",
          "4874: #if HAVE_OPENSSL_X509_STORE_GET1_OBJECTS",
          "4875:     sk_X509_OBJECT_pop_free(objs, X509_OBJECT_free);",
          "4876: #endif",
          "",
          "---------------"
        ]
      }
    }
  ]
}
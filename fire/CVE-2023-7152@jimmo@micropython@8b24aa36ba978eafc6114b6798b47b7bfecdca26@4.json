{
  "cve_id": "CVE-2023-7152",
  "cve_desc": "A vulnerability, which was classified as critical, has been found in MicroPython 1.21.0/1.22.0-preview. Affected by this issue is the function poll_set_add_fd of the file extmod/modselect.c. The manipulation leads to use after free. The exploit has been disclosed to the public and may be used. The patch is identified as 8b24aa36ba978eafc6114b6798b47b7bfecdca26. It is recommended to apply a patch to fix this issue. VDB-249158 is the identifier assigned to this vulnerability.",
  "repo": "jimmo/micropython",
  "patch_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
  "patch_info": {
    "commit_hash": "8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "repo": "jimmo/micropython",
    "commit_url": "https://github.com/jimmo/micropython/commit/8b24aa36ba978eafc6114b6798b47b7bfecdca26",
    "files": [
      "extmod/modselect.c",
      "tests/extmod/select_poll_fd.py"
    ],
    "message": "extmod/modselect: Handle growing the pollfds allocation correctly.\n\nThe poll_obj_t instances have their pollfd field point into this\nallocation.  So if re-allocating results in a move, we need to update the\nexisting poll_obj_t's.\n\nUpdate the test to cover this case.\n\nFixes issue #12887.\n\nThis work was funded through GitHub Sponsors.\n\nSigned-off-by: Jim Mussared <jim.mussared@gmail.com>",
    "before_after_code_files": [
      "extmod/modselect.c||extmod/modselect.c",
      "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py"
    ]
  },
  "patch_diff": {
    "extmod/modselect.c||extmod/modselect.c": [
      "File: extmod/modselect.c -> extmod/modselect.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42: #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS",
      "44: #include <poll.h>",
      "46: #if !((MP_STREAM_POLL_RD) == (POLLIN) && \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44: #include <string.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "142:     }",
      "143: }",
      "145: STATIC struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {",
      "146:     struct pollfd *free_slot = NULL;",
      "148:     if (poll_set->used == poll_set->max_used) {",
      "150:         if (poll_set->max_used >= poll_set->alloc) {",
      "153:         }",
      "154:         free_slot = &poll_set->pollfds[poll_set->max_used++];",
      "155:     } else {",
      "",
      "[Removed Lines]",
      "151:             poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);",
      "152:             poll_set->alloc += 4;",
      "",
      "[Added Lines]",
      "147: #define POLL_SET_ALLOC_INCREMENT (4)",
      "155:             size_t new_alloc = poll_set->alloc + POLL_SET_ALLOC_INCREMENT;",
      "157:             struct pollfd *new_fds = m_renew_maybe(struct pollfd, poll_set->pollfds, poll_set->alloc, new_alloc, false);",
      "158:             if (!new_fds) {",
      "160:                 new_fds = m_new(struct pollfd, new_alloc);",
      "161:                 memcpy(new_fds, poll_set->pollfds, sizeof(struct pollfd) * poll_set->alloc);",
      "165:                 for (mp_uint_t i = 0; i < poll_set->map.alloc; ++i) {",
      "166:                     if (!mp_map_slot_is_filled(&poll_set->map, i)) {",
      "167:                         continue;",
      "168:                     }",
      "170:                     poll_obj_t *poll_obj = MP_OBJ_TO_PTR(poll_set->map.table[i].value);",
      "171:                     if (!poll_obj) {",
      "175:                         continue;",
      "176:                     }",
      "178:                     poll_obj->pollfd = new_fds + (poll_obj->pollfd - poll_set->pollfds);",
      "179:                 }",
      "182:                 m_del(struct pollfd, poll_set->pollfds, poll_set->alloc);",
      "183:             }",
      "185:             poll_set->pollfds = new_fds;",
      "186:             poll_set->alloc = new_alloc;",
      "",
      "---------------"
    ],
    "tests/extmod/select_poll_fd.py||tests/extmod/select_poll_fd.py": [
      "File: tests/extmod/select_poll_fd.py -> tests/extmod/select_poll_fd.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "34: # Poll for input, should return an empty list.",
      "35: print(poller.poll(0))",
      "38: poller = select.poll()",
      "39: for fd in range(6000):",
      "40:     poller.register(fd)",
      "41: try:",
      "42:     poller.poll()",
      "43: except OSError as er:",
      "44:     print(er.errno == errno.EINVAL)",
      "",
      "[Removed Lines]",
      "37: # Test registering a very large number of file descriptors.",
      "",
      "[Added Lines]",
      "37: # Test registering a very large number of file descriptors (will trigger",
      "38: # EINVAL due to more than OPEN_MAX fds).",
      "44:     assert False",
      "48: # Register stdout/stderr, plus many extra ones to trigger the fd vector",
      "49: # resizing. Then unregister the excess ones and verify poll still works.",
      "50: poller = select.poll()",
      "51: for fd in range(1, 1000):",
      "52:     poller.register(fd)",
      "53: for i in range(3, 1000):",
      "54:     poller.unregister(i)",
      "55: print(sorted(poller.poll()))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2ed976f1406e33a266d25cb6505020c76746ecbc",
      "candidate_info": {
        "commit_hash": "2ed976f1406e33a266d25cb6505020c76746ecbc",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/2ed976f1406e33a266d25cb6505020c76746ecbc",
        "files": [
          "ports/samd/mcu/samd21/mpconfigmcu.h"
        ],
        "message": "samd/mcu/samd21: Enable MICROPY_STACK_CHECK on SAMD21.\n\nIncreases firmware size by +140 bytes and uses +4 extra bytes of RAM, but\nallows the test suite to run without crashing.\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "ports/samd/mcu/samd21/mpconfigmcu.h||ports/samd/mcu/samd21/mpconfigmcu.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/samd/mcu/samd21/mpconfigmcu.h||ports/samd/mcu/samd21/mpconfigmcu.h": [
          "File: ports/samd/mcu/samd21/mpconfigmcu.h -> ports/samd/mcu/samd21/mpconfigmcu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #define MICROPY_ENABLE_FINALISER        (1)",
          "19: #define MICROPY_KBD_EXCEPTION           (1)",
          "20: #define MICROPY_HELPER_REPL             (1)",
          "21: #define MICROPY_REPL_AUTO_INDENT        (1)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: #define MICROPY_STACK_CHECK             (1)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e4d3ab33045274c8e31ca559afea20753dbb6b82",
      "candidate_info": {
        "commit_hash": "e4d3ab33045274c8e31ca559afea20753dbb6b82",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/e4d3ab33045274c8e31ca559afea20753dbb6b82",
        "files": [
          "ports/nrf/main.c",
          "ports/nrf/qstrdefsport.h"
        ],
        "message": "nrf/main: Add /flash and /flash/lib to sys.path.\n\nThis allows to follow good practice and have libraries live in the lib\nfolder which means they will be found by the runtime without adding this\npath manually at runtime.\n\nSigned-off-by: Sebastian Romero <s.romero@arduino.cc>",
        "before_after_code_files": [
          "ports/nrf/main.c||ports/nrf/main.c",
          "ports/nrf/qstrdefsport.h||ports/nrf/qstrdefsport.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/nrf/main.c||ports/nrf/main.c": [
          "File: ports/nrf/main.c -> ports/nrf/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "192:     if (ret != 0) {",
          "193:         printf(\"MPY: can't mount flash\\n\");",
          "194:     }",
          "195:     #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "194:     } else {",
          "195:         mp_obj_list_append(mp_sys_path, MP_OBJ_NEW_QSTR(MP_QSTR__slash_flash));",
          "196:         mp_obj_list_append(mp_sys_path, MP_OBJ_NEW_QSTR(MP_QSTR__slash_flash_slash_lib));",
          "",
          "---------------"
        ],
        "ports/nrf/qstrdefsport.h||ports/nrf/qstrdefsport.h": [
          "File: ports/nrf/qstrdefsport.h -> ports/nrf/qstrdefsport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: Q(/flash)",
          "34: Q(/)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: Q(/flash/lib)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cfc212b10810863b7dee4f9228ce824ceca837c6",
      "candidate_info": {
        "commit_hash": "cfc212b10810863b7dee4f9228ce824ceca837c6",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/cfc212b10810863b7dee4f9228ce824ceca837c6",
        "files": [
          "ports/rp2/CMakeLists.txt",
          "ports/rp2/main.c",
          "ports/rp2/modrp2.c",
          "ports/rp2/modrp2.h",
          "ports/rp2/rp2_dma.c"
        ],
        "message": "rp2/rp2_dma: Introduce a new rp2.DMA class for control over DMA xfers.\n\nThis commit implements fairly complete support for the DMA controller in\nthe rp2 series of microcontrollers.  It provides a class for accessing the\nDMA channels through a high-level, Pythonic interface, and functions for\nsetting and manipulating the DMA channel configurations.\n\nCreating an instance of the rp2.DMA class claims one of the processor's DMA\nchannels.  A sensible, per-channel default value for the ctrl register can\nbe fetched from the DMA.pack_ctrl() function, and the components of this\nregister can be set via keyword arguments to pack_ctrl().\n\nThe read, write, count and ctrl attributes of the DMA class provide\nread/write access to the respective registers of the DMA controller.  The\nconfig() method allows any or all of these values to be set simultaneously\nand adds a trigger keyword argument to allow the setup to immediately be\ntriggered.  The read and write attributes (or keywords in config()) accept\neither actual addresses or any object that supports the buffer interface.\nThe active() method provides read/write control of the channel's activity,\nallowing the user to start and stop the channel and test if it is running.\n\nStandard MicroPython interrupt handlers are supported through the irq()\nmethod and the channel can be released either by deleting it and allowing\nit to be garbage-collected or with the explicit close() method.\n\nDirect, unfettered access to the DMA controllers registers is provided\nthrough a proxy memoryview() object returned by the DMA.registers attribute\nthat maps directly onto the memory-mapped registers.  This is necessary for\nmore fine-grained control and is helpful for allowing chaining of DMA\nchannels.\n\nAs a simple example, using DMA to do a fast memory copy just needs:\n\n    src = bytearray(32*1024)\n    dest = bytearray(32*1024)\n    dma = rp2.DMA()\n    dma.config(read=src, write=dest, count=len(src) // 4,\n        ctrl=dma.pack_ctrl(), trigger=True)\n\n    # Wait for completion\n    while dma.active():\n        pass\n\nThis API aims to strike a balance between simplicity and comprehensiveness.\n\nSigned-off-by: Nicko van Someren <nicko@nicko.org>\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "ports/rp2/main.c||ports/rp2/main.c",
          "ports/rp2/modrp2.c||ports/rp2/modrp2.c",
          "ports/rp2/modrp2.h||ports/rp2/modrp2.h",
          "ports/rp2/rp2_dma.c||ports/rp2/rp2_dma.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/rp2/main.c||ports/rp2/main.c": [
          "File: ports/rp2/main.c -> ports/rp2/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "159:         readline_init0();",
          "160:         machine_pin_init();",
          "161:         rp2_pio_init();",
          "162:         machine_i2s_init0();",
          "164:         #if MICROPY_PY_BLUETOOTH",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "162:         rp2_dma_init();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "207:         #if MICROPY_PY_NETWORK",
          "208:         mod_network_deinit();",
          "209:         #endif",
          "210:         rp2_pio_deinit();",
          "211:         #if MICROPY_PY_BLUETOOTH",
          "212:         mp_bluetooth_deinit();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "211:         rp2_dma_deinit();",
          "",
          "---------------"
        ],
        "ports/rp2/modrp2.c||ports/rp2/modrp2.c": [
          "File: ports/rp2/modrp2.c -> ports/rp2/modrp2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "88:     { MP_ROM_QSTR(MP_QSTR_Flash),               MP_ROM_PTR(&rp2_flash_type) },",
          "89:     { MP_ROM_QSTR(MP_QSTR_PIO),                 MP_ROM_PTR(&rp2_pio_type) },",
          "90:     { MP_ROM_QSTR(MP_QSTR_StateMachine),        MP_ROM_PTR(&rp2_state_machine_type) },",
          "91:     { MP_ROM_QSTR(MP_QSTR_bootsel_button),      MP_ROM_PTR(&rp2_bootsel_button_obj) },",
          "93:     #if MICROPY_PY_NETWORK_CYW43",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "91:     { MP_ROM_QSTR(MP_QSTR_DMA),                 MP_ROM_PTR(&rp2_dma_type) },",
          "",
          "---------------"
        ],
        "ports/rp2/modrp2.h||ports/rp2/modrp2.h": [
          "File: ports/rp2/modrp2.h -> ports/rp2/modrp2.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: extern const mp_obj_type_t rp2_flash_type;",
          "32: extern const mp_obj_type_t rp2_pio_type;",
          "33: extern const mp_obj_type_t rp2_state_machine_type;",
          "35: void rp2_pio_init(void);",
          "36: void rp2_pio_deinit(void);",
          "38: #endif // MICROPY_INCLUDED_RP2_MODRP2_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34: extern const mp_obj_type_t rp2_dma_type;",
          "39: void rp2_dma_init(void);",
          "40: void rp2_dma_deinit(void);",
          "",
          "---------------"
        ],
        "ports/rp2/rp2_dma.c||ports/rp2/rp2_dma.c": [
          "File: ports/rp2/rp2_dma.c -> ports/rp2/rp2_dma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include <string.h>",
          "29: #include \"py/runtime.h\"",
          "30: #include \"py/mperrno.h\"",
          "31: #include \"py/objarray.h\"",
          "32: #include \"shared/runtime/mpirq.h\"",
          "33: #include \"modrp2.h\"",
          "35: #include \"hardware/irq.h\"",
          "36: #include \"hardware/dma.h\"",
          "38: #define CHANNEL_CLOSED 0xff",
          "40: typedef struct _rp2_dma_ctrl_obj_t {",
          "41:     mp_obj_base_t base;",
          "42:     uint32_t value;",
          "43: } rp2_dma_config_obj_t;",
          "45: typedef struct _rp2_dma_obj_t {",
          "46:     mp_obj_base_t base;",
          "47:     uint8_t channel;",
          "48:     uint8_t irq_flag : 1;",
          "49:     uint8_t irq_trigger : 1;",
          "50: } rp2_dma_obj_t;",
          "52: typedef struct _rp2_dma_ctrl_field_t {",
          "53:     qstr name;",
          "54:     uint8_t shift : 5;",
          "55:     uint8_t length : 3;",
          "56:     uint8_t read_only : 1;",
          "57: } rp2_dma_ctrl_field_t;",
          "59: STATIC rp2_dma_ctrl_field_t rp2_dma_ctrl_fields_table[] = {",
          "60:     { MP_QSTR_enable,        0, 1, 0 },",
          "61:     { MP_QSTR_high_pri,      1, 1, 0 },",
          "62:     { MP_QSTR_size,          2, 2, 0 },",
          "63:     { MP_QSTR_inc_read,      4, 1, 0 },",
          "64:     { MP_QSTR_inc_write,     5, 1, 0 },",
          "65:     { MP_QSTR_ring_size,     6, 4, 0 },",
          "66:     { MP_QSTR_ring_sel,     10, 1, 0 },",
          "67:     { MP_QSTR_chain_to,     11, 4, 0 },",
          "68:     { MP_QSTR_treq_sel,     15, 6, 0 },",
          "69:     { MP_QSTR_irq_quiet,    21, 1, 0 },",
          "70:     { MP_QSTR_bswap,        22, 1, 0 },",
          "71:     { MP_QSTR_sniff_en,     23, 1, 0 },",
          "72:     { MP_QSTR_busy,         24, 1, 1 },",
          "74:     { MP_QSTR_write_err,    29, 1, 0 },",
          "75:     { MP_QSTR_read_err,     30, 1, 0 },",
          "76:     { MP_QSTR_ahb_err,      31, 1, 1 },",
          "77: };",
          "79: STATIC const uint32_t rp2_dma_ctrl_field_count = MP_ARRAY_SIZE(rp2_dma_ctrl_fields_table);",
          "81: #define REG_TYPE_COUNT       0  // Accept just integers",
          "82: #define REG_TYPE_CONF        1  // Accept integers or ctrl values",
          "83: #define REG_TYPE_ADDR_READ   2  // Accept integers, buffers or objects that can be read from",
          "84: #define REG_TYPE_ADDR_WRITE  3  // Accept integers, buffers or objects that can be written to",
          "86: STATIC uint32_t rp2_dma_register_value_from_obj(mp_obj_t o, int reg_type) {",
          "87:     if (reg_type == REG_TYPE_ADDR_READ || reg_type == REG_TYPE_ADDR_WRITE) {",
          "88:         mp_buffer_info_t buf_info;",
          "89:         mp_uint_t flags = MP_BUFFER_READ;",
          "90:         if (mp_get_buffer(o, &buf_info, flags)) {",
          "91:             return (uint32_t)buf_info.buf;",
          "92:         }",
          "93:     }",
          "95:     return mp_obj_get_int_truncated(o);",
          "96: }",
          "98: STATIC void rp2_dma_irq_handler(void) {",
          "100:     uint32_t irq_bits = dma_hw->ints0;",
          "101:     dma_hw->ints0 = 0xffff;",
          "103:     for (int i = 0; i < NUM_DMA_CHANNELS; i++) {",
          "104:         if (irq_bits & (1u << i)) {",
          "105:             mp_irq_obj_t *handler = MP_STATE_PORT(rp2_dma_irq_obj[i]);",
          "106:             if (handler) {",
          "107:                 rp2_dma_obj_t *self = (rp2_dma_obj_t *)handler->parent;",
          "108:                 self->irq_flag = 1;",
          "109:                 mp_irq_handler(handler);",
          "110:             } else {",
          "112:                 dma_channel_set_irq0_enabled(i, false);",
          "113:             }",
          "114:         }",
          "115:     }",
          "116: }",
          "118: STATIC mp_uint_t rp2_dma_irq_trigger(mp_obj_t self_in, mp_uint_t new_trigger) {",
          "119:     rp2_dma_obj_t *self = MP_OBJ_TO_PTR(self_in);",
          "120:     irq_set_enabled(DMA_IRQ_0, false);",
          "121:     self->irq_flag = 0;",
          "122:     dma_channel_set_irq0_enabled(self->channel, (new_trigger != 0));",
          "123:     irq_set_enabled(DMA_IRQ_0, true);",
          "124:     return 0;",
          "125: }",
          "127: STATIC mp_uint_t rp2_dma_irq_info(mp_obj_t self_in, mp_uint_t info_type) {",
          "128:     rp2_dma_obj_t *self = MP_OBJ_TO_PTR(self_in);",
          "129:     if (info_type == MP_IRQ_INFO_FLAGS) {",
          "130:         return self->irq_flag;",
          "131:     } else if (info_type == MP_IRQ_INFO_TRIGGERS) {",
          "132:         return (dma_hw->ints0 & (1u << self->channel)) != 0;",
          "133:     }",
          "134:     return 0;",
          "135: }",
          "137: STATIC const mp_irq_methods_t rp2_dma_irq_methods = {",
          "138:     .trigger = rp2_dma_irq_trigger,",
          "139:     .info = rp2_dma_irq_info,",
          "140: };",
          "142: STATIC mp_obj_t rp2_dma_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {",
          "143:     mp_arg_check_num(n_args, n_kw, 0, 0, false);",
          "145:     int dma_channel = dma_claim_unused_channel(false);",
          "146:     if (dma_channel < 0) {",
          "147:         mp_raise_OSError(MP_EBUSY);",
          "148:     }",
          "150:     rp2_dma_obj_t *self = m_new_obj_with_finaliser(rp2_dma_obj_t);",
          "151:     self->base.type = &rp2_dma_type;",
          "152:     self->channel = dma_channel;",
          "155:     return MP_OBJ_FROM_PTR(self);",
          "156: }",
          "158: STATIC void rp2_dma_error_if_closed(rp2_dma_obj_t *self) {",
          "159:     if (self->channel == CHANNEL_CLOSED) {",
          "160:         mp_raise_ValueError(MP_ERROR_TEXT(\"channel closed\"));",
          "161:     }",
          "162: }",
          "164: STATIC void rp2_dma_attr(mp_obj_t self_in, qstr attr_in, mp_obj_t *dest) {",
          "165:     rp2_dma_obj_t *self = MP_OBJ_TO_PTR(self_in);",
          "167:     if (dest[0] == MP_OBJ_NULL) {",
          "169:         dma_channel_hw_t *reg_block = dma_channel_hw_addr(self->channel);",
          "170:         if (attr_in == MP_QSTR_read) {",
          "171:             rp2_dma_error_if_closed(self);",
          "172:             dest[0] = mp_obj_new_int_from_uint((mp_uint_t)reg_block->read_addr);",
          "173:         } else if (attr_in == MP_QSTR_write) {",
          "174:             rp2_dma_error_if_closed(self);",
          "175:             dest[0] = mp_obj_new_int_from_uint((mp_uint_t)reg_block->write_addr);",
          "176:         } else if (attr_in == MP_QSTR_count) {",
          "177:             rp2_dma_error_if_closed(self);",
          "178:             dest[0] = mp_obj_new_int_from_uint((mp_uint_t)reg_block->transfer_count);",
          "179:         } else if (attr_in == MP_QSTR_ctrl) {",
          "180:             rp2_dma_error_if_closed(self);",
          "181:             dest[0] = mp_obj_new_int_from_uint((mp_uint_t)reg_block->al1_ctrl);",
          "182:         } else if (attr_in == MP_QSTR_channel) {",
          "183:             dest[0] = mp_obj_new_int_from_uint(self->channel);",
          "184:         } else if (attr_in == MP_QSTR_registers) {",
          "185:             mp_obj_array_t *reg_view = m_new_obj(mp_obj_array_t);",
          "186:             mp_obj_memoryview_init(reg_view, 'I' | MP_OBJ_ARRAY_TYPECODE_FLAG_RW, 0, 16, dma_channel_hw_addr(self->channel));",
          "187:             dest[0] = reg_view;",
          "188:         } else {",
          "190:             dest[1] = MP_OBJ_SENTINEL;",
          "191:         }",
          "192:     } else {",
          "194:         if (dest[1] == MP_OBJ_NULL) {",
          "196:             return;",
          "197:         }",
          "199:         rp2_dma_error_if_closed(self);",
          "201:         if (attr_in == MP_QSTR_read) {",
          "202:             uint32_t value = rp2_dma_register_value_from_obj(dest[1], REG_TYPE_ADDR_READ);",
          "203:             dma_channel_set_read_addr(self->channel, (volatile void *)value, false);",
          "204:             dest[0] = MP_OBJ_NULL; // indicate success",
          "205:         } else if (attr_in == MP_QSTR_write) {",
          "206:             uint32_t value = rp2_dma_register_value_from_obj(dest[1], REG_TYPE_ADDR_WRITE);",
          "207:             dma_channel_set_write_addr(self->channel, (volatile void *)value, false);",
          "208:             dest[0] = MP_OBJ_NULL; // indicate success",
          "209:         } else if (attr_in == MP_QSTR_count) {",
          "210:             uint32_t value = rp2_dma_register_value_from_obj(dest[1], REG_TYPE_COUNT);",
          "211:             dma_channel_set_trans_count(self->channel, value, false);",
          "212:             dest[0] = MP_OBJ_NULL; // indicate success",
          "213:         } else if (attr_in == MP_QSTR_ctrl) {",
          "214:             uint32_t value = rp2_dma_register_value_from_obj(dest[1], REG_TYPE_CONF);",
          "215:             dma_channel_set_config(self->channel, (dma_channel_config *)&value, false);",
          "216:             dest[0] = MP_OBJ_NULL; // indicate success",
          "217:         }",
          "218:     }",
          "219: }",
          "221: STATIC void rp2_dma_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {",
          "222:     rp2_dma_obj_t *self = MP_OBJ_TO_PTR(self_in);",
          "223:     mp_printf(print, \"DMA(%u)\", self->channel);",
          "224: }",
          "227: STATIC mp_obj_t rp2_dma_config(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {",
          "228:     rp2_dma_obj_t *self = MP_OBJ_TO_PTR(*pos_args);",
          "230:     rp2_dma_error_if_closed(self);",
          "232:     enum {",
          "233:         ARG_read,",
          "234:         ARG_write,",
          "235:         ARG_count,",
          "236:         ARG_ctrl,",
          "237:         ARG_trigger,",
          "238:     };",
          "239:     static const mp_arg_t allowed_args[] = {",
          "240:         { MP_QSTR_read,         MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },",
          "241:         { MP_QSTR_write,        MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },",
          "242:         { MP_QSTR_count,        MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },",
          "243:         { MP_QSTR_ctrl,         MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },",
          "244:         { MP_QSTR_trigger,      MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = false} },",
          "245:     };",
          "247:     mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];",
          "249:     mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);",
          "251:     if (kw_args->used) {",
          "252:         bool trigger = args[ARG_trigger].u_bool;",
          "253:         mp_int_t value_count = trigger ? kw_args->used - 1 : kw_args->used;",
          "254:         if (trigger && (value_count == 0)) {",
          "256:             dma_channel_start(self->channel);",
          "257:         } else {",
          "258:             if (args[ARG_read].u_obj != MP_OBJ_NULL) {",
          "259:                 uint32_t value = rp2_dma_register_value_from_obj(args[ARG_read].u_obj, REG_TYPE_ADDR_READ);",
          "260:                 value_count--;",
          "261:                 dma_channel_set_read_addr(self->channel, (volatile void *)value, trigger && (value_count == 0));",
          "262:             }",
          "263:             if (args[ARG_write].u_obj != MP_OBJ_NULL) {",
          "264:                 uint32_t value = rp2_dma_register_value_from_obj(args[ARG_write].u_obj, REG_TYPE_ADDR_WRITE);",
          "265:                 value_count--;",
          "266:                 dma_channel_set_write_addr(self->channel, (volatile void *)value, trigger && (value_count == 0));",
          "267:             }",
          "268:             if (args[ARG_count].u_obj != MP_OBJ_NULL) {",
          "269:                 uint32_t value = rp2_dma_register_value_from_obj(args[ARG_count].u_obj, REG_TYPE_COUNT);",
          "270:                 value_count--;",
          "271:                 dma_channel_set_trans_count(self->channel, value, trigger && (value_count == 0));",
          "272:             }",
          "273:             if (args[ARG_ctrl].u_obj != MP_OBJ_NULL) {",
          "274:                 uint32_t value = rp2_dma_register_value_from_obj(args[ARG_ctrl].u_obj, REG_TYPE_CONF);",
          "275:                 value_count--;",
          "276:                 dma_channel_set_config(self->channel, (dma_channel_config *)&value, trigger && (value_count == 0));",
          "277:             }",
          "278:         }",
          "279:     }",
          "281:     return mp_const_none;",
          "282: }",
          "283: STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_dma_config_obj, 1, rp2_dma_config);",
          "286: STATIC mp_obj_t rp2_dma_active(size_t n_args, const mp_obj_t *args) {",
          "287:     rp2_dma_obj_t *self = MP_OBJ_TO_PTR(args[0]);",
          "288:     rp2_dma_error_if_closed(self);",
          "290:     if (n_args > 1) {",
          "291:         if (mp_obj_is_true(args[1])) {",
          "292:             dma_channel_start(self->channel);",
          "293:         } else {",
          "294:             dma_channel_abort(self->channel);",
          "295:         }",
          "296:     }",
          "298:     uint32_t busy = dma_channel_is_busy(self->channel);",
          "299:     return mp_obj_new_bool((mp_int_t)busy);",
          "300: }",
          "301: STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(rp2_dma_active_obj, 1, 2, rp2_dma_active);",
          "304: #define DEFAULT_DMA_CONFIG (1 << 21) | (0x3f << 15) | (1 << 5) | (1 << 4) | (2 << 2) | (1 << 0)",
          "307: STATIC mp_obj_t rp2_dma_pack_ctrl(size_t n_pos_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {",
          "310:     rp2_dma_obj_t *self = MP_OBJ_TO_PTR(pos_args[0]);",
          "311:     mp_uint_t value = DEFAULT_DMA_CONFIG | ((self->channel & 0xf) << 11);",
          "313:     if (n_pos_args > 1) {",
          "314:         mp_raise_TypeError(MP_ERROR_TEXT(\"pack_ctrl only takes keyword arguments\"));",
          "315:     }",
          "316:     mp_uint_t remaining = kw_args->used;",
          "318:     mp_map_elem_t *default_entry = mp_map_lookup(kw_args, MP_OBJ_NEW_QSTR(MP_QSTR_default), MP_MAP_LOOKUP);",
          "319:     if (default_entry) {",
          "320:         remaining--;",
          "321:         value = mp_obj_get_int_truncated(default_entry->value);",
          "322:     }",
          "324:     for (mp_uint_t i = 0; i < rp2_dma_ctrl_field_count; i++) {",
          "325:         mp_map_elem_t *field_entry = mp_map_lookup(",
          "326:             kw_args,",
          "327:             MP_OBJ_NEW_QSTR(rp2_dma_ctrl_fields_table[i].name),",
          "328:             MP_MAP_LOOKUP",
          "329:             );",
          "330:         if (field_entry) {",
          "331:             remaining--;",
          "333:             if (!rp2_dma_ctrl_fields_table[i].read_only) {",
          "334:                 mp_uint_t field_value = mp_obj_get_int_truncated(field_entry->value);",
          "335:                 mp_uint_t mask = ((1 << rp2_dma_ctrl_fields_table[i].length) - 1);",
          "336:                 mp_uint_t masked_value = field_value & mask;",
          "337:                 if (field_value != masked_value) {",
          "338:                     mp_raise_ValueError(MP_ERROR_TEXT(\"bad field value\"));",
          "339:                 }",
          "340:                 value &= ~(mask << rp2_dma_ctrl_fields_table[i].shift);",
          "341:                 value |= masked_value << rp2_dma_ctrl_fields_table[i].shift;",
          "342:             }",
          "343:         }",
          "344:     }",
          "346:     if (remaining) {",
          "347:         mp_raise_TypeError(NULL);",
          "348:     }",
          "350:     return mp_obj_new_int_from_uint(value);",
          "351: }",
          "352: STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_dma_pack_ctrl_obj, 1, rp2_dma_pack_ctrl);",
          "355: STATIC mp_obj_t rp2_dma_unpack_ctrl(mp_obj_t value_obj) {",
          "357:     mp_obj_t result_dict[rp2_dma_ctrl_field_count * 2];",
          "359:     mp_uint_t value = mp_obj_get_int_truncated(value_obj);",
          "361:     for (mp_uint_t i = 0; i < rp2_dma_ctrl_field_count; i++) {",
          "362:         result_dict[i * 2] = MP_OBJ_NEW_QSTR(rp2_dma_ctrl_fields_table[i].name);",
          "363:         mp_uint_t field_value =",
          "364:             (value >> rp2_dma_ctrl_fields_table[i].shift) & ((1 << rp2_dma_ctrl_fields_table[i].length) - 1);",
          "365:         result_dict[i * 2 + 1] = MP_OBJ_NEW_SMALL_INT(field_value);",
          "366:     }",
          "368:     return mp_obj_dict_make_new(&mp_type_dict, 0, rp2_dma_ctrl_field_count, result_dict);",
          "369: }",
          "370: STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_dma_unpack_ctrl_fun_obj, rp2_dma_unpack_ctrl);",
          "371: STATIC MP_DEFINE_CONST_STATICMETHOD_OBJ(rp2_dma_unpack_ctrl_obj, MP_ROM_PTR(&rp2_dma_unpack_ctrl_fun_obj));",
          "373: STATIC mp_obj_t rp2_dma_irq(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {",
          "374:     enum { ARG_handler, ARG_hard };",
          "375:     static const mp_arg_t allowed_args[] = {",
          "376:         { MP_QSTR_handler, MP_ARG_OBJ, {.u_rom_obj = mp_const_none} },",
          "377:         { MP_QSTR_hard, MP_ARG_BOOL, {.u_bool = false} },",
          "378:     };",
          "381:     rp2_dma_obj_t *self = MP_OBJ_TO_PTR(pos_args[0]);",
          "382:     mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];",
          "383:     mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);",
          "386:     mp_irq_obj_t *irq = MP_STATE_PORT(rp2_dma_irq_obj[self->channel]);",
          "389:     if (irq == NULL) {",
          "390:         irq = mp_irq_new(&rp2_dma_irq_methods, MP_OBJ_FROM_PTR(self));",
          "391:         MP_STATE_PORT(rp2_dma_irq_obj[self->channel]) = irq;",
          "392:     }",
          "394:     if (n_args > 1 || kw_args->used != 0) {",
          "396:         irq_set_enabled(DMA_IRQ_0, false);",
          "399:         irq->handler = args[ARG_handler].u_obj;",
          "400:         irq->ishard = args[ARG_hard].u_bool;",
          "401:         self->irq_flag = 0;",
          "404:         bool enable = (args[ARG_handler].u_obj != mp_const_none);",
          "405:         dma_channel_set_irq0_enabled(self->channel, enable);",
          "407:         irq_set_enabled(DMA_IRQ_0, true);",
          "408:     }",
          "410:     return MP_OBJ_FROM_PTR(irq);",
          "411: }",
          "412: STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_dma_irq_obj, 1, rp2_dma_irq);",
          "415: STATIC mp_obj_t rp2_dma_close(mp_obj_t self_in) {",
          "416:     rp2_dma_obj_t *self = MP_OBJ_TO_PTR(self_in);",
          "417:     uint8_t channel = self->channel;",
          "419:     if (channel != CHANNEL_CLOSED) {",
          "421:         mp_irq_obj_t *irq = MP_STATE_PORT(rp2_dma_irq_obj[channel]);",
          "422:         MP_STATE_PORT(rp2_dma_irq_obj[channel]) = MP_OBJ_NULL;",
          "423:         if (irq) {",
          "424:             irq->parent = MP_OBJ_NULL;",
          "425:             irq->handler = MP_OBJ_NULL;",
          "426:             dma_channel_set_irq0_enabled(channel, false);",
          "427:         }",
          "428:         dma_channel_unclaim(channel);",
          "429:         self->channel = CHANNEL_CLOSED;",
          "430:     }",
          "432:     return mp_const_none;",
          "433: }",
          "434: STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_dma_close_obj, rp2_dma_close);",
          "436: STATIC const mp_rom_map_elem_t rp2_dma_locals_dict_table[] = {",
          "437:     { MP_ROM_QSTR(MP_QSTR_config), MP_ROM_PTR(&rp2_dma_config_obj) },",
          "438:     { MP_ROM_QSTR(MP_QSTR_active), MP_ROM_PTR(&rp2_dma_active_obj) },",
          "439:     { MP_ROM_QSTR(MP_QSTR_irq), MP_ROM_PTR(&rp2_dma_irq_obj) },",
          "440:     { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&rp2_dma_close_obj) },",
          "441:     { MP_ROM_QSTR(MP_QSTR___del__), MP_ROM_PTR(&rp2_dma_close_obj) },",
          "442:     { MP_ROM_QSTR(MP_QSTR_pack_ctrl), MP_ROM_PTR(&rp2_dma_pack_ctrl_obj) },",
          "443:     { MP_ROM_QSTR(MP_QSTR_unpack_ctrl), MP_ROM_PTR(&rp2_dma_unpack_ctrl_obj) },",
          "444: };",
          "445: STATIC MP_DEFINE_CONST_DICT(rp2_dma_locals_dict, rp2_dma_locals_dict_table);",
          "447: MP_DEFINE_CONST_OBJ_TYPE(",
          "448:     rp2_dma_type,",
          "449:     MP_QSTR_DMA,",
          "450:     MP_TYPE_FLAG_NONE,",
          "451:     make_new, rp2_dma_make_new,",
          "452:     print, rp2_dma_print,",
          "453:     attr, rp2_dma_attr,",
          "454:     locals_dict, &rp2_dma_locals_dict",
          "455:     );",
          "457: void rp2_dma_init(void) {",
          "459:     memset(MP_STATE_PORT(rp2_dma_irq_obj), 0, sizeof(MP_STATE_PORT(rp2_dma_irq_obj)));",
          "460:     irq_set_exclusive_handler(DMA_IRQ_0, rp2_dma_irq_handler);",
          "461: }",
          "463: void rp2_dma_deinit(void) {",
          "465:     irq_set_mask_enabled(1u << DMA_IRQ_0, false);",
          "466:     irq_remove_handler(DMA_IRQ_0, rp2_dma_irq_handler);",
          "467: }",
          "469: MP_REGISTER_ROOT_POINTER(void *rp2_dma_irq_obj[NUM_DMA_CHANNELS]);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d45176fc271d4d5e264bec2809faeb906787a6f9",
      "candidate_info": {
        "commit_hash": "d45176fc271d4d5e264bec2809faeb906787a6f9",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/d45176fc271d4d5e264bec2809faeb906787a6f9",
        "files": [
          "ports/mimxrt/mpconfigport.h",
          "ports/mimxrt/mphalport.h",
          "ports/renesas-ra/mpconfigport.h",
          "ports/renesas-ra/mphalport.h",
          "ports/rp2/mpconfigport.h",
          "ports/rp2/mphalport.h",
          "ports/stm32/mpconfigport.h",
          "ports/stm32/mphalport.h"
        ],
        "message": "ports: Move MICROPY_PY_LWIP_ENTER/REENTER/EXIT defns to mphalport.h.\n\nFollowing ad806df857b52e9814dbd857b14f09b63eb847fe where the\nMICROPY_PY_PENDSV_ENTER/REENTER/EXIT macro definitions were moved to\nmphalport.h.\n\nSigned-off-by: Damien George <damien@micropython.org>",
        "before_after_code_files": [
          "ports/mimxrt/mpconfigport.h||ports/mimxrt/mpconfigport.h",
          "ports/mimxrt/mphalport.h||ports/mimxrt/mphalport.h",
          "ports/renesas-ra/mpconfigport.h||ports/renesas-ra/mpconfigport.h",
          "ports/renesas-ra/mphalport.h||ports/renesas-ra/mphalport.h",
          "ports/rp2/mpconfigport.h||ports/rp2/mpconfigport.h",
          "ports/rp2/mphalport.h||ports/rp2/mphalport.h",
          "ports/stm32/mpconfigport.h||ports/stm32/mpconfigport.h",
          "ports/stm32/mphalport.h||ports/stm32/mphalport.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ports/mimxrt/mpconfigport.h||ports/mimxrt/mpconfigport.h": [
          "File: ports/mimxrt/mpconfigport.h -> ports/mimxrt/mpconfigport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "134: #define MICROPY_PY_HASHLIB_SHA1             (MICROPY_PY_SSL)",
          "142: #ifndef MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE",
          "143: #define MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE (1)",
          "144: #endif",
          "",
          "[Removed Lines]",
          "138: #define MICROPY_PY_LWIP_ENTER   MICROPY_PY_PENDSV_ENTER",
          "139: #define MICROPY_PY_LWIP_REENTER MICROPY_PY_PENDSV_REENTER",
          "140: #define MICROPY_PY_LWIP_EXIT    MICROPY_PY_PENDSV_EXIT",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ports/mimxrt/mphalport.h||ports/mimxrt/mphalport.h": [
          "File: ports/mimxrt/mphalport.h -> ports/mimxrt/mphalport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "45: #define MICROPY_PY_PENDSV_REENTER atomic_state = raise_irq_pri(IRQ_PRI_PENDSV);",
          "46: #define MICROPY_PY_PENDSV_EXIT    restore_irq_pri(atomic_state);",
          "48: #define MICROPY_HW_USB_CDC_TX_TIMEOUT   (500)",
          "50: #define MP_HAL_PIN_FMT                  \"%q\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "49: #define MICROPY_PY_LWIP_ENTER   MICROPY_PY_PENDSV_ENTER",
          "50: #define MICROPY_PY_LWIP_REENTER MICROPY_PY_PENDSV_REENTER",
          "51: #define MICROPY_PY_LWIP_EXIT    MICROPY_PY_PENDSV_EXIT",
          "",
          "---------------"
        ],
        "ports/renesas-ra/mpconfigport.h||ports/renesas-ra/mpconfigport.h": [
          "File: ports/renesas-ra/mpconfigport.h -> ports/renesas-ra/mpconfigport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "292: #define MICROPY_THREAD_YIELD()",
          "293: #endif",
          "299: #ifndef MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE",
          "300: #define MICROPY_PY_BLUETOOTH_ENABLE_CENTRAL_MODE (1)",
          "301: #endif",
          "",
          "[Removed Lines]",
          "295: #define MICROPY_PY_LWIP_ENTER",
          "296: #define MICROPY_PY_LWIP_REENTER",
          "297: #define MICROPY_PY_LWIP_EXIT",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ports/renesas-ra/mphalport.h||ports/renesas-ra/mphalport.h": [
          "File: ports/renesas-ra/mphalport.h -> ports/renesas-ra/mphalport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: #define MICROPY_PY_PENDSV_ENTER   uint32_t atomic_state = raise_irq_pri(IRQ_PRI_PENDSV)",
          "36: #define MICROPY_PY_PENDSV_EXIT    restore_irq_pri(atomic_state)",
          "38: #define MICROPY_HW_USB_CDC_TX_TIMEOUT (500)",
          "40: extern const unsigned char mp_hal_status_to_errno_table[4];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "38: #define MICROPY_PY_LWIP_ENTER",
          "39: #define MICROPY_PY_LWIP_REENTER",
          "40: #define MICROPY_PY_LWIP_EXIT",
          "",
          "---------------"
        ],
        "ports/rp2/mpconfigport.h||ports/rp2/mpconfigport.h": [
          "File: ports/rp2/mpconfigport.h -> ports/rp2/mpconfigport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "245: #define MICROPY_HW_BOOTSEL_DELAY_US 8",
          "246: #endif",
          "",
          "[Removed Lines]",
          "249: #define MICROPY_PY_LWIP_ENTER   lwip_lock_acquire();",
          "250: #define MICROPY_PY_LWIP_REENTER lwip_lock_acquire();",
          "251: #define MICROPY_PY_LWIP_EXIT    lwip_lock_release();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ports/rp2/mphalport.h||ports/rp2/mphalport.h": [
          "File: ports/rp2/mphalport.h -> ports/rp2/mphalport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "43: #define MICROPY_PY_PENDSV_ENTER   pendsv_suspend()",
          "44: #define MICROPY_PY_PENDSV_EXIT    pendsv_resume()",
          "46: extern int mp_interrupt_char;",
          "47: extern ringbuf_t stdin_ringbuf;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47: #define MICROPY_PY_LWIP_ENTER   lwip_lock_acquire();",
          "48: #define MICROPY_PY_LWIP_REENTER lwip_lock_acquire();",
          "49: #define MICROPY_PY_LWIP_EXIT    lwip_lock_release();",
          "",
          "---------------"
        ],
        "ports/stm32/mpconfigport.h||ports/stm32/mpconfigport.h": [
          "File: ports/stm32/mpconfigport.h -> ports/stm32/mpconfigport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "269: #define MICROPY_SOFT_TIMER_TICKS_MS uwTick",
          "276: #ifndef MICROPY_PY_NETWORK_HOSTNAME_DEFAULT",
          "277: #define MICROPY_PY_NETWORK_HOSTNAME_DEFAULT \"mpy-stm32\"",
          "278: #endif",
          "",
          "[Removed Lines]",
          "272: #define MICROPY_PY_LWIP_ENTER   MICROPY_PY_PENDSV_ENTER",
          "273: #define MICROPY_PY_LWIP_REENTER MICROPY_PY_PENDSV_REENTER",
          "274: #define MICROPY_PY_LWIP_EXIT    MICROPY_PY_PENDSV_EXIT",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ports/stm32/mphalport.h||ports/stm32/mphalport.h": [
          "File: ports/stm32/mphalport.h -> ports/stm32/mphalport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "53: #define MICROPY_PY_PENDSV_REENTER atomic_state = raise_irq_pri(IRQ_PRI_PENDSV);",
          "54: #define MICROPY_PY_PENDSV_EXIT    restore_irq_pri(atomic_state);",
          "58: #if __CORTEX_M == 0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "57: #define MICROPY_PY_LWIP_ENTER   MICROPY_PY_PENDSV_ENTER",
          "58: #define MICROPY_PY_LWIP_REENTER MICROPY_PY_PENDSV_REENTER",
          "59: #define MICROPY_PY_LWIP_EXIT    MICROPY_PY_PENDSV_EXIT",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fec85d84ab1efa659c5b76f52221880629272690",
      "candidate_info": {
        "commit_hash": "fec85d84ab1efa659c5b76f52221880629272690",
        "repo": "jimmo/micropython",
        "commit_url": "https://github.com/jimmo/micropython/commit/fec85d84ab1efa659c5b76f52221880629272690",
        "files": [
          "py/mpz.c"
        ],
        "message": "py/mpz: Use consistent comment style. Remove unused code.\n\nSigned-off-by: Jim Mussared <jim.mussared@gmail.com>",
        "before_after_code_files": [
          "py/mpz.c||py/mpz.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/micropython/micropython/pull/12644"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "py/mpz.c||py/mpz.c": [
          "File: py/mpz.c -> py/mpz.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: #define DIG_MSB  (MPZ_LONG_1 << (DIG_SIZE - 1))",
          "37: #define DIG_BASE (MPZ_LONG_1 << DIG_SIZE)",
          "52: STATIC size_t mpn_remove_trailing_zeros(mpz_dig_t *oidig, mpz_dig_t *idig) {",
          "53:     for (--idig; idig >= oidig && *idig == 0; --idig) {",
          "",
          "[Removed Lines]",
          "40:  mpz is an arbitrary precision integer type with a public API.",
          "42:  mpn functions act on non-negative integers represented by an array of generalised",
          "43:  digits (eg a word per digit).  You also need to specify separately the length of the",
          "44:  array.  There is no public API for mpn.  Rather, the functions are used by mpz to",
          "45:  implement its features.",
          "47:  Integer values are stored little endian (first digit is first in memory).",
          "49:  Definition of normalise: ?",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55:     return idig + 1 - oidig;",
          "56: }",
          "62: STATIC int mpn_cmp(const mpz_dig_t *idig, size_t ilen, const mpz_dig_t *jdig, size_t jlen) {",
          "63:     if (ilen < jlen) {",
          "64:         return -1;",
          "",
          "[Removed Lines]",
          "59:    returns sign(i - j)",
          "60:    assumes i, j are normalised",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "80:     return 0;",
          "81: }",
          "88: STATIC size_t mpn_shl(mpz_dig_t *idig, mpz_dig_t *jdig, size_t jlen, mp_uint_t n) {",
          "89:     mp_uint_t n_whole = (n + DIG_SIZE - 1) / DIG_SIZE;",
          "90:     mp_uint_t n_part = n % DIG_SIZE;",
          "",
          "[Removed Lines]",
          "84:    returns number of digits in i",
          "85:    assumes enough memory in i; assumes normalised j; assumes n > 0",
          "86:    can have i, j pointing to same memory",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "119:     return jlen;",
          "120: }",
          "127: STATIC size_t mpn_shr(mpz_dig_t *idig, mpz_dig_t *jdig, size_t jlen, mp_uint_t n) {",
          "128:     mp_uint_t n_whole = n / DIG_SIZE;",
          "129:     mp_uint_t n_part = n % DIG_SIZE;",
          "",
          "[Removed Lines]",
          "123:    returns number of digits in i",
          "124:    assumes enough memory in i; assumes normalised j; assumes n > 0",
          "125:    can have i, j pointing to same memory",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "151:     return jlen;",
          "152: }",
          "159: STATIC size_t mpn_add(mpz_dig_t *idig, const mpz_dig_t *jdig, size_t jlen, const mpz_dig_t *kdig, size_t klen) {",
          "160:     mpz_dig_t *oidig = idig;",
          "161:     mpz_dbl_dig_t carry = 0;",
          "",
          "[Removed Lines]",
          "155:    returns number of digits in i",
          "156:    assumes enough memory in i; assumes normalised j, k; assumes jlen >= klen",
          "157:    can have i, j, k pointing to same memory",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "181:     return idig - oidig;",
          "182: }",
          "189: STATIC size_t mpn_sub(mpz_dig_t *idig, const mpz_dig_t *jdig, size_t jlen, const mpz_dig_t *kdig, size_t klen) {",
          "190:     mpz_dig_t *oidig = idig;",
          "191:     mpz_dbl_dig_signed_t borrow = 0;",
          "",
          "[Removed Lines]",
          "185:    returns number of digits in i",
          "186:    assumes enough memory in i; assumes normalised j, k; assumes j >= k",
          "187:    can have i, j, k pointing to same memory",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "208: }",
          "210: #if MICROPY_OPT_MPZ_BITWISE",
          "217: STATIC size_t mpn_and(mpz_dig_t *idig, const mpz_dig_t *jdig, const mpz_dig_t *kdig, size_t klen) {",
          "218:     mpz_dig_t *oidig = idig;",
          "",
          "[Removed Lines]",
          "213:    returns number of digits in i",
          "214:    assumes enough memory in i; assumes normalised j, k; assumes jlen >= klen (jlen argument not needed)",
          "215:    can have i, j, k pointing to same memory",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "224:     return mpn_remove_trailing_zeros(oidig, idig);",
          "225: }",
          "227: #endif",
          "238: STATIC size_t mpn_and_neg(mpz_dig_t *idig, const mpz_dig_t *jdig, size_t jlen, const mpz_dig_t *kdig, size_t klen,",
          "239:     mpz_dbl_dig_t carryi, mpz_dbl_dig_t carryj, mpz_dbl_dig_t carryk) {",
          "240:     mpz_dig_t *oidig = idig;",
          "",
          "[Removed Lines]",
          "230:     i =  (j & (-k)) =  (j & (~k + 1)) =  (  j      & (~k + 1))",
          "231:     i =  ((-j) & k) =  ((~j + 1) & k) =  ((~j + 1) &   k     )",
          "232:    computes general form:",
          "233:    i = (im ^ (((j ^ jm) + jc) & ((k ^ km) + kc))) + ic  where Xm = Xc == 0 ? 0 : DIG_MASK",
          "234:    returns number of digits in i",
          "235:    assumes enough memory in i; assumes normalised j, k; assumes length j >= length k",
          "236:    can have i, j, k pointing to same memory",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "260: }",
          "262: #if MICROPY_OPT_MPZ_BITWISE",
          "269: STATIC size_t mpn_or(mpz_dig_t *idig, const mpz_dig_t *jdig, size_t jlen, const mpz_dig_t *kdig, size_t klen) {",
          "270:     mpz_dig_t *oidig = idig;",
          "",
          "[Removed Lines]",
          "265:    returns number of digits in i",
          "266:    assumes enough memory in i; assumes normalised j, k; assumes jlen >= klen",
          "267:    can have i, j, k pointing to same memory",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "282:     return idig - oidig;",
          "283: }",
          "285: #endif",
          "297: #if MICROPY_OPT_MPZ_BITWISE",
          "299: STATIC size_t mpn_or_neg(mpz_dig_t *idig, const mpz_dig_t *jdig, size_t jlen, const mpz_dig_t *kdig, size_t klen,",
          "300:     mpz_dbl_dig_t carryj, mpz_dbl_dig_t carryk) {",
          "301:     mpz_dig_t *oidig = idig;",
          "",
          "[Removed Lines]",
          "288:     i = -(j | (-k)) = -(j | (~k + 1)) = ~(  j      | (~k + 1)) + 1",
          "289:     i = -((-j) | k) = -((~j + 1) | k) = ~((~j + 1) |   k     ) + 1",
          "290:    computes general form:",
          "291:    i = ~(((j ^ jm) + jc) | ((k ^ km) + kc)) + 1  where Xm = Xc == 0 ? 0 : DIG_MASK",
          "292:    returns number of digits in i",
          "293:    assumes enough memory in i; assumes normalised j, k; assumes length j >= length k",
          "294:    can have i, j, k pointing to same memory",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "349:     return mpn_remove_trailing_zeros(oidig, idig);",
          "350: }",
          "352: #endif",
          "354: #if MICROPY_OPT_MPZ_BITWISE",
          "361: STATIC size_t mpn_xor(mpz_dig_t *idig, const mpz_dig_t *jdig, size_t jlen, const mpz_dig_t *kdig, size_t klen) {",
          "362:     mpz_dig_t *oidig = idig;",
          "",
          "[Removed Lines]",
          "357:    returns number of digits in i",
          "358:    assumes enough memory in i; assumes normalised j, k; assumes jlen >= klen",
          "359:    can have i, j, k pointing to same memory",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "374:     return mpn_remove_trailing_zeros(oidig, idig);",
          "375: }",
          "377: #endif",
          "388: STATIC size_t mpn_xor_neg(mpz_dig_t *idig, const mpz_dig_t *jdig, size_t jlen, const mpz_dig_t *kdig, size_t klen,",
          "389:     mpz_dbl_dig_t carryi, mpz_dbl_dig_t carryj, mpz_dbl_dig_t carryk) {",
          "390:     mpz_dig_t *oidig = idig;",
          "",
          "[Removed Lines]",
          "380:     i = -(j ^ (-k)) = -(j ^ ~(k - 1)) = ~(j ^ ~(k - 1)) + 1 = (j ^ (k - 1)) + 1",
          "381:     i = -((-j) ^ k) = -(~(j - 1) ^ k) = ~(~(j - 1) ^ k) + 1 = ((j - 1) ^ k) + 1",
          "382:    computes general form:",
          "383:    i = ((j - 1 + jc) ^ (k - 1 + kc)) + ic",
          "384:    returns number of digits in i",
          "385:    assumes enough memory in i; assumes normalised j, k; assumes length j >= length k",
          "386:    can have i, j, k pointing to same memory",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "406:     return mpn_remove_trailing_zeros(oidig, idig);",
          "407: }",
          "413: STATIC size_t mpn_mul_dig_add_dig(mpz_dig_t *idig, size_t ilen, mpz_dig_t dmul, mpz_dig_t dadd) {",
          "414:     mpz_dig_t *oidig = idig;",
          "415:     mpz_dbl_dig_t carry = dadd;",
          "",
          "[Removed Lines]",
          "410:    returns number of digits in i",
          "411:    assumes enough memory in i; assumes normalised i; assumes dmul != 0",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "427:     return idig - oidig;",
          "428: }",
          "435: STATIC size_t mpn_mul(mpz_dig_t *idig, mpz_dig_t *jdig, size_t jlen, mpz_dig_t *kdig, size_t klen) {",
          "436:     mpz_dig_t *oidig = idig;",
          "437:     size_t ilen = 0;",
          "",
          "[Removed Lines]",
          "431:    returns number of digits in i",
          "432:    assumes enough memory in i; assumes i is zeroed; assumes normalised j, k",
          "433:    can have j, k point to same memory",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "457:     return ilen;",
          "458: }",
          "466: STATIC void mpn_div(mpz_dig_t *num_dig, size_t *num_len, const mpz_dig_t *den_dig, size_t den_len, mpz_dig_t *quo_dig, size_t *quo_len) {",
          "467:     mpz_dig_t *orig_num_dig = num_dig;",
          "468:     mpz_dig_t *orig_quo_dig = quo_dig;",
          "",
          "[Removed Lines]",
          "461:    assumes den != 0",
          "462:    assumes num_dig has enough memory to be extended by 1 digit",
          "463:    assumes quo_dig has enough memory (as many digits as num)",
          "464:    assumes quo_dig is filled with zeros",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "632:     }",
          "633: }",
          "671: STATIC void mpz_free(mpz_t *z) {",
          "672:     if (z != NULL) {",
          "673:         m_del(mpz_dig_t, z->dig, z->alloc);",
          "",
          "[Removed Lines]",
          "635: #if 0",
          "636: these functions are unused",
          "638: mpz_t *mpz_zero(void) {",
          "639:     mpz_t *z = m_new_obj(mpz_t);",
          "640:     mpz_init_zero(z);",
          "641:     return z;",
          "642: }",
          "644: mpz_t *mpz_from_int(mp_int_t val) {",
          "645:     mpz_t *z = mpz_zero();",
          "646:     mpz_set_from_int(z, val);",
          "647:     return z;",
          "648: }",
          "650: mpz_t *mpz_from_ll(long long val, bool is_signed) {",
          "651:     mpz_t *z = mpz_zero();",
          "652:     mpz_set_from_ll(z, val, is_signed);",
          "653:     return z;",
          "654: }",
          "656: #if MICROPY_PY_BUILTINS_FLOAT",
          "657: mpz_t *mpz_from_float(mp_float_t val) {",
          "658:     mpz_t *z = mpz_zero();",
          "659:     mpz_set_from_float(z, val);",
          "660:     return z;",
          "661: }",
          "662: #endif",
          "664: mpz_t *mpz_from_str(const char *str, size_t len, bool neg, unsigned int base) {",
          "665:     mpz_t *z = mpz_zero();",
          "666:     mpz_set_from_str(z, str, len, neg, base);",
          "667:     return z;",
          "668: }",
          "669: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "701:     return z;",
          "702: }",
          "707: void mpz_set(mpz_t *dest, const mpz_t *src) {",
          "708:     mpz_need_dig(dest, src->len);",
          "709:     dest->neg = src->neg;",
          "",
          "[Removed Lines]",
          "705:    can have dest, src the same",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "883:     z->len = mpn_remove_trailing_zeros(z->dig, z->dig + z->len);",
          "884: }",
          "902: int mpz_cmp(const mpz_t *z1, const mpz_t *z2) {",
          "903:     int cmp = (int)z2->neg - (int)z1->neg;",
          "904:     if (cmp != 0) {",
          "",
          "[Removed Lines]",
          "886: #if 0",
          "887: these functions are unused",
          "889: bool mpz_is_pos(const mpz_t *z) {",
          "890:     return z->len > 0 && z->neg == 0;",
          "891: }",
          "893: bool mpz_is_odd(const mpz_t *z) {",
          "894:     return z->len > 0 && (z->dig[0] & 1) != 0;",
          "895: }",
          "897: bool mpz_is_even(const mpz_t *z) {",
          "898:     return z->len == 0 || (z->dig[0] & 1) == 0;",
          "899: }",
          "900: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "911:     return cmp;",
          "912: }",
          "1038: void mpz_abs_inpl(mpz_t *dest, const mpz_t *z) {",
          "1039:     if (dest != z) {",
          "1040:         mpz_set(dest, z);",
          "",
          "[Removed Lines]",
          "914: #if 0",
          "917: mp_int_t mpz_cmp_sml_int(const mpz_t *z, mp_int_t sml_int) {",
          "918:     mp_int_t cmp;",
          "919:     if (z->neg == 0) {",
          "920:         if (sml_int < 0) {",
          "921:             return 1;",
          "922:         }",
          "923:         if (sml_int == 0) {",
          "924:             if (z->len == 0) {",
          "925:                 return 0;",
          "926:             }",
          "927:             return 1;",
          "928:         }",
          "929:         if (z->len == 0) {",
          "930:             return -1;",
          "931:         }",
          "932:         assert(sml_int < (1 << DIG_SIZE));",
          "933:         if (z->len != 1) {",
          "934:             return 1;",
          "935:         }",
          "936:         cmp = z->dig[0] - sml_int;",
          "937:     } else {",
          "938:         if (sml_int > 0) {",
          "939:             return -1;",
          "940:         }",
          "941:         if (sml_int == 0) {",
          "942:             if (z->len == 0) {",
          "943:                 return 0;",
          "944:             }",
          "945:             return -1;",
          "946:         }",
          "947:         if (z->len == 0) {",
          "948:             return 1;",
          "949:         }",
          "950:         assert(sml_int > -(1 << DIG_SIZE));",
          "951:         if (z->len != 1) {",
          "952:             return -1;",
          "953:         }",
          "954:         cmp = -z->dig[0] - sml_int;",
          "955:     }",
          "956:     if (cmp < 0) {",
          "957:         return -1;",
          "958:     }",
          "959:     if (cmp > 0) {",
          "960:         return 1;",
          "961:     }",
          "962:     return 0;",
          "963: }",
          "964: #endif",
          "966: #if 0",
          "967: these functions are unused",
          "971: mpz_t *mpz_abs(const mpz_t *z) {",
          "973:     mpz_t *z2 = mpz_clone(z);",
          "974:     z2->neg = 0;",
          "975:     return z2;",
          "976: }",
          "980: mpz_t *mpz_neg(const mpz_t *z) {",
          "982:     mpz_t *z2 = mpz_clone(z);",
          "983:     z2->neg = 1 - z2->neg;",
          "984:     return z2;",
          "985: }",
          "988:    can have lhs, rhs the same",
          "990: mpz_t *mpz_add(const mpz_t *lhs, const mpz_t *rhs) {",
          "991:     mpz_t *z = mpz_zero();",
          "992:     mpz_add_inpl(z, lhs, rhs);",
          "993:     return z;",
          "994: }",
          "997:    can have lhs, rhs the same",
          "999: mpz_t *mpz_sub(const mpz_t *lhs, const mpz_t *rhs) {",
          "1000:     mpz_t *z = mpz_zero();",
          "1001:     mpz_sub_inpl(z, lhs, rhs);",
          "1002:     return z;",
          "1003: }",
          "1006:    can have lhs, rhs the same",
          "1008: mpz_t *mpz_mul(const mpz_t *lhs, const mpz_t *rhs) {",
          "1009:     mpz_t *z = mpz_zero();",
          "1010:     mpz_mul_inpl(z, lhs, rhs);",
          "1011:     return z;",
          "1012: }",
          "1015:    can have lhs, rhs the same",
          "1017: mpz_t *mpz_pow(const mpz_t *lhs, const mpz_t *rhs) {",
          "1018:     mpz_t *z = mpz_zero();",
          "1019:     mpz_pow_inpl(z, lhs, rhs);",
          "1020:     return z;",
          "1021: }",
          "1024:        quo * rhs + rem = lhs",
          "1025:        0 <= rem < rhs",
          "1026:    can have lhs, rhs the same",
          "1028: void mpz_divmod(const mpz_t *lhs, const mpz_t *rhs, mpz_t **quo, mpz_t **rem) {",
          "1031:     mpz_divmod_inpl(*quo, *rem, lhs, rhs);",
          "1032: }",
          "1033: #endif",
          "1036:    can have dest, z the same",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1042:     dest->neg = 0;",
          "1043: }",
          "1048: void mpz_neg_inpl(mpz_t *dest, const mpz_t *z) {",
          "1049:     if (dest != z) {",
          "1050:         mpz_set(dest, z);",
          "",
          "[Removed Lines]",
          "1046:    can have dest, z the same",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1054:     }",
          "1055: }",
          "1060: void mpz_not_inpl(mpz_t *dest, const mpz_t *z) {",
          "1061:     if (dest != z) {",
          "1062:         mpz_set(dest, z);",
          "",
          "[Removed Lines]",
          "1058:    can have dest, z the same",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1078:     }",
          "1079: }",
          "1084: void mpz_shl_inpl(mpz_t *dest, const mpz_t *lhs, mp_uint_t rhs) {",
          "1085:     if (lhs->len == 0 || rhs == 0) {",
          "1086:         mpz_set(dest, lhs);",
          "",
          "[Removed Lines]",
          "1082:    can have dest, lhs the same",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1091:     }",
          "1092: }",
          "1097: void mpz_shr_inpl(mpz_t *dest, const mpz_t *lhs, mp_uint_t rhs) {",
          "1098:     if (lhs->len == 0 || rhs == 0) {",
          "1099:         mpz_set(dest, lhs);",
          "",
          "[Removed Lines]",
          "1095:    can have dest, lhs the same",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1129:     }",
          "1130: }",
          "1135: void mpz_add_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "1136:     if (mpn_cmp(lhs->dig, lhs->len, rhs->dig, rhs->len) < 0) {",
          "1137:         const mpz_t *temp = lhs;",
          "",
          "[Removed Lines]",
          "1133:    can have dest, lhs, rhs the same",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1150:     dest->neg = lhs->neg & !!dest->len;",
          "1151: }",
          "1156: void mpz_sub_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "1157:     bool neg = false;",
          "",
          "[Removed Lines]",
          "1154:    can have dest, lhs, rhs the same",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1180:     }",
          "1181: }",
          "1186: void mpz_and_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "1188:     if (lhs->len < rhs->len) {",
          "",
          "[Removed Lines]",
          "1184:    can have dest, lhs, rhs the same",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1214:     #endif",
          "1215: }",
          "1220: void mpz_or_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "1222:     if (lhs->len < rhs->len) {",
          "",
          "[Removed Lines]",
          "1218:    can have dest, lhs, rhs the same",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1248:     #endif",
          "1249: }",
          "1254: void mpz_xor_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "1256:     if (lhs->len < rhs->len) {",
          "",
          "[Removed Lines]",
          "1252:    can have dest, lhs, rhs the same",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1286:     #endif",
          "1287: }",
          "1292: void mpz_mul_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "1293:     if (lhs->len == 0 || rhs->len == 0) {",
          "1294:         mpz_set_from_int(dest, 0);",
          "",
          "[Removed Lines]",
          "1290:    can have dest, lhs, rhs the same",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1318:     mpz_free(temp);",
          "1319: }",
          "1324: void mpz_pow_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs) {",
          "1325:     if (lhs->len == 0 || rhs->neg != 0) {",
          "1326:         mpz_set_from_int(dest, 0);",
          "",
          "[Removed Lines]",
          "1322:    can have dest, lhs, rhs the same",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1352:     mpz_free(n);",
          "1353: }",
          "1358: void mpz_pow3_inpl(mpz_t *dest, const mpz_t *lhs, const mpz_t *rhs, const mpz_t *mod) {",
          "1359:     if (lhs->len == 0 || rhs->neg != 0 || (mod->len == 1 && mod->dig[0] == 1)) {",
          "1360:         mpz_set_from_int(dest, 0);",
          "",
          "[Removed Lines]",
          "1356:    can have dest, lhs, rhs the same; mod can't be the same as dest",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1390:     mpz_free(n);",
          "1391: }",
          "1483: void mpz_divmod_inpl(mpz_t *dest_quo, mpz_t *dest_rem, const mpz_t *lhs, const mpz_t *rhs) {",
          "1484:     assert(!mpz_is_zero(rhs));",
          "",
          "[Removed Lines]",
          "1393: #if 0",
          "1394: these functions are unused",
          "1397:    based on Knuth's modified gcd algorithm (I think?)",
          "1398:    gcd(z1, z2) >= 0",
          "1399:    gcd(0, 0) = 0",
          "1400:    gcd(z, 0) = abs(z)",
          "1402: mpz_t *mpz_gcd(const mpz_t *z1, const mpz_t *z2) {",
          "1403:     if (z1->len == 0) {",
          "1405:         mpz_t *a = mpz_clone(z2);",
          "1406:         a->neg = 0;",
          "1407:         return a;",
          "1408:     } else if (z2->len == 0) {",
          "1409:         mpz_t *a = mpz_clone(z1);",
          "1410:         a->neg = 0;",
          "1411:         return a;",
          "1412:     }",
          "1414:     mpz_t *a = mpz_clone(z1);",
          "1415:     mpz_t *b = mpz_clone(z2);",
          "1416:     mpz_t c;",
          "1417:     mpz_init_zero(&c);",
          "1418:     a->neg = 0;",
          "1419:     b->neg = 0;",
          "1421:     for (;;) {",
          "1422:         if (mpz_cmp(a, b) < 0) {",
          "1423:             if (a->len == 0) {",
          "1424:                 mpz_free(a);",
          "1425:                 mpz_deinit(&c);",
          "1426:                 return b;",
          "1427:             }",
          "1428:             mpz_t *t = a;",
          "1429:             a = b;",
          "1430:             b = t;",
          "1431:         }",
          "1432:         if (!(b->len >= 2 || (b->len == 1 && b->dig[0] > 1))) { // compute b > 0; could be mpz_cmp_small_int(b, 1) > 0",
          "1433:             break;",
          "1434:         }",
          "1435:         mpz_set(&c, b);",
          "1436:         do {",
          "1437:             mpz_add_inpl(&c, &c, &c);",
          "1438:         } while (mpz_cmp(&c, a) <= 0);",
          "1439:         c.len = mpn_shr(c.dig, c.dig, c.len, 1);",
          "1440:         mpz_sub_inpl(a, a, &c);",
          "1441:     }",
          "1443:     mpz_deinit(&c);",
          "1445:     if (b->len == 1 && b->dig[0] == 1) { // compute b == 1; could be mpz_cmp_small_int(b, 1) == 0",
          "1446:         mpz_free(a);",
          "1447:         return b;",
          "1448:     } else {",
          "1449:         mpz_free(b);",
          "1450:         return a;",
          "1451:     }",
          "1452: }",
          "1455:      = abs(z1) / gcd(z1, z2) * abs(z2)",
          "1456:   lcm(z1, z1) >= 0",
          "1457:   lcm(0, 0) = 0",
          "1458:   lcm(z, 0) = 0",
          "1460: mpz_t *mpz_lcm(const mpz_t *z1, const mpz_t *z2) {",
          "1461:     if (z1->len == 0 || z2->len == 0) {",
          "1462:         return mpz_zero();",
          "1463:     }",
          "1465:     mpz_t *gcd = mpz_gcd(z1, z2);",
          "1466:     mpz_t *quo = mpz_zero();",
          "1467:     mpz_t *rem = mpz_zero();",
          "1468:     mpz_divmod_inpl(quo, rem, z1, gcd);",
          "1469:     mpz_mul_inpl(rem, quo, z2);",
          "1470:     mpz_free(gcd);",
          "1471:     mpz_free(quo);",
          "1472:     rem->neg = 0;",
          "1473:     return rem;",
          "1474: }",
          "1475: #endif",
          "1478:        quo * rhs + rem = lhs",
          "1479:        0 <= rem < rhs",
          "1480:    can have lhs, rhs the same",
          "1481:    assumes rhs != 0 (undefined behaviour if it is)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1504:     }",
          "1505: }",
          "1536: mp_int_t mpz_hash(const mpz_t *z) {",
          "1537:     mp_uint_t val = 0;",
          "1538:     mpz_dig_t *d = z->dig + z->len;",
          "",
          "[Removed Lines]",
          "1507: #if 0",
          "1508: these functions are unused",
          "1511:    can have lhs, rhs the same",
          "1513: mpz_t *mpz_div(const mpz_t *lhs, const mpz_t *rhs) {",
          "1514:     mpz_t *quo = mpz_zero();",
          "1515:     mpz_t rem;",
          "1516:     mpz_init_zero(&rem);",
          "1517:     mpz_divmod_inpl(quo, &rem, lhs, rhs);",
          "1518:     mpz_deinit(&rem);",
          "1519:     return quo;",
          "1520: }",
          "1523:    can have lhs, rhs the same",
          "1525: mpz_t *mpz_mod(const mpz_t *lhs, const mpz_t *rhs) {",
          "1526:     mpz_t quo;",
          "1527:     mpz_init_zero(&quo);",
          "1528:     mpz_t *rem = mpz_zero();",
          "1529:     mpz_divmod_inpl(&quo, rem, lhs, rhs);",
          "1530:     mpz_deinit(&quo);",
          "1531:     return rem;",
          "1532: }",
          "1533: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1648: }",
          "1649: #endif",
          "1663: size_t mpz_as_str_inpl(const mpz_t *i, unsigned int base, const char *prefix, char base_char, char comma, char *str) {",
          "1664:     assert(str != NULL);",
          "1665:     assert(2 <= base && base <= 32);",
          "",
          "[Removed Lines]",
          "1651: #if 0",
          "1652: this function is unused",
          "1653: char *mpz_as_str(const mpz_t *i, unsigned int base) {",
          "1654:     char *s = m_new(char, mp_int_format_size(mpz_max_num_bits(i), base, NULL, '\\0'));",
          "1655:     mpz_as_str_inpl(i, base, NULL, 'a', '\\0', s);",
          "1656:     return s;",
          "1657: }",
          "1658: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
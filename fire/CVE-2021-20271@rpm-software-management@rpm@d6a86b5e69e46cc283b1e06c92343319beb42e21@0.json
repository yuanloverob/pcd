{
  "cve_id": "CVE-2021-20271",
  "cve_desc": "A flaw was found in RPM's signature check functionality when reading a package file. This flaw allows an attacker who can convince a victim to install a seemingly verifiable package, whose signature header was modified, to cause RPM database corruption and execute code. The highest threat from this vulnerability is to data integrity, confidentiality, and system availability.",
  "repo": "rpm-software-management/rpm",
  "patch_hash": "d6a86b5e69e46cc283b1e06c92343319beb42e21",
  "patch_info": {
    "commit_hash": "d6a86b5e69e46cc283b1e06c92343319beb42e21",
    "repo": "rpm-software-management/rpm",
    "commit_url": "https://github.com/rpm-software-management/rpm/commit/d6a86b5e69e46cc283b1e06c92343319beb42e21",
    "files": [
      "lib/package.c"
    ],
    "message": "Be much more careful about copying data from the signature header\n\nOnly look for known tags, and ensure correct type and size where known\nbefore copying over. Bump the old arbitrary 16k count limit to 16M limit\nthough, it's not inconceivable that a package could have that many files.\nWhile at it, ensure none of these tags exist in the main header,\nwhich would confuse us greatly.\n\nThis is optimized for backporting ease, upstream can remove redundancies\nand further improve checking later.\n\nReported and initial patches by Demi Marie Obenour.\n\nFixes: RhBug:1935049, RhBug:1933867, RhBug:1935035, RhBug:1934125, ...\n\nFixes: CVE-2021-3421, CVE-2021-20271",
    "before_after_code_files": [
      "lib/package.c||lib/package.c"
    ]
  },
  "patch_diff": {
    "lib/package.c||lib/package.c": [
      "File: lib/package.c -> lib/package.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "31:     rpmRC rc;",
      "32: };",
      "39: static",
      "41: {",
      "43:     struct rpmtd_s td;",
      "70:      break;",
      "89:   break;",
      "97:   break;",
      "103:   break;",
      "106:   break;",
      "109:  }",
      "110:     }",
      "112: }",
      "",
      "[Removed Lines]",
      "40: void headerMergeLegacySigs(Header h, Header sigh)",
      "42:     HeaderIterator hi;",
      "45:     hi = headerInitIterator(sigh);",
      "46:     for (; headerNext(hi, &td); rpmtdFreeData(&td))",
      "47:     {",
      "48:  switch (td.tag) {",
      "50:  case RPMSIGTAG_SIZE:",
      "51:      td.tag = RPMTAG_SIGSIZE;",
      "52:      break;",
      "53:  case RPMSIGTAG_PGP:",
      "54:      td.tag = RPMTAG_SIGPGP;",
      "55:      break;",
      "56:  case RPMSIGTAG_MD5:",
      "57:      td.tag = RPMTAG_SIGMD5;",
      "58:      break;",
      "59:  case RPMSIGTAG_GPG:",
      "60:      td.tag = RPMTAG_SIGGPG;",
      "61:      break;",
      "62:  case RPMSIGTAG_PGP5:",
      "63:      td.tag = RPMTAG_SIGPGP5;",
      "64:      break;",
      "65:  case RPMSIGTAG_PAYLOADSIZE:",
      "66:      td.tag = RPMTAG_ARCHIVESIZE;",
      "67:      break;",
      "68:  case RPMSIGTAG_FILESIGNATURES:",
      "69:      td.tag = RPMTAG_FILESIGNATURES;",
      "71:  case RPMSIGTAG_FILESIGNATURELENGTH:",
      "72:      td.tag = RPMTAG_FILESIGNATURELENGTH;",
      "73:      break;",
      "74:  case RPMSIGTAG_VERITYSIGNATURES:",
      "75:  case RPMSIGTAG_VERITYSIGNATUREALGO:",
      "76:  case RPMSIGTAG_SHA1:",
      "77:  case RPMSIGTAG_SHA256:",
      "78:  case RPMSIGTAG_DSA:",
      "79:  case RPMSIGTAG_RSA:",
      "80:  default:",
      "81:      if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE))",
      "82:   continue;",
      "83:      break;",
      "84:  }",
      "85:  if (!headerIsEntry(h, td.tag)) {",
      "86:      switch (td.type) {",
      "87:      case RPM_NULL_TYPE:",
      "88:   continue;",
      "90:      case RPM_CHAR_TYPE:",
      "91:      case RPM_INT8_TYPE:",
      "92:      case RPM_INT16_TYPE:",
      "93:      case RPM_INT32_TYPE:",
      "94:      case RPM_INT64_TYPE:",
      "95:   if (td.count != 1)",
      "96:       continue;",
      "98:      case RPM_STRING_TYPE:",
      "99:      case RPM_STRING_ARRAY_TYPE:",
      "100:      case RPM_BIN_TYPE:",
      "101:   if (td.count >= 16*1024)",
      "102:       continue;",
      "104:      case RPM_I18NSTRING_TYPE:",
      "105:   continue;",
      "107:      }",
      "108:      (void) headerPut(h, &td, HEADERPUT_DEFAULT);",
      "111:     headerFreeIterator(hi);",
      "",
      "[Added Lines]",
      "34: struct taglate_s {",
      "35:     rpmTagVal stag;",
      "36:     rpmTagVal xtag;",
      "37:     rpm_count_t count;",
      "38: } const xlateTags[] = {",
      "39:     { RPMSIGTAG_SIZE, RPMTAG_SIGSIZE, 1 },",
      "40:     { RPMSIGTAG_PGP, RPMTAG_SIGPGP, 0 },",
      "41:     { RPMSIGTAG_MD5, RPMTAG_SIGMD5, 16 },",
      "42:     { RPMSIGTAG_GPG, RPMTAG_SIGGPG, 0 },",
      "44:     { RPMSIGTAG_PAYLOADSIZE, RPMTAG_ARCHIVESIZE, 1 },",
      "45:     { RPMSIGTAG_FILESIGNATURES, RPMTAG_FILESIGNATURES, 0 },",
      "46:     { RPMSIGTAG_FILESIGNATURELENGTH, RPMTAG_FILESIGNATURELENGTH, 1 },",
      "47:     { RPMSIGTAG_VERITYSIGNATURES, RPMTAG_VERITYSIGNATURES, 0 },",
      "48:     { RPMSIGTAG_VERITYSIGNATUREALGO, RPMTAG_VERITYSIGNATUREALGO, 1 },",
      "49:     { RPMSIGTAG_SHA1, RPMTAG_SHA1HEADER, 1 },",
      "50:     { RPMSIGTAG_SHA256, RPMTAG_SHA256HEADER, 1 },",
      "51:     { RPMSIGTAG_DSA, RPMTAG_DSAHEADER, 0 },",
      "52:     { RPMSIGTAG_RSA, RPMTAG_RSAHEADER, 0 },",
      "53:     { RPMSIGTAG_LONGSIZE, RPMTAG_LONGSIGSIZE, 1 },",
      "54:     { RPMSIGTAG_LONGARCHIVESIZE, RPMTAG_LONGARCHIVESIZE, 1 },",
      "55:     { 0 }",
      "56: };",
      "65: rpmTagVal headerMergeLegacySigs(Header h, Header sigh, char **msg)",
      "67:     const struct taglate_s *xl;",
      "70:     rpmtdReset(&td);",
      "71:     for (xl = xlateTags; xl->stag; xl++) {",
      "73:  if (headerIsEntry(h, xl->xtag))",
      "75:  if (headerGet(sigh, xl->stag, &td, HEADERGET_RAW|HEADERGET_MINMEM)) {",
      "77:      if (xl->stag != xl->xtag)",
      "78:   td.tag = xl->xtag;",
      "80:      if (td.type != rpmTagGetTagType(td.tag))",
      "82:      if (td.count < 1 || td.count > 16*1024*1024)",
      "84:      if (xl->count && td.count != xl->count)",
      "86:      if (!headerPut(h, &td, HEADERPUT_DEFAULT))",
      "88:      rpmtdFreeData(&td);",
      "91:     rpmtdFreeData(&td);",
      "93:     if (xl->stag) {",
      "94:  rasprintf(msg, \"invalid signature tag %s (%d)\",",
      "95:    rpmTagGetName(xl->xtag), xl->xtag);",
      "96:     }",
      "98:     return xl->stag;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "380:   goto exit;",
      "384:      applyRetrofits(h);",
      "",
      "[Removed Lines]",
      "383:      headerMergeLegacySigs(h, sigh);",
      "",
      "[Added Lines]",
      "370:      if (headerMergeLegacySigs(h, sigh, &msg))",
      "371:   goto exit;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9fe388c9a48b9074d25515e0fd129d21471036a3",
      "candidate_info": {
        "commit_hash": "9fe388c9a48b9074d25515e0fd129d21471036a3",
        "repo": "rpm-software-management/rpm",
        "commit_url": "https://github.com/rpm-software-management/rpm/commit/9fe388c9a48b9074d25515e0fd129d21471036a3",
        "files": [
          "lib/package.c"
        ],
        "message": "Be much more careful about copying data from the signature header\n\nOnly look for known tags, and ensure correct type and size where known\nbefore copying over. Bump the old arbitrary 16k count limit to 16M limit\nthough, it's not inconceivable that a package could have that many files.\nWhile at it, ensure none of these tags exist in the main header,\nwhich would confuse us greatly.\n\nThis is optimized for backporting ease, upstream can remove redundancies\nand further improve checking later.\n\nReported and initial patches by Demi Marie Obenour.\n\nFixes: RhBug:1935049, RhBug:1933867, RhBug:1935035, RhBug:1934125, ...\n\nFixes: CVE-2021-3421, CVE-2021-20271\n\nBackported from commit d6a86b5e69e46cc283b1e06c92343319beb42e21",
        "before_after_code_files": [
          "lib/package.c||lib/package.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "lib/package.c||lib/package.c"
          ],
          "candidate": [
            "lib/package.c||lib/package.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/package.c||lib/package.c": [
          "File: lib/package.c -> lib/package.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31:     rpmRC rc;",
          "32: };",
          "39: static",
          "41: {",
          "43:     struct rpmtd_s td;",
          "70:      break;",
          "87:   break;",
          "95:   break;",
          "101:   break;",
          "104:   break;",
          "107:  }",
          "108:     }",
          "110: }",
          "",
          "[Removed Lines]",
          "40: void headerMergeLegacySigs(Header h, Header sigh)",
          "42:     HeaderIterator hi;",
          "45:     hi = headerInitIterator(sigh);",
          "46:     for (; headerNext(hi, &td); rpmtdFreeData(&td))",
          "47:     {",
          "48:  switch (td.tag) {",
          "50:  case RPMSIGTAG_SIZE:",
          "51:      td.tag = RPMTAG_SIGSIZE;",
          "52:      break;",
          "53:  case RPMSIGTAG_PGP:",
          "54:      td.tag = RPMTAG_SIGPGP;",
          "55:      break;",
          "56:  case RPMSIGTAG_MD5:",
          "57:      td.tag = RPMTAG_SIGMD5;",
          "58:      break;",
          "59:  case RPMSIGTAG_GPG:",
          "60:      td.tag = RPMTAG_SIGGPG;",
          "61:      break;",
          "62:  case RPMSIGTAG_PGP5:",
          "63:      td.tag = RPMTAG_SIGPGP5;",
          "64:      break;",
          "65:  case RPMSIGTAG_PAYLOADSIZE:",
          "66:      td.tag = RPMTAG_ARCHIVESIZE;",
          "67:      break;",
          "68:  case RPMSIGTAG_FILESIGNATURES:",
          "69:      td.tag = RPMTAG_FILESIGNATURES;",
          "71:  case RPMSIGTAG_FILESIGNATURELENGTH:",
          "72:      td.tag = RPMTAG_FILESIGNATURELENGTH;",
          "73:      break;",
          "74:  case RPMSIGTAG_SHA1:",
          "75:  case RPMSIGTAG_SHA256:",
          "76:  case RPMSIGTAG_DSA:",
          "77:  case RPMSIGTAG_RSA:",
          "78:  default:",
          "79:      if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE))",
          "80:   continue;",
          "81:      break;",
          "82:  }",
          "83:  if (!headerIsEntry(h, td.tag)) {",
          "84:      switch (td.type) {",
          "85:      case RPM_NULL_TYPE:",
          "86:   continue;",
          "88:      case RPM_CHAR_TYPE:",
          "89:      case RPM_INT8_TYPE:",
          "90:      case RPM_INT16_TYPE:",
          "91:      case RPM_INT32_TYPE:",
          "92:      case RPM_INT64_TYPE:",
          "93:   if (td.count != 1)",
          "94:       continue;",
          "96:      case RPM_STRING_TYPE:",
          "97:      case RPM_STRING_ARRAY_TYPE:",
          "98:      case RPM_BIN_TYPE:",
          "99:   if (td.count >= 16*1024)",
          "100:       continue;",
          "102:      case RPM_I18NSTRING_TYPE:",
          "103:   continue;",
          "105:      }",
          "106:      (void) headerPut(h, &td, HEADERPUT_DEFAULT);",
          "109:     headerFreeIterator(hi);",
          "",
          "[Added Lines]",
          "34: struct taglate_s {",
          "35:     rpmTagVal stag;",
          "36:     rpmTagVal xtag;",
          "37:     rpm_count_t count;",
          "38: } const xlateTags[] = {",
          "39:     { RPMSIGTAG_SIZE, RPMTAG_SIGSIZE, 1 },",
          "40:     { RPMSIGTAG_PGP, RPMTAG_SIGPGP, 0 },",
          "41:     { RPMSIGTAG_MD5, RPMTAG_SIGMD5, 16 },",
          "42:     { RPMSIGTAG_GPG, RPMTAG_SIGGPG, 0 },",
          "44:     { RPMSIGTAG_PAYLOADSIZE, RPMTAG_ARCHIVESIZE, 1 },",
          "45:     { RPMSIGTAG_FILESIGNATURES, RPMTAG_FILESIGNATURES, 0 },",
          "46:     { RPMSIGTAG_FILESIGNATURELENGTH, RPMTAG_FILESIGNATURELENGTH, 1 },",
          "47:     { RPMSIGTAG_SHA1, RPMTAG_SHA1HEADER, 1 },",
          "48:     { RPMSIGTAG_SHA256, RPMTAG_SHA256HEADER, 1 },",
          "49:     { RPMSIGTAG_DSA, RPMTAG_DSAHEADER, 0 },",
          "50:     { RPMSIGTAG_RSA, RPMTAG_RSAHEADER, 0 },",
          "51:     { RPMSIGTAG_LONGSIZE, RPMTAG_LONGSIGSIZE, 1 },",
          "52:     { RPMSIGTAG_LONGARCHIVESIZE, RPMTAG_LONGARCHIVESIZE, 1 },",
          "53:     { 0 }",
          "54: };",
          "63: rpmTagVal headerMergeLegacySigs(Header h, Header sigh, char **msg)",
          "65:     const struct taglate_s *xl;",
          "68:     rpmtdReset(&td);",
          "69:     for (xl = xlateTags; xl->stag; xl++) {",
          "71:  if (headerIsEntry(h, xl->xtag))",
          "73:  if (headerGet(sigh, xl->stag, &td, HEADERGET_RAW|HEADERGET_MINMEM)) {",
          "75:      if (xl->stag != xl->xtag)",
          "76:   td.tag = xl->xtag;",
          "78:      if (td.type != rpmTagGetTagType(td.tag))",
          "80:      if (td.count < 1 || td.count > 16*1024*1024)",
          "82:      if (xl->count && td.count != xl->count)",
          "84:      if (!headerPut(h, &td, HEADERPUT_DEFAULT))",
          "86:      rpmtdFreeData(&td);",
          "89:     rpmtdFreeData(&td);",
          "91:     if (xl->stag) {",
          "92:  rasprintf(msg, \"invalid signature tag %s (%d)\",",
          "93:    rpmTagGetName(xl->xtag), xl->xtag);",
          "94:     }",
          "96:     return xl->stag;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "369:   goto exit;",
          "373:      applyRetrofits(h);",
          "",
          "[Removed Lines]",
          "372:      headerMergeLegacySigs(h, sigh);",
          "",
          "[Added Lines]",
          "359:      if (headerMergeLegacySigs(h, sigh, &msg))",
          "360:   goto exit;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "df99bd28b99d40c8d697aa4d7e1389786ea37a4c",
      "candidate_info": {
        "commit_hash": "df99bd28b99d40c8d697aa4d7e1389786ea37a4c",
        "repo": "rpm-software-management/rpm",
        "commit_url": "https://github.com/rpm-software-management/rpm/commit/df99bd28b99d40c8d697aa4d7e1389786ea37a4c",
        "files": [
          "lib/package.c"
        ],
        "message": "Be much more careful about copying data from the signature header\n\nOnly look for known tags, and ensure correct type and size where known\nbefore copying over. Bump the old arbitrary 16k count limit to 16M limit\nthough, it's not inconceivable that a package could have that many files.\nWhile at it, ensure none of these tags exist in the main header,\nwhich would confuse us greatly.\n\nThis is optimized for backporting ease, upstream can remove redundancies\nand further improve checking later.\n\nReported and initial patches by Demi Marie Obenour.\n\nFixes: RhBug:1935049, RhBug:1933867, RhBug:1935035, RhBug:1934125, ...\n\nFixes: CVE-2021-3421, CVE-2021-20271\n\nBackported from commit d6a86b5e69e46cc283b1e06c92343319beb42e21",
        "before_after_code_files": [
          "lib/package.c||lib/package.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "lib/package.c||lib/package.c"
          ],
          "candidate": [
            "lib/package.c||lib/package.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/package.c||lib/package.c": [
          "File: lib/package.c -> lib/package.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31:     rpmRC rc;",
          "32: };",
          "39: static",
          "41: {",
          "43:     struct rpmtd_s td;",
          "70:      break;",
          "87:   break;",
          "95:   break;",
          "101:   break;",
          "104:   break;",
          "107:  }",
          "108:     }",
          "110: }",
          "",
          "[Removed Lines]",
          "40: void headerMergeLegacySigs(Header h, Header sigh)",
          "42:     HeaderIterator hi;",
          "45:     hi = headerInitIterator(sigh);",
          "46:     for (; headerNext(hi, &td); rpmtdFreeData(&td))",
          "47:     {",
          "48:  switch (td.tag) {",
          "50:  case RPMSIGTAG_SIZE:",
          "51:      td.tag = RPMTAG_SIGSIZE;",
          "52:      break;",
          "53:  case RPMSIGTAG_PGP:",
          "54:      td.tag = RPMTAG_SIGPGP;",
          "55:      break;",
          "56:  case RPMSIGTAG_MD5:",
          "57:      td.tag = RPMTAG_SIGMD5;",
          "58:      break;",
          "59:  case RPMSIGTAG_GPG:",
          "60:      td.tag = RPMTAG_SIGGPG;",
          "61:      break;",
          "62:  case RPMSIGTAG_PGP5:",
          "63:      td.tag = RPMTAG_SIGPGP5;",
          "64:      break;",
          "65:  case RPMSIGTAG_PAYLOADSIZE:",
          "66:      td.tag = RPMTAG_ARCHIVESIZE;",
          "67:      break;",
          "68:  case RPMSIGTAG_FILESIGNATURES:",
          "69:      td.tag = RPMTAG_FILESIGNATURES;",
          "71:  case RPMSIGTAG_FILESIGNATURELENGTH:",
          "72:      td.tag = RPMTAG_FILESIGNATURELENGTH;",
          "73:      break;",
          "74:  case RPMSIGTAG_SHA1:",
          "75:  case RPMSIGTAG_SHA256:",
          "76:  case RPMSIGTAG_DSA:",
          "77:  case RPMSIGTAG_RSA:",
          "78:  default:",
          "79:      if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE))",
          "80:   continue;",
          "81:      break;",
          "82:  }",
          "83:  if (!headerIsEntry(h, td.tag)) {",
          "84:      switch (td.type) {",
          "85:      case RPM_NULL_TYPE:",
          "86:   continue;",
          "88:      case RPM_CHAR_TYPE:",
          "89:      case RPM_INT8_TYPE:",
          "90:      case RPM_INT16_TYPE:",
          "91:      case RPM_INT32_TYPE:",
          "92:      case RPM_INT64_TYPE:",
          "93:   if (td.count != 1)",
          "94:       continue;",
          "96:      case RPM_STRING_TYPE:",
          "97:      case RPM_STRING_ARRAY_TYPE:",
          "98:      case RPM_BIN_TYPE:",
          "99:   if (td.count >= 16*1024)",
          "100:       continue;",
          "102:      case RPM_I18NSTRING_TYPE:",
          "103:   continue;",
          "105:      }",
          "106:      (void) headerPut(h, &td, HEADERPUT_DEFAULT);",
          "109:     headerFreeIterator(hi);",
          "",
          "[Added Lines]",
          "34: struct taglate_s {",
          "35:     rpmTagVal stag;",
          "36:     rpmTagVal xtag;",
          "37:     rpm_count_t count;",
          "38: } const xlateTags[] = {",
          "39:     { RPMSIGTAG_SIZE, RPMTAG_SIGSIZE, 1 },",
          "40:     { RPMSIGTAG_PGP, RPMTAG_SIGPGP, 0 },",
          "41:     { RPMSIGTAG_MD5, RPMTAG_SIGMD5, 16 },",
          "42:     { RPMSIGTAG_GPG, RPMTAG_SIGGPG, 0 },",
          "44:     { RPMSIGTAG_PAYLOADSIZE, RPMTAG_ARCHIVESIZE, 1 },",
          "45:     { RPMSIGTAG_FILESIGNATURES, RPMTAG_FILESIGNATURES, 0 },",
          "46:     { RPMSIGTAG_FILESIGNATURELENGTH, RPMTAG_FILESIGNATURELENGTH, 1 },",
          "47:     { RPMSIGTAG_SHA1, RPMTAG_SHA1HEADER, 1 },",
          "48:     { RPMSIGTAG_SHA256, RPMTAG_SHA256HEADER, 1 },",
          "49:     { RPMSIGTAG_DSA, RPMTAG_DSAHEADER, 0 },",
          "50:     { RPMSIGTAG_RSA, RPMTAG_RSAHEADER, 0 },",
          "51:     { RPMSIGTAG_LONGSIZE, RPMTAG_LONGSIGSIZE, 1 },",
          "52:     { RPMSIGTAG_LONGARCHIVESIZE, RPMTAG_LONGARCHIVESIZE, 1 },",
          "53:     { 0 }",
          "54: };",
          "63: rpmTagVal headerMergeLegacySigs(Header h, Header sigh, char **msg)",
          "65:     const struct taglate_s *xl;",
          "68:     rpmtdReset(&td);",
          "69:     for (xl = xlateTags; xl->stag; xl++) {",
          "71:  if (headerIsEntry(h, xl->xtag))",
          "73:  if (headerGet(sigh, xl->stag, &td, HEADERGET_RAW|HEADERGET_MINMEM)) {",
          "75:      if (xl->stag != xl->xtag)",
          "76:   td.tag = xl->xtag;",
          "78:      if (td.type != rpmTagGetTagType(td.tag))",
          "80:      if (td.count < 1 || td.count > 16*1024*1024)",
          "82:      if (xl->count && td.count != xl->count)",
          "84:      if (!headerPut(h, &td, HEADERPUT_DEFAULT))",
          "86:      rpmtdFreeData(&td);",
          "89:     rpmtdFreeData(&td);",
          "91:     if (xl->stag) {",
          "92:  rasprintf(msg, \"invalid signature tag %s (%d)\",",
          "93:    rpmTagGetName(xl->xtag), xl->xtag);",
          "94:     }",
          "96:     return xl->stag;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "369:   goto exit;",
          "373:      applyRetrofits(h);",
          "",
          "[Removed Lines]",
          "372:      headerMergeLegacySigs(h, sigh);",
          "",
          "[Added Lines]",
          "359:      if (headerMergeLegacySigs(h, sigh, &msg))",
          "360:   goto exit;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bcfef4a4ed0fa5bbfdaf8ad3679839bcba249917",
      "candidate_info": {
        "commit_hash": "bcfef4a4ed0fa5bbfdaf8ad3679839bcba249917",
        "repo": "rpm-software-management/rpm",
        "commit_url": "https://github.com/rpm-software-management/rpm/commit/bcfef4a4ed0fa5bbfdaf8ad3679839bcba249917",
        "files": [
          "lib/package.c"
        ],
        "message": "Be much more careful about copying data from the signature header\n\nOnly look for known tags, and ensure correct type and size where known\nbefore copying over. Bump the old arbitrary 16k count limit to 16M limit\nthough, it's not inconceivable that a package could have that many files.\nWhile at it, ensure none of these tags exist in the main header,\nwhich would confuse us greatly.\n\nThis is optimized for backporting ease, upstream can remove redundancies\nand further improve checking later.\n\nReported and initial patches by Demi Marie Obenour.\n\nFixes: RhBug:1935049, RhBug:1933867, RhBug:1935035, RhBug:1934125, ...\n\nFixes: CVE-2021-3421, CVE-2021-20271\n\nBackported from commit d6a86b5e69e46cc283b1e06c92343319beb42e21",
        "before_after_code_files": [
          "lib/package.c||lib/package.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "lib/package.c||lib/package.c"
          ],
          "candidate": [
            "lib/package.c||lib/package.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/package.c||lib/package.c": [
          "File: lib/package.c -> lib/package.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31:     rpmRC rc;",
          "32: };",
          "39: static",
          "41: {",
          "43:     struct rpmtd_s td;",
          "70:      break;",
          "87:   break;",
          "95:   break;",
          "101:   break;",
          "104:   break;",
          "107:  }",
          "108:     }",
          "110: }",
          "",
          "[Removed Lines]",
          "40: void headerMergeLegacySigs(Header h, Header sigh)",
          "42:     HeaderIterator hi;",
          "45:     hi = headerInitIterator(sigh);",
          "46:     for (; headerNext(hi, &td); rpmtdFreeData(&td))",
          "47:     {",
          "48:  switch (td.tag) {",
          "50:  case RPMSIGTAG_SIZE:",
          "51:      td.tag = RPMTAG_SIGSIZE;",
          "52:      break;",
          "53:  case RPMSIGTAG_PGP:",
          "54:      td.tag = RPMTAG_SIGPGP;",
          "55:      break;",
          "56:  case RPMSIGTAG_MD5:",
          "57:      td.tag = RPMTAG_SIGMD5;",
          "58:      break;",
          "59:  case RPMSIGTAG_GPG:",
          "60:      td.tag = RPMTAG_SIGGPG;",
          "61:      break;",
          "62:  case RPMSIGTAG_PGP5:",
          "63:      td.tag = RPMTAG_SIGPGP5;",
          "64:      break;",
          "65:  case RPMSIGTAG_PAYLOADSIZE:",
          "66:      td.tag = RPMTAG_ARCHIVESIZE;",
          "67:      break;",
          "68:  case RPMSIGTAG_FILESIGNATURES:",
          "69:      td.tag = RPMTAG_FILESIGNATURES;",
          "71:  case RPMSIGTAG_FILESIGNATURELENGTH:",
          "72:      td.tag = RPMTAG_FILESIGNATURELENGTH;",
          "73:      break;",
          "74:  case RPMSIGTAG_SHA1:",
          "75:  case RPMSIGTAG_SHA256:",
          "76:  case RPMSIGTAG_DSA:",
          "77:  case RPMSIGTAG_RSA:",
          "78:  default:",
          "79:      if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE))",
          "80:   continue;",
          "81:      break;",
          "82:  }",
          "83:  if (!headerIsEntry(h, td.tag)) {",
          "84:      switch (td.type) {",
          "85:      case RPM_NULL_TYPE:",
          "86:   continue;",
          "88:      case RPM_CHAR_TYPE:",
          "89:      case RPM_INT8_TYPE:",
          "90:      case RPM_INT16_TYPE:",
          "91:      case RPM_INT32_TYPE:",
          "92:      case RPM_INT64_TYPE:",
          "93:   if (td.count != 1)",
          "94:       continue;",
          "96:      case RPM_STRING_TYPE:",
          "97:      case RPM_STRING_ARRAY_TYPE:",
          "98:      case RPM_BIN_TYPE:",
          "99:   if (td.count >= 16*1024)",
          "100:       continue;",
          "102:      case RPM_I18NSTRING_TYPE:",
          "103:   continue;",
          "105:      }",
          "106:      (void) headerPut(h, &td, HEADERPUT_DEFAULT);",
          "109:     headerFreeIterator(hi);",
          "",
          "[Added Lines]",
          "34: struct taglate_s {",
          "35:     rpmTagVal stag;",
          "36:     rpmTagVal xtag;",
          "37:     rpm_count_t count;",
          "38: } const xlateTags[] = {",
          "39:     { RPMSIGTAG_SIZE, RPMTAG_SIGSIZE, 1 },",
          "40:     { RPMSIGTAG_PGP, RPMTAG_SIGPGP, 0 },",
          "41:     { RPMSIGTAG_MD5, RPMTAG_SIGMD5, 16 },",
          "42:     { RPMSIGTAG_GPG, RPMTAG_SIGGPG, 0 },",
          "44:     { RPMSIGTAG_PAYLOADSIZE, RPMTAG_ARCHIVESIZE, 1 },",
          "45:     { RPMSIGTAG_FILESIGNATURES, RPMTAG_FILESIGNATURES, 0 },",
          "46:     { RPMSIGTAG_FILESIGNATURELENGTH, RPMTAG_FILESIGNATURELENGTH, 1 },",
          "47:     { RPMSIGTAG_SHA1, RPMTAG_SHA1HEADER, 1 },",
          "48:     { RPMSIGTAG_SHA256, RPMTAG_SHA256HEADER, 1 },",
          "49:     { RPMSIGTAG_DSA, RPMTAG_DSAHEADER, 0 },",
          "50:     { RPMSIGTAG_RSA, RPMTAG_RSAHEADER, 0 },",
          "51:     { RPMSIGTAG_LONGSIZE, RPMTAG_LONGSIGSIZE, 1 },",
          "52:     { RPMSIGTAG_LONGARCHIVESIZE, RPMTAG_LONGARCHIVESIZE, 1 },",
          "53:     { 0 }",
          "54: };",
          "63: rpmTagVal headerMergeLegacySigs(Header h, Header sigh, char **msg)",
          "65:     const struct taglate_s *xl;",
          "68:     rpmtdReset(&td);",
          "69:     for (xl = xlateTags; xl->stag; xl++) {",
          "71:  if (headerIsEntry(h, xl->xtag))",
          "73:  if (headerGet(sigh, xl->stag, &td, HEADERGET_RAW|HEADERGET_MINMEM)) {",
          "75:      if (xl->stag != xl->xtag)",
          "76:   td.tag = xl->xtag;",
          "78:      if (td.type != rpmTagGetTagType(td.tag))",
          "80:      if (td.count < 1 || td.count > 16*1024*1024)",
          "82:      if (xl->count && td.count != xl->count)",
          "84:      if (!headerPut(h, &td, HEADERPUT_DEFAULT))",
          "86:      rpmtdFreeData(&td);",
          "89:     rpmtdFreeData(&td);",
          "91:     if (xl->stag) {",
          "92:  rasprintf(msg, \"invalid signature tag %s (%d)\",",
          "93:    rpmTagGetName(xl->xtag), xl->xtag);",
          "94:     }",
          "96:     return xl->stag;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "378:   goto exit;",
          "382:      applyRetrofits(h);",
          "",
          "[Removed Lines]",
          "381:      headerMergeLegacySigs(h, sigh);",
          "",
          "[Added Lines]",
          "368:      if (headerMergeLegacySigs(h, sigh, &msg))",
          "369:   goto exit;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f7b97593af5cf818a5c6c5b9bc55bba6d08c9cb0",
      "candidate_info": {
        "commit_hash": "f7b97593af5cf818a5c6c5b9bc55bba6d08c9cb0",
        "repo": "rpm-software-management/rpm",
        "commit_url": "https://github.com/rpm-software-management/rpm/commit/f7b97593af5cf818a5c6c5b9bc55bba6d08c9cb0",
        "files": [
          "lib/package.c"
        ],
        "message": "Optimize signature header merge a bit\n\nLook up possible offending tags from the main header first in a separate\nloop, this avoids having to re-sort after each headerPut() operation.",
        "before_after_code_files": [
          "lib/package.c||lib/package.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/rpm-software-management/rpm/pull/1577"
        ],
        "olp_code_files": {
          "patch": [
            "lib/package.c||lib/package.c"
          ],
          "candidate": [
            "lib/package.c||lib/package.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/package.c||lib/package.c": [
          "File: lib/package.c -> lib/package.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "67:     const struct taglate_s *xl;",
          "68:     struct rpmtd_s td;",
          "71:     for (xl = xlateTags; xl->stag; xl++) {",
          "73:  if (headerIsEntry(h, xl->xtag))",
          "75:  if (headerGet(sigh, xl->stag, &td, HEADERGET_RAW|HEADERGET_MINMEM)) {",
          "77:      if (xl->stag != xl->xtag)",
          "",
          "[Removed Lines]",
          "70:     rpmtdReset(&td);",
          "74:      break;",
          "",
          "[Added Lines]",
          "73:      goto exit;",
          "74:     }",
          "76:     rpmtdReset(&td);",
          "77:     for (xl = xlateTags; xl->stag; xl++) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "90:     }",
          "91:     rpmtdFreeData(&td);",
          "93:     if (xl->stag) {",
          "94:  rasprintf(msg, \"invalid signature tag %s (%d)\",",
          "95:    rpmTagGetName(xl->xtag), xl->xtag);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "96: exit:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "822c3dc2046c29718e34ac2da16a9757a9be11da",
      "candidate_info": {
        "commit_hash": "822c3dc2046c29718e34ac2da16a9757a9be11da",
        "repo": "rpm-software-management/rpm",
        "commit_url": "https://github.com/rpm-software-management/rpm/commit/822c3dc2046c29718e34ac2da16a9757a9be11da",
        "files": [
          "lib/package.c"
        ],
        "message": "Exclude the xlateTags symbol from librpm's public API.\n\nThe d6a86b5e69e46cc283b1e06c92343319beb42e21 commit introduced\na new variable that is only used internally by headerMergeLegacySigs().",
        "before_after_code_files": [
          "lib/package.c||lib/package.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/package.c||lib/package.c"
          ],
          "candidate": [
            "lib/package.c||lib/package.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/package.c||lib/package.c": [
          "File: lib/package.c -> lib/package.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31:     rpmRC rc;",
          "32: };",
          "35:     rpmTagVal stag;",
          "36:     rpmTagVal xtag;",
          "37:     rpm_count_t count;",
          "",
          "[Removed Lines]",
          "34: struct taglate_s {",
          "",
          "[Added Lines]",
          "34: static struct taglate_s {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2024-4030",
  "cve_desc": "On Windows a directory returned by tempfile.mkdtemp() would not always have permissions set to restrict reading and writing to the temporary directory by other users, instead usually inheriting the correct permissions from the default location. Alternate configurations or users without a profile directory may not have the intended permissions.\n\nIf you\u2019re not using Windows or haven\u2019t changed the temporary directory location then you aren\u2019t affected by this vulnerability. On other platforms the returned directory is consistently readable and writable only by the current user.\n\nThis issue was caused by Python not supporting Unix permissions on Windows. The fix adds support for Unix \u201c700\u201d for the mkdir function on Windows which is used by mkdtemp() to ensure the newly created directory has the proper permissions.",
  "repo": "python/cpython",
  "patch_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
  "patch_info": {
    "commit_hash": "d86b49411753bf2c83291e3a14ae43fefded2f84",
    "repo": "python/cpython",
    "commit_url": "https://github.com/python/cpython/commit/d86b49411753bf2c83291e3a14ae43fefded2f84",
    "files": [
      "Doc/whatsnew/3.13.rst",
      "Misc/NEWS.d/next/Security/2024-05-01-20-57-09.gh-issue-118486.K44KJG.rst"
    ],
    "message": "gh-118486: Update docs for CVE-2024-4030 reference (GH-118737)\n\nUpdate docs for CVE-2024-4030 reference",
    "before_after_code_files": []
  },
  "patch_diff": {},
  "candidates": [
    {
      "candidate_hash": "91c4444d22a36119c83c9a21bfe0efe39d745086",
      "candidate_info": {
        "commit_hash": "91c4444d22a36119c83c9a21bfe0efe39d745086",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/91c4444d22a36119c83c9a21bfe0efe39d745086",
        "files": [
          "Include/internal/pycore_interp.h",
          "Include/object.h",
          "Lib/test/test_free_threading/test_type.py",
          "Objects/typeobject.c",
          "Tools/tsan/suppressions_free_threading.txt"
        ],
        "message": "[3.13] gh-117657: Make Py_TYPE and Py_SET_TYPE thread safe (GH-120165) (GH-120403)\n\ngh-117657: Make Py_TYPE and Py_SET_TYPE thread safe (GH-120165)\n(cherry picked from commit e16aed63f64b18a26859eff3de976ded373e66b8)\n\nCo-authored-by: Ken Jin <kenjin@python.org>\nCo-authored-by: B\u00e9n\u00e9dikt Tran <10796600+picnixz@users.noreply.github.com>\nCo-authored-by: Nadeshiko Manju <me@manjusaka.me>",
        "before_after_code_files": [
          "Include/internal/pycore_interp.h||Include/internal/pycore_interp.h",
          "Include/object.h||Include/object.h",
          "Lib/test/test_free_threading/test_type.py||Lib/test/test_free_threading/test_type.py",
          "Objects/typeobject.c||Objects/typeobject.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Include/internal/pycore_interp.h||Include/internal/pycore_interp.h": [
          "File: Include/internal/pycore_interp.h -> Include/internal/pycore_interp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "401: #define RARE_EVENT_INTERP_INC(interp, name) \\",
          "402:     do { \\",
          "405:         RARE_EVENT_STAT_INC(name); \\",
          "406:     } while (0); \\",
          "",
          "[Removed Lines]",
          "404:         if (interp->rare_events.name < UINT8_MAX) interp->rare_events.name++; \\",
          "",
          "[Added Lines]",
          "404:         int val = FT_ATOMIC_LOAD_UINT8_RELAXED(interp->rare_events.name); \\",
          "405:         if (val < UINT8_MAX) { \\",
          "406:             FT_ATOMIC_STORE_UINT8(interp->rare_events.name, val + 1); \\",
          "407:         } \\",
          "",
          "---------------"
        ],
        "Include/object.h||Include/object.h": [
          "File: Include/object.h -> Include/object.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "333: static inline PyTypeObject* Py_TYPE(PyObject *ob) {",
          "334:     return ob->ob_type;",
          "335: }",
          "336: #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000",
          "337: #  define Py_TYPE(ob) Py_TYPE(_PyObject_CAST(ob))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "334: #ifdef Py_GIL_DISABLED",
          "335:     return (PyTypeObject *)_Py_atomic_load_ptr_relaxed(&ob->ob_type);",
          "336: #else",
          "338: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "423: static inline void Py_SET_TYPE(PyObject *ob, PyTypeObject *type) {",
          "424:     ob->ob_type = type;",
          "425: }",
          "426: #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000",
          "427: #  define Py_SET_TYPE(ob, type) Py_SET_TYPE(_PyObject_CAST(ob), type)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "428: #ifdef Py_GIL_DISABLED",
          "429:     _Py_atomic_store_ptr(&ob->ob_type, type);",
          "430: #else",
          "432: #endif",
          "",
          "---------------"
        ],
        "Lib/test/test_free_threading/test_type.py||Lib/test/test_free_threading/test_type.py": [
          "File: Lib/test/test_free_threading/test_type.py -> Lib/test/test_free_threading/test_type.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:         self.run_one(writer_func, reader_func)",
          "99:     def run_one(self, writer_func, reader_func):",
          "100:         writer = Thread(target=writer_func)",
          "101:         readers = []",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "99:     def test___class___modification(self):",
          "100:         class Foo:",
          "101:             pass",
          "103:         class Bar:",
          "104:             pass",
          "106:         thing = Foo()",
          "107:         def work():",
          "108:             foo = thing",
          "109:             for _ in range(10000):",
          "110:                 foo.__class__ = Bar",
          "111:                 type(foo)",
          "112:                 foo.__class__ = Foo",
          "113:                 type(foo)",
          "116:         threads = []",
          "117:         for i in range(NTHREADS):",
          "118:             thread = threading.Thread(target=work)",
          "119:             thread.start()",
          "120:             threads.append(thread)",
          "122:         for thread in threads:",
          "123:             thread.join()",
          "",
          "---------------"
        ],
        "Objects/typeobject.c||Objects/typeobject.c": [
          "File: Objects/typeobject.c -> Objects/typeobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6474:         if (newto->tp_flags & Py_TPFLAGS_HEAPTYPE) {",
          "6475:             Py_INCREF(newto);",
          "6476:         }",
          "6477:         Py_SET_TYPE(self, newto);",
          "6479:             Py_DECREF(oldto);",
          "6481:         RARE_EVENT_INC(set_class);",
          "6482:         return 0;",
          "",
          "[Removed Lines]",
          "6478:         if (oldto->tp_flags & Py_TPFLAGS_HEAPTYPE)",
          "",
          "[Added Lines]",
          "6477:         Py_BEGIN_CRITICAL_SECTION(self);",
          "6480:         oldto = Py_TYPE(self);",
          "6482:         Py_END_CRITICAL_SECTION();",
          "6483:         if (oldto->tp_flags & Py_TPFLAGS_HEAPTYPE) {",
          "6485:         }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "225c3cd6c1b2e768f1c879c271b48ec27a99cb5b",
      "candidate_info": {
        "commit_hash": "225c3cd6c1b2e768f1c879c271b48ec27a99cb5b",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/225c3cd6c1b2e768f1c879c271b48ec27a99cb5b",
        "files": [
          "Lib/shutil.py",
          "Lib/test/test_shutil.py",
          "Misc/NEWS.d/next/Library/2024-05-30-21-37-05.gh-issue-89727.D6S9ig.rst"
        ],
        "message": "[3.13] GH-89727: Fix `shutil.rmtree()` recursion error on deep trees (GH-119808) (#119918)\n\nImplement `shutil._rmtree_safe_fd()` using a list as a stack to avoid emitting recursion errors on deeply nested trees.\n\n`shutil._rmtree_unsafe()` was fixed in a150679f90.\n\n(cherry picked from commit 53b1981fb0cda6c656069e992f172fc6aad7c99c)\n\nCo-authored-by: Barney Gale <barney.gale@gmail.com>",
        "before_after_code_files": [
          "Lib/shutil.py||Lib/shutil.py",
          "Lib/test/test_shutil.py||Lib/test/test_shutil.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/shutil.py||Lib/shutil.py": [
          "File: Lib/shutil.py -> Lib/shutil.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "635:         onexc(os.rmdir, path, err)",
          "637: # Version using fd-based APIs to protect against races",
          "639:     try:",
          "640:         with os.scandir(topfd) as scandir_it:",
          "641:             entries = list(scandir_it)",
          "667:             try:",
          "670:             except FileNotFoundError:",
          "671:                 continue",
          "707:             try:",
          "708:                 os.unlink(entry.name, dir_fd=topfd)",
          "709:             except FileNotFoundError:",
          "710:                 continue",
          "711:             except OSError as err:",
          "712:                 onexc(os.unlink, fullname, err)",
          "714: _use_fd_functions = ({os.open, os.stat, os.unlink, os.rmdir} <=",
          "715:                      os.supports_dir_fd and",
          "",
          "[Removed Lines]",
          "638: def _rmtree_safe_fd(topfd, path, onexc):",
          "642:     except FileNotFoundError:",
          "643:         return",
          "644:     except OSError as err:",
          "645:         err.filename = path",
          "646:         onexc(os.scandir, path, err)",
          "647:         return",
          "648:     for entry in entries:",
          "649:         fullname = os.path.join(path, entry.name)",
          "650:         try:",
          "651:             is_dir = entry.is_dir(follow_symlinks=False)",
          "652:         except FileNotFoundError:",
          "653:             continue",
          "654:         except OSError:",
          "655:             is_dir = False",
          "656:         else:",
          "657:             if is_dir:",
          "658:                 try:",
          "659:                     orig_st = entry.stat(follow_symlinks=False)",
          "660:                     is_dir = stat.S_ISDIR(orig_st.st_mode)",
          "661:                 except FileNotFoundError:",
          "662:                     continue",
          "663:                 except OSError as err:",
          "664:                     onexc(os.lstat, fullname, err)",
          "665:                     continue",
          "666:         if is_dir:",
          "668:                 dirfd = os.open(entry.name, os.O_RDONLY | os.O_NONBLOCK, dir_fd=topfd)",
          "669:                 dirfd_closed = False",
          "672:             except OSError as err:",
          "673:                 onexc(os.open, fullname, err)",
          "674:             else:",
          "675:                 try:",
          "676:                     if os.path.samestat(orig_st, os.fstat(dirfd)):",
          "677:                         _rmtree_safe_fd(dirfd, fullname, onexc)",
          "678:                         try:",
          "679:                             os.close(dirfd)",
          "680:                         except OSError as err:",
          "681:                             # close() should not be retried after an error.",
          "682:                             dirfd_closed = True",
          "683:                             onexc(os.close, fullname, err)",
          "684:                         dirfd_closed = True",
          "685:                         try:",
          "686:                             os.rmdir(entry.name, dir_fd=topfd)",
          "687:                         except FileNotFoundError:",
          "688:                             continue",
          "689:                         except OSError as err:",
          "690:                             onexc(os.rmdir, fullname, err)",
          "691:                     else:",
          "692:                         try:",
          "693:                             # This can only happen if someone replaces",
          "694:                             # a directory with a symlink after the call to",
          "695:                             # os.scandir or stat.S_ISDIR above.",
          "696:                             raise OSError(\"Cannot call rmtree on a symbolic \"",
          "697:                                           \"link\")",
          "698:                         except OSError as err:",
          "699:                             onexc(os.path.islink, fullname, err)",
          "700:                 finally:",
          "701:                     if not dirfd_closed:",
          "702:                         try:",
          "703:                             os.close(dirfd)",
          "704:                         except OSError as err:",
          "705:                             onexc(os.close, fullname, err)",
          "706:         else:",
          "",
          "[Added Lines]",
          "638: def _rmtree_safe_fd(stack, onexc):",
          "639:     # Each stack item has four elements:",
          "640:     # * func: The first operation to perform: os.lstat, os.close or os.rmdir.",
          "641:     #   Walking a directory starts with an os.lstat() to detect symlinks; in",
          "642:     #   this case, func is updated before subsequent operations and passed to",
          "643:     #   onexc() if an error occurs.",
          "644:     # * dirfd: Open file descriptor, or None if we're processing the top-level",
          "645:     #   directory given to rmtree() and the user didn't supply dir_fd.",
          "646:     # * path: Path of file to operate upon. This is passed to onexc() if an",
          "647:     #   error occurs.",
          "648:     # * orig_entry: os.DirEntry, or None if we're processing the top-level",
          "649:     #   directory given to rmtree(). We used the cached stat() of the entry to",
          "650:     #   save a call to os.lstat() when walking subdirectories.",
          "651:     func, dirfd, path, orig_entry = stack.pop()",
          "652:     name = path if orig_entry is None else orig_entry.name",
          "654:         if func is os.close:",
          "655:             os.close(dirfd)",
          "656:             return",
          "657:         if func is os.rmdir:",
          "658:             os.rmdir(name, dir_fd=dirfd)",
          "659:             return",
          "661:         # Note: To guard against symlink races, we use the standard",
          "662:         # lstat()/open()/fstat() trick.",
          "663:         assert func is os.lstat",
          "664:         if orig_entry is None:",
          "665:             orig_st = os.lstat(name, dir_fd=dirfd)",
          "666:         else:",
          "667:             orig_st = orig_entry.stat(follow_symlinks=False)",
          "669:         func = os.open  # For error reporting.",
          "670:         topfd = os.open(name, os.O_RDONLY | os.O_NONBLOCK, dir_fd=dirfd)",
          "672:         func = os.path.islink  # For error reporting.",
          "673:         try:",
          "674:             if not os.path.samestat(orig_st, os.fstat(topfd)):",
          "675:                 # Symlinks to directories are forbidden, see GH-46010.",
          "676:                 raise OSError(\"Cannot call rmtree on a symbolic link\")",
          "677:             stack.append((os.rmdir, dirfd, path, orig_entry))",
          "678:         finally:",
          "679:             stack.append((os.close, topfd, path, orig_entry))",
          "681:         func = os.scandir  # For error reporting.",
          "684:         for entry in entries:",
          "685:             fullname = os.path.join(path, entry.name)",
          "687:                 if entry.is_dir(follow_symlinks=False):",
          "688:                     # Traverse into sub-directory.",
          "689:                     stack.append((os.lstat, topfd, fullname, entry))",
          "690:                     continue",
          "693:             except OSError:",
          "694:                 pass",
          "701:     except FileNotFoundError as err:",
          "702:         if orig_entry is None or func is os.close:",
          "703:             err.filename = path",
          "704:             onexc(func, path, err)",
          "705:     except OSError as err:",
          "706:         err.filename = path",
          "707:         onexc(func, path, err)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "762:         # While the unsafe rmtree works fine on bytes, the fd based does not.",
          "763:         if isinstance(path, bytes):",
          "764:             path = os.fsdecode(path)",
          "772:         try:",
          "798:         finally:",
          "800:                 try:",
          "801:                     os.close(fd)",
          "802:                 except OSError as err:",
          "",
          "[Removed Lines]",
          "765:         # Note: To guard against symlink races, we use the standard",
          "766:         # lstat()/open()/fstat() trick.",
          "767:         try:",
          "768:             orig_st = os.lstat(path, dir_fd=dir_fd)",
          "769:         except OSError as err:",
          "770:             onexc(os.lstat, path, err)",
          "771:             return",
          "773:             fd = os.open(path, os.O_RDONLY | os.O_NONBLOCK, dir_fd=dir_fd)",
          "774:             fd_closed = False",
          "775:         except OSError as err:",
          "776:             onexc(os.open, path, err)",
          "777:             return",
          "778:         try:",
          "779:             if os.path.samestat(orig_st, os.fstat(fd)):",
          "780:                 _rmtree_safe_fd(fd, path, onexc)",
          "781:                 try:",
          "782:                     os.close(fd)",
          "783:                 except OSError as err:",
          "784:                     # close() should not be retried after an error.",
          "785:                     fd_closed = True",
          "786:                     onexc(os.close, path, err)",
          "787:                 fd_closed = True",
          "788:                 try:",
          "789:                     os.rmdir(path, dir_fd=dir_fd)",
          "790:                 except OSError as err:",
          "791:                     onexc(os.rmdir, path, err)",
          "792:             else:",
          "793:                 try:",
          "794:                     # symlinks to directories are forbidden, see bug #1669",
          "795:                     raise OSError(\"Cannot call rmtree on a symbolic link\")",
          "796:                 except OSError as err:",
          "797:                     onexc(os.path.islink, path, err)",
          "799:             if not fd_closed:",
          "",
          "[Added Lines]",
          "760:         stack = [(os.lstat, dir_fd, path, None)]",
          "762:             while stack:",
          "763:                 _rmtree_safe_fd(stack, onexc)",
          "765:             # Close any file descriptors still on the stack.",
          "766:             while stack:",
          "767:                 func, fd, path, entry = stack.pop()",
          "768:                 if func is not os.close:",
          "769:                     continue",
          "",
          "---------------"
        ],
        "Lib/test/test_shutil.py||Lib/test/test_shutil.py": [
          "File: Lib/test/test_shutil.py -> Lib/test/test_shutil.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "741:             shutil.rmtree(TESTFN)",
          "742:             raise",
          "745:     def test_rmtree_above_recursion_limit(self):",
          "746:         recursion_limit = 40",
          "747:         # directory_depth > recursion_limit",
          "",
          "[Removed Lines]",
          "744:     @unittest.skipIf(shutil._use_fd_functions, \"fd-based functions remain unfixed (GH-89727)\")",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "48f3378d6c620e99f17679ee11982a57640d3bb4",
      "candidate_info": {
        "commit_hash": "48f3378d6c620e99f17679ee11982a57640d3bb4",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/48f3378d6c620e99f17679ee11982a57640d3bb4",
        "files": [
          "Python/gc_free_threading.c",
          "Tools/tsan/suppressions_free_threading.txt"
        ],
        "message": "[3.13] gh-117657: Fix TSAN race in free-threaded GC (GH-119883) (#119903)\n\nOnly call `gc_restore_tid()` from stop-the-world contexts.\n`worklist_pop()` can be called while other threads are running, so use a\nrelaxed atomic to modify `ob_tid`.\n(cherry picked from commit 60593b2052ca275559c11028d50e19f8e5dfee13)\n\nCo-authored-by: Sam Gross <colesbury@gmail.com>",
        "before_after_code_files": [
          "Python/gc_free_threading.c||Python/gc_free_threading.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Python/gc_free_threading.c||Python/gc_free_threading.c": [
          "File: Python/gc_free_threading.c -> Python/gc_free_threading.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "86:     PyObject *op = (PyObject *)worklist->head;",
          "87:     if (op != NULL) {",
          "88:         worklist->head = op->ob_tid;",
          "90:     }",
          "91:     return op;",
          "92: }",
          "",
          "[Removed Lines]",
          "89:         op->ob_tid = 0;",
          "",
          "[Added Lines]",
          "89:         _Py_atomic_store_uintptr_relaxed(&op->ob_tid, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "189: static void",
          "190: gc_restore_tid(PyObject *op)",
          "191: {",
          "192:     mi_segment_t *segment = _mi_ptr_segment(op);",
          "193:     if (_Py_REF_IS_MERGED(op->ob_ref_shared)) {",
          "194:         op->ob_tid = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "192:     assert(_PyInterpreterState_GET()->stoptheworld.world_stopped);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "676:             Py_DECREF(temp);",
          "677:         }",
          "680:         Py_DECREF(op);  // drop worklist reference",
          "681:     }",
          "682: }",
          "",
          "[Removed Lines]",
          "679:         gc_restore_tid(op);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "986: {",
          "987:     PyObject *op;",
          "988:     while ((op = worklist_pop(worklist)) != NULL) {",
          "990:         gc_clear_unreachable(op);",
          "991:         Py_DECREF(op);",
          "992:     }",
          "",
          "[Removed Lines]",
          "989:         gc_restore_tid(op);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f3d7823ede41f7650ae7a199186cb63f62031441",
      "candidate_info": {
        "commit_hash": "f3d7823ede41f7650ae7a199186cb63f62031441",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/f3d7823ede41f7650ae7a199186cb63f62031441",
        "files": [
          "Lib/test/list_tests.py",
          "Lib/test/test_list.py",
          "Misc/NEWS.d/next/Core and Builtins/2024-06-13-12-17-52.gh-issue-120384.w1UBGl.rst",
          "Objects/listobject.c"
        ],
        "message": "[3.13] gh-120384: Fix array-out-of-bounds crash in `list_ass_subscript` (GH-120442) (#120826)\n\ngh-120384: Fix array-out-of-bounds crash in `list_ass_subscript` (GH-120442)\n(cherry picked from commit 8334a1b55c93068f5d243852029baa83377ff6c9)\n\nCo-authored-by: Nikita Sobolev <mail@sobolevn.me>",
        "before_after_code_files": [
          "Lib/test/list_tests.py||Lib/test/list_tests.py",
          "Lib/test/test_list.py||Lib/test/test_list.py",
          "Objects/listobject.c||Objects/listobject.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Lib/test/list_tests.py||Lib/test/list_tests.py": [
          "File: Lib/test/list_tests.py -> Lib/test/list_tests.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "192:         self.assertRaises(TypeError, a.__setitem__)",
          "194:     def test_delslice(self):",
          "195:         a = self.type2test([0, 1])",
          "196:         del a[1:2]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "194:     def test_slice_assign_iterator(self):",
          "195:         x = self.type2test(range(5))",
          "196:         x[0:3] = reversed(range(3))",
          "197:         self.assertEqual(x, self.type2test([2, 1, 0, 3, 4]))",
          "199:         x[:] = reversed(range(3))",
          "200:         self.assertEqual(x, self.type2test([2, 1, 0]))",
          "",
          "---------------"
        ],
        "Lib/test/test_list.py||Lib/test/test_list.py": [
          "File: Lib/test/test_list.py -> Lib/test/test_list.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "245:         with self.assertRaises(TypeError):",
          "246:             a[0] < a",
          "248:     @cpython_only",
          "249:     def test_preallocation(self):",
          "250:         iterable = [0] * 10",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "248:     def test_list_index_modifing_operand(self):",
          "249:         # See gh-120384",
          "250:         class evil:",
          "251:             def __init__(self, lst):",
          "252:                 self.lst = lst",
          "253:             def __iter__(self):",
          "254:                 yield from self.lst",
          "255:                 self.lst.clear()",
          "257:         lst = list(range(5))",
          "258:         operand = evil(lst)",
          "259:         with self.assertRaises(ValueError):",
          "260:             lst[::-1] = operand",
          "",
          "---------------"
        ],
        "Objects/listobject.c||Objects/listobject.c": [
          "File: Objects/listobject.c -> Objects/listobject.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3581:     }",
          "3582: }",
          "3584: static int",
          "3585: list_ass_subscript(PyObject* _self, PyObject* item, PyObject* value)",
          "3586: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3584: static Py_ssize_t",
          "3585: adjust_slice_indexes(PyListObject *lst,",
          "3586:                      Py_ssize_t *start, Py_ssize_t *stop,",
          "3587:                      Py_ssize_t step)",
          "3588: {",
          "3589:     Py_ssize_t slicelength = PySlice_AdjustIndices(Py_SIZE(lst), start, stop,",
          "3590:                                                    step);",
          "3594:     if ((step < 0 && *start < *stop) ||",
          "3595:         (step > 0 && *start > *stop))",
          "3598:     return slicelength;",
          "3599: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3594:         return list_ass_item((PyObject *)self, i, value);",
          "3595:     }",
          "3596:     else if (PySlice_Check(item)) {",
          "3599:         if (PySlice_Unpack(item, &start, &stop, &step) < 0) {",
          "3600:             return -1;",
          "3601:         }",
          "3614:         if (value == NULL) {",
          "",
          "[Removed Lines]",
          "3597:         Py_ssize_t start, stop, step, slicelength;",
          "3602:         slicelength = PySlice_AdjustIndices(Py_SIZE(self), &start, &stop,",
          "3603:                                             step);",
          "3605:         if (step == 1)",
          "3606:             return list_ass_slice(self, start, stop, value);",
          "3610:         if ((step < 0 && start < stop) ||",
          "3611:             (step > 0 && start > stop))",
          "3612:             stop = start;",
          "",
          "[Added Lines]",
          "3614:         Py_ssize_t start, stop, step;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3618:             Py_ssize_t i;",
          "3619:             int res;",
          "3621:             if (slicelength <= 0)",
          "3622:                 return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3627:             Py_ssize_t slicelength = adjust_slice_indexes(self, &start, &stop,",
          "3628:                                                           step);",
          "3630:             if (step == 1)",
          "3631:                 return list_ass_slice(self, start, stop, value);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3695:             if (!seq)",
          "3696:                 return -1;",
          "3698:             if (PySequence_Fast_GET_SIZE(seq) != slicelength) {",
          "3699:                 PyErr_Format(PyExc_ValueError,",
          "3700:                     \"attempt to assign sequence of \"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3710:             Py_ssize_t slicelength = adjust_slice_indexes(self, &start, &stop,",
          "3711:                                                           step);",
          "3713:             if (step == 1) {",
          "3714:                 int res = list_ass_slice(self, start, stop, seq);",
          "3715:                 Py_DECREF(seq);",
          "3716:                 return res;",
          "3717:             }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3cb6c4cd60bec1acbcd960f5e7bd65f78152dbdd",
      "candidate_info": {
        "commit_hash": "3cb6c4cd60bec1acbcd960f5e7bd65f78152dbdd",
        "repo": "python/cpython",
        "commit_url": "https://github.com/python/cpython/commit/3cb6c4cd60bec1acbcd960f5e7bd65f78152dbdd",
        "files": [
          "Doc/c-api/init.rst",
          "Doc/whatsnew/3.13.rst",
          "Include/Python.h",
          "Include/cpython/lock.h",
          "Include/cpython/weakrefobject.h",
          "Include/internal/pycore_critical_section.h",
          "Include/internal/pycore_lock.h",
          "Include/internal/pycore_warnings.h",
          "Include/lock.h",
          "Include/object.h",
          "Makefile.pre.in",
          "Misc/NEWS.d/next/C API/2024-04-10-16-48-04.gh-issue-117511.RZtBRK.rst",
          "Modules/_testinternalcapi/test_lock.c",
          "Objects/object.c",
          "PCbuild/pythoncore.vcxproj",
          "PCbuild/pythoncore.vcxproj.filters",
          "Python/critical_section.c",
          "Python/lock.c"
        ],
        "message": "[3.13] gh-117511: Make PyMutex public in the non-limited API (GH-117731) (#120800)\n\n(cherry picked from commit 3af7263037de1d0ef63b070fc7bfc2cf042eaebe)",
        "before_after_code_files": [
          "Include/Python.h||Include/Python.h",
          "Include/cpython/lock.h||Include/cpython/lock.h",
          "Include/cpython/weakrefobject.h||Include/cpython/weakrefobject.h",
          "Include/internal/pycore_critical_section.h||Include/internal/pycore_critical_section.h",
          "Include/internal/pycore_lock.h||Include/internal/pycore_lock.h",
          "Include/internal/pycore_warnings.h||Include/internal/pycore_warnings.h",
          "Include/lock.h||Include/lock.h",
          "Include/object.h||Include/object.h",
          "Makefile.pre.in||Makefile.pre.in",
          "Modules/_testinternalcapi/test_lock.c||Modules/_testinternalcapi/test_lock.c",
          "Objects/object.c||Objects/object.c",
          "PCbuild/pythoncore.vcxproj||PCbuild/pythoncore.vcxproj",
          "PCbuild/pythoncore.vcxproj.filters||PCbuild/pythoncore.vcxproj.filters",
          "Python/critical_section.c||Python/critical_section.c",
          "Python/lock.c||Python/lock.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/AcreetionOS-Linux/python/pull/2"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Include/Python.h||Include/Python.h": [
          "File: Include/Python.h -> Include/Python.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: #include \"pybuffer.h\"",
          "65: #include \"pystats.h\"",
          "66: #include \"pyatomic.h\"",
          "67: #include \"object.h\"",
          "68: #include \"objimpl.h\"",
          "69: #include \"typeslots.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "67: #include \"lock.h\"",
          "",
          "---------------"
        ],
        "Include/cpython/lock.h||Include/cpython/lock.h": [
          "File: Include/cpython/lock.h -> Include/cpython/lock.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #ifndef Py_CPYTHON_LOCK_H",
          "2: #  error \"this header file must not be included directly\"",
          "3: #endif",
          "5: #define _Py_UNLOCKED    0",
          "6: #define _Py_LOCKED      1",
          "29: typedef struct PyMutex {",
          "30:     uint8_t _bits;  // (private)",
          "31: } PyMutex;",
          "34: PyAPI_FUNC(void) PyMutex_Lock(PyMutex *m);",
          "37: PyAPI_FUNC(void) PyMutex_Unlock(PyMutex *m);",
          "44: static inline void",
          "45: _PyMutex_Lock(PyMutex *m)",
          "46: {",
          "47:     uint8_t expected = _Py_UNLOCKED;",
          "48:     if (!_Py_atomic_compare_exchange_uint8(&m->_bits, &expected, _Py_LOCKED)) {",
          "49:         PyMutex_Lock(m);",
          "50:     }",
          "51: }",
          "52: #define PyMutex_Lock _PyMutex_Lock",
          "55: static inline void",
          "56: _PyMutex_Unlock(PyMutex *m)",
          "57: {",
          "58:     uint8_t expected = _Py_LOCKED;",
          "59:     if (!_Py_atomic_compare_exchange_uint8(&m->_bits, &expected, _Py_UNLOCKED)) {",
          "60:         PyMutex_Unlock(m);",
          "61:     }",
          "62: }",
          "63: #define PyMutex_Unlock _PyMutex_Unlock",
          "",
          "---------------"
        ],
        "Include/cpython/weakrefobject.h||Include/cpython/weakrefobject.h": [
          "File: Include/cpython/weakrefobject.h -> Include/cpython/weakrefobject.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: #endif",
          "41: };",
          "",
          "[Removed Lines]",
          "39:     struct _PyMutex *weakrefs_lock;",
          "",
          "[Added Lines]",
          "39:     PyMutex *weakrefs_lock;",
          "",
          "---------------"
        ],
        "Include/internal/pycore_critical_section.h||Include/internal/pycore_critical_section.h": [
          "File: Include/internal/pycore_critical_section.h -> Include/internal/pycore_critical_section.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "202: static inline void",
          "203: _PyCriticalSection_Begin(_PyCriticalSection *c, PyMutex *m)",
          "204: {",
          "206:         PyThreadState *tstate = _PyThreadState_GET();",
          "207:         c->mutex = m;",
          "208:         c->prev = tstate->critical_section;",
          "",
          "[Removed Lines]",
          "205:     if (PyMutex_LockFast(&m->v)) {",
          "",
          "[Added Lines]",
          "205:     if (PyMutex_LockFast(&m->_bits)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "255:         m2 = tmp;",
          "256:     }",
          "260:             PyThreadState *tstate = _PyThreadState_GET();",
          "261:             c->base.mutex = m1;",
          "262:             c->mutex2 = m2;",
          "",
          "[Removed Lines]",
          "258:     if (PyMutex_LockFast(&m1->v)) {",
          "259:         if (PyMutex_LockFast(&m2->v)) {",
          "",
          "[Added Lines]",
          "258:     if (PyMutex_LockFast(&m1->_bits)) {",
          "259:         if (PyMutex_LockFast(&m2->_bits)) {",
          "",
          "---------------"
        ],
        "Include/internal/pycore_lock.h||Include/internal/pycore_lock.h": [
          "File: Include/internal/pycore_lock.h -> Include/internal/pycore_lock.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #  error \"this header requires Py_BUILD_CORE define\"",
          "14: #endif",
          "49: #define _Py_HAS_PARKED  2",
          "50: #define _Py_ONCE_INITIALIZED 4",
          "58: static inline int",
          "59: PyMutex_LockFast(uint8_t *lock_bits)",
          "60: {",
          "",
          "[Removed Lines]",
          "41: #ifndef Py_GIL_DISABLED",
          "42: struct _PyMutex { uint8_t v; };",
          "43: #endif",
          "45: typedef struct _PyMutex PyMutex;",
          "47: #define _Py_UNLOCKED    0",
          "48: #define _Py_LOCKED      1",
          "53: PyAPI_FUNC(void) _PyMutex_LockSlow(PyMutex *m);",
          "56: PyAPI_FUNC(void) _PyMutex_UnlockSlow(PyMutex *m);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62:     return _Py_atomic_compare_exchange_uint8(lock_bits, &expected, _Py_LOCKED);",
          "63: }",
          "90: static inline int",
          "91: PyMutex_IsLocked(PyMutex *m)",
          "92: {",
          "94: }",
          "",
          "[Removed Lines]",
          "70: static inline void",
          "71: PyMutex_Lock(PyMutex *m)",
          "72: {",
          "73:     uint8_t expected = _Py_UNLOCKED;",
          "74:     if (!_Py_atomic_compare_exchange_uint8(&m->v, &expected, _Py_LOCKED)) {",
          "75:         _PyMutex_LockSlow(m);",
          "76:     }",
          "77: }",
          "80: static inline void",
          "81: PyMutex_Unlock(PyMutex *m)",
          "82: {",
          "83:     uint8_t expected = _Py_LOCKED;",
          "84:     if (!_Py_atomic_compare_exchange_uint8(&m->v, &expected, _Py_UNLOCKED)) {",
          "85:         _PyMutex_UnlockSlow(m);",
          "86:     }",
          "87: }",
          "93:     return (_Py_atomic_load_uint8(&m->v) & _Py_LOCKED) != 0;",
          "",
          "[Added Lines]",
          "31:     return (_Py_atomic_load_uint8(&m->_bits) & _Py_LOCKED) != 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "121: PyMutex_LockFlags(PyMutex *m, _PyLockFlags flags)",
          "122: {",
          "123:     uint8_t expected = _Py_UNLOCKED;",
          "125:         _PyMutex_LockTimed(m, -1, flags);",
          "126:     }",
          "127: }",
          "",
          "[Removed Lines]",
          "124:     if (!_Py_atomic_compare_exchange_uint8(&m->v, &expected, _Py_LOCKED)) {",
          "",
          "[Added Lines]",
          "62:     if (!_Py_atomic_compare_exchange_uint8(&m->_bits, &expected, _Py_LOCKED)) {",
          "",
          "---------------"
        ],
        "Include/internal/pycore_warnings.h||Include/internal/pycore_warnings.h": [
          "File: Include/internal/pycore_warnings.h -> Include/internal/pycore_warnings.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "18:     long filters_version;",
          "19: };",
          "",
          "[Removed Lines]",
          "17:     struct _PyMutex mutex;",
          "",
          "[Added Lines]",
          "17:     PyMutex mutex;",
          "",
          "---------------"
        ],
        "Include/lock.h||Include/lock.h": [
          "File: Include/lock.h -> Include/lock.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #ifndef Py_LOCK_H",
          "2: #define Py_LOCK_H",
          "3: #ifdef __cplusplus",
          "4: extern \"C\" {",
          "5: #endif",
          "7: #ifndef Py_LIMITED_API",
          "8: #  define Py_CPYTHON_LOCK_H",
          "9: #  include \"cpython/lock.h\"",
          "10: #  undef Py_CPYTHON_LOCK_H",
          "11: #endif",
          "13: #ifdef __cplusplus",
          "14: }",
          "15: #endif",
          "",
          "---------------"
        ],
        "Include/object.h||Include/object.h": [
          "File: Include/object.h -> Include/object.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "205: #define _Py_REF_SHARED(refcnt, flags) (((refcnt) << _Py_REF_SHARED_SHIFT) + (flags))",
          "211: struct _object {",
          "215:     uintptr_t ob_tid;",
          "216:     uint16_t _padding;",
          "218:     uint8_t ob_gc_bits;         // gc-related state",
          "219:     uint32_t ob_ref_local;      // local reference count",
          "220:     Py_ssize_t ob_ref_shared;   // shared (atomic) reference count",
          "",
          "[Removed Lines]",
          "209: struct _PyMutex { uint8_t v; };",
          "217:     struct _PyMutex ob_mutex;   // per-object lock",
          "",
          "[Added Lines]",
          "213:     PyMutex ob_mutex;           // per-object lock",
          "",
          "---------------"
        ],
        "Makefile.pre.in||Makefile.pre.in": [
          "File: Makefile.pre.in -> Makefile.pre.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "1019:   $(srcdir)/Include/intrcheck.h \\",
          "1020:   $(srcdir)/Include/iterobject.h \\",
          "1021:   $(srcdir)/Include/listobject.h \\",
          "1022:   $(srcdir)/Include/longobject.h \\",
          "1023:   $(srcdir)/Include/marshal.h \\",
          "1024:   $(srcdir)/Include/memoryobject.h \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1022:   $(srcdir)/Include/lock.h \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1091:   $(srcdir)/Include/cpython/import.h \\",
          "1092:   $(srcdir)/Include/cpython/initconfig.h \\",
          "1093:   $(srcdir)/Include/cpython/listobject.h \\",
          "1094:   $(srcdir)/Include/cpython/longintrepr.h \\",
          "1095:   $(srcdir)/Include/cpython/longobject.h \\",
          "1096:   $(srcdir)/Include/cpython/memoryobject.h \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1095:   $(srcdir)/Include/cpython/lock.h \\",
          "",
          "---------------"
        ],
        "Modules/_testinternalcapi/test_lock.c||Modules/_testinternalcapi/test_lock.c": [
          "File: Modules/_testinternalcapi/test_lock.c -> Modules/_testinternalcapi/test_lock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38:     PyMutex_Lock(&m);",
          "40:     PyMutex_Unlock(&m);",
          "43:     Py_RETURN_NONE;",
          "44: }",
          "",
          "[Removed Lines]",
          "39:     assert(m.v == 1);",
          "41:     assert(m.v == 0);",
          "",
          "[Added Lines]",
          "39:     assert(m._bits == 1);",
          "41:     assert(m._bits == 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57:     _Py_atomic_store_int(&test_data->started, 1);",
          "59:     PyMutex_Lock(m);",
          "62:     PyMutex_Unlock(m);",
          "65:     _PyEvent_Notify(&test_data->done);",
          "66: }",
          "",
          "[Removed Lines]",
          "60:     assert(m->v == 1);",
          "63:     assert(m->v == 0);",
          "",
          "[Added Lines]",
          "60:     assert(m->_bits == 1);",
          "63:     assert(m->_bits == 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "73:     memset(&test_data, 0, sizeof(test_data));",
          "75:     PyMutex_Lock(&test_data.m);",
          "78:     PyThread_start_new_thread(lock_thread, &test_data);",
          "",
          "[Removed Lines]",
          "76:     assert(test_data.m.v == 1);",
          "",
          "[Added Lines]",
          "76:     assert(test_data.m._bits == 1);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "82:     uint8_t v;",
          "83:     do {",
          "84:         pysleep(10);  // allow some time for the other thread to try to lock",
          "86:         assert(v == 1 || v == 3);",
          "87:         iters++;",
          "88:     } while (v != 3 && iters < 200);",
          "93:     PyMutex_Unlock(&test_data.m);",
          "94:     PyEvent_Wait(&test_data.done);",
          "97:     Py_RETURN_NONE;",
          "98: }",
          "",
          "[Removed Lines]",
          "85:         v = _Py_atomic_load_uint8_relaxed(&test_data.m.v);",
          "91:     assert(test_data.m.v == 3);",
          "95:     assert(test_data.m.v == 0);",
          "",
          "[Added Lines]",
          "85:         v = _Py_atomic_load_uint8_relaxed(&test_data.m._bits);",
          "91:     assert(test_data.m._bits == 3);",
          "95:     assert(test_data.m._bits == 0);",
          "",
          "---------------"
        ],
        "Objects/object.c||Objects/object.c": [
          "File: Objects/object.c -> Objects/object.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2376: #else",
          "2377:     op->ob_tid = _Py_ThreadId();",
          "2378:     op->_padding = 0;",
          "2380:     op->ob_gc_bits = 0;",
          "2381:     op->ob_ref_local = 1;",
          "2382:     op->ob_ref_shared = 0;",
          "",
          "[Removed Lines]",
          "2379:     op->ob_mutex = (struct _PyMutex){ 0 };",
          "",
          "[Added Lines]",
          "2379:     op->ob_mutex = (PyMutex){ 0 };",
          "",
          "---------------"
        ],
        "PCbuild/pythoncore.vcxproj||PCbuild/pythoncore.vcxproj": [
          "File: PCbuild/pythoncore.vcxproj -> PCbuild/pythoncore.vcxproj",
          "--- Hunk 1 ---",
          "[Context before]",
          "156:     <ClInclude Include=\"..\\Include\\cpython\\import.h\" />",
          "157:     <ClInclude Include=\"..\\Include\\cpython\\initconfig.h\" />",
          "158:     <ClInclude Include=\"..\\Include\\cpython\\listobject.h\" />",
          "159:     <ClInclude Include=\"..\\Include\\cpython\\longintrepr.h\" />",
          "160:     <ClInclude Include=\"..\\Include\\cpython\\longobject.h\" />",
          "161:     <ClInclude Include=\"..\\Include\\cpython\\memoryobject.h\" />",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "159:     <ClInclude Include=\"..\\Include\\cpython\\lock.h\" />",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "310:     <ClInclude Include=\"..\\Include\\intrcheck.h\" />",
          "311:     <ClInclude Include=\"..\\Include\\iterobject.h\" />",
          "312:     <ClInclude Include=\"..\\Include\\listobject.h\" />",
          "313:     <ClInclude Include=\"..\\Include\\longobject.h\" />",
          "314:     <ClInclude Include=\"..\\Include\\marshal.h\" />",
          "315:     <ClInclude Include=\"..\\Include\\memoryobject.h\" />",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "314:     <ClInclude Include=\"..\\Include\\lock.h\" />",
          "",
          "---------------"
        ],
        "PCbuild/pythoncore.vcxproj.filters||PCbuild/pythoncore.vcxproj.filters": [
          "File: PCbuild/pythoncore.vcxproj.filters -> PCbuild/pythoncore.vcxproj.filters",
          "--- Hunk 1 ---",
          "[Context before]",
          "114:     <ClInclude Include=\"..\\Include\\listobject.h\">",
          "115:       <Filter>Include</Filter>",
          "116:     </ClInclude>",
          "117:     <ClInclude Include=\"..\\Include\\longobject.h\">",
          "118:       <Filter>Include</Filter>",
          "119:     </ClInclude>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "117:     <ClInclude Include=\"..\\Include\\lock.h\">",
          "118:       <Filter>Include</Filter>",
          "119:     </ClInclude>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "393:     <ClInclude Include=\"..\\Include\\cpython\\listobject.h\">",
          "394:       <Filter>Include\\cpython</Filter>",
          "395:     </ClInclude>",
          "396:     <ClInclude Include=\"..\\Include\\cpython\\longintrepr.h\">",
          "397:       <Filter>Include</Filter>",
          "398:     </ClInclude>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "399:     <ClInclude Include=\"..\\Include\\cpython\\lock.h\">",
          "400:       <Filter>Include</Filter>",
          "401:     </ClInclude>",
          "",
          "---------------"
        ],
        "Python/critical_section.c||Python/critical_section.c": [
          "File: Python/critical_section.c -> Python/critical_section.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "14:     c->prev = (uintptr_t)tstate->critical_section;",
          "15:     tstate->critical_section = (uintptr_t)c;",
          "18:     c->mutex = m;",
          "19: }",
          "",
          "[Removed Lines]",
          "17:     _PyMutex_LockSlow(m);",
          "",
          "[Added Lines]",
          "17:     PyMutex_Lock(m);",
          "",
          "---------------"
        ],
        "Python/lock.c||Python/lock.c": [
          "File: Python/lock.c -> Python/lock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: #endif",
          "48: }",
          "56: PyLockStatus",
          "57: _PyMutex_LockTimed(PyMutex *m, PyTime_t timeout, _PyLockFlags flags)",
          "58: {",
          "60:     if ((v & _Py_LOCKED) == 0) {",
          "62:             return PY_LOCK_ACQUIRED;",
          "63:         }",
          "64:     }",
          "",
          "[Removed Lines]",
          "50: void",
          "51: _PyMutex_LockSlow(PyMutex *m)",
          "52: {",
          "53:     _PyMutex_LockTimed(m, -1, _PY_LOCK_DETACH);",
          "54: }",
          "59:     uint8_t v = _Py_atomic_load_uint8_relaxed(&m->v);",
          "61:         if (_Py_atomic_compare_exchange_uint8(&m->v, &v, v|_Py_LOCKED)) {",
          "",
          "[Added Lines]",
          "53:     uint8_t v = _Py_atomic_load_uint8_relaxed(&m->_bits);",
          "55:         if (_Py_atomic_compare_exchange_uint8(&m->_bits, &v, v|_Py_LOCKED)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83:     for (;;) {",
          "84:         if ((v & _Py_LOCKED) == 0) {",
          "87:                 return PY_LOCK_ACQUIRED;",
          "88:             }",
          "89:             continue;",
          "",
          "[Removed Lines]",
          "86:             if (_Py_atomic_compare_exchange_uint8(&m->v, &v, v|_Py_LOCKED)) {",
          "",
          "[Added Lines]",
          "80:             if (_Py_atomic_compare_exchange_uint8(&m->_bits, &v, v|_Py_LOCKED)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "104:         if (!(v & _Py_HAS_PARKED)) {",
          "106:             newv = v | _Py_HAS_PARKED;",
          "108:                 continue;",
          "109:             }",
          "110:         }",
          "113:                                      &entry, (flags & _PY_LOCK_DETACH) != 0);",
          "114:         if (ret == Py_PARK_OK) {",
          "115:             if (entry.handed_off) {",
          "118:                 return PY_LOCK_ACQUIRED;",
          "119:             }",
          "120:         }",
          "",
          "[Removed Lines]",
          "107:             if (!_Py_atomic_compare_exchange_uint8(&m->v, &v, newv)) {",
          "112:         int ret = _PyParkingLot_Park(&m->v, &newv, sizeof(newv), timeout,",
          "117:                 assert(_Py_atomic_load_uint8_relaxed(&m->v) & _Py_LOCKED);",
          "",
          "[Added Lines]",
          "101:             if (!_Py_atomic_compare_exchange_uint8(&m->_bits, &v, newv)) {",
          "106:         int ret = _PyParkingLot_Park(&m->_bits, &newv, sizeof(newv), timeout,",
          "111:                 assert(_Py_atomic_load_uint8_relaxed(&m->_bits) & _Py_LOCKED);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "136:             }",
          "137:         }",
          "140:     }",
          "141: }",
          "",
          "[Removed Lines]",
          "139:         v = _Py_atomic_load_uint8_relaxed(&m->v);",
          "",
          "[Added Lines]",
          "133:         v = _Py_atomic_load_uint8_relaxed(&m->_bits);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "158:             v |= _Py_HAS_PARKED;",
          "159:         }",
          "160:     }",
          "162: }",
          "164: int",
          "165: _PyMutex_TryUnlock(PyMutex *m)",
          "166: {",
          "168:     for (;;) {",
          "169:         if ((v & _Py_LOCKED) == 0) {",
          "",
          "[Removed Lines]",
          "161:     _Py_atomic_store_uint8(&m->v, v);",
          "167:     uint8_t v = _Py_atomic_load_uint8(&m->v);",
          "",
          "[Added Lines]",
          "155:     _Py_atomic_store_uint8(&m->_bits, v);",
          "161:     uint8_t v = _Py_atomic_load_uint8(&m->_bits);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "172:         }",
          "173:         else if ((v & _Py_HAS_PARKED)) {",
          "176:             return 0;",
          "177:         }",
          "180:             return 0;",
          "181:         }",
          "182:     }",
          "183: }",
          "195: struct raw_mutex_entry {",
          "",
          "[Removed Lines]",
          "175:             _PyParkingLot_Unpark(&m->v, (_Py_unpark_fn_t *)mutex_unpark, m);",
          "178:         else if (_Py_atomic_compare_exchange_uint8(&m->v, &v, _Py_UNLOCKED)) {",
          "185: void",
          "186: _PyMutex_UnlockSlow(PyMutex *m)",
          "187: {",
          "188:     if (_PyMutex_TryUnlock(m) < 0) {",
          "189:         Py_FatalError(\"unlocking mutex that is not locked\");",
          "190:     }",
          "191: }",
          "",
          "[Added Lines]",
          "169:             _PyParkingLot_Unpark(&m->_bits, (_Py_unpark_fn_t *)mutex_unpark, m);",
          "172:         else if (_Py_atomic_compare_exchange_uint8(&m->_bits, &v, _Py_UNLOCKED)) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "585:      return 0;",
          "586: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "574: #undef PyMutex_Lock",
          "575: void",
          "576: PyMutex_Lock(PyMutex *m)",
          "577: {",
          "578:     _PyMutex_LockTimed(m, -1, _PY_LOCK_DETACH);",
          "579: }",
          "581: #undef PyMutex_Unlock",
          "582: void",
          "583: PyMutex_Unlock(PyMutex *m)",
          "584: {",
          "585:     if (_PyMutex_TryUnlock(m) < 0) {",
          "586:         Py_FatalError(\"unlocking mutex that is not locked\");",
          "587:     }",
          "588: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
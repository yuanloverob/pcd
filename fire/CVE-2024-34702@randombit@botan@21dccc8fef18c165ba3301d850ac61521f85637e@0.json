{
  "cve_id": "CVE-2024-34702",
  "cve_desc": "Botan is a C++ cryptography library. X.509 certificates can identify elliptic curves using either an object identifier or using explicit encoding of the parameters.  Prior to 3.5.0 and 2.19.5, checking name constraints in X.509 certificates is quadratic in the number of names and name constraints. An attacker who presented a certificate chain which contained a very large number of names in the SubjectAlternativeName, signed by a CA certificate which contained a large number of name constraints, could cause a denial of service. The problem has been addressed in Botan 3.5.0 and a partial backport has also been applied and is included in Botan 2.19.5.",
  "repo": "randombit/botan",
  "patch_hash": "21dccc8fef18c165ba3301d850ac61521f85637e",
  "patch_info": {
    "commit_hash": "21dccc8fef18c165ba3301d850ac61521f85637e",
    "repo": "randombit/botan",
    "commit_url": "https://github.com/randombit/botan/commit/21dccc8fef18c165ba3301d850ac61521f85637e",
    "files": [
      "src/lib/x509/asn1_alt_name.cpp",
      "src/lib/x509/name_constraint.cpp",
      "src/lib/x509/pkix_types.h",
      "src/lib/x509/x509_ext.cpp",
      "src/lib/x509/x509cert.cpp",
      "src/python/botan2.py",
      "src/scripts/test_python.py",
      "src/tests/test_name_constraint.cpp"
    ],
    "message": "Merge pull request #4187 from randombit/jack/fix-nc-dos-2x\n\nAddress various name constraint bugs",
    "before_after_code_files": [
      "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp",
      "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
      "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h",
      "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp",
      "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp",
      "src/python/botan2.py||src/python/botan2.py",
      "src/scripts/test_python.py||src/scripts/test_python.py",
      "src/tests/test_name_constraint.cpp||src/tests/test_name_constraint.cpp"
    ]
  },
  "patch_diff": {
    "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp": [
      "File: src/lib/x509/asn1_alt_name.cpp -> src/lib/x509/asn1_alt_name.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "257:             const uint32_t ip = load_be<uint32_t>(obj.bits(), 0);",
      "258:             add_attribute(\"IP\", ipv4_to_string(ip));",
      "259:             }",
      "260:          }",
      "262:       }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "260:          else if(obj.length() != 16)",
      "261:             {",
      "262:             throw Decoding_Error(\"Invalid length for IP address SAN\");",
      "263:             }",
      "",
      "---------------"
    ],
    "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp": [
      "File: src/lib/x509/name_constraint.cpp -> src/lib/x509/name_constraint.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "164: bool GeneralName::matches_dns(const std::string& nam) const",
      "165:    {",
      "167:       {",
      "169:       }",
      "171:       {",
      "173:       return false;",
      "174:       }",
      "176:       {",
      "181:       }",
      "182:    }",
      "184: bool GeneralName::matches_dn(const std::string& nam) const",
      "185:    {",
      "186:    std::stringstream ss(nam);",
      "190:    ss >> nam_dn;",
      "191:    tt >> my_dn;",
      "193:    auto attr = nam_dn.get_attributes();",
      "",
      "[Removed Lines]",
      "166:    if(nam.size() == name().size())",
      "168:       return tolower_string(nam) == tolower_string(name());",
      "170:    else if(name().size() > nam.size())",
      "175:    else // name.size() < nam.size()",
      "178:       const std::string constr = name().front() == '.' ? name() : \".\" + name();",
      "179:       const std::string substr = nam.substr(nam.size() - constr.size(), constr.size());",
      "180:       return tolower_string(constr) == tolower_string(substr);",
      "187:    std::stringstream tt(name());",
      "188:    X509_DN nam_dn, my_dn;",
      "",
      "[Added Lines]",
      "166:    const std::string constraint = tolower_string(name());",
      "167:    const std::string issued = tolower_string(nam);",
      "169:    if(nam.size() == constraint.size())",
      "171:       return issued == constraint;",
      "173:    else if(constraint.size() > nam.size())",
      "178:    else",
      "180:       if(constraint.empty()) {",
      "181:          return true;",
      "182:       }",
      "184:       std::string substr = issued.substr(nam.size() - constraint.size(), constraint.size());",
      "186:       if(constraint.front() == '.') {",
      "187:          return substr == constraint;",
      "188:       } else if(substr[0] == '.') {",
      "189:          return substr.substr(1) == constraint;",
      "190:       } else {",
      "191:          return substr == constraint && issued[issued.size() - constraint.size() - 1] == '.';",
      "194: }",
      "199:    X509_DN nam_dn;",
      "201:    return matches_dn_obj(nam_dn);",
      "202:    }",
      "204: bool GeneralName::matches_dn_obj(const X509_DN& nam_dn) const",
      "205:    {",
      "206:    std::stringstream tt(name());",
      "207:    X509_DN my_dn;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "270:    os << gs.minimum() << \",\" << gs.maximum() << \",\" << gs.base();",
      "271:    return os;",
      "272:    }",
      "273: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "291: NameConstraints::NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,",
      "292:                                  std::vector<GeneralSubtree>&& excluded_subtrees) :",
      "293:    m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees)",
      "294:    {",
      "295:    for(const auto& c : m_permitted_subtrees)",
      "296:       {",
      "297:       m_permitted_name_types.insert(c.base().type());",
      "298:       }",
      "299:    for(const auto& c : m_excluded_subtrees)",
      "300:       {",
      "301:       m_excluded_name_types.insert(c.base().type());",
      "302:       }",
      "303:    }",
      "305: namespace {",
      "307: bool looks_like_ipv4(const std::string& s)",
      "308:    {",
      "309:    try",
      "310:      {",
      "312:      string_to_ipv4(s);",
      "313:      return true;",
      "314:      }",
      "315:    catch(...)",
      "316:       {",
      "317:       return false;",
      "318:       }",
      "319:    }",
      "321: }",
      "323: bool NameConstraints::is_permitted(const X509_Certificate& cert, bool reject_unknown) const {",
      "324:    if(permitted().empty()) {",
      "325:       return true;",
      "326:    }",
      "328:    const auto& alt_name = cert.subject_alt_name();",
      "330:    if(reject_unknown) {",
      "331:       if(m_permitted_name_types.find(\"URI\") != m_permitted_name_types.end() && !alt_name.get_attribute(\"URI\").empty()) {",
      "332:          return false;",
      "333:       }",
      "334:       if(m_permitted_name_types.find(\"RFC822\") != m_permitted_name_types.end() && !alt_name.get_attribute(\"RFC822\").empty()) {",
      "335:          return false;",
      "336:       }",
      "337:    }",
      "339:    auto is_permitted_dn = [&](const X509_DN& dn) {",
      "341:       if(m_permitted_name_types.find(\"DN\") == m_permitted_name_types.end()) {",
      "342:          return true;",
      "343:       }",
      "345:       if(dn.empty()) {",
      "346:          return true;",
      "347:       }",
      "349:       for(const auto& c : m_permitted_subtrees) {",
      "350:          if(c.base().type() == \"DN\" && c.base().matches_dn_obj(dn)) {",
      "351:             return true;",
      "352:          }",
      "353:       }",
      "356:       return false;",
      "357:    };",
      "359:    auto is_permitted_dns_name = [&](const std::string& name) {",
      "360:       if(name.empty() || name[0] == '.') {",
      "361:          return false;",
      "362:       }",
      "365:       if(m_permitted_name_types.find(\"DNS\") == m_permitted_name_types.end()) {",
      "366:          return true;",
      "367:       }",
      "369:       for(const auto& c : m_permitted_subtrees) {",
      "370:          if(c.base().type() == \"DNS\" && c.base().matches_dns(name)) {",
      "371:             return true;",
      "372:          }",
      "373:       }",
      "376:       return false;",
      "377:    };",
      "379:    auto is_permitted_ipv4 = [&](const std::string& ipv4) {",
      "381:       if(m_permitted_name_types.find(\"IP\") == m_permitted_name_types.end()) {",
      "382:          return true;",
      "383:       }",
      "385:       for(const auto& c : m_permitted_subtrees) {",
      "386:          if(c.base().type() == \"IP\" && c.base().matches_ip(ipv4)) {",
      "387:             return true;",
      "388:          }",
      "389:       }",
      "392:       return false;",
      "393:    };",
      "395:    if(!is_permitted_dn(cert.subject_dn())) {",
      "396:       return false;",
      "397:    }",
      "399:    if(!is_permitted_dn(alt_name.dn()))",
      "400:       {",
      "401:       return false;",
      "402:       }",
      "404:    for(const auto& alt_dns : alt_name.get_attribute(\"DNS\")) {",
      "405:       if(!is_permitted_dns_name(alt_dns)) {",
      "406:          return false;",
      "407:       }",
      "408:    }",
      "410:    for(const auto& alt_ipv4 : alt_name.get_attribute(\"IP\")) {",
      "411:       if(!is_permitted_ipv4(alt_ipv4)) {",
      "412:          return false;",
      "413:       }",
      "414:    }",
      "416:    if(!alt_name.has_items())",
      "417:       {",
      "418:       for(const auto& cn : cert.subject_info(\"Name\"))",
      "419:          {",
      "420:          if(cn.find(\".\") != std::string::npos)",
      "421:             {",
      "422:             if(looks_like_ipv4(cn))",
      "423:                {",
      "424:                if(!is_permitted_ipv4(cn))",
      "425:                   {",
      "426:                   return false;",
      "427:                   }",
      "428:                }",
      "429:             else",
      "430:                {",
      "431:                if(!is_permitted_dns_name(cn))",
      "432:                   {",
      "433:                   return false;",
      "434:                   }",
      "435:                }",
      "436:             }",
      "437:          }",
      "438:       }",
      "441:    return true;",
      "444: bool NameConstraints::is_excluded(const X509_Certificate& cert, bool reject_unknown) const {",
      "445:    if(excluded().empty()) {",
      "446:       return false;",
      "447:    }",
      "449:    const auto& alt_name = cert.subject_alt_name();",
      "451:    if(reject_unknown) {",
      "452:       if(m_excluded_name_types.find(\"URI\") != m_excluded_name_types.end() && !alt_name.get_attribute(\"URI\").empty()) {",
      "453:          return false;",
      "454:       }",
      "455:       if(m_excluded_name_types.find(\"RFC822\") != m_excluded_name_types.end() && !alt_name.get_attribute(\"RFC822\").empty()) {",
      "456:          return false;",
      "457:       }",
      "458:    }",
      "460:    auto is_excluded_dn = [&](const X509_DN& dn) {",
      "462:       if(m_excluded_name_types.find(\"DN\") == m_excluded_name_types.end()) {",
      "463:          return false;",
      "464:       }",
      "466:       if(dn.empty()) {",
      "467:          return false;",
      "468:       }",
      "470:       for(const auto& c : m_excluded_subtrees) {",
      "471:          if(c.base().type() == \"DN\" && c.base().matches_dn_obj(dn)) {",
      "472:             return true;",
      "473:          }",
      "474:       }",
      "477:       return false;",
      "478:    };",
      "480:    auto is_excluded_dns_name = [&](const std::string& name) {",
      "481:       if(name.empty() || name[0] == '.') {",
      "482:          return true;",
      "483:       }",
      "486:       if(m_excluded_name_types.find(\"DNS\") == m_excluded_name_types.end()) {",
      "487:          return false;",
      "488:       }",
      "490:       for(const auto& c : m_excluded_subtrees) {",
      "491:          if(c.base().type() == \"DNS\" && c.base().matches_dns(name)) {",
      "492:             return true;",
      "493:          }",
      "494:       }",
      "497:       return false;",
      "498:    };",
      "500:    auto is_excluded_ipv4 = [&](const std::string& ipv4) {",
      "502:       if(m_excluded_name_types.find(\"IP\") == m_excluded_name_types.end()) {",
      "503:          return false;",
      "504:       }",
      "506:       for(const auto& c : m_excluded_subtrees) {",
      "507:          if(c.base().type() == \"IP\" && c.base().matches_ip(ipv4)) {",
      "508:             return true;",
      "509:          }",
      "510:       }",
      "513:       return false;",
      "514:    };",
      "516:    if(is_excluded_dn(cert.subject_dn())) {",
      "517:       return true;",
      "518:    }",
      "520:    if(is_excluded_dn(alt_name.dn())) {",
      "521:       return true;",
      "522:    }",
      "524:    for(const auto& alt_dns : alt_name.get_attribute(\"DNS\")) {",
      "525:       if(is_excluded_dns_name(alt_dns)) {",
      "526:          return true;",
      "527:       }",
      "528:    }",
      "530:    for(const auto& alt_ipv4 : alt_name.get_attribute(\"IP\")) {",
      "531:       if(is_excluded_ipv4(alt_ipv4)) {",
      "532:          return true;",
      "533:       }",
      "534:    }",
      "536:    if(!alt_name.has_items())",
      "537:       {",
      "538:       for(const auto& cn : cert.subject_info(\"Name\"))",
      "539:          {",
      "540:          if(cn.find(\".\") != std::string::npos)",
      "541:             {",
      "542:             if(looks_like_ipv4(cn))",
      "543:                {",
      "544:                if(is_excluded_ipv4(cn))",
      "545:                   {",
      "546:                   return true;",
      "547:                   }",
      "548:                }",
      "549:             else",
      "550:                {",
      "551:                if(is_excluded_dns_name(cn))",
      "552:                   {",
      "553:                   return true;",
      "554:                   }",
      "555:                }",
      "556:             }",
      "557:          }",
      "558:       }",
      "561:    return false;",
      "562: }",
      "564: }  // namespace Botan",
      "",
      "---------------"
    ],
    "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h": [
      "File: src/lib/x509/pkix_types.h -> src/lib/x509/pkix_types.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "216:       GeneralName(const std::string& str);",
      "218:       void encode_into(DER_Encoder&) const override;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "219:       BOTAN_DEPRECATED(\"Deprecated no replacement\")",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "237:       MatchResult matches(const X509_Certificate& cert) const;",
      "243:       bool matches_dns(const std::string&) const;",
      "244:       bool matches_dn(const std::string&) const;",
      "245:       bool matches_ip(const std::string&) const;",
      "246:    };",
      "248: std::ostream& operator<<(std::ostream& os, const GeneralName& gn);",
      "",
      "[Removed Lines]",
      "239:    private:",
      "240:       std::string m_type;",
      "241:       std::string m_name;",
      "",
      "[Added Lines]",
      "241:       BOTAN_DEPRECATED(\"Deprecated no replacement\")",
      "246:       bool matches_dn_obj(const X509_DN& dn) const;",
      "249:    private:",
      "250:       std::string m_type;",
      "251:       std::string m_name;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "263:       GeneralSubtree() : m_base(), m_minimum(0), m_maximum(std::numeric_limits<std::size_t>::max())",
      "264:       {}",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "272:       BOTAN_DEPRECATED(\"Deprecated no replacement\")",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "272:       GeneralSubtree(const GeneralName& base, size_t min, size_t max)",
      "273:       : m_base(base), m_minimum(min), m_maximum(max)",
      "274:       {}",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "282:       BOTAN_DEPRECATED(\"Deprecated no replacement\")",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "280:       GeneralSubtree(const std::string& str);",
      "282:       void encode_into(DER_Encoder&) const override;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "291:       BOTAN_DEPRECATED(\"Deprecated no replacement\")",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "327:       NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,",
      "",
      "[Removed Lines]",
      "328:                     std::vector<GeneralSubtree>&& excluded_subtrees)",
      "329:       : m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees)",
      "330:       {}",
      "",
      "[Added Lines]",
      "340:                       std::vector<GeneralSubtree>&& excluded_subtrees);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "340:       const std::vector<GeneralSubtree>& excluded() const { return m_excluded_subtrees; }",
      "342:    private:",
      "343:       std::vector<GeneralSubtree> m_permitted_subtrees;",
      "344:       std::vector<GeneralSubtree> m_excluded_subtrees;",
      "345:    };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "355:       bool is_permitted(const X509_Certificate& cert, bool reject_unknown) const;",
      "360:       bool is_excluded(const X509_Certificate& cert, bool reject_unknown) const;",
      "366:       std::set<std::string> m_permitted_name_types;",
      "367:       std::set<std::string> m_excluded_name_types;",
      "",
      "---------------"
    ],
    "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp": [
      "File: src/lib/x509/x509_ext.cpp -> src/lib/x509/x509_ext.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "602:    {",
      "603:    std::vector<GeneralSubtree> permit, exclude;",
      "604:    BER_Decoder ber(in);",
      "609:    if(per.is_a(0, ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC)))",
      "610:       {",
      "612:       if(permit.empty())",
      "613:          throw Encoding_Error(\"Empty Name Contraint list\");",
      "614:       }",
      "619:       {",
      "621:       if(exclude.empty())",
      "622:          throw Encoding_Error(\"Empty Name Contraint list\");",
      "623:       }",
      "627:    if(permit.empty() && exclude.empty())",
      "628:       throw Encoding_Error(\"Empty Name Contraint extension\");",
      "",
      "[Removed Lines]",
      "605:    BER_Decoder ext = ber.start_cons(SEQUENCE);",
      "606:    BER_Object per = ext.get_next_object();",
      "608:    ext.push_back(per);",
      "611:       ext.decode_list(permit,ASN1_Tag(0),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));",
      "616:    BER_Object exc = ext.get_next_object();",
      "617:    ext.push_back(exc);",
      "618:    if(per.is_a(1, ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC)))",
      "620:       ext.decode_list(exclude,ASN1_Tag(1),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));",
      "625:    ext.end_cons();",
      "",
      "[Added Lines]",
      "605:    BER_Decoder inner = ber.start_cons(SEQUENCE);",
      "606:    BER_Object per = inner.get_next_object();",
      "608:    inner.push_back(per);",
      "611:       inner.decode_list(permit,ASN1_Tag(0),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));",
      "616:    BER_Object exc = inner.get_next_object();",
      "617:    inner.push_back(exc);",
      "618:    if(exc.is_a(1, ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC)))",
      "620:       inner.decode_list(exclude,ASN1_Tag(1),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));",
      "625:    inner.end_cons();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "651:       }",
      "652:    }",
      "655:       const std::vector<std::shared_ptr<const X509_Certificate>>& cert_path,",
      "656:       std::vector<std::set<Certificate_Status_Code>>& cert_status,",
      "657:       size_t pos)",
      "658:    {",
      "659:    if(!m_name_constraints.permitted().empty() || !m_name_constraints.excluded().empty())",
      "660:       {",
      "661:       if(!subject.is_CA_cert())",
      "",
      "[Removed Lines]",
      "654: void Name_Constraints::validate(const X509_Certificate& subject, const X509_Certificate& issuer,",
      "",
      "[Added Lines]",
      "654: void Name_Constraints::validate(const X509_Certificate& subject, const X509_Certificate& /*issuer*/,",
      "662:    const size_t MAX_NC_COMPARES = (1 << 12);",
      "663:    const size_t total_constraints = m_name_constraints.permitted().size() + m_name_constraints.excluded().size();",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "664:          }",
      "666:       const bool issuer_name_constraint_critical =",
      "670:       for(size_t j = 0; j < pos; ++j)",
      "671:          {",
      "710:             cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);",
      "712:          }",
      "713:       }",
      "714:    }",
      "716: namespace {",
      "",
      "[Removed Lines]",
      "667:          issuer.is_critical(\"X509v3.NameConstraints\");",
      "672:          bool permitted = m_name_constraints.permitted().empty();",
      "673:          bool failed = false;",
      "675:          for(auto c: m_name_constraints.permitted())",
      "676:             {",
      "677:             switch(c.base().matches(*cert_path.at(j)))",
      "678:                {",
      "679:                case GeneralName::MatchResult::NotFound:",
      "680:                case GeneralName::MatchResult::All:",
      "681:                   permitted = true;",
      "682:                   break;",
      "683:                case GeneralName::MatchResult::UnknownType:",
      "684:                   failed = issuer_name_constraint_critical;",
      "685:                   permitted = true;",
      "686:                   break;",
      "687:                default:",
      "688:                   break;",
      "689:                }",
      "690:             }",
      "692:          for(auto c: m_name_constraints.excluded())",
      "693:             {",
      "694:             switch(c.base().matches(*cert_path.at(j)))",
      "695:                {",
      "696:                case GeneralName::MatchResult::All:",
      "697:                case GeneralName::MatchResult::Some:",
      "698:                   failed = true;",
      "699:                   break;",
      "700:                case GeneralName::MatchResult::UnknownType:",
      "701:                   failed = issuer_name_constraint_critical;",
      "702:                   break;",
      "703:                default:",
      "704:                   break;",
      "705:                }",
      "706:             }",
      "708:          if(failed || !permitted)",
      "709:             {",
      "711:             }",
      "",
      "[Added Lines]",
      "673:          subject.is_critical(\"X509v3.NameConstraints\");",
      "678:          const auto& cert = cert_path.at(j);",
      "680:          const size_t total_names =",
      "681:             cert->subject_dn().dn_info().size() +",
      "682:             cert->subject_alt_name().get_attributes().size();",
      "684:          if(total_names * total_constraints >= MAX_NC_COMPARES) {",
      "685:             cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);",
      "686:             continue;",
      "687:          }",
      "689:          if(!m_name_constraints.is_permitted(*cert, issuer_name_constraint_critical)) {",
      "690:             cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);",
      "691:             continue;",
      "692:          }",
      "694:          if(m_name_constraints.is_excluded(*cert, issuer_name_constraint_critical)) {",
      "696:             continue;",
      "700: }",
      "",
      "---------------"
    ],
    "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp": [
      "File: src/lib/x509/x509cert.cpp -> src/lib/x509/x509cert.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "17: #include <botan/oids.h>",
      "18: #include <botan/hash.h>",
      "19: #include <botan/hex.h>",
      "20: #include <algorithm>",
      "21: #include <sstream>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "20: #include <botan/internal/stl_util.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "788:    if(name.empty())",
      "789:       return false;",
      "795:       issued_names = subject_info(\"Name\");",
      "797:    for(size_t i = 0; i != issued_names.size(); ++i)",
      "798:       {",
      "801:       }",
      "803:    return false;",
      "",
      "[Removed Lines]",
      "791:    std::vector<std::string> issued_names = subject_info(\"DNS\");",
      "794:    if(issued_names.empty())",
      "799:       if(host_wildcard_match(issued_names[i], name))",
      "800:          return true;",
      "",
      "[Added Lines]",
      "792:    bool is_ipv4 = false;",
      "794:    try {",
      "795:       string_to_ipv4(name);",
      "796:       is_ipv4 = true;",
      "797:       }",
      "798:    catch(...) {}",
      "800:    std::vector<std::string> issued_names;",
      "802:    if(subject_alt_name().has_items()) {",
      "803:       issued_names = subject_alt_name().get_attribute(is_ipv4 ? \"IP\" : \"DNS\");",
      "804:    } else if(is_ipv4 == false) {",
      "807:    }",
      "811:       if(is_ipv4)",
      "812:          {",
      "813:          if(issued_names[i] == name)",
      "814:             return true;",
      "815:          }",
      "816:       else",
      "817:          {",
      "818:          if(host_wildcard_match(issued_names[i], name))",
      "819:             return true;",
      "820:          }",
      "",
      "---------------"
    ],
    "src/python/botan2.py||src/python/botan2.py": [
      "File: src/python/botan2.py -> src/python/botan2.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "1285: #",
      "1286: class X509Cert(object): # pylint: disable=invalid-name",
      "1287:     def __init__(self, filename=None, buf=None):",
      "1288:         self.__obj = _load_buf_or_file(filename, buf, _DLL.botan_x509_cert_load_file, _DLL.botan_x509_cert_load)",
      "1290:     def __del__(self):",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1288:         self.__obj = c_void_p(0)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1464: #",
      "1465: class X509CRL(object):",
      "1466:     def __init__(self, filename=None, buf=None):",
      "1467:         self.__obj = _load_buf_or_file(filename, buf, _DLL.botan_x509_crl_load_file, _DLL.botan_x509_crl_load)",
      "1469:     def __del__(self):",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1468:         self.__obj = c_void_p(0)",
      "",
      "---------------"
    ],
    "src/scripts/test_python.py||src/scripts/test_python.py": [
      "File: src/scripts/test_python.py -> src/scripts/test_python.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "474:         self.assertEqual(cert.issuer_dn('Organizational Unit', 0), 'bsi')",
      "475:         self.assertEqual(cert.issuer_dn('Country', 0), 'DE')",
      "480:         self.assertEqual(cert.not_before(), 1184858838)",
      "481:         self.assertEqual(cert.not_after(), 1831907880)",
      "",
      "[Removed Lines]",
      "477:         self.assertTrue(cert.hostname_match('csca-germany'))",
      "478:         self.assertFalse(cert.hostname_match('csca-slovakia'))",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/tests/test_name_constraint.cpp||src/tests/test_name_constraint.cpp": [
      "File: src/tests/test_name_constraint.cpp -> src/tests/test_name_constraint.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "29:             std::make_tuple(",
      "30:                \"Root_Email_Name_Constraint.crt\",",
      "31:                \"Invalid_Email_Name_Constraint.crt\",",
      "33:                \"Certificate does not pass name constraint\"),",
      "34:             std::make_tuple(",
      "35:                \"Root_DN_Name_Constraint.crt\",",
      "36:                \"Invalid_DN_Name_Constraint.crt\",",
      "38:                \"Certificate does not pass name constraint\"),",
      "39:             std::make_tuple(",
      "40:                \"Root_DN_Name_Constraint.crt\",",
      "41:                \"Valid_DN_Name_Constraint.crt\",",
      "43:                \"Verified\"),",
      "44:             std::make_tuple(",
      "45:                \"Root_DNS_Name_Constraint.crt\",",
      "",
      "[Removed Lines]",
      "32:                \"Invalid Email Name Constraint\",",
      "37:                \"Invalid DN Name Constraint\",",
      "42:                \"Valid DN Name Constraint\",",
      "",
      "[Added Lines]",
      "32:                \"\",",
      "37:                \"\",",
      "42:                \"\",",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "49:             std::make_tuple(",
      "50:                \"Root_IP_Name_Constraint.crt\",",
      "51:                \"Valid_IP_Name_Constraint.crt\",",
      "53:                \"Verified\"),",
      "54:             std::make_tuple(",
      "55:                \"Root_IP_Name_Constraint.crt\",",
      "56:                \"Invalid_IP_Name_Constraint.crt\",",
      "58:                \"Certificate does not pass name constraint\"),",
      "59:             };",
      "60:          std::vector<Test::Result> results;",
      "",
      "[Removed Lines]",
      "52:                \"Valid IP Name Constraint\",",
      "57:                \"Invalid IP Name Constraint\",",
      "",
      "[Added Lines]",
      "52:                \"\",",
      "57:                \"\",",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "68338f5912534c74469f7f4e6e22b37aa5159952",
      "candidate_info": {
        "commit_hash": "68338f5912534c74469f7f4e6e22b37aa5159952",
        "repo": "randombit/botan",
        "commit_url": "https://github.com/randombit/botan/commit/68338f5912534c74469f7f4e6e22b37aa5159952",
        "files": [
          "src/lib/x509/asn1_alt_name.cpp",
          "src/lib/x509/name_constraint.cpp",
          "src/lib/x509/pkix_types.h",
          "src/lib/x509/x509_ext.cpp",
          "src/lib/x509/x509cert.cpp",
          "src/python/botan2.py",
          "src/scripts/test_python.py",
          "src/tests/test_name_constraint.cpp"
        ],
        "message": "Address various name constraint bugs",
        "before_after_code_files": [
          "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp",
          "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
          "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h",
          "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp",
          "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp",
          "src/python/botan2.py||src/python/botan2.py",
          "src/scripts/test_python.py||src/scripts/test_python.py",
          "src/tests/test_name_constraint.cpp||src/tests/test_name_constraint.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/randombit/botan/pull/4187"
        ],
        "olp_code_files": {
          "patch": [
            "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp",
            "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
            "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h",
            "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp",
            "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp",
            "src/python/botan2.py||src/python/botan2.py",
            "src/scripts/test_python.py||src/scripts/test_python.py",
            "src/tests/test_name_constraint.cpp||src/tests/test_name_constraint.cpp"
          ],
          "candidate": [
            "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp",
            "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp",
            "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h",
            "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp",
            "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp",
            "src/python/botan2.py||src/python/botan2.py",
            "src/scripts/test_python.py||src/scripts/test_python.py",
            "src/tests/test_name_constraint.cpp||src/tests/test_name_constraint.cpp"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/x509/asn1_alt_name.cpp||src/lib/x509/asn1_alt_name.cpp": [
          "File: src/lib/x509/asn1_alt_name.cpp -> src/lib/x509/asn1_alt_name.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "257:             const uint32_t ip = load_be<uint32_t>(obj.bits(), 0);",
          "258:             add_attribute(\"IP\", ipv4_to_string(ip));",
          "259:             }",
          "260:          }",
          "262:       }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "260:          else if(obj.length() != 16)",
          "261:             {",
          "262:             throw Decoding_Error(\"Invalid length for IP address SAN\");",
          "263:             }",
          "",
          "---------------"
        ],
        "src/lib/x509/name_constraint.cpp||src/lib/x509/name_constraint.cpp": [
          "File: src/lib/x509/name_constraint.cpp -> src/lib/x509/name_constraint.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "164: bool GeneralName::matches_dns(const std::string& nam) const",
          "165:    {",
          "167:       {",
          "169:       }",
          "171:       {",
          "173:       return false;",
          "174:       }",
          "176:       {",
          "181:       }",
          "182:    }",
          "184: bool GeneralName::matches_dn(const std::string& nam) const",
          "185:    {",
          "186:    std::stringstream ss(nam);",
          "190:    ss >> nam_dn;",
          "191:    tt >> my_dn;",
          "193:    auto attr = nam_dn.get_attributes();",
          "",
          "[Removed Lines]",
          "166:    if(nam.size() == name().size())",
          "168:       return tolower_string(nam) == tolower_string(name());",
          "170:    else if(name().size() > nam.size())",
          "175:    else // name.size() < nam.size()",
          "178:       const std::string constr = name().front() == '.' ? name() : \".\" + name();",
          "179:       const std::string substr = nam.substr(nam.size() - constr.size(), constr.size());",
          "180:       return tolower_string(constr) == tolower_string(substr);",
          "187:    std::stringstream tt(name());",
          "188:    X509_DN nam_dn, my_dn;",
          "",
          "[Added Lines]",
          "166:    const std::string constraint = tolower_string(name());",
          "167:    const std::string issued = tolower_string(nam);",
          "169:    if(nam.size() == constraint.size())",
          "171:       return issued == constraint;",
          "173:    else if(constraint.size() > nam.size())",
          "178:    else",
          "180:       if(constraint.empty()) {",
          "181:          return true;",
          "182:       }",
          "184:       std::string substr = issued.substr(nam.size() - constraint.size(), constraint.size());",
          "186:       if(constraint.front() == '.') {",
          "187:          return substr == constraint;",
          "188:       } else if(substr[0] == '.') {",
          "189:          return substr.substr(1) == constraint;",
          "190:       } else {",
          "191:          return substr == constraint && issued[issued.size() - constraint.size() - 1] == '.';",
          "194: }",
          "199:    X509_DN nam_dn;",
          "201:    return matches_dn_obj(nam_dn);",
          "202:    }",
          "204: bool GeneralName::matches_dn_obj(const X509_DN& nam_dn) const",
          "205:    {",
          "206:    std::stringstream tt(name());",
          "207:    X509_DN my_dn;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "270:    os << gs.minimum() << \",\" << gs.maximum() << \",\" << gs.base();",
          "271:    return os;",
          "272:    }",
          "273: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "291: NameConstraints::NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,",
          "292:                                  std::vector<GeneralSubtree>&& excluded_subtrees) :",
          "293:    m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees)",
          "294:    {",
          "295:    for(const auto& c : m_permitted_subtrees)",
          "296:       {",
          "297:       m_permitted_name_types.insert(c.base().type());",
          "298:       }",
          "299:    for(const auto& c : m_excluded_subtrees)",
          "300:       {",
          "301:       m_excluded_name_types.insert(c.base().type());",
          "302:       }",
          "303:    }",
          "305: namespace {",
          "307: bool looks_like_ipv4(const std::string& s)",
          "308:    {",
          "309:    try",
          "310:      {",
          "312:      string_to_ipv4(s);",
          "313:      return true;",
          "314:      }",
          "315:    catch(...)",
          "316:       {",
          "317:       return false;",
          "318:       }",
          "319:    }",
          "321: }",
          "323: bool NameConstraints::is_permitted(const X509_Certificate& cert, bool reject_unknown) const {",
          "324:    if(permitted().empty()) {",
          "325:       return true;",
          "326:    }",
          "328:    const auto& alt_name = cert.subject_alt_name();",
          "330:    if(reject_unknown) {",
          "331:       if(m_permitted_name_types.find(\"URI\") != m_permitted_name_types.end() && !alt_name.get_attribute(\"URI\").empty()) {",
          "332:          return false;",
          "333:       }",
          "334:       if(m_permitted_name_types.find(\"RFC822\") != m_permitted_name_types.end() && !alt_name.get_attribute(\"RFC822\").empty()) {",
          "335:          return false;",
          "336:       }",
          "337:    }",
          "339:    auto is_permitted_dn = [&](const X509_DN& dn) {",
          "341:       if(m_permitted_name_types.find(\"DN\") == m_permitted_name_types.end()) {",
          "342:          return true;",
          "343:       }",
          "345:       if(dn.empty()) {",
          "346:          return true;",
          "347:       }",
          "349:       for(const auto& c : m_permitted_subtrees) {",
          "350:          if(c.base().type() == \"DN\" && c.base().matches_dn_obj(dn)) {",
          "351:             return true;",
          "352:          }",
          "353:       }",
          "356:       return false;",
          "357:    };",
          "359:    auto is_permitted_dns_name = [&](const std::string& name) {",
          "360:       if(name.empty() || name[0] == '.') {",
          "361:          return false;",
          "362:       }",
          "365:       if(m_permitted_name_types.find(\"DNS\") == m_permitted_name_types.end()) {",
          "366:          return true;",
          "367:       }",
          "369:       for(const auto& c : m_permitted_subtrees) {",
          "370:          if(c.base().type() == \"DNS\" && c.base().matches_dns(name)) {",
          "371:             return true;",
          "372:          }",
          "373:       }",
          "376:       return false;",
          "377:    };",
          "379:    auto is_permitted_ipv4 = [&](const std::string& ipv4) {",
          "381:       if(m_permitted_name_types.find(\"IP\") == m_permitted_name_types.end()) {",
          "382:          return true;",
          "383:       }",
          "385:       for(const auto& c : m_permitted_subtrees) {",
          "386:          if(c.base().type() == \"IP\" && c.base().matches_ip(ipv4)) {",
          "387:             return true;",
          "388:          }",
          "389:       }",
          "392:       return false;",
          "393:    };",
          "395:    if(!is_permitted_dn(cert.subject_dn())) {",
          "396:       return false;",
          "397:    }",
          "399:    if(!is_permitted_dn(alt_name.dn()))",
          "400:       {",
          "401:       return false;",
          "402:       }",
          "404:    for(const auto& alt_dns : alt_name.get_attribute(\"DNS\")) {",
          "405:       if(!is_permitted_dns_name(alt_dns)) {",
          "406:          return false;",
          "407:       }",
          "408:    }",
          "410:    for(const auto& alt_ipv4 : alt_name.get_attribute(\"IP\")) {",
          "411:       if(!is_permitted_ipv4(alt_ipv4)) {",
          "412:          return false;",
          "413:       }",
          "414:    }",
          "416:    if(!alt_name.has_items())",
          "417:       {",
          "418:       for(const auto& cn : cert.subject_info(\"Name\"))",
          "419:          {",
          "420:          if(cn.find(\".\") != std::string::npos)",
          "421:             {",
          "422:             if(looks_like_ipv4(cn))",
          "423:                {",
          "424:                if(!is_permitted_ipv4(cn))",
          "425:                   {",
          "426:                   return false;",
          "427:                   }",
          "428:                }",
          "429:             else",
          "430:                {",
          "431:                if(!is_permitted_dns_name(cn))",
          "432:                   {",
          "433:                   return false;",
          "434:                   }",
          "435:                }",
          "436:             }",
          "437:          }",
          "438:       }",
          "441:    return true;",
          "444: bool NameConstraints::is_excluded(const X509_Certificate& cert, bool reject_unknown) const {",
          "445:    if(excluded().empty()) {",
          "446:       return false;",
          "447:    }",
          "449:    const auto& alt_name = cert.subject_alt_name();",
          "451:    if(reject_unknown) {",
          "452:       if(m_excluded_name_types.find(\"URI\") != m_excluded_name_types.end() && !alt_name.get_attribute(\"URI\").empty()) {",
          "453:          return false;",
          "454:       }",
          "455:       if(m_excluded_name_types.find(\"RFC822\") != m_excluded_name_types.end() && !alt_name.get_attribute(\"RFC822\").empty()) {",
          "456:          return false;",
          "457:       }",
          "458:    }",
          "460:    auto is_excluded_dn = [&](const X509_DN& dn) {",
          "462:       if(m_excluded_name_types.find(\"DN\") == m_excluded_name_types.end()) {",
          "463:          return false;",
          "464:       }",
          "466:       if(dn.empty()) {",
          "467:          return false;",
          "468:       }",
          "470:       for(const auto& c : m_excluded_subtrees) {",
          "471:          if(c.base().type() == \"DN\" && c.base().matches_dn_obj(dn)) {",
          "472:             return true;",
          "473:          }",
          "474:       }",
          "477:       return false;",
          "478:    };",
          "480:    auto is_excluded_dns_name = [&](const std::string& name) {",
          "481:       if(name.empty() || name[0] == '.') {",
          "482:          return true;",
          "483:       }",
          "486:       if(m_excluded_name_types.find(\"DNS\") == m_excluded_name_types.end()) {",
          "487:          return false;",
          "488:       }",
          "490:       for(const auto& c : m_excluded_subtrees) {",
          "491:          if(c.base().type() == \"DNS\" && c.base().matches_dns(name)) {",
          "492:             return true;",
          "493:          }",
          "494:       }",
          "497:       return false;",
          "498:    };",
          "500:    auto is_excluded_ipv4 = [&](const std::string& ipv4) {",
          "502:       if(m_excluded_name_types.find(\"IP\") == m_excluded_name_types.end()) {",
          "503:          return false;",
          "504:       }",
          "506:       for(const auto& c : m_excluded_subtrees) {",
          "507:          if(c.base().type() == \"IP\" && c.base().matches_ip(ipv4)) {",
          "508:             return true;",
          "509:          }",
          "510:       }",
          "513:       return false;",
          "514:    };",
          "516:    if(is_excluded_dn(cert.subject_dn())) {",
          "517:       return true;",
          "518:    }",
          "520:    if(is_excluded_dn(alt_name.dn())) {",
          "521:       return true;",
          "522:    }",
          "524:    for(const auto& alt_dns : alt_name.get_attribute(\"DNS\")) {",
          "525:       if(is_excluded_dns_name(alt_dns)) {",
          "526:          return true;",
          "527:       }",
          "528:    }",
          "530:    for(const auto& alt_ipv4 : alt_name.get_attribute(\"IP\")) {",
          "531:       if(is_excluded_ipv4(alt_ipv4)) {",
          "532:          return true;",
          "533:       }",
          "534:    }",
          "536:    if(!alt_name.has_items())",
          "537:       {",
          "538:       for(const auto& cn : cert.subject_info(\"Name\"))",
          "539:          {",
          "540:          if(cn.find(\".\") != std::string::npos)",
          "541:             {",
          "542:             if(looks_like_ipv4(cn))",
          "543:                {",
          "544:                if(is_excluded_ipv4(cn))",
          "545:                   {",
          "546:                   return true;",
          "547:                   }",
          "548:                }",
          "549:             else",
          "550:                {",
          "551:                if(is_excluded_dns_name(cn))",
          "552:                   {",
          "553:                   return true;",
          "554:                   }",
          "555:                }",
          "556:             }",
          "557:          }",
          "558:       }",
          "561:    return false;",
          "562: }",
          "564: }  // namespace Botan",
          "",
          "---------------"
        ],
        "src/lib/x509/pkix_types.h||src/lib/x509/pkix_types.h": [
          "File: src/lib/x509/pkix_types.h -> src/lib/x509/pkix_types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "216:       GeneralName(const std::string& str);",
          "218:       void encode_into(DER_Encoder&) const override;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "219:       BOTAN_DEPRECATED(\"Deprecated no replacement\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "237:       MatchResult matches(const X509_Certificate& cert) const;",
          "243:       bool matches_dns(const std::string&) const;",
          "244:       bool matches_dn(const std::string&) const;",
          "245:       bool matches_ip(const std::string&) const;",
          "246:    };",
          "248: std::ostream& operator<<(std::ostream& os, const GeneralName& gn);",
          "",
          "[Removed Lines]",
          "239:    private:",
          "240:       std::string m_type;",
          "241:       std::string m_name;",
          "",
          "[Added Lines]",
          "241:       BOTAN_DEPRECATED(\"Deprecated no replacement\")",
          "246:       bool matches_dn_obj(const X509_DN& dn) const;",
          "249:    private:",
          "250:       std::string m_type;",
          "251:       std::string m_name;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "263:       GeneralSubtree() : m_base(), m_minimum(0), m_maximum(std::numeric_limits<std::size_t>::max())",
          "264:       {}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "272:       BOTAN_DEPRECATED(\"Deprecated no replacement\")",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "272:       GeneralSubtree(const GeneralName& base, size_t min, size_t max)",
          "273:       : m_base(base), m_minimum(min), m_maximum(max)",
          "274:       {}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "282:       BOTAN_DEPRECATED(\"Deprecated no replacement\")",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "280:       GeneralSubtree(const std::string& str);",
          "282:       void encode_into(DER_Encoder&) const override;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "291:       BOTAN_DEPRECATED(\"Deprecated no replacement\")",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "327:       NameConstraints(std::vector<GeneralSubtree>&& permitted_subtrees,",
          "",
          "[Removed Lines]",
          "328:                     std::vector<GeneralSubtree>&& excluded_subtrees)",
          "329:       : m_permitted_subtrees(permitted_subtrees), m_excluded_subtrees(excluded_subtrees)",
          "330:       {}",
          "",
          "[Added Lines]",
          "340:                       std::vector<GeneralSubtree>&& excluded_subtrees);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "340:       const std::vector<GeneralSubtree>& excluded() const { return m_excluded_subtrees; }",
          "342:    private:",
          "343:       std::vector<GeneralSubtree> m_permitted_subtrees;",
          "344:       std::vector<GeneralSubtree> m_excluded_subtrees;",
          "345:    };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "355:       bool is_permitted(const X509_Certificate& cert, bool reject_unknown) const;",
          "360:       bool is_excluded(const X509_Certificate& cert, bool reject_unknown) const;",
          "366:       std::set<std::string> m_permitted_name_types;",
          "367:       std::set<std::string> m_excluded_name_types;",
          "",
          "---------------"
        ],
        "src/lib/x509/x509_ext.cpp||src/lib/x509/x509_ext.cpp": [
          "File: src/lib/x509/x509_ext.cpp -> src/lib/x509/x509_ext.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "602:    {",
          "603:    std::vector<GeneralSubtree> permit, exclude;",
          "604:    BER_Decoder ber(in);",
          "609:    if(per.is_a(0, ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC)))",
          "610:       {",
          "612:       if(permit.empty())",
          "613:          throw Encoding_Error(\"Empty Name Contraint list\");",
          "614:       }",
          "619:       {",
          "621:       if(exclude.empty())",
          "622:          throw Encoding_Error(\"Empty Name Contraint list\");",
          "623:       }",
          "627:    if(permit.empty() && exclude.empty())",
          "628:       throw Encoding_Error(\"Empty Name Contraint extension\");",
          "",
          "[Removed Lines]",
          "605:    BER_Decoder ext = ber.start_cons(SEQUENCE);",
          "606:    BER_Object per = ext.get_next_object();",
          "608:    ext.push_back(per);",
          "611:       ext.decode_list(permit,ASN1_Tag(0),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));",
          "616:    BER_Object exc = ext.get_next_object();",
          "617:    ext.push_back(exc);",
          "618:    if(per.is_a(1, ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC)))",
          "620:       ext.decode_list(exclude,ASN1_Tag(1),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));",
          "625:    ext.end_cons();",
          "",
          "[Added Lines]",
          "605:    BER_Decoder inner = ber.start_cons(SEQUENCE);",
          "606:    BER_Object per = inner.get_next_object();",
          "608:    inner.push_back(per);",
          "611:       inner.decode_list(permit,ASN1_Tag(0),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));",
          "616:    BER_Object exc = inner.get_next_object();",
          "617:    inner.push_back(exc);",
          "618:    if(exc.is_a(1, ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC)))",
          "620:       inner.decode_list(exclude,ASN1_Tag(1),ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC));",
          "625:    inner.end_cons();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "651:       }",
          "652:    }",
          "655:       const std::vector<std::shared_ptr<const X509_Certificate>>& cert_path,",
          "656:       std::vector<std::set<Certificate_Status_Code>>& cert_status,",
          "657:       size_t pos)",
          "658:    {",
          "659:    if(!m_name_constraints.permitted().empty() || !m_name_constraints.excluded().empty())",
          "660:       {",
          "661:       if(!subject.is_CA_cert())",
          "",
          "[Removed Lines]",
          "654: void Name_Constraints::validate(const X509_Certificate& subject, const X509_Certificate& issuer,",
          "",
          "[Added Lines]",
          "654: void Name_Constraints::validate(const X509_Certificate& subject, const X509_Certificate& /*issuer*/,",
          "662:    const size_t MAX_NC_COMPARES = (1 << 12);",
          "663:    const size_t total_constraints = m_name_constraints.permitted().size() + m_name_constraints.excluded().size();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "664:          }",
          "666:       const bool issuer_name_constraint_critical =",
          "670:       for(size_t j = 0; j < pos; ++j)",
          "671:          {",
          "710:             cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);",
          "712:          }",
          "713:       }",
          "714:    }",
          "716: namespace {",
          "",
          "[Removed Lines]",
          "667:          issuer.is_critical(\"X509v3.NameConstraints\");",
          "672:          bool permitted = m_name_constraints.permitted().empty();",
          "673:          bool failed = false;",
          "675:          for(auto c: m_name_constraints.permitted())",
          "676:             {",
          "677:             switch(c.base().matches(*cert_path.at(j)))",
          "678:                {",
          "679:                case GeneralName::MatchResult::NotFound:",
          "680:                case GeneralName::MatchResult::All:",
          "681:                   permitted = true;",
          "682:                   break;",
          "683:                case GeneralName::MatchResult::UnknownType:",
          "684:                   failed = issuer_name_constraint_critical;",
          "685:                   permitted = true;",
          "686:                   break;",
          "687:                default:",
          "688:                   break;",
          "689:                }",
          "690:             }",
          "692:          for(auto c: m_name_constraints.excluded())",
          "693:             {",
          "694:             switch(c.base().matches(*cert_path.at(j)))",
          "695:                {",
          "696:                case GeneralName::MatchResult::All:",
          "697:                case GeneralName::MatchResult::Some:",
          "698:                   failed = true;",
          "699:                   break;",
          "700:                case GeneralName::MatchResult::UnknownType:",
          "701:                   failed = issuer_name_constraint_critical;",
          "702:                   break;",
          "703:                default:",
          "704:                   break;",
          "705:                }",
          "706:             }",
          "708:          if(failed || !permitted)",
          "709:             {",
          "711:             }",
          "",
          "[Added Lines]",
          "673:          subject.is_critical(\"X509v3.NameConstraints\");",
          "678:          const auto& cert = cert_path.at(j);",
          "680:          const size_t total_names =",
          "681:             cert->subject_dn().dn_info().size() +",
          "682:             cert->subject_alt_name().get_attributes().size();",
          "684:          if(total_names * total_constraints >= MAX_NC_COMPARES) {",
          "685:             cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);",
          "686:             continue;",
          "687:          }",
          "689:          if(!m_name_constraints.is_permitted(*cert, issuer_name_constraint_critical)) {",
          "690:             cert_status.at(j).insert(Certificate_Status_Code::NAME_CONSTRAINT_ERROR);",
          "691:             continue;",
          "692:          }",
          "694:          if(m_name_constraints.is_excluded(*cert, issuer_name_constraint_critical)) {",
          "696:             continue;",
          "700: }",
          "",
          "---------------"
        ],
        "src/lib/x509/x509cert.cpp||src/lib/x509/x509cert.cpp": [
          "File: src/lib/x509/x509cert.cpp -> src/lib/x509/x509cert.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #include <botan/oids.h>",
          "18: #include <botan/hash.h>",
          "19: #include <botan/hex.h>",
          "20: #include <algorithm>",
          "21: #include <sstream>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include <botan/internal/stl_util.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "788:    if(name.empty())",
          "789:       return false;",
          "795:       issued_names = subject_info(\"Name\");",
          "797:    for(size_t i = 0; i != issued_names.size(); ++i)",
          "798:       {",
          "801:       }",
          "803:    return false;",
          "",
          "[Removed Lines]",
          "791:    std::vector<std::string> issued_names = subject_info(\"DNS\");",
          "794:    if(issued_names.empty())",
          "799:       if(host_wildcard_match(issued_names[i], name))",
          "800:          return true;",
          "",
          "[Added Lines]",
          "792:    bool is_ipv4 = false;",
          "794:    try {",
          "795:       string_to_ipv4(name);",
          "796:       is_ipv4 = true;",
          "797:       }",
          "798:    catch(...) {}",
          "800:    std::vector<std::string> issued_names;",
          "802:    if(subject_alt_name().has_items()) {",
          "803:       issued_names = subject_alt_name().get_attribute(is_ipv4 ? \"IP\" : \"DNS\");",
          "804:    } else if(is_ipv4 == false) {",
          "807:    }",
          "811:       if(is_ipv4)",
          "812:          {",
          "813:          if(issued_names[i] == name)",
          "814:             return true;",
          "815:          }",
          "816:       else",
          "817:          {",
          "818:          if(host_wildcard_match(issued_names[i], name))",
          "819:             return true;",
          "820:          }",
          "",
          "---------------"
        ],
        "src/python/botan2.py||src/python/botan2.py": [
          "File: src/python/botan2.py -> src/python/botan2.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1285: #",
          "1286: class X509Cert(object): # pylint: disable=invalid-name",
          "1287:     def __init__(self, filename=None, buf=None):",
          "1288:         self.__obj = _load_buf_or_file(filename, buf, _DLL.botan_x509_cert_load_file, _DLL.botan_x509_cert_load)",
          "1290:     def __del__(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1288:         self.__obj = c_void_p(0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1464: #",
          "1465: class X509CRL(object):",
          "1466:     def __init__(self, filename=None, buf=None):",
          "1467:         self.__obj = _load_buf_or_file(filename, buf, _DLL.botan_x509_crl_load_file, _DLL.botan_x509_crl_load)",
          "1469:     def __del__(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1468:         self.__obj = c_void_p(0)",
          "",
          "---------------"
        ],
        "src/scripts/test_python.py||src/scripts/test_python.py": [
          "File: src/scripts/test_python.py -> src/scripts/test_python.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "474:         self.assertEqual(cert.issuer_dn('Organizational Unit', 0), 'bsi')",
          "475:         self.assertEqual(cert.issuer_dn('Country', 0), 'DE')",
          "480:         self.assertEqual(cert.not_before(), 1184858838)",
          "481:         self.assertEqual(cert.not_after(), 1831907880)",
          "",
          "[Removed Lines]",
          "477:         self.assertTrue(cert.hostname_match('csca-germany'))",
          "478:         self.assertFalse(cert.hostname_match('csca-slovakia'))",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/tests/test_name_constraint.cpp||src/tests/test_name_constraint.cpp": [
          "File: src/tests/test_name_constraint.cpp -> src/tests/test_name_constraint.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:             std::make_tuple(",
          "30:                \"Root_Email_Name_Constraint.crt\",",
          "31:                \"Invalid_Email_Name_Constraint.crt\",",
          "33:                \"Certificate does not pass name constraint\"),",
          "34:             std::make_tuple(",
          "35:                \"Root_DN_Name_Constraint.crt\",",
          "36:                \"Invalid_DN_Name_Constraint.crt\",",
          "38:                \"Certificate does not pass name constraint\"),",
          "39:             std::make_tuple(",
          "40:                \"Root_DN_Name_Constraint.crt\",",
          "41:                \"Valid_DN_Name_Constraint.crt\",",
          "43:                \"Verified\"),",
          "44:             std::make_tuple(",
          "45:                \"Root_DNS_Name_Constraint.crt\",",
          "",
          "[Removed Lines]",
          "32:                \"Invalid Email Name Constraint\",",
          "37:                \"Invalid DN Name Constraint\",",
          "42:                \"Valid DN Name Constraint\",",
          "",
          "[Added Lines]",
          "32:                \"\",",
          "37:                \"\",",
          "42:                \"\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "49:             std::make_tuple(",
          "50:                \"Root_IP_Name_Constraint.crt\",",
          "51:                \"Valid_IP_Name_Constraint.crt\",",
          "53:                \"Verified\"),",
          "54:             std::make_tuple(",
          "55:                \"Root_IP_Name_Constraint.crt\",",
          "56:                \"Invalid_IP_Name_Constraint.crt\",",
          "58:                \"Certificate does not pass name constraint\"),",
          "59:             };",
          "60:          std::vector<Test::Result> results;",
          "",
          "[Removed Lines]",
          "52:                \"Valid IP Name Constraint\",",
          "57:                \"Invalid IP Name Constraint\",",
          "",
          "[Added Lines]",
          "52:                \"\",",
          "57:                \"\",",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-25155",
  "cve_desc": "Redis is an in-memory database that persists on disk. Authenticated users issuing specially crafted `SRANDMEMBER`, `ZRANDMEMBER`, and `HRANDFIELD` commands can trigger an integer overflow, resulting in a runtime assertion and termination of the Redis server process. This problem affects all Redis versions. Patches were released in Redis version(s) 6.0.18, 6.2.11 and 7.0.9.",
  "repo": "redis/redis",
  "patch_hash": "2a2a582e7cd99ba3b531336b8bd41df2b566e619",
  "patch_info": {
    "commit_hash": "2a2a582e7cd99ba3b531336b8bd41df2b566e619",
    "repo": "redis/redis",
    "commit_url": "https://github.com/redis/redis/commit/2a2a582e7cd99ba3b531336b8bd41df2b566e619",
    "files": [
      "src/t_hash.c",
      "src/t_set.c",
      "src/t_zset.c",
      "tests/unit/type/hash.tcl",
      "tests/unit/type/set.tcl",
      "tests/unit/type/zset.tcl"
    ],
    "message": "Integer Overflow in RAND commands can lead to assertion (CVE-2023-25155)\n\nIssue happens when passing a negative long value that greater than\nthe max positive value that the long can store.",
    "before_after_code_files": [
      "src/t_hash.c||src/t_hash.c",
      "src/t_set.c||src/t_set.c",
      "src/t_zset.c||src/t_zset.c",
      "tests/unit/type/hash.tcl||tests/unit/type/hash.tcl",
      "tests/unit/type/set.tcl||tests/unit/type/set.tcl",
      "tests/unit/type/zset.tcl||tests/unit/type/zset.tcl"
    ]
  },
  "patch_diff": {
    "src/t_hash.c||src/t_hash.c": [
      "File: src/t_hash.c -> src/t_hash.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1120:     listpackEntry ele;",
      "1122:     if (c->argc >= 3) {",
      "1124:         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {",
      "1125:             addReplyErrorObject(c,shared.syntaxerr);",
      "1126:             return;",
      "1127:         } else if (c->argc == 4) {",
      "1128:             withvalues = 1;",
      "1130:                 addReplyError(c,\"value is out of range\");",
      "1131:                 return;",
      "1132:             }",
      "",
      "[Removed Lines]",
      "1123:         if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;",
      "1129:             if (l < LONG_MIN/2 || l > LONG_MAX/2) {",
      "",
      "[Added Lines]",
      "1123:         if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;",
      "1129:             if (l < -LONG_MAX/2 || l > LONG_MAX/2) {",
      "",
      "---------------"
    ],
    "src/t_set.c||src/t_set.c": [
      "File: src/t_set.c -> src/t_set.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "666:     dict *d;",
      "669:     if (l >= 0) {",
      "670:         count = (unsigned long) l;",
      "671:     } else {",
      "",
      "[Removed Lines]",
      "668:     if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;",
      "",
      "[Added Lines]",
      "668:     if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;",
      "",
      "---------------"
    ],
    "src/t_zset.c||src/t_zset.c": [
      "File: src/t_zset.c -> src/t_zset.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4289:     listpackEntry ele;",
      "4291:     if (c->argc >= 3) {",
      "4293:         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withscores\"))) {",
      "4294:             addReplyErrorObject(c,shared.syntaxerr);",
      "4295:             return;",
      "4296:         } else if (c->argc == 4) {",
      "4297:             withscores = 1;",
      "4299:                 addReplyError(c,\"value is out of range\");",
      "4300:                 return;",
      "4301:             }",
      "",
      "[Removed Lines]",
      "4292:         if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;",
      "4298:             if (l < LONG_MIN/2 || l > LONG_MAX/2) {",
      "",
      "[Added Lines]",
      "4292:         if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;",
      "4298:             if (l < -LONG_MAX/2 || l > LONG_MAX/2) {",
      "",
      "---------------"
    ],
    "tests/unit/type/hash.tcl||tests/unit/type/hash.tcl": [
      "File: tests/unit/type/hash.tcl -> tests/unit/type/hash.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "74:     test \"HRANDFIELD count overflow\" {",
      "75:         r hmset myhash a 1",
      "76:         assert_error {*value is out of range*} {r hrandfield myhash -9223372036854770000 withvalues}",
      "77:     } {}",
      "79:     test \"HRANDFIELD with <count> against non existing key\" {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "77:         assert_error {*value is out of range*} {r hrandfield myhash -9223372036854775808 withvalues}",
      "78:         assert_error {*value is out of range*} {r hrandfield myhash -9223372036854775808}",
      "",
      "---------------"
    ],
    "tests/unit/type/set.tcl||tests/unit/type/set.tcl": [
      "File: tests/unit/type/set.tcl -> tests/unit/type/set.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "645:         r srandmember nonexisting_key 100",
      "646:     } {}",
      "648:     # Make sure we can distinguish between an empty array and a null response",
      "649:     r readraw 1",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "648:     test \"SRANDMEMBER count overflow\" {",
      "649:         r sadd myset a",
      "650:         assert_error {*value is out of range*} {r srandmember myset -9223372036854775808}",
      "651:     } {}",
      "",
      "---------------"
    ],
    "tests/unit/type/zset.tcl||tests/unit/type/zset.tcl": [
      "File: tests/unit/type/zset.tcl -> tests/unit/type/zset.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "2303:     test \"ZRANDMEMBER count overflow\" {",
      "2304:         r zadd myzset 0 a",
      "2305:         assert_error {*value is out of range*} {r zrandmember myzset -9223372036854770000 withscores}",
      "2306:     } {}",
      "2308:     # Make sure we can distinguish between an empty array and a null response",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2306:         assert_error {*value is out of range*} {r zrandmember myzset -9223372036854775808 withscores}",
      "2307:         assert_error {*value is out of range*} {r zrandmember myzset -9223372036854775808}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5aaa1a271c8b33b57a71d98958ccdbc2415bd72c",
      "candidate_info": {
        "commit_hash": "5aaa1a271c8b33b57a71d98958ccdbc2415bd72c",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/5aaa1a271c8b33b57a71d98958ccdbc2415bd72c",
        "files": [
          "src/commands.c",
          "src/commands/client-list.json"
        ],
        "message": "Document some fields history of CLIENT LIST command (#11729)\n\nChange history:\n- `user` added in 6.0.0, 0f42447a0ec841f0b3e83328ac16a573012e2880\n- `argv-mem` and `tot-mem` added in 6.2.0, bea40e6a41e31a52e9e6efee77ea5a4bd873b759\n- `redir` added in 6.2.0, dd1f20edc5ecda7848c31601782c5e9d7bce4788\n- `resp` added in 7.0.0, 7c376398b1cd827282e17804e230c41cbb48a89c\n- `multi-mem` added in 7.0.0, 2753429c99425e3d0216cba79e0e61192975f252\n- `rbs` and `rbp` added in 7.0.0, 47c51d0c7858dc8ce7747b78b73cf8cec2e59ff3\n- `ssub` added in 7.0.3, 35c2ee8716dc9b1d4edbbb409815a585af491335\n\n(cherry picked from commit e7f35edb13f73090cc3e2347cdcfe41043e1a1a1)",
        "before_after_code_files": [
          "src/commands.c||src/commands.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/11848"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/commands.c||src/commands.c": [
          "File: src/commands.c -> src/commands.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "812: commandHistory CLIENT_LIST_History[] = {",
          "813: {\"2.8.12\",\"Added unique client `id` field.\"},",
          "814: {\"5.0.0\",\"Added optional `TYPE` filter.\"},",
          "816: {0}",
          "817: };",
          "",
          "[Removed Lines]",
          "815: {\"6.2.0\",\"Added `laddr` field and the optional `ID` filter.\"},",
          "",
          "[Added Lines]",
          "815: {\"6.0.0\",\"Added `user` field.\"},",
          "816: {\"6.2.0\",\"Added `argv-mem`, `tot-mem`, `laddr` and `redir` fields and the optional `ID` filter.\"},",
          "817: {\"7.0.0\",\"Added `resp`, `multi-mem`, `rbs` and `rbp` fields.\"},",
          "818: {\"7.0.3\",\"Added `ssub` field.\"},",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "af80a4a5548709ed8314aa549306ee0f353102bd",
      "candidate_info": {
        "commit_hash": "af80a4a5548709ed8314aa549306ee0f353102bd",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/af80a4a5548709ed8314aa549306ee0f353102bd",
        "files": [
          "src/cluster.c",
          "src/module.c",
          "src/object.c",
          "src/sds.c",
          "src/sds.h",
          "src/server.c",
          "tests/unit/type/string.tcl"
        ],
        "message": "Optimization: sdsRemoveFreeSpace to avoid realloc on noop (#11766)\n\nIn #7875 (Redis 6.2), we changed the sds alloc to be the usable allocation\nsize in order to:\n\n> reduce the need for realloc calls by making the sds implicitly take over\nthe internal fragmentation\n\nThis change was done most sds functions, excluding `sdsRemoveFreeSpace` and\n`sdsResize`, the reason is that in some places (e.g. clientsCronResizeQueryBuffer)\nwe call sdsRemoveFreeSpace when we see excessive free space and want to trim it.\nso if we don't trim it exactly to size, the caller may still see excessive free space and\ncall it again and again.\n\nHowever, this resulted in some excessive calls to realloc, even when there's no need\nand it's gonna be a no-op (e.g. when reducing 15 bytes allocation to 13).\n\nIt turns out that a call for realloc with jemalloc can be expensive even if it ends up\ndoing nothing, so this PR adds a check using `je_nallocx`, which is cheap to avoid\nthe call for realloc.\n\nin addition to that this PR unifies sdsResize and sdsRemoveFreeSpace into common\ncode. the difference between them was that sdsResize would avoid using SDS_TYPE_5,\nsince it want to keep the string ready to be resized again, while sdsRemoveFreeSpace\nwould permit using SDS_TYPE_5 and get an optimal memory consumption.\nnow both methods take a `would_regrow` argument that makes it more explicit.\n\nthe only actual impact of that is that in clientsCronResizeQueryBuffer we call both sdsResize\nand sdsRemoveFreeSpace for in different cases, and we now prevent the use of SDS_TYPE_5 in both.\n\nThe new test that was added to cover this concern used to pass before this PR as well,\nthis PR is just a performance optimization and cleanup.\n\nBenchmark:\n`redis-benchmark -c 100 -t set  -d 512 -P 10  -n  100000000`\non i7-9850H with jemalloc, shows improvement from 1021k ops/sec to 1067k (average of 3 runs).\nsome 4.5% improvement.\n\nCo-authored-by: Oran Agra <oran@redislabs.com>\n(cherry picked from commit 46393f9819ae29ddb86cb9819d0b055a923037b4)",
        "before_after_code_files": [
          "src/cluster.c||src/cluster.c",
          "src/module.c||src/module.c",
          "src/object.c||src/object.c",
          "src/sds.c||src/sds.c",
          "src/sds.h||src/sds.h",
          "src/server.c||src/server.c",
          "tests/unit/type/string.tcl||tests/unit/type/string.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/11848"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/cluster.c||src/cluster.c": [
          "File: src/cluster.c -> src/cluster.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3954:     if (link != NULL && sdsavail(link->sndbuf) / 4 > sdslen(link->sndbuf)) {",
          "3956:     }",
          "3957: }",
          "",
          "[Removed Lines]",
          "3955:         link->sndbuf = sdsRemoveFreeSpace(link->sndbuf);",
          "",
          "[Added Lines]",
          "3955:         link->sndbuf = sdsRemoveFreeSpace(link->sndbuf, 1);",
          "",
          "---------------"
        ],
        "src/module.c||src/module.c": [
          "File: src/module.c -> src/module.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4018:             sdssubstr(key->value->ptr,0,newlen);",
          "4020:             if (sdslen(key->value->ptr) < sdsavail(key->value->ptr))",
          "4022:         }",
          "4023:     }",
          "4024:     return REDISMODULE_OK;",
          "",
          "[Removed Lines]",
          "4021:                 key->value->ptr = sdsRemoveFreeSpace(key->value->ptr);",
          "",
          "[Added Lines]",
          "4021:                 key->value->ptr = sdsRemoveFreeSpace(key->value->ptr, 0);",
          "",
          "---------------"
        ],
        "src/object.c||src/object.c": [
          "File: src/object.c -> src/object.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "595:     if (o->encoding == OBJ_ENCODING_RAW &&",
          "596:         sdsavail(o->ptr) > sdslen(o->ptr)/10)",
          "597:     {",
          "599:     }",
          "600: }",
          "",
          "[Removed Lines]",
          "598:         o->ptr = sdsRemoveFreeSpace(o->ptr);",
          "",
          "[Added Lines]",
          "598:         o->ptr = sdsRemoveFreeSpace(o->ptr, 0);",
          "",
          "---------------"
        ],
        "src/sds.c||src/sds.c": [
          "File: src/sds.c -> src/sds.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "344: }",
          "349:     void *sh, *newsh;",
          "350:     char type, oldtype = s[-1] & SDS_TYPE_MASK;",
          "351:     int hdrlen, oldhdrlen = sdsHdrSize(oldtype);",
          "",
          "[Removed Lines]",
          "309: sds sdsRemoveFreeSpace(sds s) {",
          "310:     void *sh, *newsh;",
          "311:     char type, oldtype = s[-1] & SDS_TYPE_MASK;",
          "312:     int hdrlen, oldhdrlen = sdsHdrSize(oldtype);",
          "313:     size_t len = sdslen(s);",
          "314:     size_t avail = sdsavail(s);",
          "315:     sh = (char*)s-oldhdrlen;",
          "318:     if (avail == 0) return s;",
          "322:     type = sdsReqType(len);",
          "323:     hdrlen = sdsHdrSize(type);",
          "329:     if (oldtype==type || type > SDS_TYPE_8) {",
          "330:         newsh = s_realloc(sh, oldhdrlen+len+1);",
          "331:         if (newsh == NULL) return NULL;",
          "332:         s = (char*)newsh+oldhdrlen;",
          "333:     } else {",
          "334:         newsh = s_malloc(hdrlen+len+1);",
          "335:         if (newsh == NULL) return NULL;",
          "336:         memcpy((char*)newsh+hdrlen, s, len+1);",
          "337:         s_free(sh);",
          "338:         s = (char*)newsh+hdrlen;",
          "339:         s[-1] = type;",
          "340:         sdssetlen(s, len);",
          "341:     }",
          "342:     sdssetalloc(s, len);",
          "343:     return s;",
          "348: sds sdsResize(sds s, size_t size) {",
          "",
          "[Added Lines]",
          "309: sds sdsRemoveFreeSpace(sds s, int would_regrow) {",
          "310:     return sdsResize(s, sdslen(s), would_regrow);",
          "322: sds sdsResize(sds s, size_t size, int would_regrow) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "363:     type = sdsReqType(size);",
          "366:     hdrlen = sdsHdrSize(type);",
          "",
          "[Removed Lines]",
          "365:     if (type == SDS_TYPE_5) type = SDS_TYPE_8;",
          "",
          "[Added Lines]",
          "338:     if (would_regrow) {",
          "340:         if (type == SDS_TYPE_5) type = SDS_TYPE_8;",
          "341:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "375:         if (newsh == NULL) return NULL;",
          "376:         s = (char*)newsh+oldhdrlen;",
          "379:         if (newsh == NULL) return NULL;",
          "380:         memcpy((char*)newsh+hdrlen, s, len);",
          "381:         s_free(sh);",
          "",
          "[Removed Lines]",
          "373:     if (oldtype==type || (type < oldtype && type > SDS_TYPE_8)) {",
          "374:         newsh = s_realloc(sh, oldhdrlen+size+1);",
          "377:     } else {",
          "378:         newsh = s_malloc(hdrlen+size+1);",
          "",
          "[Added Lines]",
          "349:     int use_realloc = (oldtype==type || (type < oldtype && type > SDS_TYPE_8));",
          "350:     size_t newlen = use_realloc ? oldhdrlen+size+1 : hdrlen+size+1;",
          "351:     int alloc_already_optimal = 0;",
          "352:     #if defined(USE_JEMALLOC)",
          "357:         alloc_already_optimal = (je_nallocx(newlen, 0) == zmalloc_size(sh));",
          "358:     #endif",
          "360:     if (use_realloc && !alloc_already_optimal) {",
          "361:         newsh = s_realloc(sh, newlen);",
          "364:     } else if (!alloc_already_optimal) {",
          "365:         newsh = s_malloc(newlen);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1553:         x = sdsnew(\"1234567890123456789012345678901234567890\");",
          "1555:         test_cond(\"sdsrezie() expand len\", sdslen(x) == 40);",
          "1556:         test_cond(\"sdsrezie() expand strlen\", strlen(x) == 40);",
          "1557:         test_cond(\"sdsrezie() expand alloc\", sdsalloc(x) == 200);",
          "1560:         test_cond(\"sdsrezie() shrink len\", sdslen(x) == 40);",
          "1561:         test_cond(\"sdsrezie() shrink strlen\", strlen(x) == 40);",
          "1562:         test_cond(\"sdsrezie() shrink alloc\", sdsalloc(x) == 80);",
          "1565:         test_cond(\"sdsrezie() crop len\", sdslen(x) == 30);",
          "1566:         test_cond(\"sdsrezie() crop strlen\", strlen(x) == 30);",
          "1567:         test_cond(\"sdsrezie() crop alloc\", sdsalloc(x) == 30);",
          "1570:         test_cond(\"sdsrezie() expand len\", sdslen(x) == 30);",
          "1571:         test_cond(\"sdsrezie() expand strlen\", strlen(x) == 30);",
          "1572:         test_cond(\"sdsrezie() expand alloc\", sdsalloc(x) == 400);",
          "1575:         test_cond(\"sdsrezie() crop len\", sdslen(x) == 4);",
          "1576:         test_cond(\"sdsrezie() crop strlen\", strlen(x) == 4);",
          "1577:         test_cond(\"sdsrezie() crop alloc\", sdsalloc(x) == 4);",
          "",
          "[Removed Lines]",
          "1554:         x = sdsResize(x, 200);",
          "1559:         x = sdsResize(x, 80);",
          "1564:         x = sdsResize(x, 30);",
          "1569:         x = sdsResize(x, 400);",
          "1574:         x = sdsResize(x, 4);",
          "",
          "[Added Lines]",
          "1541:         x = sdsResize(x, 200, 1);",
          "1546:         x = sdsResize(x, 80, 1);",
          "1551:         x = sdsResize(x, 30, 1);",
          "1556:         x = sdsResize(x, 400, 1);",
          "1561:         x = sdsResize(x, 4, 1);",
          "",
          "---------------"
        ],
        "src/sds.h||src/sds.h": [
          "File: src/sds.h -> src/sds.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "267: sds sdsMakeRoomFor(sds s, size_t addlen);",
          "268: sds sdsMakeRoomForNonGreedy(sds s, size_t addlen);",
          "269: void sdsIncrLen(sds s, ssize_t incr);",
          "272: size_t sdsAllocSize(sds s);",
          "273: void *sdsAllocPtr(sds s);",
          "",
          "[Removed Lines]",
          "270: sds sdsRemoveFreeSpace(sds s);",
          "271: sds sdsResize(sds s, size_t size);",
          "",
          "[Added Lines]",
          "270: sds sdsRemoveFreeSpace(sds s, int would_regrow);",
          "271: sds sdsResize(sds s, size_t size, int would_regrow);",
          "",
          "---------------"
        ],
        "src/server.c||src/server.c": [
          "File: src/server.c -> src/server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "698:         if (idletime > 2) {",
          "701:         } else if (querybuf_size > PROTO_RESIZE_THRESHOLD && querybuf_size/2 > c->querybuf_peak) {",
          "",
          "[Removed Lines]",
          "700:             c->querybuf = sdsRemoveFreeSpace(c->querybuf);",
          "",
          "[Added Lines]",
          "700:             c->querybuf = sdsRemoveFreeSpace(c->querybuf, 1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "707:             size_t resize = sdslen(c->querybuf);",
          "708:             if (resize < c->querybuf_peak) resize = c->querybuf_peak;",
          "709:             if (c->bulklen != -1 && resize < (size_t)c->bulklen) resize = c->bulklen;",
          "711:         }",
          "712:     }",
          "",
          "[Removed Lines]",
          "710:             c->querybuf = sdsResize(c->querybuf, resize);",
          "",
          "[Added Lines]",
          "710:             c->querybuf = sdsResize(c->querybuf, resize, 1);",
          "",
          "---------------"
        ],
        "tests/unit/type/string.tcl||tests/unit/type/string.tcl": [
          "File: tests/unit/type/string.tcl -> tests/unit/type/string.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "459:             assert_equal [string range $bin $_start $_end] [r getrange bin $start $end]",
          "460:         }",
          "461:     }",
          "463:     test {Extended SET can detect syntax errors} {",
          "464:         set e {}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "463:     test {trim on SET with big value} {",
          "464:         # set a big value to trigger increasing the query buf",
          "465:         r set key [string repeat A 100000]",
          "466:         # set a smaller value but > PROTO_MBULK_BIG_ARG (32*1024) Redis will try to save the query buf itself on the DB.",
          "467:         r set key [string repeat A 33000]",
          "468:         # asset the value was trimmed",
          "469:         assert {[r memory usage key] < 42000}; # 42K to count for Jemalloc's additional memory overhead.",
          "470:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3a6f00329a34e38ef7b26c1e5888b59f89b19419",
      "candidate_info": {
        "commit_hash": "3a6f00329a34e38ef7b26c1e5888b59f89b19419",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/3a6f00329a34e38ef7b26c1e5888b59f89b19419",
        "files": [
          "src/expire.c"
        ],
        "message": "Call postExecutionUnitOperations in active-expire of writable replicas (#11615)\n\nWe need to honor the post-execution-unit API and call it after each KSN\n\nNote that this is an edge case that only happens in case volatile keys were\ncreated directly on a writable replica, and that anyway nothing is propagated to sub-replicas\n\nCo-authored-by: Oran Agra <oran@redislabs.com>\n(cherry picked from commit df327b8bd56023931cd41e233f8703de7bbaa82c)",
        "before_after_code_files": [
          "src/expire.c||src/expire.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/11848"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/expire.c||src/expire.c": [
          "File: src/expire.c -> src/expire.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "425:         if ((cycles % 64) == 0 && mstime()-start > 1) break;",
          "426:         if (dictSize(slaveKeysWithExpire) == 0) break;",
          "427:     }",
          "428: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "430:     propagatePendingCommands();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "feb796d3126fa73240d3db6b511efd31018a43fd",
      "candidate_info": {
        "commit_hash": "feb796d3126fa73240d3db6b511efd31018a43fd",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/feb796d3126fa73240d3db6b511efd31018a43fd",
        "files": [
          "src/expire.c",
          "tests/unit/expire.tcl"
        ],
        "message": "add test case and comments for active expiry in the writeable replica (#11789)\n\nThis test case is to cover a edge scenario: when a writable replica enabled AOF\nat the same time, active expiry keys which was created in writable replicas should\npropagate to the AOF file, and some versions might crash (fixed by #11615).\nFor details, please refer to #11778\n\n(cherry picked from commit 40659c342487fba6ef98444c7b9bb6cad9794f18)",
        "before_after_code_files": [
          "src/expire.c||src/expire.c",
          "tests/unit/expire.tcl||tests/unit/expire.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/11848"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/expire.c||src/expire.c": [
          "File: src/expire.c -> src/expire.c"
        ],
        "tests/unit/expire.tcl||tests/unit/expire.tcl": [
          "File: tests/unit/expire.tcl -> tests/unit/expire.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "571:                 assert_equal [$primary pexpiretime $key] [$replica pexpiretime $key]",
          "572:             }",
          "573:         }",
          "574:     }",
          "576:     test {SET command will remove expire} {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "575:         test {expired key which is created in writeable replicas should be deleted by active expiry} {",
          "576:             $primary flushall",
          "577:             $replica config set replica-read-only no",
          "578:             foreach {yes_or_no} {yes no} {",
          "579:                 $replica config set appendonly $yes_or_no",
          "580:                 waitForBgrewriteaof $replica",
          "581:                 set prev_expired [s expired_keys]",
          "582:                 $replica set foo bar PX 1",
          "583:                 wait_for_condition 100 10 {",
          "584:                     [s expired_keys] eq $prev_expired + 1",
          "585:                 } else {",
          "586:                     fail \"key not expired\"",
          "587:                 }",
          "588:                 assert_equal {} [$replica get foo]",
          "589:             }",
          "590:         }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0a8a45f94d96d0a1286d25438110521b132a55b0",
      "candidate_info": {
        "commit_hash": "0a8a45f94d96d0a1286d25438110521b132a55b0",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/0a8a45f94d96d0a1286d25438110521b132a55b0",
        "files": [
          "src/t_hash.c",
          "src/t_set.c",
          "src/t_zset.c",
          "tests/unit/type/hash.tcl",
          "tests/unit/type/set.tcl",
          "tests/unit/type/zset.tcl"
        ],
        "message": "Integer Overflow in RAND commands can lead to assertion (CVE-2023-25155)\n\nIssue happens when passing a negative long value that greater than\nthe max positive value that the long can store.\n\n(cherry picked from commit 41430af6a821c551abb862666ef896f2c196dea6)",
        "before_after_code_files": [
          "src/t_hash.c||src/t_hash.c",
          "src/t_set.c||src/t_set.c",
          "src/t_zset.c||src/t_zset.c",
          "tests/unit/type/hash.tcl||tests/unit/type/hash.tcl",
          "tests/unit/type/set.tcl||tests/unit/type/set.tcl",
          "tests/unit/type/zset.tcl||tests/unit/type/zset.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/t_hash.c||src/t_hash.c",
            "src/t_set.c||src/t_set.c",
            "src/t_zset.c||src/t_zset.c",
            "tests/unit/type/hash.tcl||tests/unit/type/hash.tcl",
            "tests/unit/type/set.tcl||tests/unit/type/set.tcl",
            "tests/unit/type/zset.tcl||tests/unit/type/zset.tcl"
          ],
          "candidate": [
            "src/t_hash.c||src/t_hash.c",
            "src/t_set.c||src/t_set.c",
            "src/t_zset.c||src/t_zset.c",
            "tests/unit/type/hash.tcl||tests/unit/type/hash.tcl",
            "tests/unit/type/set.tcl||tests/unit/type/set.tcl",
            "tests/unit/type/zset.tcl||tests/unit/type/zset.tcl"
          ]
        }
      },
      "candidate_diff": {
        "src/t_hash.c||src/t_hash.c": [
          "File: src/t_hash.c -> src/t_hash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1192:     ziplistEntry ele;",
          "1194:     if (c->argc >= 3) {",
          "1196:         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {",
          "1197:             addReplyErrorObject(c,shared.syntaxerr);",
          "1198:             return;",
          "1199:         } else if (c->argc == 4) {",
          "1200:             withvalues = 1;",
          "1202:                 addReplyError(c,\"value is out of range\");",
          "1203:                 return;",
          "1204:             }",
          "",
          "[Removed Lines]",
          "1195:         if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;",
          "1201:             if (l < LONG_MIN/2 || l > LONG_MAX/2) {",
          "",
          "[Added Lines]",
          "1195:         if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;",
          "1201:             if (l < -LONG_MAX/2 || l > LONG_MAX/2) {",
          "",
          "---------------"
        ],
        "src/t_set.c||src/t_set.c": [
          "File: src/t_set.c -> src/t_set.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "668:     dict *d;",
          "671:     if (l >= 0) {",
          "672:         count = (unsigned long) l;",
          "673:     } else {",
          "",
          "[Removed Lines]",
          "670:     if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;",
          "",
          "[Added Lines]",
          "670:     if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;",
          "",
          "---------------"
        ],
        "src/t_zset.c||src/t_zset.c": [
          "File: src/t_zset.c -> src/t_zset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4238:     ziplistEntry ele;",
          "4240:     if (c->argc >= 3) {",
          "4242:         if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withscores\"))) {",
          "4243:             addReplyErrorObject(c,shared.syntaxerr);",
          "4244:             return;",
          "4245:         } else if (c->argc == 4) {",
          "4246:             withscores = 1;",
          "4248:                 addReplyError(c,\"value is out of range\");",
          "4249:                 return;",
          "4250:             }",
          "",
          "[Removed Lines]",
          "4241:         if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;",
          "4247:             if (l < LONG_MIN/2 || l > LONG_MAX/2) {",
          "",
          "[Added Lines]",
          "4241:         if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;",
          "4247:             if (l < -LONG_MAX/2 || l > LONG_MAX/2) {",
          "",
          "---------------"
        ],
        "tests/unit/type/hash.tcl||tests/unit/type/hash.tcl": [
          "File: tests/unit/type/hash.tcl -> tests/unit/type/hash.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "71:     test \"HRANDFIELD count overflow\" {",
          "72:         r hmset myhash a 1",
          "73:         assert_error {*value is out of range*} {r hrandfield myhash -9223372036854770000 withvalues}",
          "74:     } {}",
          "76:     test \"HRANDFIELD with <count> against non existing key\" {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74:         assert_error {*value is out of range*} {r hrandfield myhash -9223372036854775808 withvalues}",
          "75:         assert_error {*value is out of range*} {r hrandfield myhash -9223372036854775808}",
          "",
          "---------------"
        ],
        "tests/unit/type/set.tcl||tests/unit/type/set.tcl": [
          "File: tests/unit/type/set.tcl -> tests/unit/type/set.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "588:         r srandmember nonexisting_key 100",
          "589:     } {}",
          "591:     # Make sure we can distinguish between an empty array and a null response",
          "592:     r readraw 1",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "591:     test \"SRANDMEMBER count overflow\" {",
          "592:         r sadd myset a",
          "593:         assert_error {*value is out of range*} {r srandmember myset -9223372036854775808}",
          "594:     } {}",
          "",
          "---------------"
        ],
        "tests/unit/type/zset.tcl||tests/unit/type/zset.tcl": [
          "File: tests/unit/type/zset.tcl -> tests/unit/type/zset.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "1738:     test \"ZRANDMEMBER count overflow\" {",
          "1739:         r zadd myzset 0 a",
          "1740:         assert_error {*value is out of range*} {r zrandmember myzset -9223372036854770000 withscores}",
          "1741:     } {}",
          "1743:     # Make sure we can distinguish between an empty array and a null response",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1741:         assert_error {*value is out of range*} {r zrandmember myzset -9223372036854775808 withscores}",
          "1742:         assert_error {*value is out of range*} {r zrandmember myzset -9223372036854775808}",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-7212",
  "cve_desc": "The _encode_invalid_chars function in util/url.py in the urllib3 library 1.25.2 through 1.25.7 for Python allows a denial of service (CPU consumption) because of an inefficient algorithm. The percent_encodings array contains all matches of percent encodings. It is not deduplicated. For a URL of length N, the size of percent_encodings may be up to O(N). The next step (normalize existing percent-encoded bytes) also takes up to O(N) for each step, so the total time is O(N^2). If percent_encodings were deduplicated, the time to compute _encode_invalid_chars would be O(kN), where k is at most 484 ((10+6*2)^2).",
  "repo": "urllib3/urllib3",
  "patch_hash": "a74c9cfbaed9f811e7563cfc3dce894928e0221a",
  "patch_info": {
    "commit_hash": "a74c9cfbaed9f811e7563cfc3dce894928e0221a",
    "repo": "urllib3/urllib3",
    "commit_url": "https://github.com/urllib3/urllib3/commit/a74c9cfbaed9f811e7563cfc3dce894928e0221a",
    "files": [
      "CHANGES.rst",
      "src/urllib3/util/url.py",
      "test/test_util.py"
    ],
    "message": "Percent-encode invalid characters with request target (#1586)",
    "before_after_code_files": [
      "src/urllib3/util/url.py||src/urllib3/util/url.py",
      "test/test_util.py||test/test_util.py"
    ]
  },
  "patch_diff": {
    "src/urllib3/util/url.py||src/urllib3/util/url.py": [
      "File: src/urllib3/util/url.py -> src/urllib3/util/url.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "6: from ..packages import six, rfc3986",
      "7: from ..packages.rfc3986.exceptions import RFC3986Exception, ValidationError",
      "8: from ..packages.rfc3986.validators import Validator",
      "11: url_attrs = ['scheme', 'auth', 'host', 'port', 'path', 'query', 'fragment']",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "9: from ..packages.rfc3986 import abnf_regexp, normalizers, compat, misc",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "17: # Regex for detecting URLs with schemes. RFC 3986 Section 3.1",
      "18: SCHEME_REGEX = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+\\-]*:|/)\")",
      "21: class Url(namedtuple('Url', url_attrs)):",
      "22:     \"\"\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "21: PATH_CHARS = abnf_regexp.UNRESERVED_CHARS_SET | abnf_regexp.SUB_DELIMITERS_SET | {':', '@', '/'}",
      "22: QUERY_CHARS = FRAGMENT_CHARS = PATH_CHARS | {'?'}",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "136:     return s[:min_idx], s[min_idx + 1:], min_delim",
      "139: def parse_url(url):",
      "140:     \"\"\"",
      "141:     Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "143: def _encode_invalid_chars(component, allowed_chars, encoding='utf-8'):",
      "144:     \"\"\"Percent-encodes a URI component without reapplying",
      "145:     onto an already percent-encoded component. Based on",
      "146:     rfc3986.normalizers.encode_component()",
      "147:     \"\"\"",
      "148:     if component is None:",
      "149:         return component",
      "151:     # Try to see if the component we're encoding is already percent-encoded",
      "152:     # so we can skip all '%' characters but still encode all others.",
      "153:     percent_encodings = len(normalizers.PERCENT_MATCHER.findall(",
      "154:                             compat.to_str(component, encoding)))",
      "156:     uri_bytes = component.encode('utf-8', 'surrogatepass')",
      "157:     is_percent_encoded = percent_encodings == uri_bytes.count(b'%')",
      "159:     encoded_component = bytearray()",
      "161:     for i in range(0, len(uri_bytes)):",
      "162:         # Will return a single character bytestring on both Python 2 & 3",
      "163:         byte = uri_bytes[i:i+1]",
      "164:         byte_ord = ord(byte)",
      "165:         if ((is_percent_encoded and byte == b'%')",
      "166:                 or (byte_ord < 128 and byte.decode() in allowed_chars)):",
      "167:             encoded_component.extend(byte)",
      "168:             continue",
      "169:         encoded_component.extend('%{0:02x}'.format(byte_ord).encode().upper())",
      "171:     return encoded_component.decode(encoding)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "160:         return Url()",
      "162:     is_string = not isinstance(url, six.binary_type)",
      "166:     # RFC 3986 doesn't like URLs that have a host but don't start",
      "167:     # with a scheme and we support URLs like that so we need to",
      "",
      "[Removed Lines]",
      "163:     if not is_string:",
      "164:         url = url.decode(\"utf-8\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "171:     if not SCHEME_REGEX.search(url):",
      "172:         url = \"//\" + url",
      "179:     def idna_encode(name):",
      "180:         if name and any([ord(x) > 128 for x in name]):",
      "181:             try:",
      "",
      "[Removed Lines]",
      "174:     try:",
      "175:         iri_ref = rfc3986.IRIReference.from_string(url, encoding=\"utf-8\")",
      "176:     except (ValueError, RFC3986Exception):",
      "177:         six.raise_from(LocationParseError(url), None)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "188:                 raise LocationParseError(u\"Name '%s' is not a valid IDNA label\" % name)",
      "189:         return name",
      "194:     # rfc3986 strips the authority if it's invalid",
      "195:     if has_authority and uri_ref.authority is None:",
      "",
      "[Removed Lines]",
      "191:     has_authority = iri_ref.authority is not None",
      "192:     uri_ref = iri_ref.encode(idna_encoder=idna_encode)",
      "",
      "[Added Lines]",
      "219:     try:",
      "220:         split_iri = misc.IRI_MATCHER.match(compat.to_str(url)).groupdict()",
      "221:         iri_ref = rfc3986.IRIReference(",
      "222:             split_iri['scheme'], split_iri['authority'],",
      "223:             _encode_invalid_chars(split_iri['path'], PATH_CHARS),",
      "224:             _encode_invalid_chars(split_iri['query'], QUERY_CHARS),",
      "225:             _encode_invalid_chars(split_iri['fragment'], FRAGMENT_CHARS)",
      "226:         )",
      "227:         has_authority = iri_ref.authority is not None",
      "228:         uri_ref = iri_ref.encode(idna_encoder=idna_encode)",
      "229:     except (ValueError, RFC3986Exception):",
      "230:         return six.raise_from(LocationParseError(url), None)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "210:         ).validate(uri_ref)",
      "211:     except ValidationError:",
      "214:     # For the sake of backwards compatibility we put empty",
      "215:     # string values for path if there are any defined values",
      "",
      "[Removed Lines]",
      "212:         six.raise_from(LocationParseError(url), None)",
      "",
      "[Added Lines]",
      "250:         return six.raise_from(LocationParseError(url), None)",
      "",
      "---------------"
    ],
    "test/test_util.py||test/test_util.py": [
      "File: test/test_util.py -> test/test_util.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "135:         'http://user\\\\@google.com',",
      "136:         'http://google\\\\.com',",
      "137:         'user\\\\@google.com',",
      "139:         'http://user@user@google.com/',",
      "140:     ])",
      "141:     def test_invalid_url(self, url):",
      "142:         with pytest.raises(LocationParseError):",
      "",
      "[Removed Lines]",
      "138:         'http://google.com#fragment#',",
      "",
      "[Added Lines]",
      "140:         # Invalid IDNA labels",
      "141:         u'http://\\uD7FF.com',",
      "142:         u'http://\u2764\ufe0f',",
      "144:         # Unicode surrogates",
      "145:         u'http://\\uD800.com',",
      "146:         u'http://\\uDC00.com',",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "149:         ('HTTPS://Example.Com/?Key=Value', 'https://example.com/?Key=Value'),",
      "150:         ('Https://Example.Com/#Fragment', 'https://example.com/#Fragment'),",
      "151:         ('[::Ff%etH0%Ff]/%ab%Af', '[::ff%25etH0%Ff]/%AB%AF'),",
      "152:     ])",
      "153:     def test_parse_url_normalization(self, url, expected_normalized_url):",
      "154:         \"\"\"Assert parse_url normalizes the scheme/host, and only the scheme/host\"\"\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "160:         # Invalid characters for the query/fragment getting encoded",
      "161:         ('http://google.com/p[]?parameter[]=\\\"hello\\\"#fragment#',",
      "162:          'http://google.com/p%5B%5D?parameter%5B%5D=%22hello%22#fragment%23'),",
      "164:         # Percent encoding isn't applied twice despite '%' being invalid",
      "165:         # but the percent encoding is still normalized.",
      "166:         ('http://google.com/p%5B%5d?parameter%5b%5D=%22hello%22#fragment%23',",
      "167:          'http://google.com/p%5B%5D?parameter%5B%5D=%22hello%22#fragment%23')",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "215:         # Uppercase IRI",
      "216:         (u'http://K\u00f6nigsg\u00e4\u00dfchen.de/stra\u00dfe',",
      "218:     ]",
      "220:     @pytest.mark.parametrize(",
      "",
      "[Removed Lines]",
      "217:          Url('http', host='xn--knigsgchen-b4a3dun.de', path='/stra%C3%9Fe'))",
      "",
      "[Added Lines]",
      "233:          Url('http', host='xn--knigsgchen-b4a3dun.de', path='/stra%C3%9Fe')),",
      "235:         # Unicode Surrogates",
      "236:         (u'http://google.com/\\uD800', Url('http', host='google.com', path='%ED%A0%80')),",
      "237:         (u'http://google.com?q=\\uDC00',",
      "238:          Url('http', host='google.com', path='', query='q=%ED%B0%80')),",
      "239:         (u'http://google.com#\\uDC00',",
      "240:          Url('http', host='google.com', path='', fragment='%ED%B0%80')),",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5d523706c7b03f947dc50a7e783758a2bfff0532",
      "candidate_info": {
        "commit_hash": "5d523706c7b03f947dc50a7e783758a2bfff0532",
        "repo": "urllib3/urllib3",
        "commit_url": "https://github.com/urllib3/urllib3/commit/5d523706c7b03f947dc50a7e783758a2bfff0532",
        "files": [
          "src/urllib3/connectionpool.py",
          "src/urllib3/packages/rfc3986/__init__.py",
          "src/urllib3/packages/rfc3986/_mixin.py",
          "src/urllib3/packages/rfc3986/abnf_regexp.py",
          "src/urllib3/packages/rfc3986/api.py",
          "src/urllib3/packages/rfc3986/exceptions.py",
          "src/urllib3/packages/rfc3986/iri.py",
          "src/urllib3/packages/rfc3986/misc.py",
          "src/urllib3/packages/rfc3986/normalizers.py",
          "src/urllib3/packages/rfc3986/uri.py",
          "src/urllib3/packages/rfc3986/validators.py",
          "src/urllib3/util/url.py",
          "test/test_util.py"
        ],
        "message": "Use rfc3986.validator.Validator for parse_url (#1531)",
        "before_after_code_files": [
          "src/urllib3/connectionpool.py||src/urllib3/connectionpool.py",
          "src/urllib3/packages/rfc3986/__init__.py||src/urllib3/packages/rfc3986/__init__.py",
          "src/urllib3/packages/rfc3986/_mixin.py||src/urllib3/packages/rfc3986/_mixin.py",
          "src/urllib3/packages/rfc3986/abnf_regexp.py||src/urllib3/packages/rfc3986/abnf_regexp.py",
          "src/urllib3/packages/rfc3986/api.py||src/urllib3/packages/rfc3986/api.py",
          "src/urllib3/packages/rfc3986/exceptions.py||src/urllib3/packages/rfc3986/exceptions.py",
          "src/urllib3/packages/rfc3986/iri.py||src/urllib3/packages/rfc3986/iri.py",
          "src/urllib3/packages/rfc3986/misc.py||src/urllib3/packages/rfc3986/misc.py",
          "src/urllib3/packages/rfc3986/normalizers.py||src/urllib3/packages/rfc3986/normalizers.py",
          "src/urllib3/packages/rfc3986/uri.py||src/urllib3/packages/rfc3986/uri.py",
          "src/urllib3/packages/rfc3986/validators.py||src/urllib3/packages/rfc3986/validators.py",
          "src/urllib3/util/url.py||src/urllib3/util/url.py",
          "test/test_util.py||test/test_util.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/urllib3/util/url.py||src/urllib3/util/url.py",
            "test/test_util.py||test/test_util.py"
          ],
          "candidate": [
            "src/urllib3/util/url.py||src/urllib3/util/url.py",
            "test/test_util.py||test/test_util.py"
          ]
        }
      },
      "candidate_diff": {
        "src/urllib3/connectionpool.py||src/urllib3/connectionpool.py": [
          "File: src/urllib3/connectionpool.py -> src/urllib3/connectionpool.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: from .packages.ssl_match_hostname import CertificateError",
          "27: from .packages import six",
          "28: from .packages.six.moves import queue",
          "29: from .connection import (",
          "30:     port_by_scheme,",
          "31:     DummyConnection,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: from .packages.rfc3986.normalizers import normalize_host",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65:         if not host:",
          "66:             raise LocationValueError(\"No host specified.\")",
          "69:         self._proxy_host = host.lower()",
          "70:         self.port = port",
          "",
          "[Removed Lines]",
          "68:         self.host = _ipv6_host(host, self.scheme)",
          "",
          "[Added Lines]",
          "69:         self.host = _normalize_host(host, scheme=self.scheme)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "435:         # TODO: Add optional support for socket.gethostbyname checking.",
          "436:         scheme, host, port = get_host(url)",
          "440:         # Use explicit default port for comparison when none is given",
          "441:         if self.port and not port:",
          "",
          "[Removed Lines]",
          "438:         host = _ipv6_host(host, self.scheme)",
          "",
          "[Added Lines]",
          "438:         if host is not None:",
          "439:             host = _normalize_host(host, scheme=scheme)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "878:         return HTTPConnectionPool(host, port=port, **kw)",
          "882:     \"\"\"",
          "884:     \"\"\"",
          "886:     # httplib doesn't like it when we include brackets in IPv6 addresses",
          "",
          "[Removed Lines]",
          "881: def _ipv6_host(host, scheme):",
          "883:     Process IPv6 address literals",
          "",
          "[Added Lines]",
          "882: def _normalize_host(host, scheme):",
          "884:     Normalize hosts for comparisons and use with sockets.",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "889:     # Instead, we need to make sure we never pass ``None`` as the port.",
          "890:     # However, for backward compatibility reasons we can't actually",
          "891:     # *assert* that.  See http://bugs.python.org/issue28539",
          "895:     if host.startswith('[') and host.endswith(']'):",
          "897:     if scheme in NORMALIZABLE_SCHEMES:",
          "899:     return host",
          "",
          "[Removed Lines]",
          "892:     #",
          "893:     # Also if an IPv6 address literal has a zone identifier, the",
          "894:     # percent sign might be URIencoded, convert it back into ASCII",
          "896:         host = host.replace('%25', '%').strip('[]')",
          "898:         host = host.lower()",
          "",
          "[Added Lines]",
          "894:         host = host.strip('[]')",
          "896:         host = normalize_host(host)",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/__init__.py||src/urllib3/packages/rfc3986/__init__.py": [
          "File: src/urllib3/packages/rfc3986/__init__.py -> src/urllib3/packages/rfc3986/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: :license: Apache v2.0, see LICENSE for details",
          "23: \"\"\"",
          "25: from .api import is_valid_uri",
          "26: from .api import normalize_uri",
          "27: from .api import uri_reference",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: from .api import iri_reference",
          "26: from .api import IRIReference",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34: __author_email__ = 'graffatcolmingov@gmail.com'",
          "35: __license__ = 'Apache v2.0'",
          "36: __copyright__ = 'Copyright 2014 Rackspace'",
          "39: __all__ = (",
          "40:     'ParseResult',",
          "41:     'URIReference',",
          "42:     'is_valid_uri',",
          "43:     'normalize_uri',",
          "44:     'uri_reference',",
          "45:     'urlparse',",
          "46:     '__title__',",
          "47:     '__author__',",
          "",
          "[Removed Lines]",
          "37: __version__ = '1.2.0'",
          "",
          "[Added Lines]",
          "39: __version__ = '1.3.0'",
          "44:     'IRIReference',",
          "48:     'iri_reference',",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/_mixin.py||src/urllib3/packages/rfc3986/_mixin.py": [
          "File: src/urllib3/packages/rfc3986/_mixin.py -> src/urllib3/packages/rfc3986/_mixin.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: \"\"\"Module containing the implementation of the URIMixin class.\"\"\"",
          "2: import warnings",
          "4: from . import exceptions as exc",
          "5: from . import misc",
          "6: from . import normalizers",
          "7: from . import validators",
          "10: class URIMixin(object):",
          "11:     \"\"\"Mixin with all shared methods for URIs and IRIs.\"\"\"",
          "13:     __hash__ = tuple.__hash__",
          "15:     def authority_info(self):",
          "16:         \"\"\"Return a dictionary with the ``userinfo``, ``host``, and ``port``.",
          "18:         If the authority is not valid, it will raise a",
          "19:         :class:`~rfc3986.exceptions.InvalidAuthority` Exception.",
          "21:         :returns:",
          "22:             ``{'userinfo': 'username:password', 'host': 'www.example.com',",
          "23:             'port': '80'}``",
          "24:         :rtype: dict",
          "25:         :raises rfc3986.exceptions.InvalidAuthority:",
          "26:             If the authority is not ``None`` and can not be parsed.",
          "27:         \"\"\"",
          "28:         if not self.authority:",
          "29:             return {'userinfo': None, 'host': None, 'port': None}",
          "31:         match = self._match_subauthority()",
          "33:         if match is None:",
          "34:             # In this case, we have an authority that was parsed from the URI",
          "35:             # Reference, but it cannot be further parsed by our",
          "36:             # misc.SUBAUTHORITY_MATCHER. In this case it must not be a valid",
          "37:             # authority.",
          "38:             raise exc.InvalidAuthority(self.authority.encode(self.encoding))",
          "40:         # We had a match, now let's ensure that it is actually a valid host",
          "41:         # address if it is IPv4",
          "42:         matches = match.groupdict()",
          "43:         host = matches.get('host')",
          "45:         if (host and misc.IPv4_MATCHER.match(host) and not",
          "46:                 validators.valid_ipv4_host_address(host)):",
          "47:             # If we have a host, it appears to be IPv4 and it does not have",
          "48:             # valid bytes, it is an InvalidAuthority.",
          "49:             raise exc.InvalidAuthority(self.authority.encode(self.encoding))",
          "51:         return matches",
          "53:     def _match_subauthority(self):",
          "54:         return misc.SUBAUTHORITY_MATCHER.match(self.authority)",
          "56:     @property",
          "57:     def host(self):",
          "58:         \"\"\"If present, a string representing the host.\"\"\"",
          "59:         try:",
          "60:             authority = self.authority_info()",
          "61:         except exc.InvalidAuthority:",
          "62:             return None",
          "63:         return authority['host']",
          "65:     @property",
          "66:     def port(self):",
          "67:         \"\"\"If present, the port extracted from the authority.\"\"\"",
          "68:         try:",
          "69:             authority = self.authority_info()",
          "70:         except exc.InvalidAuthority:",
          "71:             return None",
          "72:         return authority['port']",
          "74:     @property",
          "75:     def userinfo(self):",
          "76:         \"\"\"If present, the userinfo extracted from the authority.\"\"\"",
          "77:         try:",
          "78:             authority = self.authority_info()",
          "79:         except exc.InvalidAuthority:",
          "80:             return None",
          "81:         return authority['userinfo']",
          "83:     def is_absolute(self):",
          "84:         \"\"\"Determine if this URI Reference is an absolute URI.",
          "86:         See http://tools.ietf.org/html/rfc3986#section-4.3 for explanation.",
          "88:         :returns: ``True`` if it is an absolute URI, ``False`` otherwise.",
          "89:         :rtype: bool",
          "90:         \"\"\"",
          "91:         return bool(misc.ABSOLUTE_URI_MATCHER.match(self.unsplit()))",
          "93:     def is_valid(self, **kwargs):",
          "94:         \"\"\"Determine if the URI is valid.",
          "96:         .. deprecated:: 1.1.0",
          "98:             Use the :class:`~rfc3986.validators.Validator` object instead.",
          "100:         :param bool require_scheme: Set to ``True`` if you wish to require the",
          "101:             presence of the scheme component.",
          "102:         :param bool require_authority: Set to ``True`` if you wish to require",
          "103:             the presence of the authority component.",
          "104:         :param bool require_path: Set to ``True`` if you wish to require the",
          "105:             presence of the path component.",
          "106:         :param bool require_query: Set to ``True`` if you wish to require the",
          "107:             presence of the query component.",
          "108:         :param bool require_fragment: Set to ``True`` if you wish to require",
          "109:             the presence of the fragment component.",
          "110:         :returns: ``True`` if the URI is valid. ``False`` otherwise.",
          "111:         :rtype: bool",
          "112:         \"\"\"",
          "113:         warnings.warn(\"Please use rfc3986.validators.Validator instead. \"",
          "114:                       \"This method will be eventually removed.\",",
          "115:                       DeprecationWarning)",
          "116:         validators = [",
          "117:             (self.scheme_is_valid, kwargs.get('require_scheme', False)),",
          "118:             (self.authority_is_valid, kwargs.get('require_authority', False)),",
          "119:             (self.path_is_valid, kwargs.get('require_path', False)),",
          "120:             (self.query_is_valid, kwargs.get('require_query', False)),",
          "121:             (self.fragment_is_valid, kwargs.get('require_fragment', False)),",
          "122:             ]",
          "123:         return all(v(r) for v, r in validators)",
          "125:     def authority_is_valid(self, require=False):",
          "126:         \"\"\"Determine if the authority component is valid.",
          "128:         .. deprecated:: 1.1.0",
          "130:             Use the :class:`~rfc3986.validators.Validator` object instead.",
          "132:         :param bool require:",
          "133:             Set to ``True`` to require the presence of this component.",
          "134:         :returns:",
          "135:             ``True`` if the authority is valid. ``False`` otherwise.",
          "136:         :rtype:",
          "137:             bool",
          "138:         \"\"\"",
          "139:         warnings.warn(\"Please use rfc3986.validators.Validator instead. \"",
          "140:                       \"This method will be eventually removed.\",",
          "141:                       DeprecationWarning)",
          "142:         try:",
          "143:             self.authority_info()",
          "144:         except exc.InvalidAuthority:",
          "145:             return False",
          "147:         return validators.authority_is_valid(",
          "148:             self.authority,",
          "149:             host=self.host,",
          "150:             require=require,",
          "151:         )",
          "153:     def scheme_is_valid(self, require=False):",
          "154:         \"\"\"Determine if the scheme component is valid.",
          "156:         .. deprecated:: 1.1.0",
          "158:             Use the :class:`~rfc3986.validators.Validator` object instead.",
          "160:         :param str require: Set to ``True`` to require the presence of this",
          "161:             component.",
          "162:         :returns: ``True`` if the scheme is valid. ``False`` otherwise.",
          "163:         :rtype: bool",
          "164:         \"\"\"",
          "165:         warnings.warn(\"Please use rfc3986.validators.Validator instead. \"",
          "166:                       \"This method will be eventually removed.\",",
          "167:                       DeprecationWarning)",
          "168:         return validators.scheme_is_valid(self.scheme, require)",
          "170:     def path_is_valid(self, require=False):",
          "171:         \"\"\"Determine if the path component is valid.",
          "173:         .. deprecated:: 1.1.0",
          "175:             Use the :class:`~rfc3986.validators.Validator` object instead.",
          "177:         :param str require: Set to ``True`` to require the presence of this",
          "178:             component.",
          "179:         :returns: ``True`` if the path is valid. ``False`` otherwise.",
          "180:         :rtype: bool",
          "181:         \"\"\"",
          "182:         warnings.warn(\"Please use rfc3986.validators.Validator instead. \"",
          "183:                       \"This method will be eventually removed.\",",
          "184:                       DeprecationWarning)",
          "185:         return validators.path_is_valid(self.path, require)",
          "187:     def query_is_valid(self, require=False):",
          "188:         \"\"\"Determine if the query component is valid.",
          "190:         .. deprecated:: 1.1.0",
          "192:             Use the :class:`~rfc3986.validators.Validator` object instead.",
          "194:         :param str require: Set to ``True`` to require the presence of this",
          "195:             component.",
          "196:         :returns: ``True`` if the query is valid. ``False`` otherwise.",
          "197:         :rtype: bool",
          "198:         \"\"\"",
          "199:         warnings.warn(\"Please use rfc3986.validators.Validator instead. \"",
          "200:                       \"This method will be eventually removed.\",",
          "201:                       DeprecationWarning)",
          "202:         return validators.query_is_valid(self.query, require)",
          "204:     def fragment_is_valid(self, require=False):",
          "205:         \"\"\"Determine if the fragment component is valid.",
          "207:         .. deprecated:: 1.1.0",
          "209:             Use the Validator object instead.",
          "211:         :param str require: Set to ``True`` to require the presence of this",
          "212:             component.",
          "213:         :returns: ``True`` if the fragment is valid. ``False`` otherwise.",
          "214:         :rtype: bool",
          "215:         \"\"\"",
          "216:         warnings.warn(\"Please use rfc3986.validators.Validator instead. \"",
          "217:                       \"This method will be eventually removed.\",",
          "218:                       DeprecationWarning)",
          "219:         return validators.fragment_is_valid(self.fragment, require)",
          "221:     def normalized_equality(self, other_ref):",
          "222:         \"\"\"Compare this URIReference to another URIReference.",
          "224:         :param URIReference other_ref: (required), The reference with which",
          "225:             we're comparing.",
          "226:         :returns: ``True`` if the references are equal, ``False`` otherwise.",
          "227:         :rtype: bool",
          "228:         \"\"\"",
          "229:         return tuple(self.normalize()) == tuple(other_ref.normalize())",
          "231:     def resolve_with(self, base_uri, strict=False):",
          "232:         \"\"\"Use an absolute URI Reference to resolve this relative reference.",
          "234:         Assuming this is a relative reference that you would like to resolve,",
          "235:         use the provided base URI to resolve it.",
          "237:         See http://tools.ietf.org/html/rfc3986#section-5 for more information.",
          "239:         :param base_uri: Either a string or URIReference. It must be an",
          "240:             absolute URI or it will raise an exception.",
          "241:         :returns: A new URIReference which is the result of resolving this",
          "242:             reference using ``base_uri``.",
          "243:         :rtype: :class:`URIReference`",
          "244:         :raises rfc3986.exceptions.ResolutionError:",
          "245:             If the ``base_uri`` is not an absolute URI.",
          "246:         \"\"\"",
          "247:         if not isinstance(base_uri, URIMixin):",
          "248:             base_uri = type(self).from_string(base_uri)",
          "250:         if not base_uri.is_absolute():",
          "251:             raise exc.ResolutionError(base_uri)",
          "253:         # This is optional per",
          "254:         # http://tools.ietf.org/html/rfc3986#section-5.2.1",
          "255:         base_uri = base_uri.normalize()",
          "257:         # The reference we're resolving",
          "258:         resolving = self",
          "260:         if not strict and resolving.scheme == base_uri.scheme:",
          "261:             resolving = resolving.copy_with(scheme=None)",
          "263:         # http://tools.ietf.org/html/rfc3986#page-32",
          "264:         if resolving.scheme is not None:",
          "265:             target = resolving.copy_with(",
          "266:                 path=normalizers.normalize_path(resolving.path)",
          "267:             )",
          "268:         else:",
          "269:             if resolving.authority is not None:",
          "270:                 target = resolving.copy_with(",
          "271:                     scheme=base_uri.scheme,",
          "272:                     path=normalizers.normalize_path(resolving.path)",
          "273:                 )",
          "274:             else:",
          "275:                 if resolving.path is None:",
          "276:                     if resolving.query is not None:",
          "277:                         query = resolving.query",
          "278:                     else:",
          "279:                         query = base_uri.query",
          "280:                     target = resolving.copy_with(",
          "281:                         scheme=base_uri.scheme,",
          "282:                         authority=base_uri.authority,",
          "283:                         path=base_uri.path,",
          "284:                         query=query",
          "285:                     )",
          "286:                 else:",
          "287:                     if resolving.path.startswith('/'):",
          "288:                         path = normalizers.normalize_path(resolving.path)",
          "289:                     else:",
          "290:                         path = normalizers.normalize_path(",
          "291:                             misc.merge_paths(base_uri, resolving.path)",
          "292:                         )",
          "293:                     target = resolving.copy_with(",
          "294:                         scheme=base_uri.scheme,",
          "295:                         authority=base_uri.authority,",
          "296:                         path=path,",
          "297:                         query=resolving.query",
          "298:                     )",
          "299:         return target",
          "301:     def unsplit(self):",
          "302:         \"\"\"Create a URI string from the components.",
          "304:         :returns: The URI Reference reconstituted as a string.",
          "305:         :rtype: str",
          "306:         \"\"\"",
          "307:         # See http://tools.ietf.org/html/rfc3986#section-5.3",
          "308:         result_list = []",
          "309:         if self.scheme:",
          "310:             result_list.extend([self.scheme, ':'])",
          "311:         if self.authority:",
          "312:             result_list.extend(['//', self.authority])",
          "313:         if self.path:",
          "314:             result_list.append(self.path)",
          "315:         if self.query is not None:",
          "316:             result_list.extend(['?', self.query])",
          "317:         if self.fragment is not None:",
          "318:             result_list.extend(['#', self.fragment])",
          "319:         return ''.join(result_list)",
          "321:     def copy_with(self, scheme=misc.UseExisting, authority=misc.UseExisting,",
          "322:                   path=misc.UseExisting, query=misc.UseExisting,",
          "323:                   fragment=misc.UseExisting):",
          "324:         \"\"\"Create a copy of this reference with the new components.",
          "326:         :param str scheme:",
          "327:             (optional) The scheme to use for the new reference.",
          "328:         :param str authority:",
          "329:             (optional) The authority to use for the new reference.",
          "330:         :param str path:",
          "331:             (optional) The path to use for the new reference.",
          "332:         :param str query:",
          "333:             (optional) The query to use for the new reference.",
          "334:         :param str fragment:",
          "335:             (optional) The fragment to use for the new reference.",
          "336:         :returns:",
          "337:             New URIReference with provided components.",
          "338:         :rtype:",
          "339:             URIReference",
          "340:         \"\"\"",
          "341:         attributes = {",
          "342:             'scheme': scheme,",
          "343:             'authority': authority,",
          "344:             'path': path,",
          "345:             'query': query,",
          "346:             'fragment': fragment,",
          "347:         }",
          "348:         for key, value in list(attributes.items()):",
          "349:             if value is misc.UseExisting:",
          "350:                 del attributes[key]",
          "351:         uri = self._replace(**attributes)",
          "352:         uri.encoding = self.encoding",
          "353:         return uri",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/abnf_regexp.py||src/urllib3/packages/rfc3986/abnf_regexp.py": [
          "File: src/urllib3/packages/rfc3986/abnf_regexp.py -> src/urllib3/packages/rfc3986/abnf_regexp.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: # limitations under the License.",
          "14: \"\"\"Module for the regular expressions crafted from ABNF.\"\"\"",
          "16: # https://tools.ietf.org/html/rfc3986#page-13",
          "17: GEN_DELIMS = GENERIC_DELIMITERS = \":/?#[]@\"",
          "18: GENERIC_DELIMITERS_SET = set(GENERIC_DELIMITERS)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: import sys",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "25: ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'",
          "26: DIGIT = '0123456789'",
          "27: # https://tools.ietf.org/html/rfc3986#section-2.3",
          "29: UNRESERVED_CHARS_SET = set(UNRESERVED_CHARS)",
          "30: NON_PCT_ENCODED_SET = RESERVED_CHARS_SET.union(UNRESERVED_CHARS_SET)",
          "31: # We need to escape the '-' in this case:",
          "",
          "[Removed Lines]",
          "28: UNRESERVED = UNRESERVED_CHARS = ALPHA + DIGIT + '._!-'",
          "",
          "[Added Lines]",
          "30: UNRESERVED = UNRESERVED_CHARS = ALPHA + DIGIT + r'._!-'",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "75:     '%[0-9A-Fa-f]{2}', SUB_DELIMITERS_RE + UNRESERVED_RE",
          "76: )",
          "77: # The pattern for an IPv4 address, e.g., 192.168.255.255, 127.0.0.1,",
          "79: # Hexadecimal characters used in each piece of an IPv6 address",
          "80: HEXDIG_RE = '[0-9A-Fa-f]{1,4}'",
          "81: # Least-significant 32 bits of an IPv6 address",
          "",
          "[Removed Lines]",
          "78: IPv4_RE = '([0-9]{1,3}.){3}[0-9]{1,3}'",
          "",
          "[Added Lines]",
          "80: IPv4_RE = r'([0-9]{1,3}\\.){3}[0-9]{1,3}'",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "112: )",
          "115:     UNRESERVED_RE + SUB_DELIMITERS_RE + ':'",
          "116: )",
          "119: # RFC 6874 Zone ID ABNF",
          "120: ZONE_ID = '(?:[' + UNRESERVED_RE + ']|' + PCT_ENCODED + ')+'",
          "126:     IPv_FUTURE_RE,",
          "127: )",
          "",
          "[Removed Lines]",
          "114: IPv_FUTURE_RE = 'v[0-9A-Fa-f]+.[%s]+' % (",
          "121: IPv6_ADDRZ_RE = IPv6_RE + '%25' + ZONE_ID",
          "123: IP_LITERAL_RE = r'\\[({0}|(?:{1})|{2})\\]'.format(",
          "124:     IPv6_RE,",
          "125:     IPv6_ADDRZ_RE,",
          "",
          "[Added Lines]",
          "116: IPv_FUTURE_RE = r'v[0-9A-Fa-f]+\\.[%s]+' % (",
          "123: IPv6_ADDRZ_RFC4007_RE = IPv6_RE + '(?:(?:%25|%)' + ZONE_ID + ')?'",
          "124: IPv6_ADDRZ_RE = IPv6_RE + '(?:%25' + ZONE_ID + ')?'",
          "126: IP_LITERAL_RE = r'\\[({0}|{1})\\]'.format(",
          "127:     IPv6_ADDRZ_RFC4007_RE,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "186:     PATH_ROOTLESS,",
          "187:     PATH_EMPTY,",
          "188: )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "192: # ###############",
          "193: # IRIs / RFC 3987",
          "194: # ###############",
          "196: # Only wide-unicode gets the high-ranges of UCSCHAR",
          "197: if sys.maxunicode > 0xFFFF:  # pragma: no cover",
          "198:     IPRIVATE = u'\\uE000-\\uF8FF\\U000F0000-\\U000FFFFD\\U00100000-\\U0010FFFD'",
          "199:     UCSCHAR_RE = (",
          "200:         u'\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF'",
          "201:         u'\\U00010000-\\U0001FFFD\\U00020000-\\U0002FFFD'",
          "202:         u'\\U00030000-\\U0003FFFD\\U00040000-\\U0004FFFD'",
          "203:         u'\\U00050000-\\U0005FFFD\\U00060000-\\U0006FFFD'",
          "204:         u'\\U00070000-\\U0007FFFD\\U00080000-\\U0008FFFD'",
          "205:         u'\\U00090000-\\U0009FFFD\\U000A0000-\\U000AFFFD'",
          "206:         u'\\U000B0000-\\U000BFFFD\\U000C0000-\\U000CFFFD'",
          "207:         u'\\U000D0000-\\U000DFFFD\\U000E1000-\\U000EFFFD'",
          "208:     )",
          "209: else:  # pragma: no cover",
          "210:     IPRIVATE = u'\\uE000-\\uF8FF'",
          "211:     UCSCHAR_RE = (",
          "212:         u'\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF'",
          "213:     )",
          "215: IUNRESERVED_RE = u'A-Za-z0-9\\\\._~\\\\-' + UCSCHAR_RE",
          "216: IPCHAR = u'([' + IUNRESERVED_RE + SUB_DELIMITERS_RE + u':@]|%s)' % PCT_ENCODED",
          "218: isegments = {",
          "219:     'isegment': IPCHAR + u'*',",
          "220:     # Non-zero length segment",
          "221:     'isegment-nz': IPCHAR + u'+',",
          "222:     # Non-zero length segment without \":\"",
          "223:     'isegment-nz-nc': IPCHAR.replace(':', '') + u'+'",
          "224: }",
          "226: IPATH_ROOTLESS = u'%(isegment-nz)s(/%(isegment)s)*' % isegments",
          "227: IPATH_NOSCHEME = u'%(isegment-nz-nc)s(/%(isegment)s)*' % isegments",
          "228: IPATH_ABSOLUTE = u'/(?:%s)?' % IPATH_ROOTLESS",
          "229: IPATH_ABEMPTY = u'(?:/%(isegment)s)*' % isegments",
          "230: IPATH_RE = u'^(?:%s|%s|%s|%s|%s)$' % (",
          "231:     IPATH_ABEMPTY, IPATH_ABSOLUTE, IPATH_NOSCHEME, IPATH_ROOTLESS, PATH_EMPTY",
          "232: )",
          "234: IREGULAR_NAME_RE = IREG_NAME = u'(?:{0}|[{1}])*'.format(",
          "235:     u'%[0-9A-Fa-f]{2}', SUB_DELIMITERS_RE + IUNRESERVED_RE",
          "236: )",
          "238: IHOST_RE = IHOST_PATTERN = u'({0}|{1}|{2})'.format(",
          "239:     IREG_NAME,",
          "240:     IPv4_RE,",
          "241:     IP_LITERAL_RE,",
          "242: )",
          "244: IUSERINFO_RE = u'^(?:[' + IUNRESERVED_RE + SUB_DELIMITERS_RE + u':]|%s)+' % (",
          "245:     PCT_ENCODED",
          "246: )",
          "248: IFRAGMENT_RE = (u'^(?:[/?:@' + IUNRESERVED_RE + SUB_DELIMITERS_RE",
          "249:                 + u']|%s)*$' % PCT_ENCODED)",
          "250: IQUERY_RE = (u'^(?:[/?:@' + IUNRESERVED_RE + SUB_DELIMITERS_RE",
          "251:              + IPRIVATE + u']|%s)*$' % PCT_ENCODED)",
          "253: IRELATIVE_PART_RE = u'(//%s%s|%s|%s|%s)' % (",
          "254:     COMPONENT_PATTERN_DICT['authority'],",
          "255:     IPATH_ABEMPTY,",
          "256:     IPATH_ABSOLUTE,",
          "257:     IPATH_NOSCHEME,",
          "258:     PATH_EMPTY,",
          "259: )",
          "261: IHIER_PART_RE = u'(//%s%s|%s|%s|%s)' % (",
          "262:     COMPONENT_PATTERN_DICT['authority'],",
          "263:     IPATH_ABEMPTY,",
          "264:     IPATH_ABSOLUTE,",
          "265:     IPATH_ROOTLESS,",
          "266:     PATH_EMPTY,",
          "267: )",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/api.py||src/urllib3/packages/rfc3986/api.py": [
          "File: src/urllib3/packages/rfc3986/api.py -> src/urllib3/packages/rfc3986/api.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: and classes of rfc3986.",
          "20: \"\"\"",
          "22: from .parseresult import ParseResult",
          "23: from .uri import URIReference",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: from .iri import IRIReference",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37:     return URIReference.from_string(uri, encoding)",
          "40: def is_valid_uri(uri, encoding='utf-8', **kwargs):",
          "41:     \"\"\"Determine if the URI given is valid.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "41: def iri_reference(iri, encoding='utf-8'):",
          "42:     \"\"\"Parse a IRI string into an IRIReference.",
          "44:     This is a convenience function. You could achieve the same end by using",
          "45:     ``IRIReference.from_string(iri)``.",
          "47:     :param str iri: The IRI which needs to be parsed into a reference.",
          "48:     :param str encoding: The encoding of the string provided",
          "49:     :returns: A parsed IRI",
          "50:     :rtype: :class:`IRIReference`",
          "51:     \"\"\"",
          "52:     return IRIReference.from_string(iri, encoding)",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/exceptions.py||src/urllib3/packages/rfc3986/exceptions.py": [
          "File: src/urllib3/packages/rfc3986/exceptions.py -> src/urllib3/packages/rfc3986/exceptions.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: # -*- coding: utf-8 -*-",
          "2: \"\"\"Exceptions module for rfc3986.\"\"\"",
          "5: class RFC3986Exception(Exception):",
          "6:     \"\"\"Base class for all rfc3986 exception classes.\"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: from . import compat",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "14:     def __init__(self, authority):",
          "15:         \"\"\"Initialize the exception with the invalid authority.\"\"\"",
          "16:         super(InvalidAuthority, self).__init__(",
          "20: class InvalidPort(RFC3986Exception):",
          "",
          "[Removed Lines]",
          "17:             \"The authority ({0}) is not valid.\".format(authority))",
          "",
          "[Added Lines]",
          "19:             u\"The authority ({0}) is not valid.\".format(",
          "20:                 compat.to_str(authority)))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "109:             uri,",
          "110:             self.components,",
          "111:         )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "117: class MissingDependencyError(RFC3986Exception):",
          "118:     \"\"\"Exception raised when an IRI is encoded without the 'idna' module.\"\"\"",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/iri.py||src/urllib3/packages/rfc3986/iri.py": [
          "File: src/urllib3/packages/rfc3986/iri.py -> src/urllib3/packages/rfc3986/iri.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: \"\"\"Module containing the implementation of the IRIReference class.\"\"\"",
          "2: # -*- coding: utf-8 -*-",
          "3: # Copyright (c) 2014 Rackspace",
          "4: # Copyright (c) 2015 Ian Stapleton Cordasco",
          "5: # Licensed under the Apache License, Version 2.0 (the \"License\");",
          "6: # you may not use this file except in compliance with the License.",
          "7: # You may obtain a copy of the License at",
          "8: #",
          "9: #    http://www.apache.org/licenses/LICENSE-2.0",
          "10: #",
          "11: # Unless required by applicable law or agreed to in writing, software",
          "12: # distributed under the License is distributed on an \"AS IS\" BASIS,",
          "13: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or",
          "14: # implied.",
          "15: # See the License for the specific language governing permissions and",
          "16: # limitations under the License.",
          "17: from collections import namedtuple",
          "19: from . import compat",
          "20: from . import exceptions",
          "21: from . import misc",
          "22: from . import normalizers",
          "23: from . import uri",
          "26: try:",
          "27:     import idna",
          "28: except ImportError:  # pragma: no cover",
          "29:     idna = None",
          "32: class IRIReference(namedtuple('IRIReference', misc.URI_COMPONENTS),",
          "33:                    uri.URIMixin):",
          "34:     \"\"\"Immutable object representing a parsed IRI Reference.",
          "36:     Can be encoded into an URIReference object via the procedure",
          "37:     specified in RFC 3987 Section 3.1",
          "39:      .. note::",
          "40:         The IRI submodule is a new interface and may possibly change in",
          "41:         the future. Check for changes to the interface when upgrading.",
          "42:     \"\"\"",
          "44:     slots = ()",
          "46:     def __new__(cls, scheme, authority, path, query, fragment,",
          "47:                 encoding='utf-8'):",
          "48:         \"\"\"Create a new IRIReference.\"\"\"",
          "49:         ref = super(IRIReference, cls).__new__(",
          "50:             cls,",
          "51:             scheme or None,",
          "52:             authority or None,",
          "53:             path or None,",
          "54:             query,",
          "55:             fragment)",
          "56:         ref.encoding = encoding",
          "57:         return ref",
          "59:     def __eq__(self, other):",
          "60:         \"\"\"Compare this reference to another.\"\"\"",
          "61:         other_ref = other",
          "62:         if isinstance(other, tuple):",
          "63:             other_ref = self.__class__(*other)",
          "64:         elif not isinstance(other, IRIReference):",
          "65:             try:",
          "66:                 other_ref = self.__class__.from_string(other)",
          "67:             except TypeError:",
          "68:                 raise TypeError(",
          "69:                     'Unable to compare {0}() to {1}()'.format(",
          "70:                         type(self).__name__, type(other).__name__))",
          "72:         # See http://tools.ietf.org/html/rfc3986#section-6.2",
          "73:         return tuple(self) == tuple(other_ref)",
          "75:     def _match_subauthority(self):",
          "76:         return misc.ISUBAUTHORITY_MATCHER.match(self.authority)",
          "78:     @classmethod",
          "79:     def from_string(cls, iri_string, encoding='utf-8'):",
          "80:         \"\"\"Parse a IRI reference from the given unicode IRI string.",
          "82:         :param str iri_string: Unicode IRI to be parsed into a reference.",
          "83:         :param str encoding: The encoding of the string provided",
          "84:         :returns: :class:`IRIReference` or subclass thereof",
          "85:         \"\"\"",
          "86:         iri_string = compat.to_str(iri_string, encoding)",
          "88:         split_iri = misc.IRI_MATCHER.match(iri_string).groupdict()",
          "89:         return cls(",
          "90:             split_iri['scheme'], split_iri['authority'],",
          "91:             normalizers.encode_component(split_iri['path'], encoding),",
          "92:             normalizers.encode_component(split_iri['query'], encoding),",
          "93:             normalizers.encode_component(split_iri['fragment'], encoding),",
          "94:             encoding,",
          "95:         )",
          "97:     def encode(self, idna_encoder=None):",
          "98:         \"\"\"Encode an IRIReference into a URIReference instance.",
          "100:         If the ``idna`` module is installed or the ``rfc3986[idna]``",
          "101:         extra is used then unicode characters in the IRI host",
          "102:         component will be encoded with IDNA2008.",
          "104:         :param idna_encoder:",
          "105:             Function that encodes each part of the host component",
          "106:             If not given will raise an exception if the IRI",
          "107:             contains a host component.",
          "108:         :rtype: uri.URIReference",
          "109:         :returns: A URI reference",
          "110:         \"\"\"",
          "111:         authority = self.authority",
          "112:         if authority:",
          "113:             if idna_encoder is None:",
          "114:                 if idna is None:  # pragma: no cover",
          "115:                     raise exceptions.MissingDependencyError(",
          "116:                         \"Could not import the 'idna' module \"",
          "117:                         \"and the IRI hostname requires encoding\"",
          "118:                     )",
          "119:                 else:",
          "120:                     def idna_encoder(x):",
          "121:                         try:",
          "122:                             return idna.encode(x, strict=True, std3_rules=True).lower()",
          "123:                         except idna.IDNAError:",
          "124:                             raise exceptions.InvalidAuthority(self.authority)",
          "126:             authority = \"\"",
          "127:             if self.host:",
          "128:                 authority = \".\".join([compat.to_str(idna_encoder(part))",
          "129:                                       for part in self.host.split(\".\")])",
          "131:             if self.userinfo is not None:",
          "132:                 authority = (normalizers.encode_component(",
          "133:                              self.userinfo, self.encoding) + '@' + authority)",
          "135:             if self.port is not None:",
          "136:                 authority += \":\" + str(self.port)",
          "138:         return uri.URIReference(self.scheme,",
          "139:                                 authority,",
          "140:                                 path=self.path,",
          "141:                                 query=self.query,",
          "142:                                 fragment=self.fragment,",
          "143:                                 encoding=self.encoding)",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/misc.py||src/urllib3/packages/rfc3986/misc.py": [
          "File: src/urllib3/packages/rfc3986/misc.py -> src/urllib3/packages/rfc3986/misc.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:              abnf_regexp.PORT_RE))",
          "61: IPv4_MATCHER = re.compile('^' + abnf_regexp.IPv4_RE + '$')",
          "63: # Matcher used to validate path components",
          "64: PATH_MATCHER = re.compile(abnf_regexp.PATH_RE)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61: HOST_MATCHER = re.compile('^' + abnf_regexp.HOST_RE + '$')",
          "63: IPv6_MATCHER = re.compile(r'^\\[' + abnf_regexp.IPv6_ADDRZ_RFC4007_RE + r'\\]$')",
          "65: # Used by host validator",
          "66: IPv6_NO_RFC4007_MATCHER = re.compile(r'^\\[%s\\]$' % (",
          "67:     abnf_regexp.IPv6_ADDRZ_RE",
          "68: ))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76: SCHEME_MATCHER = re.compile('^{0}$'.format(abnf_regexp.SCHEME_RE))",
          "78: RELATIVE_REF_MATCHER = re.compile(r'^%s(\\?%s)?(#%s)?$' % (",
          "80:     abnf_regexp.FRAGMENT_RE,",
          "81: ))",
          "",
          "[Removed Lines]",
          "79:     abnf_regexp.RELATIVE_PART_RE, abnf_regexp.QUERY_RE,",
          "",
          "[Added Lines]",
          "86:     abnf_regexp.RELATIVE_PART_RE,",
          "87:     abnf_regexp.QUERY_RE,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "87:     abnf_regexp.QUERY_RE[1:-1],",
          "88: ))",
          "91: # Path merger as defined in http://tools.ietf.org/html/rfc3986#section-5.2.3",
          "92: def merge_paths(base_uri, relative_path):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "98: # ###############",
          "99: # IRIs / RFC 3987",
          "100: # ###############",
          "102: IRI_MATCHER = re.compile(abnf_regexp.URL_PARSING_RE, re.UNICODE)",
          "104: ISUBAUTHORITY_MATCHER = re.compile((",
          "105:     u'^(?:(?P<userinfo>{0})@)?'  # iuserinfo",
          "106:     u'(?P<host>{1})'  # ihost",
          "107:     u':?(?P<port>{2})?$'  # port",
          "108:     ).format(abnf_regexp.IUSERINFO_RE,",
          "109:              abnf_regexp.IHOST_RE,",
          "110:              abnf_regexp.PORT_RE), re.UNICODE)",
          "113: IHOST_MATCHER = re.compile('^' + abnf_regexp.IHOST_RE + '$', re.UNICODE)",
          "115: IPATH_MATCHER = re.compile(abnf_regexp.IPATH_RE, re.UNICODE)",
          "117: IQUERY_MATCHER = re.compile(abnf_regexp.IQUERY_RE, re.UNICODE)",
          "119: IFRAGMENT_MATCHER = re.compile(abnf_regexp.IFRAGMENT_RE, re.UNICODE)",
          "122: RELATIVE_IRI_MATCHER = re.compile(u'^%s(?:\\\\?%s)?(?:%s)?$' % (",
          "123:     abnf_regexp.IRELATIVE_PART_RE,",
          "124:     abnf_regexp.IQUERY_RE,",
          "125:     abnf_regexp.IFRAGMENT_RE",
          "126: ), re.UNICODE)",
          "128: ABSOLUTE_IRI_MATCHER = re.compile(u'^%s:%s(?:\\\\?%s)?$' % (",
          "129:     abnf_regexp.COMPONENT_PATTERN_DICT['scheme'],",
          "130:     abnf_regexp.IHIER_PART_RE,",
          "131:     abnf_regexp.IQUERY_RE[1:-1]",
          "132: ), re.UNICODE)",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/normalizers.py||src/urllib3/packages/rfc3986/normalizers.py": [
          "File: src/urllib3/packages/rfc3986/normalizers.py -> src/urllib3/packages/rfc3986/normalizers.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: def normalize_host(host):",
          "51:     \"\"\"Normalize a host string.\"\"\"",
          "52:     return host.lower()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52:     if misc.IPv6_MATCHER.match(host):",
          "53:         percent = host.find('%')",
          "54:         if percent != -1:",
          "55:             percent_25 = host.find('%25')",
          "57:             # Replace RFC 4007 IPv6 Zone ID delimiter '%' with '%25'",
          "58:             # from RFC 6874. If the host is '[<IPv6 addr>%25]' then we",
          "59:             # assume RFC 4007 and normalize to '[<IPV6 addr>%2525]'",
          "60:             if percent_25 == -1 or percent < percent_25 or \\",
          "61:                     (percent == percent_25 and percent_25 == len(host) - 4):",
          "62:                 host = host.replace('%', '%25', 1)",
          "64:             # Don't normalize the casing of the Zone ID",
          "65:             return host[:percent].lower() + host[percent:]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "147:                 or (byte_ord < 128 and byte.decode() in misc.NON_PCT_ENCODED)):",
          "148:             encoded_uri.extend(byte)",
          "149:             continue",
          "152:     return encoded_uri.decode(encoding)",
          "",
          "[Removed Lines]",
          "150:         encoded_uri.extend('%{0:02x}'.format(byte_ord).encode())",
          "",
          "[Added Lines]",
          "165:         encoded_uri.extend('%{0:02x}'.format(byte_ord).encode().upper())",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/uri.py||src/urllib3/packages/rfc3986/uri.py": [
          "File: src/urllib3/packages/rfc3986/uri.py -> src/urllib3/packages/rfc3986/uri.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: # See the License for the specific language governing permissions and",
          "16: # limitations under the License.",
          "17: from collections import namedtuple",
          "20: from . import compat",
          "22: from . import misc",
          "23: from . import normalizers",
          "28:     \"\"\"Immutable object representing a parsed URI Reference.",
          "30:     .. note::",
          "",
          "[Removed Lines]",
          "18: import warnings",
          "21: from . import exceptions as exc",
          "24: from . import validators",
          "27: class URIReference(namedtuple('URIReference', misc.URI_COMPONENTS)):",
          "",
          "[Added Lines]",
          "22: from ._mixin import URIMixin",
          "25: class URIReference(namedtuple('URIReference', misc.URI_COMPONENTS), URIMixin):",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "116:         naive_equality = tuple(self) == tuple(other_ref)",
          "117:         return naive_equality or self.normalized_equality(other_ref)",
          "341:     def normalize(self):",
          "342:         \"\"\"Normalize this reference as described in Section 6.2.2.",
          "",
          "[Removed Lines]",
          "119:     @classmethod",
          "120:     def from_string(cls, uri_string, encoding='utf-8'):",
          "121:         \"\"\"Parse a URI reference from the given unicode URI string.",
          "123:         :param str uri_string: Unicode URI to be parsed into a reference.",
          "124:         :param str encoding: The encoding of the string provided",
          "125:         :returns: :class:`URIReference` or subclass thereof",
          "126:         \"\"\"",
          "127:         uri_string = compat.to_str(uri_string, encoding)",
          "129:         split_uri = misc.URI_MATCHER.match(uri_string).groupdict()",
          "130:         return cls(",
          "131:             split_uri['scheme'], split_uri['authority'],",
          "132:             normalizers.encode_component(split_uri['path'], encoding),",
          "133:             normalizers.encode_component(split_uri['query'], encoding),",
          "134:             normalizers.encode_component(split_uri['fragment'], encoding),",
          "135:             encoding,",
          "136:         )",
          "138:     def authority_info(self):",
          "139:         \"\"\"Return a dictionary with the ``userinfo``, ``host``, and ``port``.",
          "141:         If the authority is not valid, it will raise a",
          "142:         :class:`~rfc3986.exceptions.InvalidAuthority` Exception.",
          "144:         :returns:",
          "145:             ``{'userinfo': 'username:password', 'host': 'www.example.com',",
          "146:             'port': '80'}``",
          "147:         :rtype: dict",
          "148:         :raises rfc3986.exceptions.InvalidAuthority:",
          "149:             If the authority is not ``None`` and can not be parsed.",
          "150:         \"\"\"",
          "151:         if not self.authority:",
          "152:             return {'userinfo': None, 'host': None, 'port': None}",
          "154:         match = misc.SUBAUTHORITY_MATCHER.match(self.authority)",
          "156:         if match is None:",
          "157:             # In this case, we have an authority that was parsed from the URI",
          "158:             # Reference, but it cannot be further parsed by our",
          "159:             # misc.SUBAUTHORITY_MATCHER. In this case it must not be a valid",
          "160:             # authority.",
          "161:             raise exc.InvalidAuthority(self.authority.encode(self.encoding))",
          "163:         # We had a match, now let's ensure that it is actually a valid host",
          "164:         # address if it is IPv4",
          "165:         matches = match.groupdict()",
          "166:         host = matches.get('host')",
          "168:         if (host and misc.IPv4_MATCHER.match(host) and not",
          "169:                 validators.valid_ipv4_host_address(host)):",
          "170:             # If we have a host, it appears to be IPv4 and it does not have",
          "171:             # valid bytes, it is an InvalidAuthority.",
          "172:             raise exc.InvalidAuthority(self.authority.encode(self.encoding))",
          "174:         return matches",
          "176:     @property",
          "177:     def host(self):",
          "178:         \"\"\"If present, a string representing the host.\"\"\"",
          "179:         try:",
          "180:             authority = self.authority_info()",
          "181:         except exc.InvalidAuthority:",
          "182:             return None",
          "183:         return authority['host']",
          "185:     @property",
          "186:     def port(self):",
          "187:         \"\"\"If present, the port extracted from the authority.\"\"\"",
          "188:         try:",
          "189:             authority = self.authority_info()",
          "190:         except exc.InvalidAuthority:",
          "191:             return None",
          "192:         return authority['port']",
          "194:     @property",
          "195:     def userinfo(self):",
          "196:         \"\"\"If present, the userinfo extracted from the authority.\"\"\"",
          "197:         try:",
          "198:             authority = self.authority_info()",
          "199:         except exc.InvalidAuthority:",
          "200:             return None",
          "201:         return authority['userinfo']",
          "203:     def is_absolute(self):",
          "204:         \"\"\"Determine if this URI Reference is an absolute URI.",
          "206:         See http://tools.ietf.org/html/rfc3986#section-4.3 for explanation.",
          "208:         :returns: ``True`` if it is an absolute URI, ``False`` otherwise.",
          "209:         :rtype: bool",
          "210:         \"\"\"",
          "211:         return bool(misc.ABSOLUTE_URI_MATCHER.match(self.unsplit()))",
          "213:     def is_valid(self, **kwargs):",
          "214:         \"\"\"Determine if the URI is valid.",
          "216:         .. deprecated:: 1.1.0",
          "218:             Use the :class:`~rfc3986.validators.Validator` object instead.",
          "220:         :param bool require_scheme: Set to ``True`` if you wish to require the",
          "221:             presence of the scheme component.",
          "222:         :param bool require_authority: Set to ``True`` if you wish to require",
          "223:             the presence of the authority component.",
          "224:         :param bool require_path: Set to ``True`` if you wish to require the",
          "225:             presence of the path component.",
          "226:         :param bool require_query: Set to ``True`` if you wish to require the",
          "227:             presence of the query component.",
          "228:         :param bool require_fragment: Set to ``True`` if you wish to require",
          "229:             the presence of the fragment component.",
          "230:         :returns: ``True`` if the URI is valid. ``False`` otherwise.",
          "231:         :rtype: bool",
          "232:         \"\"\"",
          "233:         warnings.warn(\"Please use rfc3986.validators.Validator instead. \"",
          "234:                       \"This method will be eventually removed.\",",
          "235:                       DeprecationWarning)",
          "236:         validators = [",
          "237:             (self.scheme_is_valid, kwargs.get('require_scheme', False)),",
          "238:             (self.authority_is_valid, kwargs.get('require_authority', False)),",
          "239:             (self.path_is_valid, kwargs.get('require_path', False)),",
          "240:             (self.query_is_valid, kwargs.get('require_query', False)),",
          "241:             (self.fragment_is_valid, kwargs.get('require_fragment', False)),",
          "242:             ]",
          "243:         return all(v(r) for v, r in validators)",
          "245:     def authority_is_valid(self, require=False):",
          "246:         \"\"\"Determine if the authority component is valid.",
          "248:         .. deprecated:: 1.1.0",
          "250:             Use the :class:`~rfc3986.validators.Validator` object instead.",
          "252:         :param bool require:",
          "253:             Set to ``True`` to require the presence of this component.",
          "254:         :returns:",
          "255:             ``True`` if the authority is valid. ``False`` otherwise.",
          "256:         :rtype:",
          "257:             bool",
          "258:         \"\"\"",
          "259:         warnings.warn(\"Please use rfc3986.validators.Validator instead. \"",
          "260:                       \"This method will be eventually removed.\",",
          "261:                       DeprecationWarning)",
          "262:         try:",
          "263:             self.authority_info()",
          "264:         except exc.InvalidAuthority:",
          "265:             return False",
          "267:         return validators.authority_is_valid(",
          "268:             self.authority,",
          "269:             host=self.host,",
          "270:             require=require,",
          "271:         )",
          "273:     def scheme_is_valid(self, require=False):",
          "274:         \"\"\"Determine if the scheme component is valid.",
          "276:         .. deprecated:: 1.1.0",
          "278:             Use the :class:`~rfc3986.validators.Validator` object instead.",
          "280:         :param str require: Set to ``True`` to require the presence of this",
          "281:             component.",
          "282:         :returns: ``True`` if the scheme is valid. ``False`` otherwise.",
          "283:         :rtype: bool",
          "284:         \"\"\"",
          "285:         warnings.warn(\"Please use rfc3986.validators.Validator instead. \"",
          "286:                       \"This method will be eventually removed.\",",
          "287:                       DeprecationWarning)",
          "288:         return validators.scheme_is_valid(self.scheme, require)",
          "290:     def path_is_valid(self, require=False):",
          "291:         \"\"\"Determine if the path component is valid.",
          "293:         .. deprecated:: 1.1.0",
          "295:             Use the :class:`~rfc3986.validators.Validator` object instead.",
          "297:         :param str require: Set to ``True`` to require the presence of this",
          "298:             component.",
          "299:         :returns: ``True`` if the path is valid. ``False`` otherwise.",
          "300:         :rtype: bool",
          "301:         \"\"\"",
          "302:         warnings.warn(\"Please use rfc3986.validators.Validator instead. \"",
          "303:                       \"This method will be eventually removed.\",",
          "304:                       DeprecationWarning)",
          "305:         return validators.path_is_valid(self.path, require)",
          "307:     def query_is_valid(self, require=False):",
          "308:         \"\"\"Determine if the query component is valid.",
          "310:         .. deprecated:: 1.1.0",
          "312:             Use the :class:`~rfc3986.validators.Validator` object instead.",
          "314:         :param str require: Set to ``True`` to require the presence of this",
          "315:             component.",
          "316:         :returns: ``True`` if the query is valid. ``False`` otherwise.",
          "317:         :rtype: bool",
          "318:         \"\"\"",
          "319:         warnings.warn(\"Please use rfc3986.validators.Validator instead. \"",
          "320:                       \"This method will be eventually removed.\",",
          "321:                       DeprecationWarning)",
          "322:         return validators.query_is_valid(self.query, require)",
          "324:     def fragment_is_valid(self, require=False):",
          "325:         \"\"\"Determine if the fragment component is valid.",
          "327:         .. deprecated:: 1.1.0",
          "329:             Use the Validator object instead.",
          "331:         :param str require: Set to ``True`` to require the presence of this",
          "332:             component.",
          "333:         :returns: ``True`` if the fragment is valid. ``False`` otherwise.",
          "334:         :rtype: bool",
          "335:         \"\"\"",
          "336:         warnings.warn(\"Please use rfc3986.validators.Validator instead. \"",
          "337:                       \"This method will be eventually removed.\",",
          "338:                       DeprecationWarning)",
          "339:         return validators.fragment_is_valid(self.fragment, require)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "357:                             normalizers.normalize_fragment(self.fragment),",
          "358:                             self.encoding)",
          "367:         \"\"\"",
          "",
          "[Removed Lines]",
          "360:     def normalized_equality(self, other_ref):",
          "361:         \"\"\"Compare this URIReference to another URIReference.",
          "363:         :param URIReference other_ref: (required), The reference with which",
          "364:             we're comparing.",
          "365:         :returns: ``True`` if the references are equal, ``False`` otherwise.",
          "366:         :rtype: bool",
          "368:         return tuple(self.normalize()) == tuple(other_ref.normalize())",
          "370:     def resolve_with(self, base_uri, strict=False):",
          "371:         \"\"\"Use an absolute URI Reference to resolve this relative reference.",
          "373:         Assuming this is a relative reference that you would like to resolve,",
          "374:         use the provided base URI to resolve it.",
          "376:         See http://tools.ietf.org/html/rfc3986#section-5 for more information.",
          "378:         :param base_uri: Either a string or URIReference. It must be an",
          "379:             absolute URI or it will raise an exception.",
          "380:         :returns: A new URIReference which is the result of resolving this",
          "381:             reference using ``base_uri``.",
          "382:         :rtype: :class:`URIReference`",
          "383:         :raises rfc3986.exceptions.ResolutionError:",
          "384:             If the ``base_uri`` is not an absolute URI.",
          "385:         \"\"\"",
          "386:         if not isinstance(base_uri, URIReference):",
          "387:             base_uri = URIReference.from_string(base_uri)",
          "389:         if not base_uri.is_absolute():",
          "390:             raise exc.ResolutionError(base_uri)",
          "392:         # This is optional per",
          "393:         # http://tools.ietf.org/html/rfc3986#section-5.2.1",
          "394:         base_uri = base_uri.normalize()",
          "396:         # The reference we're resolving",
          "397:         resolving = self",
          "399:         if not strict and resolving.scheme == base_uri.scheme:",
          "400:             resolving = resolving.copy_with(scheme=None)",
          "402:         # http://tools.ietf.org/html/rfc3986#page-32",
          "403:         if resolving.scheme is not None:",
          "404:             target = resolving.copy_with(",
          "405:                 path=normalizers.normalize_path(resolving.path)",
          "406:             )",
          "407:         else:",
          "408:             if resolving.authority is not None:",
          "409:                 target = resolving.copy_with(",
          "410:                     scheme=base_uri.scheme,",
          "411:                     path=normalizers.normalize_path(resolving.path)",
          "412:                 )",
          "413:             else:",
          "414:                 if resolving.path is None:",
          "415:                     if resolving.query is not None:",
          "416:                         query = resolving.query",
          "417:                     else:",
          "418:                         query = base_uri.query",
          "419:                     target = resolving.copy_with(",
          "420:                         scheme=base_uri.scheme,",
          "421:                         authority=base_uri.authority,",
          "422:                         path=base_uri.path,",
          "423:                         query=query",
          "424:                     )",
          "425:                 else:",
          "426:                     if resolving.path.startswith('/'):",
          "427:                         path = normalizers.normalize_path(resolving.path)",
          "428:                     else:",
          "429:                         path = normalizers.normalize_path(",
          "430:                             misc.merge_paths(base_uri, resolving.path)",
          "431:                         )",
          "432:                     target = resolving.copy_with(",
          "433:                         scheme=base_uri.scheme,",
          "434:                         authority=base_uri.authority,",
          "435:                         path=path,",
          "436:                         query=resolving.query",
          "437:                     )",
          "438:         return target",
          "440:     def unsplit(self):",
          "441:         \"\"\"Create a URI string from the components.",
          "443:         :returns: The URI Reference reconstituted as a string.",
          "444:         :rtype: str",
          "445:         \"\"\"",
          "446:         # See http://tools.ietf.org/html/rfc3986#section-5.3",
          "447:         result_list = []",
          "448:         if self.scheme:",
          "449:             result_list.extend([self.scheme, ':'])",
          "450:         if self.authority:",
          "451:             result_list.extend(['//', self.authority])",
          "452:         if self.path:",
          "453:             result_list.append(self.path)",
          "454:         if self.query is not None:",
          "455:             result_list.extend(['?', self.query])",
          "456:         if self.fragment is not None:",
          "457:             result_list.extend(['#', self.fragment])",
          "458:         return ''.join(result_list)",
          "460:     def copy_with(self, scheme=misc.UseExisting, authority=misc.UseExisting,",
          "461:                   path=misc.UseExisting, query=misc.UseExisting,",
          "462:                   fragment=misc.UseExisting):",
          "463:         \"\"\"Create a copy of this reference with the new components.",
          "465:         :param str scheme:",
          "466:             (optional) The scheme to use for the new reference.",
          "467:         :param str authority:",
          "468:             (optional) The authority to use for the new reference.",
          "469:         :param str path:",
          "470:             (optional) The path to use for the new reference.",
          "471:         :param str query:",
          "472:             (optional) The query to use for the new reference.",
          "473:         :param str fragment:",
          "474:             (optional) The fragment to use for the new reference.",
          "475:         :returns:",
          "476:             New URIReference with provided components.",
          "477:         :rtype:",
          "478:             URIReference",
          "479:         \"\"\"",
          "480:         attributes = {",
          "481:             'scheme': scheme,",
          "482:             'authority': authority,",
          "483:             'path': path,",
          "484:             'query': query,",
          "485:             'fragment': fragment,",
          "486:         }",
          "487:         for key, value in list(attributes.items()):",
          "488:             if value is misc.UseExisting:",
          "489:                 del attributes[key]",
          "490:         uri = self._replace(**attributes)",
          "491:         uri.encoding = self.encoding",
          "492:         return uri",
          "",
          "[Added Lines]",
          "136:     @classmethod",
          "137:     def from_string(cls, uri_string, encoding='utf-8'):",
          "138:         \"\"\"Parse a URI reference from the given unicode URI string.",
          "140:         :param str uri_string: Unicode URI to be parsed into a reference.",
          "141:         :param str encoding: The encoding of the string provided",
          "142:         :returns: :class:`URIReference` or subclass thereof",
          "144:         uri_string = compat.to_str(uri_string, encoding)",
          "146:         split_uri = misc.URI_MATCHER.match(uri_string).groupdict()",
          "147:         return cls(",
          "148:             split_uri['scheme'], split_uri['authority'],",
          "149:             normalizers.encode_component(split_uri['path'], encoding),",
          "150:             normalizers.encode_component(split_uri['query'], encoding),",
          "151:             normalizers.encode_component(split_uri['fragment'], encoding),",
          "152:             encoding,",
          "153:         )",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/validators.py||src/urllib3/packages/rfc3986/validators.py": [
          "File: src/urllib3/packages/rfc3986/validators.py -> src/urllib3/packages/rfc3986/validators.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "304:         bool",
          "305:     \"\"\"",
          "306:     validated = is_valid(authority, misc.SUBAUTHORITY_MATCHER, require)",
          "307:     if validated and host is not None and misc.IPv4_MATCHER.match(host):",
          "308:         return valid_ipv4_host_address(host)",
          "309:     return validated",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "307:     if validated and host is not None:",
          "308:         return host_is_valid(host, require)",
          "309:     return validated",
          "312: def host_is_valid(host, require=False):",
          "313:     \"\"\"Determine if the host string is valid.",
          "315:     :param str host:",
          "316:         The host to validate.",
          "317:     :param bool require:",
          "318:         (optional) Specify if host must not be None.",
          "319:     :returns:",
          "320:         ``True`` if valid, ``False`` otherwise",
          "321:     :rtype:",
          "322:         bool",
          "323:     \"\"\"",
          "324:     validated = is_valid(host, misc.HOST_MATCHER, require)",
          "327:     elif validated and host is not None and misc.IPv6_MATCHER.match(host):",
          "328:         return misc.IPv6_NO_RFC4007_MATCHER.match(host) is not None",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "396:     # If we can parse the authority into sub-components and we're not",
          "397:     # validating the port, we can assume it's valid.",
          "399:         return True",
          "401:     try:",
          "",
          "[Removed Lines]",
          "398:     if component != 'port':",
          "",
          "[Added Lines]",
          "418:     if component == 'host':",
          "419:         return host_is_valid(subauthority_dict['host'])",
          "420:     elif component != 'port':",
          "",
          "---------------"
        ],
        "src/urllib3/util/url.py||src/urllib3/util/url.py": [
          "File: src/urllib3/util/url.py -> src/urllib3/util/url.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: from ..exceptions import LocationParseError",
          "6: from ..packages import six, rfc3986",
          "10: url_attrs = ['scheme', 'auth', 'host', 'port', 'path', 'query', 'fragment']",
          "",
          "[Removed Lines]",
          "7: from ..packages.rfc3986.exceptions import RFC3986Exception",
          "",
          "[Added Lines]",
          "7: from ..packages.rfc3986.exceptions import RFC3986Exception, ValidationError",
          "8: from ..packages.rfc3986.validators import Validator",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "14: NORMALIZABLE_SCHEMES = ('http', 'https', None)",
          "16: # Regex for detecting URLs with schemes. RFC 3986 Section 3.1",
          "20: class Url(namedtuple('Url', url_attrs)):",
          "21:     \"\"\"",
          "23:     :func:`parse_url`. Both the scheme and host are normalized as they are",
          "24:     both case-insensitive according to RFC 3986.",
          "25:     \"\"\"",
          "",
          "[Removed Lines]",
          "17: SCHEME_REGEX = re.compile(r\"^[a-zA-Z][a-zA-Z0-9+\\-.]*://\")",
          "22:     Datastructure for representing an HTTP URL. Used as a return value for",
          "",
          "[Added Lines]",
          "18: SCHEME_REGEX = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+\\-]*:|/)\")",
          "23:     Data structure for representing an HTTP URL. Used as a return value for",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "29:                 query=None, fragment=None):",
          "30:         if path and not path.startswith('/'):",
          "31:             path = '/' + path",
          "33:             scheme = scheme.lower()",
          "36:         return super(Url, cls).__new__(cls, scheme, auth, host, port, path,",
          "37:                                        query, fragment)",
          "",
          "[Removed Lines]",
          "32:         if scheme:",
          "34:         if host and scheme in NORMALIZABLE_SCHEMES:",
          "35:             host = host.lower()",
          "",
          "[Added Lines]",
          "33:         if scheme is not None:",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "78:             'http://username:password@host.com:80/path?query#fragment'",
          "79:         \"\"\"",
          "80:         scheme, auth, host, port, path, query, fragment = self",
          "83:         # We use \"is not None\" we want things to happen with empty strings (or 0 port)",
          "84:         if scheme is not None:",
          "86:         if auth is not None:",
          "88:         if host is not None:",
          "89:             url += host",
          "90:         if port is not None:",
          "92:         if path is not None:",
          "93:             url += path",
          "94:         if query is not None:",
          "96:         if fragment is not None:",
          "99:         return url",
          "",
          "[Removed Lines]",
          "81:         url = ''",
          "85:             url += scheme + '://'",
          "87:             url += auth + '@'",
          "91:             url += ':' + str(port)",
          "95:             url += '?' + query",
          "97:             url += '#' + fragment",
          "",
          "[Added Lines]",
          "80:         url = u''",
          "84:             url += scheme + u'://'",
          "86:             url += auth + u'@'",
          "90:             url += u':' + str(port)",
          "94:             url += u'?' + query",
          "96:             url += u'#' + fragment",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "105: def split_first(s, delims):",
          "106:     \"\"\"",
          "109:     Given a string and an iterable of delimiters, split on the first found",
          "110:     delimiter. Return two split parts and the matched delimiter.",
          "",
          "[Removed Lines]",
          "107:     Deprecated. No longer used by parse_url().",
          "",
          "[Added Lines]",
          "106:     .. deprecated:: 1.25",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "161:         return Url()",
          "163:     is_string = not isinstance(url, six.binary_type)",
          "165:     # RFC 3986 doesn't like URLs that have a host but don't start",
          "166:     # with a scheme and we support URLs like that so we need to",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "163:     if not is_string:",
          "164:         url = url.decode(\"utf-8\")",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "171:         url = \"//\" + url",
          "173:     try:",
          "175:     except (ValueError, RFC3986Exception):",
          "176:         raise LocationParseError(url)",
          "182:     # For the sake of backwards compatibility we put empty",
          "183:     # string values for path if there are any defined values",
          "184:     # beyond the path in the URL.",
          "185:     # TODO: Remove this when we break backwards compatibility.",
          "187:     if not path:",
          "190:             path = \"\"",
          "191:         else:",
          "192:             path = None",
          "",
          "[Removed Lines]",
          "174:         parse_result = rfc3986.urlparse(url, encoding=\"utf-8\")",
          "178:     # RFC 3986 doesn't assert ports must be non-negative.",
          "179:     if parse_result.port and parse_result.port < 0:",
          "180:         raise LocationParseError(url)",
          "186:     path = parse_result.path",
          "188:         if (parse_result.query is not None",
          "189:                 or parse_result.fragment is not None):",
          "",
          "[Added Lines]",
          "175:         iri_ref = rfc3986.IRIReference.from_string(url, encoding=\"utf-8\")",
          "177:         six.raise_from(LocationParseError(url), None)",
          "179:     def idna_encode(name):",
          "180:         if name and any([ord(x) > 128 for x in name]):",
          "181:             try:",
          "182:                 import idna",
          "183:             except ImportError:",
          "184:                 raise LocationParseError(\"Unable to parse URL without the 'idna' module\")",
          "185:             try:",
          "186:                 return idna.encode(name, strict=True, std3_rules=True).lower()",
          "187:             except idna.IDNAError:",
          "188:                 raise LocationParseError(u\"Name '%s' is not a valid IDNA label\" % name)",
          "189:         return name",
          "191:     has_authority = iri_ref.authority is not None",
          "192:     uri_ref = iri_ref.encode(idna_encoder=idna_encode)",
          "194:     # rfc3986 strips the authority if it's invalid",
          "195:     if has_authority and uri_ref.authority is None:",
          "198:     # Only normalize schemes we understand to not break http+unix",
          "199:     # or other schemes that don't follow RFC 3986.",
          "200:     if uri_ref.scheme is None or uri_ref.scheme.lower() in NORMALIZABLE_SCHEMES:",
          "201:         uri_ref = uri_ref.normalize()",
          "203:     # Validate all URIReference components and ensure that all",
          "204:     # components that were set before are still set after",
          "205:     # normalization has completed.",
          "206:     validator = Validator()",
          "207:     try:",
          "208:         validator.check_validity_of(",
          "210:         ).validate(uri_ref)",
          "211:     except ValidationError:",
          "212:         six.raise_from(LocationParseError(url), None)",
          "218:     path = uri_ref.path",
          "220:         if (uri_ref.query is not None",
          "221:                 or uri_ref.fragment is not None):",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "201:         return x",
          "203:     return Url(",
          "208:         path=to_input_type(path),",
          "211:     )",
          "",
          "[Removed Lines]",
          "204:         scheme=to_input_type(parse_result.scheme),",
          "205:         auth=to_input_type(parse_result.userinfo),",
          "206:         host=to_input_type(parse_result.hostname),",
          "207:         port=parse_result.port,",
          "209:         query=to_input_type(parse_result.query),",
          "210:         fragment=to_input_type(parse_result.fragment)",
          "",
          "[Added Lines]",
          "236:         scheme=to_input_type(uri_ref.scheme),",
          "237:         auth=to_input_type(uri_ref.userinfo),",
          "238:         host=to_input_type(uri_ref.host),",
          "239:         port=int(uri_ref.port) if uri_ref.port is not None else None,",
          "241:         query=to_input_type(uri_ref.query),",
          "242:         fragment=to_input_type(uri_ref.fragment)",
          "",
          "---------------"
        ],
        "test/test_util.py||test/test_util.py": [
          "File: test/test_util.py -> test/test_util.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "131:         with pytest.raises(LocationParseError):",
          "132:             get_host(location)",
          "134:     @pytest.mark.parametrize('url, expected_normalized_url', [",
          "135:         ('HTTP://GOOGLE.COM/MAIL/', 'http://google.com/MAIL/'),",
          "136:         ('HTTP://JeremyCline:Hunter2@Example.com:8080/',",
          "137:          'http://JeremyCline:Hunter2@example.com:8080/'),",
          "138:         ('HTTPS://Example.Com/?Key=Value', 'https://example.com/?Key=Value'),",
          "139:         ('Https://Example.Com/#Fragment', 'https://example.com/#Fragment'),",
          "140:     ])",
          "141:     def test_parse_url_normalization(self, url, expected_normalized_url):",
          "142:         \"\"\"Assert parse_url normalizes the scheme/host, and only the scheme/host\"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "134:     @pytest.mark.parametrize('url', [",
          "135:         'http://user\\\\@google.com',",
          "136:         'http://google\\\\.com',",
          "137:         'user\\\\@google.com',",
          "138:         'http://google.com#fragment#',",
          "139:         'http://user@user@google.com/',",
          "140:     ])",
          "141:     def test_invalid_url(self, url):",
          "142:         with pytest.raises(LocationParseError):",
          "143:             parse_url(url)",
          "151:         ('[::Ff%etH0%Ff]/%ab%Af', '[::ff%25etH0%Ff]/%AB%AF'),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "155:         # Path/query/fragment",
          "156:         ('', Url()),",
          "157:         ('/', Url(path='/')),",
          "160:         ('/foo', Url(path='/foo')),",
          "161:         ('/foo?bar=baz', Url(path='/foo', query='bar=baz')),",
          "162:         ('/foo?bar=baz#banana?apple/orange', Url(path='/foo',",
          "",
          "[Removed Lines]",
          "158:         ('/abc/../def', Url(path=\"/abc/../def\")),",
          "159:         ('#?/!google.com/?foo#bar', Url(path='', fragment='?/!google.com/?foo#bar')),",
          "",
          "[Added Lines]",
          "170:         ('#?/!google.com/?foo', Url(path='', fragment='?/!google.com/?foo')),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "173:         # Auth",
          "174:         ('http://foo:bar@localhost/', Url('http', auth='foo:bar', host='localhost', path='/')),",
          "175:         ('http://foo@localhost/', Url('http', auth='foo', host='localhost', path='/')),",
          "181:         # Unicode type (Python 2.x)",
          "182:         (u'http://foo:bar@localhost/', Url(u'http',",
          "",
          "[Removed Lines]",
          "176:         ('http://foo:bar@baz@localhost/', Url('http',",
          "177:                                               auth='foo:bar@baz',",
          "178:                                               host='localhost',",
          "179:                                               path='/')),",
          "",
          "[Added Lines]",
          "187:         ('http://foo:bar@localhost/', Url('http',",
          "188:                                           auth='foo:bar',",
          "189:                                           host='localhost',",
          "190:                                           path='/')),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "194:         ('?', Url(path='', query='')),",
          "195:         ('#', Url(path='', fragment='')),",
          "197:         # Empty Port",
          "198:         ('http://google.com:', Url('http', host='google.com')),",
          "199:         ('http://google.com:/', Url('http', host='google.com', path='/')),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "208:         # Path normalization",
          "209:         ('/abc/../def', Url(path=\"/def\")),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "211:     def test_unparse_url(self, url, expected_url):",
          "212:         assert url == expected_url.url",
          "214:     def test_parse_url_invalid_IPv6(self):",
          "215:         with pytest.raises(LocationParseError):",
          "216:             parse_url('[::1')",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "228:     @pytest.mark.parametrize(",
          "229:         ['url', 'expected_url'],",
          "230:         [",
          "231:             # RFC 3986 5.2.4",
          "232:             ('/abc/../def', Url(path=\"/def\")),",
          "233:             ('/..', Url(path=\"/\")),",
          "234:             ('/./abc/./def/', Url(path='/abc/def/')),",
          "235:             ('/.', Url(path='/')),",
          "236:             ('/./', Url(path='/')),",
          "237:             ('/abc/./.././d/././e/.././f/./../../ghi', Url(path='/ghi'))",
          "238:         ]",
          "239:     )",
          "240:     def test_parse_and_normalize_url_paths(self, url, expected_url):",
          "241:         actual_url = parse_url(url)",
          "242:         assert actual_url == expected_url",
          "243:         assert actual_url.url == expected_url.url",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "261:         # CVE-2016-5699",
          "262:         (\"http://127.0.0.1%0d%0aConnection%3a%20keep-alive\",",
          "265:         # NodeJS unicode -> double dot",
          "266:         (u\"http://google.com/\\uff2e\\uff2e/abc\", Url(\"http\",",
          "267:                                                     host=\"google.com\",",
          "269:     ]",
          "271:     @pytest.mark.parametrize(\"url, expected_url\", url_vulnerabilities)",
          "",
          "[Removed Lines]",
          "263:          Url(\"http\", host=\"127.0.0.1%0d%0aConnection%3a%20keep-alive\")),",
          "268:                                                     path='/%ef%bc%ae%ef%bc%ae/abc'))",
          "",
          "[Added Lines]",
          "294:          Url(\"http\", host=\"127.0.0.1%0d%0aconnection%3a%20keep-alive\")),",
          "299:                                                     path='/%EF%BC%AE%EF%BC%AE/abc')),",
          "301:         # Scheme without ://",
          "302:         (\"javascript:a='@google.com:12345/';alert(0)\",",
          "303:          Url(scheme=\"javascript\",",
          "304:              path=\"a='@google.com:12345/';alert(0)\")),",
          "306:         (\"//google.com/a/b/c\", Url(host=\"google.com\", path=\"/a/b/c\")),",
          "308:         # International URLs",
          "309:         (u'http://\u30d2:\u30ad@\u30d2.abc.\u30cb/\u30d2?\u30ad#\u30ef', Url(u'http',",
          "310:                                           host=u'xn--pdk.abc.xn--idk',",
          "311:                                           auth=u'%E3%83%92:%E3%82%AD',",
          "312:                                           path=u'/%E3%83%92',",
          "313:                                           query=u'%E3%82%AD',",
          "314:                                           fragment=u'%E3%83%AF')),",
          "316:         # Injected headers (CVE-2016-5699, CVE-2019-9740, CVE-2019-9947)",
          "317:         (\"10.251.0.83:7777?a=1 HTTP/1.1\\r\\nX-injected: header\",",
          "318:          Url(host='10.251.0.83', port=7777, path='',",
          "319:              query='a=1%20HTTP/1.1%0D%0AX-injected:%20header')),",
          "321:         (\"http://127.0.0.1:6379?\\r\\nSET test failure12\\r\\n:8080/test/?test=a\",",
          "322:          Url(scheme='http', host='127.0.0.1', port=6379, path='',",
          "323:              query='%0D%0ASET%20test%20failure12%0D%0A:8080/test/?test=a')),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9167b58128dbfe3ddcbab253166697348d8d364c",
      "candidate_info": {
        "commit_hash": "9167b58128dbfe3ddcbab253166697348d8d364c",
        "repo": "urllib3/urllib3",
        "commit_url": "https://github.com/urllib3/urllib3/commit/9167b58128dbfe3ddcbab253166697348d8d364c",
        "files": [
          "src/urllib3/util/url.py",
          "test/test_util.py"
        ],
        "message": "Don't percent encode tilde character (#1692)",
        "before_after_code_files": [
          "src/urllib3/util/url.py||src/urllib3/util/url.py",
          "test/test_util.py||test/test_util.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/urllib3/util/url.py||src/urllib3/util/url.py",
            "test/test_util.py||test/test_util.py"
          ],
          "candidate": [
            "src/urllib3/util/url.py||src/urllib3/util/url.py",
            "test/test_util.py||test/test_util.py"
          ]
        }
      },
      "candidate_diff": {
        "src/urllib3/util/url.py||src/urllib3/util/url.py": [
          "File: src/urllib3/util/url.py -> src/urllib3/util/url.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "50:     \"(?:(?:%(hex)s:){0,6}%(hex)s)?::\",",
          "51: ]",
          "54: IPV6_PAT = \"(?:\" + \"|\".join([x % _subs for x in _variations]) + \")\"",
          "55: ZONE_ID_PAT = \"(?:%25|%)(?:[\" + UNRESERVED_PAT + \"]|%[a-fA-F0-9]{2})+\"",
          "56: IPV6_ADDRZ_PAT = r\"\\[\" + IPV6_PAT + r\"(?:\" + ZONE_ID_PAT + r\")?\\]\"",
          "",
          "[Removed Lines]",
          "53: UNRESERVED_PAT = r\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._!\\-\"",
          "",
          "[Added Lines]",
          "53: UNRESERVED_PAT = r\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._!\\-~\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63: BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + IPV6_ADDRZ_PAT[2:-2] + \"$\")",
          "64: ZONE_ID_RE = re.compile(\"(\" + ZONE_ID_PAT + r\")\\]$\")",
          "67:     REG_NAME_PAT,",
          "68:     IPV4_PAT,",
          "69:     IPV6_ADDRZ_PAT,",
          "70: )",
          "71: SUBAUTHORITY_RE = re.compile(SUBAUTHORITY_PAT, re.UNICODE | re.DOTALL)",
          "75: )",
          "77: PATH_CHARS = USERINFO_CHARS | {\"@\", \"/\"}",
          "78: QUERY_CHARS = FRAGMENT_CHARS = PATH_CHARS | {\"?\"}",
          "",
          "[Removed Lines]",
          "66: SUBAUTHORITY_PAT = (u\"^(?:(.*)@)?\" u\"(%s|%s|%s)\" u\"(?::([0-9]{0,5}))?$\") % (",
          "73: ZONE_ID_CHARS = set(",
          "74:     \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"abcdefghijklmnopqrstuvwxyz\" \"0123456789._!-\"",
          "76: USERINFO_CHARS = ZONE_ID_CHARS | set(\"$&'()*+,;=:\")",
          "",
          "[Added Lines]",
          "66: SUBAUTHORITY_PAT = (u\"^(?:(.*)@)?(%s|%s|%s)(?::([0-9]{0,5}))?$\") % (",
          "73: UNRESERVED_CHARS = set(",
          "74:     \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"",
          "76: SUB_DELIM_CHARS = set(\"!$&'()*+,;=\")",
          "77: USERINFO_CHARS = UNRESERVED_CHARS | SUB_DELIM_CHARS | {\":\"}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "290:                         zone_id = zone_id[3:]",
          "291:                     else:",
          "292:                         zone_id = zone_id[1:]",
          "294:                     return host[:start].lower() + zone_id + host[end:]",
          "295:                 else:",
          "296:                     return host.lower()",
          "",
          "[Removed Lines]",
          "293:                     zone_id = \"%\" + _encode_invalid_chars(zone_id, ZONE_ID_CHARS)",
          "",
          "[Added Lines]",
          "294:                     zone_id = \"%\" + _encode_invalid_chars(zone_id, UNRESERVED_CHARS)",
          "",
          "---------------"
        ],
        "test/test_util.py||test/test_util.py": [
          "File: test/test_util.py -> test/test_util.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "170:         \"url, expected_normalized_url\",",
          "171:         [",
          "172:             (\"HTTP://GOOGLE.COM/MAIL/\", \"http://google.com/MAIL/\"),",
          "173:             (",
          "174:                 \"HTTP://JeremyCline:Hunter2@Example.com:8080/\",",
          "175:                 \"http://JeremyCline:Hunter2@example.com:8080/\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "173:             (",
          "174:                 \"http://user@domain.com:password@example.com/~tilde@?@\",",
          "175:                 \"http://user%40domain.com:password@example.com/~tilde@?@\",",
          "176:             ),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5b047b645f5f93900d5e2fc31230848c25eb1f5f",
      "candidate_info": {
        "commit_hash": "5b047b645f5f93900d5e2fc31230848c25eb1f5f",
        "repo": "urllib3/urllib3",
        "commit_url": "https://github.com/urllib3/urllib3/commit/5b047b645f5f93900d5e2fc31230848c25eb1f5f",
        "files": [
          "CHANGES.rst",
          "_travis/upload_coverage.sh",
          "noxfile.py",
          "setup.py",
          "src/urllib3/connectionpool.py",
          "src/urllib3/packages/rfc3986/__init__.py",
          "src/urllib3/packages/rfc3986/_mixin.py",
          "src/urllib3/packages/rfc3986/abnf_regexp.py",
          "src/urllib3/packages/rfc3986/api.py",
          "src/urllib3/packages/rfc3986/builder.py",
          "src/urllib3/packages/rfc3986/compat.py",
          "src/urllib3/packages/rfc3986/exceptions.py",
          "src/urllib3/packages/rfc3986/iri.py",
          "src/urllib3/packages/rfc3986/misc.py",
          "src/urllib3/packages/rfc3986/normalizers.py",
          "src/urllib3/packages/rfc3986/parseresult.py",
          "src/urllib3/packages/rfc3986/uri.py",
          "src/urllib3/packages/rfc3986/validators.py",
          "src/urllib3/packages/six.py",
          "src/urllib3/util/ssl_.py",
          "src/urllib3/util/url.py",
          "test/test_util.py"
        ],
        "message": "Percent-encode invalid characters within auth section (#1647)",
        "before_after_code_files": [
          "_travis/upload_coverage.sh||_travis/upload_coverage.sh",
          "noxfile.py||noxfile.py",
          "setup.py||setup.py",
          "src/urllib3/connectionpool.py||src/urllib3/connectionpool.py",
          "src/urllib3/packages/rfc3986/__init__.py||src/urllib3/packages/rfc3986/__init__.py",
          "src/urllib3/packages/rfc3986/_mixin.py||src/urllib3/packages/rfc3986/_mixin.py",
          "src/urllib3/packages/rfc3986/abnf_regexp.py||src/urllib3/packages/rfc3986/abnf_regexp.py",
          "src/urllib3/packages/rfc3986/api.py||src/urllib3/packages/rfc3986/api.py",
          "src/urllib3/packages/rfc3986/builder.py||src/urllib3/packages/rfc3986/builder.py",
          "src/urllib3/packages/rfc3986/compat.py||src/urllib3/packages/rfc3986/compat.py",
          "src/urllib3/packages/rfc3986/exceptions.py||src/urllib3/packages/rfc3986/exceptions.py",
          "src/urllib3/packages/rfc3986/iri.py||src/urllib3/packages/rfc3986/iri.py",
          "src/urllib3/packages/rfc3986/misc.py||src/urllib3/packages/rfc3986/misc.py",
          "src/urllib3/packages/rfc3986/normalizers.py||src/urllib3/packages/rfc3986/normalizers.py",
          "src/urllib3/packages/rfc3986/parseresult.py||src/urllib3/packages/rfc3986/parseresult.py",
          "src/urllib3/packages/rfc3986/uri.py||src/urllib3/packages/rfc3986/uri.py",
          "src/urllib3/packages/rfc3986/validators.py||src/urllib3/packages/rfc3986/validators.py",
          "src/urllib3/packages/six.py||src/urllib3/packages/six.py",
          "src/urllib3/util/ssl_.py||src/urllib3/util/ssl_.py",
          "src/urllib3/util/url.py||src/urllib3/util/url.py",
          "test/test_util.py||test/test_util.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/urllib3/util/url.py||src/urllib3/util/url.py",
            "test/test_util.py||test/test_util.py"
          ],
          "candidate": [
            "src/urllib3/util/url.py||src/urllib3/util/url.py",
            "test/test_util.py||test/test_util.py"
          ]
        }
      },
      "candidate_diff": {
        "_travis/upload_coverage.sh||_travis/upload_coverage.sh": [
          "File: _travis/upload_coverage.sh -> _travis/upload_coverage.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: set -exo pipefail",
          "5: if [[ -e .coverage ]]; then",
          "8: fi",
          "",
          "[Removed Lines]",
          "6:     python3.6 -m pip install codecov",
          "7:     python3.6 -m codecov --env TRAVIS_OS_NAME,NOX_SESSION",
          "",
          "[Added Lines]",
          "6:     python3 -m pip install codecov",
          "7:     python3 -m codecov --env TRAVIS_OS_NAME,NOX_SESSION",
          "",
          "---------------"
        ],
        "noxfile.py||noxfile.py": [
          "File: noxfile.py -> noxfile.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "77:     session.install(\"black\")",
          "78:     session.run(\"black\", \"src\", \"dummyserver\", \"test\", \"noxfile.py\", \"setup.py\")",
          "81: @nox.session",
          "82: def lint(session):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "80:     lint(session)",
          "",
          "---------------"
        ],
        "setup.py||setup.py": [
          "File: setup.py -> setup.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:         \"urllib3.packages\",",
          "58:         \"urllib3.packages.ssl_match_hostname\",",
          "59:         \"urllib3.packages.backports\",",
          "61:         \"urllib3.contrib\",",
          "62:         \"urllib3.contrib._securetransport\",",
          "63:         \"urllib3.util\",",
          "",
          "[Removed Lines]",
          "60:         \"urllib3.packages.rfc3986\",",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/urllib3/connectionpool.py||src/urllib3/connectionpool.py": [
          "File: src/urllib3/connectionpool.py -> src/urllib3/connectionpool.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: from .packages.ssl_match_hostname import CertificateError",
          "27: from .packages import six",
          "28: from .packages.six.moves import queue",
          "30: from .connection import (",
          "31:     port_by_scheme,",
          "32:     DummyConnection,",
          "",
          "[Removed Lines]",
          "29: from .packages.rfc3986.normalizers import normalize_host",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44: from .util.response import assert_header_parsing",
          "45: from .util.retry import Retry",
          "46: from .util.timeout import Timeout",
          "48: from .util.queue import LifoQueue",
          "",
          "[Removed Lines]",
          "47: from .util.url import get_host, Url, NORMALIZABLE_SCHEMES",
          "",
          "[Added Lines]",
          "46: from .util.url import get_host, Url, _normalize_host as normalize_host",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1027:     Normalize hosts for comparisons and use with sockets.",
          "1028:     \"\"\"",
          "1030:     # httplib doesn't like it when we include brackets in IPv6 addresses",
          "1031:     # Specifically, if we include brackets but also pass the port then",
          "1032:     # httplib crazily doubles up the square brackets on the Host header.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1029:     host = normalize_host(host, scheme)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1034:     # However, for backward compatibility reasons we can't actually",
          "1035:     # *assert* that.  See http://bugs.python.org/issue28539",
          "1036:     if host.startswith(\"[\") and host.endswith(\"]\"):",
          "1040:     return host",
          "",
          "[Removed Lines]",
          "1037:         host = host.strip(\"[]\")",
          "1038:     if scheme in NORMALIZABLE_SCHEMES:",
          "1039:         host = normalize_host(host)",
          "",
          "[Added Lines]",
          "1038:         host = host[1:-1]",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/__init__.py||src/urllib3/packages/rfc3986/__init__.py": [
          "File: src/urllib3/packages/rfc3986/__init__.py -> src/urllib3/packages/rfc3986/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/_mixin.py||src/urllib3/packages/rfc3986/_mixin.py": [
          "File: src/urllib3/packages/rfc3986/_mixin.py -> src/urllib3/packages/rfc3986/_mixin.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/abnf_regexp.py||src/urllib3/packages/rfc3986/abnf_regexp.py": [
          "File: src/urllib3/packages/rfc3986/abnf_regexp.py -> src/urllib3/packages/rfc3986/abnf_regexp.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/api.py||src/urllib3/packages/rfc3986/api.py": [
          "File: src/urllib3/packages/rfc3986/api.py -> src/urllib3/packages/rfc3986/api.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/builder.py||src/urllib3/packages/rfc3986/builder.py": [
          "File: src/urllib3/packages/rfc3986/builder.py -> src/urllib3/packages/rfc3986/builder.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/compat.py||src/urllib3/packages/rfc3986/compat.py": [
          "File: src/urllib3/packages/rfc3986/compat.py -> src/urllib3/packages/rfc3986/compat.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/exceptions.py||src/urllib3/packages/rfc3986/exceptions.py": [
          "File: src/urllib3/packages/rfc3986/exceptions.py -> src/urllib3/packages/rfc3986/exceptions.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/iri.py||src/urllib3/packages/rfc3986/iri.py": [
          "File: src/urllib3/packages/rfc3986/iri.py -> src/urllib3/packages/rfc3986/iri.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/misc.py||src/urllib3/packages/rfc3986/misc.py": [
          "File: src/urllib3/packages/rfc3986/misc.py -> src/urllib3/packages/rfc3986/misc.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/normalizers.py||src/urllib3/packages/rfc3986/normalizers.py": [
          "File: src/urllib3/packages/rfc3986/normalizers.py -> src/urllib3/packages/rfc3986/normalizers.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/parseresult.py||src/urllib3/packages/rfc3986/parseresult.py": [
          "File: src/urllib3/packages/rfc3986/parseresult.py -> src/urllib3/packages/rfc3986/parseresult.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/uri.py||src/urllib3/packages/rfc3986/uri.py": [
          "File: src/urllib3/packages/rfc3986/uri.py -> src/urllib3/packages/rfc3986/uri.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/urllib3/packages/rfc3986/validators.py||src/urllib3/packages/rfc3986/validators.py": [
          "File: src/urllib3/packages/rfc3986/validators.py -> src/urllib3/packages/rfc3986/validators.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/urllib3/packages/six.py||src/urllib3/packages/six.py": [
          "File: src/urllib3/packages/six.py -> src/urllib3/packages/six.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #",
          "5: # Permission is hereby granted, free of charge, to any person obtaining a copy",
          "6: # of this software and associated documentation files (the \"Software\"), to deal",
          "",
          "[Removed Lines]",
          "1: \"\"\"Utilities for writing code that runs on Python 2 and 3\"\"\"",
          "3: # Copyright (c) 2010-2015 Benjamin Peterson",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2010-2019 Benjamin Peterson",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "20: # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE",
          "21: # SOFTWARE.",
          "23: from __future__ import absolute_import",
          "25: import functools",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: \"\"\"Utilities for writing code that runs on Python 2 and 3\"\"\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "29: import types",
          "31: __author__ = \"Benjamin Peterson <benjamin@python.org>\"",
          "35: # Useful for very coarse version differentiation.",
          "",
          "[Removed Lines]",
          "32: __version__ = \"1.10.0\"",
          "",
          "[Added Lines]",
          "32: __version__ = \"1.12.0\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "242:     MovedAttribute(\"map\", \"itertools\", \"builtins\", \"imap\", \"map\"),",
          "243:     MovedAttribute(\"getcwd\", \"os\", \"os\", \"getcwdu\", \"getcwd\"),",
          "244:     MovedAttribute(\"getcwdb\", \"os\", \"os\", \"getcwd\", \"getcwdb\"),",
          "245:     MovedAttribute(\"range\", \"__builtin__\", \"builtins\", \"xrange\", \"range\"),",
          "246:     MovedAttribute(",
          "247:         \"reload_module\", \"__builtin__\", \"importlib\" if PY34 else \"imp\", \"reload\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "245:     MovedAttribute(\"getoutput\", \"commands\", \"subprocess\"),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "267:     MovedModule(\"html_entities\", \"htmlentitydefs\", \"html.entities\"),",
          "268:     MovedModule(\"html_parser\", \"HTMLParser\", \"html.parser\"),",
          "269:     MovedModule(\"http_client\", \"httplib\", \"http.client\"),",
          "270:     MovedModule(\"email_mime_multipart\", \"email.MIMEMultipart\", \"email.mime.multipart\"),",
          "271:     MovedModule(",
          "272:         \"email_mime_nonmultipart\", \"email.MIMENonMultipart\", \"email.mime.nonmultipart\"",
          "273:     ),",
          "274:     MovedModule(\"email_mime_text\", \"email.MIMEText\", \"email.mime.text\"),",
          "276:     MovedModule(\"BaseHTTPServer\", \"BaseHTTPServer\", \"http.server\"),",
          "277:     MovedModule(\"CGIHTTPServer\", \"CGIHTTPServer\", \"http.server\"),",
          "278:     MovedModule(\"SimpleHTTPServer\", \"SimpleHTTPServer\", \"http.server\"),",
          "",
          "[Removed Lines]",
          "275:     MovedModule(\"email_mime_base\", \"email.MIMEBase\", \"email.mime.base\"),",
          "",
          "[Added Lines]",
          "271:     MovedModule(\"email_mime_base\", \"email.MIMEBase\", \"email.mime.base\"),",
          "272:     MovedModule(\"email_mime_image\", \"email.MIMEImage\", \"email.mime.image\"),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "339:     MovedAttribute(\"quote_plus\", \"urllib\", \"urllib.parse\"),",
          "340:     MovedAttribute(\"unquote\", \"urllib\", \"urllib.parse\"),",
          "341:     MovedAttribute(\"unquote_plus\", \"urllib\", \"urllib.parse\"),",
          "342:     MovedAttribute(\"urlencode\", \"urllib\", \"urllib.parse\"),",
          "343:     MovedAttribute(\"splitquery\", \"urllib\", \"urllib.parse\"),",
          "344:     MovedAttribute(\"splittag\", \"urllib\", \"urllib.parse\"),",
          "345:     MovedAttribute(\"splituser\", \"urllib\", \"urllib.parse\"),",
          "346:     MovedAttribute(\"uses_fragment\", \"urlparse\", \"urllib.parse\"),",
          "347:     MovedAttribute(\"uses_netloc\", \"urlparse\", \"urllib.parse\"),",
          "348:     MovedAttribute(\"uses_params\", \"urlparse\", \"urllib.parse\"),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "344:     MovedAttribute(",
          "345:         \"unquote_to_bytes\", \"urllib\", \"urllib.parse\", \"unquote\", \"unquote_to_bytes\"",
          "346:     ),",
          "351:     MovedAttribute(\"splitvalue\", \"urllib\", \"urllib.parse\"),",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "424:     MovedAttribute(\"URLopener\", \"urllib\", \"urllib.request\"),",
          "425:     MovedAttribute(\"FancyURLopener\", \"urllib\", \"urllib.request\"),",
          "426:     MovedAttribute(\"proxy_bypass\", \"urllib\", \"urllib.request\"),",
          "427: ]",
          "428: for attr in _urllib_request_moved_attributes:",
          "429:     setattr(Module_six_moves_urllib_request, attr.name, attr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "433:     MovedAttribute(\"parse_http_list\", \"urllib2\", \"urllib.request\"),",
          "434:     MovedAttribute(\"parse_keqv_list\", \"urllib2\", \"urllib.request\"),",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "666:     StringIO = io.StringIO",
          "667:     BytesIO = io.BytesIO",
          "668:     _assertCountEqual = \"assertCountEqual\"",
          "669:     if sys.version_info[1] <= 1:",
          "670:         _assertRaisesRegex = \"assertRaisesRegexp\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "676:     del io",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "718:     exec_ = getattr(moves.builtins, \"exec\")",
          "720:     def reraise(tp, value, tb=None):",
          "728: else:",
          "",
          "[Removed Lines]",
          "721:         if value is None:",
          "722:             value = tp()",
          "723:         if value.__traceback__ is not tb:",
          "724:             raise value.with_traceback(tb)",
          "725:         raise value",
          "",
          "[Added Lines]",
          "730:         try:",
          "731:             if value is None:",
          "732:                 value = tp()",
          "733:             if value.__traceback__ is not tb:",
          "734:                 raise value.with_traceback(tb)",
          "735:             raise value",
          "736:         finally:",
          "737:             value = None",
          "738:             tb = None",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "742:     exec_(",
          "743:         \"\"\"def reraise(tp, value, tb=None):",
          "745: \"\"\"",
          "746:     )",
          "",
          "[Removed Lines]",
          "744:     raise tp, value, tb",
          "",
          "[Added Lines]",
          "757:     try:",
          "758:         raise tp, value, tb",
          "759:     finally:",
          "760:         tb = None",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "749: if sys.version_info[:2] == (3, 2):",
          "750:     exec_(",
          "751:         \"\"\"def raise_from(value, from_value):",
          "755: \"\"\"",
          "756:     )",
          "757: elif sys.version_info[:2] > (3, 2):",
          "758:     exec_(",
          "759:         \"\"\"def raise_from(value, from_value):",
          "761: \"\"\"",
          "762:     )",
          "763: else:",
          "",
          "[Removed Lines]",
          "752:     if from_value is None:",
          "753:         raise value",
          "754:     raise value from from_value",
          "760:     raise value from from_value",
          "",
          "[Added Lines]",
          "768:     try:",
          "769:         if from_value is None:",
          "770:             raise value",
          "771:         raise value from from_value",
          "772:     finally:",
          "773:         value = None",
          "779:     try:",
          "780:         raise value from from_value",
          "781:     finally:",
          "782:         value = None",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "864:     # This requires a bit of explanation: the basic idea is to make a dummy",
          "865:     # metaclass for one level of class instantiation that replaces itself with",
          "866:     # the actual metaclass.",
          "868:         def __new__(cls, name, this_bases, d):",
          "869:             return meta(name, bases, d)",
          "871:     return type.__new__(metaclass, \"temporary_class\", (), {})",
          "",
          "[Removed Lines]",
          "867:     class metaclass(meta):",
          "",
          "[Added Lines]",
          "889:     class metaclass(type):",
          "893:         @classmethod",
          "894:         def __prepare__(cls, name, this_bases):",
          "895:             return meta.__prepare__(name, bases)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "884:                 orig_vars.pop(slots_var)",
          "885:         orig_vars.pop(\"__dict__\", None)",
          "886:         orig_vars.pop(\"__weakref__\", None)",
          "887:         return metaclass(cls.__name__, cls.__bases__, orig_vars)",
          "889:     return wrapper",
          "892: def python_2_unicode_compatible(klass):",
          "893:     \"\"\"",
          "894:     A decorator that defines __unicode__ and __str__ methods under Python 2.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "913:         if hasattr(cls, \"__qualname__\"):",
          "914:             orig_vars[\"__qualname__\"] = cls.__qualname__",
          "920: def ensure_binary(s, encoding=\"utf-8\", errors=\"strict\"):",
          "921:     \"\"\"Coerce **s** to six.binary_type.",
          "923:     For Python 2:",
          "924:       - `unicode` -> encoded to `str`",
          "925:       - `str` -> `str`",
          "927:     For Python 3:",
          "928:       - `str` -> encoded to `bytes`",
          "929:       - `bytes` -> `bytes`",
          "930:     \"\"\"",
          "931:     if isinstance(s, text_type):",
          "932:         return s.encode(encoding, errors)",
          "933:     elif isinstance(s, binary_type):",
          "934:         return s",
          "935:     else:",
          "936:         raise TypeError(\"not expecting type '%s'\" % type(s))",
          "939: def ensure_str(s, encoding=\"utf-8\", errors=\"strict\"):",
          "940:     \"\"\"Coerce *s* to `str`.",
          "942:     For Python 2:",
          "943:       - `unicode` -> encoded to `str`",
          "944:       - `str` -> `str`",
          "946:     For Python 3:",
          "947:       - `str` -> `str`",
          "948:       - `bytes` -> decoded to `str`",
          "949:     \"\"\"",
          "950:     if not isinstance(s, (text_type, binary_type)):",
          "951:         raise TypeError(\"not expecting type '%s'\" % type(s))",
          "952:     if PY2 and isinstance(s, text_type):",
          "953:         s = s.encode(encoding, errors)",
          "954:     elif PY3 and isinstance(s, binary_type):",
          "955:         s = s.decode(encoding, errors)",
          "956:     return s",
          "959: def ensure_text(s, encoding=\"utf-8\", errors=\"strict\"):",
          "960:     \"\"\"Coerce *s* to six.text_type.",
          "962:     For Python 2:",
          "963:       - `unicode` -> `unicode`",
          "964:       - `str` -> `unicode`",
          "966:     For Python 3:",
          "967:       - `str` -> `str`",
          "968:       - `bytes` -> decoded to `str`",
          "969:     \"\"\"",
          "970:     if isinstance(s, binary_type):",
          "971:         return s.decode(encoding, errors)",
          "972:     elif isinstance(s, text_type):",
          "973:         return s",
          "974:     else:",
          "975:         raise TypeError(\"not expecting type '%s'\" % type(s))",
          "",
          "---------------"
        ],
        "src/urllib3/util/ssl_.py||src/urllib3/util/ssl_.py": [
          "File: src/urllib3/util/ssl_.py -> src/urllib3/util/ssl_.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: import errno",
          "3: import warnings",
          "4: import hmac",
          "7: from binascii import hexlify, unhexlify",
          "8: from hashlib import md5, sha1, sha256",
          "10: from ..exceptions import SSLError, InsecurePlatformWarning, SNIMissingWarning",
          "11: from ..packages import six",
          "15: SSLContext = None",
          "",
          "[Removed Lines]",
          "5: import re",
          "12: from ..packages.rfc3986 import abnf_regexp",
          "",
          "[Added Lines]",
          "9: from .url import IPV4_RE, BRACELESS_IPV6_ADDRZ_RE",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37: _const_compare_digest = getattr(hmac, \"compare_digest\", _const_compare_digest_backport)",
          "46: try:  # Test for SSL features",
          "47:     import ssl",
          "48:     from ssl import wrap_socket, CERT_REQUIRED",
          "",
          "[Removed Lines]",
          "39: # Borrow rfc3986's regular expressions for IPv4",
          "40: # and IPv6 addresses for use in is_ipaddress()",
          "41: _IP_ADDRESS_REGEX = re.compile(",
          "42:     r\"^(?:%s|%s|%s)$\"",
          "43:     % (abnf_regexp.IPv4_RE, abnf_regexp.IPv6_RE, abnf_regexp.IPv6_ADDRZ_RFC4007_RE)",
          "44: )",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "389:     if six.PY3 and isinstance(hostname, bytes):",
          "390:         # IDN A-label bytes are ASCII compatible.",
          "391:         hostname = hostname.decode(\"ascii\")",
          "395: def _is_key_file_encrypted(key_file):",
          "",
          "[Removed Lines]",
          "392:     return _IP_ADDRESS_REGEX.match(hostname) is not None",
          "",
          "[Added Lines]",
          "384:     return bool(IPV4_RE.match(hostname) or BRACELESS_IPV6_ADDRZ_RE.match(hostname))",
          "",
          "---------------"
        ],
        "src/urllib3/util/url.py||src/urllib3/util/url.py": [
          "File: src/urllib3/util/url.py -> src/urllib3/util/url.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: from collections import namedtuple",
          "5: from ..exceptions import LocationParseError",
          "12: url_attrs = [\"scheme\", \"auth\", \"host\", \"port\", \"path\", \"query\", \"fragment\"]",
          "",
          "[Removed Lines]",
          "6: from ..packages import six, rfc3986",
          "7: from ..packages.rfc3986.exceptions import RFC3986Exception, ValidationError",
          "8: from ..packages.rfc3986.validators import Validator",
          "9: from ..packages.rfc3986 import abnf_regexp, normalizers, compat, misc",
          "",
          "[Added Lines]",
          "6: from ..packages import six",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "15: # urllib3 infers URLs without a scheme (None) to be http.",
          "16: NORMALIZABLE_SCHEMES = (\"http\", \"https\", None)",
          "23: )",
          "24: QUERY_CHARS = FRAGMENT_CHARS = PATH_CHARS | {\"?\"}",
          "",
          "[Removed Lines]",
          "18: # Regex for detecting URLs with schemes. RFC 3986 Section 3.1",
          "19: SCHEME_REGEX = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+\\-]*:|/)\")",
          "21: PATH_CHARS = (",
          "22:     abnf_regexp.UNRESERVED_CHARS_SET | abnf_regexp.SUB_DELIMITERS_SET | {\":\", \"@\", \"/\"}",
          "",
          "[Added Lines]",
          "15: # Almost all of these patterns were derived from the",
          "16: # 'rfc3986' module: https://github.com/python-hyper/rfc3986",
          "17: PERCENT_RE = re.compile(r\"%[a-fA-F0-9]{2}\")",
          "18: SCHEME_RE = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)\")",
          "19: URI_RE = re.compile(",
          "20:     r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"",
          "21:     r\"(?://([^/?#]*))?\"",
          "22:     r\"([^?#]*)\"",
          "23:     r\"(?:\\?([^#]*))?\"",
          "24:     r\"(?:#(.*))?$\",",
          "25:     re.UNICODE | re.DOTALL,",
          "26: )",
          "28: IPV4_PAT = r\"(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\"",
          "29: HEX_PAT = \"[0-9A-Fa-f]{1,4}\"",
          "30: LS32_PAT = \"(?:{hex}:{hex}|{ipv4})\".format(hex=HEX_PAT, ipv4=IPV4_PAT)",
          "31: _subs = {\"hex\": HEX_PAT, \"ls32\": LS32_PAT}",
          "32: _variations = [",
          "33:     #                            6( h16 \":\" ) ls32",
          "34:     \"(?:%(hex)s:){6}%(ls32)s\",",
          "35:     #                       \"::\" 5( h16 \":\" ) ls32",
          "36:     \"::(?:%(hex)s:){5}%(ls32)s\",",
          "37:     # [               h16 ] \"::\" 4( h16 \":\" ) ls32",
          "38:     \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",",
          "39:     # [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32",
          "40:     \"(?:(?:%(hex)s:)?%(hex)s)?::(?:%(hex)s:){3}%(ls32)s\",",
          "41:     # [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32",
          "42:     \"(?:(?:%(hex)s:){0,2}%(hex)s)?::(?:%(hex)s:){2}%(ls32)s\",",
          "43:     # [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32",
          "44:     \"(?:(?:%(hex)s:){0,3}%(hex)s)?::%(hex)s:%(ls32)s\",",
          "45:     # [ *4( h16 \":\" ) h16 ] \"::\"              ls32",
          "46:     \"(?:(?:%(hex)s:){0,4}%(hex)s)?::%(ls32)s\",",
          "47:     # [ *5( h16 \":\" ) h16 ] \"::\"              h16",
          "48:     \"(?:(?:%(hex)s:){0,5}%(hex)s)?::%(hex)s\",",
          "49:     # [ *6( h16 \":\" ) h16 ] \"::\"",
          "50:     \"(?:(?:%(hex)s:){0,6}%(hex)s)?::\",",
          "51: ]",
          "53: UNRESERVED_PAT = r\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._!\\-\"",
          "54: IPV6_PAT = \"(?:\" + \"|\".join([x % _subs for x in _variations]) + \")\"",
          "55: ZONE_ID_PAT = \"(?:%25|%)(?:[\" + UNRESERVED_PAT + \"]|%[a-fA-F0-9]{2})+\"",
          "56: IPV6_ADDRZ_PAT = r\"\\[\" + IPV6_PAT + r\"(?:\" + ZONE_ID_PAT + r\")?\\]\"",
          "57: REG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"",
          "59: IPV4_RE = re.compile(\"^\" + IPV4_PAT + \"$\")",
          "60: IPV6_RE = re.compile(\"^\" + IPV6_PAT + \"$\")",
          "61: IPV6_ADDRZ_RE = re.compile(\"^\" + IPV6_ADDRZ_PAT + \"$\")",
          "62: BRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + IPV6_ADDRZ_PAT[2:-2] + \"$\")",
          "63: ZONE_ID_RE = re.compile(\"(\" + ZONE_ID_PAT + r\")\\]$\")",
          "65: SUBAUTHORITY_PAT = (u\"^(?:(.*)@)?\" u\"(%s|%s|%s)\" u\"(?::([0-9]{0,5}))?$\") % (",
          "66:     REG_NAME_PAT,",
          "67:     IPV4_PAT,",
          "68:     IPV6_ADDRZ_PAT,",
          "69: )",
          "70: SUBAUTHORITY_RE = re.compile(SUBAUTHORITY_PAT, re.UNICODE | re.DOTALL)",
          "72: ZONE_ID_CHARS = set(",
          "73:     \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"abcdefghijklmnopqrstuvwxyz\" \"0123456789._!-\"",
          "75: USERINFO_CHARS = ZONE_ID_CHARS | set(\"$&'()*+,;=:\")",
          "76: PATH_CHARS = USERINFO_CHARS | {\"@\", \"/\"}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "155: def _encode_invalid_chars(component, allowed_chars, encoding=\"utf-8\"):",
          "156:     \"\"\"Percent-encodes a URI component without reapplying",
          "159:     \"\"\"",
          "160:     if component is None:",
          "161:         return component",
          "163:     # Try to see if the component we're encoding is already percent-encoded",
          "164:     # so we can skip all '%' characters but still encode all others.",
          "169:     uri_bytes = component.encode(\"utf-8\", \"surrogatepass\")",
          "172:     encoded_component = bytearray()",
          "",
          "[Removed Lines]",
          "157:     onto an already percent-encoded component. Based on",
          "158:     rfc3986.normalizers.encode_component()",
          "165:     percent_encodings = len(",
          "166:         normalizers.PERCENT_MATCHER.findall(compat.to_str(component, encoding))",
          "167:     )",
          "170:     is_percent_encoded = percent_encodings == uri_bytes.count(b\"%\")",
          "",
          "[Added Lines]",
          "210:     onto an already percent-encoded component.",
          "215:     component = six.ensure_text(component)",
          "219:     percent_encodings = PERCENT_RE.findall(component)",
          "221:     # Normalize existing percent-encoded bytes.",
          "222:     for enc in percent_encodings:",
          "223:         if not enc.isupper():",
          "224:             component = component.replace(enc, enc.upper())",
          "227:     is_percent_encoded = len(percent_encodings) == uri_bytes.count(b\"%\")",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "180:         ):",
          "181:             encoded_component.extend(byte)",
          "182:             continue",
          "185:     return encoded_component.decode(encoding)",
          "188: def parse_url(url):",
          "189:     \"\"\"",
          "190:     Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is",
          "191:     performed to parse incomplete urls. Fields not provided will be None.",
          "192:     This parser is RFC 3986 compliant.",
          "194:     :param str url: URL to parse into a :class:`.Url` namedtuple.",
          "196:     Partly backwards-compatible with :mod:`urlparse`.",
          "",
          "[Removed Lines]",
          "183:         encoded_component.extend(\"%{0:02x}\".format(byte_ord).encode().upper())",
          "",
          "[Added Lines]",
          "240:         encoded_component.extend(b\"%\" + (hex(byte_ord)[2:].encode().zfill(2).upper()))",
          "245: def _remove_path_dot_segments(path):",
          "246:     # See http://tools.ietf.org/html/rfc3986#section-5.2.4 for pseudo-code",
          "247:     segments = path.split(\"/\")  # Turn the path into a list of segments",
          "248:     output = []  # Initialize the variable to use to store output",
          "250:     for segment in segments:",
          "251:         # '.' is the current directory, so ignore it, it is superfluous",
          "252:         if segment == \".\":",
          "253:             continue",
          "254:         # Anything other than '..', should be appended to the output",
          "255:         elif segment != \"..\":",
          "256:             output.append(segment)",
          "257:         # In this case segment == '..', if we can, we should pop the last",
          "258:         # element",
          "259:         elif output:",
          "260:             output.pop()",
          "262:     # If the path starts with '/' and the output is empty or the first string",
          "263:     # is non-empty",
          "264:     if path.startswith(\"/\") and (not output or output[0]):",
          "265:         output.insert(0, \"\")",
          "267:     # If the path starts with '/.' or '/..' ensure we add one more empty",
          "268:     # string to add a trailing '/'",
          "269:     if path.endswith((\"/.\", \"/..\")):",
          "270:         output.append(\"\")",
          "272:     return \"/\".join(output)",
          "275: def _normalize_host(host, scheme):",
          "276:     if host:",
          "277:         if isinstance(host, six.binary_type):",
          "278:             host = six.ensure_str(host)",
          "280:         if scheme in NORMALIZABLE_SCHEMES:",
          "281:             is_ipv6 = IPV6_ADDRZ_RE.match(host)",
          "282:             if is_ipv6:",
          "283:                 match = ZONE_ID_RE.search(host)",
          "284:                 if match:",
          "285:                     start, end = match.span(1)",
          "286:                     zone_id = host[start:end]",
          "288:                     if zone_id.startswith(\"%25\") and zone_id != \"%25\":",
          "289:                         zone_id = zone_id[3:]",
          "290:                     else:",
          "291:                         zone_id = zone_id[1:]",
          "292:                     zone_id = \"%\" + _encode_invalid_chars(zone_id, ZONE_ID_CHARS)",
          "293:                     return host[:start].lower() + zone_id + host[end:]",
          "294:                 else:",
          "295:                     return host.lower()",
          "296:             elif not IPV4_RE.match(host):",
          "297:                 return six.ensure_str(",
          "298:                     b\".\".join([_idna_encode(label) for label in host.split(\".\")])",
          "299:                 )",
          "300:     return host",
          "303: def _idna_encode(name):",
          "304:     if name and any([ord(x) > 128 for x in name]):",
          "305:         try:",
          "306:             import idna",
          "307:         except ImportError:",
          "308:             six.raise_from(",
          "309:                 LocationParseError(\"Unable to parse URL without the 'idna' module\"),",
          "310:                 None,",
          "311:             )",
          "312:         try:",
          "313:             return idna.encode(name.lower(), strict=True, std3_rules=True)",
          "314:         except idna.IDNAError:",
          "315:             six.raise_from(",
          "316:                 LocationParseError(u\"Name '%s' is not a valid IDNA label\" % name), None",
          "317:             )",
          "318:     return name.lower().encode(\"ascii\")",
          "327:     The parser logic and helper functions are based heavily on",
          "328:     work done in the ``rfc3986`` module.",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "208:         # Empty",
          "209:         return Url()",
          "219:         url = \"//\" + url",
          "262:     try:",
          "267:     # For the sake of backwards compatibility we put empty",
          "268:     # string values for path if there are any defined values",
          "269:     # beyond the path in the URL.",
          "270:     # TODO: Remove this when we break backwards compatibility.",
          "272:     if not path:",
          "274:             path = \"\"",
          "275:         else:",
          "276:             path = None",
          "278:     # Ensure that each part of the URL is a `str` for",
          "279:     # backwards compatibility.",
          "287:     return Url(",
          "295:     )",
          "",
          "[Removed Lines]",
          "211:     is_string = not isinstance(url, six.binary_type)",
          "213:     # RFC 3986 doesn't like URLs that have a host but don't start",
          "214:     # with a scheme and we support URLs like that so we need to",
          "215:     # detect that problem and add an empty scheme indication.",
          "216:     # We don't get hurt on path-only URLs here as it's stripped",
          "217:     # off and given an empty scheme anyways.",
          "218:     if not SCHEME_REGEX.search(url):",
          "221:     def idna_encode(name):",
          "222:         if name and any([ord(x) > 128 for x in name]):",
          "223:             try:",
          "224:                 import idna",
          "225:             except ImportError:",
          "226:                 raise LocationParseError(",
          "227:                     \"Unable to parse URL without the 'idna' module\"",
          "228:                 )",
          "229:             try:",
          "230:                 return idna.encode(name.lower(), strict=True, std3_rules=True)",
          "231:             except idna.IDNAError:",
          "232:                 raise LocationParseError(u\"Name '%s' is not a valid IDNA label\" % name)",
          "233:         return name",
          "235:     try:",
          "236:         split_iri = misc.IRI_MATCHER.match(compat.to_str(url)).groupdict()",
          "237:         iri_ref = rfc3986.IRIReference(",
          "238:             split_iri[\"scheme\"],",
          "239:             split_iri[\"authority\"],",
          "240:             _encode_invalid_chars(split_iri[\"path\"], PATH_CHARS),",
          "241:             _encode_invalid_chars(split_iri[\"query\"], QUERY_CHARS),",
          "242:             _encode_invalid_chars(split_iri[\"fragment\"], FRAGMENT_CHARS),",
          "243:         )",
          "244:         has_authority = iri_ref.authority is not None",
          "245:         uri_ref = iri_ref.encode(idna_encoder=idna_encode)",
          "246:     except (ValueError, RFC3986Exception):",
          "247:         return six.raise_from(LocationParseError(url), None)",
          "249:     # rfc3986 strips the authority if it's invalid",
          "250:     if has_authority and uri_ref.authority is None:",
          "251:         raise LocationParseError(url)",
          "253:     # Only normalize schemes we understand to not break http+unix",
          "254:     # or other schemes that don't follow RFC 3986.",
          "255:     if uri_ref.scheme is None or uri_ref.scheme.lower() in NORMALIZABLE_SCHEMES:",
          "256:         uri_ref = uri_ref.normalize()",
          "258:     # Validate all URIReference components and ensure that all",
          "259:     # components that were set before are still set after",
          "260:     # normalization has completed.",
          "261:     validator = Validator()",
          "263:         validator.check_validity_of(*validator.COMPONENT_NAMES).validate(uri_ref)",
          "264:     except ValidationError:",
          "265:         return six.raise_from(LocationParseError(url), None)",
          "271:     path = uri_ref.path",
          "273:         if uri_ref.query is not None or uri_ref.fragment is not None:",
          "280:     def to_input_type(x):",
          "281:         if x is None:",
          "282:             return None",
          "283:         elif not is_string and not isinstance(x, six.binary_type):",
          "284:             return x.encode(\"utf-8\")",
          "285:         return x",
          "288:         scheme=to_input_type(uri_ref.scheme),",
          "289:         auth=to_input_type(uri_ref.userinfo),",
          "290:         host=to_input_type(uri_ref.host),",
          "291:         port=int(uri_ref.port) if uri_ref.port is not None else None,",
          "292:         path=to_input_type(path),",
          "293:         query=to_input_type(uri_ref.query),",
          "294:         fragment=to_input_type(uri_ref.fragment),",
          "",
          "[Added Lines]",
          "347:     source_url = url",
          "348:     if not SCHEME_RE.search(url):",
          "352:         scheme, authority, path, query, fragment = URI_RE.match(url).groups()",
          "353:         normalize_uri = scheme is None or scheme.lower() in NORMALIZABLE_SCHEMES",
          "355:         if scheme:",
          "356:             scheme = scheme.lower()",
          "358:         if authority:",
          "359:             auth, host, port = SUBAUTHORITY_RE.match(authority).groups()",
          "360:             if auth and normalize_uri:",
          "361:                 auth = _encode_invalid_chars(auth, USERINFO_CHARS)",
          "362:             if port == \"\":",
          "363:                 port = None",
          "364:         else:",
          "365:             auth, host, port = None, None, None",
          "367:         if port is not None:",
          "368:             port = int(port)",
          "369:             if not (0 <= port <= 65535):",
          "370:                 raise LocationParseError(url)",
          "372:         host = _normalize_host(host, scheme)",
          "374:         if normalize_uri and path:",
          "375:             path = _remove_path_dot_segments(path)",
          "376:             path = _encode_invalid_chars(path, PATH_CHARS)",
          "377:         if normalize_uri and query:",
          "378:             query = _encode_invalid_chars(query, QUERY_CHARS)",
          "379:         if normalize_uri and fragment:",
          "380:             fragment = _encode_invalid_chars(fragment, FRAGMENT_CHARS)",
          "382:     except (ValueError, AttributeError):",
          "383:         return six.raise_from(LocationParseError(source_url), None)",
          "390:         if query is not None or fragment is not None:",
          "397:     if isinstance(url, six.text_type):",
          "398:         ensure_func = six.ensure_text",
          "399:     else:",
          "400:         ensure_func = six.ensure_str",
          "402:     def ensure_type(x):",
          "403:         return x if x is None else ensure_func(x)",
          "406:         scheme=ensure_type(scheme),",
          "407:         auth=ensure_type(auth),",
          "408:         host=ensure_type(host),",
          "409:         port=port,",
          "410:         path=ensure_type(path),",
          "411:         query=ensure_type(query),",
          "412:         fragment=ensure_type(fragment),",
          "",
          "---------------"
        ],
        "test/test_util.py||test/test_util.py": [
          "File: test/test_util.py -> test/test_util.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "154:     @pytest.mark.parametrize(",
          "155:         \"url\",",
          "156:         [",
          "161:             # Invalid IDNA labels",
          "162:             u\"http://\\uD7FF.com\",",
          "163:             u\"http://\u2764\ufe0f\",",
          "",
          "[Removed Lines]",
          "157:             \"http://user\\\\@google.com\",",
          "158:             \"http://google\\\\.com\",",
          "159:             \"user\\\\@google.com\",",
          "160:             \"http://user@user@google.com/\",",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "180:             ),",
          "181:             (\"HTTPS://Example.Com/?Key=Value\", \"https://example.com/?Key=Value\"),",
          "182:             (\"Https://Example.Com/#Fragment\", \"https://example.com/#Fragment\"),",
          "184:             # Invalid characters for the query/fragment getting encoded",
          "185:             (",
          "186:                 'http://google.com/p[]?parameter[]=\"hello\"#fragment#',",
          "",
          "[Removed Lines]",
          "183:             (\"[::Ff%etH0%Ff]/%ab%Af\", \"[::ff%25etH0%Ff]/%AB%AF\"),",
          "",
          "[Added Lines]",
          "179:             (\"[::1%25]\", \"[::1%25]\"),",
          "180:             (\"[::Ff%etH0%Ff]/%ab%Af\", \"[::ff%etH0%FF]/%AB%AF\"),",
          "181:             (",
          "182:                 \"http://user:pass@[AaAa::Ff%25etH0%Ff]/%ab%Af\",",
          "183:                 \"http://user:pass@[aaaa::ff%etH0%FF]/%AB%AF\",",
          "184:             ),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "199:         actual_normalized_url = parse_url(url).url",
          "200:         assert actual_normalized_url == expected_normalized_url",
          "202:     parse_url_host_map = [",
          "203:         (\"http://google.com/mail\", Url(\"http\", host=\"google.com\", path=\"/mail\")),",
          "204:         (\"http://google.com/mail/\", Url(\"http\", host=\"google.com\", path=\"/mail/\")),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "203:     @pytest.mark.parametrize(\"char\", [chr(i) for i in range(0x00, 0x21)] + [\"\\x7F\"])",
          "204:     def test_control_characters_are_percent_encoded(self, char):",
          "205:         percent_char = \"%\" + (hex(ord(char))[2:].zfill(2).upper())",
          "206:         url = parse_url(",
          "207:             \"http://user{0}@example.com/path{0}?query{0}#fragment{0}\".format(char)",
          "208:         )",
          "210:         assert url == Url(",
          "211:             \"http\",",
          "212:             auth=\"user\" + percent_char,",
          "213:             host=\"example.com\",",
          "214:             path=\"/path\" + percent_char,",
          "215:             query=\"query\" + percent_char,",
          "216:             fragment=\"fragment\" + percent_char,",
          "217:         )",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "260:             u\"http://K\u00f6nigsg\u00e4\u00dfchen.de/stra\u00dfe\",",
          "261:             Url(\"http\", host=\"xn--knigsgchen-b4a3dun.de\", path=\"/stra%C3%9Fe\"),",
          "262:         ),",
          "263:         # Unicode Surrogates",
          "264:         (u\"http://google.com/\\uD800\", Url(\"http\", host=\"google.com\", path=\"%ED%A0%80\")),",
          "265:         (",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "280:         # Percent-encode in userinfo",
          "281:         (",
          "282:             u\"http://user@email.com:password@example.com/\",",
          "283:             Url(\"http\", auth=\"user%40email.com:password\", host=\"example.com\", path=\"/\"),",
          "284:         ),",
          "285:         (",
          "286:             u'http://user\":quoted@example.com/',",
          "287:             Url(\"http\", auth=\"user%22:quoted\", host=\"example.com\", path=\"/\"),",
          "288:         ),",
          "",
          "---------------"
        ]
      }
    }
  ]
}
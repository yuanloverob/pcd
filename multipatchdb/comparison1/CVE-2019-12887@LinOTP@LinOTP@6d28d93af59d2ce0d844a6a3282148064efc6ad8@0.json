{
  "cve_id": "CVE-2019-12887",
  "cve_desc": "KeyIdentity LinOTP before 2.10.5.3 has Incorrect Access Control (issue 1 of 2).",
  "repo": "LinOTP/LinOTP",
  "patch_hash": "6d28d93af59d2ce0d844a6a3282148064efc6ad8",
  "patch_info": {
    "commit_hash": "6d28d93af59d2ce0d844a6a3282148064efc6ad8",
    "repo": "LinOTP/LinOTP",
    "commit_url": "https://github.com/LinOTP/LinOTP/commit/6d28d93af59d2ce0d844a6a3282148064efc6ad8",
    "files": [
      "adminclient/LinOTPAdminClientCLI/src/debian/changelog",
      "adminclient/LinOTPAdminClientCLI/src/linotpadminclientcli/__init__.py",
      "linotpd/src/debian/changelog",
      "linotpd/src/linotp/__init__.py",
      "linotpd/src/linotp/tests/functional/test_totp.py",
      "linotpd/src/linotp/tokens/totptoken.py"
    ],
    "message": "Merge branch 'fix/LINOTP-795-for-master' into 'master'\n\nLINOTP-975 fix for master\n\nSee merge request dev/linotp/linotp!51",
    "before_after_code_files": [
      "adminclient/LinOTPAdminClientCLI/src/linotpadminclientcli/__init__.py||adminclient/LinOTPAdminClientCLI/src/linotpadminclientcli/__init__.py",
      "linotpd/src/linotp/__init__.py||linotpd/src/linotp/__init__.py",
      "linotpd/src/linotp/tests/functional/test_totp.py||linotpd/src/linotp/tests/functional/test_totp.py",
      "linotpd/src/linotp/tokens/totptoken.py||linotpd/src/linotp/tokens/totptoken.py"
    ]
  },
  "patch_diff": {
    "adminclient/LinOTPAdminClientCLI/src/linotpadminclientcli/__init__.py||adminclient/LinOTPAdminClientCLI/src/linotpadminclientcli/__init__.py": [
      "File: adminclient/LinOTPAdminClientCLI/src/linotpadminclientcli/__init__.py -> adminclient/LinOTPAdminClientCLI/src/linotpadminclientcli/__init__.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "37: __license__ = \"Gnu AGPLv3\"",
      "38: __contact__ = \"www.linotp.org\"",
      "39: __email__ = \"linotp@keyidentity.com\"",
      "",
      "[Removed Lines]",
      "40: __version__ = '2.10.5.2'",
      "",
      "[Added Lines]",
      "40: __version__ = '2.10.7.dev0'",
      "",
      "---------------"
    ],
    "linotpd/src/linotp/__init__.py||linotpd/src/linotp/__init__.py": [
      "File: linotpd/src/linotp/__init__.py -> linotpd/src/linotp/__init__.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "67: __license__ = \"Gnu AGPLv3\"",
      "68: __contact__ = \"www.linotp.org\"",
      "69: __email__ = \"linotp@keyidentity.com\"",
      "71: __api__ = \"2.0802\"",
      "",
      "[Removed Lines]",
      "70: __version__ = '2.10.5.2'",
      "",
      "[Added Lines]",
      "70: __version__ = '2.10.7.dev0'",
      "",
      "---------------"
    ],
    "linotpd/src/linotp/tests/functional/test_totp.py||linotpd/src/linotp/tests/functional/test_totp.py": [
      "File: linotpd/src/linotp/tests/functional/test_totp.py -> linotpd/src/linotp/tests/functional/test_totp.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "508:         return",
      "511:     def test_getotp(self):",
      "512:         '''",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "510:     def test_resync_no_replay(self):",
      "511:         '''",
      "512:             totp test: verify that auto resync does not succeed with reused (sync) OTPs",
      "514:             We will use the same OTP twice. Once for starting the sync",
      "515:             and then to complete it. Both of those should not yield a",
      "516:             valid authentication. The user must provide two consecutive",
      "517:             OTPs to finish the sync. The second OTP must be within a",
      "518:             small timeframe after the first.",
      "519:         '''",
      "520:         user = 'root'",
      "521:         step = 30",
      "523:         params = {",
      "524:             'AutoResyncTimeout': '240',",
      "525:             'AutoResync': True",
      "526:         }",
      "528:         response = self.make_system_request('setConfig', params=params)",
      "529:         assert 'false' not in response.body",
      "531:         for offset in range(10*step, 20*step, step/2):",
      "532:             # Freeze time to the current system time",
      "533:             with freeze_time(datetime.datetime.now()) as frozen_time:",
      "534:                 t1 = TotpToken(timestep=step)",
      "535:                 key = t1.getKey().encode('hex')",
      "536:                 step = t1.getTimeStep()",
      "538:                 tserial = self.addToken(user=user, otplen=t1.digits,",
      "539:                                         typ='totp', key=key, timeStep=step)",
      "541:                 self.serials.append(tserial)",
      "543:                 (otp, counter) = t1.getOtp()",
      "544:                 _tt1 = t1.getTimeFromCounter(counter)",
      "546:                 res = self.checkOtp(user, otp)",
      "547:                 assert '\"value\": true' in res.body",
      "549:                 # replay doesn't work",
      "550:                 res = self.checkOtp(user, otp)",
      "551:                 assert '\"value\": false' in res.body",
      "553:                 # advance to a future time where the old otp is no longer valid",
      "554:                 frozen_time.tick(delta=datetime.timedelta(seconds=offset))",
      "556:                 # start resync",
      "557:                 res = self.checkOtp(user, otp)",
      "558:                 assert '\"value\": false' in res.body, \"%s: %s\" %(offset,res.body)",
      "560:                 # finish resync",
      "561:                 res = self.checkOtp(user, otp)",
      "562:                 assert '\"value\": true' not in res.body, offset",
      "564:     def test_resync_non_consecutive(self):",
      "565:         '''",
      "566:             totp test: verify that auto resync does not succeed with non-consecutive OTPs",
      "567:         '''",
      "568:         user = 'root'",
      "569:         timeWindow = 180",
      "570:         params = {",
      "571:             'AutoResyncTimeout': '240',",
      "572:             'AutoResync': True",
      "573:         }",
      "575:         response = self.make_system_request('setConfig', params=params)",
      "576:         assert 'false' not in response.body",
      "578:         # Freeze time to the current system time",
      "579:         with freeze_time(datetime.datetime.now()) as frozen_time:",
      "580:             t1 = TotpToken()",
      "581:             key = t1.getKey().encode('hex')",
      "582:             step = t1.getTimeStep()",
      "584:             tserial = self.addToken(user=user, otplen=t1.digits,",
      "585:                                     typ='totp', key=key, timeStep=step)",
      "587:             self.serials.append(tserial)",
      "589:             (otp, counter) = t1.getOtp()",
      "591:             res = self.checkOtp(user, otp)",
      "592:             assert '\"value\": true' in res.body",
      "594:             # advance to a future time where the old otp is no longer valid",
      "595:             frozen_time.tick(delta=datetime.timedelta(seconds=timeWindow))",
      "596:             res = self.checkOtp(user, otp)",
      "597:             assert '\"value\": false' in res.body",
      "599:             # skip enough OTPs to leave the current window",
      "600:             counter += 2 * timeWindow",
      "602:             # get the first token",
      "603:             (first_otp, _) = t1.getOtp(counter=counter)",
      "604:             # get the second token",
      "605:             (second_otp, counter) = t1.getOtp(counter=counter+step)",
      "607:             # start resync with 2nd otp",
      "608:             res = self.checkOtp(user, second_otp)",
      "609:             assert '\"value\": false' in res.body",
      "611:             # provide the first OTP for the resync, it should fail",
      "612:             res = self.checkOtp(user, first_otp)",
      "613:             assert '\"value\": true' not in res.body",
      "615:     def test_resync_consecutive(self):",
      "616:         '''",
      "617:             totp test: verify that auto resync does succeed with consecutive OTPs and fails if they are outside of the range",
      "618:         '''",
      "619:         user = 'root'",
      "620:         timeWindow = 180",
      "621:         syncTimeout = 240",
      "622:         step = 30",
      "623:         params = {",
      "624:             'AutoResyncTimeout': '%s' % syncTimeout,",
      "625:             'AutoResync': True",
      "626:         }",
      "628:         response = self.make_system_request('setConfig', params=params)",
      "629:         assert 'false' not in response.body",
      "631:         for offset in range(1, 5):",
      "632:             # Freeze time to the current system time",
      "633:             with freeze_time(datetime.datetime.now()) as frozen_time:",
      "634:                 t1 = TotpToken(timestep=step)",
      "635:                 key = t1.getKey().encode('hex')",
      "637:                 tserial = self.addToken(user=user, otplen=t1.digits,",
      "638:                                         typ='totp', key=key, timeStep=step)",
      "640:                 self.serials.append(tserial)",
      "642:                 (otp, counter) = t1.getOtp()",
      "643:                 res = self.checkOtp(user, otp)",
      "644:                 assert '\"value\": true' in res.body",
      "646:                 log.info(\"Successful counter: %s\", counter)",
      "648:                 # advance to a future time where the old otp is no longer valid",
      "649:                 frozen_time.tick(delta=datetime.timedelta(seconds=timeWindow))",
      "650:                 res = self.checkOtp(user, otp)",
      "651:                 assert '\"value\": false' in res.body",
      "653:                 counter_advance = (40 * timeWindow)",
      "654:                 log.info(\"Advancing counter by %s\", counter_advance)",
      "655:                 # skip enough OTPs to leave the current window",
      "656:                 counter = (counter * step) + counter_advance",
      "658:                 # get the first token",
      "659:                 (first_otp, first_counter) = t1.getOtp(counter=counter)",
      "661:                 # get the second token that is offset by a few but within range",
      "662:                 (second_otp, second_counter) = t1.getOtp(counter=counter+step*offset)",
      "664:                 log.info(\"First OTP: %s (%s), Second OTP: %s (%s)\",",
      "665:                         first_otp, first_counter,",
      "666:                         second_otp, second_counter)",
      "668:                 # start resync with a valid OTP",
      "669:                 res = self.checkOtp(user, first_otp)",
      "670:                 assert '\"value\": false' in res.body",
      "672:                 # provide the second otp that follows the previous one",
      "673:                 res = self.checkOtp(user, second_otp)",
      "675:                 if offset <= 3:",
      "676:                     # as long as the OTP is not out of the sync range it should be good",
      "677:                     assert '\"value\": true' in res.body, offset",
      "678:                 else:",
      "679:                     # if we are out of the sync range the OTP should be rejected",
      "680:                     assert '\"value\": false' in res.body, offset",
      "",
      "---------------"
    ],
    "linotpd/src/linotp/tokens/totptoken.py||linotpd/src/linotp/tokens/totptoken.py": [
      "File: linotpd/src/linotp/tokens/totptoken.py -> linotpd/src/linotp/tokens/totptoken.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "502:         #check if the otpval is valid in the sync scope",
      "503:         res = hmac2Otp.checkOtp(anOtpVal, syncWindow, symetric=True)",
      "505:         #if yes:",
      "506:         if res != -1:",
      "507:             # if former is defined",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "505:         # ------------------------------------------------------------------ --",
      "507:         # protect against a replay",
      "509:         # if the counter belonging to the provided otp is lower than the one",
      "510:         # we have last seen (which is the stored otp counter), then we deny",
      "511:         # the resync as it might be replay or an error",
      "513:         if res != -1 and res < self.getOtpCount():",
      "514:             log.info('otp below the last seen!')",
      "515:             return -1",
      "517:         # ------------------------------------------------------------------ --",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3a3a4360cf7e4f1aafc36f4672ccfc92fe97448e",
      "candidate_info": {
        "commit_hash": "3a3a4360cf7e4f1aafc36f4672ccfc92fe97448e",
        "repo": "LinOTP/LinOTP",
        "commit_url": "https://github.com/LinOTP/LinOTP/commit/3a3a4360cf7e4f1aafc36f4672ccfc92fe97448e",
        "files": [
          "linotpd/src/linotp/lib/tokens/totptoken.py"
        ],
        "message": "fix: for totp replay using auto resync\n\nrefers to LINOTP-975",
        "before_after_code_files": [
          "linotpd/src/linotp/lib/tokens/totptoken.py||linotpd/src/linotp/lib/tokens/totptoken.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "linotpd/src/linotp/lib/tokens/totptoken.py||linotpd/src/linotp/lib/tokens/totptoken.py": [
          "File: linotpd/src/linotp/lib/tokens/totptoken.py -> linotpd/src/linotp/lib/tokens/totptoken.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "507:         #check if the otpval is valid in the sync scope",
          "508:         res = hmac2Otp.checkOtp(anOtpVal, syncWindow, symetric=True)",
          "510:         #if yes:",
          "511:         if res != -1:",
          "512:             # if former is defined",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "510:         # ------------------------------------------------------------------ --",
          "512:         # protect against a replay",
          "514:         # if the counter belonging to the provided otp is lower than the one",
          "515:         # we have last seen (which is the stored otp counter), then we deny",
          "516:         # the resync as it might be replay or an error",
          "518:         if res != -1 and res < self.getOtpCount():",
          "519:             log.info('otp below the last seen!')",
          "520:             return -1",
          "522:         # ------------------------------------------------------------------ --",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "097a96966cb8c5c37c3e48a36db958333760cf33",
      "candidate_info": {
        "commit_hash": "097a96966cb8c5c37c3e48a36db958333760cf33",
        "repo": "LinOTP/LinOTP",
        "commit_url": "https://github.com/LinOTP/LinOTP/commit/097a96966cb8c5c37c3e48a36db958333760cf33",
        "files": [
          "linotpd/src/linotp/tests/functional/test_totp.py"
        ],
        "message": "test: add tests for token autoresync that cover a few more aspects\n\nWe never had tests dedicated to these rather important properties of the\nresync process. They should now ensure that we can not cheat the replay\nand consecutive properties of the scheme.\n\nLINOTP-982",
        "before_after_code_files": [
          "linotpd/src/linotp/tests/functional/test_totp.py||linotpd/src/linotp/tests/functional/test_totp.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "linotpd/src/linotp/tests/functional/test_totp.py||linotpd/src/linotp/tests/functional/test_totp.py"
          ],
          "candidate": [
            "linotpd/src/linotp/tests/functional/test_totp.py||linotpd/src/linotp/tests/functional/test_totp.py"
          ]
        }
      },
      "candidate_diff": {
        "linotpd/src/linotp/tests/functional/test_totp.py||linotpd/src/linotp/tests/functional/test_totp.py": [
          "File: linotpd/src/linotp/tests/functional/test_totp.py -> linotpd/src/linotp/tests/functional/test_totp.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "507:         return",
          "510:     def test_getotp(self):",
          "511:         '''",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "509:     def test_resync_no_replay(self):",
          "510:         '''",
          "511:             totp test: verify that auto resync does not succeed with reused (sync) OTPs",
          "513:             We will use the same OTP twice. Once for starting the sync",
          "514:             and then to complete it. Both of those should not yield a",
          "515:             valid authentication. The user must provide two consecutive",
          "516:             OTPs to finish the sync. The second OTP must be within a",
          "517:             small timeframe after the first.",
          "518:         '''",
          "519:         user = 'root'",
          "520:         step = 30",
          "522:         params = {",
          "523:             'AutoResyncTimeout': '240',",
          "524:             'AutoResync': True",
          "525:         }",
          "527:         response = self.make_system_request('setConfig', params=params)",
          "528:         assert 'false' not in response.body",
          "530:         for offset in range(10*step, 20*step, step/2):",
          "531:             # Freeze time to the current system time",
          "532:             with freeze_time(datetime.datetime.now()) as frozen_time:",
          "533:                 t1 = TotpToken(timestep=step)",
          "534:                 key = t1.getKey().encode('hex')",
          "535:                 step = t1.getTimeStep()",
          "537:                 tserial = self.addToken(user=user, otplen=t1.digits,",
          "538:                                         typ='totp', key=key, timeStep=step)",
          "540:                 self.serials.append(tserial)",
          "542:                 (otp, counter) = t1.getOtp()",
          "543:                 _tt1 = t1.getTimeFromCounter(counter)",
          "545:                 res = self.checkOtp(user, otp)",
          "546:                 assert '\"value\": true' in res.body",
          "548:                 # replay doesn't work",
          "549:                 res = self.checkOtp(user, otp)",
          "550:                 assert '\"value\": false' in res.body",
          "552:                 # advance to a future time where the old otp is no longer valid",
          "553:                 frozen_time.tick(delta=datetime.timedelta(seconds=offset))",
          "555:                 # start resync",
          "556:                 res = self.checkOtp(user, otp)",
          "557:                 assert '\"value\": false' in res.body, \"%s: %s\" %(offset,res.body)",
          "559:                 # finish resync",
          "560:                 res = self.checkOtp(user, otp)",
          "561:                 assert '\"value\": true' not in res.body, offset",
          "563:     def test_resync_non_consecutive(self):",
          "564:         '''",
          "565:             totp test: verify that auto resync does not succeed with non-consecutive OTPs",
          "566:         '''",
          "567:         user = 'root'",
          "568:         timeWindow = 180",
          "569:         params = {",
          "570:             'AutoResyncTimeout': '240',",
          "571:             'AutoResync': True",
          "572:         }",
          "574:         response = self.make_system_request('setConfig', params=params)",
          "575:         assert 'false' not in response.body",
          "577:         # Freeze time to the current system time",
          "578:         with freeze_time(datetime.datetime.now()) as frozen_time:",
          "579:             t1 = TotpToken()",
          "580:             key = t1.getKey().encode('hex')",
          "581:             step = t1.getTimeStep()",
          "583:             tserial = self.addToken(user=user, otplen=t1.digits,",
          "584:                                     typ='totp', key=key, timeStep=step)",
          "586:             self.serials.append(tserial)",
          "588:             (otp, counter) = t1.getOtp()",
          "590:             res = self.checkOtp(user, otp)",
          "591:             assert '\"value\": true' in res.body",
          "593:             # advance to a future time where the old otp is no longer valid",
          "594:             frozen_time.tick(delta=datetime.timedelta(seconds=timeWindow))",
          "595:             res = self.checkOtp(user, otp)",
          "596:             assert '\"value\": false' in res.body",
          "598:             # skip enough OTPs to leave the current window",
          "599:             counter += 2 * timeWindow",
          "601:             # get the first token",
          "602:             (first_otp, _) = t1.getOtp(counter=counter)",
          "603:             # get the second token",
          "604:             (second_otp, counter) = t1.getOtp(counter=counter+step)",
          "606:             # start resync with 2nd otp",
          "607:             res = self.checkOtp(user, second_otp)",
          "608:             assert '\"value\": false' in res.body",
          "610:             # provide the first OTP for the resync, it should fail",
          "611:             res = self.checkOtp(user, first_otp)",
          "612:             assert '\"value\": true' not in res.body",
          "614:     def test_resync_consecutive(self):",
          "615:         '''",
          "616:             totp test: verify that auto resync does succeed with consecutive OTPs and fails if they are outside of the range",
          "617:         '''",
          "618:         user = 'root'",
          "619:         timeWindow = 180",
          "620:         syncTimeout = 240",
          "621:         step = 30",
          "622:         params = {",
          "623:             'AutoResyncTimeout': '%s' % syncTimeout,",
          "624:             'AutoResync': True",
          "625:         }",
          "627:         response = self.make_system_request('setConfig', params=params)",
          "628:         assert 'false' not in response.body",
          "630:         for offset in range(1, 5):",
          "631:             # Freeze time to the current system time",
          "632:             with freeze_time(datetime.datetime.now()) as frozen_time:",
          "633:                 t1 = TotpToken(timestep=step)",
          "634:                 key = t1.getKey().encode('hex')",
          "636:                 tserial = self.addToken(user=user, otplen=t1.digits,",
          "637:                                         typ='totp', key=key, timeStep=step)",
          "639:                 self.serials.append(tserial)",
          "641:                 (otp, counter) = t1.getOtp()",
          "642:                 res = self.checkOtp(user, otp)",
          "643:                 assert '\"value\": true' in res.body",
          "645:                 log.info(\"Successful counter: %s\", counter)",
          "647:                 # advance to a future time where the old otp is no longer valid",
          "648:                 frozen_time.tick(delta=datetime.timedelta(seconds=timeWindow))",
          "649:                 res = self.checkOtp(user, otp)",
          "650:                 assert '\"value\": false' in res.body",
          "652:                 counter_advance = (40 * timeWindow)",
          "653:                 log.info(\"Advancing counter by %s\", counter_advance)",
          "654:                 # skip enough OTPs to leave the current window",
          "655:                 counter = (counter * step) + counter_advance",
          "657:                 # get the first token",
          "658:                 (first_otp, first_counter) = t1.getOtp(counter=counter)",
          "660:                 # get the second token that is offset by a few but within range",
          "661:                 (second_otp, second_counter) = t1.getOtp(counter=counter+step*offset)",
          "663:                 log.info(\"First OTP: %s (%s), Second OTP: %s (%s)\",",
          "664:                         first_otp, first_counter,",
          "665:                         second_otp, second_counter)",
          "667:                 # start resync with a valid OTP",
          "668:                 res = self.checkOtp(user, first_otp)",
          "669:                 assert '\"value\": false' in res.body",
          "671:                 # provide the second otp that follows the previous one",
          "672:                 res = self.checkOtp(user, second_otp)",
          "674:                 if offset <= 3:",
          "675:                     # as long as the OTP is not out of the sync range it should be good",
          "676:                     assert '\"value\": true' in res.body, offset",
          "677:                 else:",
          "678:                     # if we are out of the sync range the OTP should be rejected",
          "679:                     assert '\"value\": false' in res.body, offset",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8f13d2ddb8bf54c0fea6ae975cba4c4af8d1e1b2",
      "candidate_info": {
        "commit_hash": "8f13d2ddb8bf54c0fea6ae975cba4c4af8d1e1b2",
        "repo": "LinOTP/LinOTP",
        "commit_url": "https://github.com/LinOTP/LinOTP/commit/8f13d2ddb8bf54c0fea6ae975cba4c4af8d1e1b2",
        "files": [
          "linotpd/src/linotp/tests/functional/test_totp.py"
        ],
        "message": "test: add tests for token autoresync that cover a few more aspects\n\nWe never had tests dedicated to these rather important properties of the\nresync process. They should now ensure that we can not cheat the replay\nand consecutive properties of the scheme.\n\nLINOTP-982",
        "before_after_code_files": [
          "linotpd/src/linotp/tests/functional/test_totp.py||linotpd/src/linotp/tests/functional/test_totp.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "linotpd/src/linotp/tests/functional/test_totp.py||linotpd/src/linotp/tests/functional/test_totp.py"
          ],
          "candidate": [
            "linotpd/src/linotp/tests/functional/test_totp.py||linotpd/src/linotp/tests/functional/test_totp.py"
          ]
        }
      },
      "candidate_diff": {
        "linotpd/src/linotp/tests/functional/test_totp.py||linotpd/src/linotp/tests/functional/test_totp.py": [
          "File: linotpd/src/linotp/tests/functional/test_totp.py -> linotpd/src/linotp/tests/functional/test_totp.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "492:         return",
          "495:     def test_getotp(self):",
          "496:         '''",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "494:     def test_resync_no_replay(self):",
          "495:         '''",
          "496:             totp test: verify that auto resync does not succeed with reused (sync) OTPs",
          "498:             We will use the same OTP twice. Once for starting the sync",
          "499:             and then to complete it. Both of those should not yield a",
          "500:             valid authentication. The user must provide two consecutive",
          "501:             OTPs to finish the sync. The second OTP must be within a",
          "502:             small timeframe after the first.",
          "503:         '''",
          "504:         user = 'root'",
          "505:         step = 30",
          "507:         params = {",
          "508:             'AutoResyncTimeout': '240',",
          "509:             'AutoResync': True",
          "510:         }",
          "512:         response = self.make_system_request('setConfig', params=params)",
          "513:         assert 'false' not in response.body",
          "515:         for offset in range(10*step, 20*step, step/2):",
          "516:             # Freeze time to the current system time",
          "517:             with freeze_time(datetime.datetime.now()) as frozen_time:",
          "518:                 t1 = TotpToken(timestep=step)",
          "519:                 key = t1.getKey().encode('hex')",
          "520:                 step = t1.getTimeStep()",
          "522:                 tserial = self.addToken(user=user, otplen=t1.digits,",
          "523:                                         typ='totp', key=key, timeStep=step)",
          "525:                 self.serials.append(tserial)",
          "527:                 (otp, counter) = t1.getOtp()",
          "528:                 _tt1 = t1.getTimeFromCounter(counter)",
          "530:                 res = self.checkOtp(user, otp)",
          "531:                 assert '\"value\": true' in res.body",
          "533:                 # replay doesn't work",
          "534:                 res = self.checkOtp(user, otp)",
          "535:                 assert '\"value\": false' in res.body",
          "537:                 # advance to a future time where the old otp is no longer valid",
          "538:                 frozen_time.tick(delta=datetime.timedelta(seconds=offset))",
          "540:                 # start resync",
          "541:                 res = self.checkOtp(user, otp)",
          "542:                 assert '\"value\": false' in res.body, \"%s: %s\" %(offset,res.body)",
          "544:                 # finish resync",
          "545:                 res = self.checkOtp(user, otp)",
          "546:                 assert '\"value\": true' not in res.body, offset",
          "548:     def test_resync_non_consecutive(self):",
          "549:         '''",
          "550:             totp test: verify that auto resync does not succeed with non-consecutive OTPs",
          "551:         '''",
          "552:         user = 'root'",
          "553:         timeWindow = 180",
          "554:         params = {",
          "555:             'AutoResyncTimeout': '240',",
          "556:             'AutoResync': True",
          "557:         }",
          "559:         response = self.make_system_request('setConfig', params=params)",
          "560:         assert 'false' not in response.body",
          "562:         # Freeze time to the current system time",
          "563:         with freeze_time(datetime.datetime.now()) as frozen_time:",
          "564:             t1 = TotpToken()",
          "565:             key = t1.getKey().encode('hex')",
          "566:             step = t1.getTimeStep()",
          "568:             tserial = self.addToken(user=user, otplen=t1.digits,",
          "569:                                     typ='totp', key=key, timeStep=step)",
          "571:             self.serials.append(tserial)",
          "573:             (otp, counter) = t1.getOtp()",
          "575:             res = self.checkOtp(user, otp)",
          "576:             assert '\"value\": true' in res.body",
          "578:             # advance to a future time where the old otp is no longer valid",
          "579:             frozen_time.tick(delta=datetime.timedelta(seconds=timeWindow))",
          "580:             res = self.checkOtp(user, otp)",
          "581:             assert '\"value\": false' in res.body",
          "583:             # skip enough OTPs to leave the current window",
          "584:             counter += 2 * timeWindow",
          "586:             # get the first token",
          "587:             (first_otp, _) = t1.getOtp(counter=counter)",
          "588:             # get the second token",
          "589:             (second_otp, counter) = t1.getOtp(counter=counter+step)",
          "591:             # start resync with 2nd otp",
          "592:             res = self.checkOtp(user, second_otp)",
          "593:             assert '\"value\": false' in res.body",
          "595:             # provide the first OTP for the resync, it should fail",
          "596:             res = self.checkOtp(user, first_otp)",
          "597:             assert '\"value\": true' not in res.body",
          "599:     def test_resync_consecutive(self):",
          "600:         '''",
          "601:             totp test: verify that auto resync does succeed with consecutive OTPs and fails if they are outside of the range",
          "602:         '''",
          "603:         user = 'root'",
          "604:         timeWindow = 180",
          "605:         syncTimeout = 240",
          "606:         step = 30",
          "607:         params = {",
          "608:             'AutoResyncTimeout': '%s' % syncTimeout,",
          "609:             'AutoResync': True",
          "610:         }",
          "612:         response = self.make_system_request('setConfig', params=params)",
          "613:         assert 'false' not in response.body",
          "615:         for offset in range(1, 5):",
          "616:             # Freeze time to the current system time",
          "617:             with freeze_time(datetime.datetime.now()) as frozen_time:",
          "618:                 t1 = TotpToken(timestep=step)",
          "619:                 key = t1.getKey().encode('hex')",
          "621:                 tserial = self.addToken(user=user, otplen=t1.digits,",
          "622:                                         typ='totp', key=key, timeStep=step)",
          "624:                 self.serials.append(tserial)",
          "626:                 (otp, counter) = t1.getOtp()",
          "627:                 res = self.checkOtp(user, otp)",
          "628:                 assert '\"value\": true' in res.body",
          "630:                 log.info(\"Successful counter: %s\", counter)",
          "632:                 # advance to a future time where the old otp is no longer valid",
          "633:                 frozen_time.tick(delta=datetime.timedelta(seconds=timeWindow))",
          "634:                 res = self.checkOtp(user, otp)",
          "635:                 assert '\"value\": false' in res.body",
          "637:                 counter_advance = (40 * timeWindow)",
          "638:                 log.info(\"Advancing counter by %s\", counter_advance)",
          "639:                 # skip enough OTPs to leave the current window",
          "640:                 counter = (counter * step) + counter_advance",
          "642:                 # get the first token",
          "643:                 (first_otp, first_counter) = t1.getOtp(counter=counter)",
          "645:                 # get the second token that is offset by a few but within range",
          "646:                 (second_otp, second_counter) = t1.getOtp(counter=counter+step*offset)",
          "648:                 log.info(\"First OTP: %s (%s), Second OTP: %s (%s)\",",
          "649:                         first_otp, first_counter,",
          "650:                         second_otp, second_counter)",
          "652:                 # start resync with a valid OTP",
          "653:                 res = self.checkOtp(user, first_otp)",
          "654:                 assert '\"value\": false' in res.body",
          "656:                 # provide the second otp that follows the previous one",
          "657:                 res = self.checkOtp(user, second_otp)",
          "659:                 if offset <= 3:",
          "660:                     # as long as the OTP is not out of the sync range it should be good",
          "661:                     assert '\"value\": true' in res.body, offset",
          "662:                 else:",
          "663:                     # if we are out of the sync range the OTP should be rejected",
          "664:                     assert '\"value\": false' in res.body, offset",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-39393",
  "cve_desc": "Wasmtime is a standalone runtime for WebAssembly. Prior to versions 2.0.2 and 1.0.2, there is a bug in Wasmtime's implementation of its pooling instance allocator where when a linear memory is reused for another instance the initial heap snapshot of the prior instance can be visible, erroneously to the next instance. This bug has been patched and users should upgrade to Wasmtime 2.0.2 and 1.0.2. Other mitigations include disabling the pooling allocator and disabling the `memory-init-cow`.",
  "repo": "bytecodealliance/wasmtime",
  "patch_hash": "2614f2e9d2d36805ead8a8da0fa0c6e0d9e428a0",
  "patch_info": {
    "commit_hash": "2614f2e9d2d36805ead8a8da0fa0c6e0d9e428a0",
    "repo": "bytecodealliance/wasmtime",
    "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/2614f2e9d2d36805ead8a8da0fa0c6e0d9e428a0",
    "files": [
      "crates/runtime/src/instance/allocator/pooling.rs",
      "tests/all/pooling_allocator.rs"
    ],
    "message": "Merge pull request from GHSA-wh6w-3828-g9qf\n\nThis is a minimal fix for the release branch to fix the issue of having\na memory slot get reused between a module with an image and one without.",
    "before_after_code_files": [
      "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
      "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
    ]
  },
  "patch_diff": {
    "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs": [
      "File: crates/runtime/src/instance/allocator/pooling.rs -> crates/runtime/src/instance/allocator/pooling.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "393:                 )",
      "394:             };",
      "396:             if let Some(image) = runtime_info",
      "397:                 .memory_image(defined_index)",
      "398:                 .map_err(|err| InstantiationError::Resource(err.into()))?",
      "399:             {",
      "403:                 let initial_size = plan.memory.minimum * WASM_PAGE_SIZE as u64;",
      "",
      "[Removed Lines]",
      "400:                 let mut slot = self",
      "401:                     .memories",
      "402:                     .take_memory_image_slot(instance_index, defined_index);",
      "",
      "[Added Lines]",
      "396:             let mut slot = self",
      "397:                 .memories",
      "398:                 .take_memory_image_slot(instance_index, defined_index);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "425:                     .map_err(InstantiationError::Resource)?,",
      "426:                 );",
      "427:             } else {",
      "428:                 memories.push(",
      "429:                     Memory::new_static(plan, memory, Some(commit_memory_pages), None, unsafe {",
      "430:                         &mut *store.unwrap()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "428:                 drop(slot);",
      "",
      "---------------"
    ],
    "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs": [
      "File: tests/all/pooling_allocator.rs -> tests/all/pooling_allocator.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "615:     Ok(())",
      "616: }",
      "618: #[test]",
      "619: #[cfg(target_pointer_width = \"64\")]",
      "620: fn instance_too_large() -> Result<()> {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "618: #[test]",
      "619: fn switch_image_and_non_image() -> Result<()> {",
      "620:     let mut c = Config::new();",
      "621:     c.allocation_strategy(InstanceAllocationStrategy::Pooling {",
      "622:         instance_limits: InstanceLimits {",
      "623:             count: 1,",
      "624:             ..Default::default()",
      "625:         },",
      "626:         strategy: Default::default(),",
      "627:     });",
      "628:     let engine = Engine::new(&c)?;",
      "629:     let module1 = Module::new(",
      "630:         &engine,",
      "631:         r#\"",
      "632:             (module",
      "633:                 (memory 1)",
      "634:                 (func (export \"load\") (param i32) (result i32)",
      "635:                     local.get 0",
      "636:                     i32.load",
      "637:                 )",
      "638:             )",
      "639:         \"#,",
      "640:     )?;",
      "641:     let module2 = Module::new(",
      "642:         &engine,",
      "643:         r#\"",
      "644:             (module",
      "645:                 (memory (export \"memory\") 1)",
      "646:                 (data (i32.const 0) \"1234\")",
      "647:             )",
      "648:         \"#,",
      "649:     )?;",
      "651:     let assert_zero = || -> Result<()> {",
      "652:         let mut store = Store::new(&engine, ());",
      "653:         let instance = Instance::new(&mut store, &module1, &[])?;",
      "654:         let func = instance.get_typed_func::<i32, i32, _>(&mut store, \"load\")?;",
      "655:         assert_eq!(func.call(&mut store, 0)?, 0);",
      "656:         Ok(())",
      "657:     };",
      "661:     Instance::new(&mut Store::new(&engine, ()), &module2, &[])?;",
      "662:     assert_zero()?;",
      "665:     Instance::new(&mut Store::new(&engine, ()), &module2, &[])?;",
      "666:     assert_zero()?;",
      "669:     let mut store = Store::new(&engine, ());",
      "670:     let instance = Instance::new(&mut store, &module2, &[])?;",
      "671:     let memory = instance.get_memory(&mut store, \"memory\").unwrap();",
      "672:     let mem = memory.data_mut(&mut store);",
      "673:     assert!(mem.starts_with(b\"1234\"));",
      "674:     mem[..6].copy_from_slice(b\"567890\");",
      "676:     Ok(())",
      "677: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "723409bc5884798ca23f432f613f74841e31899b",
      "candidate_info": {
        "commit_hash": "723409bc5884798ca23f432f613f74841e31899b",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/723409bc5884798ca23f432f613f74841e31899b",
        "files": [
          "crates/runtime/src/instance/allocator/pooling.rs",
          "tests/all/pooling_allocator.rs"
        ],
        "message": "Merge pull request from GHSA-wh6w-3828-g9qf\n\nThis is a minimal fix for the release branch to fix the issue of having\na memory slot get reused between a module with an image and one without.",
        "before_after_code_files": [
          "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
          "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
            "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
          ],
          "candidate": [
            "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
            "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
          ]
        }
      },
      "candidate_diff": {
        "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs": [
          "File: crates/runtime/src/instance/allocator/pooling.rs -> crates/runtime/src/instance/allocator/pooling.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "316:                 )",
          "317:             };",
          "319:             if let Some(image) = runtime_info",
          "320:                 .memory_image(defined_index)",
          "321:                 .map_err(|err| InstantiationError::Resource(err.into()))?",
          "322:             {",
          "326:                 let initial_size = plan.memory.minimum * WASM_PAGE_SIZE as u64;",
          "",
          "[Removed Lines]",
          "323:                 let mut slot = self",
          "324:                     .memories",
          "325:                     .take_memory_image_slot(instance_index, defined_index);",
          "",
          "[Added Lines]",
          "319:             let mut slot = self",
          "320:                 .memories",
          "321:                 .take_memory_image_slot(instance_index, defined_index);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "348:                     .map_err(InstantiationError::Resource)?,",
          "349:                 );",
          "350:             } else {",
          "351:                 memories.push(",
          "352:                     Memory::new_static(plan, memory, Some(commit_memory_pages), None, unsafe {",
          "353:                         &mut *store.unwrap()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "351:                 drop(slot);",
          "",
          "---------------"
        ],
        "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs": [
          "File: tests/all/pooling_allocator.rs -> tests/all/pooling_allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "579:     Ok(())",
          "580: }",
          "582: #[test]",
          "583: #[cfg(target_pointer_width = \"64\")]",
          "584: fn instance_too_large() -> Result<()> {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "582: #[test]",
          "583: fn switch_image_and_non_image() -> Result<()> {",
          "584:     let mut c = Config::new();",
          "585:     c.allocation_strategy(InstanceAllocationStrategy::Pooling {",
          "586:         instance_limits: InstanceLimits {",
          "587:             count: 1,",
          "588:             ..Default::default()",
          "589:         },",
          "590:         strategy: Default::default(),",
          "591:     });",
          "592:     let engine = Engine::new(&c)?;",
          "593:     let module1 = Module::new(",
          "594:         &engine,",
          "595:         r#\"",
          "596:             (module",
          "597:                 (memory 1)",
          "598:                 (func (export \"load\") (param i32) (result i32)",
          "599:                     local.get 0",
          "600:                     i32.load",
          "601:                 )",
          "602:             )",
          "603:         \"#,",
          "604:     )?;",
          "605:     let module2 = Module::new(",
          "606:         &engine,",
          "607:         r#\"",
          "608:             (module",
          "609:                 (memory (export \"memory\") 1)",
          "610:                 (data (i32.const 0) \"1234\")",
          "611:             )",
          "612:         \"#,",
          "613:     )?;",
          "615:     let assert_zero = || -> Result<()> {",
          "616:         let mut store = Store::new(&engine, ());",
          "617:         let instance = Instance::new(&mut store, &module1, &[])?;",
          "618:         let func = instance.get_typed_func::<i32, i32, _>(&mut store, \"load\")?;",
          "619:         assert_eq!(func.call(&mut store, 0)?, 0);",
          "620:         Ok(())",
          "621:     };",
          "625:     Instance::new(&mut Store::new(&engine, ()), &module2, &[])?;",
          "626:     assert_zero()?;",
          "629:     Instance::new(&mut Store::new(&engine, ()), &module2, &[])?;",
          "630:     assert_zero()?;",
          "633:     let mut store = Store::new(&engine, ());",
          "634:     let instance = Instance::new(&mut store, &module2, &[])?;",
          "635:     let memory = instance.get_memory(&mut store, \"memory\").unwrap();",
          "636:     let mem = memory.data_mut(&mut store);",
          "637:     assert!(mem.starts_with(b\"1234\"));",
          "638:     mem[..6].copy_from_slice(b\"567890\");",
          "640:     Ok(())",
          "641: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
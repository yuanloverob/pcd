{
  "cve_id": "CVE-2022-24348",
  "cve_desc": "Argo CD before 2.1.9 and 2.2.x before 2.2.4 allows directory traversal related to Helm charts because of an error in helmTemplate in repository.go. For example, an attacker may be able to discover credentials stored in a YAML file.",
  "repo": "argoproj/argo-cd",
  "patch_hash": "78c2084f0febd159039ff785ddc2bd4ba1cecf88",
  "patch_info": {
    "commit_hash": "78c2084f0febd159039ff785ddc2bd4ba1cecf88",
    "repo": "argoproj/argo-cd",
    "commit_url": "https://github.com/argoproj/argo-cd/commit/78c2084f0febd159039ff785ddc2bd4ba1cecf88",
    "files": [
      "reposerver/repository/repository.go",
      "reposerver/repository/repository_test.go",
      "reposerver/repository/testdata/symlinks/bam",
      "reposerver/repository/testdata/symlinks/bar",
      "reposerver/repository/testdata/symlinks/baz",
      "reposerver/repository/testdata/symlinks/foo"
    ],
    "message": "Merge pull request from GHSA-63qx-x74g-jcr7\n\nSigned-off-by: jannfis <jann@mistrust.net>",
    "before_after_code_files": [
      "reposerver/repository/repository.go||reposerver/repository/repository.go",
      "reposerver/repository/repository_test.go||reposerver/repository/repository_test.go"
    ]
  },
  "patch_diff": {
    "reposerver/repository/repository.go||reposerver/repository/repository.go": [
      "File: reposerver/repository/repository.go -> reposerver/repository/repository.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "52:  \"github.com/argoproj/argo-cd/v2/util/io\"",
      "53:  \"github.com/argoproj/argo-cd/v2/util/ksonnet\"",
      "54:  \"github.com/argoproj/argo-cd/v2/util/kustomize\"",
      "56:  \"github.com/argoproj/argo-cd/v2/util/text\"",
      "57: )",
      "",
      "[Removed Lines]",
      "55:  \"github.com/argoproj/argo-cd/v2/util/security\"",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "66:  ociPrefix                      = \"oci://\"",
      "67: )",
      "70: type Service struct {",
      "71:  repoLock                  *repositoryLock",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "69: var allowedHelmRemoteProtocols = []string{\"http\", \"https\"}",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "554:  return ioutil.WriteFile(markerFile, []byte(\"marker\"), 0644)",
      "555: }",
      "557: func helmTemplate(appPath string, repoRoot string, env *v1alpha1.Env, q *apiclient.ManifestRequest, isLocal bool) ([]*unstructured.Unstructured, error) {",
      "558:  concurrencyAllowed := isConcurrencyAllowed(appPath)",
      "559:  if !concurrencyAllowed {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "562: func resolveSymbolicLinkRecursive(path string, maxDepth int) (string, error) {",
      "563:  resolved, err := os.Readlink(path)",
      "564:  if err != nil {",
      "566:   _, ok := err.(*os.PathError)",
      "567:   if ok {",
      "568:    return path, nil",
      "569:   }",
      "571:   return \"\", err",
      "572:  }",
      "574:  if maxDepth == 0 {",
      "575:   return \"\", fmt.Errorf(\"maximum nesting level reached\")",
      "576:  }",
      "578:  return resolveSymbolicLinkRecursive(resolved, maxDepth-1)",
      "579: }",
      "583: func isURLSchemeAllowed(scheme string, allowed []string) bool {",
      "584:  isAllowed := false",
      "585:  if len(allowed) > 0 {",
      "586:   for _, s := range allowed {",
      "587:    if strings.EqualFold(scheme, s) {",
      "588:     isAllowed = true",
      "589:     break",
      "590:    }",
      "591:   }",
      "592:  }",
      "595:  return isAllowed && scheme != \"\"",
      "596: }",
      "627: func resolveHelmValueFilePath(appPath, repoRoot, valueFile string, allowedURLSchemes []string) (resolvedPath string, isRemote bool, err error) {",
      "632:  resolveFailure := func(path string, err error) error {",
      "633:   log.Errorf(\"failed to resolve path '%s': %v\", path, err)",
      "634:   return fmt.Errorf(\"internal error: failed to resolve path. Check logs for more details\")",
      "635:  }",
      "639:  url, err := url.Parse(valueFile)",
      "640:  if err == nil {",
      "642:   if url.Scheme != \"\" {",
      "643:    if isURLSchemeAllowed(url.Scheme, allowedURLSchemes) {",
      "644:     return valueFile, true, nil",
      "645:    } else {",
      "646:     return \"\", false, fmt.Errorf(\"the URL scheme '%s' is not allowed\", url.Scheme)",
      "647:    }",
      "648:   }",
      "649:  }",
      "652:  absRepoPath, err := filepath.Abs(repoRoot)",
      "653:  if err != nil {",
      "654:   return \"\", false, resolveFailure(repoRoot, err)",
      "655:  }",
      "659:  path := valueFile",
      "660:  if !filepath.IsAbs(path) {",
      "661:   absWorkDir, err := filepath.Abs(appPath)",
      "662:   if err != nil {",
      "663:    return \"\", false, resolveFailure(repoRoot, err)",
      "664:   }",
      "665:   path = filepath.Join(absWorkDir, path)",
      "666:  } else {",
      "667:   path = filepath.Join(absRepoPath, path)",
      "668:  }",
      "671:  delinkedPath, err := resolveSymbolicLinkRecursive(path, 10)",
      "672:  if err != nil {",
      "673:   return \"\", false, resolveFailure(path, err)",
      "674:  }",
      "675:  path = delinkedPath",
      "678:  path, err = filepath.Abs(path)",
      "679:  if err != nil {",
      "680:   return \"\", false, resolveFailure(path, err)",
      "681:  }",
      "685:  requiredRootPath := absRepoPath",
      "686:  if !strings.HasSuffix(requiredRootPath, \"/\") {",
      "687:   requiredRootPath += \"/\"",
      "688:  }",
      "691:  if !strings.HasPrefix(path, requiredRootPath) {",
      "692:   return \"\", false, fmt.Errorf(\"value file '%s' resolved to outside repository root\", valueFile)",
      "693:  }",
      "695:  return path, false, nil",
      "697: }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "583:   }",
      "585:   for _, val := range appHelm.ValueFiles {",
      "611:     _, err = os.Stat(path)",
      "612:     if os.IsNotExist(err) {",
      "613:      if appHelm.IgnoreMissingValueFiles {",
      "",
      "[Removed Lines]",
      "588:    if _, err := url.ParseRequestURI(val); err != nil {",
      "591:     absRepoPath, err := filepath.Abs(repoRoot)",
      "592:     if err != nil {",
      "593:      return nil, err",
      "594:     }",
      "597:     path := val",
      "598:     if !filepath.IsAbs(path) {",
      "599:      absWorkDir, err := filepath.Abs(appPath)",
      "600:      if err != nil {",
      "601:       return nil, err",
      "602:      }",
      "603:      path = filepath.Join(absWorkDir, path)",
      "604:     }",
      "606:     _, err = security.EnforceToCurrentRoot(absRepoPath, path)",
      "607:     if err != nil {",
      "608:      return nil, err",
      "609:     }",
      "",
      "[Added Lines]",
      "730:    path, isRemote, err := resolveHelmValueFilePath(appPath, repoRoot, val, allowedHelmRemoteProtocols)",
      "731:    if err != nil {",
      "732:     return nil, err",
      "733:    }",
      "735:    if !isRemote {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "616:      }",
      "617:     }",
      "618:    }",
      "620:   }",
      "622:   if appHelm.Values != \"\" {",
      "",
      "[Removed Lines]",
      "619:    templateOpts.Values = append(templateOpts.Values, val)",
      "",
      "[Added Lines]",
      "745:    templateOpts.Values = append(templateOpts.Values, path)",
      "",
      "---------------"
    ],
    "reposerver/repository/repository_test.go||reposerver/repository/repository_test.go": [
      "File: reposerver/repository/repository_test.go -> reposerver/repository/repository_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "754:  }",
      "755:  request := &apiclient.ManifestRequest{Repo: &argoappv1.Repository{}, ApplicationSource: source, NoCache: true}",
      "756:  _, err := service.GenerateManifest(context.Background(), request)",
      "758: }",
      "760: func TestGenerateHelmWithURL(t *testing.T) {",
      "",
      "[Removed Lines]",
      "757:  assert.Error(t, err, \"should be on or under current directory\")",
      "",
      "[Added Lines]",
      "757:  assert.Error(t, err)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "779: func TestGenerateHelmWithValuesDirectoryTraversalOutsideRepo(t *testing.T) {",
      "789:    },",
      "791:  })",
      "803:    },",
      "805:  })",
      "807: }",
      "",
      "[Removed Lines]",
      "780:  service := newService(\"../..\")",
      "781:  _, err := service.GenerateManifest(context.Background(), &apiclient.ManifestRequest{",
      "782:   Repo:    &argoappv1.Repository{},",
      "783:   AppName: \"test\",",
      "784:   ApplicationSource: &argoappv1.ApplicationSource{",
      "785:    Path: \"./util/helm/testdata/redis\",",
      "786:    Helm: &argoappv1.ApplicationSourceHelm{",
      "787:     ValueFiles: []string{\"../../../../../minio/values.yaml\"},",
      "788:     Values:     `cluster: {slaveCount: 2}`,",
      "790:   },",
      "792:  assert.Error(t, err, \"should be on or under current directory\")",
      "794:  service = newService(\"./testdata/my-chart\")",
      "795:  _, err = service.GenerateManifest(context.Background(), &apiclient.ManifestRequest{",
      "796:   Repo:    &argoappv1.Repository{},",
      "797:   AppName: \"test\",",
      "798:   ApplicationSource: &argoappv1.ApplicationSource{",
      "799:    Path: \".\",",
      "800:    Helm: &argoappv1.ApplicationSourceHelm{",
      "801:     ValueFiles: []string{\"../my-chart-2/values.yaml\"},",
      "802:     Values:     `cluster: {slaveCount: 2}`,",
      "804:   },",
      "806:  assert.Error(t, err, \"should be on or under current directory\")",
      "",
      "[Added Lines]",
      "780:  t.Run(\"Values file with relative path pointing outside repo root\", func(t *testing.T) {",
      "781:   service := newService(\"../..\")",
      "782:   _, err := service.GenerateManifest(context.Background(), &apiclient.ManifestRequest{",
      "783:    Repo:    &argoappv1.Repository{},",
      "784:    AppName: \"test\",",
      "785:    ApplicationSource: &argoappv1.ApplicationSource{",
      "786:     Path: \"./util/helm/testdata/redis\",",
      "787:     Helm: &argoappv1.ApplicationSourceHelm{",
      "788:      ValueFiles: []string{\"../../../../../minio/values.yaml\"},",
      "789:      Values:     `cluster: {slaveCount: 2}`,",
      "790:     },",
      "792:   })",
      "793:   assert.Error(t, err)",
      "794:   assert.Contains(t, err.Error(), \"outside repository root\")",
      "797:  t.Run(\"Values file with relative path pointing inside repo root\", func(t *testing.T) {",
      "798:   service := newService(\"./testdata/my-chart\")",
      "799:   _, err := service.GenerateManifest(context.Background(), &apiclient.ManifestRequest{",
      "800:    Repo:    &argoappv1.Repository{},",
      "801:    AppName: \"test\",",
      "802:    ApplicationSource: &argoappv1.ApplicationSource{",
      "803:     Path: \".\",",
      "804:     Helm: &argoappv1.ApplicationSourceHelm{",
      "805:      ValueFiles: []string{\"../my-chart/my-chart-values.yaml\"},",
      "806:      Values:     `cluster: {slaveCount: 2}`,",
      "807:     },",
      "809:   })",
      "810:   assert.NoError(t, err)",
      "811:  })",
      "813:  t.Run(\"Values file with absolute path stays within repo root\", func(t *testing.T) {",
      "814:   service := newService(\"./testdata/my-chart\")",
      "815:   _, err := service.GenerateManifest(context.Background(), &apiclient.ManifestRequest{",
      "816:    Repo:    &argoappv1.Repository{},",
      "817:    AppName: \"test\",",
      "818:    ApplicationSource: &argoappv1.ApplicationSource{",
      "819:     Path: \".\",",
      "820:     Helm: &argoappv1.ApplicationSourceHelm{",
      "821:      ValueFiles: []string{\"/my-chart-values.yaml\"},",
      "822:      Values:     `cluster: {slaveCount: 2}`,",
      "823:     },",
      "824:    },",
      "825:   })",
      "826:   assert.NoError(t, err)",
      "827:  })",
      "829:  t.Run(\"Values file with absolute path using back-references outside repo root\", func(t *testing.T) {",
      "830:   service := newService(\"./testdata/my-chart\")",
      "831:   _, err := service.GenerateManifest(context.Background(), &apiclient.ManifestRequest{",
      "832:    Repo:    &argoappv1.Repository{},",
      "833:    AppName: \"test\",",
      "834:    ApplicationSource: &argoappv1.ApplicationSource{",
      "835:     Path: \".\",",
      "836:     Helm: &argoappv1.ApplicationSourceHelm{",
      "837:      ValueFiles: []string{\"/../../../my-chart-values.yaml\"},",
      "838:      Values:     `cluster: {slaveCount: 2}`,",
      "839:     },",
      "840:    },",
      "841:   })",
      "842:   assert.Error(t, err)",
      "843:   assert.Contains(t, err.Error(), \"outside repository root\")",
      "844:  })",
      "846:  t.Run(\"Remote values file from forbidden protocol\", func(t *testing.T) {",
      "847:   service := newService(\"./testdata/my-chart\")",
      "848:   _, err := service.GenerateManifest(context.Background(), &apiclient.ManifestRequest{",
      "849:    Repo:    &argoappv1.Repository{},",
      "850:    AppName: \"test\",",
      "851:    ApplicationSource: &argoappv1.ApplicationSource{",
      "852:     Path: \".\",",
      "853:     Helm: &argoappv1.ApplicationSourceHelm{",
      "854:      ValueFiles: []string{\"file://../../../../my-chart-values.yaml\"},",
      "855:      Values:     `cluster: {slaveCount: 2}`,",
      "856:     },",
      "857:    },",
      "858:   })",
      "859:   assert.Error(t, err)",
      "860:   assert.Contains(t, err.Error(), \"is not allowed\")",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1631:  assert.Equal(t, expectedResolveRevisionResponse, resolveRevisionResponse)",
      "1633: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1690: func Test_resolveSymlinkRecursive(t *testing.T) {",
      "1691:  cwd, err := os.Getwd()",
      "1692:  require.NoError(t, err)",
      "1693:  err = os.Chdir(\"testdata/symlinks\")",
      "1694:  require.NoError(t, err)",
      "1695:  defer func() {",
      "1696:   err := os.Chdir(cwd)",
      "1697:   if err != nil {",
      "1698:    panic(err)",
      "1699:   }",
      "1700:  }()",
      "1701:  t.Run(\"Resolve non-symlink\", func(t *testing.T) {",
      "1702:   r, err := resolveSymbolicLinkRecursive(\"foo\", 2)",
      "1703:   assert.NoError(t, err)",
      "1704:   assert.Equal(t, \"foo\", r)",
      "1705:  })",
      "1706:  t.Run(\"Successfully resolve symlink\", func(t *testing.T) {",
      "1707:   r, err := resolveSymbolicLinkRecursive(\"bar\", 2)",
      "1708:   assert.NoError(t, err)",
      "1709:   assert.Equal(t, \"foo\", r)",
      "1710:  })",
      "1711:  t.Run(\"Do not allow symlink at all\", func(t *testing.T) {",
      "1712:   r, err := resolveSymbolicLinkRecursive(\"bar\", 0)",
      "1713:   assert.Error(t, err)",
      "1714:   assert.Equal(t, \"\", r)",
      "1715:  })",
      "1716:  t.Run(\"Error because too nested symlink\", func(t *testing.T) {",
      "1717:   r, err := resolveSymbolicLinkRecursive(\"bam\", 2)",
      "1718:   assert.Error(t, err)",
      "1719:   assert.Equal(t, \"\", r)",
      "1720:  })",
      "1721:  t.Run(\"No such file or directory\", func(t *testing.T) {",
      "1722:   r, err := resolveSymbolicLinkRecursive(\"foobar\", 2)",
      "1723:   assert.NoError(t, err)",
      "1724:   assert.Equal(t, \"foobar\", r)",
      "1725:  })",
      "1726: }",
      "1728: func Test_isURLSchemeAllowed(t *testing.T) {",
      "1729:  type testdata struct {",
      "1730:   name     string",
      "1731:   scheme   string",
      "1732:   allowed  []string",
      "1733:   expected bool",
      "1734:  }",
      "1735:  var tts []testdata = []testdata{",
      "1736:   {",
      "1737:    name:     \"Allowed scheme matches\",",
      "1738:    scheme:   \"http\",",
      "1739:    allowed:  []string{\"http\", \"https\"},",
      "1740:    expected: true,",
      "1741:   },",
      "1742:   {",
      "1743:    name:     \"Allowed scheme matches only partially\",",
      "1744:    scheme:   \"http\",",
      "1745:    allowed:  []string{\"https\"},",
      "1746:    expected: false,",
      "1747:   },",
      "1748:   {",
      "1749:    name:     \"Scheme is not allowed\",",
      "1750:    scheme:   \"file\",",
      "1751:    allowed:  []string{\"http\", \"https\"},",
      "1752:    expected: false,",
      "1753:   },",
      "1754:   {",
      "1755:    name:     \"Empty scheme with valid allowances is forbidden\",",
      "1756:    scheme:   \"\",",
      "1757:    allowed:  []string{\"http\", \"https\"},",
      "1758:    expected: false,",
      "1759:   },",
      "1760:   {",
      "1761:    name:     \"Empty scheme with empty allowances is forbidden\",",
      "1762:    scheme:   \"\",",
      "1763:    allowed:  []string{},",
      "1764:    expected: false,",
      "1765:   },",
      "1766:   {",
      "1767:    name:     \"Some scheme with empty allowances is forbidden\",",
      "1768:    scheme:   \"file\",",
      "1769:    allowed:  []string{},",
      "1770:    expected: false,",
      "1771:   },",
      "1772:  }",
      "1773:  for _, tt := range tts {",
      "1774:   t.Run(tt.name, func(t *testing.T) {",
      "1775:    r := isURLSchemeAllowed(tt.scheme, tt.allowed)",
      "1776:    assert.Equal(t, tt.expected, r)",
      "1777:   })",
      "1778:  }",
      "1779: }",
      "1781: func Test_resolveHelmValueFilePath(t *testing.T) {",
      "1782:  t.Run(\"Resolve normal relative path into absolute path\", func(t *testing.T) {",
      "1783:   p, remote, err := resolveHelmValueFilePath(\"/foo/bar\", \"/foo\", \"baz/bim.yaml\", allowedHelmRemoteProtocols)",
      "1784:   assert.NoError(t, err)",
      "1785:   assert.False(t, remote)",
      "1786:   assert.Equal(t, \"/foo/bar/baz/bim.yaml\", p)",
      "1787:  })",
      "1788:  t.Run(\"Resolve normal relative path into absolute path\", func(t *testing.T) {",
      "1789:   p, remote, err := resolveHelmValueFilePath(\"/foo/bar\", \"/foo\", \"baz/../../bim.yaml\", allowedHelmRemoteProtocols)",
      "1790:   assert.NoError(t, err)",
      "1791:   assert.False(t, remote)",
      "1792:   assert.Equal(t, \"/foo/bim.yaml\", p)",
      "1793:  })",
      "1794:  t.Run(\"Error on path resolving outside repository root\", func(t *testing.T) {",
      "1795:   p, remote, err := resolveHelmValueFilePath(\"/foo/bar\", \"/foo\", \"baz/../../../bim.yaml\", allowedHelmRemoteProtocols)",
      "1796:   assert.Error(t, err)",
      "1797:   assert.Contains(t, err.Error(), \"outside repository root\")",
      "1798:   assert.False(t, remote)",
      "1799:   assert.Equal(t, \"\", p)",
      "1800:  })",
      "1801:  t.Run(\"Return verbatim URL\", func(t *testing.T) {",
      "1802:   url := \"https://some.where/foo,yaml\"",
      "1803:   p, remote, err := resolveHelmValueFilePath(\"/foo/bar\", \"/foo\", url, allowedHelmRemoteProtocols)",
      "1804:   assert.NoError(t, err)",
      "1805:   assert.True(t, remote)",
      "1806:   assert.Equal(t, url, p)",
      "1807:  })",
      "1808:  t.Run(\"URL scheme not allowed\", func(t *testing.T) {",
      "1809:   url := \"file:///some.where/foo,yaml\"",
      "1810:   p, remote, err := resolveHelmValueFilePath(\"/foo/bar\", \"/foo\", url, allowedHelmRemoteProtocols)",
      "1811:   assert.Error(t, err)",
      "1812:   assert.False(t, remote)",
      "1813:   assert.Equal(t, \"\", p)",
      "1814:  })",
      "1815:  t.Run(\"Implicit URL by absolute path\", func(t *testing.T) {",
      "1816:   p, remote, err := resolveHelmValueFilePath(\"/foo/bar\", \"/foo\", \"/baz.yaml\", allowedHelmRemoteProtocols)",
      "1817:   assert.NoError(t, err)",
      "1818:   assert.False(t, remote)",
      "1819:   assert.Equal(t, \"/foo/baz.yaml\", p)",
      "1820:  })",
      "1821:  t.Run(\"Relative app path\", func(t *testing.T) {",
      "1822:   p, remote, err := resolveHelmValueFilePath(\".\", \"/foo\", \"/baz.yaml\", allowedHelmRemoteProtocols)",
      "1823:   assert.NoError(t, err)",
      "1824:   assert.False(t, remote)",
      "1825:   assert.Equal(t, \"/foo/baz.yaml\", p)",
      "1826:  })",
      "1827:  t.Run(\"Relative repo path\", func(t *testing.T) {",
      "1828:   c, err := os.Getwd()",
      "1829:   require.NoError(t, err)",
      "1830:   p, remote, err := resolveHelmValueFilePath(\".\", \".\", \"baz.yaml\", allowedHelmRemoteProtocols)",
      "1831:   assert.NoError(t, err)",
      "1832:   assert.False(t, remote)",
      "1833:   assert.Equal(t, c+\"/baz.yaml\", p)",
      "1834:  })",
      "1835:  t.Run(\"Overlapping root prefix without trailing slash\", func(t *testing.T) {",
      "1836:   p, remote, err := resolveHelmValueFilePath(\".\", \"/foo\", \"../foo2/baz.yaml\", allowedHelmRemoteProtocols)",
      "1837:   assert.Error(t, err)",
      "1838:   assert.Contains(t, err.Error(), \"outside repository root\")",
      "1839:   assert.False(t, remote)",
      "1840:   assert.Equal(t, \"\", p)",
      "1841:  })",
      "1842:  t.Run(\"Overlapping root prefix with trailing slash\", func(t *testing.T) {",
      "1843:   p, remote, err := resolveHelmValueFilePath(\".\", \"/foo/\", \"../foo2/baz.yaml\", allowedHelmRemoteProtocols)",
      "1844:   assert.Error(t, err)",
      "1845:   assert.Contains(t, err.Error(), \"outside repository root\")",
      "1846:   assert.False(t, remote)",
      "1847:   assert.Equal(t, \"\", p)",
      "1848:  })",
      "1849:  t.Run(\"Garbage input as values file\", func(t *testing.T) {",
      "1850:   p, remote, err := resolveHelmValueFilePath(\".\", \"/foo/\", \"kfdj\\\\ks&&&321209.,---e32908923%$\u00a7!\\\"\", allowedHelmRemoteProtocols)",
      "1851:   assert.Error(t, err)",
      "1852:   assert.Contains(t, err.Error(), \"outside repository root\")",
      "1853:   assert.False(t, remote)",
      "1854:   assert.Equal(t, \"\", p)",
      "1855:  })",
      "1856:  t.Run(\"NUL-byte path input as values file\", func(t *testing.T) {",
      "1857:   p, remote, err := resolveHelmValueFilePath(\".\", \"/foo/\", \"\\000\", allowedHelmRemoteProtocols)",
      "1858:   assert.Error(t, err)",
      "1859:   assert.Contains(t, err.Error(), \"outside repository root\")",
      "1860:   assert.False(t, remote)",
      "1861:   assert.Equal(t, \"\", p)",
      "1862:  })",
      "1863: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "02e61797b3ce407e3d4baa772a0863bba8cd2899",
      "candidate_info": {
        "commit_hash": "02e61797b3ce407e3d4baa772a0863bba8cd2899",
        "repo": "argoproj/argo-cd",
        "commit_url": "https://github.com/argoproj/argo-cd/commit/02e61797b3ce407e3d4baa772a0863bba8cd2899",
        "files": [
          "reposerver/repository/repository.go",
          "reposerver/repository/repository_test.go",
          "reposerver/repository/testdata/symlinks/bam",
          "reposerver/repository/testdata/symlinks/bar",
          "reposerver/repository/testdata/symlinks/baz",
          "reposerver/repository/testdata/symlinks/foo"
        ],
        "message": "Merge pull request from GHSA-63qx-x74g-jcr7\n\nSigned-off-by: jannfis <jann@mistrust.net>",
        "before_after_code_files": [
          "reposerver/repository/repository.go||reposerver/repository/repository.go",
          "reposerver/repository/repository_test.go||reposerver/repository/repository_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "reposerver/repository/repository.go||reposerver/repository/repository.go",
            "reposerver/repository/repository_test.go||reposerver/repository/repository_test.go"
          ],
          "candidate": [
            "reposerver/repository/repository.go||reposerver/repository/repository.go",
            "reposerver/repository/repository_test.go||reposerver/repository/repository_test.go"
          ]
        }
      },
      "candidate_diff": {
        "reposerver/repository/repository.go||reposerver/repository/repository.go": [
          "File: reposerver/repository/repository.go -> reposerver/repository/repository.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "51:  \"github.com/argoproj/argo-cd/v2/util/io\"",
          "52:  \"github.com/argoproj/argo-cd/v2/util/ksonnet\"",
          "53:  \"github.com/argoproj/argo-cd/v2/util/kustomize\"",
          "55:  \"github.com/argoproj/argo-cd/v2/util/text\"",
          "56: )",
          "",
          "[Removed Lines]",
          "54:  \"github.com/argoproj/argo-cd/v2/util/security\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65:  ociPrefix                      = \"oci://\"",
          "66: )",
          "69: type Service struct {",
          "70:  repoLock                  *repositoryLock",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68: var allowedHelmRemoteProtocols = []string{\"http\", \"https\"}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "553:  return ioutil.WriteFile(markerFile, []byte(\"marker\"), 0644)",
          "554: }",
          "556: func helmTemplate(appPath string, repoRoot string, env *v1alpha1.Env, q *apiclient.ManifestRequest, isLocal bool) ([]*unstructured.Unstructured, error) {",
          "557:  concurrencyAllowed := isConcurrencyAllowed(appPath)",
          "558:  if !concurrencyAllowed {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "561: func resolveSymbolicLinkRecursive(path string, maxDepth int) (string, error) {",
          "562:  resolved, err := os.Readlink(path)",
          "563:  if err != nil {",
          "565:   _, ok := err.(*os.PathError)",
          "566:   if ok {",
          "567:    return path, nil",
          "568:   }",
          "570:   return \"\", err",
          "571:  }",
          "573:  if maxDepth == 0 {",
          "574:   return \"\", fmt.Errorf(\"maximum nesting level reached\")",
          "575:  }",
          "577:  return resolveSymbolicLinkRecursive(resolved, maxDepth-1)",
          "578: }",
          "582: func isURLSchemeAllowed(scheme string, allowed []string) bool {",
          "583:  isAllowed := false",
          "584:  if len(allowed) > 0 {",
          "585:   for _, s := range allowed {",
          "586:    if strings.EqualFold(scheme, s) {",
          "587:     isAllowed = true",
          "588:     break",
          "589:    }",
          "590:   }",
          "591:  }",
          "594:  return isAllowed && scheme != \"\"",
          "595: }",
          "626: func resolveHelmValueFilePath(appPath, repoRoot, valueFile string, allowedURLSchemes []string) (resolvedPath string, isRemote bool, err error) {",
          "631:  resolveFailure := func(path string, err error) error {",
          "632:   log.Errorf(\"failed to resolve path '%s': %v\", path, err)",
          "633:   return fmt.Errorf(\"internal error: failed to resolve path. Check logs for more details\")",
          "634:  }",
          "638:  url, err := url.Parse(valueFile)",
          "639:  if err == nil {",
          "641:   if url.Scheme != \"\" {",
          "642:    if isURLSchemeAllowed(url.Scheme, allowedURLSchemes) {",
          "643:     return valueFile, true, nil",
          "644:    } else {",
          "645:     return \"\", false, fmt.Errorf(\"the URL scheme '%s' is not allowed\", url.Scheme)",
          "646:    }",
          "647:   }",
          "648:  }",
          "651:  absRepoPath, err := filepath.Abs(repoRoot)",
          "652:  if err != nil {",
          "653:   return \"\", false, resolveFailure(repoRoot, err)",
          "654:  }",
          "658:  path := valueFile",
          "659:  if !filepath.IsAbs(path) {",
          "660:   absWorkDir, err := filepath.Abs(appPath)",
          "661:   if err != nil {",
          "662:    return \"\", false, resolveFailure(repoRoot, err)",
          "663:   }",
          "664:   path = filepath.Join(absWorkDir, path)",
          "665:  } else {",
          "666:   path = filepath.Join(absRepoPath, path)",
          "667:  }",
          "670:  delinkedPath, err := resolveSymbolicLinkRecursive(path, 10)",
          "671:  if err != nil {",
          "672:   return \"\", false, resolveFailure(path, err)",
          "673:  }",
          "674:  path = delinkedPath",
          "677:  path, err = filepath.Abs(path)",
          "678:  if err != nil {",
          "679:   return \"\", false, resolveFailure(path, err)",
          "680:  }",
          "684:  requiredRootPath := absRepoPath",
          "685:  if !strings.HasSuffix(requiredRootPath, \"/\") {",
          "686:   requiredRootPath += \"/\"",
          "687:  }",
          "690:  if !strings.HasPrefix(path, requiredRootPath) {",
          "691:   return \"\", false, fmt.Errorf(\"value file '%s' resolved to outside repository root\", valueFile)",
          "692:  }",
          "694:  return path, false, nil",
          "696: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "582:   }",
          "584:   for _, val := range appHelm.ValueFiles {",
          "608:    }",
          "610:   }",
          "612:   if appHelm.Values != \"\" {",
          "",
          "[Removed Lines]",
          "586:    if _, err := url.ParseRequestURI(val); err != nil {",
          "589:     absRepoPath, err := filepath.Abs(repoRoot)",
          "590:     if err != nil {",
          "591:      return nil, err",
          "592:     }",
          "595:     path := val",
          "596:     if !filepath.IsAbs(path) {",
          "597:      absWorkDir, err := filepath.Abs(appPath)",
          "598:      if err != nil {",
          "599:       return nil, err",
          "600:      }",
          "601:      path = filepath.Join(absWorkDir, path)",
          "602:     }",
          "604:     _, err = security.EnforceToCurrentRoot(absRepoPath, path)",
          "605:     if err != nil {",
          "606:      return nil, err",
          "607:     }",
          "609:    templateOpts.Values = append(templateOpts.Values, val)",
          "",
          "[Added Lines]",
          "729:    path, _, err := resolveHelmValueFilePath(appPath, repoRoot, val, allowedHelmRemoteProtocols)",
          "730:    if err != nil {",
          "731:     return nil, err",
          "734:    templateOpts.Values = append(templateOpts.Values, path)",
          "",
          "---------------"
        ],
        "reposerver/repository/repository_test.go||reposerver/repository/repository_test.go": [
          "File: reposerver/repository/repository_test.go -> reposerver/repository/repository_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "728:  }",
          "729:  request := &apiclient.ManifestRequest{Repo: &argoappv1.Repository{}, ApplicationSource: source, NoCache: true}",
          "730:  _, err := service.GenerateManifest(context.Background(), request)",
          "732: }",
          "734: func TestGenerateHelmWithURL(t *testing.T) {",
          "",
          "[Removed Lines]",
          "731:  assert.Error(t, err, \"should be on or under current directory\")",
          "",
          "[Added Lines]",
          "731:  assert.Error(t, err)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "753: func TestGenerateHelmWithValuesDirectoryTraversalOutsideRepo(t *testing.T) {",
          "763:    },",
          "765:  })",
          "777:    },",
          "779:  })",
          "781: }",
          "",
          "[Removed Lines]",
          "754:  service := newService(\"../..\")",
          "755:  _, err := service.GenerateManifest(context.Background(), &apiclient.ManifestRequest{",
          "756:   Repo:    &argoappv1.Repository{},",
          "757:   AppName: \"test\",",
          "758:   ApplicationSource: &argoappv1.ApplicationSource{",
          "759:    Path: \"./util/helm/testdata/redis\",",
          "760:    Helm: &argoappv1.ApplicationSourceHelm{",
          "761:     ValueFiles: []string{\"../../../../../minio/values.yaml\"},",
          "762:     Values:     `cluster: {slaveCount: 2}`,",
          "764:   },",
          "766:  assert.Error(t, err, \"should be on or under current directory\")",
          "768:  service = newService(\"./testdata/my-chart\")",
          "769:  _, err = service.GenerateManifest(context.Background(), &apiclient.ManifestRequest{",
          "770:   Repo:    &argoappv1.Repository{},",
          "771:   AppName: \"test\",",
          "772:   ApplicationSource: &argoappv1.ApplicationSource{",
          "773:    Path: \".\",",
          "774:    Helm: &argoappv1.ApplicationSourceHelm{",
          "775:     ValueFiles: []string{\"../my-chart-2/values.yaml\"},",
          "776:     Values:     `cluster: {slaveCount: 2}`,",
          "778:   },",
          "780:  assert.Error(t, err, \"should be on or under current directory\")",
          "",
          "[Added Lines]",
          "754:  t.Run(\"Values file with relative path pointing outside repo root\", func(t *testing.T) {",
          "755:   service := newService(\"../..\")",
          "756:   _, err := service.GenerateManifest(context.Background(), &apiclient.ManifestRequest{",
          "757:    Repo:    &argoappv1.Repository{},",
          "758:    AppName: \"test\",",
          "759:    ApplicationSource: &argoappv1.ApplicationSource{",
          "760:     Path: \"./util/helm/testdata/redis\",",
          "761:     Helm: &argoappv1.ApplicationSourceHelm{",
          "762:      ValueFiles: []string{\"../../../../../minio/values.yaml\"},",
          "763:      Values:     `cluster: {slaveCount: 2}`,",
          "764:     },",
          "766:   })",
          "767:   assert.Error(t, err)",
          "768:   assert.Contains(t, err.Error(), \"outside repository root\")",
          "771:  t.Run(\"Values file with relative path pointing inside repo root\", func(t *testing.T) {",
          "772:   service := newService(\"./testdata/my-chart\")",
          "773:   _, err := service.GenerateManifest(context.Background(), &apiclient.ManifestRequest{",
          "774:    Repo:    &argoappv1.Repository{},",
          "775:    AppName: \"test\",",
          "776:    ApplicationSource: &argoappv1.ApplicationSource{",
          "777:     Path: \".\",",
          "778:     Helm: &argoappv1.ApplicationSourceHelm{",
          "779:      ValueFiles: []string{\"../my-chart/my-chart-values.yaml\"},",
          "780:      Values:     `cluster: {slaveCount: 2}`,",
          "781:     },",
          "783:   })",
          "784:   assert.NoError(t, err)",
          "785:  })",
          "787:  t.Run(\"Values file with absolute path stays within repo root\", func(t *testing.T) {",
          "788:   service := newService(\"./testdata/my-chart\")",
          "789:   _, err := service.GenerateManifest(context.Background(), &apiclient.ManifestRequest{",
          "790:    Repo:    &argoappv1.Repository{},",
          "791:    AppName: \"test\",",
          "792:    ApplicationSource: &argoappv1.ApplicationSource{",
          "793:     Path: \".\",",
          "794:     Helm: &argoappv1.ApplicationSourceHelm{",
          "795:      ValueFiles: []string{\"/my-chart-values.yaml\"},",
          "796:      Values:     `cluster: {slaveCount: 2}`,",
          "797:     },",
          "798:    },",
          "799:   })",
          "800:   assert.NoError(t, err)",
          "801:  })",
          "803:  t.Run(\"Values file with absolute path using back-references outside repo root\", func(t *testing.T) {",
          "804:   service := newService(\"./testdata/my-chart\")",
          "805:   _, err := service.GenerateManifest(context.Background(), &apiclient.ManifestRequest{",
          "806:    Repo:    &argoappv1.Repository{},",
          "807:    AppName: \"test\",",
          "808:    ApplicationSource: &argoappv1.ApplicationSource{",
          "809:     Path: \".\",",
          "810:     Helm: &argoappv1.ApplicationSourceHelm{",
          "811:      ValueFiles: []string{\"/../../../my-chart-values.yaml\"},",
          "812:      Values:     `cluster: {slaveCount: 2}`,",
          "813:     },",
          "814:    },",
          "815:   })",
          "816:   assert.Error(t, err)",
          "817:   assert.Contains(t, err.Error(), \"outside repository root\")",
          "818:  })",
          "820:  t.Run(\"Remote values file from forbidden protocol\", func(t *testing.T) {",
          "821:   service := newService(\"./testdata/my-chart\")",
          "822:   _, err := service.GenerateManifest(context.Background(), &apiclient.ManifestRequest{",
          "823:    Repo:    &argoappv1.Repository{},",
          "824:    AppName: \"test\",",
          "825:    ApplicationSource: &argoappv1.ApplicationSource{",
          "826:     Path: \".\",",
          "827:     Helm: &argoappv1.ApplicationSourceHelm{",
          "828:      ValueFiles: []string{\"file://../../../../my-chart-values.yaml\"},",
          "829:      Values:     `cluster: {slaveCount: 2}`,",
          "830:     },",
          "831:    },",
          "832:   })",
          "833:   assert.Error(t, err)",
          "834:   assert.Contains(t, err.Error(), \"is not allowed\")",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1561:  assert.Equal(t, repos[0].Repo, repo1)",
          "1562:  assert.Equal(t, repos[1].Repo, repo2)",
          "1563: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1620: func Test_resolveSymlinkRecursive(t *testing.T) {",
          "1621:  cwd, err := os.Getwd()",
          "1622:  require.NoError(t, err)",
          "1623:  err = os.Chdir(\"testdata/symlinks\")",
          "1624:  require.NoError(t, err)",
          "1625:  defer func() {",
          "1626:   err := os.Chdir(cwd)",
          "1627:   if err != nil {",
          "1628:    panic(err)",
          "1629:   }",
          "1630:  }()",
          "1631:  t.Run(\"Resolve non-symlink\", func(t *testing.T) {",
          "1632:   r, err := resolveSymbolicLinkRecursive(\"foo\", 2)",
          "1633:   assert.NoError(t, err)",
          "1634:   assert.Equal(t, \"foo\", r)",
          "1635:  })",
          "1636:  t.Run(\"Successfully resolve symlink\", func(t *testing.T) {",
          "1637:   r, err := resolveSymbolicLinkRecursive(\"bar\", 2)",
          "1638:   assert.NoError(t, err)",
          "1639:   assert.Equal(t, \"foo\", r)",
          "1640:  })",
          "1641:  t.Run(\"Do not allow symlink at all\", func(t *testing.T) {",
          "1642:   r, err := resolveSymbolicLinkRecursive(\"bar\", 0)",
          "1643:   assert.Error(t, err)",
          "1644:   assert.Equal(t, \"\", r)",
          "1645:  })",
          "1646:  t.Run(\"Error because too nested symlink\", func(t *testing.T) {",
          "1647:   r, err := resolveSymbolicLinkRecursive(\"bam\", 2)",
          "1648:   assert.Error(t, err)",
          "1649:   assert.Equal(t, \"\", r)",
          "1650:  })",
          "1651:  t.Run(\"No such file or directory\", func(t *testing.T) {",
          "1652:   r, err := resolveSymbolicLinkRecursive(\"foobar\", 2)",
          "1653:   assert.NoError(t, err)",
          "1654:   assert.Equal(t, \"foobar\", r)",
          "1655:  })",
          "1656: }",
          "1658: func Test_isURLSchemeAllowed(t *testing.T) {",
          "1659:  type testdata struct {",
          "1660:   name     string",
          "1661:   scheme   string",
          "1662:   allowed  []string",
          "1663:   expected bool",
          "1664:  }",
          "1665:  var tts []testdata = []testdata{",
          "1666:   {",
          "1667:    name:     \"Allowed scheme matches\",",
          "1668:    scheme:   \"http\",",
          "1669:    allowed:  []string{\"http\", \"https\"},",
          "1670:    expected: true,",
          "1671:   },",
          "1672:   {",
          "1673:    name:     \"Allowed scheme matches only partially\",",
          "1674:    scheme:   \"http\",",
          "1675:    allowed:  []string{\"https\"},",
          "1676:    expected: false,",
          "1677:   },",
          "1678:   {",
          "1679:    name:     \"Scheme is not allowed\",",
          "1680:    scheme:   \"file\",",
          "1681:    allowed:  []string{\"http\", \"https\"},",
          "1682:    expected: false,",
          "1683:   },",
          "1684:   {",
          "1685:    name:     \"Empty scheme with valid allowances is forbidden\",",
          "1686:    scheme:   \"\",",
          "1687:    allowed:  []string{\"http\", \"https\"},",
          "1688:    expected: false,",
          "1689:   },",
          "1690:   {",
          "1691:    name:     \"Empty scheme with empty allowances is forbidden\",",
          "1692:    scheme:   \"\",",
          "1693:    allowed:  []string{},",
          "1694:    expected: false,",
          "1695:   },",
          "1696:   {",
          "1697:    name:     \"Some scheme with empty allowances is forbidden\",",
          "1698:    scheme:   \"file\",",
          "1699:    allowed:  []string{},",
          "1700:    expected: false,",
          "1701:   },",
          "1702:  }",
          "1703:  for _, tt := range tts {",
          "1704:   t.Run(tt.name, func(t *testing.T) {",
          "1705:    r := isURLSchemeAllowed(tt.scheme, tt.allowed)",
          "1706:    assert.Equal(t, tt.expected, r)",
          "1707:   })",
          "1708:  }",
          "1709: }",
          "1711: func Test_resolveHelmValueFilePath(t *testing.T) {",
          "1712:  t.Run(\"Resolve normal relative path into absolute path\", func(t *testing.T) {",
          "1713:   p, remote, err := resolveHelmValueFilePath(\"/foo/bar\", \"/foo\", \"baz/bim.yaml\", allowedHelmRemoteProtocols)",
          "1714:   assert.NoError(t, err)",
          "1715:   assert.False(t, remote)",
          "1716:   assert.Equal(t, \"/foo/bar/baz/bim.yaml\", p)",
          "1717:  })",
          "1718:  t.Run(\"Resolve normal relative path into absolute path\", func(t *testing.T) {",
          "1719:   p, remote, err := resolveHelmValueFilePath(\"/foo/bar\", \"/foo\", \"baz/../../bim.yaml\", allowedHelmRemoteProtocols)",
          "1720:   assert.NoError(t, err)",
          "1721:   assert.False(t, remote)",
          "1722:   assert.Equal(t, \"/foo/bim.yaml\", p)",
          "1723:  })",
          "1724:  t.Run(\"Error on path resolving outside repository root\", func(t *testing.T) {",
          "1725:   p, remote, err := resolveHelmValueFilePath(\"/foo/bar\", \"/foo\", \"baz/../../../bim.yaml\", allowedHelmRemoteProtocols)",
          "1726:   assert.Error(t, err)",
          "1727:   assert.Contains(t, err.Error(), \"outside repository root\")",
          "1728:   assert.False(t, remote)",
          "1729:   assert.Equal(t, \"\", p)",
          "1730:  })",
          "1731:  t.Run(\"Return verbatim URL\", func(t *testing.T) {",
          "1732:   url := \"https://some.where/foo,yaml\"",
          "1733:   p, remote, err := resolveHelmValueFilePath(\"/foo/bar\", \"/foo\", url, allowedHelmRemoteProtocols)",
          "1734:   assert.NoError(t, err)",
          "1735:   assert.True(t, remote)",
          "1736:   assert.Equal(t, url, p)",
          "1737:  })",
          "1738:  t.Run(\"URL scheme not allowed\", func(t *testing.T) {",
          "1739:   url := \"file:///some.where/foo,yaml\"",
          "1740:   p, remote, err := resolveHelmValueFilePath(\"/foo/bar\", \"/foo\", url, allowedHelmRemoteProtocols)",
          "1741:   assert.Error(t, err)",
          "1742:   assert.False(t, remote)",
          "1743:   assert.Equal(t, \"\", p)",
          "1744:  })",
          "1745:  t.Run(\"Implicit URL by absolute path\", func(t *testing.T) {",
          "1746:   p, remote, err := resolveHelmValueFilePath(\"/foo/bar\", \"/foo\", \"/baz.yaml\", allowedHelmRemoteProtocols)",
          "1747:   assert.NoError(t, err)",
          "1748:   assert.False(t, remote)",
          "1749:   assert.Equal(t, \"/foo/baz.yaml\", p)",
          "1750:  })",
          "1751:  t.Run(\"Relative app path\", func(t *testing.T) {",
          "1752:   p, remote, err := resolveHelmValueFilePath(\".\", \"/foo\", \"/baz.yaml\", allowedHelmRemoteProtocols)",
          "1753:   assert.NoError(t, err)",
          "1754:   assert.False(t, remote)",
          "1755:   assert.Equal(t, \"/foo/baz.yaml\", p)",
          "1756:  })",
          "1757:  t.Run(\"Relative repo path\", func(t *testing.T) {",
          "1758:   c, err := os.Getwd()",
          "1759:   require.NoError(t, err)",
          "1760:   p, remote, err := resolveHelmValueFilePath(\".\", \".\", \"baz.yaml\", allowedHelmRemoteProtocols)",
          "1761:   assert.NoError(t, err)",
          "1762:   assert.False(t, remote)",
          "1763:   assert.Equal(t, c+\"/baz.yaml\", p)",
          "1764:  })",
          "1765:  t.Run(\"Overlapping root prefix without trailing slash\", func(t *testing.T) {",
          "1766:   p, remote, err := resolveHelmValueFilePath(\".\", \"/foo\", \"../foo2/baz.yaml\", allowedHelmRemoteProtocols)",
          "1767:   assert.Error(t, err)",
          "1768:   assert.Contains(t, err.Error(), \"outside repository root\")",
          "1769:   assert.False(t, remote)",
          "1770:   assert.Equal(t, \"\", p)",
          "1771:  })",
          "1772:  t.Run(\"Overlapping root prefix with trailing slash\", func(t *testing.T) {",
          "1773:   p, remote, err := resolveHelmValueFilePath(\".\", \"/foo/\", \"../foo2/baz.yaml\", allowedHelmRemoteProtocols)",
          "1774:   assert.Error(t, err)",
          "1775:   assert.Contains(t, err.Error(), \"outside repository root\")",
          "1776:   assert.False(t, remote)",
          "1777:   assert.Equal(t, \"\", p)",
          "1778:  })",
          "1779:  t.Run(\"Garbage input as values file\", func(t *testing.T) {",
          "1780:   p, remote, err := resolveHelmValueFilePath(\".\", \"/foo/\", \"kfdj\\\\ks&&&321209.,---e32908923%$\u00a7!\\\"\", allowedHelmRemoteProtocols)",
          "1781:   assert.Error(t, err)",
          "1782:   assert.Contains(t, err.Error(), \"outside repository root\")",
          "1783:   assert.False(t, remote)",
          "1784:   assert.Equal(t, \"\", p)",
          "1785:  })",
          "1786:  t.Run(\"NUL-byte path input as values file\", func(t *testing.T) {",
          "1787:   p, remote, err := resolveHelmValueFilePath(\".\", \"/foo/\", \"\\000\", allowedHelmRemoteProtocols)",
          "1788:   assert.Error(t, err)",
          "1789:   assert.Contains(t, err.Error(), \"outside repository root\")",
          "1790:   assert.False(t, remote)",
          "1791:   assert.Equal(t, \"\", p)",
          "1792:  })",
          "1793: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
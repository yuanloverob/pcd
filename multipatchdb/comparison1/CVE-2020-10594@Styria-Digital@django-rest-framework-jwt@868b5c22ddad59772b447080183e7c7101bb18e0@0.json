{
  "cve_id": "CVE-2020-10594",
  "cve_desc": "An issue was discovered in drf-jwt 1.15.x before 1.15.1. It allows attackers with access to a notionally invalidated token to obtain a new, working token via the refresh endpoint, because the blacklist protection mechanism is incompatible with the token-refresh feature. NOTE: drf-jwt is a fork of jpadilla/django-rest-framework-jwt, which is unmaintained.",
  "repo": "Styria-Digital/django-rest-framework-jwt",
  "patch_hash": "868b5c22ddad59772b447080183e7c7101bb18e0",
  "patch_info": {
    "commit_hash": "868b5c22ddad59772b447080183e7c7101bb18e0",
    "repo": "Styria-Digital/django-rest-framework-jwt",
    "commit_url": "https://github.com/Styria-Digital/django-rest-framework-jwt/commit/868b5c22ddad59772b447080183e7c7101bb18e0",
    "files": [
      "src/rest_framework_jwt/utils.py",
      "tests/views/test_refresh.py"
    ],
    "message": "Disallow refreshing a blacklisted token.\n\nOtherwise, you can refresh a blacklisted token and get a fresh token that works.",
    "before_after_code_files": [
      "src/rest_framework_jwt/utils.py||src/rest_framework_jwt/utils.py",
      "tests/views/test_refresh.py||tests/views/test_refresh.py"
    ]
  },
  "patch_diff": {
    "src/rest_framework_jwt/utils.py||src/rest_framework_jwt/utils.py": [
      "File: src/rest_framework_jwt/utils.py -> src/rest_framework_jwt/utils.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "8: import jwt",
      "10: from django.contrib.auth import get_user_model",
      "11: from django.utils.encoding import force_text",
      "13: from rest_framework import serializers",
      "15: from rest_framework_jwt.compat import gettext_lazy as _",
      "16: from rest_framework_jwt.settings import api_settings",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "10: from django.apps import apps",
      "12: from django.utils.encoding import force_str",
      "17: from rest_framework_jwt.blacklist.models import BlacklistedToken",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "138: def check_payload(token):",
      "139:     from rest_framework_jwt.authentication import JSONWebTokenAuthentication",
      "141:     try:",
      "142:         payload = JSONWebTokenAuthentication.jwt_decode_token(token)",
      "143:     except jwt.ExpiredSignature:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "144:     if apps.is_installed('rest_framework_jwt.blacklist'):",
      "145:         if BlacklistedToken.objects.filter(token=force_str(token)).exists():",
      "146:             msg = _('Token is blacklisted.')",
      "147:             raise serializers.ValidationError(msg)",
      "",
      "---------------"
    ],
    "tests/views/test_refresh.py||tests/views/test_refresh.py": [
      "File: tests/views/test_refresh.py -> tests/views/test_refresh.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "3: from __future__ import unicode_literals",
      "5: from rest_framework_jwt.authentication import JSONWebTokenAuthentication",
      "6: from rest_framework_jwt.compat import gettext_lazy as _",
      "7: from rest_framework_jwt.settings import api_settings",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5: from datetime import timedelta",
      "7: from django.utils import timezone",
      "10: from rest_framework_jwt.blacklist.models import BlacklistedToken",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "84:     refresh_response = call_auth_refresh_endpoint(auth_token)",
      "85:     assert refresh_response.json() == expected_output",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "93: def test_blacklisted_token__returns_validation_error(",
      "94:     call_auth_refresh_endpoint, user",
      "95: ):",
      "96:     payload = JSONWebTokenAuthentication.jwt_create_payload(user)",
      "97:     auth_token = JSONWebTokenAuthentication.jwt_encode_payload(payload)",
      "98:     BlacklistedToken.objects.create(",
      "99:         token=auth_token,",
      "100:         user=user,",
      "101:         expires_at=timezone.now() - timedelta(days=7),",
      "102:     )",
      "104:     expected_output = {\"non_field_errors\": [_(\"Token is blacklisted.\")]}",
      "106:     refresh_response = call_auth_refresh_endpoint(auth_token)",
      "107:     assert refresh_response.json() == expected_output",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a043949c539dd71e899ddfc0e69694e805a57044",
      "candidate_info": {
        "commit_hash": "a043949c539dd71e899ddfc0e69694e805a57044",
        "repo": "Styria-Digital/django-rest-framework-jwt",
        "commit_url": "https://github.com/Styria-Digital/django-rest-framework-jwt/commit/a043949c539dd71e899ddfc0e69694e805a57044",
        "files": [
          "src/rest_framework_jwt/authentication.py",
          "src/rest_framework_jwt/blacklist/models.py",
          "src/rest_framework_jwt/blacklist/permissions.py",
          "src/rest_framework_jwt/utils.py"
        ],
        "message": "Add a central point for checking tokens that are blocked.\n\nI'm about to make the logic here more elaborate, and prefer it in one spot in any case.",
        "before_after_code_files": [
          "src/rest_framework_jwt/authentication.py||src/rest_framework_jwt/authentication.py",
          "src/rest_framework_jwt/blacklist/models.py||src/rest_framework_jwt/blacklist/models.py",
          "src/rest_framework_jwt/blacklist/permissions.py||src/rest_framework_jwt/blacklist/permissions.py",
          "src/rest_framework_jwt/utils.py||src/rest_framework_jwt/utils.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/rest_framework_jwt/utils.py||src/rest_framework_jwt/utils.py"
          ],
          "candidate": [
            "src/rest_framework_jwt/utils.py||src/rest_framework_jwt/utils.py"
          ]
        }
      },
      "candidate_diff": {
        "src/rest_framework_jwt/authentication.py||src/rest_framework_jwt/authentication.py": [
          "File: src/rest_framework_jwt/authentication.py -> src/rest_framework_jwt/authentication.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "71:         if apps.is_installed('rest_framework_jwt.blacklist'):",
          "72:             from rest_framework_jwt.blacklist.models import BlacklistedToken",
          "74:                 msg = _('Token is blacklisted.')",
          "75:                 raise exceptions.PermissionDenied(msg)",
          "",
          "[Removed Lines]",
          "73:             if BlacklistedToken.objects.filter(token=force_str(token)).exists():",
          "",
          "[Added Lines]",
          "73:             if BlacklistedToken.is_blocked(token):",
          "",
          "---------------"
        ],
        "src/rest_framework_jwt/blacklist/models.py||src/rest_framework_jwt/blacklist/models.py": [
          "File: src/rest_framework_jwt/blacklist/models.py -> src/rest_framework_jwt/blacklist/models.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: from django.db import models",
          "6: from django.db.models import Q",
          "7: from django.utils import timezone",
          "10: class BlacklistedTokenManager(models.Manager):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: from django.utils.encoding import force_str",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35:     def __str__(self):",
          "36:         return 'Blacklisted token - {} - {}'.format(self.user, self.token)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40:     @staticmethod",
          "41:     def is_blocked(token):",
          "42:         return BlacklistedToken.objects.filter(token=force_str(token)).exists()",
          "",
          "---------------"
        ],
        "src/rest_framework_jwt/blacklist/permissions.py||src/rest_framework_jwt/blacklist/permissions.py": [
          "File: src/rest_framework_jwt/blacklist/permissions.py -> src/rest_framework_jwt/blacklist/permissions.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:         if token is None:",
          "16:             return True",
          "",
          "[Removed Lines]",
          "18:         return not BlacklistedToken.objects.filter(token=token).exists()",
          "",
          "[Added Lines]",
          "18:         return not BlacklistedToken.is_blocked(token)",
          "",
          "---------------"
        ],
        "src/rest_framework_jwt/utils.py||src/rest_framework_jwt/utils.py": [
          "File: src/rest_framework_jwt/utils.py -> src/rest_framework_jwt/utils.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: from django.apps import apps",
          "12: from django.contrib.auth import get_user_model",
          "15: from rest_framework import serializers",
          "16: from rest_framework.utils.encoders import JSONEncoder",
          "",
          "[Removed Lines]",
          "13: from django.utils.encoding import force_str",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "207:     if apps.is_installed('rest_framework_jwt.blacklist'):",
          "208:         from rest_framework_jwt.blacklist.models import BlacklistedToken",
          "210:             msg = _('Token is blacklisted.')",
          "211:             raise serializers.ValidationError(msg)",
          "",
          "[Removed Lines]",
          "209:         if BlacklistedToken.objects.filter(token=force_str(token)).exists():",
          "",
          "[Added Lines]",
          "208:         if BlacklistedToken.is_blocked(token):",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2023-34104",
  "cve_desc": "fast-xml-parser is an open source, pure javascript xml parser. fast-xml-parser allows special characters in entity names, which are not escaped or sanitized. Since the entity name is used for creating a regex for searching and replacing entities in the XML body, an attacker can abuse it for denial of service (DoS) attacks. By crafting an entity name that results in an intentionally bad performing regex and utilizing it in the entity replacement step of the parser, this can cause the parser to stall for an indefinite amount of time. This problem has been resolved in v4.2.4. Users are advised to upgrade. Users unable to upgrade should avoid using DOCTYPE parsing by setting the `processEntities: false` option.",
  "repo": "NaturalIntelligence/fast-xml-parser",
  "patch_hash": "39b0e050bb909e8499478657f84a3076e39ce76c",
  "patch_info": {
    "commit_hash": "39b0e050bb909e8499478657f84a3076e39ce76c",
    "repo": "NaturalIntelligence/fast-xml-parser",
    "commit_url": "https://github.com/NaturalIntelligence/fast-xml-parser/commit/39b0e050bb909e8499478657f84a3076e39ce76c",
    "files": [
      "spec/entities_spec.js",
      "src/xmlparser/DocTypeReader.js"
    ],
    "message": "fix security bug",
    "before_after_code_files": [
      "spec/entities_spec.js||spec/entities_spec.js",
      "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js"
    ]
  },
  "patch_diff": {
    "spec/entities_spec.js||spec/entities_spec.js": [
      "File: spec/entities_spec.js -> spec/entities_spec.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "377:         expect(result).toEqual(expected);",
      "378:     });",
      "379: });",
      "381: describe(\"XMLParser External Entites\", function() {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "379:     it(\"should throw error if an entity name contains special char\", function() {",
      "380:         const xmlData = `",
      "381:         <?xml version=\"1.0\" encoding=\"UTF-8\"?>",
      "383:         <!DOCTYPE note [",
      "384:         <!ENTITY nj$ \"writer;\">",
      "385:         <!ENTITY wr?er \"Writer: Donald Duck.\">",
      "386:         ]>`;",
      "388:         const options = {",
      "389:             processEntities: true,",
      "390:         };",
      "392:         expect(() =>{",
      "393:             const parser = new XMLParser(options);",
      "394:             parser.parse(xmlData);",
      "395:         }).toThrowError(\"Invalid character $ in entity name\")",
      "396:     });",
      "",
      "---------------"
    ],
    "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js": [
      "File: src/xmlparser/DocTypeReader.js -> src/xmlparser/DocTypeReader.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "19:                     i += 7;",
      "20:                     [entityName, val,i] = readEntityExp(xmlData,i+1);",
      "21:                     if(val.indexOf(\"&\") === -1) //Parameter entities are not supported",
      "23:                             regx : RegExp( `&${entityName};`,\"g\"),",
      "24:                             val: val",
      "25:                         };",
      "",
      "[Removed Lines]",
      "22:                         entities[ entityName ] = {",
      "",
      "[Added Lines]",
      "22:                         entities[ validateEntityName(entityName) ] = {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "140:     return false",
      "141: }",
      "143: module.exports = readDocType;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "145: const specialChar = \"!?\\\\\\/[]$%{}^&*()<>\";",
      "147: function validateEntityName(name){",
      "148:     for (let i = 0; i < specialChar.length; i++) {",
      "149:         const ch = specialChar[i];",
      "150:         if(name.indexOf(ch) !== -1) throw new Error(`Invalid character ${ch} in entity name`);",
      "151:     }",
      "152:     return name;",
      "153: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "30624d73f7a898c970414ec95da84340924a5ea2",
      "candidate_info": {
        "commit_hash": "30624d73f7a898c970414ec95da84340924a5ea2",
        "repo": "NaturalIntelligence/fast-xml-parser",
        "commit_url": "https://github.com/NaturalIntelligence/fast-xml-parser/commit/30624d73f7a898c970414ec95da84340924a5ea2",
        "files": [
          "CHANGELOG.md",
          "lib/fxbuilder.min.js",
          "lib/fxbuilder.min.js.map",
          "lib/fxp.min.js",
          "lib/fxp.min.js.map",
          "lib/fxparser.min.js",
          "lib/fxparser.min.js.map",
          "package-lock.json",
          "package.json",
          "spec/entities_spec.js",
          "src/xmlbuilder/json2xml.js",
          "src/xmlparser/DocTypeReader.js",
          "yarn.lock"
        ],
        "message": "Fix '<' or '>' in DTD comment throwing an error. (#533)\n\n* comment unimplemented methods\n\n* update package for release\n\n* Add test\n\n* Make DocTypeReader not try to parse a tag if the '^<' is in a comment\n\n* Remove error, don't decrement angleBracketCount if '^>' is in a comment and not an end tag\n\n* Remove new line from xml string definition\n\nCo-authored-by: amit kumar gupta <amitgupta.gwl@gmail.com>",
        "before_after_code_files": [
          "lib/fxbuilder.min.js||lib/fxbuilder.min.js",
          "lib/fxbuilder.min.js.map||lib/fxbuilder.min.js.map",
          "lib/fxp.min.js||lib/fxp.min.js",
          "lib/fxp.min.js.map||lib/fxp.min.js.map",
          "lib/fxparser.min.js||lib/fxparser.min.js",
          "lib/fxparser.min.js.map||lib/fxparser.min.js.map",
          "spec/entities_spec.js||spec/entities_spec.js",
          "src/xmlbuilder/json2xml.js||src/xmlbuilder/json2xml.js",
          "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js",
          "yarn.lock||yarn.lock"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "spec/entities_spec.js||spec/entities_spec.js",
            "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js"
          ],
          "candidate": [
            "spec/entities_spec.js||spec/entities_spec.js",
            "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js"
          ]
        }
      },
      "candidate_diff": {
        "lib/fxbuilder.min.js||lib/fxbuilder.min.js": [
          "File: lib/fxbuilder.min.js -> lib/fxbuilder.min.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: var XMLBuilder;(()=>{var t={784:(t,e,i)=>{\"use strict\";var s=i(687),r={attributeNamePrefix:\"@_\",attributesGroupName:!1,textNodeName:\"#text\",ignoreAttributes:!0,cdataPropName:!1,format:!1,indentBy:\"  \",suppressEmptyNode:!1,suppressUnpairedNode:!0,suppressBooleanAttributes:!0,tagValueProcessor:function(t,e){return e},attributeValueProcessor:function(t,e){return e},preserveOrder:!1,commentPropName:!1,unpairedTags:[],entities:[{regex:new RegExp(\"&\",\"g\"),val:\"&amp;\"},{regex:new RegExp(\">\",\"g\"),val:\"&gt;\"},{regex:new RegExp(\"<\",\"g\"),val:\"&lt;\"},{regex:new RegExp(\"'\",\"g\"),val:\"&apos;\"},{regex:new RegExp('\"',\"g\"),val:\"&quot;\"}],processEntities:!0,stopNodes:[],transformTagName:!1};function n(t){this.options=Object.assign({},r,t),this.options.ignoreAttributes||this.options.attributesGroupName?this.isAttribute=function(){return!1}:(this.attrPrefixLen=this.options.attributeNamePrefix.length,this.isAttribute=N),this.processTextOrObjNode=o,this.options.format?(this.indentate=f,this.tagEndChar=\">\\n\",this.newLine=\"\\n\"):(this.indentate=function(){return\"\"},this.tagEndChar=\">\",this.newLine=\"\"),this.options.suppressEmptyNode?(this.buildTextNode=l,this.buildObjNode=u):(this.buildTextNode=d,this.buildObjNode=h),this.buildTextValNode=d,this.buildObjectNode=h,this.replaceEntitiesValue=p,this.buildAttrPairStr=a}function a(t,e){return e=this.options.attributeValueProcessor(t,\"\"+e),e=this.replaceEntitiesValue(e),this.options.suppressBooleanAttributes&&\"true\"===e?\" \"+t:\" \"+t+'=\"'+e+'\"'}function o(t,e,i){var s=this.j2x(t,i+1);return void 0!==t[this.options.textNodeName]&&1===Object.keys(t).length?this.buildTextNode(t[this.options.textNodeName],e,s.attrStr,i):this.buildObjNode(s.val,e,s.attrStr,i)}function h(t,e,i,s){var r=\"</\"+e+this.tagEndChar,n=\"\";return\"?\"===e[0]&&(n=\"?\",r=\"\"),i&&-1===t.indexOf(\"<\")?this.indentate(s)+\"<\"+e+i+n+\">\"+t+r:!1!==this.options.commentPropName&&e===this.options.commentPropName&&0===n.length?this.indentate(s)+\"\\x3c!--\"+t+\"--\\x3e\"+this.newLine:this.indentate(s)+\"<\"+e+i+n+this.tagEndChar+t+this.indentate(s)+r}function u(t,e,i,s){return\"\"!==t?this.buildObjectNode(t,e,i,s):\"?\"===e[0]?this.indentate(s)+\"<\"+e+i+\"?\"+this.tagEndChar:this.indentate(s)+\"<\"+e+i+\"/\"+this.tagEndChar}function d(t,e,i,s){if(!1!==this.options.cdataPropName&&e===this.options.cdataPropName)return this.indentate(s)+\"<![CDATA[\"+t+\"]]>\"+this.newLine;if(!1!==this.options.commentPropName&&e===this.options.commentPropName)return this.indentate(s)+\"\\x3c!--\"+t+\"--\\x3e\"+this.newLine;var r=this.options.tagValueProcessor(e,t);return\"\"===(r=this.replaceEntitiesValue(r))&&-1!==this.options.unpairedTags.indexOf(e)?this.options.suppressUnpairedNode?this.indentate(s)+\"<\"+e+this.tagEndChar:this.indentate(s)+\"<\"+e+\"/\"+this.tagEndChar:this.indentate(s)+\"<\"+e+i+\">\"+r+\"</\"+e+this.tagEndChar}function p(t){if(t&&t.length>0&&this.options.processEntities)for(var e=0;e<this.options.entities.length;e++){var i=this.options.entities[e];t=t.replace(i.regex,i.val)}return t}function l(t,e,i,s){return\"\"===t&&-1!==this.options.unpairedTags.indexOf(e)?this.options.suppressUnpairedNode?this.indentate(s)+\"<\"+e+this.tagEndChar:this.indentate(s)+\"<\"+e+\"/\"+this.tagEndChar:\"\"!==t?this.buildTextValNode(t,e,i,s):\"?\"===e[0]?this.indentate(s)+\"<\"+e+i+\"?\"+this.tagEndChar:this.indentate(s)+\"<\"+e+i+\"/\"+this.tagEndChar}function f(t){return this.options.indentBy.repeat(t)}function N(t){return!!t.startsWith(this.options.attributeNamePrefix)&&t.substr(this.attrPrefixLen)}n.prototype.build=function(t){return this.options.preserveOrder?s(t,this.options):(Array.isArray(t)&&this.options.arrayNodeName&&this.options.arrayNodeName.length>1&&((e={})[this.options.arrayNodeName]=t,t=e),this.j2x(t,0).val);var e},n.prototype.j2x=function(t,e){var i=\"\",s=\"\";for(var r in t)if(void 0===t[r]);else if(null===t[r])\"?\"===r[0]?s+=this.indentate(e)+\"<\"+r+\"?\"+this.tagEndChar:s+=this.indentate(e)+\"<\"+r+\"/\"+this.tagEndChar;else if(t[r]instanceof Date)s+=this.buildTextNode(t[r],r,\"\",e);else if(\"object\"!=typeof t[r]){var n=this.isAttribute(r);if(n)i+=this.buildAttrPairStr(n,\"\"+t[r]);else if(r===this.options.textNodeName){var a=this.options.tagValueProcessor(r,\"\"+t[r]);s+=this.replaceEntitiesValue(a)}else s+=this.buildTextNode(t[r],r,\"\",e)}else if(Array.isArray(t[r]))for(var o=t[r].length,h=0;h<o;h++){var u=t[r][h];void 0===u||(null===u?\"?\"===r[0]?s+=this.indentate(e)+\"<\"+r+\"?\"+this.tagEndChar:s+=this.indentate(e)+\"<\"+r+\"/\"+this.tagEndChar:s+=\"object\"==typeof u?this.processTextOrObjNode(u,r,e):this.buildTextNode(u,r,\"\",e))}else if(this.options.attributesGroupName&&r===this.options.attributesGroupName)for(var d=Object.keys(t[r]),p=d.length,l=0;l<p;l++)i+=this.buildAttrPairStr(d[l],\"\"+t[r][d[l]]);else s+=this.processTextOrObjNode(t[r],r,e);return{attrStr:i,val:s}},t.exports=n},687:t=>{function e(t,a,o,h){var u=\"\",d=\"\";a.format&&a.indentBy.length>0&&(d=\"\\n\"+a.indentBy.repeat(h));for(var p=0;p<t.length;p++){var l,f=t[p],N=i(f);if(l=0===o.length?N:o+\".\"+N,N!==a.textNodeName)if(N!==a.cdataPropName)if(N!==a.commentPropName)if(\"?\"!==N[0]){var g=d+\"<\"+N+s(f[\":@\"],a),c=e(f[N],a,l,h+1);-1!==a.unpairedTags.indexOf(N)?a.suppressUnpairedNode?u+=g+\">\":u+=g+\"/>\":c&&0!==c.length||!a.suppressEmptyNode?u+=g+\">\"+c+d+\"</\"+N+\">\":u+=g+\"/>\"}else{var x=s(f[\":@\"],a),b=\"?xml\"===N?\"\":d,m=f[N][0][a.textNodeName];u+=b+\"<\"+N+(m=0!==m.length?\" \"+m:\"\")+x+\"?>\"}else u+=d+\"\\x3c!--\"+f[N][0][a.textNodeName]+\"--\\x3e\";else u+=d+\"<![CDATA[\"+f[N][0][a.textNodeName]+\"]]>\";else{var v=f[N];r(l,a)||(v=n(v=a.tagValueProcessor(N,v),a)),u+=d+v}}return u}function i(t){for(var e=Object.keys(t),i=0;i<e.length;i++){var s=e[i];if(\":@\"!==s)return s}}function s(t,e){var i=\"\";if(t&&!e.ignoreAttributes)for(var s in t){var r=e.attributeValueProcessor(s,t[s]);!0===(r=n(r,e))&&e.suppressBooleanAttributes?i+=\" \"+s.substr(e.attributeNamePrefix.length):i+=\" \"+s.substr(e.attributeNamePrefix.length)+'=\"'+r+'\"'}return i}function r(t,e){var i=(t=t.substr(0,t.length-e.textNodeName.length-1)).substr(t.lastIndexOf(\".\")+1);for(var s in e.stopNodes)if(e.stopNodes[s]===t||e.stopNodes[s]===\"*.\"+i)return!0;return!1}function n(t,e){if(t&&t.length>0&&e.processEntities)for(var i=0;i<e.entities.length;i++){var s=e.entities[i];t=t.replace(s.regex,s.val)}return t}t.exports=function(t,i){return e(t,i,\"\",0)}}},e={},i=function i(s){var r=e[s];if(void 0!==r)return r.exports;var n=e[s]={exports:{}};return t[s](n,n.exports,i),n.exports}(784);XMLBuilder=i})();",
          "",
          "[Added Lines]",
          "1: var XMLBuilder;(()=>{var t={784:(t,e,i)=>{\"use strict\";var s=i(687),r={attributeNamePrefix:\"@_\",attributesGroupName:!1,textNodeName:\"#text\",ignoreAttributes:!0,cdataPropName:!1,format:!1,indentBy:\"  \",suppressEmptyNode:!1,suppressUnpairedNode:!0,suppressBooleanAttributes:!0,tagValueProcessor:function(t,e){return e},attributeValueProcessor:function(t,e){return e},preserveOrder:!1,commentPropName:!1,unpairedTags:[],entities:[{regex:new RegExp(\"&\",\"g\"),val:\"&amp;\"},{regex:new RegExp(\">\",\"g\"),val:\"&gt;\"},{regex:new RegExp(\"<\",\"g\"),val:\"&lt;\"},{regex:new RegExp(\"'\",\"g\"),val:\"&apos;\"},{regex:new RegExp('\"',\"g\"),val:\"&quot;\"}],processEntities:!0,stopNodes:[]};function n(t){this.options=Object.assign({},r,t),this.options.ignoreAttributes||this.options.attributesGroupName?this.isAttribute=function(){return!1}:(this.attrPrefixLen=this.options.attributeNamePrefix.length,this.isAttribute=N),this.processTextOrObjNode=a,this.options.format?(this.indentate=f,this.tagEndChar=\">\\n\",this.newLine=\"\\n\"):(this.indentate=function(){return\"\"},this.tagEndChar=\">\",this.newLine=\"\"),this.options.suppressEmptyNode?(this.buildTextNode=l,this.buildObjNode=u):(this.buildTextNode=d,this.buildObjNode=h),this.buildTextValNode=d,this.buildObjectNode=h,this.replaceEntitiesValue=p,this.buildAttrPairStr=o}function o(t,e){return e=this.options.attributeValueProcessor(t,\"\"+e),e=this.replaceEntitiesValue(e),this.options.suppressBooleanAttributes&&\"true\"===e?\" \"+t:\" \"+t+'=\"'+e+'\"'}function a(t,e,i){var s=this.j2x(t,i+1);return void 0!==t[this.options.textNodeName]&&1===Object.keys(t).length?this.buildTextNode(t[this.options.textNodeName],e,s.attrStr,i):this.buildObjNode(s.val,e,s.attrStr,i)}function h(t,e,i,s){var r=\"</\"+e+this.tagEndChar,n=\"\";return\"?\"===e[0]&&(n=\"?\",r=\"\"),i&&-1===t.indexOf(\"<\")?this.indentate(s)+\"<\"+e+i+n+\">\"+t+r:!1!==this.options.commentPropName&&e===this.options.commentPropName&&0===n.length?this.indentate(s)+\"\\x3c!--\"+t+\"--\\x3e\"+this.newLine:this.indentate(s)+\"<\"+e+i+n+this.tagEndChar+t+this.indentate(s)+r}function u(t,e,i,s){return\"\"!==t?this.buildObjectNode(t,e,i,s):\"?\"===e[0]?this.indentate(s)+\"<\"+e+i+\"?\"+this.tagEndChar:this.indentate(s)+\"<\"+e+i+\"/\"+this.tagEndChar}function d(t,e,i,s){if(!1!==this.options.cdataPropName&&e===this.options.cdataPropName)return this.indentate(s)+\"<![CDATA[\"+t+\"]]>\"+this.newLine;if(!1!==this.options.commentPropName&&e===this.options.commentPropName)return this.indentate(s)+\"\\x3c!--\"+t+\"--\\x3e\"+this.newLine;var r=this.options.tagValueProcessor(e,t);return\"\"===(r=this.replaceEntitiesValue(r))&&-1!==this.options.unpairedTags.indexOf(e)?this.options.suppressUnpairedNode?this.indentate(s)+\"<\"+e+this.tagEndChar:this.indentate(s)+\"<\"+e+\"/\"+this.tagEndChar:this.indentate(s)+\"<\"+e+i+\">\"+r+\"</\"+e+this.tagEndChar}function p(t){if(t&&t.length>0&&this.options.processEntities)for(var e=0;e<this.options.entities.length;e++){var i=this.options.entities[e];t=t.replace(i.regex,i.val)}return t}function l(t,e,i,s){return\"\"===t&&-1!==this.options.unpairedTags.indexOf(e)?this.options.suppressUnpairedNode?this.indentate(s)+\"<\"+e+this.tagEndChar:this.indentate(s)+\"<\"+e+\"/\"+this.tagEndChar:\"\"!==t?this.buildTextValNode(t,e,i,s):\"?\"===e[0]?this.indentate(s)+\"<\"+e+i+\"?\"+this.tagEndChar:this.indentate(s)+\"<\"+e+i+\"/\"+this.tagEndChar}function f(t){return this.options.indentBy.repeat(t)}function N(t){return!!t.startsWith(this.options.attributeNamePrefix)&&t.substr(this.attrPrefixLen)}n.prototype.build=function(t){return this.options.preserveOrder?s(t,this.options):(Array.isArray(t)&&this.options.arrayNodeName&&this.options.arrayNodeName.length>1&&((e={})[this.options.arrayNodeName]=t,t=e),this.j2x(t,0).val);var e},n.prototype.j2x=function(t,e){var i=\"\",s=\"\";for(var r in t)if(void 0===t[r]);else if(null===t[r])\"?\"===r[0]?s+=this.indentate(e)+\"<\"+r+\"?\"+this.tagEndChar:s+=this.indentate(e)+\"<\"+r+\"/\"+this.tagEndChar;else if(t[r]instanceof Date)s+=this.buildTextNode(t[r],r,\"\",e);else if(\"object\"!=typeof t[r]){var n=this.isAttribute(r);if(n)i+=this.buildAttrPairStr(n,\"\"+t[r]);else if(r===this.options.textNodeName){var o=this.options.tagValueProcessor(r,\"\"+t[r]);s+=this.replaceEntitiesValue(o)}else s+=this.buildTextNode(t[r],r,\"\",e)}else if(Array.isArray(t[r]))for(var a=t[r].length,h=0;h<a;h++){var u=t[r][h];void 0===u||(null===u?\"?\"===r[0]?s+=this.indentate(e)+\"<\"+r+\"?\"+this.tagEndChar:s+=this.indentate(e)+\"<\"+r+\"/\"+this.tagEndChar:s+=\"object\"==typeof u?this.processTextOrObjNode(u,r,e):this.buildTextNode(u,r,\"\",e))}else if(this.options.attributesGroupName&&r===this.options.attributesGroupName)for(var d=Object.keys(t[r]),p=d.length,l=0;l<p;l++)i+=this.buildAttrPairStr(d[l],\"\"+t[r][d[l]]);else s+=this.processTextOrObjNode(t[r],r,e);return{attrStr:i,val:s}},t.exports=n},687:t=>{function e(t,o,a,h){for(var u=\"\",d=!1,p=0;p<t.length;p++){var l,f=t[p],N=i(f);if(l=0===a.length?N:a+\".\"+N,N!==o.textNodeName)if(N!==o.cdataPropName)if(N!==o.commentPropName)if(\"?\"!==N[0]){var c=h;\"\"!==c&&(c+=o.indentBy);var g=h+\"<\"+N+s(f[\":@\"],o),x=e(f[N],o,l,c);-1!==o.unpairedTags.indexOf(N)?o.suppressUnpairedNode?u+=g+\">\":u+=g+\"/>\":x&&0!==x.length||!o.suppressEmptyNode?x&&x.endsWith(\">\")?u+=g+\">\"+x+h+\"</\"+N+\">\":(u+=g+\">\",x&&\"\"!==h&&(x.includes(\"/>\")||x.includes(\"</\"))?u+=h+o.indentBy+x+h:u+=x,u+=\"</\"+N+\">\"):u+=g+\"/>\",d=!0}else{var b=s(f[\":@\"],o),m=\"?xml\"===N?\"\":h,v=f[N][0][o.textNodeName];u+=m+\"<\"+N+(v=0!==v.length?\" \"+v:\"\")+b+\"?>\",d=!0}else u+=h+\"\\x3c!--\"+f[N][0][o.textNodeName]+\"--\\x3e\",d=!0;else d&&(u+=h),u+=\"<![CDATA[\"+f[N][0][o.textNodeName]+\"]]>\",d=!1;else{var E=f[N];r(l,o)||(E=n(E=o.tagValueProcessor(N,E),o)),d&&(u+=h),u+=E,d=!1}}return u}function i(t){for(var e=Object.keys(t),i=0;i<e.length;i++){var s=e[i];if(\":@\"!==s)return s}}function s(t,e){var i=\"\";if(t&&!e.ignoreAttributes)for(var s in t){var r=e.attributeValueProcessor(s,t[s]);!0===(r=n(r,e))&&e.suppressBooleanAttributes?i+=\" \"+s.substr(e.attributeNamePrefix.length):i+=\" \"+s.substr(e.attributeNamePrefix.length)+'=\"'+r+'\"'}return i}function r(t,e){var i=(t=t.substr(0,t.length-e.textNodeName.length-1)).substr(t.lastIndexOf(\".\")+1);for(var s in e.stopNodes)if(e.stopNodes[s]===t||e.stopNodes[s]===\"*.\"+i)return!0;return!1}function n(t,e){if(t&&t.length>0&&e.processEntities)for(var i=0;i<e.entities.length;i++){var s=e.entities[i];t=t.replace(s.regex,s.val)}return t}t.exports=function(t,i){var s=\"\";return i.format&&i.indentBy.length>0&&(s=\"\\n\"),e(t,i,\"\",s)}}},e={},i=function i(s){var r=e[s];if(void 0!==r)return r.exports;var n=e[s]={exports:{}};return t[s](n,n.exports,i),n.exports}(784);XMLBuilder=i})();",
          "",
          "---------------"
        ],
        "lib/fxbuilder.min.js.map||lib/fxbuilder.min.js.map": [
          "File: lib/fxbuilder.min.js.map -> lib/fxbuilder.min.js.map",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: {\"version\":3,\"file\":\"./lib/fxbuilder.min.js\",\"mappings\":\"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\",\"sources\":[\"webpack://XMLBuilder/./src/xmlbuilder/json2xml.js\",\"webpack://XMLBuilder/./src/xmlbuilder/orderedJs2Xml.js\",\"webpack://XMLBuilder/webpack/bootstrap\",\"webpack://XMLBuilder/webpack/startup\"],\"sourcesContent\":[\"'use strict';\\n//parse Empty Node as self closing node\\nconst buildFromOrderedJs = require('./orderedJs2Xml');\\n\\nconst defaultOptions = {\\n  attributeNamePrefix: '@_',\\n  attributesGroupName: false,\\n  textNodeName: '#text',\\n  ignoreAttributes: true,\\n  cdataPropName: false,\\n  format: false,\\n  indentBy: '  ',\\n  suppressEmptyNode: false,\\n  suppressUnpairedNode: true,\\n  suppressBooleanAttributes: true,\\n  tagValueProcessor: function(key, a) {\\n    return a;\\n  },\\n  attributeValueProcessor: function(attrName, a) {\\n    return a;\\n  },\\n  preserveOrder: false,\\n  commentPropName: false,\\n  unpairedTags: [],\\n  entities: [\\n    { regex: new RegExp(\\\"&\\\", \\\"g\\\"), val: \\\"&amp;\\\" },//it must be on top\\n    { regex: new RegExp(\\\">\\\", \\\"g\\\"), val: \\\"&gt;\\\" },\\n    { regex: new RegExp(\\\"<\\\", \\\"g\\\"), val: \\\"&lt;\\\" },\\n    { regex: new RegExp(\\\"\\\\'\\\", \\\"g\\\"), val: \\\"&apos;\\\" },\\n    { regex: new RegExp(\\\"\\\\\\\"\\\", \\\"g\\\"), val: \\\"&quot;\\\" }\\n  ],\\n  processEntities: true,\\n  stopNodes: [],\\n  transformTagName: false,\\n};\\n\\nfunction Builder(options) {\\n  this.options = Object.assign({}, defaultOptions, options);\\n  if (this.options.ignoreAttributes || this.options.attributesGroupName) {\\n    this.isAttribute = function(/*a*/) {\\n      return false;\\n    };\\n  } else {\\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\\n    this.isAttribute = isAttribute;\\n  }\\n\\n  this.processTextOrObjNode = processTextOrObjNode\\n\\n  if (this.options.format) {\\n    this.indentate = indentate;\\n    this.tagEndChar = '>\\\\n';\\n    this.newLine = '\\\\n';\\n  } else {\\n    this.indentate = function() {\\n      return '';\\n    };\\n    this.tagEndChar = '>';\\n    this.newLine = '';\\n  }\\n\\n  if (this.options.suppressEmptyNode) {\\n    this.buildTextNode = buildEmptyTextNode;\\n    this.buildObjNode = buildEmptyObjNode;\\n  } else {\\n    this.buildTextNode = buildTextValNode;\\n    this.buildObjNode = buildObjectNode;\\n  }\\n\\n  this.buildTextValNode = buildTextValNode;\\n  this.buildObjectNode = buildObjectNode;\\n\\n  this.replaceEntitiesValue = replaceEntitiesValue;\\n  this.buildAttrPairStr = buildAttrPairStr;\\n}\\n\\nBuilder.prototype.build = function(jObj) {\\n  if(this.options.preserveOrder){\\n    return buildFromOrderedJs(jObj, this.options);\\n  }else {\\n    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){\\n      jObj = {\\n        [this.options.arrayNodeName] : jObj\\n      }\\n    }\\n    return this.j2x(jObj, 0).val;\\n  }\\n};\\n\\nBuilder.prototype.j2x = function(jObj, level) {\\n  let attrStr = '';\\n  let val = '';\\n  for (let key in jObj) {\\n    if (typeof jObj[key] === 'undefined') {\\n      // supress undefined node\\n    } else if (jObj[key] === null) {\\n      if(key[0] === \\\"?\\\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\\n      else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\\n      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\\n    } else if (jObj[key] instanceof Date) {\\n      val += this.buildTextNode(jObj[key], key, '', level);\\n    } else if (typeof jObj[key] !== 'object') {\\n      //premitive type\\n      const attr = this.isAttribute(key);\\n      if (attr) {\\n        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);\\n      }else {\\n        //tag value\\n        if (key === this.options.textNodeName) {\\n          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);\\n          val += this.replaceEntitiesValue(newval);\\n        } else {\\n          val += this.buildTextNode(jObj[key], key, '', level);\\n        }\\n      }\\n    } else if (Array.isArray(jObj[key])) {\\n      //repeated nodes\\n      const arrLen = jObj[key].length;\\n      for (let j = 0; j < arrLen; j++) {\\n        const item = jObj[key][j];\\n        if (typeof item === 'undefined') {\\n          // supress undefined node\\n        } else if (item === null) {\\n          if(key[0] === \\\"?\\\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\\n          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\\n          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\\n        } else if (typeof item === 'object') {\\n          val += this.processTextOrObjNode(item, key, level)\\n        } else {\\n          val += this.buildTextNode(item, key, '', level);\\n        }\\n      }\\n    } else {\\n      //nested node\\n      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\\n        const Ks = Object.keys(jObj[key]);\\n        const L = Ks.length;\\n        for (let j = 0; j < L; j++) {\\n          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);\\n        }\\n      } else {\\n        val += this.processTextOrObjNode(jObj[key], key, level)\\n      }\\n    }\\n  }\\n  return {attrStr: attrStr, val: val};\\n};\\n\\nfunction buildAttrPairStr(attrName, val){\\n  val = this.options.attributeValueProcessor(attrName, '' + val);\\n  val = this.replaceEntitiesValue(val);\\n  if (this.options.suppressBooleanAttributes && val === \\\"true\\\") {\\n    return ' ' + attrName;\\n  } else return ' ' + attrName + '=\\\"' + val + '\\\"';\\n}\\n\\nfunction processTextOrObjNode (object, key, level) {\\n  const result = this.j2x(object, level + 1);\\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\\n    return this.buildTextNode(object[this.options.textNodeName], key, result.attrStr, level);\\n  } else {\\n    return this.buildObjNode(result.val, key, result.attrStr, level);\\n  }\\n}\\n\\nfunction buildObjectNode(val, key, attrStr, level) {\\n  let tagEndExp = '</' + key + this.tagEndChar;\\n  let piClosingChar = \\\"\\\";\\n  \\n  if(key[0] === \\\"?\\\") {\\n    piClosingChar = \\\"?\\\";\\n    tagEndExp = \\\"\\\";\\n  }\\n\\n  if (attrStr && val.indexOf('<') === -1) {\\n    return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );\\n  } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\\n    return this.indentate(level) + `<!--${val}-->` + this.newLine;\\n  }else {\\n    return (\\n      this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +\\n      val +\\n      this.indentate(level) + tagEndExp    );\\n  }\\n}\\n\\nfunction buildEmptyObjNode(val, key, attrStr, level) {\\n  if (val !== '') {\\n    return this.buildObjectNode(val, key, attrStr, level);\\n  } else {\\n    if(key[0] === \\\"?\\\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\\n    else return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\\n  }\\n}\\n\\nfunction buildTextValNode(val, key, attrStr, level) {\\n  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\\n    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;\\n  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\\n    return this.indentate(level) + `<!--${val}-->` +  this.newLine;\\n  }else{\\n    let textValue = this.options.tagValueProcessor(key, val);\\n    textValue = this.replaceEntitiesValue(textValue);\\n  \\n    if( textValue === '' && this.options.unpairedTags.indexOf(key) !== -1){ //unpaired\\n      if(this.options.suppressUnpairedNode){\\n        return this.indentate(level) + '<' + key + this.tagEndChar;\\n      }else{\\n        return this.indentate(level) + '<' + key + \\\"/\\\" + this.tagEndChar;\\n      }\\n    } else{\\n      return (\\n        this.indentate(level) + '<' + key + attrStr + '>' +\\n         textValue +\\n        '</' + key + this.tagEndChar  );\\n    }\\n\\n  }\\n}\\n\\nfunction replaceEntitiesValue(textValue){\\n  if(textValue && textValue.length > 0 && this.options.processEntities){\\n    for (let i=0; i<this.options.entities.length; i++) {\\n      const entity = this.options.entities[i];\\n      textValue = textValue.replace(entity.regex, entity.val);\\n    }\\n  }\\n  return textValue;\\n}\\n\\nfunction buildEmptyTextNode(val, key, attrStr, level) {\\n  if( val === '' && this.options.unpairedTags.indexOf(key) !== -1){ //unpaired\\n    if(this.options.suppressUnpairedNode){\\n      return this.indentate(level) + '<' + key + this.tagEndChar;\\n    }else{\\n      return this.indentate(level) + '<' + key + \\\"/\\\" + this.tagEndChar;\\n    }\\n  }else if (val !== '') { //empty\\n    return this.buildTextValNode(val, key, attrStr, level);\\n  } else {\\n    if(key[0] === \\\"?\\\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; //PI tag\\n    else return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar; //normal\\n  }\\n}\\n\\nfunction indentate(level) {\\n  return this.options.indentBy.repeat(level);\\n}\\n\\nfunction isAttribute(name /*, options*/) {\\n  if (name.startsWith(this.options.attributeNamePrefix)) {\\n    return name.substr(this.attrPrefixLen);\\n  } else {\\n    return false;\\n  }\\n}\\n\\nmodule.exports = Builder;\\n\",\"const EOL = \\\"\\\\n\\\";\\n\\n/**\\n * \\n * @param {array} jArray \\n * @param {any} options \\n * @returns \\n */\\nfunction toXml(jArray, options){\\n    return arrToStr( jArray, options, \\\"\\\", 0);\\n}\\n\\nfunction arrToStr(arr, options, jPath, level){\\n    let xmlStr = \\\"\\\";\\n\\n    let indentation = \\\"\\\";\\n    if(options.format && options.indentBy.length > 0){//TODO: this logic can be avoided for each call\\n        indentation = EOL + \\\"\\\" + options.indentBy.repeat(level);\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        const tagObj = arr[i];\\n        const tagName = propName(tagObj);\\n        let newJPath = \\\"\\\";\\n        if(jPath.length === 0) newJPath = tagName\\n        else newJPath = `${jPath}.${tagName}`;\\n\\n        if(tagName === options.textNodeName){\\n            let tagText = tagObj[tagName];\\n            if(!isStopNode(newJPath, options)){\\n                tagText = options.tagValueProcessor( tagName, tagText);\\n                tagText = replaceEntitiesValue(tagText, options);\\n            }\\n            xmlStr += indentation + tagText;\\n            continue;\\n        }else if( tagName === options.cdataPropName){\\n            xmlStr += indentation + `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\\n            continue;\\n        }else if( tagName === options.commentPropName){\\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\\n            continue;\\n        }else if( tagName[0] === \\\"?\\\"){\\n            const attStr = attr_to_str(tagObj[\\\":@\\\"], options);\\n            const tempInd = tagName === \\\"?xml\\\" ? \\\"\\\" : indentation;\\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\\n            piTextNodeName = piTextNodeName.length !== 0 ? \\\" \\\" + piTextNodeName : \\\"\\\"; //remove extra spacing\\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\\n            continue;\\n        }\\n        const attStr = attr_to_str(tagObj[\\\":@\\\"], options);\\n        let tagStart =  indentation + `<${tagName}${attStr}`;\\n        let tagValue = arrToStr(tagObj[tagName], options, newJPath, level + 1);\\n        if(options.unpairedTags.indexOf(tagName) !== -1){\\n            if(options.suppressUnpairedNode)  xmlStr += tagStart + \\\">\\\"; \\n            else xmlStr += tagStart + \\\"/>\\\"; \\n        }else if( (!tagValue || tagValue.length === 0) && options.suppressEmptyNode){ \\n            xmlStr += tagStart + \\\"/>\\\"; \\n        }else{ \\n            //TODO: node with only text value should not parse the text value in next line\\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>` ;\\n        }\\n    }\\n    \\n    return xmlStr;\\n}\\n\\nfunction propName(obj){\\n    const keys = Object.keys(obj);\\n    for (let i = 0; i < keys.length; i++) {\\n      const key = keys[i];\\n      if(key !== \\\":@\\\") return key;\\n    }\\n  }\\n\\nfunction attr_to_str(attrMap, options){\\n    let attrStr = \\\"\\\";\\n    if(attrMap && !options.ignoreAttributes){\\n        for (let attr in attrMap){\\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\\n            attrVal = replaceEntitiesValue(attrVal, options);\\n            if(attrVal === true && options.suppressBooleanAttributes){\\n                attrStr+= ` ${attr.substr(options.attributeNamePrefix.length)}`;\\n            }else{\\n                attrStr+= ` ${attr.substr(options.attributeNamePrefix.length)}=\\\"${attrVal}\\\"`;\\n            }\\n        }\\n    }\\n    return attrStr;\\n}\\n\\nfunction isStopNode(jPath, options){\\n    jPath = jPath.substr(0,jPath.length - options.textNodeName.length - 1);\\n    let tagName = jPath.substr(jPath.lastIndexOf(\\\".\\\") + 1);\\n    for(let index in options.stopNodes){\\n        if(options.stopNodes[index] === jPath || options.stopNodes[index] === \\\"*.\\\"+tagName) return true;\\n    }\\n    return false;\\n}\\n\\nfunction replaceEntitiesValue(textValue, options){\\n    if(textValue && textValue.length > 0 && options.processEntities){\\n      for (let i=0; i< options.entities.length; i++) {\\n        const entity = options.entities[i];\\n        textValue = textValue.replace(entity.regex, entity.val);\\n      }\\n    }\\n    return textValue;\\n  }\\nmodule.exports = toXml;\",\"// The module cache\\nvar __webpack_module_cache__ = {};\\n\\n// The require function\\nfunction __webpack_require__(moduleId) {\\n\\t// Check if module is in cache\\n\\tvar cachedModule = __webpack_module_cache__[moduleId];\\n\\tif (cachedModule !== undefined) {\\n\\t\\treturn cachedModule.exports;\\n\\t}\\n\\t// Create a new module (and put it into the cache)\\n\\tvar module = __webpack_module_cache__[moduleId] = {\\n\\t\\t// no module.id needed\\n\\t\\t// no module.loaded needed\\n\\t\\texports: {}\\n\\t};\\n\\n\\t// Execute the module function\\n\\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\\n\\n\\t// Return the exports of the module\\n\\treturn module.exports;\\n}\\n\\n\",\"// startup\\n// Load entry module and return exports\\n// This entry module is referenced by other modules so it can't be inlined\\nvar __webpack_exports__ = __webpack_require__(784);\\n\"],\"names\":[\"buildFromOrderedJs\",\"require\",\"defaultOptions\",\"attributeNamePrefix\",\"attributesGroupName\",\"textNodeName\",\"ignoreAttributes\",\"cdataPropName\",\"format\",\"indentBy\",\"suppressEmptyNode\",\"suppressUnpairedNode\",\"suppressBooleanAttributes\",\"tagValueProcessor\",\"key\",\"a\",\"attributeValueProcessor\",\"attrName\",\"preserveOrder\",\"commentPropName\",\"unpairedTags\",\"entities\",\"regex\",\"RegExp\",\"val\",\"processEntities\",\"stopNodes\",\"transformTagName\",\"Builder\",\"options\",\"this\",\"Object\",\"assign\",\"isAttribute\",\"attrPrefixLen\",\"length\",\"processTextOrObjNode\",\"indentate\",\"tagEndChar\",\"newLine\",\"buildTextNode\",\"buildEmptyTextNode\",\"buildObjNode\",\"buildEmptyObjNode\",\"buildTextValNode\",\"buildObjectNode\",\"replaceEntitiesValue\",\"buildAttrPairStr\",\"object\",\"level\",\"result\",\"j2x\",\"undefined\",\"keys\",\"attrStr\",\"tagEndExp\",\"piClosingChar\",\"indexOf\",\"textValue\",\"i\",\"entity\",\"replace\",\"repeat\",\"name\",\"startsWith\",\"substr\",\"prototype\",\"build\",\"jObj\",\"Array\",\"isArray\",\"arrayNodeName\",\"Date\",\"attr\",\"newval\",\"arrLen\",\"j\",\"item\",\"Ks\",\"L\",\"module\",\"exports\",\"arrToStr\",\"arr\",\"jPath\",\"xmlStr\",\"indentation\",\"newJPath\",\"tagObj\",\"tagName\",\"propName\",\"tagStart\",\"attr_to_str\",\"tagValue\",\"attStr\",\"tempInd\",\"piTextNodeName\",\"tagText\",\"isStopNode\",\"obj\",\"attrMap\",\"attrVal\",\"lastIndexOf\",\"index\",\"jArray\",\"__webpack_module_cache__\",\"__webpack_exports__\",\"__webpack_require__\",\"moduleId\",\"cachedModule\",\"__webpack_modules__\"],\"sourceRoot\":\"\"}",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/fxp.min.js||lib/fxp.min.js": [
          "File: lib/fxp.min.js -> lib/fxp.min.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: var fxp;(()=>{var t={807:t=>{const e=/^[-+]?0x[a-fA-F0-9]+$/,i=/^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;!Number.parseInt&&window.parseInt&&(Number.parseInt=window.parseInt),!Number.parseFloat&&window.parseFloat&&(Number.parseFloat=window.parseFloat);const r={hex:!0,leadingZeros:!0,decimalPoint:\".\",eNotation:!0};t.exports=function(t,n={}){if(n=Object.assign({},r,n),!t||\"string\"!=typeof t)return t;let s=t.trim();if(void 0!==n.skipLike&&n.skipLike.test(s))return t;if(n.hex&&e.test(s))return Number.parseInt(s,16);{const e=i.exec(s);if(e){const i=e[1],r=e[2];let o=(a=e[3])&&-1!==a.indexOf(\".\")?(\".\"===(a=a.replace(/0+$/,\"\"))?a=\"0\":\".\"===a[0]?a=\"0\"+a:\".\"===a[a.length-1]&&(a=a.substr(0,a.length-1)),a):a;const u=e[4]||e[6];if(!n.leadingZeros&&r.length>0&&i&&\".\"!==s[2])return t;if(!n.leadingZeros&&r.length>0&&!i&&\".\"!==s[1])return t;{const e=Number(s),a=\"\"+e;return-1!==a.search(/[eE]/)||u?n.eNotation?e:t:-1!==s.indexOf(\".\")?\"0\"===a&&\"\"===o||a===o||i&&a===\"-\"+o?e:t:r?o===a||i+o===a?e:t:s===a||s===i+a?e:t}}return t}var a}},316:(t,e,i)=>{\"use strict\";var r=i(239),n=i(870),s=i(784);t.exports={XMLParser:n,XMLValidator:r,XMLBuilder:s}},839:(t,e)=>{\"use strict\";var i=\"[:A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*\",r=new RegExp(\"^\"+i+\"$\");e.isExist=function(t){return void 0!==t},e.isEmptyObject=function(t){return 0===Object.keys(t).length},e.merge=function(t,e,i){if(e)for(var r=Object.keys(e),n=r.length,s=0;s<n;s++)t[r[s]]=\"strict\"===i?[e[r[s]]]:e[r[s]]},e.getValue=function(t){return e.isExist(t)?t:\"\"},e.isName=function(t){return!(null==r.exec(t))},e.getAllMatches=function(t,e){for(var i=[],r=e.exec(t);r;){var n=[];n.startIndex=e.lastIndex-r[0].length;for(var s=r.length,a=0;a<s;a++)n.push(r[a]);i.push(n),r=e.exec(t)}return i},e.nameRegexp=i},239:(t,e,i)=>{\"use strict\";var r=i(839),n={allowBooleanAttributes:!1,unpairedTags:[]};function s(t){return\" \"===t||\"\\t\"===t||\"\\n\"===t||\"\\r\"===t}function a(t,e){for(var i=e;e<t.length;e++)if(\"?\"!=t[e]&&\" \"!=t[e]);else{var r=t.substr(i,e-i);if(e>5&&\"xml\"===r)return p(\"InvalidXml\",\"XML declaration allowed only at the start of the document.\",g(t,e));if(\"?\"==t[e]&&\">\"==t[e+1]){e++;break}}return e}function o(t,e){if(t.length>e+5&&\"-\"===t[e+1]&&\"-\"===t[e+2]){for(e+=3;e<t.length;e++)if(\"-\"===t[e]&&\"-\"===t[e+1]&&\">\"===t[e+2]){e+=2;break}}else if(t.length>e+8&&\"D\"===t[e+1]&&\"O\"===t[e+2]&&\"C\"===t[e+3]&&\"T\"===t[e+4]&&\"Y\"===t[e+5]&&\"P\"===t[e+6]&&\"E\"===t[e+7]){var i=1;for(e+=8;e<t.length;e++)if(\"<\"===t[e])i++;else if(\">\"===t[e]&&0==--i)break}else if(t.length>e+9&&\"[\"===t[e+1]&&\"C\"===t[e+2]&&\"D\"===t[e+3]&&\"A\"===t[e+4]&&\"T\"===t[e+5]&&\"A\"===t[e+6]&&\"[\"===t[e+7])for(e+=8;e<t.length;e++)if(\"]\"===t[e]&&\"]\"===t[e+1]&&\">\"===t[e+2]){e+=2;break}return e}function u(t,e){for(var i=\"\",r=\"\",n=!1;e<t.length;e++){if('\"'===t[e]||\"'\"===t[e])\"\"===r?r=t[e]:r!==t[e]||(r=\"\");else if(\">\"===t[e]&&\"\"===r){n=!0;break}i+=t[e]}return\"\"===r&&{value:i,index:e,tagClosed:n}}e.validate=function(t,e){e=Object.assign({},n,e);var i,l=[],f=!1,c=!1;\"\\ufeff\"===t[0]&&(t=t.substr(1));for(var v=0;v<t.length;v++)if(\"<\"===t[v]&&\"?\"===t[v+1]){if((v=a(t,v+=2)).err)return v}else{if(\"<\"!==t[v]){if(s(t[v]))continue;return p(\"InvalidChar\",\"char '\"+t[v]+\"' is not expected.\",g(t,v))}var x=v;if(\"!\"===t[++v]){v=o(t,v);continue}var m=!1;\"/\"===t[v]&&(m=!0,v++);for(var N=\"\";v<t.length&&\">\"!==t[v]&&\" \"!==t[v]&&\"\\t\"!==t[v]&&\"\\n\"!==t[v]&&\"\\r\"!==t[v];v++)N+=t[v];if(\"/\"===(N=N.trim())[N.length-1]&&(N=N.substring(0,N.length-1),v--),i=N,!r.isName(i))return p(\"InvalidTag\",0===N.trim().length?\"Invalid space after '<'.\":\"Tag '\"+N+\"' is an invalid name.\",g(t,v));var b=u(t,v);if(!1===b)return p(\"InvalidAttr\",\"Attributes for '\"+N+\"' have open quote.\",g(t,v));var E=b.value;if(v=b.index,\"/\"===E[E.length-1]){var T=v-E.length,y=h(E=E.substring(0,E.length-1),e);if(!0!==y)return p(y.err.code,y.err.msg,g(t,T+y.err.line));f=!0}else if(m){if(!b.tagClosed)return p(\"InvalidTag\",\"Closing tag '\"+N+\"' doesn't have proper closing.\",g(t,v));if(E.trim().length>0)return p(\"InvalidTag\",\"Closing tag '\"+N+\"' can't have attributes or invalid starting.\",g(t,x));var O=l.pop();if(N!==O.tagName){var A=g(t,O.tagStartPos);return p(\"InvalidTag\",\"Expected closing tag '\"+O.tagName+\"' (opened in line \"+A.line+\", col \"+A.col+\") instead of closing tag '\"+N+\"'.\",g(t,x))}0==l.length&&(c=!0)}else{var P=h(E,e);if(!0!==P)return p(P.err.code,P.err.msg,g(t,v-E.length+P.err.line));if(!0===c)return p(\"InvalidXml\",\"Multiple possible root nodes found.\",g(t,v));-1!==e.unpairedTags.indexOf(N)||l.push({tagName:N,tagStartPos:x}),f=!0}for(v++;v<t.length;v++)if(\"<\"===t[v]){if(\"!\"===t[v+1]){v=o(t,++v);continue}if(\"?\"!==t[v+1])break;if((v=a(t,++v)).err)return v}else if(\"&\"===t[v]){var w=d(t,v);if(-1==w)return p(\"InvalidChar\",\"char '&' is not expected.\",g(t,v));v=w}else if(!0===c&&!s(t[v]))return p(\"InvalidXml\",\"Extra text at the end\",g(t,v));\"<\"===t[v]&&v--}return f?1==l.length?p(\"InvalidTag\",\"Unclosed tag '\"+l[0].tagName+\"'.\",g(t,l[0].tagStartPos)):!(l.length>0)||p(\"InvalidXml\",\"Invalid '\"+JSON.stringify(l.map((function(t){return t.tagName})),null,4).replace(/\\r?\\n/g,\"\")+\"' found.\",{line:1,col:1}):p(\"InvalidXml\",\"Start tag expected.\",1)};var l=new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\",\"g\");function h(t,e){for(var i=r.getAllMatches(t,l),n={},s=0;s<i.length;s++){if(0===i[s][1].length)return p(\"InvalidAttr\",\"Attribute '\"+i[s][2]+\"' has no space in starting.\",c(i[s]));if(void 0!==i[s][3]&&void 0===i[s][4])return p(\"InvalidAttr\",\"Attribute '\"+i[s][2]+\"' is without value.\",c(i[s]));if(void 0===i[s][3]&&!e.allowBooleanAttributes)return p(\"InvalidAttr\",\"boolean attribute '\"+i[s][2]+\"' is not allowed.\",c(i[s]));var a=i[s][2];if(!f(a))return p(\"InvalidAttr\",\"Attribute '\"+a+\"' is an invalid name.\",c(i[s]));if(n.hasOwnProperty(a))return p(\"InvalidAttr\",\"Attribute '\"+a+\"' is repeated.\",c(i[s]));n[a]=1}return!0}function d(t,e){if(\";\"===t[++e])return-1;if(\"#\"===t[e])return function(t,e){var i=/\\d/;for(\"x\"===t[e]&&(e++,i=/[\\da-fA-F]/);e<t.length;e++){if(\";\"===t[e])return e;if(!t[e].match(i))break}return-1}(t,++e);for(var i=0;e<t.length;e++,i++)if(!(t[e].match(/\\w/)&&i<20)){if(\";\"===t[e])break;return-1}return e}function p(t,e,i){return{err:{code:t,msg:e,line:i.line||i,col:i.col}}}function f(t){return r.isName(t)}function g(t,e){var i=t.substring(0,e).split(/\\r?\\n/);return{line:i.length,col:i[i.length-1].length+1}}function c(t){return t.startIndex+t[1].length}},784:(t,e,i)=>{\"use strict\";var r=i(687),n={attributeNamePrefix:\"@_\",attributesGroupName:!1,textNodeName:\"#text\",ignoreAttributes:!0,cdataPropName:!1,format:!1,indentBy:\"  \",suppressEmptyNode:!1,suppressUnpairedNode:!0,suppressBooleanAttributes:!0,tagValueProcessor:function(t,e){return e},attributeValueProcessor:function(t,e){return e},preserveOrder:!1,commentPropName:!1,unpairedTags:[],entities:[{regex:new RegExp(\"&\",\"g\"),val:\"&amp;\"},{regex:new RegExp(\">\",\"g\"),val:\"&gt;\"},{regex:new RegExp(\"<\",\"g\"),val:\"&lt;\"},{regex:new RegExp(\"'\",\"g\"),val:\"&apos;\"},{regex:new RegExp('\"',\"g\"),val:\"&quot;\"}],processEntities:!0,stopNodes:[],transformTagName:!1};function s(t){this.options=Object.assign({},n,t),this.options.ignoreAttributes||this.options.attributesGroupName?this.isAttribute=function(){return!1}:(this.attrPrefixLen=this.options.attributeNamePrefix.length,this.isAttribute=g),this.processTextOrObjNode=o,this.options.format?(this.indentate=f,this.tagEndChar=\">\\n\",this.newLine=\"\\n\"):(this.indentate=function(){return\"\"},this.tagEndChar=\">\",this.newLine=\"\"),this.options.suppressEmptyNode?(this.buildTextNode=p,this.buildObjNode=l):(this.buildTextNode=h,this.buildObjNode=u),this.buildTextValNode=h,this.buildObjectNode=u,this.replaceEntitiesValue=d,this.buildAttrPairStr=a}function a(t,e){return e=this.options.attributeValueProcessor(t,\"\"+e),e=this.replaceEntitiesValue(e),this.options.suppressBooleanAttributes&&\"true\"===e?\" \"+t:\" \"+t+'=\"'+e+'\"'}function o(t,e,i){var r=this.j2x(t,i+1);return void 0!==t[this.options.textNodeName]&&1===Object.keys(t).length?this.buildTextNode(t[this.options.textNodeName],e,r.attrStr,i):this.buildObjNode(r.val,e,r.attrStr,i)}function u(t,e,i,r){var n=\"</\"+e+this.tagEndChar,s=\"\";return\"?\"===e[0]&&(s=\"?\",n=\"\"),i&&-1===t.indexOf(\"<\")?this.indentate(r)+\"<\"+e+i+s+\">\"+t+n:!1!==this.options.commentPropName&&e===this.options.commentPropName&&0===s.length?this.indentate(r)+\"\\x3c!--\"+t+\"--\\x3e\"+this.newLine:this.indentate(r)+\"<\"+e+i+s+this.tagEndChar+t+this.indentate(r)+n}function l(t,e,i,r){return\"\"!==t?this.buildObjectNode(t,e,i,r):\"?\"===e[0]?this.indentate(r)+\"<\"+e+i+\"?\"+this.tagEndChar:this.indentate(r)+\"<\"+e+i+\"/\"+this.tagEndChar}function h(t,e,i,r){if(!1!==this.options.cdataPropName&&e===this.options.cdataPropName)return this.indentate(r)+\"<![CDATA[\"+t+\"]]>\"+this.newLine;if(!1!==this.options.commentPropName&&e===this.options.commentPropName)return this.indentate(r)+\"\\x3c!--\"+t+\"--\\x3e\"+this.newLine;var n=this.options.tagValueProcessor(e,t);return\"\"===(n=this.replaceEntitiesValue(n))&&-1!==this.options.unpairedTags.indexOf(e)?this.options.suppressUnpairedNode?this.indentate(r)+\"<\"+e+this.tagEndChar:this.indentate(r)+\"<\"+e+\"/\"+this.tagEndChar:this.indentate(r)+\"<\"+e+i+\">\"+n+\"</\"+e+this.tagEndChar}function d(t){if(t&&t.length>0&&this.options.processEntities)for(var e=0;e<this.options.entities.length;e++){var i=this.options.entities[e];t=t.replace(i.regex,i.val)}return t}function p(t,e,i,r){return\"\"===t&&-1!==this.options.unpairedTags.indexOf(e)?this.options.suppressUnpairedNode?this.indentate(r)+\"<\"+e+this.tagEndChar:this.indentate(r)+\"<\"+e+\"/\"+this.tagEndChar:\"\"!==t?this.buildTextValNode(t,e,i,r):\"?\"===e[0]?this.indentate(r)+\"<\"+e+i+\"?\"+this.tagEndChar:this.indentate(r)+\"<\"+e+i+\"/\"+this.tagEndChar}function f(t){return this.options.indentBy.repeat(t)}function g(t){return!!t.startsWith(this.options.attributeNamePrefix)&&t.substr(this.attrPrefixLen)}s.prototype.build=function(t){return this.options.preserveOrder?r(t,this.options):(Array.isArray(t)&&this.options.arrayNodeName&&this.options.arrayNodeName.length>1&&((e={})[this.options.arrayNodeName]=t,t=e),this.j2x(t,0).val);var e},s.prototype.j2x=function(t,e){var i=\"\",r=\"\";for(var n in t)if(void 0===t[n]);else if(null===t[n])\"?\"===n[0]?r+=this.indentate(e)+\"<\"+n+\"?\"+this.tagEndChar:r+=this.indentate(e)+\"<\"+n+\"/\"+this.tagEndChar;else if(t[n]instanceof Date)r+=this.buildTextNode(t[n],n,\"\",e);else if(\"object\"!=typeof t[n]){var s=this.isAttribute(n);if(s)i+=this.buildAttrPairStr(s,\"\"+t[n]);else if(n===this.options.textNodeName){var a=this.options.tagValueProcessor(n,\"\"+t[n]);r+=this.replaceEntitiesValue(a)}else r+=this.buildTextNode(t[n],n,\"\",e)}else if(Array.isArray(t[n]))for(var o=t[n].length,u=0;u<o;u++){var l=t[n][u];void 0===l||(null===l?\"?\"===n[0]?r+=this.indentate(e)+\"<\"+n+\"?\"+this.tagEndChar:r+=this.indentate(e)+\"<\"+n+\"/\"+this.tagEndChar:r+=\"object\"==typeof l?this.processTextOrObjNode(l,n,e):this.buildTextNode(l,n,\"\",e))}else if(this.options.attributesGroupName&&n===this.options.attributesGroupName)for(var h=Object.keys(t[n]),d=h.length,p=0;p<d;p++)i+=this.buildAttrPairStr(h[p],\"\"+t[n][h[p]]);else r+=this.processTextOrObjNode(t[n],n,e);return{attrStr:i,val:r}},t.exports=s},687:t=>{function e(t,a,o,u){var l=\"\",h=\"\";a.format&&a.indentBy.length>0&&(h=\"\\n\"+a.indentBy.repeat(u));for(var d=0;d<t.length;d++){var p,f=t[d],g=i(f);if(p=0===o.length?g:o+\".\"+g,g!==a.textNodeName)if(g!==a.cdataPropName)if(g!==a.commentPropName)if(\"?\"!==g[0]){var c=h+\"<\"+g+r(f[\":@\"],a),v=e(f[g],a,p,u+1);-1!==a.unpairedTags.indexOf(g)?a.suppressUnpairedNode?l+=c+\">\":l+=c+\"/>\":v&&0!==v.length||!a.suppressEmptyNode?l+=c+\">\"+v+h+\"</\"+g+\">\":l+=c+\"/>\"}else{var x=r(f[\":@\"],a),m=\"?xml\"===g?\"\":h,N=f[g][0][a.textNodeName];l+=m+\"<\"+g+(N=0!==N.length?\" \"+N:\"\")+x+\"?>\"}else l+=h+\"\\x3c!--\"+f[g][0][a.textNodeName]+\"--\\x3e\";else l+=h+\"<![CDATA[\"+f[g][0][a.textNodeName]+\"]]>\";else{var b=f[g];n(p,a)||(b=s(b=a.tagValueProcessor(g,b),a)),l+=h+b}}return l}function i(t){for(var e=Object.keys(t),i=0;i<e.length;i++){var r=e[i];if(\":@\"!==r)return r}}function r(t,e){var i=\"\";if(t&&!e.ignoreAttributes)for(var r in t){var n=e.attributeValueProcessor(r,t[r]);!0===(n=s(n,e))&&e.suppressBooleanAttributes?i+=\" \"+r.substr(e.attributeNamePrefix.length):i+=\" \"+r.substr(e.attributeNamePrefix.length)+'=\"'+n+'\"'}return i}function n(t,e){var i=(t=t.substr(0,t.length-e.textNodeName.length-1)).substr(t.lastIndexOf(\".\")+1);for(var r in e.stopNodes)if(e.stopNodes[r]===t||e.stopNodes[r]===\"*.\"+i)return!0;return!1}function s(t,e){if(t&&t.length>0&&e.processEntities)for(var i=0;i<e.entities.length;i++){var r=e.entities[i];t=t.replace(r.regex,r.val)}return t}t.exports=function(t,i){return e(t,i,\"\",0)}},106:t=>{var e=RegExp(\"^\\\\s([a-zA-z0-0]+)[ \\t](['\\\"])([^&]+)\\\\2\");function i(t,i){var r=e.exec(t);r&&(i[r[1]]={regx:RegExp(\"&\"+r[1]+\";\",\"g\"),val:r[3]})}t.exports=function(t,e){var r={};if(\"O\"!==t[e+3]||\"C\"!==t[e+4]||\"T\"!==t[e+5]||\"Y\"!==t[e+6]||\"P\"!==t[e+7]||\"E\"!==t[e+8])throw new Error(\"Invalid Tag instead of DOCTYPE\");e+=9;for(var n=1,s=!1,a=!1,o=!1,u=\"\";e<t.length;e++)if(\"<\"===t[e]){if(s&&\"!\"===t[e+1]&&\"E\"===t[e+2]&&\"N\"===t[e+3]&&\"T\"===t[e+4]&&\"I\"===t[e+5]&&\"T\"===t[e+6]&&\"Y\"===t[e+7])e+=7,a=!0;else if(s&&\"!\"===t[e+1]&&\"E\"===t[e+2]&&\"L\"===t[e+3]&&\"E\"===t[e+4]&&\"M\"===t[e+5]&&\"E\"===t[e+6]&&\"N\"===t[e+7]&&\"T\"===t[e+8])e+=8;else if(s&&\"!\"===t[e+1]&&\"A\"===t[e+2]&&\"T\"===t[e+3]&&\"T\"===t[e+4]&&\"L\"===t[e+5]&&\"I\"===t[e+6]&&\"S\"===t[e+7]&&\"T\"===t[e+8])e+=8;else if(s&&\"!\"===t[e+1]&&\"N\"===t[e+2]&&\"O\"===t[e+3]&&\"T\"===t[e+4]&&\"A\"===t[e+5]&&\"T\"===t[e+6]&&\"I\"===t[e+7]&&\"O\"===t[e+8]&&\"N\"===t[e+9])e+=9;else{if(\"!\"!==t[e+1]||\"-\"!==t[e+2]||\"-\"!==t[e+3])throw new Error(\"Invalid DOCTYPE\");o=!0}n++,u=\"\"}else if(\">\"===t[e]){if(o){if(\"-\"!==t[e-1]||\"-\"!==t[e-2])throw new Error(\"Invalid XML comment in DOCTYPE\");o=!1}else a&&(i(u,r),a=!1);if(0==--n)break}else\"[\"===t[e]?s=!0:u+=t[e];if(0!==n)throw new Error(\"Unclosed DOCTYPE\");return{entities:r,i:e}}},348:(t,e)=>{var i={preserveOrder:!1,attributeNamePrefix:\"@_\",attributesGroupName:!1,textNodeName:\"#text\",ignoreAttributes:!0,removeNSPrefix:!1,allowBooleanAttributes:!1,parseTagValue:!0,parseAttributeValue:!1,trimValues:!0,cdataPropName:!1,numberParseOptions:{hex:!0,leadingZeros:!0},tagValueProcessor:function(t,e){return e},attributeValueProcessor:function(t,e){return e},stopNodes:[],alwaysCreateTextNode:!1,isArray:function(){return!1},commentPropName:!1,unpairedTags:[],processEntities:!0,htmlEntities:!1,ignoreDeclaration:!1,ignorePiTags:!1,transformTagName:!1};e.buildOptions=function(t){return Object.assign({},i,t)},e.defaultOptions=i},498:(t,e,i)=>{\"use strict\";var r=i(839),n=i(876),s=i(106),a=i(807);function o(t){for(var e=Object.keys(t),i=0;i<e.length;i++){var r=e[i];this.lastEntities[r]={regex:new RegExp(\"&\"+r+\";\",\"g\"),val:t[r]}}}function u(t,e,i,r,n,s,a){if(void 0!==t&&(this.options.trimValues&&!r&&(t=t.trim()),t.length>0)){a||(t=this.replaceEntitiesValue(t));var o=this.options.tagValueProcessor(e,t,i,n,s);return null==o?t:typeof o!=typeof t||o!==t?o:this.options.trimValues||t.trim()===t?N(t,this.options.parseTagValue,this.options.numberParseOptions):t}}function l(t){if(this.options.removeNSPrefix){var e=t.split(\":\"),i=\"/\"===t.charAt(0)?\"/\":\"\";if(\"xmlns\"===e[0])return\"\";2===e.length&&(t=i+e[1])}return t}\"<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)\".replace(/NAME/g,r.nameRegexp);var h=new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])([\\\\s\\\\S]*?)\\\\3)?\",\"gm\");function d(t,e){if(!this.options.ignoreAttributes&&\"string\"==typeof t){for(var i=r.getAllMatches(t,h),n=i.length,s={},a=0;a<n;a++){var o=this.resolveNameSpace(i[a][1]),u=i[a][4],l=this.options.attributeNamePrefix+o;if(o.length)if(void 0!==u){this.options.trimValues&&(u=u.trim()),u=this.replaceEntitiesValue(u);var d=this.options.attributeValueProcessor(o,u,e);s[l]=null==d?u:typeof d!=typeof u||d!==u?d:N(u,this.options.parseAttributeValue,this.options.numberParseOptions)}else this.options.allowBooleanAttributes&&(s[l]=!0)}if(!Object.keys(s).length)return;if(this.options.attributesGroupName){var p={};return p[this.options.attributesGroupName]=s,p}return s}}var p=function(t){t=t.replace(/\\r\\n?/g,\"\\n\");for(var e=new n(\"!xml\"),i=e,r=\"\",a=\"\",o=0;o<t.length;o++)if(\"<\"===t[o])if(\"/\"===t[o+1]){var u=v(t,\">\",o,\"Closing Tag is not closed.\"),l=t.substring(o+2,u).trim();if(this.options.removeNSPrefix){var h=l.indexOf(\":\");-1!==h&&(l=l.substr(h+1))}this.options.transformTagName&&(l=this.options.transformTagName(l)),i&&(r=this.saveTextToParentTag(r,i,a)),a=a.substr(0,a.lastIndexOf(\".\")),i=this.tagsNodeStack.pop(),r=\"\",o=u}else if(\"?\"===t[o+1]){var d=x(t,o,!1,\"?>\");if(!d)throw new Error(\"Pi Tag is not closed.\");if(r=this.saveTextToParentTag(r,i,a),this.options.ignoreDeclaration&&\"?xml\"===d.tagName||this.options.ignorePiTags);else{var p=new n(d.tagName);p.add(this.options.textNodeName,\"\"),d.tagName!==d.tagExp&&d.attrExpPresent&&(p[\":@\"]=this.buildAttributesMap(d.tagExp,a)),i.addChild(p)}o=d.closeIndex+1}else if(\"!--\"===t.substr(o+1,3)){var f=v(t,\"--\\x3e\",o+4,\"Comment is not closed.\");if(this.options.commentPropName){var g,c=t.substring(o+4,f-2);r=this.saveTextToParentTag(r,i,a),i.add(this.options.commentPropName,[(g={},g[this.options.textNodeName]=c,g)])}o=f}else if(\"!D\"===t.substr(o+1,2)){var m=s(t,o);this.docTypeEntities=m.entities,o=m.i}else if(\"![\"===t.substr(o+1,2)){var N=v(t,\"]]>\",o,\"CDATA is not closed.\")-2,b=t.substring(o+9,N);if(r=this.saveTextToParentTag(r,i,a),this.options.cdataPropName){var E;i.add(this.options.cdataPropName,[(E={},E[this.options.textNodeName]=b,E)])}else{var T=this.parseTextData(b,i.tagname,a,!0,!1,!0);null==T&&(T=\"\"),i.add(this.options.textNodeName,T)}o=N+2}else{var y=x(t,o,this.options.removeNSPrefix),O=y.tagName,A=y.tagExp,P=y.attrExpPresent,w=y.closeIndex;this.options.transformTagName&&(O=this.options.transformTagName(O)),i&&r&&\"!xml\"!==i.tagname&&(r=this.saveTextToParentTag(r,i,a,!1)),O!==e.tagname&&(a+=a?\".\"+O:O);var C=i;if(C&&-1!==this.options.unpairedTags.indexOf(C.tagname)&&(i=this.tagsNodeStack.pop()),this.isItStopNode(this.options.stopNodes,a,O)){var F=\"\";if(A.length>0&&A.lastIndexOf(\"/\")===A.length-1)o=y.closeIndex;else if(-1!==this.options.unpairedTags.indexOf(O))o=y.closeIndex;else{var I=this.readStopNodeData(t,O,w+1);if(!I)throw new Error(\"Unexpected end of \"+O);o=I.i,F=I.tagContent}var D=new n(O);O!==A&&P&&(D[\":@\"]=this.buildAttributesMap(A,a)),F&&(F=this.parseTextData(F,O,a,!0,P,!0,!0)),a=a.substr(0,a.lastIndexOf(\".\")),D.add(this.options.textNodeName,F),i.addChild(D)}else{if(A.length>0&&A.lastIndexOf(\"/\")===A.length-1){A=\"/\"===O[O.length-1]?O=O.substr(0,O.length-1):A.substr(0,A.length-1),this.options.transformTagName&&(O=this.options.transformTagName(O));var S=new n(O);O!==A&&P&&(S[\":@\"]=this.buildAttributesMap(A,a)),a=a.substr(0,a.lastIndexOf(\".\")),i.addChild(S)}else{var j=new n(O);this.tagsNodeStack.push(i),O!==A&&P&&(j[\":@\"]=this.buildAttributesMap(A,a)),i.addChild(j),i=j}r=\"\",o=w}}else r+=t[o];return e.child},f=function(t){if(this.options.processEntities){for(var e in this.docTypeEntities){var i=this.docTypeEntities[e];t=t.replace(i.regx,i.val)}for(var r in this.lastEntities){var n=this.lastEntities[r];t=t.replace(n.regex,n.val)}if(this.options.htmlEntities)for(var s in this.htmlEntities){var a=this.htmlEntities[s];t=t.replace(a.regex,a.val)}t=t.replace(this.ampEntity.regex,this.ampEntity.val)}return t};function g(t,e,i,r){return t&&(void 0===r&&(r=0===Object.keys(e.child).length),void 0!==(t=this.parseTextData(t,e.tagname,i,!1,!!e[\":@\"]&&0!==Object.keys(e[\":@\"]).length,r))&&\"\"!==t&&e.add(this.options.textNodeName,t),t=\"\"),t}function c(t,e,i){var r=\"*.\"+i;for(var n in t){var s=t[n];if(r===s||e===s)return!0}return!1}function v(t,e,i,r){var n=t.indexOf(e,i);if(-1===n)throw new Error(r);return n+e.length-1}function x(t,e,i,r){void 0===r&&(r=\">\");var n=function(t,e,i){var r;void 0===i&&(i=\">\");for(var n=\"\",s=e;s<t.length;s++){var a=t[s];if(r)a===r&&(r=\"\");else if('\"'===a||\"'\"===a)r=a;else if(a===i[0]){if(!i[1])return{data:n,index:s};if(t[s+1]===i[1])return{data:n,index:s}}else\"\\t\"===a&&(a=\" \");n+=a}}(t,e+1,r);if(n){var s=n.data,a=n.index,o=s.search(/\\s/),u=s,l=!0;if(-1!==o&&(u=s.substr(0,o).replace(/\\s\\s*$/,\"\"),s=s.substr(o+1)),i){var h=u.indexOf(\":\");-1!==h&&(l=(u=u.substr(h+1))!==n.data.substr(h+1))}return{tagName:u,tagExp:s,closeIndex:a,attrExpPresent:l}}}function m(t,e,i){for(var r=i,n=1;i<t.length;i++)if(\"<\"===t[i])if(\"/\"===t[i+1]){var s=v(t,\">\",i,e+\" is not closed\");if(t.substring(i+2,s).trim()===e&&0==--n)return{tagContent:t.substring(r,i),i:s};i=s}else if(\"?\"===t[i+1])i=v(t,\"?>\",i+1,\"StopNode is not closed.\");else if(\"!--\"===t.substr(i+1,3))i=v(t,\"--\\x3e\",i+3,\"StopNode is not closed.\");else if(\"![\"===t.substr(i+1,2))i=v(t,\"]]>\",i,\"StopNode is not closed.\")-2;else{var a=x(t,i,\">\");a&&((a&&a.tagName)===e&&\"/\"!==a.tagExp[a.tagExp.length-1]&&n++,i=a.closeIndex)}}function N(t,e,i){if(e&&\"string\"==typeof t){var n=t.trim();return\"true\"===n||\"false\"!==n&&a(t,i)}return r.isExist(t)?t:\"\"}t.exports=function(t){this.options=t,this.currentNode=null,this.tagsNodeStack=[],this.docTypeEntities={},this.lastEntities={apos:{regex:/&(apos|#39|#x27);/g,val:\"'\"},gt:{regex:/&(gt|#62|#x3E);/g,val:\">\"},lt:{regex:/&(lt|#60|#x3C);/g,val:\"<\"},quot:{regex:/&(quot|#34|#x22);/g,val:'\"'}},this.ampEntity={regex:/&(amp|#38|#x26);/g,val:\"&\"},this.htmlEntities={space:{regex:/&(nbsp|#160);/g,val:\" \"},cent:{regex:/&(cent|#162);/g,val:\"\u00a2\"},pound:{regex:/&(pound|#163);/g,val:\"\u00a3\"},yen:{regex:/&(yen|#165);/g,val:\"\u00a5\"},euro:{regex:/&(euro|#8364);/g,val:\"\u20ac\"},copyright:{regex:/&(copy|#169);/g,val:\"\u00a9\"},reg:{regex:/&(reg|#174);/g,val:\"\u00ae\"},inr:{regex:/&(inr|#8377);/g,val:\"\u20b9\"}},this.addExternalEntities=o,this.parseXml=p,this.parseTextData=u,this.resolveNameSpace=l,this.buildAttributesMap=d,this.isItStopNode=c,this.replaceEntitiesValue=f,this.readStopNodeData=m,this.saveTextToParentTag=g}},870:(t,e,i)=>{var r=i(348).buildOptions,n=i(498),s=i(400).prettify,a=i(239),o=function(){function t(t){this.externalEntities={},this.options=r(t)}var e=t.prototype;return e.parse=function(t,e){if(\"string\"==typeof t);else{if(!t.toString)throw new Error(\"XML data is accepted in String or Bytes[] form.\");t=t.toString()}if(e){!0===e&&(e={});var i=a.validate(t,e);if(!0!==i)throw Error(i.err.msg+\":\"+i.err.line+\":\"+i.err.col)}var r=new n(this.options);r.addExternalEntities(this.externalEntities);var o=r.parseXml(t);return this.options.preserveOrder||void 0===o?o:s(o,this.options)},e.addEntity=function(t,e){if(-1!==e.indexOf(\"&\"))throw new Error(\"Entity value can't have '&'\");if(-1!==t.indexOf(\"&\")||-1!==t.indexOf(\";\"))throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\");if(\"&\"===e)throw new Error(\"An entity with value '&' is not permitted\");this.externalEntities[t]=e},t}();t.exports=o},400:(t,e)=>{\"use strict\";function i(t,e,a){for(var o,u={},l=0;l<t.length;l++){var h,d=t[l],p=r(d);if(h=void 0===a?p:a+\".\"+p,p===e.textNodeName)void 0===o?o=d[p]:o+=\"\"+d[p];else{if(void 0===p)continue;if(d[p]){var f=i(d[p],e,h),g=s(f,e);d[\":@\"]?n(f,d[\":@\"],h,e):1!==Object.keys(f).length||void 0===f[e.textNodeName]||e.alwaysCreateTextNode?0===Object.keys(f).length&&(e.alwaysCreateTextNode?f[e.textNodeName]=\"\":f=\"\"):f=f[e.textNodeName],void 0!==u[p]&&u.hasOwnProperty(p)?(Array.isArray(u[p])||(u[p]=[u[p]]),u[p].push(f)):e.isArray(p,h,g)?u[p]=[f]:u[p]=f}}}return\"string\"==typeof o?o.length>0&&(u[e.textNodeName]=o):void 0!==o&&(u[e.textNodeName]=o),u}function r(t){for(var e=Object.keys(t),i=0;i<e.length;i++){var r=e[i];if(\":@\"!==r)return r}}function n(t,e,i,r){if(e)for(var n=Object.keys(e),s=n.length,a=0;a<s;a++){var o=n[a];r.isArray(o,i+\".\"+o,!0,!0)?t[o]=[e[o]]:t[o]=e[o]}}function s(t,e){var i=Object.keys(t).length;return!!(0===i||1===i&&t[e.textNodeName])}e.prettify=function(t,e){return i(t,e)}},876:t=>{\"use strict\";var e=function(){function t(t){this.tagname=t,this.child=[],this[\":@\"]={}}var e=t.prototype;return e.add=function(t,e){var i;this.child.push(((i={})[t]=e,i))},e.addChild=function(t){var e,i;t[\":@\"]&&Object.keys(t[\":@\"]).length>0?this.child.push(((e={})[t.tagname]=t.child,e[\":@\"]=t[\":@\"],e)):this.child.push(((i={})[t.tagname]=t.child,i))},t}();t.exports=e}},e={},i=function i(r){var n=e[r];if(void 0!==n)return n.exports;var s=e[r]={exports:{}};return t[r](s,s.exports,i),s.exports}(316);fxp=i})();",
          "",
          "[Added Lines]",
          "1: var fxp;(()=>{var t={807:t=>{const e=/^[-+]?0x[a-fA-F0-9]+$/,i=/^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;!Number.parseInt&&window.parseInt&&(Number.parseInt=window.parseInt),!Number.parseFloat&&window.parseFloat&&(Number.parseFloat=window.parseFloat);const r={hex:!0,leadingZeros:!0,decimalPoint:\".\",eNotation:!0};t.exports=function(t,n={}){if(n=Object.assign({},r,n),!t||\"string\"!=typeof t)return t;let s=t.trim();if(void 0!==n.skipLike&&n.skipLike.test(s))return t;if(n.hex&&e.test(s))return Number.parseInt(s,16);{const e=i.exec(s);if(e){const i=e[1],r=e[2];let o=(a=e[3])&&-1!==a.indexOf(\".\")?(\".\"===(a=a.replace(/0+$/,\"\"))?a=\"0\":\".\"===a[0]?a=\"0\"+a:\".\"===a[a.length-1]&&(a=a.substr(0,a.length-1)),a):a;const u=e[4]||e[6];if(!n.leadingZeros&&r.length>0&&i&&\".\"!==s[2])return t;if(!n.leadingZeros&&r.length>0&&!i&&\".\"!==s[1])return t;{const e=Number(s),a=\"\"+e;return-1!==a.search(/[eE]/)||u?n.eNotation?e:t:-1!==s.indexOf(\".\")?\"0\"===a&&\"\"===o||a===o||i&&a===\"-\"+o?e:t:r?o===a||i+o===a?e:t:s===a||s===i+a?e:t}}return t}var a}},316:(t,e,i)=>{\"use strict\";var r=i(239),n=i(870),s=i(784);t.exports={XMLParser:n,XMLValidator:r,XMLBuilder:s}},839:(t,e)=>{\"use strict\";var i=\"[:A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*\",r=new RegExp(\"^\"+i+\"$\");e.isExist=function(t){return void 0!==t},e.isEmptyObject=function(t){return 0===Object.keys(t).length},e.merge=function(t,e,i){if(e)for(var r=Object.keys(e),n=r.length,s=0;s<n;s++)t[r[s]]=\"strict\"===i?[e[r[s]]]:e[r[s]]},e.getValue=function(t){return e.isExist(t)?t:\"\"},e.isName=function(t){return!(null==r.exec(t))},e.getAllMatches=function(t,e){for(var i=[],r=e.exec(t);r;){var n=[];n.startIndex=e.lastIndex-r[0].length;for(var s=r.length,a=0;a<s;a++)n.push(r[a]);i.push(n),r=e.exec(t)}return i},e.nameRegexp=i},239:(t,e,i)=>{\"use strict\";var r=i(839),n={allowBooleanAttributes:!1,unpairedTags:[]};function s(t){return\" \"===t||\"\\t\"===t||\"\\n\"===t||\"\\r\"===t}function a(t,e){for(var i=e;e<t.length;e++)if(\"?\"!=t[e]&&\" \"!=t[e]);else{var r=t.substr(i,e-i);if(e>5&&\"xml\"===r)return f(\"InvalidXml\",\"XML declaration allowed only at the start of the document.\",g(t,e));if(\"?\"==t[e]&&\">\"==t[e+1]){e++;break}}return e}function o(t,e){if(t.length>e+5&&\"-\"===t[e+1]&&\"-\"===t[e+2]){for(e+=3;e<t.length;e++)if(\"-\"===t[e]&&\"-\"===t[e+1]&&\">\"===t[e+2]){e+=2;break}}else if(t.length>e+8&&\"D\"===t[e+1]&&\"O\"===t[e+2]&&\"C\"===t[e+3]&&\"T\"===t[e+4]&&\"Y\"===t[e+5]&&\"P\"===t[e+6]&&\"E\"===t[e+7]){var i=1;for(e+=8;e<t.length;e++)if(\"<\"===t[e])i++;else if(\">\"===t[e]&&0==--i)break}else if(t.length>e+9&&\"[\"===t[e+1]&&\"C\"===t[e+2]&&\"D\"===t[e+3]&&\"A\"===t[e+4]&&\"T\"===t[e+5]&&\"A\"===t[e+6]&&\"[\"===t[e+7])for(e+=8;e<t.length;e++)if(\"]\"===t[e]&&\"]\"===t[e+1]&&\">\"===t[e+2]){e+=2;break}return e}function u(t,e){for(var i=\"\",r=\"\",n=!1;e<t.length;e++){if('\"'===t[e]||\"'\"===t[e])\"\"===r?r=t[e]:r!==t[e]||(r=\"\");else if(\">\"===t[e]&&\"\"===r){n=!0;break}i+=t[e]}return\"\"===r&&{value:i,index:e,tagClosed:n}}e.validate=function(t,e){e=Object.assign({},n,e);var i,l=[],p=!1,c=!1;\"\\ufeff\"===t[0]&&(t=t.substr(1));for(var v=0;v<t.length;v++)if(\"<\"===t[v]&&\"?\"===t[v+1]){if((v=a(t,v+=2)).err)return v}else{if(\"<\"!==t[v]){if(s(t[v]))continue;return f(\"InvalidChar\",\"char '\"+t[v]+\"' is not expected.\",g(t,v))}var x=v;if(\"!\"===t[++v]){v=o(t,v);continue}var m=!1;\"/\"===t[v]&&(m=!0,v++);for(var N=\"\";v<t.length&&\">\"!==t[v]&&\" \"!==t[v]&&\"\\t\"!==t[v]&&\"\\n\"!==t[v]&&\"\\r\"!==t[v];v++)N+=t[v];if(\"/\"===(N=N.trim())[N.length-1]&&(N=N.substring(0,N.length-1),v--),i=N,!r.isName(i))return f(\"InvalidTag\",0===N.trim().length?\"Invalid space after '<'.\":\"Tag '\"+N+\"' is an invalid name.\",g(t,v));var b=u(t,v);if(!1===b)return f(\"InvalidAttr\",\"Attributes for '\"+N+\"' have open quote.\",g(t,v));var E=b.value;if(v=b.index,\"/\"===E[E.length-1]){var T=v-E.length,y=h(E=E.substring(0,E.length-1),e);if(!0!==y)return f(y.err.code,y.err.msg,g(t,T+y.err.line));p=!0}else if(m){if(!b.tagClosed)return f(\"InvalidTag\",\"Closing tag '\"+N+\"' doesn't have proper closing.\",g(t,v));if(E.trim().length>0)return f(\"InvalidTag\",\"Closing tag '\"+N+\"' can't have attributes or invalid starting.\",g(t,x));var A=l.pop();if(N!==A.tagName){var O=g(t,A.tagStartPos);return f(\"InvalidTag\",\"Expected closing tag '\"+A.tagName+\"' (opened in line \"+O.line+\", col \"+O.col+\") instead of closing tag '\"+N+\"'.\",g(t,x))}0==l.length&&(c=!0)}else{var P=h(E,e);if(!0!==P)return f(P.err.code,P.err.msg,g(t,v-E.length+P.err.line));if(!0===c)return f(\"InvalidXml\",\"Multiple possible root nodes found.\",g(t,v));-1!==e.unpairedTags.indexOf(N)||l.push({tagName:N,tagStartPos:x}),p=!0}for(v++;v<t.length;v++)if(\"<\"===t[v]){if(\"!\"===t[v+1]){v=o(t,++v);continue}if(\"?\"!==t[v+1])break;if((v=a(t,++v)).err)return v}else if(\"&\"===t[v]){var w=d(t,v);if(-1==w)return f(\"InvalidChar\",\"char '&' is not expected.\",g(t,v));v=w}else if(!0===c&&!s(t[v]))return f(\"InvalidXml\",\"Extra text at the end\",g(t,v));\"<\"===t[v]&&v--}return p?1==l.length?f(\"InvalidTag\",\"Unclosed tag '\"+l[0].tagName+\"'.\",g(t,l[0].tagStartPos)):!(l.length>0)||f(\"InvalidXml\",\"Invalid '\"+JSON.stringify(l.map((function(t){return t.tagName})),null,4).replace(/\\r?\\n/g,\"\")+\"' found.\",{line:1,col:1}):f(\"InvalidXml\",\"Start tag expected.\",1)};var l=new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\",\"g\");function h(t,e){for(var i=r.getAllMatches(t,l),n={},s=0;s<i.length;s++){if(0===i[s][1].length)return f(\"InvalidAttr\",\"Attribute '\"+i[s][2]+\"' has no space in starting.\",c(i[s]));if(void 0!==i[s][3]&&void 0===i[s][4])return f(\"InvalidAttr\",\"Attribute '\"+i[s][2]+\"' is without value.\",c(i[s]));if(void 0===i[s][3]&&!e.allowBooleanAttributes)return f(\"InvalidAttr\",\"boolean attribute '\"+i[s][2]+\"' is not allowed.\",c(i[s]));var a=i[s][2];if(!p(a))return f(\"InvalidAttr\",\"Attribute '\"+a+\"' is an invalid name.\",c(i[s]));if(n.hasOwnProperty(a))return f(\"InvalidAttr\",\"Attribute '\"+a+\"' is repeated.\",c(i[s]));n[a]=1}return!0}function d(t,e){if(\";\"===t[++e])return-1;if(\"#\"===t[e])return function(t,e){var i=/\\d/;for(\"x\"===t[e]&&(e++,i=/[\\da-fA-F]/);e<t.length;e++){if(\";\"===t[e])return e;if(!t[e].match(i))break}return-1}(t,++e);for(var i=0;e<t.length;e++,i++)if(!(t[e].match(/\\w/)&&i<20)){if(\";\"===t[e])break;return-1}return e}function f(t,e,i){return{err:{code:t,msg:e,line:i.line||i,col:i.col}}}function p(t){return r.isName(t)}function g(t,e){var i=t.substring(0,e).split(/\\r?\\n/);return{line:i.length,col:i[i.length-1].length+1}}function c(t){return t.startIndex+t[1].length}},784:(t,e,i)=>{\"use strict\";var r=i(687),n={attributeNamePrefix:\"@_\",attributesGroupName:!1,textNodeName:\"#text\",ignoreAttributes:!0,cdataPropName:!1,format:!1,indentBy:\"  \",suppressEmptyNode:!1,suppressUnpairedNode:!0,suppressBooleanAttributes:!0,tagValueProcessor:function(t,e){return e},attributeValueProcessor:function(t,e){return e},preserveOrder:!1,commentPropName:!1,unpairedTags:[],entities:[{regex:new RegExp(\"&\",\"g\"),val:\"&amp;\"},{regex:new RegExp(\">\",\"g\"),val:\"&gt;\"},{regex:new RegExp(\"<\",\"g\"),val:\"&lt;\"},{regex:new RegExp(\"'\",\"g\"),val:\"&apos;\"},{regex:new RegExp('\"',\"g\"),val:\"&quot;\"}],processEntities:!0,stopNodes:[]};function s(t){this.options=Object.assign({},n,t),this.options.ignoreAttributes||this.options.attributesGroupName?this.isAttribute=function(){return!1}:(this.attrPrefixLen=this.options.attributeNamePrefix.length,this.isAttribute=g),this.processTextOrObjNode=o,this.options.format?(this.indentate=p,this.tagEndChar=\">\\n\",this.newLine=\"\\n\"):(this.indentate=function(){return\"\"},this.tagEndChar=\">\",this.newLine=\"\"),this.options.suppressEmptyNode?(this.buildTextNode=f,this.buildObjNode=l):(this.buildTextNode=h,this.buildObjNode=u),this.buildTextValNode=h,this.buildObjectNode=u,this.replaceEntitiesValue=d,this.buildAttrPairStr=a}function a(t,e){return e=this.options.attributeValueProcessor(t,\"\"+e),e=this.replaceEntitiesValue(e),this.options.suppressBooleanAttributes&&\"true\"===e?\" \"+t:\" \"+t+'=\"'+e+'\"'}function o(t,e,i){var r=this.j2x(t,i+1);return void 0!==t[this.options.textNodeName]&&1===Object.keys(t).length?this.buildTextNode(t[this.options.textNodeName],e,r.attrStr,i):this.buildObjNode(r.val,e,r.attrStr,i)}function u(t,e,i,r){var n=\"</\"+e+this.tagEndChar,s=\"\";return\"?\"===e[0]&&(s=\"?\",n=\"\"),i&&-1===t.indexOf(\"<\")?this.indentate(r)+\"<\"+e+i+s+\">\"+t+n:!1!==this.options.commentPropName&&e===this.options.commentPropName&&0===s.length?this.indentate(r)+\"\\x3c!--\"+t+\"--\\x3e\"+this.newLine:this.indentate(r)+\"<\"+e+i+s+this.tagEndChar+t+this.indentate(r)+n}function l(t,e,i,r){return\"\"!==t?this.buildObjectNode(t,e,i,r):\"?\"===e[0]?this.indentate(r)+\"<\"+e+i+\"?\"+this.tagEndChar:this.indentate(r)+\"<\"+e+i+\"/\"+this.tagEndChar}function h(t,e,i,r){if(!1!==this.options.cdataPropName&&e===this.options.cdataPropName)return this.indentate(r)+\"<![CDATA[\"+t+\"]]>\"+this.newLine;if(!1!==this.options.commentPropName&&e===this.options.commentPropName)return this.indentate(r)+\"\\x3c!--\"+t+\"--\\x3e\"+this.newLine;var n=this.options.tagValueProcessor(e,t);return\"\"===(n=this.replaceEntitiesValue(n))&&-1!==this.options.unpairedTags.indexOf(e)?this.options.suppressUnpairedNode?this.indentate(r)+\"<\"+e+this.tagEndChar:this.indentate(r)+\"<\"+e+\"/\"+this.tagEndChar:this.indentate(r)+\"<\"+e+i+\">\"+n+\"</\"+e+this.tagEndChar}function d(t){if(t&&t.length>0&&this.options.processEntities)for(var e=0;e<this.options.entities.length;e++){var i=this.options.entities[e];t=t.replace(i.regex,i.val)}return t}function f(t,e,i,r){return\"\"===t&&-1!==this.options.unpairedTags.indexOf(e)?this.options.suppressUnpairedNode?this.indentate(r)+\"<\"+e+this.tagEndChar:this.indentate(r)+\"<\"+e+\"/\"+this.tagEndChar:\"\"!==t?this.buildTextValNode(t,e,i,r):\"?\"===e[0]?this.indentate(r)+\"<\"+e+i+\"?\"+this.tagEndChar:this.indentate(r)+\"<\"+e+i+\"/\"+this.tagEndChar}function p(t){return this.options.indentBy.repeat(t)}function g(t){return!!t.startsWith(this.options.attributeNamePrefix)&&t.substr(this.attrPrefixLen)}s.prototype.build=function(t){return this.options.preserveOrder?r(t,this.options):(Array.isArray(t)&&this.options.arrayNodeName&&this.options.arrayNodeName.length>1&&((e={})[this.options.arrayNodeName]=t,t=e),this.j2x(t,0).val);var e},s.prototype.j2x=function(t,e){var i=\"\",r=\"\";for(var n in t)if(void 0===t[n]);else if(null===t[n])\"?\"===n[0]?r+=this.indentate(e)+\"<\"+n+\"?\"+this.tagEndChar:r+=this.indentate(e)+\"<\"+n+\"/\"+this.tagEndChar;else if(t[n]instanceof Date)r+=this.buildTextNode(t[n],n,\"\",e);else if(\"object\"!=typeof t[n]){var s=this.isAttribute(n);if(s)i+=this.buildAttrPairStr(s,\"\"+t[n]);else if(n===this.options.textNodeName){var a=this.options.tagValueProcessor(n,\"\"+t[n]);r+=this.replaceEntitiesValue(a)}else r+=this.buildTextNode(t[n],n,\"\",e)}else if(Array.isArray(t[n]))for(var o=t[n].length,u=0;u<o;u++){var l=t[n][u];void 0===l||(null===l?\"?\"===n[0]?r+=this.indentate(e)+\"<\"+n+\"?\"+this.tagEndChar:r+=this.indentate(e)+\"<\"+n+\"/\"+this.tagEndChar:r+=\"object\"==typeof l?this.processTextOrObjNode(l,n,e):this.buildTextNode(l,n,\"\",e))}else if(this.options.attributesGroupName&&n===this.options.attributesGroupName)for(var h=Object.keys(t[n]),d=h.length,f=0;f<d;f++)i+=this.buildAttrPairStr(h[f],\"\"+t[n][h[f]]);else r+=this.processTextOrObjNode(t[n],n,e);return{attrStr:i,val:r}},t.exports=s},687:t=>{function e(t,a,o,u){for(var l=\"\",h=!1,d=0;d<t.length;d++){var f,p=t[d],g=i(p);if(f=0===o.length?g:o+\".\"+g,g!==a.textNodeName)if(g!==a.cdataPropName)if(g!==a.commentPropName)if(\"?\"!==g[0]){var c=u;\"\"!==c&&(c+=a.indentBy);var v=u+\"<\"+g+r(p[\":@\"],a),x=e(p[g],a,f,c);-1!==a.unpairedTags.indexOf(g)?a.suppressUnpairedNode?l+=v+\">\":l+=v+\"/>\":x&&0!==x.length||!a.suppressEmptyNode?x&&x.endsWith(\">\")?l+=v+\">\"+x+u+\"</\"+g+\">\":(l+=v+\">\",x&&\"\"!==u&&(x.includes(\"/>\")||x.includes(\"</\"))?l+=u+a.indentBy+x+u:l+=x,l+=\"</\"+g+\">\"):l+=v+\"/>\",h=!0}else{var m=r(p[\":@\"],a),N=\"?xml\"===g?\"\":u,b=p[g][0][a.textNodeName];l+=N+\"<\"+g+(b=0!==b.length?\" \"+b:\"\")+m+\"?>\",h=!0}else l+=u+\"\\x3c!--\"+p[g][0][a.textNodeName]+\"--\\x3e\",h=!0;else h&&(l+=u),l+=\"<![CDATA[\"+p[g][0][a.textNodeName]+\"]]>\",h=!1;else{var E=p[g];n(f,a)||(E=s(E=a.tagValueProcessor(g,E),a)),h&&(l+=u),l+=E,h=!1}}return l}function i(t){for(var e=Object.keys(t),i=0;i<e.length;i++){var r=e[i];if(\":@\"!==r)return r}}function r(t,e){var i=\"\";if(t&&!e.ignoreAttributes)for(var r in t){var n=e.attributeValueProcessor(r,t[r]);!0===(n=s(n,e))&&e.suppressBooleanAttributes?i+=\" \"+r.substr(e.attributeNamePrefix.length):i+=\" \"+r.substr(e.attributeNamePrefix.length)+'=\"'+n+'\"'}return i}function n(t,e){var i=(t=t.substr(0,t.length-e.textNodeName.length-1)).substr(t.lastIndexOf(\".\")+1);for(var r in e.stopNodes)if(e.stopNodes[r]===t||e.stopNodes[r]===\"*.\"+i)return!0;return!1}function s(t,e){if(t&&t.length>0&&e.processEntities)for(var i=0;i<e.entities.length;i++){var r=e.entities[i];t=t.replace(r.regex,r.val)}return t}t.exports=function(t,i){var r=\"\";return i.format&&i.indentBy.length>0&&(r=\"\\n\"),e(t,i,\"\",r)}},106:t=>{var e=RegExp(\"^\\\\s([a-zA-z0-0]+)[ \\t](['\\\"])([^&]+)\\\\2\");function i(t,i){var r=e.exec(t);r&&(i[r[1]]={regx:RegExp(\"&\"+r[1]+\";\",\"g\"),val:r[3]})}t.exports=function(t,e){var r={};if(\"O\"!==t[e+3]||\"C\"!==t[e+4]||\"T\"!==t[e+5]||\"Y\"!==t[e+6]||\"P\"!==t[e+7]||\"E\"!==t[e+8])throw new Error(\"Invalid Tag instead of DOCTYPE\");e+=9;for(var n=1,s=!1,a=!1,o=!1,u=\"\";e<t.length;e++)if(\"<\"===t[e]){if(s&&\"!\"===t[e+1]&&\"E\"===t[e+2]&&\"N\"===t[e+3]&&\"T\"===t[e+4]&&\"I\"===t[e+5]&&\"T\"===t[e+6]&&\"Y\"===t[e+7])e+=7,a=!0;else if(s&&\"!\"===t[e+1]&&\"E\"===t[e+2]&&\"L\"===t[e+3]&&\"E\"===t[e+4]&&\"M\"===t[e+5]&&\"E\"===t[e+6]&&\"N\"===t[e+7]&&\"T\"===t[e+8])e+=8;else if(s&&\"!\"===t[e+1]&&\"A\"===t[e+2]&&\"T\"===t[e+3]&&\"T\"===t[e+4]&&\"L\"===t[e+5]&&\"I\"===t[e+6]&&\"S\"===t[e+7]&&\"T\"===t[e+8])e+=8;else if(s&&\"!\"===t[e+1]&&\"N\"===t[e+2]&&\"O\"===t[e+3]&&\"T\"===t[e+4]&&\"A\"===t[e+5]&&\"T\"===t[e+6]&&\"I\"===t[e+7]&&\"O\"===t[e+8]&&\"N\"===t[e+9])e+=9;else{if(\"!\"!==t[e+1]||\"-\"!==t[e+2]||\"-\"!==t[e+3])throw new Error(\"Invalid DOCTYPE\");o=!0}n++,u=\"\"}else if(\">\"===t[e]){if(o){if(\"-\"!==t[e-1]||\"-\"!==t[e-2])throw new Error(\"Invalid XML comment in DOCTYPE\");o=!1}else a&&(i(u,r),a=!1);if(0==--n)break}else\"[\"===t[e]?s=!0:u+=t[e];if(0!==n)throw new Error(\"Unclosed DOCTYPE\");return{entities:r,i:e}}},348:(t,e)=>{var i={preserveOrder:!1,attributeNamePrefix:\"@_\",attributesGroupName:!1,textNodeName:\"#text\",ignoreAttributes:!0,removeNSPrefix:!1,allowBooleanAttributes:!1,parseTagValue:!0,parseAttributeValue:!1,trimValues:!0,cdataPropName:!1,numberParseOptions:{hex:!0,leadingZeros:!0},tagValueProcessor:function(t,e){return e},attributeValueProcessor:function(t,e){return e},stopNodes:[],alwaysCreateTextNode:!1,isArray:function(){return!1},commentPropName:!1,unpairedTags:[],processEntities:!0,htmlEntities:!1,ignoreDeclaration:!1,ignorePiTags:!1,transformTagName:!1,transformAttributeName:!1};e.buildOptions=function(t){return Object.assign({},i,t)},e.defaultOptions=i},498:(t,e,i)=>{\"use strict\";var r=i(839),n=i(876),s=i(106),a=i(807);function o(t){for(var e=Object.keys(t),i=0;i<e.length;i++){var r=e[i];this.lastEntities[r]={regex:new RegExp(\"&\"+r+\";\",\"g\"),val:t[r]}}}function u(t,e,i,r,n,s,a){if(void 0!==t&&(this.options.trimValues&&!r&&(t=t.trim()),t.length>0)){a||(t=this.replaceEntitiesValue(t));var o=this.options.tagValueProcessor(e,t,i,n,s);return null==o?t:typeof o!=typeof t||o!==t?o:this.options.trimValues||t.trim()===t?N(t,this.options.parseTagValue,this.options.numberParseOptions):t}}function l(t){if(this.options.removeNSPrefix){var e=t.split(\":\"),i=\"/\"===t.charAt(0)?\"/\":\"\";if(\"xmlns\"===e[0])return\"\";2===e.length&&(t=i+e[1])}return t}\"<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)\".replace(/NAME/g,r.nameRegexp);var h=new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])([\\\\s\\\\S]*?)\\\\3)?\",\"gm\");function d(t,e){if(!this.options.ignoreAttributes&&\"string\"==typeof t){for(var i=r.getAllMatches(t,h),n=i.length,s={},a=0;a<n;a++){var o=this.resolveNameSpace(i[a][1]),u=i[a][4],l=this.options.attributeNamePrefix+o;if(o.length)if(this.options.transformAttributeName&&(l=this.options.transformAttributeName(l)),void 0!==u){this.options.trimValues&&(u=u.trim()),u=this.replaceEntitiesValue(u);var d=this.options.attributeValueProcessor(o,u,e);s[l]=null==d?u:typeof d!=typeof u||d!==u?d:N(u,this.options.parseAttributeValue,this.options.numberParseOptions)}else this.options.allowBooleanAttributes&&(s[l]=!0)}if(!Object.keys(s).length)return;if(this.options.attributesGroupName){var f={};return f[this.options.attributesGroupName]=s,f}return s}}var f=function(t){t=t.replace(/\\r\\n?/g,\"\\n\");for(var e=new n(\"!xml\"),i=e,r=\"\",a=\"\",o=0;o<t.length;o++)if(\"<\"===t[o])if(\"/\"===t[o+1]){var u=v(t,\">\",o,\"Closing Tag is not closed.\"),l=t.substring(o+2,u).trim();if(this.options.removeNSPrefix){var h=l.indexOf(\":\");-1!==h&&(l=l.substr(h+1))}this.options.transformTagName&&(l=this.options.transformTagName(l)),i&&(r=this.saveTextToParentTag(r,i,a)),a=a.substr(0,a.lastIndexOf(\".\")),i=this.tagsNodeStack.pop(),r=\"\",o=u}else if(\"?\"===t[o+1]){var d=x(t,o,!1,\"?>\");if(!d)throw new Error(\"Pi Tag is not closed.\");if(r=this.saveTextToParentTag(r,i,a),this.options.ignoreDeclaration&&\"?xml\"===d.tagName||this.options.ignorePiTags);else{var f=new n(d.tagName);f.add(this.options.textNodeName,\"\"),d.tagName!==d.tagExp&&d.attrExpPresent&&(f[\":@\"]=this.buildAttributesMap(d.tagExp,a)),i.addChild(f)}o=d.closeIndex+1}else if(\"!--\"===t.substr(o+1,3)){var p=v(t,\"--\\x3e\",o+4,\"Comment is not closed.\");if(this.options.commentPropName){var g,c=t.substring(o+4,p-2);r=this.saveTextToParentTag(r,i,a),i.add(this.options.commentPropName,[(g={},g[this.options.textNodeName]=c,g)])}o=p}else if(\"!D\"===t.substr(o+1,2)){var m=s(t,o);this.docTypeEntities=m.entities,o=m.i}else if(\"![\"===t.substr(o+1,2)){var N=v(t,\"]]>\",o,\"CDATA is not closed.\")-2,b=t.substring(o+9,N);if(r=this.saveTextToParentTag(r,i,a),this.options.cdataPropName){var E;i.add(this.options.cdataPropName,[(E={},E[this.options.textNodeName]=b,E)])}else{var T=this.parseTextData(b,i.tagname,a,!0,!1,!0);null==T&&(T=\"\"),i.add(this.options.textNodeName,T)}o=N+2}else{var y=x(t,o,this.options.removeNSPrefix),A=y.tagName,O=y.tagExp,P=y.attrExpPresent,w=y.closeIndex;this.options.transformTagName&&(A=this.options.transformTagName(A)),i&&r&&\"!xml\"!==i.tagname&&(r=this.saveTextToParentTag(r,i,a,!1)),A!==e.tagname&&(a+=a?\".\"+A:A);var C=i;if(C&&-1!==this.options.unpairedTags.indexOf(C.tagname)&&(i=this.tagsNodeStack.pop()),this.isItStopNode(this.options.stopNodes,a,A)){var F=\"\";if(O.length>0&&O.lastIndexOf(\"/\")===O.length-1)o=y.closeIndex;else if(-1!==this.options.unpairedTags.indexOf(A))o=y.closeIndex;else{var I=this.readStopNodeData(t,A,w+1);if(!I)throw new Error(\"Unexpected end of \"+A);o=I.i,F=I.tagContent}var D=new n(A);A!==O&&P&&(D[\":@\"]=this.buildAttributesMap(O,a)),F&&(F=this.parseTextData(F,A,a,!0,P,!0,!0)),a=a.substr(0,a.lastIndexOf(\".\")),D.add(this.options.textNodeName,F),i.addChild(D)}else{if(O.length>0&&O.lastIndexOf(\"/\")===O.length-1){O=\"/\"===A[A.length-1]?A=A.substr(0,A.length-1):O.substr(0,O.length-1),this.options.transformTagName&&(A=this.options.transformTagName(A));var S=new n(A);A!==O&&P&&(S[\":@\"]=this.buildAttributesMap(O,a)),a=a.substr(0,a.lastIndexOf(\".\")),i.addChild(S)}else{var j=new n(A);this.tagsNodeStack.push(i),A!==O&&P&&(j[\":@\"]=this.buildAttributesMap(O,a)),i.addChild(j),i=j}r=\"\",o=w}}else r+=t[o];return e.child},p=function(t){if(this.options.processEntities){for(var e in this.docTypeEntities){var i=this.docTypeEntities[e];t=t.replace(i.regx,i.val)}for(var r in this.lastEntities){var n=this.lastEntities[r];t=t.replace(n.regex,n.val)}if(this.options.htmlEntities)for(var s in this.htmlEntities){var a=this.htmlEntities[s];t=t.replace(a.regex,a.val)}t=t.replace(this.ampEntity.regex,this.ampEntity.val)}return t};function g(t,e,i,r){return t&&(void 0===r&&(r=0===Object.keys(e.child).length),void 0!==(t=this.parseTextData(t,e.tagname,i,!1,!!e[\":@\"]&&0!==Object.keys(e[\":@\"]).length,r))&&\"\"!==t&&e.add(this.options.textNodeName,t),t=\"\"),t}function c(t,e,i){var r=\"*.\"+i;for(var n in t){var s=t[n];if(r===s||e===s)return!0}return!1}function v(t,e,i,r){var n=t.indexOf(e,i);if(-1===n)throw new Error(r);return n+e.length-1}function x(t,e,i,r){void 0===r&&(r=\">\");var n=function(t,e,i){var r;void 0===i&&(i=\">\");for(var n=\"\",s=e;s<t.length;s++){var a=t[s];if(r)a===r&&(r=\"\");else if('\"'===a||\"'\"===a)r=a;else if(a===i[0]){if(!i[1])return{data:n,index:s};if(t[s+1]===i[1])return{data:n,index:s}}else\"\\t\"===a&&(a=\" \");n+=a}}(t,e+1,r);if(n){var s=n.data,a=n.index,o=s.search(/\\s/),u=s,l=!0;if(-1!==o&&(u=s.substr(0,o).replace(/\\s\\s*$/,\"\"),s=s.substr(o+1)),i){var h=u.indexOf(\":\");-1!==h&&(l=(u=u.substr(h+1))!==n.data.substr(h+1))}return{tagName:u,tagExp:s,closeIndex:a,attrExpPresent:l}}}function m(t,e,i){for(var r=i,n=1;i<t.length;i++)if(\"<\"===t[i])if(\"/\"===t[i+1]){var s=v(t,\">\",i,e+\" is not closed\");if(t.substring(i+2,s).trim()===e&&0==--n)return{tagContent:t.substring(r,i),i:s};i=s}else if(\"?\"===t[i+1])i=v(t,\"?>\",i+1,\"StopNode is not closed.\");else if(\"!--\"===t.substr(i+1,3))i=v(t,\"--\\x3e\",i+3,\"StopNode is not closed.\");else if(\"![\"===t.substr(i+1,2))i=v(t,\"]]>\",i,\"StopNode is not closed.\")-2;else{var a=x(t,i,\">\");a&&((a&&a.tagName)===e&&\"/\"!==a.tagExp[a.tagExp.length-1]&&n++,i=a.closeIndex)}}function N(t,e,i){if(e&&\"string\"==typeof t){var n=t.trim();return\"true\"===n||\"false\"!==n&&a(t,i)}return r.isExist(t)?t:\"\"}t.exports=function(t){this.options=t,this.currentNode=null,this.tagsNodeStack=[],this.docTypeEntities={},this.lastEntities={apos:{regex:/&(apos|#39|#x27);/g,val:\"'\"},gt:{regex:/&(gt|#62|#x3E);/g,val:\">\"},lt:{regex:/&(lt|#60|#x3C);/g,val:\"<\"},quot:{regex:/&(quot|#34|#x22);/g,val:'\"'}},this.ampEntity={regex:/&(amp|#38|#x26);/g,val:\"&\"},this.htmlEntities={space:{regex:/&(nbsp|#160);/g,val:\" \"},cent:{regex:/&(cent|#162);/g,val:\"\u00a2\"},pound:{regex:/&(pound|#163);/g,val:\"\u00a3\"},yen:{regex:/&(yen|#165);/g,val:\"\u00a5\"},euro:{regex:/&(euro|#8364);/g,val:\"\u20ac\"},copyright:{regex:/&(copy|#169);/g,val:\"\u00a9\"},reg:{regex:/&(reg|#174);/g,val:\"\u00ae\"},inr:{regex:/&(inr|#8377);/g,val:\"\u20b9\"}},this.addExternalEntities=o,this.parseXml=f,this.parseTextData=u,this.resolveNameSpace=l,this.buildAttributesMap=d,this.isItStopNode=c,this.replaceEntitiesValue=p,this.readStopNodeData=m,this.saveTextToParentTag=g}},870:(t,e,i)=>{var r=i(348).buildOptions,n=i(498),s=i(400).prettify,a=i(239),o=function(){function t(t){this.externalEntities={},this.options=r(t)}var e=t.prototype;return e.parse=function(t,e){if(\"string\"==typeof t);else{if(!t.toString)throw new Error(\"XML data is accepted in String or Bytes[] form.\");t=t.toString()}if(e){!0===e&&(e={});var i=a.validate(t,e);if(!0!==i)throw Error(i.err.msg+\":\"+i.err.line+\":\"+i.err.col)}var r=new n(this.options);r.addExternalEntities(this.externalEntities);var o=r.parseXml(t);return this.options.preserveOrder||void 0===o?o:s(o,this.options)},e.addEntity=function(t,e){if(-1!==e.indexOf(\"&\"))throw new Error(\"Entity value can't have '&'\");if(-1!==t.indexOf(\"&\")||-1!==t.indexOf(\";\"))throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\");if(\"&\"===e)throw new Error(\"An entity with value '&' is not permitted\");this.externalEntities[t]=e},t}();t.exports=o},400:(t,e)=>{\"use strict\";function i(t,e,a){for(var o,u={},l=0;l<t.length;l++){var h,d=t[l],f=r(d);if(h=void 0===a?f:a+\".\"+f,f===e.textNodeName)void 0===o?o=d[f]:o+=\"\"+d[f];else{if(void 0===f)continue;if(d[f]){var p=i(d[f],e,h),g=s(p,e);d[\":@\"]?n(p,d[\":@\"],h,e):1!==Object.keys(p).length||void 0===p[e.textNodeName]||e.alwaysCreateTextNode?0===Object.keys(p).length&&(e.alwaysCreateTextNode?p[e.textNodeName]=\"\":p=\"\"):p=p[e.textNodeName],void 0!==u[f]&&u.hasOwnProperty(f)?(Array.isArray(u[f])||(u[f]=[u[f]]),u[f].push(p)):e.isArray(f,h,g)?u[f]=[p]:u[f]=p}}}return\"string\"==typeof o?o.length>0&&(u[e.textNodeName]=o):void 0!==o&&(u[e.textNodeName]=o),u}function r(t){for(var e=Object.keys(t),i=0;i<e.length;i++){var r=e[i];if(\":@\"!==r)return r}}function n(t,e,i,r){if(e)for(var n=Object.keys(e),s=n.length,a=0;a<s;a++){var o=n[a];r.isArray(o,i+\".\"+o,!0,!0)?t[o]=[e[o]]:t[o]=e[o]}}function s(t,e){var i=Object.keys(t).length;return!!(0===i||1===i&&t[e.textNodeName])}e.prettify=function(t,e){return i(t,e)}},876:t=>{\"use strict\";var e=function(){function t(t){this.tagname=t,this.child=[],this[\":@\"]={}}var e=t.prototype;return e.add=function(t,e){var i;this.child.push(((i={})[t]=e,i))},e.addChild=function(t){var e,i;t[\":@\"]&&Object.keys(t[\":@\"]).length>0?this.child.push(((e={})[t.tagname]=t.child,e[\":@\"]=t[\":@\"],e)):this.child.push(((i={})[t.tagname]=t.child,i))},t}();t.exports=e}},e={},i=function i(r){var n=e[r];if(void 0!==n)return n.exports;var s=e[r]={exports:{}};return t[r](s,s.exports,i),s.exports}(316);fxp=i})();",
          "",
          "---------------"
        ],
        "lib/fxp.min.js.map||lib/fxp.min.js.map": [
          "File: lib/fxp.min.js.map -> lib/fxp.min.js.map",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: {\"version\":3,\"file\":\"./lib/fxp.min.js\",\"mappings\":\"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\",\"sources\":[\"webpack://fxp/./node_modules/strnum/strnum.js\",\"webpack://fxp/./src/fxp.js\",\"webpack://fxp/./src/util.js\",\"webpack://fxp/./src/validator.js\",\"webpack://fxp/./src/xmlbuilder/json2xml.js\",\"webpack://fxp/./src/xmlbuilder/orderedJs2Xml.js\",\"webpack://fxp/./src/xmlparser/DocTypeReader.js\",\"webpack://fxp/./src/xmlparser/OptionsBuilder.js\",\"webpack://fxp/./src/xmlparser/OrderedObjParser.js\",\"webpack://fxp/./src/xmlparser/XMLParser.js\",\"webpack://fxp/./src/xmlparser/node2json.js\",\"webpack://fxp/./src/xmlparser/xmlNode.js\",\"webpack://fxp/webpack/bootstrap\",\"webpack://fxp/webpack/startup\"],\"sourcesContent\":[\"const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\\nconst numRegex = /^([\\\\-\\\\+])?(0*)(\\\\.[0-9]+([eE]\\\\-?[0-9]+)?|[0-9]+(\\\\.[0-9]+([eE]\\\\-?[0-9]+)?)?)$/;\\n// const octRegex = /0x[a-z0-9]+/;\\n// const binRegex = /0x[a-z0-9]+/;\\n\\n\\n//polyfill\\nif (!Number.parseInt && window.parseInt) {\\n    Number.parseInt = window.parseInt;\\n}\\nif (!Number.parseFloat && window.parseFloat) {\\n    Number.parseFloat = window.parseFloat;\\n}\\n\\n  \\nconst consider = {\\n    hex :  true,\\n    leadingZeros: true,\\n    decimalPoint: \\\"\\\\.\\\",\\n    eNotation: true\\n    //skipLike: /regex/\\n};\\n\\nfunction toNumber(str, options = {}){\\n    // const options = Object.assign({}, consider);\\n    // if(opt.leadingZeros === false){\\n    //     options.leadingZeros = false;\\n    // }else if(opt.hex === false){\\n    //     options.hex = false;\\n    // }\\n\\n    options = Object.assign({}, consider, options );\\n    if(!str || typeof str !== \\\"string\\\" ) return str;\\n    \\n    let trimmedStr  = str.trim();\\n    // if(trimmedStr === \\\"0.0\\\") return 0;\\n    // else if(trimmedStr === \\\"+0.0\\\") return 0;\\n    // else if(trimmedStr === \\\"-0.0\\\") return -0;\\n\\n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\\n    else if (options.hex && hexRegex.test(trimmedStr)) {\\n        return Number.parseInt(trimmedStr, 16);\\n    // } else if (options.parseOct && octRegex.test(str)) {\\n    //     return Number.parseInt(val, 8);\\n    // }else if (options.parseBin && binRegex.test(str)) {\\n    //     return Number.parseInt(val, 2);\\n    }else{\\n        //separate negative sign, leading zeros, and rest number\\n        const match = numRegex.exec(trimmedStr);\\n        if(match){\\n            const sign = match[1];\\n            const leadingZeros = match[2];\\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\\n            //trim ending zeros for floating number\\n            \\n            const eNotation = match[4] || match[6];\\n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \\\".\\\") return str; //-0123\\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \\\".\\\") return str; //0123\\n            else{//no leading zeros or leading zeros are allowed\\n                const num = Number(trimmedStr);\\n                const numStr = \\\"\\\" + num;\\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\\n                    if(options.eNotation) return num;\\n                    else return str;\\n                }else if(eNotation){ //given number has enotation\\n                    if(options.eNotation) return num;\\n                    else return str;\\n                }else if(trimmedStr.indexOf(\\\".\\\") !== -1){ //floating number\\n                    // const decimalPart = match[5].substr(1);\\n                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf(\\\".\\\"));\\n\\n                    \\n                    // const p = numStr.indexOf(\\\".\\\");\\n                    // const givenIntPart = numStr.substr(0,p);\\n                    // const givenDecPart = numStr.substr(p+1);\\n                    if(numStr === \\\"0\\\" && (numTrimmedByZeros === \\\"\\\") ) return num; //0.0\\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\\n                    else if( sign && numStr === \\\"-\\\"+numTrimmedByZeros) return num;\\n                    else return str;\\n                }\\n                \\n                if(leadingZeros){\\n                    // if(numTrimmedByZeros === numStr){\\n                    //     if(options.leadingZeros) return num;\\n                    //     else return str;\\n                    // }else return str;\\n                    if(numTrimmedByZeros === numStr) return num;\\n                    else if(sign+numTrimmedByZeros === numStr) return num;\\n                    else return str;\\n                }\\n\\n                if(trimmedStr === numStr) return num;\\n                else if(trimmedStr === sign+numStr) return num;\\n                // else{\\n                //     //number with +/- sign\\n                //     trimmedStr.test(/[-+][0-9]);\\n\\n                // }\\n                return str;\\n            }\\n            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;\\n            \\n        }else{ //non-numeric string\\n            return str;\\n        }\\n    }\\n}\\n\\n/**\\n * \\n * @param {string} numStr without leading zeros\\n * @returns \\n */\\nfunction trimZeros(numStr){\\n    if(numStr && numStr.indexOf(\\\".\\\") !== -1){//float\\n        numStr = numStr.replace(/0+$/, \\\"\\\"); //remove ending zeros\\n        if(numStr === \\\".\\\")  numStr = \\\"0\\\";\\n        else if(numStr[0] === \\\".\\\")  numStr = \\\"0\\\"+numStr;\\n        else if(numStr[numStr.length-1] === \\\".\\\")  numStr = numStr.substr(0,numStr.length-1);\\n        return numStr;\\n    }\\n    return numStr;\\n}\\nmodule.exports = toNumber\\n\",\"'use strict';\\n\\nconst validator = require('./validator');\\nconst XMLParser = require('./xmlparser/XMLParser');\\nconst XMLBuilder = require('./xmlbuilder/json2xml');\\n\\nmodule.exports = {\\n  XMLParser: XMLParser,\\n  XMLValidator: validator,\\n  XMLBuilder: XMLBuilder\\n}\",\"'use strict';\\n\\nconst nameStartChar = ':A-Za-z_\\\\\\\\u00C0-\\\\\\\\u00D6\\\\\\\\u00D8-\\\\\\\\u00F6\\\\\\\\u00F8-\\\\\\\\u02FF\\\\\\\\u0370-\\\\\\\\u037D\\\\\\\\u037F-\\\\\\\\u1FFF\\\\\\\\u200C-\\\\\\\\u200D\\\\\\\\u2070-\\\\\\\\u218F\\\\\\\\u2C00-\\\\\\\\u2FEF\\\\\\\\u3001-\\\\\\\\uD7FF\\\\\\\\uF900-\\\\\\\\uFDCF\\\\\\\\uFDF0-\\\\\\\\uFFFD';\\nconst nameChar = nameStartChar + '\\\\\\\\-.\\\\\\\\d\\\\\\\\u00B7\\\\\\\\u0300-\\\\\\\\u036F\\\\\\\\u203F-\\\\\\\\u2040';\\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\\nconst regexName = new RegExp('^' + nameRegexp + '$');\\n\\nconst getAllMatches = function(string, regex) {\\n  const matches = [];\\n  let match = regex.exec(string);\\n  while (match) {\\n    const allmatches = [];\\n    allmatches.startIndex = regex.lastIndex - match[0].length;\\n    const len = match.length;\\n    for (let index = 0; index < len; index++) {\\n      allmatches.push(match[index]);\\n    }\\n    matches.push(allmatches);\\n    match = regex.exec(string);\\n  }\\n  return matches;\\n};\\n\\nconst isName = function(string) {\\n  const match = regexName.exec(string);\\n  return !(match === null || typeof match === 'undefined');\\n};\\n\\nexports.isExist = function(v) {\\n  return typeof v !== 'undefined';\\n};\\n\\nexports.isEmptyObject = function(obj) {\\n  return Object.keys(obj).length === 0;\\n};\\n\\n/**\\n * Copy all the properties of a into b.\\n * @param {*} target\\n * @param {*} a\\n */\\nexports.merge = function(target, a, arrayMode) {\\n  if (a) {\\n    const keys = Object.keys(a); // will return an array of own properties\\n    const len = keys.length; //don't make it inline\\n    for (let i = 0; i < len; i++) {\\n      if (arrayMode === 'strict') {\\n        target[keys[i]] = [ a[keys[i]] ];\\n      } else {\\n        target[keys[i]] = a[keys[i]];\\n      }\\n    }\\n  }\\n};\\n/* exports.merge =function (b,a){\\n  return Object.assign(b,a);\\n} */\\n\\nexports.getValue = function(v) {\\n  if (exports.isExist(v)) {\\n    return v;\\n  } else {\\n    return '';\\n  }\\n};\\n\\n// const fakeCall = function(a) {return a;};\\n// const fakeCallNoReturn = function() {};\\n\\nexports.isName = isName;\\nexports.getAllMatches = getAllMatches;\\nexports.nameRegexp = nameRegexp;\\n\",\"'use strict';\\n\\nconst util = require('./util');\\n\\nconst defaultOptions = {\\n  allowBooleanAttributes: false, //A tag can have attributes without any value\\n  unpairedTags: []\\n};\\n\\n//const tagsPattern = new RegExp(\\\"<\\\\\\\\/?([\\\\\\\\w:\\\\\\\\-_\\\\.]+)\\\\\\\\s*\\\\/?>\\\",\\\"g\\\");\\nexports.validate = function (xmlData, options) {\\n  options = Object.assign({}, defaultOptions, options);\\n\\n  //xmlData = xmlData.replace(/(\\\\r\\\\n|\\\\n|\\\\r)/gm,\\\"\\\");//make it single line\\n  //xmlData = xmlData.replace(/(^\\\\s*<\\\\?xml.*?\\\\?>)/g,\\\"\\\");//Remove XML starting tag\\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\\\s\\\\w\\\\\\\"\\\\.\\\\/\\\\-\\\\:]+(\\\\[.*\\\\])*\\\\s*>)/g,\\\"\\\");//Remove DOCTYPE\\n  const tags = [];\\n  let tagFound = false;\\n\\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\\n  let reachedRoot = false;\\n\\n  if (xmlData[0] === '\\\\ufeff') {\\n    // check for byte order mark (BOM)\\n    xmlData = xmlData.substr(1);\\n  }\\n  \\n  for (let i = 0; i < xmlData.length; i++) {\\n\\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\\n      i+=2;\\n      i = readPI(xmlData,i);\\n      if (i.err) return i;\\n    }else if (xmlData[i] === '<') {\\n      //starting of tag\\n      //read until you reach to '>' avoiding any '>' in attribute value\\n      let tagStartPos = i;\\n      i++;\\n      \\n      if (xmlData[i] === '!') {\\n        i = readCommentAndCDATA(xmlData, i);\\n        continue;\\n      } else {\\n        let closingTag = false;\\n        if (xmlData[i] === '/') {\\n          //closing tag\\n          closingTag = true;\\n          i++;\\n        }\\n        //read tagname\\n        let tagName = '';\\n        for (; i < xmlData.length &&\\n          xmlData[i] !== '>' &&\\n          xmlData[i] !== ' ' &&\\n          xmlData[i] !== '\\\\t' &&\\n          xmlData[i] !== '\\\\n' &&\\n          xmlData[i] !== '\\\\r'; i++\\n        ) {\\n          tagName += xmlData[i];\\n        }\\n        tagName = tagName.trim();\\n        //console.log(tagName);\\n\\n        if (tagName[tagName.length - 1] === '/') {\\n          //self closing tag without attributes\\n          tagName = tagName.substring(0, tagName.length - 1);\\n          //continue;\\n          i--;\\n        }\\n        if (!validateTagName(tagName)) {\\n          let msg;\\n          if (tagName.trim().length === 0) {\\n            msg = \\\"Invalid space after '<'.\\\";\\n          } else {\\n            msg = \\\"Tag '\\\"+tagName+\\\"' is an invalid name.\\\";\\n          }\\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\\n        }\\n\\n        const result = readAttributeStr(xmlData, i);\\n        if (result === false) {\\n          return getErrorObject('InvalidAttr', \\\"Attributes for '\\\"+tagName+\\\"' have open quote.\\\", getLineNumberForPosition(xmlData, i));\\n        }\\n        let attrStr = result.value;\\n        i = result.index;\\n\\n        if (attrStr[attrStr.length - 1] === '/') {\\n          //self closing tag\\n          const attrStrStart = i - attrStr.length;\\n          attrStr = attrStr.substring(0, attrStr.length - 1);\\n          const isValid = validateAttributeString(attrStr, options);\\n          if (isValid === true) {\\n            tagFound = true;\\n            //continue; //text may presents after self closing tag\\n          } else {\\n            //the result from the nested function returns the position of the error within the attribute\\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\\n          }\\n        } else if (closingTag) {\\n          if (!result.tagClosed) {\\n            return getErrorObject('InvalidTag', \\\"Closing tag '\\\"+tagName+\\\"' doesn't have proper closing.\\\", getLineNumberForPosition(xmlData, i));\\n          } else if (attrStr.trim().length > 0) {\\n            return getErrorObject('InvalidTag', \\\"Closing tag '\\\"+tagName+\\\"' can't have attributes or invalid starting.\\\", getLineNumberForPosition(xmlData, tagStartPos));\\n          } else {\\n            const otg = tags.pop();\\n            if (tagName !== otg.tagName) {\\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\\n              return getErrorObject('InvalidTag',\\n                \\\"Expected closing tag '\\\"+otg.tagName+\\\"' (opened in line \\\"+openPos.line+\\\", col \\\"+openPos.col+\\\") instead of closing tag '\\\"+tagName+\\\"'.\\\",\\n                getLineNumberForPosition(xmlData, tagStartPos));\\n            }\\n\\n            //when there are no more tags, we reached the root level.\\n            if (tags.length == 0) {\\n              reachedRoot = true;\\n            }\\n          }\\n        } else {\\n          const isValid = validateAttributeString(attrStr, options);\\n          if (isValid !== true) {\\n            //the result from the nested function returns the position of the error within the attribute\\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\\n          }\\n\\n          //if the root level has been reached before ...\\n          if (reachedRoot === true) {\\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\\n          } else if(options.unpairedTags.indexOf(tagName) !== -1){\\n            //don't push into stack\\n          } else {\\n            tags.push({tagName, tagStartPos});\\n          }\\n          tagFound = true;\\n        }\\n\\n        //skip tag text value\\n        //It may include comments and CDATA value\\n        for (i++; i < xmlData.length; i++) {\\n          if (xmlData[i] === '<') {\\n            if (xmlData[i + 1] === '!') {\\n              //comment or CADATA\\n              i++;\\n              i = readCommentAndCDATA(xmlData, i);\\n              continue;\\n            } else if (xmlData[i+1] === '?') {\\n              i = readPI(xmlData, ++i);\\n              if (i.err) return i;\\n            } else{\\n              break;\\n            }\\n          } else if (xmlData[i] === '&') {\\n            const afterAmp = validateAmpersand(xmlData, i);\\n            if (afterAmp == -1)\\n              return getErrorObject('InvalidChar', \\\"char '&' is not expected.\\\", getLineNumberForPosition(xmlData, i));\\n            i = afterAmp;\\n          }else{\\n            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\\n              return getErrorObject('InvalidXml', \\\"Extra text at the end\\\", getLineNumberForPosition(xmlData, i));\\n            }\\n          }\\n        } //end of reading tag text value\\n        if (xmlData[i] === '<') {\\n          i--;\\n        }\\n      }\\n    } else {\\n      if ( isWhiteSpace(xmlData[i])) {\\n        continue;\\n      }\\n      return getErrorObject('InvalidChar', \\\"char '\\\"+xmlData[i]+\\\"' is not expected.\\\", getLineNumberForPosition(xmlData, i));\\n    }\\n  }\\n\\n  if (!tagFound) {\\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\\n  }else if (tags.length == 1) {\\n      return getErrorObject('InvalidTag', \\\"Unclosed tag '\\\"+tags[0].tagName+\\\"'.\\\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\\n  }else if (tags.length > 0) {\\n      return getErrorObject('InvalidXml', \\\"Invalid '\\\"+\\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\\\r?\\\\n/g, '')+\\n          \\\"' found.\\\", {line: 1, col: 1});\\n  }\\n\\n  return true;\\n};\\n\\nfunction isWhiteSpace(char){\\n  return char === ' ' || char === '\\\\t' || char === '\\\\n'  || char === '\\\\r';\\n}\\n/**\\n * Read Processing insstructions and skip\\n * @param {*} xmlData\\n * @param {*} i\\n */\\nfunction readPI(xmlData, i) {\\n  const start = i;\\n  for (; i < xmlData.length; i++) {\\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\\n      //tagname\\n      const tagname = xmlData.substr(start, i - start);\\n      if (i > 5 && tagname === 'xml') {\\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\\n        //check if valid attribut string\\n        i++;\\n        break;\\n      } else {\\n        continue;\\n      }\\n    }\\n  }\\n  return i;\\n}\\n\\nfunction readCommentAndCDATA(xmlData, i) {\\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\\n    //comment\\n    for (i += 3; i < xmlData.length; i++) {\\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\\n        i += 2;\\n        break;\\n      }\\n    }\\n  } else if (\\n    xmlData.length > i + 8 &&\\n    xmlData[i + 1] === 'D' &&\\n    xmlData[i + 2] === 'O' &&\\n    xmlData[i + 3] === 'C' &&\\n    xmlData[i + 4] === 'T' &&\\n    xmlData[i + 5] === 'Y' &&\\n    xmlData[i + 6] === 'P' &&\\n    xmlData[i + 7] === 'E'\\n  ) {\\n    let angleBracketsCount = 1;\\n    for (i += 8; i < xmlData.length; i++) {\\n      if (xmlData[i] === '<') {\\n        angleBracketsCount++;\\n      } else if (xmlData[i] === '>') {\\n        angleBracketsCount--;\\n        if (angleBracketsCount === 0) {\\n          break;\\n        }\\n      }\\n    }\\n  } else if (\\n    xmlData.length > i + 9 &&\\n    xmlData[i + 1] === '[' &&\\n    xmlData[i + 2] === 'C' &&\\n    xmlData[i + 3] === 'D' &&\\n    xmlData[i + 4] === 'A' &&\\n    xmlData[i + 5] === 'T' &&\\n    xmlData[i + 6] === 'A' &&\\n    xmlData[i + 7] === '['\\n  ) {\\n    for (i += 8; i < xmlData.length; i++) {\\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\\n        i += 2;\\n        break;\\n      }\\n    }\\n  }\\n\\n  return i;\\n}\\n\\nconst doubleQuote = '\\\"';\\nconst singleQuote = \\\"'\\\";\\n\\n/**\\n * Keep reading xmlData until '<' is found outside the attribute value.\\n * @param {string} xmlData\\n * @param {number} i\\n */\\nfunction readAttributeStr(xmlData, i) {\\n  let attrStr = '';\\n  let startChar = '';\\n  let tagClosed = false;\\n  for (; i < xmlData.length; i++) {\\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\\n      if (startChar === '') {\\n        startChar = xmlData[i];\\n      } else if (startChar !== xmlData[i]) {\\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\\n      } else {\\n        startChar = '';\\n      }\\n    } else if (xmlData[i] === '>') {\\n      if (startChar === '') {\\n        tagClosed = true;\\n        break;\\n      }\\n    }\\n    attrStr += xmlData[i];\\n  }\\n  if (startChar !== '') {\\n    return false;\\n  }\\n\\n  return {\\n    value: attrStr,\\n    index: i,\\n    tagClosed: tagClosed\\n  };\\n}\\n\\n/**\\n * Select all the attributes whether valid or invalid.\\n */\\nconst validAttrStrRegxp = new RegExp('(\\\\\\\\s*)([^\\\\\\\\s=]+)(\\\\\\\\s*=)?(\\\\\\\\s*([\\\\'\\\"])(([\\\\\\\\s\\\\\\\\S])*?)\\\\\\\\5)?', 'g');\\n\\n//attr, =\\\"sd\\\", a=\\\"amit's\\\", a=\\\"sd\\\"b=\\\"saf\\\", ab  cd=\\\"\\\"\\n\\nfunction validateAttributeString(attrStr, options) {\\n  //console.log(\\\"start:\\\"+attrStr+\\\":end\\\");\\n\\n  //if(attrStr.trim().length === 0) return true; //empty string\\n\\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\\n  const attrNames = {};\\n\\n  for (let i = 0; i < matches.length; i++) {\\n    if (matches[i][1].length === 0) {\\n      //nospace before attribute name: a=\\\"sd\\\"b=\\\"saf\\\"\\n      return getErrorObject('InvalidAttr', \\\"Attribute '\\\"+matches[i][2]+\\\"' has no space in starting.\\\", getPositionFromMatch(matches[i]))\\n    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\\n      return getErrorObject('InvalidAttr', \\\"Attribute '\\\"+matches[i][2]+\\\"' is without value.\\\", getPositionFromMatch(matches[i]));\\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\\n      //independent attribute: ab\\n      return getErrorObject('InvalidAttr', \\\"boolean attribute '\\\"+matches[i][2]+\\\"' is not allowed.\\\", getPositionFromMatch(matches[i]));\\n    }\\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\\n                    return { err: { code:\\\"InvalidAttr\\\",msg:\\\"attribute \\\" + matches[i][2] + \\\" has no value assigned.\\\"}};\\n                } */\\n    const attrName = matches[i][2];\\n    if (!validateAttrName(attrName)) {\\n      return getErrorObject('InvalidAttr', \\\"Attribute '\\\"+attrName+\\\"' is an invalid name.\\\", getPositionFromMatch(matches[i]));\\n    }\\n    if (!attrNames.hasOwnProperty(attrName)) {\\n      //check for duplicate attribute.\\n      attrNames[attrName] = 1;\\n    } else {\\n      return getErrorObject('InvalidAttr', \\\"Attribute '\\\"+attrName+\\\"' is repeated.\\\", getPositionFromMatch(matches[i]));\\n    }\\n  }\\n\\n  return true;\\n}\\n\\nfunction validateNumberAmpersand(xmlData, i) {\\n  let re = /\\\\d/;\\n  if (xmlData[i] === 'x') {\\n    i++;\\n    re = /[\\\\da-fA-F]/;\\n  }\\n  for (; i < xmlData.length; i++) {\\n    if (xmlData[i] === ';')\\n      return i;\\n    if (!xmlData[i].match(re))\\n      break;\\n  }\\n  return -1;\\n}\\n\\nfunction validateAmpersand(xmlData, i) {\\n  // https://www.w3.org/TR/xml/#dt-charref\\n  i++;\\n  if (xmlData[i] === ';')\\n    return -1;\\n  if (xmlData[i] === '#') {\\n    i++;\\n    return validateNumberAmpersand(xmlData, i);\\n  }\\n  let count = 0;\\n  for (; i < xmlData.length; i++, count++) {\\n    if (xmlData[i].match(/\\\\w/) && count < 20)\\n      continue;\\n    if (xmlData[i] === ';')\\n      break;\\n    return -1;\\n  }\\n  return i;\\n}\\n\\nfunction getErrorObject(code, message, lineNumber) {\\n  return {\\n    err: {\\n      code: code,\\n      msg: message,\\n      line: lineNumber.line || lineNumber,\\n      col: lineNumber.col,\\n    },\\n  };\\n}\\n\\nfunction validateAttrName(attrName) {\\n  return util.isName(attrName);\\n}\\n\\n// const startsWithXML = /^xml/i;\\n\\nfunction validateTagName(tagname) {\\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\\n}\\n\\n//this function returns the line number for the character at the given index\\nfunction getLineNumberForPosition(xmlData, index) {\\n  const lines = xmlData.substring(0, index).split(/\\\\r?\\\\n/);\\n  return {\\n    line: lines.length,\\n\\n    // column number is last line's length + 1, because column numbering starts at 1:\\n    col: lines[lines.length - 1].length + 1\\n  };\\n}\\n\\n//this function returns the position of the first character of match within attrStr\\nfunction getPositionFromMatch(match) {\\n  return match.startIndex + match[1].length;\\n}\\n\",\"'use strict';\\n//parse Empty Node as self closing node\\nconst buildFromOrderedJs = require('./orderedJs2Xml');\\n\\nconst defaultOptions = {\\n  attributeNamePrefix: '@_',\\n  attributesGroupName: false,\\n  textNodeName: '#text',\\n  ignoreAttributes: true,\\n  cdataPropName: false,\\n  format: false,\\n  indentBy: '  ',\\n  suppressEmptyNode: false,\\n  suppressUnpairedNode: true,\\n  suppressBooleanAttributes: true,\\n  tagValueProcessor: function(key, a) {\\n    return a;\\n  },\\n  attributeValueProcessor: function(attrName, a) {\\n    return a;\\n  },\\n  preserveOrder: false,\\n  commentPropName: false,\\n  unpairedTags: [],\\n  entities: [\\n    { regex: new RegExp(\\\"&\\\", \\\"g\\\"), val: \\\"&amp;\\\" },//it must be on top\\n    { regex: new RegExp(\\\">\\\", \\\"g\\\"), val: \\\"&gt;\\\" },\\n    { regex: new RegExp(\\\"<\\\", \\\"g\\\"), val: \\\"&lt;\\\" },\\n    { regex: new RegExp(\\\"\\\\'\\\", \\\"g\\\"), val: \\\"&apos;\\\" },\\n    { regex: new RegExp(\\\"\\\\\\\"\\\", \\\"g\\\"), val: \\\"&quot;\\\" }\\n  ],\\n  processEntities: true,\\n  stopNodes: [],\\n  transformTagName: false,\\n};\\n\\nfunction Builder(options) {\\n  this.options = Object.assign({}, defaultOptions, options);\\n  if (this.options.ignoreAttributes || this.options.attributesGroupName) {\\n    this.isAttribute = function(/*a*/) {\\n      return false;\\n    };\\n  } else {\\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\\n    this.isAttribute = isAttribute;\\n  }\\n\\n  this.processTextOrObjNode = processTextOrObjNode\\n\\n  if (this.options.format) {\\n    this.indentate = indentate;\\n    this.tagEndChar = '>\\\\n';\\n    this.newLine = '\\\\n';\\n  } else {\\n    this.indentate = function() {\\n      return '';\\n    };\\n    this.tagEndChar = '>';\\n    this.newLine = '';\\n  }\\n\\n  if (this.options.suppressEmptyNode) {\\n    this.buildTextNode = buildEmptyTextNode;\\n    this.buildObjNode = buildEmptyObjNode;\\n  } else {\\n    this.buildTextNode = buildTextValNode;\\n    this.buildObjNode = buildObjectNode;\\n  }\\n\\n  this.buildTextValNode = buildTextValNode;\\n  this.buildObjectNode = buildObjectNode;\\n\\n  this.replaceEntitiesValue = replaceEntitiesValue;\\n  this.buildAttrPairStr = buildAttrPairStr;\\n}\\n\\nBuilder.prototype.build = function(jObj) {\\n  if(this.options.preserveOrder){\\n    return buildFromOrderedJs(jObj, this.options);\\n  }else {\\n    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){\\n      jObj = {\\n        [this.options.arrayNodeName] : jObj\\n      }\\n    }\\n    return this.j2x(jObj, 0).val;\\n  }\\n};\\n\\nBuilder.prototype.j2x = function(jObj, level) {\\n  let attrStr = '';\\n  let val = '';\\n  for (let key in jObj) {\\n    if (typeof jObj[key] === 'undefined') {\\n      // supress undefined node\\n    } else if (jObj[key] === null) {\\n      if(key[0] === \\\"?\\\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\\n      else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\\n      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\\n    } else if (jObj[key] instanceof Date) {\\n      val += this.buildTextNode(jObj[key], key, '', level);\\n    } else if (typeof jObj[key] !== 'object') {\\n      //premitive type\\n      const attr = this.isAttribute(key);\\n      if (attr) {\\n        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);\\n      }else {\\n        //tag value\\n        if (key === this.options.textNodeName) {\\n          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);\\n          val += this.replaceEntitiesValue(newval);\\n        } else {\\n          val += this.buildTextNode(jObj[key], key, '', level);\\n        }\\n      }\\n    } else if (Array.isArray(jObj[key])) {\\n      //repeated nodes\\n      const arrLen = jObj[key].length;\\n      for (let j = 0; j < arrLen; j++) {\\n        const item = jObj[key][j];\\n        if (typeof item === 'undefined') {\\n          // supress undefined node\\n        } else if (item === null) {\\n          if(key[0] === \\\"?\\\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\\n          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\\n          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\\n        } else if (typeof item === 'object') {\\n          val += this.processTextOrObjNode(item, key, level)\\n        } else {\\n          val += this.buildTextNode(item, key, '', level);\\n        }\\n      }\\n    } else {\\n      //nested node\\n      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\\n        const Ks = Object.keys(jObj[key]);\\n        const L = Ks.length;\\n        for (let j = 0; j < L; j++) {\\n          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);\\n        }\\n      } else {\\n        val += this.processTextOrObjNode(jObj[key], key, level)\\n      }\\n    }\\n  }\\n  return {attrStr: attrStr, val: val};\\n};\\n\\nfunction buildAttrPairStr(attrName, val){\\n  val = this.options.attributeValueProcessor(attrName, '' + val);\\n  val = this.replaceEntitiesValue(val);\\n  if (this.options.suppressBooleanAttributes && val === \\\"true\\\") {\\n    return ' ' + attrName;\\n  } else return ' ' + attrName + '=\\\"' + val + '\\\"';\\n}\\n\\nfunction processTextOrObjNode (object, key, level) {\\n  const result = this.j2x(object, level + 1);\\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\\n    return this.buildTextNode(object[this.options.textNodeName], key, result.attrStr, level);\\n  } else {\\n    return this.buildObjNode(result.val, key, result.attrStr, level);\\n  }\\n}\\n\\nfunction buildObjectNode(val, key, attrStr, level) {\\n  let tagEndExp = '</' + key + this.tagEndChar;\\n  let piClosingChar = \\\"\\\";\\n  \\n  if(key[0] === \\\"?\\\") {\\n    piClosingChar = \\\"?\\\";\\n    tagEndExp = \\\"\\\";\\n  }\\n\\n  if (attrStr && val.indexOf('<') === -1) {\\n    return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );\\n  } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\\n    return this.indentate(level) + `<!--${val}-->` + this.newLine;\\n  }else {\\n    return (\\n      this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +\\n      val +\\n      this.indentate(level) + tagEndExp    );\\n  }\\n}\\n\\nfunction buildEmptyObjNode(val, key, attrStr, level) {\\n  if (val !== '') {\\n    return this.buildObjectNode(val, key, attrStr, level);\\n  } else {\\n    if(key[0] === \\\"?\\\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\\n    else return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\\n  }\\n}\\n\\nfunction buildTextValNode(val, key, attrStr, level) {\\n  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\\n    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;\\n  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\\n    return this.indentate(level) + `<!--${val}-->` +  this.newLine;\\n  }else{\\n    let textValue = this.options.tagValueProcessor(key, val);\\n    textValue = this.replaceEntitiesValue(textValue);\\n  \\n    if( textValue === '' && this.options.unpairedTags.indexOf(key) !== -1){ //unpaired\\n      if(this.options.suppressUnpairedNode){\\n        return this.indentate(level) + '<' + key + this.tagEndChar;\\n      }else{\\n        return this.indentate(level) + '<' + key + \\\"/\\\" + this.tagEndChar;\\n      }\\n    } else{\\n      return (\\n        this.indentate(level) + '<' + key + attrStr + '>' +\\n         textValue +\\n        '</' + key + this.tagEndChar  );\\n    }\\n\\n  }\\n}\\n\\nfunction replaceEntitiesValue(textValue){\\n  if(textValue && textValue.length > 0 && this.options.processEntities){\\n    for (let i=0; i<this.options.entities.length; i++) {\\n      const entity = this.options.entities[i];\\n      textValue = textValue.replace(entity.regex, entity.val);\\n    }\\n  }\\n  return textValue;\\n}\\n\\nfunction buildEmptyTextNode(val, key, attrStr, level) {\\n  if( val === '' && this.options.unpairedTags.indexOf(key) !== -1){ //unpaired\\n    if(this.options.suppressUnpairedNode){\\n      return this.indentate(level) + '<' + key + this.tagEndChar;\\n    }else{\\n      return this.indentate(level) + '<' + key + \\\"/\\\" + this.tagEndChar;\\n    }\\n  }else if (val !== '') { //empty\\n    return this.buildTextValNode(val, key, attrStr, level);\\n  } else {\\n    if(key[0] === \\\"?\\\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; //PI tag\\n    else return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar; //normal\\n  }\\n}\\n\\nfunction indentate(level) {\\n  return this.options.indentBy.repeat(level);\\n}\\n\\nfunction isAttribute(name /*, options*/) {\\n  if (name.startsWith(this.options.attributeNamePrefix)) {\\n    return name.substr(this.attrPrefixLen);\\n  } else {\\n    return false;\\n  }\\n}\\n\\nmodule.exports = Builder;\\n\",\"const EOL = \\\"\\\\n\\\";\\n\\n/**\\n * \\n * @param {array} jArray \\n * @param {any} options \\n * @returns \\n */\\nfunction toXml(jArray, options){\\n    return arrToStr( jArray, options, \\\"\\\", 0);\\n}\\n\\nfunction arrToStr(arr, options, jPath, level){\\n    let xmlStr = \\\"\\\";\\n\\n    let indentation = \\\"\\\";\\n    if(options.format && options.indentBy.length > 0){//TODO: this logic can be avoided for each call\\n        indentation = EOL + \\\"\\\" + options.indentBy.repeat(level);\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        const tagObj = arr[i];\\n        const tagName = propName(tagObj);\\n        let newJPath = \\\"\\\";\\n        if(jPath.length === 0) newJPath = tagName\\n        else newJPath = `${jPath}.${tagName}`;\\n\\n        if(tagName === options.textNodeName){\\n            let tagText = tagObj[tagName];\\n            if(!isStopNode(newJPath, options)){\\n                tagText = options.tagValueProcessor( tagName, tagText);\\n                tagText = replaceEntitiesValue(tagText, options);\\n            }\\n            xmlStr += indentation + tagText;\\n            continue;\\n        }else if( tagName === options.cdataPropName){\\n            xmlStr += indentation + `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\\n            continue;\\n        }else if( tagName === options.commentPropName){\\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\\n            continue;\\n        }else if( tagName[0] === \\\"?\\\"){\\n            const attStr = attr_to_str(tagObj[\\\":@\\\"], options);\\n            const tempInd = tagName === \\\"?xml\\\" ? \\\"\\\" : indentation;\\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\\n            piTextNodeName = piTextNodeName.length !== 0 ? \\\" \\\" + piTextNodeName : \\\"\\\"; //remove extra spacing\\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\\n            continue;\\n        }\\n        const attStr = attr_to_str(tagObj[\\\":@\\\"], options);\\n        let tagStart =  indentation + `<${tagName}${attStr}`;\\n        let tagValue = arrToStr(tagObj[tagName], options, newJPath, level + 1);\\n        if(options.unpairedTags.indexOf(tagName) !== -1){\\n            if(options.suppressUnpairedNode)  xmlStr += tagStart + \\\">\\\"; \\n            else xmlStr += tagStart + \\\"/>\\\"; \\n        }else if( (!tagValue || tagValue.length === 0) && options.suppressEmptyNode){ \\n            xmlStr += tagStart + \\\"/>\\\"; \\n        }else{ \\n            //TODO: node with only text value should not parse the text value in next line\\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>` ;\\n        }\\n    }\\n    \\n    return xmlStr;\\n}\\n\\nfunction propName(obj){\\n    const keys = Object.keys(obj);\\n    for (let i = 0; i < keys.length; i++) {\\n      const key = keys[i];\\n      if(key !== \\\":@\\\") return key;\\n    }\\n  }\\n\\nfunction attr_to_str(attrMap, options){\\n    let attrStr = \\\"\\\";\\n    if(attrMap && !options.ignoreAttributes){\\n        for (let attr in attrMap){\\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\\n            attrVal = replaceEntitiesValue(attrVal, options);\\n            if(attrVal === true && options.suppressBooleanAttributes){\\n                attrStr+= ` ${attr.substr(options.attributeNamePrefix.length)}`;\\n            }else{\\n                attrStr+= ` ${attr.substr(options.attributeNamePrefix.length)}=\\\"${attrVal}\\\"`;\\n            }\\n        }\\n    }\\n    return attrStr;\\n}\\n\\nfunction isStopNode(jPath, options){\\n    jPath = jPath.substr(0,jPath.length - options.textNodeName.length - 1);\\n    let tagName = jPath.substr(jPath.lastIndexOf(\\\".\\\") + 1);\\n    for(let index in options.stopNodes){\\n        if(options.stopNodes[index] === jPath || options.stopNodes[index] === \\\"*.\\\"+tagName) return true;\\n    }\\n    return false;\\n}\\n\\nfunction replaceEntitiesValue(textValue, options){\\n    if(textValue && textValue.length > 0 && options.processEntities){\\n      for (let i=0; i< options.entities.length; i++) {\\n        const entity = options.entities[i];\\n        textValue = textValue.replace(entity.regex, entity.val);\\n      }\\n    }\\n    return textValue;\\n  }\\nmodule.exports = toXml;\",\"//TODO: handle comments\\nfunction readDocType(xmlData, i){\\n    \\n    const entities = {};\\n    if( xmlData[i + 3] === 'O' &&\\n         xmlData[i + 4] === 'C' &&\\n         xmlData[i + 5] === 'T' &&\\n         xmlData[i + 6] === 'Y' &&\\n         xmlData[i + 7] === 'P' &&\\n         xmlData[i + 8] === 'E')\\n    {    \\n        i = i+9;\\n        let angleBracketsCount = 1;\\n        let hasBody = false, entity = false, comment = false;\\n        let exp = \\\"\\\";\\n        for(;i<xmlData.length;i++){\\n            if (xmlData[i] === '<') {\\n                if( hasBody && \\n                     xmlData[i+1] === '!' &&\\n                     xmlData[i+2] === 'E' &&\\n                     xmlData[i+3] === 'N' &&\\n                     xmlData[i+4] === 'T' &&\\n                     xmlData[i+5] === 'I' &&\\n                     xmlData[i+6] === 'T' &&\\n                     xmlData[i+7] === 'Y'\\n                ){\\n                    i += 7;\\n                    entity = true;\\n                }else if( hasBody && \\n                    xmlData[i+1] === '!' &&\\n                     xmlData[i+2] === 'E' &&\\n                     xmlData[i+3] === 'L' &&\\n                     xmlData[i+4] === 'E' &&\\n                     xmlData[i+5] === 'M' &&\\n                     xmlData[i+6] === 'E' &&\\n                     xmlData[i+7] === 'N' &&\\n                     xmlData[i+8] === 'T'\\n                ){\\n                    //Not supported\\n                    i += 8;\\n                }else if( hasBody && \\n                    xmlData[i+1] === '!' &&\\n                    xmlData[i+2] === 'A' &&\\n                    xmlData[i+3] === 'T' &&\\n                    xmlData[i+4] === 'T' &&\\n                    xmlData[i+5] === 'L' &&\\n                    xmlData[i+6] === 'I' &&\\n                    xmlData[i+7] === 'S' &&\\n                    xmlData[i+8] === 'T'\\n                ){\\n                    //Not supported\\n                    i += 8;\\n                }else if( hasBody && \\n                    xmlData[i+1] === '!' &&\\n                    xmlData[i+2] === 'N' &&\\n                    xmlData[i+3] === 'O' &&\\n                    xmlData[i+4] === 'T' &&\\n                    xmlData[i+5] === 'A' &&\\n                    xmlData[i+6] === 'T' &&\\n                    xmlData[i+7] === 'I' &&\\n                    xmlData[i+8] === 'O' &&\\n                    xmlData[i+9] === 'N'\\n                ){\\n                    //Not supported\\n                    i += 9;\\n                }else if( //comment\\n                    xmlData[i+1] === '!' &&\\n                    xmlData[i+2] === '-' &&\\n                    xmlData[i+3] === '-'\\n                ){\\n                    comment = true;\\n                }else{\\n                    throw new Error(\\\"Invalid DOCTYPE\\\");\\n                }\\n                angleBracketsCount++;\\n                exp = \\\"\\\";\\n            } else if (xmlData[i] === '>') {\\n                if(comment){\\n                    if( xmlData[i - 1] === \\\"-\\\" && xmlData[i - 2] === \\\"-\\\"){\\n                        comment = false;\\n                    }else{\\n                        throw new Error(`Invalid XML comment in DOCTYPE`);\\n                    }\\n                }else if(entity){\\n                    parseEntityExp(exp, entities);\\n                    entity = false;\\n                }\\n                angleBracketsCount--;\\n                if (angleBracketsCount === 0) {\\n                  break;\\n                }\\n            }else if( xmlData[i] === '['){\\n                hasBody = true;\\n            }else{\\n                exp += xmlData[i];\\n            }\\n        }\\n        if(angleBracketsCount !== 0){\\n            throw new Error(`Unclosed DOCTYPE`);\\n        }\\n    }else{\\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\\n    }\\n    return {entities, i};\\n}\\n\\nconst entityRegex = RegExp(\\\"^\\\\\\\\s([a-zA-z0-0]+)[ \\\\t](['\\\\\\\"])([^&]+)\\\\\\\\2\\\");\\nfunction parseEntityExp(exp, entities){\\n    const match = entityRegex.exec(exp);\\n    if(match){\\n        entities[ match[1] ] = {\\n            regx : RegExp( `&${match[1]};`,\\\"g\\\"),\\n            val: match[3]\\n        };\\n    }\\n}\\nmodule.exports = readDocType;\",\"\\nconst defaultOptions = {\\n    preserveOrder: false,\\n    attributeNamePrefix: '@_',\\n    attributesGroupName: false,\\n    textNodeName: '#text',\\n    ignoreAttributes: true,\\n    removeNSPrefix: false, // remove NS from tag name or attribute name if true\\n    allowBooleanAttributes: false, //a tag can have attributes without any value\\n    //ignoreRootElement : false,\\n    parseTagValue: true,\\n    parseAttributeValue: false,\\n    trimValues: true, //Trim string values of tag and attributes\\n    cdataPropName: false,\\n    numberParseOptions: {\\n      hex: true,\\n      leadingZeros: true\\n    },\\n    tagValueProcessor: function(tagName, val) {\\n      return val;\\n    },\\n    attributeValueProcessor: function(attrName, val) {\\n      return val;\\n    },\\n    stopNodes: [], //nested tags will not be parsed even for errors\\n    alwaysCreateTextNode: false,\\n    isArray: () => false,\\n    commentPropName: false,\\n    unpairedTags: [],\\n    processEntities: true,\\n    htmlEntities: false,\\n    ignoreDeclaration: false,\\n    ignorePiTags: false,\\n    transformTagName: false,\\n};\\n   \\nconst buildOptions = function(options) {\\n    return Object.assign({}, defaultOptions, options);\\n};\\n\\nexports.buildOptions = buildOptions;\\nexports.defaultOptions = defaultOptions;\",\"'use strict';\\n///@ts-check\\n\\nconst util = require('../util');\\nconst xmlNode = require('./xmlNode');\\nconst readDocType = require(\\\"./DocTypeReader\\\");\\nconst toNumber = require(\\\"strnum\\\");\\n\\nconst regx =\\n  '<((!\\\\\\\\[CDATA\\\\\\\\[([\\\\\\\\s\\\\\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\\\\\/)(NAME)\\\\\\\\s*>))([^<]*)'\\n  .replace(/NAME/g, util.nameRegexp);\\n\\n//const tagsRegx = new RegExp(\\\"<(\\\\\\\\/?[\\\\\\\\w:\\\\\\\\-\\\\._]+)([^>]*)>(\\\\\\\\s*\\\"+cdataRegx+\\\")*([^<]+)?\\\",\\\"g\\\");\\n//const tagsRegx = new RegExp(\\\"<(\\\\\\\\/?)((\\\\\\\\w*:)?([\\\\\\\\w:\\\\\\\\-\\\\._]+))([^>]*)>([^<]*)(\\\"+cdataRegx+\\\"([^<]*))*([^<]+)?\\\",\\\"g\\\");\\n\\nclass OrderedObjParser{\\n  constructor(options){\\n    this.options = options;\\n    this.currentNode = null;\\n    this.tagsNodeStack = [];\\n    this.docTypeEntities = {};\\n    this.lastEntities = {\\n      \\\"apos\\\" : { regex: /&(apos|#39|#x27);/g, val : \\\"'\\\"},\\n      \\\"gt\\\" : { regex: /&(gt|#62|#x3E);/g, val : \\\">\\\"},\\n      \\\"lt\\\" : { regex: /&(lt|#60|#x3C);/g, val : \\\"<\\\"},\\n      \\\"quot\\\" : { regex: /&(quot|#34|#x22);/g, val : \\\"\\\\\\\"\\\"},\\n    };\\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \\\"&\\\"};\\n    this.htmlEntities = {\\n      \\\"space\\\": { regex: /&(nbsp|#160);/g, val: \\\" \\\" },\\n      // \\\"lt\\\" : { regex: /&(lt|#60);/g, val: \\\"<\\\" },\\n      // \\\"gt\\\" : { regex: /&(gt|#62);/g, val: \\\">\\\" },\\n      // \\\"amp\\\" : { regex: /&(amp|#38);/g, val: \\\"&\\\" },\\n      // \\\"quot\\\" : { regex: /&(quot|#34);/g, val: \\\"\\\\\\\"\\\" },\\n      // \\\"apos\\\" : { regex: /&(apos|#39);/g, val: \\\"'\\\" },\\n      \\\"cent\\\" : { regex: /&(cent|#162);/g, val: \\\"\u00a2\\\" },\\n      \\\"pound\\\" : { regex: /&(pound|#163);/g, val: \\\"\u00a3\\\" },\\n      \\\"yen\\\" : { regex: /&(yen|#165);/g, val: \\\"\u00a5\\\" },\\n      \\\"euro\\\" : { regex: /&(euro|#8364);/g, val: \\\"\u20ac\\\" },\\n      \\\"copyright\\\" : { regex: /&(copy|#169);/g, val: \\\"\u00a9\\\" },\\n      \\\"reg\\\" : { regex: /&(reg|#174);/g, val: \\\"\u00ae\\\" },\\n      \\\"inr\\\" : { regex: /&(inr|#8377);/g, val: \\\"\u20b9\\\" },\\n    };\\n    this.addExternalEntities = addExternalEntities;\\n    this.parseXml = parseXml;\\n    this.parseTextData = parseTextData;\\n    this.resolveNameSpace = resolveNameSpace;\\n    this.buildAttributesMap = buildAttributesMap;\\n    this.isItStopNode = isItStopNode;\\n    this.replaceEntitiesValue = replaceEntitiesValue;\\n    this.readStopNodeData = readStopNodeData;\\n    this.saveTextToParentTag = saveTextToParentTag;\\n  }\\n\\n}\\n\\nfunction addExternalEntities(externalEntities){\\n  const entKeys = Object.keys(externalEntities);\\n  for (let i = 0; i < entKeys.length; i++) {\\n    const ent = entKeys[i];\\n    this.lastEntities[ent] = {\\n       regex: new RegExp(\\\"&\\\"+ent+\\\";\\\",\\\"g\\\"),\\n       val : externalEntities[ent]\\n    }\\n  }\\n}\\n\\n/**\\n * @param {string} val\\n * @param {string} tagName\\n * @param {string} jPath\\n * @param {boolean} dontTrim\\n * @param {boolean} hasAttributes\\n * @param {boolean} isLeafNode\\n * @param {boolean} escapeEntities\\n */\\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\\n  if (val !== undefined) {\\n    if (this.options.trimValues && !dontTrim) {\\n      val = val.trim();\\n    }\\n    if(val.length > 0){\\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\\n      \\n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\\n      if(newval === null || newval === undefined){\\n        //don't parse\\n        return val;\\n      }else if(typeof newval !== typeof val || newval !== val){\\n        //overwrite\\n        return newval;\\n      }else if(this.options.trimValues){\\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\\n      }else{\\n        const trimmedVal = val.trim();\\n        if(trimmedVal === val){\\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\\n        }else{\\n          return val;\\n        }\\n      }\\n    }\\n  }\\n}\\n\\nfunction resolveNameSpace(tagname) {\\n  if (this.options.removeNSPrefix) {\\n    const tags = tagname.split(':');\\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\\n    if (tags[0] === 'xmlns') {\\n      return '';\\n    }\\n    if (tags.length === 2) {\\n      tagname = prefix + tags[1];\\n    }\\n  }\\n  return tagname;\\n}\\n\\n//TODO: change regex to capture NS\\n//const attrsRegx = new RegExp(\\\"([\\\\\\\\w\\\\\\\\-\\\\\\\\.\\\\\\\\:]+)\\\\\\\\s*=\\\\\\\\s*(['\\\\\\\"])((.|\\\\n)*?)\\\\\\\\2\\\",\\\"gm\\\");\\nconst attrsRegx = new RegExp('([^\\\\\\\\s=]+)\\\\\\\\s*(=\\\\\\\\s*([\\\\'\\\"])([\\\\\\\\s\\\\\\\\S]*?)\\\\\\\\3)?', 'gm');\\n\\nfunction buildAttributesMap(attrStr, jPath) {\\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\\n    // attrStr = attrStr.replace(/\\\\r?\\\\n/g, ' ');\\n    //attrStr = attrStr || attrStr.trim();\\n\\n    const matches = util.getAllMatches(attrStr, attrsRegx);\\n    const len = matches.length; //don't make it inline\\n    const attrs = {};\\n    for (let i = 0; i < len; i++) {\\n      const attrName = this.resolveNameSpace(matches[i][1]);\\n      let oldVal = matches[i][4];\\n      const aName = this.options.attributeNamePrefix + attrName;\\n      if (attrName.length) {\\n        if (oldVal !== undefined) {\\n          if (this.options.trimValues) {\\n            oldVal = oldVal.trim();\\n          }\\n          oldVal = this.replaceEntitiesValue(oldVal);\\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\\n          if(newVal === null || newVal === undefined){\\n            //don't parse\\n            attrs[aName] = oldVal;\\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\\n            //overwrite\\n            attrs[aName] = newVal;\\n          }else{\\n            //parse\\n            attrs[aName] = parseValue(\\n              oldVal,\\n              this.options.parseAttributeValue,\\n              this.options.numberParseOptions\\n            );\\n          }\\n        } else if (this.options.allowBooleanAttributes) {\\n          attrs[aName] = true;\\n        }\\n      }\\n    }\\n    if (!Object.keys(attrs).length) {\\n      return;\\n    }\\n    if (this.options.attributesGroupName) {\\n      const attrCollection = {};\\n      attrCollection[this.options.attributesGroupName] = attrs;\\n      return attrCollection;\\n    }\\n    return attrs;\\n  }\\n}\\n\\nconst parseXml = function(xmlData) {\\n  xmlData = xmlData.replace(/\\\\r\\\\n?/g, \\\"\\\\n\\\"); //TODO: remove this line\\n  const xmlObj = new xmlNode('!xml');\\n  let currentNode = xmlObj;\\n  let textData = \\\"\\\";\\n  let jPath = \\\"\\\";\\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\\n    const ch = xmlData[i];\\n    if(ch === '<'){\\n      // const nextIndex = i+1;\\n      // const _2ndChar = xmlData[nextIndex];\\n      if( xmlData[i+1] === '/') {//Closing Tag\\n        const closeIndex = findClosingIndex(xmlData, \\\">\\\", i, \\\"Closing Tag is not closed.\\\")\\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\\n\\n        if(this.options.removeNSPrefix){\\n          const colonIndex = tagName.indexOf(\\\":\\\");\\n          if(colonIndex !== -1){\\n            tagName = tagName.substr(colonIndex+1);\\n          }\\n        }\\n\\n        if(this.options.transformTagName) {\\n          tagName = this.options.transformTagName(tagName);\\n        }\\n\\n        if(currentNode){\\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\\n        }\\n\\n        jPath = jPath.substr(0, jPath.lastIndexOf(\\\".\\\"));\\n        \\n        currentNode = this.tagsNodeStack.pop();//avoid recurssion, set the parent tag scope\\n        textData = \\\"\\\";\\n        i = closeIndex;\\n      } else if( xmlData[i+1] === '?') {\\n\\n        let tagData = readTagExp(xmlData,i, false, \\\"?>\\\");\\n        if(!tagData) throw new Error(\\\"Pi Tag is not closed.\\\");\\n\\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\\n        if( (this.options.ignoreDeclaration && tagData.tagName === \\\"?xml\\\") || this.options.ignorePiTags){\\n\\n        }else{\\n  \\n          const childNode = new xmlNode(tagData.tagName);\\n          childNode.add(this.options.textNodeName, \\\"\\\");\\n          \\n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\\n            childNode[\\\":@\\\"] = this.buildAttributesMap(tagData.tagExp, jPath);\\n          }\\n          currentNode.addChild(childNode);\\n\\n        }\\n\\n\\n        i = tagData.closeIndex + 1;\\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\\n        const endIndex = findClosingIndex(xmlData, \\\"-->\\\", i+4, \\\"Comment is not closed.\\\")\\n        if(this.options.commentPropName){\\n          const comment = xmlData.substring(i + 4, endIndex - 2);\\n\\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\\n\\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\\n        }\\n        i = endIndex;\\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\\n        const result = readDocType(xmlData, i);\\n        this.docTypeEntities = result.entities;\\n        i = result.i;\\n      }else if(xmlData.substr(i + 1, 2) === '![') {\\n        const closeIndex = findClosingIndex(xmlData, \\\"]]>\\\", i, \\\"CDATA is not closed.\\\") - 2;\\n        const tagExp = xmlData.substring(i + 9,closeIndex);\\n\\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\\n\\n        //cdata should be set even if it is 0 length string\\n        if(this.options.cdataPropName){\\n          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + \\\".\\\" + this.options.cdataPropName, true, false, true);\\n          // if(!val) val = \\\"\\\";\\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\\n        }else{\\n          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);\\n          if(val == undefined) val = \\\"\\\";\\n          currentNode.add(this.options.textNodeName, val);\\n        }\\n        \\n        i = closeIndex + 2;\\n      }else {//Opening tag\\n        let result = readTagExp(xmlData,i, this. options.removeNSPrefix);\\n        let tagName= result.tagName;\\n        let tagExp = result.tagExp;\\n        let attrExpPresent = result.attrExpPresent;\\n        let closeIndex = result.closeIndex;\\n\\n        if (this.options.transformTagName) {\\n          tagName = this.options.transformTagName(tagName);\\n        }\\n        \\n        //save text as child node\\n        if (currentNode && textData) {\\n          if(currentNode.tagname !== '!xml'){\\n            //when nested tag is found\\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\\n          }\\n        }\\n\\n        if(tagName !== xmlObj.tagname){\\n          jPath += jPath ? \\\".\\\" + tagName : tagName;\\n        }\\n\\n        //check if last tag was unpaired tag\\n        const lastTag = currentNode;\\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\\n          currentNode = this.tagsNodeStack.pop();\\n        }\\n\\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) { //TODO: namespace\\n          let tagContent = \\\"\\\";\\n          //self-closing tag\\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\\\"/\\\") === tagExp.length - 1){\\n            i = result.closeIndex;\\n          }\\n          //boolean tag\\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\\n            i = result.closeIndex;\\n          }\\n          //normal tag\\n          else{\\n            //read until closing tag is found\\n            const result = this.readStopNodeData(xmlData, tagName, closeIndex + 1);\\n            if(!result) throw new Error(`Unexpected end of ${tagName}`);\\n            i = result.i;\\n            tagContent = result.tagContent;\\n          }\\n\\n          const childNode = new xmlNode(tagName);\\n          if(tagName !== tagExp && attrExpPresent){\\n            childNode[\\\":@\\\"] = this.buildAttributesMap(tagExp, jPath);\\n          }\\n          if(tagContent) {\\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\\n          }\\n          \\n          jPath = jPath.substr(0, jPath.lastIndexOf(\\\".\\\"));\\n          childNode.add(this.options.textNodeName, tagContent);\\n          \\n          currentNode.addChild(childNode);\\n        }else{\\n  //selfClosing tag\\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\\\"/\\\") === tagExp.length - 1){\\n            if(tagName[tagName.length - 1] === \\\"/\\\"){ //remove trailing '/'\\n              tagName = tagName.substr(0, tagName.length - 1);\\n              tagExp = tagName;\\n            }else{\\n              tagExp = tagExp.substr(0, tagExp.length - 1);\\n            }\\n            \\n            if(this.options.transformTagName) {\\n              tagName = this.options.transformTagName(tagName);\\n            }\\n\\n            const childNode = new xmlNode(tagName);\\n            if(tagName !== tagExp && attrExpPresent){\\n              childNode[\\\":@\\\"] = this.buildAttributesMap(tagExp, jPath);\\n            }\\n            jPath = jPath.substr(0, jPath.lastIndexOf(\\\".\\\"));\\n            currentNode.addChild(childNode);\\n          }\\n    //opening tag\\n          else{\\n            const childNode = new xmlNode( tagName);\\n            this.tagsNodeStack.push(currentNode);\\n            \\n            if(tagName !== tagExp && attrExpPresent){\\n              childNode[\\\":@\\\"] = this.buildAttributesMap(tagExp, jPath);\\n            }\\n            currentNode.addChild(childNode);\\n            currentNode = childNode;\\n          }\\n          textData = \\\"\\\";\\n          i = closeIndex;\\n        }\\n      }\\n    }else{\\n      textData += xmlData[i];\\n    }\\n  }\\n  return xmlObj.child;\\n}\\n\\nconst replaceEntitiesValue = function(val){\\n\\n  if(this.options.processEntities){\\n    for(let entityName in this.docTypeEntities){\\n      const entity = this.docTypeEntities[entityName];\\n      val = val.replace( entity.regx, entity.val);\\n    }\\n    for(let entityName in this.lastEntities){\\n      const entity = this.lastEntities[entityName];\\n      val = val.replace( entity.regex, entity.val);\\n    }\\n    if(this.options.htmlEntities){\\n      for(let entityName in this.htmlEntities){\\n        const entity = this.htmlEntities[entityName];\\n        val = val.replace( entity.regex, entity.val);\\n      }\\n    }\\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\\n  }\\n  return val;\\n}\\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\\n  if (textData) { //store previously collected data as textNode\\n    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0\\n    \\n    textData = this.parseTextData(textData,\\n      currentNode.tagname,\\n      jPath,\\n      false,\\n      currentNode[\\\":@\\\"] ? Object.keys(currentNode[\\\":@\\\"]).length !== 0 : false,\\n      isLeafNode);\\n\\n    if (textData !== undefined && textData !== \\\"\\\")\\n      currentNode.add(this.options.textNodeName, textData);\\n    textData = \\\"\\\";\\n  }\\n  return textData;\\n}\\n\\n//TODO: use jPath to simplify the logic\\n/**\\n * \\n * @param {string[]} stopNodes \\n * @param {string} jPath\\n * @param {string} currentTagName \\n */\\nfunction isItStopNode(stopNodes, jPath, currentTagName){\\n  const allNodesExp = \\\"*.\\\" + currentTagName;\\n  for (const stopNodePath in stopNodes) {\\n    const stopNodeExp = stopNodes[stopNodePath];\\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\\n  }\\n  return false;\\n}\\n\\n/**\\n * Returns the tag Expression and where it is ending handling single-dobule quotes situation\\n * @param {string} xmlData \\n * @param {number} i starting index\\n * @returns \\n */\\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \\\">\\\"){\\n  let attrBoundary;\\n  let tagExp = \\\"\\\";\\n  for (let index = i; index < xmlData.length; index++) {\\n    let ch = xmlData[index];\\n    if (attrBoundary) {\\n        if (ch === attrBoundary) attrBoundary = \\\"\\\";//reset\\n    } else if (ch === '\\\"' || ch === \\\"'\\\") {\\n        attrBoundary = ch;\\n    } else if (ch === closingChar[0]) {\\n      if(closingChar[1]){\\n        if(xmlData[index + 1] === closingChar[1]){\\n          return {\\n            data: tagExp,\\n            index: index\\n          }\\n        }\\n      }else{\\n        return {\\n          data: tagExp,\\n          index: index\\n        }\\n      }\\n    } else if (ch === '\\\\t') {\\n      ch = \\\" \\\"\\n    }\\n    tagExp += ch;\\n  }\\n}\\n\\nfunction findClosingIndex(xmlData, str, i, errMsg){\\n  const closingIndex = xmlData.indexOf(str, i);\\n  if(closingIndex === -1){\\n    throw new Error(errMsg)\\n  }else{\\n    return closingIndex + str.length - 1;\\n  }\\n}\\n\\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \\\">\\\"){\\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\\n  if(!result) return;\\n  let tagExp = result.data;\\n  const closeIndex = result.index;\\n  const separatorIndex = tagExp.search(/\\\\s/);\\n  let tagName = tagExp;\\n  let attrExpPresent = true;\\n  if(separatorIndex !== -1){//separate tag name and attributes expression\\n    tagName = tagExp.substr(0, separatorIndex).replace(/\\\\s\\\\s*$/, '');\\n    tagExp = tagExp.substr(separatorIndex + 1);\\n  }\\n\\n  if(removeNSPrefix){\\n    const colonIndex = tagName.indexOf(\\\":\\\");\\n    if(colonIndex !== -1){\\n      tagName = tagName.substr(colonIndex+1);\\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\\n    }\\n  }\\n\\n  return {\\n    tagName: tagName,\\n    tagExp: tagExp,\\n    closeIndex: closeIndex,\\n    attrExpPresent: attrExpPresent,\\n  }\\n}\\n/**\\n * find paired tag for a stop node\\n * @param {string} xmlData \\n * @param {string} tagName \\n * @param {number} i \\n */\\nfunction readStopNodeData(xmlData, tagName, i){\\n  const startIndex = i;\\n  // Starting at 1 since we already have an open tag\\n  let openTagCount = 1;\\n\\n  for (; i < xmlData.length; i++) {\\n    if( xmlData[i] === \\\"<\\\"){ \\n      if (xmlData[i+1] === \\\"/\\\") {//close tag\\n          const closeIndex = findClosingIndex(xmlData, \\\">\\\", i, `${tagName} is not closed`);\\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\\n          if(closeTagName === tagName){\\n            openTagCount--;\\n            if (openTagCount === 0) {\\n              return {\\n                tagContent: xmlData.substring(startIndex, i),\\n                i : closeIndex\\n              }\\n            }\\n          }\\n          i=closeIndex;\\n        } else if(xmlData[i+1] === '?') { \\n          const closeIndex = findClosingIndex(xmlData, \\\"?>\\\", i+1, \\\"StopNode is not closed.\\\")\\n          i=closeIndex;\\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \\n          const closeIndex = findClosingIndex(xmlData, \\\"-->\\\", i+3, \\\"StopNode is not closed.\\\")\\n          i=closeIndex;\\n        } else if(xmlData.substr(i + 1, 2) === '![') { \\n          const closeIndex = findClosingIndex(xmlData, \\\"]]>\\\", i, \\\"StopNode is not closed.\\\") - 2;\\n          i=closeIndex;\\n        } else {\\n          const tagData = readTagExp(xmlData, i, '>')\\n\\n          if (tagData) {\\n            const openTagName = tagData && tagData.tagName;\\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \\\"/\\\") {\\n              openTagCount++;\\n            }\\n            i=tagData.closeIndex;\\n          }\\n        }\\n      }\\n  }//end for loop\\n}\\n\\nfunction parseValue(val, shouldParse, options) {\\n  if (shouldParse && typeof val === 'string') {\\n    //console.log(options)\\n    const newval = val.trim();\\n    if(newval === 'true' ) return true;\\n    else if(newval === 'false' ) return false;\\n    else return toNumber(val, options);\\n  } else {\\n    if (util.isExist(val)) {\\n      return val;\\n    } else {\\n      return '';\\n    }\\n  }\\n}\\n\\n\\nmodule.exports = OrderedObjParser;\\n\",\"const { buildOptions} = require(\\\"./OptionsBuilder\\\");\\nconst OrderedObjParser = require(\\\"./OrderedObjParser\\\");\\nconst { prettify} = require(\\\"./node2json\\\");\\nconst validator = require('../validator');\\n\\nclass XMLParser{\\n    \\n    constructor(options){\\n        this.externalEntities = {};\\n        this.options = buildOptions(options);\\n        \\n    }\\n    /**\\n     * Parse XML dats to JS object \\n     * @param {string|Buffer} xmlData \\n     * @param {boolean|Object} validationOption \\n     */\\n    parse(xmlData,validationOption){\\n        if(typeof xmlData === \\\"string\\\"){\\n        }else if( xmlData.toString){\\n            xmlData = xmlData.toString();\\n        }else{\\n            throw new Error(\\\"XML data is accepted in String or Bytes[] form.\\\")\\n        }\\n        if( validationOption){\\n            if(validationOption === true) validationOption = {}; //validate with default options\\n            \\n            const result = validator.validate(xmlData, validationOption);\\n            if (result !== true) {\\n              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )\\n            }\\n          }\\n        const orderedObjParser = new OrderedObjParser(this.options);\\n        orderedObjParser.addExternalEntities(this.externalEntities);\\n        const orderedResult = orderedObjParser.parseXml(xmlData);\\n        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;\\n        else return prettify(orderedResult, this.options);\\n    }\\n\\n    /**\\n     * Add Entity which is not by default supported by this library\\n     * @param {string} key \\n     * @param {string} value \\n     */\\n    addEntity(key, value){\\n        if(value.indexOf(\\\"&\\\") !== -1){\\n            throw new Error(\\\"Entity value can't have '&'\\\")\\n        }else if(key.indexOf(\\\"&\\\") !== -1 || key.indexOf(\\\";\\\") !== -1){\\n            throw new Error(\\\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\\\")\\n        }else if(value === \\\"&\\\"){\\n            throw new Error(\\\"An entity with value '&' is not permitted\\\");\\n        }else{\\n            this.externalEntities[key] = value;\\n        }\\n    }\\n}\\n\\nmodule.exports = XMLParser;\",\"'use strict';\\n\\n/**\\n * \\n * @param {array} node \\n * @param {any} options \\n * @returns \\n */\\nfunction prettify(node, options){\\n  return compress( node, options);\\n}\\n\\n/**\\n * \\n * @param {array} arr \\n * @param {object} options \\n * @param {string} jPath \\n * @returns object\\n */\\nfunction compress(arr, options, jPath){\\n  let text;\\n  const compressedObj = {};\\n  for (let i = 0; i < arr.length; i++) {\\n    const tagObj = arr[i];\\n    const property = propName(tagObj);\\n    let newJpath = \\\"\\\";\\n    if(jPath === undefined) newJpath = property;\\n    else newJpath = jPath + \\\".\\\" + property;\\n\\n    if(property === options.textNodeName){\\n      if(text === undefined) text = tagObj[property];\\n      else text += \\\"\\\" + tagObj[property];\\n    }else if(property === undefined){\\n      continue;\\n    }else if(tagObj[property]){\\n      \\n      let val = compress(tagObj[property], options, newJpath);\\n      const isLeaf = isLeafTag(val, options);\\n\\n      if(tagObj[\\\":@\\\"]){\\n        assignAttributes( val, tagObj[\\\":@\\\"], newJpath, options);\\n      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){\\n        val = val[options.textNodeName];\\n      }else if(Object.keys(val).length === 0){\\n        if(options.alwaysCreateTextNode) val[options.textNodeName] = \\\"\\\";\\n        else val = \\\"\\\";\\n      }\\n\\n      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\\n        if(!Array.isArray(compressedObj[property])) {\\n            compressedObj[property] = [ compressedObj[property] ];\\n        }\\n        compressedObj[property].push(val);\\n      }else{\\n        //TODO: if a node is not an array, then check if it should be an array\\n        //also determine if it is a leaf node\\n        if (options.isArray(property, newJpath, isLeaf )) {\\n          compressedObj[property] = [val];\\n        }else{\\n          compressedObj[property] = val;\\n        }\\n      }\\n    }\\n    \\n  }\\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\\n  if(typeof text === \\\"string\\\"){\\n    if(text.length > 0) compressedObj[options.textNodeName] = text;\\n  }else if(text !== undefined) compressedObj[options.textNodeName] = text;\\n  return compressedObj;\\n}\\n\\nfunction propName(obj){\\n  const keys = Object.keys(obj);\\n  for (let i = 0; i < keys.length; i++) {\\n    const key = keys[i];\\n    if(key !== \\\":@\\\") return key;\\n  }\\n}\\n\\nfunction assignAttributes(obj, attrMap, jpath, options){\\n  if (attrMap) {\\n    const keys = Object.keys(attrMap);\\n    const len = keys.length; //don't make it inline\\n    for (let i = 0; i < len; i++) {\\n      const atrrName = keys[i];\\n      if (options.isArray(atrrName, jpath + \\\".\\\" + atrrName, true, true)) {\\n        obj[atrrName] = [ attrMap[atrrName] ];\\n      } else {\\n        obj[atrrName] = attrMap[atrrName];\\n      }\\n    }\\n  }\\n}\\n\\nfunction isLeafTag(obj, options){\\n  const propCount = Object.keys(obj).length;\\n  if( propCount === 0 || (propCount === 1 && obj[options.textNodeName]) ) return true;\\n  return false;\\n}\\nexports.prettify = prettify;\\n\",\"'use strict';\\n\\nclass XmlNode{\\n  constructor(tagname) {\\n    this.tagname = tagname;\\n    this.child = []; //nested tags, text, cdata, comments in order\\n    this[\\\":@\\\"] = {}; //attributes map\\n  }\\n  add(key,val){\\n    // this.child.push( {name : key, val: val, isCdata: isCdata });\\n    this.child.push( {[key]: val });\\n  }\\n  addChild(node) {\\n    if(node[\\\":@\\\"] && Object.keys(node[\\\":@\\\"]).length > 0){\\n      this.child.push( { [node.tagname]: node.child, [\\\":@\\\"]: node[\\\":@\\\"] });\\n    }else{\\n      this.child.push( { [node.tagname]: node.child });\\n    }\\n  };\\n};\\n\\n\\nmodule.exports = XmlNode;\",\"// The module cache\\nvar __webpack_module_cache__ = {};\\n\\n// The require function\\nfunction __webpack_require__(moduleId) {\\n\\t// Check if module is in cache\\n\\tvar cachedModule = __webpack_module_cache__[moduleId];\\n\\tif (cachedModule !== undefined) {\\n\\t\\treturn cachedModule.exports;\\n\\t}\\n\\t// Create a new module (and put it into the cache)\\n\\tvar module = __webpack_module_cache__[moduleId] = {\\n\\t\\t// no module.id needed\\n\\t\\t// no module.loaded needed\\n\\t\\texports: {}\\n\\t};\\n\\n\\t// Execute the module function\\n\\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\\n\\n\\t// Return the exports of the module\\n\\treturn module.exports;\\n}\\n\\n\",\"// startup\\n// Load entry module and return exports\\n// This entry module is referenced by other modules so it can't be inlined\\nvar __webpack_exports__ = __webpack_require__(316);\\n\"],\"names\":[\"hexRegex\",\"numRegex\",\"Number\",\"parseInt\",\"window\",\"parseFloat\",\"consider\",\"hex\",\"leadingZeros\",\"decimalPoint\",\"eNotation\",\"module\",\"exports\",\"str\",\"options\",\"Object\",\"assign\",\"trimmedStr\",\"trim\",\"undefined\",\"skipLike\",\"test\",\"match\",\"exec\",\"sign\",\"numTrimmedByZeros\",\"numStr\",\"indexOf\",\"replace\",\"length\",\"substr\",\"num\",\"search\",\"validator\",\"require\",\"XMLParser\",\"XMLBuilder\",\"XMLValidator\",\"nameRegexp\",\"regexName\",\"RegExp\",\"isExist\",\"v\",\"isEmptyObject\",\"obj\",\"keys\",\"merge\",\"target\",\"a\",\"arrayMode\",\"len\",\"i\",\"getValue\",\"isName\",\"string\",\"getAllMatches\",\"regex\",\"matches\",\"allmatches\",\"startIndex\",\"lastIndex\",\"index\",\"push\",\"util\",\"defaultOptions\",\"allowBooleanAttributes\",\"unpairedTags\",\"isWhiteSpace\",\"char\",\"readPI\",\"xmlData\",\"start\",\"tagname\",\"getErrorObject\",\"getLineNumberForPosition\",\"readCommentAndCDATA\",\"angleBracketsCount\",\"readAttributeStr\",\"attrStr\",\"startChar\",\"tagClosed\",\"value\",\"validate\",\"tags\",\"tagFound\",\"reachedRoot\",\"err\",\"tagStartPos\",\"closingTag\",\"tagName\",\"substring\",\"result\",\"attrStrStart\",\"isValid\",\"validateAttributeString\",\"code\",\"msg\",\"line\",\"otg\",\"pop\",\"openPos\",\"col\",\"afterAmp\",\"validateAmpersand\",\"JSON\",\"stringify\",\"map\",\"t\",\"validAttrStrRegxp\",\"attrNames\",\"getPositionFromMatch\",\"attrName\",\"validateAttrName\",\"hasOwnProperty\",\"re\",\"validateNumberAmpersand\",\"count\",\"message\",\"lineNumber\",\"lines\",\"split\",\"buildFromOrderedJs\",\"attributeNamePrefix\",\"attributesGroupName\",\"textNodeName\",\"ignoreAttributes\",\"cdataPropName\",\"format\",\"indentBy\",\"suppressEmptyNode\",\"suppressUnpairedNode\",\"suppressBooleanAttributes\",\"tagValueProcessor\",\"key\",\"attributeValueProcessor\",\"preserveOrder\",\"commentPropName\",\"entities\",\"val\",\"processEntities\",\"stopNodes\",\"transformTagName\",\"Builder\",\"this\",\"isAttribute\",\"attrPrefixLen\",\"processTextOrObjNode\",\"indentate\",\"tagEndChar\",\"newLine\",\"buildTextNode\",\"buildEmptyTextNode\",\"buildObjNode\",\"buildEmptyObjNode\",\"buildTextValNode\",\"buildObjectNode\",\"replaceEntitiesValue\",\"buildAttrPairStr\",\"object\",\"level\",\"j2x\",\"tagEndExp\",\"piClosingChar\",\"textValue\",\"entity\",\"repeat\",\"name\",\"startsWith\",\"prototype\",\"build\",\"jObj\",\"Array\",\"isArray\",\"arrayNodeName\",\"Date\",\"attr\",\"newval\",\"arrLen\",\"j\",\"item\",\"Ks\",\"L\",\"arrToStr\",\"arr\",\"jPath\",\"xmlStr\",\"indentation\",\"newJPath\",\"tagObj\",\"propName\",\"tagStart\",\"attr_to_str\",\"tagValue\",\"attStr\",\"tempInd\",\"piTextNodeName\",\"tagText\",\"isStopNode\",\"attrMap\",\"attrVal\",\"lastIndexOf\",\"jArray\",\"entityRegex\",\"parseEntityExp\",\"exp\",\"regx\",\"Error\",\"hasBody\",\"comment\",\"removeNSPrefix\",\"parseTagValue\",\"parseAttributeValue\",\"trimValues\",\"numberParseOptions\",\"alwaysCreateTextNode\",\"htmlEntities\",\"ignoreDeclaration\",\"ignorePiTags\",\"buildOptions\",\"xmlNode\",\"readDocType\",\"toNumber\",\"addExternalEntities\",\"externalEntities\",\"entKeys\",\"ent\",\"lastEntities\",\"parseTextData\",\"dontTrim\",\"hasAttributes\",\"isLeafNode\",\"escapeEntities\",\"parseValue\",\"resolveNameSpace\",\"prefix\",\"charAt\",\"attrsRegx\",\"buildAttributesMap\",\"attrs\",\"oldVal\",\"aName\",\"newVal\",\"attrCollection\",\"parseXml\",\"xmlObj\",\"currentNode\",\"textData\",\"closeIndex\",\"findClosingIndex\",\"colonIndex\",\"saveTextToParentTag\",\"tagsNodeStack\",\"tagData\",\"readTagExp\",\"childNode\",\"add\",\"tagExp\",\"attrExpPresent\",\"addChild\",\"endIndex\",\"docTypeEntities\",\"lastTag\",\"isItStopNode\",\"tagContent\",\"readStopNodeData\",\"child\",\"entityName\",\"ampEntity\",\"currentTagName\",\"allNodesExp\",\"stopNodePath\",\"stopNodeExp\",\"errMsg\",\"closingIndex\",\"closingChar\",\"attrBoundary\",\"ch\",\"data\",\"tagExpWithClosingIndex\",\"separatorIndex\",\"openTagCount\",\"shouldParse\",\"OrderedObjParser\",\"prettify\",\"parse\",\"validationOption\",\"toString\",\"orderedObjParser\",\"orderedResult\",\"addEntity\",\"compress\",\"text\",\"compressedObj\",\"newJpath\",\"property\",\"isLeaf\",\"isLeafTag\",\"assignAttributes\",\"jpath\",\"atrrName\",\"propCount\",\"node\",\"XmlNode\",\"__webpack_module_cache__\",\"__webpack_exports__\",\"__webpack_require__\",\"moduleId\",\"cachedModule\",\"__webpack_modules__\"],\"sourceRoot\":\"\"}",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/fxparser.min.js||lib/fxparser.min.js": [
          "File: lib/fxparser.min.js -> lib/fxparser.min.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: var XMLParser;(()=>{var t={807:t=>{const e=/^[-+]?0x[a-fA-F0-9]+$/,r=/^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;!Number.parseInt&&window.parseInt&&(Number.parseInt=window.parseInt),!Number.parseFloat&&window.parseFloat&&(Number.parseFloat=window.parseFloat);const i={hex:!0,leadingZeros:!0,decimalPoint:\".\",eNotation:!0};t.exports=function(t,n={}){if(n=Object.assign({},i,n),!t||\"string\"!=typeof t)return t;let a=t.trim();if(void 0!==n.skipLike&&n.skipLike.test(a))return t;if(n.hex&&e.test(a))return Number.parseInt(a,16);{const e=r.exec(a);if(e){const r=e[1],i=e[2];let o=(s=e[3])&&-1!==s.indexOf(\".\")?(\".\"===(s=s.replace(/0+$/,\"\"))?s=\"0\":\".\"===s[0]?s=\"0\"+s:\".\"===s[s.length-1]&&(s=s.substr(0,s.length-1)),s):s;const l=e[4]||e[6];if(!n.leadingZeros&&i.length>0&&r&&\".\"!==a[2])return t;if(!n.leadingZeros&&i.length>0&&!r&&\".\"!==a[1])return t;{const e=Number(a),s=\"\"+e;return-1!==s.search(/[eE]/)||l?n.eNotation?e:t:-1!==a.indexOf(\".\")?\"0\"===s&&\"\"===o||s===o||r&&s===\"-\"+o?e:t:i?o===s||r+o===s?e:t:a===s||a===r+s?e:t}}return t}var s}},839:(t,e)=>{\"use strict\";var r=\"[:A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*\",i=new RegExp(\"^\"+r+\"$\");e.isExist=function(t){return void 0!==t},e.isEmptyObject=function(t){return 0===Object.keys(t).length},e.merge=function(t,e,r){if(e)for(var i=Object.keys(e),n=i.length,a=0;a<n;a++)t[i[a]]=\"strict\"===r?[e[i[a]]]:e[i[a]]},e.getValue=function(t){return e.isExist(t)?t:\"\"},e.isName=function(t){return!(null==i.exec(t))},e.getAllMatches=function(t,e){for(var r=[],i=e.exec(t);i;){var n=[];n.startIndex=e.lastIndex-i[0].length;for(var a=i.length,s=0;s<a;s++)n.push(i[s]);r.push(n),i=e.exec(t)}return r},e.nameRegexp=r},239:(t,e,r)=>{\"use strict\";var i=r(839),n={allowBooleanAttributes:!1,unpairedTags:[]};function a(t){return\" \"===t||\"\\t\"===t||\"\\n\"===t||\"\\r\"===t}function s(t,e){for(var r=e;e<t.length;e++)if(\"?\"!=t[e]&&\" \"!=t[e]);else{var i=t.substr(r,e-r);if(e>5&&\"xml\"===i)return h(\"InvalidXml\",\"XML declaration allowed only at the start of the document.\",p(t,e));if(\"?\"==t[e]&&\">\"==t[e+1]){e++;break}}return e}function o(t,e){if(t.length>e+5&&\"-\"===t[e+1]&&\"-\"===t[e+2]){for(e+=3;e<t.length;e++)if(\"-\"===t[e]&&\"-\"===t[e+1]&&\">\"===t[e+2]){e+=2;break}}else if(t.length>e+8&&\"D\"===t[e+1]&&\"O\"===t[e+2]&&\"C\"===t[e+3]&&\"T\"===t[e+4]&&\"Y\"===t[e+5]&&\"P\"===t[e+6]&&\"E\"===t[e+7]){var r=1;for(e+=8;e<t.length;e++)if(\"<\"===t[e])r++;else if(\">\"===t[e]&&0==--r)break}else if(t.length>e+9&&\"[\"===t[e+1]&&\"C\"===t[e+2]&&\"D\"===t[e+3]&&\"A\"===t[e+4]&&\"T\"===t[e+5]&&\"A\"===t[e+6]&&\"[\"===t[e+7])for(e+=8;e<t.length;e++)if(\"]\"===t[e]&&\"]\"===t[e+1]&&\">\"===t[e+2]){e+=2;break}return e}function l(t,e){for(var r=\"\",i=\"\",n=!1;e<t.length;e++){if('\"'===t[e]||\"'\"===t[e])\"\"===i?i=t[e]:i!==t[e]||(i=\"\");else if(\">\"===t[e]&&\"\"===i){n=!0;break}r+=t[e]}return\"\"===i&&{value:r,index:e,tagClosed:n}}e.validate=function(t,e){e=Object.assign({},n,e);var r,u=[],d=!1,c=!1;\"\\ufeff\"===t[0]&&(t=t.substr(1));for(var v=0;v<t.length;v++)if(\"<\"===t[v]&&\"?\"===t[v+1]){if((v=s(t,v+=2)).err)return v}else{if(\"<\"!==t[v]){if(a(t[v]))continue;return h(\"InvalidChar\",\"char '\"+t[v]+\"' is not expected.\",p(t,v))}var x=v;if(\"!\"===t[++v]){v=o(t,v);continue}var m=!1;\"/\"===t[v]&&(m=!0,v++);for(var N=\"\";v<t.length&&\">\"!==t[v]&&\" \"!==t[v]&&\"\\t\"!==t[v]&&\"\\n\"!==t[v]&&\"\\r\"!==t[v];v++)N+=t[v];if(\"/\"===(N=N.trim())[N.length-1]&&(N=N.substring(0,N.length-1),v--),r=N,!i.isName(r))return h(\"InvalidTag\",0===N.trim().length?\"Invalid space after '<'.\":\"Tag '\"+N+\"' is an invalid name.\",p(t,v));var b=l(t,v);if(!1===b)return h(\"InvalidAttr\",\"Attributes for '\"+N+\"' have open quote.\",p(t,v));var E=b.value;if(v=b.index,\"/\"===E[E.length-1]){var T=v-E.length,w=f(E=E.substring(0,E.length-1),e);if(!0!==w)return h(w.err.code,w.err.msg,p(t,T+w.err.line));d=!0}else if(m){if(!b.tagClosed)return h(\"InvalidTag\",\"Closing tag '\"+N+\"' doesn't have proper closing.\",p(t,v));if(E.trim().length>0)return h(\"InvalidTag\",\"Closing tag '\"+N+\"' can't have attributes or invalid starting.\",p(t,x));var y=u.pop();if(N!==y.tagName){var A=p(t,y.tagStartPos);return h(\"InvalidTag\",\"Expected closing tag '\"+y.tagName+\"' (opened in line \"+A.line+\", col \"+A.col+\") instead of closing tag '\"+N+\"'.\",p(t,x))}0==u.length&&(c=!0)}else{var O=f(E,e);if(!0!==O)return h(O.err.code,O.err.msg,p(t,v-E.length+O.err.line));if(!0===c)return h(\"InvalidXml\",\"Multiple possible root nodes found.\",p(t,v));-1!==e.unpairedTags.indexOf(N)||u.push({tagName:N,tagStartPos:x}),d=!0}for(v++;v<t.length;v++)if(\"<\"===t[v]){if(\"!\"===t[v+1]){v=o(t,++v);continue}if(\"?\"!==t[v+1])break;if((v=s(t,++v)).err)return v}else if(\"&\"===t[v]){var F=g(t,v);if(-1==F)return h(\"InvalidChar\",\"char '&' is not expected.\",p(t,v));v=F}else if(!0===c&&!a(t[v]))return h(\"InvalidXml\",\"Extra text at the end\",p(t,v));\"<\"===t[v]&&v--}return d?1==u.length?h(\"InvalidTag\",\"Unclosed tag '\"+u[0].tagName+\"'.\",p(t,u[0].tagStartPos)):!(u.length>0)||h(\"InvalidXml\",\"Invalid '\"+JSON.stringify(u.map((function(t){return t.tagName})),null,4).replace(/\\r?\\n/g,\"\")+\"' found.\",{line:1,col:1}):h(\"InvalidXml\",\"Start tag expected.\",1)};var u=new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\",\"g\");function f(t,e){for(var r=i.getAllMatches(t,u),n={},a=0;a<r.length;a++){if(0===r[a][1].length)return h(\"InvalidAttr\",\"Attribute '\"+r[a][2]+\"' has no space in starting.\",c(r[a]));if(void 0!==r[a][3]&&void 0===r[a][4])return h(\"InvalidAttr\",\"Attribute '\"+r[a][2]+\"' is without value.\",c(r[a]));if(void 0===r[a][3]&&!e.allowBooleanAttributes)return h(\"InvalidAttr\",\"boolean attribute '\"+r[a][2]+\"' is not allowed.\",c(r[a]));var s=r[a][2];if(!d(s))return h(\"InvalidAttr\",\"Attribute '\"+s+\"' is an invalid name.\",c(r[a]));if(n.hasOwnProperty(s))return h(\"InvalidAttr\",\"Attribute '\"+s+\"' is repeated.\",c(r[a]));n[s]=1}return!0}function g(t,e){if(\";\"===t[++e])return-1;if(\"#\"===t[e])return function(t,e){var r=/\\d/;for(\"x\"===t[e]&&(e++,r=/[\\da-fA-F]/);e<t.length;e++){if(\";\"===t[e])return e;if(!t[e].match(r))break}return-1}(t,++e);for(var r=0;e<t.length;e++,r++)if(!(t[e].match(/\\w/)&&r<20)){if(\";\"===t[e])break;return-1}return e}function h(t,e,r){return{err:{code:t,msg:e,line:r.line||r,col:r.col}}}function d(t){return i.isName(t)}function p(t,e){var r=t.substring(0,e).split(/\\r?\\n/);return{line:r.length,col:r[r.length-1].length+1}}function c(t){return t.startIndex+t[1].length}},106:t=>{var e=RegExp(\"^\\\\s([a-zA-z0-0]+)[ \\t](['\\\"])([^&]+)\\\\2\");function r(t,r){var i=e.exec(t);i&&(r[i[1]]={regx:RegExp(\"&\"+i[1]+\";\",\"g\"),val:i[3]})}t.exports=function(t,e){var i={};if(\"O\"!==t[e+3]||\"C\"!==t[e+4]||\"T\"!==t[e+5]||\"Y\"!==t[e+6]||\"P\"!==t[e+7]||\"E\"!==t[e+8])throw new Error(\"Invalid Tag instead of DOCTYPE\");e+=9;for(var n=1,a=!1,s=!1,o=!1,l=\"\";e<t.length;e++)if(\"<\"===t[e]){if(a&&\"!\"===t[e+1]&&\"E\"===t[e+2]&&\"N\"===t[e+3]&&\"T\"===t[e+4]&&\"I\"===t[e+5]&&\"T\"===t[e+6]&&\"Y\"===t[e+7])e+=7,s=!0;else if(a&&\"!\"===t[e+1]&&\"E\"===t[e+2]&&\"L\"===t[e+3]&&\"E\"===t[e+4]&&\"M\"===t[e+5]&&\"E\"===t[e+6]&&\"N\"===t[e+7]&&\"T\"===t[e+8])e+=8;else if(a&&\"!\"===t[e+1]&&\"A\"===t[e+2]&&\"T\"===t[e+3]&&\"T\"===t[e+4]&&\"L\"===t[e+5]&&\"I\"===t[e+6]&&\"S\"===t[e+7]&&\"T\"===t[e+8])e+=8;else if(a&&\"!\"===t[e+1]&&\"N\"===t[e+2]&&\"O\"===t[e+3]&&\"T\"===t[e+4]&&\"A\"===t[e+5]&&\"T\"===t[e+6]&&\"I\"===t[e+7]&&\"O\"===t[e+8]&&\"N\"===t[e+9])e+=9;else{if(\"!\"!==t[e+1]||\"-\"!==t[e+2]||\"-\"!==t[e+3])throw new Error(\"Invalid DOCTYPE\");o=!0}n++,l=\"\"}else if(\">\"===t[e]){if(o){if(\"-\"!==t[e-1]||\"-\"!==t[e-2])throw new Error(\"Invalid XML comment in DOCTYPE\");o=!1}else s&&(r(l,i),s=!1);if(0==--n)break}else\"[\"===t[e]?a=!0:l+=t[e];if(0!==n)throw new Error(\"Unclosed DOCTYPE\");return{entities:i,i:e}}},348:(t,e)=>{var r={preserveOrder:!1,attributeNamePrefix:\"@_\",attributesGroupName:!1,textNodeName:\"#text\",ignoreAttributes:!0,removeNSPrefix:!1,allowBooleanAttributes:!1,parseTagValue:!0,parseAttributeValue:!1,trimValues:!0,cdataPropName:!1,numberParseOptions:{hex:!0,leadingZeros:!0},tagValueProcessor:function(t,e){return e},attributeValueProcessor:function(t,e){return e},stopNodes:[],alwaysCreateTextNode:!1,isArray:function(){return!1},commentPropName:!1,unpairedTags:[],processEntities:!0,htmlEntities:!1,ignoreDeclaration:!1,ignorePiTags:!1,transformTagName:!1};e.buildOptions=function(t){return Object.assign({},r,t)},e.defaultOptions=r},498:(t,e,r)=>{\"use strict\";var i=r(839),n=r(876),a=r(106),s=r(807);function o(t){for(var e=Object.keys(t),r=0;r<e.length;r++){var i=e[r];this.lastEntities[i]={regex:new RegExp(\"&\"+i+\";\",\"g\"),val:t[i]}}}function l(t,e,r,i,n,a,s){if(void 0!==t&&(this.options.trimValues&&!i&&(t=t.trim()),t.length>0)){s||(t=this.replaceEntitiesValue(t));var o=this.options.tagValueProcessor(e,t,r,n,a);return null==o?t:typeof o!=typeof t||o!==t?o:this.options.trimValues||t.trim()===t?N(t,this.options.parseTagValue,this.options.numberParseOptions):t}}function u(t){if(this.options.removeNSPrefix){var e=t.split(\":\"),r=\"/\"===t.charAt(0)?\"/\":\"\";if(\"xmlns\"===e[0])return\"\";2===e.length&&(t=r+e[1])}return t}\"<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)\".replace(/NAME/g,i.nameRegexp);var f=new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])([\\\\s\\\\S]*?)\\\\3)?\",\"gm\");function g(t,e){if(!this.options.ignoreAttributes&&\"string\"==typeof t){for(var r=i.getAllMatches(t,f),n=r.length,a={},s=0;s<n;s++){var o=this.resolveNameSpace(r[s][1]),l=r[s][4],u=this.options.attributeNamePrefix+o;if(o.length)if(void 0!==l){this.options.trimValues&&(l=l.trim()),l=this.replaceEntitiesValue(l);var g=this.options.attributeValueProcessor(o,l,e);a[u]=null==g?l:typeof g!=typeof l||g!==l?g:N(l,this.options.parseAttributeValue,this.options.numberParseOptions)}else this.options.allowBooleanAttributes&&(a[u]=!0)}if(!Object.keys(a).length)return;if(this.options.attributesGroupName){var h={};return h[this.options.attributesGroupName]=a,h}return a}}var h=function(t){t=t.replace(/\\r\\n?/g,\"\\n\");for(var e=new n(\"!xml\"),r=e,i=\"\",s=\"\",o=0;o<t.length;o++)if(\"<\"===t[o])if(\"/\"===t[o+1]){var l=v(t,\">\",o,\"Closing Tag is not closed.\"),u=t.substring(o+2,l).trim();if(this.options.removeNSPrefix){var f=u.indexOf(\":\");-1!==f&&(u=u.substr(f+1))}this.options.transformTagName&&(u=this.options.transformTagName(u)),r&&(i=this.saveTextToParentTag(i,r,s)),s=s.substr(0,s.lastIndexOf(\".\")),r=this.tagsNodeStack.pop(),i=\"\",o=l}else if(\"?\"===t[o+1]){var g=x(t,o,!1,\"?>\");if(!g)throw new Error(\"Pi Tag is not closed.\");if(i=this.saveTextToParentTag(i,r,s),this.options.ignoreDeclaration&&\"?xml\"===g.tagName||this.options.ignorePiTags);else{var h=new n(g.tagName);h.add(this.options.textNodeName,\"\"),g.tagName!==g.tagExp&&g.attrExpPresent&&(h[\":@\"]=this.buildAttributesMap(g.tagExp,s)),r.addChild(h)}o=g.closeIndex+1}else if(\"!--\"===t.substr(o+1,3)){var d=v(t,\"--\\x3e\",o+4,\"Comment is not closed.\");if(this.options.commentPropName){var p,c=t.substring(o+4,d-2);i=this.saveTextToParentTag(i,r,s),r.add(this.options.commentPropName,[(p={},p[this.options.textNodeName]=c,p)])}o=d}else if(\"!D\"===t.substr(o+1,2)){var m=a(t,o);this.docTypeEntities=m.entities,o=m.i}else if(\"![\"===t.substr(o+1,2)){var N=v(t,\"]]>\",o,\"CDATA is not closed.\")-2,b=t.substring(o+9,N);if(i=this.saveTextToParentTag(i,r,s),this.options.cdataPropName){var E;r.add(this.options.cdataPropName,[(E={},E[this.options.textNodeName]=b,E)])}else{var T=this.parseTextData(b,r.tagname,s,!0,!1,!0);null==T&&(T=\"\"),r.add(this.options.textNodeName,T)}o=N+2}else{var w=x(t,o,this.options.removeNSPrefix),y=w.tagName,A=w.tagExp,O=w.attrExpPresent,F=w.closeIndex;this.options.transformTagName&&(y=this.options.transformTagName(y)),r&&i&&\"!xml\"!==r.tagname&&(i=this.saveTextToParentTag(i,r,s,!1)),y!==e.tagname&&(s+=s?\".\"+y:y);var I=r;if(I&&-1!==this.options.unpairedTags.indexOf(I.tagname)&&(r=this.tagsNodeStack.pop()),this.isItStopNode(this.options.stopNodes,s,y)){var P=\"\";if(A.length>0&&A.lastIndexOf(\"/\")===A.length-1)o=w.closeIndex;else if(-1!==this.options.unpairedTags.indexOf(y))o=w.closeIndex;else{var C=this.readStopNodeData(t,y,F+1);if(!C)throw new Error(\"Unexpected end of \"+y);o=C.i,P=C.tagContent}var D=new n(y);y!==A&&O&&(D[\":@\"]=this.buildAttributesMap(A,s)),P&&(P=this.parseTextData(P,y,s,!0,O,!0,!0)),s=s.substr(0,s.lastIndexOf(\".\")),D.add(this.options.textNodeName,P),r.addChild(D)}else{if(A.length>0&&A.lastIndexOf(\"/\")===A.length-1){A=\"/\"===y[y.length-1]?y=y.substr(0,y.length-1):A.substr(0,A.length-1),this.options.transformTagName&&(y=this.options.transformTagName(y));var k=new n(y);y!==A&&O&&(k[\":@\"]=this.buildAttributesMap(A,s)),s=s.substr(0,s.lastIndexOf(\".\")),r.addChild(k)}else{var S=new n(y);this.tagsNodeStack.push(r),y!==A&&O&&(S[\":@\"]=this.buildAttributesMap(A,s)),r.addChild(S),r=S}i=\"\",o=F}}else i+=t[o];return e.child},d=function(t){if(this.options.processEntities){for(var e in this.docTypeEntities){var r=this.docTypeEntities[e];t=t.replace(r.regx,r.val)}for(var i in this.lastEntities){var n=this.lastEntities[i];t=t.replace(n.regex,n.val)}if(this.options.htmlEntities)for(var a in this.htmlEntities){var s=this.htmlEntities[a];t=t.replace(s.regex,s.val)}t=t.replace(this.ampEntity.regex,this.ampEntity.val)}return t};function p(t,e,r,i){return t&&(void 0===i&&(i=0===Object.keys(e.child).length),void 0!==(t=this.parseTextData(t,e.tagname,r,!1,!!e[\":@\"]&&0!==Object.keys(e[\":@\"]).length,i))&&\"\"!==t&&e.add(this.options.textNodeName,t),t=\"\"),t}function c(t,e,r){var i=\"*.\"+r;for(var n in t){var a=t[n];if(i===a||e===a)return!0}return!1}function v(t,e,r,i){var n=t.indexOf(e,r);if(-1===n)throw new Error(i);return n+e.length-1}function x(t,e,r,i){void 0===i&&(i=\">\");var n=function(t,e,r){var i;void 0===r&&(r=\">\");for(var n=\"\",a=e;a<t.length;a++){var s=t[a];if(i)s===i&&(i=\"\");else if('\"'===s||\"'\"===s)i=s;else if(s===r[0]){if(!r[1])return{data:n,index:a};if(t[a+1]===r[1])return{data:n,index:a}}else\"\\t\"===s&&(s=\" \");n+=s}}(t,e+1,i);if(n){var a=n.data,s=n.index,o=a.search(/\\s/),l=a,u=!0;if(-1!==o&&(l=a.substr(0,o).replace(/\\s\\s*$/,\"\"),a=a.substr(o+1)),r){var f=l.indexOf(\":\");-1!==f&&(u=(l=l.substr(f+1))!==n.data.substr(f+1))}return{tagName:l,tagExp:a,closeIndex:s,attrExpPresent:u}}}function m(t,e,r){for(var i=r,n=1;r<t.length;r++)if(\"<\"===t[r])if(\"/\"===t[r+1]){var a=v(t,\">\",r,e+\" is not closed\");if(t.substring(r+2,a).trim()===e&&0==--n)return{tagContent:t.substring(i,r),i:a};r=a}else if(\"?\"===t[r+1])r=v(t,\"?>\",r+1,\"StopNode is not closed.\");else if(\"!--\"===t.substr(r+1,3))r=v(t,\"--\\x3e\",r+3,\"StopNode is not closed.\");else if(\"![\"===t.substr(r+1,2))r=v(t,\"]]>\",r,\"StopNode is not closed.\")-2;else{var s=x(t,r,\">\");s&&((s&&s.tagName)===e&&\"/\"!==s.tagExp[s.tagExp.length-1]&&n++,r=s.closeIndex)}}function N(t,e,r){if(e&&\"string\"==typeof t){var n=t.trim();return\"true\"===n||\"false\"!==n&&s(t,r)}return i.isExist(t)?t:\"\"}t.exports=function(t){this.options=t,this.currentNode=null,this.tagsNodeStack=[],this.docTypeEntities={},this.lastEntities={apos:{regex:/&(apos|#39|#x27);/g,val:\"'\"},gt:{regex:/&(gt|#62|#x3E);/g,val:\">\"},lt:{regex:/&(lt|#60|#x3C);/g,val:\"<\"},quot:{regex:/&(quot|#34|#x22);/g,val:'\"'}},this.ampEntity={regex:/&(amp|#38|#x26);/g,val:\"&\"},this.htmlEntities={space:{regex:/&(nbsp|#160);/g,val:\" \"},cent:{regex:/&(cent|#162);/g,val:\"\u00a2\"},pound:{regex:/&(pound|#163);/g,val:\"\u00a3\"},yen:{regex:/&(yen|#165);/g,val:\"\u00a5\"},euro:{regex:/&(euro|#8364);/g,val:\"\u20ac\"},copyright:{regex:/&(copy|#169);/g,val:\"\u00a9\"},reg:{regex:/&(reg|#174);/g,val:\"\u00ae\"},inr:{regex:/&(inr|#8377);/g,val:\"\u20b9\"}},this.addExternalEntities=o,this.parseXml=h,this.parseTextData=l,this.resolveNameSpace=u,this.buildAttributesMap=g,this.isItStopNode=c,this.replaceEntitiesValue=d,this.readStopNodeData=m,this.saveTextToParentTag=p}},870:(t,e,r)=>{var i=r(348).buildOptions,n=r(498),a=r(400).prettify,s=r(239),o=function(){function t(t){this.externalEntities={},this.options=i(t)}var e=t.prototype;return e.parse=function(t,e){if(\"string\"==typeof t);else{if(!t.toString)throw new Error(\"XML data is accepted in String or Bytes[] form.\");t=t.toString()}if(e){!0===e&&(e={});var r=s.validate(t,e);if(!0!==r)throw Error(r.err.msg+\":\"+r.err.line+\":\"+r.err.col)}var i=new n(this.options);i.addExternalEntities(this.externalEntities);var o=i.parseXml(t);return this.options.preserveOrder||void 0===o?o:a(o,this.options)},e.addEntity=function(t,e){if(-1!==e.indexOf(\"&\"))throw new Error(\"Entity value can't have '&'\");if(-1!==t.indexOf(\"&\")||-1!==t.indexOf(\";\"))throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\");if(\"&\"===e)throw new Error(\"An entity with value '&' is not permitted\");this.externalEntities[t]=e},t}();t.exports=o},400:(t,e)=>{\"use strict\";function r(t,e,s){for(var o,l={},u=0;u<t.length;u++){var f,g=t[u],h=i(g);if(f=void 0===s?h:s+\".\"+h,h===e.textNodeName)void 0===o?o=g[h]:o+=\"\"+g[h];else{if(void 0===h)continue;if(g[h]){var d=r(g[h],e,f),p=a(d,e);g[\":@\"]?n(d,g[\":@\"],f,e):1!==Object.keys(d).length||void 0===d[e.textNodeName]||e.alwaysCreateTextNode?0===Object.keys(d).length&&(e.alwaysCreateTextNode?d[e.textNodeName]=\"\":d=\"\"):d=d[e.textNodeName],void 0!==l[h]&&l.hasOwnProperty(h)?(Array.isArray(l[h])||(l[h]=[l[h]]),l[h].push(d)):e.isArray(h,f,p)?l[h]=[d]:l[h]=d}}}return\"string\"==typeof o?o.length>0&&(l[e.textNodeName]=o):void 0!==o&&(l[e.textNodeName]=o),l}function i(t){for(var e=Object.keys(t),r=0;r<e.length;r++){var i=e[r];if(\":@\"!==i)return i}}function n(t,e,r,i){if(e)for(var n=Object.keys(e),a=n.length,s=0;s<a;s++){var o=n[s];i.isArray(o,r+\".\"+o,!0,!0)?t[o]=[e[o]]:t[o]=e[o]}}function a(t,e){var r=Object.keys(t).length;return!!(0===r||1===r&&t[e.textNodeName])}e.prettify=function(t,e){return r(t,e)}},876:t=>{\"use strict\";var e=function(){function t(t){this.tagname=t,this.child=[],this[\":@\"]={}}var e=t.prototype;return e.add=function(t,e){var r;this.child.push(((r={})[t]=e,r))},e.addChild=function(t){var e,r;t[\":@\"]&&Object.keys(t[\":@\"]).length>0?this.child.push(((e={})[t.tagname]=t.child,e[\":@\"]=t[\":@\"],e)):this.child.push(((r={})[t.tagname]=t.child,r))},t}();t.exports=e}},e={},r=function r(i){var n=e[i];if(void 0!==n)return n.exports;var a=e[i]={exports:{}};return t[i](a,a.exports,r),a.exports}(870);XMLParser=r})();",
          "",
          "[Added Lines]",
          "1: var XMLParser;(()=>{var t={807:t=>{const e=/^[-+]?0x[a-fA-F0-9]+$/,r=/^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;!Number.parseInt&&window.parseInt&&(Number.parseInt=window.parseInt),!Number.parseFloat&&window.parseFloat&&(Number.parseFloat=window.parseFloat);const i={hex:!0,leadingZeros:!0,decimalPoint:\".\",eNotation:!0};t.exports=function(t,n={}){if(n=Object.assign({},i,n),!t||\"string\"!=typeof t)return t;let a=t.trim();if(void 0!==n.skipLike&&n.skipLike.test(a))return t;if(n.hex&&e.test(a))return Number.parseInt(a,16);{const e=r.exec(a);if(e){const r=e[1],i=e[2];let o=(s=e[3])&&-1!==s.indexOf(\".\")?(\".\"===(s=s.replace(/0+$/,\"\"))?s=\"0\":\".\"===s[0]?s=\"0\"+s:\".\"===s[s.length-1]&&(s=s.substr(0,s.length-1)),s):s;const l=e[4]||e[6];if(!n.leadingZeros&&i.length>0&&r&&\".\"!==a[2])return t;if(!n.leadingZeros&&i.length>0&&!r&&\".\"!==a[1])return t;{const e=Number(a),s=\"\"+e;return-1!==s.search(/[eE]/)||l?n.eNotation?e:t:-1!==a.indexOf(\".\")?\"0\"===s&&\"\"===o||s===o||r&&s===\"-\"+o?e:t:i?o===s||r+o===s?e:t:a===s||a===r+s?e:t}}return t}var s}},839:(t,e)=>{\"use strict\";var r=\"[:A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*\",i=new RegExp(\"^\"+r+\"$\");e.isExist=function(t){return void 0!==t},e.isEmptyObject=function(t){return 0===Object.keys(t).length},e.merge=function(t,e,r){if(e)for(var i=Object.keys(e),n=i.length,a=0;a<n;a++)t[i[a]]=\"strict\"===r?[e[i[a]]]:e[i[a]]},e.getValue=function(t){return e.isExist(t)?t:\"\"},e.isName=function(t){return!(null==i.exec(t))},e.getAllMatches=function(t,e){for(var r=[],i=e.exec(t);i;){var n=[];n.startIndex=e.lastIndex-i[0].length;for(var a=i.length,s=0;s<a;s++)n.push(i[s]);r.push(n),i=e.exec(t)}return r},e.nameRegexp=r},239:(t,e,r)=>{\"use strict\";var i=r(839),n={allowBooleanAttributes:!1,unpairedTags:[]};function a(t){return\" \"===t||\"\\t\"===t||\"\\n\"===t||\"\\r\"===t}function s(t,e){for(var r=e;e<t.length;e++)if(\"?\"!=t[e]&&\" \"!=t[e]);else{var i=t.substr(r,e-r);if(e>5&&\"xml\"===i)return h(\"InvalidXml\",\"XML declaration allowed only at the start of the document.\",p(t,e));if(\"?\"==t[e]&&\">\"==t[e+1]){e++;break}}return e}function o(t,e){if(t.length>e+5&&\"-\"===t[e+1]&&\"-\"===t[e+2]){for(e+=3;e<t.length;e++)if(\"-\"===t[e]&&\"-\"===t[e+1]&&\">\"===t[e+2]){e+=2;break}}else if(t.length>e+8&&\"D\"===t[e+1]&&\"O\"===t[e+2]&&\"C\"===t[e+3]&&\"T\"===t[e+4]&&\"Y\"===t[e+5]&&\"P\"===t[e+6]&&\"E\"===t[e+7]){var r=1;for(e+=8;e<t.length;e++)if(\"<\"===t[e])r++;else if(\">\"===t[e]&&0==--r)break}else if(t.length>e+9&&\"[\"===t[e+1]&&\"C\"===t[e+2]&&\"D\"===t[e+3]&&\"A\"===t[e+4]&&\"T\"===t[e+5]&&\"A\"===t[e+6]&&\"[\"===t[e+7])for(e+=8;e<t.length;e++)if(\"]\"===t[e]&&\"]\"===t[e+1]&&\">\"===t[e+2]){e+=2;break}return e}function l(t,e){for(var r=\"\",i=\"\",n=!1;e<t.length;e++){if('\"'===t[e]||\"'\"===t[e])\"\"===i?i=t[e]:i!==t[e]||(i=\"\");else if(\">\"===t[e]&&\"\"===i){n=!0;break}r+=t[e]}return\"\"===i&&{value:r,index:e,tagClosed:n}}e.validate=function(t,e){e=Object.assign({},n,e);var r,u=[],d=!1,c=!1;\"\\ufeff\"===t[0]&&(t=t.substr(1));for(var v=0;v<t.length;v++)if(\"<\"===t[v]&&\"?\"===t[v+1]){if((v=s(t,v+=2)).err)return v}else{if(\"<\"!==t[v]){if(a(t[v]))continue;return h(\"InvalidChar\",\"char '\"+t[v]+\"' is not expected.\",p(t,v))}var x=v;if(\"!\"===t[++v]){v=o(t,v);continue}var m=!1;\"/\"===t[v]&&(m=!0,v++);for(var N=\"\";v<t.length&&\">\"!==t[v]&&\" \"!==t[v]&&\"\\t\"!==t[v]&&\"\\n\"!==t[v]&&\"\\r\"!==t[v];v++)N+=t[v];if(\"/\"===(N=N.trim())[N.length-1]&&(N=N.substring(0,N.length-1),v--),r=N,!i.isName(r))return h(\"InvalidTag\",0===N.trim().length?\"Invalid space after '<'.\":\"Tag '\"+N+\"' is an invalid name.\",p(t,v));var b=l(t,v);if(!1===b)return h(\"InvalidAttr\",\"Attributes for '\"+N+\"' have open quote.\",p(t,v));var E=b.value;if(v=b.index,\"/\"===E[E.length-1]){var T=v-E.length,w=f(E=E.substring(0,E.length-1),e);if(!0!==w)return h(w.err.code,w.err.msg,p(t,T+w.err.line));d=!0}else if(m){if(!b.tagClosed)return h(\"InvalidTag\",\"Closing tag '\"+N+\"' doesn't have proper closing.\",p(t,v));if(E.trim().length>0)return h(\"InvalidTag\",\"Closing tag '\"+N+\"' can't have attributes or invalid starting.\",p(t,x));var A=u.pop();if(N!==A.tagName){var y=p(t,A.tagStartPos);return h(\"InvalidTag\",\"Expected closing tag '\"+A.tagName+\"' (opened in line \"+y.line+\", col \"+y.col+\") instead of closing tag '\"+N+\"'.\",p(t,x))}0==u.length&&(c=!0)}else{var O=f(E,e);if(!0!==O)return h(O.err.code,O.err.msg,p(t,v-E.length+O.err.line));if(!0===c)return h(\"InvalidXml\",\"Multiple possible root nodes found.\",p(t,v));-1!==e.unpairedTags.indexOf(N)||u.push({tagName:N,tagStartPos:x}),d=!0}for(v++;v<t.length;v++)if(\"<\"===t[v]){if(\"!\"===t[v+1]){v=o(t,++v);continue}if(\"?\"!==t[v+1])break;if((v=s(t,++v)).err)return v}else if(\"&\"===t[v]){var F=g(t,v);if(-1==F)return h(\"InvalidChar\",\"char '&' is not expected.\",p(t,v));v=F}else if(!0===c&&!a(t[v]))return h(\"InvalidXml\",\"Extra text at the end\",p(t,v));\"<\"===t[v]&&v--}return d?1==u.length?h(\"InvalidTag\",\"Unclosed tag '\"+u[0].tagName+\"'.\",p(t,u[0].tagStartPos)):!(u.length>0)||h(\"InvalidXml\",\"Invalid '\"+JSON.stringify(u.map((function(t){return t.tagName})),null,4).replace(/\\r?\\n/g,\"\")+\"' found.\",{line:1,col:1}):h(\"InvalidXml\",\"Start tag expected.\",1)};var u=new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\",\"g\");function f(t,e){for(var r=i.getAllMatches(t,u),n={},a=0;a<r.length;a++){if(0===r[a][1].length)return h(\"InvalidAttr\",\"Attribute '\"+r[a][2]+\"' has no space in starting.\",c(r[a]));if(void 0!==r[a][3]&&void 0===r[a][4])return h(\"InvalidAttr\",\"Attribute '\"+r[a][2]+\"' is without value.\",c(r[a]));if(void 0===r[a][3]&&!e.allowBooleanAttributes)return h(\"InvalidAttr\",\"boolean attribute '\"+r[a][2]+\"' is not allowed.\",c(r[a]));var s=r[a][2];if(!d(s))return h(\"InvalidAttr\",\"Attribute '\"+s+\"' is an invalid name.\",c(r[a]));if(n.hasOwnProperty(s))return h(\"InvalidAttr\",\"Attribute '\"+s+\"' is repeated.\",c(r[a]));n[s]=1}return!0}function g(t,e){if(\";\"===t[++e])return-1;if(\"#\"===t[e])return function(t,e){var r=/\\d/;for(\"x\"===t[e]&&(e++,r=/[\\da-fA-F]/);e<t.length;e++){if(\";\"===t[e])return e;if(!t[e].match(r))break}return-1}(t,++e);for(var r=0;e<t.length;e++,r++)if(!(t[e].match(/\\w/)&&r<20)){if(\";\"===t[e])break;return-1}return e}function h(t,e,r){return{err:{code:t,msg:e,line:r.line||r,col:r.col}}}function d(t){return i.isName(t)}function p(t,e){var r=t.substring(0,e).split(/\\r?\\n/);return{line:r.length,col:r[r.length-1].length+1}}function c(t){return t.startIndex+t[1].length}},106:t=>{var e=RegExp(\"^\\\\s([a-zA-z0-0]+)[ \\t](['\\\"])([^&]+)\\\\2\");function r(t,r){var i=e.exec(t);i&&(r[i[1]]={regx:RegExp(\"&\"+i[1]+\";\",\"g\"),val:i[3]})}t.exports=function(t,e){var i={};if(\"O\"!==t[e+3]||\"C\"!==t[e+4]||\"T\"!==t[e+5]||\"Y\"!==t[e+6]||\"P\"!==t[e+7]||\"E\"!==t[e+8])throw new Error(\"Invalid Tag instead of DOCTYPE\");e+=9;for(var n=1,a=!1,s=!1,o=!1,l=\"\";e<t.length;e++)if(\"<\"===t[e]){if(a&&\"!\"===t[e+1]&&\"E\"===t[e+2]&&\"N\"===t[e+3]&&\"T\"===t[e+4]&&\"I\"===t[e+5]&&\"T\"===t[e+6]&&\"Y\"===t[e+7])e+=7,s=!0;else if(a&&\"!\"===t[e+1]&&\"E\"===t[e+2]&&\"L\"===t[e+3]&&\"E\"===t[e+4]&&\"M\"===t[e+5]&&\"E\"===t[e+6]&&\"N\"===t[e+7]&&\"T\"===t[e+8])e+=8;else if(a&&\"!\"===t[e+1]&&\"A\"===t[e+2]&&\"T\"===t[e+3]&&\"T\"===t[e+4]&&\"L\"===t[e+5]&&\"I\"===t[e+6]&&\"S\"===t[e+7]&&\"T\"===t[e+8])e+=8;else if(a&&\"!\"===t[e+1]&&\"N\"===t[e+2]&&\"O\"===t[e+3]&&\"T\"===t[e+4]&&\"A\"===t[e+5]&&\"T\"===t[e+6]&&\"I\"===t[e+7]&&\"O\"===t[e+8]&&\"N\"===t[e+9])e+=9;else{if(\"!\"!==t[e+1]||\"-\"!==t[e+2]||\"-\"!==t[e+3])throw new Error(\"Invalid DOCTYPE\");o=!0}n++,l=\"\"}else if(\">\"===t[e]){if(o){if(\"-\"!==t[e-1]||\"-\"!==t[e-2])throw new Error(\"Invalid XML comment in DOCTYPE\");o=!1}else s&&(r(l,i),s=!1);if(0==--n)break}else\"[\"===t[e]?a=!0:l+=t[e];if(0!==n)throw new Error(\"Unclosed DOCTYPE\");return{entities:i,i:e}}},348:(t,e)=>{var r={preserveOrder:!1,attributeNamePrefix:\"@_\",attributesGroupName:!1,textNodeName:\"#text\",ignoreAttributes:!0,removeNSPrefix:!1,allowBooleanAttributes:!1,parseTagValue:!0,parseAttributeValue:!1,trimValues:!0,cdataPropName:!1,numberParseOptions:{hex:!0,leadingZeros:!0},tagValueProcessor:function(t,e){return e},attributeValueProcessor:function(t,e){return e},stopNodes:[],alwaysCreateTextNode:!1,isArray:function(){return!1},commentPropName:!1,unpairedTags:[],processEntities:!0,htmlEntities:!1,ignoreDeclaration:!1,ignorePiTags:!1,transformTagName:!1,transformAttributeName:!1};e.buildOptions=function(t){return Object.assign({},r,t)},e.defaultOptions=r},498:(t,e,r)=>{\"use strict\";var i=r(839),n=r(876),a=r(106),s=r(807);function o(t){for(var e=Object.keys(t),r=0;r<e.length;r++){var i=e[r];this.lastEntities[i]={regex:new RegExp(\"&\"+i+\";\",\"g\"),val:t[i]}}}function l(t,e,r,i,n,a,s){if(void 0!==t&&(this.options.trimValues&&!i&&(t=t.trim()),t.length>0)){s||(t=this.replaceEntitiesValue(t));var o=this.options.tagValueProcessor(e,t,r,n,a);return null==o?t:typeof o!=typeof t||o!==t?o:this.options.trimValues||t.trim()===t?N(t,this.options.parseTagValue,this.options.numberParseOptions):t}}function u(t){if(this.options.removeNSPrefix){var e=t.split(\":\"),r=\"/\"===t.charAt(0)?\"/\":\"\";if(\"xmlns\"===e[0])return\"\";2===e.length&&(t=r+e[1])}return t}\"<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)\".replace(/NAME/g,i.nameRegexp);var f=new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])([\\\\s\\\\S]*?)\\\\3)?\",\"gm\");function g(t,e){if(!this.options.ignoreAttributes&&\"string\"==typeof t){for(var r=i.getAllMatches(t,f),n=r.length,a={},s=0;s<n;s++){var o=this.resolveNameSpace(r[s][1]),l=r[s][4],u=this.options.attributeNamePrefix+o;if(o.length)if(this.options.transformAttributeName&&(u=this.options.transformAttributeName(u)),void 0!==l){this.options.trimValues&&(l=l.trim()),l=this.replaceEntitiesValue(l);var g=this.options.attributeValueProcessor(o,l,e);a[u]=null==g?l:typeof g!=typeof l||g!==l?g:N(l,this.options.parseAttributeValue,this.options.numberParseOptions)}else this.options.allowBooleanAttributes&&(a[u]=!0)}if(!Object.keys(a).length)return;if(this.options.attributesGroupName){var h={};return h[this.options.attributesGroupName]=a,h}return a}}var h=function(t){t=t.replace(/\\r\\n?/g,\"\\n\");for(var e=new n(\"!xml\"),r=e,i=\"\",s=\"\",o=0;o<t.length;o++)if(\"<\"===t[o])if(\"/\"===t[o+1]){var l=v(t,\">\",o,\"Closing Tag is not closed.\"),u=t.substring(o+2,l).trim();if(this.options.removeNSPrefix){var f=u.indexOf(\":\");-1!==f&&(u=u.substr(f+1))}this.options.transformTagName&&(u=this.options.transformTagName(u)),r&&(i=this.saveTextToParentTag(i,r,s)),s=s.substr(0,s.lastIndexOf(\".\")),r=this.tagsNodeStack.pop(),i=\"\",o=l}else if(\"?\"===t[o+1]){var g=x(t,o,!1,\"?>\");if(!g)throw new Error(\"Pi Tag is not closed.\");if(i=this.saveTextToParentTag(i,r,s),this.options.ignoreDeclaration&&\"?xml\"===g.tagName||this.options.ignorePiTags);else{var h=new n(g.tagName);h.add(this.options.textNodeName,\"\"),g.tagName!==g.tagExp&&g.attrExpPresent&&(h[\":@\"]=this.buildAttributesMap(g.tagExp,s)),r.addChild(h)}o=g.closeIndex+1}else if(\"!--\"===t.substr(o+1,3)){var d=v(t,\"--\\x3e\",o+4,\"Comment is not closed.\");if(this.options.commentPropName){var p,c=t.substring(o+4,d-2);i=this.saveTextToParentTag(i,r,s),r.add(this.options.commentPropName,[(p={},p[this.options.textNodeName]=c,p)])}o=d}else if(\"!D\"===t.substr(o+1,2)){var m=a(t,o);this.docTypeEntities=m.entities,o=m.i}else if(\"![\"===t.substr(o+1,2)){var N=v(t,\"]]>\",o,\"CDATA is not closed.\")-2,b=t.substring(o+9,N);if(i=this.saveTextToParentTag(i,r,s),this.options.cdataPropName){var E;r.add(this.options.cdataPropName,[(E={},E[this.options.textNodeName]=b,E)])}else{var T=this.parseTextData(b,r.tagname,s,!0,!1,!0);null==T&&(T=\"\"),r.add(this.options.textNodeName,T)}o=N+2}else{var w=x(t,o,this.options.removeNSPrefix),A=w.tagName,y=w.tagExp,O=w.attrExpPresent,F=w.closeIndex;this.options.transformTagName&&(A=this.options.transformTagName(A)),r&&i&&\"!xml\"!==r.tagname&&(i=this.saveTextToParentTag(i,r,s,!1)),A!==e.tagname&&(s+=s?\".\"+A:A);var I=r;if(I&&-1!==this.options.unpairedTags.indexOf(I.tagname)&&(r=this.tagsNodeStack.pop()),this.isItStopNode(this.options.stopNodes,s,A)){var P=\"\";if(y.length>0&&y.lastIndexOf(\"/\")===y.length-1)o=w.closeIndex;else if(-1!==this.options.unpairedTags.indexOf(A))o=w.closeIndex;else{var C=this.readStopNodeData(t,A,F+1);if(!C)throw new Error(\"Unexpected end of \"+A);o=C.i,P=C.tagContent}var D=new n(A);A!==y&&O&&(D[\":@\"]=this.buildAttributesMap(y,s)),P&&(P=this.parseTextData(P,A,s,!0,O,!0,!0)),s=s.substr(0,s.lastIndexOf(\".\")),D.add(this.options.textNodeName,P),r.addChild(D)}else{if(y.length>0&&y.lastIndexOf(\"/\")===y.length-1){y=\"/\"===A[A.length-1]?A=A.substr(0,A.length-1):y.substr(0,y.length-1),this.options.transformTagName&&(A=this.options.transformTagName(A));var k=new n(A);A!==y&&O&&(k[\":@\"]=this.buildAttributesMap(y,s)),s=s.substr(0,s.lastIndexOf(\".\")),r.addChild(k)}else{var S=new n(A);this.tagsNodeStack.push(r),A!==y&&O&&(S[\":@\"]=this.buildAttributesMap(y,s)),r.addChild(S),r=S}i=\"\",o=F}}else i+=t[o];return e.child},d=function(t){if(this.options.processEntities){for(var e in this.docTypeEntities){var r=this.docTypeEntities[e];t=t.replace(r.regx,r.val)}for(var i in this.lastEntities){var n=this.lastEntities[i];t=t.replace(n.regex,n.val)}if(this.options.htmlEntities)for(var a in this.htmlEntities){var s=this.htmlEntities[a];t=t.replace(s.regex,s.val)}t=t.replace(this.ampEntity.regex,this.ampEntity.val)}return t};function p(t,e,r,i){return t&&(void 0===i&&(i=0===Object.keys(e.child).length),void 0!==(t=this.parseTextData(t,e.tagname,r,!1,!!e[\":@\"]&&0!==Object.keys(e[\":@\"]).length,i))&&\"\"!==t&&e.add(this.options.textNodeName,t),t=\"\"),t}function c(t,e,r){var i=\"*.\"+r;for(var n in t){var a=t[n];if(i===a||e===a)return!0}return!1}function v(t,e,r,i){var n=t.indexOf(e,r);if(-1===n)throw new Error(i);return n+e.length-1}function x(t,e,r,i){void 0===i&&(i=\">\");var n=function(t,e,r){var i;void 0===r&&(r=\">\");for(var n=\"\",a=e;a<t.length;a++){var s=t[a];if(i)s===i&&(i=\"\");else if('\"'===s||\"'\"===s)i=s;else if(s===r[0]){if(!r[1])return{data:n,index:a};if(t[a+1]===r[1])return{data:n,index:a}}else\"\\t\"===s&&(s=\" \");n+=s}}(t,e+1,i);if(n){var a=n.data,s=n.index,o=a.search(/\\s/),l=a,u=!0;if(-1!==o&&(l=a.substr(0,o).replace(/\\s\\s*$/,\"\"),a=a.substr(o+1)),r){var f=l.indexOf(\":\");-1!==f&&(u=(l=l.substr(f+1))!==n.data.substr(f+1))}return{tagName:l,tagExp:a,closeIndex:s,attrExpPresent:u}}}function m(t,e,r){for(var i=r,n=1;r<t.length;r++)if(\"<\"===t[r])if(\"/\"===t[r+1]){var a=v(t,\">\",r,e+\" is not closed\");if(t.substring(r+2,a).trim()===e&&0==--n)return{tagContent:t.substring(i,r),i:a};r=a}else if(\"?\"===t[r+1])r=v(t,\"?>\",r+1,\"StopNode is not closed.\");else if(\"!--\"===t.substr(r+1,3))r=v(t,\"--\\x3e\",r+3,\"StopNode is not closed.\");else if(\"![\"===t.substr(r+1,2))r=v(t,\"]]>\",r,\"StopNode is not closed.\")-2;else{var s=x(t,r,\">\");s&&((s&&s.tagName)===e&&\"/\"!==s.tagExp[s.tagExp.length-1]&&n++,r=s.closeIndex)}}function N(t,e,r){if(e&&\"string\"==typeof t){var n=t.trim();return\"true\"===n||\"false\"!==n&&s(t,r)}return i.isExist(t)?t:\"\"}t.exports=function(t){this.options=t,this.currentNode=null,this.tagsNodeStack=[],this.docTypeEntities={},this.lastEntities={apos:{regex:/&(apos|#39|#x27);/g,val:\"'\"},gt:{regex:/&(gt|#62|#x3E);/g,val:\">\"},lt:{regex:/&(lt|#60|#x3C);/g,val:\"<\"},quot:{regex:/&(quot|#34|#x22);/g,val:'\"'}},this.ampEntity={regex:/&(amp|#38|#x26);/g,val:\"&\"},this.htmlEntities={space:{regex:/&(nbsp|#160);/g,val:\" \"},cent:{regex:/&(cent|#162);/g,val:\"\u00a2\"},pound:{regex:/&(pound|#163);/g,val:\"\u00a3\"},yen:{regex:/&(yen|#165);/g,val:\"\u00a5\"},euro:{regex:/&(euro|#8364);/g,val:\"\u20ac\"},copyright:{regex:/&(copy|#169);/g,val:\"\u00a9\"},reg:{regex:/&(reg|#174);/g,val:\"\u00ae\"},inr:{regex:/&(inr|#8377);/g,val:\"\u20b9\"}},this.addExternalEntities=o,this.parseXml=h,this.parseTextData=l,this.resolveNameSpace=u,this.buildAttributesMap=g,this.isItStopNode=c,this.replaceEntitiesValue=d,this.readStopNodeData=m,this.saveTextToParentTag=p}},870:(t,e,r)=>{var i=r(348).buildOptions,n=r(498),a=r(400).prettify,s=r(239),o=function(){function t(t){this.externalEntities={},this.options=i(t)}var e=t.prototype;return e.parse=function(t,e){if(\"string\"==typeof t);else{if(!t.toString)throw new Error(\"XML data is accepted in String or Bytes[] form.\");t=t.toString()}if(e){!0===e&&(e={});var r=s.validate(t,e);if(!0!==r)throw Error(r.err.msg+\":\"+r.err.line+\":\"+r.err.col)}var i=new n(this.options);i.addExternalEntities(this.externalEntities);var o=i.parseXml(t);return this.options.preserveOrder||void 0===o?o:a(o,this.options)},e.addEntity=function(t,e){if(-1!==e.indexOf(\"&\"))throw new Error(\"Entity value can't have '&'\");if(-1!==t.indexOf(\"&\")||-1!==t.indexOf(\";\"))throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\");if(\"&\"===e)throw new Error(\"An entity with value '&' is not permitted\");this.externalEntities[t]=e},t}();t.exports=o},400:(t,e)=>{\"use strict\";function r(t,e,s){for(var o,l={},u=0;u<t.length;u++){var f,g=t[u],h=i(g);if(f=void 0===s?h:s+\".\"+h,h===e.textNodeName)void 0===o?o=g[h]:o+=\"\"+g[h];else{if(void 0===h)continue;if(g[h]){var d=r(g[h],e,f),p=a(d,e);g[\":@\"]?n(d,g[\":@\"],f,e):1!==Object.keys(d).length||void 0===d[e.textNodeName]||e.alwaysCreateTextNode?0===Object.keys(d).length&&(e.alwaysCreateTextNode?d[e.textNodeName]=\"\":d=\"\"):d=d[e.textNodeName],void 0!==l[h]&&l.hasOwnProperty(h)?(Array.isArray(l[h])||(l[h]=[l[h]]),l[h].push(d)):e.isArray(h,f,p)?l[h]=[d]:l[h]=d}}}return\"string\"==typeof o?o.length>0&&(l[e.textNodeName]=o):void 0!==o&&(l[e.textNodeName]=o),l}function i(t){for(var e=Object.keys(t),r=0;r<e.length;r++){var i=e[r];if(\":@\"!==i)return i}}function n(t,e,r,i){if(e)for(var n=Object.keys(e),a=n.length,s=0;s<a;s++){var o=n[s];i.isArray(o,r+\".\"+o,!0,!0)?t[o]=[e[o]]:t[o]=e[o]}}function a(t,e){var r=Object.keys(t).length;return!!(0===r||1===r&&t[e.textNodeName])}e.prettify=function(t,e){return r(t,e)}},876:t=>{\"use strict\";var e=function(){function t(t){this.tagname=t,this.child=[],this[\":@\"]={}}var e=t.prototype;return e.add=function(t,e){var r;this.child.push(((r={})[t]=e,r))},e.addChild=function(t){var e,r;t[\":@\"]&&Object.keys(t[\":@\"]).length>0?this.child.push(((e={})[t.tagname]=t.child,e[\":@\"]=t[\":@\"],e)):this.child.push(((r={})[t.tagname]=t.child,r))},t}();t.exports=e}},e={},r=function r(i){var n=e[i];if(void 0!==n)return n.exports;var a=e[i]={exports:{}};return t[i](a,a.exports,r),a.exports}(870);XMLParser=r})();",
          "",
          "---------------"
        ],
        "lib/fxparser.min.js.map||lib/fxparser.min.js.map": [
          "File: lib/fxparser.min.js.map -> lib/fxparser.min.js.map",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: {\"version\":3,\"file\":\"./lib/fxparser.min.js\",\"mappings\":\"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\",\"sources\":[\"webpack://XMLParser/./node_modules/strnum/strnum.js\",\"webpack://XMLParser/./src/util.js\",\"webpack://XMLParser/./src/validator.js\",\"webpack://XMLParser/./src/xmlparser/DocTypeReader.js\",\"webpack://XMLParser/./src/xmlparser/OptionsBuilder.js\",\"webpack://XMLParser/./src/xmlparser/OrderedObjParser.js\",\"webpack://XMLParser/./src/xmlparser/XMLParser.js\",\"webpack://XMLParser/./src/xmlparser/node2json.js\",\"webpack://XMLParser/./src/xmlparser/xmlNode.js\",\"webpack://XMLParser/webpack/bootstrap\",\"webpack://XMLParser/webpack/startup\"],\"sourcesContent\":[\"const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\\nconst numRegex = /^([\\\\-\\\\+])?(0*)(\\\\.[0-9]+([eE]\\\\-?[0-9]+)?|[0-9]+(\\\\.[0-9]+([eE]\\\\-?[0-9]+)?)?)$/;\\n// const octRegex = /0x[a-z0-9]+/;\\n// const binRegex = /0x[a-z0-9]+/;\\n\\n\\n//polyfill\\nif (!Number.parseInt && window.parseInt) {\\n    Number.parseInt = window.parseInt;\\n}\\nif (!Number.parseFloat && window.parseFloat) {\\n    Number.parseFloat = window.parseFloat;\\n}\\n\\n  \\nconst consider = {\\n    hex :  true,\\n    leadingZeros: true,\\n    decimalPoint: \\\"\\\\.\\\",\\n    eNotation: true\\n    //skipLike: /regex/\\n};\\n\\nfunction toNumber(str, options = {}){\\n    // const options = Object.assign({}, consider);\\n    // if(opt.leadingZeros === false){\\n    //     options.leadingZeros = false;\\n    // }else if(opt.hex === false){\\n    //     options.hex = false;\\n    // }\\n\\n    options = Object.assign({}, consider, options );\\n    if(!str || typeof str !== \\\"string\\\" ) return str;\\n    \\n    let trimmedStr  = str.trim();\\n    // if(trimmedStr === \\\"0.0\\\") return 0;\\n    // else if(trimmedStr === \\\"+0.0\\\") return 0;\\n    // else if(trimmedStr === \\\"-0.0\\\") return -0;\\n\\n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\\n    else if (options.hex && hexRegex.test(trimmedStr)) {\\n        return Number.parseInt(trimmedStr, 16);\\n    // } else if (options.parseOct && octRegex.test(str)) {\\n    //     return Number.parseInt(val, 8);\\n    // }else if (options.parseBin && binRegex.test(str)) {\\n    //     return Number.parseInt(val, 2);\\n    }else{\\n        //separate negative sign, leading zeros, and rest number\\n        const match = numRegex.exec(trimmedStr);\\n        if(match){\\n            const sign = match[1];\\n            const leadingZeros = match[2];\\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\\n            //trim ending zeros for floating number\\n            \\n            const eNotation = match[4] || match[6];\\n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \\\".\\\") return str; //-0123\\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \\\".\\\") return str; //0123\\n            else{//no leading zeros or leading zeros are allowed\\n                const num = Number(trimmedStr);\\n                const numStr = \\\"\\\" + num;\\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\\n                    if(options.eNotation) return num;\\n                    else return str;\\n                }else if(eNotation){ //given number has enotation\\n                    if(options.eNotation) return num;\\n                    else return str;\\n                }else if(trimmedStr.indexOf(\\\".\\\") !== -1){ //floating number\\n                    // const decimalPart = match[5].substr(1);\\n                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf(\\\".\\\"));\\n\\n                    \\n                    // const p = numStr.indexOf(\\\".\\\");\\n                    // const givenIntPart = numStr.substr(0,p);\\n                    // const givenDecPart = numStr.substr(p+1);\\n                    if(numStr === \\\"0\\\" && (numTrimmedByZeros === \\\"\\\") ) return num; //0.0\\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\\n                    else if( sign && numStr === \\\"-\\\"+numTrimmedByZeros) return num;\\n                    else return str;\\n                }\\n                \\n                if(leadingZeros){\\n                    // if(numTrimmedByZeros === numStr){\\n                    //     if(options.leadingZeros) return num;\\n                    //     else return str;\\n                    // }else return str;\\n                    if(numTrimmedByZeros === numStr) return num;\\n                    else if(sign+numTrimmedByZeros === numStr) return num;\\n                    else return str;\\n                }\\n\\n                if(trimmedStr === numStr) return num;\\n                else if(trimmedStr === sign+numStr) return num;\\n                // else{\\n                //     //number with +/- sign\\n                //     trimmedStr.test(/[-+][0-9]);\\n\\n                // }\\n                return str;\\n            }\\n            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;\\n            \\n        }else{ //non-numeric string\\n            return str;\\n        }\\n    }\\n}\\n\\n/**\\n * \\n * @param {string} numStr without leading zeros\\n * @returns \\n */\\nfunction trimZeros(numStr){\\n    if(numStr && numStr.indexOf(\\\".\\\") !== -1){//float\\n        numStr = numStr.replace(/0+$/, \\\"\\\"); //remove ending zeros\\n        if(numStr === \\\".\\\")  numStr = \\\"0\\\";\\n        else if(numStr[0] === \\\".\\\")  numStr = \\\"0\\\"+numStr;\\n        else if(numStr[numStr.length-1] === \\\".\\\")  numStr = numStr.substr(0,numStr.length-1);\\n        return numStr;\\n    }\\n    return numStr;\\n}\\nmodule.exports = toNumber\\n\",\"'use strict';\\n\\nconst nameStartChar = ':A-Za-z_\\\\\\\\u00C0-\\\\\\\\u00D6\\\\\\\\u00D8-\\\\\\\\u00F6\\\\\\\\u00F8-\\\\\\\\u02FF\\\\\\\\u0370-\\\\\\\\u037D\\\\\\\\u037F-\\\\\\\\u1FFF\\\\\\\\u200C-\\\\\\\\u200D\\\\\\\\u2070-\\\\\\\\u218F\\\\\\\\u2C00-\\\\\\\\u2FEF\\\\\\\\u3001-\\\\\\\\uD7FF\\\\\\\\uF900-\\\\\\\\uFDCF\\\\\\\\uFDF0-\\\\\\\\uFFFD';\\nconst nameChar = nameStartChar + '\\\\\\\\-.\\\\\\\\d\\\\\\\\u00B7\\\\\\\\u0300-\\\\\\\\u036F\\\\\\\\u203F-\\\\\\\\u2040';\\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\\nconst regexName = new RegExp('^' + nameRegexp + '$');\\n\\nconst getAllMatches = function(string, regex) {\\n  const matches = [];\\n  let match = regex.exec(string);\\n  while (match) {\\n    const allmatches = [];\\n    allmatches.startIndex = regex.lastIndex - match[0].length;\\n    const len = match.length;\\n    for (let index = 0; index < len; index++) {\\n      allmatches.push(match[index]);\\n    }\\n    matches.push(allmatches);\\n    match = regex.exec(string);\\n  }\\n  return matches;\\n};\\n\\nconst isName = function(string) {\\n  const match = regexName.exec(string);\\n  return !(match === null || typeof match === 'undefined');\\n};\\n\\nexports.isExist = function(v) {\\n  return typeof v !== 'undefined';\\n};\\n\\nexports.isEmptyObject = function(obj) {\\n  return Object.keys(obj).length === 0;\\n};\\n\\n/**\\n * Copy all the properties of a into b.\\n * @param {*} target\\n * @param {*} a\\n */\\nexports.merge = function(target, a, arrayMode) {\\n  if (a) {\\n    const keys = Object.keys(a); // will return an array of own properties\\n    const len = keys.length; //don't make it inline\\n    for (let i = 0; i < len; i++) {\\n      if (arrayMode === 'strict') {\\n        target[keys[i]] = [ a[keys[i]] ];\\n      } else {\\n        target[keys[i]] = a[keys[i]];\\n      }\\n    }\\n  }\\n};\\n/* exports.merge =function (b,a){\\n  return Object.assign(b,a);\\n} */\\n\\nexports.getValue = function(v) {\\n  if (exports.isExist(v)) {\\n    return v;\\n  } else {\\n    return '';\\n  }\\n};\\n\\n// const fakeCall = function(a) {return a;};\\n// const fakeCallNoReturn = function() {};\\n\\nexports.isName = isName;\\nexports.getAllMatches = getAllMatches;\\nexports.nameRegexp = nameRegexp;\\n\",\"'use strict';\\n\\nconst util = require('./util');\\n\\nconst defaultOptions = {\\n  allowBooleanAttributes: false, //A tag can have attributes without any value\\n  unpairedTags: []\\n};\\n\\n//const tagsPattern = new RegExp(\\\"<\\\\\\\\/?([\\\\\\\\w:\\\\\\\\-_\\\\.]+)\\\\\\\\s*\\\\/?>\\\",\\\"g\\\");\\nexports.validate = function (xmlData, options) {\\n  options = Object.assign({}, defaultOptions, options);\\n\\n  //xmlData = xmlData.replace(/(\\\\r\\\\n|\\\\n|\\\\r)/gm,\\\"\\\");//make it single line\\n  //xmlData = xmlData.replace(/(^\\\\s*<\\\\?xml.*?\\\\?>)/g,\\\"\\\");//Remove XML starting tag\\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\\\s\\\\w\\\\\\\"\\\\.\\\\/\\\\-\\\\:]+(\\\\[.*\\\\])*\\\\s*>)/g,\\\"\\\");//Remove DOCTYPE\\n  const tags = [];\\n  let tagFound = false;\\n\\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\\n  let reachedRoot = false;\\n\\n  if (xmlData[0] === '\\\\ufeff') {\\n    // check for byte order mark (BOM)\\n    xmlData = xmlData.substr(1);\\n  }\\n  \\n  for (let i = 0; i < xmlData.length; i++) {\\n\\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\\n      i+=2;\\n      i = readPI(xmlData,i);\\n      if (i.err) return i;\\n    }else if (xmlData[i] === '<') {\\n      //starting of tag\\n      //read until you reach to '>' avoiding any '>' in attribute value\\n      let tagStartPos = i;\\n      i++;\\n      \\n      if (xmlData[i] === '!') {\\n        i = readCommentAndCDATA(xmlData, i);\\n        continue;\\n      } else {\\n        let closingTag = false;\\n        if (xmlData[i] === '/') {\\n          //closing tag\\n          closingTag = true;\\n          i++;\\n        }\\n        //read tagname\\n        let tagName = '';\\n        for (; i < xmlData.length &&\\n          xmlData[i] !== '>' &&\\n          xmlData[i] !== ' ' &&\\n          xmlData[i] !== '\\\\t' &&\\n          xmlData[i] !== '\\\\n' &&\\n          xmlData[i] !== '\\\\r'; i++\\n        ) {\\n          tagName += xmlData[i];\\n        }\\n        tagName = tagName.trim();\\n        //console.log(tagName);\\n\\n        if (tagName[tagName.length - 1] === '/') {\\n          //self closing tag without attributes\\n          tagName = tagName.substring(0, tagName.length - 1);\\n          //continue;\\n          i--;\\n        }\\n        if (!validateTagName(tagName)) {\\n          let msg;\\n          if (tagName.trim().length === 0) {\\n            msg = \\\"Invalid space after '<'.\\\";\\n          } else {\\n            msg = \\\"Tag '\\\"+tagName+\\\"' is an invalid name.\\\";\\n          }\\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\\n        }\\n\\n        const result = readAttributeStr(xmlData, i);\\n        if (result === false) {\\n          return getErrorObject('InvalidAttr', \\\"Attributes for '\\\"+tagName+\\\"' have open quote.\\\", getLineNumberForPosition(xmlData, i));\\n        }\\n        let attrStr = result.value;\\n        i = result.index;\\n\\n        if (attrStr[attrStr.length - 1] === '/') {\\n          //self closing tag\\n          const attrStrStart = i - attrStr.length;\\n          attrStr = attrStr.substring(0, attrStr.length - 1);\\n          const isValid = validateAttributeString(attrStr, options);\\n          if (isValid === true) {\\n            tagFound = true;\\n            //continue; //text may presents after self closing tag\\n          } else {\\n            //the result from the nested function returns the position of the error within the attribute\\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\\n          }\\n        } else if (closingTag) {\\n          if (!result.tagClosed) {\\n            return getErrorObject('InvalidTag', \\\"Closing tag '\\\"+tagName+\\\"' doesn't have proper closing.\\\", getLineNumberForPosition(xmlData, i));\\n          } else if (attrStr.trim().length > 0) {\\n            return getErrorObject('InvalidTag', \\\"Closing tag '\\\"+tagName+\\\"' can't have attributes or invalid starting.\\\", getLineNumberForPosition(xmlData, tagStartPos));\\n          } else {\\n            const otg = tags.pop();\\n            if (tagName !== otg.tagName) {\\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\\n              return getErrorObject('InvalidTag',\\n                \\\"Expected closing tag '\\\"+otg.tagName+\\\"' (opened in line \\\"+openPos.line+\\\", col \\\"+openPos.col+\\\") instead of closing tag '\\\"+tagName+\\\"'.\\\",\\n                getLineNumberForPosition(xmlData, tagStartPos));\\n            }\\n\\n            //when there are no more tags, we reached the root level.\\n            if (tags.length == 0) {\\n              reachedRoot = true;\\n            }\\n          }\\n        } else {\\n          const isValid = validateAttributeString(attrStr, options);\\n          if (isValid !== true) {\\n            //the result from the nested function returns the position of the error within the attribute\\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\\n          }\\n\\n          //if the root level has been reached before ...\\n          if (reachedRoot === true) {\\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\\n          } else if(options.unpairedTags.indexOf(tagName) !== -1){\\n            //don't push into stack\\n          } else {\\n            tags.push({tagName, tagStartPos});\\n          }\\n          tagFound = true;\\n        }\\n\\n        //skip tag text value\\n        //It may include comments and CDATA value\\n        for (i++; i < xmlData.length; i++) {\\n          if (xmlData[i] === '<') {\\n            if (xmlData[i + 1] === '!') {\\n              //comment or CADATA\\n              i++;\\n              i = readCommentAndCDATA(xmlData, i);\\n              continue;\\n            } else if (xmlData[i+1] === '?') {\\n              i = readPI(xmlData, ++i);\\n              if (i.err) return i;\\n            } else{\\n              break;\\n            }\\n          } else if (xmlData[i] === '&') {\\n            const afterAmp = validateAmpersand(xmlData, i);\\n            if (afterAmp == -1)\\n              return getErrorObject('InvalidChar', \\\"char '&' is not expected.\\\", getLineNumberForPosition(xmlData, i));\\n            i = afterAmp;\\n          }else{\\n            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\\n              return getErrorObject('InvalidXml', \\\"Extra text at the end\\\", getLineNumberForPosition(xmlData, i));\\n            }\\n          }\\n        } //end of reading tag text value\\n        if (xmlData[i] === '<') {\\n          i--;\\n        }\\n      }\\n    } else {\\n      if ( isWhiteSpace(xmlData[i])) {\\n        continue;\\n      }\\n      return getErrorObject('InvalidChar', \\\"char '\\\"+xmlData[i]+\\\"' is not expected.\\\", getLineNumberForPosition(xmlData, i));\\n    }\\n  }\\n\\n  if (!tagFound) {\\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\\n  }else if (tags.length == 1) {\\n      return getErrorObject('InvalidTag', \\\"Unclosed tag '\\\"+tags[0].tagName+\\\"'.\\\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\\n  }else if (tags.length > 0) {\\n      return getErrorObject('InvalidXml', \\\"Invalid '\\\"+\\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\\\r?\\\\n/g, '')+\\n          \\\"' found.\\\", {line: 1, col: 1});\\n  }\\n\\n  return true;\\n};\\n\\nfunction isWhiteSpace(char){\\n  return char === ' ' || char === '\\\\t' || char === '\\\\n'  || char === '\\\\r';\\n}\\n/**\\n * Read Processing insstructions and skip\\n * @param {*} xmlData\\n * @param {*} i\\n */\\nfunction readPI(xmlData, i) {\\n  const start = i;\\n  for (; i < xmlData.length; i++) {\\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\\n      //tagname\\n      const tagname = xmlData.substr(start, i - start);\\n      if (i > 5 && tagname === 'xml') {\\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\\n        //check if valid attribut string\\n        i++;\\n        break;\\n      } else {\\n        continue;\\n      }\\n    }\\n  }\\n  return i;\\n}\\n\\nfunction readCommentAndCDATA(xmlData, i) {\\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\\n    //comment\\n    for (i += 3; i < xmlData.length; i++) {\\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\\n        i += 2;\\n        break;\\n      }\\n    }\\n  } else if (\\n    xmlData.length > i + 8 &&\\n    xmlData[i + 1] === 'D' &&\\n    xmlData[i + 2] === 'O' &&\\n    xmlData[i + 3] === 'C' &&\\n    xmlData[i + 4] === 'T' &&\\n    xmlData[i + 5] === 'Y' &&\\n    xmlData[i + 6] === 'P' &&\\n    xmlData[i + 7] === 'E'\\n  ) {\\n    let angleBracketsCount = 1;\\n    for (i += 8; i < xmlData.length; i++) {\\n      if (xmlData[i] === '<') {\\n        angleBracketsCount++;\\n      } else if (xmlData[i] === '>') {\\n        angleBracketsCount--;\\n        if (angleBracketsCount === 0) {\\n          break;\\n        }\\n      }\\n    }\\n  } else if (\\n    xmlData.length > i + 9 &&\\n    xmlData[i + 1] === '[' &&\\n    xmlData[i + 2] === 'C' &&\\n    xmlData[i + 3] === 'D' &&\\n    xmlData[i + 4] === 'A' &&\\n    xmlData[i + 5] === 'T' &&\\n    xmlData[i + 6] === 'A' &&\\n    xmlData[i + 7] === '['\\n  ) {\\n    for (i += 8; i < xmlData.length; i++) {\\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\\n        i += 2;\\n        break;\\n      }\\n    }\\n  }\\n\\n  return i;\\n}\\n\\nconst doubleQuote = '\\\"';\\nconst singleQuote = \\\"'\\\";\\n\\n/**\\n * Keep reading xmlData until '<' is found outside the attribute value.\\n * @param {string} xmlData\\n * @param {number} i\\n */\\nfunction readAttributeStr(xmlData, i) {\\n  let attrStr = '';\\n  let startChar = '';\\n  let tagClosed = false;\\n  for (; i < xmlData.length; i++) {\\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\\n      if (startChar === '') {\\n        startChar = xmlData[i];\\n      } else if (startChar !== xmlData[i]) {\\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\\n      } else {\\n        startChar = '';\\n      }\\n    } else if (xmlData[i] === '>') {\\n      if (startChar === '') {\\n        tagClosed = true;\\n        break;\\n      }\\n    }\\n    attrStr += xmlData[i];\\n  }\\n  if (startChar !== '') {\\n    return false;\\n  }\\n\\n  return {\\n    value: attrStr,\\n    index: i,\\n    tagClosed: tagClosed\\n  };\\n}\\n\\n/**\\n * Select all the attributes whether valid or invalid.\\n */\\nconst validAttrStrRegxp = new RegExp('(\\\\\\\\s*)([^\\\\\\\\s=]+)(\\\\\\\\s*=)?(\\\\\\\\s*([\\\\'\\\"])(([\\\\\\\\s\\\\\\\\S])*?)\\\\\\\\5)?', 'g');\\n\\n//attr, =\\\"sd\\\", a=\\\"amit's\\\", a=\\\"sd\\\"b=\\\"saf\\\", ab  cd=\\\"\\\"\\n\\nfunction validateAttributeString(attrStr, options) {\\n  //console.log(\\\"start:\\\"+attrStr+\\\":end\\\");\\n\\n  //if(attrStr.trim().length === 0) return true; //empty string\\n\\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\\n  const attrNames = {};\\n\\n  for (let i = 0; i < matches.length; i++) {\\n    if (matches[i][1].length === 0) {\\n      //nospace before attribute name: a=\\\"sd\\\"b=\\\"saf\\\"\\n      return getErrorObject('InvalidAttr', \\\"Attribute '\\\"+matches[i][2]+\\\"' has no space in starting.\\\", getPositionFromMatch(matches[i]))\\n    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\\n      return getErrorObject('InvalidAttr', \\\"Attribute '\\\"+matches[i][2]+\\\"' is without value.\\\", getPositionFromMatch(matches[i]));\\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\\n      //independent attribute: ab\\n      return getErrorObject('InvalidAttr', \\\"boolean attribute '\\\"+matches[i][2]+\\\"' is not allowed.\\\", getPositionFromMatch(matches[i]));\\n    }\\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\\n                    return { err: { code:\\\"InvalidAttr\\\",msg:\\\"attribute \\\" + matches[i][2] + \\\" has no value assigned.\\\"}};\\n                } */\\n    const attrName = matches[i][2];\\n    if (!validateAttrName(attrName)) {\\n      return getErrorObject('InvalidAttr', \\\"Attribute '\\\"+attrName+\\\"' is an invalid name.\\\", getPositionFromMatch(matches[i]));\\n    }\\n    if (!attrNames.hasOwnProperty(attrName)) {\\n      //check for duplicate attribute.\\n      attrNames[attrName] = 1;\\n    } else {\\n      return getErrorObject('InvalidAttr', \\\"Attribute '\\\"+attrName+\\\"' is repeated.\\\", getPositionFromMatch(matches[i]));\\n    }\\n  }\\n\\n  return true;\\n}\\n\\nfunction validateNumberAmpersand(xmlData, i) {\\n  let re = /\\\\d/;\\n  if (xmlData[i] === 'x') {\\n    i++;\\n    re = /[\\\\da-fA-F]/;\\n  }\\n  for (; i < xmlData.length; i++) {\\n    if (xmlData[i] === ';')\\n      return i;\\n    if (!xmlData[i].match(re))\\n      break;\\n  }\\n  return -1;\\n}\\n\\nfunction validateAmpersand(xmlData, i) {\\n  // https://www.w3.org/TR/xml/#dt-charref\\n  i++;\\n  if (xmlData[i] === ';')\\n    return -1;\\n  if (xmlData[i] === '#') {\\n    i++;\\n    return validateNumberAmpersand(xmlData, i);\\n  }\\n  let count = 0;\\n  for (; i < xmlData.length; i++, count++) {\\n    if (xmlData[i].match(/\\\\w/) && count < 20)\\n      continue;\\n    if (xmlData[i] === ';')\\n      break;\\n    return -1;\\n  }\\n  return i;\\n}\\n\\nfunction getErrorObject(code, message, lineNumber) {\\n  return {\\n    err: {\\n      code: code,\\n      msg: message,\\n      line: lineNumber.line || lineNumber,\\n      col: lineNumber.col,\\n    },\\n  };\\n}\\n\\nfunction validateAttrName(attrName) {\\n  return util.isName(attrName);\\n}\\n\\n// const startsWithXML = /^xml/i;\\n\\nfunction validateTagName(tagname) {\\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\\n}\\n\\n//this function returns the line number for the character at the given index\\nfunction getLineNumberForPosition(xmlData, index) {\\n  const lines = xmlData.substring(0, index).split(/\\\\r?\\\\n/);\\n  return {\\n    line: lines.length,\\n\\n    // column number is last line's length + 1, because column numbering starts at 1:\\n    col: lines[lines.length - 1].length + 1\\n  };\\n}\\n\\n//this function returns the position of the first character of match within attrStr\\nfunction getPositionFromMatch(match) {\\n  return match.startIndex + match[1].length;\\n}\\n\",\"//TODO: handle comments\\nfunction readDocType(xmlData, i){\\n    \\n    const entities = {};\\n    if( xmlData[i + 3] === 'O' &&\\n         xmlData[i + 4] === 'C' &&\\n         xmlData[i + 5] === 'T' &&\\n         xmlData[i + 6] === 'Y' &&\\n         xmlData[i + 7] === 'P' &&\\n         xmlData[i + 8] === 'E')\\n    {    \\n        i = i+9;\\n        let angleBracketsCount = 1;\\n        let hasBody = false, entity = false, comment = false;\\n        let exp = \\\"\\\";\\n        for(;i<xmlData.length;i++){\\n            if (xmlData[i] === '<') {\\n                if( hasBody && \\n                     xmlData[i+1] === '!' &&\\n                     xmlData[i+2] === 'E' &&\\n                     xmlData[i+3] === 'N' &&\\n                     xmlData[i+4] === 'T' &&\\n                     xmlData[i+5] === 'I' &&\\n                     xmlData[i+6] === 'T' &&\\n                     xmlData[i+7] === 'Y'\\n                ){\\n                    i += 7;\\n                    entity = true;\\n                }else if( hasBody && \\n                    xmlData[i+1] === '!' &&\\n                     xmlData[i+2] === 'E' &&\\n                     xmlData[i+3] === 'L' &&\\n                     xmlData[i+4] === 'E' &&\\n                     xmlData[i+5] === 'M' &&\\n                     xmlData[i+6] === 'E' &&\\n                     xmlData[i+7] === 'N' &&\\n                     xmlData[i+8] === 'T'\\n                ){\\n                    //Not supported\\n                    i += 8;\\n                }else if( hasBody && \\n                    xmlData[i+1] === '!' &&\\n                    xmlData[i+2] === 'A' &&\\n                    xmlData[i+3] === 'T' &&\\n                    xmlData[i+4] === 'T' &&\\n                    xmlData[i+5] === 'L' &&\\n                    xmlData[i+6] === 'I' &&\\n                    xmlData[i+7] === 'S' &&\\n                    xmlData[i+8] === 'T'\\n                ){\\n                    //Not supported\\n                    i += 8;\\n                }else if( hasBody && \\n                    xmlData[i+1] === '!' &&\\n                    xmlData[i+2] === 'N' &&\\n                    xmlData[i+3] === 'O' &&\\n                    xmlData[i+4] === 'T' &&\\n                    xmlData[i+5] === 'A' &&\\n                    xmlData[i+6] === 'T' &&\\n                    xmlData[i+7] === 'I' &&\\n                    xmlData[i+8] === 'O' &&\\n                    xmlData[i+9] === 'N'\\n                ){\\n                    //Not supported\\n                    i += 9;\\n                }else if( //comment\\n                    xmlData[i+1] === '!' &&\\n                    xmlData[i+2] === '-' &&\\n                    xmlData[i+3] === '-'\\n                ){\\n                    comment = true;\\n                }else{\\n                    throw new Error(\\\"Invalid DOCTYPE\\\");\\n                }\\n                angleBracketsCount++;\\n                exp = \\\"\\\";\\n            } else if (xmlData[i] === '>') {\\n                if(comment){\\n                    if( xmlData[i - 1] === \\\"-\\\" && xmlData[i - 2] === \\\"-\\\"){\\n                        comment = false;\\n                    }else{\\n                        throw new Error(`Invalid XML comment in DOCTYPE`);\\n                    }\\n                }else if(entity){\\n                    parseEntityExp(exp, entities);\\n                    entity = false;\\n                }\\n                angleBracketsCount--;\\n                if (angleBracketsCount === 0) {\\n                  break;\\n                }\\n            }else if( xmlData[i] === '['){\\n                hasBody = true;\\n            }else{\\n                exp += xmlData[i];\\n            }\\n        }\\n        if(angleBracketsCount !== 0){\\n            throw new Error(`Unclosed DOCTYPE`);\\n        }\\n    }else{\\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\\n    }\\n    return {entities, i};\\n}\\n\\nconst entityRegex = RegExp(\\\"^\\\\\\\\s([a-zA-z0-0]+)[ \\\\t](['\\\\\\\"])([^&]+)\\\\\\\\2\\\");\\nfunction parseEntityExp(exp, entities){\\n    const match = entityRegex.exec(exp);\\n    if(match){\\n        entities[ match[1] ] = {\\n            regx : RegExp( `&${match[1]};`,\\\"g\\\"),\\n            val: match[3]\\n        };\\n    }\\n}\\nmodule.exports = readDocType;\",\"\\nconst defaultOptions = {\\n    preserveOrder: false,\\n    attributeNamePrefix: '@_',\\n    attributesGroupName: false,\\n    textNodeName: '#text',\\n    ignoreAttributes: true,\\n    removeNSPrefix: false, // remove NS from tag name or attribute name if true\\n    allowBooleanAttributes: false, //a tag can have attributes without any value\\n    //ignoreRootElement : false,\\n    parseTagValue: true,\\n    parseAttributeValue: false,\\n    trimValues: true, //Trim string values of tag and attributes\\n    cdataPropName: false,\\n    numberParseOptions: {\\n      hex: true,\\n      leadingZeros: true\\n    },\\n    tagValueProcessor: function(tagName, val) {\\n      return val;\\n    },\\n    attributeValueProcessor: function(attrName, val) {\\n      return val;\\n    },\\n    stopNodes: [], //nested tags will not be parsed even for errors\\n    alwaysCreateTextNode: false,\\n    isArray: () => false,\\n    commentPropName: false,\\n    unpairedTags: [],\\n    processEntities: true,\\n    htmlEntities: false,\\n    ignoreDeclaration: false,\\n    ignorePiTags: false,\\n    transformTagName: false,\\n};\\n   \\nconst buildOptions = function(options) {\\n    return Object.assign({}, defaultOptions, options);\\n};\\n\\nexports.buildOptions = buildOptions;\\nexports.defaultOptions = defaultOptions;\",\"'use strict';\\n///@ts-check\\n\\nconst util = require('../util');\\nconst xmlNode = require('./xmlNode');\\nconst readDocType = require(\\\"./DocTypeReader\\\");\\nconst toNumber = require(\\\"strnum\\\");\\n\\nconst regx =\\n  '<((!\\\\\\\\[CDATA\\\\\\\\[([\\\\\\\\s\\\\\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\\\\\/)(NAME)\\\\\\\\s*>))([^<]*)'\\n  .replace(/NAME/g, util.nameRegexp);\\n\\n//const tagsRegx = new RegExp(\\\"<(\\\\\\\\/?[\\\\\\\\w:\\\\\\\\-\\\\._]+)([^>]*)>(\\\\\\\\s*\\\"+cdataRegx+\\\")*([^<]+)?\\\",\\\"g\\\");\\n//const tagsRegx = new RegExp(\\\"<(\\\\\\\\/?)((\\\\\\\\w*:)?([\\\\\\\\w:\\\\\\\\-\\\\._]+))([^>]*)>([^<]*)(\\\"+cdataRegx+\\\"([^<]*))*([^<]+)?\\\",\\\"g\\\");\\n\\nclass OrderedObjParser{\\n  constructor(options){\\n    this.options = options;\\n    this.currentNode = null;\\n    this.tagsNodeStack = [];\\n    this.docTypeEntities = {};\\n    this.lastEntities = {\\n      \\\"apos\\\" : { regex: /&(apos|#39|#x27);/g, val : \\\"'\\\"},\\n      \\\"gt\\\" : { regex: /&(gt|#62|#x3E);/g, val : \\\">\\\"},\\n      \\\"lt\\\" : { regex: /&(lt|#60|#x3C);/g, val : \\\"<\\\"},\\n      \\\"quot\\\" : { regex: /&(quot|#34|#x22);/g, val : \\\"\\\\\\\"\\\"},\\n    };\\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \\\"&\\\"};\\n    this.htmlEntities = {\\n      \\\"space\\\": { regex: /&(nbsp|#160);/g, val: \\\" \\\" },\\n      // \\\"lt\\\" : { regex: /&(lt|#60);/g, val: \\\"<\\\" },\\n      // \\\"gt\\\" : { regex: /&(gt|#62);/g, val: \\\">\\\" },\\n      // \\\"amp\\\" : { regex: /&(amp|#38);/g, val: \\\"&\\\" },\\n      // \\\"quot\\\" : { regex: /&(quot|#34);/g, val: \\\"\\\\\\\"\\\" },\\n      // \\\"apos\\\" : { regex: /&(apos|#39);/g, val: \\\"'\\\" },\\n      \\\"cent\\\" : { regex: /&(cent|#162);/g, val: \\\"\u00a2\\\" },\\n      \\\"pound\\\" : { regex: /&(pound|#163);/g, val: \\\"\u00a3\\\" },\\n      \\\"yen\\\" : { regex: /&(yen|#165);/g, val: \\\"\u00a5\\\" },\\n      \\\"euro\\\" : { regex: /&(euro|#8364);/g, val: \\\"\u20ac\\\" },\\n      \\\"copyright\\\" : { regex: /&(copy|#169);/g, val: \\\"\u00a9\\\" },\\n      \\\"reg\\\" : { regex: /&(reg|#174);/g, val: \\\"\u00ae\\\" },\\n      \\\"inr\\\" : { regex: /&(inr|#8377);/g, val: \\\"\u20b9\\\" },\\n    };\\n    this.addExternalEntities = addExternalEntities;\\n    this.parseXml = parseXml;\\n    this.parseTextData = parseTextData;\\n    this.resolveNameSpace = resolveNameSpace;\\n    this.buildAttributesMap = buildAttributesMap;\\n    this.isItStopNode = isItStopNode;\\n    this.replaceEntitiesValue = replaceEntitiesValue;\\n    this.readStopNodeData = readStopNodeData;\\n    this.saveTextToParentTag = saveTextToParentTag;\\n  }\\n\\n}\\n\\nfunction addExternalEntities(externalEntities){\\n  const entKeys = Object.keys(externalEntities);\\n  for (let i = 0; i < entKeys.length; i++) {\\n    const ent = entKeys[i];\\n    this.lastEntities[ent] = {\\n       regex: new RegExp(\\\"&\\\"+ent+\\\";\\\",\\\"g\\\"),\\n       val : externalEntities[ent]\\n    }\\n  }\\n}\\n\\n/**\\n * @param {string} val\\n * @param {string} tagName\\n * @param {string} jPath\\n * @param {boolean} dontTrim\\n * @param {boolean} hasAttributes\\n * @param {boolean} isLeafNode\\n * @param {boolean} escapeEntities\\n */\\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\\n  if (val !== undefined) {\\n    if (this.options.trimValues && !dontTrim) {\\n      val = val.trim();\\n    }\\n    if(val.length > 0){\\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\\n      \\n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\\n      if(newval === null || newval === undefined){\\n        //don't parse\\n        return val;\\n      }else if(typeof newval !== typeof val || newval !== val){\\n        //overwrite\\n        return newval;\\n      }else if(this.options.trimValues){\\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\\n      }else{\\n        const trimmedVal = val.trim();\\n        if(trimmedVal === val){\\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\\n        }else{\\n          return val;\\n        }\\n      }\\n    }\\n  }\\n}\\n\\nfunction resolveNameSpace(tagname) {\\n  if (this.options.removeNSPrefix) {\\n    const tags = tagname.split(':');\\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\\n    if (tags[0] === 'xmlns') {\\n      return '';\\n    }\\n    if (tags.length === 2) {\\n      tagname = prefix + tags[1];\\n    }\\n  }\\n  return tagname;\\n}\\n\\n//TODO: change regex to capture NS\\n//const attrsRegx = new RegExp(\\\"([\\\\\\\\w\\\\\\\\-\\\\\\\\.\\\\\\\\:]+)\\\\\\\\s*=\\\\\\\\s*(['\\\\\\\"])((.|\\\\n)*?)\\\\\\\\2\\\",\\\"gm\\\");\\nconst attrsRegx = new RegExp('([^\\\\\\\\s=]+)\\\\\\\\s*(=\\\\\\\\s*([\\\\'\\\"])([\\\\\\\\s\\\\\\\\S]*?)\\\\\\\\3)?', 'gm');\\n\\nfunction buildAttributesMap(attrStr, jPath) {\\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\\n    // attrStr = attrStr.replace(/\\\\r?\\\\n/g, ' ');\\n    //attrStr = attrStr || attrStr.trim();\\n\\n    const matches = util.getAllMatches(attrStr, attrsRegx);\\n    const len = matches.length; //don't make it inline\\n    const attrs = {};\\n    for (let i = 0; i < len; i++) {\\n      const attrName = this.resolveNameSpace(matches[i][1]);\\n      let oldVal = matches[i][4];\\n      const aName = this.options.attributeNamePrefix + attrName;\\n      if (attrName.length) {\\n        if (oldVal !== undefined) {\\n          if (this.options.trimValues) {\\n            oldVal = oldVal.trim();\\n          }\\n          oldVal = this.replaceEntitiesValue(oldVal);\\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\\n          if(newVal === null || newVal === undefined){\\n            //don't parse\\n            attrs[aName] = oldVal;\\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\\n            //overwrite\\n            attrs[aName] = newVal;\\n          }else{\\n            //parse\\n            attrs[aName] = parseValue(\\n              oldVal,\\n              this.options.parseAttributeValue,\\n              this.options.numberParseOptions\\n            );\\n          }\\n        } else if (this.options.allowBooleanAttributes) {\\n          attrs[aName] = true;\\n        }\\n      }\\n    }\\n    if (!Object.keys(attrs).length) {\\n      return;\\n    }\\n    if (this.options.attributesGroupName) {\\n      const attrCollection = {};\\n      attrCollection[this.options.attributesGroupName] = attrs;\\n      return attrCollection;\\n    }\\n    return attrs;\\n  }\\n}\\n\\nconst parseXml = function(xmlData) {\\n  xmlData = xmlData.replace(/\\\\r\\\\n?/g, \\\"\\\\n\\\"); //TODO: remove this line\\n  const xmlObj = new xmlNode('!xml');\\n  let currentNode = xmlObj;\\n  let textData = \\\"\\\";\\n  let jPath = \\\"\\\";\\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\\n    const ch = xmlData[i];\\n    if(ch === '<'){\\n      // const nextIndex = i+1;\\n      // const _2ndChar = xmlData[nextIndex];\\n      if( xmlData[i+1] === '/') {//Closing Tag\\n        const closeIndex = findClosingIndex(xmlData, \\\">\\\", i, \\\"Closing Tag is not closed.\\\")\\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\\n\\n        if(this.options.removeNSPrefix){\\n          const colonIndex = tagName.indexOf(\\\":\\\");\\n          if(colonIndex !== -1){\\n            tagName = tagName.substr(colonIndex+1);\\n          }\\n        }\\n\\n        if(this.options.transformTagName) {\\n          tagName = this.options.transformTagName(tagName);\\n        }\\n\\n        if(currentNode){\\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\\n        }\\n\\n        jPath = jPath.substr(0, jPath.lastIndexOf(\\\".\\\"));\\n        \\n        currentNode = this.tagsNodeStack.pop();//avoid recurssion, set the parent tag scope\\n        textData = \\\"\\\";\\n        i = closeIndex;\\n      } else if( xmlData[i+1] === '?') {\\n\\n        let tagData = readTagExp(xmlData,i, false, \\\"?>\\\");\\n        if(!tagData) throw new Error(\\\"Pi Tag is not closed.\\\");\\n\\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\\n        if( (this.options.ignoreDeclaration && tagData.tagName === \\\"?xml\\\") || this.options.ignorePiTags){\\n\\n        }else{\\n  \\n          const childNode = new xmlNode(tagData.tagName);\\n          childNode.add(this.options.textNodeName, \\\"\\\");\\n          \\n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\\n            childNode[\\\":@\\\"] = this.buildAttributesMap(tagData.tagExp, jPath);\\n          }\\n          currentNode.addChild(childNode);\\n\\n        }\\n\\n\\n        i = tagData.closeIndex + 1;\\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\\n        const endIndex = findClosingIndex(xmlData, \\\"-->\\\", i+4, \\\"Comment is not closed.\\\")\\n        if(this.options.commentPropName){\\n          const comment = xmlData.substring(i + 4, endIndex - 2);\\n\\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\\n\\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\\n        }\\n        i = endIndex;\\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\\n        const result = readDocType(xmlData, i);\\n        this.docTypeEntities = result.entities;\\n        i = result.i;\\n      }else if(xmlData.substr(i + 1, 2) === '![') {\\n        const closeIndex = findClosingIndex(xmlData, \\\"]]>\\\", i, \\\"CDATA is not closed.\\\") - 2;\\n        const tagExp = xmlData.substring(i + 9,closeIndex);\\n\\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\\n\\n        //cdata should be set even if it is 0 length string\\n        if(this.options.cdataPropName){\\n          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + \\\".\\\" + this.options.cdataPropName, true, false, true);\\n          // if(!val) val = \\\"\\\";\\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\\n        }else{\\n          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);\\n          if(val == undefined) val = \\\"\\\";\\n          currentNode.add(this.options.textNodeName, val);\\n        }\\n        \\n        i = closeIndex + 2;\\n      }else {//Opening tag\\n        let result = readTagExp(xmlData,i, this. options.removeNSPrefix);\\n        let tagName= result.tagName;\\n        let tagExp = result.tagExp;\\n        let attrExpPresent = result.attrExpPresent;\\n        let closeIndex = result.closeIndex;\\n\\n        if (this.options.transformTagName) {\\n          tagName = this.options.transformTagName(tagName);\\n        }\\n        \\n        //save text as child node\\n        if (currentNode && textData) {\\n          if(currentNode.tagname !== '!xml'){\\n            //when nested tag is found\\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\\n          }\\n        }\\n\\n        if(tagName !== xmlObj.tagname){\\n          jPath += jPath ? \\\".\\\" + tagName : tagName;\\n        }\\n\\n        //check if last tag was unpaired tag\\n        const lastTag = currentNode;\\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\\n          currentNode = this.tagsNodeStack.pop();\\n        }\\n\\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) { //TODO: namespace\\n          let tagContent = \\\"\\\";\\n          //self-closing tag\\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\\\"/\\\") === tagExp.length - 1){\\n            i = result.closeIndex;\\n          }\\n          //boolean tag\\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\\n            i = result.closeIndex;\\n          }\\n          //normal tag\\n          else{\\n            //read until closing tag is found\\n            const result = this.readStopNodeData(xmlData, tagName, closeIndex + 1);\\n            if(!result) throw new Error(`Unexpected end of ${tagName}`);\\n            i = result.i;\\n            tagContent = result.tagContent;\\n          }\\n\\n          const childNode = new xmlNode(tagName);\\n          if(tagName !== tagExp && attrExpPresent){\\n            childNode[\\\":@\\\"] = this.buildAttributesMap(tagExp, jPath);\\n          }\\n          if(tagContent) {\\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\\n          }\\n          \\n          jPath = jPath.substr(0, jPath.lastIndexOf(\\\".\\\"));\\n          childNode.add(this.options.textNodeName, tagContent);\\n          \\n          currentNode.addChild(childNode);\\n        }else{\\n  //selfClosing tag\\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\\\"/\\\") === tagExp.length - 1){\\n            if(tagName[tagName.length - 1] === \\\"/\\\"){ //remove trailing '/'\\n              tagName = tagName.substr(0, tagName.length - 1);\\n              tagExp = tagName;\\n            }else{\\n              tagExp = tagExp.substr(0, tagExp.length - 1);\\n            }\\n            \\n            if(this.options.transformTagName) {\\n              tagName = this.options.transformTagName(tagName);\\n            }\\n\\n            const childNode = new xmlNode(tagName);\\n            if(tagName !== tagExp && attrExpPresent){\\n              childNode[\\\":@\\\"] = this.buildAttributesMap(tagExp, jPath);\\n            }\\n            jPath = jPath.substr(0, jPath.lastIndexOf(\\\".\\\"));\\n            currentNode.addChild(childNode);\\n          }\\n    //opening tag\\n          else{\\n            const childNode = new xmlNode( tagName);\\n            this.tagsNodeStack.push(currentNode);\\n            \\n            if(tagName !== tagExp && attrExpPresent){\\n              childNode[\\\":@\\\"] = this.buildAttributesMap(tagExp, jPath);\\n            }\\n            currentNode.addChild(childNode);\\n            currentNode = childNode;\\n          }\\n          textData = \\\"\\\";\\n          i = closeIndex;\\n        }\\n      }\\n    }else{\\n      textData += xmlData[i];\\n    }\\n  }\\n  return xmlObj.child;\\n}\\n\\nconst replaceEntitiesValue = function(val){\\n\\n  if(this.options.processEntities){\\n    for(let entityName in this.docTypeEntities){\\n      const entity = this.docTypeEntities[entityName];\\n      val = val.replace( entity.regx, entity.val);\\n    }\\n    for(let entityName in this.lastEntities){\\n      const entity = this.lastEntities[entityName];\\n      val = val.replace( entity.regex, entity.val);\\n    }\\n    if(this.options.htmlEntities){\\n      for(let entityName in this.htmlEntities){\\n        const entity = this.htmlEntities[entityName];\\n        val = val.replace( entity.regex, entity.val);\\n      }\\n    }\\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\\n  }\\n  return val;\\n}\\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\\n  if (textData) { //store previously collected data as textNode\\n    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0\\n    \\n    textData = this.parseTextData(textData,\\n      currentNode.tagname,\\n      jPath,\\n      false,\\n      currentNode[\\\":@\\\"] ? Object.keys(currentNode[\\\":@\\\"]).length !== 0 : false,\\n      isLeafNode);\\n\\n    if (textData !== undefined && textData !== \\\"\\\")\\n      currentNode.add(this.options.textNodeName, textData);\\n    textData = \\\"\\\";\\n  }\\n  return textData;\\n}\\n\\n//TODO: use jPath to simplify the logic\\n/**\\n * \\n * @param {string[]} stopNodes \\n * @param {string} jPath\\n * @param {string} currentTagName \\n */\\nfunction isItStopNode(stopNodes, jPath, currentTagName){\\n  const allNodesExp = \\\"*.\\\" + currentTagName;\\n  for (const stopNodePath in stopNodes) {\\n    const stopNodeExp = stopNodes[stopNodePath];\\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\\n  }\\n  return false;\\n}\\n\\n/**\\n * Returns the tag Expression and where it is ending handling single-dobule quotes situation\\n * @param {string} xmlData \\n * @param {number} i starting index\\n * @returns \\n */\\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \\\">\\\"){\\n  let attrBoundary;\\n  let tagExp = \\\"\\\";\\n  for (let index = i; index < xmlData.length; index++) {\\n    let ch = xmlData[index];\\n    if (attrBoundary) {\\n        if (ch === attrBoundary) attrBoundary = \\\"\\\";//reset\\n    } else if (ch === '\\\"' || ch === \\\"'\\\") {\\n        attrBoundary = ch;\\n    } else if (ch === closingChar[0]) {\\n      if(closingChar[1]){\\n        if(xmlData[index + 1] === closingChar[1]){\\n          return {\\n            data: tagExp,\\n            index: index\\n          }\\n        }\\n      }else{\\n        return {\\n          data: tagExp,\\n          index: index\\n        }\\n      }\\n    } else if (ch === '\\\\t') {\\n      ch = \\\" \\\"\\n    }\\n    tagExp += ch;\\n  }\\n}\\n\\nfunction findClosingIndex(xmlData, str, i, errMsg){\\n  const closingIndex = xmlData.indexOf(str, i);\\n  if(closingIndex === -1){\\n    throw new Error(errMsg)\\n  }else{\\n    return closingIndex + str.length - 1;\\n  }\\n}\\n\\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \\\">\\\"){\\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\\n  if(!result) return;\\n  let tagExp = result.data;\\n  const closeIndex = result.index;\\n  const separatorIndex = tagExp.search(/\\\\s/);\\n  let tagName = tagExp;\\n  let attrExpPresent = true;\\n  if(separatorIndex !== -1){//separate tag name and attributes expression\\n    tagName = tagExp.substr(0, separatorIndex).replace(/\\\\s\\\\s*$/, '');\\n    tagExp = tagExp.substr(separatorIndex + 1);\\n  }\\n\\n  if(removeNSPrefix){\\n    const colonIndex = tagName.indexOf(\\\":\\\");\\n    if(colonIndex !== -1){\\n      tagName = tagName.substr(colonIndex+1);\\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\\n    }\\n  }\\n\\n  return {\\n    tagName: tagName,\\n    tagExp: tagExp,\\n    closeIndex: closeIndex,\\n    attrExpPresent: attrExpPresent,\\n  }\\n}\\n/**\\n * find paired tag for a stop node\\n * @param {string} xmlData \\n * @param {string} tagName \\n * @param {number} i \\n */\\nfunction readStopNodeData(xmlData, tagName, i){\\n  const startIndex = i;\\n  // Starting at 1 since we already have an open tag\\n  let openTagCount = 1;\\n\\n  for (; i < xmlData.length; i++) {\\n    if( xmlData[i] === \\\"<\\\"){ \\n      if (xmlData[i+1] === \\\"/\\\") {//close tag\\n          const closeIndex = findClosingIndex(xmlData, \\\">\\\", i, `${tagName} is not closed`);\\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\\n          if(closeTagName === tagName){\\n            openTagCount--;\\n            if (openTagCount === 0) {\\n              return {\\n                tagContent: xmlData.substring(startIndex, i),\\n                i : closeIndex\\n              }\\n            }\\n          }\\n          i=closeIndex;\\n        } else if(xmlData[i+1] === '?') { \\n          const closeIndex = findClosingIndex(xmlData, \\\"?>\\\", i+1, \\\"StopNode is not closed.\\\")\\n          i=closeIndex;\\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \\n          const closeIndex = findClosingIndex(xmlData, \\\"-->\\\", i+3, \\\"StopNode is not closed.\\\")\\n          i=closeIndex;\\n        } else if(xmlData.substr(i + 1, 2) === '![') { \\n          const closeIndex = findClosingIndex(xmlData, \\\"]]>\\\", i, \\\"StopNode is not closed.\\\") - 2;\\n          i=closeIndex;\\n        } else {\\n          const tagData = readTagExp(xmlData, i, '>')\\n\\n          if (tagData) {\\n            const openTagName = tagData && tagData.tagName;\\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \\\"/\\\") {\\n              openTagCount++;\\n            }\\n            i=tagData.closeIndex;\\n          }\\n        }\\n      }\\n  }//end for loop\\n}\\n\\nfunction parseValue(val, shouldParse, options) {\\n  if (shouldParse && typeof val === 'string') {\\n    //console.log(options)\\n    const newval = val.trim();\\n    if(newval === 'true' ) return true;\\n    else if(newval === 'false' ) return false;\\n    else return toNumber(val, options);\\n  } else {\\n    if (util.isExist(val)) {\\n      return val;\\n    } else {\\n      return '';\\n    }\\n  }\\n}\\n\\n\\nmodule.exports = OrderedObjParser;\\n\",\"const { buildOptions} = require(\\\"./OptionsBuilder\\\");\\nconst OrderedObjParser = require(\\\"./OrderedObjParser\\\");\\nconst { prettify} = require(\\\"./node2json\\\");\\nconst validator = require('../validator');\\n\\nclass XMLParser{\\n    \\n    constructor(options){\\n        this.externalEntities = {};\\n        this.options = buildOptions(options);\\n        \\n    }\\n    /**\\n     * Parse XML dats to JS object \\n     * @param {string|Buffer} xmlData \\n     * @param {boolean|Object} validationOption \\n     */\\n    parse(xmlData,validationOption){\\n        if(typeof xmlData === \\\"string\\\"){\\n        }else if( xmlData.toString){\\n            xmlData = xmlData.toString();\\n        }else{\\n            throw new Error(\\\"XML data is accepted in String or Bytes[] form.\\\")\\n        }\\n        if( validationOption){\\n            if(validationOption === true) validationOption = {}; //validate with default options\\n            \\n            const result = validator.validate(xmlData, validationOption);\\n            if (result !== true) {\\n              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )\\n            }\\n          }\\n        const orderedObjParser = new OrderedObjParser(this.options);\\n        orderedObjParser.addExternalEntities(this.externalEntities);\\n        const orderedResult = orderedObjParser.parseXml(xmlData);\\n        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;\\n        else return prettify(orderedResult, this.options);\\n    }\\n\\n    /**\\n     * Add Entity which is not by default supported by this library\\n     * @param {string} key \\n     * @param {string} value \\n     */\\n    addEntity(key, value){\\n        if(value.indexOf(\\\"&\\\") !== -1){\\n            throw new Error(\\\"Entity value can't have '&'\\\")\\n        }else if(key.indexOf(\\\"&\\\") !== -1 || key.indexOf(\\\";\\\") !== -1){\\n            throw new Error(\\\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\\\")\\n        }else if(value === \\\"&\\\"){\\n            throw new Error(\\\"An entity with value '&' is not permitted\\\");\\n        }else{\\n            this.externalEntities[key] = value;\\n        }\\n    }\\n}\\n\\nmodule.exports = XMLParser;\",\"'use strict';\\n\\n/**\\n * \\n * @param {array} node \\n * @param {any} options \\n * @returns \\n */\\nfunction prettify(node, options){\\n  return compress( node, options);\\n}\\n\\n/**\\n * \\n * @param {array} arr \\n * @param {object} options \\n * @param {string} jPath \\n * @returns object\\n */\\nfunction compress(arr, options, jPath){\\n  let text;\\n  const compressedObj = {};\\n  for (let i = 0; i < arr.length; i++) {\\n    const tagObj = arr[i];\\n    const property = propName(tagObj);\\n    let newJpath = \\\"\\\";\\n    if(jPath === undefined) newJpath = property;\\n    else newJpath = jPath + \\\".\\\" + property;\\n\\n    if(property === options.textNodeName){\\n      if(text === undefined) text = tagObj[property];\\n      else text += \\\"\\\" + tagObj[property];\\n    }else if(property === undefined){\\n      continue;\\n    }else if(tagObj[property]){\\n      \\n      let val = compress(tagObj[property], options, newJpath);\\n      const isLeaf = isLeafTag(val, options);\\n\\n      if(tagObj[\\\":@\\\"]){\\n        assignAttributes( val, tagObj[\\\":@\\\"], newJpath, options);\\n      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){\\n        val = val[options.textNodeName];\\n      }else if(Object.keys(val).length === 0){\\n        if(options.alwaysCreateTextNode) val[options.textNodeName] = \\\"\\\";\\n        else val = \\\"\\\";\\n      }\\n\\n      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\\n        if(!Array.isArray(compressedObj[property])) {\\n            compressedObj[property] = [ compressedObj[property] ];\\n        }\\n        compressedObj[property].push(val);\\n      }else{\\n        //TODO: if a node is not an array, then check if it should be an array\\n        //also determine if it is a leaf node\\n        if (options.isArray(property, newJpath, isLeaf )) {\\n          compressedObj[property] = [val];\\n        }else{\\n          compressedObj[property] = val;\\n        }\\n      }\\n    }\\n    \\n  }\\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\\n  if(typeof text === \\\"string\\\"){\\n    if(text.length > 0) compressedObj[options.textNodeName] = text;\\n  }else if(text !== undefined) compressedObj[options.textNodeName] = text;\\n  return compressedObj;\\n}\\n\\nfunction propName(obj){\\n  const keys = Object.keys(obj);\\n  for (let i = 0; i < keys.length; i++) {\\n    const key = keys[i];\\n    if(key !== \\\":@\\\") return key;\\n  }\\n}\\n\\nfunction assignAttributes(obj, attrMap, jpath, options){\\n  if (attrMap) {\\n    const keys = Object.keys(attrMap);\\n    const len = keys.length; //don't make it inline\\n    for (let i = 0; i < len; i++) {\\n      const atrrName = keys[i];\\n      if (options.isArray(atrrName, jpath + \\\".\\\" + atrrName, true, true)) {\\n        obj[atrrName] = [ attrMap[atrrName] ];\\n      } else {\\n        obj[atrrName] = attrMap[atrrName];\\n      }\\n    }\\n  }\\n}\\n\\nfunction isLeafTag(obj, options){\\n  const propCount = Object.keys(obj).length;\\n  if( propCount === 0 || (propCount === 1 && obj[options.textNodeName]) ) return true;\\n  return false;\\n}\\nexports.prettify = prettify;\\n\",\"'use strict';\\n\\nclass XmlNode{\\n  constructor(tagname) {\\n    this.tagname = tagname;\\n    this.child = []; //nested tags, text, cdata, comments in order\\n    this[\\\":@\\\"] = {}; //attributes map\\n  }\\n  add(key,val){\\n    // this.child.push( {name : key, val: val, isCdata: isCdata });\\n    this.child.push( {[key]: val });\\n  }\\n  addChild(node) {\\n    if(node[\\\":@\\\"] && Object.keys(node[\\\":@\\\"]).length > 0){\\n      this.child.push( { [node.tagname]: node.child, [\\\":@\\\"]: node[\\\":@\\\"] });\\n    }else{\\n      this.child.push( { [node.tagname]: node.child });\\n    }\\n  };\\n};\\n\\n\\nmodule.exports = XmlNode;\",\"// The module cache\\nvar __webpack_module_cache__ = {};\\n\\n// The require function\\nfunction __webpack_require__(moduleId) {\\n\\t// Check if module is in cache\\n\\tvar cachedModule = __webpack_module_cache__[moduleId];\\n\\tif (cachedModule !== undefined) {\\n\\t\\treturn cachedModule.exports;\\n\\t}\\n\\t// Create a new module (and put it into the cache)\\n\\tvar module = __webpack_module_cache__[moduleId] = {\\n\\t\\t// no module.id needed\\n\\t\\t// no module.loaded needed\\n\\t\\texports: {}\\n\\t};\\n\\n\\t// Execute the module function\\n\\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\\n\\n\\t// Return the exports of the module\\n\\treturn module.exports;\\n}\\n\\n\",\"// startup\\n// Load entry module and return exports\\n// This entry module is referenced by other modules so it can't be inlined\\nvar __webpack_exports__ = __webpack_require__(870);\\n\"],\"names\":[\"hexRegex\",\"numRegex\",\"Number\",\"parseInt\",\"window\",\"parseFloat\",\"consider\",\"hex\",\"leadingZeros\",\"decimalPoint\",\"eNotation\",\"module\",\"exports\",\"str\",\"options\",\"Object\",\"assign\",\"trimmedStr\",\"trim\",\"undefined\",\"skipLike\",\"test\",\"match\",\"exec\",\"sign\",\"numTrimmedByZeros\",\"numStr\",\"indexOf\",\"replace\",\"length\",\"substr\",\"num\",\"search\",\"nameRegexp\",\"regexName\",\"RegExp\",\"isExist\",\"v\",\"isEmptyObject\",\"obj\",\"keys\",\"merge\",\"target\",\"a\",\"arrayMode\",\"len\",\"i\",\"getValue\",\"isName\",\"string\",\"getAllMatches\",\"regex\",\"matches\",\"allmatches\",\"startIndex\",\"lastIndex\",\"index\",\"push\",\"util\",\"require\",\"defaultOptions\",\"allowBooleanAttributes\",\"unpairedTags\",\"isWhiteSpace\",\"char\",\"readPI\",\"xmlData\",\"start\",\"tagname\",\"getErrorObject\",\"getLineNumberForPosition\",\"readCommentAndCDATA\",\"angleBracketsCount\",\"readAttributeStr\",\"attrStr\",\"startChar\",\"tagClosed\",\"value\",\"validate\",\"tags\",\"tagFound\",\"reachedRoot\",\"err\",\"tagStartPos\",\"closingTag\",\"tagName\",\"substring\",\"result\",\"attrStrStart\",\"isValid\",\"validateAttributeString\",\"code\",\"msg\",\"line\",\"otg\",\"pop\",\"openPos\",\"col\",\"afterAmp\",\"validateAmpersand\",\"JSON\",\"stringify\",\"map\",\"t\",\"validAttrStrRegxp\",\"attrNames\",\"getPositionFromMatch\",\"attrName\",\"validateAttrName\",\"hasOwnProperty\",\"re\",\"validateNumberAmpersand\",\"count\",\"message\",\"lineNumber\",\"lines\",\"split\",\"entityRegex\",\"parseEntityExp\",\"exp\",\"entities\",\"regx\",\"val\",\"Error\",\"hasBody\",\"entity\",\"comment\",\"preserveOrder\",\"attributeNamePrefix\",\"attributesGroupName\",\"textNodeName\",\"ignoreAttributes\",\"removeNSPrefix\",\"parseTagValue\",\"parseAttributeValue\",\"trimValues\",\"cdataPropName\",\"numberParseOptions\",\"tagValueProcessor\",\"attributeValueProcessor\",\"stopNodes\",\"alwaysCreateTextNode\",\"isArray\",\"commentPropName\",\"processEntities\",\"htmlEntities\",\"ignoreDeclaration\",\"ignorePiTags\",\"transformTagName\",\"buildOptions\",\"xmlNode\",\"readDocType\",\"toNumber\",\"addExternalEntities\",\"externalEntities\",\"entKeys\",\"ent\",\"this\",\"lastEntities\",\"parseTextData\",\"jPath\",\"dontTrim\",\"hasAttributes\",\"isLeafNode\",\"escapeEntities\",\"replaceEntitiesValue\",\"newval\",\"parseValue\",\"resolveNameSpace\",\"prefix\",\"charAt\",\"attrsRegx\",\"buildAttributesMap\",\"attrs\",\"oldVal\",\"aName\",\"newVal\",\"attrCollection\",\"parseXml\",\"xmlObj\",\"currentNode\",\"textData\",\"closeIndex\",\"findClosingIndex\",\"colonIndex\",\"saveTextToParentTag\",\"lastIndexOf\",\"tagsNodeStack\",\"tagData\",\"readTagExp\",\"childNode\",\"add\",\"tagExp\",\"attrExpPresent\",\"addChild\",\"endIndex\",\"docTypeEntities\",\"lastTag\",\"isItStopNode\",\"tagContent\",\"readStopNodeData\",\"child\",\"entityName\",\"ampEntity\",\"currentTagName\",\"allNodesExp\",\"stopNodePath\",\"stopNodeExp\",\"errMsg\",\"closingIndex\",\"closingChar\",\"attrBoundary\",\"ch\",\"data\",\"tagExpWithClosingIndex\",\"separatorIndex\",\"openTagCount\",\"shouldParse\",\"OrderedObjParser\",\"prettify\",\"validator\",\"XMLParser\",\"parse\",\"validationOption\",\"toString\",\"orderedObjParser\",\"orderedResult\",\"addEntity\",\"key\",\"compress\",\"arr\",\"text\",\"compressedObj\",\"newJpath\",\"tagObj\",\"property\",\"propName\",\"isLeaf\",\"isLeafTag\",\"assignAttributes\",\"Array\",\"attrMap\",\"jpath\",\"atrrName\",\"propCount\",\"node\",\"XmlNode\",\"__webpack_module_cache__\",\"__webpack_exports__\",\"__webpack_require__\",\"moduleId\",\"cachedModule\",\"__webpack_modules__\"],\"sourceRoot\":\"\"}",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "spec/entities_spec.js||spec/entities_spec.js": [
          "File: spec/entities_spec.js -> spec/entities_spec.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "128:         expect(result).toEqual(expected);",
          "129:     });",
          "131:     it(\"should parse attributes having '>' in value\", function() {",
          "132:         const xmlData = `",
          "133:         <?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "131:     it(\"should not throw error when DTD comments contain '<' or '>'\", function() {",
          "132:         const xmlData = `<!DOCTYPE greeting [<!-- < > < -->]>`;",
          "134:         const parser = new XMLParser();",
          "135:         parser.parse(xmlData);",
          "136:     });",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "526:         expect(result).toEqual(expected);",
          "527:     });",
          "",
          "[Removed Lines]",
          "528: });",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/xmlbuilder/json2xml.js||src/xmlbuilder/json2xml.js": [
          "File: src/xmlbuilder/json2xml.js -> src/xmlbuilder/json2xml.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "31:   ],",
          "32:   processEntities: true,",
          "33:   stopNodes: [],",
          "36: };",
          "38: function Builder(options) {",
          "",
          "[Removed Lines]",
          "34:   transformTagName: false,",
          "35:   transformAttributeName: false,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js": [
          "File: src/xmlparser/DocTypeReader.js -> src/xmlparser/DocTypeReader.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "14:         let hasBody = false, entity = false, comment = false;",
          "15:         let exp = \"\";",
          "16:         for(;i<xmlData.length;i++){",
          "18:                 if( hasBody &&",
          "19:                      xmlData[i+1] === '!' &&",
          "20:                      xmlData[i+2] === 'E' &&",
          "",
          "[Removed Lines]",
          "17:             if (xmlData[i] === '<') {",
          "",
          "[Added Lines]",
          "17:             if (xmlData[i] === '<' && !comment) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78:                 if(comment){",
          "79:                     if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){",
          "80:                         comment = false;",
          "83:                     }",
          "87:                 }",
          "89:                 if (angleBracketsCount === 0) {",
          "90:                   break;",
          "91:                 }",
          "",
          "[Removed Lines]",
          "81:                     }else{",
          "82:                         throw new Error(`Invalid XML comment in DOCTYPE`);",
          "84:                 }else if(entity){",
          "85:                     parseEntityExp(exp, entities);",
          "86:                     entity = false;",
          "88:                 angleBracketsCount--;",
          "",
          "[Added Lines]",
          "81:                         angleBracketsCount--;",
          "83:                 }else{",
          "84:                     if(entity) {",
          "85:                         parseEntityExp(exp, entities);",
          "86:                         entity = false;",
          "87:                     }",
          "88:                     angleBracketsCount--;",
          "",
          "---------------"
        ],
        "yarn.lock||yarn.lock": [
          "File: yarn.lock -> yarn.lock",
          "--- Hunk 1 ---",
          "[Context before]",
          "3833:     \"jsonify\" \"~0.0.0\"",
          "3835: \"json5@^1.0.1\":",
          "3839:   dependencies:",
          "3840:     \"minimist\" \"^1.2.0\"",
          "3842: \"json5@^2.1.2\":",
          "3849: \"jsonfile@^6.0.1\":",
          "3850:   \"integrity\" \"sha512-5dgndWOriYSm5cnYaJNhalLNDKOqFwyDB/rr1E9ZsGciGvKPs8R2xYGCacuf3z6K1YKDz182fd+fY3cn3pMqXQ==\"",
          "",
          "[Removed Lines]",
          "3836:   \"integrity\" \"sha512-aKS4WQjPenRxiQsC93MNfjx+nbF4PAdYzmd/1JIj8HYzqfbu86beTuNgXDzPknWk0n0uARlyewZo4s++ES36Ow==\"",
          "3837:   \"resolved\" \"https://registry.npmjs.org/json5/-/json5-1.0.1.tgz\"",
          "3838:   \"version\" \"1.0.1\"",
          "3843:   \"integrity\" \"sha512-f+8cldu7X/y7RAJurMEJmdoKXGB/X550w2Nr3tTbezL6RwEE/iMcm+tZnXeoZtKuOq6ft8+CqzEkrIgx1fPoQA==\"",
          "3844:   \"resolved\" \"https://registry.npmjs.org/json5/-/json5-2.2.0.tgz\"",
          "3845:   \"version\" \"2.2.0\"",
          "3846:   dependencies:",
          "3847:     \"minimist\" \"^1.2.5\"",
          "",
          "[Added Lines]",
          "3836:   \"integrity\" \"sha512-g1MWMLBiz8FKi1e4w0UyVL3w+iJceWAFBAaBnnGKOpNa5f8TLktkbre1+s6oICydWAm+HRUGTmI+//xv2hvXYA==\"",
          "3837:   \"resolved\" \"https://registry.npmjs.org/json5/-/json5-1.0.2.tgz\"",
          "3838:   \"version\" \"1.0.2\"",
          "3843:   \"integrity\" \"sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==\"",
          "3844:   \"resolved\" \"https://registry.npmjs.org/json5/-/json5-2.2.3.tgz\"",
          "3845:   \"version\" \"2.2.3\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3930:   \"version\" \"4.2.0\"",
          "3932: \"loader-utils@^1.4.0\":",
          "3936:   dependencies:",
          "3937:     \"big.js\" \"^5.2.2\"",
          "3938:     \"emojis-list\" \"^3.0.0\"",
          "",
          "[Removed Lines]",
          "3933:   \"integrity\" \"sha512-qH0WSMBtn/oHuwjy/NucEgbx5dbxxnxup9s4PVXJUDHZBQY+s0NWA9rJf53RBnQZxfch7euUui7hpoAPvALZdA==\"",
          "3934:   \"resolved\" \"https://registry.npmjs.org/loader-utils/-/loader-utils-1.4.0.tgz\"",
          "3935:   \"version\" \"1.4.0\"",
          "",
          "[Added Lines]",
          "3931:   \"integrity\" \"sha512-I5d00Pd/jwMD2QCduo657+YM/6L3KZu++pmX9VFncxaxvHcru9jx1lBaFft+r4Mt2jK0Yhp41XlRAihzPxHNCg==\"",
          "3932:   \"resolved\" \"https://registry.npmjs.org/loader-utils/-/loader-utils-1.4.2.tgz\"",
          "3933:   \"version\" \"1.4.2\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4103:   \"version\" \"1.0.1\"",
          "4105: \"minimatch@^3.0.0\", \"minimatch@^3.0.4\", \"minimatch@2 || 3\":",
          "4109:   dependencies:",
          "4110:     \"brace-expansion\" \"^1.1.7\"",
          "4113:   \"integrity\" \"sha512-Jsjnk4bw3YJqYzbdyBiNsPWHPfO++UGG749Cxs6peCu5Xg4nrena6OVxOYxrQTqww0Jmwt+Ref8rggumkTLz9Q==\"",
          "4114:   \"resolved\" \"https://registry.npmjs.org/minimist/-/minimist-1.2.6.tgz\"",
          "4115:   \"version\" \"1.2.6\"",
          "",
          "[Removed Lines]",
          "4106:   \"integrity\" \"sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==\"",
          "4107:   \"resolved\" \"https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz\"",
          "4108:   \"version\" \"3.0.4\"",
          "4112: \"minimist@^1.1.0\", \"minimist@^1.1.1\", \"minimist@^1.2.0\", \"minimist@^1.2.5\", \"minimist@^1.2.6\":",
          "",
          "[Added Lines]",
          "4104:   \"integrity\" \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\"",
          "4105:   \"resolved\" \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\"",
          "4106:   \"version\" \"3.1.2\"",
          "4110: \"minimist@^1.1.0\", \"minimist@^1.1.1\", \"minimist@^1.2.0\", \"minimist@^1.2.6\":",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9a880b887916855c3a510869fd1ee268d7fe58b1",
      "candidate_info": {
        "commit_hash": "9a880b887916855c3a510869fd1ee268d7fe58b1",
        "repo": "NaturalIntelligence/fast-xml-parser",
        "commit_url": "https://github.com/NaturalIntelligence/fast-xml-parser/commit/9a880b887916855c3a510869fd1ee268d7fe58b1",
        "files": [
          "spec/entities_spec.js",
          "src/xmlparser/DocTypeReader.js"
        ],
        "message": "Merge pull request from GHSA-gpv5-7x3g-ghjv\n\nCo-authored-by: Julian Gilbey <jdg@debian.org>",
        "before_after_code_files": [
          "spec/entities_spec.js||spec/entities_spec.js",
          "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "spec/entities_spec.js||spec/entities_spec.js",
            "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js"
          ],
          "candidate": [
            "spec/entities_spec.js||spec/entities_spec.js",
            "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js"
          ]
        }
      },
      "candidate_diff": {
        "spec/entities_spec.js||spec/entities_spec.js": [
          "File: spec/entities_spec.js -> spec/entities_spec.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "392:         expect(() =>{",
          "393:             const parser = new XMLParser(options);",
          "394:             parser.parse(xmlData);",
          "396:     });",
          "397: });",
          "",
          "[Removed Lines]",
          "395:         }).toThrowError(\"Invalid character $ in entity name\")",
          "",
          "[Added Lines]",
          "396:         }).toThrowError(\"Invalid entity name nj$\")",
          "397:     });",
          "399:     it(\"should allow localised entity names\", function() {",
          "400:         const xmlData = `",
          "401:         <?xml version=\"1.0\" encoding=\"UTF-8\"?>",
          "403:         <!DOCTYPE note [",
          "404:         <!ENTITY \u1200\u120e \"Amharic hello!\">",
          "405:         <!ENTITY \u0417\u0434\u0440\u0430\u0432\u043e \"Macedonian hello.\">",
          "406:         ]>",
          "408:         <note>",
          "409:             <heading>Reminder</heading>",
          "410:             <body attr=\"&\u1200\u120e;\">Don't forget me this weekend! &\u0417\u0434\u0440\u0430\u0432\u043e;</body>",
          "411:         </note> `;",
          "413:         const expected = {",
          "414:             \"?xml\": {",
          "415:                 \"version\": \"1.0\",",
          "416:                 \"encoding\": \"UTF-8\"",
          "417:             },",
          "418:             \"note\": {",
          "419:                 \"heading\": \"Reminder\",",
          "420:                 \"body\": {",
          "421:                     \"#text\": \"Don't forget me this weekend! Macedonian hello.\",",
          "422:                     \"attr\": \"Amharic hello!\"",
          "423:                 }",
          "424:             }",
          "425:         };",
          "427:         const options = {",
          "428:             attributeNamePrefix: \"\",",
          "429:             ignoreAttributes:    false,",
          "430:             processEntities: true,",
          "431:             htmlEntities: true",
          "432:         };",
          "433:         const parser = new XMLParser(options);",
          "434:         let result = parser.parse(xmlData);",
          "437:         expect(result).toEqual(expected);",
          "",
          "---------------"
        ],
        "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js": [
          "File: src/xmlparser/DocTypeReader.js -> src/xmlparser/DocTypeReader.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: function readDocType(xmlData, i){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const util = require('../util');",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "145: const specialChar = \"!?\\\\\\/[]$%{}^&*()<>|+\";",
          "147: function validateEntityName(name){",
          "153: }",
          "",
          "[Removed Lines]",
          "148:     for (let i = 0; i < specialChar.length; i++) {",
          "149:         const ch = specialChar[i];",
          "150:         if(name.indexOf(ch) !== -1) throw new Error(`Invalid character ${ch} in entity name`);",
          "151:     }",
          "152:     return name;",
          "155: module.exports = readDocType;",
          "",
          "[Added Lines]",
          "150:     if (util.isName(name))",
          "151:  return name;",
          "152:     else",
          "153:         throw new Error(`Invalid entity name ${name}`);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f6a1da18895aba52bab8c452e710d22acc5989c9",
      "candidate_info": {
        "commit_hash": "f6a1da18895aba52bab8c452e710d22acc5989c9",
        "repo": "NaturalIntelligence/fast-xml-parser",
        "commit_url": "https://github.com/NaturalIntelligence/fast-xml-parser/commit/f6a1da18895aba52bab8c452e710d22acc5989c9",
        "files": [
          "spec/entities_spec.js",
          "src/xmlparser/DocTypeReader.js"
        ],
        "message": "fix DOCTYPE: allow !ATTLIST and !NOTATION",
        "before_after_code_files": [
          "spec/entities_spec.js||spec/entities_spec.js",
          "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "spec/entities_spec.js||spec/entities_spec.js",
            "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js"
          ],
          "candidate": [
            "spec/entities_spec.js||spec/entities_spec.js",
            "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js"
          ]
        }
      },
      "candidate_diff": {
        "spec/entities_spec.js||spec/entities_spec.js": [
          "File: spec/entities_spec.js -> spec/entities_spec.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "217:         expect(result).toEqual(expected);",
          "218:     });",
          "220:     it(\"should build by decoding defaul entities\", function() {",
          "221:         const jsObj = {",
          "222:             \"note\": {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "217:         expect(result).toEqual(expected);",
          "218:     });",
          "220:     it(\"should allow !ATTLIST & !NOTATION\", function() {",
          "221:         const xmlData = `<?xml version=\"1.0\"?>",
          "222:         <!DOCTYPE code [",
          "223:           <!ELEMENT code (#PCDATA)>",
          "224:           <!NOTATION vrml PUBLIC \"VRML 1.0\">",
          "225:           <!ATTLIST code lang NOTATION (vrml) #REQUIRED>",
          "226:         ]>",
          "227:         <code lang=\"vrml\">Some VRML instructions</code>`;",
          "229:         const expected = {",
          "230:             \"?xml\": {",
          "231:                 \"version\": \"1.0\"",
          "232:             },",
          "233:             \"code\": {",
          "234:                 \"lang\": 'vrml',",
          "235:                 \"#text\": 'Some VRML instructions'",
          "236:             }",
          "237:         };",
          "239:         const options = {",
          "240:             attributeNamePrefix: \"\",",
          "241:             ignoreAttributes:    false,",
          "242:             processEntities: true",
          "243:         };",
          "244:         const parser = new XMLParser(options);",
          "245:         let result = parser.parse(xmlData);",
          "",
          "---------------"
        ],
        "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js": [
          "File: src/xmlparser/DocTypeReader.js -> src/xmlparser/DocTypeReader.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "38:                 ){",
          "40:                     i += 8;",
          "41:                 }else if( //comment",
          "42:                     xmlData[i+1] === '!' &&",
          "43:                     xmlData[i+2] === '-' &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "41:                 }else if( hasBody &&",
          "42:                     xmlData[i+1] === '!' &&",
          "43:                     xmlData[i+2] === 'A' &&",
          "44:                     xmlData[i+3] === 'T' &&",
          "45:                     xmlData[i+4] === 'T' &&",
          "46:                     xmlData[i+5] === 'L' &&",
          "47:                     xmlData[i+6] === 'I' &&",
          "48:                     xmlData[i+7] === 'S' &&",
          "49:                     xmlData[i+8] === 'T'",
          "50:                 ){",
          "52:                     i += 8;",
          "53:                 }else if( hasBody &&",
          "54:                     xmlData[i+1] === '!' &&",
          "55:                     xmlData[i+2] === 'N' &&",
          "56:                     xmlData[i+3] === 'O' &&",
          "57:                     xmlData[i+4] === 'T' &&",
          "58:                     xmlData[i+5] === 'A' &&",
          "59:                     xmlData[i+6] === 'T' &&",
          "60:                     xmlData[i+7] === 'I' &&",
          "61:                     xmlData[i+8] === 'O' &&",
          "62:                     xmlData[i+9] === 'N'",
          "63:                 ){",
          "65:                     i += 9;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0955739fc404fbb048002920bdaec2d3e469308d",
      "candidate_info": {
        "commit_hash": "0955739fc404fbb048002920bdaec2d3e469308d",
        "repo": "NaturalIntelligence/fast-xml-parser",
        "commit_url": "https://github.com/NaturalIntelligence/fast-xml-parser/commit/0955739fc404fbb048002920bdaec2d3e469308d",
        "files": [
          "src/xmlparser/DocTypeReader.js"
        ],
        "message": "fix: security bug",
        "before_after_code_files": [
          "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js"
          ],
          "candidate": [
            "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js"
          ]
        }
      },
      "candidate_diff": {
        "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js": [
          "File: src/xmlparser/DocTypeReader.js -> src/xmlparser/DocTypeReader.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "147: function validateEntityName(name){",
          "148:     for (let i = 0; i < specialChar.length; i++) {",
          "",
          "[Removed Lines]",
          "145: const specialChar = \"!?\\\\\\/[]$%{}^&*()<>\";",
          "",
          "[Added Lines]",
          "145: const specialChar = \"!?\\\\\\/[]$%{}^&*()<>|+\";",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a4bdced80369892ee413bf08e28b78795a2b0d5b",
      "candidate_info": {
        "commit_hash": "a4bdced80369892ee413bf08e28b78795a2b0d5b",
        "repo": "NaturalIntelligence/fast-xml-parser",
        "commit_url": "https://github.com/NaturalIntelligence/fast-xml-parser/commit/a4bdced80369892ee413bf08e28b78795a2b0d5b",
        "files": [
          "spec/entities_spec.js",
          "src/xmlparser/DocTypeReader.js"
        ],
        "message": "fix #546: Support complex entity value",
        "before_after_code_files": [
          "spec/entities_spec.js||spec/entities_spec.js",
          "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "spec/entities_spec.js||spec/entities_spec.js",
            "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js"
          ],
          "candidate": [
            "spec/entities_spec.js||spec/entities_spec.js",
            "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js"
          ]
        }
      },
      "candidate_diff": {
        "spec/entities_spec.js||spec/entities_spec.js": [
          "File: spec/entities_spec.js -> spec/entities_spec.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "533:         expect(result).toEqual(expected);",
          "534:     });",
          "535: });",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "536:     fit(\"should support entites with tags in content\", function() {",
          "537:         const xmlData = `",
          "538:         <?xml version=\"1.0\" encoding=\"utf-8\"?>",
          "539: <!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\" [",
          "540:  <!ENTITY Smile \"",
          "541:      <rect x='.5' y='.5' width='29' height='39' fill='black' stroke='red'/>",
          "542:   <g transform='translate(0, 5)'>",
          "543:    <circle cx='15' cy='15' r='10' fill='yellow'/>",
          "544:    <circle cx='12' cy='12' r='1.5' fill='black'/>",
          "545:    <circle cx='17' cy='12' r='1.5' fill='black'/>",
          "546:    <path d='M 10 19 L 15 23 20 19' stroke='black' stroke-width='2'/></g>\"",
          "547:  >",
          "548: ]>",
          "549: <svg width=\"850px\" height=\"700px\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">",
          "550: <g transform=\"matrix(16,0,0,16,0,0)\">&Smile;</g></svg> `;",
          "552:         const expected = {",
          "553:             \"?xml\": {",
          "554:                 \"version\": \"1.0\",",
          "555:                 \"encoding\": \"utf-8\"",
          "556:             },",
          "557:             \"svg\": {",
          "558:                 \"g\": {",
          "559:                     \"#text\": \" \\n    \\t<rect x='.5' y='.5' width='29' height='39' fill='black' stroke='red'/>\\n\\t\\t<g transform='translate(0, 5)'> \\n\\t\\t\\t<circle cx='15' cy='15' r='10' fill='yellow'/>\\n\\t\\t\\t<circle cx='12' cy='12' r='1.5' fill='black'/>\\n\\t\\t\\t<circle cx='17' cy='12' r='1.5' fill='black'/>\\n\\t\\t\\t<path d='M 10 19 L 15 23 20 19' stroke='black' stroke-width='2'/></g>\",",
          "560:                     \"transform\": \"matrix(16,0,0,16,0,0)\"",
          "561:                 },",
          "562:                 \"width\": \"850px\",",
          "563:                 \"height\": \"700px\",",
          "564:                 \"version\": \"1.1\",",
          "565:                 \"xmlns\": \"http://www.w3.org/2000/svg\"",
          "566:             }",
          "567:         };",
          "569:         const options = {",
          "570:             attributeNamePrefix: \"\",",
          "571:             ignoreAttributes:    false,",
          "572:             processEntities: true,",
          "574:         };",
          "575:         const parser = new XMLParser(options);",
          "576:         let result = parser.parse(xmlData);",
          "579:         expect(result).toEqual(expected);",
          "580:     });",
          "",
          "---------------"
        ],
        "src/xmlparser/DocTypeReader.js||src/xmlparser/DocTypeReader.js": [
          "File: src/xmlparser/DocTypeReader.js -> src/xmlparser/DocTypeReader.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:     {",
          "12:         i = i+9;",
          "13:         let angleBracketsCount = 1;",
          "15:         let exp = \"\";",
          "16:         for(;i<xmlData.length;i++){",
          "74:                 }",
          "75:                 angleBracketsCount++;",
          "76:                 exp = \"\";",
          "78:                 if(comment){",
          "79:                     if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){",
          "80:                         comment = false;",
          "81:                         angleBracketsCount--;",
          "82:                     }",
          "83:                 }else{",
          "88:                     angleBracketsCount--;",
          "89:                 }",
          "90:                 if (angleBracketsCount === 0) {",
          "",
          "[Removed Lines]",
          "14:         let hasBody = false, entity = false, comment = false;",
          "17:             if (xmlData[i] === '<' && !comment) {",
          "18:                 if( hasBody &&",
          "19:                      xmlData[i+1] === '!' &&",
          "20:                      xmlData[i+2] === 'E' &&",
          "21:                      xmlData[i+3] === 'N' &&",
          "22:                      xmlData[i+4] === 'T' &&",
          "23:                      xmlData[i+5] === 'I' &&",
          "24:                      xmlData[i+6] === 'T' &&",
          "25:                      xmlData[i+7] === 'Y'",
          "26:                 ){",
          "27:                     i += 7;",
          "28:                     entity = true;",
          "29:                 }else if( hasBody &&",
          "30:                     xmlData[i+1] === '!' &&",
          "31:                      xmlData[i+2] === 'E' &&",
          "32:                      xmlData[i+3] === 'L' &&",
          "33:                      xmlData[i+4] === 'E' &&",
          "34:                      xmlData[i+5] === 'M' &&",
          "35:                      xmlData[i+6] === 'E' &&",
          "36:                      xmlData[i+7] === 'N' &&",
          "37:                      xmlData[i+8] === 'T'",
          "38:                 ){",
          "40:                     i += 8;",
          "41:                 }else if( hasBody &&",
          "42:                     xmlData[i+1] === '!' &&",
          "43:                     xmlData[i+2] === 'A' &&",
          "44:                     xmlData[i+3] === 'T' &&",
          "45:                     xmlData[i+4] === 'T' &&",
          "46:                     xmlData[i+5] === 'L' &&",
          "47:                     xmlData[i+6] === 'I' &&",
          "48:                     xmlData[i+7] === 'S' &&",
          "49:                     xmlData[i+8] === 'T'",
          "50:                 ){",
          "52:                     i += 8;",
          "53:                 }else if( hasBody &&",
          "54:                     xmlData[i+1] === '!' &&",
          "55:                     xmlData[i+2] === 'N' &&",
          "56:                     xmlData[i+3] === 'O' &&",
          "57:                     xmlData[i+4] === 'T' &&",
          "58:                     xmlData[i+5] === 'A' &&",
          "59:                     xmlData[i+6] === 'T' &&",
          "60:                     xmlData[i+7] === 'I' &&",
          "61:                     xmlData[i+8] === 'O' &&",
          "62:                     xmlData[i+9] === 'N'",
          "63:                 ){",
          "65:                     i += 9;",
          "66:                 }else if( //comment",
          "67:                     xmlData[i+1] === '!' &&",
          "68:                     xmlData[i+2] === '-' &&",
          "69:                     xmlData[i+3] === '-'",
          "70:                 ){",
          "71:                     comment = true;",
          "72:                 }else{",
          "73:                     throw new Error(\"Invalid DOCTYPE\");",
          "77:             } else if (xmlData[i] === '>') {",
          "84:                     if(entity) {",
          "85:                         parseEntityExp(exp, entities);",
          "86:                         entity = false;",
          "87:                     }",
          "",
          "[Added Lines]",
          "14:         let hasBody = false, comment = false;",
          "17:             if (xmlData[i] === '<' && !comment) { //Determine the tag type",
          "18:                 if( hasBody && isEntity(xmlData, i)){",
          "19:                     i += 7;",
          "20:                     [entityName, val,i] = readEntityExp(xmlData,i+1);",
          "21:                     if(val.indexOf(\"&\") === -1) //Parameter entities are not supported",
          "22:                         entities[ entityName ] = {",
          "23:                             regx : RegExp( `&${entityName};`,\"g\"),",
          "24:                             val: val",
          "25:                         };",
          "27:                 else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported",
          "28:                 else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported",
          "29:                 else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported",
          "30:                 else if( isComment)                         comment = true;",
          "31:                 else                                        throw new Error(\"Invalid DOCTYPE\");",
          "35:             } else if (xmlData[i] === '>') { //Read tag content",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "105:     return {entities, i};",
          "106: }",
          "116:     }",
          "117: }",
          "118: module.exports = readDocType;",
          "",
          "[Removed Lines]",
          "108: const entityRegex = RegExp(\"^\\\\s([a-zA-z0-0]+)[ \\t](['\\\"])([^&]+)\\\\2\");",
          "109: function parseEntityExp(exp, entities){",
          "110:     const match = entityRegex.exec(exp);",
          "111:     if(match){",
          "112:         entities[ match[1] ] = {",
          "113:             regx : RegExp( `&${match[1]};`,\"g\"),",
          "114:             val: match[3]",
          "115:         };",
          "",
          "[Added Lines]",
          "62: function readEntityExp(xmlData,i){",
          "73:     let entityName = \"\";",
          "74:     for (; i < xmlData.length && (xmlData[i] !== \"'\" && xmlData[i] !== '\"' ); i++) {",
          "77:         entityName += xmlData[i];",
          "78:     }",
          "79:     entityName = entityName.trim();",
          "80:     if(entityName.indexOf(\" \") !== -1) throw new Error(\"External entites are not supported\");",
          "83:     const startChar = xmlData[i++];",
          "84:     let val = \"\"",
          "85:     for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {",
          "86:         val += xmlData[i];",
          "88:     return [entityName, val, i];",
          "91: function isComment(xmlData, i){",
          "92:     if(xmlData[i+1] === '!' &&",
          "93:     xmlData[i+2] === '-' &&",
          "94:     xmlData[i+3] === '-') return true",
          "95:     return false",
          "96: }",
          "97: function isEntity(xmlData, i){",
          "98:     if(xmlData[i+1] === '!' &&",
          "99:     xmlData[i+2] === 'E' &&",
          "100:     xmlData[i+3] === 'N' &&",
          "101:     xmlData[i+4] === 'T' &&",
          "102:     xmlData[i+5] === 'I' &&",
          "103:     xmlData[i+6] === 'T' &&",
          "104:     xmlData[i+7] === 'Y') return true",
          "105:     return false",
          "106: }",
          "107: function isElement(xmlData, i){",
          "108:     if(xmlData[i+1] === '!' &&",
          "109:     xmlData[i+2] === 'E' &&",
          "110:     xmlData[i+3] === 'L' &&",
          "111:     xmlData[i+4] === 'E' &&",
          "112:     xmlData[i+5] === 'M' &&",
          "113:     xmlData[i+6] === 'E' &&",
          "114:     xmlData[i+7] === 'N' &&",
          "115:     xmlData[i+8] === 'T') return true",
          "116:     return false",
          "117: }",
          "119: function isAttlist(xmlData, i){",
          "120:     if(xmlData[i+1] === '!' &&",
          "121:     xmlData[i+2] === 'A' &&",
          "122:     xmlData[i+3] === 'T' &&",
          "123:     xmlData[i+4] === 'T' &&",
          "124:     xmlData[i+5] === 'L' &&",
          "125:     xmlData[i+6] === 'I' &&",
          "126:     xmlData[i+7] === 'S' &&",
          "127:     xmlData[i+8] === 'T') return true",
          "128:     return false",
          "129: }",
          "130: function isNotation(xmlData, i){",
          "131:     if(xmlData[i+1] === '!' &&",
          "132:     xmlData[i+2] === 'N' &&",
          "133:     xmlData[i+3] === 'O' &&",
          "134:     xmlData[i+4] === 'T' &&",
          "135:     xmlData[i+5] === 'A' &&",
          "136:     xmlData[i+6] === 'T' &&",
          "137:     xmlData[i+7] === 'I' &&",
          "138:     xmlData[i+8] === 'O' &&",
          "139:     xmlData[i+9] === 'N') return true",
          "140:     return false",
          "141: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
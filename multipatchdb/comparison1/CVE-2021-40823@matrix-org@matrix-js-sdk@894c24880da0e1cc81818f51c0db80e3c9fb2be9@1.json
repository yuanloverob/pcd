{
  "cve_id": "CVE-2021-40823",
  "cve_desc": "A logic error in the room key sharing functionality of matrix-js-sdk (aka Matrix Javascript SDK) before 12.4.1 allows a malicious Matrix homeserver present in an encrypted room to steal room encryption keys (via crafted Matrix protocol messages) that were originally sent by affected Matrix clients participating in that room. This allows the homeserver to decrypt end-to-end encrypted messages sent by affected clients.",
  "repo": "matrix-org/matrix-js-sdk",
  "patch_hash": "894c24880da0e1cc81818f51c0db80e3c9fb2be9",
  "patch_info": {
    "commit_hash": "894c24880da0e1cc81818f51c0db80e3c9fb2be9",
    "repo": "matrix-org/matrix-js-sdk",
    "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/894c24880da0e1cc81818f51c0db80e3c9fb2be9",
    "files": [
      "src/crypto/algorithms/megolm.ts"
    ],
    "message": "Verify target device key on reshare",
    "before_after_code_files": [
      "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
    ]
  },
  "patch_diff": {
    "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
      "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
      "--- Hunk 1 ---",
      "[Context before]",
      "101: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "104: interface SharedWithData {",
      "106:     deviceKey: string;",
      "108:     messageIndex: number;",
      "109: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "120: class OutboundSessionInfo {",
      "121:     public useCount = 0;",
      "122:     public creationTime: number;",
      "124:     public blockedDevicesNotified: Record<string, Record<string, boolean>> = {};",
      "126:     constructor(public readonly sessionId: string, public readonly sharedHistory = false) {",
      "",
      "[Removed Lines]",
      "123:     public sharedWithDevices: Record<string, Record<string, number>> = {};",
      "",
      "[Added Lines]",
      "130:     public sharedWithDevices: Record<string, Record<string, SharedWithData>> = {};",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "150:         return false;",
      "151:     }",
      "154:         if (!this.sharedWithDevices[userId]) {",
      "155:             this.sharedWithDevices[userId] = {};",
      "156:         }",
      "158:     }",
      "160:     public markNotifiedBlockedDevice(userId: string, deviceId: string): void {",
      "",
      "[Removed Lines]",
      "153:     public markSharedWithDevice(userId: string, deviceId: string, chainIndex: number): void {",
      "157:         this.sharedWithDevices[userId][deviceId] = chainIndex;",
      "",
      "[Added Lines]",
      "160:     public markSharedWithDevice(userId: string, deviceId: string, deviceKey: string, chainIndex: number): void {",
      "164:         this.sharedWithDevices[userId][deviceId] = { deviceKey, messageIndex: chainIndex };",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "572:         payload: IPayload,",
      "573:     ): Promise<void> {",
      "574:         const contentMap = {};",
      "576:         const promises = [];",
      "577:         for (let i = 0; i < userDeviceMap.length; i++) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "582:         const deviceInfoByDeviceId = new Map<string, DeviceInfo>();",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "584:             const userId = val.userId;",
      "585:             const deviceInfo = val.deviceInfo;",
      "586:             const deviceId = deviceInfo.deviceId;",
      "588:             if (!contentMap[userId]) {",
      "589:                 contentMap[userId] = {};",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "595:             deviceInfoByDeviceId.set(deviceId, deviceInfo);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "636:                 for (const userId of Object.keys(contentMap)) {",
      "637:                     for (const deviceId of Object.keys(contentMap[userId])) {",
      "638:                         session.markSharedWithDevice(",
      "640:                         );",
      "641:                     }",
      "642:                 }",
      "",
      "[Removed Lines]",
      "639:                             userId, deviceId, chainIndex,",
      "",
      "[Added Lines]",
      "648:                             userId,",
      "649:                             deviceId,",
      "650:                             deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
      "651:                             chainIndex,",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "719:             logger.debug(`megolm session ${sessionId} never shared with user ${userId}`);",
      "720:             return;",
      "721:         }",
      "724:             logger.debug(",
      "725:                 \"megolm session ID \" + sessionId + \" never shared with device \" +",
      "726:                 userId + \":\" + device.deviceId,",
      "",
      "[Removed Lines]",
      "722:         const sentChainIndex = obSessionInfo.sharedWithDevices[userId][device.deviceId];",
      "723:         if (sentChainIndex === undefined) {",
      "",
      "[Added Lines]",
      "734:         const sessionSharedData = obSessionInfo.sharedWithDevices[userId][device.deviceId];",
      "735:         if (sessionSharedData === undefined) {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "728:             return;",
      "729:         }",
      "733:         const key = await this.olmDevice.getInboundGroupSessionKey(",
      "735:         );",
      "737:         if (!key) {",
      "",
      "[Removed Lines]",
      "734:             this.roomId, senderKey, sessionId, sentChainIndex,",
      "",
      "[Added Lines]",
      "743:         if (sessionSharedData.deviceKey !== device.getIdentityKey()) {",
      "744:             logger.warn(",
      "745:                 `Session has been shared with device ${device.deviceId} but with identity ` +",
      "746:                 `key ${sessionSharedData.deviceKey}. Key is now ${device.getIdentityKey()}!`,",
      "747:             );",
      "748:             return;",
      "749:         }",
      "754:             this.roomId, senderKey, sessionId, sessionSharedData.messageIndex,",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "882:             const deviceId = deviceInfo.deviceId;",
      "884:             session.markSharedWithDevice(",
      "886:             );",
      "887:         }",
      "",
      "[Removed Lines]",
      "885:                 userId, deviceId, key.chain_index,",
      "",
      "[Added Lines]",
      "905:                 userId, deviceId, deviceInfo.getIdentityKey(), key.chain_index,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "adaebb4dff092ed2eeb63d2fec3190c85a910f57",
      "candidate_info": {
        "commit_hash": "adaebb4dff092ed2eeb63d2fec3190c85a910f57",
        "repo": "matrix-org/matrix-js-sdk",
        "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/adaebb4dff092ed2eeb63d2fec3190c85a910f57",
        "files": [
          "src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts"
        ],
        "message": "untested first cut at factoring out a encryptAndSendToDevices method",
        "before_after_code_files": [
          "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts||src/crypto/index.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ],
          "candidate": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ]
        }
      },
      "candidate_diff": {
        "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
          "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "578:         userDeviceMap: IOlmDevice[],",
          "579:         payload: IPayload,",
          "580:     ): Promise<void> {",
          "620:             for (const userId of Object.keys(contentMap)) {",
          "621:                 for (const deviceId of Object.keys(contentMap[userId])) {",
          "634:                 }",
          "635:             }",
          "656:         });",
          "657:     }",
          "",
          "[Removed Lines]",
          "581:         const contentMap = {};",
          "582:         const deviceInfoByDeviceId = new Map<string, DeviceInfo>();",
          "584:         const promises = [];",
          "585:         for (let i = 0; i < userDeviceMap.length; i++) {",
          "586:             const encryptedContent = {",
          "587:                 algorithm: olmlib.OLM_ALGORITHM,",
          "588:                 sender_key: this.olmDevice.deviceCurve25519Key,",
          "589:                 ciphertext: {},",
          "590:             };",
          "591:             const val = userDeviceMap[i];",
          "592:             const userId = val.userId;",
          "593:             const deviceInfo = val.deviceInfo;",
          "594:             const deviceId = deviceInfo.deviceId;",
          "595:             deviceInfoByDeviceId.set(deviceId, deviceInfo);",
          "597:             if (!contentMap[userId]) {",
          "598:                 contentMap[userId] = {};",
          "599:             }",
          "600:             contentMap[userId][deviceId] = encryptedContent;",
          "602:             promises.push(",
          "603:                 olmlib.encryptMessageForDevice(",
          "604:                     encryptedContent.ciphertext,",
          "605:                     this.userId,",
          "606:                     this.deviceId,",
          "607:                     this.olmDevice,",
          "608:                     userId,",
          "609:                     deviceInfo,",
          "610:                     payload,",
          "611:                 ),",
          "612:             );",
          "613:         }",
          "615:         return Promise.all(promises).then(() => {",
          "622:                     if (Object.keys(contentMap[userId][deviceId].ciphertext).length === 0) {",
          "623:                         logger.log(",
          "624:                             \"No ciphertext for device \" +",
          "625:                             userId + \":\" + deviceId + \": pruning\",",
          "626:                         );",
          "627:                         delete contentMap[userId][deviceId];",
          "628:                     }",
          "629:                 }",
          "631:                 if (Object.keys(contentMap[userId]).length === 0) {",
          "632:                     logger.log(\"Pruned all devices for user \" + userId);",
          "633:                     delete contentMap[userId];",
          "638:             if (Object.keys(contentMap).length === 0) {",
          "639:                 logger.log(\"No users left to send to: aborting\");",
          "640:                 return;",
          "641:             }",
          "643:             return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap).then(() => {",
          "645:                 for (const userId of Object.keys(contentMap)) {",
          "646:                     for (const deviceId of Object.keys(contentMap[userId])) {",
          "647:                         session.markSharedWithDevice(",
          "648:                             userId,",
          "649:                             deviceId,",
          "650:                             deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
          "651:                             chainIndex,",
          "652:                         );",
          "653:                     }",
          "654:                 }",
          "655:             });",
          "",
          "[Added Lines]",
          "581:         this.crypto.encryptAndSendToDevices(",
          "582:             userDeviceMap,",
          "583:             payload",
          "584:         ).then(() => {",
          "588:                     session.markSharedWithDevice(",
          "589:                         userId,",
          "590:                         deviceId,",
          "591:                         deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
          "592:                         chainIndex,",
          "593:                     );",
          "",
          "---------------"
        ],
        "src/crypto/index.ts||src/crypto/index.ts": [
          "File: src/crypto/index.ts -> src/crypto/index.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "3030:         });",
          "3031:     }",
          "3033:     private onToDeviceEvent = (event: MatrixEvent): void => {",
          "3034:         try {",
          "3035:             logger.log(`received to_device ${event.getType()} from: ` +",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3047:     private encryptAndSendToDevices(",
          "3048:         userDeviceMap: IExportedDevice[],",
          "3049:         payload: object,",
          "3050:     ): Promise<{}> {",
          "3051:         const contentMap = {};",
          "3052:         const deviceInfoByDeviceId = new Map<string, DeviceInfo>();",
          "3054:         const promises = [];",
          "3055:         for (let i = 0; i < userDeviceMap.length; i++) {",
          "3056:             const encryptedContent = {",
          "3057:                 algorithm: olmlib.OLM_ALGORITHM,",
          "3058:                 sender_key: this.olmDevice.deviceCurve25519Key,",
          "3059:                 ciphertext: {},",
          "3060:             };",
          "3061:             const val = userDeviceMap[i];",
          "3062:             const userId = val.userId;",
          "3063:             const deviceInfo = val.deviceInfo;",
          "3064:             const deviceId = deviceInfo.deviceId;",
          "3065:             deviceInfoByDeviceId.set(deviceId, deviceInfo);",
          "3067:             if (!contentMap[userId]) {",
          "3068:                 contentMap[userId] = {};",
          "3069:             }",
          "3070:             contentMap[userId][deviceId] = encryptedContent;",
          "3072:             promises.push(",
          "3073:                 olmlib.encryptMessageForDevice(",
          "3074:                     encryptedContent.ciphertext,",
          "3075:                     this.userId,",
          "3076:                     this.deviceId,",
          "3077:                     this.olmDevice,",
          "3078:                     userId,",
          "3079:                     deviceInfo,",
          "3080:                     payload,",
          "3081:                 ),",
          "3082:             );",
          "3083:         }",
          "3085:         return Promise.all(promises).then(() => {",
          "3090:             for (const userId of Object.keys(contentMap)) {",
          "3091:                 for (const deviceId of Object.keys(contentMap[userId])) {",
          "3092:                     if (Object.keys(contentMap[userId][deviceId].ciphertext).length === 0) {",
          "3093:                         logger.log(",
          "3094:                             \"No ciphertext for device \" +",
          "3095:                             userId + \":\" + deviceId + \": pruning\",",
          "3096:                         );",
          "3097:                         delete contentMap[userId][deviceId];",
          "3098:                     }",
          "3099:                 }",
          "3101:                 if (Object.keys(contentMap[userId]).length === 0) {",
          "3102:                     logger.log(\"Pruned all devices for user \" + userId);",
          "3103:                     delete contentMap[userId];",
          "3104:                 }",
          "3105:             }",
          "3108:             if (Object.keys(contentMap).length === 0) {",
          "3109:                 logger.log(\"No users left to send to: aborting\");",
          "3110:                 return;",
          "3111:             }",
          "3113:             return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap);",
          "3114:         });",
          "3115:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5a83635ef55307364ca4b8624f0500cd1a27695c",
      "candidate_info": {
        "commit_hash": "5a83635ef55307364ca4b8624f0500cd1a27695c",
        "repo": "matrix-org/matrix-js-sdk",
        "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/5a83635ef55307364ca4b8624f0500cd1a27695c",
        "files": [
          "src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts"
        ],
        "message": "switch encryptAndSendToDevices to return a promise rather than use a cb\n\nand assert that olm sessions are open to the destination devices",
        "before_after_code_files": [
          "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts||src/crypto/index.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ],
          "candidate": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ]
        }
      },
      "candidate_diff": {
        "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
          "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "586:     ): Promise<void> {",
          "587:         return this.crypto.encryptAndSendToDevices(",
          "588:             userDeviceMap,",
          "601:                 }",
          "602:             }",
          "604:     }",
          "",
          "[Removed Lines]",
          "589:             payload,",
          "590:             (contentMap, deviceInfoByDeviceId) => {",
          "592:                 for (const userId of Object.keys(contentMap)) {",
          "593:                     for (const deviceId of Object.keys(contentMap[userId])) {",
          "594:                         session.markSharedWithDevice(",
          "595:                             userId,",
          "596:                             deviceId,",
          "597:                             deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
          "598:                             chainIndex,",
          "599:                         );",
          "600:                     }",
          "603:         );",
          "",
          "[Added Lines]",
          "589:             payload",
          "590:         ).then((result) => {",
          "591:             const {contentMap, deviceInfoByDeviceId} = result;",
          "593:             for (const userId of Object.keys(contentMap)) {",
          "594:                 for (const deviceId of Object.keys(contentMap[userId])) {",
          "595:                     session.markSharedWithDevice(",
          "596:                         userId,",
          "597:                         deviceId,",
          "598:                         deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
          "599:                         chainIndex,",
          "600:                     );",
          "603:         });",
          "",
          "---------------"
        ],
        "src/crypto/index.ts||src/crypto/index.ts": [
          "File: src/crypto/index.ts -> src/crypto/index.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "3049:     encryptAndSendToDevices(",
          "3050:         userDeviceMap: IOlmDevice<DeviceInfo>[],",
          "3051:         payload: object,",
          "3054:         const contentMap = {};",
          "3055:         const deviceInfoByDeviceId = new Map<string, DeviceInfo>();",
          "",
          "[Removed Lines]",
          "3052:         afterwards: (contentMap: {}, deviceInfoByDeviceId: Map<string, DeviceInfo>) => void,",
          "3053:     ): Promise<void> {",
          "",
          "[Added Lines]",
          "3052:     ): Promise<{contentMap, deviceInfoByDeviceId}> {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3072:             }",
          "3073:             contentMap[userId][deviceId] = encryptedContent;",
          "3075:             promises.push(",
          "3076:                 olmlib.encryptMessageForDevice(",
          "3077:                     encryptedContent.ciphertext,",
          "3078:                     this.userId,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3074:             const devicesByUser = {};",
          "3075:             devicesByUser[userId] = [deviceInfo];",
          "3078:                 olmlib.ensureOlmSessionsForDevices(",
          "3079:                     this.olmDevice,",
          "3080:                     this.baseApis,",
          "3081:                     devicesByUser,",
          "3082:                 ),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3114:             }",
          "3116:             return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap).then(",
          "3118:             );",
          "3119:         });",
          "3120:     }",
          "",
          "[Removed Lines]",
          "3117:                 afterwards.bind(contentMap, deviceInfoByDeviceId)",
          "",
          "[Added Lines]",
          "3124:                 (response)=>({ contentMap, deviceInfoByDeviceId })",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9f3f9990ef790a3648941de003ca842d3c7d6575",
      "candidate_info": {
        "commit_hash": "9f3f9990ef790a3648941de003ca842d3c7d6575",
        "repo": "matrix-org/matrix-js-sdk",
        "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/9f3f9990ef790a3648941de003ca842d3c7d6575",
        "files": [
          "src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts"
        ],
        "message": "untested first cut at factoring out a encryptAndSendToDevices method",
        "before_after_code_files": [
          "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts||src/crypto/index.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ],
          "candidate": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ]
        }
      },
      "candidate_diff": {
        "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
          "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "584:         userDeviceMap: IOlmDevice[],",
          "585:         payload: IPayload,",
          "586:     ): Promise<void> {",
          "626:             for (const userId of Object.keys(contentMap)) {",
          "627:                 for (const deviceId of Object.keys(contentMap[userId])) {",
          "640:                 }",
          "641:             }",
          "662:         });",
          "663:     }",
          "",
          "[Removed Lines]",
          "587:         const contentMap = {};",
          "588:         const deviceInfoByDeviceId = new Map<string, DeviceInfo>();",
          "590:         const promises = [];",
          "591:         for (let i = 0; i < userDeviceMap.length; i++) {",
          "592:             const encryptedContent = {",
          "593:                 algorithm: olmlib.OLM_ALGORITHM,",
          "594:                 sender_key: this.olmDevice.deviceCurve25519Key,",
          "595:                 ciphertext: {},",
          "596:             };",
          "597:             const val = userDeviceMap[i];",
          "598:             const userId = val.userId;",
          "599:             const deviceInfo = val.deviceInfo;",
          "600:             const deviceId = deviceInfo.deviceId;",
          "601:             deviceInfoByDeviceId.set(deviceId, deviceInfo);",
          "603:             if (!contentMap[userId]) {",
          "604:                 contentMap[userId] = {};",
          "605:             }",
          "606:             contentMap[userId][deviceId] = encryptedContent;",
          "608:             promises.push(",
          "609:                 olmlib.encryptMessageForDevice(",
          "610:                     encryptedContent.ciphertext,",
          "611:                     this.userId,",
          "612:                     this.deviceId,",
          "613:                     this.olmDevice,",
          "614:                     userId,",
          "615:                     deviceInfo,",
          "616:                     payload,",
          "617:                 ),",
          "618:             );",
          "619:         }",
          "621:         return Promise.all(promises).then(() => {",
          "628:                     if (Object.keys(contentMap[userId][deviceId].ciphertext).length === 0) {",
          "629:                         logger.log(",
          "630:                             \"No ciphertext for device \" +",
          "631:                             userId + \":\" + deviceId + \": pruning\",",
          "632:                         );",
          "633:                         delete contentMap[userId][deviceId];",
          "634:                     }",
          "635:                 }",
          "637:                 if (Object.keys(contentMap[userId]).length === 0) {",
          "638:                     logger.log(\"Pruned all devices for user \" + userId);",
          "639:                     delete contentMap[userId];",
          "644:             if (Object.keys(contentMap).length === 0) {",
          "645:                 logger.log(\"No users left to send to: aborting\");",
          "646:                 return;",
          "647:             }",
          "649:             return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap).then(() => {",
          "651:                 for (const userId of Object.keys(contentMap)) {",
          "652:                     for (const deviceId of Object.keys(contentMap[userId])) {",
          "653:                         session.markSharedWithDevice(",
          "654:                             userId,",
          "655:                             deviceId,",
          "656:                             deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
          "657:                             chainIndex,",
          "658:                         );",
          "659:                     }",
          "660:                 }",
          "661:             });",
          "",
          "[Added Lines]",
          "587:         this.crypto.encryptAndSendToDevices(",
          "588:             userDeviceMap,",
          "589:             payload",
          "590:         ).then(() => {",
          "594:                     session.markSharedWithDevice(",
          "595:                         userId,",
          "596:                         deviceId,",
          "597:                         deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
          "598:                         chainIndex,",
          "599:                     );",
          "",
          "---------------"
        ],
        "src/crypto/index.ts||src/crypto/index.ts": [
          "File: src/crypto/index.ts -> src/crypto/index.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "3030:         });",
          "3031:     }",
          "3033:     private onToDeviceEvent = (event: MatrixEvent): void => {",
          "3034:         try {",
          "3035:             logger.log(`received to_device ${event.getType()} from: ` +",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3047:     private encryptAndSendToDevices(",
          "3048:         userDeviceMap: IExportedDevice[],",
          "3049:         payload: object,",
          "3050:     ): Promise<{}> {",
          "3051:         const contentMap = {};",
          "3052:         const deviceInfoByDeviceId = new Map<string, DeviceInfo>();",
          "3054:         const promises = [];",
          "3055:         for (let i = 0; i < userDeviceMap.length; i++) {",
          "3056:             const encryptedContent = {",
          "3057:                 algorithm: olmlib.OLM_ALGORITHM,",
          "3058:                 sender_key: this.olmDevice.deviceCurve25519Key,",
          "3059:                 ciphertext: {},",
          "3060:             };",
          "3061:             const val = userDeviceMap[i];",
          "3062:             const userId = val.userId;",
          "3063:             const deviceInfo = val.deviceInfo;",
          "3064:             const deviceId = deviceInfo.deviceId;",
          "3065:             deviceInfoByDeviceId.set(deviceId, deviceInfo);",
          "3067:             if (!contentMap[userId]) {",
          "3068:                 contentMap[userId] = {};",
          "3069:             }",
          "3070:             contentMap[userId][deviceId] = encryptedContent;",
          "3072:             promises.push(",
          "3073:                 olmlib.encryptMessageForDevice(",
          "3074:                     encryptedContent.ciphertext,",
          "3075:                     this.userId,",
          "3076:                     this.deviceId,",
          "3077:                     this.olmDevice,",
          "3078:                     userId,",
          "3079:                     deviceInfo,",
          "3080:                     payload,",
          "3081:                 ),",
          "3082:             );",
          "3083:         }",
          "3085:         return Promise.all(promises).then(() => {",
          "3090:             for (const userId of Object.keys(contentMap)) {",
          "3091:                 for (const deviceId of Object.keys(contentMap[userId])) {",
          "3092:                     if (Object.keys(contentMap[userId][deviceId].ciphertext).length === 0) {",
          "3093:                         logger.log(",
          "3094:                             \"No ciphertext for device \" +",
          "3095:                             userId + \":\" + deviceId + \": pruning\",",
          "3096:                         );",
          "3097:                         delete contentMap[userId][deviceId];",
          "3098:                     }",
          "3099:                 }",
          "3101:                 if (Object.keys(contentMap[userId]).length === 0) {",
          "3102:                     logger.log(\"Pruned all devices for user \" + userId);",
          "3103:                     delete contentMap[userId];",
          "3104:                 }",
          "3105:             }",
          "3108:             if (Object.keys(contentMap).length === 0) {",
          "3109:                 logger.log(\"No users left to send to: aborting\");",
          "3110:                 return;",
          "3111:             }",
          "3113:             return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap);",
          "3114:         });",
          "3115:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c36bfc821c18d90cceb46fe6dd49732ca69bfc0a",
      "candidate_info": {
        "commit_hash": "c36bfc821c18d90cceb46fe6dd49732ca69bfc0a",
        "repo": "matrix-org/matrix-js-sdk",
        "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/c36bfc821c18d90cceb46fe6dd49732ca69bfc0a",
        "files": [
          "package.json",
          "spec/unit/crypto.spec.ts",
          "spec/unit/crypto/algorithms/megolm.spec.ts",
          "spec/unit/matrix-client.spec.ts",
          "src/client.ts",
          "src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts",
          "yarn.lock"
        ],
        "message": "Add support for sending user-defined encrypted to-device messages (#2528)\n\n* Add support for sending user-defined encrypted to-device messages\n\nThis is a port of the same change from the robertlong/group-call branch.\n\n* Fix tests\n\n* Expose the method in MatrixClient\n\n* Fix a code smell\n\n* Fix types\n\n* Test the MatrixClient method\n\n* Fix some types in Crypto test suite\n\n* Test the Crypto method\n\n* Fix tests\n\n* Upgrade matrix-mock-request\n\n* Move useRealTimers to afterEach",
        "before_after_code_files": [
          "spec/unit/crypto.spec.ts||spec/unit/crypto.spec.ts",
          "spec/unit/crypto/algorithms/megolm.spec.ts||spec/unit/crypto/algorithms/megolm.spec.ts",
          "spec/unit/matrix-client.spec.ts||spec/unit/matrix-client.spec.ts",
          "src/client.ts||src/client.ts",
          "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts||src/crypto/index.ts",
          "yarn.lock||yarn.lock"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ],
          "candidate": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ]
        }
      },
      "candidate_diff": {
        "spec/unit/crypto.spec.ts||spec/unit/crypto.spec.ts": [
          "File: spec/unit/crypto.spec.ts -> spec/unit/crypto.spec.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import { EventEmitter } from \"events\";",
          "5: import { Crypto } from \"../../src/crypto\";",
          "6: import { MemoryCryptoStore } from \"../../src/crypto/store/memory-crypto-store\";",
          "7: import { MockStorageApi } from \"../MockStorageApi\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: import { MatrixClient } from \"../../src/client\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:         return Olm.init();",
          "65:     });",
          "67:     it(\"Crypto exposes the correct olm library version\", function() {",
          "68:         expect(Crypto.getOlmVersion()[0]).toEqual(3);",
          "69:     });",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:     afterEach(() => {",
          "69:         jest.useRealTimers();",
          "70:     });",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "225:     });",
          "227:     describe('Key requests', function() {",
          "231:         beforeEach(async function() {",
          "232:             aliceClient = (new TestClient(",
          "",
          "[Removed Lines]",
          "228:         let aliceClient;",
          "229:         let bobClient;",
          "",
          "[Added Lines]",
          "233:         let aliceClient: MatrixClient;",
          "234:         let bobClient: MatrixClient;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "313:             expect(events[0].getContent().msgtype).toBe(\"m.bad.encrypted\");",
          "314:             expect(events[1].getContent().msgtype).not.toBe(\"m.bad.encrypted\");",
          "317:             const eventContent = events[0].getWireContent();",
          "318:             const senderKey = eventContent.sender_key;",
          "319:             const sessionId = eventContent.session_id;",
          "",
          "[Removed Lines]",
          "316:             const cryptoStore = bobClient.cryptoStore;",
          "",
          "[Added Lines]",
          "321:             const cryptoStore = bobClient.crypto.cryptoStore;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "384:             const ksEvent = await keyshareEventForEvent(aliceClient, event, 1);",
          "385:             ksEvent.getContent().sender_key = undefined; // test",
          "387:             await bobDecryptor.onRoomKeyEvent(ksEvent);",
          "389:         });",
          "391:         it(\"creates a new keyshare request if we request a keyshare\", async function() {",
          "",
          "[Removed Lines]",
          "386:             bobClient.crypto.addInboundGroupSession = jest.fn();",
          "388:             expect(bobClient.crypto.addInboundGroupSession).not.toHaveBeenCalled();",
          "",
          "[Added Lines]",
          "391:             bobClient.crypto.olmDevice.addInboundGroupSession = jest.fn();",
          "393:             expect(bobClient.crypto.olmDevice.addInboundGroupSession).not.toHaveBeenCalled();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "401:                 },",
          "402:             });",
          "403:             await aliceClient.cancelAndResendEventRoomKeyRequest(event);",
          "405:             const roomKeyRequestBody = {",
          "406:                 algorithm: olmlib.MEGOLM_ALGORITHM,",
          "407:                 room_id: \"!someroom\",",
          "",
          "[Removed Lines]",
          "404:             const cryptoStore = aliceClient.cryptoStore;",
          "",
          "[Added Lines]",
          "409:             const cryptoStore = aliceClient.crypto.cryptoStore;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "425:                 },",
          "426:             });",
          "429:             aliceClient.startClient();",
          "",
          "[Removed Lines]",
          "428:             aliceClient.sendToDevice = jest.fn().mockResolvedValue(undefined);",
          "",
          "[Added Lines]",
          "433:             const aliceSendToDevice = jest.fn().mockResolvedValue(undefined);",
          "434:             aliceClient.sendToDevice = aliceSendToDevice;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "437:             aliceClient.crypto.outgoingRoomKeyRequestManager.sendQueuedRequests();",
          "438:             jest.runAllTimers();",
          "439:             await Promise.resolve();",
          "",
          "[Removed Lines]",
          "440:             expect(aliceClient.sendToDevice).toBeCalledTimes(1);",
          "441:             const txnId = aliceClient.sendToDevice.mock.calls[0][2];",
          "",
          "[Added Lines]",
          "447:             expect(aliceSendToDevice).toBeCalledTimes(1);",
          "448:             const txnId = aliceSendToDevice.mock.calls[0][2];",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "456:         });",
          "457:     });",
          "",
          "[Removed Lines]",
          "454:             expect(aliceClient.sendToDevice).toBeCalledTimes(3);",
          "455:             expect(aliceClient.sendToDevice.mock.calls[2][2]).not.toBe(txnId);",
          "",
          "[Added Lines]",
          "461:             expect(aliceSendToDevice).toBeCalledTimes(3);",
          "462:             expect(aliceSendToDevice.mock.calls[2][2]).not.toBe(txnId);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "480:             client.stopClient();",
          "481:         });",
          "482:     });",
          "483: });",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "491:     describe(\"encryptAndSendToDevices\", () => {",
          "492:         let client: TestClient;",
          "493:         let ensureOlmSessionsForDevices: jest.SpiedFunction<typeof olmlib.ensureOlmSessionsForDevices>;",
          "494:         let encryptMessageForDevice: jest.SpiedFunction<typeof olmlib.encryptMessageForDevice>;",
          "495:         const payload = { hello: \"world\" };",
          "496:         let encryptedPayload: object;",
          "498:         beforeEach(async () => {",
          "499:             ensureOlmSessionsForDevices = jest.spyOn(olmlib, \"ensureOlmSessionsForDevices\");",
          "500:             ensureOlmSessionsForDevices.mockResolvedValue({});",
          "501:             encryptMessageForDevice = jest.spyOn(olmlib, \"encryptMessageForDevice\");",
          "502:             encryptMessageForDevice.mockImplementation(async (...[result,,,,,, payload]) => {",
          "503:                 result.plaintext = JSON.stringify(payload);",
          "504:             });",
          "506:             client = new TestClient(\"@alice:example.org\", \"aliceweb\");",
          "507:             await client.client.initCrypto();",
          "509:             encryptedPayload = {",
          "510:                 algorithm: \"m.olm.v1.curve25519-aes-sha2\",",
          "511:                 sender_key: client.client.crypto.olmDevice.deviceCurve25519Key,",
          "512:                 ciphertext: { plaintext: JSON.stringify(payload) },",
          "513:             };",
          "514:         });",
          "516:         afterEach(async () => {",
          "517:             ensureOlmSessionsForDevices.mockRestore();",
          "518:             encryptMessageForDevice.mockRestore();",
          "519:             await client.stop();",
          "520:         });",
          "522:         it(\"encrypts and sends to devices\", async () => {",
          "523:             client.httpBackend",
          "524:                 .when(\"PUT\", \"/sendToDevice/m.room.encrypted\", {",
          "525:                     messages: {",
          "526:                         \"@bob:example.org\": {",
          "527:                             bobweb: encryptedPayload,",
          "528:                             bobmobile: encryptedPayload,",
          "529:                         },",
          "530:                         \"@carol:example.org\": {",
          "531:                             caroldesktop: encryptedPayload,",
          "532:                         },",
          "533:                     },",
          "534:                 })",
          "535:                 .respond(200, {});",
          "537:             await Promise.all([",
          "538:                 client.client.encryptAndSendToDevices(",
          "539:                     [",
          "540:                         { userId: \"@bob:example.org\", deviceInfo: new DeviceInfo(\"bobweb\") },",
          "541:                         { userId: \"@bob:example.org\", deviceInfo: new DeviceInfo(\"bobmobile\") },",
          "542:                         { userId: \"@carol:example.org\", deviceInfo: new DeviceInfo(\"caroldesktop\") },",
          "543:                     ],",
          "544:                     payload,",
          "545:                 ),",
          "546:                 client.httpBackend.flushAllExpected(),",
          "547:             ]);",
          "548:         });",
          "550:         it(\"sends nothing to devices that couldn't be encrypted to\", async () => {",
          "551:             encryptMessageForDevice.mockImplementation(async (...[result,,,, userId, device, payload]) => {",
          "553:                 if (userId === \"@carol:example.org\" && device.deviceId === \"caroldesktop\") return;",
          "554:                 result.plaintext = JSON.stringify(payload);",
          "555:             });",
          "557:             client.httpBackend",
          "558:                 .when(\"PUT\", \"/sendToDevice/m.room.encrypted\", {",
          "560:                     messages: { \"@bob:example.org\": { bobweb: encryptedPayload } },",
          "561:                 })",
          "562:                 .respond(200, {});",
          "564:             await Promise.all([",
          "565:                 client.client.encryptAndSendToDevices(",
          "566:                     [",
          "567:                         { userId: \"@bob:example.org\", deviceInfo: new DeviceInfo(\"bobweb\") },",
          "568:                         { userId: \"@carol:example.org\", deviceInfo: new DeviceInfo(\"caroldesktop\") },",
          "569:                     ],",
          "570:                     payload,",
          "571:                 ),",
          "572:                 client.httpBackend.flushAllExpected(),",
          "573:             ]);",
          "574:         });",
          "576:         it(\"no-ops if no devices can be encrypted to\", async () => {",
          "578:             encryptMessageForDevice.mockResolvedValue(undefined);",
          "581:             client.httpBackend.when(\"GET\", \"/room_keys/version\").respond(404, {});",
          "582:             await client.httpBackend.flush(\"/room_keys/version\", 1);",
          "584:             await client.client.encryptAndSendToDevices(",
          "585:                 [{ userId: \"@bob:example.org\", deviceInfo: new DeviceInfo(\"bobweb\") }],",
          "586:                 payload,",
          "587:             );",
          "588:             client.httpBackend.verifyNoOutstandingRequests();",
          "589:         });",
          "590:     });",
          "",
          "---------------"
        ],
        "spec/unit/crypto/algorithms/megolm.spec.ts||spec/unit/crypto/algorithms/megolm.spec.ts": [
          "File: spec/unit/crypto/algorithms/megolm.spec.ts -> spec/unit/crypto/algorithms/megolm.spec.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "360:                         rotation_period_ms: rotationPeriodMs,",
          "361:                     },",
          "362:                 });",
          "363:                 mockRoom = {",
          "364:                     getEncryptionTargetMembers: jest.fn().mockReturnValue(",
          "365:                         [{ userId: \"@alice:home.server\" }],",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "367:                 mockCrypto.encryptAndSendToDevices = Crypto.prototype.encryptAndSendToDevices;",
          "369:                 mockCrypto.olmDevice = olmDevice;",
          "371:                 mockCrypto.baseApis = mockBaseApis;",
          "",
          "---------------"
        ],
        "spec/unit/matrix-client.spec.ts||spec/unit/matrix-client.spec.ts": [
          "File: spec/unit/matrix-client.spec.ts -> spec/unit/matrix-client.spec.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:     UNSTABLE_MSC3089_TREE_SUBTYPE,",
          "28: } from \"../../src/@types/event\";",
          "29: import { MEGOLM_ALGORITHM } from \"../../src/crypto/olmlib\";",
          "30: import { EventStatus, MatrixEvent } from \"../../src/models/event\";",
          "31: import { Preset } from \"../../src/@types/partials\";",
          "32: import { ReceiptType } from \"../../src/@types/read_receipts\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: import { Crypto } from \"../../src/crypto\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1297:             expect(result!.aliases).toEqual(response.aliases);",
          "1298:         });",
          "1299:     });",
          "1300: });",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1302:     describe(\"encryptAndSendToDevices\", () => {",
          "1303:         it(\"throws an error if crypto is unavailable\", () => {",
          "1304:             client.crypto = undefined;",
          "1305:             expect(() => client.encryptAndSendToDevices([], {})).toThrow();",
          "1306:         });",
          "1308:         it(\"is an alias for the crypto method\", async () => {",
          "1309:             client.crypto = testUtils.mock(Crypto, \"Crypto\");",
          "1310:             const deviceInfos = [];",
          "1311:             const payload = {};",
          "1312:             await client.encryptAndSendToDevices(deviceInfos, payload);",
          "1313:             expect(client.crypto.encryptAndSendToDevices).toHaveBeenLastCalledWith(deviceInfos, payload);",
          "1314:         });",
          "1315:     });",
          "",
          "---------------"
        ],
        "src/client.ts||src/client.ts": [
          "File: src/client.ts -> src/client.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: import { Direction, EventTimeline } from \"./models/event-timeline\";",
          "41: import { IActionsObject, PushProcessor } from \"./pushprocessor\";",
          "42: import { AutoDiscovery, AutoDiscoveryAction } from \"./autodiscovery\";",
          "43: import * as olmlib from \"./crypto/olmlib\";",
          "44: import { decodeBase64, encodeBase64 } from \"./crypto/olmlib\";",
          "46: import { TypedReEmitter } from './ReEmitter';",
          "47: import { IRoomEncryption, RoomList } from './crypto/RoomList';",
          "48: import { logger } from './logger';",
          "",
          "[Removed Lines]",
          "45: import { IExportedDevice as IOlmDevice } from \"./crypto/OlmDevice\";",
          "",
          "[Added Lines]",
          "43: import { IEncryptAndSendToDevicesResult } from \"./crypto\";",
          "46: import { IExportedDevice as IExportedOlmDevice } from \"./crypto/OlmDevice\";",
          "47: import { IOlmDevice } from \"./crypto/algorithms/megolm\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "208: const TURN_CHECK_INTERVAL = 10 * 60 * 1000; // poll for turn credentials every 10 minutes",
          "210: interface IExportedDevice {",
          "212:     userId: string;",
          "213:     deviceId: string;",
          "214: }",
          "",
          "[Removed Lines]",
          "211:     olmDevice: IOlmDevice;",
          "",
          "[Added Lines]",
          "213:     olmDevice: IExportedOlmDevice;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "936:     protected turnServers: ITurnServer[] = [];",
          "937:     protected turnServersExpiry = 0;",
          "938:     protected checkTurnServersIntervalID: ReturnType<typeof setInterval>;",
          "940:     protected txnCtr = 0;",
          "941:     protected mediaHandler = new MediaHandler(this);",
          "942:     protected pendingEventEncryption = new Map<string, Promise<void>>();",
          "",
          "[Removed Lines]",
          "939:     protected exportedOlmDeviceToImport: IOlmDevice;",
          "",
          "[Added Lines]",
          "941:     protected exportedOlmDeviceToImport: IExportedOlmDevice;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2558:         return this.roomList.isRoomEncrypted(roomId);",
          "2559:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2577:     public encryptAndSendToDevices(",
          "2578:         userDeviceInfoArr: IOlmDevice<DeviceInfo>[],",
          "2579:         payload: object,",
          "2580:     ): Promise<IEncryptAndSendToDevicesResult> {",
          "2581:         if (!this.crypto) {",
          "2582:             throw new Error(\"End-to-End encryption disabled\");",
          "2583:         }",
          "2584:         return this.crypto.encryptAndSendToDevices(userDeviceInfoArr, payload);",
          "2585:     }",
          "",
          "---------------"
        ],
        "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
          "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: import { logger } from '../../logger';",
          "24: import * as olmlib from \"../olmlib\";",
          "26: import {",
          "27:     DecryptionAlgorithm,",
          "28:     DecryptionError,",
          "",
          "[Removed Lines]",
          "25: import { EventType } from '../../@types/event';",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38: import { DeviceInfoMap } from \"../DeviceList\";",
          "39: import { MatrixEvent } from \"../..\";",
          "40: import { IEventDecryptionResult, IMegolmSessionData, IncomingRoomKeyRequest } from \"../index\";",
          "44: export function isRoomSharedHistory(room: Room): boolean {",
          "",
          "[Removed Lines]",
          "41: import { ToDeviceBatch, ToDeviceMessage } from '../../models/ToDeviceMessage';",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "611:         userDeviceMap: IOlmDevice[],",
          "612:         payload: IPayload,",
          "613:     ): Promise<void> {",
          "671:             for (const msg of toDeviceBatch.batch) {",
          "680:             }",
          "695:         });",
          "696:     }",
          "",
          "[Removed Lines]",
          "614:         const toDeviceBatch: ToDeviceBatch = {",
          "615:             eventType: EventType.RoomMessageEncrypted,",
          "616:             batch: [],",
          "617:         };",
          "620:         const deviceInfoByUserIdAndDeviceId = new Map<string, Map<string, DeviceInfo>>();",
          "622:         const promises: Promise<unknown>[] = [];",
          "623:         for (let i = 0; i < userDeviceMap.length; i++) {",
          "624:             const encryptedContent: IEncryptedContent = {",
          "625:                 algorithm: olmlib.OLM_ALGORITHM,",
          "626:                 sender_key: this.olmDevice.deviceCurve25519Key,",
          "627:                 ciphertext: {},",
          "628:             };",
          "629:             const val = userDeviceMap[i];",
          "630:             const userId = val.userId;",
          "631:             const deviceInfo = val.deviceInfo;",
          "632:             const deviceId = deviceInfo.deviceId;",
          "635:             let userIdDeviceInfo = deviceInfoByUserIdAndDeviceId.get(userId);",
          "637:             if (userIdDeviceInfo === undefined) {",
          "638:                 userIdDeviceInfo = new Map<string, DeviceInfo>();",
          "640:                 deviceInfoByUserIdAndDeviceId.set(userId, userIdDeviceInfo);",
          "641:             }",
          "644:             userIdDeviceInfo.set(deviceId, deviceInfo);",
          "646:             toDeviceBatch.batch.push({",
          "647:                 userId,",
          "648:                 deviceId,",
          "649:                 payload: encryptedContent,",
          "650:             });",
          "652:             promises.push(",
          "653:                 olmlib.encryptMessageForDevice(",
          "654:                     encryptedContent.ciphertext,",
          "655:                     this.userId,",
          "656:                     this.deviceId,",
          "657:                     this.olmDevice,",
          "658:                     userId,",
          "659:                     deviceInfo,",
          "660:                     payload,",
          "661:                 ),",
          "662:             );",
          "663:         }",
          "665:         return Promise.all(promises).then(() => {",
          "670:             const prunedBatch: ToDeviceMessage[] = [];",
          "672:                 if (Object.keys(msg.payload.ciphertext).length > 0) {",
          "673:                     prunedBatch.push(msg);",
          "674:                 } else {",
          "675:                     logger.log(",
          "676:                         \"No ciphertext for device \" +",
          "677:                         msg.userId + \":\" + msg.deviceId + \": pruning\",",
          "678:                     );",
          "679:                 }",
          "682:             toDeviceBatch.batch = prunedBatch;",
          "684:             return this.baseApis.queueToDevice(toDeviceBatch).then(() => {",
          "686:                 for (const msg of toDeviceBatch.batch) {",
          "687:                     session.markSharedWithDevice(",
          "688:                         msg.userId,",
          "689:                         msg.deviceId,",
          "690:                         deviceInfoByUserIdAndDeviceId.get(msg.userId).get(msg.deviceId).getIdentityKey(),",
          "691:                         chainIndex,",
          "692:                     );",
          "693:                 }",
          "694:             });",
          "",
          "[Added Lines]",
          "612:         return this.crypto.encryptAndSendToDevices(",
          "613:             userDeviceMap,",
          "614:             payload,",
          "615:         ).then(({ toDeviceBatch, deviceInfoByUserIdAndDeviceId }) => {",
          "618:                 session.markSharedWithDevice(",
          "619:                     msg.userId,",
          "620:                     msg.deviceId,",
          "621:                     deviceInfoByUserIdAndDeviceId.get(msg.userId).get(msg.deviceId).getIdentityKey(),",
          "622:                     chainIndex,",
          "623:                 );",
          "625:         }).catch((error) => {",
          "626:             logger.error(\"failed to encryptAndSendToDevices\", error);",
          "627:             throw error;",
          "",
          "---------------"
        ],
        "src/crypto/index.ts||src/crypto/index.ts": [
          "File: src/crypto/index.ts -> src/crypto/index.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: import anotherjson from \"another-json\";",
          "26: import { TypedReEmitter } from '../ReEmitter';",
          "27: import { logger } from '../logger';",
          "28: import { IExportedDevice, OlmDevice } from \"./OlmDevice\";",
          "29: import * as olmlib from \"./olmlib\";",
          "30: import { DeviceInfoMap, DeviceList } from \"./DeviceList\";",
          "31: import { DeviceInfo, IDevice } from \"./deviceinfo\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: import { EventType } from \"../@types/event\";",
          "30: import { IOlmDevice } from \"./algorithms/megolm\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68: import { Room, RoomEvent } from \"../models/room\";",
          "69: import { RoomMember, RoomMemberEvent } from \"../models/room-member\";",
          "70: import { EventStatus, IClearEvent, IEvent, MatrixEvent, MatrixEventEvent } from \"../models/event\";",
          "71: import {",
          "72:     ClientEvent,",
          "73:     ICrossSigningKey,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73: import { ToDeviceBatch } from \"../models/ToDeviceMessage\";",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "201:     setRequestByChannel(channel: IVerificationChannel, request: VerificationRequest): void;",
          "202: }",
          "204: export enum CryptoEvent {",
          "205:     DeviceVerificationChanged = \"deviceVerificationChanged\",",
          "206:     UserTrustStatusChanged = \"userTrustStatusChanged\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "208: export interface IEncryptedContent {",
          "209:     algorithm: string;",
          "210:     sender_key: string;",
          "211:     ciphertext: Record<string, string>;",
          "212: }",
          "215: export interface IEncryptAndSendToDevicesResult {",
          "216:     toDeviceBatch: ToDeviceBatch;",
          "217:     deviceInfoByUserIdAndDeviceId: Map<string, Map<string, DeviceInfo>>;",
          "218: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3100:         });",
          "3101:     }",
          "3103:     private onMembership = (event: MatrixEvent, member: RoomMember, oldMembership?: string) => {",
          "3104:         try {",
          "3105:             this.onRoomMembership(event, member, oldMembership);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3129:     public async encryptAndSendToDevices(",
          "3130:         userDeviceInfoArr: IOlmDevice<DeviceInfo>[],",
          "3131:         payload: object,",
          "3132:     ): Promise<IEncryptAndSendToDevicesResult> {",
          "3133:         const toDeviceBatch: ToDeviceBatch = {",
          "3134:             eventType: EventType.RoomMessageEncrypted,",
          "3135:             batch: [],",
          "3136:         };",
          "3137:         const deviceInfoByUserIdAndDeviceId = new Map<string, Map<string, DeviceInfo>>();",
          "3139:         try {",
          "3140:             await Promise.all(userDeviceInfoArr.map(async ({ userId, deviceInfo }) => {",
          "3141:                 const deviceId = deviceInfo.deviceId;",
          "3142:                 const encryptedContent: IEncryptedContent = {",
          "3143:                     algorithm: olmlib.OLM_ALGORITHM,",
          "3144:                     sender_key: this.olmDevice.deviceCurve25519Key,",
          "3145:                     ciphertext: {},",
          "3146:                 };",
          "3149:                 let userIdDeviceInfo = deviceInfoByUserIdAndDeviceId.get(userId);",
          "3151:                 if (userIdDeviceInfo === undefined) {",
          "3152:                     userIdDeviceInfo = new Map<string, DeviceInfo>();",
          "3153:                     deviceInfoByUserIdAndDeviceId.set(userId, userIdDeviceInfo);",
          "3154:                 }",
          "3157:                 userIdDeviceInfo.set(deviceId, deviceInfo);",
          "3159:                 toDeviceBatch.batch.push({",
          "3160:                     userId,",
          "3161:                     deviceId,",
          "3162:                     payload: encryptedContent,",
          "3163:                 });",
          "3165:                 await olmlib.ensureOlmSessionsForDevices(",
          "3166:                     this.olmDevice,",
          "3167:                     this.baseApis,",
          "3168:                     { [userId]: [deviceInfo] },",
          "3169:                 );",
          "3170:                 await olmlib.encryptMessageForDevice(",
          "3171:                     encryptedContent.ciphertext,",
          "3172:                     this.userId,",
          "3173:                     this.deviceId,",
          "3174:                     this.olmDevice,",
          "3175:                     userId,",
          "3176:                     deviceInfo,",
          "3177:                     payload,",
          "3178:                 );",
          "3179:             }));",
          "3185:             toDeviceBatch.batch = toDeviceBatch.batch.filter(msg => {",
          "3186:                 if (Object.keys(msg.payload.ciphertext).length > 0) {",
          "3187:                     return true;",
          "3188:                 } else {",
          "3189:                     logger.log(`No ciphertext for device ${msg.userId}:${msg.deviceId}: pruning`);",
          "3190:                     return false;",
          "3191:                 }",
          "3192:             });",
          "3194:             try {",
          "3195:                 await this.baseApis.queueToDevice(toDeviceBatch);",
          "3196:                 return { toDeviceBatch, deviceInfoByUserIdAndDeviceId };",
          "3197:             } catch (e) {",
          "3198:                 logger.error(\"sendToDevice failed\", e);",
          "3199:                 throw e;",
          "3200:             }",
          "3201:         } catch (e) {",
          "3202:             logger.error(\"encryptAndSendToDevices promises failed\", e);",
          "3203:             throw e;",
          "3204:         }",
          "3205:     }",
          "",
          "---------------"
        ],
        "yarn.lock||yarn.lock": [
          "File: yarn.lock -> yarn.lock",
          "--- Hunk 1 ---",
          "[Context before]",
          "1308: \"@matrix-org/olm@https://gitlab.matrix.org/api/v4/projects/27/packages/npm/@matrix-org/olm/-/@matrix-org/olm-3.2.12.tgz\":",
          "1309:   version \"3.2.12\"",
          "1311:   resolved \"https://gitlab.matrix.org/api/v4/projects/27/packages/npm/@matrix-org/olm/-/@matrix-org/olm-3.2.12.tgz#0bce3c86f9d36a4984d3c3e07df1c3fb4c679bd9\"",
          "1313: \"@nicolo-ribaudo/chokidar-2@2.1.8-no-fsevents.3\":",
          "",
          "[Removed Lines]",
          "1310:   uid \"0bce3c86f9d36a4984d3c3e07df1c3fb4c679bd9\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1438:     \"@octokit/openapi-types\" \"^12.10.0\"",
          "1440: \"@sinclair/typebox@^0.24.1\":",
          "1445: \"@sinonjs/commons@^1.7.0\":",
          "1446:   version \"1.8.3\"",
          "",
          "[Removed Lines]",
          "1441:   version \"0.24.20\"",
          "1442:   resolved \"https://registry.yarnpkg.com/@sinclair/typebox/-/typebox-0.24.20.tgz#11a657875de6008622d53f56e063a6347c51a6dd\"",
          "1443:   integrity sha512-kVaO5aEFZb33nPMTZBxiPEkY+slxiPtqC7QX8f9B3eGOMBvEfuMfxp9DSTTCsRJPumPKjrge4yagyssO4q6qzQ==",
          "",
          "[Added Lines]",
          "1440:   version \"0.24.26\"",
          "1441:   resolved \"https://registry.yarnpkg.com/@sinclair/typebox/-/typebox-0.24.26.tgz#84f9e8c1d93154e734a7947609a1dc7c7a81cc22\"",
          "1442:   integrity sha512-1ZVIyyS1NXDRVT8GjWD5jULjhDyM3IsIHef2VGUMdnWOlX2tkPjyEX/7K0TGSH2S8EaPhp1ylFdjSjUGQ+gecg==",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1581:   integrity sha512-eC4U9MlIcu2q0KQmXszyn5Akca/0jrQmwDRgpAMJai7qBWq4amIQhZyNau4VYGtCeALvW1/NtjzJJ567aZxfKA==",
          "1583: \"@types/node@*\":",
          "1588: \"@types/node@16\":",
          "1589:   version \"16.11.45\"",
          "",
          "[Removed Lines]",
          "1584:   version \"18.6.1\"",
          "1585:   resolved \"https://registry.yarnpkg.com/@types/node/-/node-18.6.1.tgz#828e4785ccca13f44e2fb6852ae0ef11e3e20ba5\"",
          "1586:   integrity sha512-z+2vB6yDt1fNwKOeGbckpmirO+VBDuQqecXkgeIqDlaOtmKn6hPR/viQ8cxCfqLU4fTlvM3+YjM367TukWdxpg==",
          "",
          "[Added Lines]",
          "1583:   version \"18.6.3\"",
          "1584:   resolved \"https://registry.yarnpkg.com/@types/node/-/node-18.6.3.tgz#4e4a95b6fe44014563ceb514b2598b3e623d1c98\"",
          "1585:   integrity sha512-6qKpDtoaYLM+5+AFChLhHermMQxc3TOEFIDzrZLPRGHPrLEwqFkkT5Kx3ju05g6X7uDPazz3jHbKPX0KzCjntg==",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4802:   resolved \"https://registry.yarnpkg.com/matrix-events-sdk/-/matrix-events-sdk-0.0.1-beta.7.tgz#5ffe45eba1f67cc8d7c2377736c728b322524934\"",
          "4803:   integrity sha512-9jl4wtWanUFSy2sr2lCjErN/oC8KTAtaeaozJtrgot1JiQcEI4Rda9OLgQ7nLKaqb4Z/QUx/fR3XpDzm5Jy1JA==",
          "4809:   dependencies:",
          "4810:     expect \"^28.1.0\"",
          "",
          "[Removed Lines]",
          "4805: matrix-mock-request@^2.1.1:",
          "4806:   version \"2.1.1\"",
          "4807:   resolved \"https://registry.yarnpkg.com/matrix-mock-request/-/matrix-mock-request-2.1.1.tgz#a8fc03a2816464bb95445df4cc8885ac36786b23\"",
          "4808:   integrity sha512-CxdaUPRVB4o8JxTBMASstS2loRe+hlqeJu0Q7yyS1r36LkSSo/KAP4AuomsqxuKqaqYYnEJFJzkG0gOhxV7aqA==",
          "",
          "[Added Lines]",
          "4804: matrix-mock-request@^2.1.2:",
          "4805:   version \"2.1.2\"",
          "4806:   resolved \"https://registry.yarnpkg.com/matrix-mock-request/-/matrix-mock-request-2.1.2.tgz#11e38ed1233dced88a6f2bfba1684d5c5b3aa2c2\"",
          "4807:   integrity sha512-/OXCIzDGSLPJ3fs+uzDrtaOHI/Sqp4iEuniRn31U8S06mPXbvAnXknHqJ4c6A/KVwJj/nPFbGXpK4wPM038I6A==",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f46355e7c0415b538bb9a908189fe4de91f669eb",
      "candidate_info": {
        "commit_hash": "f46355e7c0415b538bb9a908189fe4de91f669eb",
        "repo": "matrix-org/matrix-js-sdk",
        "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/f46355e7c0415b538bb9a908189fe4de91f669eb",
        "files": [
          "src/crypto/algorithms/megolm.ts"
        ],
        "message": "don't choke on missing promise",
        "before_after_code_files": [
          "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ],
          "candidate": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ]
        }
      },
      "candidate_diff": {
        "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
          "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "584:         userDeviceMap: IOlmDevice[],",
          "585:         payload: IPayload,",
          "586:     ): Promise<void> {",
          "588:             userDeviceMap,",
          "589:             payload,",
          "591:             const { contentMap, deviceInfoByDeviceId } = result;",
          "593:             for (const userId of Object.keys(contentMap)) {",
          "",
          "[Removed Lines]",
          "587:         return this.crypto.encryptAndSendToDevices(",
          "590:         ).then((result) => {",
          "",
          "[Added Lines]",
          "587:         const p = this.crypto.encryptAndSendToDevices(",
          "590:         );",
          "591:         if (!p) return;",
          "592:         return p.then((result) => {",
          "593:             if (!result) return;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
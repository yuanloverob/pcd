{
  "cve_id": "CVE-2021-40823",
  "cve_desc": "A logic error in the room key sharing functionality of matrix-js-sdk (aka Matrix Javascript SDK) before 12.4.1 allows a malicious Matrix homeserver present in an encrypted room to steal room encryption keys (via crafted Matrix protocol messages) that were originally sent by affected Matrix clients participating in that room. This allows the homeserver to decrypt end-to-end encrypted messages sent by affected clients.",
  "repo": "matrix-org/matrix-js-sdk",
  "patch_hash": "894c24880da0e1cc81818f51c0db80e3c9fb2be9",
  "patch_info": {
    "commit_hash": "894c24880da0e1cc81818f51c0db80e3c9fb2be9",
    "repo": "matrix-org/matrix-js-sdk",
    "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/894c24880da0e1cc81818f51c0db80e3c9fb2be9",
    "files": [
      "src/crypto/algorithms/megolm.ts"
    ],
    "message": "Verify target device key on reshare",
    "before_after_code_files": [
      "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
    ]
  },
  "patch_diff": {
    "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
      "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
      "--- Hunk 1 ---",
      "[Context before]",
      "101: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "104: interface SharedWithData {",
      "106:     deviceKey: string;",
      "108:     messageIndex: number;",
      "109: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "120: class OutboundSessionInfo {",
      "121:     public useCount = 0;",
      "122:     public creationTime: number;",
      "124:     public blockedDevicesNotified: Record<string, Record<string, boolean>> = {};",
      "126:     constructor(public readonly sessionId: string, public readonly sharedHistory = false) {",
      "",
      "[Removed Lines]",
      "123:     public sharedWithDevices: Record<string, Record<string, number>> = {};",
      "",
      "[Added Lines]",
      "130:     public sharedWithDevices: Record<string, Record<string, SharedWithData>> = {};",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "150:         return false;",
      "151:     }",
      "154:         if (!this.sharedWithDevices[userId]) {",
      "155:             this.sharedWithDevices[userId] = {};",
      "156:         }",
      "158:     }",
      "160:     public markNotifiedBlockedDevice(userId: string, deviceId: string): void {",
      "",
      "[Removed Lines]",
      "153:     public markSharedWithDevice(userId: string, deviceId: string, chainIndex: number): void {",
      "157:         this.sharedWithDevices[userId][deviceId] = chainIndex;",
      "",
      "[Added Lines]",
      "160:     public markSharedWithDevice(userId: string, deviceId: string, deviceKey: string, chainIndex: number): void {",
      "164:         this.sharedWithDevices[userId][deviceId] = { deviceKey, messageIndex: chainIndex };",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "572:         payload: IPayload,",
      "573:     ): Promise<void> {",
      "574:         const contentMap = {};",
      "576:         const promises = [];",
      "577:         for (let i = 0; i < userDeviceMap.length; i++) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "582:         const deviceInfoByDeviceId = new Map<string, DeviceInfo>();",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "584:             const userId = val.userId;",
      "585:             const deviceInfo = val.deviceInfo;",
      "586:             const deviceId = deviceInfo.deviceId;",
      "588:             if (!contentMap[userId]) {",
      "589:                 contentMap[userId] = {};",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "595:             deviceInfoByDeviceId.set(deviceId, deviceInfo);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "636:                 for (const userId of Object.keys(contentMap)) {",
      "637:                     for (const deviceId of Object.keys(contentMap[userId])) {",
      "638:                         session.markSharedWithDevice(",
      "640:                         );",
      "641:                     }",
      "642:                 }",
      "",
      "[Removed Lines]",
      "639:                             userId, deviceId, chainIndex,",
      "",
      "[Added Lines]",
      "648:                             userId,",
      "649:                             deviceId,",
      "650:                             deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
      "651:                             chainIndex,",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "719:             logger.debug(`megolm session ${sessionId} never shared with user ${userId}`);",
      "720:             return;",
      "721:         }",
      "724:             logger.debug(",
      "725:                 \"megolm session ID \" + sessionId + \" never shared with device \" +",
      "726:                 userId + \":\" + device.deviceId,",
      "",
      "[Removed Lines]",
      "722:         const sentChainIndex = obSessionInfo.sharedWithDevices[userId][device.deviceId];",
      "723:         if (sentChainIndex === undefined) {",
      "",
      "[Added Lines]",
      "734:         const sessionSharedData = obSessionInfo.sharedWithDevices[userId][device.deviceId];",
      "735:         if (sessionSharedData === undefined) {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "728:             return;",
      "729:         }",
      "733:         const key = await this.olmDevice.getInboundGroupSessionKey(",
      "735:         );",
      "737:         if (!key) {",
      "",
      "[Removed Lines]",
      "734:             this.roomId, senderKey, sessionId, sentChainIndex,",
      "",
      "[Added Lines]",
      "743:         if (sessionSharedData.deviceKey !== device.getIdentityKey()) {",
      "744:             logger.warn(",
      "745:                 `Session has been shared with device ${device.deviceId} but with identity ` +",
      "746:                 `key ${sessionSharedData.deviceKey}. Key is now ${device.getIdentityKey()}!`,",
      "747:             );",
      "748:             return;",
      "749:         }",
      "754:             this.roomId, senderKey, sessionId, sessionSharedData.messageIndex,",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "882:             const deviceId = deviceInfo.deviceId;",
      "884:             session.markSharedWithDevice(",
      "886:             );",
      "887:         }",
      "",
      "[Removed Lines]",
      "885:                 userId, deviceId, key.chain_index,",
      "",
      "[Added Lines]",
      "905:                 userId, deviceId, deviceInfo.getIdentityKey(), key.chain_index,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "37c752cb0bc431e25509d4b962f9265b3954fd09",
      "candidate_info": {
        "commit_hash": "37c752cb0bc431e25509d4b962f9265b3954fd09",
        "repo": "matrix-org/matrix-js-sdk",
        "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/37c752cb0bc431e25509d4b962f9265b3954fd09",
        "files": [
          "src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts"
        ],
        "message": "make it build",
        "before_after_code_files": [
          "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts||src/crypto/index.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ],
          "candidate": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ]
        }
      },
      "candidate_diff": {
        "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
          "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "578:         userDeviceMap: IOlmDevice[],",
          "579:         payload: IPayload,",
          "580:     ): Promise<void> {",
          "582:             userDeviceMap,",
          "594:                 }",
          "595:             }",
          "597:     }",
          "",
          "[Removed Lines]",
          "581:         this.crypto.encryptAndSendToDevices(",
          "583:             payload",
          "584:         ).then(() => {",
          "586:             for (const userId of Object.keys(contentMap)) {",
          "587:                 for (const deviceId of Object.keys(contentMap[userId])) {",
          "588:                     session.markSharedWithDevice(",
          "589:                         userId,",
          "590:                         deviceId,",
          "591:                         deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
          "592:                         chainIndex,",
          "593:                     );",
          "596:         });",
          "",
          "[Added Lines]",
          "581:         return this.crypto.encryptAndSendToDevices(",
          "583:             payload,",
          "584:             (contentMap, deviceInfoByDeviceId) => {",
          "586:                 for (const userId of Object.keys(contentMap)) {",
          "587:                     for (const deviceId of Object.keys(contentMap[userId])) {",
          "588:                         session.markSharedWithDevice(",
          "589:                             userId,",
          "590:                             deviceId,",
          "591:                             deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
          "592:                             chainIndex,",
          "593:                         );",
          "594:                     }",
          "597:         );",
          "",
          "---------------"
        ],
        "src/crypto/index.ts||src/crypto/index.ts": [
          "File: src/crypto/index.ts -> src/crypto/index.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: import { ReEmitter } from '../ReEmitter';",
          "28: import { logger } from '../logger';",
          "29: import { IExportedDevice, OlmDevice } from \"./OlmDevice\";",
          "30: import * as olmlib from \"./olmlib\";",
          "31: import { DeviceInfoMap, DeviceList } from \"./DeviceList\";",
          "32: import { DeviceInfo, IDevice } from \"./deviceinfo\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: import { IOlmDevice } from \"./algorithms/megolm\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3049:         payload: object,",
          "3051:         const contentMap = {};",
          "3052:         const deviceInfoByDeviceId = new Map<string, DeviceInfo>();",
          "",
          "[Removed Lines]",
          "3047:     private encryptAndSendToDevices(",
          "3048:         userDeviceMap: IExportedDevice[],",
          "3050:     ): Promise<{}> {",
          "",
          "[Added Lines]",
          "3049:     encryptAndSendToDevices(",
          "3050:         userDeviceMap: IOlmDevice<DeviceInfo>[],",
          "3052:         afterwards: (contentMap: {}, deviceInfoByDeviceId: Map<string, DeviceInfo>) => void,",
          "3053:     ): Promise<void> {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3110:                 return;",
          "3111:             }",
          "3114:         });",
          "3115:     }",
          "",
          "[Removed Lines]",
          "3113:             return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap);",
          "",
          "[Added Lines]",
          "3116:             return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap).then(",
          "3117:                 afterwards.bind(contentMap, deviceInfoByDeviceId)",
          "3118:             );",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dbe917282a5c723d81de816e5b59bf385fbf4f7e",
      "candidate_info": {
        "commit_hash": "dbe917282a5c723d81de816e5b59bf385fbf4f7e",
        "repo": "matrix-org/matrix-js-sdk",
        "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/dbe917282a5c723d81de816e5b59bf385fbf4f7e",
        "files": [
          "src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts"
        ],
        "message": "switch encryptAndSendToDevices to return a promise rather than use a cb\n\nand assert that olm sessions are open to the destination devices",
        "before_after_code_files": [
          "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts||src/crypto/index.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ],
          "candidate": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ]
        }
      },
      "candidate_diff": {
        "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
          "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "580:     ): Promise<void> {",
          "581:         return this.crypto.encryptAndSendToDevices(",
          "582:             userDeviceMap,",
          "595:                 }",
          "596:             }",
          "598:     }",
          "",
          "[Removed Lines]",
          "583:             payload,",
          "584:             (contentMap, deviceInfoByDeviceId) => {",
          "586:                 for (const userId of Object.keys(contentMap)) {",
          "587:                     for (const deviceId of Object.keys(contentMap[userId])) {",
          "588:                         session.markSharedWithDevice(",
          "589:                             userId,",
          "590:                             deviceId,",
          "591:                             deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
          "592:                             chainIndex,",
          "593:                         );",
          "594:                     }",
          "597:         );",
          "",
          "[Added Lines]",
          "583:             payload",
          "584:         ).then((result) => {",
          "585:             const {contentMap, deviceInfoByDeviceId} = result;",
          "587:             for (const userId of Object.keys(contentMap)) {",
          "588:                 for (const deviceId of Object.keys(contentMap[userId])) {",
          "589:                     session.markSharedWithDevice(",
          "590:                         userId,",
          "591:                         deviceId,",
          "592:                         deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
          "593:                         chainIndex,",
          "594:                     );",
          "597:         });",
          "",
          "---------------"
        ],
        "src/crypto/index.ts||src/crypto/index.ts": [
          "File: src/crypto/index.ts -> src/crypto/index.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "3049:     encryptAndSendToDevices(",
          "3050:         userDeviceMap: IOlmDevice<DeviceInfo>[],",
          "3051:         payload: object,",
          "3054:         const contentMap = {};",
          "3055:         const deviceInfoByDeviceId = new Map<string, DeviceInfo>();",
          "",
          "[Removed Lines]",
          "3052:         afterwards: (contentMap: {}, deviceInfoByDeviceId: Map<string, DeviceInfo>) => void,",
          "3053:     ): Promise<void> {",
          "",
          "[Added Lines]",
          "3052:     ): Promise<{contentMap, deviceInfoByDeviceId}> {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3072:             }",
          "3073:             contentMap[userId][deviceId] = encryptedContent;",
          "3075:             promises.push(",
          "3076:                 olmlib.encryptMessageForDevice(",
          "3077:                     encryptedContent.ciphertext,",
          "3078:                     this.userId,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3074:             const devicesByUser = {};",
          "3075:             devicesByUser[userId] = [deviceInfo];",
          "3078:                 olmlib.ensureOlmSessionsForDevices(",
          "3079:                     this.olmDevice,",
          "3080:                     this.baseApis,",
          "3081:                     devicesByUser,",
          "3082:                 ),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3114:             }",
          "3116:             return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap).then(",
          "3118:             );",
          "3119:         });",
          "3120:     }",
          "",
          "[Removed Lines]",
          "3117:                 afterwards.bind(contentMap, deviceInfoByDeviceId)",
          "",
          "[Added Lines]",
          "3124:                 (response)=>({ contentMap, deviceInfoByDeviceId })",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "835aafcb179bccacae8057c6f9afa74d37c80ca2",
      "candidate_info": {
        "commit_hash": "835aafcb179bccacae8057c6f9afa74d37c80ca2",
        "repo": "matrix-org/matrix-js-sdk",
        "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/835aafcb179bccacae8057c6f9afa74d37c80ca2",
        "files": [
          "src/crypto/DeviceList.ts",
          "src/crypto/algorithms/base.ts",
          "src/crypto/algorithms/index.js",
          "src/crypto/algorithms/index.ts",
          "src/crypto/algorithms/megolm.js",
          "src/crypto/algorithms/megolm.ts",
          "src/crypto/algorithms/olm.js",
          "src/crypto/algorithms/olm.ts",
          "src/crypto/index.ts",
          "src/models/event.ts"
        ],
        "message": "Type the rest of algorithms because tests are unhappy otherwise",
        "before_after_code_files": [
          "src/crypto/DeviceList.ts||src/crypto/DeviceList.ts",
          "src/crypto/algorithms/base.ts||src/crypto/algorithms/base.ts",
          "src/crypto/algorithms/index.js||src/crypto/algorithms/index.ts",
          "src/crypto/algorithms/megolm.js||src/crypto/algorithms/megolm.js",
          "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts",
          "src/crypto/algorithms/olm.js||src/crypto/algorithms/olm.js",
          "src/crypto/algorithms/olm.ts||src/crypto/algorithms/olm.ts",
          "src/crypto/index.ts||src/crypto/index.ts",
          "src/models/event.ts||src/models/event.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ],
          "candidate": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ]
        }
      },
      "candidate_diff": {
        "src/crypto/DeviceList.ts||src/crypto/DeviceList.ts": [
          "File: src/crypto/DeviceList.ts -> src/crypto/DeviceList.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:     UpToDate,",
          "60: }",
          "",
          "[Removed Lines]",
          "62: type DeviceInfoMap = Record<string, Record<string, IDevice>>;",
          "",
          "[Added Lines]",
          "62: export type DeviceInfoMap = Record<string, Record<string, DeviceInfo>>;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "73:     private devices: DeviceInfoMap = {};",
          "",
          "[Added Lines]",
          "73:     private devices: Record<string, Record<string, IDevice>> = {};",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "317:     private getDevicesFromStore(userIds: string[]): DeviceInfoMap {",
          "319:         userIds.map((u) => {",
          "320:             stored[u] = {};",
          "321:             const devices = this.getStoredDevicesForUser(u) || [];",
          "",
          "[Removed Lines]",
          "318:         const stored = {};",
          "",
          "[Added Lines]",
          "318:         const stored: DeviceInfoMap = {};",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "487:         this.dirty = true;",
          "488:     }",
          "",
          "[Removed Lines]",
          "469:     public storeDevicesForUser(u: string, devs: Record<string, IDevice>): void {",
          "471:         if (this.devices[u] !== undefined) {",
          "472:             for (const [deviceId, dev] of Object.entries(this.devices[u])) {",
          "473:                 const identityKey = dev.keys['curve25519:'+deviceId];",
          "475:                 delete this.userByIdentityKey[identityKey];",
          "476:             }",
          "477:         }",
          "479:         this.devices[u] = devs;",
          "482:         for (const [deviceId, dev] of Object.entries(devs)) {",
          "483:             const identityKey = dev.keys['curve25519:'+deviceId];",
          "485:             this.userByIdentityKey[identityKey] = u;",
          "486:         }",
          "",
          "[Added Lines]",
          "469:     public storeDevicesForUser(userId: string, devices: Record<string, IDevice>): void {",
          "470:         this.setRawStoredDevicesForUser(userId, devices);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "859:             );",
          "863:             Object.keys(userStore).forEach((deviceId) => {",
          "864:                 storage[deviceId] = userStore[deviceId].toStorage();",
          "865:             });",
          "",
          "[Removed Lines]",
          "862:             const storage = {};",
          "",
          "[Added Lines]",
          "846:             const storage: Record<string, IDevice> = {};",
          "",
          "---------------"
        ],
        "src/crypto/algorithms/base.ts||src/crypto/algorithms/base.ts": [
          "File: src/crypto/algorithms/base.ts -> src/crypto/algorithms/base.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: import { Room } from \"../../models/room\";",
          "25: import { OlmDevice } from \"../OlmDevice\";",
          "26: import { MatrixEvent, RoomMember } from \"../..\";",
          "28: import { DeviceInfo } from \"../deviceinfo\";",
          "",
          "[Removed Lines]",
          "27: import { IEventDecryptionResult, IMegolmSessionData, IncomingRoomKeyRequest } from \"..\";",
          "",
          "[Added Lines]",
          "27: import { Crypto, IEventDecryptionResult, IMegolmSessionData, IncomingRoomKeyRequest } from \"..\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "36: export const ENCRYPTION_CLASSES: Record<string, EncryptionAlgorithm> = {};",
          "",
          "[Added Lines]",
          "36: export const ENCRYPTION_CLASSES: Record<string, new (params: IParams) => EncryptionAlgorithm> = {};",
          "38: type DecryptionClassParams = Omit<IParams, \"deviceId\" | \"config\">;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "46: interface IParams {",
          "47:     userId: string;",
          "",
          "[Removed Lines]",
          "44: export const DECRYPTION_CLASSES: Record<string, DecryptionAlgorithm> = {};",
          "",
          "[Added Lines]",
          "46: export const DECRYPTION_CLASSES: Record<string, new (params: DecryptionClassParams) => DecryptionAlgorithm> = {};",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "50:     olmDevice: OlmDevice;",
          "51:     baseApis: MatrixClient;",
          "52:     roomId: string;",
          "53: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "55:     config: object;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "92:     public abstract prepareToEncrypt(room: Room): void;",
          "",
          "[Added Lines]",
          "95:     public prepareToEncrypt(room: Room): void {}",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "121:         senderKey: string,",
          "122:         sessionId: string,",
          "123:         userId: string,",
          "124:         device: DeviceInfo,",
          "125:     ): Promise<void>;",
          "128: }",
          "",
          "[Removed Lines]",
          "118:     public abstract onRoomMembership(event: MatrixEvent, member: RoomMember, oldMembership?: string);",
          "120:     public abstract reshareKeyWithDevice(",
          "127:     public forceDiscardSession?: () => void;",
          "",
          "[Added Lines]",
          "121:     public onRoomMembership(event: MatrixEvent, member: RoomMember, oldMembership?: string): void {}",
          "123:     public reshareKeyWithDevice?(",
          "130:     public forceDiscardSession?(): void;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "142: export abstract class DecryptionAlgorithm {",
          "150:         this.userId = params.userId;",
          "151:         this.crypto = params.crypto;",
          "152:         this.olmDevice = params.olmDevice;",
          "",
          "[Removed Lines]",
          "143:     private readonly userId: string;",
          "144:     private readonly crypto: Crypto;",
          "145:     private readonly olmDevice: OlmDevice;",
          "146:     private readonly baseApis: MatrixClient;",
          "147:     private readonly roomId: string;",
          "149:     constructor(params: Omit<IParams, \"deviceId\">) {",
          "",
          "[Added Lines]",
          "146:     protected readonly userId: string;",
          "147:     protected readonly crypto: Crypto;",
          "148:     protected readonly olmDevice: OlmDevice;",
          "149:     protected readonly baseApis: MatrixClient;",
          "150:     protected readonly roomId: string;",
          "152:     constructor(params: DecryptionClassParams) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "209:         throw new Error(\"shareKeysWithDevice not supported for this DecryptionAlgorithm\");",
          "210:     }",
          "",
          "[Removed Lines]",
          "208:     public shareKeysWithDevice(keyRequest: IncomingRoomKeyRequest) {",
          "",
          "[Added Lines]",
          "211:     public shareKeysWithDevice(keyRequest: IncomingRoomKeyRequest): void {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "220:     }",
          "224: }",
          "",
          "[Removed Lines]",
          "218:     public async retryDecryptionFromSender(senderKey: string): Promise<void> {",
          "222:     public onRoomKeyWithheldEvent?: (event: MatrixEvent) => Promise<void>;",
          "223:     public sendSharedHistoryInboundSessions?: (devicesByUser: Record<string, DeviceInfo[]>) => Promise<void>;",
          "",
          "[Added Lines]",
          "221:     public async retryDecryptionFromSender(senderKey: string): Promise<boolean> {",
          "223:         return false;",
          "226:     public onRoomKeyWithheldEvent?(event: MatrixEvent): Promise<void>;",
          "227:     public sendSharedHistoryInboundSessions?(devicesByUser: Record<string, DeviceInfo[]>): Promise<void>;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "237: export class DecryptionError extends Error {",
          "238:     public readonly detailedString: string;",
          "241:         super(msg);",
          "242:         this.code = code;",
          "243:         this.name = 'DecryptionError';",
          "",
          "[Removed Lines]",
          "240:     constructor(public readonly code: string, msg: string, details: Record<string, string>) {",
          "",
          "[Added Lines]",
          "244:     constructor(public readonly code: string, msg: string, details?: Record<string, string>) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "245:     }",
          "246: }",
          "249:     let result = err.name + '[msg: ' + err.message;",
          "251:     if (details) {",
          "",
          "[Removed Lines]",
          "248: function detailedStringForDecryptionError(err: DecryptionError, details: Record<string, string>): string {",
          "",
          "[Added Lines]",
          "252: function detailedStringForDecryptionError(err: DecryptionError, details?: Record<string, string>): string {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "290: export function registerAlgorithm(",
          "291:     algorithm: string,",
          "294: ): void {",
          "295:     ENCRYPTION_CLASSES[algorithm] = encryptor;",
          "296:     DECRYPTION_CLASSES[algorithm] = decryptor;",
          "",
          "[Removed Lines]",
          "292:     encryptor: EncryptionAlgorithm,",
          "293:     decryptor: DecryptionAlgorithm,",
          "",
          "[Added Lines]",
          "296:     encryptor: new (params: IParams) => EncryptionAlgorithm,",
          "297:     decryptor: new (params: Omit<IParams, \"deviceId\">) => DecryptionAlgorithm,",
          "",
          "---------------"
        ],
        "src/crypto/algorithms/index.js||src/crypto/algorithms/index.ts": [
          "File: src/crypto/algorithms/index.js -> src/crypto/algorithms/index.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: Licensed under the Apache License, Version 2.0 (the \"License\");",
          "6: you may not use this file except in compliance with the License.",
          "",
          "[Removed Lines]",
          "2: Copyright 2016 OpenMarket Ltd",
          "3: Copyright 2019 The Matrix.org Foundation C.I.C.",
          "",
          "[Added Lines]",
          "2: Copyright 2016 - 2021 The Matrix.org Foundation C.I.C.",
          "",
          "---------------"
        ],
        "src/crypto/algorithms/megolm.js||src/crypto/algorithms/megolm.js": [
          "File: src/crypto/algorithms/megolm.js -> src/crypto/algorithms/megolm.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
          "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: Copyright 2015 - 2021 The Matrix.org Foundation C.I.C.",
          "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
          "5: you may not use this file except in compliance with the License.",
          "6: You may obtain a copy of the License at",
          "8:     http://www.apache.org/licenses/LICENSE-2.0",
          "10: Unless required by applicable law or agreed to in writing, software",
          "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
          "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "13: See the License for the specific language governing permissions and",
          "14: limitations under the License.",
          "23: import { logger } from '../../logger';",
          "24: import * as olmlib from \"../olmlib\";",
          "25: import {",
          "26:     DecryptionAlgorithm,",
          "27:     DecryptionError,",
          "28:     EncryptionAlgorithm,",
          "29:     registerAlgorithm,",
          "30:     UnknownDeviceError,",
          "31: } from \"./base\";",
          "32: import { WITHHELD_MESSAGES } from '../OlmDevice';",
          "33: import { Room } from '../../models/room';",
          "34: import { DeviceInfo } from \"../deviceinfo\";",
          "35: import { IOlmSessionResult } from \"../olmlib\";",
          "36: import { DeviceInfoMap } from \"../DeviceList\";",
          "37: import { MatrixEvent } from \"../..\";",
          "38: import { IEventDecryptionResult, IMegolmSessionData, IncomingRoomKeyRequest } from \"../index\";",
          "41: export function isRoomSharedHistory(room: Room): boolean {",
          "42:     const visibilityEvent = room?.currentState?.getStateEvents(\"m.room.history_visibility\", \"\");",
          "48:     const visibility = visibilityEvent?.getContent()?.history_visibility;",
          "49:     return [\"world_readable\", \"shared\"].includes(visibility);",
          "50: }",
          "52: interface IBlockedDevice {",
          "53:     code: string;",
          "54:     reason: string;",
          "55:     deviceInfo: DeviceInfo;",
          "56: }",
          "58: interface IBlockedMap {",
          "59:     [userId: string]: {",
          "60:         [deviceId: string]: IBlockedDevice;",
          "61:     };",
          "62: }",
          "64: interface IOlmDevice<T = DeviceInfo> {",
          "65:     userId: string;",
          "66:     deviceInfo: T;",
          "67: }",
          "70: interface IOutboundGroupSessionKey {",
          "71:     chain_index: number;",
          "72:     key: string;",
          "73: }",
          "75: interface IMessage {",
          "76:     type: string;",
          "77:     content: {",
          "78:         algorithm: string;",
          "79:         room_id: string;",
          "80:         sender_key?: string;",
          "81:         sender_claimed_ed25519_key?: string;",
          "82:         session_id: string;",
          "83:         session_key: string;",
          "84:         chain_index: number;",
          "85:         forwarding_curve25519_key_chain?: string[];",
          "86:         \"org.matrix.msc3061.shared_history\": boolean;",
          "87:     };",
          "88: }",
          "90: interface IKeyForwardingMessage extends IMessage {",
          "91:     type: \"m.forwarded_room_key\";",
          "92: }",
          "94: interface IPayload extends Partial<IMessage> {",
          "95:     code?: string;",
          "96:     reason?: string;",
          "97:     room_id?: string;",
          "98:     session_id?: string;",
          "99:     algorithm?: string;",
          "100:     sender_key?: string;",
          "101: }",
          "120: class OutboundSessionInfo {",
          "121:     public useCount = 0;",
          "122:     public creationTime: number;",
          "123:     public sharedWithDevices: Record<string, Record<string, number>> = {};",
          "124:     public blockedDevicesNotified: Record<string, Record<string, boolean>> = {};",
          "126:     constructor(public readonly sessionId: string, public readonly sharedHistory = false) {",
          "127:         this.creationTime = new Date().getTime();",
          "128:     }",
          "137:     public needsRotation(rotationPeriodMsgs: number, rotationPeriodMs: number): boolean {",
          "138:         const sessionLifetime = new Date().getTime() - this.creationTime;",
          "140:         if (this.useCount >= rotationPeriodMsgs ||",
          "141:             sessionLifetime >= rotationPeriodMs",
          "142:         ) {",
          "143:             logger.log(",
          "144:                 \"Rotating megolm session after \" + this.useCount +",
          "145:                 \" messages, \" + sessionLifetime + \"ms\",",
          "146:             );",
          "147:             return true;",
          "148:         }",
          "150:         return false;",
          "151:     }",
          "153:     public markSharedWithDevice(userId: string, deviceId: string, chainIndex: number): void {",
          "154:         if (!this.sharedWithDevices[userId]) {",
          "155:             this.sharedWithDevices[userId] = {};",
          "156:         }",
          "157:         this.sharedWithDevices[userId][deviceId] = chainIndex;",
          "158:     }",
          "160:     public markNotifiedBlockedDevice(userId: string, deviceId: string): void {",
          "161:         if (!this.blockedDevicesNotified[userId]) {",
          "162:             this.blockedDevicesNotified[userId] = {};",
          "163:         }",
          "164:         this.blockedDevicesNotified[userId][deviceId] = true;",
          "165:     }",
          "177:     public sharedWithTooManyDevices(devicesInRoom: Record<string, Record<string, object>>): boolean {",
          "178:         for (const userId in this.sharedWithDevices) {",
          "179:             if (!this.sharedWithDevices.hasOwnProperty(userId)) {",
          "180:                 continue;",
          "181:             }",
          "183:             if (!devicesInRoom.hasOwnProperty(userId)) {",
          "184:                 logger.log(\"Starting new megolm session because we shared with \" + userId);",
          "185:                 return true;",
          "186:             }",
          "188:             for (const deviceId in this.sharedWithDevices[userId]) {",
          "189:                 if (!this.sharedWithDevices[userId].hasOwnProperty(deviceId)) {",
          "190:                     continue;",
          "191:                 }",
          "193:                 if (!devicesInRoom[userId].hasOwnProperty(deviceId)) {",
          "194:                     logger.log(",
          "195:                         \"Starting new megolm session because we shared with \" +",
          "196:                         userId + \":\" + deviceId,",
          "197:                     );",
          "198:                     return true;",
          "199:                 }",
          "200:             }",
          "201:         }",
          "202:     }",
          "203: }",
          "214: class MegolmEncryption extends EncryptionAlgorithm {",
          "220:     private setupPromise = Promise.resolve<OutboundSessionInfo>(undefined);",
          "225:     private outboundSessions: Record<string, OutboundSessionInfo> = {};",
          "227:     private readonly sessionRotationPeriodMsgs: number;",
          "228:     private readonly sessionRotationPeriodMs: number;",
          "229:     private encryptionPreparation: Promise<void>;",
          "230:     private encryptionPreparationMetadata: {",
          "231:         startTime: number;",
          "232:     };",
          "234:     constructor(params) {",
          "235:         super(params);",
          "237:         this.sessionRotationPeriodMsgs = params.config?.rotation_period_msgs ?? 100;",
          "238:         this.sessionRotationPeriodMs = params.config?.rotation_period_ms ?? 7 * 24 * 3600 * 1000;",
          "239:     }",
          "253:     private async ensureOutboundSession(",
          "254:         room: Room,",
          "255:         devicesInRoom: DeviceInfoMap,",
          "256:         blocked: IBlockedMap,",
          "257:         singleOlmCreationPhase = false,",
          "258:     ): Promise<OutboundSessionInfo> {",
          "259:         let session;",
          "266:         const prepareSession = async (oldSession: OutboundSessionInfo) => {",
          "267:             session = oldSession;",
          "269:             const sharedHistory = isRoomSharedHistory(room);",
          "272:             if (session && sharedHistory !== session.sharedHistory) {",
          "273:                 session = null;",
          "274:             }",
          "277:             if (session && session.needsRotation(this.sessionRotationPeriodMsgs,",
          "278:                 this.sessionRotationPeriodMs)",
          "279:             ) {",
          "280:                 logger.log(\"Starting new megolm session because we need to rotate.\");",
          "281:                 session = null;",
          "282:             }",
          "285:             if (session && session.sharedWithTooManyDevices(devicesInRoom)) {",
          "286:                 session = null;",
          "287:             }",
          "289:             if (!session) {",
          "290:                 logger.log(`Starting new megolm session for room ${this.roomId}`);",
          "291:                 session = await this.prepareNewSession(sharedHistory);",
          "292:                 logger.log(`Started new megolm session ${session.sessionId} ` +",
          "293:                     `for room ${this.roomId}`);",
          "294:                 this.outboundSessions[session.sessionId] = session;",
          "295:             }",
          "298:             const shareMap = {};",
          "300:             for (const [userId, userDevices] of Object.entries(devicesInRoom)) {",
          "301:                 for (const [deviceId, deviceInfo] of Object.entries(userDevices)) {",
          "302:                     const key = deviceInfo.getIdentityKey();",
          "303:                     if (key == this.olmDevice.deviceCurve25519Key) {",
          "305:                         continue;",
          "306:                     }",
          "308:                     if (",
          "309:                         !session.sharedWithDevices[userId] ||",
          "310:                         session.sharedWithDevices[userId][deviceId] === undefined",
          "311:                     ) {",
          "312:                         shareMap[userId] = shareMap[userId] || [];",
          "313:                         shareMap[userId].push(deviceInfo);",
          "314:                     }",
          "315:                 }",
          "316:             }",
          "318:             const key = this.olmDevice.getOutboundGroupSessionKey(session.sessionId);",
          "319:             const payload: IPayload = {",
          "320:                 type: \"m.room_key\",",
          "321:                 content: {",
          "322:                     \"algorithm\": olmlib.MEGOLM_ALGORITHM,",
          "323:                     \"room_id\": this.roomId,",
          "324:                     \"session_id\": session.sessionId,",
          "325:                     \"session_key\": key.key,",
          "326:                     \"chain_index\": key.chain_index,",
          "327:                     \"org.matrix.msc3061.shared_history\": sharedHistory,",
          "328:                 },",
          "329:             };",
          "330:             const [devicesWithoutSession, olmSessions] = await olmlib.getExistingOlmSessions(",
          "331:                 this.olmDevice, this.baseApis, shareMap,",
          "332:             );",
          "334:             await Promise.all([",
          "335:                 (async () => {",
          "337:                     logger.debug(`Sharing keys with existing Olm sessions in ${this.roomId}`);",
          "338:                     await this.shareKeyWithOlmSessions(session, key, payload, olmSessions);",
          "339:                     logger.debug(`Shared keys with existing Olm sessions in ${this.roomId}`);",
          "340:                 })(),",
          "341:                 (async () => {",
          "342:                     logger.debug(`Sharing keys (start phase 1) with new Olm sessions in ${this.roomId}`);",
          "343:                     const errorDevices = [];",
          "350:                     const start = Date.now();",
          "351:                     const failedServers = [];",
          "352:                     await this.shareKeyWithDevices(",
          "353:                         session, key, payload, devicesWithoutSession, errorDevices,",
          "354:                         singleOlmCreationPhase ? 10000 : 2000, failedServers,",
          "355:                     );",
          "356:                     logger.debug(`Shared keys (end phase 1) with new Olm sessions in ${this.roomId}`);",
          "358:                     if (!singleOlmCreationPhase && (Date.now() - start < 10000)) {",
          "361:                         (async () => {",
          "367:                             const retryDevices = {};",
          "368:                             const failedServerMap = new Set;",
          "369:                             for (const server of failedServers) {",
          "370:                                 failedServerMap.add(server);",
          "371:                             }",
          "372:                             const failedDevices = [];",
          "373:                             for (const { userId, deviceInfo } of errorDevices) {",
          "374:                                 const userHS = userId.slice(userId.indexOf(\":\") + 1);",
          "375:                                 if (failedServerMap.has(userHS)) {",
          "376:                                     retryDevices[userId] = retryDevices[userId] || [];",
          "377:                                     retryDevices[userId].push(deviceInfo);",
          "378:                                 } else {",
          "381:                                     failedDevices.push({ userId, deviceInfo });",
          "382:                                 }",
          "383:                             }",
          "385:                             logger.debug(`Sharing keys (start phase 2) with new Olm sessions in ${this.roomId}`);",
          "386:                             await this.shareKeyWithDevices(",
          "387:                                 session, key, payload, retryDevices, failedDevices, 30000,",
          "388:                             );",
          "389:                             logger.debug(`Shared keys (end phase 2) with new Olm sessions in ${this.roomId}`);",
          "391:                             await this.notifyFailedOlmDevices(session, key, failedDevices);",
          "392:                         })();",
          "393:                     } else {",
          "394:                         await this.notifyFailedOlmDevices(session, key, errorDevices);",
          "395:                     }",
          "396:                     logger.debug(`Shared keys (all phases done) with new Olm sessions in ${this.roomId}`);",
          "397:                 })(),",
          "398:                 (async () => {",
          "399:                     logger.debug(`Notifying blocked devices in ${this.roomId}`);",
          "401:                     const blockedMap: Record<string, Record<string, { device: IBlockedDevice }>> = {};",
          "402:                     let blockedCount = 0;",
          "403:                     for (const [userId, userBlockedDevices] of Object.entries(blocked)) {",
          "404:                         for (const [deviceId, device] of Object.entries(userBlockedDevices)) {",
          "405:                             if (",
          "406:                                 !session.blockedDevicesNotified[userId] ||",
          "407:                                 session.blockedDevicesNotified[userId][deviceId] === undefined",
          "408:                             ) {",
          "409:                                 blockedMap[userId] = blockedMap[userId] || {};",
          "410:                                 blockedMap[userId][deviceId] = { device };",
          "411:                                 blockedCount++;",
          "412:                             }",
          "413:                         }",
          "414:                     }",
          "416:                     await this.notifyBlockedDevices(session, blockedMap);",
          "417:                     logger.debug(`Notified ${blockedCount} blocked devices in ${this.roomId}`);",
          "418:                 })(),",
          "419:             ]);",
          "420:         };",
          "423:         function returnSession() {",
          "424:             return session;",
          "425:         }",
          "428:         const prom = this.setupPromise.then(prepareSession);",
          "431:         prom.catch(e => {",
          "432:             logger.error(`Failed to ensure outbound session in ${this.roomId}`, e);",
          "433:         });",
          "436:         this.setupPromise = prom.then(returnSession, returnSession);",
          "439:         return prom.then(returnSession);",
          "440:     }",
          "449:     private async prepareNewSession(sharedHistory: boolean): Promise<OutboundSessionInfo> {",
          "450:         const sessionId = this.olmDevice.createOutboundGroupSession();",
          "451:         const key = this.olmDevice.getOutboundGroupSessionKey(sessionId);",
          "453:         await this.olmDevice.addInboundGroupSession(",
          "454:             this.roomId, this.olmDevice.deviceCurve25519Key, [], sessionId,",
          "455:             key.key, { ed25519: this.olmDevice.deviceEd25519Key }, false,",
          "456:             { sharedHistory },",
          "457:         );",
          "460:         this.crypto.backupManager.backupGroupSession(this.olmDevice.deviceCurve25519Key, sessionId);",
          "462:         return new OutboundSessionInfo(sessionId, sharedHistory);",
          "463:     }",
          "480:     private getDevicesWithoutSessions(",
          "481:         devicemap: Record<string, Record<string, IOlmSessionResult>>,",
          "482:         devicesByUser: Record<string, DeviceInfo[]>,",
          "483:         noOlmDevices: IOlmDevice[] = [],",
          "484:     ): IOlmDevice[] {",
          "485:         for (const [userId, devicesToShareWith] of Object.entries(devicesByUser)) {",
          "486:             const sessionResults = devicemap[userId];",
          "488:             for (const deviceInfo of devicesToShareWith) {",
          "489:                 const deviceId = deviceInfo.deviceId;",
          "491:                 const sessionResult = sessionResults[deviceId];",
          "492:                 if (!sessionResult.sessionId) {",
          "496:                     noOlmDevices.push({ userId, deviceInfo });",
          "497:                     delete sessionResults[deviceId];",
          "501:                     continue;",
          "502:                 }",
          "503:             }",
          "504:         }",
          "506:         return noOlmDevices;",
          "507:     }",
          "519:     private splitDevices<T extends DeviceInfo | IBlockedDevice>(",
          "520:         devicesByUser: Record<string, Record<string, { device: T }>>,",
          "521:     ): IOlmDevice<T>[][] {",
          "522:         const maxDevicesPerRequest = 20;",
          "525:         let currentSlice: IOlmDevice<T>[] = [];",
          "526:         const mapSlices = [currentSlice];",
          "528:         for (const [userId, userDevices] of Object.entries(devicesByUser)) {",
          "529:             for (const deviceInfo of Object.values(userDevices)) {",
          "530:                 currentSlice.push({",
          "531:                     userId: userId,",
          "532:                     deviceInfo: deviceInfo.device,",
          "533:                 });",
          "534:             }",
          "541:             if (currentSlice.length > maxDevicesPerRequest) {",
          "543:                 currentSlice = [];",
          "544:                 mapSlices.push(currentSlice);",
          "545:             }",
          "546:         }",
          "547:         if (currentSlice.length === 0) {",
          "548:             mapSlices.pop();",
          "549:         }",
          "550:         return mapSlices;",
          "551:     }",
          "568:     private encryptAndSendKeysToDevices(",
          "569:         session: OutboundSessionInfo,",
          "570:         chainIndex: number,",
          "571:         userDeviceMap: IOlmDevice[],",
          "572:         payload: IPayload,",
          "573:     ): Promise<void> {",
          "574:         const contentMap = {};",
          "576:         const promises = [];",
          "577:         for (let i = 0; i < userDeviceMap.length; i++) {",
          "578:             const encryptedContent = {",
          "579:                 algorithm: olmlib.OLM_ALGORITHM,",
          "580:                 sender_key: this.olmDevice.deviceCurve25519Key,",
          "581:                 ciphertext: {},",
          "582:             };",
          "583:             const val = userDeviceMap[i];",
          "584:             const userId = val.userId;",
          "585:             const deviceInfo = val.deviceInfo;",
          "586:             const deviceId = deviceInfo.deviceId;",
          "588:             if (!contentMap[userId]) {",
          "589:                 contentMap[userId] = {};",
          "590:             }",
          "591:             contentMap[userId][deviceId] = encryptedContent;",
          "593:             promises.push(",
          "594:                 olmlib.encryptMessageForDevice(",
          "595:                     encryptedContent.ciphertext,",
          "596:                     this.userId,",
          "597:                     this.deviceId,",
          "598:                     this.olmDevice,",
          "599:                     userId,",
          "600:                     deviceInfo,",
          "601:                     payload,",
          "602:                 ),",
          "603:             );",
          "604:         }",
          "606:         return Promise.all(promises).then(() => {",
          "611:             for (const userId of Object.keys(contentMap)) {",
          "612:                 for (const deviceId of Object.keys(contentMap[userId])) {",
          "613:                     if (Object.keys(contentMap[userId][deviceId].ciphertext).length === 0) {",
          "614:                         logger.log(",
          "615:                             \"No ciphertext for device \" +",
          "616:                             userId + \":\" + deviceId + \": pruning\",",
          "617:                         );",
          "618:                         delete contentMap[userId][deviceId];",
          "619:                     }",
          "620:                 }",
          "622:                 if (Object.keys(contentMap[userId]).length === 0) {",
          "623:                     logger.log(\"Pruned all devices for user \" + userId);",
          "624:                     delete contentMap[userId];",
          "625:                 }",
          "626:             }",
          "629:             if (Object.keys(contentMap).length === 0) {",
          "630:                 logger.log(\"No users left to send to: aborting\");",
          "631:                 return;",
          "632:             }",
          "634:             return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap).then(() => {",
          "636:                 for (const userId of Object.keys(contentMap)) {",
          "637:                     for (const deviceId of Object.keys(contentMap[userId])) {",
          "638:                         session.markSharedWithDevice(",
          "639:                             userId, deviceId, chainIndex,",
          "640:                         );",
          "641:                     }",
          "642:                 }",
          "643:             });",
          "644:         });",
          "645:     }",
          "659:     private async sendBlockedNotificationsToDevices(",
          "660:         session: OutboundSessionInfo,",
          "661:         userDeviceMap: IOlmDevice<IBlockedDevice>[],",
          "662:         payload: IPayload,",
          "663:     ): Promise<void> {",
          "664:         const contentMap = {};",
          "666:         for (const val of userDeviceMap) {",
          "667:             const userId = val.userId;",
          "668:             const blockedInfo = val.deviceInfo;",
          "669:             const deviceInfo = blockedInfo.deviceInfo;",
          "670:             const deviceId = deviceInfo.deviceId;",
          "672:             const message = Object.assign({}, payload);",
          "673:             message.code = blockedInfo.code;",
          "674:             message.reason = blockedInfo.reason;",
          "675:             if (message.code === \"m.no_olm\") {",
          "676:                 delete message.room_id;",
          "677:                 delete message.session_id;",
          "678:             }",
          "680:             if (!contentMap[userId]) {",
          "681:                 contentMap[userId] = {};",
          "682:             }",
          "683:             contentMap[userId][deviceId] = message;",
          "684:         }",
          "686:         await this.baseApis.sendToDevice(\"org.matrix.room_key.withheld\", contentMap);",
          "689:         for (const userId of Object.keys(contentMap)) {",
          "690:             for (const deviceId of Object.keys(contentMap[userId])) {",
          "691:                 session.markNotifiedBlockedDevice(userId, deviceId);",
          "692:             }",
          "693:         }",
          "694:     }",
          "705:     public async reshareKeyWithDevice(",
          "706:         senderKey: string,",
          "707:         sessionId: string,",
          "708:         userId: string,",
          "709:         device: DeviceInfo,",
          "710:     ): Promise<void> {",
          "711:         const obSessionInfo = this.outboundSessions[sessionId];",
          "712:         if (!obSessionInfo) {",
          "713:             logger.debug(`megolm session ${sessionId} not found: not re-sharing keys`);",
          "714:             return;",
          "715:         }",
          "718:         if (obSessionInfo.sharedWithDevices[userId] === undefined) {",
          "719:             logger.debug(`megolm session ${sessionId} never shared with user ${userId}`);",
          "720:             return;",
          "721:         }",
          "722:         const sentChainIndex = obSessionInfo.sharedWithDevices[userId][device.deviceId];",
          "723:         if (sentChainIndex === undefined) {",
          "724:             logger.debug(",
          "725:                 \"megolm session ID \" + sessionId + \" never shared with device \" +",
          "726:                 userId + \":\" + device.deviceId,",
          "727:             );",
          "728:             return;",
          "729:         }",
          "733:         const key = await this.olmDevice.getInboundGroupSessionKey(",
          "734:             this.roomId, senderKey, sessionId, sentChainIndex,",
          "735:         );",
          "737:         if (!key) {",
          "738:             logger.warn(",
          "739:                 `No inbound session key found for megolm ${sessionId}: not re-sharing keys`,",
          "740:             );",
          "741:             return;",
          "742:         }",
          "744:         await olmlib.ensureOlmSessionsForDevices(",
          "745:             this.olmDevice, this.baseApis, {",
          "746:                 [userId]: [device],",
          "747:             },",
          "748:         );",
          "750:         const payload = {",
          "751:             type: \"m.forwarded_room_key\",",
          "752:             content: {",
          "753:                 \"algorithm\": olmlib.MEGOLM_ALGORITHM,",
          "754:                 \"room_id\": this.roomId,",
          "755:                 \"session_id\": sessionId,",
          "756:                 \"session_key\": key.key,",
          "757:                 \"chain_index\": key.chain_index,",
          "758:                 \"sender_key\": senderKey,",
          "759:                 \"sender_claimed_ed25519_key\": key.sender_claimed_ed25519_key,",
          "760:                 \"forwarding_curve25519_key_chain\": key.forwarding_curve25519_key_chain,",
          "761:                 \"org.matrix.msc3061.shared_history\": key.shared_history || false,",
          "762:             },",
          "763:         };",
          "765:         const encryptedContent = {",
          "766:             algorithm: olmlib.OLM_ALGORITHM,",
          "767:             sender_key: this.olmDevice.deviceCurve25519Key,",
          "768:             ciphertext: {},",
          "769:         };",
          "770:         await olmlib.encryptMessageForDevice(",
          "771:             encryptedContent.ciphertext,",
          "772:             this.userId,",
          "773:             this.deviceId,",
          "774:             this.olmDevice,",
          "775:             userId,",
          "776:             device,",
          "777:             payload,",
          "778:         );",
          "780:         await this.baseApis.sendToDevice(\"m.room.encrypted\", {",
          "781:             [userId]: {",
          "782:                 [device.deviceId]: encryptedContent,",
          "783:             },",
          "784:         });",
          "785:         logger.debug(`Re-shared key for megolm session ${sessionId} with ${userId}:${device.deviceId}`);",
          "786:     }",
          "811:     private async shareKeyWithDevices(",
          "812:         session: OutboundSessionInfo,",
          "813:         key: IOutboundGroupSessionKey,",
          "814:         payload: IPayload,",
          "815:         devicesByUser: Record<string, DeviceInfo[]>,",
          "816:         errorDevices: IOlmDevice[],",
          "817:         otkTimeout: number,",
          "818:         failedServers?: string[],",
          "819:     ) {",
          "820:         logger.debug(`Ensuring Olm sessions for devices in ${this.roomId}`);",
          "821:         const devicemap = await olmlib.ensureOlmSessionsForDevices(",
          "822:             this.olmDevice, this.baseApis, devicesByUser, false, otkTimeout, failedServers,",
          "823:             logger.withPrefix(`[${this.roomId}]`),",
          "824:         );",
          "825:         logger.debug(`Ensured Olm sessions for devices in ${this.roomId}`);",
          "827:         this.getDevicesWithoutSessions(devicemap, devicesByUser, errorDevices);",
          "829:         logger.debug(`Sharing keys with Olm sessions in ${this.roomId}`);",
          "830:         await this.shareKeyWithOlmSessions(session, key, payload, devicemap);",
          "831:         logger.debug(`Shared keys with Olm sessions in ${this.roomId}`);",
          "832:     }",
          "834:     private async shareKeyWithOlmSessions(",
          "835:         session: OutboundSessionInfo,",
          "836:         key: IOutboundGroupSessionKey,",
          "837:         payload: IPayload,",
          "838:         devicemap: Record<string, Record<string, IOlmSessionResult>>,",
          "839:     ): Promise<void> {",
          "840:         const userDeviceMaps = this.splitDevices(devicemap);",
          "842:         for (let i = 0; i < userDeviceMaps.length; i++) {",
          "843:             const taskDetail =",
          "844:                 `megolm keys for ${session.sessionId} ` +",
          "845:                 `in ${this.roomId} (slice ${i + 1}/${userDeviceMaps.length})`;",
          "846:             try {",
          "847:                 logger.debug(`Sharing ${taskDetail}`);",
          "848:                 await this.encryptAndSendKeysToDevices(",
          "849:                     session, key.chain_index, userDeviceMaps[i], payload,",
          "850:                 );",
          "851:                 logger.debug(`Shared ${taskDetail}`);",
          "852:             } catch (e) {",
          "853:                 logger.error(`Failed to share ${taskDetail}`);",
          "854:                 throw e;",
          "855:             }",
          "856:         }",
          "857:     }",
          "869:     private async notifyFailedOlmDevices(",
          "870:         session: OutboundSessionInfo,",
          "871:         key: IOutboundGroupSessionKey,",
          "872:         failedDevices: IOlmDevice[],",
          "873:     ): Promise<void> {",
          "874:         logger.debug(",
          "875:             `Notifying ${failedDevices.length} devices we failed to ` +",
          "876:             `create Olm sessions in ${this.roomId}`,",
          "877:         );",
          "881:         for (const { userId, deviceInfo } of failedDevices) {",
          "882:             const deviceId = deviceInfo.deviceId;",
          "884:             session.markSharedWithDevice(",
          "885:                 userId, deviceId, key.chain_index,",
          "886:             );",
          "887:         }",
          "889:         const filteredFailedDevices =",
          "890:             await this.olmDevice.filterOutNotifiedErrorDevices(",
          "891:                 failedDevices,",
          "892:             );",
          "893:         logger.debug(",
          "894:             `Filtered down to ${filteredFailedDevices.length} error devices ` +",
          "895:             `in ${this.roomId}`,",
          "896:         );",
          "897:         const blockedMap: Record<string, Record<string, { device: IBlockedDevice }>> = {};",
          "898:         for (const { userId, deviceInfo } of filteredFailedDevices) {",
          "899:             blockedMap[userId] = blockedMap[userId] || {};",
          "903:             blockedMap[userId][deviceInfo.deviceId] = {",
          "904:                 device: {",
          "905:                     code: \"m.no_olm\",",
          "906:                     reason: WITHHELD_MESSAGES[\"m.no_olm\"],",
          "907:                     deviceInfo,",
          "908:                 },",
          "909:             };",
          "910:         }",
          "913:         await this.notifyBlockedDevices(session, blockedMap);",
          "914:         logger.debug(",
          "915:             `Notified ${filteredFailedDevices.length} devices we failed to ` +",
          "916:             `create Olm sessions in ${this.roomId}`,",
          "917:         );",
          "918:     }",
          "928:     private async notifyBlockedDevices(",
          "929:         session: OutboundSessionInfo,",
          "930:         devicesByUser: Record<string, Record<string, { device: IBlockedDevice }>>,",
          "931:     ): Promise<void> {",
          "932:         const payload: IPayload = {",
          "933:             room_id: this.roomId,",
          "934:             session_id: session.sessionId,",
          "935:             algorithm: olmlib.MEGOLM_ALGORITHM,",
          "936:             sender_key: this.olmDevice.deviceCurve25519Key,",
          "937:         };",
          "939:         const userDeviceMaps = this.splitDevices(devicesByUser);",
          "941:         for (let i = 0; i < userDeviceMaps.length; i++) {",
          "942:             try {",
          "943:                 await this.sendBlockedNotificationsToDevices(session, userDeviceMaps[i], payload);",
          "944:                 logger.log(`Completed blacklist notification for ${session.sessionId} `",
          "945:                     + `in ${this.roomId} (slice ${i + 1}/${userDeviceMaps.length})`);",
          "946:             } catch (e) {",
          "947:                 logger.log(`blacklist notification for ${session.sessionId} in `",
          "948:                     + `${this.roomId} (slice ${i + 1}/${userDeviceMaps.length}) failed`);",
          "950:                 throw e;",
          "951:             }",
          "952:         }",
          "953:     }",
          "961:     public prepareToEncrypt(room: Room): void {",
          "962:         if (this.encryptionPreparation) {",
          "966:             const elapsedTime = Date.now() - this.encryptionPreparationMetadata.startTime;",
          "967:             logger.debug(",
          "968:                 `Already started preparing to encrypt for ${this.roomId} ` +",
          "969:                 `${elapsedTime} ms ago, skipping`,",
          "970:             );",
          "971:             return;",
          "972:         }",
          "974:         logger.debug(`Preparing to encrypt events for ${this.roomId}`);",
          "976:         this.encryptionPreparationMetadata = {",
          "977:             startTime: Date.now(),",
          "978:         };",
          "979:         this.encryptionPreparation = (async () => {",
          "980:             try {",
          "981:                 logger.debug(`Getting devices in ${this.roomId}`);",
          "982:                 const [devicesInRoom, blocked] = await this.getDevicesInRoom(room);",
          "984:                 if (this.crypto.getGlobalErrorOnUnknownDevices()) {",
          "988:                     this.removeUnknownDevices(devicesInRoom);",
          "989:                 }",
          "991:                 logger.debug(`Ensuring outbound session in ${this.roomId}`);",
          "992:                 await this.ensureOutboundSession(room, devicesInRoom, blocked, true);",
          "994:                 logger.debug(`Ready to encrypt events for ${this.roomId}`);",
          "995:             } catch (e) {",
          "996:                 logger.error(`Failed to prepare to encrypt events for ${this.roomId}`, e);",
          "997:             } finally {",
          "998:                 delete this.encryptionPreparationMetadata;",
          "999:                 delete this.encryptionPreparation;",
          "1000:             }",
          "1001:         })();",
          "1002:     }",
          "1013:     public async encryptMessage(room: Room, eventType: string, content: object): Promise<object> {",
          "1014:         logger.log(`Starting to encrypt event for ${this.roomId}`);",
          "1016:         if (this.encryptionPreparation) {",
          "1020:             try {",
          "1021:                 await this.encryptionPreparation;",
          "1022:             } catch (e) {",
          "1025:             }",
          "1026:         }",
          "1028:         const [devicesInRoom, blocked] = await this.getDevicesInRoom(room);",
          "1032:         if (this.crypto.getGlobalErrorOnUnknownDevices()) {",
          "1033:             this.checkForUnknownDevices(devicesInRoom);",
          "1034:         }",
          "1036:         const session = await this.ensureOutboundSession(room, devicesInRoom, blocked);",
          "1037:         const payloadJson = {",
          "1038:             room_id: this.roomId,",
          "1039:             type: eventType,",
          "1040:             content: content,",
          "1041:         };",
          "1043:         const ciphertext = this.olmDevice.encryptGroupMessage(",
          "1044:             session.sessionId, JSON.stringify(payloadJson),",
          "1045:         );",
          "1046:         const encryptedContent = {",
          "1047:             algorithm: olmlib.MEGOLM_ALGORITHM,",
          "1048:             sender_key: this.olmDevice.deviceCurve25519Key,",
          "1049:             ciphertext: ciphertext,",
          "1050:             session_id: session.sessionId,",
          "1055:             device_id: this.deviceId,",
          "1056:         };",
          "1058:         session.useCount++;",
          "1059:         return encryptedContent;",
          "1060:     }",
          "1068:     public forceDiscardSession(): void {",
          "1069:         this.setupPromise = this.setupPromise.then(() => null);",
          "1070:     }",
          "1080:     private checkForUnknownDevices(devicesInRoom: DeviceInfoMap): void {",
          "1081:         const unknownDevices = {};",
          "1083:         Object.keys(devicesInRoom).forEach((userId)=>{",
          "1084:             Object.keys(devicesInRoom[userId]).forEach((deviceId)=>{",
          "1085:                 const device = devicesInRoom[userId][deviceId];",
          "1086:                 if (device.isUnverified() && !device.isKnown()) {",
          "1087:                     if (!unknownDevices[userId]) {",
          "1088:                         unknownDevices[userId] = {};",
          "1089:                     }",
          "1090:                     unknownDevices[userId][deviceId] = device;",
          "1091:                 }",
          "1092:             });",
          "1093:         });",
          "1095:         if (Object.keys(unknownDevices).length) {",
          "1097:             throw new UnknownDeviceError(",
          "1098:                 \"This room contains unknown devices which have not been verified. \" +",
          "1099:                 \"We strongly recommend you verify them before continuing.\", unknownDevices);",
          "1100:         }",
          "1101:     }",
          "1110:     private removeUnknownDevices(devicesInRoom: DeviceInfoMap): void {",
          "1111:         for (const [userId, userDevices] of Object.entries(devicesInRoom)) {",
          "1112:             for (const [deviceId, device] of Object.entries(userDevices)) {",
          "1113:                 if (device.isUnverified() && !device.isKnown()) {",
          "1114:                     delete userDevices[deviceId];",
          "1115:                 }",
          "1116:             }",
          "1118:             if (Object.keys(userDevices).length === 0) {",
          "1119:                 delete devicesInRoom[userId];",
          "1120:             }",
          "1121:         }",
          "1122:     }",
          "1135:     private async getDevicesInRoom(room: Room): Promise<[DeviceInfoMap, IBlockedMap]> {",
          "1136:         const members = await room.getEncryptionTargetMembers();",
          "1137:         const roomMembers = members.map(function(u) {",
          "1138:             return u.userId;",
          "1139:         });",
          "1142:         let isBlacklisting = this.crypto.getGlobalBlacklistUnverifiedDevices();",
          "1143:         if (typeof room.getBlacklistUnverifiedDevices() === 'boolean') {",
          "1144:             isBlacklisting = room.getBlacklistUnverifiedDevices();",
          "1145:         }",
          "1153:         const devices = await this.crypto.downloadKeys(roomMembers, false);",
          "1154:         const blocked: IBlockedMap = {};",
          "1156:         for (const userId in devices) {",
          "1157:             if (!devices.hasOwnProperty(userId)) {",
          "1158:                 continue;",
          "1159:             }",
          "1161:             const userDevices = devices[userId];",
          "1162:             for (const deviceId in userDevices) {",
          "1163:                 if (!userDevices.hasOwnProperty(deviceId)) {",
          "1164:                     continue;",
          "1165:                 }",
          "1167:                 const deviceTrust = this.crypto.checkDeviceTrust(userId, deviceId);",
          "1169:                 if (userDevices[deviceId].isBlocked() ||",
          "1170:                     (!deviceTrust.isVerified() && isBlacklisting)",
          "1171:                 ) {",
          "1172:                     if (!blocked[userId]) {",
          "1173:                         blocked[userId] = {};",
          "1174:                     }",
          "1175:                     const isBlocked = userDevices[deviceId].isBlocked();",
          "1176:                     blocked[userId][deviceId] = {",
          "1177:                         code: isBlocked ? \"m.blacklisted\" : \"m.unverified\",",
          "1178:                         reason: WITHHELD_MESSAGES[isBlocked ? \"m.blacklisted\" : \"m.unverified\"],",
          "1179:                         deviceInfo: userDevices[deviceId],",
          "1180:                     };",
          "1181:                     delete userDevices[deviceId];",
          "1182:                 }",
          "1183:             }",
          "1184:         }",
          "1186:         return [devices, blocked];",
          "1187:     }",
          "1188: }",
          "1199: class MegolmDecryption extends DecryptionAlgorithm {",
          "1202:     private pendingEvents: Record<string, Map<string, Set<MatrixEvent>>> = {};",
          "1205:     private olmlib = olmlib;",
          "1217:     public async decryptEvent(event: MatrixEvent): Promise<IEventDecryptionResult> {",
          "1218:         const content = event.getWireContent();",
          "1220:         if (!content.sender_key || !content.session_id ||",
          "1221:             !content.ciphertext",
          "1222:         ) {",
          "1223:             throw new DecryptionError(",
          "1224:                 \"MEGOLM_MISSING_FIELDS\",",
          "1225:                 \"Missing fields in input\",",
          "1226:             );",
          "1227:         }",
          "1234:         this.addEventToPendingList(event);",
          "1236:         let res;",
          "1237:         try {",
          "1238:             res = await this.olmDevice.decryptGroupMessage(",
          "1239:                 event.getRoomId(), content.sender_key, content.session_id, content.ciphertext,",
          "1240:                 event.getId(), event.getTs(),",
          "1241:             );",
          "1242:         } catch (e) {",
          "1243:             if (e.name === \"DecryptionError\") {",
          "1245:                 throw e;",
          "1246:             }",
          "1248:             let errorCode = \"OLM_DECRYPT_GROUP_MESSAGE_ERROR\";",
          "1250:             if (e && e.message === 'OLM.UNKNOWN_MESSAGE_INDEX') {",
          "1251:                 this.requestKeysForEvent(event);",
          "1253:                 errorCode = 'OLM_UNKNOWN_MESSAGE_INDEX';",
          "1254:             }",
          "1256:             throw new DecryptionError(",
          "1257:                 errorCode,",
          "1258:                 e ? e.toString() : \"Unknown Error: Error is undefined\", {",
          "1259:                     session: content.sender_key + '|' + content.session_id,",
          "1260:                 },",
          "1261:             );",
          "1262:         }",
          "1264:         if (res === null) {",
          "1272:             this.requestKeysForEvent(event);",
          "1276:             const problem = await this.olmDevice.sessionMayHaveProblems(",
          "1277:                 content.sender_key, event.getTs() - 120000,",
          "1278:             );",
          "1279:             if (problem) {",
          "1280:                 let problemDescription = PROBLEM_DESCRIPTIONS[problem.type]",
          "1281:                     || PROBLEM_DESCRIPTIONS.unknown;",
          "1282:                 if (problem.fixed) {",
          "1283:                     problemDescription +=",
          "1284:                         \" Trying to create a new secure channel and re-requesting the keys.\";",
          "1285:                 }",
          "1286:                 throw new DecryptionError(",
          "1287:                     \"MEGOLM_UNKNOWN_INBOUND_SESSION_ID\",",
          "1288:                     problemDescription,",
          "1289:                     {",
          "1290:                         session: content.sender_key + '|' + content.session_id,",
          "1291:                     },",
          "1292:                 );",
          "1293:             }",
          "1295:             throw new DecryptionError(",
          "1296:                 \"MEGOLM_UNKNOWN_INBOUND_SESSION_ID\",",
          "1297:                 \"The sender's device has not sent us the keys for this message.\",",
          "1298:                 {",
          "1299:                     session: content.sender_key + '|' + content.session_id,",
          "1300:                 },",
          "1301:             );",
          "1302:         }",
          "1306:         this.removeEventFromPendingList(event);",
          "1308:         const payload = JSON.parse(res.result);",
          "1313:         if (payload.room_id !== event.getRoomId()) {",
          "1314:             throw new DecryptionError(",
          "1315:                 \"MEGOLM_BAD_ROOM\",",
          "1316:                 \"Message intended for room \" + payload.room_id,",
          "1317:             );",
          "1318:         }",
          "1320:         return {",
          "1321:             clearEvent: payload,",
          "1322:             senderCurve25519Key: res.senderKey,",
          "1323:             claimedEd25519Key: res.keysClaimed.ed25519,",
          "1324:             forwardingCurve25519KeyChain: res.forwardingCurve25519KeyChain,",
          "1325:             untrusted: res.untrusted,",
          "1326:         };",
          "1327:     }",
          "1329:     private requestKeysForEvent(event: MatrixEvent): void {",
          "1330:         const wireContent = event.getWireContent();",
          "1332:         const recipients = event.getKeyRequestRecipients(this.userId);",
          "1334:         this.crypto.requestRoomKey({",
          "1335:             room_id: event.getRoomId(),",
          "1336:             algorithm: wireContent.algorithm,",
          "1337:             sender_key: wireContent.sender_key,",
          "1338:             session_id: wireContent.session_id,",
          "1339:         }, recipients);",
          "1340:     }",
          "1349:     private addEventToPendingList(event: MatrixEvent): void {",
          "1350:         const content = event.getWireContent();",
          "1351:         const senderKey = content.sender_key;",
          "1352:         const sessionId = content.session_id;",
          "1353:         if (!this.pendingEvents[senderKey]) {",
          "1354:             this.pendingEvents[senderKey] = new Map();",
          "1355:         }",
          "1356:         const senderPendingEvents = this.pendingEvents[senderKey];",
          "1357:         if (!senderPendingEvents.has(sessionId)) {",
          "1358:             senderPendingEvents.set(sessionId, new Set());",
          "1359:         }",
          "1360:         senderPendingEvents.get(sessionId).add(event);",
          "1361:     }",
          "1370:     private removeEventFromPendingList(event: MatrixEvent): void {",
          "1371:         const content = event.getWireContent();",
          "1372:         const senderKey = content.sender_key;",
          "1373:         const sessionId = content.session_id;",
          "1374:         const senderPendingEvents = this.pendingEvents[senderKey];",
          "1375:         const pendingEvents = senderPendingEvents && senderPendingEvents.get(sessionId);",
          "1376:         if (!pendingEvents) {",
          "1377:             return;",
          "1378:         }",
          "1380:         pendingEvents.delete(event);",
          "1381:         if (pendingEvents.size === 0) {",
          "1382:             senderPendingEvents.delete(senderKey);",
          "1383:         }",
          "1384:         if (senderPendingEvents.size === 0) {",
          "1385:             delete this.pendingEvents[senderKey];",
          "1386:         }",
          "1387:     }",
          "1394:     public onRoomKeyEvent(event: MatrixEvent): void {",
          "1395:         const content = event.getContent();",
          "1396:         const sessionId = content.session_id;",
          "1397:         let senderKey = event.getSenderKey();",
          "1398:         let forwardingKeyChain = [];",
          "1399:         let exportFormat = false;",
          "1400:         let keysClaimed;",
          "1402:         if (!content.room_id ||",
          "1403:             !sessionId ||",
          "1404:             !content.session_key",
          "1405:         ) {",
          "1406:             logger.error(\"key event is missing fields\");",
          "1407:             return;",
          "1408:         }",
          "1410:         if (!senderKey) {",
          "1411:             logger.error(\"key event has no sender key (not encrypted?)\");",
          "1412:             return;",
          "1413:         }",
          "1415:         if (event.getType() == \"m.forwarded_room_key\") {",
          "1416:             exportFormat = true;",
          "1417:             forwardingKeyChain = content.forwarding_curve25519_key_chain;",
          "1418:             if (!Array.isArray(forwardingKeyChain)) {",
          "1419:                 forwardingKeyChain = [];",
          "1420:             }",
          "1423:             forwardingKeyChain = forwardingKeyChain.slice();",
          "1424:             forwardingKeyChain.push(senderKey);",
          "1426:             senderKey = content.sender_key;",
          "1427:             if (!senderKey) {",
          "1428:                 logger.error(\"forwarded_room_key event is missing sender_key field\");",
          "1429:                 return;",
          "1430:             }",
          "1432:             const ed25519Key = content.sender_claimed_ed25519_key;",
          "1433:             if (!ed25519Key) {",
          "1434:                 logger.error(",
          "1435:                     `forwarded_room_key_event is missing sender_claimed_ed25519_key field`,",
          "1436:                 );",
          "1437:                 return;",
          "1438:             }",
          "1440:             keysClaimed = {",
          "1441:                 ed25519: ed25519Key,",
          "1442:             };",
          "1443:         } else {",
          "1444:             keysClaimed = event.getKeysClaimed();",
          "1445:         }",
          "1447:         const extraSessionData: any = {};",
          "1448:         if (content[\"org.matrix.msc3061.shared_history\"]) {",
          "1449:             extraSessionData.sharedHistory = true;",
          "1450:         }",
          "1451:         return this.olmDevice.addInboundGroupSession(",
          "1452:             content.room_id, senderKey, forwardingKeyChain, sessionId,",
          "1453:             content.session_key, keysClaimed,",
          "1454:             exportFormat, extraSessionData,",
          "1455:         ).then(() => {",
          "1457:             this.retryDecryption(senderKey, sessionId)",
          "1458:                 .then((success) => {",
          "1464:                     if (success) {",
          "1465:                         this.crypto.cancelRoomKeyRequest({",
          "1466:                             algorithm: content.algorithm,",
          "1467:                             room_id: content.room_id,",
          "1468:                             session_id: content.session_id,",
          "1469:                             sender_key: senderKey,",
          "1470:                         });",
          "1471:                     }",
          "1472:                 });",
          "1473:         }).then(() => {",
          "1475:             this.crypto.backupManager.backupGroupSession(senderKey, content.session_id);",
          "1476:         }).catch((e) => {",
          "1477:             logger.error(`Error handling m.room_key_event: ${e}`);",
          "1478:         });",
          "1479:     }",
          "1486:     public async onRoomKeyWithheldEvent(event: MatrixEvent): Promise<void> {",
          "1487:         const content = event.getContent();",
          "1488:         const senderKey = content.sender_key;",
          "1490:         if (content.code === \"m.no_olm\") {",
          "1491:             const sender = event.getSender();",
          "1492:             logger.warn(",
          "1493:                 `${sender}:${senderKey} was unable to establish an olm session with us`,",
          "1494:             );",
          "1503:             if (await this.olmDevice.getSessionIdForDevice(senderKey)) {",
          "1506:                 logger.debug(\"New session already created.  Not creating a new one.\");",
          "1507:                 await this.olmDevice.recordSessionProblem(senderKey, \"no_olm\", true);",
          "1508:                 this.retryDecryptionFromSender(senderKey);",
          "1509:                 return;",
          "1510:             }",
          "1511:             let device = this.crypto.deviceList.getDeviceByIdentityKey(",
          "1512:                 content.algorithm, senderKey,",
          "1513:             );",
          "1514:             if (!device) {",
          "1517:                 await this.crypto.downloadKeys([sender], false);",
          "1518:                 device = this.crypto.deviceList.getDeviceByIdentityKey(",
          "1519:                     content.algorithm, senderKey,",
          "1520:                 );",
          "1521:                 if (!device) {",
          "1522:                     logger.info(",
          "1523:                         \"Couldn't find device for identity key \" + senderKey +",
          "1524:                         \": not establishing session\",",
          "1525:                     );",
          "1526:                     await this.olmDevice.recordSessionProblem(senderKey, \"no_olm\", false);",
          "1527:                     this.retryDecryptionFromSender(senderKey);",
          "1528:                     return;",
          "1529:                 }",
          "1530:             }",
          "1531:             await olmlib.ensureOlmSessionsForDevices(",
          "1532:                 this.olmDevice, this.baseApis, { [sender]: [device] }, false,",
          "1533:             );",
          "1534:             const encryptedContent = {",
          "1535:                 algorithm: olmlib.OLM_ALGORITHM,",
          "1536:                 sender_key: this.olmDevice.deviceCurve25519Key,",
          "1537:                 ciphertext: {},",
          "1538:             };",
          "1539:             await olmlib.encryptMessageForDevice(",
          "1540:                 encryptedContent.ciphertext,",
          "1541:                 this.userId,",
          "1542:                 this.deviceId,",
          "1543:                 this.olmDevice,",
          "1544:                 sender,",
          "1545:                 device,",
          "1546:                 { type: \"m.dummy\" },",
          "1547:             );",
          "1549:             await this.olmDevice.recordSessionProblem(senderKey, \"no_olm\", true);",
          "1550:             this.retryDecryptionFromSender(senderKey);",
          "1552:             await this.baseApis.sendToDevice(\"m.room.encrypted\", {",
          "1553:                 [sender]: {",
          "1554:                     [device.deviceId]: encryptedContent,",
          "1555:                 },",
          "1556:             });",
          "1557:         } else {",
          "1558:             await this.olmDevice.addInboundGroupSessionWithheld(",
          "1559:                 content.room_id, senderKey, content.session_id, content.code,",
          "1560:                 content.reason,",
          "1561:             );",
          "1562:         }",
          "1563:     }",
          "1568:     public hasKeysForKeyRequest(keyRequest: IncomingRoomKeyRequest): Promise<boolean> {",
          "1569:         const body = keyRequest.requestBody;",
          "1571:         return this.olmDevice.hasInboundSessionKeys(",
          "1572:             body.room_id,",
          "1573:             body.sender_key,",
          "1574:             body.session_id,",
          "1576:         );",
          "1577:     }",
          "1582:     public shareKeysWithDevice(keyRequest: IncomingRoomKeyRequest): void {",
          "1583:         const userId = keyRequest.userId;",
          "1584:         const deviceId = keyRequest.deviceId;",
          "1585:         const deviceInfo = this.crypto.getStoredDevice(userId, deviceId);",
          "1586:         const body = keyRequest.requestBody;",
          "1588:         this.olmlib.ensureOlmSessionsForDevices(",
          "1589:             this.olmDevice, this.baseApis, {",
          "1590:                 [userId]: [deviceInfo],",
          "1591:             },",
          "1592:         ).then((devicemap) => {",
          "1593:             const olmSessionResult = devicemap[userId][deviceId];",
          "1594:             if (!olmSessionResult.sessionId) {",
          "1600:                 return null;",
          "1601:             }",
          "1603:             logger.log(",
          "1604:                 \"sharing keys for session \" + body.sender_key + \"|\"",
          "1605:                 + body.session_id + \" with device \"",
          "1606:                 + userId + \":\" + deviceId,",
          "1607:             );",
          "1609:             return this.buildKeyForwardingMessage(",
          "1610:                 body.room_id, body.sender_key, body.session_id,",
          "1611:             );",
          "1612:         }).then((payload) => {",
          "1613:             const encryptedContent = {",
          "1614:                 algorithm: olmlib.OLM_ALGORITHM,",
          "1615:                 sender_key: this.olmDevice.deviceCurve25519Key,",
          "1616:                 ciphertext: {},",
          "1617:             };",
          "1619:             return this.olmlib.encryptMessageForDevice(",
          "1620:                 encryptedContent.ciphertext,",
          "1621:                 this.userId,",
          "1622:                 this.deviceId,",
          "1623:                 this.olmDevice,",
          "1624:                 userId,",
          "1625:                 deviceInfo,",
          "1626:                 payload,",
          "1627:             ).then(() => {",
          "1628:                 const contentMap = {",
          "1629:                     [userId]: {",
          "1630:                         [deviceId]: encryptedContent,",
          "1631:                     },",
          "1632:                 };",
          "1635:                 return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap);",
          "1636:             });",
          "1637:         });",
          "1638:     }",
          "1640:     private async buildKeyForwardingMessage(",
          "1641:         roomId: string,",
          "1642:         senderKey: string,",
          "1643:         sessionId: string,",
          "1644:     ): Promise<IKeyForwardingMessage> {",
          "1645:         const key = await this.olmDevice.getInboundGroupSessionKey(roomId, senderKey, sessionId);",
          "1647:         return {",
          "1648:             type: \"m.forwarded_room_key\",",
          "1649:             content: {",
          "1650:                 \"algorithm\": olmlib.MEGOLM_ALGORITHM,",
          "1651:                 \"room_id\": roomId,",
          "1652:                 \"sender_key\": senderKey,",
          "1653:                 \"sender_claimed_ed25519_key\": key.sender_claimed_ed25519_key,",
          "1654:                 \"session_id\": sessionId,",
          "1655:                 \"session_key\": key.key,",
          "1656:                 \"chain_index\": key.chain_index,",
          "1657:                 \"forwarding_curve25519_key_chain\": key.forwarding_curve25519_key_chain,",
          "1658:                 \"org.matrix.msc3061.shared_history\": key.shared_history || false,",
          "1659:             },",
          "1660:         };",
          "1661:     }",
          "1671:     public importRoomKey(session: IMegolmSessionData, opts: any = {}): Promise<void> {",
          "1672:         const extraSessionData: any = {};",
          "1673:         if (opts.untrusted) {",
          "1674:             extraSessionData.untrusted = true;",
          "1675:         }",
          "1676:         if (session[\"org.matrix.msc3061.shared_history\"]) {",
          "1677:             extraSessionData.sharedHistory = true;",
          "1678:         }",
          "1679:         return this.olmDevice.addInboundGroupSession(",
          "1680:             session.room_id,",
          "1681:             session.sender_key,",
          "1682:             session.forwarding_curve25519_key_chain,",
          "1683:             session.session_id,",
          "1684:             session.session_key,",
          "1685:             session.sender_claimed_keys,",
          "1686:             true,",
          "1687:             extraSessionData,",
          "1688:         ).then(() => {",
          "1689:             if (opts.source !== \"backup\") {",
          "1691:                 this.crypto.backupManager.backupGroupSession(",
          "1692:                     session.sender_key, session.session_id,",
          "1693:                 ).catch((e) => {",
          "1696:                     logger.log(\"Failed to back up megolm session\", e);",
          "1697:                 });",
          "1698:             }",
          "1700:             this.retryDecryption(session.sender_key, session.session_id);",
          "1701:         });",
          "1702:     }",
          "1714:     private async retryDecryption(senderKey: string, sessionId: string): Promise<boolean> {",
          "1715:         const senderPendingEvents = this.pendingEvents[senderKey];",
          "1716:         if (!senderPendingEvents) {",
          "1717:             return true;",
          "1718:         }",
          "1720:         const pending = senderPendingEvents.get(sessionId);",
          "1721:         if (!pending) {",
          "1722:             return true;",
          "1723:         }",
          "1725:         logger.debug(\"Retrying decryption on events\", [...pending]);",
          "1727:         await Promise.all([...pending].map(async (ev) => {",
          "1728:             try {",
          "1729:                 await ev.attemptDecryption(this.crypto, { isRetry: true });",
          "1730:             } catch (e) {",
          "1732:             }",
          "1733:         }));",
          "1736:         return !((this.pendingEvents[senderKey] || {})[sessionId]);",
          "1737:     }",
          "1739:     public async retryDecryptionFromSender(senderKey: string): Promise<boolean> {",
          "1740:         const senderPendingEvents = this.pendingEvents[senderKey];",
          "1741:         if (!senderPendingEvents) {",
          "1742:             return true;",
          "1743:         }",
          "1745:         delete this.pendingEvents[senderKey];",
          "1747:         await Promise.all([...senderPendingEvents].map(async ([_sessionId, pending]) => {",
          "1748:             await Promise.all([...pending].map(async (ev) => {",
          "1749:                 try {",
          "1750:                     await ev.attemptDecryption(this.crypto);",
          "1751:                 } catch (e) {",
          "1753:                 }",
          "1754:             }));",
          "1755:         }));",
          "1757:         return !this.pendingEvents[senderKey];",
          "1758:     }",
          "1760:     public async sendSharedHistoryInboundSessions(devicesByUser: Record<string, DeviceInfo[]>): Promise<void> {",
          "1761:         await olmlib.ensureOlmSessionsForDevices(this.olmDevice, this.baseApis, devicesByUser);",
          "1763:         logger.log(\"sendSharedHistoryInboundSessions to users\", Object.keys(devicesByUser));",
          "1765:         const sharedHistorySessions = await this.olmDevice.getSharedHistoryInboundGroupSessions(this.roomId);",
          "1766:         logger.log(\"shared-history sessions\", sharedHistorySessions);",
          "1767:         for (const [senderKey, sessionId] of sharedHistorySessions) {",
          "1768:             const payload = await this.buildKeyForwardingMessage(this.roomId, senderKey, sessionId);",
          "1770:             const promises = [];",
          "1771:             const contentMap = {};",
          "1772:             for (const [userId, devices] of Object.entries(devicesByUser)) {",
          "1773:                 contentMap[userId] = {};",
          "1774:                 for (const deviceInfo of devices) {",
          "1775:                     const encryptedContent = {",
          "1776:                         algorithm: olmlib.OLM_ALGORITHM,",
          "1777:                         sender_key: this.olmDevice.deviceCurve25519Key,",
          "1778:                         ciphertext: {},",
          "1779:                     };",
          "1780:                     contentMap[userId][deviceInfo.deviceId] = encryptedContent;",
          "1781:                     promises.push(",
          "1782:                         olmlib.encryptMessageForDevice(",
          "1783:                             encryptedContent.ciphertext,",
          "1784:                             this.userId,",
          "1785:                             this.deviceId,",
          "1786:                             this.olmDevice,",
          "1787:                             userId,",
          "1788:                             deviceInfo,",
          "1789:                             payload,",
          "1790:                         ),",
          "1791:                     );",
          "1792:                 }",
          "1793:             }",
          "1794:             await Promise.all(promises);",
          "1800:             for (const userId of Object.keys(contentMap)) {",
          "1801:                 for (const deviceId of Object.keys(contentMap[userId])) {",
          "1802:                     if (Object.keys(contentMap[userId][deviceId].ciphertext).length === 0) {",
          "1803:                         logger.log(",
          "1804:                             \"No ciphertext for device \" +",
          "1805:                             userId + \":\" + deviceId + \": pruning\",",
          "1806:                         );",
          "1807:                         delete contentMap[userId][deviceId];",
          "1808:                     }",
          "1809:                 }",
          "1811:                 if (Object.keys(contentMap[userId]).length === 0) {",
          "1812:                     logger.log(\"Pruned all devices for user \" + userId);",
          "1813:                     delete contentMap[userId];",
          "1814:                 }",
          "1815:             }",
          "1818:             if (Object.keys(contentMap).length === 0) {",
          "1819:                 logger.log(\"No users left to send to: aborting\");",
          "1820:                 return;",
          "1821:             }",
          "1823:             await this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap);",
          "1824:         }",
          "1825:     }",
          "1826: }",
          "1828: const PROBLEM_DESCRIPTIONS = {",
          "1829:     no_olm: \"The sender was unable to establish a secure channel.\",",
          "1830:     unknown: \"The secure channel with the sender was corrupted.\",",
          "1831: };",
          "1833: registerAlgorithm(olmlib.MEGOLM_ALGORITHM, MegolmEncryption, MegolmDecryption);",
          "",
          "---------------"
        ],
        "src/crypto/algorithms/olm.js||src/crypto/algorithms/olm.js": [
          "File: src/crypto/algorithms/olm.js -> src/crypto/algorithms/olm.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/crypto/algorithms/olm.ts||src/crypto/algorithms/olm.ts": [
          "File: src/crypto/algorithms/olm.ts -> src/crypto/algorithms/olm.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: Copyright 2016 - 2021 The Matrix.org Foundation C.I.C.",
          "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
          "5: you may not use this file except in compliance with the License.",
          "6: You may obtain a copy of the License at",
          "8:     http://www.apache.org/licenses/LICENSE-2.0",
          "10: Unless required by applicable law or agreed to in writing, software",
          "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
          "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "13: See the License for the specific language governing permissions and",
          "14: limitations under the License.",
          "23: import { logger } from '../../logger';",
          "24: import * as olmlib from \"../olmlib\";",
          "25: import { DeviceInfo } from \"../deviceinfo\";",
          "26: import {",
          "27:     DecryptionAlgorithm,",
          "28:     DecryptionError,",
          "29:     EncryptionAlgorithm,",
          "30:     registerAlgorithm,",
          "31: } from \"./base\";",
          "32: import { Room } from '../../models/room';",
          "33: import { MatrixEvent } from \"../..\";",
          "34: import { IEventDecryptionResult } from \"../index\";",
          "36: const DeviceVerification = DeviceInfo.DeviceVerification;",
          "38: interface IMessage {",
          "39:     type: number | string;",
          "40:     body: string;",
          "41: }",
          "52: class OlmEncryption extends EncryptionAlgorithm {",
          "53:     private sessionPrepared = false;",
          "54:     private prepPromise: Promise<void> = null;",
          "62:     private ensureSession(roomMembers: string[]): Promise<void> {",
          "63:         if (this.prepPromise) {",
          "65:             return this.prepPromise;",
          "66:         }",
          "68:         if (this.sessionPrepared) {",
          "70:             return Promise.resolve();",
          "71:         }",
          "73:         this.prepPromise = this.crypto.downloadKeys(roomMembers).then((res) => {",
          "74:             return this.crypto.ensureOlmSessionsForUsers(roomMembers);",
          "75:         }).then(() => {",
          "76:             this.sessionPrepared = true;",
          "77:         }).finally(() => {",
          "78:             this.prepPromise = null;",
          "79:         });",
          "81:         return this.prepPromise;",
          "82:     }",
          "93:     public async encryptMessage(room: Room, eventType: string, content: object): Promise<object> {",
          "99:         const members = await room.getEncryptionTargetMembers();",
          "101:         const users = members.map(function(u) {",
          "102:             return u.userId;",
          "103:         });",
          "105:         await this.ensureSession(users);",
          "107:         const payloadFields = {",
          "108:             room_id: room.roomId,",
          "109:             type: eventType,",
          "110:             content: content,",
          "111:         };",
          "113:         const encryptedContent = {",
          "114:             algorithm: olmlib.OLM_ALGORITHM,",
          "115:             sender_key: this.olmDevice.deviceCurve25519Key,",
          "116:             ciphertext: {},",
          "117:         };",
          "119:         const promises = [];",
          "121:         for (let i = 0; i < users.length; ++i) {",
          "122:             const userId = users[i];",
          "123:             const devices = this.crypto.getStoredDevicesForUser(userId);",
          "125:             for (let j = 0; j < devices.length; ++j) {",
          "126:                 const deviceInfo = devices[j];",
          "127:                 const key = deviceInfo.getIdentityKey();",
          "128:                 if (key == this.olmDevice.deviceCurve25519Key) {",
          "130:                     continue;",
          "131:                 }",
          "132:                 if (deviceInfo.verified == DeviceVerification.BLOCKED) {",
          "134:                     continue;",
          "135:                 }",
          "137:                 promises.push(",
          "138:                     olmlib.encryptMessageForDevice(",
          "139:                         encryptedContent.ciphertext,",
          "140:                         this.userId, this.deviceId, this.olmDevice,",
          "141:                         userId, deviceInfo, payloadFields,",
          "142:                     ),",
          "143:                 );",
          "144:             }",
          "145:         }",
          "147:         return await Promise.all(promises).then(() => encryptedContent);",
          "148:     }",
          "149: }",
          "159: class OlmDecryption extends DecryptionAlgorithm {",
          "170:     public async decryptEvent(event: MatrixEvent): Promise<IEventDecryptionResult> {",
          "171:         const content = event.getWireContent();",
          "172:         const deviceKey = content.sender_key;",
          "173:         const ciphertext = content.ciphertext;",
          "175:         if (!ciphertext) {",
          "176:             throw new DecryptionError(",
          "177:                 \"OLM_MISSING_CIPHERTEXT\",",
          "178:                 \"Missing ciphertext\",",
          "179:             );",
          "180:         }",
          "182:         if (!(this.olmDevice.deviceCurve25519Key in ciphertext)) {",
          "183:             throw new DecryptionError(",
          "184:                 \"OLM_NOT_INCLUDED_IN_RECIPIENTS\",",
          "185:                 \"Not included in recipients\",",
          "186:             );",
          "187:         }",
          "188:         const message = ciphertext[this.olmDevice.deviceCurve25519Key];",
          "189:         let payloadString;",
          "191:         try {",
          "192:             payloadString = await this.decryptMessage(deviceKey, message);",
          "193:         } catch (e) {",
          "194:             throw new DecryptionError(",
          "195:                 \"OLM_BAD_ENCRYPTED_MESSAGE\",",
          "196:                 \"Bad Encrypted Message\", {",
          "197:                     sender: deviceKey,",
          "198:                     err: e,",
          "199:                 },",
          "200:             );",
          "201:         }",
          "203:         const payload = JSON.parse(payloadString);",
          "207:         if (payload.recipient != this.userId) {",
          "208:             throw new DecryptionError(",
          "209:                 \"OLM_BAD_RECIPIENT\",",
          "210:                 \"Message was intented for \" + payload.recipient,",
          "211:             );",
          "212:         }",
          "214:         if (payload.recipient_keys.ed25519 != this.olmDevice.deviceEd25519Key) {",
          "215:             throw new DecryptionError(",
          "216:                 \"OLM_BAD_RECIPIENT_KEY\",",
          "217:                 \"Message not intended for this device\", {",
          "218:                     intended: payload.recipient_keys.ed25519,",
          "219:                     our_key: this.olmDevice.deviceEd25519Key,",
          "220:                 },",
          "221:             );",
          "222:         }",
          "228:         if (payload.sender != event.getSender()) {",
          "229:             throw new DecryptionError(",
          "230:                 \"OLM_FORWARDED_MESSAGE\",",
          "231:                 \"Message forwarded from \" + payload.sender, {",
          "232:                     reported_sender: event.getSender(),",
          "233:                 },",
          "234:             );",
          "235:         }",
          "238:         if (payload.room_id !== event.getRoomId()) {",
          "239:             throw new DecryptionError(",
          "240:                 \"OLM_BAD_ROOM\",",
          "241:                 \"Message intended for room \" + payload.room_id, {",
          "242:                     reported_room: event.getRoomId(),",
          "243:                 },",
          "244:             );",
          "245:         }",
          "247:         const claimedKeys = payload.keys || {};",
          "249:         return {",
          "250:             clearEvent: payload,",
          "251:             senderCurve25519Key: deviceKey,",
          "252:             claimedEd25519Key: claimedKeys.ed25519 || null,",
          "253:         };",
          "254:     }",
          "264:     private async decryptMessage(theirDeviceIdentityKey: string, message: IMessage): Promise<string> {",
          "268:         if (message.type !== 0) {",
          "270:             return this.reallyDecryptMessage(theirDeviceIdentityKey, message);",
          "271:         } else {",
          "272:             const myPromise = this.olmDevice._olmPrekeyPromise.then(() => {",
          "273:                 return this.reallyDecryptMessage(theirDeviceIdentityKey, message);",
          "274:             });",
          "276:             this.olmDevice._olmPrekeyPromise = myPromise.catch(() => {});",
          "277:             return await myPromise;",
          "278:         }",
          "279:     }",
          "281:     private async reallyDecryptMessage(theirDeviceIdentityKey: string, message: IMessage): Promise<string> {",
          "282:         const sessionIds = await this.olmDevice.getSessionIdsForDevice(theirDeviceIdentityKey);",
          "285:         const decryptionErrors = {};",
          "286:         for (let i = 0; i < sessionIds.length; i++) {",
          "287:             const sessionId = sessionIds[i];",
          "288:             try {",
          "289:                 const payload = await this.olmDevice.decryptMessage(",
          "290:                     theirDeviceIdentityKey, sessionId, message.type, message.body,",
          "291:                 );",
          "292:                 logger.log(",
          "293:                     \"Decrypted Olm message from \" + theirDeviceIdentityKey +",
          "294:                     \" with session \" + sessionId,",
          "295:                 );",
          "296:                 return payload;",
          "297:             } catch (e) {",
          "298:                 const foundSession = await this.olmDevice.matchesSession(",
          "299:                     theirDeviceIdentityKey, sessionId, message.type, message.body,",
          "300:                 );",
          "302:                 if (foundSession) {",
          "305:                     throw new Error(",
          "306:                         \"Error decrypting prekey message with existing session id \" +",
          "307:                         sessionId + \": \" + e.message,",
          "308:                     );",
          "309:                 }",
          "313:                 decryptionErrors[sessionId] = e.message;",
          "314:             }",
          "315:         }",
          "317:         if (message.type !== 0) {",
          "321:             if (sessionIds.length === 0) {",
          "322:                 throw new Error(\"No existing sessions\");",
          "323:             }",
          "325:             throw new Error(",
          "326:                 \"Error decrypting non-prekey message with existing sessions: \" +",
          "327:                 JSON.stringify(decryptionErrors),",
          "328:             );",
          "329:         }",
          "334:         let res;",
          "335:         try {",
          "336:             res = await this.olmDevice.createInboundSession(",
          "337:                 theirDeviceIdentityKey, message.type, message.body,",
          "338:             );",
          "339:         } catch (e) {",
          "340:             decryptionErrors[\"(new)\"] = e.message;",
          "341:             throw new Error(",
          "342:                 \"Error decrypting prekey message: \" +",
          "343:                 JSON.stringify(decryptionErrors),",
          "344:             );",
          "345:         }",
          "347:         logger.log(",
          "348:             \"created new inbound Olm session ID \" +",
          "349:             res.session_id + \" with \" + theirDeviceIdentityKey,",
          "350:         );",
          "351:         return res.payload;",
          "352:     }",
          "353: }",
          "355: registerAlgorithm(olmlib.OLM_ALGORITHM, OlmEncryption, OlmDecryption);",
          "",
          "---------------"
        ],
        "src/crypto/index.ts||src/crypto/index.ts": [
          "File: src/crypto/index.ts -> src/crypto/index.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: import { logger } from '../logger';",
          "29: import { OlmDevice } from \"./OlmDevice\";",
          "30: import * as olmlib from \"./olmlib\";",
          "32: import { DeviceInfo, IDevice } from \"./deviceinfo\";",
          "33: import * as algorithms from \"./algorithms\";",
          "34: import { createCryptoStoreCacheCallbacks, CrossSigningInfo, DeviceTrustLevel, UserTrustLevel } from './CrossSigning';",
          "",
          "[Removed Lines]",
          "31: import { DeviceList } from \"./DeviceList\";",
          "",
          "[Added Lines]",
          "31: import {DeviceInfoMap, DeviceList } from \"./DeviceList\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1930:         return this.deviceList.downloadKeys(userIds, forceDownload);",
          "1931:     }",
          "",
          "[Removed Lines]",
          "1926:     public downloadKeys(",
          "1927:         userIds: string[],",
          "1928:         forceDownload?: boolean,",
          "1929:     ): Promise<Record<string, Record<string, IDevice>>> {",
          "",
          "[Added Lines]",
          "1926:     public downloadKeys(userIds: string[], forceDownload?: boolean): Promise<DeviceInfoMap> {",
          "",
          "---------------"
        ],
        "src/models/event.ts||src/models/event.ts": [
          "File: src/models/event.ts -> src/models/event.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "131: }",
          "135:     type: string;",
          "136:     content: Omit<IContent, \"membership\" | \"avatar_url\" | \"displayname\" | \"m.relates_to\">;",
          "137:     unsigned?: IUnsigned;",
          "",
          "[Removed Lines]",
          "134: interface IClearEvent {",
          "",
          "[Added Lines]",
          "134: export interface IClearEvent {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "24406d24118ce6abe0985b6be73be76000a65f95",
      "candidate_info": {
        "commit_hash": "24406d24118ce6abe0985b6be73be76000a65f95",
        "repo": "matrix-org/matrix-js-sdk",
        "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/24406d24118ce6abe0985b6be73be76000a65f95",
        "files": [
          "src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts"
        ],
        "message": "make it build",
        "before_after_code_files": [
          "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts||src/crypto/index.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ],
          "candidate": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ]
        }
      },
      "candidate_diff": {
        "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
          "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "584:         userDeviceMap: IOlmDevice[],",
          "585:         payload: IPayload,",
          "586:     ): Promise<void> {",
          "588:             userDeviceMap,",
          "600:                 }",
          "601:             }",
          "603:     }",
          "",
          "[Removed Lines]",
          "587:         this.crypto.encryptAndSendToDevices(",
          "589:             payload",
          "590:         ).then(() => {",
          "592:             for (const userId of Object.keys(contentMap)) {",
          "593:                 for (const deviceId of Object.keys(contentMap[userId])) {",
          "594:                     session.markSharedWithDevice(",
          "595:                         userId,",
          "596:                         deviceId,",
          "597:                         deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
          "598:                         chainIndex,",
          "599:                     );",
          "602:         });",
          "",
          "[Added Lines]",
          "587:         return this.crypto.encryptAndSendToDevices(",
          "589:             payload,",
          "590:             (contentMap, deviceInfoByDeviceId) => {",
          "592:                 for (const userId of Object.keys(contentMap)) {",
          "593:                     for (const deviceId of Object.keys(contentMap[userId])) {",
          "594:                         session.markSharedWithDevice(",
          "595:                             userId,",
          "596:                             deviceId,",
          "597:                             deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
          "598:                             chainIndex,",
          "599:                         );",
          "600:                     }",
          "603:         );",
          "",
          "---------------"
        ],
        "src/crypto/index.ts||src/crypto/index.ts": [
          "File: src/crypto/index.ts -> src/crypto/index.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: import { ReEmitter } from '../ReEmitter';",
          "28: import { logger } from '../logger';",
          "29: import { IExportedDevice, OlmDevice } from \"./OlmDevice\";",
          "30: import * as olmlib from \"./olmlib\";",
          "31: import { DeviceInfoMap, DeviceList } from \"./DeviceList\";",
          "32: import { DeviceInfo, IDevice } from \"./deviceinfo\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: import { IOlmDevice } from \"./algorithms/megolm\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3049:         payload: object,",
          "3051:         const contentMap = {};",
          "3052:         const deviceInfoByDeviceId = new Map<string, DeviceInfo>();",
          "",
          "[Removed Lines]",
          "3047:     private encryptAndSendToDevices(",
          "3048:         userDeviceMap: IExportedDevice[],",
          "3050:     ): Promise<{}> {",
          "",
          "[Added Lines]",
          "3049:     encryptAndSendToDevices(",
          "3050:         userDeviceMap: IOlmDevice<DeviceInfo>[],",
          "3052:         afterwards: (contentMap: {}, deviceInfoByDeviceId: Map<string, DeviceInfo>) => void,",
          "3053:     ): Promise<void> {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3110:                 return;",
          "3111:             }",
          "3114:         });",
          "3115:     }",
          "",
          "[Removed Lines]",
          "3113:             return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap);",
          "",
          "[Added Lines]",
          "3116:             return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap).then(",
          "3117:                 afterwards.bind(contentMap, deviceInfoByDeviceId)",
          "3118:             );",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "86363cb7f41139490a7976e2bca3a83b521306aa",
      "candidate_info": {
        "commit_hash": "86363cb7f41139490a7976e2bca3a83b521306aa",
        "repo": "matrix-org/matrix-js-sdk",
        "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/86363cb7f41139490a7976e2bca3a83b521306aa",
        "files": [
          "src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts"
        ],
        "message": "lint",
        "before_after_code_files": [
          "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts",
          "src/crypto/index.ts||src/crypto/index.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ],
          "candidate": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ]
        }
      },
      "candidate_diff": {
        "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
          "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "580:     ): Promise<void> {",
          "581:         return this.crypto.encryptAndSendToDevices(",
          "582:             userDeviceMap,",
          "584:         ).then((result) => {",
          "587:             for (const userId of Object.keys(contentMap)) {",
          "588:                 for (const deviceId of Object.keys(contentMap[userId])) {",
          "",
          "[Removed Lines]",
          "583:             payload",
          "585:             const {contentMap, deviceInfoByDeviceId} = result;",
          "",
          "[Added Lines]",
          "583:             payload,",
          "585:             const { contentMap, deviceInfoByDeviceId } = result;",
          "",
          "---------------"
        ],
        "src/crypto/index.ts||src/crypto/index.ts": [
          "File: src/crypto/index.ts -> src/crypto/index.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "3050:         userDeviceMap: IOlmDevice<DeviceInfo>[],",
          "3051:         payload: object,",
          "3052:     ): Promise<{contentMap, deviceInfoByDeviceId}> {",
          "",
          "[Removed Lines]",
          "3049:     encryptAndSendToDevices(",
          "",
          "[Added Lines]",
          "3049:     public encryptAndSendToDevices(",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3121:             }",
          "3123:             return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap).then(",
          "3125:             );",
          "3126:         });",
          "3127:     }",
          "",
          "[Removed Lines]",
          "3124:                 (response)=>({ contentMap, deviceInfoByDeviceId })",
          "",
          "[Added Lines]",
          "3124:                 (response)=>({ contentMap, deviceInfoByDeviceId }),",
          "",
          "---------------"
        ]
      }
    }
  ]
}
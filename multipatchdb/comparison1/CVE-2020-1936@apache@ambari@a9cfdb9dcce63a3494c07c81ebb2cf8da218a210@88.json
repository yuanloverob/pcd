{
  "cve_id": "CVE-2020-1936",
  "cve_desc": "A cross-site scripting issue was found in Apache Ambari Views. This was addressed in Apache Ambari 2.7.4.",
  "repo": "apache/ambari",
  "patch_hash": "a9cfdb9dcce63a3494c07c81ebb2cf8da218a210",
  "patch_info": {
    "commit_hash": "a9cfdb9dcce63a3494c07c81ebb2cf8da218a210",
    "repo": "apache/ambari",
    "commit_url": "https://github.com/apache/ambari/pull/3040/commits/a9cfdb9dcce63a3494c07c81ebb2cf8da218a210",
    "files": [
      "ambari-web/app/views/common/breadcrumbs_view.js"
    ],
    "message": "AMBARI-25329. Ambari breadcrumbs xss vulnerability",
    "before_after_code_files": [
      "ambari-web/app/views/common/breadcrumbs_view.js||ambari-web/app/views/common/breadcrumbs_view.js"
    ]
  },
  "patch_diff": {
    "ambari-web/app/views/common/breadcrumbs_view.js||ambari-web/app/views/common/breadcrumbs_view.js": [
      "File: ambari-web/app/views/common/breadcrumbs_view.js -> ambari-web/app/views/common/breadcrumbs_view.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "149:   createLabel() {",
      "150:     let label = this.get('label');",
      "151:     let labelBindingPath = this.get('labelBindingPath');",
      "154:     this.set('formattedLabel', this.labelPostFormat(formattedLabel));",
      "155:   },",
      "",
      "[Removed Lines]",
      "153:     let formattedLabel = labelBindingPath ? App.get(_getLabelPathWithoutApp(labelBindingPath)) : label;",
      "",
      "[Added Lines]",
      "152:     let formattedLabel;",
      "154:     if (labelBindingPath) {",
      "155:       formattedLabel = Ember.Handlebars.Utils.escapeExpression(App.get(_getLabelPathWithoutApp(labelBindingPath)));",
      "156:     } else{",
      "157:       formattedLabel = label;",
      "158:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "216:       }",
      "217:       currentState = currentState.get('parentState');",
      "218:     }",
      "220:     if (items.length) {",
      "221:       items.get('lastObject').setProperties({",
      "222:         disabled: true,",
      "",
      "[Removed Lines]",
      "219:     items = items.reverse().map(item => App.BreadcrumbItem.extend(item).create());",
      "",
      "[Added Lines]",
      "227:     items.reverse();",
      "228:     items.slice(1).forEach(item => item.label = Ember.Handlebars.Utils.escapeExpression(item.label));",
      "229:     items = items.map(item => App.BreadcrumbItem.extend(item).create());",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1c25b1019b8eaa6b03882ae4ee7bdd99b9ae1d5d",
      "candidate_info": {
        "commit_hash": "1c25b1019b8eaa6b03882ae4ee7bdd99b9ae1d5d",
        "repo": "apache/ambari",
        "commit_url": "https://github.com/apache/ambari/commit/1c25b1019b8eaa6b03882ae4ee7bdd99b9ae1d5d",
        "files": [
          "ambari-server/src/main/java/org/apache/ambari/server/checks/DatabaseConsistencyCheckHelper.java",
          "ambari-server/src/main/java/org/apache/ambari/server/upgrade/UpgradeCatalog271.java",
          "ambari-server/src/test/java/org/apache/ambari/server/checks/DatabaseConsistencyCheckHelperTest.java",
          "ambari-server/src/test/java/org/apache/ambari/server/upgrade/UpgradeCatalog271Test.java"
        ],
        "message": "AMBARI-24283 - DB consistency warning due to config group without service name (#1915) (#1928)",
        "before_after_code_files": [
          "ambari-server/src/main/java/org/apache/ambari/server/checks/DatabaseConsistencyCheckHelper.java||ambari-server/src/main/java/org/apache/ambari/server/checks/DatabaseConsistencyCheckHelper.java",
          "ambari-server/src/main/java/org/apache/ambari/server/upgrade/UpgradeCatalog271.java||ambari-server/src/main/java/org/apache/ambari/server/upgrade/UpgradeCatalog271.java",
          "ambari-server/src/test/java/org/apache/ambari/server/checks/DatabaseConsistencyCheckHelperTest.java||ambari-server/src/test/java/org/apache/ambari/server/checks/DatabaseConsistencyCheckHelperTest.java",
          "ambari-server/src/test/java/org/apache/ambari/server/upgrade/UpgradeCatalog271Test.java||ambari-server/src/test/java/org/apache/ambari/server/upgrade/UpgradeCatalog271Test.java"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/apache/ambari/pull/3633",
          "https://github.com/apache/ambari/pull/3631",
          "https://github.com/apache/ambari/pull/3637",
          "https://github.com/apache/ambari/pull/3632",
          "https://github.com/apache/ambari/pull/3634",
          "https://github.com/apache/ambari/pull/3635"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ambari-server/src/main/java/org/apache/ambari/server/checks/DatabaseConsistencyCheckHelper.java||ambari-server/src/main/java/org/apache/ambari/server/checks/DatabaseConsistencyCheckHelper.java": [
          "File: ambari-server/src/main/java/org/apache/ambari/server/checks/DatabaseConsistencyCheckHelper.java -> ambari-server/src/main/java/org/apache/ambari/server/checks/DatabaseConsistencyCheckHelper.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: import java.util.Set;",
          "37: import java.util.regex.Matcher;",
          "38: import java.util.regex.Pattern;",
          "40: import javax.annotation.Nullable;",
          "41: import javax.inject.Provider;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39: import java.util.stream.Collectors;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59: import org.apache.ambari.server.orm.entities.HostComponentStateEntity;",
          "60: import org.apache.ambari.server.orm.entities.MetainfoEntity;",
          "61: import org.apache.ambari.server.orm.entities.ServiceComponentDesiredStateEntity;",
          "62: import org.apache.ambari.server.state.ClientConfigFileDefinition;",
          "63: import org.apache.ambari.server.state.Cluster;",
          "64: import org.apache.ambari.server.state.Clusters;",
          "65: import org.apache.ambari.server.state.ComponentInfo;",
          "66: import org.apache.ambari.server.state.ServiceInfo;",
          "67: import org.apache.ambari.server.state.State;",
          "68: import org.apache.ambari.server.state.UpgradeState;",
          "69: import org.apache.ambari.server.utils.VersionUtils;",
          "70: import org.apache.commons.lang.StringUtils;",
          "71: import org.slf4j.Logger;",
          "72: import org.slf4j.LoggerFactory;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63: import org.apache.ambari.server.security.authorization.AuthorizationException;",
          "68: import org.apache.ambari.server.state.Host;",
          "69: import org.apache.ambari.server.state.Service;",
          "73: import org.apache.ambari.server.state.configgroup.ConfigGroup;",
          "75: import org.apache.commons.collections.MapUtils;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "181:       if (fixIssues) {",
          "182:         fixHostComponentStatesCountEqualsHostComponentsDesiredStates();",
          "183:         fixClusterConfigsNotMappedToAnyService();",
          "184:         fixConfigsSelectedMoreThanOnce();",
          "185:       }",
          "186:       checkSchemaName();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "190:         fixConfigGroupServiceNames();",
          "191:         fixConfigGroupHostMappings();",
          "192:         fixConfigGroupsForDeletedServices();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "191:       checkHostComponentStates();",
          "192:       checkServiceConfigs();",
          "193:       checkForLargeTables();",
          "194:       LOG.info(\"******************************* Check database completed *******************************\");",
          "195:       return checkResult;",
          "196:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "203:       checkConfigGroupsHasServiceName();",
          "204:       checkConfigGroupHostMapping(true);",
          "205:       checkConfigGroupsForDeletedServices(true);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1148:   }",
          "1150:   private static void ensureConnection() {",
          "1151:     if (connection == null) {",
          "1152:       if (dbAccessor == null) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1165:   static Map<Long, ConfigGroup> collectConfigGroupsWithoutServiceName() {",
          "1166:     Map<Long, ConfigGroup> configGroupMap = new HashMap<>();",
          "1167:     Clusters clusters = injector.getInstance(Clusters.class);",
          "1168:     Map<String, Cluster> clusterMap = clusters.getClusters();",
          "1170:     if (MapUtils.isEmpty(clusterMap))",
          "1171:       return configGroupMap;",
          "1173:     for (Cluster cluster : clusterMap.values()) {",
          "1174:       Map<Long, ConfigGroup> configGroups = cluster.getConfigGroups();",
          "1176:       if (MapUtils.isEmpty(configGroups)) {",
          "1177:         continue;",
          "1178:       }",
          "1180:       for (ConfigGroup configGroup : configGroups.values()) {",
          "1181:         if (StringUtils.isEmpty(configGroup.getServiceName())) {",
          "1182:           configGroupMap.put(configGroup.getId(), configGroup);",
          "1183:         }",
          "1184:       }",
          "1185:     }",
          "1187:     return configGroupMap;",
          "1188:   }",
          "1193:   static void checkConfigGroupsHasServiceName() {",
          "1194:     Map<Long, ConfigGroup> configGroupMap = collectConfigGroupsWithoutServiceName();",
          "1195:     if (MapUtils.isEmpty(configGroupMap))",
          "1196:       return;",
          "1198:     String message = String.join(\" ), ( \",",
          "1199:             configGroupMap.values().stream().map(ConfigGroup::getName).collect(Collectors.toList()));",
          "1201:     warning(\"You have config groups present in the database with no \" +",
          "1202:             \"service name, [(ConfigGroup) => ( {} )]. Run --auto-fix-database to fix \" +",
          "1203:             \"this automatically. Please backup Ambari Server database before running --auto-fix-database.\", message);",
          "1204:   }",
          "1209:   @Transactional",
          "1210:   static void fixConfigGroupServiceNames() {",
          "1211:     Map<Long, ConfigGroup> configGroupMap = collectConfigGroupsWithoutServiceName();",
          "1212:     if (MapUtils.isEmpty(configGroupMap))",
          "1213:       return;",
          "1215:     Clusters clusters = injector.getInstance(Clusters.class);",
          "1217:     for (Map.Entry<Long, ConfigGroup> configGroupEntry : configGroupMap.entrySet()) {",
          "1218:       ConfigGroup configGroup = configGroupEntry.getValue();",
          "1219:       try {",
          "1220:         Cluster cluster = clusters.getCluster(configGroup.getClusterName());",
          "1221:         Map<String, Service> serviceMap = cluster.getServices();",
          "1222:         if (serviceMap.containsKey(configGroup.getTag())) {",
          "1223:           LOG.info(\"Setting service name of config group {} with id {} to {}\",",
          "1224:                   configGroup.getName(), configGroupEntry.getKey(), configGroup.getTag());",
          "1225:           configGroup.setServiceName(configGroup.getTag());",
          "1226:         }",
          "1227:         else {",
          "1228:           LOG.info(\"Config group {} with id {} contains a tag {} which is not a service name in the cluster {}\",",
          "1229:                   configGroup.getName(), configGroupEntry.getKey(), configGroup.getTag(), cluster.getClusterName());",
          "1230:         }",
          "1231:       } catch (AmbariException e) {",
          "1233:       }",
          "1234:     }",
          "1235:   }",
          "1241:   static Map<Long, Set<Long>> checkConfigGroupHostMapping(boolean warnIfFound) {",
          "1242:     LOG.info(\"Checking config group host mappings\");",
          "1243:     Map<Long, Set<Long>> nonMappedHostIds = new HashMap<>();",
          "1244:     Clusters clusters = injector.getInstance(Clusters.class);",
          "1245:     Map<String, Cluster> clusterMap = clusters.getClusters();",
          "1246:     StringBuilder output = new StringBuilder(\"[(ConfigGroup, Service, HostCount) => \");",
          "1248:     if (!MapUtils.isEmpty(clusterMap)) {",
          "1249:       for (Cluster cluster : clusterMap.values()) {",
          "1250:         Map<Long, ConfigGroup> configGroups = cluster.getConfigGroups();",
          "1251:         Map<String, Host> clusterHosts = clusters.getHostsForCluster(cluster.getClusterName());",
          "1253:         if (!MapUtils.isEmpty(configGroups) && !MapUtils.isEmpty(clusterHosts)) {",
          "1254:           for (ConfigGroup configGroup : configGroups.values()) {",
          "1258:             Map<Long, Host> hosts = configGroup.getHosts();",
          "1259:             boolean addToOutput = false;",
          "1260:             Set<String> hostnames = new HashSet<>();",
          "1261:             if (!MapUtils.isEmpty(hosts)) {",
          "1262:               for (Host host : hosts.values()) {",
          "1264:                 if (!clusterHosts.containsKey(host.getHostName())) {",
          "1265:                   Set<Long> hostIds = nonMappedHostIds.computeIfAbsent(configGroup.getId(), configGroupId -> new HashSet<>());",
          "1266:                   hostIds.add(host.getHostId());",
          "1267:                   hostnames.add(host.getHostName());",
          "1268:                   addToOutput = true;",
          "1269:                 }",
          "1270:               }",
          "1271:             }",
          "1272:             if (addToOutput) {",
          "1273:               output.append(\"( \");",
          "1274:               output.append(configGroup.getName());",
          "1275:               output.append(\", \");",
          "1276:               output.append(configGroup.getTag());",
          "1277:               output.append(\", \");",
          "1278:               output.append(hostnames);",
          "1279:               output.append(\" ), \");",
          "1280:             }",
          "1281:           }",
          "1282:         }",
          "1283:       }",
          "1284:     }",
          "1285:     if (!MapUtils.isEmpty(nonMappedHostIds) && warnIfFound) {",
          "1286:       output.replace(output.lastIndexOf(\",\"), output.length(), \"]\");",
          "1287:       warning(\"You have config group host mappings with hosts that are no \" +",
          "1288:         \"longer associated with the cluster, {}. Run --auto-fix-database to \" +",
          "1289:         \"fix this automatically. Alternatively, you can remove this mapping \" +",
          "1290:         \"from the UI. Please backup Ambari Server database before running --auto-fix-database.\", output.toString());",
          "1291:     }",
          "1293:     return nonMappedHostIds;",
          "1294:   }",
          "1296:   static Map<Long, ConfigGroup> checkConfigGroupsForDeletedServices(boolean warnIfFound) {",
          "1297:     Map<Long, ConfigGroup> configGroupMap = new HashMap<>();",
          "1298:     Clusters clusters = injector.getInstance(Clusters.class);",
          "1299:     Map<String, Cluster> clusterMap = clusters.getClusters();",
          "1300:     StringBuilder output = new StringBuilder(\"[(ConfigGroup, Service) => \");",
          "1302:     if (!MapUtils.isEmpty(clusterMap)) {",
          "1303:       for (Cluster cluster : clusterMap.values()) {",
          "1304:         Map<Long, ConfigGroup> configGroups = cluster.getConfigGroups();",
          "1305:         Map<String, Service> services = cluster.getServices();",
          "1307:         if (!MapUtils.isEmpty(configGroups)) {",
          "1308:           for (ConfigGroup configGroup : configGroups.values()) {",
          "1309:             if (!services.containsKey(configGroup.getServiceName())) {",
          "1310:               configGroupMap.put(configGroup.getId(), configGroup);",
          "1311:               output.append(\"( \");",
          "1312:               output.append(configGroup.getName());",
          "1313:               output.append(\", \");",
          "1314:               output.append(configGroup.getServiceName());",
          "1315:               output.append(\" ), \");",
          "1316:             }",
          "1317:           }",
          "1318:         }",
          "1319:       }",
          "1320:     }",
          "1322:     if (warnIfFound && !configGroupMap.isEmpty()) {",
          "1323:       output.replace(output.lastIndexOf(\",\"), output.length(), \"]\");",
          "1324:       warning(\"You have config groups present in the database with no \" +",
          "1325:         \"corresponding service found, {}. Run --auto-fix-database to fix \" +",
          "1326:           \"this automatically. Please backup Ambari Server database before running --auto-fix-database.\", output.toString());",
          "1327:     }",
          "1329:     return configGroupMap;",
          "1330:   }",
          "1332:   @Transactional",
          "1333:   static void fixConfigGroupsForDeletedServices() {",
          "1334:     Map<Long, ConfigGroup> configGroupMap = checkConfigGroupsForDeletedServices(false);",
          "1335:     Clusters clusters = injector.getInstance(Clusters.class);",
          "1337:     if (!MapUtils.isEmpty(configGroupMap)) {",
          "1338:       for (Map.Entry<Long, ConfigGroup> configGroupEntry : configGroupMap.entrySet()) {",
          "1339:         Long id = configGroupEntry.getKey();",
          "1340:         ConfigGroup configGroup = configGroupEntry.getValue();",
          "1341:         if (!StringUtils.isEmpty(configGroup.getServiceName())) {",
          "1342:           LOG.info(\"Deleting config group {} with id {} for deleted service {}\",",
          "1343:                   configGroup.getName(), id, configGroup.getServiceName());",
          "1344:           try {",
          "1345:             Cluster cluster = clusters.getCluster(configGroup.getClusterName());",
          "1346:             cluster.deleteConfigGroup(id);",
          "1347:           } catch (AuthorizationException e) {",
          "1349:           } catch (AmbariException e) {",
          "1351:           }",
          "1352:         }",
          "1353:         else {",
          "1354:           warning(\"The config group {} with id {} can not be fixed automatically because service name is missing.\",",
          "1355:                   configGroup.getName(), id);",
          "1356:         }",
          "1357:       }",
          "1358:     }",
          "1359:   }",
          "1364:   @Transactional",
          "1365:   static void fixConfigGroupHostMappings() {",
          "1366:     Map<Long, Set<Long>> nonMappedHostIds = checkConfigGroupHostMapping(false);",
          "1367:     Clusters clusters = injector.getInstance(Clusters.class);",
          "1369:     if (!MapUtils.isEmpty(nonMappedHostIds)) {",
          "1370:       LOG.info(\"Fixing {} config groups with inconsistent host mappings\", nonMappedHostIds.size());",
          "1372:       for (Map.Entry<Long, Set<Long>> nonMappedHostEntry : nonMappedHostIds.entrySet()) {",
          "1373:         if (!MapUtils.isEmpty(clusters.getClusters())) {",
          "1374:           for (Cluster cluster : clusters.getClusters().values()) {",
          "1375:             Map<Long, ConfigGroup> configGroups = cluster.getConfigGroups();",
          "1376:             if (!MapUtils.isEmpty(configGroups)) {",
          "1377:               ConfigGroup configGroup = configGroups.get(nonMappedHostEntry.getKey());",
          "1378:               if (configGroup != null) {",
          "1379:                 for (Long hostId : nonMappedHostEntry.getValue()) {",
          "1380:                   try {",
          "1381:                     configGroup.removeHost(hostId);",
          "1382:                   } catch (AmbariException e) {",
          "1383:                     LOG.warn(\"Unable to fix inconsistency by removing host \" +",
          "1384:                       \"mapping for config group: {}, service: {}, hostId = {}\",",
          "1385:                       configGroup.getName(), configGroup.getTag(), hostId);",
          "1386:                   }",
          "1387:                 }",
          "1388:               } else {",
          "1389:                 LOG.warn(\"Unable to find config group with id = {}\", nonMappedHostEntry.getKey());",
          "1390:               }",
          "1391:             }",
          "1392:           }",
          "1393:         }",
          "1394:       }",
          "1395:     }",
          "1396:   }",
          "",
          "---------------"
        ],
        "ambari-server/src/main/java/org/apache/ambari/server/upgrade/UpgradeCatalog271.java||ambari-server/src/main/java/org/apache/ambari/server/upgrade/UpgradeCatalog271.java": [
          "File: ambari-server/src/main/java/org/apache/ambari/server/upgrade/UpgradeCatalog271.java -> ambari-server/src/main/java/org/apache/ambari/server/upgrade/UpgradeCatalog271.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: package org.apache.ambari.server.upgrade;",
          "20: import java.sql.SQLException;",
          "21: import java.util.HashMap;",
          "22: import java.util.Map;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: import static org.apache.ambari.server.upgrade.UpgradeCatalog270.AMBARI_INFRA_NEW_NAME;",
          "21: import static org.apache.ambari.server.upgrade.UpgradeCatalog270.AMBARI_INFRA_OLD_NAME;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "24: import java.util.regex.Matcher;",
          "25: import java.util.regex.Pattern;",
          "27: import org.apache.ambari.server.AmbariException;",
          "28: import org.apache.ambari.server.controller.AmbariManagementController;",
          "29: import org.apache.ambari.server.orm.dao.DaoUtils;",
          "30: import org.apache.ambari.server.state.Cluster;",
          "31: import org.apache.ambari.server.state.Clusters;",
          "32: import org.apache.ambari.server.state.Config;",
          "34: import org.slf4j.Logger;",
          "35: import org.slf4j.LoggerFactory;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: import javax.persistence.EntityManager;",
          "31: import javax.persistence.TypedQuery;",
          "36: import org.apache.ambari.server.orm.entities.ServiceConfigEntity;",
          "40: import org.apache.commons.collections.MapUtils;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "97:     addNewConfigurationsFromXml();",
          "98:     updateRangerLogDirConfigs();",
          "99:     updateRangerKmsDbUrl();",
          "100:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "107:     renameAmbariInfraInConfigGroups();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "195:     }",
          "196:   }",
          "198: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "206:   protected void renameAmbariInfraInConfigGroups() {",
          "207:     LOG.info(\"Renaming service AMBARI_INFRA to AMBARI_INFRA_SOLR in config group records\");",
          "208:     AmbariManagementController ambariManagementController = injector.getInstance(AmbariManagementController.class);",
          "209:     Clusters clusters = ambariManagementController.getClusters();",
          "210:     if (clusters == null)",
          "211:       return;",
          "213:     Map<String, Cluster> clusterMap = clusters.getClusters();",
          "214:     if (MapUtils.isEmpty(clusterMap))",
          "215:       return;",
          "217:     EntityManager entityManager = getEntityManagerProvider().get();",
          "219:     executeInTransaction(() -> {",
          "220:       TypedQuery<ServiceConfigEntity> serviceConfigUpdate = entityManager.createQuery(",
          "221:               \"UPDATE ConfigGroupEntity SET serviceName = :newServiceName WHERE serviceName = :oldServiceName\", ServiceConfigEntity.class);",
          "222:       serviceConfigUpdate.setParameter(\"newServiceName\", AMBARI_INFRA_NEW_NAME);",
          "223:       serviceConfigUpdate.setParameter(\"oldServiceName\", AMBARI_INFRA_OLD_NAME);",
          "224:       serviceConfigUpdate.executeUpdate();",
          "225:     });",
          "227:     executeInTransaction(() -> {",
          "228:       TypedQuery<ServiceConfigEntity> serviceConfigUpdate = entityManager.createQuery(",
          "229:               \"UPDATE ConfigGroupEntity SET tag = :newServiceName WHERE tag = :oldServiceName\", ServiceConfigEntity.class);",
          "230:       serviceConfigUpdate.setParameter(\"newServiceName\", AMBARI_INFRA_NEW_NAME);",
          "231:       serviceConfigUpdate.setParameter(\"oldServiceName\", AMBARI_INFRA_OLD_NAME);",
          "232:       serviceConfigUpdate.executeUpdate();",
          "233:     });",
          "237:     entityManager.getEntityManagerFactory().getCache().evictAll();",
          "238:     clusters.invalidateAllClusters();",
          "239:   }",
          "",
          "---------------"
        ],
        "ambari-server/src/test/java/org/apache/ambari/server/checks/DatabaseConsistencyCheckHelperTest.java||ambari-server/src/test/java/org/apache/ambari/server/checks/DatabaseConsistencyCheckHelperTest.java": [
          "File: ambari-server/src/test/java/org/apache/ambari/server/checks/DatabaseConsistencyCheckHelperTest.java -> ambari-server/src/test/java/org/apache/ambari/server/checks/DatabaseConsistencyCheckHelperTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: import java.util.HashMap;",
          "41: import java.util.List;",
          "42: import java.util.Map;",
          "44: import javax.persistence.EntityManager;",
          "45: import javax.persistence.TypedQuery;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43: import java.util.Set;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52: import org.apache.ambari.server.stack.StackManagerFactory;",
          "53: import org.apache.ambari.server.state.Cluster;",
          "54: import org.apache.ambari.server.state.Clusters;",
          "55: import org.apache.ambari.server.state.ServiceInfo;",
          "56: import org.apache.ambari.server.state.stack.OsFamily;",
          "57: import org.apache.ambari.server.testutils.PartialNiceMockBinder;",
          "58: import org.easymock.EasyMockSupport;",
          "59: import org.junit.Assert;",
          "60: import org.junit.Test;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56: import org.apache.ambari.server.state.Host;",
          "57: import org.apache.ambari.server.state.Service;",
          "59: import org.apache.ambari.server.state.configgroup.ConfigGroup;",
          "62: import org.apache.commons.collections.MapUtils;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "522:     easyMockSupport.verifyAll();",
          "523:   }",
          "525:   @Test",
          "526:   public void testFixConfigsSelectedMoreThanOnce() throws Exception {",
          "527:     EasyMockSupport easyMockSupport = new EasyMockSupport();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "530:   @Test",
          "531:   public void testConfigGroupHostMappings() throws Exception {",
          "532:     EasyMockSupport easyMockSupport = new EasyMockSupport();",
          "534:     final DBAccessor mockDBDbAccessor = easyMockSupport.createNiceMock(DBAccessor.class);",
          "536:     final StackManagerFactory mockStackManagerFactory = easyMockSupport.createNiceMock(StackManagerFactory.class);",
          "537:     final EntityManager mockEntityManager = easyMockSupport.createNiceMock(EntityManager.class);",
          "538:     final Clusters mockClusters = easyMockSupport.createNiceMock(Clusters.class);",
          "539:     final OsFamily mockOSFamily = easyMockSupport.createNiceMock(OsFamily.class);",
          "540:     final Injector mockInjector = Guice.createInjector(new AbstractModule() {",
          "541:       @Override",
          "542:       protected void configure() {",
          "543:         bind(StackManagerFactory.class).toInstance(mockStackManagerFactory);",
          "544:         bind(EntityManager.class).toInstance(mockEntityManager);",
          "545:         bind(DBAccessor.class).toInstance(mockDBDbAccessor);",
          "546:         bind(Clusters.class).toInstance(mockClusters);",
          "547:         bind(OsFamily.class).toInstance(mockOSFamily);",
          "548:       }",
          "549:     });",
          "551:     Map<String, Cluster> clusters = new HashMap<>();",
          "552:     Cluster cluster = easyMockSupport.createNiceMock(Cluster.class);",
          "553:     clusters.put(\"c1\", cluster);",
          "554:     expect(mockClusters.getClusters()).andReturn(clusters).anyTimes();",
          "556:     Map<Long, ConfigGroup> configGroupMap = new HashMap<>();",
          "557:     ConfigGroup cg1 = easyMockSupport.createNiceMock(ConfigGroup.class);",
          "558:     ConfigGroup cg2 = easyMockSupport.createNiceMock(ConfigGroup.class);",
          "559:     configGroupMap.put(1L, cg1);",
          "560:     configGroupMap.put(2L, cg2);",
          "562:     expect(cluster.getConfigGroups()).andReturn(configGroupMap).anyTimes();",
          "564:     expect(cluster.getClusterName()).andReturn(\"c1\").anyTimes();",
          "566:     Map<String, Host> hosts = new HashMap<>();",
          "567:     Host h1 = easyMockSupport.createNiceMock(Host.class);",
          "568:     Host h2 = easyMockSupport.createNiceMock(Host.class);",
          "569:     hosts.put(\"h1\", h1);",
          "570:     expect(mockClusters.getHostsForCluster(\"c1\")).andReturn(hosts);",
          "572:     Map<Long, Host> cgHosts = new HashMap<>();",
          "573:     cgHosts.put(1L, h1);",
          "574:     cgHosts.put(2L, h2);",
          "576:     expect(cg1.getHosts()).andReturn(cgHosts);",
          "578:     expect(h1.getHostName()).andReturn(\"h1\").anyTimes();",
          "579:     expect(h2.getHostName()).andReturn(\"h2\").anyTimes() ;",
          "580:     expect(h1.getHostId()).andReturn(1L).anyTimes();",
          "581:     expect(h2.getHostId()).andReturn(2L).anyTimes();",
          "583:     expect(cg1.getId()).andReturn(1L).anyTimes();",
          "584:     expect(cg2.getId()).andReturn(2L).anyTimes();",
          "585:     expect(cg1.getName()).andReturn(\"cg1\").anyTimes();",
          "586:     expect(cg2.getName()).andReturn(\"cg2\").anyTimes();",
          "588:     DatabaseConsistencyCheckHelper.setInjector(mockInjector);",
          "590:     easyMockSupport.replayAll();",
          "592:     Map<Long, Set<Long>> hostIds = DatabaseConsistencyCheckHelper.checkConfigGroupHostMapping(true);",
          "594:     easyMockSupport.verifyAll();",
          "596:     Assert.assertNotNull(hostIds);",
          "597:     Assert.assertEquals(1, hostIds.size());",
          "598:     Assert.assertEquals(1L, hostIds.keySet().iterator().next().longValue());",
          "599:     Assert.assertEquals(2L, hostIds.get(1L).iterator().next().longValue());",
          "600:   }",
          "602:   @Test",
          "603:   public void testConfigGroupForDeletedServices() throws Exception {",
          "604:     EasyMockSupport easyMockSupport = new EasyMockSupport();",
          "606:     final DBAccessor mockDBDbAccessor = easyMockSupport.createNiceMock(DBAccessor.class);",
          "608:     final StackManagerFactory mockStackManagerFactory = easyMockSupport.createNiceMock(StackManagerFactory.class);",
          "609:     final EntityManager mockEntityManager = easyMockSupport.createNiceMock(EntityManager.class);",
          "610:     final Clusters mockClusters = easyMockSupport.createNiceMock(Clusters.class);",
          "611:     final OsFamily mockOSFamily = easyMockSupport.createNiceMock(OsFamily.class);",
          "612:     final Injector mockInjector = Guice.createInjector(new AbstractModule() {",
          "613:       @Override",
          "614:       protected void configure() {",
          "615:         bind(StackManagerFactory.class).toInstance(mockStackManagerFactory);",
          "616:         bind(EntityManager.class).toInstance(mockEntityManager);",
          "617:         bind(DBAccessor.class).toInstance(mockDBDbAccessor);",
          "618:         bind(Clusters.class).toInstance(mockClusters);",
          "619:         bind(OsFamily.class).toInstance(mockOSFamily);",
          "620:       }",
          "621:     });",
          "623:     Map<String, Cluster> clusters = new HashMap<>();",
          "624:     Cluster cluster = easyMockSupport.createStrictMock(Cluster.class);",
          "625:     clusters.put(\"c1\", cluster);",
          "626:     expect(mockClusters.getClusters()).andReturn(clusters).anyTimes();",
          "628:     Map<Long, ConfigGroup> configGroupMap = new HashMap<>();",
          "629:     ConfigGroup cg1 = easyMockSupport.createNiceMock(ConfigGroup.class);",
          "630:     ConfigGroup cg2 = easyMockSupport.createNiceMock(ConfigGroup.class);",
          "631:     ConfigGroup cgWithoutServiceName = easyMockSupport.createNiceMock(ConfigGroup.class);",
          "632:     configGroupMap.put(1L, cg1);",
          "633:     configGroupMap.put(2L, cg2);",
          "634:     configGroupMap.put(3L, cgWithoutServiceName);",
          "636:     expect(cluster.getConfigGroups()).andStubReturn(configGroupMap);",
          "637:     expect(cg1.getName()).andReturn(\"cg1\").anyTimes();",
          "638:     expect(cg1.getId()).andReturn(1L).anyTimes();",
          "639:     expect(cg1.getServiceName()).andReturn(\"YARN\").anyTimes();",
          "640:     expect(cg2.getServiceName()).andReturn(\"HDFS\").anyTimes();",
          "641:     expect(cgWithoutServiceName.getName()).andReturn(\"cg3\").anyTimes();",
          "642:     expect(cgWithoutServiceName.getId()).andReturn(3L).anyTimes();",
          "643:     expect(cgWithoutServiceName.getServiceName()).andReturn(null).anyTimes();",
          "645:     Service service = easyMockSupport.createNiceMock(Service.class);",
          "646:     Map<String, Service> services = new HashMap<>();",
          "647:     services.put(\"HDFS\", service);",
          "648:     expect(cluster.getServices()).andReturn(services).anyTimes();",
          "650:     expect(cg1.getClusterName()).andReturn(\"c1\");",
          "651:     expect(mockClusters.getCluster(\"c1\")).andReturn(cluster).anyTimes();",
          "652:     cluster.deleteConfigGroup(1L);",
          "653:     expectLastCall();",
          "655:     DatabaseConsistencyCheckHelper.setInjector(mockInjector);",
          "657:     easyMockSupport.replayAll();",
          "659:     Map<Long, ConfigGroup> configGroups = DatabaseConsistencyCheckHelper.checkConfigGroupsForDeletedServices(true);",
          "660:     DatabaseConsistencyCheckHelper.fixConfigGroupsForDeletedServices();",
          "662:     easyMockSupport.verifyAll();",
          "664:     Assert.assertFalse(MapUtils.isEmpty(configGroups));",
          "665:     Assert.assertEquals(2, configGroups.size());",
          "666:     Assert.assertTrue(configGroups.containsKey(1L));",
          "667:     Assert.assertFalse(configGroups.containsKey(2L));",
          "668:     Assert.assertTrue(configGroups.containsKey(3L));",
          "669:   }",
          "671:   @Test",
          "672:   public void testCollectConfigGroupsWithoutServiceName() throws Exception {",
          "673:     EasyMockSupport easyMockSupport = new EasyMockSupport();",
          "675:     final DBAccessor mockDBDbAccessor = easyMockSupport.createNiceMock(DBAccessor.class);",
          "677:     final StackManagerFactory mockStackManagerFactory = easyMockSupport.createNiceMock(StackManagerFactory.class);",
          "678:     final EntityManager mockEntityManager = easyMockSupport.createNiceMock(EntityManager.class);",
          "679:     final Clusters mockClusters = easyMockSupport.createNiceMock(Clusters.class);",
          "680:     final OsFamily mockOSFamily = easyMockSupport.createNiceMock(OsFamily.class);",
          "681:     final Injector mockInjector = Guice.createInjector(new AbstractModule() {",
          "682:       @Override",
          "683:       protected void configure() {",
          "684:         bind(StackManagerFactory.class).toInstance(mockStackManagerFactory);",
          "685:         bind(EntityManager.class).toInstance(mockEntityManager);",
          "686:         bind(DBAccessor.class).toInstance(mockDBDbAccessor);",
          "687:         bind(Clusters.class).toInstance(mockClusters);",
          "688:         bind(OsFamily.class).toInstance(mockOSFamily);",
          "689:       }",
          "690:     });",
          "692:     Map<String, Cluster> clusters = new HashMap<>();",
          "693:     Cluster cluster1 = easyMockSupport.createNiceMock(Cluster.class);",
          "694:     clusters.put(\"c1\", cluster1);",
          "695:     Cluster cluster2 = easyMockSupport.createNiceMock(Cluster.class);",
          "696:     clusters.put(\"c2\", cluster2);",
          "697:     expect(cluster2.getConfigGroups()).andReturn(new HashMap<Long, ConfigGroup>(0)).anyTimes();",
          "698:     expect(mockClusters.getClusters()).andReturn(clusters).anyTimes();",
          "699:     expect(mockClusters.getCluster(\"c1\")).andReturn(cluster1).anyTimes();",
          "700:     expect(mockClusters.getCluster(\"c2\")).andReturn(cluster2).anyTimes();",
          "702:     Map<Long, ConfigGroup> configGroupMap = new HashMap<>();",
          "703:     ConfigGroup cgWithoutServiceName = easyMockSupport.createNiceMock(ConfigGroup.class);",
          "704:     ConfigGroup cgWithServiceName = easyMockSupport.createNiceMock(ConfigGroup.class);",
          "705:     ConfigGroup cgForNonExistentService = easyMockSupport.createNiceMock(ConfigGroup.class);",
          "706:     configGroupMap.put(1L, cgWithoutServiceName);",
          "707:     configGroupMap.put(2L, cgWithServiceName);",
          "708:     configGroupMap.put(3L, cgForNonExistentService);",
          "710:     expect(cluster1.getConfigGroups()).andReturn(configGroupMap).anyTimes();",
          "711:     expect(cgWithoutServiceName.getId()).andReturn(1L).anyTimes();",
          "712:     expect(cgWithoutServiceName.getClusterName()).andReturn(\"c1\").anyTimes();",
          "713:     expect(cgWithoutServiceName.getServiceName()).andReturn(null).anyTimes();",
          "714:     expect(cgWithoutServiceName.getTag()).andReturn(\"YARN\").anyTimes();",
          "715:     cgWithoutServiceName.setServiceName(\"YARN\"); expectLastCall();",
          "716:     expect(cgWithServiceName.getId()).andReturn(2L).anyTimes();",
          "717:     expect(cgWithServiceName.getClusterName()).andReturn(\"c1\").anyTimes();",
          "718:     expect(cgWithServiceName.getServiceName()).andReturn(\"HDFS\").anyTimes();",
          "719:     expect(cgForNonExistentService.getId()).andReturn(3L).anyTimes();",
          "720:     expect(cgForNonExistentService.getClusterName()).andReturn(\"c1\").anyTimes();",
          "721:     expect(cgForNonExistentService.getServiceName()).andReturn(null).anyTimes();",
          "722:     expect(cgForNonExistentService.getTag()).andReturn(\"NOT_EXISTS\").anyTimes();",
          "724:     Service hdfsService = easyMockSupport.createNiceMock(Service.class);",
          "725:     Service yarnService = easyMockSupport.createNiceMock(Service.class);",
          "726:     Map<String, Service> services = new HashMap<>();",
          "727:     services.put(\"HDFS\", hdfsService);",
          "728:     services.put(\"YARN\", yarnService);",
          "729:     expect(cluster1.getServices()).andReturn(services).anyTimes();",
          "731:     DatabaseConsistencyCheckHelper.setInjector(mockInjector);",
          "733:     easyMockSupport.replayAll();",
          "735:     Map<Long, ConfigGroup> configGroups = DatabaseConsistencyCheckHelper.collectConfigGroupsWithoutServiceName();",
          "736:     DatabaseConsistencyCheckHelper.fixConfigGroupServiceNames();",
          "738:     easyMockSupport.verifyAll();",
          "740:     Assert.assertFalse(MapUtils.isEmpty(configGroups));",
          "741:     Assert.assertEquals(2, configGroups.size());",
          "742:     Assert.assertTrue(configGroups.containsKey(1L));",
          "743:     Assert.assertFalse(configGroups.containsKey(2L));",
          "744:     Assert.assertTrue(configGroups.containsKey(3L));",
          "745:   }",
          "747:   @Test",
          "748:   public void testCollectConfigGroupsWithoutServiceNameReturnsEmptyMapWhenNoClusters() throws Exception {",
          "749:     EasyMockSupport easyMockSupport = new EasyMockSupport();",
          "751:     final DBAccessor mockDBDbAccessor = easyMockSupport.createNiceMock(DBAccessor.class);",
          "753:     final StackManagerFactory mockStackManagerFactory = easyMockSupport.createNiceMock(StackManagerFactory.class);",
          "754:     final EntityManager mockEntityManager = easyMockSupport.createNiceMock(EntityManager.class);",
          "755:     final Clusters mockClusters = easyMockSupport.createNiceMock(Clusters.class);",
          "756:     final OsFamily mockOSFamily = easyMockSupport.createNiceMock(OsFamily.class);",
          "757:     final Injector mockInjector = Guice.createInjector(new AbstractModule() {",
          "758:       @Override",
          "759:       protected void configure() {",
          "760:         bind(StackManagerFactory.class).toInstance(mockStackManagerFactory);",
          "761:         bind(EntityManager.class).toInstance(mockEntityManager);",
          "762:         bind(DBAccessor.class).toInstance(mockDBDbAccessor);",
          "763:         bind(Clusters.class).toInstance(mockClusters);",
          "764:         bind(OsFamily.class).toInstance(mockOSFamily);",
          "765:       }",
          "766:     });",
          "768:     Map<String, Cluster> clusters = new HashMap<>();",
          "769:     expect(mockClusters.getClusters()).andReturn(clusters).anyTimes();",
          "771:     DatabaseConsistencyCheckHelper.setInjector(mockInjector);",
          "773:     easyMockSupport.replayAll();",
          "775:     Map<Long, ConfigGroup> configGroups = DatabaseConsistencyCheckHelper.collectConfigGroupsWithoutServiceName();",
          "777:     easyMockSupport.verifyAll();",
          "779:     Assert.assertTrue(MapUtils.isEmpty(configGroups));",
          "780:   }",
          "",
          "---------------"
        ],
        "ambari-server/src/test/java/org/apache/ambari/server/upgrade/UpgradeCatalog271Test.java||ambari-server/src/test/java/org/apache/ambari/server/upgrade/UpgradeCatalog271Test.java": [
          "File: ambari-server/src/test/java/org/apache/ambari/server/upgrade/UpgradeCatalog271Test.java -> ambari-server/src/test/java/org/apache/ambari/server/upgrade/UpgradeCatalog271Test.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:     Method addNewConfigurationsFromXml = AbstractUpgradeCatalog.class.getDeclaredMethod(\"addNewConfigurationsFromXml\");",
          "56:     Method updateRangerLogDirConfigs = UpgradeCatalog271.class.getDeclaredMethod(\"updateRangerLogDirConfigs\");",
          "57:     Method updateRangerKmsDbUrl = UpgradeCatalog271.class.getDeclaredMethod(\"updateRangerKmsDbUrl\");",
          "59:     UpgradeCatalog271 upgradeCatalog271 = createMockBuilder(UpgradeCatalog271.class)",
          "60:       .addMockedMethod(updateRangerKmsDbUrl)",
          "61:       .addMockedMethod(updateRangerLogDirConfigs)",
          "62:       .addMockedMethod(addNewConfigurationsFromXml)",
          "63:       .createMock();",
          "65:     upgradeCatalog271.addNewConfigurationsFromXml();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "58:     Method renameAmbariInfraInConfigGroups = UpgradeCatalog271.class.getDeclaredMethod(\"renameAmbariInfraInConfigGroups\");",
          "64:       .addMockedMethod(renameAmbariInfraInConfigGroups)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "71:     upgradeCatalog271.updateRangerKmsDbUrl();",
          "72:     expectLastCall().once();",
          "74:     replay(upgradeCatalog271);",
          "75:     upgradeCatalog271.executeDMLUpdates();",
          "76:     verify(upgradeCatalog271);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "76:     upgradeCatalog271.renameAmbariInfraInConfigGroups();",
          "77:     expectLastCall().once();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4da9f42584e7185be7c776574ce0e15ce4cc25d5",
      "candidate_info": {
        "commit_hash": "4da9f42584e7185be7c776574ce0e15ce4cc25d5",
        "repo": "apache/ambari",
        "commit_url": "https://github.com/apache/ambari/commit/4da9f42584e7185be7c776574ce0e15ce4cc25d5",
        "files": [
          "ambari-agent/src/main/python/ambari_agent/AmbariConfig.py",
          "ambari-common/src/main/python/resource_management/libraries/script/script.py"
        ],
        "message": "AMBARI-24757. Grafana start failing on U14 fails with error \"AttributeError: 'module' object has no attribute 'PROTOCOL_TLSv1_2'\" (aonishuk)",
        "before_after_code_files": [
          "ambari-agent/src/main/python/ambari_agent/AmbariConfig.py||ambari-agent/src/main/python/ambari_agent/AmbariConfig.py",
          "ambari-common/src/main/python/resource_management/libraries/script/script.py||ambari-common/src/main/python/resource_management/libraries/script/script.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/apache/ambari/pull/3633",
          "https://github.com/apache/ambari/pull/3631",
          "https://github.com/apache/ambari/pull/3637",
          "https://github.com/apache/ambari/pull/3632",
          "https://github.com/apache/ambari/pull/3634",
          "https://github.com/apache/ambari/pull/3635"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ambari-agent/src/main/python/ambari_agent/AmbariConfig.py||ambari-agent/src/main/python/ambari_agent/AmbariConfig.py": [
          "File: ambari-agent/src/main/python/ambari_agent/AmbariConfig.py -> ambari-agent/src/main/python/ambari_agent/AmbariConfig.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: import hostname",
          "25: import ambari_simplejson as json",
          "26: import os",
          "28: from ambari_agent.FileCache import FileCache",
          "29: from ambari_commons.os_family_impl import OsFamilyFuncImpl, OsFamilyImpl",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: import ssl",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "377:     :return: protocol name, PROTOCOL_TLSv1_2 by default",
          "378:     \"\"\"",
          "381:   def get_force_https_protocol_value(self):",
          "382:     \"\"\"",
          "",
          "[Removed Lines]",
          "379:     return self.get('security', 'force_https_protocol', default=\"PROTOCOL_TLSv1_2\")",
          "",
          "[Added Lines]",
          "380:     default = \"PROTOCOL_TLSv1_2\" if hasattr(ssl, \"PROTOCOL_TLSv1_2\") else \"PROTOCOL_TLSv1\"",
          "381:     return self.get('security', 'force_https_protocol', default=default)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "385:     :return: protocol value",
          "386:     \"\"\"",
          "388:     return getattr(ssl, self.get_force_https_protocol_name())",
          "390:   def get_ca_cert_file_path(self):",
          "",
          "[Removed Lines]",
          "387:     import ssl",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "ambari-common/src/main/python/resource_management/libraries/script/script.py||ambari-common/src/main/python/resource_management/libraries/script/script.py": [
          "File: ambari-common/src/main/python/resource_management/libraries/script/script.py -> ambari-common/src/main/python/resource_management/libraries/script/script.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: import re",
          "25: import os",
          "26: import sys",
          "27: import logging",
          "28: import platform",
          "29: import inspect",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: import ssl",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "130:   # Class variable",
          "131:   tmp_dir = \"\"",
          "133:   ca_cert_file_path = None",
          "135:   def load_structured_out(self):",
          "",
          "[Removed Lines]",
          "132:   force_https_protocol = \"PROTOCOL_TLSv1_2\"",
          "",
          "[Added Lines]",
          "133:   force_https_protocol = \"PROTOCOL_TLSv1_2\" if hasattr(ssl, \"PROTOCOL_TLSv1_2\") else \"PROTOCOL_TLSv1\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "623:     :return: protocol value",
          "624:     \"\"\"",
          "626:     return getattr(ssl, Script.get_force_https_protocol_name())",
          "628:   @staticmethod",
          "",
          "[Removed Lines]",
          "625:     import ssl",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "44384bf1e682c4c0bbfcb8881a0590dc93bc4414",
      "candidate_info": {
        "commit_hash": "44384bf1e682c4c0bbfcb8881a0590dc93bc4414",
        "repo": "apache/ambari",
        "commit_url": "https://github.com/apache/ambari/commit/44384bf1e682c4c0bbfcb8881a0590dc93bc4414",
        "files": [
          "ambari-common/src/main/python/resource_management/libraries/providers/hdfs_resource.py"
        ],
        "message": "AMBARI-24399. Components start failing with 'Holder DFSClient_NONMAPREDUCE does not have any open files' while adding Namespace  (aonishuk)",
        "before_after_code_files": [
          "ambari-common/src/main/python/resource_management/libraries/providers/hdfs_resource.py||ambari-common/src/main/python/resource_management/libraries/providers/hdfs_resource.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/apache/ambari/pull/3633",
          "https://github.com/apache/ambari/pull/3631",
          "https://github.com/apache/ambari/pull/3637",
          "https://github.com/apache/ambari/pull/3632",
          "https://github.com/apache/ambari/pull/3634",
          "https://github.com/apache/ambari/pull/3635"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ambari-common/src/main/python/resource_management/libraries/providers/hdfs_resource.py||ambari-common/src/main/python/resource_management/libraries/providers/hdfs_resource.py": [
          "File: ambari-common/src/main/python/resource_management/libraries/providers/hdfs_resource.py -> ambari-common/src/main/python/resource_management/libraries/providers/hdfs_resource.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "58: }",
          "60: EXCEPTIONS_TO_RETRY = {",
          "64: }",
          "66: class HdfsResourceJar:",
          "",
          "[Removed Lines]",
          "61:   # \"ExceptionName\": (try_count, try_sleep_seconds)",
          "62:   \"LeaseExpiredException\": (20, 6),",
          "63:   \"RetriableException\": (20, 6),",
          "",
          "[Added Lines]",
          "61:   # (\"ExceptionName\"): (\"required text fragment\", try_count, try_sleep_seconds)",
          "63:   \"\"\"",
          "64:   Happens when multiple nodes try to put same file at the same time.",
          "65:   Needs a longer retry time, to wait for other nodes success.",
          "66:   \"\"\"",
          "67:   \"FileNotFoundException\": (\" does not have any open files\", 6, 30),",
          "69:   \"LeaseExpiredException\": (\"\", 20, 6),",
          "70:   \"RetriableException\": (\"\", 20, 6),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "173:       return self.result_message[\"RemoteException\"][\"exception\"]",
          "174:     return None",
          "176: class WebHDFSUtil:",
          "177:   def __init__(self, hdfs_site, nameservice, run_user, security_enabled, logoutput=None):",
          "178:     self.is_https_enabled = is_https_enabled_in_hdfs(hdfs_site['dfs.http.policy'], hdfs_site['dfs.https.enable'])",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "183:   def get_exception_text(self):",
          "184:     if isinstance(self.result_message, dict) and \"RemoteException\" in self.result_message and \"message\" in self.result_message[\"RemoteException\"]:",
          "185:       return self.result_message[\"RemoteException\"][\"message\"]",
          "186:     return None",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "199:       return self._run_command(*args, **kwargs)",
          "200:     except WebHDFSCallException as ex:",
          "201:       exception_name = ex.get_exception_name()",
          "202:       if exception_name in EXCEPTIONS_TO_RETRY:",
          "205:       else:",
          "206:         raise",
          "",
          "[Removed Lines]",
          "203:         try_count, try_sleep = EXCEPTIONS_TO_RETRY[exception_name]",
          "204:         last_exception = ex",
          "",
          "[Added Lines]",
          "214:       exception_text = ex.get_exception_text()",
          "217:         required_text, try_count, try_sleep = EXCEPTIONS_TO_RETRY[exception_name]",
          "219:         if not required_text or (exception_text and required_text in exception_text):",
          "220:           last_exception = ex",
          "221:         else:",
          "222:           raise",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e9de4b7c12457b4870d1566b82219e1d7a5ed0a0",
      "candidate_info": {
        "commit_hash": "e9de4b7c12457b4870d1566b82219e1d7a5ed0a0",
        "repo": "apache/ambari",
        "commit_url": "https://github.com/apache/ambari/commit/e9de4b7c12457b4870d1566b82219e1d7a5ed0a0",
        "files": [
          "ambari-agent/src/main/python/ambari_agent/ComponentStatusExecutor.py",
          "ambari-agent/src/main/python/ambari_agent/HeartbeatThread.py"
        ],
        "message": "AMBARI-24689. All component statuses should be re-send on registration. (#2555)\n\n* AMBARI-24689. All component statuses should be re-send on registration (aonishuk)\n\n* AMBARI-24689. All component statuses should be re-send on registration (aonishuk)",
        "before_after_code_files": [
          "ambari-agent/src/main/python/ambari_agent/ComponentStatusExecutor.py||ambari-agent/src/main/python/ambari_agent/ComponentStatusExecutor.py",
          "ambari-agent/src/main/python/ambari_agent/HeartbeatThread.py||ambari-agent/src/main/python/ambari_agent/HeartbeatThread.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/apache/ambari/pull/3633",
          "https://github.com/apache/ambari/pull/3631",
          "https://github.com/apache/ambari/pull/3637",
          "https://github.com/apache/ambari/pull/3632",
          "https://github.com/apache/ambari/pull/3634",
          "https://github.com/apache/ambari/pull/3635"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ambari-agent/src/main/python/ambari_agent/ComponentStatusExecutor.py||ambari-agent/src/main/python/ambari_agent/ComponentStatusExecutor.py": [
          "File: ambari-agent/src/main/python/ambari_agent/ComponentStatusExecutor.py -> ambari-agent/src/main/python/ambari_agent/ComponentStatusExecutor.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:     self.logger = logging.getLogger(__name__)",
          "44:     self.reports_to_discard = []",
          "45:     self.reports_to_discard_lock = threading.RLock()",
          "46:     threading.Thread.__init__(self)",
          "48:   def run(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:     self.reported_component_status_lock = threading.RLock()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "178:       'clusterId': cluster_id,",
          "179:     }",
          "182:       logging.info(\"Status for {0} has changed to {1}\".format(component_name, status))",
          "183:       self.recovery_manager.handle_status_change(component_name, status)",
          "",
          "[Removed Lines]",
          "181:     if status != self.reported_component_status[cluster_id][component_name][command_name]:",
          "",
          "[Added Lines]",
          "182:     if status != self.reported_component_status[cluster_id][\"{0}/{1}\".format(service_name, component_name)][command_name]:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "191:       return result",
          "192:     return None",
          "194:   def send_updates_to_server(self, cluster_reports):",
          "195:     if not cluster_reports or not self.initializer_module.is_registered:",
          "196:       return",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "195:   def force_send_component_statuses(self):",
          "196:     \"\"\"",
          "197:     Forcefully resends all component statuses which are currently in cache.",
          "198:     \"\"\"",
          "199:     cluster_reports = defaultdict(lambda:[])",
          "201:     with self.reported_component_status_lock:",
          "202:       for cluster_id, component_to_command_dict in self.reported_component_status.iteritems():",
          "203:         for service_and_component_name, commands_status in component_to_command_dict.iteritems():",
          "204:           service_name, component_name = service_and_component_name.split(\"/\")",
          "205:           for command_name, status in commands_status.iteritems():",
          "206:             report = {",
          "207:               'serviceName': service_name,",
          "208:               'componentName': component_name,",
          "209:               'command': command_name,",
          "210:               'status': status,",
          "211:               'clusterId': cluster_id,",
          "212:             }",
          "214:             cluster_reports[cluster_id].append(report)",
          "216:     self.send_updates_to_server(cluster_reports)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "199:     self.server_responses_listener.listener_functions_on_success[correlation_id] = lambda headers, message: self.save_reported_component_status(cluster_reports)",
          "201:   def save_reported_component_status(self, cluster_reports):",
          "210:   def clean_not_existing_clusters_info(self):",
          "211:     \"\"\"",
          "212:     This needs to be done to remove information about clusters which where deleted (e.g. ambari-server reset)",
          "213:     \"\"\"",
          "",
          "[Removed Lines]",
          "202:     for cluster_id, reports in cluster_reports.iteritems():",
          "203:       for report in reports:",
          "204:         component_name = report['componentName']",
          "205:         command = report['command']",
          "206:         status = report['status']",
          "208:         self.reported_component_status[cluster_id][component_name][command] = status",
          "214:     for cluster_id in self.reported_component_status.keys():",
          "215:       if cluster_id not in self.topology_cache.get_cluster_ids():",
          "216:         del self.reported_component_status[cluster_id]",
          "",
          "[Added Lines]",
          "226:     with self.reported_component_status_lock:",
          "227:       for cluster_id, reports in cluster_reports.iteritems():",
          "228:         for report in reports:",
          "229:           component_name = report['componentName']",
          "230:           service_name = report['serviceName']",
          "231:           command = report['command']",
          "232:           status = report['status']",
          "234:           self.reported_component_status[cluster_id][\"{0}/{1}\".format(service_name, component_name)][command] = status",
          "240:     with self.reported_component_status_lock:",
          "241:       for cluster_id in self.reported_component_status.keys():",
          "242:         if cluster_id not in self.topology_cache.get_cluster_ids():",
          "243:           del self.reported_component_status[cluster_id]",
          "",
          "---------------"
        ],
        "ambari-agent/src/main/python/ambari_agent/HeartbeatThread.py||ambari-agent/src/main/python/ambari_agent/HeartbeatThread.py": [
          "File: ambari-agent/src/main/python/ambari_agent/HeartbeatThread.py -> ambari-agent/src/main/python/ambari_agent/HeartbeatThread.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "67:     self.host_level_params_events_listener = HostLevelParamsEventListener(initializer_module)",
          "68:     self.alert_definitions_events_listener = AlertDefinitionsEventListener(initializer_module)",
          "69:     self.agent_actions_events_listener = AgentActionsListener(initializer_module)",
          "70:     self.listeners = [self.server_responses_listener, self.commands_events_listener, self.metadata_events_listener, self.topology_events_listener, self.configuration_events_listener, self.host_level_params_events_listener, self.alert_definitions_events_listener, self.agent_actions_events_listener]",
          "72:     self.post_registration_requests = [",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70:     self.component_status_executor = initializer_module.component_status_executor",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "146:           raise",
          "147:       finally:",
          "148:         with listener.event_queue_lock:",
          "150:           listener.enabled = True",
          "151:           # Process queued messages if any",
          "152:           listener.dequeue_unprocessed_events()",
          "",
          "[Removed Lines]",
          "149:           logger.info(\"Enabling events for listener {0}\".format(listener))",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "160:     self.initializer_module._connection = self.connection",
          "162:     self.report_components_initial_versions()",
          "164:   def run_post_registration_actions(self):",
          "165:     for post_registration_action in self.post_registration_actions:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "163:     self.force_component_status_update()",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "168:   def report_components_initial_versions(self):",
          "169:     ComponentVersionReporter(self.initializer_module).start()",
          "171:   def unregister(self):",
          "172:     \"\"\"",
          "173:     Disconnect and remove connection object from initializer_module so other threads cannot use it",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "172:   def force_component_status_update(self):",
          "173:     self.component_status_executor.force_send_component_statuses()",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "11fd4eb25c8bd4d744c532e853d8bfad72a7b77b",
      "candidate_info": {
        "commit_hash": "11fd4eb25c8bd4d744c532e853d8bfad72a7b77b",
        "repo": "apache/ambari",
        "commit_url": "https://github.com/apache/ambari/commit/11fd4eb25c8bd4d744c532e853d8bfad72a7b77b",
        "files": [
          "ambari-agent/src/main/python/ambari_agent/CustomServiceOrchestrator.py"
        ],
        "message": "AMBARI-25123. /var/lib/ambari-agent/cache not updating (Ambari 2.7) (aonishuk)",
        "before_after_code_files": [
          "ambari-agent/src/main/python/ambari_agent/CustomServiceOrchestrator.py||ambari-agent/src/main/python/ambari_agent/CustomServiceOrchestrator.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/apache/ambari/pull/3633",
          "https://github.com/apache/ambari/pull/3631",
          "https://github.com/apache/ambari/pull/3637",
          "https://github.com/apache/ambari/pull/3632",
          "https://github.com/apache/ambari/pull/3634",
          "https://github.com/apache/ambari/pull/3635"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ambari-agent/src/main/python/ambari_agent/CustomServiceOrchestrator.py||ambari-agent/src/main/python/ambari_agent/CustomServiceOrchestrator.py": [
          "File: ambari-agent/src/main/python/ambari_agent/CustomServiceOrchestrator.py -> ambari-agent/src/main/python/ambari_agent/CustomServiceOrchestrator.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "348:         # forces a hash challenge on the directories to keep them updated, even",
          "349:         # if the return type is not used",
          "350:         base_dir = self.file_cache.get_service_base_dir(command)",
          "351:         script_path = self.resolve_script_path(base_dir, script)",
          "352:         script_tuple = (script_path, base_dir)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "350:         self.file_cache.get_host_scripts_base_dir(command)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
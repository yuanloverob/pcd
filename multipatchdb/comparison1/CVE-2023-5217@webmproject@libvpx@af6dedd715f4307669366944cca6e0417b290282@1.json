{
  "cve_id": "CVE-2023-5217",
  "cve_desc": "Heap buffer overflow in vp8 encoding in libvpx in Google Chrome prior to 117.0.5938.132 and libvpx 1.13.1 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page. (Chromium security severity: High)",
  "repo": "webmproject/libvpx",
  "patch_hash": "af6dedd715f4307669366944cca6e0417b290282",
  "patch_info": {
    "commit_hash": "af6dedd715f4307669366944cca6e0417b290282",
    "repo": "webmproject/libvpx",
    "commit_url": "https://github.com/webmproject/libvpx/commit/af6dedd715f4307669366944cca6e0417b290282",
    "files": [
      "test/encode_api_test.cc"
    ],
    "message": "encode_api_test: add ConfigResizeChangeThreadCount\n\nUpdate thread counts and resolution to ensure allocations are updated\ncorrectly. VP8 is disabled to avoid a crash.\n\nBug: chromium:1486441\nChange-Id: Ie89776d9818d27dc351eff298a44c699e850761b",
    "before_after_code_files": [
      "test/encode_api_test.cc||test/encode_api_test.cc"
    ]
  },
  "patch_diff": {
    "test/encode_api_test.cc||test/encode_api_test.cc": [
      "File: test/encode_api_test.cc -> test/encode_api_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "309: void InitCodec(const vpx_codec_iface_t &iface, int width, int height,",
      "310:                vpx_codec_ctx_t *enc, vpx_codec_enc_cfg_t *cfg) {",
      "312:   cfg->g_w = width;",
      "313:   cfg->g_h = height;",
      "314:   cfg->g_lag_in_frames = 0;",
      "",
      "[Removed Lines]",
      "311:   ASSERT_EQ(vpx_codec_enc_config_default(&iface, cfg, 0), VPX_CODEC_OK);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "346:         vpx_codec_ctx_t ctx = {};",
      "347:       } enc;",
      "349:       EXPECT_NO_FATAL_FAILURE(",
      "350:           InitCodec(*iface, kWidth, kHeight, &enc.ctx, &cfg));",
      "351:       if (IsVP9(iface)) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "348:       ASSERT_EQ(vpx_codec_enc_config_default(iface, &cfg, 0), VPX_CODEC_OK);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "364:   }",
      "365: }",
      "367: #if CONFIG_VP9_ENCODER",
      "368: class EncodeApiGetTplStatsTest",
      "369:     : public ::libvpx_test::EncoderTest,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "367: TEST(EncodeAPI, ConfigResizeChangeThreadCount) {",
      "368:   constexpr int kInitWidth = 1024;",
      "369:   constexpr int kInitHeight = 1024;",
      "371:   for (const auto *iface : kCodecIfaces) {",
      "372:     SCOPED_TRACE(vpx_codec_iface_name(iface));",
      "373:     if (!IsVP9(iface)) {",
      "374:       GTEST_SKIP() << \"TODO(https://crbug.com/1486441) remove this condition \"",
      "375:                       \"after VP8 is fixed.\";",
      "376:     }",
      "377:     for (int i = 0; i < (IsVP9(iface) ? 2 : 1); ++i) {",
      "378:       vpx_codec_enc_cfg_t cfg = {};",
      "379:       struct Encoder {",
      "380:         ~Encoder() { EXPECT_EQ(vpx_codec_destroy(&ctx), VPX_CODEC_OK); }",
      "381:         vpx_codec_ctx_t ctx = {};",
      "382:       } enc;",
      "384:       ASSERT_EQ(vpx_codec_enc_config_default(iface, &cfg, 0), VPX_CODEC_OK);",
      "388:       cfg.g_threads = 4;",
      "389:       EXPECT_NO_FATAL_FAILURE(",
      "390:           InitCodec(*iface, kInitWidth, kInitHeight, &enc.ctx, &cfg));",
      "391:       if (IsVP9(iface)) {",
      "392:         EXPECT_EQ(vpx_codec_control_(&enc.ctx, VP9E_SET_TILE_COLUMNS, 6),",
      "393:                   VPX_CODEC_OK);",
      "394:         EXPECT_EQ(vpx_codec_control_(&enc.ctx, VP9E_SET_ROW_MT, i),",
      "395:                   VPX_CODEC_OK);",
      "396:       }",
      "398:       cfg.g_w = 1000;",
      "399:       cfg.g_h = 608;",
      "400:       EXPECT_EQ(vpx_codec_enc_config_set(&enc.ctx, &cfg), VPX_CODEC_OK)",
      "401:           << vpx_codec_error_detail(&enc.ctx);",
      "403:       cfg.g_w = 16;",
      "404:       cfg.g_h = 720;",
      "406:       for (const auto threads : { 1, 4, 8, 6, 2, 1 }) {",
      "407:         cfg.g_threads = threads;",
      "408:         EXPECT_NO_FATAL_FAILURE(EncodeWithConfig(cfg, &enc.ctx))",
      "409:             << \"iteration: \" << i << \" threads: \" << threads;",
      "410:       }",
      "411:     }",
      "412:   }",
      "413: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "20ae08971506ab401556fe0cc41d3784aec59a31",
      "candidate_info": {
        "commit_hash": "20ae08971506ab401556fe0cc41d3784aec59a31",
        "repo": "webmproject/libvpx",
        "commit_url": "https://github.com/webmproject/libvpx/commit/20ae08971506ab401556fe0cc41d3784aec59a31",
        "files": [
          "test/encode_api_test.cc"
        ],
        "message": "encode_api_test: add ConfigResizeChangeThreadCount\n\nUpdate thread counts and resolution to ensure allocations are updated\ncorrectly. VP8 is disabled to avoid a crash.\n\nBug: chromium:1486441\nChange-Id: Ie89776d9818d27dc351eff298a44c699e850761b\n(cherry picked from commit af6dedd715f4307669366944cca6e0417b290282)",
        "before_after_code_files": [
          "test/encode_api_test.cc||test/encode_api_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "test/encode_api_test.cc||test/encode_api_test.cc"
          ],
          "candidate": [
            "test/encode_api_test.cc||test/encode_api_test.cc"
          ]
        }
      },
      "candidate_diff": {
        "test/encode_api_test.cc||test/encode_api_test.cc": [
          "File: test/encode_api_test.cc -> test/encode_api_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "309: void InitCodec(const vpx_codec_iface_t &iface, int width, int height,",
          "310:                vpx_codec_ctx_t *enc, vpx_codec_enc_cfg_t *cfg) {",
          "312:   cfg->g_w = width;",
          "313:   cfg->g_h = height;",
          "314:   cfg->g_lag_in_frames = 0;",
          "",
          "[Removed Lines]",
          "311:   ASSERT_EQ(vpx_codec_enc_config_default(&iface, cfg, 0), VPX_CODEC_OK);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "346:         vpx_codec_ctx_t ctx = {};",
          "347:       } enc;",
          "349:       EXPECT_NO_FATAL_FAILURE(",
          "350:           InitCodec(*iface, kWidth, kHeight, &enc.ctx, &cfg));",
          "351:       if (IsVP9(iface)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "348:       ASSERT_EQ(vpx_codec_enc_config_default(iface, &cfg, 0), VPX_CODEC_OK);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "364:   }",
          "365: }",
          "367: #if CONFIG_VP9_ENCODER",
          "368: class EncodeApiGetTplStatsTest",
          "369:     : public ::libvpx_test::EncoderTest,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "367: TEST(EncodeAPI, ConfigResizeChangeThreadCount) {",
          "368:   constexpr int kInitWidth = 1024;",
          "369:   constexpr int kInitHeight = 1024;",
          "371:   for (const auto *iface : kCodecIfaces) {",
          "372:     SCOPED_TRACE(vpx_codec_iface_name(iface));",
          "373:     if (!IsVP9(iface)) {",
          "374:       GTEST_SKIP() << \"TODO(https://crbug.com/1486441) remove this condition \"",
          "375:                       \"after VP8 is fixed.\";",
          "376:     }",
          "377:     for (int i = 0; i < (IsVP9(iface) ? 2 : 1); ++i) {",
          "378:       vpx_codec_enc_cfg_t cfg = {};",
          "379:       struct Encoder {",
          "380:         ~Encoder() { EXPECT_EQ(vpx_codec_destroy(&ctx), VPX_CODEC_OK); }",
          "381:         vpx_codec_ctx_t ctx = {};",
          "382:       } enc;",
          "384:       ASSERT_EQ(vpx_codec_enc_config_default(iface, &cfg, 0), VPX_CODEC_OK);",
          "388:       cfg.g_threads = 4;",
          "389:       EXPECT_NO_FATAL_FAILURE(",
          "390:           InitCodec(*iface, kInitWidth, kInitHeight, &enc.ctx, &cfg));",
          "391:       if (IsVP9(iface)) {",
          "392:         EXPECT_EQ(vpx_codec_control_(&enc.ctx, VP9E_SET_TILE_COLUMNS, 6),",
          "393:                   VPX_CODEC_OK);",
          "394:         EXPECT_EQ(vpx_codec_control_(&enc.ctx, VP9E_SET_ROW_MT, i),",
          "395:                   VPX_CODEC_OK);",
          "396:       }",
          "398:       cfg.g_w = 1000;",
          "399:       cfg.g_h = 608;",
          "400:       EXPECT_EQ(vpx_codec_enc_config_set(&enc.ctx, &cfg), VPX_CODEC_OK)",
          "401:           << vpx_codec_error_detail(&enc.ctx);",
          "403:       cfg.g_w = 16;",
          "404:       cfg.g_h = 720;",
          "406:       for (const auto threads : { 1, 4, 8, 6, 2, 1 }) {",
          "407:         cfg.g_threads = threads;",
          "408:         EXPECT_NO_FATAL_FAILURE(EncodeWithConfig(cfg, &enc.ctx))",
          "409:             << \"iteration: \" << i << \" threads: \" << threads;",
          "410:       }",
          "411:     }",
          "412:   }",
          "413: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b729684b059d48b6bac0750045acbe6a4a9e9a6b",
      "candidate_info": {
        "commit_hash": "b729684b059d48b6bac0750045acbe6a4a9e9a6b",
        "repo": "webmproject/libvpx",
        "commit_url": "https://github.com/webmproject/libvpx/commit/b729684b059d48b6bac0750045acbe6a4a9e9a6b",
        "files": [
          "test/encode_api_test.cc"
        ],
        "message": "Use big cfg.g_w in ConfigResizeChangeThreadCount\n\nvp8cx_create_encoder_threads() caps the thread count at\n(cm->mb_cols / cpi->mt_sync_range) - 1. If cfg.g_w is 16, cm->mb_cols is\nonly 1 (see vp8_alloc_frame_buffers: mb_cols = width >> 4), so we won't\nbe using multiple threads. To reproduce bug chromium:1486441, the test\njust needs to increase cfg.g_h sufficiently.\n\nBug: chromium:1486441\nChange-Id: Ie6b2da2e31cfa1717a481f55eebc8c875db94d87",
        "before_after_code_files": [
          "test/encode_api_test.cc||test/encode_api_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/encode_api_test.cc||test/encode_api_test.cc"
          ],
          "candidate": [
            "test/encode_api_test.cc||test/encode_api_test.cc"
          ]
        }
      },
      "candidate_diff": {
        "test/encode_api_test.cc||test/encode_api_test.cc": [
          "File: test/encode_api_test.cc -> test/encode_api_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "396:       EXPECT_EQ(vpx_codec_enc_config_set(&enc.ctx, &cfg), VPX_CODEC_OK)",
          "397:           << vpx_codec_error_detail(&enc.ctx);",
          "400:       cfg.g_h = 720;",
          "402:       for (const auto threads : { 1, 4, 8, 6, 2, 1 }) {",
          "",
          "[Removed Lines]",
          "399:       cfg.g_w = 16;",
          "",
          "[Added Lines]",
          "399:       cfg.g_w = 1000;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
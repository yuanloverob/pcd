{
  "cve_id": "CVE-2018-1000159",
  "cve_desc": "tlslite-ng version 0.7.3 and earlier, since commit d7b288316bca7bcdd082e6ccff5491e241305233 contains a CWE-354: Improper Validation of Integrity Check Value vulnerability in TLS implementation, tlslite/utils/constanttime.py: ct_check_cbc_mac_and_pad(); line \"end_pos = data_len - 1 - mac.digest_size\" that can result in an attacker manipulating the TLS ciphertext which will not be detected by receiving tlslite-ng. This attack appears to be exploitable via man in the middle on a network connection. This vulnerability appears to have been fixed after commit 3674815d1b0f7484454995e2737a352e0a6a93d8.",
  "repo": "tlsfuzzer/tlslite-ng",
  "patch_hash": "3674815d1b0f7484454995e2737a352e0a6a93d8",
  "patch_info": {
    "commit_hash": "3674815d1b0f7484454995e2737a352e0a6a93d8",
    "repo": "tlsfuzzer/tlslite-ng",
    "commit_url": "https://github.com/tlsfuzzer/tlslite-ng/pull/234/commits/3674815d1b0f7484454995e2737a352e0a6a93d8",
    "files": [
      "tlslite/utils/constanttime.py",
      "unit_tests/test_tlslite_utils_constanttime.py"
    ],
    "message": "verify the mac even if the padding is 1 byte long\n\noff-by-one error on mac checking, if the padding is of\nminimal length (a single 0x00 byte), the mac is not\nchecked and thus the return value is never falsified\n\nthis fixes the issue",
    "before_after_code_files": [
      "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py",
      "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
    ]
  },
  "patch_diff": {
    "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py": [
      "File: tlslite/utils/constanttime.py -> tlslite/utils/constanttime.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "170:     data_mac.update(compatHMAC(data[:start_pos]))",
      "172:     # don't check past the array end (already checked to be >= zero)",
      "175:     # calculate all possible",
      "176:     for i in range(start_pos, end_pos): # constant for given overall length",
      "",
      "[Removed Lines]",
      "173:     end_pos = data_len - 1 - mac.digest_size",
      "",
      "[Added Lines]",
      "173:     end_pos = data_len - mac.digest_size",
      "",
      "---------------"
    ],
    "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py": [
      "File: unit_tests/test_tlslite_utils_constanttime.py -> unit_tests/test_tlslite_utils_constanttime.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "16: from hypothesis import given, example",
      "17: import hypothesis.strategies as st",
      "18: from tlslite.utils.compat import compatHMAC",
      "19: from tlslite.recordlayer import RecordLayer",
      "20: import tlslite.utils.tlshashlib as hashlib",
      "21: import hmac",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "19: from tlslite.utils.cryptomath import getRandomBytes",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "266:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "267:                                                   content_type, version))",
      "269:     def test_with_invalid_pad(self):",
      "270:         key = compatHMAC(bytearray(20))",
      "271:         seqnum_bytes = bytearray(16)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "270:     @given(i=st.integers(1, 20))",
      "271:     def test_with_invalid_random_hash(self, i):",
      "272:         key = compatHMAC(getRandomBytes(20))",
      "273:         seqnum_bytes = bytearray(16)",
      "274:         content_type = 0x15",
      "275:         version = (3, 3)",
      "276:         application_data = getRandomBytes(63)",
      "277:         mac = hashlib.sha1",
      "279:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "280:                                  version, mac, key)",
      "281:         data[-i] ^= 0xff",
      "282:         padding = bytearray(b'\\x00')",
      "283:         data += padding",
      "285:         h = hmac.new(key, digestmod=mac)",
      "286:         h.block_size = mac().block_size",
      "287:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "288:                                                   content_type, version))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d7b288316bca7bcdd082e6ccff5491e241305233",
      "candidate_info": {
        "commit_hash": "d7b288316bca7bcdd082e6ccff5491e241305233",
        "repo": "tlsfuzzer/tlslite-ng",
        "commit_url": "https://github.com/tlsfuzzer/tlslite-ng/commit/d7b288316bca7bcdd082e6ccff5491e241305233",
        "files": [
          "tlslite/utils/constanttime.py",
          "unit_tests/test_tlslite_utils_constanttime.py"
        ],
        "message": "constant time implementation of CBC mac and pad check\n\nto protect against Lucky 13 attacks, we need to check both the\nhash and padding in constant time, independent of the length of\npadding",
        "before_after_code_files": [
          "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py",
          "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py",
            "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
          ],
          "candidate": [
            "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py",
            "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
          ]
        }
      },
      "candidate_diff": {
        "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py": [
          "File: tlslite/utils/constanttime.py -> tlslite/utils/constanttime.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2015, Hubert Kario",
          "2: #",
          "3: # See the LICENSE file for legal information regarding use of this file.",
          "4: \"\"\"Various constant time functions for processing sensitive data\"\"\"",
          "6: from __future__ import division",
          "8: from .compat import compatHMAC",
          "9: import hmac",
          "11: def ct_lt_u32(val_a, val_b):",
          "12:     \"\"\"",
          "13:     Returns 1 if val_a < val_b, 0 otherwise. Constant time.",
          "15:     @type val_a: int",
          "16:     @type val_b: int",
          "17:     @param val_a: an unsigned integer representable as a 32 bit value",
          "18:     @param val_b: an unsigned integer representable as a 32 bit value",
          "19:     @rtype: int",
          "20:     \"\"\"",
          "21:     val_a &= 0xffffffff",
          "22:     val_b &= 0xffffffff",
          "24:     return (val_a^((val_a^val_b)|(((val_a-val_b)&0xffffffff)^val_b)))>>31",
          "26: def ct_gt_u32(val_a, val_b):",
          "27:     \"\"\"",
          "28:     Return 1 if val_a > val_b, 0 otherwise. Constant time.",
          "30:     @type val_a: int",
          "31:     @type val_b: int",
          "32:     @param val_a: an unsigned integer representable as a 32 bit value",
          "33:     @param val_b: an unsigned integer representable as a 32 bit value",
          "34:     @rtype: int",
          "35:     \"\"\"",
          "36:     return ct_lt_u32(val_b, val_a)",
          "38: def ct_le_u32(val_a, val_b):",
          "39:     \"\"\"",
          "40:     Return 1 if val_a <= val_b, 0 otherwise. Constant time.",
          "42:     @type val_a: int",
          "43:     @type val_b: int",
          "44:     @param val_a: an unsigned integer representable as a 32 bit value",
          "45:     @param val_b: an unsigned integer representable as a 32 bit value",
          "46:     @rtype: int",
          "47:     \"\"\"",
          "48:     return 1 ^ ct_gt_u32(val_a, val_b)",
          "50: def ct_lsb_prop_u8(val):",
          "51:     \"\"\"Propagate LSB to all 8 bits of the returned byte. Constant time.\"\"\"",
          "52:     val &= 0x01",
          "53:     val |= val << 1",
          "54:     val |= val << 2",
          "55:     val |= val << 4",
          "56:     return val",
          "58: def ct_isnonzero_u32(val):",
          "59:     \"\"\"",
          "60:     Returns 1 if val is != 0, 0 otherwise. Constant time.",
          "62:     @type val: int",
          "63:     @param val: an unsigned integer representable as a 32 bit value",
          "64:     @rtype: int",
          "65:     \"\"\"",
          "66:     val &= 0xffffffff",
          "67:     return (val|(-val&0xffffffff)) >> 31",
          "69: def ct_neq_u32(val_a, val_b):",
          "70:     \"\"\"",
          "71:     Return 1 if val_a != val_b, 0 otherwise. Constant time.",
          "73:     @type val_a: int",
          "74:     @type val_b: int",
          "75:     @param val_a: an unsigned integer representable as a 32 bit value",
          "76:     @param val_b: an unsigned integer representable as a 32 bit value",
          "77:     @rtype: int",
          "78:     \"\"\"",
          "79:     val_a &= 0xffffffff",
          "80:     val_b &= 0xffffffff",
          "82:     return (((val_a-val_b)&0xffffffff) | ((val_b-val_a)&0xffffffff)) >> 31",
          "84: def ct_eq_u32(val_a, val_b):",
          "85:     \"\"\"",
          "86:     Return 1 if val_a == val_b, 0 otherwise. Constant time.",
          "88:     @type val_a: int",
          "89:     @type val_b: int",
          "90:     @param val_a: an unsigned integer representable as a 32 bit value",
          "91:     @param val_b: an unsigned integer representable as a 32 bit value",
          "92:     @rtype: int",
          "93:     \"\"\"",
          "94:     return 1 ^ ct_neq_u32(val_a, val_b)",
          "96: def ct_check_cbc_mac_and_pad(data, mac, seqnumBytes, contentType, version):",
          "97:     \"\"\"",
          "98:     Check CBC cipher HMAC and padding. Close to constant time.",
          "100:     @type data: bytearray",
          "101:     @param data: data with HMAC value to test and padding",
          "103:     @type mac: hashlib mac",
          "104:     @param mac: empty HMAC, initialised with a key",
          "106:     @type seqnumBytes: bytearray",
          "107:     @param seqnumBytes: TLS sequence number, used as input to HMAC",
          "109:     @type contentType: int",
          "110:     @param contentType: a single byte, used as input to HMAC",
          "112:     @type version: tuple of int",
          "113:     @param version: a tuple of two ints, used as input to HMAC and to guide",
          "114:     checking of padding",
          "116:     @rtype: boolean",
          "117:     @return: True if MAC and pad is ok, False otherwise",
          "118:     \"\"\"",
          "119:     assert version in ((3, 0), (3, 1), (3, 2), (3, 3))",
          "121:     data_len = len(data)",
          "122:     if mac.digest_size + 1 > data_len: # data_len is public",
          "123:         return False",
          "125:     # 0 - OK",
          "126:     result = 0x00",
          "128:     #",
          "129:     # check padding",
          "130:     #",
          "131:     pad_length = data[data_len-1]",
          "132:     pad_start = data_len - pad_length - 1",
          "133:     pad_start = max(0, pad_start)",
          "135:     if version == (3, 0): # version is public",
          "136:         # in SSLv3 we can only check if pad is not longer than overall length",
          "138:         # subtract 1 for the pad length byte",
          "139:         mask = ct_lsb_prop_u8(ct_lt_u32(data_len-1, pad_length))",
          "140:         result |= mask",
          "141:     else:",
          "142:         start_pos = max(0, data_len - 256)",
          "143:         for i in range(start_pos, data_len):",
          "144:             # if pad_start < i: mask = 0xff; else: mask = 0x00",
          "145:             mask = ct_lsb_prop_u8(ct_le_u32(pad_start, i))",
          "146:             # if data[i] != pad_length and \"inside_pad\": result = False",
          "147:             result |= (data[i] ^ pad_length) & mask",
          "149:     #",
          "150:     # check MAC",
          "151:     #",
          "153:     # real place where mac starts and data ends",
          "154:     mac_start = pad_start - mac.digest_size",
          "155:     mac_start = max(0, mac_start)",
          "157:     # place to start processing",
          "158:     start_pos = max(0, data_len - (256 + mac.digest_size)) // mac.block_size",
          "159:     start_pos *= mac.block_size",
          "161:     # add start data",
          "162:     data_mac = mac.copy()",
          "163:     data_mac.update(compatHMAC(seqnumBytes))",
          "164:     data_mac.update(compatHMAC(bytearray([contentType])))",
          "165:     if version != (3, 0): # version is public",
          "166:         data_mac.update(compatHMAC(bytearray([version[0]])))",
          "167:         data_mac.update(compatHMAC(bytearray([version[1]])))",
          "168:     data_mac.update(compatHMAC(bytearray([mac_start >> 8])))",
          "169:     data_mac.update(compatHMAC(bytearray([mac_start & 0xff])))",
          "170:     data_mac.update(compatHMAC(data[:start_pos]))",
          "172:     # don't check past the array end (already checked to be >= zero)",
          "173:     end_pos = data_len - 1 - mac.digest_size",
          "175:     # calculate all possible",
          "176:     for i in range(start_pos, end_pos): # constant for given overall length",
          "177:         cur_mac = data_mac.copy()",
          "178:         cur_mac.update(compatHMAC(data[start_pos:i]))",
          "179:         mac_compare = bytearray(cur_mac.digest())",
          "180:         # compare the hash for real only if it's the place where mac is",
          "181:         # supposed to be",
          "182:         mask = ct_lsb_prop_u8(ct_eq_u32(i, mac_start))",
          "183:         for j in range(0, mac.digest_size): # digest_size is public",
          "184:             result |= (data[i+j] ^ mac_compare[j]) & mask",
          "186:     # return python boolean",
          "187:     return result == 0",
          "189: if hasattr(hmac, 'compare_digest'):",
          "190:     ct_compare_digest = hmac.compare_digest",
          "191: else:",
          "192:     def ct_compare_digest(val_a, val_b):",
          "193:         \"\"\"Compares if string like objects are equal. Constant time.\"\"\"",
          "194:         if len(val_a) != len(val_b):",
          "195:             return False",
          "197:         result = 0",
          "198:         for x, y in zip(val_a, val_b):",
          "199:             result |= x ^ y",
          "201:         return result == 0",
          "",
          "---------------"
        ],
        "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py": [
          "File: unit_tests/test_tlslite_utils_constanttime.py -> unit_tests/test_tlslite_utils_constanttime.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2015, Hubert Kario",
          "2: #",
          "3: # See the LICENSE file for legal information regarding use of this file.",
          "5: # compatibility with Python 2.6, for that we need unittest2 package,",
          "6: # which is not available on 3.3 or 3.4",
          "7: try:",
          "8:     import unittest2 as unittest",
          "9: except ImportError:",
          "10:     import unittest",
          "12: from tlslite.utils.constanttime import ct_lt_u32, ct_gt_u32, ct_le_u32, \\",
          "13:         ct_lsb_prop_u8, ct_isnonzero_u32, ct_neq_u32, ct_eq_u32, \\",
          "14:         ct_check_cbc_mac_and_pad, ct_compare_digest",
          "16: from tlslite.utils.compat import compatHMAC",
          "17: from tlslite.recordlayer import RecordLayer",
          "18: import hashlib",
          "19: import hmac",
          "21: class TestContanttime(unittest.TestCase):",
          "22:     def test_ct_lt_u32(self):",
          "23:         for i in range(0, 256):",
          "24:             for j in range(0, 256):",
          "25:                 self.assertEqual((i < j), (ct_lt_u32(i, j) == 1))",
          "27:         for i in range(2**32-256, 2**32):",
          "28:             for j in range(2**32-256, 2**32):",
          "29:                 self.assertEqual((i < j), (ct_lt_u32(i, j) == 1))",
          "31:         for i in range(0, 256):",
          "32:             for j in range(2**32-256, 2**32):",
          "33:                 self.assertEqual((i < j), (ct_lt_u32(i, j) == 1))",
          "35:         for i in range(2**32-256, 2**32):",
          "36:             for j in range(0, 256):",
          "37:                 self.assertEqual((i < j), (ct_lt_u32(i, j) == 1))",
          "39:     def test_ct_gt_u32(self):",
          "40:         for i in range(0, 256):",
          "41:             for j in range(0, 256):",
          "42:                 self.assertEqual((i > j), (ct_gt_u32(i, j) == 1))",
          "44:         for i in range(2**32-256, 2**32):",
          "45:             for j in range(2**32-256, 2**32):",
          "46:                 self.assertEqual((i > j), (ct_gt_u32(i, j) == 1))",
          "48:         for i in range(0, 256):",
          "49:             for j in range(2**32-256, 2**32):",
          "50:                 self.assertEqual((i > j), (ct_gt_u32(i, j) == 1))",
          "52:         for i in range(2**32-256, 2**32):",
          "53:             for j in range(0, 256):",
          "54:                 self.assertEqual((i > j), (ct_gt_u32(i, j) == 1))",
          "56:     def test_ct_le_u32(self):",
          "57:         for i in range(0, 256):",
          "58:             for j in range(0, 256):",
          "59:                 self.assertEqual((i <= j), (ct_le_u32(i, j) == 1))",
          "61:         for i in range(2**32-256, 2**32):",
          "62:             for j in range(2**32-256, 2**32):",
          "63:                 self.assertEqual((i <= j), (ct_le_u32(i, j) == 1))",
          "65:         for i in range(0, 256):",
          "66:             for j in range(2**32-256, 2**32):",
          "67:                 self.assertEqual((i <= j), (ct_le_u32(i, j) == 1))",
          "69:         for i in range(2**32-256, 2**32):",
          "70:             for j in range(0, 256):",
          "71:                 self.assertEqual((i <= j), (ct_le_u32(i, j) == 1))",
          "73:     def test_ct_lsb_prop_u8(self):",
          "74:         for i in range(0, 256):",
          "75:             self.assertEqual(((i & 0x1) == 1), (ct_lsb_prop_u8(i) == 0xff))",
          "76:             self.assertEqual(((i & 0x1) == 0), (ct_lsb_prop_u8(i) == 0x00))",
          "78:     def test_ct_isnonzero_u32(self):",
          "79:         for i in range(0, 256):",
          "80:             self.assertEqual((i != 0), (ct_isnonzero_u32(i) == 1))",
          "82:     def test_ct_neq_u32(self):",
          "83:         for i in range(0, 256):",
          "84:             for j in range(0, 256):",
          "85:                 self.assertEqual((i != j), (ct_neq_u32(i, j) == 1))",
          "87:         for i in range(2**32-128, 2**32):",
          "88:             for j in range(2**32-128, 2**32):",
          "89:                 self.assertEqual((i != j), (ct_neq_u32(i, j) == 1))",
          "91:     def test_ct_eq_u32(self):",
          "92:         for i in range(0, 256):",
          "93:             for j in range(0, 256):",
          "94:                 self.assertEqual((i == j), (ct_eq_u32(i, j) == 1))",
          "96:         for i in range(2**32-128, 2**32):",
          "97:             for j in range(2**32-128, 2**32):",
          "98:                 self.assertEqual((i == j), (ct_eq_u32(i, j) == 1))",
          "100: class TestContanttimeCBCCheck(unittest.TestCase):",
          "102:     @staticmethod",
          "103:     def data_prepare(application_data, seqnum_bytes, content_type, version,",
          "104:                      mac, key):",
          "105:         r_layer = RecordLayer(None)",
          "106:         r_layer.version = version",
          "108:         h = hmac.new(key, digestmod=mac)",
          "110:         digest = r_layer._calculateMAC(h, seqnum_bytes, content_type,",
          "111:                                        application_data)",
          "113:         return application_data + digest",
          "115:     def test_with_empty_data_and_minimum_pad(self):",
          "116:         key = compatHMAC(bytearray(20))",
          "117:         seqnum_bytes = bytearray(16)",
          "118:         content_type = 0x14",
          "119:         version = (3, 1)",
          "120:         application_data = bytearray(0)",
          "121:         mac = hashlib.sha1",
          "123:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "124:                                  version, mac, key)",
          "126:         padding = bytearray(b'\\x00')",
          "127:         data += padding",
          "129:         h = hmac.new(key, digestmod=mac)",
          "130:         h.block_size = mac().block_size # python2 workaround",
          "131:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "132:                                                  content_type, version))",
          "134:     def test_with_empty_data_and_maximum_pad(self):",
          "135:         key = compatHMAC(bytearray(20))",
          "136:         seqnum_bytes = bytearray(16)",
          "137:         content_type = 0x14",
          "138:         version = (3, 1)",
          "139:         application_data = bytearray(0)",
          "140:         mac = hashlib.sha1",
          "142:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "143:                                  version, mac, key)",
          "145:         padding = bytearray(b'\\xff'*256)",
          "146:         data += padding",
          "148:         h = hmac.new(key, digestmod=mac)",
          "149:         h.block_size = mac().block_size # python2 workaround",
          "150:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "151:                                                  content_type, version))",
          "153:     def test_with_little_data_and_minimum_pad(self):",
          "154:         key = compatHMAC(bytearray(20))",
          "155:         seqnum_bytes = bytearray(16)",
          "156:         content_type = 0x14",
          "157:         version = (3, 1)",
          "158:         application_data = bytearray(b'\\x01'*32)",
          "159:         mac = hashlib.sha1",
          "161:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "162:                                  version, mac, key)",
          "164:         padding = bytearray(b'\\x00')",
          "165:         data += padding",
          "167:         h = hmac.new(key, digestmod=mac)",
          "168:         h.block_size = mac().block_size # python2 workaround",
          "169:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "170:                                                  content_type, version))",
          "172:     def test_with_little_data_and_maximum_pad(self):",
          "173:         key = compatHMAC(bytearray(20))",
          "174:         seqnum_bytes = bytearray(16)",
          "175:         content_type = 0x14",
          "176:         version = (3, 1)",
          "177:         application_data = bytearray(b'\\x01'*32)",
          "178:         mac = hashlib.sha1",
          "180:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "181:                                  version, mac, key)",
          "183:         padding = bytearray(b'\\xff'*256)",
          "184:         data += padding",
          "186:         h = hmac.new(key, digestmod=mac)",
          "187:         h.block_size = mac().block_size # python2 workaround",
          "188:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "189:                                                  content_type, version))",
          "191:     def test_with_lots_of_data_and_minimum_pad(self):",
          "192:         key = compatHMAC(bytearray(20))",
          "193:         seqnum_bytes = bytearray(16)",
          "194:         content_type = 0x14",
          "195:         version = (3, 1)",
          "196:         application_data = bytearray(b'\\x01'*1024)",
          "197:         mac = hashlib.sha1",
          "199:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "200:                                  version, mac, key)",
          "202:         padding = bytearray(b'\\x00')",
          "203:         data += padding",
          "205:         h = hmac.new(key, digestmod=mac)",
          "206:         h.block_size = mac().block_size # python2 workaround",
          "207:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "208:                                                  content_type, version))",
          "210:     def test_with_lots_of_data_and_maximum_pad(self):",
          "211:         key = compatHMAC(bytearray(20))",
          "212:         seqnum_bytes = bytearray(16)",
          "213:         content_type = 0x14",
          "214:         version = (3, 1)",
          "215:         application_data = bytearray(b'\\x01'*1024)",
          "216:         mac = hashlib.sha1",
          "218:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "219:                                  version, mac, key)",
          "221:         padding = bytearray(b'\\xff'*256)",
          "222:         data += padding",
          "224:         h = hmac.new(key, digestmod=mac)",
          "225:         h.block_size = mac().block_size # python2 workaround",
          "226:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "227:                                                  content_type, version))",
          "229:     def test_with_lots_of_data_and_small_pad(self):",
          "230:         key = compatHMAC(bytearray(20))",
          "231:         seqnum_bytes = bytearray(16)",
          "232:         content_type = 0x14",
          "233:         version = (3, 1)",
          "234:         application_data = bytearray(b'\\x01'*1024)",
          "235:         mac = hashlib.sha1",
          "237:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "238:                                  version, mac, key)",
          "240:         padding = bytearray(b'\\x0a'*11)",
          "241:         data += padding",
          "243:         h = hmac.new(key, digestmod=mac)",
          "244:         h.block_size = mac().block_size # python2 workaround",
          "245:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "246:                                                  content_type, version))",
          "248:     def test_with_too_little_data(self):",
          "249:         key = compatHMAC(bytearray(20))",
          "250:         seqnum_bytes = bytearray(16)",
          "251:         content_type = 0x14",
          "252:         version = (3, 1)",
          "253:         mac = hashlib.sha1",
          "255:         data = bytearray(mac().digest_size)",
          "257:         h = hmac.new(key, digestmod=mac)",
          "258:         h.block_size = mac().block_size # python2 workaround",
          "259:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "260:                                                   content_type, version))",
          "262:     def test_with_invalid_hash(self):",
          "263:         key = compatHMAC(bytearray(20))",
          "264:         seqnum_bytes = bytearray(16)",
          "265:         content_type = 0x14",
          "266:         version = (3, 1)",
          "267:         application_data = bytearray(b'\\x01'*1024)",
          "268:         mac = hashlib.sha1",
          "270:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "271:                                  version, mac, key)",
          "272:         data[-1] ^= 0xff",
          "274:         padding = bytearray(b'\\xff'*256)",
          "275:         data += padding",
          "277:         h = hmac.new(key, digestmod=mac)",
          "278:         h.block_size = mac().block_size # python2 workaround",
          "279:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "280:                                                   content_type, version))",
          "282:     def test_with_invalid_pad(self):",
          "283:         key = compatHMAC(bytearray(20))",
          "284:         seqnum_bytes = bytearray(16)",
          "285:         content_type = 0x14",
          "286:         version = (3, 1)",
          "287:         application_data = bytearray(b'\\x01'*1024)",
          "288:         mac = hashlib.sha1",
          "290:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "291:                                  version, mac, key)",
          "293:         padding = bytearray(b'\\x00' + b'\\xff'*255)",
          "294:         data += padding",
          "296:         h = hmac.new(key, digestmod=mac)",
          "297:         h.block_size = mac().block_size # python2 workaround",
          "298:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "299:                                                   content_type, version))",
          "301:     def test_with_pad_longer_than_data(self):",
          "302:         key = compatHMAC(bytearray(20))",
          "303:         seqnum_bytes = bytearray(16)",
          "304:         content_type = 0x14",
          "305:         version = (3, 1)",
          "306:         application_data = bytearray(b'\\x01')",
          "307:         mac = hashlib.sha1",
          "309:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "310:                                  version, mac, key)",
          "312:         padding = bytearray(b'\\xff')",
          "313:         data += padding",
          "315:         h = hmac.new(key, digestmod=mac)",
          "316:         h.block_size = mac().block_size # python2 workaround",
          "317:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "318:                                                   content_type, version))",
          "320:     def test_with_pad_longer_than_data_in_SSLv3(self):",
          "321:         key = compatHMAC(bytearray(20))",
          "322:         seqnum_bytes = bytearray(16)",
          "323:         content_type = 0x14",
          "324:         version = (3, 0)",
          "325:         application_data = bytearray(b'\\x01')",
          "326:         mac = hashlib.sha1",
          "328:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "329:                                  version, mac, key)",
          "331:         padding = bytearray([len(application_data) + mac().digest_size + 1])",
          "332:         data += padding",
          "334:         h = hmac.new(key, digestmod=mac)",
          "335:         h.block_size = mac().block_size # python2 workaround",
          "336:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "337:                                                   content_type, version))",
          "339:     def test_with_null_pad_in_SSLv3(self):",
          "340:         key = compatHMAC(bytearray(20))",
          "341:         seqnum_bytes = bytearray(16)",
          "342:         content_type = 0x14",
          "343:         version = (3, 0)",
          "344:         application_data = bytearray(b'\\x01'*10)",
          "345:         mac = hashlib.md5",
          "347:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "348:                                  version, mac, key)",
          "350:         padding = bytearray(b'\\x00'*10 + b'\\x0a')",
          "351:         data += padding",
          "353:         h = hmac.new(key, digestmod=mac)",
          "354:         h.block_size = mac().block_size # python2 workaround",
          "355:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "356:                                                  content_type, version))",
          "358:     def test_with_MD5(self):",
          "359:         key = compatHMAC(bytearray(20))",
          "360:         seqnum_bytes = bytearray(16)",
          "361:         content_type = 0x14",
          "362:         version = (3, 1)",
          "363:         application_data = bytearray(b'\\x01'*10)",
          "364:         mac = hashlib.md5",
          "366:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "367:                                  version, mac, key)",
          "369:         padding = bytearray(b'\\x0a'*11)",
          "370:         data += padding",
          "372:         h = hmac.new(key, digestmod=mac)",
          "373:         h.block_size = mac().block_size # python2 workaround",
          "374:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "375:                                                  content_type, version))",
          "377:     def test_with_SHA256(self):",
          "378:         key = compatHMAC(bytearray(20))",
          "379:         seqnum_bytes = bytearray(16)",
          "380:         content_type = 0x14",
          "381:         version = (3, 3)",
          "382:         application_data = bytearray(b'\\x01'*10)",
          "383:         mac = hashlib.sha256",
          "385:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "386:                                  version, mac, key)",
          "388:         padding = bytearray(b'\\x0a'*11)",
          "389:         data += padding",
          "391:         h = hmac.new(key, digestmod=mac)",
          "392:         h.block_size = mac().block_size # python2 workaround",
          "393:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "394:                                                  content_type, version))",
          "396:     def test_with_SHA384(self):",
          "397:         key = compatHMAC(bytearray(20))",
          "398:         seqnum_bytes = bytearray(16)",
          "399:         content_type = 0x14",
          "400:         version = (3, 3)",
          "401:         application_data = bytearray(b'\\x01'*10)",
          "402:         mac = hashlib.sha384",
          "404:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "405:                                  version, mac, key)",
          "407:         padding = bytearray(b'\\x0a'*11)",
          "408:         data += padding",
          "410:         h = hmac.new(key, digestmod=mac)",
          "411:         h.block_size = mac().block_size # python2 workaround",
          "412:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "413:                                                  content_type, version))",
          "415: class TestCompareDigest(unittest.TestCase):",
          "416:     def test_with_equal_length(self):",
          "417:         self.assertTrue(ct_compare_digest(bytearray(10), bytearray(10)))",
          "419:         self.assertTrue(ct_compare_digest(bytearray(b'\\x02'*8),",
          "420:                                           bytearray(b'\\x02'*8)))",
          "422:     def test_different_lengths(self):",
          "423:         self.assertFalse(ct_compare_digest(bytearray(10), bytearray(12)))",
          "425:         self.assertFalse(ct_compare_digest(bytearray(20), bytearray(12)))",
          "427:     def test_different(self):",
          "428:         self.assertFalse(ct_compare_digest(bytearray(b'\\x01'),",
          "429:                                            bytearray(b'\\x03')))",
          "431:         self.assertFalse(ct_compare_digest(bytearray(b'\\x01'*10 + b'\\x02'),",
          "432:                                            bytearray(b'\\x01'*10 + b'\\x03')))",
          "434:         self.assertFalse(ct_compare_digest(bytearray(b'\\x02' + b'\\x01'*10),",
          "435:                                            bytearray(b'\\x03' + b'\\x01'*10)))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e5e9145558f4c1a81071c61c947aa55a52542585",
      "candidate_info": {
        "commit_hash": "e5e9145558f4c1a81071c61c947aa55a52542585",
        "repo": "tlsfuzzer/tlslite-ng",
        "commit_url": "https://github.com/tlsfuzzer/tlslite-ng/commit/e5e9145558f4c1a81071c61c947aa55a52542585",
        "files": [
          "tlslite/utils/constanttime.py",
          "unit_tests/test_tlslite_utils_constanttime.py"
        ],
        "message": "verify the mac even if the padding is 1 byte long\n\noff-by-one error on mac checking, if the padding is of\nminimal length (a single 0x00 byte), the mac is not\nchecked and thus the return value is never falsified\n\nthis fixes the issue\n\nbackport of 3674815d1b0f7484454995e2737a352e0a6a93d8",
        "before_after_code_files": [
          "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py",
          "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py",
            "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
          ],
          "candidate": [
            "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py",
            "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
          ]
        }
      },
      "candidate_diff": {
        "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py": [
          "File: tlslite/utils/constanttime.py -> tlslite/utils/constanttime.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "170:     data_mac.update(compatHMAC(data[:start_pos]))",
          "172:     # don't check past the array end (already checked to be >= zero)",
          "175:     # calculate all possible",
          "176:     for i in range(start_pos, end_pos): # constant for given overall length",
          "",
          "[Removed Lines]",
          "173:     end_pos = data_len - 1 - mac.digest_size",
          "",
          "[Added Lines]",
          "173:     end_pos = data_len - mac.digest_size",
          "",
          "---------------"
        ],
        "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py": [
          "File: unit_tests/test_tlslite_utils_constanttime.py -> unit_tests/test_tlslite_utils_constanttime.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: from hypothesis import given, example",
          "17: import hypothesis.strategies as st",
          "18: from tlslite.utils.compat import compatHMAC",
          "19: from tlslite.recordlayer import RecordLayer",
          "20: import tlslite.utils.tlshashlib as hashlib",
          "21: import hmac",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: from tlslite.utils.cryptomath import getRandomBytes",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "266:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "267:                                                   content_type, version))",
          "269:     def test_with_invalid_pad(self):",
          "270:         key = compatHMAC(bytearray(20))",
          "271:         seqnum_bytes = bytearray(16)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "270:     @given(i=st.integers(1, 20))",
          "271:     def test_with_invalid_random_hash(self, i):",
          "272:         key = compatHMAC(getRandomBytes(20))",
          "273:         seqnum_bytes = bytearray(16)",
          "274:         content_type = 0x15",
          "275:         version = (3, 3)",
          "276:         application_data = getRandomBytes(63)",
          "277:         mac = hashlib.sha1",
          "279:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "280:                                  version, mac, key)",
          "281:         data[-i] ^= 0xff",
          "282:         padding = bytearray(b'\\x00')",
          "283:         data += padding",
          "285:         h = hmac.new(key, digestmod=mac)",
          "286:         h.block_size = mac().block_size",
          "287:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "288:                                                   content_type, version))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
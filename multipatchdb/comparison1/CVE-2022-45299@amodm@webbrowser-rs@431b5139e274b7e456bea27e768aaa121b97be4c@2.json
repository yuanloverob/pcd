{
  "cve_id": "CVE-2022-45299",
  "cve_desc": "An issue in the IpFile argument of rust-lang webbrowser-rs v0.8.2 allows attackers to access arbitrary files via supplying a crafted URL.",
  "repo": "amodm/webbrowser-rs",
  "patch_hash": "431b5139e274b7e456bea27e768aaa121b97be4c",
  "patch_info": {
    "commit_hash": "431b5139e274b7e456bea27e768aaa121b97be4c",
    "repo": "amodm/webbrowser-rs",
    "commit_url": "https://github.com/amodm/webbrowser-rs/commit/431b5139e274b7e456bea27e768aaa121b97be4c",
    "files": [
      "README.md",
      "src/lib.rs",
      "src/macos.rs",
      "src/unix.rs",
      "src/windows.rs"
    ],
    "message": "define consistent behaviour to include opening web browser even for local files",
    "before_after_code_files": [
      "src/lib.rs||src/lib.rs",
      "src/macos.rs||src/macos.rs",
      "src/unix.rs||src/unix.rs",
      "src/windows.rs||src/windows.rs"
    ]
  },
  "patch_diff": {
    "src/lib.rs||src/lib.rs": [
      "File: src/lib.rs -> src/lib.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "62:     \"Only Windows, Mac OS, iOS, Linux, *BSD and Haiku and Wasm32 are currently supported\"",
      "63: );",
      "65: use std::default::Default;",
      "66: use std::io::{Error, ErrorKind, Result};",
      "67: use std::str::FromStr;",
      "68: use std::{error, fmt};",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "69: use std::convert::TryFrom;",
      "71: use std::fmt::Display;",
      "73: use std::ops::Deref;",
      "74: use std::path::PathBuf;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "280:     url: &str,",
      "281:     options: &BrowserOptions,",
      "282: ) -> Result<()> {",
      "284:     os::open_browser_internal(browser, &target, options)",
      "285: }",
      "294: impl TargetType {",
      "296:     #[cfg(any(target_os = \"android\", target_os = \"ios\", target_family = \"wasm\"))]",
      "297:     fn is_http(&self) -> bool {",
      "303:             _ => false,",
      "304:         }",
      "305:     }",
      "",
      "[Removed Lines]",
      "283:     let target = TargetType::from(url);",
      "289: enum TargetType {",
      "290:     Url(url::Url),",
      "291:     Path(String),",
      "292: }",
      "298:         match self {",
      "299:             Self::Url(u) => match u.scheme() {",
      "300:                 \"http\" | \"https\" => true,",
      "301:                 _ => false,",
      "302:             },",
      "",
      "[Added Lines]",
      "291:     let target = TargetType::try_from(url)?;",
      "297: struct TargetType(url::Url);",
      "303:         match self.0.scheme() {",
      "304:             \"http\" | \"https\" => true,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "309:     #[cfg(any(target_os = \"android\", target_os = \"ios\", target_family = \"wasm\"))]",
      "310:     fn get_http_url(&self) -> Result<&str> {",
      "311:         if self.is_http() {",
      "313:         } else {",
      "315:         }",
      "316:     }",
      "317: }",
      "325:     }",
      "326: }",
      "333:         }",
      "334:     }",
      "335: }",
      "",
      "[Removed Lines]",
      "312:             Ok(self.as_ref())",
      "314:             Err(Error::new(ErrorKind::InvalidInput, \"not a valid url\"))",
      "319: impl AsRef<str> for TargetType {",
      "320:     fn as_ref(&self) -> &str {",
      "321:         match self {",
      "322:             TargetType::Url(u) => u.as_str(),",
      "323:             TargetType::Path(p) => p,",
      "324:         }",
      "328: impl From<&str> for TargetType {",
      "329:     fn from(target: &str) -> Self {",
      "330:         match url::Url::parse(target) {",
      "331:             Ok(u) => TargetType::Url(u),",
      "332:             Err(_) => TargetType::Path(target.into()),",
      "",
      "[Added Lines]",
      "314:             Ok(self.0.as_str())",
      "316:             Err(Error::new(ErrorKind::InvalidInput, \"not an http url\"))",
      "321: impl Deref for TargetType {",
      "322:     type Target = str;",
      "324:     fn deref(&self) -> &Self::Target {",
      "325:         self.0.as_str()",
      "326:     }",
      "327: }",
      "329: impl Display for TargetType {",
      "330:     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "331:         (self as &str).fmt(f)",
      "335: impl TryFrom<&str> for TargetType {",
      "336:     type Error = Error;",
      "338:     fn try_from(value: &str) -> Result<Self> {",
      "339:         match url::Url::parse(value) {",
      "340:             Ok(u) => Ok(Self(u)),",
      "341:             Err(_) => {",
      "343:                 let pb = PathBuf::from(value);",
      "344:                 let url = url::Url::from_file_path(if pb.is_relative() {",
      "345:                     std::env::current_dir()?.join(pb)",
      "346:                 } else {",
      "347:                     pb",
      "348:                 })",
      "349:                 .map_err(|_| {",
      "350:                     Error::new(ErrorKind::InvalidInput, \"failed to convert path to url\")",
      "351:                 })?;",
      "353:                 Ok(Self(url))",
      "354:             }",
      "",
      "---------------"
    ],
    "src/macos.rs||src/macos.rs": [
      "File: src/macos.rs -> src/macos.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "82:     }",
      "90:     let mut launched_app: CFURLRef = std::ptr::null_mut();",
      "91:     let status = unsafe { LSOpenFromURLSpec(&spec, &mut launched_app) };",
      "92:     log::trace!(\"received status: {}\", status);",
      "",
      "[Removed Lines]",
      "85:     log::trace!(",
      "86:         \"about to start browser: {} for {}\",",
      "87:         &browser,",
      "88:         target.as_ref()",
      "89:     );",
      "",
      "[Added Lines]",
      "85:     log::trace!(\"about to start browser: {} for {}\", &browser, &target);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "208: #[cfg(test)]",
      "209: mod tests {",
      "210:     use super::*;",
      "212:     #[test]",
      "213:     fn open_non_existing_browser() {",
      "214:         let _ = env_logger::try_init();",
      "215:         if let Err(err) = open_browser_internal(",
      "216:             Browser::Opera,",
      "218:             &BrowserOptions::default(),",
      "219:         ) {",
      "220:             assert_eq!(err.kind(), ErrorKind::NotFound);",
      "",
      "[Removed Lines]",
      "217:             &TargetType::from(\"https://github.com\"),",
      "",
      "[Added Lines]",
      "207:     use std::convert::TryFrom;",
      "214:             &TargetType::try_from(\"https://github.com\").expect(\"failed to parse url\"),",
      "",
      "---------------"
    ],
    "src/unix.rs||src/unix.rs": [
      "File: src/unix.rs -> src/unix.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "30:     options: &BrowserOptions,",
      "31: ) -> Result<()> {",
      "32:     match browser {",
      "34:         _ => Err(Error::new(",
      "35:             ErrorKind::NotFound,",
      "36:             \"only default browser supported\",",
      "",
      "[Removed Lines]",
      "33:         Browser::Default => open_browser_default(target.as_ref(), options),",
      "",
      "[Added Lines]",
      "33:         Browser::Default => open_browser_default(&target, options),",
      "",
      "---------------"
    ],
    "src/windows.rs||src/windows.rs": [
      "File: src/windows.rs -> src/windows.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "33:             static OPEN: &[u16] = &['o' as u16, 'p' as u16, 'e' as u16, 'n' as u16, 0x0000];",
      "34:             static HTTP: &[u16] = &['h' as u16, 't' as u16, 't' as u16, 'p' as u16, 0x0000];",
      "36:                 .map_err(|e| Error::new(ErrorKind::InvalidInput, e))?;",
      "37:             let code = unsafe {",
      "38:                 let coinitializeex_result = CoInitializeEx(",
      "",
      "[Removed Lines]",
      "35:             let url = U16CString::from_str(target.as_ref())",
      "",
      "[Added Lines]",
      "35:             let url = U16CString::from_str(&target)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bb23f75ce0c903ea824b3b1af57d209aa65fffcf",
      "candidate_info": {
        "commit_hash": "bb23f75ce0c903ea824b3b1af57d209aa65fffcf",
        "repo": "amodm/webbrowser-rs",
        "commit_url": "https://github.com/amodm/webbrowser-rs/commit/bb23f75ce0c903ea824b3b1af57d209aa65fffcf",
        "files": [
          ".github/workflows/linux.yaml",
          "src/windows.rs"
        ],
        "message": "fix linux and windows builds #build-linux #build-windows",
        "before_after_code_files": [
          "src/windows.rs||src/windows.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/windows.rs||src/windows.rs"
          ],
          "candidate": [
            "src/windows.rs||src/windows.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/windows.rs||src/windows.rs": [
          "File: src/windows.rs -> src/windows.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:             static OPEN: &[u16] = &['o' as u16, 'p' as u16, 'e' as u16, 'n' as u16, 0x0000];",
          "34:             static HTTP: &[u16] = &['h' as u16, 't' as u16, 't' as u16, 'p' as u16, 0x0000];",
          "36:                 .map_err(|e| Error::new(ErrorKind::InvalidInput, e))?;",
          "37:             let code = unsafe {",
          "38:                 let coinitializeex_result = CoInitializeEx(",
          "",
          "[Removed Lines]",
          "35:             let url = U16CString::from_str(&target)",
          "",
          "[Added Lines]",
          "35:             let url = U16CString::from_str(&**target)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "614cacf4a67ae0a75323768a1d70c16d792a760d",
      "candidate_info": {
        "commit_hash": "614cacf4a67ae0a75323768a1d70c16d792a760d",
        "repo": "amodm/webbrowser-rs",
        "commit_url": "https://github.com/amodm/webbrowser-rs/commit/614cacf4a67ae0a75323768a1d70c16d792a760d",
        "files": [
          "src/unix.rs"
        ],
        "message": "Bring consistent behaviour on Unix. Non-terminal browsers are guaranteed to not block the thread",
        "before_after_code_files": [
          "src/unix.rs||src/unix.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/unix.rs||src/unix.rs"
          ],
          "candidate": [
            "src/unix.rs||src/unix.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/unix.rs||src/unix.rs": [
          "File: src/unix.rs -> src/unix.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use crate::{Browser, Error, ErrorKind, Result};",
          "",
          "[Removed Lines]",
          "2: use std::os::unix::process::ExitStatusExt;",
          "3: use std::process::{Command, ExitStatus};",
          "5: mod common;",
          "6: use common::from_status;",
          "",
          "[Added Lines]",
          "2: use std::os::unix::fs::PermissionsExt;",
          "3: use std::path::PathBuf;",
          "4: use std::process::{Command, Stdio};",
          "6: macro_rules! try_browser {",
          "7:     ( $name:expr, $( $arg:expr ),+ ) => {",
          "8:         for_matching_path($name, |pb| {",
          "9:             let mut cmd = Command::new(pb);",
          "10:             $(",
          "11:                 cmd.arg($arg);",
          "12:             )+",
          "13:             run_command(&mut cmd, !is_text_browser(&pb))",
          "14:         })",
          "15:     }",
          "16: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "14: #[inline]",
          "47: }",
          "54:         if !browser.is_empty() {",
          "",
          "[Removed Lines]",
          "15: pub fn open_browser_internal(browser: Browser, url: &str) -> Result<()> {",
          "16:     from_status(open_browser_unix(browser, url))",
          "17: }",
          "19: fn open_browser_unix(browser: Browser, url: &str) -> Result<ExitStatus> {",
          "20:     match browser {",
          "21:         Browser::Default => open_on_unix_using_browser_env(url)",
          "22:             .or_else(|_| -> Result<ExitStatus> { Command::new(\"xdg-open\").arg(url).status() })",
          "23:             .or_else(|r| -> Result<ExitStatus> {",
          "24:                 if let Ok(desktop) = ::std::env::var(\"XDG_CURRENT_DESKTOP\") {",
          "25:                     if desktop == \"KDE\" {",
          "26:                         return Command::new(\"kioclient\").arg(\"exec\").arg(url).status();",
          "27:                     }",
          "28:                 }",
          "29:                 Err(r) // If either `if` check fails, fall through to the next or_else",
          "30:             })",
          "31:             .or_else(|_| -> Result<ExitStatus> { Command::new(\"gvfs-open\").arg(url).status() })",
          "32:             .or_else(|_| -> Result<ExitStatus> { Command::new(\"gnome-open\").arg(url).status() })",
          "33:             .or_else(|_| -> Result<ExitStatus> {",
          "34:                 Command::new(\"kioclient\").arg(\"exec\").arg(url).status()",
          "35:             })",
          "36:             .or_else(|e| -> Result<ExitStatus> {",
          "37:                 if let Ok(_child) = Command::new(\"x-www-browser\").arg(url).spawn() {",
          "38:                     return Ok(ExitStatusExt::from_raw(0));",
          "39:                 }",
          "40:                 Err(e)",
          "41:             }),",
          "42:         _ => Err(Error::new(",
          "43:             ErrorKind::NotFound,",
          "44:             \"Only the default browser is supported on this platform right now\",",
          "45:         )),",
          "46:     }",
          "49: fn open_on_unix_using_browser_env(url: &str) -> Result<ExitStatus> {",
          "50:     let browsers = ::std::env::var(\"BROWSER\")",
          "51:         .map_err(|_| -> Error { Error::new(ErrorKind::NotFound, \"BROWSER env not set\") })?;",
          "52:     for browser in browsers.split(':') {",
          "",
          "[Added Lines]",
          "25: pub fn open_browser_internal(_: Browser, url: &str) -> Result<()> {",
          "27:     try_with_browser_env(url)",
          "29:         .or_else(|_| try_browser!(\"xdg-open\", url))",
          "31:         .or_else(|r| {",
          "33:             let desktop_env: String = std::env::var(\"XDG_CURRENT_DESKTOP\")",
          "34:                 .unwrap_or_else(|_| String::from(\"unknown\"))",
          "35:                 .to_ascii_uppercase();",
          "36:             match desktop_env.as_str() {",
          "37:                 \"KDE\" => try_browser!(\"kde-open\", url).or_else(|_| try_browser!(\"kde-open5\", url)),",
          "38:                 \"GNOME\" | \"CINNAMON\" => try_browser!(\"gio\", \"open\", url)",
          "39:                     .or_else(|_| try_browser!(\"gvfs-open\", url))",
          "40:                     .or_else(|_| try_browser!(\"gnome-open\", url)),",
          "41:                 \"MATE\" => try_browser!(\"gio\", \"open\", url)",
          "42:                     .or_else(|_| try_browser!(\"gvfs-open\", url))",
          "43:                     .or_else(|_| try_browser!(\"mate-open\", url)),",
          "44:                 \"XFCE\" => try_browser!(\"exo-open\", url)",
          "45:                     .or_else(|_| try_browser!(\"gio\", \"open\", url))",
          "46:                     .or_else(|_| try_browser!(\"gvfs-open\", url)),",
          "47:                 _ => Err(r),",
          "48:             }",
          "49:         })",
          "51:         .or_else(|_| try_browser!(\"x-www-browser\", url))",
          "53:         .and_then(|_| Ok(()))",
          "54:         .or_else(|_| {",
          "55:             Err(Error::new(",
          "56:                 ErrorKind::NotFound,",
          "57:                 \"No valid browsers detected. You can specify one in BROWSERS environment variable\",",
          "58:             ))",
          "59:         })",
          "62: #[inline]",
          "63: fn try_with_browser_env(url: &str) -> Result<()> {",
          "65:     for browser in std::env::var(\"BROWSER\")",
          "66:         .unwrap_or_else(|_| String::from(\"\"))",
          "67:         .split(':')",
          "68:     {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "58:                 .replace(\"%s\", url)",
          "59:                 .replace(\"%c\", \":\")",
          "60:                 .replace(\"%%\", \"%\");",
          "72:             }",
          "73:         }",
          "74:     }",
          "75:     Err(Error::new(",
          "76:         ErrorKind::NotFound,",
          "78:     ))",
          "79: }",
          "",
          "[Removed Lines]",
          "61:             let cmdarr: Vec<&str> = cmdline.split_whitespace().collect();",
          "62:             let mut cmd = Command::new(&cmdarr[0]);",
          "63:             if cmdarr.len() > 1 {",
          "64:                 cmd.args(&cmdarr[1..cmdarr.len()]);",
          "65:             }",
          "66:             if !browser.contains(\"%s\") {",
          "68:                 cmd.arg(url);",
          "69:             }",
          "70:             if let Ok(status) = cmd.status() {",
          "71:                 return Ok(status);",
          "77:         \"No valid command in $BROWSER\",",
          "",
          "[Added Lines]",
          "76:             let cmdarr: Vec<&str> = cmdline.split_ascii_whitespace().collect();",
          "77:             let browser_cmd = cmdarr[0];",
          "78:             let env_exit = for_matching_path(browser_cmd, |pb| {",
          "79:                 let mut cmd = Command::new(pb);",
          "80:                 for i in 1..cmdarr.len() {",
          "81:                     cmd.arg(cmdarr[i]);",
          "82:                 }",
          "83:                 if !browser.contains(\"%s\") {",
          "85:                     cmd.arg(url);",
          "86:                 }",
          "87:                 run_command(&mut cmd, !is_text_browser(&pb))",
          "88:             });",
          "89:             if env_exit.is_ok() {",
          "90:                 return Ok(());",
          "96:         \"No valid browser configured in BROWSER environment variable\",",
          "101: #[inline]",
          "102: fn is_text_browser(pb: &PathBuf) -> bool {",
          "103:     for browser in TEXT_BROWSERS.iter() {",
          "104:         if pb.ends_with(&browser) {",
          "105:             return true;",
          "106:         }",
          "107:     }",
          "108:     false",
          "109: }",
          "111: #[inline]",
          "112: fn for_matching_path<F>(name: &str, op: F) -> Result<()>",
          "113: where",
          "114:     F: FnOnce(&PathBuf) -> Result<()>,",
          "115: {",
          "116:     let err = Err(Error::new(ErrorKind::NotFound, \"command not found\"));",
          "120:     if name.contains(std::path::MAIN_SEPARATOR) {",
          "121:         let pb = std::path::PathBuf::from(name);",
          "122:         if let Ok(metadata) = pb.metadata() {",
          "123:             if metadata.is_file() && metadata.permissions().mode() & 0o111 != 0 {",
          "124:                 return op(&pb);",
          "125:             }",
          "126:         } else {",
          "127:             return err;",
          "128:         }",
          "129:     } else {",
          "131:         if let Ok(path) = std::env::var(\"PATH\") {",
          "132:             for entry in path.split(\":\") {",
          "133:                 let mut pb = std::path::PathBuf::from(entry);",
          "134:                 pb.push(name);",
          "135:                 if let Ok(metadata) = pb.metadata() {",
          "136:                     if metadata.is_file() && metadata.permissions().mode() & 0o111 != 0 {",
          "137:                         return op(&pb);",
          "138:                     }",
          "139:                 }",
          "140:             }",
          "141:         }",
          "142:     }",
          "144:     err",
          "145: }",
          "148: #[inline]",
          "149: fn run_command(cmd: &mut Command, background: bool) -> Result<()> {",
          "150:     if background {",
          "153:         cmd.stdin(Stdio::null())",
          "154:             .stdout(Stdio::null())",
          "155:             .stderr(Stdio::null())",
          "156:             .spawn()",
          "157:             .and_then(|_| Ok(()))",
          "158:     } else {",
          "161:         cmd.status().and_then(|status| {",
          "162:             if status.success() {",
          "163:                 Ok(())",
          "164:             } else {",
          "165:                 Err(Error::new(",
          "166:                     ErrorKind::Other,",
          "167:                     \"command present but exited unsuccessfully\",",
          "168:                 ))",
          "169:             }",
          "170:         })",
          "171:     }",
          "172: }",
          "174: static TEXT_BROWSERS: [&'static str; 9] = [",
          "175:     \"lynx\", \"links\", \"links2\", \"elinks\", \"w3m\", \"eww\", \"netrik\", \"retawq\", \"curl\",",
          "176: ];",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1ac45cba6d57b535a2ac92a0bd01f8e13dd1eed1",
      "candidate_info": {
        "commit_hash": "1ac45cba6d57b535a2ac92a0bd01f8e13dd1eed1",
        "repo": "amodm/webbrowser-rs",
        "commit_url": "https://github.com/amodm/webbrowser-rs/commit/1ac45cba6d57b535a2ac92a0bd01f8e13dd1eed1",
        "files": [
          "src/unix.rs"
        ],
        "message": "delete unrelevant open command for unix",
        "before_after_code_files": [
          "src/unix.rs||src/unix.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/unix.rs||src/unix.rs"
          ],
          "candidate": [
            "src/unix.rs||src/unix.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/unix.rs||src/unix.rs": [
          "File: src/unix.rs -> src/unix.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:             })",
          "24:             .or_else(|_| -> Result<ExitStatus> { Command::new(\"gvfs-open\").arg(url).status() })",
          "25:             .or_else(|_| -> Result<ExitStatus> { Command::new(\"gnome-open\").arg(url).status() })",
          "27:             .or_else(|_| -> Result<ExitStatus> {",
          "28:                 Command::new(\"kioclient\").arg(\"exec\").arg(url).status()",
          "29:             })",
          "",
          "[Removed Lines]",
          "26:             .or_else(|_| -> Result<ExitStatus> { Command::new(\"open\").arg(url).status() })",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7e881f823e55ef70e8cd6d9ea08c938897aac682",
      "candidate_info": {
        "commit_hash": "7e881f823e55ef70e8cd6d9ea08c938897aac682",
        "repo": "amodm/webbrowser-rs",
        "commit_url": "https://github.com/amodm/webbrowser-rs/commit/7e881f823e55ef70e8cd6d9ea08c938897aac682",
        "files": [
          "src/android.rs",
          "src/ios.rs",
          "src/lib.rs",
          "src/macos.rs",
          "src/unix.rs",
          "src/wasm.rs",
          "src/windows.rs"
        ],
        "message": "refactor TargetType",
        "before_after_code_files": [
          "src/android.rs||src/android.rs",
          "src/ios.rs||src/ios.rs",
          "src/lib.rs||src/lib.rs",
          "src/macos.rs||src/macos.rs",
          "src/unix.rs||src/unix.rs",
          "src/wasm.rs||src/wasm.rs",
          "src/windows.rs||src/windows.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib.rs||src/lib.rs",
            "src/macos.rs||src/macos.rs",
            "src/unix.rs||src/unix.rs",
            "src/windows.rs||src/windows.rs"
          ],
          "candidate": [
            "src/lib.rs||src/lib.rs",
            "src/macos.rs||src/macos.rs",
            "src/unix.rs||src/unix.rs",
            "src/windows.rs||src/windows.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/android.rs||src/android.rs": [
          "File: src/android.rs -> src/android.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "10:     options: &BrowserOptions,",
          "11: ) -> Result<()> {",
          "15:     match browser {",
          "16:         Browser::Default => open_browser_default(url, options),",
          "",
          "[Removed Lines]",
          "13:     let url = crate::get_http_url(target)?;",
          "",
          "[Added Lines]",
          "13:     let url = target.get_http_url()?;",
          "",
          "---------------"
        ],
        "src/ios.rs||src/ios.rs": [
          "File: src/ios.rs -> src/ios.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "8:     options: &BrowserOptions,",
          "9: ) -> Result<()> {",
          "14:     if options.dry_run {",
          "",
          "[Removed Lines]",
          "11:     let url = crate::get_http_url(target)?;",
          "",
          "[Added Lines]",
          "11:     let url = target.get_http_url()?;",
          "",
          "---------------"
        ],
        "src/lib.rs||src/lib.rs": [
          "File: src/lib.rs -> src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "294:     Path(String),",
          "295: }",
          "308:     }",
          "309: }",
          "",
          "[Removed Lines]",
          "299: #[cfg(any(target_os = \"android\", target_os = \"ios\", target_family = \"wasm\"))]",
          "300: #[inline]",
          "301: pub(crate) fn get_http_url(target: &TargetType) -> Result<&str> {",
          "302:     match target {",
          "303:         TargetType::Url(u) => match u.scheme() {",
          "304:             \"http\" | \"https\" => Ok(u.as_str()),",
          "305:             _ => Err(Error::new(ErrorKind::InvalidInput, \"not a valid url\")),",
          "306:         },",
          "307:         _ => Err(Error::new(ErrorKind::InvalidInput, \"not a valid url\")),",
          "",
          "[Added Lines]",
          "297: impl TargetType {",
          "299:     #[cfg(any(target_os = \"android\", target_os = \"ios\", target_family = \"wasm\"))]",
          "300:     fn is_http(&self) -> bool {",
          "301:         match self {",
          "302:             Self::Url(u) => match u.scheme() {",
          "303:                 \"http\" | \"https\" => true,",
          "304:                 _ => false,",
          "305:             },",
          "306:             _ => false,",
          "307:         }",
          "308:     }",
          "312:     #[cfg(any(target_os = \"android\", target_os = \"ios\", target_family = \"wasm\"))]",
          "313:     fn get_http_url(&self) -> Result<&str> {",
          "314:         if self.is_http() {",
          "315:             Ok(self.as_ref())",
          "316:         } else {",
          "317:             Err(Error::new(ErrorKind::InvalidInput, \"not a valid url\"))",
          "318:         }",
          "319:     }",
          "320: }",
          "322: impl AsRef<str> for TargetType {",
          "323:     fn as_ref(&self) -> &str {",
          "324:         match self {",
          "325:             TargetType::Url(u) => u.as_str(),",
          "326:             TargetType::Path(p) => p,",
          "327:         }",
          "",
          "---------------"
        ],
        "src/macos.rs||src/macos.rs": [
          "File: src/macos.rs -> src/macos.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "10:     target: &TargetType,",
          "11:     options: &BrowserOptions,",
          "12: ) -> Result<()> {",
          "18:     let mut cmd = Command::new(\"open\");",
          "19:     match browser {",
          "20:         Browser::Default => {",
          "",
          "[Removed Lines]",
          "13:     let url = match target {",
          "14:         TargetType::Url(u) => u.as_str(),",
          "15:         TargetType::Path(s) => s.as_str(),",
          "16:     };",
          "",
          "[Added Lines]",
          "13:     let url = target.as_ref();",
          "",
          "---------------"
        ],
        "src/unix.rs||src/unix.rs": [
          "File: src/unix.rs -> src/unix.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:     target: &TargetType,",
          "30:     options: &BrowserOptions,",
          "31: ) -> Result<()> {",
          "37:     match browser {",
          "39:         _ => Err(Error::new(",
          "40:             ErrorKind::NotFound,",
          "41:             \"only default browser supported\",",
          "",
          "[Removed Lines]",
          "32:     let url = match target {",
          "33:         TargetType::Url(u) => u.as_str(),",
          "34:         TargetType::Path(s) => s.as_str(),",
          "35:     };",
          "38:         Browser::Default => open_browser_default(url, options),",
          "",
          "[Added Lines]",
          "33:         Browser::Default => open_browser_default(target.as_ref(), options),",
          "",
          "---------------"
        ],
        "src/wasm.rs||src/wasm.rs": [
          "File: src/wasm.rs -> src/wasm.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "8:     options: &BrowserOptions,",
          "9: ) -> Result<()> {",
          "14:     if options.dry_run {",
          "",
          "[Removed Lines]",
          "11:     let url = crate::get_http_url(target)?;",
          "",
          "[Added Lines]",
          "11:     let url = target.get_http_url()?;",
          "",
          "---------------"
        ],
        "src/windows.rs||src/windows.rs": [
          "File: src/windows.rs -> src/windows.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:     target: &TargetType,",
          "24:     options: &BrowserOptions,",
          "25: ) -> Result<()> {",
          "31:     match browser {",
          "32:         Browser::Default => {",
          "",
          "[Removed Lines]",
          "26:     let url = match target {",
          "27:         TargetType::Url(u) => u.as_str(),",
          "28:         TargetType::Path(s) => s.as_str(),",
          "29:     };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38:             static OPEN: &[u16] = &['o' as u16, 'p' as u16, 'e' as u16, 'n' as u16, 0x0000];",
          "39:             static HTTP: &[u16] = &['h' as u16, 't' as u16, 't' as u16, 'p' as u16, 0x0000];",
          "42:             let code = unsafe {",
          "43:                 let coinitializeex_result = CoInitializeEx(",
          "44:                     ptr::null_mut(),",
          "",
          "[Removed Lines]",
          "40:             let url =",
          "41:                 U16CString::from_str(url).map_err(|e| Error::new(ErrorKind::InvalidInput, e))?;",
          "",
          "[Added Lines]",
          "35:             let url = U16CString::from_str(target.as_ref())",
          "36:                 .map_err(|e| Error::new(ErrorKind::InvalidInput, e))?;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "68161a5c3ef7dc9fa3314b1f291d65c05ef46db4",
      "candidate_info": {
        "commit_hash": "68161a5c3ef7dc9fa3314b1f291d65c05ef46db4",
        "repo": "amodm/webbrowser-rs",
        "commit_url": "https://github.com/amodm/webbrowser-rs/commit/68161a5c3ef7dc9fa3314b1f291d65c05ef46db4",
        "files": [
          "src/lib.rs"
        ],
        "message": "fix wasm build #build-wasm",
        "before_after_code_files": [
          "src/lib.rs||src/lib.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib.rs||src/lib.rs"
          ],
          "candidate": [
            "src/lib.rs||src/lib.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/lib.rs||src/lib.rs": [
          "File: src/lib.rs -> src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "339:         match url::Url::parse(value) {",
          "340:             Ok(u) => Ok(Self(u)),",
          "341:             Err(_) => {",
          "346:                 } else {",
          "354:             }",
          "355:         }",
          "356:     }",
          "",
          "[Removed Lines]",
          "343:                 let pb = PathBuf::from(value);",
          "344:                 let url = url::Url::from_file_path(if pb.is_relative() {",
          "345:                     std::env::current_dir()?.join(pb)",
          "347:                     pb",
          "348:                 })",
          "349:                 .map_err(|_| {",
          "350:                     Error::new(ErrorKind::InvalidInput, \"failed to convert path to url\")",
          "351:                 })?;",
          "353:                 Ok(Self(url))",
          "",
          "[Added Lines]",
          "342:                 if cfg!(target_family = \"wasm\") {",
          "343:                     Err(Error::new(ErrorKind::InvalidInput, \"invalid url for wasm\"))",
          "346:                     let pb = PathBuf::from(value);",
          "347:                     let url = url::Url::from_file_path(if pb.is_relative() {",
          "348:                         std::env::current_dir()?.join(pb)",
          "349:                     } else {",
          "350:                         pb",
          "351:                     })",
          "352:                     .map_err(|_| {",
          "353:                         Error::new(ErrorKind::InvalidInput, \"failed to convert path to url\")",
          "354:                     })?;",
          "356:                     Ok(Self(url))",
          "357:                 }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
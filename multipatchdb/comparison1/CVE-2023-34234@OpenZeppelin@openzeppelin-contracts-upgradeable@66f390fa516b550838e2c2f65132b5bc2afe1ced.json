{
  "cve_id": "CVE-2023-34234",
  "cve_desc": " OpenZeppelin Contracts is a library for smart contract development. By frontrunning the creation of a proposal, an attacker can become the proposer and gain the ability to cancel it. The attacker can do this repeatedly to try to prevent a proposal from being proposed at all. This impacts the `Governor` contract in v4.9.0 only, and the `GovernorCompatibilityBravo` contract since v4.3.0. This problem has been patched in 4.9.1 by introducing opt-in frontrunning protection. Users are advised to upgrade. Users unable to upgrade may submit the proposal creation transaction to an endpoint with frontrunning protection as a workaround.",
  "repo": "OpenZeppelin/openzeppelin-contracts-upgradeable",
  "patch_hash": "66f390fa516b550838e2c2f65132b5bc2afe1ced",
  "patch_info": {
    "commit_hash": "66f390fa516b550838e2c2f65132b5bc2afe1ced",
    "repo": "OpenZeppelin/openzeppelin-contracts-upgradeable",
    "commit_url": "https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/commit/66f390fa516b550838e2c2f65132b5bc2afe1ced",
    "files": [
      ".changeset/swift-bags-divide.md",
      "contracts/governance/GovernorUpgradeable.sol",
      "test/governance/Governor.t.sol",
      "test/governance/Governor.test.js"
    ],
    "message": "Transpile 33ff9b08",
    "before_after_code_files": [
      "contracts/governance/GovernorUpgradeable.sol||contracts/governance/GovernorUpgradeable.sol",
      "test/governance/Governor.t.sol||test/governance/Governor.t.sol",
      "test/governance/Governor.test.js||test/governance/Governor.test.js"
    ]
  },
  "patch_diff": {
    "contracts/governance/GovernorUpgradeable.sol||contracts/governance/GovernorUpgradeable.sol": [
      "File: contracts/governance/GovernorUpgradeable.sol -> contracts/governance/GovernorUpgradeable.sol",
      "--- Hunk 1 ---",
      "[Context before]",
      "278:         string memory description",
      "279:     ) public virtual override returns (uint256) {",
      "280:         address proposer = _msgSender();",
      "283:         require(",
      "284:             getVotes(proposer, currentTimepoint - 1) >= proposalThreshold(),",
      "285:             \"Governor: proposer votes below proposal threshold\"",
      "",
      "[Removed Lines]",
      "281:         uint256 currentTimepoint = clock();",
      "",
      "[Added Lines]",
      "281:         require(_isValidDescriptionForProposer(proposer, description), \"Governor: proposer restricted\");",
      "283:         uint256 currentTimepoint = clock();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "641:         return this.onERC1155BatchReceived.selector;",
      "642:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "662:     function _isValidDescriptionForProposer(",
      "663:         address proposer,",
      "664:         string memory description",
      "665:     ) internal view virtual returns (bool) {",
      "666:         uint256 len = bytes(description).length;",
      "669:         if (len < 52) {",
      "670:             return true;",
      "671:         }",
      "674:         bytes12 marker;",
      "675:         assembly {",
      "682:             marker := mload(add(description, sub(len, 20)))",
      "683:         }",
      "686:         if (marker != bytes12(\"#proposer=0x\")) {",
      "687:             return true;",
      "688:         }",
      "691:         uint160 recovered = 0;",
      "692:         for (uint256 i = len - 40; i < len; ++i) {",
      "693:             (bool isHex, uint8 value) = _tryHexToUint(bytes(description)[i]);",
      "695:             if (!isHex) {",
      "696:                 return true;",
      "697:             }",
      "698:             recovered = (recovered << 4) | value;",
      "699:         }",
      "701:         return recovered == uint160(proposer);",
      "702:     }",
      "708:     function _tryHexToUint(bytes1 char) private pure returns (bool, uint8) {",
      "709:         uint8 c = uint8(char);",
      "710:         unchecked {",
      "712:             if (47 < c && c < 58) {",
      "713:                 return (true, c - 48);",
      "714:             }",
      "716:             else if (64 < c && c < 71) {",
      "717:                 return (true, c - 55);",
      "718:             }",
      "720:             else if (96 < c && c < 103) {",
      "721:                 return (true, c - 87);",
      "722:             }",
      "724:             else {",
      "725:                 return (false, 0);",
      "726:             }",
      "727:         }",
      "728:     }",
      "",
      "---------------"
    ],
    "test/governance/Governor.t.sol||test/governance/Governor.t.sol": [
      "File: test/governance/Governor.t.sol -> test/governance/Governor.t.sol",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3: pragma solidity ^0.8.19;",
      "5: import \"forge-std/Test.sol\";",
      "6: import \"../../contracts/utils/Strings.sol\";",
      "7: import \"../../contracts/governance/Governor.sol\";",
      "9: contract GovernorInternalTest is Test, Governor {",
      "10:     constructor() Governor(\"\") {}",
      "12:     function testValidDescriptionForProposer(string memory description, address proposer, bool includeProposer) public {",
      "13:         if (includeProposer) {",
      "14:             description = string.concat(description, \"#proposer=\", Strings.toHexString(proposer));",
      "15:         }",
      "16:         assertTrue(_isValidDescriptionForProposer(proposer, description));",
      "17:     }",
      "19:     function testInvalidDescriptionForProposer(",
      "20:         string memory description,",
      "21:         address commitProposer,",
      "22:         address actualProposer",
      "23:     ) public {",
      "24:         vm.assume(commitProposer != actualProposer);",
      "25:         description = string.concat(description, \"#proposer=\", Strings.toHexString(commitProposer));",
      "26:         assertFalse(_isValidDescriptionForProposer(actualProposer, description));",
      "27:     }",
      "32:     function clock() public pure override returns (uint48) {}",
      "35:     function CLOCK_MODE() public pure override returns (string memory) {}",
      "38:     function COUNTING_MODE() public pure virtual override returns (string memory) {}",
      "40:     function votingDelay() public pure virtual override returns (uint256) {}",
      "42:     function votingPeriod() public pure virtual override returns (uint256) {}",
      "44:     function quorum(uint256) public pure virtual override returns (uint256) {}",
      "46:     function hasVoted(uint256, address) public pure virtual override returns (bool) {}",
      "48:     function _quorumReached(uint256) internal pure virtual override returns (bool) {}",
      "50:     function _voteSucceeded(uint256) internal pure virtual override returns (bool) {}",
      "52:     function _getVotes(address, uint256, bytes memory) internal pure virtual override returns (uint256) {}",
      "54:     function _countVote(uint256, address, uint8, uint256, bytes memory) internal virtual override {}",
      "55: }",
      "",
      "---------------"
    ],
    "test/governance/Governor.test.js||test/governance/Governor.test.js": [
      "File: test/governance/Governor.test.js -> test/governance/Governor.test.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "544:         });",
      "545:       });",
      "547:       describe('onlyGovernance updates', function () {",
      "548:         it('setVotingDelay is protected', async function () {",
      "549:           await expectRevert(this.mock.setVotingDelay('0'), 'Governor: onlyGovernance');",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "547:       describe('frontrun protection using description suffix', function () {",
      "548:         describe('without protection', function () {",
      "549:           describe('without suffix', function () {",
      "550:             it('proposer can propose', async function () {",
      "551:               expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
      "552:             });",
      "554:             it('someone else can propose', async function () {",
      "555:               expectEvent(await this.helper.propose({ from: voter1 }), 'ProposalCreated');",
      "556:             });",
      "557:           });",
      "559:           describe('with different suffix', function () {",
      "560:             beforeEach(async function () {",
      "561:               this.proposal = this.helper.setProposal(",
      "562:                 [",
      "563:                   {",
      "564:                     target: this.receiver.address,",
      "565:                     data: this.receiver.contract.methods.mockFunction().encodeABI(),",
      "566:                     value,",
      "567:                   },",
      "568:                 ],",
      "569:                 `<proposal description>#wrong-suffix=${proposer}`,",
      "570:               );",
      "571:             });",
      "573:             it('proposer can propose', async function () {",
      "574:               expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
      "575:             });",
      "577:             it('someone else can propose', async function () {",
      "578:               expectEvent(await this.helper.propose({ from: voter1 }), 'ProposalCreated');",
      "579:             });",
      "580:           });",
      "582:           describe('with proposer suffix but bad address part', function () {",
      "583:             beforeEach(async function () {",
      "584:               this.proposal = this.helper.setProposal(",
      "585:                 [",
      "586:                   {",
      "587:                     target: this.receiver.address,",
      "588:                     data: this.receiver.contract.methods.mockFunction().encodeABI(),",
      "589:                     value,",
      "590:                   },",
      "591:                 ],",
      "592:                 `<proposal description>#proposer=0x3C44CdDdB6a900fa2b585dd299e03d12FA429XYZ`, // XYZ are not a valid hex char",
      "593:               );",
      "594:             });",
      "596:             it('propose can propose', async function () {",
      "597:               expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
      "598:             });",
      "600:             it('someone else can propose', async function () {",
      "601:               expectEvent(await this.helper.propose({ from: voter1 }), 'ProposalCreated');",
      "602:             });",
      "603:           });",
      "604:         });",
      "606:         describe('with protection via proposer suffix', function () {",
      "607:           beforeEach(async function () {",
      "608:             this.proposal = this.helper.setProposal(",
      "609:               [",
      "610:                 {",
      "611:                   target: this.receiver.address,",
      "612:                   data: this.receiver.contract.methods.mockFunction().encodeABI(),",
      "613:                   value,",
      "614:                 },",
      "615:               ],",
      "616:               `<proposal description>#proposer=${proposer}`,",
      "617:             );",
      "618:           });",
      "620:           it('proposer can propose', async function () {",
      "621:             expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
      "622:           });",
      "624:           it('someone else cannot propose', async function () {",
      "625:             await expectRevert(this.helper.propose({ from: voter1 }), 'Governor: proposer restricted');",
      "626:           });",
      "627:         });",
      "628:       });",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b53fccbcb9bdabfb4df2c6af6155436127262018",
      "candidate_info": {
        "commit_hash": "b53fccbcb9bdabfb4df2c6af6155436127262018",
        "repo": "OpenZeppelin/openzeppelin-contracts-upgradeable",
        "commit_url": "https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/commit/b53fccbcb9bdabfb4df2c6af6155436127262018",
        "files": [],
        "message": "Transpile 43eb8d12",
        "before_after_code_files": [
          ".mocharc.js||.mocharc.js",
          ".solcover.js||.solcover.js",
          "certorharnesses/AccessControlDefaultAdminRulesHarness.sol||certora/harnesses/AccessControlDefaultAdminRulesHarness.sol",
          "certorharnesses/AccessControlHarness.sol||certora/harnesses/AccessControlHarness.sol",
          "certorharnesses/DoubleEndedQueueHarness.sol||certora/harnesses/DoubleEndedQueueHarness.sol",
          "certorharnesses/ERC20FlashMintHarness.sol||certora/harnesses/ERC20FlashMintHarness.sol",
          "certorharnesses/ERC20PermitHarness.sol||certora/harnesses/ERC20PermitHarness.sol",
          "certorharnesses/ERC20WrapperHarness.sol||certora/harnesses/ERC20WrapperHarness.sol",
          "certorharnesses/ERC3156FlashBorrowerHarness.sol||certora/harnesses/ERC3156FlashBorrowerHarness.sol",
          "certorharnesses/ERC721Harness.sol||certora/harnesses/ERC721Harness.sol",
          "certorharnesses/ERC721ReceiverHarness.sol||certora/harnesses/ERC721ReceiverHarness.sol",
          "certorharnesses/EnumerableMapHarness.sol||certora/harnesses/EnumerableMapHarness.sol",
          "certorharnesses/EnumerableSetHarness.sol||certora/harnesses/EnumerableSetHarness.sol",
          "certorharnesses/InitializableHarness.sol||certora/harnesses/InitializableHarness.sol",
          "certorharnesses/Ownable2StepHarness.sol||certora/harnesses/Ownable2StepHarness.sol",
          "certorharnesses/OwnableHarness.sol||certora/harnesses/OwnableHarness.sol",
          "certorharnesses/PausableHarness.sol||certora/harnesses/PausableHarness.sol",
          "certorharnesses/TimelockControllerHarness.sol||certora/harnesses/TimelockControllerHarness.sol",
          "certorrun.js||certora/run.js",
          "certorspecs/AccessControl.spec||certora/specs/AccessControl.spec",
          "certorspecs/AccessControlDefaultAdminRules.spec||certora/specs/AccessControlDefaultAdminRules.spec",
          "certorspecs/DoubleEndedQueue.spec||certora/specs/DoubleEndedQueue.spec",
          "certorspecs/ERC20.spec||certora/specs/ERC20.spec",
          "certorspecs/ERC20FlashMint.spec||certora/specs/ERC20FlashMint.spec",
          "certorspecs/ERC20Wrapper.spec||certora/specs/ERC20Wrapper.spec",
          "certorspecs/ERC721.spec||certora/specs/ERC721.spec",
          "certorspecs/EnumerableMap.spec||certora/specs/EnumerableMap.spec",
          "certorspecs/EnumerableSet.spec||certora/specs/EnumerableSet.spec",
          "certorspecs/Initializable.spec||certora/specs/Initializable.spec",
          "certorspecs/Ownable.spec||certora/specs/Ownable.spec",
          "certorspecs/Ownable2Step.spec||certora/specs/Ownable2Step.spec",
          "certorspecs/Pausable.spec||certora/specs/Pausable.spec",
          "certorspecs/TimelockController.spec||certora/specs/TimelockController.spec",
          "certorspecs/helpers/helpers.spec||certora/specs/helpers/helpers.spec",
          "certorspecs/methods/IAccessControl.spec||certora/specs/methods/IAccessControl.spec",
          "certorspecs/methods/IAccessControlDefaultAdminRules.spec||certora/specs/methods/IAccessControlDefaultAdminRules.spec",
          "certorspecs/methods/IERC20.spec||certora/specs/methods/IERC20.spec",
          "certorspecs/methods/IERC2612.spec||certora/specs/methods/IERC2612.spec",
          "certorspecs/methods/IERC3156.spec||certora/specs/methods/IERC3156.spec",
          "certorspecs/methods/IERC5313.spec||certora/specs/methods/IERC5313.spec",
          "certorspecs/methods/IERC721.spec||certora/specs/methods/IERC721.spec",
          "certorspecs/methods/IOwnable.spec||certora/specs/methods/IOwnable.spec",
          "certorspecs/methods/IOwnable2Step.spec||certora/specs/methods/IOwnable2Step.spec",
          "contracts/access/AccessControlCrossChainUpgradeable.sol||contracts/access/AccessControlCrossChainUpgradeable.sol",
          "contracts/access/AccessControlDefaultAdminRulesUpgradeable.sol||contracts/access/AccessControlDefaultAdminRulesUpgradeable.sol",
          "contracts/access/AccessControlEnumerableUpgradeable.sol||contracts/access/AccessControlEnumerableUpgradeable.sol",
          "contracts/access/AccessControlUpgradeable.sol||contracts/access/AccessControlUpgradeable.sol",
          "contracts/access/IAccessControlDefaultAdminRulesUpgradeable.sol||contracts/access/IAccessControlDefaultAdminRulesUpgradeable.sol",
          "contracts/access/IAccessControlEnumerableUpgradeable.sol||contracts/access/IAccessControlEnumerableUpgradeable.sol",
          "contracts/access/IAccessControlUpgradeable.sol||contracts/access/IAccessControlUpgradeable.sol",
          "contracts/access/Ownable2StepUpgradeable.sol||contracts/access/Ownable2StepUpgradeable.sol",
          "contracts/access/OwnableUpgradeable.sol||contracts/access/OwnableUpgradeable.sol",
          "contracts/crosschain/CrossChainEnabledUpgradeable.sol||contracts/crosschain/CrossChainEnabledUpgradeable.sol",
          "contracts/crosschain/amb/CrossChainEnabledAMBUpgradeable.sol||contracts/crosschain/amCrossChainEnabledAMBUpgradeable.sol",
          "contracts/crosschain/amb/LibAMBUpgradeable.sol||contracts/crosschain/amLibAMBUpgradeable.sol",
          "contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL1Upgradeable.sol||contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL1Upgradeable.sol",
          "contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL2Upgradeable.sol||contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL2Upgradeable.sol",
          "contracts/crosschain/arbitrum/LibArbitrumL1Upgradeable.sol||contracts/crosschain/arbitrum/LibArbitrumL1Upgradeable.sol",
          "contracts/crosschain/arbitrum/LibArbitrumL2Upgradeable.sol||contracts/crosschain/arbitrum/LibArbitrumL2Upgradeable.sol",
          "contracts/crosschain/errorsUpgradeable.sol||contracts/crosschain/errorsUpgradeable.sol",
          "contracts/crosschain/optimism/CrossChainEnabledOptimismUpgradeable.sol||contracts/crosschain/optimism/CrossChainEnabledOptimismUpgradeable.sol",
          "contracts/crosschain/optimism/LibOptimismUpgradeable.sol||contracts/crosschain/optimism/LibOptimismUpgradeable.sol",
          "contracts/crosschain/polygon/CrossChainEnabledPolygonChildUpgradeable.sol||contracts/crosschain/polygon/CrossChainEnabledPolygonChildUpgradeable.sol",
          "contracts/finance/PaymentSplitterUpgradeable.sol||contracts/finance/PaymentSplitterUpgradeable.sol",
          "contracts/finance/VestingWalletUpgradeable.sol||contracts/finance/VestingWalletUpgradeable.sol",
          "contracts/governance/GovernorUpgradeable.sol||contracts/governance/GovernorUpgradeable.sol",
          "contracts/governance/IGovernorUpgradeable.sol||contracts/governance/IGovernorUpgradeable.sol",
          "contracts/governance/TimelockControllerUpgradeable.sol||contracts/governance/TimelockControllerUpgradeable.sol",
          "contracts/governance/TimelockControllerWith46MigrationUpgradeable.sol||contracts/governance/TimelockControllerWith46MigrationUpgradeable.sol",
          "contracts/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol||contracts/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol",
          "contracts/governance/compatibility/IGovernorCompatibilityBravoUpgradeable.sol||contracts/governance/compatibility/IGovernorCompatibilityBravoUpgradeable.sol",
          "contracts/governance/extensions/GovernorCountingSimpleUpgradeable.sol||contracts/governance/extensions/GovernorCountingSimpleUpgradeable.sol",
          "contracts/governance/extensions/GovernorPreventLateQuorumUpgradeable.sol||contracts/governance/extensions/GovernorPreventLateQuorumUpgradeable.sol",
          "contracts/governance/extensions/GovernorProposalThresholdUpgradeable.sol||contracts/governance/extensions/GovernorProposalThresholdUpgradeable.sol",
          "contracts/governance/extensions/GovernorSettingsUpgradeable.sol||contracts/governance/extensions/GovernorSettingsUpgradeable.sol",
          "contracts/governance/extensions/GovernorTimelockCompoundUpgradeable.sol||contracts/governance/extensions/GovernorTimelockCompoundUpgradeable.sol",
          "contracts/governance/extensions/GovernorTimelockControlUpgradeable.sol||contracts/governance/extensions/GovernorTimelockControlUpgradeable.sol",
          "contracts/governance/extensions/GovernorVotesCompUpgradeable.sol||contracts/governance/extensions/GovernorVotesCompUpgradeable.sol",
          "contracts/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol||contracts/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol",
          "contracts/governance/extensions/GovernorVotesUpgradeable.sol||contracts/governance/extensions/GovernorVotesUpgradeable.sol",
          "contracts/governance/extensions/IGovernorTimelockUpgradeable.sol||contracts/governance/extensions/IGovernorTimelockUpgradeable.sol",
          "contracts/governance/utils/IVotesUpgradeable.sol||contracts/governance/utils/IVotesUpgradeable.sol",
          "contracts/governance/utils/VotesUpgradeable.sol||contracts/governance/utils/VotesUpgradeable.sol",
          "contracts/interfaces/IERC1155MetadataURIUpgradeable.sol||contracts/interfaces/IERC1155MetadataURIUpgradeable.sol",
          "contracts/interfaces/IERC1155ReceiverUpgradeable.sol||contracts/interfaces/IERC1155ReceiverUpgradeable.sol",
          "contracts/interfaces/IERC1155Upgradeable.sol||contracts/interfaces/IERC1155Upgradeable.sol",
          "contracts/interfaces/IERC1271Upgradeable.sol||contracts/interfaces/IERC1271Upgradeable.sol",
          "contracts/interfaces/IERC1363ReceiverUpgradeable.sol||contracts/interfaces/IERC1363ReceiverUpgradeable.sol",
          "contracts/interfaces/IERC1363SpenderUpgradeable.sol||contracts/interfaces/IERC1363SpenderUpgradeable.sol",
          "contracts/interfaces/IERC1363Upgradeable.sol||contracts/interfaces/IERC1363Upgradeable.sol",
          "contracts/interfaces/IERC165Upgradeable.sol||contracts/interfaces/IERC165Upgradeable.sol",
          "contracts/interfaces/IERC1820ImplementerUpgradeable.sol||contracts/interfaces/IERC1820ImplementerUpgradeable.sol",
          "contracts/interfaces/IERC1820RegistryUpgradeable.sol||contracts/interfaces/IERC1820RegistryUpgradeable.sol",
          "contracts/interfaces/IERC1967Upgradeable.sol||contracts/interfaces/IERC1967Upgradeable.sol",
          "contracts/interfaces/IERC20MetadataUpgradeable.sol||contracts/interfaces/IERC20MetadataUpgradeable.sol",
          "contracts/interfaces/IERC20Upgradeable.sol||contracts/interfaces/IERC20Upgradeable.sol",
          "contracts/interfaces/IERC2309Upgradeable.sol||contracts/interfaces/IERC2309Upgradeable.sol",
          "contracts/interfaces/IERC2612Upgradeable.sol||contracts/interfaces/IERC2612Upgradeable.sol",
          "contracts/interfaces/IERC2981Upgradeable.sol||contracts/interfaces/IERC2981Upgradeable.sol",
          "contracts/interfaces/IERC3156FlashBorrowerUpgradeable.sol||contracts/interfaces/IERC3156FlashBorrowerUpgradeable.sol",
          "contracts/interfaces/IERC3156FlashLenderUpgradeable.sol||contracts/interfaces/IERC3156FlashLenderUpgradeable.sol",
          "contracts/interfaces/IERC3156Upgradeable.sol||contracts/interfaces/IERC3156Upgradeable.sol",
          "contracts/interfaces/IERC4626Upgradeable.sol||contracts/interfaces/IERC4626Upgradeable.sol",
          "contracts/interfaces/IERC4906Upgradeable.sol||contracts/interfaces/IERC4906Upgradeable.sol",
          "contracts/interfaces/IERC5267Upgradeable.sol||contracts/interfaces/IERC5267Upgradeable.sol",
          "contracts/interfaces/IERC5313Upgradeable.sol||contracts/interfaces/IERC5313Upgradeable.sol",
          "contracts/interfaces/IERC5805Upgradeable.sol||contracts/interfaces/IERC5805Upgradeable.sol",
          "contracts/interfaces/IERC6372Upgradeable.sol||contracts/interfaces/IERC6372Upgradeable.sol",
          "contracts/interfaces/IERC721EnumerableUpgradeable.sol||contracts/interfaces/IERC721EnumerableUpgradeable.sol",
          "contracts/interfaces/IERC721MetadataUpgradeable.sol||contracts/interfaces/IERC721MetadataUpgradeable.sol",
          "contracts/interfaces/IERC721ReceiverUpgradeable.sol||contracts/interfaces/IERC721ReceiverUpgradeable.sol",
          "contracts/interfaces/IERC721Upgradeable.sol||contracts/interfaces/IERC721Upgradeable.sol",
          "contracts/interfaces/IERC777RecipientUpgradeable.sol||contracts/interfaces/IERC777RecipientUpgradeable.sol",
          "contracts/interfaces/IERC777SenderUpgradeable.sol||contracts/interfaces/IERC777SenderUpgradeable.sol",
          "contracts/interfaces/IERC777Upgradeable.sol||contracts/interfaces/IERC777Upgradeable.sol",
          "contracts/interfaces/draft-IERC1822Upgradeable.sol||contracts/interfaces/draft-IERC1822Upgradeable.sol",
          "contracts/interfaces/draft-IERC2612Upgradeable.sol||contracts/interfaces/draft-IERC2612Upgradeable.sol",
          "contracts/metatx/ERC2771ContextUpgradeable.sol||contracts/metatx/ERC2771ContextUpgradeable.sol",
          "contracts/metatx/MinimalForwarderUpgradeable.sol||contracts/metatx/MinimalForwarderUpgradeable.sol",
          "contracts/mocks/AccessControlCrossChainMockUpgradeable.sol||contracts/mocks/AccessControlCrossChainMockUpgradeable.sol",
          "contracts/mocks/ArraysMockUpgradeable.sol||contracts/mocks/ArraysMockUpgradeable.sol",
          "contracts/mocks/CallReceiverMockUpgradeable.sol||contracts/mocks/CallReceiverMockUpgradeable.sol",
          "contracts/mocks/ConditionalEscrowMockUpgradeable.sol||contracts/mocks/ConditionalEscrowMockUpgradeable.sol",
          "contracts/mocks/ContextMockUpgradeable.sol||contracts/mocks/ContextMockUpgradeable.sol",
          "contracts/mocks/DummyImplementationUpgradeable.sol||contracts/mocks/DummyImplementationUpgradeable.sol",
          "contracts/mocks/EIP712VerifierUpgradeable.sol||contracts/mocks/EIP712VerifierUpgradeable.sol",
          "contracts/mocks/ERC1271WalletMockUpgradeable.sol||contracts/mocks/ERC1271WalletMockUpgradeable.sol",
          "contracts/mocks/ERC165/ERC165MaliciousDataUpgradeable.sol||contracts/mocks/ERC165/ERC165MaliciousDataUpgradeable.sol",
          "contracts/mocks/ERC165/ERC165MissingDataUpgradeable.sol||contracts/mocks/ERC165/ERC165MissingDataUpgradeable.sol",
          "contracts/mocks/ERC165/ERC165NotSupportedUpgradeable.sol||contracts/mocks/ERC165/ERC165NotSupportedUpgradeable.sol",
          "contracts/mocks/ERC165/ERC165ReturnBombUpgradeable.sol||contracts/mocks/ERC165/ERC165ReturnBombUpgradeable.sol",
          "contracts/mocks/ERC20MockUpgradeable.sol||contracts/mocks/ERC20MockUpgradeable.sol",
          "contracts/mocks/ERC20ReentrantUpgradeable.sol||contracts/mocks/ERC20ReentrantUpgradeable.sol",
          "contracts/mocks/ERC2771ContextMockUpgradeable.sol||contracts/mocks/ERC2771ContextMockUpgradeable.sol",
          "contracts/mocks/ERC3156FlashBorrowerMockUpgradeable.sol||contracts/mocks/ERC3156FlashBorrowerMockUpgradeable.sol",
          "contracts/mocks/ERC4626MockUpgradeable.sol||contracts/mocks/ERC4626MockUpgradeable.sol",
          "contracts/mocks/EtherReceiverMockUpgradeable.sol||contracts/mocks/EtherReceiverMockUpgradeable.sol",
          "contracts/mocks/InitializableMock.sol||contracts/mocks/InitializableMock.sol",
          "contracts/mocks/MulticallTestUpgradeable.sol||contracts/mocks/MulticallTestUpgradeable.sol",
          "contracts/mocks/MultipleInheritanceInitializableMocks.sol||contracts/mocks/MultipleInheritanceInitializableMocks.sol",
          "contracts/mocks/PausableMockUpgradeable.sol||contracts/mocks/PausableMockUpgradeable.sol",
          "contracts/mocks/PullPaymentMockUpgradeable.sol||contracts/mocks/PullPaymentMockUpgradeable.sol",
          "contracts/mocks/ReentrancyAttackUpgradeable.sol||contracts/mocks/ReentrancyAttackUpgradeable.sol",
          "contracts/mocks/ReentrancyMockUpgradeable.sol||contracts/mocks/ReentrancyMockUpgradeable.sol",
          "contracts/mocks/RegressionImplementation.sol||contracts/mocks/RegressionImplementation.sol",
          "contracts/mocks/SafeMathMemoryCheckUpgradeable.sol||contracts/mocks/SafeMathMemoryCheckUpgradeable.sol",
          "contracts/mocks/SingleInheritanceInitializableMocks.sol||contracts/mocks/SingleInheritanceInitializableMocks.sol",
          "contracts/mocks/StorageSlotMockUpgradeable.sol||contracts/mocks/StorageSlotMockUpgradeable.sol",
          "contracts/mocks/TimelockReentrantUpgradeable.sol||contracts/mocks/TimelockReentrantUpgradeable.sol",
          "contracts/mocks/TimersBlockNumberImplUpgradeable.sol||contracts/mocks/TimersBlockNumberImplUpgradeable.sol",
          "contracts/mocks/TimersTimestampImplUpgradeable.sol||contracts/mocks/TimersTimestampImplUpgradeable.sol",
          "contracts/mocks/VotesMockUpgradeable.sol||contracts/mocks/VotesMockUpgradeable.sol",
          "contracts/mocks/WithInit.sol||contracts/mocks/WithInit.sol",
          "contracts/mocks/compound/CompTimelockUpgradeable.sol||contracts/mocks/compound/CompTimelockUpgradeable.sol",
          "contracts/mocks/crosschain/bridgesUpgradeable.sol||contracts/mocks/crosschain/bridgesUpgradeable.sol",
          "contracts/mocks/crosschain/receiversUpgradeable.sol||contracts/mocks/crosschain/receiversUpgradeable.sol",
          "contracts/mocks/governance/GovernorCompMockUpgradeable.sol||contracts/mocks/governance/GovernorCompMockUpgradeable.sol",
          "contracts/mocks/governance/GovernorCompatibilityBravoMockUpgradeable.sol||contracts/mocks/governance/GovernorCompatibilityBravoMockUpgradeable.sol",
          "contracts/mocks/governance/GovernorMockUpgradeable.sol||contracts/mocks/governance/GovernorMockUpgradeable.sol",
          "contracts/mocks/governance/GovernorPreventLateQuorumMockUpgradeable.sol||contracts/mocks/governance/GovernorPreventLateQuorumMockUpgradeable.sol",
          "contracts/mocks/governance/GovernorTimelockCompoundMockUpgradeable.sol||contracts/mocks/governance/GovernorTimelockCompoundMockUpgradeable.sol",
          "contracts/mocks/governance/GovernorTimelockControlMockUpgradeable.sol||contracts/mocks/governance/GovernorTimelockControlMockUpgradeable.sol",
          "contracts/mocks/governance/GovernorVoteMockUpgradeable.sol||contracts/mocks/governance/GovernorVoteMockUpgradeable.sol",
          "contracts/mocks/governance/GovernorWithParamsMockUpgradeable.sol||contracts/mocks/governance/GovernorWithParamsMockUpgradeable.sol",
          "contracts/mocks/proxy/BadBeaconUpgradeable.sol||contracts/mocks/proxy/BadBeaconUpgradeable.sol",
          "contracts/mocks/proxy/ClashingImplementationUpgradeable.sol||contracts/mocks/proxy/ClashingImplementationUpgradeable.sol",
          "contracts/mocks/proxy/UUPSLegacyUpgradeable.sol||contracts/mocks/proxy/UUPSLegacyUpgradeable.sol",
          "contracts/mocks/proxy/UUPSUpgradeableMockUpgradeable.sol||contracts/mocks/proxy/UUPSUpgradeableMockUpgradeable.sol",
          "contracts/mocks/token/ERC1155ReceiverMockUpgradeable.sol||contracts/mocks/token/ERC1155ReceiverMockUpgradeable.sol",
          "contracts/mocks/token/ERC20DecimalsMockUpgradeable.sol||contracts/mocks/token/ERC20DecimalsMockUpgradeable.sol",
          "contracts/mocks/token/ERC20ExcessDecimalsMockUpgradeable.sol||contracts/mocks/token/ERC20ExcessDecimalsMockUpgradeable.sol",
          "contracts/mocks/token/ERC20FlashMintMockUpgradeable.sol||contracts/mocks/token/ERC20FlashMintMockUpgradeable.sol",
          "contracts/mocks/token/ERC20ForceApproveMockUpgradeable.sol||contracts/mocks/token/ERC20ForceApproveMockUpgradeable.sol",
          "contracts/mocks/token/ERC20MulticallMockUpgradeable.sol||contracts/mocks/token/ERC20MulticallMockUpgradeable.sol",
          "contracts/mocks/token/ERC20NoReturnMockUpgradeable.sol||contracts/mocks/token/ERC20NoReturnMockUpgradeable.sol",
          "contracts/mocks/token/ERC20PermitNoRevertMockUpgradeable.sol||contracts/mocks/token/ERC20PermitNoRevertMockUpgradeable.sol",
          "contracts/mocks/token/ERC20ReturnFalseMockUpgradeable.sol||contracts/mocks/token/ERC20ReturnFalseMockUpgradeable.sol",
          "contracts/mocks/token/ERC20VotesLegacyMockUpgradeable.sol||contracts/mocks/token/ERC20VotesLegacyMockUpgradeable.sol",
          "contracts/mocks/token/ERC4626OffsetMockUpgradeable.sol||contracts/mocks/token/ERC4626OffsetMockUpgradeable.sol",
          "contracts/mocks/token/ERC4646FeesMockUpgradeable.sol||contracts/mocks/token/ERC4646FeesMockUpgradeable.sol",
          "contracts/mocks/token/ERC721ConsecutiveEnumerableMockUpgradeable.sol||contracts/mocks/token/ERC721ConsecutiveEnumerableMockUpgradeable.sol",
          "contracts/mocks/token/ERC721ConsecutiveMockUpgradeable.sol||contracts/mocks/token/ERC721ConsecutiveMockUpgradeable.sol",
          "contracts/mocks/token/ERC721ReceiverMockUpgradeable.sol||contracts/mocks/token/ERC721ReceiverMockUpgradeable.sol",
          "contracts/mocks/token/ERC721URIStorageMockUpgradeable.sol||contracts/mocks/token/ERC721URIStorageMockUpgradeable.sol",
          "contracts/mocks/token/ERC777MockUpgradeable.sol||contracts/mocks/token/ERC777MockUpgradeable.sol",
          "contracts/mocks/token/ERC777SenderRecipientMockUpgradeable.sol||contracts/mocks/token/ERC777SenderRecipientMockUpgradeable.sol",
          "contracts/mocks/token/VotesTimestampUpgradeable.sol||contracts/mocks/token/VotesTimestampUpgradeable.sol",
          "contracts/mocks/wizard/MyGovernor1Upgradeable.sol||contracts/mocks/wizard/MyGovernor1Upgradeable.sol",
          "contracts/mocks/wizard/MyGovernor2Upgradeable.sol||contracts/mocks/wizard/MyGovernor2Upgradeable.sol",
          "contracts/mocks/wizard/MyGovernor3Upgradeable.sol||contracts/mocks/wizard/MyGovernor3Upgradeable.sol",
          "contracts/proxy/ClonesUpgradeable.sol||contracts/proxy/ClonesUpgradeable.sol",
          "contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol||contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol",
          "contracts/proxy/beacon/IBeaconUpgradeable.sol||contracts/proxy/beacon/IBeaconUpgradeable.sol",
          "contracts/proxy/utils/Initializable.sol||contracts/proxy/utils/Initializable.sol",
          "contracts/proxy/utils/UUPSUpgradeable.sol||contracts/proxy/utils/UUPSUpgradeable.sol",
          "contracts/security/PausableUpgradeable.sol||contracts/security/PausableUpgradeable.sol",
          "contracts/security/PullPaymentUpgradeable.sol||contracts/security/PullPaymentUpgradeable.sol",
          "contracts/security/ReentrancyGuardUpgradeable.sol||contracts/security/ReentrancyGuardUpgradeable.sol",
          "contracts/token/ERC1155/ERC1155Upgradeable.sol||contracts/token/ERC1155/ERC1155Upgradeable.sol",
          "contracts/token/ERC1155/IERC1155ReceiverUpgradeable.sol||contracts/token/ERC1155/IERC1155ReceiverUpgradeable.sol",
          "contracts/token/ERC1155/IERC1155Upgradeable.sol||contracts/token/ERC1155/IERC1155Upgradeable.sol",
          "contracts/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol||contracts/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol",
          "contracts/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol||contracts/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol",
          "contracts/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol||contracts/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol",
          "contracts/token/ERC1155/extensions/ERC1155URIStorageUpgradeable.sol||contracts/token/ERC1155/extensions/ERC1155URIStorageUpgradeable.sol",
          "contracts/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol||contracts/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol",
          "contracts/token/ERC1155/presets/ERC1155PresetMinterPauserUpgradeable.sol||contracts/token/ERC1155/presets/ERC1155PresetMinterPauserUpgradeable.sol",
          "contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol||contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol",
          "contracts/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol||contracts/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol",
          "contracts/token/ERC20/ERC20Upgradeable.sol||contracts/token/ERC20/ERC20Upgradeable.sol",
          "contracts/token/ERC20/IERC20Upgradeable.sol||contracts/token/ERC20/IERC20Upgradeable.sol",
          "contracts/token/ERC20/extensions/ERC20BurnableUpgradeable.sol||contracts/token/ERC20/extensions/ERC20BurnableUpgradeable.sol",
          "contracts/token/ERC20/extensions/ERC20CappedUpgradeable.sol||contracts/token/ERC20/extensions/ERC20CappedUpgradeable.sol",
          "contracts/token/ERC20/extensions/ERC20FlashMintUpgradeable.sol||contracts/token/ERC20/extensions/ERC20FlashMintUpgradeable.sol",
          "contracts/token/ERC20/extensions/ERC20PausableUpgradeable.sol||contracts/token/ERC20/extensions/ERC20PausableUpgradeable.sol",
          "contracts/token/ERC20/extensions/ERC20PermitUpgradeable.sol||contracts/token/ERC20/extensions/ERC20PermitUpgradeable.sol",
          "contracts/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol||contracts/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol",
          "contracts/token/ERC20/extensions/ERC20VotesCompUpgradeable.sol||contracts/token/ERC20/extensions/ERC20VotesCompUpgradeable.sol",
          "contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol||contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol",
          "contracts/token/ERC20/extensions/ERC20WrapperUpgradeable.sol||contracts/token/ERC20/extensions/ERC20WrapperUpgradeable.sol",
          "contracts/token/ERC20/extensions/ERC4626Upgradeable.sol||contracts/token/ERC20/extensions/ERC4626Upgradeable.sol",
          "contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol||contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol",
          "contracts/token/ERC20/extensions/IERC20PermitUpgradeable.sol||contracts/token/ERC20/extensions/IERC20PermitUpgradeable.sol",
          "contracts/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol||contracts/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol",
          "contracts/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol||contracts/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol",
          "contracts/token/ERC20/presets/ERC20PresetFixedSupplyUpgradeable.sol||contracts/token/ERC20/presets/ERC20PresetFixedSupplyUpgradeable.sol",
          "contracts/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol||contracts/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol",
          "contracts/token/ERC20/utils/SafeERC20Upgradeable.sol||contracts/token/ERC20/utils/SafeERC20Upgradeable.sol",
          "contracts/token/ERC20/utils/TokenTimelockUpgradeable.sol||contracts/token/ERC20/utils/TokenTimelockUpgradeable.sol",
          "contracts/token/ERC721/ERC721Upgradeable.sol||contracts/token/ERC721/ERC721Upgradeable.sol",
          "contracts/token/ERC721/IERC721ReceiverUpgradeable.sol||contracts/token/ERC721/IERC721ReceiverUpgradeable.sol",
          "contracts/token/ERC721/IERC721Upgradeable.sol||contracts/token/ERC721/IERC721Upgradeable.sol",
          "contracts/token/ERC721/extensions/ERC721BurnableUpgradeable.sol||contracts/token/ERC721/extensions/ERC721BurnableUpgradeable.sol",
          "contracts/token/ERC721/extensions/ERC721ConsecutiveUpgradeable.sol||contracts/token/ERC721/extensions/ERC721ConsecutiveUpgradeable.sol",
          "contracts/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol||contracts/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol",
          "contracts/token/ERC721/extensions/ERC721PausableUpgradeable.sol||contracts/token/ERC721/extensions/ERC721PausableUpgradeable.sol",
          "contracts/token/ERC721/extensions/ERC721RoyaltyUpgradeable.sol||contracts/token/ERC721/extensions/ERC721RoyaltyUpgradeable.sol",
          "contracts/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol||contracts/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol",
          "contracts/token/ERC721/extensions/ERC721VotesUpgradeable.sol||contracts/token/ERC721/extensions/ERC721VotesUpgradeable.sol",
          "contracts/token/ERC721/extensions/ERC721WrapperUpgradeable.sol||contracts/token/ERC721/extensions/ERC721WrapperUpgradeable.sol",
          "contracts/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol||contracts/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol",
          "contracts/token/ERC721/extensions/IERC721MetadataUpgradeable.sol||contracts/token/ERC721/extensions/IERC721MetadataUpgradeable.sol",
          "contracts/token/ERC721/extensions/draft-ERC721VotesUpgradeable.sol||contracts/token/ERC721/extensions/draft-ERC721VotesUpgradeable.sol",
          "contracts/token/ERC721/presets/ERC721PresetMinterPauserAutoIdUpgradeable.sol||contracts/token/ERC721/presets/ERC721PresetMinterPauserAutoIdUpgradeable.sol",
          "contracts/token/ERC721/utils/ERC721HolderUpgradeable.sol||contracts/token/ERC721/utils/ERC721HolderUpgradeable.sol",
          "contracts/token/ERC777/ERC777Upgradeable.sol||contracts/token/ERC777/ERC777Upgradeable.sol",
          "contracts/token/ERC777/IERC777RecipientUpgradeable.sol||contracts/token/ERC777/IERC777RecipientUpgradeable.sol",
          "contracts/token/ERC777/IERC777SenderUpgradeable.sol||contracts/token/ERC777/IERC777SenderUpgradeable.sol",
          "contracts/token/ERC777/IERC777Upgradeable.sol||contracts/token/ERC777/IERC777Upgradeable.sol",
          "contracts/token/ERC777/presets/ERC777PresetFixedSupplyUpgradeable.sol||contracts/token/ERC777/presets/ERC777PresetFixedSupplyUpgradeable.sol",
          "contracts/token/common/ERC2981Upgradeable.sol||contracts/token/common/ERC2981Upgradeable.sol",
          "contracts/utils/AddressUpgradeable.sol||contracts/utils/AddressUpgradeable.sol",
          "contracts/utils/ArraysUpgradeable.sol||contracts/utils/ArraysUpgradeable.sol",
          "contracts/utils/Base64Upgradeable.sol||contracts/utils/Base64Upgradeable.sol",
          "contracts/utils/CheckpointsUpgradeable.sol||contracts/utils/CheckpointsUpgradeable.sol",
          "contracts/utils/ContextUpgradeable.sol||contracts/utils/ContextUpgradeable.sol",
          "contracts/utils/CountersUpgradeable.sol||contracts/utils/CountersUpgradeable.sol",
          "contracts/utils/Create2Upgradeable.sol||contracts/utils/Create2Upgradeable.sol",
          "contracts/utils/MulticallUpgradeable.sol||contracts/utils/MulticallUpgradeable.sol",
          "contracts/utils/ShortStringsUpgradeable.sol||contracts/utils/ShortStringsUpgradeable.sol",
          "contracts/utils/StorageSlotUpgradeable.sol||contracts/utils/StorageSlotUpgradeable.sol",
          "contracts/utils/StringsUpgradeable.sol||contracts/utils/StringsUpgradeable.sol",
          "contracts/utils/TimersUpgradeable.sol||contracts/utils/TimersUpgradeable.sol",
          "contracts/utils/cryptography/ECDSAUpgradeable.sol||contracts/utils/cryptography/ECDSAUpgradeable.sol",
          "contracts/utils/cryptography/EIP712Upgradeable.sol||contracts/utils/cryptography/EIP712Upgradeable.sol",
          "contracts/utils/cryptography/MerkleProofUpgradeable.sol||contracts/utils/cryptography/MerkleProofUpgradeable.sol",
          "contracts/utils/cryptography/SignatureCheckerUpgradeable.sol||contracts/utils/cryptography/SignatureCheckerUpgradeable.sol",
          "contracts/utils/cryptography/draft-EIP712Upgradeable.sol||contracts/utils/cryptography/draft-EIP712Upgradeable.sol",
          "contracts/utils/escrow/ConditionalEscrowUpgradeable.sol||contracts/utils/escrow/ConditionalEscrowUpgradeable.sol",
          "contracts/utils/escrow/EscrowUpgradeable.sol||contracts/utils/escrow/EscrowUpgradeable.sol",
          "contracts/utils/escrow/RefundEscrowUpgradeable.sol||contracts/utils/escrow/RefundEscrowUpgradeable.sol",
          "contracts/utils/introspection/ERC165CheckerUpgradeable.sol||contracts/utils/introspection/ERC165CheckerUpgradeable.sol",
          "contracts/utils/introspection/ERC165StorageUpgradeable.sol||contracts/utils/introspection/ERC165StorageUpgradeable.sol",
          "contracts/utils/introspection/ERC165Upgradeable.sol||contracts/utils/introspection/ERC165Upgradeable.sol",
          "contracts/utils/introspection/ERC1820ImplementerUpgradeable.sol||contracts/utils/introspection/ERC1820ImplementerUpgradeable.sol",
          "contracts/utils/introspection/IERC165Upgradeable.sol||contracts/utils/introspection/IERC165Upgradeable.sol",
          "contracts/utils/introspection/IERC1820ImplementerUpgradeable.sol||contracts/utils/introspection/IERC1820ImplementerUpgradeable.sol",
          "contracts/utils/introspection/IERC1820RegistryUpgradeable.sol||contracts/utils/introspection/IERC1820RegistryUpgradeable.sol",
          "contracts/utils/math/MathUpgradeable.sol||contracts/utils/math/MathUpgradeable.sol",
          "contracts/utils/math/SafeCastUpgradeable.sol||contracts/utils/math/SafeCastUpgradeable.sol",
          "contracts/utils/math/SafeMathUpgradeable.sol||contracts/utils/math/SafeMathUpgradeable.sol",
          "contracts/utils/math/SignedMathUpgradeable.sol||contracts/utils/math/SignedMathUpgradeable.sol",
          "contracts/utils/math/SignedSafeMathUpgradeable.sol||contracts/utils/math/SignedSafeMathUpgradeable.sol",
          "contracts/utils/structs/BitMapsUpgradeable.sol||contracts/utils/structs/BitMapsUpgradeable.sol",
          "contracts/utils/structs/DoubleEndedQueueUpgradeable.sol||contracts/utils/structs/DoubleEndedQueueUpgradeable.sol",
          "contracts/utils/structs/EnumerableMapUpgradeable.sol||contracts/utils/structs/EnumerableMapUpgradeable.sol",
          "contracts/utils/structs/EnumerableSetUpgradeable.sol||contracts/utils/structs/EnumerableSetUpgradeable.sol",
          "contracts/vendor/amb/IAMBUpgradeable.sol||contracts/vendor/amIAMBUpgradeable.sol",
          "contracts/vendor/arbitrum/IArbSysUpgradeable.sol||contracts/vendor/arbitrum/IArbSysUpgradeable.sol",
          "contracts/vendor/arbitrum/IBridgeUpgradeable.sol||contracts/vendor/arbitrum/IBridgeUpgradeable.sol",
          "contracts/vendor/arbitrum/IDelayedMessageProviderUpgradeable.sol||contracts/vendor/arbitrum/IDelayedMessageProviderUpgradeable.sol",
          "contracts/vendor/arbitrum/IInboxUpgradeable.sol||contracts/vendor/arbitrum/IInboxUpgradeable.sol",
          "contracts/vendor/arbitrum/IOutboxUpgradeable.sol||contracts/vendor/arbitrum/IOutboxUpgradeable.sol",
          "contracts/vendor/compound/ICompoundTimelockUpgradeable.sol||contracts/vendor/compound/ICompoundTimelockUpgradeable.sol",
          "contracts/vendor/optimism/ICrossDomainMessengerUpgradeable.sol||contracts/vendor/optimism/ICrossDomainMessengerUpgradeable.sol",
          "contracts/vendor/polygon/IFxMessageProcessorUpgradeable.sol||contracts/vendor/polygon/IFxMessageProcessorUpgradeable.sol",
          "hardhat.config.js||hardhat.config.js",
          "hardhat/env-artifacts.js||hardhat/env-artifacts.js",
          "hardhat/env-contract.js||hardhat/env-contract.js",
          "hardhat/ignore-unreachable-warnings.js||hardhat/ignore-unreachable-warnings.js",
          "hardhat/skip-foundry-tests.js||hardhat/skip-foundry-tests.js",
          "hardhat/task-test-get-files.js||hardhat/task-test-get-files.js",
          "scripts/checks/compare-layout.js||scripts/checks/compare-layout.js",
          "scripts/checks/compareGasReports.js||scripts/checks/compareGasReports.js",
          "scripts/checks/extract-layout.js||scripts/checks/extract-layout.js",
          "scripts/checks/generation.sh||scripts/checks/generation.sh",
          "scripts/checks/inheritance-ordering.js||scripts/checks/inheritance-ordering.js",
          "scripts/gen-nav.js||scripts/gen-nav.js",
          "scripts/generate/format-lines.js||scripts/generate/format-lines.js",
          "scripts/generate/run.js||scripts/generate/run.js",
          "scripts/generate/templates/Checkpoints.js||scripts/generate/templates/Checkpoints.js",
          "scripts/generate/templates/Checkpoints.opts.js||scripts/generate/templates/Checkpoints.opts.js",
          "scripts/generate/templates/Checkpoints.t.js||scripts/generate/templates/Checkpoints.t.js",
          "scripts/generate/templates/EnumerableMap.js||scripts/generate/templates/EnumerableMap.js",
          "scripts/generate/templates/EnumerableSet.js||scripts/generate/templates/EnumerableSet.js",
          "scripts/generate/templates/SafeCast.js||scripts/generate/templates/SafeCast.js",
          "scripts/generate/templates/StorageSlot.js||scripts/generate/templates/StorageSlot.js",
          "scripts/generate/templates/conversion.js||scripts/generate/templates/conversion.js",
          "scripts/git-user-config.sh||scripts/git-user-config.sh",
          "scripts/helpers.js||scripts/helpers.js",
          "scripts/migrate-imports.js||scripts/migrate-imports.js",
          "scripts/prepack.sh||scripts/prepack.sh",
          "scripts/prepare-contracts-package.sh||scripts/prepare-contracts-package.sh",
          "scripts/prepare-docs.sh||scripts/prepare-docs.sh",
          "scripts/prepare.sh||scripts/prepare.sh",
          "scripts/release/format-changelog.js||scripts/release/format-changelog.js",
          "scripts/release/synchronize-versions.js||scripts/release/synchronize-versions.js",
          "scripts/release/update-comment.js||scripts/release/update-comment.js",
          "scripts/release/version.sh||scripts/release/version.sh",
          "scripts/release/workflow/exit-prerelease.sh||scripts/release/workflow/exit-prerelease.sh",
          "scripts/release/workflow/github-release.js||scripts/release/workflow/github-release.js",
          "scripts/release/workflow/integrity-check.sh||scripts/release/workflow/integrity-check.sh",
          "scripts/release/workflow/pack.sh||scripts/release/workflow/pack.sh",
          "scripts/release/workflow/prepare-release-merge.sh||scripts/release/workflow/prepare-release-merge.sh",
          "scripts/release/workflow/publish.sh||scripts/release/workflow/publish.sh",
          "scripts/release/workflow/rerun.js||scripts/release/workflow/rerun.js",
          "scripts/release/workflow/set-changesets-pr-title.js||scripts/release/workflow/set-changesets-pr-title.js",
          "scripts/release/workflow/start.sh||scripts/release/workflow/start.sh",
          "scripts/release/workflow/state.js||scripts/release/workflow/state.js",
          "scripts/remove-ignored-artifacts.js||scripts/remove-ignored-artifacts.js",
          "scripts/update-docs-branch.js||scripts/update-docs-branch.js",
          "scripts/upgradeable/patch-apply.sh||scripts/upgradeable/patch-apply.sh",
          "scripts/upgradeable/patch-save.sh||scripts/upgradeable/patch-save.sh",
          "scripts/upgradeable/transpile-onto.sh||scripts/upgradeable/transpile-onto.sh",
          "scripts/upgradeable/transpile.sh||scripts/upgradeable/transpile.sh",
          "test/access/AccessControl.behavior.js||test/access/AccessControl.behavior.js",
          "test/access/AccessControl.test.js||test/access/AccessControl.test.js",
          "test/access/AccessControlCrossChain.test.js||test/access/AccessControlCrossChain.test.js",
          "test/access/AccessControlDefaultAdminRules.test.js||test/access/AccessControlDefaultAdminRules.test.js",
          "test/access/AccessControlEnumerable.test.js||test/access/AccessControlEnumerable.test.js",
          "test/access/Ownable.test.js||test/access/Ownable.test.js",
          "test/access/Ownable2Step.test.js||test/access/Ownable2Step.test.js",
          "test/crosschain/CrossChainEnabled.test.js||test/crosschain/CrossChainEnabled.test.js",
          "test/finance/PaymentSplitter.test.js||test/finance/PaymentSplitter.test.js",
          "test/finance/VestingWallet.behavior.js||test/finance/VestingWallet.behavior.js",
          "test/finance/VestingWallet.test.js||test/finance/VestingWallet.test.js",
          "test/governance/Governor.test.js||test/governance/Governor.test.js",
          "test/governance/TimelockController.test.js||test/governance/TimelockController.test.js",
          "test/governance/compatibility/GovernorCompatibilityBravo.test.js||test/governance/compatibility/GovernorCompatibilityBravo.test.js",
          "test/governance/extensions/GovernorComp.test.js||test/governance/extensions/GovernorComp.test.js",
          "test/governance/extensions/GovernorERC721.test.js||test/governance/extensions/GovernorERC721.test.js",
          "test/governance/extensions/GovernorPreventLateQuorum.test.js||test/governance/extensions/GovernorPreventLateQuorum.test.js",
          "test/governance/extensions/GovernorTimelockCompound.test.js||test/governance/extensions/GovernorTimelockCompound.test.js",
          "test/governance/extensions/GovernorTimelockControl.test.js||test/governance/extensions/GovernorTimelockControl.test.js",
          "test/governance/extensions/GovernorVotesQuorumFraction.test.js||test/governance/extensions/GovernorVotesQuorumFraction.test.js",
          "test/governance/extensions/GovernorWithParams.test.js||test/governance/extensions/GovernorWithParams.test.js",
          "test/governance/utils/EIP6372.behavior.js||test/governance/utils/EIP6372.behavior.js",
          "test/governance/utils/Votes.behavior.js||test/governance/utils/Votes.behavior.js",
          "test/governance/utils/Votes.test.js||test/governance/utils/Votes.test.js",
          "test/helpers/chainid.js||test/helpers/chainid.js",
          "test/helpers/create2.js||test/helpers/create2.js",
          "test/helpers/crosschain.js||test/helpers/crosschain.js",
          "test/helpers/customError.js||test/helpers/customError.js",
          "test/helpers/eip712.js||test/helpers/eip712.js",
          "test/helpers/enums.js||test/helpers/enums.js",
          "test/helpers/erc1967.js||test/helpers/erc1967.js",
          "test/helpers/governance.js||test/helpers/governance.js",
          "test/helpers/map-values.js||test/helpers/map-values.js",
          "test/helpers/sign.js||test/helpers/sign.js",
          "test/helpers/time.js||test/helpers/time.js",
          "test/helpers/txpool.js||test/helpers/txpool.js",
          "test/metatx/ERC2771Context.test.js||test/metatx/ERC2771Context.test.js",
          "test/metatx/MinimalForwarder.test.js||test/metatx/MinimalForwarder.test.js",
          "test/migrate-imports.test.js||test/migrate-imports.test.js",
          "test/proxy/Clones.behaviour.js||test/proxy/Clones.behaviour.js",
          "test/proxy/Clones.test.js||test/proxy/Clones.test.js",
          "test/proxy/ERC1967/ERC1967Proxy.test.js||test/proxy/ERC1967/ERC1967Proxy.test.js",
          "test/proxy/Proxy.behaviour.js||test/proxy/Proxy.behaviour.js",
          "test/proxy/beacon/BeaconProxy.test.js||test/proxy/beacon/BeaconProxy.test.js",
          "test/proxy/beacon/UpgradeableBeacon.test.js||test/proxy/beacon/UpgradeableBeacon.test.js",
          "test/proxy/transparent/ProxyAdmin.test.js||test/proxy/transparent/ProxyAdmin.test.js",
          "test/proxy/transparent/TransparentUpgradeableProxy.behaviour.js||test/proxy/transparent/TransparentUpgradeableProxy.behaviour.js",
          "test/proxy/transparent/TransparentUpgradeableProxy.test.js||test/proxy/transparent/TransparentUpgradeableProxy.test.js",
          "test/proxy/utils/Initializable.test.js||test/proxy/utils/Initializable.test.js",
          "test/proxy/utils/UUPSUpgradeable.test.js||test/proxy/utils/UUPSUpgradeable.test.js",
          "test/security/Pausable.test.js||test/security/Pausable.test.js",
          "test/security/PullPayment.test.js||test/security/PullPayment.test.js",
          "test/security/ReentrancyGuard.test.js||test/security/ReentrancyGuard.test.js",
          "test/token/ERC1155/ERC1155.behavior.js||test/token/ERC1155/ERC1155.behavior.js",
          "test/token/ERC1155/ERC1155.test.js||test/token/ERC1155/ERC1155.test.js",
          "test/token/ERC1155/extensions/ERC1155Burnable.test.js||test/token/ERC1155/extensions/ERC1155Burnable.test.js",
          "test/token/ERC1155/extensions/ERC1155Pausable.test.js||test/token/ERC1155/extensions/ERC1155Pausable.test.js",
          "test/token/ERC1155/extensions/ERC1155Supply.test.js||test/token/ERC1155/extensions/ERC1155Supply.test.js",
          "test/token/ERC1155/extensions/ERC1155URIStorage.test.js||test/token/ERC1155/extensions/ERC1155URIStorage.test.js",
          "test/token/ERC1155/presets/ERC1155PresetMinterPauser.test.js||test/token/ERC1155/presets/ERC1155PresetMinterPauser.test.js",
          "test/token/ERC1155/utils/ERC1155Holder.test.js||test/token/ERC1155/utils/ERC1155Holder.test.js",
          "test/token/ERC20/ERC20.behavior.js||test/token/ERC20/ERC20.behavior.js",
          "test/token/ERC20/ERC20.test.js||test/token/ERC20/ERC20.test.js",
          "test/token/ERC20/extensions/ERC20Burnable.behavior.js||test/token/ERC20/extensions/ERC20Burnable.behavior.js",
          "test/token/ERC20/extensions/ERC20Burnable.test.js||test/token/ERC20/extensions/ERC20Burnable.test.js",
          "test/token/ERC20/extensions/ERC20Capped.behavior.js||test/token/ERC20/extensions/ERC20Capped.behavior.js",
          "test/token/ERC20/extensions/ERC20Capped.test.js||test/token/ERC20/extensions/ERC20Capped.test.js",
          "test/token/ERC20/extensions/ERC20FlashMint.test.js||test/token/ERC20/extensions/ERC20FlashMint.test.js",
          "test/token/ERC20/extensions/ERC20Pausable.test.js||test/token/ERC20/extensions/ERC20Pausable.test.js",
          "test/token/ERC20/extensions/ERC20Snapshot.test.js||test/token/ERC20/extensions/ERC20Snapshot.test.js",
          "test/token/ERC20/extensions/ERC20Votes.test.js||test/token/ERC20/extensions/ERC20Votes.test.js",
          "test/token/ERC20/extensions/ERC20VotesComp.test.js||test/token/ERC20/extensions/ERC20VotesComp.test.js",
          "test/token/ERC20/extensions/ERC20Wrapper.test.js||test/token/ERC20/extensions/ERC20Wrapper.test.js",
          "test/token/ERC20/extensions/ERC4626.t.sol||test/token/ERC20/extensions/ERC4626.t.sol",
          "test/token/ERC20/extensions/ERC4626.test.js||test/token/ERC20/extensions/ERC4626.test.js",
          "test/token/ERC20/extensions/draft-ERC20Permit.test.js||test/token/ERC20/extensions/draft-ERC20Permit.test.js",
          "test/token/ERC20/presets/ERC20PresetFixedSupply.test.js||test/token/ERC20/presets/ERC20PresetFixedSupply.test.js",
          "test/token/ERC20/presets/ERC20PresetMinterPauser.test.js||test/token/ERC20/presets/ERC20PresetMinterPauser.test.js",
          "test/token/ERC20/utils/SafeERC20.test.js||test/token/ERC20/utils/SafeERC20.test.js",
          "test/token/ERC20/utils/TokenTimelock.test.js||test/token/ERC20/utils/TokenTimelock.test.js",
          "test/token/ERC721/ERC721.behavior.js||test/token/ERC721/ERC721.behavior.js",
          "test/token/ERC721/ERC721.test.js||test/token/ERC721/ERC721.test.js",
          "test/token/ERC721/ERC721Enumerable.test.js||test/token/ERC721/ERC721Enumerable.test.js",
          "test/token/ERC721/extensions/ERC721Burnable.test.js||test/token/ERC721/extensions/ERC721Burnable.test.js",
          "test/token/ERC721/extensions/ERC721Consecutive.t.sol||test/token/ERC721/extensions/ERC721Consecutive.t.sol",
          "test/token/ERC721/extensions/ERC721Consecutive.test.js||test/token/ERC721/extensions/ERC721Consecutive.test.js",
          "test/token/ERC721/extensions/ERC721Pausable.test.js||test/token/ERC721/extensions/ERC721Pausable.test.js",
          "test/token/ERC721/extensions/ERC721Royalty.test.js||test/token/ERC721/extensions/ERC721Royalty.test.js",
          "test/token/ERC721/extensions/ERC721URIStorage.test.js||test/token/ERC721/extensions/ERC721URIStorage.test.js",
          "test/token/ERC721/extensions/ERC721Votes.test.js||test/token/ERC721/extensions/ERC721Votes.test.js",
          "test/token/ERC721/extensions/ERC721Wrapper.test.js||test/token/ERC721/extensions/ERC721Wrapper.test.js",
          "test/token/ERC721/presets/ERC721PresetMinterPauserAutoId.test.js||test/token/ERC721/presets/ERC721PresetMinterPauserAutoId.test.js",
          "test/token/ERC721/utils/ERC721Holder.test.js||test/token/ERC721/utils/ERC721Holder.test.js",
          "test/token/ERC777/ERC777.behavior.js||test/token/ERC777/ERC777.behavior.js",
          "test/token/ERC777/ERC777.test.js||test/token/ERC777/ERC777.test.js",
          "test/token/ERC777/presets/ERC777PresetFixedSupply.test.js||test/token/ERC777/presets/ERC777PresetFixedSupply.test.js",
          "test/token/common/ERC2981.behavior.js||test/token/common/ERC2981.behavior.js",
          "test/utils/Address.test.js||test/utils/Address.test.js",
          "test/utils/Arrays.test.js||test/utils/Arrays.test.js",
          "test/utils/Base64.test.js||test/utils/Base64.test.js",
          "test/utils/Checkpoints.t.sol||test/utils/Checkpoints.t.sol",
          "test/utils/Checkpoints.test.js||test/utils/Checkpoints.test.js",
          "test/utils/Context.behavior.js||test/utils/Context.behavior.js",
          "test/utils/Context.test.js||test/utils/Context.test.js",
          "test/utils/Counters.test.js||test/utils/Counters.test.js",
          "test/utils/Create2.test.js||test/utils/Create2.test.js",
          "test/utils/Multicall.test.js||test/utils/Multicall.test.js",
          "test/utils/ShortStrings.t.sol||test/utils/ShortStrings.t.sol",
          "test/utils/ShortStrings.test.js||test/utils/ShortStrings.test.js",
          "test/utils/StorageSlot.test.js||test/utils/StorageSlot.test.js",
          "test/utils/Strings.test.js||test/utils/Strings.test.js",
          "test/utils/TimersBlockNumberImpl.test.js||test/utils/TimersBlockNumberImpl.test.js",
          "test/utils/TimersTimestamp.test.js||test/utils/TimersTimestamp.test.js",
          "test/utils/cryptography/ECDSA.test.js||test/utils/cryptography/ECDSA.test.js",
          "test/utils/cryptography/EIP712.test.js||test/utils/cryptography/EIP712.test.js",
          "test/utils/cryptography/MerkleProof.test.js||test/utils/cryptography/MerkleProof.test.js",
          "test/utils/cryptography/SignatureChecker.test.js||test/utils/cryptography/SignatureChecker.test.js",
          "test/utils/escrow/ConditionalEscrow.test.js||test/utils/escrow/ConditionalEscrow.test.js",
          "test/utils/escrow/Escrow.behavior.js||test/utils/escrow/Escrow.behavior.js",
          "test/utils/escrow/Escrow.test.js||test/utils/escrow/Escrow.test.js",
          "test/utils/escrow/RefundEscrow.test.js||test/utils/escrow/RefundEscrow.test.js",
          "test/utils/introspection/ERC165.test.js||test/utils/introspection/ERC165.test.js",
          "test/utils/introspection/ERC165Checker.test.js||test/utils/introspection/ERC165Checker.test.js",
          "test/utils/introspection/ERC165Storage.test.js||test/utils/introspection/ERC165Storage.test.js",
          "test/utils/introspection/ERC1820Implementer.test.js||test/utils/introspection/ERC1820Implementer.test.js",
          "test/utils/introspection/SupportsInterface.behavior.js||test/utils/introspection/SupportsInterface.behavior.js",
          "test/utils/math/Math.t.sol||test/utils/math/Math.t.sol",
          "test/utils/math/Math.test.js||test/utils/math/Math.test.js",
          "test/utils/math/SafeCast.test.js||test/utils/math/SafeCast.test.js",
          "test/utils/math/SafeMath.test.js||test/utils/math/SafeMath.test.js",
          "test/utils/math/SignedMath.test.js||test/utils/math/SignedMath.test.js",
          "test/utils/math/SignedSafeMath.test.js||test/utils/math/SignedSafeMath.test.js",
          "test/utils/structs/BitMap.test.js||test/utils/structs/BitMap.test.js",
          "test/utils/structs/DoubleEndedQueue.test.js||test/utils/structs/DoubleEndedQueue.test.js",
          "test/utils/structs/EnumerableMap.behavior.js||test/utils/structs/EnumerableMap.behavior.js",
          "test/utils/structs/EnumerableMap.test.js||test/utils/structs/EnumerableMap.test.js",
          "test/utils/structs/EnumerableSet.behavior.js||test/utils/structs/EnumerableSet.behavior.js",
          "test/utils/structs/EnumerableSet.test.js||test/utils/structs/EnumerableSet.test.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "contracts/governance/GovernorUpgradeable.sol||contracts/governance/GovernorUpgradeable.sol",
            "test/governance/Governor.test.js||test/governance/Governor.test.js"
          ],
          "candidate": [
            "contracts/governance/GovernorUpgradeable.sol||contracts/governance/GovernorUpgradeable.sol",
            "test/governance/Governor.test.js||test/governance/Governor.test.js"
          ]
        }
      },
      "candidate_diff": {
        ".mocharc.js||.mocharc.js": [
          "File: .mocharc.js -> .mocharc.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: module.exports = {",
          "2:   require: 'hardhat/register',",
          "3:   timeout: 4000,",
          "4: };",
          "",
          "---------------"
        ],
        ".solcover.js||.solcover.js": [
          "File: .solcover.js -> .solcover.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: module.exports = {",
          "2:   norpc: true,",
          "3:   testCommand: 'npm test',",
          "4:   compileCommand: 'npm run compile',",
          "5:   skipFiles: ['mocks'],",
          "6:   providerOptions: {",
          "7:     default_balance_ether: '10000000000000000000000000',",
          "8:   },",
          "9:   mocha: {",
          "10:     fgrep: '[skip-on-coverage]',",
          "11:     invert: true,",
          "12:   },",
          "13: };",
          "",
          "---------------"
        ],
        "certorharnesses/AccessControlDefaultAdminRulesHarness.sol||certora/harnesses/AccessControlDefaultAdminRulesHarness.sol": [
          "File: certorharnesses/AccessControlDefaultAdminRulesHarness.sol -> certora/harnesses/AccessControlDefaultAdminRulesHarness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../patched/access/AccessControlDefaultAdminRules.sol\";",
          "7: contract AccessControlDefaultAdminRulesHarness is AccessControlDefaultAdminRules {",
          "8:     uint48 private _delayIncreaseWait;",
          "10:     constructor(",
          "11:         uint48 initialDelay,",
          "12:         address initialDefaultAdmin,",
          "13:         uint48 delayIncreaseWait",
          "14:     ) AccessControlDefaultAdminRules(initialDelay, initialDefaultAdmin) {",
          "15:         _delayIncreaseWait = delayIncreaseWait;",
          "16:     }",
          "19:     function pendingDefaultAdmin_() external view returns (address) {",
          "20:         (address newAdmin, ) = pendingDefaultAdmin();",
          "21:         return newAdmin;",
          "22:     }",
          "24:     function pendingDefaultAdminSchedule_() external view returns (uint48) {",
          "25:         (, uint48 schedule) = pendingDefaultAdmin();",
          "26:         return schedule;",
          "27:     }",
          "29:     function pendingDelay_() external view returns (uint48) {",
          "30:         (uint48 newDelay, ) = pendingDefaultAdminDelay();",
          "31:         return newDelay;",
          "32:     }",
          "34:     function pendingDelaySchedule_() external view returns (uint48) {",
          "35:         (, uint48 schedule) = pendingDefaultAdminDelay();",
          "36:         return schedule;",
          "37:     }",
          "39:     function delayChangeWait_(uint48 newDelay) external view returns (uint48) {",
          "40:         return _delayChangeWait(newDelay);",
          "41:     }",
          "44:     function defaultAdminDelayIncreaseWait() public view override returns (uint48) {",
          "45:         return _delayIncreaseWait;",
          "46:     }",
          "47: }",
          "",
          "---------------"
        ],
        "certorharnesses/AccessControlHarness.sol||certora/harnesses/AccessControlHarness.sol": [
          "File: certorharnesses/AccessControlHarness.sol -> certora/harnesses/AccessControlHarness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../patched/access/AccessControl.sol\";",
          "7: contract AccessControlHarness is AccessControl {}",
          "",
          "---------------"
        ],
        "certorharnesses/DoubleEndedQueueHarness.sol||certora/harnesses/DoubleEndedQueueHarness.sol": [
          "File: certorharnesses/DoubleEndedQueueHarness.sol -> certora/harnesses/DoubleEndedQueueHarness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../patched/utils/structs/DoubleEndedQueue.sol\";",
          "7: contract DoubleEndedQueueHarness {",
          "8:     using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;",
          "10:     DoubleEndedQueue.Bytes32Deque private _deque;",
          "12:     function pushFront(bytes32 value) external {",
          "13:         _deque.pushFront(value);",
          "14:     }",
          "16:     function pushBack(bytes32 value) external {",
          "17:         _deque.pushBack(value);",
          "18:     }",
          "20:     function popFront() external returns (bytes32 value) {",
          "21:         return _deque.popFront();",
          "22:     }",
          "24:     function popBack() external returns (bytes32 value) {",
          "25:         return _deque.popBack();",
          "26:     }",
          "28:     function clear() external {",
          "29:         _deque.clear();",
          "30:     }",
          "32:     function begin() external view returns (int128) {",
          "33:         return _deque._begin;",
          "34:     }",
          "36:     function end() external view returns (int128) {",
          "37:         return _deque._end;",
          "38:     }",
          "40:     function length() external view returns (uint256) {",
          "41:         return _deque.length();",
          "42:     }",
          "44:     function empty() external view returns (bool) {",
          "45:         return _deque.empty();",
          "46:     }",
          "48:     function front() external view returns (bytes32 value) {",
          "49:         return _deque.front();",
          "50:     }",
          "52:     function back() external view returns (bytes32 value) {",
          "53:         return _deque.back();",
          "54:     }",
          "56:     function at_(uint256 index) external view returns (bytes32 value) {",
          "57:         return _deque.at(index);",
          "58:     }",
          "59: }",
          "",
          "---------------"
        ],
        "certorharnesses/ERC20FlashMintHarness.sol||certora/harnesses/ERC20FlashMintHarness.sol": [
          "File: certorharnesses/ERC20FlashMintHarness.sol -> certora/harnesses/ERC20FlashMintHarness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../patched/token/ERC20/ERC20.sol\";",
          "6: import \"../patched/token/ERC20/extensions/ERC20Permit.sol\";",
          "7: import \"../patched/token/ERC20/extensions/ERC20FlashMint.sol\";",
          "9: contract ERC20FlashMintHarness is ERC20, ERC20Permit, ERC20FlashMint {",
          "10:     uint256 someFee;",
          "11:     address someFeeReceiver;",
          "13:     constructor(string memory name, string memory symbol) ERC20(name, symbol) ERC20Permit(name) {}",
          "15:     function mint(address account, uint256 amount) external {",
          "16:         _mint(account, amount);",
          "17:     }",
          "19:     function burn(address account, uint256 amount) external {",
          "20:         _burn(account, amount);",
          "21:     }",
          "24:     function flashFeeReceiver() public view returns (address) {",
          "25:         return someFeeReceiver;",
          "26:     }",
          "29:     function _flashFee(address, uint256) internal view override returns (uint256) {",
          "30:         return someFee;",
          "31:     }",
          "33:     function _flashFeeReceiver() internal view override returns (address) {",
          "34:         return someFeeReceiver;",
          "35:     }",
          "36: }",
          "",
          "---------------"
        ],
        "certorharnesses/ERC20PermitHarness.sol||certora/harnesses/ERC20PermitHarness.sol": [
          "File: certorharnesses/ERC20PermitHarness.sol -> certora/harnesses/ERC20PermitHarness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../patched/token/ERC20/extensions/ERC20Permit.sol\";",
          "7: contract ERC20PermitHarness is ERC20Permit {",
          "8:     constructor(string memory name, string memory symbol) ERC20(name, symbol) ERC20Permit(name) {}",
          "10:     function mint(address account, uint256 amount) external {",
          "11:         _mint(account, amount);",
          "12:     }",
          "14:     function burn(address account, uint256 amount) external {",
          "15:         _burn(account, amount);",
          "16:     }",
          "17: }",
          "",
          "---------------"
        ],
        "certorharnesses/ERC20WrapperHarness.sol||certora/harnesses/ERC20WrapperHarness.sol": [
          "File: certorharnesses/ERC20WrapperHarness.sol -> certora/harnesses/ERC20WrapperHarness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../patched/token/ERC20/extensions/ERC20Wrapper.sol\";",
          "7: contract ERC20WrapperHarness is ERC20Wrapper {",
          "8:     constructor(IERC20 _underlying, string memory _name, string memory _symbol) ERC20(_name, _symbol) ERC20Wrapper(_underlying) {}",
          "10:     function underlyingTotalSupply() public view returns (uint256) {",
          "11:         return underlying().totalSupply();",
          "12:     }",
          "14:     function underlyingBalanceOf(address account) public view returns (uint256) {",
          "15:         return underlying().balanceOf(account);",
          "16:     }",
          "18:     function underlyingAllowanceToThis(address account) public view returns (uint256) {",
          "19:         return underlying().allowance(account, address(this));",
          "20:     }",
          "22:     function recover(address account) public returns (uint256) {",
          "23:         return _recover(account);",
          "24:     }",
          "25: }",
          "",
          "---------------"
        ],
        "certorharnesses/ERC3156FlashBorrowerHarness.sol||certora/harnesses/ERC3156FlashBorrowerHarness.sol": [
          "File: certorharnesses/ERC3156FlashBorrowerHarness.sol -> certora/harnesses/ERC3156FlashBorrowerHarness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: import \"../patched/interfaces/IERC3156FlashBorrower.sol\";",
          "5: pragma solidity ^0.8.0;",
          "7: contract ERC3156FlashBorrowerHarness is IERC3156FlashBorrower {",
          "8:     bytes32 somethingToReturn;",
          "10:     function onFlashLoan(address, address, uint256, uint256, bytes calldata) external view override returns (bytes32) {",
          "11:         return somethingToReturn;",
          "12:     }",
          "13: }",
          "",
          "---------------"
        ],
        "certorharnesses/ERC721Harness.sol||certora/harnesses/ERC721Harness.sol": [
          "File: certorharnesses/ERC721Harness.sol -> certora/harnesses/ERC721Harness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../patched/token/ERC721/ERC721.sol\";",
          "7: contract ERC721Harness is ERC721 {",
          "8:     constructor(string memory name, string memory symbol) ERC721(name, symbol) {}",
          "10:     function mint(address account, uint256 tokenId) external {",
          "11:         _mint(account, tokenId);",
          "12:     }",
          "14:     function safeMint(address to, uint256 tokenId) external {",
          "15:         _safeMint(to, tokenId);",
          "16:     }",
          "18:     function safeMint(address to, uint256 tokenId, bytes memory data) external {",
          "19:         _safeMint(to, tokenId, data);",
          "20:     }",
          "22:     function burn(uint256 tokenId) external {",
          "23:         _burn(tokenId);",
          "24:     }",
          "26:     function tokenExists(uint256 tokenId) external view returns (bool) {",
          "27:         return _exists(tokenId);",
          "28:     }",
          "30:     function unsafeOwnerOf(uint256 tokenId) external view returns (address) {",
          "31:         return _ownerOf(tokenId);",
          "32:     }",
          "34:     function unsafeGetApproved(uint256 tokenId) external view returns (address) {",
          "35:         return _getApproved(tokenId);",
          "36:     }",
          "37: }",
          "",
          "---------------"
        ],
        "certorharnesses/ERC721ReceiverHarness.sol||certora/harnesses/ERC721ReceiverHarness.sol": [
          "File: certorharnesses/ERC721ReceiverHarness.sol -> certora/harnesses/ERC721ReceiverHarness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../patched/interfaces/IERC721Receiver.sol\";",
          "7: contract ERC721ReceiverHarness is IERC721Receiver {",
          "8:     function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {",
          "9:         return this.onERC721Received.selector;",
          "10:     }",
          "11: }",
          "",
          "---------------"
        ],
        "certorharnesses/EnumerableMapHarness.sol||certora/harnesses/EnumerableMapHarness.sol": [
          "File: certorharnesses/EnumerableMapHarness.sol -> certora/harnesses/EnumerableMapHarness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../patched/utils/structs/EnumerableMap.sol\";",
          "7: contract EnumerableMapHarness {",
          "8:     using EnumerableMap for EnumerableMap.Bytes32ToBytes32Map;",
          "10:     EnumerableMap.Bytes32ToBytes32Map private _map;",
          "12:     function set(bytes32 key, bytes32 value) public returns (bool) {",
          "13:         return _map.set(key, value);",
          "14:     }",
          "16:     function remove(bytes32 key) public returns (bool) {",
          "17:         return _map.remove(key);",
          "18:     }",
          "20:     function contains(bytes32 key) public view returns (bool) {",
          "21:         return _map.contains(key);",
          "22:     }",
          "24:     function length() public view returns (uint256) {",
          "25:         return _map.length();",
          "26:     }",
          "28:     function key_at(uint256 index) public view returns (bytes32) {",
          "29:         (bytes32 key,) = _map.at(index);",
          "30:         return key;",
          "31:     }",
          "33:     function value_at(uint256 index) public view returns (bytes32) {",
          "34:         (,bytes32 value) = _map.at(index);",
          "35:         return value;",
          "36:     }",
          "38:     function tryGet_contains(bytes32 key) public view returns (bool) {",
          "39:         (bool contained,) = _map.tryGet(key);",
          "40:         return contained;",
          "41:     }",
          "43:     function tryGet_value(bytes32 key) public view returns (bytes32) {",
          "44:         (,bytes32 value) = _map.tryGet(key);",
          "45:         return value;",
          "46:     }",
          "48:     function get(bytes32 key) public view returns (bytes32) {",
          "49:         return _map.get(key);",
          "50:     }",
          "52:     function _indexOf(bytes32 key) public view returns (uint256) {",
          "53:         return _map._keys._inner._indexes[key];",
          "54:     }",
          "55: }",
          "",
          "---------------"
        ],
        "certorharnesses/EnumerableSetHarness.sol||certora/harnesses/EnumerableSetHarness.sol": [
          "File: certorharnesses/EnumerableSetHarness.sol -> certora/harnesses/EnumerableSetHarness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../patched/utils/structs/EnumerableSet.sol\";",
          "7: contract EnumerableSetHarness {",
          "8:     using EnumerableSet for EnumerableSet.Bytes32Set;",
          "10:     EnumerableSet.Bytes32Set private _set;",
          "12:     function add(bytes32 value) public returns (bool) {",
          "13:         return _set.add(value);",
          "14:     }",
          "16:     function remove(bytes32 value) public returns (bool) {",
          "17:         return _set.remove(value);",
          "18:     }",
          "20:     function contains(bytes32 value) public view returns (bool) {",
          "21:         return _set.contains(value);",
          "22:     }",
          "24:     function length() public view returns (uint256) {",
          "25:         return _set.length();",
          "26:     }",
          "28:     function at_(uint256 index) public view returns (bytes32) {",
          "29:         return _set.at(index);",
          "30:     }",
          "32:     function _indexOf(bytes32 value) public view returns (uint256) {",
          "33:         return _set._inner._indexes[value];",
          "34:     }",
          "35: }",
          "",
          "---------------"
        ],
        "certorharnesses/InitializableHarness.sol||certora/harnesses/InitializableHarness.sol": [
          "File: certorharnesses/InitializableHarness.sol -> certora/harnesses/InitializableHarness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: pragma solidity ^0.8.2;",
          "4: import \"../patched/proxy/utils/Initializable.sol\";",
          "6: contract InitializableHarness is Initializable {",
          "7:     function initialize()          public initializer      {}",
          "8:     function reinitialize(uint8 n) public reinitializer(n) {}",
          "9:     function disable()             public { _disableInitializers(); }",
          "11:     function nested_init_init()                     public initializer      { initialize();    }",
          "12:     function nested_init_reinit(uint8 m)            public initializer      { reinitialize(m); }",
          "13:     function nested_reinit_init(uint8 n)            public reinitializer(n) { initialize();    }",
          "14:     function nested_reinit_reinit(uint8 n, uint8 m) public reinitializer(n) { reinitialize(m); }",
          "16:     function version() public view returns (uint8) {",
          "17:         return _getInitializedVersion();",
          "18:     }",
          "20:     function initializing() public view returns (bool) {",
          "21:         return _isInitializing();",
          "22:     }",
          "23: }",
          "",
          "---------------"
        ],
        "certorharnesses/Ownable2StepHarness.sol||certora/harnesses/Ownable2StepHarness.sol": [
          "File: certorharnesses/Ownable2StepHarness.sol -> certora/harnesses/Ownable2StepHarness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../patched/access/Ownable2Step.sol\";",
          "7: contract Ownable2StepHarness is Ownable2Step {",
          "8:   function restricted() external onlyOwner {}",
          "9: }",
          "",
          "---------------"
        ],
        "certorharnesses/OwnableHarness.sol||certora/harnesses/OwnableHarness.sol": [
          "File: certorharnesses/OwnableHarness.sol -> certora/harnesses/OwnableHarness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../patched/access/Ownable.sol\";",
          "7: contract OwnableHarness is Ownable {",
          "8:   function restricted() external onlyOwner {}",
          "9: }",
          "",
          "---------------"
        ],
        "certorharnesses/PausableHarness.sol||certora/harnesses/PausableHarness.sol": [
          "File: certorharnesses/PausableHarness.sol -> certora/harnesses/PausableHarness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../patched/security/Pausable.sol\";",
          "7: contract PausableHarness is Pausable {",
          "8:     function pause() external {",
          "9:         _pause();",
          "10:     }",
          "12:     function unpause() external {",
          "13:         _unpause();",
          "14:     }",
          "16:     function onlyWhenPaused() external whenPaused {}",
          "18:     function onlyWhenNotPaused() external whenNotPaused {}",
          "19: }",
          "",
          "---------------"
        ],
        "certorharnesses/TimelockControllerHarness.sol||certora/harnesses/TimelockControllerHarness.sol": [
          "File: certorharnesses/TimelockControllerHarness.sol -> certora/harnesses/TimelockControllerHarness.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: pragma solidity ^0.8.0;",
          "3: import \"../patched/governance/TimelockController.sol\";",
          "5: contract TimelockControllerHarness is TimelockController {",
          "6:     constructor(",
          "7:         uint256 minDelay,",
          "8:         address[] memory proposers,",
          "9:         address[] memory executors,",
          "10:         address admin",
          "11:     ) TimelockController(minDelay, proposers, executors, admin) {}",
          "12: }",
          "",
          "---------------"
        ],
        "certorrun.js||certora/run.js": [
          "File: certorrun.js -> certora/run.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env node",
          "10: const proc = require('child_process');",
          "11: const { PassThrough } = require('stream');",
          "12: const events = require('events');",
          "14: const argv = require('yargs')",
          "15:   .env('')",
          "16:   .options({",
          "17:     all: {",
          "18:       alias: 'a',",
          "19:       type: 'boolean',",
          "20:     },",
          "21:     spec: {",
          "22:       alias: 's',",
          "23:       type: 'string',",
          "24:       default: __dirname + '/specs.json',",
          "25:     },",
          "26:     parallel: {",
          "27:       alias: 'p',",
          "28:       type: 'number',",
          "29:       default: 4,",
          "30:     },",
          "31:     options: {",
          "32:       alias: 'o',",
          "33:       type: 'array',",
          "34:       default: [],",
          "35:     },",
          "36:   }).argv;",
          "38: function match(entry, request) {",
          "39:   const [reqSpec, reqContract] = request.split(':').reverse();",
          "40:   return entry.spec == reqSpec && (!reqContract || entry.contract == reqContract);",
          "41: }",
          "43: const specs = require(argv.spec).filter(s => argv.all || argv._.some(r => match(s, r)));",
          "44: const limit = require('p-limit')(argv.parallel);",
          "46: if (argv._.length == 0 && !argv.all) {",
          "47:   console.error(`Warning: No specs requested. Did you forgot to toggle '--all'?`);",
          "48: }",
          "50: for (const r of argv._) {",
          "51:   if (!specs.some(s => match(s, r))) {",
          "52:     console.error(`Error: Requested spec '${r}' not found in ${argv.spec}`);",
          "53:     process.exitCode = 1;",
          "54:   }",
          "55: }",
          "57: if (process.exitCode) {",
          "58:   process.exit(process.exitCode);",
          "59: }",
          "61: for (const { spec, contract, files, options = [] } of specs) {",
          "62:   limit(runCertora, spec, contract, files, [...options.flatMap(opt => opt.split(' ')), ...argv.options]);",
          "63: }",
          "66: async function runCertora(spec, contract, files, options = []) {",
          "67:   const args = [...files, '--verify', `${contract}:certora/specs/${spec}.spec`, ...options];",
          "68:   const child = proc.spawn('certoraRun', args);",
          "70:   const stream = new PassThrough();",
          "71:   const output = collect(stream);",
          "73:   child.stdout.pipe(stream, { end: false });",
          "74:   child.stderr.pipe(stream, { end: false });",
          "77:   stream.on('data', function logStatusUrl(data) {",
          "78:     const { '-DjobId': jobId, '-DuserId': userId } = Object.fromEntries(",
          "79:       data",
          "80:         .toString('utf8')",
          "81:         .match(/-D\\S+=\\S+/g)",
          "82:         ?.map(s => s.split('=')) || [],",
          "83:     );",
          "85:     if (jobId && userId) {",
          "86:       console.error(`[${spec}] https://prover.certora.com/output/${userId}/${jobId}/`);",
          "87:       stream.off('data', logStatusUrl);",
          "88:     }",
          "89:   });",
          "92:   const [code, signal] = await events.once(child, 'exit');",
          "95:   if (code || signal) {",
          "96:     console.error(`[${spec}] Exited with code ${code || signal}`);",
          "97:     process.exitCode = 1;",
          "98:   }",
          "101:   stream.end();",
          "104:   writeEntry(spec, contract, code || signal, (await output).match(/https:\\/\\/prover.certora.com\\/output\\/\\S*/)?.[0]);",
          "107:   console.error(`+ certoraRun ${args.join(' ')}\\n` + (await output));",
          "108: }",
          "111: async function collect(stream) {",
          "112:   const buffers = [];",
          "113:   for await (const data of stream) {",
          "114:     const buf = Buffer.isBuffer(data) ? data : Buffer.from(data);",
          "115:     buffers.push(buf);",
          "116:   }",
          "117:   return Buffer.concat(buffers).toString('utf8');",
          "118: }",
          "121: let hasHeader = false;",
          "123: function formatRow(...array) {",
          "124:   return ['', ...array, ''].join(' | ');",
          "125: }",
          "127: function writeHeader() {",
          "128:   console.log(formatRow('spec', 'contract', 'result', 'status', 'output'));",
          "129:   console.log(formatRow('-', '-', '-', '-', '-'));",
          "130: }",
          "132: function writeEntry(spec, contract, success, url) {",
          "133:   if (!hasHeader) {",
          "134:     hasHeader = true;",
          "135:     writeHeader();",
          "136:   }",
          "137:   console.log(",
          "138:     formatRow(",
          "139:       spec,",
          "140:       contract,",
          "141:       success ? ':x:' : ':heavy_check_mark:',",
          "142:       url ? `[link](${url?.replace('/output/', '/jobStatus/')})` : 'error',",
          "143:       url ? `[link](${url})` : 'error',",
          "144:     ),",
          "145:   );",
          "146: }",
          "",
          "---------------"
        ],
        "certorspecs/AccessControl.spec||certora/specs/AccessControl.spec": [
          "File: certorspecs/AccessControl.spec -> certora/specs/AccessControl.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import \"helpers/helpers.spec\"",
          "2: import \"methods/IAccessControl.spec\"",
          "5: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "6: \u2502 Definitions                                                                                                         \u2502",
          "7: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "9: definition DEFAULT_ADMIN_ROLE() returns bytes32 = 0x0000000000000000000000000000000000000000000000000000000000000000;",
          "12: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "13: \u2502 Identify entrypoints: only grantRole, revokeRole and renounceRole can alter permissions                             \u2502",
          "14: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "16: rule onlyGrantCanGrant(env e, method f, bytes32 role, address account) {",
          "17:     calldataarg args;",
          "19:     bool hasRoleBefore = hasRole(role, account);",
          "20:     f(e, args);",
          "21:     bool hasRoleAfter = hasRole(role, account);",
          "23:     assert (",
          "24:         !hasRoleBefore &&",
          "25:         hasRoleAfter",
          "26:     ) => (",
          "27:         f.selector == grantRole(bytes32, address).selector",
          "28:     );",
          "30:     assert (",
          "31:         hasRoleBefore &&",
          "32:         !hasRoleAfter",
          "33:     ) => (",
          "34:         f.selector == revokeRole(bytes32, address).selector ||",
          "35:         f.selector == renounceRole(bytes32, address).selector",
          "36:     );",
          "37: }",
          "40: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "41: \u2502 Function correctness: grantRole only affects the specified user/role combo                                          \u2502",
          "42: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "44: rule grantRoleEffect(env e, bytes32 role) {",
          "45:     require nonpayable(e);",
          "47:     bytes32 otherRole;",
          "48:     address account;",
          "49:     address otherAccount;",
          "51:     bool isCallerAdmin = hasRole(getRoleAdmin(role), e.msg.sender);",
          "52:     bool hasOtherRoleBefore = hasRole(otherRole, otherAccount);",
          "54:     grantRole@withrevert(e, role, account);",
          "55:     bool success = !lastReverted;",
          "57:     bool hasOtherRoleAfter = hasRole(otherRole, otherAccount);",
          "60:     assert success <=> isCallerAdmin;",
          "63:     assert success => hasRole(role, account);",
          "66:     assert hasOtherRoleBefore != hasOtherRoleAfter => (role == otherRole && account == otherAccount);",
          "67: }",
          "70: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "71: \u2502 Function correctness: revokeRole only affects the specified user/role combo                                         \u2502",
          "72: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "74: rule revokeRoleEffect(env e, bytes32 role) {",
          "75:     require nonpayable(e);",
          "77:     bytes32 otherRole;",
          "78:     address account;",
          "79:     address otherAccount;",
          "81:     bool isCallerAdmin = hasRole(getRoleAdmin(role), e.msg.sender);",
          "82:     bool hasOtherRoleBefore = hasRole(otherRole, otherAccount);",
          "84:     revokeRole@withrevert(e, role, account);",
          "85:     bool success = !lastReverted;",
          "87:     bool hasOtherRoleAfter = hasRole(otherRole, otherAccount);",
          "90:     assert success <=> isCallerAdmin;",
          "93:     assert success => !hasRole(role, account);",
          "96:     assert hasOtherRoleBefore != hasOtherRoleAfter => (role == otherRole && account == otherAccount);",
          "97: }",
          "100: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "101: \u2502 Function correctness: renounceRole only affects the specified user/role combo                                       \u2502",
          "102: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "104: rule renounceRoleEffect(env e, bytes32 role) {",
          "105:     require nonpayable(e);",
          "107:     bytes32 otherRole;",
          "108:     address account;",
          "109:     address otherAccount;",
          "111:     bool hasOtherRoleBefore = hasRole(otherRole, otherAccount);",
          "113:     renounceRole@withrevert(e, role, account);",
          "114:     bool success = !lastReverted;",
          "116:     bool hasOtherRoleAfter = hasRole(otherRole, otherAccount);",
          "119:     assert success <=> account == e.msg.sender;",
          "122:     assert success => !hasRole(role, account);",
          "125:     assert hasOtherRoleBefore != hasOtherRoleAfter => (role == otherRole && account == otherAccount);",
          "126: }",
          "",
          "---------------"
        ],
        "certorspecs/AccessControlDefaultAdminRules.spec||certora/specs/AccessControlDefaultAdminRules.spec": [
          "File: certorspecs/AccessControlDefaultAdminRules.spec -> certora/specs/AccessControlDefaultAdminRules.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import \"helpers/helpers.spec\"",
          "2: import \"methods/IAccessControlDefaultAdminRules.spec\"",
          "3: import \"methods/IAccessControl.spec\"",
          "4: import \"AccessControl.spec\"",
          "6: use rule onlyGrantCanGrant filtered {",
          "7:   f -> f.selector != acceptDefaultAdminTransfer().selector",
          "8: }",
          "11: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "12: \u2502 Helpers                                                                                                             \u2502",
          "13: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "16: function max_uint48() returns mathint {",
          "17:     return (1 << 48) - 1;",
          "18: }",
          "20: function nonZeroAccount(address account) returns bool {",
          "21:   return account != 0;",
          "22: }",
          "24: function timeSanity(env e) returns bool {",
          "25:   return",
          "26:     e.block.timestamp > 0 && // Avoids 0 schedules",
          "27:     e.block.timestamp + defaultAdminDelay(e) < max_uint48();",
          "28: }",
          "30: function delayChangeWaitSanity(env e, uint48 newDelay) returns bool {",
          "31:   return e.block.timestamp + delayChangeWait_(e, newDelay) < max_uint48();",
          "32: }",
          "34: function isSet(uint48 schedule) returns bool {",
          "35:   return schedule != 0;",
          "36: }",
          "38: function hasPassed(env e, uint48 schedule) returns bool {",
          "39:   return schedule < e.block.timestamp;",
          "40: }",
          "42: function min(uint48 a, uint48 b) returns mathint {",
          "43:   return a < b ? a : b;",
          "44: }",
          "46: function increasingDelaySchedule(env e, uint48 newDelay) returns mathint {",
          "47:   return e.block.timestamp + min(newDelay, defaultAdminDelayIncreaseWait());",
          "48: }",
          "50: function decreasingDelaySchedule(env e, uint48 newDelay) returns mathint {",
          "51:   return e.block.timestamp + defaultAdminDelay(e) - newDelay;",
          "52: }",
          "55: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "56: \u2502 Invariant: defaultAdmin holds the DEFAULT_ADMIN_ROLE                                                                \u2502",
          "57: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "59: invariant defaultAdminConsistency(address account)",
          "60:   defaultAdmin() == account <=> hasRole(DEFAULT_ADMIN_ROLE(), account)",
          "61:   {",
          "62:     preserved {",
          "64:       require nonZeroAccount(account);",
          "65:     }",
          "66:   }",
          "69: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "70: \u2502 Invariant: Only one account holds the DEFAULT_ADMIN_ROLE                                                            \u2502",
          "71: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "73: invariant singleDefaultAdmin(address account, address another)",
          "74:   hasRole(DEFAULT_ADMIN_ROLE(), account) && hasRole(DEFAULT_ADMIN_ROLE(), another) => another == account",
          "78:   filtered { f -> f.selector != acceptDefaultAdminTransfer().selector }",
          "81: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "82: \u2502 Invariant: DEFAULT_ADMIN_ROLE's admin is always DEFAULT_ADMIN_ROLE                                                  \u2502",
          "83: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "85: invariant defaultAdminRoleAdminConsistency()",
          "86:   getRoleAdmin(DEFAULT_ADMIN_ROLE()) == DEFAULT_ADMIN_ROLE()",
          "89: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "90: \u2502 Invariant: owner is the defaultAdmin                                                                                \u2502",
          "91: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "93: invariant ownerConsistency()",
          "94:   defaultAdmin() == owner()",
          "97: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "98: \u2502 Function correctness: revokeRole only affects the specified user/role combo                                         \u2502",
          "99: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "101: rule revokeRoleEffect(env e, bytes32 role) {",
          "102:     require nonpayable(e);",
          "104:     bytes32 otherRole;",
          "105:     address account;",
          "106:     address otherAccount;",
          "108:     bool isCallerAdmin = hasRole(getRoleAdmin(role), e.msg.sender);",
          "109:     bool hasOtherRoleBefore = hasRole(otherRole, otherAccount);",
          "111:     revokeRole@withrevert(e, role, account);",
          "112:     bool success = !lastReverted;",
          "114:     bool hasOtherRoleAfter = hasRole(otherRole, otherAccount);",
          "117:     assert success <=> isCallerAdmin && role != DEFAULT_ADMIN_ROLE(),",
          "118:       \"roles can only be revoked by their owner except for the default admin role\";",
          "121:     assert success => !hasRole(role, account), \"role is revoked\";",
          "124:     assert hasOtherRoleBefore != hasOtherRoleAfter => (role == otherRole && account == otherAccount),",
          "125:       \"no other role is affected\";",
          "126: }",
          "129: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "130: \u2502 Function correctness: renounceRole only affects the specified user/role combo                                       \u2502",
          "131: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "133: rule renounceRoleEffect(env e, bytes32 role) {",
          "134:     require nonpayable(e);",
          "136:     bytes32 otherRole;",
          "137:     address account;",
          "138:     address otherAccount;",
          "140:     bool hasOtherRoleBefore = hasRole(otherRole, otherAccount);",
          "141:     uint48 scheduleBefore = pendingDefaultAdminSchedule_();",
          "142:     address pendingAdminBefore = pendingDefaultAdmin_();",
          "144:     renounceRole@withrevert(e, role, account);",
          "145:     bool success = !lastReverted;",
          "147:     bool hasOtherRoleAfter = hasRole(otherRole, otherAccount);",
          "150:     assert success <=> (",
          "151:       account == e.msg.sender &&",
          "152:       (",
          "153:         (",
          "154:           role != DEFAULT_ADMIN_ROLE()",
          "155:         ) || (",
          "156:           role == DEFAULT_ADMIN_ROLE() &&",
          "157:           pendingAdminBefore == 0 &&",
          "158:           isSet(scheduleBefore) &&",
          "159:           hasPassed(e, scheduleBefore)",
          "160:         )",
          "161:       )",
          "162:     ), \"an account only can renounce by itself with a delay for the default admin role\";",
          "165:     assert success => !hasRole(role, account), \"role is renounced\";",
          "168:     assert hasOtherRoleBefore != hasOtherRoleAfter => (role == otherRole && account == otherAccount),",
          "169:       \"no other role is affected\";",
          "170: }",
          "173: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "174: \u2502 Rule: defaultAdmin is only affected by accepting an admin transfer or renoucing                                     \u2502",
          "175: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "177: rule noDefaultAdminChange(env e, method f, calldataarg args) {",
          "178:   require nonZeroAccount(e.msg.sender);",
          "179:   requireInvariant defaultAdminConsistency(defaultAdmin());",
          "180:   requireInvariant singleDefaultAdmin(e.msg.sender, defaultAdmin());",
          "182:   address adminBefore = defaultAdmin();",
          "183:   f(e, args);",
          "184:   address adminAfter = defaultAdmin();",
          "186:   assert adminBefore != adminAfter => (",
          "187:     f.selector == acceptDefaultAdminTransfer().selector ||",
          "188:     f.selector == renounceRole(bytes32,address).selector",
          "189:   ), \"default admin is only affected by accepting an admin transfer or renoucing\";",
          "190: }",
          "193: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "194: \u2502 Rule: pendingDefaultAdmin is only affected by beginning, accepting or canceling an admin transfer                   \u2502",
          "195: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "197: rule noPendingDefaultAdminChange(env e, method f, calldataarg args) {",
          "198:   requireInvariant defaultAdminConsistency(defaultAdmin());",
          "199:   requireInvariant singleDefaultAdmin(e.msg.sender, defaultAdmin());",
          "201:   address pendingAdminBefore = pendingDefaultAdmin_();",
          "202:   address scheduleBefore = pendingDefaultAdminSchedule_();",
          "203:   f(e, args);",
          "204:   address pendingAdminAfter = pendingDefaultAdmin_();",
          "205:   address scheduleAfter = pendingDefaultAdminSchedule_();",
          "207:   assert (",
          "208:     pendingAdminBefore != pendingAdminAfter ||",
          "209:     scheduleBefore != scheduleAfter",
          "210:   ) => (",
          "211:     f.selector == beginDefaultAdminTransfer(address).selector ||",
          "212:     f.selector == acceptDefaultAdminTransfer().selector ||",
          "213:     f.selector == cancelDefaultAdminTransfer().selector",
          "214:   ), \"pending admin and its schedule is only affected by beginning, accepting or cancelling an admin transfer\";",
          "215: }",
          "218: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "219: \u2502 Rule: defaultAdminDelay can't be changed atomically by any function                                                 \u2502",
          "220: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "222: rule noDefaultAdminDelayChange(env e, method f, calldataarg args) {",
          "223:   uint48 delayBefore = defaultAdminDelay(e);",
          "224:   f(e, args);",
          "225:   uint48 delayAfter = defaultAdminDelay(e);",
          "227:   assert delayBefore == delayAfter, \"delay can't be changed atomically by any function\";",
          "228: }",
          "231: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "232: \u2502 Rule: pendingDefaultAdminDelay is only affected by changeDefaultAdminDelay or rollbackDefaultAdminDelay             \u2502",
          "233: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "235: rule noPendingDefaultAdminDelayChange(env e, method f, calldataarg args) {",
          "236:   uint48 pendingDelayBefore = pendingDelay_(e);",
          "237:   f(e, args);",
          "238:   uint48 pendingDelayAfter = pendingDelay_(e);",
          "240:   assert pendingDelayBefore != pendingDelayAfter => (",
          "241:     f.selector == changeDefaultAdminDelay(uint48).selector ||",
          "242:     f.selector == rollbackDefaultAdminDelay().selector",
          "243:   ), \"pending delay is only affected by changeDefaultAdminDelay or rollbackDefaultAdminDelay\";",
          "244: }",
          "247: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "248: \u2502 Rule: defaultAdminDelayIncreaseWait can't be changed atomically by any function                                     \u2502",
          "249: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "251: rule noDefaultAdminDelayIncreaseWaitChange(env e, method f, calldataarg args) {",
          "252:   uint48 delayIncreaseWaitBefore = defaultAdminDelayIncreaseWait();",
          "253:   f(e, args);",
          "254:   uint48 delayIncreaseWaitAfter = defaultAdminDelayIncreaseWait();",
          "256:   assert delayIncreaseWaitBefore == delayIncreaseWaitAfter,",
          "257:     \"delay increase wait can't be changed atomically by any function\";",
          "258: }",
          "261: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "262: \u2502 Function correctness: beginDefaultAdminTransfer sets a pending default admin and its schedule                       \u2502",
          "263: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "265: rule beginDefaultAdminTransfer(env e, address newAdmin) {",
          "266:   require nonpayable(e);",
          "267:   require timeSanity(e);",
          "268:   requireInvariant defaultAdminConsistency(defaultAdmin());",
          "269:   requireInvariant singleDefaultAdmin(e.msg.sender, defaultAdmin());",
          "271:   beginDefaultAdminTransfer@withrevert(e, newAdmin);",
          "272:   bool success = !lastReverted;",
          "275:   assert success <=> e.msg.sender == defaultAdmin(),",
          "276:     \"only the current default admin can begin a transfer\";",
          "279:   assert success => pendingDefaultAdmin_() == newAdmin,",
          "280:     \"pending default admin is set\";",
          "281:   assert success => pendingDefaultAdminSchedule_() == e.block.timestamp + defaultAdminDelay(e),",
          "282:     \"pending default admin delay is set\";",
          "283: }",
          "286: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "287: \u2502 Rule: A default admin can't change in less than the applied schedule                                                \u2502",
          "288: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "290: rule pendingDefaultAdminDelayEnforced(env e1, env e2, method f, calldataarg args, address newAdmin) {",
          "291:   require e1.block.timestamp < e2.block.timestamp;",
          "293:   uint48 delayBefore = defaultAdminDelay(e1);",
          "294:   address adminBefore = defaultAdmin();",
          "297:   beginDefaultAdminTransfer(e1, newAdmin);",
          "298:   f(e2, args);",
          "299:   address adminAfter = defaultAdmin();",
          "301:   assert adminAfter == newAdmin => ((e2.block.timestamp >= e1.block.timestamp + delayBefore) || adminBefore == newAdmin),",
          "302:     \"A delay can't change in less than applied schedule\";",
          "303: }",
          "306: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "307: \u2502 Function correctness: acceptDefaultAdminTransfer updates defaultAdmin resetting the pending admin and its schedule  \u2502",
          "308: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "310: rule acceptDefaultAdminTransfer(env e) {",
          "311:   require nonpayable(e);",
          "312:   requireInvariant defaultAdminConsistency(defaultAdmin());",
          "313:   requireInvariant singleDefaultAdmin(e.msg.sender, defaultAdmin());",
          "315:   address pendingAdminBefore = pendingDefaultAdmin_();",
          "316:   uint48 scheduleAfter = pendingDefaultAdminSchedule_();",
          "318:   acceptDefaultAdminTransfer@withrevert(e);",
          "319:   bool success = !lastReverted;",
          "322:   assert success <=> e.msg.sender == pendingAdminBefore && isSet(scheduleAfter) && hasPassed(e, scheduleAfter),",
          "323:     \"only the pending default admin can accept the role after the schedule has been set and passed\";",
          "326:   assert success => defaultAdmin() == pendingAdminBefore,",
          "327:     \"Default admin is set to the previous pending default admin\";",
          "328:   assert success => pendingDefaultAdmin_() == 0,",
          "329:     \"Pending default admin is reset\";",
          "330:   assert success => pendingDefaultAdminSchedule_() == 0,",
          "331:     \"Pending default admin delay is reset\";",
          "332: }",
          "335: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "336: \u2502 Function correctness: cancelDefaultAdminTransfer resets pending default admin and its schedule                      \u2502",
          "337: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "339: rule cancelDefaultAdminTransfer(env e) {",
          "340:   require nonpayable(e);",
          "341:   requireInvariant defaultAdminConsistency(defaultAdmin());",
          "342:   requireInvariant singleDefaultAdmin(e.msg.sender, defaultAdmin());",
          "344:   cancelDefaultAdminTransfer@withrevert(e);",
          "345:   bool success = !lastReverted;",
          "348:   assert success <=> e.msg.sender == defaultAdmin(),",
          "349:     \"only the current default admin can cancel a transfer\";",
          "352:   assert success => pendingDefaultAdmin_() == 0,",
          "353:     \"Pending default admin is reset\";",
          "354:   assert success => pendingDefaultAdminSchedule_() == 0,",
          "355:     \"Pending default admin delay is reset\";",
          "356: }",
          "359: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "360: \u2502 Function correctness: changeDefaultAdminDelay sets a pending default admin delay and its schedule                   \u2502",
          "361: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "363: rule changeDefaultAdminDelay(env e, uint48 newDelay) {",
          "364:   require nonpayable(e);",
          "365:   require timeSanity(e);",
          "366:   require delayChangeWaitSanity(e, newDelay);",
          "367:   requireInvariant defaultAdminConsistency(defaultAdmin());",
          "368:   requireInvariant singleDefaultAdmin(e.msg.sender, defaultAdmin());",
          "370:   uint48 delayBefore = defaultAdminDelay(e);",
          "372:   changeDefaultAdminDelay@withrevert(e, newDelay);",
          "373:   bool success = !lastReverted;",
          "376:   assert success <=> e.msg.sender == defaultAdmin(),",
          "377:     \"only the current default admin can begin a delay change\";",
          "380:   assert success => pendingDelay_(e) == newDelay, \"pending delay is set\";",
          "381:   assert success => (",
          "382:     pendingDelaySchedule_(e) > e.block.timestamp ||",
          "383:     delayBefore == newDelay || // Interpreted as decreasing, x - x = 0",
          "384:     defaultAdminDelayIncreaseWait() == 0",
          "385:   ),",
          "386:     \"pending delay schedule is set in the future unless accepted edge cases\";",
          "387: }",
          "390: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "391: \u2502 Rule: A delay can't change in less than the applied schedule                                                        \u2502",
          "392: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "394: rule pendingDelayWaitEnforced(env e1, env e2, method f, calldataarg args, uint48 newDelay) {",
          "395:   require e1.block.timestamp < e2.block.timestamp;",
          "397:   uint48 delayBefore = defaultAdminDelay(e1);",
          "398:   changeDefaultAdminDelay(e1, newDelay);",
          "399:   f(e2, args);",
          "400:   uint48 delayAfter = defaultAdminDelay(e2);",
          "402:   mathint delayWait = newDelay > delayBefore ? increasingDelaySchedule(e1, newDelay) : decreasingDelaySchedule(e1, newDelay);",
          "404:   assert delayAfter == newDelay => (e2.block.timestamp >= delayWait || delayBefore == newDelay),",
          "405:     \"A delay can't change in less than applied schedule\";",
          "406: }",
          "409: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "410: \u2502 Rule: pending delay wait is set depending on increasing or decreasing the delay                                     \u2502",
          "411: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "413: rule pendingDelayWait(env e, uint48 newDelay) {",
          "414:   uint48 oldDelay = defaultAdminDelay(e);",
          "415:   changeDefaultAdminDelay(e, newDelay);",
          "417:   assert newDelay > oldDelay => pendingDelaySchedule_(e) == increasingDelaySchedule(e, newDelay),",
          "418:     \"Delay wait is the minimum between the new delay and a threshold when the delay is increased\";",
          "419:   assert newDelay <= oldDelay => pendingDelaySchedule_(e) == decreasingDelaySchedule(e, newDelay),",
          "420:     \"Delay wait is the difference between the current and the new delay when the delay is decreased\";",
          "421: }",
          "424: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "425: \u2502 Function correctness: rollbackDefaultAdminDelay resets the delay and its schedule                                   \u2502",
          "426: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "428: rule rollbackDefaultAdminDelay(env e) {",
          "429:   require nonpayable(e);",
          "430:   requireInvariant defaultAdminConsistency(defaultAdmin());",
          "431:   requireInvariant singleDefaultAdmin(e.msg.sender, defaultAdmin());",
          "433:   rollbackDefaultAdminDelay@withrevert(e);",
          "434:   bool success = !lastReverted;",
          "437:   assert success <=> e.msg.sender == defaultAdmin(),",
          "438:     \"only the current default admin can rollback a delay change\";",
          "441:   assert success => pendingDelay_(e) == 0,",
          "442:     \"Pending default admin is reset\";",
          "443:   assert success => pendingDelaySchedule_(e) == 0,",
          "444:     \"Pending default admin delay is reset\";",
          "445: }",
          "448: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "449: \u2502 Rule: pending default admin and the delay can only change along with their corresponding schedules                  \u2502",
          "450: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "452: rule pendingValueAndScheduleCoupling(env e, address newAdmin, uint48 newDelay) {",
          "453:   requireInvariant defaultAdminConsistency(defaultAdmin());",
          "454:   requireInvariant singleDefaultAdmin(e.msg.sender, defaultAdmin());",
          "457:   address pendingAdminBefore = pendingDefaultAdmin_();",
          "458:   uint48 pendingAdminScheduleBefore = pendingDefaultAdminSchedule_();",
          "460:   beginDefaultAdminTransfer(e, newAdmin);",
          "462:   address pendingAdminAfter = pendingDefaultAdmin_();",
          "463:   uint48 pendingAdminScheduleAfter = pendingDefaultAdminSchedule_();",
          "465:   assert (",
          "466:     pendingAdminScheduleBefore != pendingDefaultAdminSchedule_() &&",
          "467:     pendingAdminBefore == pendingAdminAfter",
          "468:   ) => newAdmin == pendingAdminBefore, \"pending admin stays the same if the new admin set is the same\";",
          "470:   assert (",
          "471:     pendingAdminBefore != pendingAdminAfter &&",
          "472:     pendingAdminScheduleBefore == pendingDefaultAdminSchedule_()",
          "473:   ) => (",
          "476:     e.block.timestamp + defaultAdminDelay(e) == pendingAdminScheduleBefore",
          "477:   ), \"pending admin stays the same if a default admin transfer is begun on accepted edge cases\";",
          "480:   address pendingDelayBefore = pendingDelay_(e);",
          "481:   uint48 pendingDelayScheduleBefore = pendingDelaySchedule_(e);",
          "483:   changeDefaultAdminDelay(e, newDelay);",
          "485:   address pendingDelayAfter = pendingDelay_(e);",
          "486:   uint48 pendingDelayScheduleAfter = pendingDelaySchedule_(e);",
          "488:   assert (",
          "489:     pendingDelayScheduleBefore != pendingDelayScheduleAfter &&",
          "490:     pendingDelayBefore == pendingDelayAfter",
          "491:   ) => newDelay == pendingDelayBefore || pendingDelayBefore == 0, \"pending delay stays the same if the new delay set is the same\";",
          "493:   assert (",
          "494:     pendingDelayBefore != pendingDelayAfter &&",
          "495:     pendingDelayScheduleBefore == pendingDelayScheduleAfter",
          "496:   ) => (",
          "497:     increasingDelaySchedule(e, newDelay) == pendingDelayScheduleBefore ||",
          "498:     decreasingDelaySchedule(e, newDelay) == pendingDelayScheduleBefore",
          "499:   ), \"pending delay stays the same if a default admin transfer is begun on accepted edge cases\";",
          "500: }",
          "",
          "---------------"
        ],
        "certorspecs/DoubleEndedQueue.spec||certora/specs/DoubleEndedQueue.spec": [
          "File: certorspecs/DoubleEndedQueue.spec -> certora/specs/DoubleEndedQueue.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import \"helpers/helpers.spec\"",
          "3: methods {",
          "4:     pushFront(bytes32)                    envfree",
          "5:     pushBack(bytes32)                     envfree",
          "6:     popFront()          returns (bytes32) envfree",
          "7:     popBack()           returns (bytes32) envfree",
          "8:     clear()                               envfree",
          "11:     begin()             returns (int128)  envfree",
          "12:     end()               returns (int128)  envfree",
          "15:     length()            returns (uint256) envfree",
          "16:     empty()             returns (bool)    envfree",
          "17:     front()             returns (bytes32) envfree",
          "18:     back()              returns (bytes32) envfree",
          "19:     at_(uint256)        returns (bytes32) envfree // at is a reserved word",
          "20: }",
          "23: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "24: \u2502 Helpers                                                                                                             \u2502",
          "25: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "28: function min_int128() returns mathint {",
          "29:     return -(1 << 127);",
          "30: }",
          "32: function max_int128() returns mathint {",
          "33:     return (1 << 127) - 1;",
          "34: }",
          "37: function boundedQueue() returns bool {",
          "38:     return",
          "39:         max_int128() > to_mathint(end()) &&",
          "40:         min_int128() < to_mathint(begin());",
          "41: }",
          "44: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "45: \u2502 Invariant: end is larger or equal than begin                                                                        \u2502",
          "46: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "48: invariant boundariesConsistency()",
          "49:     end() >= begin()",
          "50:     filtered { f -> !f.isView }",
          "51:     { preserved { require boundedQueue(); } }",
          "54: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "55: \u2502 Invariant: length is end minus begin                                                                                \u2502",
          "56: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "58: invariant lengthConsistency()",
          "59:     length() == to_mathint(end()) - to_mathint(begin())",
          "60:     filtered { f -> !f.isView }",
          "61:     { preserved { require boundedQueue(); } }",
          "64: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "65: \u2502 Invariant: empty() is length 0 and no element exists                                                                \u2502",
          "66: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "68: invariant emptiness()",
          "69:     empty() <=> length() == 0",
          "70:     filtered { f -> !f.isView }",
          "71:     { preserved { require boundedQueue(); } }",
          "74: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "75: \u2502 Invariant: front points to the first index and back points to the last one                                          \u2502",
          "76: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "78: invariant queueEndings()",
          "79:     at_(length() - 1) == back() && at_(0) == front()",
          "80:     filtered { f -> !f.isView }",
          "81:     {",
          "82:         preserved {",
          "83:             requireInvariant boundariesConsistency();",
          "84:             require boundedQueue();",
          "85:         }",
          "86:     }",
          "89: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "90: \u2502 Function correctness: pushFront adds an element at the beginning of the queue                                       \u2502",
          "91: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "93: rule pushFront(bytes32 value) {",
          "94:     require boundedQueue();",
          "96:     uint256 lengthBefore = length();",
          "98:     pushFront@withrevert(value);",
          "101:     assert !lastReverted, \"never reverts\";",
          "104:     assert front() == value, \"front set to value\";",
          "105:     assert length() == lengthBefore + 1, \"queue extended\";",
          "106: }",
          "109: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "110: \u2502 Rule: pushFront preserves the previous values in the queue with a +1 offset                                         \u2502",
          "111: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "113: rule pushFrontConsistency(uint256 index) {",
          "114:     require boundedQueue();",
          "116:     bytes32 beforeAt = at_(index);",
          "118:     bytes32 value;",
          "119:     pushFront(value);",
          "122:     bytes32 afterAt = at_@withrevert(index + 1);",
          "124:     assert !lastReverted, \"value still there\";",
          "125:     assert afterAt == beforeAt, \"data is preserved\";",
          "126: }",
          "129: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "130: \u2502 Function correctness: pushBack adds an element at the end of the queue                                              \u2502",
          "131: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "133: rule pushBack(bytes32 value) {",
          "134:     require boundedQueue();",
          "136:     uint256 lengthBefore = length();",
          "138:     pushBack@withrevert(value);",
          "141:     assert !lastReverted, \"never reverts\";",
          "144:     assert back() == value, \"back set to value\";",
          "145:     assert length() == lengthBefore + 1, \"queue increased\";",
          "146: }",
          "149: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "150: \u2502 Rule: pushBack preserves the previous values in the queue                                                           \u2502",
          "151: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "153: rule pushBackConsistency(uint256 index) {",
          "154:     require boundedQueue();",
          "156:     bytes32 beforeAt = at_(index);",
          "158:     bytes32 value;",
          "159:     pushBack(value);",
          "162:     bytes32 afterAt = at_@withrevert(index);",
          "164:     assert !lastReverted, \"value still there\";",
          "165:     assert afterAt == beforeAt, \"data is preserved\";",
          "166: }",
          "169: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "170: \u2502 Function correctness: popFront removes an element from the beginning of the queue                                   \u2502",
          "171: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "173: rule popFront {",
          "174:     requireInvariant boundariesConsistency();",
          "175:     require boundedQueue();",
          "177:     uint256 lengthBefore = length();",
          "178:     bytes32 frontBefore = front@withrevert();",
          "180:     bytes32 popped = popFront@withrevert();",
          "181:     bool success = !lastReverted;",
          "184:     assert success <=> lengthBefore != 0, \"never reverts if not previously empty\";",
          "187:     assert success => frontBefore == popped, \"previous front is returned\";",
          "188:     assert success => length() == lengthBefore - 1, \"queue decreased\";",
          "189: }",
          "192: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "193: \u2502 Rule: at(x) is preserved and offset to at(x - 1) after calling popFront                                             |",
          "194: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "196: rule popFrontConsistency(uint256 index) {",
          "197:     requireInvariant boundariesConsistency();",
          "198:     require boundedQueue();",
          "201:     require index > 1;",
          "202:     bytes32 before = at_(index);",
          "204:     popFront();",
          "207:     bytes32 after = at_@withrevert(index - 1);",
          "209:     assert !lastReverted, \"value still exists in the queue\";",
          "210:     assert before == after, \"values are offset and not modified\";",
          "211: }",
          "214: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "215: \u2502 Function correctness: popBack removes an element from the end of the queue                                          \u2502",
          "216: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "218: rule popBack {",
          "219:     requireInvariant boundariesConsistency();",
          "220:     require boundedQueue();",
          "222:     uint256 lengthBefore = length();",
          "223:     bytes32 backBefore = back@withrevert();",
          "225:     bytes32 popped = popBack@withrevert();",
          "226:     bool success = !lastReverted;",
          "229:     assert success <=> lengthBefore != 0, \"never reverts if not previously empty\";",
          "232:     assert success => backBefore == popped, \"previous back is returned\";",
          "233:     assert success => length() == lengthBefore - 1, \"queue decreased\";",
          "234: }",
          "237: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "238: \u2502 Rule: at(x) is preserved after calling popBack                                                                     |",
          "239: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "241: rule popBackConsistency(uint256 index) {",
          "242:     requireInvariant boundariesConsistency();",
          "243:     require boundedQueue();",
          "246:     require index < length() - 1;",
          "247:     bytes32 before = at_(index);",
          "249:     popBack();",
          "252:     bytes32 after = at_@withrevert(index);",
          "254:     assert !lastReverted, \"value still exists in the queue\";",
          "255:     assert before == after, \"values are offset and not modified\";",
          "256: }",
          "259: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "260: \u2502 Function correctness: clear sets length to 0                                                                        \u2502",
          "261: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "263: rule clear {",
          "264:     clear@withrevert();",
          "267:     assert !lastReverted, \"never reverts\";",
          "270:     assert length() == 0, \"sets length to 0\";",
          "271: }",
          "274: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "275: \u2502 Rule: front/back access reverts only if the queue is empty or querying out of bounds                                \u2502",
          "276: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "278: rule onlyEmptyRevert(env e) {",
          "279:     require nonpayable(e);",
          "280:     requireInvariant boundariesConsistency();",
          "281:     require boundedQueue();",
          "283:     method f;",
          "284:     calldataarg args;",
          "286:     bool emptyBefore = empty();",
          "288:     f@withrevert(e, args);",
          "290:     assert lastReverted => (",
          "291:         (f.selector == front().selector && emptyBefore) ||",
          "292:         (f.selector == back().selector && emptyBefore) ||",
          "293:         (f.selector == popFront().selector  && emptyBefore) ||",
          "294:         (f.selector == popBack().selector  && emptyBefore) ||",
          "295:         f.selector == at_(uint256).selector // revert conditions are verified in onlyOutOfBoundsRevert",
          "296:     ), \"only revert if empty or out of bounds\";",
          "297: }",
          "300: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "301: \u2502 Rule: at(index) only reverts if index is out of bounds                                                                  |",
          "302: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "304: rule onlyOutOfBoundsRevert(uint256 index) {",
          "305:     requireInvariant boundariesConsistency();",
          "306:     require boundedQueue();",
          "308:     at_@withrevert(index);",
          "310:     assert lastReverted <=> index >= length(), \"only reverts if index is out of bounds\";",
          "311: }",
          "314: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "315: \u2502 Rule: only clear/push/pop operations can change the length of the queue                                             \u2502",
          "316: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "318: rule noLengthChange(env e) {",
          "319:     requireInvariant boundariesConsistency();",
          "320:     require boundedQueue();",
          "322:     method f;",
          "323:     calldataarg args;",
          "325:     uint256 lengthBefore = length();",
          "326:     f(e, args);",
          "327:     uint256 lengthAfter = length();",
          "329:     assert lengthAfter != lengthBefore => (",
          "330:         (f.selector == pushFront(bytes32).selector && lengthAfter == lengthBefore + 1) ||",
          "331:         (f.selector == pushBack(bytes32).selector && lengthAfter == lengthBefore + 1) ||",
          "332:         (f.selector == popBack().selector && lengthAfter == lengthBefore - 1) ||",
          "333:         (f.selector == popFront().selector && lengthAfter == lengthBefore - 1) ||",
          "334:         (f.selector == clear().selector && lengthAfter == 0)",
          "335:     ), \"length is only affected by clear/pop/push operations\";",
          "336: }",
          "339: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "340: \u2502 Rule: only push/pop can change values bounded in the queue (outside values aren't cleared)                          \u2502",
          "341: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "343: rule noDataChange(env e) {",
          "344:     requireInvariant boundariesConsistency();",
          "345:     require boundedQueue();",
          "347:     method f;",
          "348:     calldataarg args;",
          "350:     uint256 index;",
          "351:     bytes32 atBefore = at_(index);",
          "352:     f(e, args);",
          "353:     bytes32 atAfter = at_@withrevert(index);",
          "354:     bool atAfterSuccess = !lastReverted;",
          "356:     assert !atAfterSuccess <=> (",
          "357:         f.selector == clear().selector ||",
          "358:         (f.selector == popBack().selector && index == length()) ||",
          "359:         (f.selector == popFront().selector && index == length())",
          "360:     ), \"indexes of the queue are only removed by clear or pop\";",
          "362:     assert atAfterSuccess && atAfter != atBefore => (",
          "363:         f.selector == popFront().selector ||",
          "364:         f.selector == pushFront(bytes32).selector",
          "365:     ), \"values of the queue are only changed by popFront or pushFront\";",
          "366: }",
          "",
          "---------------"
        ],
        "certorspecs/ERC20.spec||certora/specs/ERC20.spec": [
          "File: certorspecs/ERC20.spec -> certora/specs/ERC20.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import \"helpers/helpers.spec\"",
          "2: import \"methods/IERC20.spec\"",
          "3: import \"methods/IERC2612.spec\"",
          "5: methods {",
          "7:     increaseAllowance(address,uint256) returns (bool)",
          "8:     decreaseAllowance(address,uint256) returns (bool)",
          "11:     mint(address,uint256)",
          "12:     burn(address,uint256)",
          "13: }",
          "16: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "17: \u2502 Ghost & hooks: sum of all balances                                                                                  \u2502",
          "18: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "20: ghost sumOfBalances() returns uint256 {",
          "21:   init_state axiom sumOfBalances() == 0;",
          "22: }",
          "24: hook Sstore _balances[KEY address addr] uint256 newValue (uint256 oldValue) STORAGE {",
          "25:     havoc sumOfBalances assuming sumOfBalances@new() == sumOfBalances@old() + newValue - oldValue;",
          "26: }",
          "29: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "30: \u2502 Invariant: totalSupply is the sum of all balances                                                                   \u2502",
          "31: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "33: invariant totalSupplyIsSumOfBalances()",
          "34:     totalSupply() == sumOfBalances()",
          "37: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "38: \u2502 Invariant: balance of address(0) is 0                                                                               \u2502",
          "39: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "41: invariant zeroAddressNoBalance()",
          "42:     balanceOf(0) == 0",
          "45: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "46: \u2502 Rules: only mint and burn can change total supply                                                                   \u2502",
          "47: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "49: rule noChangeTotalSupply(env e) {",
          "50:     requireInvariant totalSupplyIsSumOfBalances();",
          "52:     method f;",
          "53:     calldataarg args;",
          "55:     uint256 totalSupplyBefore = totalSupply();",
          "56:     f(e, args);",
          "57:     uint256 totalSupplyAfter = totalSupply();",
          "59:     assert totalSupplyAfter > totalSupplyBefore => f.selector == mint(address,uint256).selector;",
          "60:     assert totalSupplyAfter < totalSupplyBefore => f.selector == burn(address,uint256).selector;",
          "61: }",
          "64: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "65: \u2502 Rules: only the token holder or an approved third party can reduce an account's balance                             \u2502",
          "66: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "68: rule onlyAuthorizedCanTransfer(env e) {",
          "69:     requireInvariant totalSupplyIsSumOfBalances();",
          "71:     method f;",
          "72:     calldataarg args;",
          "73:     address account;",
          "75:     uint256 allowanceBefore = allowance(account, e.msg.sender);",
          "76:     uint256 balanceBefore   = balanceOf(account);",
          "77:     f(e, args);",
          "78:     uint256 balanceAfter    = balanceOf(account);",
          "80:     assert (",
          "81:         balanceAfter < balanceBefore",
          "82:     ) => (",
          "83:         f.selector == burn(address,uint256).selector ||",
          "84:         e.msg.sender == account ||",
          "85:         balanceBefore - balanceAfter <= allowanceBefore",
          "86:     );",
          "87: }",
          "90: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "91: \u2502 Rules: only the token holder (or a permit) can increase allowance. The spender can decrease it by using it          \u2502",
          "92: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "94: rule onlyHolderOfSpenderCanChangeAllowance(env e) {",
          "95:     requireInvariant totalSupplyIsSumOfBalances();",
          "97:     method f;",
          "98:     calldataarg args;",
          "99:     address holder;",
          "100:     address spender;",
          "102:     uint256 allowanceBefore = allowance(holder, spender);",
          "103:     f(e, args);",
          "104:     uint256 allowanceAfter = allowance(holder, spender);",
          "106:     assert (",
          "107:         allowanceAfter > allowanceBefore",
          "108:     ) => (",
          "109:         (f.selector == approve(address,uint256).selector           && e.msg.sender == holder) ||",
          "110:         (f.selector == increaseAllowance(address,uint256).selector && e.msg.sender == holder) ||",
          "111:         (f.selector == permit(address,address,uint256,uint256,uint8,bytes32,bytes32).selector)",
          "112:     );",
          "114:     assert (",
          "115:         allowanceAfter < allowanceBefore",
          "116:     ) => (",
          "117:         (f.selector == transferFrom(address,address,uint256).selector && e.msg.sender == spender) ||",
          "118:         (f.selector == approve(address,uint256).selector              && e.msg.sender == holder ) ||",
          "119:         (f.selector == decreaseAllowance(address,uint256).selector    && e.msg.sender == holder ) ||",
          "120:         (f.selector == permit(address,address,uint256,uint256,uint8,bytes32,bytes32).selector)",
          "121:     );",
          "122: }",
          "125: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "126: \u2502 Rules: mint behavior and side effects                                                                               \u2502",
          "127: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "129: rule mint(env e) {",
          "130:     requireInvariant totalSupplyIsSumOfBalances();",
          "131:     require nonpayable(e);",
          "133:     address to;",
          "134:     address other;",
          "135:     uint256 amount;",
          "138:     uint256 toBalanceBefore    = balanceOf(to);",
          "139:     uint256 otherBalanceBefore = balanceOf(other);",
          "140:     uint256 totalSupplyBefore  = totalSupply();",
          "143:     mint@withrevert(e, to, amount);",
          "146:     if (lastReverted) {",
          "147:         assert to == 0 || totalSupplyBefore + amount > max_uint256;",
          "148:     } else {",
          "150:         assert balanceOf(to) == toBalanceBefore   + amount;",
          "151:         assert totalSupply() == totalSupplyBefore + amount;",
          "154:         assert balanceOf(other) != otherBalanceBefore => other == to;",
          "155:     }",
          "156: }",
          "159: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "160: \u2502 Rules: burn behavior and side effects                                                                               \u2502",
          "161: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "163: rule burn(env e) {",
          "164:     requireInvariant totalSupplyIsSumOfBalances();",
          "165:     require nonpayable(e);",
          "167:     address from;",
          "168:     address other;",
          "169:     uint256 amount;",
          "172:     uint256 fromBalanceBefore  = balanceOf(from);",
          "173:     uint256 otherBalanceBefore = balanceOf(other);",
          "174:     uint256 totalSupplyBefore  = totalSupply();",
          "177:     burn@withrevert(e, from, amount);",
          "180:     if (lastReverted) {",
          "181:         assert from == 0 || fromBalanceBefore < amount;",
          "182:     } else {",
          "184:         assert balanceOf(from) == fromBalanceBefore   - amount;",
          "185:         assert totalSupply()   == totalSupplyBefore - amount;",
          "188:         assert balanceOf(other) != otherBalanceBefore => other == from;",
          "189:     }",
          "190: }",
          "193: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "194: \u2502 Rule: transfer behavior and side effects                                                                            \u2502",
          "195: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "197: rule transfer(env e) {",
          "198:     requireInvariant totalSupplyIsSumOfBalances();",
          "199:     require nonpayable(e);",
          "201:     address holder = e.msg.sender;",
          "202:     address recipient;",
          "203:     address other;",
          "204:     uint256 amount;",
          "207:     uint256 holderBalanceBefore    = balanceOf(holder);",
          "208:     uint256 recipientBalanceBefore = balanceOf(recipient);",
          "209:     uint256 otherBalanceBefore     = balanceOf(other);",
          "212:     transfer@withrevert(e, recipient, amount);",
          "215:     if (lastReverted) {",
          "216:         assert holder == 0 || recipient == 0 || amount > holderBalanceBefore;",
          "217:     } else {",
          "219:         assert balanceOf(holder)    == holderBalanceBefore    - (holder == recipient ? 0 : amount);",
          "220:         assert balanceOf(recipient) == recipientBalanceBefore + (holder == recipient ? 0 : amount);",
          "223:         assert balanceOf(other) != otherBalanceBefore => (other == holder || other == recipient);",
          "224:     }",
          "225: }",
          "228: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "229: \u2502 Rule: transferFrom behavior and side effects                                                                        \u2502",
          "230: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "232: rule transferFrom(env e) {",
          "233:     requireInvariant totalSupplyIsSumOfBalances();",
          "234:     require nonpayable(e);",
          "236:     address spender = e.msg.sender;",
          "237:     address holder;",
          "238:     address recipient;",
          "239:     address other;",
          "240:     uint256 amount;",
          "243:     uint256 allowanceBefore        = allowance(holder, spender);",
          "244:     uint256 holderBalanceBefore    = balanceOf(holder);",
          "245:     uint256 recipientBalanceBefore = balanceOf(recipient);",
          "246:     uint256 otherBalanceBefore     = balanceOf(other);",
          "249:     transferFrom@withrevert(e, holder, recipient, amount);",
          "252:     if (lastReverted) {",
          "253:         assert holder == 0 || recipient == 0 || spender == 0 || amount > holderBalanceBefore || amount > allowanceBefore;",
          "254:     } else {",
          "256:         assert allowanceBefore            >= amount;",
          "257:         assert allowance(holder, spender) == (allowanceBefore == max_uint256 ? to_uint256(max_uint256) : allowanceBefore - amount);",
          "260:         assert balanceOf(holder)    == holderBalanceBefore    - (holder == recipient ? 0 : amount);",
          "261:         assert balanceOf(recipient) == recipientBalanceBefore + (holder == recipient ? 0 : amount);",
          "264:         assert balanceOf(other) != otherBalanceBefore => (other == holder || other == recipient);",
          "265:     }",
          "266: }",
          "269: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "270: \u2502 Rule: approve behavior and side effects                                                                             \u2502",
          "271: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "273: rule approve(env e) {",
          "274:     require nonpayable(e);",
          "276:     address holder = e.msg.sender;",
          "277:     address spender;",
          "278:     address otherHolder;",
          "279:     address otherSpender;",
          "280:     uint256 amount;",
          "283:     uint256 otherAllowanceBefore = allowance(otherHolder, otherSpender);",
          "286:     approve@withrevert(e, spender, amount);",
          "289:     if (lastReverted) {",
          "290:         assert holder == 0 || spender == 0;",
          "291:     } else {",
          "293:         assert allowance(holder, spender) == amount;",
          "296:         assert allowance(otherHolder, otherSpender) != otherAllowanceBefore => (otherHolder == holder && otherSpender == spender);",
          "297:     }",
          "298: }",
          "301: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "302: \u2502 Rule: increaseAllowance behavior and side effects                                                                   \u2502",
          "303: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "305: rule increaseAllowance(env e) {",
          "306:     require nonpayable(e);",
          "308:     address holder = e.msg.sender;",
          "309:     address spender;",
          "310:     address otherHolder;",
          "311:     address otherSpender;",
          "312:     uint256 amount;",
          "315:     uint256 allowanceBefore      = allowance(holder, spender);",
          "316:     uint256 otherAllowanceBefore = allowance(otherHolder, otherSpender);",
          "319:     increaseAllowance@withrevert(e, spender, amount);",
          "322:     if (lastReverted) {",
          "323:         assert holder == 0 || spender == 0 || allowanceBefore + amount > max_uint256;",
          "324:     } else {",
          "326:         assert allowance(holder, spender) == allowanceBefore + amount;",
          "329:         assert allowance(otherHolder, otherSpender) != otherAllowanceBefore => (otherHolder == holder && otherSpender == spender);",
          "330:     }",
          "331: }",
          "334: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "335: \u2502 Rule: decreaseAllowance behavior and side effects                                                                   \u2502",
          "336: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "338: rule decreaseAllowance(env e) {",
          "339:     require nonpayable(e);",
          "341:     address holder = e.msg.sender;",
          "342:     address spender;",
          "343:     address otherHolder;",
          "344:     address otherSpender;",
          "345:     uint256 amount;",
          "348:     uint256 allowanceBefore      = allowance(holder, spender);",
          "349:     uint256 otherAllowanceBefore = allowance(otherHolder, otherSpender);",
          "352:     decreaseAllowance@withrevert(e, spender, amount);",
          "355:     if (lastReverted) {",
          "356:         assert holder == 0 || spender == 0 || allowanceBefore < amount;",
          "357:     } else {",
          "359:         assert allowance(holder, spender) == allowanceBefore - amount;",
          "362:         assert allowance(otherHolder, otherSpender) != otherAllowanceBefore => (otherHolder == holder && otherSpender == spender);",
          "363:     }",
          "364: }",
          "367: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "368: \u2502 Rule: permit behavior and side effects                                                                              \u2502",
          "369: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "371: rule permit(env e) {",
          "372:     require nonpayable(e);",
          "374:     address holder;",
          "375:     address spender;",
          "376:     uint256 amount;",
          "377:     uint256 deadline;",
          "378:     uint8 v;",
          "379:     bytes32 r;",
          "380:     bytes32 s;",
          "382:     address account1;",
          "383:     address account2;",
          "384:     address account3;",
          "387:     uint256 nonceBefore          = nonces(holder);",
          "388:     uint256 otherNonceBefore     = nonces(account1);",
          "389:     uint256 otherAllowanceBefore = allowance(account2, account3);",
          "392:     require nonceBefore      < max_uint256;",
          "393:     require otherNonceBefore < max_uint256;",
          "396:     permit@withrevert(e, holder, spender, amount, deadline, v, r, s);",
          "399:     if (lastReverted) {",
          "401:         assert true;",
          "402:     } else {",
          "404:         assert allowance(holder, spender) == amount;",
          "405:         assert nonces(holder) == nonceBefore + 1;",
          "408:         assert deadline >= e.block.timestamp;",
          "411:         assert nonces(account1)              != otherNonceBefore     => account1 == holder;",
          "412:         assert allowance(account2, account3) != otherAllowanceBefore => (account2 == holder && account3 == spender);",
          "413:     }",
          "414: }",
          "",
          "---------------"
        ],
        "certorspecs/ERC20FlashMint.spec||certora/specs/ERC20FlashMint.spec": [
          "File: certorspecs/ERC20FlashMint.spec -> certora/specs/ERC20FlashMint.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import \"helpers/helpers.spec\"",
          "2: import \"methods/IERC20.spec\"",
          "3: import \"methods/IERC3156.spec\"",
          "5: methods {",
          "7:     flashFeeReceiver() returns (address) envfree",
          "10:     _mint(address account, uint256 amount)              => specMint(account, amount)",
          "11:     _burn(address account, uint256 amount)              => specBurn(account, amount)",
          "12:     _transfer(address from, address to, uint256 amount) => specTransfer(from, to, amount)",
          "13: }",
          "16: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "17: \u2502 Ghost: track mint and burns in the CVL                                                                              \u2502",
          "18: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "20: ghost mapping(address => uint256)                     trackedMintAmount;",
          "21: ghost mapping(address => uint256)                     trackedBurnAmount;",
          "22: ghost mapping(address => mapping(address => uint256)) trackedTransferedAmount;",
          "24: function specMint(address account, uint256 amount)              returns bool { trackedMintAmount[account] = amount;        return true; }",
          "25: function specBurn(address account, uint256 amount)              returns bool { trackedBurnAmount[account] = amount;        return true; }",
          "26: function specTransfer(address from, address to, uint256 amount) returns bool { trackedTransferedAmount[from][to] = amount; return true; }",
          "29: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "30: \u2502 Rule: When doing a flashLoan, \"amount\" is minted and burnt, additionally, the fee is either burnt                   \u2502",
          "31: \u2502 (if the fee recipient is 0) or transferred (if the fee recipient is not 0)                                          \u2502",
          "32: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "34: rule checkMintAndBurn(env e) {",
          "35:     address receiver;",
          "36:     address token;",
          "37:     uint256 amount;",
          "38:     bytes data;",
          "40:     uint256 fees = flashFee(token, amount);",
          "41:     address recipient = flashFeeReceiver();",
          "43:     flashLoan(e, receiver, token, amount, data);",
          "45:     assert trackedMintAmount[receiver] == amount;",
          "46:     assert trackedBurnAmount[receiver] == amount + (recipient == 0 ? fees : 0);",
          "47:     assert (fees > 0 && recipient != 0) => trackedTransferedAmount[receiver][recipient] == fees;",
          "48: }",
          "",
          "---------------"
        ],
        "certorspecs/ERC20Wrapper.spec||certora/specs/ERC20Wrapper.spec": [
          "File: certorspecs/ERC20Wrapper.spec -> certora/specs/ERC20Wrapper.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import \"helpers/helpers.spec\"",
          "2: import \"ERC20.spec\"",
          "4: methods {",
          "5:     underlying()                       returns(address) envfree",
          "6:     underlyingTotalSupply()            returns(uint256) envfree",
          "7:     underlyingBalanceOf(address)       returns(uint256) envfree",
          "8:     underlyingAllowanceToThis(address) returns(uint256) envfree",
          "10:     depositFor(address, uint256)       returns(bool)",
          "11:     withdrawTo(address, uint256)       returns(bool)",
          "12:     recover(address)                   returns(uint256)",
          "13: }",
          "15: use invariant totalSupplyIsSumOfBalances",
          "18: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "19: \u2502 Helper: consequence of `totalSupplyIsSumOfBalances` applied to underlying                                           \u2502",
          "20: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "22: function underlyingBalancesLowerThanUnderlyingSupply(address a) returns bool {",
          "23:     return underlyingBalanceOf(a) <= underlyingTotalSupply();",
          "24: }",
          "26: function sumOfUnderlyingBalancesLowerThanUnderlyingSupply(address a, address b) returns bool {",
          "27:     return a != b => underlyingBalanceOf(a) + underlyingBalanceOf(b) <= underlyingTotalSupply();",
          "28: }",
          "31: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "32: \u2502 Invariant: wrapped token can't be undercollateralized (solvency of the wrapper)                                     \u2502",
          "33: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "35: invariant totalSupplyIsSmallerThanUnderlyingBalance()",
          "36:     totalSupply() <= underlyingBalanceOf(currentContract) &&",
          "37:     underlyingBalanceOf(currentContract) <= underlyingTotalSupply() &&",
          "38:     underlyingTotalSupply() <= max_uint256",
          "39:     {",
          "40:         preserved {",
          "41:             requireInvariant totalSupplyIsSumOfBalances;",
          "42:             require underlyingBalancesLowerThanUnderlyingSupply(currentContract);",
          "43:         }",
          "44:         preserved depositFor(address account, uint256 amount) with (env e) {",
          "45:             require sumOfUnderlyingBalancesLowerThanUnderlyingSupply(e.msg.sender, currentContract);",
          "46:         }",
          "47:     }",
          "49: invariant noSelfWrap()",
          "50:     currentContract != underlying()",
          "53: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "54: \u2502 Rule: depositFor liveness and effects                                                                               \u2502",
          "55: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "57: rule depositFor(env e) {",
          "58:     require nonpayable(e);",
          "60:     address sender = e.msg.sender;",
          "61:     address receiver;",
          "62:     address other;",
          "63:     uint256 amount;",
          "66:     requireInvariant noSelfWrap;",
          "67:     requireInvariant totalSupplyIsSumOfBalances;",
          "68:     requireInvariant totalSupplyIsSmallerThanUnderlyingBalance;",
          "69:     require sumOfUnderlyingBalancesLowerThanUnderlyingSupply(currentContract, sender);",
          "71:     uint256 balanceBefore                   = balanceOf(receiver);",
          "72:     uint256 supplyBefore                    = totalSupply();",
          "73:     uint256 senderUnderlyingBalanceBefore   = underlyingBalanceOf(sender);",
          "74:     uint256 senderUnderlyingAllowanceBefore = underlyingAllowanceToThis(sender);",
          "75:     uint256 wrapperUnderlyingBalanceBefore  = underlyingBalanceOf(currentContract);",
          "76:     uint256 underlyingSupplyBefore          = underlyingTotalSupply();",
          "78:     uint256 otherBalanceBefore              = balanceOf(other);",
          "79:     uint256 otherUnderlyingBalanceBefore    = underlyingBalanceOf(other);",
          "81:     depositFor@withrevert(e, receiver, amount);",
          "82:     bool success = !lastReverted;",
          "85:     assert success <=> (",
          "86:         sender   != currentContract               && // invalid sender",
          "87:         sender   != 0                             && // invalid sender",
          "88:         receiver != 0                             && // invalid receiver",
          "89:         amount   <= senderUnderlyingBalanceBefore && // deposit doesn't exceed balance",
          "90:         amount   <= senderUnderlyingAllowanceBefore  // deposit doesn't exceed allowance",
          "91:     );",
          "94:     assert success => (",
          "95:         balanceOf(receiver) == balanceBefore + amount &&",
          "96:         totalSupply() == supplyBefore + amount &&",
          "97:         underlyingBalanceOf(currentContract) == wrapperUnderlyingBalanceBefore + amount &&",
          "98:         underlyingBalanceOf(sender) == senderUnderlyingBalanceBefore - amount",
          "99:     );",
          "102:     assert underlyingTotalSupply() == underlyingSupplyBefore;",
          "103:     assert balanceOf(other)           != otherBalanceBefore           => other == receiver;",
          "104:     assert underlyingBalanceOf(other) != otherUnderlyingBalanceBefore => (other == sender || other == currentContract);",
          "105: }",
          "108: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "109: \u2502 Rule: withdrawTo liveness and effects                                                                               \u2502",
          "110: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "112: rule withdrawTo(env e) {",
          "113:     require nonpayable(e);",
          "115:     address sender = e.msg.sender;",
          "116:     address receiver;",
          "117:     address other;",
          "118:     uint256 amount;",
          "121:     requireInvariant noSelfWrap;",
          "122:     requireInvariant totalSupplyIsSumOfBalances;",
          "123:     requireInvariant totalSupplyIsSmallerThanUnderlyingBalance;",
          "124:     require sumOfUnderlyingBalancesLowerThanUnderlyingSupply(currentContract, receiver);",
          "126:     uint256 balanceBefore                   = balanceOf(sender);",
          "127:     uint256 supplyBefore                    = totalSupply();",
          "128:     uint256 receiverUnderlyingBalanceBefore = underlyingBalanceOf(receiver);",
          "129:     uint256 wrapperUnderlyingBalanceBefore  = underlyingBalanceOf(currentContract);",
          "130:     uint256 underlyingSupplyBefore          = underlyingTotalSupply();",
          "132:     uint256 otherBalanceBefore              = balanceOf(other);",
          "133:     uint256 otherUnderlyingBalanceBefore    = underlyingBalanceOf(other);",
          "135:     withdrawTo@withrevert(e, receiver, amount);",
          "136:     bool success = !lastReverted;",
          "139:     assert success <=> (",
          "140:         sender   != 0          && // invalid sender",
          "141:         receiver != 0          && // invalid receiver",
          "142:         amount   <= balanceBefore // withdraw doesn't exceed balance",
          "143:     );",
          "146:     assert success => (",
          "147:         balanceOf(sender) == balanceBefore - amount &&",
          "148:         totalSupply() == supplyBefore - amount &&",
          "149:         underlyingBalanceOf(currentContract) == wrapperUnderlyingBalanceBefore - (currentContract != receiver ? amount : 0) &&",
          "150:         underlyingBalanceOf(receiver) == receiverUnderlyingBalanceBefore + (currentContract != receiver ? amount : 0)",
          "151:     );",
          "154:     assert underlyingTotalSupply() == underlyingSupplyBefore;",
          "155:     assert balanceOf(other)           != otherBalanceBefore           => other == sender;",
          "156:     assert underlyingBalanceOf(other) != otherUnderlyingBalanceBefore => (other == receiver || other == currentContract);",
          "157: }",
          "160: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "161: \u2502 Rule: recover liveness and effects                                                                                  \u2502",
          "162: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "164: rule recover(env e) {",
          "165:     require nonpayable(e);",
          "167:     address receiver;",
          "168:     address other;",
          "171:     requireInvariant noSelfWrap;",
          "172:     requireInvariant totalSupplyIsSumOfBalances;",
          "173:     requireInvariant totalSupplyIsSmallerThanUnderlyingBalance;",
          "175:     uint256 value                        = underlyingBalanceOf(currentContract) - totalSupply();",
          "176:     uint256 supplyBefore                 = totalSupply();",
          "177:     uint256 balanceBefore                = balanceOf(receiver);",
          "179:     uint256 otherBalanceBefore           = balanceOf(other);",
          "180:     uint256 otherUnderlyingBalanceBefore = underlyingBalanceOf(other);",
          "182:     recover@withrevert(e, receiver);",
          "183:     bool success = !lastReverted;",
          "186:     assert success <=> receiver != 0;",
          "189:     assert success => (",
          "190:         balanceOf(receiver) == balanceBefore + value &&",
          "191:         totalSupply() == supplyBefore + value &&",
          "192:         totalSupply() == underlyingBalanceOf(currentContract)",
          "193:     );",
          "196:     assert underlyingBalanceOf(other) == otherUnderlyingBalanceBefore;",
          "197:     assert balanceOf(other) != otherBalanceBefore => other == receiver;",
          "198: }",
          "",
          "---------------"
        ],
        "certorspecs/ERC721.spec||certora/specs/ERC721.spec": [
          "File: certorspecs/ERC721.spec -> certora/specs/ERC721.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import \"helpers/helpers.spec\"",
          "2: import \"methods/IERC721.spec\"",
          "4: methods {",
          "6:     mint(address,uint256)",
          "7:     safeMint(address,uint256)",
          "8:     safeMint(address,uint256,bytes)",
          "9:     burn(uint256)",
          "11:     tokenExists(uint256) returns (bool) envfree",
          "12:     unsafeOwnerOf(uint256) returns (address) envfree",
          "13:     unsafeGetApproved(uint256) returns (address) envfree",
          "14: }",
          "17: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "18: \u2502 Helpers                                                                                                             \u2502",
          "19: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "23: function balanceLimited(address account) returns bool {",
          "24:     return balanceOf(account) < max_uint256;",
          "25: }",
          "27: function helperTransferWithRevert(env e, method f, address from, address to, uint256 tokenId) {",
          "28:     if (f.selector == transferFrom(address,address,uint256).selector) {",
          "29:         transferFrom@withrevert(e, from, to, tokenId);",
          "30:     } else if (f.selector == safeTransferFrom(address,address,uint256).selector) {",
          "31:         safeTransferFrom@withrevert(e, from, to, tokenId);",
          "32:     } else if (f.selector == safeTransferFrom(address,address,uint256,bytes).selector) {",
          "33:         bytes params;",
          "34:         require params.length < 0xffff;",
          "35:         safeTransferFrom@withrevert(e, from, to, tokenId, params);",
          "36:     } else {",
          "37:         calldataarg args;",
          "38:         f@withrevert(e, args);",
          "39:     }",
          "40: }",
          "42: function helperMintWithRevert(env e, method f, address to, uint256 tokenId) {",
          "43:     if (f.selector == mint(address,uint256).selector) {",
          "44:         mint@withrevert(e, to, tokenId);",
          "45:     } else if (f.selector == safeMint(address,uint256).selector) {",
          "46:         safeMint@withrevert(e, to, tokenId);",
          "47:     } else if (f.selector == safeMint(address,uint256,bytes).selector) {",
          "48:         bytes params;",
          "49:         require params.length < 0xffff;",
          "50:         safeMint@withrevert(e, to, tokenId, params);",
          "51:     } else {",
          "52:         require false;",
          "53:     }",
          "54: }",
          "57: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "58: \u2502 Ghost & hooks: ownership count                                                                                      \u2502",
          "59: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "61: ghost ownedTotal() returns uint256 {",
          "62:   init_state axiom ownedTotal() == 0;",
          "63: }",
          "65: ghost mapping(address => uint256) ownedByUser {",
          "66:     init_state axiom forall address a. ownedByUser[a] == 0;",
          "67: }",
          "69: hook Sstore _owners[KEY uint256 tokenId] address newOwner (address oldOwner) STORAGE {",
          "70:     ownedByUser[newOwner] = ownedByUser[newOwner] + to_uint256(newOwner != 0 ? 1 : 0);",
          "71:     ownedByUser[oldOwner] = ownedByUser[oldOwner] - to_uint256(oldOwner != 0 ? 1 : 0);",
          "73:     havoc ownedTotal assuming ownedTotal@new() == ownedTotal@old()",
          "74:         + to_uint256(newOwner != 0 ? 1 : 0)",
          "75:         - to_uint256(oldOwner != 0 ? 1 : 0);",
          "76: }",
          "79: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "80: \u2502 Ghost & hooks: sum of all balances                                                                                  \u2502",
          "81: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "83: ghost sumOfBalances() returns uint256 {",
          "84:   init_state axiom sumOfBalances() == 0;",
          "85: }",
          "87: hook Sstore _balances[KEY address addr] uint256 newValue (uint256 oldValue) STORAGE {",
          "88:     havoc sumOfBalances assuming sumOfBalances@new() == sumOfBalances@old() + newValue - oldValue;",
          "89: }",
          "91: ghost mapping(address => uint256) ghostBalanceOf {",
          "92:     init_state axiom forall address a. ghostBalanceOf[a] == 0;",
          "93: }",
          "95: hook Sload uint256 value _balances[KEY address user] STORAGE {",
          "96:     require ghostBalanceOf[user] == value;",
          "97: }",
          "100: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "101: \u2502 Invariant: ownedTotal is the sum of all balances                                                                    \u2502",
          "102: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "104: invariant ownedTotalIsSumOfBalances()",
          "105:     ownedTotal() == sumOfBalances()",
          "108: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "109: \u2502 Invariant: balanceOf is the number of tokens owned                                                                  \u2502",
          "110: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "112: invariant balanceOfConsistency(address user)",
          "113:     balanceOf(user) == ownedByUser[user] &&",
          "114:     balanceOf(user) == ghostBalanceOf[user]",
          "115:     {",
          "116:         preserved {",
          "117:             require balanceLimited(user);",
          "118:         }",
          "119:     }",
          "122: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "123: \u2502 Invariant: owner of a token must have some balance                                                                  \u2502",
          "124: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "126: invariant ownerHasBalance(uint256 tokenId)",
          "127:     balanceOf(ownerOf(tokenId)) > 0",
          "128:     {",
          "129:         preserved {",
          "130:             requireInvariant balanceOfConsistency(ownerOf(tokenId));",
          "131:             require balanceLimited(ownerOf(tokenId));",
          "132:         }",
          "133:     }",
          "136: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "137: \u2502 Invariant: tokens that do not exist are not owned and not approved                                                  \u2502",
          "138: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "140: invariant notMintedUnset(uint256 tokenId)",
          "141:     (!tokenExists(tokenId) <=> unsafeOwnerOf(tokenId) == 0) &&",
          "142:     (!tokenExists(tokenId) => unsafeGetApproved(tokenId) == 0)",
          "145: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "146: \u2502 Rule: ownerOf and getApproved revert if token does not exist                                                        \u2502",
          "147: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "149: rule notMintedRevert(uint256 tokenId) {",
          "150:     requireInvariant notMintedUnset(tokenId);",
          "152:     bool e = tokenExists(tokenId);",
          "154:     address owner = ownerOf@withrevert(tokenId);",
          "155:     assert e <=> !lastReverted;",
          "156:     assert e => owner == unsafeOwnerOf(tokenId); // notMintedUnset tells us this is non-zero",
          "158:     address approved = getApproved@withrevert(tokenId);",
          "159:     assert e <=> !lastReverted;",
          "160:     assert e => approved == unsafeGetApproved(tokenId);",
          "161: }",
          "164: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "165: \u2502 Rule: unsafeOwnerOf and unsafeGetApproved don't revert                                                              \u2502",
          "166: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "168: rule unsafeDontRevert(uint256 tokenId) {",
          "169:     unsafeOwnerOf@withrevert(tokenId);",
          "170:     assert !lastReverted;",
          "172:     unsafeGetApproved@withrevert(tokenId);",
          "173:     assert !lastReverted;",
          "174: }",
          "177: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "178: \u2502 Rule: balance of address(0) is 0                                                                                    \u2502",
          "179: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "181: rule zeroAddressBalanceRevert() {",
          "182:     balanceOf@withrevert(0);",
          "183:     assert lastReverted;",
          "184: }",
          "187: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "188: \u2502 Rules: total supply can only change through mint and burn                                                           \u2502",
          "189: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "191: rule supplyChange(env e) {",
          "192:     uint256 supplyBefore = ownedTotal();",
          "193:     method f; calldataarg args; f(e, args);",
          "194:     uint256 supplyAfter = ownedTotal();",
          "196:     assert supplyAfter > supplyBefore => (",
          "197:         supplyAfter == supplyBefore + 1 &&",
          "198:         (",
          "199:             f.selector == mint(address,uint256).selector ||",
          "200:             f.selector == safeMint(address,uint256).selector ||",
          "201:             f.selector == safeMint(address,uint256,bytes).selector",
          "202:         )",
          "203:     );",
          "204:     assert supplyAfter < supplyBefore => (",
          "205:         supplyAfter == supplyBefore - 1 &&",
          "206:         f.selector == burn(uint256).selector",
          "207:     );",
          "208: }",
          "211: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "212: \u2502 Rules: balanceOf can only change through mint, burn or transfers. balanceOf cannot change by more than 1.           \u2502",
          "213: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "215: rule balanceChange(env e, address account) {",
          "216:     requireInvariant balanceOfConsistency(account);",
          "217:     require balanceLimited(account);",
          "219:     uint256 balanceBefore = balanceOf(account);",
          "220:     method f; calldataarg args; f(e, args);",
          "221:     uint256 balanceAfter  = balanceOf(account);",
          "224:     assert balanceBefore != balanceAfter => (",
          "225:         balanceAfter == balanceBefore - 1 ||",
          "226:         balanceAfter == balanceBefore + 1",
          "227:     );",
          "230:     assert balanceBefore != balanceAfter => (",
          "231:         f.selector == transferFrom(address,address,uint256).selector ||",
          "232:         f.selector == safeTransferFrom(address,address,uint256).selector ||",
          "233:         f.selector == safeTransferFrom(address,address,uint256,bytes).selector ||",
          "234:         f.selector == mint(address,uint256).selector ||",
          "235:         f.selector == safeMint(address,uint256).selector ||",
          "236:         f.selector == safeMint(address,uint256,bytes).selector ||",
          "237:         f.selector == burn(uint256).selector",
          "238:     );",
          "239: }",
          "242: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "243: \u2502 Rules: ownership can only change through mint, burn or transfers.                                                   \u2502",
          "244: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "246: rule ownershipChange(env e, uint256 tokenId) {",
          "247:     address ownerBefore = unsafeOwnerOf(tokenId);",
          "248:     method f; calldataarg args; f(e, args);",
          "249:     address ownerAfter  = unsafeOwnerOf(tokenId);",
          "251:     assert ownerBefore == 0 && ownerAfter != 0 => (",
          "252:         f.selector == mint(address,uint256).selector ||",
          "253:         f.selector == safeMint(address,uint256).selector ||",
          "254:         f.selector == safeMint(address,uint256,bytes).selector",
          "255:     );",
          "257:     assert ownerBefore != 0 && ownerAfter == 0 => (",
          "258:         f.selector == burn(uint256).selector",
          "259:     );",
          "261:     assert (ownerBefore != ownerAfter && ownerBefore != 0 && ownerAfter != 0) => (",
          "262:         f.selector == transferFrom(address,address,uint256).selector ||",
          "263:         f.selector == safeTransferFrom(address,address,uint256).selector ||",
          "264:         f.selector == safeTransferFrom(address,address,uint256,bytes).selector",
          "265:     );",
          "266: }",
          "269: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "270: \u2502 Rules: token approval can only change through approve or transfers (implicitly).                                    \u2502",
          "271: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "273: rule approvalChange(env e, uint256 tokenId) {",
          "274:     address approvalBefore = unsafeGetApproved(tokenId);",
          "275:     method f; calldataarg args; f(e, args);",
          "276:     address approvalAfter  = unsafeGetApproved(tokenId);",
          "279:     assert approvalBefore != approvalAfter => (",
          "280:         f.selector == approve(address,uint256).selector ||",
          "281:         (",
          "282:             (",
          "283:                 f.selector == transferFrom(address,address,uint256).selector ||",
          "284:                 f.selector == safeTransferFrom(address,address,uint256).selector ||",
          "285:                 f.selector == safeTransferFrom(address,address,uint256,bytes).selector ||",
          "286:                 f.selector == burn(uint256).selector",
          "287:             ) && approvalAfter == 0",
          "288:         )",
          "289:     );",
          "290: }",
          "293: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "294: \u2502 Rules: approval for all tokens can only change through isApprovedForAll.                                            \u2502",
          "295: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "297: rule approvedForAllChange(env e, address owner, address spender) {",
          "298:     bool approvedForAllBefore = isApprovedForAll(owner, spender);",
          "299:     method f; calldataarg args; f(e, args);",
          "300:     bool approvedForAllAfter  = isApprovedForAll(owner, spender);",
          "302:     assert approvedForAllBefore != approvedForAllAfter => f.selector == setApprovalForAll(address,bool).selector;",
          "303: }",
          "306: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "307: \u2502 Rule: transferFrom behavior and side effects                                                                        \u2502",
          "308: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "310: rule transferFrom(env e, address from, address to, uint256 tokenId) {",
          "311:     require nonpayable(e);",
          "313:     address operator = e.msg.sender;",
          "314:     uint256 otherTokenId;",
          "315:     address otherAccount;",
          "317:     requireInvariant ownerHasBalance(tokenId);",
          "318:     require balanceLimited(to);",
          "320:     uint256 balanceOfFromBefore  = balanceOf(from);",
          "321:     uint256 balanceOfToBefore    = balanceOf(to);",
          "322:     uint256 balanceOfOtherBefore = balanceOf(otherAccount);",
          "323:     address ownerBefore          = unsafeOwnerOf(tokenId);",
          "324:     address otherOwnerBefore     = unsafeOwnerOf(otherTokenId);",
          "325:     address approvalBefore       = unsafeGetApproved(tokenId);",
          "326:     address otherApprovalBefore  = unsafeGetApproved(otherTokenId);",
          "328:     transferFrom@withrevert(e, from, to, tokenId);",
          "329:     bool success = !lastReverted;",
          "332:     assert success <=> (",
          "333:         from == ownerBefore &&",
          "334:         from != 0 &&",
          "335:         to   != 0 &&",
          "336:         (operator == from || operator == approvalBefore || isApprovedForAll(ownerBefore, operator))",
          "337:     );",
          "340:     assert success => (",
          "341:         balanceOf(from)            == balanceOfFromBefore - to_uint256(from != to ? 1 : 0) &&",
          "342:         balanceOf(to)              == balanceOfToBefore   + to_uint256(from != to ? 1 : 0) &&",
          "343:         unsafeOwnerOf(tokenId)     == to &&",
          "344:         unsafeGetApproved(tokenId) == 0",
          "345:     );",
          "348:     assert balanceOf(otherAccount)         != balanceOfOtherBefore => (otherAccount == from || otherAccount == to);",
          "349:     assert unsafeOwnerOf(otherTokenId)     != otherOwnerBefore     => otherTokenId == tokenId;",
          "350:     assert unsafeGetApproved(otherTokenId) != otherApprovalBefore  => otherTokenId == tokenId;",
          "351: }",
          "354: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "355: \u2502 Rule: safeTransferFrom behavior and side effects                                                                    \u2502",
          "356: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "358: rule safeTransferFrom(env e, method f, address from, address to, uint256 tokenId) filtered { f ->",
          "359:     f.selector == safeTransferFrom(address,address,uint256).selector ||",
          "360:     f.selector == safeTransferFrom(address,address,uint256,bytes).selector",
          "361: } {",
          "362:     require nonpayable(e);",
          "364:     address operator = e.msg.sender;",
          "365:     uint256 otherTokenId;",
          "366:     address otherAccount;",
          "368:     requireInvariant ownerHasBalance(tokenId);",
          "369:     require balanceLimited(to);",
          "371:     uint256 balanceOfFromBefore  = balanceOf(from);",
          "372:     uint256 balanceOfToBefore    = balanceOf(to);",
          "373:     uint256 balanceOfOtherBefore = balanceOf(otherAccount);",
          "374:     address ownerBefore          = unsafeOwnerOf(tokenId);",
          "375:     address otherOwnerBefore     = unsafeOwnerOf(otherTokenId);",
          "376:     address approvalBefore       = unsafeGetApproved(tokenId);",
          "377:     address otherApprovalBefore  = unsafeGetApproved(otherTokenId);",
          "379:     helperTransferWithRevert(e, f, from, to, tokenId);",
          "380:     bool success = !lastReverted;",
          "382:     assert success <=> (",
          "383:         from == ownerBefore &&",
          "384:         from != 0 &&",
          "385:         to   != 0 &&",
          "386:         (operator == from || operator == approvalBefore || isApprovedForAll(ownerBefore, operator))",
          "387:     );",
          "390:     assert success => (",
          "391:         balanceOf(from)            == balanceOfFromBefore - to_uint256(from != to ? 1: 0) &&",
          "392:         balanceOf(to)              == balanceOfToBefore   + to_uint256(from != to ? 1: 0) &&",
          "393:         unsafeOwnerOf(tokenId)     == to &&",
          "394:         unsafeGetApproved(tokenId) == 0",
          "395:     );",
          "398:     assert balanceOf(otherAccount)         != balanceOfOtherBefore => (otherAccount == from || otherAccount == to);",
          "399:     assert unsafeOwnerOf(otherTokenId)     != otherOwnerBefore     => otherTokenId == tokenId;",
          "400:     assert unsafeGetApproved(otherTokenId) != otherApprovalBefore  => otherTokenId == tokenId;",
          "401: }",
          "404: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "405: \u2502 Rule: mint behavior and side effects                                                                                \u2502",
          "406: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "408: rule mint(env e, address to, uint256 tokenId) {",
          "409:     require nonpayable(e);",
          "410:     requireInvariant notMintedUnset(tokenId);",
          "412:     uint256 otherTokenId;",
          "413:     address otherAccount;",
          "415:     require balanceLimited(to);",
          "417:     uint256 supplyBefore         = ownedTotal();",
          "418:     uint256 balanceOfToBefore    = balanceOf(to);",
          "419:     uint256 balanceOfOtherBefore = balanceOf(otherAccount);",
          "420:     address ownerBefore          = unsafeOwnerOf(tokenId);",
          "421:     address otherOwnerBefore     = unsafeOwnerOf(otherTokenId);",
          "423:     mint@withrevert(e, to, tokenId);",
          "424:     bool success = !lastReverted;",
          "427:     assert success <=> (",
          "428:         ownerBefore == 0 &&",
          "429:         to != 0",
          "430:     );",
          "433:     assert success => (",
          "434:         ownedTotal()           == supplyBefore + 1 &&",
          "435:         balanceOf(to)          == balanceOfToBefore + 1 &&",
          "436:         unsafeOwnerOf(tokenId) == to",
          "437:     );",
          "440:     assert balanceOf(otherAccount)     != balanceOfOtherBefore => otherAccount == to;",
          "441:     assert unsafeOwnerOf(otherTokenId) != otherOwnerBefore     => otherTokenId == tokenId;",
          "442: }",
          "445: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "446: \u2502 Rule: safeMint behavior and side effects                                                                            \u2502",
          "447: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "449: rule safeMint(env e, method f, address to, uint256 tokenId) filtered { f ->",
          "450:     f.selector == safeMint(address,uint256).selector ||",
          "451:     f.selector == safeMint(address,uint256,bytes).selector",
          "452: } {",
          "453:     require nonpayable(e);",
          "454:     requireInvariant notMintedUnset(tokenId);",
          "456:     uint256 otherTokenId;",
          "457:     address otherAccount;",
          "459:     require balanceLimited(to);",
          "461:     uint256 supplyBefore         = ownedTotal();",
          "462:     uint256 balanceOfToBefore    = balanceOf(to);",
          "463:     uint256 balanceOfOtherBefore = balanceOf(otherAccount);",
          "464:     address ownerBefore          = unsafeOwnerOf(tokenId);",
          "465:     address otherOwnerBefore     = unsafeOwnerOf(otherTokenId);",
          "467:     helperMintWithRevert(e, f, to, tokenId);",
          "468:     bool success = !lastReverted;",
          "470:     assert success <=> (",
          "471:         ownerBefore == 0 &&",
          "472:         to != 0",
          "473:     );",
          "476:     assert success => (",
          "477:         ownedTotal()           == supplyBefore + 1 &&",
          "478:         balanceOf(to)          == balanceOfToBefore + 1 &&",
          "479:         unsafeOwnerOf(tokenId) == to",
          "480:     );",
          "483:     assert balanceOf(otherAccount)     != balanceOfOtherBefore => otherAccount == to;",
          "484:     assert unsafeOwnerOf(otherTokenId) != otherOwnerBefore     => otherTokenId == tokenId;",
          "485: }",
          "488: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "489: \u2502 Rule: burn behavior and side effects                                                                                \u2502",
          "490: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "492: rule burn(env e, uint256 tokenId) {",
          "493:     require nonpayable(e);",
          "495:     address from = unsafeOwnerOf(tokenId);",
          "496:     uint256 otherTokenId;",
          "497:     address otherAccount;",
          "499:     requireInvariant ownerHasBalance(tokenId);",
          "501:     uint256 supplyBefore         = ownedTotal();",
          "502:     uint256 balanceOfFromBefore  = balanceOf(from);",
          "503:     uint256 balanceOfOtherBefore = balanceOf(otherAccount);",
          "504:     address ownerBefore          = unsafeOwnerOf(tokenId);",
          "505:     address otherOwnerBefore     = unsafeOwnerOf(otherTokenId);",
          "506:     address otherApprovalBefore  = unsafeGetApproved(otherTokenId);",
          "508:     burn@withrevert(e, tokenId);",
          "509:     bool success = !lastReverted;",
          "512:     assert success <=> (",
          "513:         ownerBefore != 0",
          "514:     );",
          "517:     assert success => (",
          "518:         ownedTotal()               == supplyBefore   - 1 &&",
          "519:         balanceOf(from)            == balanceOfFromBefore - 1 &&",
          "520:         unsafeOwnerOf(tokenId)     == 0 &&",
          "521:         unsafeGetApproved(tokenId) == 0",
          "522:     );",
          "525:     assert balanceOf(otherAccount)         != balanceOfOtherBefore => otherAccount == from;",
          "526:     assert unsafeOwnerOf(otherTokenId)     != otherOwnerBefore     => otherTokenId == tokenId;",
          "527:     assert unsafeGetApproved(otherTokenId) != otherApprovalBefore  => otherTokenId == tokenId;",
          "528: }",
          "531: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "532: \u2502 Rule: approve behavior and side effects                                                                             \u2502",
          "533: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "535: rule approve(env e, address spender, uint256 tokenId) {",
          "536:     require nonpayable(e);",
          "538:     address caller = e.msg.sender;",
          "539:     address owner = unsafeOwnerOf(tokenId);",
          "540:     uint256 otherTokenId;",
          "542:     address otherApprovalBefore  = unsafeGetApproved(otherTokenId);",
          "544:     approve@withrevert(e, spender, tokenId);",
          "545:     bool success = !lastReverted;",
          "548:     assert success <=> (",
          "549:         owner != 0 &&",
          "550:         owner != spender &&",
          "551:         (owner == caller || isApprovedForAll(owner, caller))",
          "552:     );",
          "555:     assert success => unsafeGetApproved(tokenId) == spender;",
          "558:     assert unsafeGetApproved(otherTokenId) != otherApprovalBefore  => otherTokenId == tokenId;",
          "559: }",
          "562: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "563: \u2502 Rule: setApprovalForAll behavior and side effects                                                                   \u2502",
          "564: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "566: rule setApprovalForAll(env e, address operator, bool approved) {",
          "567:     require nonpayable(e);",
          "569:     address owner = e.msg.sender;",
          "570:     address otherOwner;",
          "571:     address otherOperator;",
          "573:     bool otherIsApprovedForAllBefore = isApprovedForAll(otherOwner, otherOperator);",
          "575:     setApprovalForAll@withrevert(e, operator, approved);",
          "576:     bool success = !lastReverted;",
          "579:     assert success <=> owner != operator;",
          "582:     assert success => isApprovedForAll(owner, operator) == approved;",
          "585:     assert isApprovedForAll(otherOwner, otherOperator) != otherIsApprovedForAllBefore => (",
          "586:         otherOwner    == owner &&",
          "587:         otherOperator == operator",
          "588:     );",
          "589: }",
          "",
          "---------------"
        ],
        "certorspecs/EnumerableMap.spec||certora/specs/EnumerableMap.spec": [
          "File: certorspecs/EnumerableMap.spec -> certora/specs/EnumerableMap.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import \"helpers/helpers.spec\"",
          "3: methods {",
          "5:     set(bytes32,bytes32)     returns (bool)    envfree",
          "6:     remove(bytes32)          returns (bool)    envfree",
          "7:     contains(bytes32)        returns (bool)    envfree",
          "8:     length()                 returns (uint256) envfree",
          "9:     key_at(uint256)          returns (bytes32) envfree",
          "10:     value_at(uint256)        returns (bytes32) envfree",
          "11:     tryGet_contains(bytes32) returns (bool)    envfree",
          "12:     tryGet_value(bytes32)    returns (bytes32) envfree",
          "13:     get(bytes32)             returns (bytes32) envfree",
          "16:     _indexOf(bytes32) returns (uint256) envfree",
          "17: }",
          "20: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "21: \u2502 Helpers                                                                                                             \u2502",
          "22: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "24: function sanity() returns bool {",
          "25:     return length() < max_uint256;",
          "26: }",
          "29: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "30: \u2502 Invariant: the value mapping is empty for keys that are not in the EnumerableMap.                                   \u2502",
          "31: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "33: invariant noValueIfNotContained(bytes32 key)",
          "34:     !contains(key) => tryGet_value(key) == 0",
          "35:     {",
          "36:         preserved set(bytes32 otherKey, bytes32 someValue) {",
          "37:             require sanity();",
          "38:         }",
          "39:     }",
          "42: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "43: \u2502 Invariant: All indexed keys are contained                                                                           \u2502",
          "44: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "46: invariant indexedContained(uint256 index)",
          "47:     index < length() => contains(key_at(index))",
          "48:     {",
          "49:         preserved {",
          "50:             requireInvariant consistencyIndex(index);",
          "51:             requireInvariant consistencyIndex(to_uint256(length() - 1));",
          "52:         }",
          "53:     }",
          "56: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "57: \u2502 Invariant: A value can only be stored at a single location                                                          \u2502",
          "58: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "60: invariant atUniqueness(uint256 index1, uint256 index2)",
          "61:     index1 == index2 <=> key_at(index1) == key_at(index2)",
          "62:     {",
          "63:         preserved remove(bytes32 key) {",
          "64:             requireInvariant atUniqueness(index1, to_uint256(length() - 1));",
          "65:             requireInvariant atUniqueness(index2, to_uint256(length() - 1));",
          "66:         }",
          "67:     }",
          "70: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "71: \u2502 Invariant: index <> value relationship is consistent                                                                \u2502",
          "72: \u2502                                                                                                                     \u2502",
          "73: \u2502 Note that the two consistencyXxx invariants, put together, prove that at_ and _indexOf are inverse of one another.  \u2502",
          "74: \u2502 This proves that we have a bijection between indices (the enumerability part) and keys (the entries that are set    \u2502",
          "75: \u2502 and removed from the EnumerableMap).                                                                                \u2502",
          "76: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "78: invariant consistencyIndex(uint256 index)",
          "79:     index < length() => _indexOf(key_at(index)) == index + 1",
          "80:     {",
          "81:         preserved remove(bytes32 key) {",
          "82:             requireInvariant consistencyIndex(to_uint256(length() - 1));",
          "83:         }",
          "84:     }",
          "86: invariant consistencyKey(bytes32 key)",
          "87:     contains(key) => (",
          "88:         _indexOf(key) > 0 &&",
          "89:         _indexOf(key) <= length() &&",
          "90:         key_at(to_uint256(_indexOf(key) - 1)) == key",
          "91:     )",
          "92:     {",
          "93:         preserved remove(bytes32 otherKey) {",
          "94:             requireInvariant consistencyKey(otherKey);",
          "95:             requireInvariant atUniqueness(",
          "96:                 to_uint256(_indexOf(key) - 1),",
          "97:                 to_uint256(_indexOf(otherKey) - 1)",
          "98:             );",
          "99:         }",
          "100:     }",
          "103: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "104: \u2502 Rule: state only changes by setting or removing elements                                                            \u2502",
          "105: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "107: rule stateChange(env e, bytes32 key) {",
          "108:     require sanity();",
          "109:     requireInvariant consistencyKey(key);",
          "111:     uint256 lengthBefore   = length();",
          "112:     bool    containsBefore = contains(key);",
          "113:     bytes32 valueBefore    = tryGet_value(key);",
          "115:     method f;",
          "116:     calldataarg args;",
          "117:     f(e, args);",
          "119:     uint256 lengthAfter   = length();",
          "120:     bool    containsAfter = contains(key);",
          "121:     bytes32 valueAfter    = tryGet_value(key);",
          "123:     assert lengthBefore != lengthAfter => (",
          "124:         (f.selector == set(bytes32,bytes32).selector && lengthAfter == lengthBefore + 1) ||",
          "125:         (f.selector == remove(bytes32).selector      && lengthAfter == lengthBefore - 1)",
          "126:     );",
          "128:     assert containsBefore != containsAfter => (",
          "129:         (f.selector == set(bytes32,bytes32).selector && containsAfter) ||",
          "130:         (f.selector == remove(bytes32).selector      && !containsAfter)",
          "131:     );",
          "133:     assert valueBefore != valueAfter => (",
          "134:         (f.selector == set(bytes32,bytes32).selector && containsAfter) ||",
          "135:         (f.selector == remove(bytes32).selector      && !containsAfter && valueAfter == 0)",
          "136:     );",
          "137: }",
          "140: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "141: \u2502 Rule: check liveness of view functions.                                                                             \u2502",
          "142: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "144: rule liveness_1(bytes32 key) {",
          "145:     requireInvariant consistencyKey(key);",
          "148:     bool contains = contains@withrevert(key);",
          "149:     assert !lastReverted;",
          "152:     tryGet_contains@withrevert(key);",
          "153:     assert !lastReverted;",
          "156:     tryGet_value@withrevert(key);",
          "157:     assert !lastReverted;",
          "160:     get@withrevert(key);",
          "161:     assert !lastReverted <=> contains;",
          "162: }",
          "164: rule liveness_2(uint256 index) {",
          "165:     requireInvariant consistencyIndex(index);",
          "168:     uint256 length = length@withrevert();",
          "169:     assert !lastReverted;",
          "172:     key_at@withrevert(index);",
          "173:     assert !lastReverted <=> index < length;",
          "176:     value_at@withrevert(index);",
          "177:     assert !lastReverted <=> index < length;",
          "178: }",
          "181: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "182: \u2502 Rule: get and tryGet return the expected values.                                                                    \u2502",
          "183: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "185: rule getAndTryGet(bytes32 key) {",
          "186:     requireInvariant noValueIfNotContained(key);",
          "188:     bool    contained    = contains(key);",
          "189:     bool    tryContained = tryGet_contains(key);",
          "190:     bytes32 tryValue     = tryGet_value(key);",
          "191:     bytes32 value        = get@withrevert(key); // revert is not contained",
          "193:     assert contained == tryContained;",
          "194:     assert contained => tryValue == value;",
          "195:     assert !contained => tryValue == 0;",
          "196: }",
          "199: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "200: \u2502 Rule: set key-value in EnumerableMap                                                                                \u2502",
          "201: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "203: rule set(bytes32 key, bytes32 value, bytes32 otherKey) {",
          "204:     require sanity();",
          "206:     uint256 lengthBefore        = length();",
          "207:     bool    containsBefore      = contains(key);",
          "208:     bool    containsOtherBefore = contains(otherKey);",
          "209:     bytes32 otherValueBefore    = tryGet_value(otherKey);",
          "211:     bool added = set@withrevert(key, value);",
          "212:     bool success = !lastReverted;",
          "214:     assert success && contains(key) && get(key) == value,",
          "215:         \"liveness & immediate effect\";",
          "217:     assert added <=> !containsBefore,",
          "218:         \"return value: added iff not contained\";",
          "220:     assert length() == lengthBefore + to_mathint(added ? 1 : 0),",
          "221:         \"effect: length increases iff added\";",
          "223:     assert added => (key_at(lengthBefore) == key && value_at(lengthBefore) == value),",
          "224:         \"effect: add at the end\";",
          "226:     assert containsOtherBefore != contains(otherKey) => (added && key == otherKey),",
          "227:         \"side effect: other keys are not affected\";",
          "229:     assert otherValueBefore != tryGet_value(otherKey) => key == otherKey,",
          "230:         \"side effect: values attached to other keys are not affected\";",
          "231: }",
          "234: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "235: \u2502 Rule: remove key from EnumerableMap                                                                                 \u2502",
          "236: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "238: rule remove(bytes32 key, bytes32 otherKey) {",
          "239:     requireInvariant consistencyKey(key);",
          "240:     requireInvariant consistencyKey(otherKey);",
          "242:     uint256 lengthBefore        = length();",
          "243:     bool    containsBefore      = contains(key);",
          "244:     bool    containsOtherBefore = contains(otherKey);",
          "245:     bytes32 otherValueBefore    = tryGet_value(otherKey);",
          "247:     bool removed = remove@withrevert(key);",
          "248:     bool success = !lastReverted;",
          "250:     assert success && !contains(key),",
          "251:         \"liveness & immediate effect\";",
          "253:     assert removed <=> containsBefore,",
          "254:         \"return value: removed iff contained\";",
          "256:     assert length() == lengthBefore - to_mathint(removed ? 1 : 0),",
          "257:         \"effect: length decreases iff removed\";",
          "259:     assert containsOtherBefore != contains(otherKey) => (removed && key == otherKey),",
          "260:         \"side effect: other keys are not affected\";",
          "262:     assert otherValueBefore != tryGet_value(otherKey) => key == otherKey,",
          "263:         \"side effect: values attached to other keys are not affected\";",
          "264: }",
          "267: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "268: \u2502 Rule: when adding a new key, the other keys remain in set, at the same index.                                       \u2502",
          "269: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "271: rule setEnumerability(bytes32 key, bytes32 value, uint256 index) {",
          "272:     require sanity();",
          "274:     bytes32 atKeyBefore = key_at(index);",
          "275:     bytes32 atValueBefore = value_at(index);",
          "277:     set(key, value);",
          "279:     bytes32 atKeyAfter = key_at@withrevert(index);",
          "280:     assert !lastReverted;",
          "282:     bytes32 atValueAfter = value_at@withrevert(index);",
          "283:     assert !lastReverted;",
          "285:     assert atKeyAfter == atKeyBefore;",
          "286:     assert atValueAfter != atValueBefore => (",
          "287:         key == atKeyBefore &&",
          "288:         value == atValueAfter",
          "289:     );",
          "290: }",
          "293: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "294: \u2502 Rule: when removing a existing key, the other keys remain in set, at the same index (except for the last one).      \u2502",
          "295: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "297: rule removeEnumerability(bytes32 key, uint256 index) {",
          "298:     uint256 last = length() - 1;",
          "300:     requireInvariant consistencyKey(key);",
          "301:     requireInvariant consistencyIndex(index);",
          "302:     requireInvariant consistencyIndex(last);",
          "304:     bytes32 atKeyBefore     = key_at(index);",
          "305:     bytes32 atValueBefore   = value_at(index);",
          "306:     bytes32 lastKeyBefore   = key_at(last);",
          "307:     bytes32 lastValueBefore = value_at(last);",
          "309:     remove(key);",
          "312:     bytes32 atKeyAfter = key_at@withrevert(index);",
          "313:     assert lastReverted <=> index == last;",
          "315:     bytes32 atValueAfter = value_at@withrevert(index);",
          "316:     assert lastReverted <=> index == last;",
          "320:     assert (",
          "321:         index != last &&",
          "322:         atKeyBefore != atKeyAfter",
          "323:     ) => (",
          "324:         atKeyBefore == key &&",
          "325:         atKeyAfter == lastKeyBefore",
          "326:     );",
          "328:     assert (",
          "329:         index != last &&",
          "330:         atValueBefore != atValueAfter",
          "331:     ) => (",
          "332:         atValueAfter == lastValueBefore",
          "333:     );",
          "334: }",
          "",
          "---------------"
        ],
        "certorspecs/EnumerableSet.spec||certora/specs/EnumerableSet.spec": [
          "File: certorspecs/EnumerableSet.spec -> certora/specs/EnumerableSet.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import \"helpers/helpers.spec\"",
          "3: methods {",
          "5:     add(bytes32)      returns (bool)    envfree",
          "6:     remove(bytes32)   returns (bool)    envfree",
          "7:     contains(bytes32) returns (bool)    envfree",
          "8:     length()          returns (uint256) envfree",
          "9:     at_(uint256)      returns (bytes32) envfree",
          "12:     _indexOf(bytes32) returns (uint256) envfree",
          "13: }",
          "16: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "17: \u2502 Helpers                                                                                                             \u2502",
          "18: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "20: function sanity() returns bool {",
          "21:     return length() < max_uint256;",
          "22: }",
          "25: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "26: \u2502 Invariant: All indexed keys are contained                                                                           \u2502",
          "27: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "29: invariant indexedContained(uint256 index)",
          "30:     index < length() => contains(at_(index))",
          "31:     {",
          "32:         preserved {",
          "33:             requireInvariant consistencyIndex(index);",
          "34:             requireInvariant consistencyIndex(to_uint256(length() - 1));",
          "35:         }",
          "36:     }",
          "39: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "40: \u2502 Invariant: A value can only be stored at a single location                                                          \u2502",
          "41: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "43: invariant atUniqueness(uint256 index1, uint256 index2)",
          "44:     index1 == index2 <=> at_(index1) == at_(index2)",
          "45:     {",
          "46:         preserved remove(bytes32 key) {",
          "47:             requireInvariant atUniqueness(index1, to_uint256(length() - 1));",
          "48:             requireInvariant atUniqueness(index2, to_uint256(length() - 1));",
          "49:         }",
          "50:     }",
          "53: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "54: \u2502 Invariant: index <> key relationship is consistent                                                                  \u2502",
          "55: \u2502                                                                                                                     \u2502",
          "56: \u2502 Note that the two consistencyXxx invariants, put together, prove that at_ and _indexOf are inverse of one another.  \u2502",
          "57: \u2502 This proves that we have a bijection between indices (the enumerability part) and keys (the entries that are added  \u2502",
          "58: \u2502 and removed from the EnumerableSet).                                                                                \u2502",
          "59: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "61: invariant consistencyIndex(uint256 index)",
          "62:     index < length() => _indexOf(at_(index)) == index + 1",
          "63:     {",
          "64:         preserved remove(bytes32 key) {",
          "65:             requireInvariant consistencyIndex(to_uint256(length() - 1));",
          "66:         }",
          "67:     }",
          "69: invariant consistencyKey(bytes32 key)",
          "70:     contains(key) => (",
          "71:         _indexOf(key) > 0 &&",
          "72:         _indexOf(key) <= length() &&",
          "73:         at_(to_uint256(_indexOf(key) - 1)) == key",
          "74:     )",
          "75:     {",
          "76:         preserved remove(bytes32 otherKey) {",
          "77:             requireInvariant consistencyKey(otherKey);",
          "78:             requireInvariant atUniqueness(",
          "79:                 to_uint256(_indexOf(key) - 1),",
          "80:                 to_uint256(_indexOf(otherKey) - 1)",
          "81:             );",
          "82:         }",
          "83:     }",
          "86: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "87: \u2502 Rule: state only changes by adding or removing elements                                                             \u2502",
          "88: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "90: rule stateChange(env e, bytes32 key) {",
          "91:     require sanity();",
          "92:     requireInvariant consistencyKey(key);",
          "94:     uint256 lengthBefore   = length();",
          "95:     bool    containsBefore = contains(key);",
          "97:     method f;",
          "98:     calldataarg args;",
          "99:     f(e, args);",
          "101:     uint256 lengthAfter   = length();",
          "102:     bool    containsAfter = contains(key);",
          "104:     assert lengthBefore != lengthAfter => (",
          "105:         (f.selector == add(bytes32).selector    && lengthAfter == lengthBefore + 1) ||",
          "106:         (f.selector == remove(bytes32).selector && lengthAfter == lengthBefore - 1)",
          "107:     );",
          "109:     assert containsBefore != containsAfter => (",
          "110:         (f.selector == add(bytes32).selector    && containsAfter) ||",
          "111:         (f.selector == remove(bytes32).selector && containsBefore)",
          "112:     );",
          "113: }",
          "116: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "117: \u2502 Rule: check liveness of view functions.                                                                             \u2502",
          "118: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "120: rule liveness_1(bytes32 key) {",
          "121:     requireInvariant consistencyKey(key);",
          "124:     contains@withrevert(key);",
          "125:     assert !lastReverted;",
          "126: }",
          "128: rule liveness_2(uint256 index) {",
          "129:     requireInvariant consistencyIndex(index);",
          "132:     uint256 length = length@withrevert();",
          "133:     assert !lastReverted;",
          "136:     at_@withrevert(index);",
          "137:     assert !lastReverted <=> index < length;",
          "138: }",
          "141: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "142: \u2502 Rule: add key to EnumerableSet if not already contained                                                             \u2502",
          "143: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "145: rule add(bytes32 key, bytes32 otherKey) {",
          "146:     require sanity();",
          "148:     uint256 lengthBefore        = length();",
          "149:     bool    containsBefore      = contains(key);",
          "150:     bool    containsOtherBefore = contains(otherKey);",
          "152:     bool added = add@withrevert(key);",
          "153:     bool success = !lastReverted;",
          "155:     assert success && contains(key),",
          "156:         \"liveness & immediate effect\";",
          "158:     assert added <=> !containsBefore,",
          "159:         \"return value: added iff not contained\";",
          "161:     assert length() == lengthBefore + to_mathint(added ? 1 : 0),",
          "162:         \"effect: length increases iff added\";",
          "164:     assert added => at_(lengthBefore) == key,",
          "165:         \"effect: add at the end\";",
          "167:     assert containsOtherBefore != contains(otherKey) => (added && key == otherKey),",
          "168:         \"side effect: other keys are not affected\";",
          "169: }",
          "172: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "173: \u2502 Rule: remove key from EnumerableSet if already contained                                                            \u2502",
          "174: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "176: rule remove(bytes32 key, bytes32 otherKey) {",
          "177:     requireInvariant consistencyKey(key);",
          "178:     requireInvariant consistencyKey(otherKey);",
          "180:     uint256 lengthBefore        = length();",
          "181:     bool    containsBefore      = contains(key);",
          "182:     bool    containsOtherBefore = contains(otherKey);",
          "184:     bool removed = remove@withrevert(key);",
          "185:     bool success = !lastReverted;",
          "187:     assert success && !contains(key),",
          "188:         \"liveness & immediate effect\";",
          "190:     assert removed <=> containsBefore,",
          "191:         \"return value: removed iff contained\";",
          "193:     assert length() == lengthBefore - to_mathint(removed ? 1 : 0),",
          "194:         \"effect: length decreases iff removed\";",
          "196:     assert containsOtherBefore != contains(otherKey) => (removed && key == otherKey),",
          "197:         \"side effect: other keys are not affected\";",
          "198: }",
          "201: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "202: \u2502 Rule: when adding a new key, the other keys remain in set, at the same index.                                       \u2502",
          "203: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "205: rule addEnumerability(bytes32 key, uint256 index) {",
          "206:     require sanity();",
          "208:     bytes32 atBefore = at_(index);",
          "209:     add(key);",
          "210:     bytes32 atAfter = at_@withrevert(index);",
          "211:     bool atAfterSuccess = !lastReverted;",
          "213:     assert atAfterSuccess;",
          "214:     assert atBefore == atAfter;",
          "215: }",
          "218: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "219: \u2502 Rule: when removing a existing key, the other keys remain in set, at the same index (except for the last one).      \u2502",
          "220: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "222: rule removeEnumerability(bytes32 key, uint256 index) {",
          "223:     uint256 last = length() - 1;",
          "225:     requireInvariant consistencyKey(key);",
          "226:     requireInvariant consistencyIndex(index);",
          "227:     requireInvariant consistencyIndex(last);",
          "229:     bytes32 atBefore = at_(index);",
          "230:     bytes32 lastBefore = at_(last);",
          "232:     remove(key);",
          "235:     bytes32 atAfter = at_@withrevert(index);",
          "236:     assert lastReverted <=> index == last;",
          "240:     assert (",
          "241:         index != last &&",
          "242:         atBefore != atAfter",
          "243:     ) => (",
          "244:         atBefore == key &&",
          "245:         atAfter == lastBefore",
          "246:     );",
          "247: }",
          "",
          "---------------"
        ],
        "certorspecs/Initializable.spec||certora/specs/Initializable.spec": [
          "File: certorspecs/Initializable.spec -> certora/specs/Initializable.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import \"helpers/helpers.spec\"",
          "3: methods {",
          "5:     initialize()        envfree",
          "6:     reinitialize(uint8) envfree",
          "7:     disable()           envfree",
          "9:     nested_init_init()            envfree",
          "10:     nested_init_reinit(uint8)       envfree",
          "11:     nested_reinit_init(uint8)       envfree",
          "12:     nested_reinit_reinit(uint8,uint8) envfree",
          "15:     version()      returns uint8 envfree",
          "16:     initializing() returns bool  envfree",
          "17: }",
          "20: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "21: \u2502 Definitions                                                                                                         \u2502",
          "22: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "24: definition isUninitialized() returns bool = version() == 0;",
          "25: definition isInitialized()   returns bool = version() > 0;",
          "26: definition isDisabled()      returns bool = version() == 255;",
          "29: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "30: \u2502 Invariant: A contract must only ever be in an initializing state while in the middle of a transaction execution.    \u2502",
          "31: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "33: invariant notInitializing()",
          "34:     !initializing()",
          "37: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "38: \u2502 Rule: The version cannot decrease & disable state is irrevocable.                                                   \u2502",
          "39: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "41: rule increasingVersion(env e) {",
          "42:     uint8 versionBefore = version();",
          "43:     bool disabledBefore = isDisabled();",
          "45:     method f; calldataarg args;",
          "46:     f(e, args);",
          "48:     assert versionBefore <= version(), \"_initialized must only increase\";",
          "49:     assert disabledBefore => isDisabled(), \"a disabled initializer must stay disabled\";",
          "50: }",
          "53: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "54: \u2502 Rule: Cannot initialize a contract that is already initialized.                                                     \u2502",
          "55: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "57: rule cannotInitializeTwice() {",
          "58:     require isInitialized();",
          "60:     initialize@withrevert();",
          "62:     assert lastReverted, \"contract must only be initialized once\";",
          "63: }",
          "66: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "67: \u2502 Rule: Cannot initialize once disabled.                                                                              \u2502",
          "68: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "70: rule cannotInitializeOnceDisabled() {",
          "71:     require isDisabled();",
          "73:     initialize@withrevert();",
          "75:     assert lastReverted, \"contract is disabled\";",
          "76: }",
          "79: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "80: \u2502 Rule: Cannot reinitialize once disabled.                                                                            \u2502",
          "81: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "83: rule cannotReinitializeOnceDisabled() {",
          "84:     require isDisabled();",
          "86:     uint8 n;",
          "87:     reinitialize@withrevert(n);",
          "89:     assert lastReverted, \"contract is disabled\";",
          "90: }",
          "93: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "94: \u2502 Rule: Cannot nest initializers (after construction).                                                                \u2502",
          "95: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "97: rule cannotNestInitializers_init_init() {",
          "98:     nested_init_init@withrevert();",
          "99:     assert lastReverted, \"nested initializers\";",
          "100: }",
          "102: rule cannotNestInitializers_init_reinit(uint8 m) {",
          "103:     nested_init_reinit@withrevert(m);",
          "104:     assert lastReverted, \"nested initializers\";",
          "105: }",
          "107: rule cannotNestInitializers_reinit_init(uint8 n) {",
          "108:     nested_reinit_init@withrevert(n);",
          "109:     assert lastReverted, \"nested initializers\";",
          "110: }",
          "112: rule cannotNestInitializers_reinit_reinit(uint8 n, uint8 m) {",
          "113:     nested_reinit_reinit@withrevert(n, m);",
          "114:     assert lastReverted, \"nested initializers\";",
          "115: }",
          "118: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "119: \u2502 Rule: Initialize correctly sets the version.                                                                        \u2502",
          "120: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "122: rule initializeEffects() {",
          "123:     requireInvariant notInitializing();",
          "125:     bool isUninitializedBefore = isUninitialized();",
          "127:     initialize@withrevert();",
          "128:     bool success = !lastReverted;",
          "130:     assert success <=> isUninitializedBefore, \"can only initialize uninitialized contracts\";",
          "131:     assert success => version() == 1,         \"initialize must set version() to 1\";",
          "132: }",
          "135: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "136: \u2502 Rule: Reinitialize correctly sets the version.                                                                      \u2502",
          "137: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "139: rule reinitializeEffects() {",
          "140:     requireInvariant notInitializing();",
          "142:     uint8 versionBefore = version();",
          "144:     uint8 n;",
          "145:     reinitialize@withrevert(n);",
          "146:     bool success = !lastReverted;",
          "148:     assert success <=> versionBefore < n, \"can only reinitialize to a latter versions\";",
          "149:     assert success => version() == n,     \"reinitialize must set version() to n\";",
          "150: }",
          "153: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "154: \u2502 Rule: Can disable.                                                                                                  \u2502",
          "155: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "157: rule disableEffect() {",
          "158:     requireInvariant notInitializing();",
          "160:     disable@withrevert();",
          "161:     bool success = !lastReverted;",
          "163:     assert success,      \"call to _disableInitializers failed\";",
          "164:     assert isDisabled(), \"disable state not set\";",
          "165: }",
          "",
          "---------------"
        ],
        "certorspecs/Ownable.spec||certora/specs/Ownable.spec": [
          "File: certorspecs/Ownable.spec -> certora/specs/Ownable.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import \"helpers/helpers.spec\"",
          "2: import \"methods/IOwnable.spec\"",
          "4: methods {",
          "5:     restricted()",
          "6: }",
          "9: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "10: \u2502 Function correctness: transferOwnership changes ownership                                                           \u2502",
          "11: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "13: rule transferOwnership(env e) {",
          "14:     require nonpayable(e);",
          "16:     address newOwner;",
          "17:     address current = owner();",
          "19:     transferOwnership@withrevert(e, newOwner);",
          "20:     bool success = !lastReverted;",
          "22:     assert success <=> (e.msg.sender == current && newOwner != 0), \"unauthorized caller or invalid arg\";",
          "23:     assert success => owner() == newOwner, \"current owner changed\";",
          "24: }",
          "27: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "28: \u2502 Function correctness: renounceOwnership removes the owner                                                           \u2502",
          "30: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "32: rule renounceOwnership(env e) {",
          "33:     require nonpayable(e);",
          "35:     address current = owner();",
          "37:     renounceOwnership@withrevert(e);",
          "38:     bool success = !lastReverted;",
          "40:     assert success <=> e.msg.sender == current, \"unauthorized caller\";",
          "41:     assert success => owner() == 0, \"owner not cleared\";",
          "42: }",
          "45: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "46: \u2502 Access control: only current owner can call restricted functions                                                    \u2502",
          "47: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "49: rule onlyCurrentOwnerCanCallOnlyOwner(env e) {",
          "50:     require nonpayable(e);",
          "52:     address current = owner();",
          "54:     calldataarg args;",
          "55:     restricted@withrevert(e, args);",
          "57:     assert !lastReverted <=> e.msg.sender == current, \"access control failed\";",
          "58: }",
          "61: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "62: \u2502 Rule: ownership can only change in specific ways                                                                    \u2502",
          "63: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "65: rule onlyOwnerOrPendingOwnerCanChangeOwnership(env e) {",
          "66:     address oldCurrent = owner();",
          "68:     method f; calldataarg args;",
          "69:     f(e, args);",
          "71:     address newCurrent = owner();",
          "74:     assert oldCurrent != newCurrent => (",
          "75:         (e.msg.sender == oldCurrent && newCurrent != 0 && f.selector == transferOwnership(address).selector) ||",
          "76:         (e.msg.sender == oldCurrent && newCurrent == 0 && f.selector == renounceOwnership().selector)",
          "77:     );",
          "78: }",
          "",
          "---------------"
        ],
        "certorspecs/Ownable2Step.spec||certora/specs/Ownable2Step.spec": [
          "File: certorspecs/Ownable2Step.spec -> certora/specs/Ownable2Step.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import \"helpers/helpers.spec\"",
          "2: import \"methods/IOwnable2Step.spec\"",
          "4: methods {",
          "5:     restricted()",
          "6: }",
          "9: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "10: \u2502 Function correctness: transferOwnership sets the pending owner                                                      \u2502",
          "11: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "13: rule transferOwnership(env e) {",
          "14:     require nonpayable(e);",
          "16:     address newOwner;",
          "17:     address current = owner();",
          "19:     transferOwnership@withrevert(e, newOwner);",
          "20:     bool success = !lastReverted;",
          "22:     assert success <=> e.msg.sender == current, \"unauthorized caller\";",
          "23:     assert success => pendingOwner() == newOwner, \"pending owner not set\";",
          "24:     assert success => owner() == current, \"current owner changed\";",
          "25: }",
          "28: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "29: \u2502 Function correctness: renounceOwnership removes the owner and the pendingOwner                                      \u2502",
          "30: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "32: rule renounceOwnership(env e) {",
          "33:     require nonpayable(e);",
          "35:     address current = owner();",
          "37:     renounceOwnership@withrevert(e);",
          "38:     bool success = !lastReverted;",
          "40:     assert success <=> e.msg.sender == current, \"unauthorized caller\";",
          "41:     assert success => pendingOwner() == 0, \"pending owner not cleared\";",
          "42:     assert success => owner() == 0, \"owner not cleared\";",
          "43: }",
          "46: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "47: \u2502 Function correctness: acceptOwnership changes owner and reset pending owner                                         \u2502",
          "48: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "50: rule acceptOwnership(env e) {",
          "52:     require nonpayable(e);",
          "54:     address current = owner();",
          "55:     address pending = pendingOwner();",
          "57:     acceptOwnership@withrevert(e);",
          "58:     bool success = !lastReverted;",
          "60:     assert success <=> e.msg.sender == pending, \"unauthorized caller\";",
          "61:     assert success => pendingOwner() == 0, \"pending owner not cleared\";",
          "62:     assert success => owner() == pending, \"owner not transferred\";",
          "63: }",
          "66: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "67: \u2502 Access control: only current owner can call restricted functions                                                    \u2502",
          "68: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "70: rule onlyCurrentOwnerCanCallOnlyOwner(env e) {",
          "71:     require nonpayable(e);",
          "73:     address current = owner();",
          "75:     calldataarg args;",
          "76:     restricted@withrevert(e, args);",
          "78:     assert !lastReverted <=> e.msg.sender == current, \"access control failed\";",
          "79: }",
          "82: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "83: \u2502 Rule: ownership and pending ownership can only change in specific ways                                              \u2502",
          "84: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "86: rule ownerOrPendingOwnerChange(env e, method f) {",
          "87:     address oldCurrent = owner();",
          "88:     address oldPending = pendingOwner();",
          "90:     calldataarg args;",
          "91:     f(e, args);",
          "93:     address newCurrent = owner();",
          "94:     address newPending = pendingOwner();",
          "97:     assert oldCurrent != newCurrent => (",
          "98:         (e.msg.sender == oldPending && newCurrent == oldPending && newPending == 0 && f.selector == acceptOwnership().selector) ||",
          "99:         (e.msg.sender == oldCurrent && newCurrent == 0          && newPending == 0 && f.selector == renounceOwnership().selector)",
          "100:     );",
          "103:     assert oldPending != newPending => (",
          "104:         (e.msg.sender == oldCurrent && newCurrent == oldCurrent &&                    f.selector == transferOwnership(address).selector) ||",
          "105:         (e.msg.sender == oldPending && newCurrent == oldPending && newPending == 0 && f.selector == acceptOwnership().selector) ||",
          "106:         (e.msg.sender == oldCurrent && newCurrent == 0          && newPending == 0 && f.selector == renounceOwnership().selector)",
          "107:     );",
          "108: }",
          "",
          "---------------"
        ],
        "certorspecs/Pausable.spec||certora/specs/Pausable.spec": [
          "File: certorspecs/Pausable.spec -> certora/specs/Pausable.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import \"helpers/helpers.spec\"",
          "3: methods {",
          "4:     paused() returns (bool) envfree",
          "5:     pause()",
          "6:     unpause()",
          "7:     onlyWhenPaused()",
          "8:     onlyWhenNotPaused()",
          "9: }",
          "12: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "13: \u2502 Function correctness: _pause pauses the contract                                                                    \u2502",
          "14: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "16: rule pause(env e) {",
          "17:     require nonpayable(e);",
          "19:     bool pausedBefore = paused();",
          "21:     pause@withrevert(e);",
          "22:     bool success = !lastReverted;",
          "24:     bool pausedAfter = paused();",
          "27:     assert success <=> !pausedBefore, \"works if and only if the contract was not paused before\";",
          "30:     assert success => pausedAfter, \"contract must be paused after a successful call\";",
          "31: }",
          "34: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "35: \u2502 Function correctness: _unpause unpauses the contract                                                                \u2502",
          "36: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "38: rule unpause(env e) {",
          "39:     require nonpayable(e);",
          "41:     bool pausedBefore = paused();",
          "43:     unpause@withrevert(e);",
          "44:     bool success = !lastReverted;",
          "46:     bool pausedAfter = paused();",
          "49:     assert success <=> pausedBefore, \"works if and only if the contract was paused before\";",
          "52:     assert success => !pausedAfter, \"contract must be unpaused after a successful call\";",
          "53: }",
          "56: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "57: \u2502 Function correctness: whenPaused modifier can only be called if the contract is paused                              \u2502",
          "58: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "60: rule whenPaused(env e) {",
          "61:     require nonpayable(e);",
          "63:     onlyWhenPaused@withrevert(e);",
          "64:     assert !lastReverted <=> paused(), \"works if and only if the contract is paused\";",
          "65: }",
          "68: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "69: \u2502 Function correctness: whenNotPaused modifier can only be called if the contract is not paused                       \u2502",
          "70: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "72: rule whenNotPaused(env e) {",
          "73:     require nonpayable(e);",
          "75:     onlyWhenNotPaused@withrevert(e);",
          "76:     assert !lastReverted <=> !paused(), \"works if and only if the contract is not paused\";",
          "77: }",
          "80: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "81: \u2502 Rules: only _pause and _unpause can change paused status                                                            \u2502",
          "82: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "84: rule noPauseChange(env e) {",
          "85:     method f;",
          "86:     calldataarg args;",
          "88:     bool pausedBefore = paused();",
          "89:     f(e, args);",
          "90:     bool pausedAfter = paused();",
          "92:     assert pausedBefore != pausedAfter => (",
          "93:         (!pausedAfter && f.selector == unpause().selector) ||",
          "94:         (pausedAfter && f.selector == pause().selector)",
          "95:     ), \"contract's paused status can only be changed by _pause() or _unpause()\";",
          "96: }",
          "",
          "---------------"
        ],
        "certorspecs/TimelockController.spec||certora/specs/TimelockController.spec": [
          "File: certorspecs/TimelockController.spec -> certora/specs/TimelockController.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import \"helpers/helpers.spec\"",
          "2: import \"methods/IAccessControl.spec\"",
          "4: methods {",
          "5:     TIMELOCK_ADMIN_ROLE()       returns (bytes32) envfree",
          "6:     PROPOSER_ROLE()             returns (bytes32) envfree",
          "7:     EXECUTOR_ROLE()             returns (bytes32) envfree",
          "8:     CANCELLER_ROLE()            returns (bytes32) envfree",
          "9:     isOperation(bytes32)        returns (bool)    envfree",
          "10:     isOperationPending(bytes32) returns (bool)    envfree",
          "11:     isOperationReady(bytes32)   returns (bool)",
          "12:     isOperationDone(bytes32)    returns (bool)    envfree",
          "13:     getTimestamp(bytes32)       returns (uint256) envfree",
          "14:     getMinDelay()               returns (uint256) envfree",
          "16:     hashOperation(address, uint256, bytes, bytes32, bytes32)            returns(bytes32) envfree",
          "17:     hashOperationBatch(address[], uint256[], bytes[], bytes32, bytes32) returns(bytes32) envfree",
          "19:     schedule(address, uint256, bytes, bytes32, bytes32, uint256)",
          "20:     scheduleBatch(address[], uint256[], bytes[], bytes32, bytes32, uint256)",
          "21:     execute(address, uint256, bytes, bytes32, bytes32)",
          "22:     executeBatch(address[], uint256[], bytes[], bytes32, bytes32)",
          "23:     cancel(bytes32)",
          "25:     updateDelay(uint256)",
          "26: }",
          "29: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "30: \u2502 Helpers                                                                                                             \u2502",
          "31: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "34: function helperScheduleWithRevert(env e, method f, bytes32 id, uint256 delay) {",
          "35:     if (f.selector == schedule(address, uint256, bytes, bytes32, bytes32, uint256).selector) {",
          "36:         address target; uint256 value; bytes data; bytes32 predecessor; bytes32 salt;",
          "37:         require hashOperation(target, value, data, predecessor, salt) == id; // Correlation",
          "38:         schedule@withrevert(e, target, value, data, predecessor, salt, delay);",
          "39:     } else if (f.selector == scheduleBatch(address[], uint256[], bytes[], bytes32, bytes32, uint256).selector) {",
          "40:         address[] targets; uint256[] values; bytes[] payloads; bytes32 predecessor; bytes32 salt;",
          "41:         require hashOperationBatch(targets, values, payloads, predecessor, salt) == id; // Correlation",
          "42:         scheduleBatch@withrevert(e, targets, values, payloads, predecessor, salt, delay);",
          "43:     } else {",
          "44:         calldataarg args;",
          "45:         f@withrevert(e, args);",
          "46:     }",
          "47: }",
          "50: function helperExecuteWithRevert(env e, method f, bytes32 id, bytes32 predecessor) {",
          "51:     if (f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector) {",
          "52:         address target; uint256 value; bytes data; bytes32 salt;",
          "53:         require hashOperation(target, value, data, predecessor, salt) == id; // Correlation",
          "54:         execute@withrevert(e, target, value, data, predecessor, salt);",
          "55:     } else if (f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector) {",
          "56:         address[] targets; uint256[] values; bytes[] payloads; bytes32 salt;",
          "57:         require hashOperationBatch(targets, values, payloads, predecessor, salt) == id; // Correlation",
          "58:         executeBatch@withrevert(e, targets, values, payloads, predecessor, salt);",
          "59:     } else {",
          "60:         calldataarg args;",
          "61:         f@withrevert(e, args);",
          "62:     }",
          "63: }",
          "66: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "67: \u2502 Definitions                                                                                                         \u2502",
          "68: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "70: definition DONE_TIMESTAMP()      returns uint256 = 1;",
          "71: definition UNSET()               returns uint8   = 0x1;",
          "72: definition PENDING()             returns uint8   = 0x2;",
          "73: definition DONE()                returns uint8   = 0x4;",
          "75: definition isUnset(bytes32 id)   returns bool    = !isOperation(id);",
          "76: definition isPending(bytes32 id) returns bool    = isOperationPending(id);",
          "77: definition isDone(bytes32 id)    returns bool    = isOperationDone(id);",
          "78: definition state(bytes32 id)     returns uint8   = (isUnset(id) ? UNSET() : 0) | (isPending(id) ? PENDING() : 0) | (isDone(id) ? DONE() : 0);",
          "81: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "82: \u2502 Invariants: consistency of accessors                                                                                \u2502",
          "83: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "85: invariant isOperationCheck(bytes32 id)",
          "86:     isOperation(id) <=> getTimestamp(id) > 0",
          "87:     filtered { f -> !f.isView }",
          "89: invariant isOperationPendingCheck(bytes32 id)",
          "90:     isOperationPending(id) <=> getTimestamp(id) > DONE_TIMESTAMP()",
          "91:     filtered { f -> !f.isView }",
          "93: invariant isOperationDoneCheck(bytes32 id)",
          "94:     isOperationDone(id) <=> getTimestamp(id) == DONE_TIMESTAMP()",
          "95:     filtered { f -> !f.isView }",
          "97: invariant isOperationReadyCheck(env e, bytes32 id)",
          "98:     isOperationReady(e, id) <=> (isOperationPending(id) && getTimestamp(id) <= e.block.timestamp)",
          "99:     filtered { f -> !f.isView }",
          "102: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "103: \u2502 Invariant: a proposal id is either unset, pending or done                                                           \u2502",
          "104: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "106: invariant stateConsistency(bytes32 id, env e)",
          "108:     (isUnset(id)   <=> (!isPending(id) && !isDone(id)   )) &&",
          "109:     (isPending(id) <=> (!isUnset(id)   && !isDone(id)   )) &&",
          "110:     (isDone(id)    <=> (!isUnset(id)   && !isPending(id))) &&",
          "112:     (isUnset(id)   <=> state(id) == UNSET()              ) &&",
          "113:     (isPending(id) <=> state(id) == PENDING()            ) &&",
          "114:     (isDone(id)    <=> state(id) == DONE()               ) &&",
          "116:     isOperationReady(e, id) => isPending(id)",
          "117:     filtered { f -> !f.isView }",
          "120: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "121: \u2502 Rule: state transition rules                                                                                        \u2502",
          "122: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "124: rule stateTransition(bytes32 id, env e, method f, calldataarg args) {",
          "125:     require e.block.timestamp > 1; // Sanity",
          "127:     uint8 stateBefore = state(id);",
          "128:     f(e, args);",
          "129:     uint8 stateAfter = state(id);",
          "132:     assert stateBefore == UNSET() => stateAfter != DONE();",
          "135:     assert stateBefore == UNSET() && stateAfter == PENDING() => (",
          "136:         f.selector == schedule(address, uint256, bytes, bytes32, bytes32, uint256).selector ||",
          "137:         f.selector == scheduleBatch(address[], uint256[], bytes[], bytes32, bytes32, uint256).selector",
          "138:     );",
          "141:     assert stateBefore == PENDING() && stateAfter == UNSET() => (",
          "142:         f.selector == cancel(bytes32).selector",
          "143:     );",
          "146:     assert stateBefore == PENDING() && stateAfter == DONE() => (",
          "147:         f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector ||",
          "148:         f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector",
          "149:     );",
          "152:     assert stateBefore == DONE() => stateAfter == DONE();",
          "153: }",
          "156: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "157: \u2502 Rule: minimum delay can only be updated through a timelock execution                                                \u2502",
          "158: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "160: rule minDelayOnlyChange(env e) {",
          "161:     uint256 delayBefore = getMinDelay();",
          "163:     method f; calldataarg args;",
          "164:     f(e, args);",
          "166:     assert delayBefore != getMinDelay() => (e.msg.sender == currentContract && f.selector == updateDelay(uint256).selector), \"Unauthorized delay update\";",
          "167: }",
          "170: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "171: \u2502 Rule: schedule liveness and effects                                                                                \u2502",
          "172: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "174: rule schedule(env e, method f, bytes32 id, uint256 delay) filtered { f ->",
          "175:     f.selector == schedule(address, uint256, bytes, bytes32, bytes32, uint256).selector ||",
          "176:     f.selector == scheduleBatch(address[], uint256[], bytes[], bytes32, bytes32, uint256).selector",
          "177: } {",
          "178:     require nonpayable(e);",
          "181:     require e.block.timestamp > 1;",
          "182:     require e.block.timestamp + delay < max_uint256;",
          "183:     require e.block.timestamp + getMinDelay() < max_uint256;",
          "185:     bytes32 otherId; uint256 otherTimestamp = getTimestamp(otherId);",
          "187:     uint8 stateBefore       = state(id);",
          "188:     bool  isDelaySufficient = delay >= getMinDelay();",
          "189:     bool  isProposerBefore  = hasRole(PROPOSER_ROLE(), e.msg.sender);",
          "191:     helperScheduleWithRevert(e, f, id, delay);",
          "192:     bool success = !lastReverted;",
          "195:     assert success <=> (",
          "196:         stateBefore == UNSET() &&",
          "197:         isDelaySufficient &&",
          "198:         isProposerBefore",
          "199:     );",
          "202:     assert success => state(id) == PENDING(), \"State transition violation\";",
          "203:     assert success => getTimestamp(id) == to_uint256(e.block.timestamp + delay), \"Proposal timestamp not correctly set\";",
          "206:     assert otherTimestamp != getTimestamp(otherId) => id == otherId, \"Other proposal affected\";",
          "207: }",
          "210: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "211: \u2502 Rule: execute liveness and effects                                                                                 \u2502",
          "212: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "214: rule execute(env e, method f, bytes32 id, bytes32 predecessor) filtered { f ->",
          "215:     f.selector == execute(address, uint256, bytes, bytes32, bytes32).selector ||",
          "216:     f.selector == executeBatch(address[], uint256[], bytes[], bytes32, bytes32).selector",
          "217: } {",
          "218:     bytes32 otherId; uint256 otherTimestamp = getTimestamp(otherId);",
          "220:     uint8 stateBefore            = state(id);",
          "221:     bool  isOperationReadyBefore = isOperationReady(e, id);",
          "222:     bool  isExecutorOrOpen       = hasRole(EXECUTOR_ROLE(), e.msg.sender) || hasRole(EXECUTOR_ROLE(), 0);",
          "223:     bool  predecessorDependency  = predecessor == 0 || isDone(predecessor);",
          "225:     helperExecuteWithRevert(e, f, id, predecessor);",
          "226:     bool success = !lastReverted;",
          "234:     assert success => (",
          "235:         stateBefore == PENDING() &&",
          "236:         isOperationReadyBefore &&",
          "237:         predecessorDependency &&",
          "238:         isExecutorOrOpen",
          "239:     );",
          "242:     assert success => state(id) == DONE(), \"State transition violation\";",
          "245:     assert otherTimestamp != getTimestamp(otherId) => id == otherId, \"Other proposal affected\";",
          "246: }",
          "249: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
          "250: \u2502 Rule: cancel liveness and effects                                                                                  \u2502",
          "251: \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
          "253: rule cancel(env e, bytes32 id) {",
          "254:     require nonpayable(e);",
          "256:     bytes32 otherId; uint256 otherTimestamp = getTimestamp(otherId);",
          "258:     uint8 stateBefore = state(id);",
          "259:     bool  isCanceller = hasRole(CANCELLER_ROLE(), e.msg.sender);",
          "261:     cancel@withrevert(e, id);",
          "262:     bool success = !lastReverted;",
          "265:     assert success <=> (",
          "266:         stateBefore == PENDING() &&",
          "267:         isCanceller",
          "268:     );",
          "271:     assert success => state(id) == UNSET(), \"State transition violation\";",
          "274:     assert otherTimestamp != getTimestamp(otherId) => id == otherId, \"Other proposal affected\";",
          "275: }",
          "",
          "---------------"
        ],
        "certorspecs/helpers/helpers.spec||certora/specs/helpers/helpers.spec": [
          "File: certorspecs/helpers/helpers.spec -> certora/specs/helpers/helpers.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: definition nonpayable(env e) returns bool = e.msg.value == 0;",
          "",
          "---------------"
        ],
        "certorspecs/methods/IAccessControl.spec||certora/specs/methods/IAccessControl.spec": [
          "File: certorspecs/methods/IAccessControl.spec -> certora/specs/methods/IAccessControl.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: methods {",
          "2:     hasRole(bytes32, address) returns(bool) envfree",
          "3:     getRoleAdmin(bytes32) returns(bytes32) envfree",
          "4:     grantRole(bytes32, address)",
          "5:     revokeRole(bytes32, address)",
          "6:     renounceRole(bytes32, address)",
          "7: }",
          "",
          "---------------"
        ],
        "certorspecs/methods/IAccessControlDefaultAdminRules.spec||certora/specs/methods/IAccessControlDefaultAdminRules.spec": [
          "File: certorspecs/methods/IAccessControlDefaultAdminRules.spec -> certora/specs/methods/IAccessControlDefaultAdminRules.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import \"./IERC5313.spec\"",
          "3: methods {",
          "7:     defaultAdmin() returns(address) envfree",
          "8:     pendingDefaultAdmin() returns(address, uint48) envfree",
          "11:     defaultAdminDelay() returns(uint48)",
          "12:     pendingDefaultAdminDelay() returns(uint48, uint48)",
          "13:     defaultAdminDelayIncreaseWait() returns(uint48) envfree",
          "18:     beginDefaultAdminTransfer(address)",
          "19:     cancelDefaultAdminTransfer()",
          "20:     acceptDefaultAdminTransfer()",
          "23:     changeDefaultAdminDelay(uint48)",
          "24:     rollbackDefaultAdminDelay()",
          "29:     pendingDefaultAdmin_() returns (address) envfree",
          "30:     pendingDefaultAdminSchedule_() returns (uint48) envfree",
          "33:     pendingDelay_() returns (uint48)",
          "34:     pendingDelaySchedule_() returns (uint48)",
          "35:     delayChangeWait_(uint48) returns (uint48)",
          "36: }",
          "",
          "---------------"
        ],
        "certorspecs/methods/IERC20.spec||certora/specs/methods/IERC20.spec": [
          "File: certorspecs/methods/IERC20.spec -> certora/specs/methods/IERC20.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: methods {",
          "2:     name()                                returns (string)  envfree => DISPATCHER(true)",
          "3:     symbol()                              returns (string)  envfree => DISPATCHER(true)",
          "4:     decimals()                            returns (uint8)   envfree => DISPATCHER(true)",
          "5:     totalSupply()                         returns (uint256) envfree => DISPATCHER(true)",
          "6:     balanceOf(address)                    returns (uint256) envfree => DISPATCHER(true)",
          "7:     allowance(address,address)            returns (uint256) envfree => DISPATCHER(true)",
          "8:     approve(address,uint256)              returns (bool)            => DISPATCHER(true)",
          "9:     transfer(address,uint256)             returns (bool)            => DISPATCHER(true)",
          "10:     transferFrom(address,address,uint256) returns (bool)            => DISPATCHER(true)",
          "11: }",
          "",
          "---------------"
        ],
        "certorspecs/methods/IERC2612.spec||certora/specs/methods/IERC2612.spec": [
          "File: certorspecs/methods/IERC2612.spec -> certora/specs/methods/IERC2612.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: methods {",
          "2:     permit(address,address,uint256,uint256,uint8,bytes32,bytes32) => DISPATCHER(true)",
          "3:     nonces(address)    returns (uint256) envfree                  => DISPATCHER(true)",
          "4:     DOMAIN_SEPARATOR() returns (bytes32) envfree                  => DISPATCHER(true)",
          "5: }",
          "",
          "---------------"
        ],
        "certorspecs/methods/IERC3156.spec||certora/specs/methods/IERC3156.spec": [
          "File: certorspecs/methods/IERC3156.spec -> certora/specs/methods/IERC3156.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: methods {",
          "2:     maxFlashLoan(address)                    returns (uint256) envfree => DISPATCHER(true)",
          "3:     flashFee(address,uint256)                returns (uint256) envfree => DISPATCHER(true)",
          "4:     flashLoan(address,address,uint256,bytes) returns (bool)            => DISPATCHER(true)",
          "5: }",
          "",
          "---------------"
        ],
        "certorspecs/methods/IERC5313.spec||certora/specs/methods/IERC5313.spec": [
          "File: certorspecs/methods/IERC5313.spec -> certora/specs/methods/IERC5313.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: methods {",
          "2:     owner() returns (address) envfree",
          "3: }",
          "",
          "---------------"
        ],
        "certorspecs/methods/IERC721.spec||certora/specs/methods/IERC721.spec": [
          "File: certorspecs/methods/IERC721.spec -> certora/specs/methods/IERC721.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: methods {",
          "3:     balanceOf(address)                              returns (uint256) envfree => DISPATCHER(true)",
          "4:     ownerOf(uint256)                                returns (address) envfree => DISPATCHER(true)",
          "5:     getApproved(uint256)                            returns (address) envfree => DISPATCHER(true)",
          "6:     isApprovedForAll(address,address)               returns (bool)    envfree => DISPATCHER(true)",
          "7:     safeTransferFrom(address,address,uint256,bytes)                           => DISPATCHER(true)",
          "8:     safeTransferFrom(address,address,uint256)                                 => DISPATCHER(true)",
          "9:     transferFrom(address,address,uint256)                                     => DISPATCHER(true)",
          "10:     approve(address,uint256)                                                  => DISPATCHER(true)",
          "11:     setApprovalForAll(address,bool)                                           => DISPATCHER(true)",
          "14:     name()                                          returns (string)          => DISPATCHER(true)",
          "15:     symbol()                                        returns (string)          => DISPATCHER(true)",
          "16:     tokenURI(uint256)                               returns (string)          => DISPATCHER(true)",
          "19:     onERC721Received(address,address,uint256,bytes) returns (bytes4)          => DISPATCHER(true)",
          "20: }",
          "",
          "---------------"
        ],
        "certorspecs/methods/IOwnable.spec||certora/specs/methods/IOwnable.spec": [
          "File: certorspecs/methods/IOwnable.spec -> certora/specs/methods/IOwnable.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: methods {",
          "2:     owner() returns (address) envfree",
          "3:     transferOwnership(address)",
          "4:     renounceOwnership()",
          "5: }",
          "",
          "---------------"
        ],
        "certorspecs/methods/IOwnable2Step.spec||certora/specs/methods/IOwnable2Step.spec": [
          "File: certorspecs/methods/IOwnable2Step.spec -> certora/specs/methods/IOwnable2Step.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: methods {",
          "2:     owner() returns (address) envfree",
          "3:     pendingOwner() returns (address) envfree",
          "4:     transferOwnership(address)",
          "5:     acceptOwnership()",
          "6:     renounceOwnership()",
          "7: }",
          "",
          "---------------"
        ],
        "contracts/access/AccessControlCrossChainUpgradeable.sol||contracts/access/AccessControlCrossChainUpgradeable.sol": [
          "File: contracts/access/AccessControlCrossChainUpgradeable.sol -> contracts/access/AccessControlCrossChainUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.4;",
          "6: import \"./AccessControlUpgradeable.sol\";",
          "7: import \"../crosschain/CrossChainEnabledUpgradeable.sol\";",
          "8: import \"../proxy/utils/Initializable.sol\";",
          "26: abstract contract AccessControlCrossChainUpgradeable is Initializable, AccessControlUpgradeable, CrossChainEnabledUpgradeable {",
          "27:     function __AccessControlCrossChain_init() internal onlyInitializing {",
          "28:     }",
          "30:     function __AccessControlCrossChain_init_unchained() internal onlyInitializing {",
          "31:     }",
          "32:     bytes32 public constant CROSSCHAIN_ALIAS = keccak256(\"CROSSCHAIN_ALIAS\");",
          "37:     function _checkRole(bytes32 role) internal view virtual override {",
          "38:         if (_isCrossChain()) {",
          "39:             _checkRole(_crossChainRoleAlias(role), _crossChainSender());",
          "40:         } else {",
          "41:             super._checkRole(role);",
          "42:         }",
          "43:     }",
          "48:     function _crossChainRoleAlias(bytes32 role) internal pure virtual returns (bytes32) {",
          "49:         return role ^ CROSSCHAIN_ALIAS;",
          "50:     }",
          "57:     uint256[50] private __gap;",
          "58: }",
          "",
          "---------------"
        ],
        "contracts/access/AccessControlDefaultAdminRulesUpgradeable.sol||contracts/access/AccessControlDefaultAdminRulesUpgradeable.sol": [
          "File: contracts/access/AccessControlDefaultAdminRulesUpgradeable.sol -> contracts/access/AccessControlDefaultAdminRulesUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./AccessControlUpgradeable.sol\";",
          "7: import \"./IAccessControlDefaultAdminRulesUpgradeable.sol\";",
          "8: import \"../utils/math/SafeCastUpgradeable.sol\";",
          "9: import \"../interfaces/IERC5313Upgradeable.sol\";",
          "10: import \"../proxy/utils/Initializable.sol\";",
          "41: abstract contract AccessControlDefaultAdminRulesUpgradeable is Initializable, IAccessControlDefaultAdminRulesUpgradeable, IERC5313Upgradeable, AccessControlUpgradeable {",
          "43:     address private _pendingDefaultAdmin;",
          "44:     uint48 private _pendingDefaultAdminSchedule; // 0 == unset",
          "46:     uint48 private _currentDelay;",
          "47:     address private _currentDefaultAdmin;",
          "50:     uint48 private _pendingDelay;",
          "51:     uint48 private _pendingDelaySchedule; // 0 == unset",
          "56:     function __AccessControlDefaultAdminRules_init(uint48 initialDelay, address initialDefaultAdmin) internal onlyInitializing {",
          "57:         __AccessControlDefaultAdminRules_init_unchained(initialDelay, initialDefaultAdmin);",
          "58:     }",
          "60:     function __AccessControlDefaultAdminRules_init_unchained(uint48 initialDelay, address initialDefaultAdmin) internal onlyInitializing {",
          "61:         require(initialDefaultAdmin != address(0), \"AccessControl: 0 default admin\");",
          "62:         _currentDelay = initialDelay;",
          "63:         _grantRole(DEFAULT_ADMIN_ROLE, initialDefaultAdmin);",
          "64:     }",
          "69:     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {",
          "70:         return interfaceId == type(IAccessControlDefaultAdminRulesUpgradeable).interfaceId || super.supportsInterface(interfaceId);",
          "71:     }",
          "76:     function owner() public view virtual returns (address) {",
          "77:         return defaultAdmin();",
          "78:     }",
          "87:     function grantRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {",
          "88:         require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't directly grant default admin role\");",
          "89:         super.grantRole(role, account);",
          "90:     }",
          "95:     function revokeRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {",
          "96:         require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't directly revoke default admin role\");",
          "97:         super.revokeRole(role, account);",
          "98:     }",
          "113:     function renounceRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {",
          "114:         if (role == DEFAULT_ADMIN_ROLE) {",
          "115:             (address newDefaultAdmin, uint48 schedule) = pendingDefaultAdmin();",
          "116:             require(",
          "117:                 newDefaultAdmin == address(0) && _isScheduleSet(schedule) && _hasSchedulePassed(schedule),",
          "118:                 \"AccessControl: only can renounce in two delayed steps\"",
          "119:             );",
          "120:         }",
          "121:         super.renounceRole(role, account);",
          "122:     }",
          "133:     function _grantRole(bytes32 role, address account) internal virtual override {",
          "134:         if (role == DEFAULT_ADMIN_ROLE) {",
          "135:             require(defaultAdmin() == address(0), \"AccessControl: default admin already granted\");",
          "136:             _currentDefaultAdmin = account;",
          "137:         }",
          "138:         super._grantRole(role, account);",
          "139:     }",
          "144:     function _revokeRole(bytes32 role, address account) internal virtual override {",
          "145:         if (role == DEFAULT_ADMIN_ROLE && account == _currentDefaultAdmin) {",
          "146:             delete _currentDefaultAdmin;",
          "147:         }",
          "148:         super._revokeRole(role, account);",
          "149:     }",
          "154:     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual override {",
          "155:         require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't violate default admin rules\");",
          "156:         super._setRoleAdmin(role, adminRole);",
          "157:     }",
          "166:     function defaultAdmin() public view virtual returns (address) {",
          "167:         return _currentDefaultAdmin;",
          "168:     }",
          "173:     function pendingDefaultAdmin() public view virtual returns (address newAdmin, uint48 schedule) {",
          "174:         return (_pendingDefaultAdmin, _pendingDefaultAdminSchedule);",
          "175:     }",
          "180:     function defaultAdminDelay() public view virtual returns (uint48) {",
          "181:         uint48 schedule = _pendingDelaySchedule;",
          "182:         return (_isScheduleSet(schedule) && _hasSchedulePassed(schedule)) ? _pendingDelay : _currentDelay;",
          "183:     }",
          "188:     function pendingDefaultAdminDelay() public view virtual returns (uint48 newDelay, uint48 schedule) {",
          "189:         schedule = _pendingDelaySchedule;",
          "190:         return (_isScheduleSet(schedule) && !_hasSchedulePassed(schedule)) ? (_pendingDelay, schedule) : (0, 0);",
          "191:     }",
          "196:     function defaultAdminDelayIncreaseWait() public view virtual returns (uint48) {",
          "197:         return 5 days;",
          "198:     }",
          "207:     function beginDefaultAdminTransfer(address newAdmin) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {",
          "208:         _beginDefaultAdminTransfer(newAdmin);",
          "209:     }",
          "216:     function _beginDefaultAdminTransfer(address newAdmin) internal virtual {",
          "217:         uint48 newSchedule = SafeCastUpgradeable.toUint48(block.timestamp) + defaultAdminDelay();",
          "218:         _setPendingDefaultAdmin(newAdmin, newSchedule);",
          "219:         emit DefaultAdminTransferScheduled(newAdmin, newSchedule);",
          "220:     }",
          "225:     function cancelDefaultAdminTransfer() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {",
          "226:         _cancelDefaultAdminTransfer();",
          "227:     }",
          "234:     function _cancelDefaultAdminTransfer() internal virtual {",
          "235:         _setPendingDefaultAdmin(address(0), 0);",
          "236:     }",
          "241:     function acceptDefaultAdminTransfer() public virtual {",
          "242:         (address newDefaultAdmin, ) = pendingDefaultAdmin();",
          "243:         require(_msgSender() == newDefaultAdmin, \"AccessControl: pending admin must accept\");",
          "244:         _acceptDefaultAdminTransfer();",
          "245:     }",
          "252:     function _acceptDefaultAdminTransfer() internal virtual {",
          "253:         (address newAdmin, uint48 schedule) = pendingDefaultAdmin();",
          "254:         require(_isScheduleSet(schedule) && _hasSchedulePassed(schedule), \"AccessControl: transfer delay not passed\");",
          "255:         _revokeRole(DEFAULT_ADMIN_ROLE, defaultAdmin());",
          "256:         _grantRole(DEFAULT_ADMIN_ROLE, newAdmin);",
          "257:         delete _pendingDefaultAdmin;",
          "258:         delete _pendingDefaultAdminSchedule;",
          "259:     }",
          "268:     function changeDefaultAdminDelay(uint48 newDelay) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {",
          "269:         _changeDefaultAdminDelay(newDelay);",
          "270:     }",
          "277:     function _changeDefaultAdminDelay(uint48 newDelay) internal virtual {",
          "278:         uint48 newSchedule = SafeCastUpgradeable.toUint48(block.timestamp) + _delayChangeWait(newDelay);",
          "279:         _setPendingDelay(newDelay, newSchedule);",
          "280:         emit DefaultAdminDelayChangeScheduled(newDelay, newSchedule);",
          "281:     }",
          "286:     function rollbackDefaultAdminDelay() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {",
          "287:         _rollbackDefaultAdminDelay();",
          "288:     }",
          "295:     function _rollbackDefaultAdminDelay() internal virtual {",
          "296:         _setPendingDelay(0, 0);",
          "297:     }",
          "308:     function _delayChangeWait(uint48 newDelay) internal view virtual returns (uint48) {",
          "309:         uint48 currentDelay = defaultAdminDelay();",
          "320:         return",
          "321:             newDelay > currentDelay",
          "322:                 ? uint48(MathUpgradeable.min(newDelay, defaultAdminDelayIncreaseWait())) // no need to safecast, both inputs are uint48",
          "323:                 : currentDelay - newDelay;",
          "324:     }",
          "335:     function _setPendingDefaultAdmin(address newAdmin, uint48 newSchedule) private {",
          "336:         (, uint48 oldSchedule) = pendingDefaultAdmin();",
          "338:         _pendingDefaultAdmin = newAdmin;",
          "339:         _pendingDefaultAdminSchedule = newSchedule;",
          "342:         if (_isScheduleSet(oldSchedule)) {",
          "344:             emit DefaultAdminTransferCanceled();",
          "345:         }",
          "346:     }",
          "353:     function _setPendingDelay(uint48 newDelay, uint48 newSchedule) private {",
          "354:         uint48 oldSchedule = _pendingDelaySchedule;",
          "356:         if (_isScheduleSet(oldSchedule)) {",
          "357:             if (_hasSchedulePassed(oldSchedule)) {",
          "359:                 _currentDelay = _pendingDelay;",
          "360:             } else {",
          "362:                 emit DefaultAdminDelayChangeCanceled();",
          "363:             }",
          "364:         }",
          "366:         _pendingDelay = newDelay;",
          "367:         _pendingDelaySchedule = newSchedule;",
          "368:     }",
          "377:     function _isScheduleSet(uint48 schedule) private pure returns (bool) {",
          "378:         return schedule != 0;",
          "379:     }",
          "384:     function _hasSchedulePassed(uint48 schedule) private view returns (bool) {",
          "385:         return schedule < block.timestamp;",
          "386:     }",
          "393:     uint256[48] private __gap;",
          "394: }",
          "",
          "---------------"
        ],
        "contracts/access/AccessControlEnumerableUpgradeable.sol||contracts/access/AccessControlEnumerableUpgradeable.sol": [
          "File: contracts/access/AccessControlEnumerableUpgradeable.sol -> contracts/access/AccessControlEnumerableUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IAccessControlEnumerableUpgradeable.sol\";",
          "7: import \"./AccessControlUpgradeable.sol\";",
          "8: import \"../utils/structs/EnumerableSetUpgradeable.sol\";",
          "9: import \"../proxy/utils/Initializable.sol\";",
          "14: abstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {",
          "15:     function __AccessControlEnumerable_init() internal onlyInitializing {",
          "16:     }",
          "18:     function __AccessControlEnumerable_init_unchained() internal onlyInitializing {",
          "19:     }",
          "20:     using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;",
          "22:     mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;",
          "27:     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {",
          "28:         return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);",
          "29:     }",
          "43:     function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {",
          "44:         return _roleMembers[role].at(index);",
          "45:     }",
          "51:     function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {",
          "52:         return _roleMembers[role].length();",
          "53:     }",
          "58:     function _grantRole(bytes32 role, address account) internal virtual override {",
          "59:         super._grantRole(role, account);",
          "60:         _roleMembers[role].add(account);",
          "61:     }",
          "66:     function _revokeRole(bytes32 role, address account) internal virtual override {",
          "67:         super._revokeRole(role, account);",
          "68:         _roleMembers[role].remove(account);",
          "69:     }",
          "76:     uint256[49] private __gap;",
          "77: }",
          "",
          "---------------"
        ],
        "contracts/access/AccessControlUpgradeable.sol||contracts/access/AccessControlUpgradeable.sol": [
          "File: contracts/access/AccessControlUpgradeable.sol -> contracts/access/AccessControlUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IAccessControlUpgradeable.sol\";",
          "7: import \"../utils/ContextUpgradeable.sol\";",
          "8: import \"../utils/StringsUpgradeable.sol\";",
          "9: import \"../utils/introspection/ERC165Upgradeable.sol\";",
          "10: import \"../proxy/utils/Initializable.sol\";",
          "51: abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {",
          "52:     function __AccessControl_init() internal onlyInitializing {",
          "53:     }",
          "55:     function __AccessControl_init_unchained() internal onlyInitializing {",
          "56:     }",
          "57:     struct RoleData {",
          "58:         mapping(address => bool) members;",
          "59:         bytes32 adminRole;",
          "60:     }",
          "62:     mapping(bytes32 => RoleData) private _roles;",
          "64:     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;",
          "76:     modifier onlyRole(bytes32 role) {",
          "77:         _checkRole(role);",
          "78:         _;",
          "79:     }",
          "84:     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {",
          "85:         return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);",
          "86:     }",
          "91:     function hasRole(bytes32 role, address account) public view virtual override returns (bool) {",
          "92:         return _roles[role].members[account];",
          "93:     }",
          "103:     function _checkRole(bytes32 role) internal view virtual {",
          "104:         _checkRole(role, _msgSender());",
          "105:     }",
          "114:     function _checkRole(bytes32 role, address account) internal view virtual {",
          "115:         if (!hasRole(role, account)) {",
          "116:             revert(",
          "117:                 string(",
          "118:                     abi.encodePacked(",
          "119:                         \"AccessControl: account \",",
          "120:                         StringsUpgradeable.toHexString(account),",
          "121:                         \" is missing role \",",
          "122:                         StringsUpgradeable.toHexString(uint256(role), 32)",
          "123:                     )",
          "124:                 )",
          "125:             );",
          "126:         }",
          "127:     }",
          "135:     function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {",
          "136:         return _roles[role].adminRole;",
          "137:     }",
          "151:     function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {",
          "152:         _grantRole(role, account);",
          "153:     }",
          "166:     function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {",
          "167:         _revokeRole(role, account);",
          "168:     }",
          "186:     function renounceRole(bytes32 role, address account) public virtual override {",
          "187:         require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");",
          "189:         _revokeRole(role, account);",
          "190:     }",
          "212:     function _setupRole(bytes32 role, address account) internal virtual {",
          "213:         _grantRole(role, account);",
          "214:     }",
          "221:     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {",
          "222:         bytes32 previousAdminRole = getRoleAdmin(role);",
          "223:         _roles[role].adminRole = adminRole;",
          "224:         emit RoleAdminChanged(role, previousAdminRole, adminRole);",
          "225:     }",
          "234:     function _grantRole(bytes32 role, address account) internal virtual {",
          "235:         if (!hasRole(role, account)) {",
          "236:             _roles[role].members[account] = true;",
          "237:             emit RoleGranted(role, account, _msgSender());",
          "238:         }",
          "239:     }",
          "248:     function _revokeRole(bytes32 role, address account) internal virtual {",
          "249:         if (hasRole(role, account)) {",
          "250:             _roles[role].members[account] = false;",
          "251:             emit RoleRevoked(role, account, _msgSender());",
          "252:         }",
          "253:     }",
          "260:     uint256[49] private __gap;",
          "261: }",
          "",
          "---------------"
        ],
        "contracts/access/IAccessControlDefaultAdminRulesUpgradeable.sol||contracts/access/IAccessControlDefaultAdminRulesUpgradeable.sol": [
          "File: contracts/access/IAccessControlDefaultAdminRulesUpgradeable.sol -> contracts/access/IAccessControlDefaultAdminRulesUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IAccessControlUpgradeable.sol\";",
          "13: interface IAccessControlDefaultAdminRulesUpgradeable is IAccessControlUpgradeable {",
          "19:     event DefaultAdminTransferScheduled(address indexed newAdmin, uint48 acceptSchedule);",
          "24:     event DefaultAdminTransferCanceled();",
          "30:     event DefaultAdminDelayChangeScheduled(uint48 newDelay, uint48 effectSchedule);",
          "35:     event DefaultAdminDelayChangeCanceled();",
          "40:     function defaultAdmin() external view returns (address);",
          "52:     function pendingDefaultAdmin() external view returns (address newAdmin, uint48 acceptSchedule);",
          "63:     function defaultAdminDelay() external view returns (uint48);",
          "76:     function pendingDefaultAdminDelay() external view returns (uint48 newDelay, uint48 effectSchedule);",
          "88:     function beginDefaultAdminTransfer(address newAdmin) external;",
          "101:     function cancelDefaultAdminTransfer() external;",
          "117:     function acceptDefaultAdminTransfer() external;",
          "145:     function changeDefaultAdminDelay(uint48 newDelay) external;",
          "156:     function rollbackDefaultAdminDelay() external;",
          "171:     function defaultAdminDelayIncreaseWait() external view returns (uint48);",
          "172: }",
          "",
          "---------------"
        ],
        "contracts/access/IAccessControlEnumerableUpgradeable.sol||contracts/access/IAccessControlEnumerableUpgradeable.sol": [
          "File: contracts/access/IAccessControlEnumerableUpgradeable.sol -> contracts/access/IAccessControlEnumerableUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IAccessControlUpgradeable.sol\";",
          "11: interface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {",
          "24:     function getRoleMember(bytes32 role, uint256 index) external view returns (address);",
          "30:     function getRoleMemberCount(bytes32 role) external view returns (uint256);",
          "31: }",
          "",
          "---------------"
        ],
        "contracts/access/IAccessControlUpgradeable.sol||contracts/access/IAccessControlUpgradeable.sol": [
          "File: contracts/access/IAccessControlUpgradeable.sol -> contracts/access/IAccessControlUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "9: interface IAccessControlUpgradeable {",
          "18:     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);",
          "26:     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);",
          "35:     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);",
          "40:     function hasRole(bytes32 role, address account) external view returns (bool);",
          "48:     function getRoleAdmin(bytes32 role) external view returns (bytes32);",
          "60:     function grantRole(bytes32 role, address account) external;",
          "71:     function revokeRole(bytes32 role, address account) external;",
          "87:     function renounceRole(bytes32 role, address account) external;",
          "88: }",
          "",
          "---------------"
        ],
        "contracts/access/Ownable2StepUpgradeable.sol||contracts/access/Ownable2StepUpgradeable.sol": [
          "File: contracts/access/Ownable2StepUpgradeable.sol -> contracts/access/Ownable2StepUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./OwnableUpgradeable.sol\";",
          "7: import \"../proxy/utils/Initializable.sol\";",
          "20: abstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {",
          "21:     function __Ownable2Step_init() internal onlyInitializing {",
          "22:         __Ownable_init_unchained();",
          "23:     }",
          "25:     function __Ownable2Step_init_unchained() internal onlyInitializing {",
          "26:     }",
          "27:     address private _pendingOwner;",
          "29:     event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);",
          "34:     function pendingOwner() public view virtual returns (address) {",
          "35:         return _pendingOwner;",
          "36:     }",
          "42:     function transferOwnership(address newOwner) public virtual override onlyOwner {",
          "43:         _pendingOwner = newOwner;",
          "44:         emit OwnershipTransferStarted(owner(), newOwner);",
          "45:     }",
          "51:     function _transferOwnership(address newOwner) internal virtual override {",
          "52:         delete _pendingOwner;",
          "53:         super._transferOwnership(newOwner);",
          "54:     }",
          "59:     function acceptOwnership() public virtual {",
          "60:         address sender = _msgSender();",
          "61:         require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");",
          "62:         _transferOwnership(sender);",
          "63:     }",
          "70:     uint256[49] private __gap;",
          "71: }",
          "",
          "---------------"
        ],
        "contracts/access/OwnableUpgradeable.sol||contracts/access/OwnableUpgradeable.sol": [
          "File: contracts/access/OwnableUpgradeable.sol -> contracts/access/OwnableUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../utils/ContextUpgradeable.sol\";",
          "7: import \"../proxy/utils/Initializable.sol\";",
          "21: abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {",
          "22:     address private _owner;",
          "24:     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);",
          "29:     function __Ownable_init() internal onlyInitializing {",
          "30:         __Ownable_init_unchained();",
          "31:     }",
          "33:     function __Ownable_init_unchained() internal onlyInitializing {",
          "34:         _transferOwnership(_msgSender());",
          "35:     }",
          "40:     modifier onlyOwner() {",
          "41:         _checkOwner();",
          "42:         _;",
          "43:     }",
          "48:     function owner() public view virtual returns (address) {",
          "49:         return _owner;",
          "50:     }",
          "55:     function _checkOwner() internal view virtual {",
          "56:         require(owner() == _msgSender(), \"Ownable: caller is not the owner\");",
          "57:     }",
          "66:     function renounceOwnership() public virtual onlyOwner {",
          "67:         _transferOwnership(address(0));",
          "68:     }",
          "74:     function transferOwnership(address newOwner) public virtual onlyOwner {",
          "75:         require(newOwner != address(0), \"Ownable: new owner is the zero address\");",
          "76:         _transferOwnership(newOwner);",
          "77:     }",
          "83:     function _transferOwnership(address newOwner) internal virtual {",
          "84:         address oldOwner = _owner;",
          "85:         _owner = newOwner;",
          "86:         emit OwnershipTransferred(oldOwner, newOwner);",
          "87:     }",
          "94:     uint256[49] private __gap;",
          "95: }",
          "",
          "---------------"
        ],
        "contracts/crosschain/CrossChainEnabledUpgradeable.sol||contracts/crosschain/CrossChainEnabledUpgradeable.sol": [
          "File: contracts/crosschain/CrossChainEnabledUpgradeable.sol -> contracts/crosschain/CrossChainEnabledUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.4;",
          "6: import \"./errorsUpgradeable.sol\";",
          "7: import \"../proxy/utils/Initializable.sol\";",
          "21: abstract contract CrossChainEnabledUpgradeable is Initializable {",
          "22:     function __CrossChainEnabled_init() internal onlyInitializing {",
          "23:     }",
          "25:     function __CrossChainEnabled_init_unchained() internal onlyInitializing {",
          "26:     }",
          "31:     modifier onlyCrossChain() {",
          "32:         if (!_isCrossChain()) revert NotCrossChainCall();",
          "33:         _;",
          "34:     }",
          "40:     modifier onlyCrossChainSender(address expected) {",
          "41:         address actual = _crossChainSender();",
          "42:         if (expected != actual) revert InvalidCrossChainSender(actual, expected);",
          "43:         _;",
          "44:     }",
          "50:     function _isCrossChain() internal view virtual returns (bool);",
          "59:     function _crossChainSender() internal view virtual returns (address);",
          "66:     uint256[50] private __gap;",
          "67: }",
          "",
          "---------------"
        ],
        "contracts/crosschain/amb/CrossChainEnabledAMBUpgradeable.sol||contracts/crosschain/amCrossChainEnabledAMBUpgradeable.sol": [
          "File: contracts/crosschain/amb/CrossChainEnabledAMBUpgradeable.sol -> contracts/crosschain/amCrossChainEnabledAMBUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "contracts/crosschain/amb/LibAMBUpgradeable.sol||contracts/crosschain/amLibAMBUpgradeable.sol": [
          "File: contracts/crosschain/amb/LibAMBUpgradeable.sol -> contracts/crosschain/amLibAMBUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL1Upgradeable.sol||contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL1Upgradeable.sol": [
          "File: contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL1Upgradeable.sol -> contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL1Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.4;",
          "6: import \"../CrossChainEnabledUpgradeable.sol\";",
          "7: import \"./LibArbitrumL1Upgradeable.sol\";",
          "8: import \"../../proxy/utils/Initializable.sol\";",
          "23: abstract contract CrossChainEnabledArbitrumL1Upgradeable is Initializable, CrossChainEnabledUpgradeable {",
          "25:     address private immutable _bridge;",
          "28:     constructor(address bridge) {",
          "29:         _bridge = bridge;",
          "30:     }",
          "35:     function _isCrossChain() internal view virtual override returns (bool) {",
          "36:         return LibArbitrumL1Upgradeable.isCrossChain(_bridge);",
          "37:     }",
          "42:     function _crossChainSender() internal view virtual override onlyCrossChain returns (address) {",
          "43:         return LibArbitrumL1Upgradeable.crossChainSender(_bridge);",
          "44:     }",
          "51:     uint256[50] private __gap;",
          "52: }",
          "",
          "---------------"
        ],
        "contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL2Upgradeable.sol||contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL2Upgradeable.sol": [
          "File: contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL2Upgradeable.sol -> contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL2Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.4;",
          "6: import \"../CrossChainEnabledUpgradeable.sol\";",
          "7: import \"./LibArbitrumL2Upgradeable.sol\";",
          "8: import \"../../proxy/utils/Initializable.sol\";",
          "27: abstract contract CrossChainEnabledArbitrumL2Upgradeable is Initializable, CrossChainEnabledUpgradeable {",
          "28:     function __CrossChainEnabledArbitrumL2_init() internal onlyInitializing {",
          "29:     }",
          "31:     function __CrossChainEnabledArbitrumL2_init_unchained() internal onlyInitializing {",
          "32:     }",
          "36:     function _isCrossChain() internal view virtual override returns (bool) {",
          "37:         return LibArbitrumL2Upgradeable.isCrossChain(LibArbitrumL2Upgradeable.ARBSYS);",
          "38:     }",
          "43:     function _crossChainSender() internal view virtual override onlyCrossChain returns (address) {",
          "44:         return LibArbitrumL2Upgradeable.crossChainSender(LibArbitrumL2Upgradeable.ARBSYS);",
          "45:     }",
          "52:     uint256[50] private __gap;",
          "53: }",
          "",
          "---------------"
        ],
        "contracts/crosschain/arbitrum/LibArbitrumL1Upgradeable.sol||contracts/crosschain/arbitrum/LibArbitrumL1Upgradeable.sol": [
          "File: contracts/crosschain/arbitrum/LibArbitrumL1Upgradeable.sol -> contracts/crosschain/arbitrum/LibArbitrumL1Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.4;",
          "6: import { IBridgeUpgradeable as ArbitrumL1_Bridge } from \"../../vendor/arbitrum/IBridgeUpgradeable.sol\";",
          "7: import { IOutboxUpgradeable as ArbitrumL1_Outbox } from \"../../vendor/arbitrum/IOutboxUpgradeable.sol\";",
          "8: import \"../errorsUpgradeable.sol\";",
          "17: library LibArbitrumL1Upgradeable {",
          "22:     function isCrossChain(address bridge) internal view returns (bool) {",
          "23:         return msg.sender == bridge;",
          "24:     }",
          "34:     function crossChainSender(address bridge) internal view returns (address) {",
          "35:         if (!isCrossChain(bridge)) revert NotCrossChainCall();",
          "37:         address sender = ArbitrumL1_Outbox(ArbitrumL1_Bridge(bridge).activeOutbox()).l2ToL1Sender();",
          "38:         require(sender != address(0), \"LibArbitrumL1: system messages without sender\");",
          "40:         return sender;",
          "41:     }",
          "42: }",
          "",
          "---------------"
        ],
        "contracts/crosschain/arbitrum/LibArbitrumL2Upgradeable.sol||contracts/crosschain/arbitrum/LibArbitrumL2Upgradeable.sol": [
          "File: contracts/crosschain/arbitrum/LibArbitrumL2Upgradeable.sol -> contracts/crosschain/arbitrum/LibArbitrumL2Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.4;",
          "6: import { IArbSysUpgradeable as ArbitrumL2_Bridge } from \"../../vendor/arbitrum/IArbSysUpgradeable.sol\";",
          "7: import \"../errorsUpgradeable.sol\";",
          "21: library LibArbitrumL2Upgradeable {",
          "26:     address public constant ARBSYS = 0x0000000000000000000000000000000000000064;",
          "28:     function isCrossChain(address arbsys) internal view returns (bool) {",
          "29:         return ArbitrumL2_Bridge(arbsys).wasMyCallersAddressAliased();",
          "30:     }",
          "40:     function crossChainSender(address arbsys) internal view returns (address) {",
          "41:         if (!isCrossChain(arbsys)) revert NotCrossChainCall();",
          "43:         return ArbitrumL2_Bridge(arbsys).myCallersAddressWithoutAliasing();",
          "44:     }",
          "45: }",
          "",
          "---------------"
        ],
        "contracts/crosschain/errorsUpgradeable.sol||contracts/crosschain/errorsUpgradeable.sol": [
          "File: contracts/crosschain/errorsUpgradeable.sol -> contracts/crosschain/errorsUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.4;",
          "6: error NotCrossChainCall();",
          "7: error InvalidCrossChainSender(address actual, address expected);",
          "",
          "---------------"
        ],
        "contracts/crosschain/optimism/CrossChainEnabledOptimismUpgradeable.sol||contracts/crosschain/optimism/CrossChainEnabledOptimismUpgradeable.sol": [
          "File: contracts/crosschain/optimism/CrossChainEnabledOptimismUpgradeable.sol -> contracts/crosschain/optimism/CrossChainEnabledOptimismUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.4;",
          "6: import \"../CrossChainEnabledUpgradeable.sol\";",
          "7: import \"./LibOptimismUpgradeable.sol\";",
          "8: import \"../../proxy/utils/Initializable.sol\";",
          "20: abstract contract CrossChainEnabledOptimismUpgradeable is Initializable, CrossChainEnabledUpgradeable {",
          "22:     address private immutable _messenger;",
          "25:     constructor(address messenger) {",
          "26:         _messenger = messenger;",
          "27:     }",
          "32:     function _isCrossChain() internal view virtual override returns (bool) {",
          "33:         return LibOptimismUpgradeable.isCrossChain(_messenger);",
          "34:     }",
          "39:     function _crossChainSender() internal view virtual override onlyCrossChain returns (address) {",
          "40:         return LibOptimismUpgradeable.crossChainSender(_messenger);",
          "41:     }",
          "48:     uint256[50] private __gap;",
          "49: }",
          "",
          "---------------"
        ],
        "contracts/crosschain/optimism/LibOptimismUpgradeable.sol||contracts/crosschain/optimism/LibOptimismUpgradeable.sol": [
          "File: contracts/crosschain/optimism/LibOptimismUpgradeable.sol -> contracts/crosschain/optimism/LibOptimismUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.4;",
          "6: import { ICrossDomainMessengerUpgradeable as Optimism_Bridge } from \"../../vendor/optimism/ICrossDomainMessengerUpgradeable.sol\";",
          "7: import \"../errorsUpgradeable.sol\";",
          "14: library LibOptimismUpgradeable {",
          "19:     function isCrossChain(address messenger) internal view returns (bool) {",
          "20:         return msg.sender == messenger;",
          "21:     }",
          "31:     function crossChainSender(address messenger) internal view returns (address) {",
          "32:         if (!isCrossChain(messenger)) revert NotCrossChainCall();",
          "34:         return Optimism_Bridge(messenger).xDomainMessageSender();",
          "35:     }",
          "36: }",
          "",
          "---------------"
        ],
        "contracts/crosschain/polygon/CrossChainEnabledPolygonChildUpgradeable.sol||contracts/crosschain/polygon/CrossChainEnabledPolygonChildUpgradeable.sol": [
          "File: contracts/crosschain/polygon/CrossChainEnabledPolygonChildUpgradeable.sol -> contracts/crosschain/polygon/CrossChainEnabledPolygonChildUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.4;",
          "6: import \"../CrossChainEnabledUpgradeable.sol\";",
          "7: import \"../../security/ReentrancyGuardUpgradeable.sol\";",
          "8: import \"../../utils/AddressUpgradeable.sol\";",
          "9: import \"../../vendor/polygon/IFxMessageProcessorUpgradeable.sol\";",
          "10: import \"../../proxy/utils/Initializable.sol\";",
          "12: address constant DEFAULT_SENDER = 0x000000000000000000000000000000000000dEaD;",
          "27: abstract contract CrossChainEnabledPolygonChildUpgradeable is Initializable, IFxMessageProcessorUpgradeable, CrossChainEnabledUpgradeable, ReentrancyGuardUpgradeable {",
          "29:     address private immutable _fxChild;",
          "30:     address private _sender = DEFAULT_SENDER;",
          "33:     constructor(address fxChild) {",
          "34:         _fxChild = fxChild;",
          "35:     }",
          "40:     function _isCrossChain() internal view virtual override returns (bool) {",
          "41:         return msg.sender == _fxChild;",
          "42:     }",
          "47:     function _crossChainSender() internal view virtual override onlyCrossChain returns (address) {",
          "48:         return _sender;",
          "49:     }",
          "62:     function processMessageFromRoot(",
          "63:         uint256 /* stateId */,",
          "64:         address rootMessageSender,",
          "65:         bytes calldata data",
          "66:     ) external override nonReentrant {",
          "67:         if (!_isCrossChain()) revert NotCrossChainCall();",
          "69:         _sender = rootMessageSender;",
          "70:         AddressUpgradeable.functionDelegateCall(address(this), data, \"cross-chain execution failed\");",
          "71:         _sender = DEFAULT_SENDER;",
          "72:     }",
          "79:     uint256[49] private __gap;",
          "80: }",
          "",
          "---------------"
        ],
        "contracts/finance/PaymentSplitterUpgradeable.sol||contracts/finance/PaymentSplitterUpgradeable.sol": [
          "File: contracts/finance/PaymentSplitterUpgradeable.sol -> contracts/finance/PaymentSplitterUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC20/utils/SafeERC20Upgradeable.sol\";",
          "7: import \"../utils/AddressUpgradeable.sol\";",
          "8: import \"../utils/ContextUpgradeable.sol\";",
          "9: import \"../proxy/utils/Initializable.sol\";",
          "29: contract PaymentSplitterUpgradeable is Initializable, ContextUpgradeable {",
          "30:     event PayeeAdded(address account, uint256 shares);",
          "31:     event PaymentReleased(address to, uint256 amount);",
          "32:     event ERC20PaymentReleased(IERC20Upgradeable indexed token, address to, uint256 amount);",
          "33:     event PaymentReceived(address from, uint256 amount);",
          "35:     uint256 private _totalShares;",
          "36:     uint256 private _totalReleased;",
          "38:     mapping(address => uint256) private _shares;",
          "39:     mapping(address => uint256) private _released;",
          "40:     address[] private _payees;",
          "42:     mapping(IERC20Upgradeable => uint256) private _erc20TotalReleased;",
          "43:     mapping(IERC20Upgradeable => mapping(address => uint256)) private _erc20Released;",
          "52:     function __PaymentSplitter_init(address[] memory payees, uint256[] memory shares_) internal onlyInitializing {",
          "53:         __PaymentSplitter_init_unchained(payees, shares_);",
          "54:     }",
          "56:     function __PaymentSplitter_init_unchained(address[] memory payees, uint256[] memory shares_) internal onlyInitializing {",
          "57:         require(payees.length == shares_.length, \"PaymentSplitter: payees and shares length mismatch\");",
          "58:         require(payees.length > 0, \"PaymentSplitter: no payees\");",
          "60:         for (uint256 i = 0; i < payees.length; i++) {",
          "61:             _addPayee(payees[i], shares_[i]);",
          "62:         }",
          "63:     }",
          "74:     receive() external payable virtual {",
          "75:         emit PaymentReceived(_msgSender(), msg.value);",
          "76:     }",
          "81:     function totalShares() public view returns (uint256) {",
          "82:         return _totalShares;",
          "83:     }",
          "88:     function totalReleased() public view returns (uint256) {",
          "89:         return _totalReleased;",
          "90:     }",
          "96:     function totalReleased(IERC20Upgradeable token) public view returns (uint256) {",
          "97:         return _erc20TotalReleased[token];",
          "98:     }",
          "103:     function shares(address account) public view returns (uint256) {",
          "104:         return _shares[account];",
          "105:     }",
          "110:     function released(address account) public view returns (uint256) {",
          "111:         return _released[account];",
          "112:     }",
          "118:     function released(IERC20Upgradeable token, address account) public view returns (uint256) {",
          "119:         return _erc20Released[token][account];",
          "120:     }",
          "125:     function payee(uint256 index) public view returns (address) {",
          "126:         return _payees[index];",
          "127:     }",
          "132:     function releasable(address account) public view returns (uint256) {",
          "133:         uint256 totalReceived = address(this).balance + totalReleased();",
          "134:         return _pendingPayment(account, totalReceived, released(account));",
          "135:     }",
          "141:     function releasable(IERC20Upgradeable token, address account) public view returns (uint256) {",
          "142:         uint256 totalReceived = token.balanceOf(address(this)) + totalReleased(token);",
          "143:         return _pendingPayment(account, totalReceived, released(token, account));",
          "144:     }",
          "150:     function release(address payable account) public virtual {",
          "151:         require(_shares[account] > 0, \"PaymentSplitter: account has no shares\");",
          "153:         uint256 payment = releasable(account);",
          "155:         require(payment != 0, \"PaymentSplitter: account is not due payment\");",
          "159:         _totalReleased += payment;",
          "160:         unchecked {",
          "161:             _released[account] += payment;",
          "162:         }",
          "164:         AddressUpgradeable.sendValue(account, payment);",
          "165:         emit PaymentReleased(account, payment);",
          "166:     }",
          "173:     function release(IERC20Upgradeable token, address account) public virtual {",
          "174:         require(_shares[account] > 0, \"PaymentSplitter: account has no shares\");",
          "176:         uint256 payment = releasable(token, account);",
          "178:         require(payment != 0, \"PaymentSplitter: account is not due payment\");",
          "183:         _erc20TotalReleased[token] += payment;",
          "184:         unchecked {",
          "185:             _erc20Released[token][account] += payment;",
          "186:         }",
          "188:         SafeERC20Upgradeable.safeTransfer(token, account, payment);",
          "189:         emit ERC20PaymentReleased(token, account, payment);",
          "190:     }",
          "196:     function _pendingPayment(",
          "197:         address account,",
          "198:         uint256 totalReceived,",
          "199:         uint256 alreadyReleased",
          "200:     ) private view returns (uint256) {",
          "201:         return (totalReceived * _shares[account]) / _totalShares - alreadyReleased;",
          "202:     }",
          "209:     function _addPayee(address account, uint256 shares_) private {",
          "210:         require(account != address(0), \"PaymentSplitter: account is the zero address\");",
          "211:         require(shares_ > 0, \"PaymentSplitter: shares are 0\");",
          "212:         require(_shares[account] == 0, \"PaymentSplitter: account already has shares\");",
          "214:         _payees.push(account);",
          "215:         _shares[account] = shares_;",
          "216:         _totalShares = _totalShares + shares_;",
          "217:         emit PayeeAdded(account, shares_);",
          "218:     }",
          "225:     uint256[43] private __gap;",
          "226: }",
          "",
          "---------------"
        ],
        "contracts/finance/VestingWalletUpgradeable.sol||contracts/finance/VestingWalletUpgradeable.sol": [
          "File: contracts/finance/VestingWalletUpgradeable.sol -> contracts/finance/VestingWalletUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../token/ERC20/utils/SafeERC20Upgradeable.sol\";",
          "6: import \"../utils/AddressUpgradeable.sol\";",
          "7: import \"../utils/ContextUpgradeable.sol\";",
          "8: import \"../proxy/utils/Initializable.sol\";",
          "22: contract VestingWalletUpgradeable is Initializable, ContextUpgradeable {",
          "23:     event EtherReleased(uint256 amount);",
          "24:     event ERC20Released(address indexed token, uint256 amount);",
          "26:     uint256 private _released;",
          "27:     mapping(address => uint256) private _erc20Released;",
          "28:     address private _beneficiary;",
          "29:     uint64 private _start;",
          "30:     uint64 private _duration;",
          "35:     function __VestingWallet_init(address beneficiaryAddress, uint64 startTimestamp, uint64 durationSeconds) internal onlyInitializing {",
          "36:         __VestingWallet_init_unchained(beneficiaryAddress, startTimestamp, durationSeconds);",
          "37:     }",
          "39:     function __VestingWallet_init_unchained(address beneficiaryAddress, uint64 startTimestamp, uint64 durationSeconds) internal onlyInitializing {",
          "40:         require(beneficiaryAddress != address(0), \"VestingWallet: beneficiary is zero address\");",
          "41:         _beneficiary = beneficiaryAddress;",
          "42:         _start = startTimestamp;",
          "43:         _duration = durationSeconds;",
          "44:     }",
          "49:     receive() external payable virtual {}",
          "54:     function beneficiary() public view virtual returns (address) {",
          "55:         return _beneficiary;",
          "56:     }",
          "61:     function start() public view virtual returns (uint256) {",
          "62:         return _start;",
          "63:     }",
          "68:     function duration() public view virtual returns (uint256) {",
          "69:         return _duration;",
          "70:     }",
          "75:     function released() public view virtual returns (uint256) {",
          "76:         return _released;",
          "77:     }",
          "82:     function released(address token) public view virtual returns (uint256) {",
          "83:         return _erc20Released[token];",
          "84:     }",
          "89:     function releasable() public view virtual returns (uint256) {",
          "90:         return vestedAmount(uint64(block.timestamp)) - released();",
          "91:     }",
          "97:     function releasable(address token) public view virtual returns (uint256) {",
          "98:         return vestedAmount(token, uint64(block.timestamp)) - released(token);",
          "99:     }",
          "106:     function release() public virtual {",
          "107:         uint256 amount = releasable();",
          "108:         _released += amount;",
          "109:         emit EtherReleased(amount);",
          "110:         AddressUpgradeable.sendValue(payable(beneficiary()), amount);",
          "111:     }",
          "118:     function release(address token) public virtual {",
          "119:         uint256 amount = releasable(token);",
          "120:         _erc20Released[token] += amount;",
          "121:         emit ERC20Released(token, amount);",
          "122:         SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(token), beneficiary(), amount);",
          "123:     }",
          "128:     function vestedAmount(uint64 timestamp) public view virtual returns (uint256) {",
          "129:         return _vestingSchedule(address(this).balance + released(), timestamp);",
          "130:     }",
          "135:     function vestedAmount(address token, uint64 timestamp) public view virtual returns (uint256) {",
          "136:         return _vestingSchedule(IERC20Upgradeable(token).balanceOf(address(this)) + released(token), timestamp);",
          "137:     }",
          "143:     function _vestingSchedule(uint256 totalAllocation, uint64 timestamp) internal view virtual returns (uint256) {",
          "144:         if (timestamp < start()) {",
          "145:             return 0;",
          "146:         } else if (timestamp > start() + duration()) {",
          "147:             return totalAllocation;",
          "148:         } else {",
          "149:             return (totalAllocation * (timestamp - start())) / duration();",
          "150:         }",
          "151:     }",
          "158:     uint256[48] private __gap;",
          "159: }",
          "",
          "---------------"
        ],
        "contracts/governance/GovernorUpgradeable.sol||contracts/governance/GovernorUpgradeable.sol": [
          "File: contracts/governance/GovernorUpgradeable.sol -> contracts/governance/GovernorUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC721/IERC721ReceiverUpgradeable.sol\";",
          "7: import \"../token/ERC1155/IERC1155ReceiverUpgradeable.sol\";",
          "8: import \"../utils/cryptography/ECDSAUpgradeable.sol\";",
          "9: import \"../utils/cryptography/EIP712Upgradeable.sol\";",
          "10: import \"../utils/introspection/ERC165Upgradeable.sol\";",
          "11: import \"../utils/math/SafeCastUpgradeable.sol\";",
          "12: import \"../utils/structs/DoubleEndedQueueUpgradeable.sol\";",
          "13: import \"../utils/AddressUpgradeable.sol\";",
          "14: import \"../utils/ContextUpgradeable.sol\";",
          "15: import \"./IGovernorUpgradeable.sol\";",
          "16: import \"../proxy/utils/Initializable.sol\";",
          "29: abstract contract GovernorUpgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, EIP712Upgradeable, IGovernorUpgradeable, IERC721ReceiverUpgradeable, IERC1155ReceiverUpgradeable {",
          "30:     using DoubleEndedQueueUpgradeable for DoubleEndedQueueUpgradeable.Bytes32Deque;",
          "32:     bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");",
          "33:     bytes32 public constant EXTENDED_BALLOT_TYPEHASH =",
          "34:         keccak256(\"ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params)\");",
          "37:     struct ProposalCore {",
          "39:         uint64 voteStart;",
          "40:         address proposer;",
          "41:         bytes4 __gap_unused0;",
          "43:         uint64 voteEnd;",
          "44:         bytes24 __gap_unused1;",
          "46:         bool executed;",
          "47:         bool canceled;",
          "48:     }",
          "51:     string private _name;",
          "54:     mapping(uint256 => ProposalCore) private _proposals;",
          "60:     DoubleEndedQueueUpgradeable.Bytes32Deque private _governanceCall;",
          "72:     modifier onlyGovernance() {",
          "73:         require(_msgSender() == _executor(), \"Governor: onlyGovernance\");",
          "74:         if (_executor() != address(this)) {",
          "75:             bytes32 msgDataHash = keccak256(_msgData());",
          "77:             while (_governanceCall.popFront() != msgDataHash) {}",
          "78:         }",
          "79:         _;",
          "80:     }",
          "85:     function __Governor_init(string memory name_) internal onlyInitializing {",
          "86:         __EIP712_init_unchained(name_, version());",
          "87:         __Governor_init_unchained(name_);",
          "88:     }",
          "90:     function __Governor_init_unchained(string memory name_) internal onlyInitializing {",
          "91:         _name = name_;",
          "92:     }",
          "97:     receive() external payable virtual {",
          "98:         require(_executor() == address(this), \"Governor: must send to executor\");",
          "99:     }",
          "104:     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC165Upgradeable) returns (bool) {",
          "105:         bytes4 governorCancelId = this.cancel.selector ^ this.proposalProposer.selector;",
          "107:         bytes4 governorParamsId = this.castVoteWithReasonAndParams.selector ^",
          "108:             this.castVoteWithReasonAndParamsBySig.selector ^",
          "109:             this.getVotesWithParams.selector;",
          "112:         bytes4 governor43Id = type(IGovernorUpgradeable).interfaceId ^",
          "113:             type(IERC6372Upgradeable).interfaceId ^",
          "114:             governorCancelId ^",
          "115:             governorParamsId;",
          "118:         bytes4 governor46Id = type(IGovernorUpgradeable).interfaceId ^ type(IERC6372Upgradeable).interfaceId ^ governorCancelId;",
          "122:         return",
          "123:             interfaceId == governor43Id ||",
          "124:             interfaceId == governor46Id ||",
          "125:             interfaceId == governorCancelId ||",
          "126:             interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId ||",
          "127:             super.supportsInterface(interfaceId);",
          "128:     }",
          "133:     function name() public view virtual override returns (string memory) {",
          "134:         return _name;",
          "135:     }",
          "140:     function version() public view virtual override returns (string memory) {",
          "141:         return \"1\";",
          "142:     }",
          "157:     function hashProposal(",
          "158:         address[] memory targets,",
          "159:         uint256[] memory values,",
          "160:         bytes[] memory calldatas,",
          "161:         bytes32 descriptionHash",
          "162:     ) public pure virtual override returns (uint256) {",
          "163:         return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));",
          "164:     }",
          "169:     function state(uint256 proposalId) public view virtual override returns (ProposalState) {",
          "170:         ProposalCore storage proposal = _proposals[proposalId];",
          "172:         if (proposal.executed) {",
          "173:             return ProposalState.Executed;",
          "174:         }",
          "176:         if (proposal.canceled) {",
          "177:             return ProposalState.Canceled;",
          "178:         }",
          "180:         uint256 snapshot = proposalSnapshot(proposalId);",
          "182:         if (snapshot == 0) {",
          "183:             revert(\"Governor: unknown proposal id\");",
          "184:         }",
          "186:         uint256 currentTimepoint = clock();",
          "188:         if (snapshot >= currentTimepoint) {",
          "189:             return ProposalState.Pending;",
          "190:         }",
          "192:         uint256 deadline = proposalDeadline(proposalId);",
          "194:         if (deadline >= currentTimepoint) {",
          "195:             return ProposalState.Active;",
          "196:         }",
          "198:         if (_quorumReached(proposalId) && _voteSucceeded(proposalId)) {",
          "199:             return ProposalState.Succeeded;",
          "200:         } else {",
          "201:             return ProposalState.Defeated;",
          "202:         }",
          "203:     }",
          "208:     function proposalThreshold() public view virtual returns (uint256) {",
          "209:         return 0;",
          "210:     }",
          "215:     function proposalSnapshot(uint256 proposalId) public view virtual override returns (uint256) {",
          "216:         return _proposals[proposalId].voteStart;",
          "217:     }",
          "222:     function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {",
          "223:         return _proposals[proposalId].voteEnd;",
          "224:     }",
          "229:     function proposalProposer(uint256 proposalId) public view virtual override returns (address) {",
          "230:         return _proposals[proposalId].proposer;",
          "231:     }",
          "236:     function _quorumReached(uint256 proposalId) internal view virtual returns (bool);",
          "241:     function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);",
          "246:     function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);",
          "253:     function _countVote(",
          "254:         uint256 proposalId,",
          "255:         address account,",
          "256:         uint8 support,",
          "257:         uint256 weight,",
          "258:         bytes memory params",
          "259:     ) internal virtual;",
          "267:     function _defaultParams() internal view virtual returns (bytes memory) {",
          "268:         return \"\";",
          "269:     }",
          "274:     function propose(",
          "275:         address[] memory targets,",
          "276:         uint256[] memory values,",
          "277:         bytes[] memory calldatas,",
          "278:         string memory description",
          "279:     ) public virtual override returns (uint256) {",
          "280:         address proposer = _msgSender();",
          "281:         uint256 currentTimepoint = clock();",
          "283:         require(",
          "284:             getVotes(proposer, currentTimepoint - 1) >= proposalThreshold(),",
          "285:             \"Governor: proposer votes below proposal threshold\"",
          "286:         );",
          "288:         uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));",
          "290:         require(targets.length == values.length, \"Governor: invalid proposal length\");",
          "291:         require(targets.length == calldatas.length, \"Governor: invalid proposal length\");",
          "292:         require(targets.length > 0, \"Governor: empty proposal\");",
          "293:         require(_proposals[proposalId].voteStart == 0, \"Governor: proposal already exists\");",
          "295:         uint256 snapshot = currentTimepoint + votingDelay();",
          "296:         uint256 deadline = snapshot + votingPeriod();",
          "298:         _proposals[proposalId] = ProposalCore({",
          "299:             proposer: proposer,",
          "300:             voteStart: SafeCastUpgradeable.toUint64(snapshot),",
          "301:             voteEnd: SafeCastUpgradeable.toUint64(deadline),",
          "302:             executed: false,",
          "303:             canceled: false,",
          "304:             __gap_unused0: 0,",
          "305:             __gap_unused1: 0",
          "306:         });",
          "308:         emit ProposalCreated(",
          "309:             proposalId,",
          "310:             proposer,",
          "311:             targets,",
          "312:             values,",
          "313:             new string[](targets.length),",
          "314:             calldatas,",
          "315:             snapshot,",
          "316:             deadline,",
          "317:             description",
          "318:         );",
          "320:         return proposalId;",
          "321:     }",
          "326:     function execute(",
          "327:         address[] memory targets,",
          "328:         uint256[] memory values,",
          "329:         bytes[] memory calldatas,",
          "330:         bytes32 descriptionHash",
          "331:     ) public payable virtual override returns (uint256) {",
          "332:         uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);",
          "334:         ProposalState currentState = state(proposalId);",
          "335:         require(",
          "336:             currentState == ProposalState.Succeeded || currentState == ProposalState.Queued,",
          "337:             \"Governor: proposal not successful\"",
          "338:         );",
          "339:         _proposals[proposalId].executed = true;",
          "341:         emit ProposalExecuted(proposalId);",
          "343:         _beforeExecute(proposalId, targets, values, calldatas, descriptionHash);",
          "344:         _execute(proposalId, targets, values, calldatas, descriptionHash);",
          "345:         _afterExecute(proposalId, targets, values, calldatas, descriptionHash);",
          "347:         return proposalId;",
          "348:     }",
          "353:     function cancel(",
          "354:         address[] memory targets,",
          "355:         uint256[] memory values,",
          "356:         bytes[] memory calldatas,",
          "357:         bytes32 descriptionHash",
          "358:     ) public virtual override returns (uint256) {",
          "359:         uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);",
          "360:         require(state(proposalId) == ProposalState.Pending, \"Governor: too late to cancel\");",
          "361:         require(_msgSender() == _proposals[proposalId].proposer, \"Governor: only proposer can cancel\");",
          "362:         return _cancel(targets, values, calldatas, descriptionHash);",
          "363:     }",
          "368:     function _execute(",
          "369:         uint256 /* proposalId */,",
          "370:         address[] memory targets,",
          "371:         uint256[] memory values,",
          "372:         bytes[] memory calldatas,",
          "374:     ) internal virtual {",
          "375:         string memory errorMessage = \"Governor: call reverted without message\";",
          "376:         for (uint256 i = 0; i < targets.length; ++i) {",
          "377:             (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);",
          "378:             AddressUpgradeable.verifyCallResult(success, returndata, errorMessage);",
          "379:         }",
          "380:     }",
          "385:     function _beforeExecute(",
          "386:         uint256 /* proposalId */,",
          "387:         address[] memory targets,",
          "388:         uint256[] memory /* values */,",
          "389:         bytes[] memory calldatas,",
          "391:     ) internal virtual {",
          "392:         if (_executor() != address(this)) {",
          "393:             for (uint256 i = 0; i < targets.length; ++i) {",
          "394:                 if (targets[i] == address(this)) {",
          "395:                     _governanceCall.pushBack(keccak256(calldatas[i]));",
          "396:                 }",
          "397:             }",
          "398:         }",
          "399:     }",
          "404:     function _afterExecute(",
          "405:         uint256 /* proposalId */,",
          "406:         address[] memory /* targets */,",
          "407:         uint256[] memory /* values */,",
          "408:         bytes[] memory /* calldatas */,",
          "410:     ) internal virtual {",
          "411:         if (_executor() != address(this)) {",
          "412:             if (!_governanceCall.empty()) {",
          "413:                 _governanceCall.clear();",
          "414:             }",
          "415:         }",
          "416:     }",
          "424:     function _cancel(",
          "425:         address[] memory targets,",
          "426:         uint256[] memory values,",
          "427:         bytes[] memory calldatas,",
          "428:         bytes32 descriptionHash",
          "429:     ) internal virtual returns (uint256) {",
          "430:         uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);",
          "432:         ProposalState currentState = state(proposalId);",
          "434:         require(",
          "435:             currentState != ProposalState.Canceled &&",
          "436:                 currentState != ProposalState.Expired &&",
          "437:                 currentState != ProposalState.Executed,",
          "438:             \"Governor: proposal not active\"",
          "439:         );",
          "440:         _proposals[proposalId].canceled = true;",
          "442:         emit ProposalCanceled(proposalId);",
          "444:         return proposalId;",
          "445:     }",
          "450:     function getVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
          "451:         return _getVotes(account, timepoint, _defaultParams());",
          "452:     }",
          "457:     function getVotesWithParams(",
          "458:         address account,",
          "459:         uint256 timepoint,",
          "460:         bytes memory params",
          "461:     ) public view virtual override returns (uint256) {",
          "462:         return _getVotes(account, timepoint, params);",
          "463:     }",
          "468:     function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {",
          "469:         address voter = _msgSender();",
          "470:         return _castVote(proposalId, voter, support, \"\");",
          "471:     }",
          "476:     function castVoteWithReason(",
          "477:         uint256 proposalId,",
          "478:         uint8 support,",
          "479:         string calldata reason",
          "480:     ) public virtual override returns (uint256) {",
          "481:         address voter = _msgSender();",
          "482:         return _castVote(proposalId, voter, support, reason);",
          "483:     }",
          "488:     function castVoteWithReasonAndParams(",
          "489:         uint256 proposalId,",
          "490:         uint8 support,",
          "491:         string calldata reason,",
          "492:         bytes memory params",
          "493:     ) public virtual override returns (uint256) {",
          "494:         address voter = _msgSender();",
          "495:         return _castVote(proposalId, voter, support, reason, params);",
          "496:     }",
          "501:     function castVoteBySig(",
          "502:         uint256 proposalId,",
          "503:         uint8 support,",
          "504:         uint8 v,",
          "505:         bytes32 r,",
          "506:         bytes32 s",
          "507:     ) public virtual override returns (uint256) {",
          "508:         address voter = ECDSAUpgradeable.recover(",
          "509:             _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),",
          "510:             v,",
          "511:             r,",
          "512:             s",
          "513:         );",
          "514:         return _castVote(proposalId, voter, support, \"\");",
          "515:     }",
          "520:     function castVoteWithReasonAndParamsBySig(",
          "521:         uint256 proposalId,",
          "522:         uint8 support,",
          "523:         string calldata reason,",
          "524:         bytes memory params,",
          "525:         uint8 v,",
          "526:         bytes32 r,",
          "527:         bytes32 s",
          "528:     ) public virtual override returns (uint256) {",
          "529:         address voter = ECDSAUpgradeable.recover(",
          "530:             _hashTypedDataV4(",
          "531:                 keccak256(",
          "532:                     abi.encode(",
          "533:                         EXTENDED_BALLOT_TYPEHASH,",
          "534:                         proposalId,",
          "535:                         support,",
          "536:                         keccak256(bytes(reason)),",
          "537:                         keccak256(params)",
          "538:                     )",
          "539:                 )",
          "540:             ),",
          "541:             v,",
          "542:             r,",
          "543:             s",
          "544:         );",
          "546:         return _castVote(proposalId, voter, support, reason, params);",
          "547:     }",
          "555:     function _castVote(",
          "556:         uint256 proposalId,",
          "557:         address account,",
          "558:         uint8 support,",
          "559:         string memory reason",
          "560:     ) internal virtual returns (uint256) {",
          "561:         return _castVote(proposalId, account, support, reason, _defaultParams());",
          "562:     }",
          "570:     function _castVote(",
          "571:         uint256 proposalId,",
          "572:         address account,",
          "573:         uint8 support,",
          "574:         string memory reason,",
          "575:         bytes memory params",
          "576:     ) internal virtual returns (uint256) {",
          "577:         ProposalCore storage proposal = _proposals[proposalId];",
          "578:         require(state(proposalId) == ProposalState.Active, \"Governor: vote not currently active\");",
          "580:         uint256 weight = _getVotes(account, proposal.voteStart, params);",
          "581:         _countVote(proposalId, account, support, weight, params);",
          "583:         if (params.length == 0) {",
          "584:             emit VoteCast(account, proposalId, support, weight, reason);",
          "585:         } else {",
          "586:             emit VoteCastWithParams(account, proposalId, support, weight, reason, params);",
          "587:         }",
          "589:         return weight;",
          "590:     }",
          "598:     function relay(address target, uint256 value, bytes calldata data) external payable virtual onlyGovernance {",
          "599:         (bool success, bytes memory returndata) = target.call{value: value}(data);",
          "600:         AddressUpgradeable.verifyCallResult(success, returndata, \"Governor: relay reverted without message\");",
          "601:     }",
          "607:     function _executor() internal view virtual returns (address) {",
          "608:         return address(this);",
          "609:     }",
          "614:     function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {",
          "615:         return this.onERC721Received.selector;",
          "616:     }",
          "621:     function onERC1155Received(",
          "622:         address,",
          "623:         address,",
          "624:         uint256,",
          "625:         uint256,",
          "626:         bytes memory",
          "627:     ) public virtual override returns (bytes4) {",
          "628:         return this.onERC1155Received.selector;",
          "629:     }",
          "634:     function onERC1155BatchReceived(",
          "635:         address,",
          "636:         address,",
          "637:         uint256[] memory,",
          "638:         uint256[] memory,",
          "639:         bytes memory",
          "640:     ) public virtual override returns (bytes4) {",
          "641:         return this.onERC1155BatchReceived.selector;",
          "642:     }",
          "649:     uint256[46] private __gap;",
          "650: }",
          "",
          "---------------"
        ],
        "contracts/governance/IGovernorUpgradeable.sol||contracts/governance/IGovernorUpgradeable.sol": [
          "File: contracts/governance/IGovernorUpgradeable.sol -> contracts/governance/IGovernorUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../interfaces/IERC165Upgradeable.sol\";",
          "7: import \"../interfaces/IERC6372Upgradeable.sol\";",
          "8: import \"../proxy/utils/Initializable.sol\";",
          "15: abstract contract IGovernorUpgradeable is Initializable, IERC165Upgradeable, IERC6372Upgradeable {",
          "16:     function __IGovernor_init() internal onlyInitializing {",
          "17:     }",
          "19:     function __IGovernor_init_unchained() internal onlyInitializing {",
          "20:     }",
          "21:     enum ProposalState {",
          "22:         Pending,",
          "23:         Active,",
          "24:         Canceled,",
          "25:         Defeated,",
          "26:         Succeeded,",
          "27:         Queued,",
          "28:         Expired,",
          "29:         Executed",
          "30:     }",
          "35:     event ProposalCreated(",
          "36:         uint256 proposalId,",
          "37:         address proposer,",
          "38:         address[] targets,",
          "39:         uint256[] values,",
          "40:         string[] signatures,",
          "41:         bytes[] calldatas,",
          "42:         uint256 voteStart,",
          "43:         uint256 voteEnd,",
          "44:         string description",
          "45:     );",
          "50:     event ProposalCanceled(uint256 proposalId);",
          "55:     event ProposalExecuted(uint256 proposalId);",
          "62:     event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);",
          "70:     event VoteCastWithParams(",
          "71:         address indexed voter,",
          "72:         uint256 proposalId,",
          "73:         uint8 support,",
          "74:         uint256 weight,",
          "75:         string reason,",
          "76:         bytes params",
          "77:     );",
          "83:     function name() public view virtual returns (string memory);",
          "89:     function version() public view virtual returns (string memory);",
          "95:     function clock() public view virtual override returns (uint48);",
          "102:     function CLOCK_MODE() public view virtual override returns (string memory);",
          "127:     function COUNTING_MODE() public view virtual returns (string memory);",
          "133:     function hashProposal(",
          "134:         address[] memory targets,",
          "135:         uint256[] memory values,",
          "136:         bytes[] memory calldatas,",
          "137:         bytes32 descriptionHash",
          "138:     ) public pure virtual returns (uint256);",
          "144:     function state(uint256 proposalId) public view virtual returns (ProposalState);",
          "152:     function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256);",
          "159:     function proposalDeadline(uint256 proposalId) public view virtual returns (uint256);",
          "165:     function proposalProposer(uint256 proposalId) public view virtual returns (address);",
          "175:     function votingDelay() public view virtual returns (uint256);",
          "185:     function votingPeriod() public view virtual returns (uint256);",
          "194:     function quorum(uint256 timepoint) public view virtual returns (uint256);",
          "203:     function getVotes(address account, uint256 timepoint) public view virtual returns (uint256);",
          "209:     function getVotesWithParams(",
          "210:         address account,",
          "211:         uint256 timepoint,",
          "212:         bytes memory params",
          "213:     ) public view virtual returns (uint256);",
          "219:     function hasVoted(uint256 proposalId, address account) public view virtual returns (bool);",
          "227:     function propose(",
          "228:         address[] memory targets,",
          "229:         uint256[] memory values,",
          "230:         bytes[] memory calldatas,",
          "231:         string memory description",
          "232:     ) public virtual returns (uint256 proposalId);",
          "242:     function execute(",
          "243:         address[] memory targets,",
          "244:         uint256[] memory values,",
          "245:         bytes[] memory calldatas,",
          "246:         bytes32 descriptionHash",
          "247:     ) public payable virtual returns (uint256 proposalId);",
          "255:     function cancel(",
          "256:         address[] memory targets,",
          "257:         uint256[] memory values,",
          "258:         bytes[] memory calldatas,",
          "259:         bytes32 descriptionHash",
          "260:     ) public virtual returns (uint256 proposalId);",
          "267:     function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256 balance);",
          "274:     function castVoteWithReason(",
          "275:         uint256 proposalId,",
          "276:         uint8 support,",
          "277:         string calldata reason",
          "278:     ) public virtual returns (uint256 balance);",
          "285:     function castVoteWithReasonAndParams(",
          "286:         uint256 proposalId,",
          "287:         uint8 support,",
          "288:         string calldata reason,",
          "289:         bytes memory params",
          "290:     ) public virtual returns (uint256 balance);",
          "297:     function castVoteBySig(",
          "298:         uint256 proposalId,",
          "299:         uint8 support,",
          "300:         uint8 v,",
          "301:         bytes32 r,",
          "302:         bytes32 s",
          "303:     ) public virtual returns (uint256 balance);",
          "310:     function castVoteWithReasonAndParamsBySig(",
          "311:         uint256 proposalId,",
          "312:         uint8 support,",
          "313:         string calldata reason,",
          "314:         bytes memory params,",
          "315:         uint8 v,",
          "316:         bytes32 r,",
          "317:         bytes32 s",
          "318:     ) public virtual returns (uint256 balance);",
          "325:     uint256[50] private __gap;",
          "326: }",
          "",
          "---------------"
        ],
        "contracts/governance/TimelockControllerUpgradeable.sol||contracts/governance/TimelockControllerUpgradeable.sol": [
          "File: contracts/governance/TimelockControllerUpgradeable.sol -> contracts/governance/TimelockControllerUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../access/AccessControlUpgradeable.sol\";",
          "7: import \"../token/ERC721/IERC721ReceiverUpgradeable.sol\";",
          "8: import \"../token/ERC1155/IERC1155ReceiverUpgradeable.sol\";",
          "9: import \"../proxy/utils/Initializable.sol\";",
          "26: contract TimelockControllerUpgradeable is Initializable, AccessControlUpgradeable, IERC721ReceiverUpgradeable, IERC1155ReceiverUpgradeable {",
          "27:     bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");",
          "28:     bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");",
          "29:     bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");",
          "30:     bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");",
          "31:     uint256 internal constant _DONE_TIMESTAMP = uint256(1);",
          "33:     mapping(bytes32 => uint256) private _timestamps;",
          "34:     uint256 private _minDelay;",
          "39:     event CallScheduled(",
          "40:         bytes32 indexed id,",
          "41:         uint256 indexed index,",
          "42:         address target,",
          "43:         uint256 value,",
          "44:         bytes data,",
          "45:         bytes32 predecessor,",
          "46:         uint256 delay",
          "47:     );",
          "52:     event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);",
          "57:     event CallSalt(bytes32 indexed id, bytes32 salt);",
          "62:     event Cancelled(bytes32 indexed id);",
          "67:     event MinDelayChange(uint256 oldDuration, uint256 newDuration);",
          "82:     function __TimelockController_init(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {",
          "83:         __TimelockController_init_unchained(minDelay, proposers, executors, admin);",
          "84:     }",
          "86:     function __TimelockController_init_unchained(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) internal onlyInitializing {",
          "87:         _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);",
          "88:         _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);",
          "89:         _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);",
          "90:         _setRoleAdmin(CANCELLER_ROLE, TIMELOCK_ADMIN_ROLE);",
          "93:         _setupRole(TIMELOCK_ADMIN_ROLE, address(this));",
          "96:         if (admin != address(0)) {",
          "97:             _setupRole(TIMELOCK_ADMIN_ROLE, admin);",
          "98:         }",
          "101:         for (uint256 i = 0; i < proposers.length; ++i) {",
          "102:             _setupRole(PROPOSER_ROLE, proposers[i]);",
          "103:             _setupRole(CANCELLER_ROLE, proposers[i]);",
          "104:         }",
          "107:         for (uint256 i = 0; i < executors.length; ++i) {",
          "108:             _setupRole(EXECUTOR_ROLE, executors[i]);",
          "109:         }",
          "111:         _minDelay = minDelay;",
          "112:         emit MinDelayChange(0, minDelay);",
          "113:     }",
          "121:     modifier onlyRoleOrOpenRole(bytes32 role) {",
          "122:         if (!hasRole(role, address(0))) {",
          "123:             _checkRole(role, _msgSender());",
          "124:         }",
          "125:         _;",
          "126:     }",
          "131:     receive() external payable {}",
          "136:     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, AccessControlUpgradeable) returns (bool) {",
          "137:         return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);",
          "138:     }",
          "144:     function isOperation(bytes32 id) public view virtual returns (bool) {",
          "145:         return getTimestamp(id) > 0;",
          "146:     }",
          "151:     function isOperationPending(bytes32 id) public view virtual returns (bool) {",
          "152:         return getTimestamp(id) > _DONE_TIMESTAMP;",
          "153:     }",
          "158:     function isOperationReady(bytes32 id) public view virtual returns (bool) {",
          "159:         uint256 timestamp = getTimestamp(id);",
          "160:         return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;",
          "161:     }",
          "166:     function isOperationDone(bytes32 id) public view virtual returns (bool) {",
          "167:         return getTimestamp(id) == _DONE_TIMESTAMP;",
          "168:     }",
          "174:     function getTimestamp(bytes32 id) public view virtual returns (uint256) {",
          "175:         return _timestamps[id];",
          "176:     }",
          "183:     function getMinDelay() public view virtual returns (uint256) {",
          "184:         return _minDelay;",
          "185:     }",
          "191:     function hashOperation(",
          "192:         address target,",
          "193:         uint256 value,",
          "194:         bytes calldata data,",
          "195:         bytes32 predecessor,",
          "196:         bytes32 salt",
          "197:     ) public pure virtual returns (bytes32) {",
          "198:         return keccak256(abi.encode(target, value, data, predecessor, salt));",
          "199:     }",
          "205:     function hashOperationBatch(",
          "206:         address[] calldata targets,",
          "207:         uint256[] calldata values,",
          "208:         bytes[] calldata payloads,",
          "209:         bytes32 predecessor,",
          "210:         bytes32 salt",
          "211:     ) public pure virtual returns (bytes32) {",
          "212:         return keccak256(abi.encode(targets, values, payloads, predecessor, salt));",
          "213:     }",
          "224:     function schedule(",
          "225:         address target,",
          "226:         uint256 value,",
          "227:         bytes calldata data,",
          "228:         bytes32 predecessor,",
          "229:         bytes32 salt,",
          "230:         uint256 delay",
          "231:     ) public virtual onlyRole(PROPOSER_ROLE) {",
          "232:         bytes32 id = hashOperation(target, value, data, predecessor, salt);",
          "233:         _schedule(id, delay);",
          "234:         emit CallScheduled(id, 0, target, value, data, predecessor, delay);",
          "235:         if (salt != bytes32(0)) {",
          "236:             emit CallSalt(id, salt);",
          "237:         }",
          "238:     }",
          "249:     function scheduleBatch(",
          "250:         address[] calldata targets,",
          "251:         uint256[] calldata values,",
          "252:         bytes[] calldata payloads,",
          "253:         bytes32 predecessor,",
          "254:         bytes32 salt,",
          "255:         uint256 delay",
          "256:     ) public virtual onlyRole(PROPOSER_ROLE) {",
          "257:         require(targets.length == values.length, \"TimelockController: length mismatch\");",
          "258:         require(targets.length == payloads.length, \"TimelockController: length mismatch\");",
          "260:         bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);",
          "261:         _schedule(id, delay);",
          "262:         for (uint256 i = 0; i < targets.length; ++i) {",
          "263:             emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);",
          "264:         }",
          "265:         if (salt != bytes32(0)) {",
          "266:             emit CallSalt(id, salt);",
          "267:         }",
          "268:     }",
          "273:     function _schedule(bytes32 id, uint256 delay) private {",
          "274:         require(!isOperation(id), \"TimelockController: operation already scheduled\");",
          "275:         require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");",
          "276:         _timestamps[id] = block.timestamp + delay;",
          "277:     }",
          "286:     function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {",
          "287:         require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");",
          "288:         delete _timestamps[id];",
          "290:         emit Cancelled(id);",
          "291:     }",
          "305:     function execute(",
          "306:         address target,",
          "307:         uint256 value,",
          "308:         bytes calldata payload,",
          "309:         bytes32 predecessor,",
          "310:         bytes32 salt",
          "311:     ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {",
          "312:         bytes32 id = hashOperation(target, value, payload, predecessor, salt);",
          "314:         _beforeCall(id, predecessor);",
          "315:         _execute(target, value, payload);",
          "316:         emit CallExecuted(id, 0, target, value, payload);",
          "317:         _afterCall(id);",
          "318:     }",
          "332:     function executeBatch(",
          "333:         address[] calldata targets,",
          "334:         uint256[] calldata values,",
          "335:         bytes[] calldata payloads,",
          "336:         bytes32 predecessor,",
          "337:         bytes32 salt",
          "338:     ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {",
          "339:         require(targets.length == values.length, \"TimelockController: length mismatch\");",
          "340:         require(targets.length == payloads.length, \"TimelockController: length mismatch\");",
          "342:         bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);",
          "344:         _beforeCall(id, predecessor);",
          "345:         for (uint256 i = 0; i < targets.length; ++i) {",
          "346:             address target = targets[i];",
          "347:             uint256 value = values[i];",
          "348:             bytes calldata payload = payloads[i];",
          "349:             _execute(target, value, payload);",
          "350:             emit CallExecuted(id, i, target, value, payload);",
          "351:         }",
          "352:         _afterCall(id);",
          "353:     }",
          "358:     function _execute(address target, uint256 value, bytes calldata data) internal virtual {",
          "359:         (bool success, ) = target.call{value: value}(data);",
          "360:         require(success, \"TimelockController: underlying transaction reverted\");",
          "361:     }",
          "366:     function _beforeCall(bytes32 id, bytes32 predecessor) private view {",
          "367:         require(isOperationReady(id), \"TimelockController: operation is not ready\");",
          "368:         require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");",
          "369:     }",
          "374:     function _afterCall(bytes32 id) private {",
          "375:         require(isOperationReady(id), \"TimelockController: operation is not ready\");",
          "376:         _timestamps[id] = _DONE_TIMESTAMP;",
          "377:     }",
          "389:     function updateDelay(uint256 newDelay) external virtual {",
          "390:         require(msg.sender == address(this), \"TimelockController: caller must be timelock\");",
          "391:         emit MinDelayChange(_minDelay, newDelay);",
          "392:         _minDelay = newDelay;",
          "393:     }",
          "398:     function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {",
          "399:         return this.onERC721Received.selector;",
          "400:     }",
          "405:     function onERC1155Received(",
          "406:         address,",
          "407:         address,",
          "408:         uint256,",
          "409:         uint256,",
          "410:         bytes memory",
          "411:     ) public virtual override returns (bytes4) {",
          "412:         return this.onERC1155Received.selector;",
          "413:     }",
          "418:     function onERC1155BatchReceived(",
          "419:         address,",
          "420:         address,",
          "421:         uint256[] memory,",
          "422:         uint256[] memory,",
          "423:         bytes memory",
          "424:     ) public virtual override returns (bytes4) {",
          "425:         return this.onERC1155BatchReceived.selector;",
          "426:     }",
          "433:     uint256[48] private __gap;",
          "434: }",
          "",
          "---------------"
        ],
        "contracts/governance/TimelockControllerWith46MigrationUpgradeable.sol||contracts/governance/TimelockControllerWith46MigrationUpgradeable.sol": [
          "File: contracts/governance/TimelockControllerWith46MigrationUpgradeable.sol -> contracts/governance/TimelockControllerWith46MigrationUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./TimelockControllerUpgradeable.sol\";",
          "7: import \"../proxy/utils/Initializable.sol\";",
          "20: contract TimelockControllerWith46MigrationUpgradeable is Initializable, TimelockControllerUpgradeable {",
          "21:     function __TimelockControllerWith46Migration_init(",
          "22:         uint256 minDelay,",
          "23:         address[] memory proposers,",
          "24:         address[] memory executors,",
          "25:         address admin",
          "26:     ) internal onlyInitializing {",
          "27:         __TimelockController_init_unchained(minDelay, proposers, executors, admin);",
          "28:     }",
          "30:     function __TimelockControllerWith46Migration_init_unchained(",
          "31:         uint256,",
          "32:         address[] memory,",
          "33:         address[] memory,",
          "34:         address",
          "35:     ) internal onlyInitializing {}",
          "42:     function migrateTo46() public virtual {",
          "43:         require(",
          "44:             getRoleAdmin(PROPOSER_ROLE) == TIMELOCK_ADMIN_ROLE && getRoleAdmin(CANCELLER_ROLE) == DEFAULT_ADMIN_ROLE,",
          "45:             \"TimelockController: already migrated\"",
          "46:         );",
          "47:         _setRoleAdmin(CANCELLER_ROLE, TIMELOCK_ADMIN_ROLE);",
          "48:     }",
          "55:     uint256[50] private __gap;",
          "56: }",
          "",
          "---------------"
        ],
        "contracts/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol||contracts/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol": [
          "File: contracts/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol -> contracts/governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../../utils/math/SafeCastUpgradeable.sol\";",
          "7: import \"../extensions/IGovernorTimelockUpgradeable.sol\";",
          "8: import \"../GovernorUpgradeable.sol\";",
          "9: import \"./IGovernorCompatibilityBravoUpgradeable.sol\";",
          "10: import \"../../proxy/utils/Initializable.sol\";",
          "22: abstract contract GovernorCompatibilityBravoUpgradeable is Initializable, IGovernorTimelockUpgradeable, IGovernorCompatibilityBravoUpgradeable, GovernorUpgradeable {",
          "23:     function __GovernorCompatibilityBravo_init() internal onlyInitializing {",
          "24:     }",
          "26:     function __GovernorCompatibilityBravo_init_unchained() internal onlyInitializing {",
          "27:     }",
          "28:     enum VoteType {",
          "29:         Against,",
          "30:         For,",
          "31:         Abstain",
          "32:     }",
          "34:     struct ProposalDetails {",
          "35:         address proposer;",
          "36:         address[] targets;",
          "37:         uint256[] values;",
          "38:         string[] signatures;",
          "39:         bytes[] calldatas;",
          "40:         uint256 forVotes;",
          "41:         uint256 againstVotes;",
          "42:         uint256 abstainVotes;",
          "43:         mapping(address => Receipt) receipts;",
          "44:         bytes32 descriptionHash;",
          "45:     }",
          "47:     mapping(uint256 => ProposalDetails) private _proposalDetails;",
          "50:     function COUNTING_MODE() public pure virtual override returns (string memory) {",
          "51:         return \"support=bravo&quorum=bravo\";",
          "52:     }",
          "58:     function propose(",
          "59:         address[] memory targets,",
          "60:         uint256[] memory values,",
          "61:         bytes[] memory calldatas,",
          "62:         string memory description",
          "63:     ) public virtual override(IGovernorUpgradeable, GovernorUpgradeable) returns (uint256) {",
          "65:         _storeProposal(_msgSender(), targets, values, new string[](calldatas.length), calldatas, description);",
          "66:         return super.propose(targets, values, calldatas, description);",
          "67:     }",
          "72:     function propose(",
          "73:         address[] memory targets,",
          "74:         uint256[] memory values,",
          "75:         string[] memory signatures,",
          "76:         bytes[] memory calldatas,",
          "77:         string memory description",
          "78:     ) public virtual override returns (uint256) {",
          "79:         require(signatures.length == calldatas.length, \"GovernorBravo: invalid signatures length\");",
          "84:         _storeProposal(_msgSender(), targets, values, signatures, calldatas, description);",
          "85:         return propose(targets, values, _encodeCalldata(signatures, calldatas), description);",
          "86:     }",
          "91:     function queue(uint256 proposalId) public virtual override {",
          "92:         (",
          "93:             address[] memory targets,",
          "94:             uint256[] memory values,",
          "95:             bytes[] memory calldatas,",
          "96:             bytes32 descriptionHash",
          "97:         ) = _getProposalParameters(proposalId);",
          "99:         queue(targets, values, calldatas, descriptionHash);",
          "100:     }",
          "105:     function execute(uint256 proposalId) public payable virtual override {",
          "106:         (",
          "107:             address[] memory targets,",
          "108:             uint256[] memory values,",
          "109:             bytes[] memory calldatas,",
          "110:             bytes32 descriptionHash",
          "111:         ) = _getProposalParameters(proposalId);",
          "113:         execute(targets, values, calldatas, descriptionHash);",
          "114:     }",
          "119:     function cancel(uint256 proposalId) public virtual override {",
          "120:         (",
          "121:             address[] memory targets,",
          "122:             uint256[] memory values,",
          "123:             bytes[] memory calldatas,",
          "124:             bytes32 descriptionHash",
          "125:         ) = _getProposalParameters(proposalId);",
          "127:         cancel(targets, values, calldatas, descriptionHash);",
          "128:     }",
          "134:     function cancel(",
          "135:         address[] memory targets,",
          "136:         uint256[] memory values,",
          "137:         bytes[] memory calldatas,",
          "138:         bytes32 descriptionHash",
          "139:     ) public virtual override(IGovernorUpgradeable, GovernorUpgradeable) returns (uint256) {",
          "140:         uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);",
          "141:         address proposer = _proposalDetails[proposalId].proposer;",
          "143:         require(",
          "144:             _msgSender() == proposer || getVotes(proposer, clock() - 1) < proposalThreshold(),",
          "145:             \"GovernorBravo: proposer above threshold\"",
          "146:         );",
          "148:         return _cancel(targets, values, calldatas, descriptionHash);",
          "149:     }",
          "154:     function _encodeCalldata(",
          "155:         string[] memory signatures,",
          "156:         bytes[] memory calldatas",
          "157:     ) private pure returns (bytes[] memory) {",
          "158:         bytes[] memory fullcalldatas = new bytes[](calldatas.length);",
          "159:         for (uint256 i = 0; i < fullcalldatas.length; ++i) {",
          "160:             fullcalldatas[i] = bytes(signatures[i]).length == 0",
          "161:                 ? calldatas[i]",
          "162:                 : abi.encodePacked(bytes4(keccak256(bytes(signatures[i]))), calldatas[i]);",
          "163:         }",
          "165:         return fullcalldatas;",
          "166:     }",
          "171:     function _getProposalParameters(",
          "172:         uint256 proposalId",
          "173:     )",
          "174:         private",
          "175:         view",
          "176:         returns (address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)",
          "177:     {",
          "178:         ProposalDetails storage details = _proposalDetails[proposalId];",
          "179:         return (",
          "180:             details.targets,",
          "181:             details.values,",
          "182:             _encodeCalldata(details.signatures, details.calldatas),",
          "183:             details.descriptionHash",
          "184:         );",
          "185:     }",
          "190:     function _storeProposal(",
          "191:         address proposer,",
          "192:         address[] memory targets,",
          "193:         uint256[] memory values,",
          "194:         string[] memory signatures,",
          "195:         bytes[] memory calldatas,",
          "196:         string memory description",
          "197:     ) private {",
          "198:         bytes32 descriptionHash = keccak256(bytes(description));",
          "199:         uint256 proposalId = hashProposal(targets, values, _encodeCalldata(signatures, calldatas), descriptionHash);",
          "201:         ProposalDetails storage details = _proposalDetails[proposalId];",
          "202:         if (details.descriptionHash == bytes32(0)) {",
          "203:             details.proposer = proposer;",
          "204:             details.targets = targets;",
          "205:             details.values = values;",
          "206:             details.signatures = signatures;",
          "207:             details.calldatas = calldatas;",
          "208:             details.descriptionHash = descriptionHash;",
          "209:         }",
          "210:     }",
          "216:     function proposals(",
          "217:         uint256 proposalId",
          "218:     )",
          "219:         public",
          "220:         view",
          "221:         virtual",
          "222:         override",
          "223:         returns (",
          "224:             uint256 id,",
          "225:             address proposer,",
          "226:             uint256 eta,",
          "227:             uint256 startBlock,",
          "228:             uint256 endBlock,",
          "229:             uint256 forVotes,",
          "230:             uint256 againstVotes,",
          "231:             uint256 abstainVotes,",
          "232:             bool canceled,",
          "233:             bool executed",
          "234:         )",
          "235:     {",
          "236:         id = proposalId;",
          "237:         eta = proposalEta(proposalId);",
          "238:         startBlock = proposalSnapshot(proposalId);",
          "239:         endBlock = proposalDeadline(proposalId);",
          "241:         ProposalDetails storage details = _proposalDetails[proposalId];",
          "242:         proposer = details.proposer;",
          "243:         forVotes = details.forVotes;",
          "244:         againstVotes = details.againstVotes;",
          "245:         abstainVotes = details.abstainVotes;",
          "247:         ProposalState currentState = state(proposalId);",
          "248:         canceled = currentState == ProposalState.Canceled;",
          "249:         executed = currentState == ProposalState.Executed;",
          "250:     }",
          "255:     function getActions(",
          "256:         uint256 proposalId",
          "257:     )",
          "258:         public",
          "259:         view",
          "260:         virtual",
          "261:         override",
          "262:         returns (",
          "263:             address[] memory targets,",
          "264:             uint256[] memory values,",
          "265:             string[] memory signatures,",
          "266:             bytes[] memory calldatas",
          "267:         )",
          "268:     {",
          "269:         ProposalDetails storage details = _proposalDetails[proposalId];",
          "270:         return (details.targets, details.values, details.signatures, details.calldatas);",
          "271:     }",
          "276:     function getReceipt(uint256 proposalId, address voter) public view virtual override returns (Receipt memory) {",
          "277:         return _proposalDetails[proposalId].receipts[voter];",
          "278:     }",
          "283:     function quorumVotes() public view virtual override returns (uint256) {",
          "284:         return quorum(clock() - 1);",
          "285:     }",
          "291:     function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {",
          "292:         return _proposalDetails[proposalId].receipts[account].hasVoted;",
          "293:     }",
          "298:     function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {",
          "299:         ProposalDetails storage details = _proposalDetails[proposalId];",
          "300:         return quorum(proposalSnapshot(proposalId)) <= details.forVotes;",
          "301:     }",
          "306:     function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {",
          "307:         ProposalDetails storage details = _proposalDetails[proposalId];",
          "308:         return details.forVotes > details.againstVotes;",
          "309:     }",
          "314:     function _countVote(",
          "315:         uint256 proposalId,",
          "316:         address account,",
          "317:         uint8 support,",
          "318:         uint256 weight,",
          "319:         bytes memory // params",
          "320:     ) internal virtual override {",
          "321:         ProposalDetails storage details = _proposalDetails[proposalId];",
          "322:         Receipt storage receipt = details.receipts[account];",
          "324:         require(!receipt.hasVoted, \"GovernorCompatibilityBravo: vote already cast\");",
          "325:         receipt.hasVoted = true;",
          "326:         receipt.support = support;",
          "327:         receipt.votes = SafeCastUpgradeable.toUint96(weight);",
          "329:         if (support == uint8(VoteType.Against)) {",
          "330:             details.againstVotes += weight;",
          "331:         } else if (support == uint8(VoteType.For)) {",
          "332:             details.forVotes += weight;",
          "333:         } else if (support == uint8(VoteType.Abstain)) {",
          "334:             details.abstainVotes += weight;",
          "335:         } else {",
          "336:             revert(\"GovernorCompatibilityBravo: invalid vote type\");",
          "337:         }",
          "338:     }",
          "345:     uint256[49] private __gap;",
          "346: }",
          "",
          "---------------"
        ],
        "contracts/governance/compatibility/IGovernorCompatibilityBravoUpgradeable.sol||contracts/governance/compatibility/IGovernorCompatibilityBravoUpgradeable.sol": [
          "File: contracts/governance/compatibility/IGovernorCompatibilityBravoUpgradeable.sol -> contracts/governance/compatibility/IGovernorCompatibilityBravoUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../IGovernorUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "14: abstract contract IGovernorCompatibilityBravoUpgradeable is Initializable, IGovernorUpgradeable {",
          "15:     function __IGovernorCompatibilityBravo_init() internal onlyInitializing {",
          "16:     }",
          "18:     function __IGovernorCompatibilityBravo_init_unchained() internal onlyInitializing {",
          "19:     }",
          "24:     struct Proposal {",
          "25:         uint256 id;",
          "26:         address proposer;",
          "27:         uint256 eta;",
          "28:         address[] targets;",
          "29:         uint256[] values;",
          "30:         string[] signatures;",
          "31:         bytes[] calldatas;",
          "32:         uint256 startBlock;",
          "33:         uint256 endBlock;",
          "34:         uint256 forVotes;",
          "35:         uint256 againstVotes;",
          "36:         uint256 abstainVotes;",
          "37:         bool canceled;",
          "38:         bool executed;",
          "39:         mapping(address => Receipt) receipts;",
          "40:     }",
          "45:     struct Receipt {",
          "46:         bool hasVoted;",
          "47:         uint8 support;",
          "48:         uint96 votes;",
          "49:     }",
          "54:     function quorumVotes() public view virtual returns (uint256);",
          "59:     function proposals(",
          "60:         uint256",
          "61:     )",
          "62:         public",
          "63:         view",
          "64:         virtual",
          "65:         returns (",
          "66:             uint256 id,",
          "67:             address proposer,",
          "68:             uint256 eta,",
          "69:             uint256 startBlock,",
          "70:             uint256 endBlock,",
          "71:             uint256 forVotes,",
          "72:             uint256 againstVotes,",
          "73:             uint256 abstainVotes,",
          "74:             bool canceled,",
          "75:             bool executed",
          "76:         );",
          "81:     function propose(",
          "82:         address[] memory targets,",
          "83:         uint256[] memory values,",
          "84:         string[] memory signatures,",
          "85:         bytes[] memory calldatas,",
          "86:         string memory description",
          "87:     ) public virtual returns (uint256);",
          "92:     function queue(uint256 proposalId) public virtual;",
          "97:     function execute(uint256 proposalId) public payable virtual;",
          "102:     function cancel(uint256 proposalId) public virtual;",
          "107:     function getActions(",
          "108:         uint256 proposalId",
          "109:     )",
          "110:         public",
          "111:         view",
          "112:         virtual",
          "113:         returns (",
          "114:             address[] memory targets,",
          "115:             uint256[] memory values,",
          "116:             string[] memory signatures,",
          "117:             bytes[] memory calldatas",
          "118:         );",
          "123:     function getReceipt(uint256 proposalId, address voter) public view virtual returns (Receipt memory);",
          "130:     uint256[50] private __gap;",
          "131: }",
          "",
          "---------------"
        ],
        "contracts/governance/extensions/GovernorCountingSimpleUpgradeable.sol||contracts/governance/extensions/GovernorCountingSimpleUpgradeable.sol": [
          "File: contracts/governance/extensions/GovernorCountingSimpleUpgradeable.sol -> contracts/governance/extensions/GovernorCountingSimpleUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../GovernorUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "14: abstract contract GovernorCountingSimpleUpgradeable is Initializable, GovernorUpgradeable {",
          "15:     function __GovernorCountingSimple_init() internal onlyInitializing {",
          "16:     }",
          "18:     function __GovernorCountingSimple_init_unchained() internal onlyInitializing {",
          "19:     }",
          "23:     enum VoteType {",
          "24:         Against,",
          "25:         For,",
          "26:         Abstain",
          "27:     }",
          "29:     struct ProposalVote {",
          "30:         uint256 againstVotes;",
          "31:         uint256 forVotes;",
          "32:         uint256 abstainVotes;",
          "33:         mapping(address => bool) hasVoted;",
          "34:     }",
          "36:     mapping(uint256 => ProposalVote) private _proposalVotes;",
          "42:     function COUNTING_MODE() public pure virtual override returns (string memory) {",
          "43:         return \"support=bravo&quorum=for,abstain\";",
          "44:     }",
          "49:     function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {",
          "50:         return _proposalVotes[proposalId].hasVoted[account];",
          "51:     }",
          "56:     function proposalVotes(",
          "57:         uint256 proposalId",
          "58:     ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) {",
          "59:         ProposalVote storage proposalVote = _proposalVotes[proposalId];",
          "60:         return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes);",
          "61:     }",
          "66:     function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {",
          "67:         ProposalVote storage proposalVote = _proposalVotes[proposalId];",
          "69:         return quorum(proposalSnapshot(proposalId)) <= proposalVote.forVotes + proposalVote.abstainVotes;",
          "70:     }",
          "75:     function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {",
          "76:         ProposalVote storage proposalVote = _proposalVotes[proposalId];",
          "78:         return proposalVote.forVotes > proposalVote.againstVotes;",
          "79:     }",
          "84:     function _countVote(",
          "85:         uint256 proposalId,",
          "86:         address account,",
          "87:         uint8 support,",
          "88:         uint256 weight,",
          "89:         bytes memory // params",
          "90:     ) internal virtual override {",
          "91:         ProposalVote storage proposalVote = _proposalVotes[proposalId];",
          "93:         require(!proposalVote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");",
          "94:         proposalVote.hasVoted[account] = true;",
          "96:         if (support == uint8(VoteType.Against)) {",
          "97:             proposalVote.againstVotes += weight;",
          "98:         } else if (support == uint8(VoteType.For)) {",
          "99:             proposalVote.forVotes += weight;",
          "100:         } else if (support == uint8(VoteType.Abstain)) {",
          "101:             proposalVote.abstainVotes += weight;",
          "102:         } else {",
          "103:             revert(\"GovernorVotingSimple: invalid value for enum VoteType\");",
          "104:         }",
          "105:     }",
          "112:     uint256[49] private __gap;",
          "113: }",
          "",
          "---------------"
        ],
        "contracts/governance/extensions/GovernorPreventLateQuorumUpgradeable.sol||contracts/governance/extensions/GovernorPreventLateQuorumUpgradeable.sol": [
          "File: contracts/governance/extensions/GovernorPreventLateQuorumUpgradeable.sol -> contracts/governance/extensions/GovernorPreventLateQuorumUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../GovernorUpgradeable.sol\";",
          "7: import \"../../utils/math/MathUpgradeable.sol\";",
          "8: import \"../../proxy/utils/Initializable.sol\";",
          "21: abstract contract GovernorPreventLateQuorumUpgradeable is Initializable, GovernorUpgradeable {",
          "22:     uint64 private _voteExtension;",
          "25:     mapping(uint256 => uint64) private _extendedDeadlines;",
          "28:     event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);",
          "31:     event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);",
          "38:     function __GovernorPreventLateQuorum_init(uint64 initialVoteExtension) internal onlyInitializing {",
          "39:         __GovernorPreventLateQuorum_init_unchained(initialVoteExtension);",
          "40:     }",
          "42:     function __GovernorPreventLateQuorum_init_unchained(uint64 initialVoteExtension) internal onlyInitializing {",
          "43:         _setLateQuorumVoteExtension(initialVoteExtension);",
          "44:     }",
          "50:     function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {",
          "51:         return MathUpgradeable.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId]);",
          "52:     }",
          "60:     function _castVote(",
          "61:         uint256 proposalId,",
          "62:         address account,",
          "63:         uint8 support,",
          "64:         string memory reason,",
          "65:         bytes memory params",
          "66:     ) internal virtual override returns (uint256) {",
          "67:         uint256 result = super._castVote(proposalId, account, support, reason, params);",
          "69:         if (_extendedDeadlines[proposalId] == 0 && _quorumReached(proposalId)) {",
          "70:             uint64 extendedDeadline = clock() + lateQuorumVoteExtension();",
          "72:             if (extendedDeadline > proposalDeadline(proposalId)) {",
          "73:                 emit ProposalExtended(proposalId, extendedDeadline);",
          "74:             }",
          "76:             _extendedDeadlines[proposalId] = extendedDeadline;",
          "77:         }",
          "79:         return result;",
          "80:     }",
          "86:     function lateQuorumVoteExtension() public view virtual returns (uint64) {",
          "87:         return _voteExtension;",
          "88:     }",
          "96:     function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {",
          "97:         _setLateQuorumVoteExtension(newVoteExtension);",
          "98:     }",
          "106:     function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {",
          "107:         emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);",
          "108:         _voteExtension = newVoteExtension;",
          "109:     }",
          "116:     uint256[48] private __gap;",
          "117: }",
          "",
          "---------------"
        ],
        "contracts/governance/extensions/GovernorProposalThresholdUpgradeable.sol||contracts/governance/extensions/GovernorProposalThresholdUpgradeable.sol": [
          "File: contracts/governance/extensions/GovernorProposalThresholdUpgradeable.sol -> contracts/governance/extensions/GovernorProposalThresholdUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../GovernorUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "15: abstract contract GovernorProposalThresholdUpgradeable is Initializable, GovernorUpgradeable {",
          "16:     function __GovernorProposalThreshold_init() internal onlyInitializing {",
          "17:     }",
          "19:     function __GovernorProposalThreshold_init_unchained() internal onlyInitializing {",
          "20:     }",
          "21:     function propose(",
          "22:         address[] memory targets,",
          "23:         uint256[] memory values,",
          "24:         bytes[] memory calldatas,",
          "25:         string memory description",
          "26:     ) public virtual override returns (uint256) {",
          "27:         return super.propose(targets, values, calldatas, description);",
          "28:     }",
          "35:     uint256[50] private __gap;",
          "36: }",
          "",
          "---------------"
        ],
        "contracts/governance/extensions/GovernorSettingsUpgradeable.sol||contracts/governance/extensions/GovernorSettingsUpgradeable.sol": [
          "File: contracts/governance/extensions/GovernorSettingsUpgradeable.sol -> contracts/governance/extensions/GovernorSettingsUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../GovernorUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "14: abstract contract GovernorSettingsUpgradeable is Initializable, GovernorUpgradeable {",
          "15:     uint256 private _votingDelay;",
          "16:     uint256 private _votingPeriod;",
          "17:     uint256 private _proposalThreshold;",
          "19:     event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);",
          "20:     event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);",
          "21:     event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);",
          "26:     function __GovernorSettings_init(uint256 initialVotingDelay, uint256 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {",
          "27:         __GovernorSettings_init_unchained(initialVotingDelay, initialVotingPeriod, initialProposalThreshold);",
          "28:     }",
          "30:     function __GovernorSettings_init_unchained(uint256 initialVotingDelay, uint256 initialVotingPeriod, uint256 initialProposalThreshold) internal onlyInitializing {",
          "31:         _setVotingDelay(initialVotingDelay);",
          "32:         _setVotingPeriod(initialVotingPeriod);",
          "33:         _setProposalThreshold(initialProposalThreshold);",
          "34:     }",
          "39:     function votingDelay() public view virtual override returns (uint256) {",
          "40:         return _votingDelay;",
          "41:     }",
          "46:     function votingPeriod() public view virtual override returns (uint256) {",
          "47:         return _votingPeriod;",
          "48:     }",
          "53:     function proposalThreshold() public view virtual override returns (uint256) {",
          "54:         return _proposalThreshold;",
          "55:     }",
          "62:     function setVotingDelay(uint256 newVotingDelay) public virtual onlyGovernance {",
          "63:         _setVotingDelay(newVotingDelay);",
          "64:     }",
          "71:     function setVotingPeriod(uint256 newVotingPeriod) public virtual onlyGovernance {",
          "72:         _setVotingPeriod(newVotingPeriod);",
          "73:     }",
          "80:     function setProposalThreshold(uint256 newProposalThreshold) public virtual onlyGovernance {",
          "81:         _setProposalThreshold(newProposalThreshold);",
          "82:     }",
          "89:     function _setVotingDelay(uint256 newVotingDelay) internal virtual {",
          "90:         emit VotingDelaySet(_votingDelay, newVotingDelay);",
          "91:         _votingDelay = newVotingDelay;",
          "92:     }",
          "99:     function _setVotingPeriod(uint256 newVotingPeriod) internal virtual {",
          "101:         require(newVotingPeriod > 0, \"GovernorSettings: voting period too low\");",
          "102:         emit VotingPeriodSet(_votingPeriod, newVotingPeriod);",
          "103:         _votingPeriod = newVotingPeriod;",
          "104:     }",
          "111:     function _setProposalThreshold(uint256 newProposalThreshold) internal virtual {",
          "112:         emit ProposalThresholdSet(_proposalThreshold, newProposalThreshold);",
          "113:         _proposalThreshold = newProposalThreshold;",
          "114:     }",
          "121:     uint256[47] private __gap;",
          "122: }",
          "",
          "---------------"
        ],
        "contracts/governance/extensions/GovernorTimelockCompoundUpgradeable.sol||contracts/governance/extensions/GovernorTimelockCompoundUpgradeable.sol": [
          "File: contracts/governance/extensions/GovernorTimelockCompoundUpgradeable.sol -> contracts/governance/extensions/GovernorTimelockCompoundUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IGovernorTimelockUpgradeable.sol\";",
          "7: import \"../GovernorUpgradeable.sol\";",
          "8: import \"../../utils/math/SafeCastUpgradeable.sol\";",
          "9: import \"../../vendor/compound/ICompoundTimelockUpgradeable.sol\";",
          "10: import \"../../proxy/utils/Initializable.sol\";",
          "24: abstract contract GovernorTimelockCompoundUpgradeable is Initializable, IGovernorTimelockUpgradeable, GovernorUpgradeable {",
          "25:     ICompoundTimelockUpgradeable private _timelock;",
          "28:     mapping(uint256 => uint64) private _proposalTimelocks;",
          "33:     event TimelockChange(address oldTimelock, address newTimelock);",
          "38:     function __GovernorTimelockCompound_init(ICompoundTimelockUpgradeable timelockAddress) internal onlyInitializing {",
          "39:         __GovernorTimelockCompound_init_unchained(timelockAddress);",
          "40:     }",
          "42:     function __GovernorTimelockCompound_init_unchained(ICompoundTimelockUpgradeable timelockAddress) internal onlyInitializing {",
          "43:         _updateTimelock(timelockAddress);",
          "44:     }",
          "49:     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, GovernorUpgradeable) returns (bool) {",
          "50:         return interfaceId == type(IGovernorTimelockUpgradeable).interfaceId || super.supportsInterface(interfaceId);",
          "51:     }",
          "56:     function state(uint256 proposalId) public view virtual override(IGovernorUpgradeable, GovernorUpgradeable) returns (ProposalState) {",
          "57:         ProposalState currentState = super.state(proposalId);",
          "59:         if (currentState != ProposalState.Succeeded) {",
          "60:             return currentState;",
          "61:         }",
          "63:         uint256 eta = proposalEta(proposalId);",
          "64:         if (eta == 0) {",
          "65:             return currentState;",
          "66:         } else if (block.timestamp >= eta + _timelock.GRACE_PERIOD()) {",
          "67:             return ProposalState.Expired;",
          "68:         } else {",
          "69:             return ProposalState.Queued;",
          "70:         }",
          "71:     }",
          "76:     function timelock() public view virtual override returns (address) {",
          "77:         return address(_timelock);",
          "78:     }",
          "83:     function proposalEta(uint256 proposalId) public view virtual override returns (uint256) {",
          "84:         return _proposalTimelocks[proposalId];",
          "85:     }",
          "90:     function queue(",
          "91:         address[] memory targets,",
          "92:         uint256[] memory values,",
          "93:         bytes[] memory calldatas,",
          "94:         bytes32 descriptionHash",
          "95:     ) public virtual override returns (uint256) {",
          "96:         uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);",
          "98:         require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");",
          "100:         uint256 eta = block.timestamp + _timelock.delay();",
          "101:         _proposalTimelocks[proposalId] = SafeCastUpgradeable.toUint64(eta);",
          "103:         for (uint256 i = 0; i < targets.length; ++i) {",
          "104:             require(",
          "105:                 !_timelock.queuedTransactions(keccak256(abi.encode(targets[i], values[i], \"\", calldatas[i], eta))),",
          "106:                 \"GovernorTimelockCompound: identical proposal action already queued\"",
          "107:             );",
          "108:             _timelock.queueTransaction(targets[i], values[i], \"\", calldatas[i], eta);",
          "109:         }",
          "111:         emit ProposalQueued(proposalId, eta);",
          "113:         return proposalId;",
          "114:     }",
          "119:     function _execute(",
          "120:         uint256 proposalId,",
          "121:         address[] memory targets,",
          "122:         uint256[] memory values,",
          "123:         bytes[] memory calldatas,",
          "125:     ) internal virtual override {",
          "126:         uint256 eta = proposalEta(proposalId);",
          "127:         require(eta > 0, \"GovernorTimelockCompound: proposal not yet queued\");",
          "128:         AddressUpgradeable.sendValue(payable(_timelock), msg.value);",
          "129:         for (uint256 i = 0; i < targets.length; ++i) {",
          "130:             _timelock.executeTransaction(targets[i], values[i], \"\", calldatas[i], eta);",
          "131:         }",
          "132:     }",
          "138:     function _cancel(",
          "139:         address[] memory targets,",
          "140:         uint256[] memory values,",
          "141:         bytes[] memory calldatas,",
          "142:         bytes32 descriptionHash",
          "143:     ) internal virtual override returns (uint256) {",
          "144:         uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);",
          "146:         uint256 eta = proposalEta(proposalId);",
          "147:         if (eta > 0) {",
          "149:             delete _proposalTimelocks[proposalId];",
          "151:             for (uint256 i = 0; i < targets.length; ++i) {",
          "152:                 _timelock.cancelTransaction(targets[i], values[i], \"\", calldatas[i], eta);",
          "153:             }",
          "154:         }",
          "156:         return proposalId;",
          "157:     }",
          "162:     function _executor() internal view virtual override returns (address) {",
          "163:         return address(_timelock);",
          "164:     }",
          "170:     function __acceptAdmin() public {",
          "171:         _timelock.acceptAdmin();",
          "172:     }",
          "187:     function updateTimelock(ICompoundTimelockUpgradeable newTimelock) external virtual onlyGovernance {",
          "188:         _updateTimelock(newTimelock);",
          "189:     }",
          "191:     function _updateTimelock(ICompoundTimelockUpgradeable newTimelock) private {",
          "192:         emit TimelockChange(address(_timelock), address(newTimelock));",
          "193:         _timelock = newTimelock;",
          "194:     }",
          "201:     uint256[48] private __gap;",
          "202: }",
          "",
          "---------------"
        ],
        "contracts/governance/extensions/GovernorTimelockControlUpgradeable.sol||contracts/governance/extensions/GovernorTimelockControlUpgradeable.sol": [
          "File: contracts/governance/extensions/GovernorTimelockControlUpgradeable.sol -> contracts/governance/extensions/GovernorTimelockControlUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IGovernorTimelockUpgradeable.sol\";",
          "7: import \"../GovernorUpgradeable.sol\";",
          "8: import \"../TimelockControllerUpgradeable.sol\";",
          "9: import \"../../proxy/utils/Initializable.sol\";",
          "27: abstract contract GovernorTimelockControlUpgradeable is Initializable, IGovernorTimelockUpgradeable, GovernorUpgradeable {",
          "28:     TimelockControllerUpgradeable private _timelock;",
          "29:     mapping(uint256 => bytes32) private _timelockIds;",
          "34:     event TimelockChange(address oldTimelock, address newTimelock);",
          "39:     function __GovernorTimelockControl_init(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {",
          "40:         __GovernorTimelockControl_init_unchained(timelockAddress);",
          "41:     }",
          "43:     function __GovernorTimelockControl_init_unchained(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {",
          "44:         _updateTimelock(timelockAddress);",
          "45:     }",
          "50:     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, GovernorUpgradeable) returns (bool) {",
          "51:         return interfaceId == type(IGovernorTimelockUpgradeable).interfaceId || super.supportsInterface(interfaceId);",
          "52:     }",
          "57:     function state(uint256 proposalId) public view virtual override(IGovernorUpgradeable, GovernorUpgradeable) returns (ProposalState) {",
          "58:         ProposalState currentState = super.state(proposalId);",
          "60:         if (currentState != ProposalState.Succeeded) {",
          "61:             return currentState;",
          "62:         }",
          "65:         bytes32 queueid = _timelockIds[proposalId];",
          "66:         if (queueid == bytes32(0)) {",
          "67:             return currentState;",
          "68:         } else if (_timelock.isOperationDone(queueid)) {",
          "69:             return ProposalState.Executed;",
          "70:         } else if (_timelock.isOperationPending(queueid)) {",
          "71:             return ProposalState.Queued;",
          "72:         } else {",
          "73:             return ProposalState.Canceled;",
          "74:         }",
          "75:     }",
          "80:     function timelock() public view virtual override returns (address) {",
          "81:         return address(_timelock);",
          "82:     }",
          "87:     function proposalEta(uint256 proposalId) public view virtual override returns (uint256) {",
          "88:         uint256 eta = _timelock.getTimestamp(_timelockIds[proposalId]);",
          "89:         return eta == 1 ? 0 : eta; // _DONE_TIMESTAMP (1) should be replaced with a 0 value",
          "90:     }",
          "95:     function queue(",
          "96:         address[] memory targets,",
          "97:         uint256[] memory values,",
          "98:         bytes[] memory calldatas,",
          "99:         bytes32 descriptionHash",
          "100:     ) public virtual override returns (uint256) {",
          "101:         uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);",
          "103:         require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");",
          "105:         uint256 delay = _timelock.getMinDelay();",
          "106:         _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);",
          "107:         _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);",
          "109:         emit ProposalQueued(proposalId, block.timestamp + delay);",
          "111:         return proposalId;",
          "112:     }",
          "117:     function _execute(",
          "118:         uint256 /* proposalId */,",
          "119:         address[] memory targets,",
          "120:         uint256[] memory values,",
          "121:         bytes[] memory calldatas,",
          "122:         bytes32 descriptionHash",
          "123:     ) internal virtual override {",
          "124:         _timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, descriptionHash);",
          "125:     }",
          "134:     function _cancel(",
          "135:         address[] memory targets,",
          "136:         uint256[] memory values,",
          "137:         bytes[] memory calldatas,",
          "138:         bytes32 descriptionHash",
          "139:     ) internal virtual override returns (uint256) {",
          "140:         uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);",
          "142:         if (_timelockIds[proposalId] != 0) {",
          "143:             _timelock.cancel(_timelockIds[proposalId]);",
          "144:             delete _timelockIds[proposalId];",
          "145:         }",
          "147:         return proposalId;",
          "148:     }",
          "153:     function _executor() internal view virtual override returns (address) {",
          "154:         return address(_timelock);",
          "155:     }",
          "163:     function updateTimelock(TimelockControllerUpgradeable newTimelock) external virtual onlyGovernance {",
          "164:         _updateTimelock(newTimelock);",
          "165:     }",
          "167:     function _updateTimelock(TimelockControllerUpgradeable newTimelock) private {",
          "168:         emit TimelockChange(address(_timelock), address(newTimelock));",
          "169:         _timelock = newTimelock;",
          "170:     }",
          "177:     uint256[48] private __gap;",
          "178: }",
          "",
          "---------------"
        ],
        "contracts/governance/extensions/GovernorVotesCompUpgradeable.sol||contracts/governance/extensions/GovernorVotesCompUpgradeable.sol": [
          "File: contracts/governance/extensions/GovernorVotesCompUpgradeable.sol -> contracts/governance/extensions/GovernorVotesCompUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../GovernorUpgradeable.sol\";",
          "7: import \"../../token/ERC20/extensions/ERC20VotesCompUpgradeable.sol\";",
          "8: import \"../../proxy/utils/Initializable.sol\";",
          "17: abstract contract GovernorVotesCompUpgradeable is Initializable, GovernorUpgradeable {",
          "18:     ERC20VotesCompUpgradeable public token;",
          "20:     function __GovernorVotesComp_init(ERC20VotesCompUpgradeable token_) internal onlyInitializing {",
          "21:         __GovernorVotesComp_init_unchained(token_);",
          "22:     }",
          "24:     function __GovernorVotesComp_init_unchained(ERC20VotesCompUpgradeable token_) internal onlyInitializing {",
          "25:         token = token_;",
          "26:     }",
          "32:     function clock() public view virtual override returns (uint48) {",
          "33:         try token.clock() returns (uint48 timepoint) {",
          "34:             return timepoint;",
          "35:         } catch {",
          "36:             return SafeCastUpgradeable.toUint48(block.number);",
          "37:         }",
          "38:     }",
          "44:     function CLOCK_MODE() public view virtual override returns (string memory) {",
          "45:         try token.CLOCK_MODE() returns (string memory clockmode) {",
          "46:             return clockmode;",
          "47:         } catch {",
          "48:             return \"mode=blocknumber&from=default\";",
          "49:         }",
          "50:     }",
          "55:     function _getVotes(",
          "56:         address account,",
          "57:         uint256 timepoint,",
          "59:     ) internal view virtual override returns (uint256) {",
          "60:         return token.getPriorVotes(account, timepoint);",
          "61:     }",
          "68:     uint256[50] private __gap;",
          "69: }",
          "",
          "---------------"
        ],
        "contracts/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol||contracts/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol": [
          "File: contracts/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol -> contracts/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./GovernorVotesUpgradeable.sol\";",
          "7: import \"../../utils/CheckpointsUpgradeable.sol\";",
          "8: import \"../../utils/math/SafeCastUpgradeable.sol\";",
          "9: import \"../../proxy/utils/Initializable.sol\";",
          "17: abstract contract GovernorVotesQuorumFractionUpgradeable is Initializable, GovernorVotesUpgradeable {",
          "18:     using CheckpointsUpgradeable for CheckpointsUpgradeable.Trace224;",
          "20:     uint256 private _quorumNumerator; // DEPRECATED in favor of _quorumNumeratorHistory",
          "23:     CheckpointsUpgradeable.Trace224 private _quorumNumeratorHistory;",
          "25:     event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator);",
          "34:     function __GovernorVotesQuorumFraction_init(uint256 quorumNumeratorValue) internal onlyInitializing {",
          "35:         __GovernorVotesQuorumFraction_init_unchained(quorumNumeratorValue);",
          "36:     }",
          "38:     function __GovernorVotesQuorumFraction_init_unchained(uint256 quorumNumeratorValue) internal onlyInitializing {",
          "39:         _updateQuorumNumerator(quorumNumeratorValue);",
          "40:     }",
          "45:     function quorumNumerator() public view virtual returns (uint256) {",
          "46:         return _quorumNumeratorHistory._checkpoints.length == 0 ? _quorumNumerator : _quorumNumeratorHistory.latest();",
          "47:     }",
          "52:     function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) {",
          "54:         uint256 length = _quorumNumeratorHistory._checkpoints.length;",
          "55:         if (length == 0) {",
          "56:             return _quorumNumerator;",
          "57:         }",
          "60:         CheckpointsUpgradeable.Checkpoint224 memory latest = _quorumNumeratorHistory._checkpoints[length - 1];",
          "61:         if (latest._key <= timepoint) {",
          "62:             return latest._value;",
          "63:         }",
          "66:         return _quorumNumeratorHistory.upperLookupRecent(SafeCastUpgradeable.toUint32(timepoint));",
          "67:     }",
          "72:     function quorumDenominator() public view virtual returns (uint256) {",
          "73:         return 100;",
          "74:     }",
          "79:     function quorum(uint256 timepoint) public view virtual override returns (uint256) {",
          "80:         return (token.getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) / quorumDenominator();",
          "81:     }",
          "93:     function updateQuorumNumerator(uint256 newQuorumNumerator) external virtual onlyGovernance {",
          "94:         _updateQuorumNumerator(newQuorumNumerator);",
          "95:     }",
          "106:     function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual {",
          "107:         require(",
          "108:             newQuorumNumerator <= quorumDenominator(),",
          "109:             \"GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator\"",
          "110:         );",
          "112:         uint256 oldQuorumNumerator = quorumNumerator();",
          "115:         if (oldQuorumNumerator != 0 && _quorumNumeratorHistory._checkpoints.length == 0) {",
          "116:             _quorumNumeratorHistory._checkpoints.push(",
          "117:                 CheckpointsUpgradeable.Checkpoint224({_key: 0, _value: SafeCastUpgradeable.toUint224(oldQuorumNumerator)})",
          "118:             );",
          "119:         }",
          "122:         _quorumNumeratorHistory.push(SafeCastUpgradeable.toUint32(clock()), SafeCastUpgradeable.toUint224(newQuorumNumerator));",
          "124:         emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);",
          "125:     }",
          "132:     uint256[48] private __gap;",
          "133: }",
          "",
          "---------------"
        ],
        "contracts/governance/extensions/GovernorVotesUpgradeable.sol||contracts/governance/extensions/GovernorVotesUpgradeable.sol": [
          "File: contracts/governance/extensions/GovernorVotesUpgradeable.sol -> contracts/governance/extensions/GovernorVotesUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../GovernorUpgradeable.sol\";",
          "7: import \"../../interfaces/IERC5805Upgradeable.sol\";",
          "8: import \"../../proxy/utils/Initializable.sol\";",
          "17: abstract contract GovernorVotesUpgradeable is Initializable, GovernorUpgradeable {",
          "18:     IERC5805Upgradeable public token;",
          "20:     function __GovernorVotes_init(IVotesUpgradeable tokenAddress) internal onlyInitializing {",
          "21:         __GovernorVotes_init_unchained(tokenAddress);",
          "22:     }",
          "24:     function __GovernorVotes_init_unchained(IVotesUpgradeable tokenAddress) internal onlyInitializing {",
          "25:         token = IERC5805Upgradeable(address(tokenAddress));",
          "26:     }",
          "32:     function clock() public view virtual override returns (uint48) {",
          "33:         try token.clock() returns (uint48 timepoint) {",
          "34:             return timepoint;",
          "35:         } catch {",
          "36:             return SafeCastUpgradeable.toUint48(block.number);",
          "37:         }",
          "38:     }",
          "44:     function CLOCK_MODE() public view virtual override returns (string memory) {",
          "45:         try token.CLOCK_MODE() returns (string memory clockmode) {",
          "46:             return clockmode;",
          "47:         } catch {",
          "48:             return \"mode=blocknumber&from=default\";",
          "49:         }",
          "50:     }",
          "55:     function _getVotes(",
          "56:         address account,",
          "57:         uint256 timepoint,",
          "59:     ) internal view virtual override returns (uint256) {",
          "60:         return token.getPastVotes(account, timepoint);",
          "61:     }",
          "68:     uint256[50] private __gap;",
          "69: }",
          "",
          "---------------"
        ],
        "contracts/governance/extensions/IGovernorTimelockUpgradeable.sol||contracts/governance/extensions/IGovernorTimelockUpgradeable.sol": [
          "File: contracts/governance/extensions/IGovernorTimelockUpgradeable.sol -> contracts/governance/extensions/IGovernorTimelockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../IGovernorUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "14: abstract contract IGovernorTimelockUpgradeable is Initializable, IGovernorUpgradeable {",
          "15:     function __IGovernorTimelock_init() internal onlyInitializing {",
          "16:     }",
          "18:     function __IGovernorTimelock_init_unchained() internal onlyInitializing {",
          "19:     }",
          "20:     event ProposalQueued(uint256 proposalId, uint256 eta);",
          "22:     function timelock() public view virtual returns (address);",
          "24:     function proposalEta(uint256 proposalId) public view virtual returns (uint256);",
          "26:     function queue(",
          "27:         address[] memory targets,",
          "28:         uint256[] memory values,",
          "29:         bytes[] memory calldatas,",
          "30:         bytes32 descriptionHash",
          "31:     ) public virtual returns (uint256 proposalId);",
          "38:     uint256[50] private __gap;",
          "39: }",
          "",
          "---------------"
        ],
        "contracts/governance/utils/IVotesUpgradeable.sol||contracts/governance/utils/IVotesUpgradeable.sol": [
          "File: contracts/governance/utils/IVotesUpgradeable.sol -> contracts/governance/utils/IVotesUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "10: interface IVotesUpgradeable {",
          "14:     event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);",
          "19:     event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);",
          "24:     function getVotes(address account) external view returns (uint256);",
          "30:     function getPastVotes(address account, uint256 timepoint) external view returns (uint256);",
          "40:     function getPastTotalSupply(uint256 timepoint) external view returns (uint256);",
          "45:     function delegates(address account) external view returns (address);",
          "50:     function delegate(address delegatee) external;",
          "55:     function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;",
          "56: }",
          "",
          "---------------"
        ],
        "contracts/governance/utils/VotesUpgradeable.sol||contracts/governance/utils/VotesUpgradeable.sol": [
          "File: contracts/governance/utils/VotesUpgradeable.sol -> contracts/governance/utils/VotesUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../interfaces/IERC5805Upgradeable.sol\";",
          "6: import \"../../utils/ContextUpgradeable.sol\";",
          "7: import \"../../utils/CountersUpgradeable.sol\";",
          "8: import \"../../utils/CheckpointsUpgradeable.sol\";",
          "9: import \"../../utils/cryptography/EIP712Upgradeable.sol\";",
          "10: import \"../../proxy/utils/Initializable.sol\";",
          "32: abstract contract VotesUpgradeable is Initializable, ContextUpgradeable, EIP712Upgradeable, IERC5805Upgradeable {",
          "33:     function __Votes_init() internal onlyInitializing {",
          "34:     }",
          "36:     function __Votes_init_unchained() internal onlyInitializing {",
          "37:     }",
          "38:     using CheckpointsUpgradeable for CheckpointsUpgradeable.Trace224;",
          "39:     using CountersUpgradeable for CountersUpgradeable.Counter;",
          "41:     bytes32 private constant _DELEGATION_TYPEHASH =",
          "42:         keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");",
          "44:     mapping(address => address) private _delegation;",
          "47:     mapping(address => CheckpointsUpgradeable.Trace224) private _delegateCheckpoints;",
          "50:     CheckpointsUpgradeable.Trace224 private _totalCheckpoints;",
          "52:     mapping(address => CountersUpgradeable.Counter) private _nonces;",
          "58:     function clock() public view virtual override returns (uint48) {",
          "59:         return SafeCastUpgradeable.toUint48(block.number);",
          "60:     }",
          "66:     function CLOCK_MODE() public view virtual override returns (string memory) {",
          "68:         require(clock() == block.number, \"Votes: broken clock mode\");",
          "69:         return \"mode=blocknumber&from=default\";",
          "70:     }",
          "75:     function getVotes(address account) public view virtual override returns (uint256) {",
          "76:         return _delegateCheckpoints[account].latest();",
          "77:     }",
          "87:     function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
          "88:         require(timepoint < clock(), \"Votes: future lookup\");",
          "89:         return _delegateCheckpoints[account].upperLookupRecent(SafeCastUpgradeable.toUint32(timepoint));",
          "90:     }",
          "104:     function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {",
          "105:         require(timepoint < clock(), \"Votes: future lookup\");",
          "106:         return _totalCheckpoints.upperLookupRecent(SafeCastUpgradeable.toUint32(timepoint));",
          "107:     }",
          "112:     function _getTotalSupply() internal view virtual returns (uint256) {",
          "113:         return _totalCheckpoints.latest();",
          "114:     }",
          "119:     function delegates(address account) public view virtual override returns (address) {",
          "120:         return _delegation[account];",
          "121:     }",
          "126:     function delegate(address delegatee) public virtual override {",
          "127:         address account = _msgSender();",
          "128:         _delegate(account, delegatee);",
          "129:     }",
          "134:     function delegateBySig(",
          "135:         address delegatee,",
          "136:         uint256 nonce,",
          "137:         uint256 expiry,",
          "138:         uint8 v,",
          "139:         bytes32 r,",
          "140:         bytes32 s",
          "141:     ) public virtual override {",
          "142:         require(block.timestamp <= expiry, \"Votes: signature expired\");",
          "143:         address signer = ECDSAUpgradeable.recover(",
          "144:             _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),",
          "145:             v,",
          "146:             r,",
          "147:             s",
          "148:         );",
          "149:         require(nonce == _useNonce(signer), \"Votes: invalid nonce\");",
          "150:         _delegate(signer, delegatee);",
          "151:     }",
          "158:     function _delegate(address account, address delegatee) internal virtual {",
          "159:         address oldDelegate = delegates(account);",
          "160:         _delegation[account] = delegatee;",
          "162:         emit DelegateChanged(account, oldDelegate, delegatee);",
          "163:         _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));",
          "164:     }",
          "170:     function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {",
          "171:         if (from == address(0)) {",
          "172:             _push(_totalCheckpoints, _add, SafeCastUpgradeable.toUint224(amount));",
          "173:         }",
          "174:         if (to == address(0)) {",
          "175:             _push(_totalCheckpoints, _subtract, SafeCastUpgradeable.toUint224(amount));",
          "176:         }",
          "177:         _moveDelegateVotes(delegates(from), delegates(to), amount);",
          "178:     }",
          "183:     function _moveDelegateVotes(address from, address to, uint256 amount) private {",
          "184:         if (from != to && amount > 0) {",
          "185:             if (from != address(0)) {",
          "186:                 (uint256 oldValue, uint256 newValue) = _push(",
          "187:                     _delegateCheckpoints[from],",
          "188:                     _subtract,",
          "189:                     SafeCastUpgradeable.toUint224(amount)",
          "190:                 );",
          "191:                 emit DelegateVotesChanged(from, oldValue, newValue);",
          "192:             }",
          "193:             if (to != address(0)) {",
          "194:                 (uint256 oldValue, uint256 newValue) = _push(",
          "195:                     _delegateCheckpoints[to],",
          "196:                     _add,",
          "197:                     SafeCastUpgradeable.toUint224(amount)",
          "198:                 );",
          "199:                 emit DelegateVotesChanged(to, oldValue, newValue);",
          "200:             }",
          "201:         }",
          "202:     }",
          "204:     function _push(",
          "205:         CheckpointsUpgradeable.Trace224 storage store,",
          "206:         function(uint224, uint224) view returns (uint224) op,",
          "207:         uint224 delta",
          "208:     ) private returns (uint224, uint224) {",
          "209:         return store.push(SafeCastUpgradeable.toUint32(clock()), op(store.latest(), delta));",
          "210:     }",
          "212:     function _add(uint224 a, uint224 b) private pure returns (uint224) {",
          "213:         return a + b;",
          "214:     }",
          "216:     function _subtract(uint224 a, uint224 b) private pure returns (uint224) {",
          "217:         return a - b;",
          "218:     }",
          "225:     function _useNonce(address owner) internal virtual returns (uint256 current) {",
          "226:         CountersUpgradeable.Counter storage nonce = _nonces[owner];",
          "227:         current = nonce.current();",
          "228:         nonce.increment();",
          "229:     }",
          "234:     function nonces(address owner) public view virtual returns (uint256) {",
          "235:         return _nonces[owner].current();",
          "236:     }",
          "242:     function DOMAIN_SEPARATOR() external view returns (bytes32) {",
          "243:         return _domainSeparatorV4();",
          "244:     }",
          "249:     function _getVotingUnits(address) internal view virtual returns (uint256);",
          "256:     uint256[46] private __gap;",
          "257: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC1155MetadataURIUpgradeable.sol||contracts/interfaces/IERC1155MetadataURIUpgradeable.sol": [
          "File: contracts/interfaces/IERC1155MetadataURIUpgradeable.sol -> contracts/interfaces/IERC1155MetadataURIUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC1155ReceiverUpgradeable.sol||contracts/interfaces/IERC1155ReceiverUpgradeable.sol": [
          "File: contracts/interfaces/IERC1155ReceiverUpgradeable.sol -> contracts/interfaces/IERC1155ReceiverUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC1155/IERC1155ReceiverUpgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC1155Upgradeable.sol||contracts/interfaces/IERC1155Upgradeable.sol": [
          "File: contracts/interfaces/IERC1155Upgradeable.sol -> contracts/interfaces/IERC1155Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC1155/IERC1155Upgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC1271Upgradeable.sol||contracts/interfaces/IERC1271Upgradeable.sol": [
          "File: contracts/interfaces/IERC1271Upgradeable.sol -> contracts/interfaces/IERC1271Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "12: interface IERC1271Upgradeable {",
          "18:     function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);",
          "19: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC1363ReceiverUpgradeable.sol||contracts/interfaces/IERC1363ReceiverUpgradeable.sol": [
          "File: contracts/interfaces/IERC1363ReceiverUpgradeable.sol -> contracts/interfaces/IERC1363ReceiverUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "10: interface IERC1363ReceiverUpgradeable {",
          "29:     function onTransferReceived(",
          "30:         address operator,",
          "31:         address from,",
          "32:         uint256 amount,",
          "33:         bytes memory data",
          "34:     ) external returns (bytes4);",
          "35: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC1363SpenderUpgradeable.sol||contracts/interfaces/IERC1363SpenderUpgradeable.sol": [
          "File: contracts/interfaces/IERC1363SpenderUpgradeable.sol -> contracts/interfaces/IERC1363SpenderUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "10: interface IERC1363SpenderUpgradeable {",
          "28:     function onApprovalReceived(address owner, uint256 amount, bytes memory data) external returns (bytes4);",
          "29: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC1363Upgradeable.sol||contracts/interfaces/IERC1363Upgradeable.sol": [
          "File: contracts/interfaces/IERC1363Upgradeable.sol -> contracts/interfaces/IERC1363Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IERC20Upgradeable.sol\";",
          "7: import \"./IERC165Upgradeable.sol\";",
          "16: interface IERC1363Upgradeable is IERC165Upgradeable, IERC20Upgradeable {",
          "34:     function transferAndCall(address to, uint256 amount) external returns (bool);",
          "43:     function transferAndCall(address to, uint256 amount, bytes memory data) external returns (bool);",
          "52:     function transferFromAndCall(address from, address to, uint256 amount) external returns (bool);",
          "62:     function transferFromAndCall(address from, address to, uint256 amount, bytes memory data) external returns (bool);",
          "70:     function approveAndCall(address spender, uint256 amount) external returns (bool);",
          "79:     function approveAndCall(address spender, uint256 amount, bytes memory data) external returns (bool);",
          "80: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC165Upgradeable.sol||contracts/interfaces/IERC165Upgradeable.sol": [
          "File: contracts/interfaces/IERC165Upgradeable.sol -> contracts/interfaces/IERC165Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../utils/introspection/IERC165Upgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC1820ImplementerUpgradeable.sol||contracts/interfaces/IERC1820ImplementerUpgradeable.sol": [
          "File: contracts/interfaces/IERC1820ImplementerUpgradeable.sol -> contracts/interfaces/IERC1820ImplementerUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../utils/introspection/IERC1820ImplementerUpgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC1820RegistryUpgradeable.sol||contracts/interfaces/IERC1820RegistryUpgradeable.sol": [
          "File: contracts/interfaces/IERC1820RegistryUpgradeable.sol -> contracts/interfaces/IERC1820RegistryUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../utils/introspection/IERC1820RegistryUpgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC1967Upgradeable.sol||contracts/interfaces/IERC1967Upgradeable.sol": [
          "File: contracts/interfaces/IERC1967Upgradeable.sol -> contracts/interfaces/IERC1967Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "10: interface IERC1967Upgradeable {",
          "14:     event Upgraded(address indexed implementation);",
          "19:     event AdminChanged(address previousAdmin, address newAdmin);",
          "24:     event BeaconUpgraded(address indexed beacon);",
          "25: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC20MetadataUpgradeable.sol||contracts/interfaces/IERC20MetadataUpgradeable.sol": [
          "File: contracts/interfaces/IERC20MetadataUpgradeable.sol -> contracts/interfaces/IERC20MetadataUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC20Upgradeable.sol||contracts/interfaces/IERC20Upgradeable.sol": [
          "File: contracts/interfaces/IERC20Upgradeable.sol -> contracts/interfaces/IERC20Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC20/IERC20Upgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC2309Upgradeable.sol||contracts/interfaces/IERC2309Upgradeable.sol": [
          "File: contracts/interfaces/IERC2309Upgradeable.sol -> contracts/interfaces/IERC2309Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "11: interface IERC2309Upgradeable {",
          "15:     event ConsecutiveTransfer(",
          "16:         uint256 indexed fromTokenId,",
          "17:         uint256 toTokenId,",
          "18:         address indexed fromAddress,",
          "19:         address indexed toAddress",
          "20:     );",
          "21: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC2612Upgradeable.sol||contracts/interfaces/IERC2612Upgradeable.sol": [
          "File: contracts/interfaces/IERC2612Upgradeable.sol -> contracts/interfaces/IERC2612Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC20/extensions/IERC20PermitUpgradeable.sol\";",
          "8: interface IERC2612Upgradeable is IERC20PermitUpgradeable {}",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC2981Upgradeable.sol||contracts/interfaces/IERC2981Upgradeable.sol": [
          "File: contracts/interfaces/IERC2981Upgradeable.sol -> contracts/interfaces/IERC2981Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../utils/introspection/IERC165Upgradeable.sol\";",
          "16: interface IERC2981Upgradeable is IERC165Upgradeable {",
          "21:     function royaltyInfo(",
          "22:         uint256 tokenId,",
          "23:         uint256 salePrice",
          "24:     ) external view returns (address receiver, uint256 royaltyAmount);",
          "25: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC3156FlashBorrowerUpgradeable.sol||contracts/interfaces/IERC3156FlashBorrowerUpgradeable.sol": [
          "File: contracts/interfaces/IERC3156FlashBorrowerUpgradeable.sol -> contracts/interfaces/IERC3156FlashBorrowerUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "12: interface IERC3156FlashBorrowerUpgradeable {",
          "22:     function onFlashLoan(",
          "23:         address initiator,",
          "24:         address token,",
          "25:         uint256 amount,",
          "26:         uint256 fee,",
          "27:         bytes calldata data",
          "28:     ) external returns (bytes32);",
          "29: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC3156FlashLenderUpgradeable.sol||contracts/interfaces/IERC3156FlashLenderUpgradeable.sol": [
          "File: contracts/interfaces/IERC3156FlashLenderUpgradeable.sol -> contracts/interfaces/IERC3156FlashLenderUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IERC3156FlashBorrowerUpgradeable.sol\";",
          "14: interface IERC3156FlashLenderUpgradeable {",
          "20:     function maxFlashLoan(address token) external view returns (uint256);",
          "28:     function flashFee(address token, uint256 amount) external view returns (uint256);",
          "37:     function flashLoan(",
          "38:         IERC3156FlashBorrowerUpgradeable receiver,",
          "39:         address token,",
          "40:         uint256 amount,",
          "41:         bytes calldata data",
          "42:     ) external returns (bool);",
          "43: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC3156Upgradeable.sol||contracts/interfaces/IERC3156Upgradeable.sol": [
          "File: contracts/interfaces/IERC3156Upgradeable.sol -> contracts/interfaces/IERC3156Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IERC3156FlashBorrowerUpgradeable.sol\";",
          "7: import \"./IERC3156FlashLenderUpgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC4626Upgradeable.sol||contracts/interfaces/IERC4626Upgradeable.sol": [
          "File: contracts/interfaces/IERC4626Upgradeable.sol -> contracts/interfaces/IERC4626Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC20/IERC20Upgradeable.sol\";",
          "7: import \"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";",
          "15: interface IERC4626Upgradeable is IERC20Upgradeable, IERC20MetadataUpgradeable {",
          "16:     event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);",
          "18:     event Withdraw(",
          "19:         address indexed sender,",
          "20:         address indexed receiver,",
          "21:         address indexed owner,",
          "22:         uint256 assets,",
          "23:         uint256 shares",
          "24:     );",
          "32:     function asset() external view returns (address assetTokenAddress);",
          "41:     function totalAssets() external view returns (uint256 totalManagedAssets);",
          "56:     function convertToShares(uint256 assets) external view returns (uint256 shares);",
          "71:     function convertToAssets(uint256 shares) external view returns (uint256 assets);",
          "81:     function maxDeposit(address receiver) external view returns (uint256 maxAssets);",
          "98:     function previewDeposit(uint256 assets) external view returns (uint256 shares);",
          "111:     function deposit(uint256 assets, address receiver) external returns (uint256 shares);",
          "119:     function maxMint(address receiver) external view returns (uint256 maxShares);",
          "136:     function previewMint(uint256 shares) external view returns (uint256 assets);",
          "149:     function mint(uint256 shares, address receiver) external returns (uint256 assets);",
          "158:     function maxWithdraw(address owner) external view returns (uint256 maxAssets);",
          "176:     function previewWithdraw(uint256 assets) external view returns (uint256 shares);",
          "190:     function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);",
          "200:     function maxRedeem(address owner) external view returns (uint256 maxShares);",
          "217:     function previewRedeem(uint256 shares) external view returns (uint256 assets);",
          "231:     function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);",
          "232: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC4906Upgradeable.sol||contracts/interfaces/IERC4906Upgradeable.sol": [
          "File: contracts/interfaces/IERC4906Upgradeable.sol -> contracts/interfaces/IERC4906Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"./IERC165Upgradeable.sol\";",
          "6: import \"./IERC721Upgradeable.sol\";",
          "9: interface IERC4906Upgradeable is IERC165Upgradeable, IERC721Upgradeable {",
          "13:     event MetadataUpdate(uint256 _tokenId);",
          "18:     event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);",
          "19: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC5267Upgradeable.sol||contracts/interfaces/IERC5267Upgradeable.sol": [
          "File: contracts/interfaces/IERC5267Upgradeable.sol -> contracts/interfaces/IERC5267Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: interface IERC5267Upgradeable {",
          "9:     event EIP712DomainChanged();",
          "15:     function eip712Domain()",
          "16:         external",
          "17:         view",
          "18:         returns (",
          "19:             bytes1 fields,",
          "20:             string memory name,",
          "21:             string memory version,",
          "22:             uint256 chainId,",
          "23:             address verifyingContract,",
          "24:             bytes32 salt,",
          "25:             uint256[] memory extensions",
          "26:         );",
          "27: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC5313Upgradeable.sol||contracts/interfaces/IERC5313Upgradeable.sol": [
          "File: contracts/interfaces/IERC5313Upgradeable.sol -> contracts/interfaces/IERC5313Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "12: interface IERC5313Upgradeable {",
          "16:     function owner() external view returns (address);",
          "17: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC5805Upgradeable.sol||contracts/interfaces/IERC5805Upgradeable.sol": [
          "File: contracts/interfaces/IERC5805Upgradeable.sol -> contracts/interfaces/IERC5805Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../governance/utils/IVotesUpgradeable.sol\";",
          "7: import \"./IERC6372Upgradeable.sol\";",
          "9: interface IERC5805Upgradeable is IERC6372Upgradeable, IVotesUpgradeable {}",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC6372Upgradeable.sol||contracts/interfaces/IERC6372Upgradeable.sol": [
          "File: contracts/interfaces/IERC6372Upgradeable.sol -> contracts/interfaces/IERC6372Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: interface IERC6372Upgradeable {",
          "10:     function clock() external view returns (uint48);",
          "16:     function CLOCK_MODE() external view returns (string memory);",
          "17: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC721EnumerableUpgradeable.sol||contracts/interfaces/IERC721EnumerableUpgradeable.sol": [
          "File: contracts/interfaces/IERC721EnumerableUpgradeable.sol -> contracts/interfaces/IERC721EnumerableUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC721MetadataUpgradeable.sol||contracts/interfaces/IERC721MetadataUpgradeable.sol": [
          "File: contracts/interfaces/IERC721MetadataUpgradeable.sol -> contracts/interfaces/IERC721MetadataUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC721ReceiverUpgradeable.sol||contracts/interfaces/IERC721ReceiverUpgradeable.sol": [
          "File: contracts/interfaces/IERC721ReceiverUpgradeable.sol -> contracts/interfaces/IERC721ReceiverUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC721/IERC721ReceiverUpgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC721Upgradeable.sol||contracts/interfaces/IERC721Upgradeable.sol": [
          "File: contracts/interfaces/IERC721Upgradeable.sol -> contracts/interfaces/IERC721Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC721/IERC721Upgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC777RecipientUpgradeable.sol||contracts/interfaces/IERC777RecipientUpgradeable.sol": [
          "File: contracts/interfaces/IERC777RecipientUpgradeable.sol -> contracts/interfaces/IERC777RecipientUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC777/IERC777RecipientUpgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC777SenderUpgradeable.sol||contracts/interfaces/IERC777SenderUpgradeable.sol": [
          "File: contracts/interfaces/IERC777SenderUpgradeable.sol -> contracts/interfaces/IERC777SenderUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC777/IERC777SenderUpgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/IERC777Upgradeable.sol||contracts/interfaces/IERC777Upgradeable.sol": [
          "File: contracts/interfaces/IERC777Upgradeable.sol -> contracts/interfaces/IERC777Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../token/ERC777/IERC777Upgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/interfaces/draft-IERC1822Upgradeable.sol||contracts/interfaces/draft-IERC1822Upgradeable.sol": [
          "File: contracts/interfaces/draft-IERC1822Upgradeable.sol -> contracts/interfaces/draft-IERC1822Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "10: interface IERC1822ProxiableUpgradeable {",
          "19:     function proxiableUUID() external view returns (bytes32);",
          "20: }",
          "",
          "---------------"
        ],
        "contracts/interfaces/draft-IERC2612Upgradeable.sol||contracts/interfaces/draft-IERC2612Upgradeable.sol": [
          "File: contracts/interfaces/draft-IERC2612Upgradeable.sol -> contracts/interfaces/draft-IERC2612Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "7: import \"./IERC2612Upgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/metatx/ERC2771ContextUpgradeable.sol||contracts/metatx/ERC2771ContextUpgradeable.sol": [
          "File: contracts/metatx/ERC2771ContextUpgradeable.sol -> contracts/metatx/ERC2771ContextUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.9;",
          "6: import \"../utils/ContextUpgradeable.sol\";",
          "7: import \"../proxy/utils/Initializable.sol\";",
          "12: abstract contract ERC2771ContextUpgradeable is Initializable, ContextUpgradeable {",
          "14:     address private immutable _trustedForwarder;",
          "17:     constructor(address trustedForwarder) {",
          "18:         _trustedForwarder = trustedForwarder;",
          "19:     }",
          "21:     function isTrustedForwarder(address forwarder) public view virtual returns (bool) {",
          "22:         return forwarder == _trustedForwarder;",
          "23:     }",
          "25:     function _msgSender() internal view virtual override returns (address sender) {",
          "26:         if (isTrustedForwarder(msg.sender)) {",
          "29:             assembly {",
          "30:                 sender := shr(96, calldataload(sub(calldatasize(), 20)))",
          "31:             }",
          "32:         } else {",
          "33:             return super._msgSender();",
          "34:         }",
          "35:     }",
          "37:     function _msgData() internal view virtual override returns (bytes calldata) {",
          "38:         if (isTrustedForwarder(msg.sender)) {",
          "39:             return msg.data[:msg.data.length - 20];",
          "40:         } else {",
          "41:             return super._msgData();",
          "42:         }",
          "43:     }",
          "50:     uint256[50] private __gap;",
          "51: }",
          "",
          "---------------"
        ],
        "contracts/metatx/MinimalForwarderUpgradeable.sol||contracts/metatx/MinimalForwarderUpgradeable.sol": [
          "File: contracts/metatx/MinimalForwarderUpgradeable.sol -> contracts/metatx/MinimalForwarderUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../utils/cryptography/ECDSAUpgradeable.sol\";",
          "7: import \"../utils/cryptography/EIP712Upgradeable.sol\";",
          "8: import \"../proxy/utils/Initializable.sol\";",
          "18: contract MinimalForwarderUpgradeable is Initializable, EIP712Upgradeable {",
          "19:     using ECDSAUpgradeable for bytes32;",
          "21:     struct ForwardRequest {",
          "22:         address from;",
          "23:         address to;",
          "24:         uint256 value;",
          "25:         uint256 gas;",
          "26:         uint256 nonce;",
          "27:         bytes data;",
          "28:     }",
          "30:     bytes32 private constant _TYPEHASH =",
          "31:         keccak256(\"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data)\");",
          "33:     mapping(address => uint256) private _nonces;",
          "35:     function __MinimalForwarder_init() internal onlyInitializing {",
          "36:         __EIP712_init_unchained(\"MinimalForwarder\", \"0.0.1\");",
          "37:     }",
          "39:     function __MinimalForwarder_init_unchained() internal onlyInitializing {}",
          "41:     function getNonce(address from) public view returns (uint256) {",
          "42:         return _nonces[from];",
          "43:     }",
          "45:     function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {",
          "46:         address signer = _hashTypedDataV4(",
          "47:             keccak256(abi.encode(_TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))",
          "48:         ).recover(signature);",
          "49:         return _nonces[req.from] == req.nonce && signer == req.from;",
          "50:     }",
          "52:     function execute(",
          "53:         ForwardRequest calldata req,",
          "54:         bytes calldata signature",
          "55:     ) public payable returns (bool, bytes memory) {",
          "56:         require(verify(req, signature), \"MinimalForwarder: signature does not match request\");",
          "57:         _nonces[req.from] = req.nonce + 1;",
          "59:         (bool success, bytes memory returndata) = req.to.call{gas: req.gas, value: req.value}(",
          "60:             abi.encodePacked(req.data, req.from)",
          "61:         );",
          "65:         if (gasleft() <= req.gas / 63) {",
          "70:             assembly {",
          "71:                 invalid()",
          "72:             }",
          "73:         }",
          "75:         return (success, returndata);",
          "76:     }",
          "83:     uint256[49] private __gap;",
          "84: }",
          "",
          "---------------"
        ],
        "contracts/mocks/AccessControlCrossChainMockUpgradeable.sol||contracts/mocks/AccessControlCrossChainMockUpgradeable.sol": [
          "File: contracts/mocks/AccessControlCrossChainMockUpgradeable.sol -> contracts/mocks/AccessControlCrossChainMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.4;",
          "5: import \"../access/AccessControlCrossChainUpgradeable.sol\";",
          "6: import \"../crosschain/arbitrum/CrossChainEnabledArbitrumL2Upgradeable.sol\";",
          "7: import \"../proxy/utils/Initializable.sol\";",
          "9: contract AccessControlCrossChainMockUpgradeable is Initializable, AccessControlCrossChainUpgradeable, CrossChainEnabledArbitrumL2Upgradeable {    function __AccessControlCrossChainMock_init() internal onlyInitializing {",
          "10:     }",
          "12:     function __AccessControlCrossChainMock_init_unchained() internal onlyInitializing {",
          "13:     }",
          "20:     uint256[50] private __gap;",
          "21: }",
          "",
          "---------------"
        ],
        "contracts/mocks/ArraysMockUpgradeable.sol||contracts/mocks/ArraysMockUpgradeable.sol": [
          "File: contracts/mocks/ArraysMockUpgradeable.sol -> contracts/mocks/ArraysMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../utils/ArraysUpgradeable.sol\";",
          "6: import \"../proxy/utils/Initializable.sol\";",
          "8: contract Uint256ArraysMockUpgradeable is Initializable {",
          "9:     using ArraysUpgradeable for uint256[];",
          "11:     uint256[] private _array;",
          "13:     function __Uint256ArraysMock_init(uint256[] memory array) internal onlyInitializing {",
          "14:         __Uint256ArraysMock_init_unchained(array);",
          "15:     }",
          "17:     function __Uint256ArraysMock_init_unchained(uint256[] memory array) internal onlyInitializing {",
          "18:         _array = array;",
          "19:     }",
          "21:     function findUpperBound(uint256 element) external view returns (uint256) {",
          "22:         return _array.findUpperBound(element);",
          "23:     }",
          "25:     function unsafeAccess(uint256 pos) external view returns (uint256) {",
          "26:         return _array.unsafeAccess(pos).value;",
          "27:     }",
          "34:     uint256[49] private __gap;",
          "35: }",
          "37: contract AddressArraysMockUpgradeable is Initializable {",
          "38:     using ArraysUpgradeable for address[];",
          "40:     address[] private _array;",
          "42:     function __AddressArraysMock_init(address[] memory array) internal onlyInitializing {",
          "43:         __AddressArraysMock_init_unchained(array);",
          "44:     }",
          "46:     function __AddressArraysMock_init_unchained(address[] memory array) internal onlyInitializing {",
          "47:         _array = array;",
          "48:     }",
          "50:     function unsafeAccess(uint256 pos) external view returns (address) {",
          "51:         return _array.unsafeAccess(pos).value;",
          "52:     }",
          "59:     uint256[49] private __gap;",
          "60: }",
          "62: contract Bytes32ArraysMockUpgradeable is Initializable {",
          "63:     using ArraysUpgradeable for bytes32[];",
          "65:     bytes32[] private _array;",
          "67:     function __Bytes32ArraysMock_init(bytes32[] memory array) internal onlyInitializing {",
          "68:         __Bytes32ArraysMock_init_unchained(array);",
          "69:     }",
          "71:     function __Bytes32ArraysMock_init_unchained(bytes32[] memory array) internal onlyInitializing {",
          "72:         _array = array;",
          "73:     }",
          "75:     function unsafeAccess(uint256 pos) external view returns (bytes32) {",
          "76:         return _array.unsafeAccess(pos).value;",
          "77:     }",
          "84:     uint256[49] private __gap;",
          "85: }",
          "",
          "---------------"
        ],
        "contracts/mocks/CallReceiverMockUpgradeable.sol||contracts/mocks/CallReceiverMockUpgradeable.sol": [
          "File: contracts/mocks/CallReceiverMockUpgradeable.sol -> contracts/mocks/CallReceiverMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "4: import \"../proxy/utils/Initializable.sol\";",
          "6: contract CallReceiverMockUpgradeable is Initializable {",
          "7:     function __CallReceiverMock_init() internal onlyInitializing {",
          "8:     }",
          "10:     function __CallReceiverMock_init_unchained() internal onlyInitializing {",
          "11:     }",
          "12:     event MockFunctionCalled();",
          "13:     event MockFunctionCalledWithArgs(uint256 a, uint256 b);",
          "15:     uint256[] private _array;",
          "17:     function mockFunction() public payable returns (string memory) {",
          "18:         emit MockFunctionCalled();",
          "20:         return \"0x1234\";",
          "21:     }",
          "23:     function mockFunctionEmptyReturn() public payable {",
          "24:         emit MockFunctionCalled();",
          "25:     }",
          "27:     function mockFunctionWithArgs(uint256 a, uint256 b) public payable returns (string memory) {",
          "28:         emit MockFunctionCalledWithArgs(a, b);",
          "30:         return \"0x1234\";",
          "31:     }",
          "33:     function mockFunctionNonPayable() public returns (string memory) {",
          "34:         emit MockFunctionCalled();",
          "36:         return \"0x1234\";",
          "37:     }",
          "39:     function mockStaticFunction() public pure returns (string memory) {",
          "40:         return \"0x1234\";",
          "41:     }",
          "43:     function mockFunctionRevertsNoReason() public payable {",
          "44:         revert();",
          "45:     }",
          "47:     function mockFunctionRevertsReason() public payable {",
          "48:         revert(\"CallReceiverMock: reverting\");",
          "49:     }",
          "51:     function mockFunctionThrows() public payable {",
          "52:         assert(false);",
          "53:     }",
          "55:     function mockFunctionOutOfGas() public payable {",
          "56:         for (uint256 i = 0; ; ++i) {",
          "57:             _array.push(i);",
          "58:         }",
          "59:     }",
          "61:     function mockFunctionWritesStorage(bytes32 slot, bytes32 value) public returns (string memory) {",
          "62:         assembly {",
          "63:             sstore(slot, value)",
          "64:         }",
          "65:         return \"0x1234\";",
          "66:     }",
          "73:     uint256[49] private __gap;",
          "74: }",
          "",
          "---------------"
        ],
        "contracts/mocks/ConditionalEscrowMockUpgradeable.sol||contracts/mocks/ConditionalEscrowMockUpgradeable.sol": [
          "File: contracts/mocks/ConditionalEscrowMockUpgradeable.sol -> contracts/mocks/ConditionalEscrowMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../utils/escrow/ConditionalEscrowUpgradeable.sol\";",
          "6: import \"../proxy/utils/Initializable.sol\";",
          "9: contract ConditionalEscrowMockUpgradeable is Initializable, ConditionalEscrowUpgradeable {",
          "10:     function __ConditionalEscrowMock_init() internal onlyInitializing {",
          "11:         __Ownable_init_unchained();",
          "12:     }",
          "14:     function __ConditionalEscrowMock_init_unchained() internal onlyInitializing {",
          "15:     }",
          "16:     mapping(address => bool) private _allowed;",
          "18:     function setAllowed(address payee, bool allowed) public {",
          "19:         _allowed[payee] = allowed;",
          "20:     }",
          "22:     function withdrawalAllowed(address payee) public view override returns (bool) {",
          "23:         return _allowed[payee];",
          "24:     }",
          "31:     uint256[49] private __gap;",
          "32: }",
          "",
          "---------------"
        ],
        "contracts/mocks/ContextMockUpgradeable.sol||contracts/mocks/ContextMockUpgradeable.sol": [
          "File: contracts/mocks/ContextMockUpgradeable.sol -> contracts/mocks/ContextMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../utils/ContextUpgradeable.sol\";",
          "6: import \"../proxy/utils/Initializable.sol\";",
          "8: contract ContextMockUpgradeable is Initializable, ContextUpgradeable {",
          "9:     function __ContextMock_init() internal onlyInitializing {",
          "10:     }",
          "12:     function __ContextMock_init_unchained() internal onlyInitializing {",
          "13:     }",
          "14:     event Sender(address sender);",
          "16:     function msgSender() public {",
          "17:         emit Sender(_msgSender());",
          "18:     }",
          "20:     event Data(bytes data, uint256 integerValue, string stringValue);",
          "22:     function msgData(uint256 integerValue, string memory stringValue) public {",
          "23:         emit Data(_msgData(), integerValue, stringValue);",
          "24:     }",
          "31:     uint256[50] private __gap;",
          "32: }",
          "34: contract ContextMockCallerUpgradeable is Initializable {",
          "35:     function __ContextMockCaller_init() internal onlyInitializing {",
          "36:     }",
          "38:     function __ContextMockCaller_init_unchained() internal onlyInitializing {",
          "39:     }",
          "40:     function callSender(ContextMockUpgradeable context) public {",
          "41:         context.msgSender();",
          "42:     }",
          "44:     function callData(ContextMockUpgradeable context, uint256 integerValue, string memory stringValue) public {",
          "45:         context.msgData(integerValue, stringValue);",
          "46:     }",
          "53:     uint256[50] private __gap;",
          "54: }",
          "",
          "---------------"
        ],
        "contracts/mocks/DummyImplementationUpgradeable.sol||contracts/mocks/DummyImplementationUpgradeable.sol": [
          "File: contracts/mocks/DummyImplementationUpgradeable.sol -> contracts/mocks/DummyImplementationUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "4: import \"../proxy/utils/Initializable.sol\";",
          "6: abstract contract ImplUpgradeable is Initializable {",
          "7:     function __Impl_init() internal onlyInitializing {",
          "8:     }",
          "10:     function __Impl_init_unchained() internal onlyInitializing {",
          "11:     }",
          "12:     function version() public pure virtual returns (string memory);",
          "19:     uint256[50] private __gap;",
          "20: }",
          "22: contract DummyImplementationUpgradeable is Initializable {",
          "23:     function __DummyImplementation_init() internal onlyInitializing {",
          "24:     }",
          "26:     function __DummyImplementation_init_unchained() internal onlyInitializing {",
          "27:     }",
          "28:     uint256 public value;",
          "29:     string public text;",
          "30:     uint256[] public values;",
          "32:     function initializeNonPayable() public {",
          "33:         value = 10;",
          "34:     }",
          "36:     function initializePayable() public payable {",
          "37:         value = 100;",
          "38:     }",
          "40:     function initializeNonPayableWithValue(uint256 _value) public {",
          "41:         value = _value;",
          "42:     }",
          "44:     function initializePayableWithValue(uint256 _value) public payable {",
          "45:         value = _value;",
          "46:     }",
          "48:     function initialize(uint256 _value, string memory _text, uint256[] memory _values) public {",
          "49:         value = _value;",
          "50:         text = _text;",
          "51:         values = _values;",
          "52:     }",
          "54:     function get() public pure returns (bool) {",
          "55:         return true;",
          "56:     }",
          "58:     function version() public pure virtual returns (string memory) {",
          "59:         return \"V1\";",
          "60:     }",
          "62:     function reverts() public pure {",
          "63:         require(false, \"DummyImplementation reverted\");",
          "64:     }",
          "71:     uint256[47] private __gap;",
          "72: }",
          "74: contract DummyImplementationV2Upgradeable is Initializable, DummyImplementationUpgradeable {",
          "75:     function __DummyImplementationV2_init() internal onlyInitializing {",
          "76:     }",
          "78:     function __DummyImplementationV2_init_unchained() internal onlyInitializing {",
          "79:     }",
          "80:     function migrate(uint256 newVal) public payable {",
          "81:         value = newVal;",
          "82:     }",
          "84:     function version() public pure override returns (string memory) {",
          "85:         return \"V2\";",
          "86:     }",
          "93:     uint256[50] private __gap;",
          "94: }",
          "",
          "---------------"
        ],
        "contracts/mocks/EIP712VerifierUpgradeable.sol||contracts/mocks/EIP712VerifierUpgradeable.sol": [
          "File: contracts/mocks/EIP712VerifierUpgradeable.sol -> contracts/mocks/EIP712VerifierUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../utils/cryptography/ECDSAUpgradeable.sol\";",
          "6: import \"../utils/cryptography/EIP712Upgradeable.sol\";",
          "7: import \"../proxy/utils/Initializable.sol\";",
          "9: abstract contract EIP712VerifierUpgradeable is Initializable, EIP712Upgradeable {",
          "10:     function __EIP712Verifier_init() internal onlyInitializing {",
          "11:     }",
          "13:     function __EIP712Verifier_init_unchained() internal onlyInitializing {",
          "14:     }",
          "15:     function verify(bytes memory signature, address signer, address mailTo, string memory mailContents) external view {",
          "16:         bytes32 digest = _hashTypedDataV4(",
          "17:             keccak256(abi.encode(keccak256(\"Mail(address to,string contents)\"), mailTo, keccak256(bytes(mailContents))))",
          "18:         );",
          "19:         address recoveredSigner = ECDSAUpgradeable.recover(digest, signature);",
          "20:         require(recoveredSigner == signer);",
          "21:     }",
          "28:     uint256[50] private __gap;",
          "29: }",
          "",
          "---------------"
        ],
        "contracts/mocks/ERC1271WalletMockUpgradeable.sol||contracts/mocks/ERC1271WalletMockUpgradeable.sol": [
          "File: contracts/mocks/ERC1271WalletMockUpgradeable.sol -> contracts/mocks/ERC1271WalletMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../access/OwnableUpgradeable.sol\";",
          "6: import \"../interfaces/IERC1271Upgradeable.sol\";",
          "7: import \"../utils/cryptography/ECDSAUpgradeable.sol\";",
          "8: import \"../proxy/utils/Initializable.sol\";",
          "10: contract ERC1271WalletMockUpgradeable is Initializable, OwnableUpgradeable, IERC1271Upgradeable {",
          "11:     function __ERC1271WalletMock_init(address originalOwner) internal onlyInitializing {",
          "12:         __Ownable_init_unchained();",
          "13:         __ERC1271WalletMock_init_unchained(originalOwner);",
          "14:     }",
          "16:     function __ERC1271WalletMock_init_unchained(address originalOwner) internal onlyInitializing {",
          "17:         transferOwnership(originalOwner);",
          "18:     }",
          "20:     function isValidSignature(bytes32 hash, bytes memory signature) public view override returns (bytes4 magicValue) {",
          "21:         return ECDSAUpgradeable.recover(hash, signature) == owner() ? this.isValidSignature.selector : bytes4(0);",
          "22:     }",
          "29:     uint256[50] private __gap;",
          "30: }",
          "32: contract ERC1271MaliciousMockUpgradeable is Initializable, IERC1271Upgradeable {",
          "33:     function __ERC1271MaliciousMock_init() internal onlyInitializing {",
          "34:     }",
          "36:     function __ERC1271MaliciousMock_init_unchained() internal onlyInitializing {",
          "37:     }",
          "38:     function isValidSignature(bytes32, bytes memory) public pure override returns (bytes4) {",
          "39:         assembly {",
          "40:             mstore(0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)",
          "41:             return(0, 32)",
          "42:         }",
          "43:     }",
          "50:     uint256[50] private __gap;",
          "51: }",
          "",
          "---------------"
        ],
        "contracts/mocks/ERC165/ERC165MaliciousDataUpgradeable.sol||contracts/mocks/ERC165/ERC165MaliciousDataUpgradeable.sol": [
          "File: contracts/mocks/ERC165/ERC165MaliciousDataUpgradeable.sol -> contracts/mocks/ERC165/ERC165MaliciousDataUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "4: import \"../../proxy/utils/Initializable.sol\";",
          "6: contract ERC165MaliciousDataUpgradeable is Initializable {",
          "7:     function __ERC165MaliciousData_init() internal onlyInitializing {",
          "8:     }",
          "10:     function __ERC165MaliciousData_init_unchained() internal onlyInitializing {",
          "11:     }",
          "12:     function supportsInterface(bytes4) public pure returns (bool) {",
          "13:         assembly {",
          "14:             mstore(0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)",
          "15:             return(0, 32)",
          "16:         }",
          "17:     }",
          "24:     uint256[50] private __gap;",
          "25: }",
          "",
          "---------------"
        ],
        "contracts/mocks/ERC165/ERC165MissingDataUpgradeable.sol||contracts/mocks/ERC165/ERC165MissingDataUpgradeable.sol": [
          "File: contracts/mocks/ERC165/ERC165MissingDataUpgradeable.sol -> contracts/mocks/ERC165/ERC165MissingDataUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "4: import \"../../proxy/utils/Initializable.sol\";",
          "6: contract ERC165MissingDataUpgradeable is Initializable {",
          "7:     function __ERC165MissingData_init() internal onlyInitializing {",
          "8:     }",
          "10:     function __ERC165MissingData_init_unchained() internal onlyInitializing {",
          "11:     }",
          "12:     function supportsInterface(bytes4 interfaceId) public view {} // missing return",
          "19:     uint256[50] private __gap;",
          "20: }",
          "",
          "---------------"
        ],
        "contracts/mocks/ERC165/ERC165NotSupportedUpgradeable.sol||contracts/mocks/ERC165/ERC165NotSupportedUpgradeable.sol": [
          "File: contracts/mocks/ERC165/ERC165NotSupportedUpgradeable.sol -> contracts/mocks/ERC165/ERC165NotSupportedUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "4: import \"../../proxy/utils/Initializable.sol\";",
          "6: contract ERC165NotSupportedUpgradeable is Initializable {    function __ERC165NotSupported_init() internal onlyInitializing {",
          "7:     }",
          "9:     function __ERC165NotSupported_init_unchained() internal onlyInitializing {",
          "10:     }",
          "17:     uint256[50] private __gap;",
          "18: }",
          "",
          "---------------"
        ],
        "contracts/mocks/ERC165/ERC165ReturnBombUpgradeable.sol||contracts/mocks/ERC165/ERC165ReturnBombUpgradeable.sol": [
          "File: contracts/mocks/ERC165/ERC165ReturnBombUpgradeable.sol -> contracts/mocks/ERC165/ERC165ReturnBombUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../utils/introspection/IERC165Upgradeable.sol\";",
          "6: import \"../../proxy/utils/Initializable.sol\";",
          "8: contract ERC165ReturnBombMockUpgradeable is Initializable, IERC165Upgradeable {",
          "9:     function __ERC165ReturnBombMock_init() internal onlyInitializing {",
          "10:     }",
          "12:     function __ERC165ReturnBombMock_init_unchained() internal onlyInitializing {",
          "13:     }",
          "14:     function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {",
          "15:         if (interfaceId == type(IERC165Upgradeable).interfaceId) {",
          "16:             assembly {",
          "17:                 mstore(0, 1)",
          "18:             }",
          "19:         }",
          "20:         assembly {",
          "21:             return(0, 101500)",
          "22:         }",
          "23:     }",
          "30:     uint256[50] private __gap;",
          "31: }",
          "",
          "---------------"
        ],
        "contracts/mocks/ERC20MockUpgradeable.sol||contracts/mocks/ERC20MockUpgradeable.sol": [
          "File: contracts/mocks/ERC20MockUpgradeable.sol -> contracts/mocks/ERC20MockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: pragma solidity ^0.8.0;",
          "4: import { ERC20Upgradeable } from \"../token/ERC20/ERC20Upgradeable.sol\";",
          "5: import \"../proxy/utils/Initializable.sol\";",
          "7: contract ERC20MockUpgradeable is Initializable, ERC20Upgradeable {",
          "8:     function __ERC20Mock_init() internal onlyInitializing {",
          "9:         __ERC20_init_unchained(\"ERC20Mock\", \"E20M\");",
          "10:     }",
          "12:     function __ERC20Mock_init_unchained() internal onlyInitializing {}",
          "14:     function mint(address account, uint256 amount) external {",
          "15:         _mint(account, amount);",
          "16:     }",
          "18:     function burn(address account, uint256 amount) external {",
          "19:         _burn(account, amount);",
          "20:     }",
          "27:     uint256[50] private __gap;",
          "28: }",
          "",
          "---------------"
        ],
        "contracts/mocks/ERC20ReentrantUpgradeable.sol||contracts/mocks/ERC20ReentrantUpgradeable.sol": [
          "File: contracts/mocks/ERC20ReentrantUpgradeable.sol -> contracts/mocks/ERC20ReentrantUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: pragma solidity ^0.8.0;",
          "4: import \"../token/ERC20/ERC20Upgradeable.sol\";",
          "5: import \"../token/ERC20/extensions/ERC4626Upgradeable.sol\";",
          "6: import \"../proxy/utils/Initializable.sol\";",
          "8: contract ERC20ReentrantUpgradeable is Initializable, ERC20Upgradeable {",
          "9:     function __ERC20Reentrant_init() internal onlyInitializing {",
          "10:         __ERC20_init_unchained(\"TEST\", \"TST\");",
          "11:     }",
          "13:     function __ERC20Reentrant_init_unchained() internal onlyInitializing {",
          "14:     }",
          "15:     enum Type {",
          "16:         No,",
          "17:         Before,",
          "18:         After",
          "19:     }",
          "21:     Type private _reenterType;",
          "22:     address private _reenterTarget;",
          "23:     bytes private _reenterData;",
          "25:     function scheduleReenter(Type when, address target, bytes calldata data) external {",
          "26:         _reenterType = when;",
          "27:         _reenterTarget = target;",
          "28:         _reenterData = data;",
          "29:     }",
          "31:     function functionCall(address target, bytes memory data) public returns (bytes memory) {",
          "32:         return AddressUpgradeable.functionCall(target, data);",
          "33:     }",
          "35:     function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {",
          "36:         if (_reenterType == Type.Before) {",
          "37:             _reenterType = Type.No;",
          "38:             functionCall(_reenterTarget, _reenterData);",
          "39:         }",
          "40:         super._beforeTokenTransfer(from, to, amount);",
          "41:     }",
          "43:     function _afterTokenTransfer(address from, address to, uint256 amount) internal override {",
          "44:         super._afterTokenTransfer(from, to, amount);",
          "45:         if (_reenterType == Type.After) {",
          "46:             _reenterType = Type.No;",
          "47:             functionCall(_reenterTarget, _reenterData);",
          "48:         }",
          "49:     }",
          "56:     uint256[48] private __gap;",
          "57: }",
          "",
          "---------------"
        ],
        "contracts/mocks/ERC2771ContextMockUpgradeable.sol||contracts/mocks/ERC2771ContextMockUpgradeable.sol": [
          "File: contracts/mocks/ERC2771ContextMockUpgradeable.sol -> contracts/mocks/ERC2771ContextMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.9;",
          "5: import \"./ContextMockUpgradeable.sol\";",
          "6: import \"../metatx/ERC2771ContextUpgradeable.sol\";",
          "7: import \"../proxy/utils/Initializable.sol\";",
          "10: contract ERC2771ContextMockUpgradeable is Initializable, ContextMockUpgradeable, ERC2771ContextUpgradeable {",
          "12:     constructor(address trustedForwarder) ERC2771ContextUpgradeable(trustedForwarder) {",
          "13:         emit Sender(_msgSender()); // _msgSender() should be accessible during construction",
          "14:     }",
          "16:     function _msgSender() internal view override(ContextUpgradeable, ERC2771ContextUpgradeable) returns (address) {",
          "17:         return ERC2771ContextUpgradeable._msgSender();",
          "18:     }",
          "20:     function _msgData() internal view override(ContextUpgradeable, ERC2771ContextUpgradeable) returns (bytes calldata) {",
          "21:         return ERC2771ContextUpgradeable._msgData();",
          "22:     }",
          "29:     uint256[50] private __gap;",
          "30: }",
          "",
          "---------------"
        ],
        "contracts/mocks/ERC3156FlashBorrowerMockUpgradeable.sol||contracts/mocks/ERC3156FlashBorrowerMockUpgradeable.sol": [
          "File: contracts/mocks/ERC3156FlashBorrowerMockUpgradeable.sol -> contracts/mocks/ERC3156FlashBorrowerMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../token/ERC20/IERC20Upgradeable.sol\";",
          "6: import \"../interfaces/IERC3156Upgradeable.sol\";",
          "7: import \"../utils/AddressUpgradeable.sol\";",
          "8: import \"../proxy/utils/Initializable.sol\";",
          "17: contract ERC3156FlashBorrowerMockUpgradeable is Initializable, IERC3156FlashBorrowerUpgradeable {",
          "18:     bytes32 internal constant _RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");",
          "20:     bool _enableApprove;",
          "21:     bool _enableReturn;",
          "23:     event BalanceOf(address token, address account, uint256 value);",
          "24:     event TotalSupply(address token, uint256 value);",
          "26:     function __ERC3156FlashBorrowerMock_init(bool enableReturn, bool enableApprove) internal onlyInitializing {",
          "27:         __ERC3156FlashBorrowerMock_init_unchained(enableReturn, enableApprove);",
          "28:     }",
          "30:     function __ERC3156FlashBorrowerMock_init_unchained(bool enableReturn, bool enableApprove) internal onlyInitializing {",
          "31:         _enableApprove = enableApprove;",
          "32:         _enableReturn = enableReturn;",
          "33:     }",
          "35:     function onFlashLoan(",
          "36:         address /*initiator*/,",
          "37:         address token,",
          "38:         uint256 amount,",
          "39:         uint256 fee,",
          "40:         bytes calldata data",
          "41:     ) public override returns (bytes32) {",
          "42:         require(msg.sender == token);",
          "44:         emit BalanceOf(token, address(this), IERC20Upgradeable(token).balanceOf(address(this)));",
          "45:         emit TotalSupply(token, IERC20Upgradeable(token).totalSupply());",
          "47:         if (data.length > 0) {",
          "49:             AddressUpgradeable.functionCall(token, data);",
          "50:         }",
          "52:         if (_enableApprove) {",
          "53:             IERC20Upgradeable(token).approve(token, amount + fee);",
          "54:         }",
          "56:         return _enableReturn ? _RETURN_VALUE : bytes32(0);",
          "57:     }",
          "64:     uint256[49] private __gap;",
          "65: }",
          "",
          "---------------"
        ],
        "contracts/mocks/ERC4626MockUpgradeable.sol||contracts/mocks/ERC4626MockUpgradeable.sol": [
          "File: contracts/mocks/ERC4626MockUpgradeable.sol -> contracts/mocks/ERC4626MockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: pragma solidity ^0.8.0;",
          "4: import \"../token/ERC20/extensions/ERC4626Upgradeable.sol\";",
          "5: import \"../proxy/utils/Initializable.sol\";",
          "7: contract ERC4626MockUpgradeable is Initializable, ERC4626Upgradeable {",
          "8:     function __ERC4626Mock_init(address underlying) internal onlyInitializing {",
          "9:         __ERC20_init_unchained(\"ERC4626Mock\", \"E4626M\");",
          "10:         __ERC4626_init_unchained(IERC20Upgradeable(underlying));",
          "11:     }",
          "13:     function __ERC4626Mock_init_unchained(address) internal onlyInitializing {}",
          "15:     function mint(address account, uint256 amount) external {",
          "16:         _mint(account, amount);",
          "17:     }",
          "19:     function burn(address account, uint256 amount) external {",
          "20:         _burn(account, amount);",
          "21:     }",
          "28:     uint256[50] private __gap;",
          "29: }",
          "",
          "---------------"
        ],
        "contracts/mocks/EtherReceiverMockUpgradeable.sol||contracts/mocks/EtherReceiverMockUpgradeable.sol": [
          "File: contracts/mocks/EtherReceiverMockUpgradeable.sol -> contracts/mocks/EtherReceiverMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "4: import \"../proxy/utils/Initializable.sol\";",
          "6: contract EtherReceiverMockUpgradeable is Initializable {",
          "7:     function __EtherReceiverMock_init() internal onlyInitializing {",
          "8:     }",
          "10:     function __EtherReceiverMock_init_unchained() internal onlyInitializing {",
          "11:     }",
          "12:     bool private _acceptEther;",
          "14:     function setAcceptEther(bool acceptEther) public {",
          "15:         _acceptEther = acceptEther;",
          "16:     }",
          "18:     receive() external payable {",
          "19:         if (!_acceptEther) {",
          "20:             revert();",
          "21:         }",
          "22:     }",
          "29:     uint256[49] private __gap;",
          "30: }",
          "",
          "---------------"
        ],
        "contracts/mocks/InitializableMock.sol||contracts/mocks/InitializableMock.sol": [
          "File: contracts/mocks/InitializableMock.sol -> contracts/mocks/InitializableMock.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../proxy/utils/Initializable.sol\";",
          "11: contract InitializableMock is Initializable {",
          "12:     bool public initializerRan;",
          "13:     bool public onlyInitializingRan;",
          "14:     uint256 public x;",
          "16:     function isInitializing() public view returns (bool) {",
          "17:         return _isInitializing();",
          "18:     }",
          "20:     function initialize() public initializer {",
          "21:         initializerRan = true;",
          "22:     }",
          "24:     function initializeOnlyInitializing() public onlyInitializing {",
          "25:         onlyInitializingRan = true;",
          "26:     }",
          "28:     function initializerNested() public initializer {",
          "29:         initialize();",
          "30:     }",
          "32:     function onlyInitializingNested() public initializer {",
          "33:         initializeOnlyInitializing();",
          "34:     }",
          "36:     function initializeWithX(uint256 _x) public payable initializer {",
          "37:         x = _x;",
          "38:     }",
          "40:     function nonInitializable(uint256 _x) public payable {",
          "41:         x = _x;",
          "42:     }",
          "44:     function fail() public pure {",
          "45:         require(false, \"InitializableMock forced failure\");",
          "46:     }",
          "47: }",
          "49: contract ConstructorInitializableMock is Initializable {",
          "50:     bool public initializerRan;",
          "51:     bool public onlyInitializingRan;",
          "53:     constructor() initializer {",
          "54:         initialize();",
          "55:         initializeOnlyInitializing();",
          "56:     }",
          "58:     function initialize() public initializer {",
          "59:         initializerRan = true;",
          "60:     }",
          "62:     function initializeOnlyInitializing() public onlyInitializing {",
          "63:         onlyInitializingRan = true;",
          "64:     }",
          "65: }",
          "67: contract ChildConstructorInitializableMock is ConstructorInitializableMock {",
          "68:     bool public childInitializerRan;",
          "70:     constructor() initializer {",
          "71:         childInitialize();",
          "72:     }",
          "74:     function childInitialize() public initializer {",
          "75:         childInitializerRan = true;",
          "76:     }",
          "77: }",
          "79: contract ReinitializerMock is Initializable {",
          "80:     uint256 public counter;",
          "82:     function getInitializedVersion() public view returns (uint8) {",
          "83:         return _getInitializedVersion();",
          "84:     }",
          "86:     function initialize() public initializer {",
          "87:         doStuff();",
          "88:     }",
          "90:     function reinitialize(uint8 i) public reinitializer(i) {",
          "91:         doStuff();",
          "92:     }",
          "94:     function nestedReinitialize(uint8 i, uint8 j) public reinitializer(i) {",
          "95:         reinitialize(j);",
          "96:     }",
          "98:     function chainReinitialize(uint8 i, uint8 j) public {",
          "99:         reinitialize(i);",
          "100:         reinitialize(j);",
          "101:     }",
          "103:     function disableInitializers() public {",
          "104:         _disableInitializers();",
          "105:     }",
          "107:     function doStuff() public onlyInitializing {",
          "108:         counter++;",
          "109:     }",
          "110: }",
          "112: contract DisableNew is Initializable {",
          "113:     constructor() {",
          "114:         _disableInitializers();",
          "115:     }",
          "116: }",
          "118: contract DisableOld is Initializable {",
          "119:     constructor() initializer {}",
          "120: }",
          "122: contract DisableBad1 is DisableNew, DisableOld {}",
          "124: contract DisableBad2 is Initializable {",
          "125:     constructor() initializer {",
          "126:         _disableInitializers();",
          "127:     }",
          "128: }",
          "130: contract DisableOk is DisableOld, DisableNew {}",
          "",
          "---------------"
        ],
        "contracts/mocks/MulticallTestUpgradeable.sol||contracts/mocks/MulticallTestUpgradeable.sol": [
          "File: contracts/mocks/MulticallTestUpgradeable.sol -> contracts/mocks/MulticallTestUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"./token/ERC20MulticallMockUpgradeable.sol\";",
          "6: import \"../proxy/utils/Initializable.sol\";",
          "8: contract MulticallTestUpgradeable is Initializable {",
          "9:     function __MulticallTest_init() internal onlyInitializing {",
          "10:     }",
          "12:     function __MulticallTest_init_unchained() internal onlyInitializing {",
          "13:     }",
          "14:     function checkReturnValues(",
          "15:         ERC20MulticallMockUpgradeable multicallToken,",
          "16:         address[] calldata recipients,",
          "17:         uint256[] calldata amounts",
          "18:     ) external {",
          "19:         bytes[] memory calls = new bytes[](recipients.length);",
          "20:         for (uint256 i = 0; i < recipients.length; i++) {",
          "21:             calls[i] = abi.encodeWithSignature(\"transfer(address,uint256)\", recipients[i], amounts[i]);",
          "22:         }",
          "24:         bytes[] memory results = multicallToken.multicall(calls);",
          "25:         for (uint256 i = 0; i < results.length; i++) {",
          "26:             require(abi.decode(results[i], (bool)));",
          "27:         }",
          "28:     }",
          "35:     uint256[50] private __gap;",
          "36: }",
          "",
          "---------------"
        ],
        "contracts/mocks/MultipleInheritanceInitializableMocks.sol||contracts/mocks/MultipleInheritanceInitializableMocks.sol": [
          "File: contracts/mocks/MultipleInheritanceInitializableMocks.sol -> contracts/mocks/MultipleInheritanceInitializableMocks.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../proxy/utils/Initializable.sol\";",
          "21: contract SampleHuman is Initializable {",
          "22:     bool public isHuman;",
          "24:     function initialize() public initializer {",
          "25:         __SampleHuman_init();",
          "26:     }",
          "29:     function __SampleHuman_init() internal onlyInitializing {",
          "30:         __SampleHuman_init_unchained();",
          "31:     }",
          "34:     function __SampleHuman_init_unchained() internal onlyInitializing {",
          "35:         isHuman = true;",
          "36:     }",
          "37: }",
          "42: contract SampleMother is Initializable, SampleHuman {",
          "43:     uint256 public mother;",
          "45:     function initialize(uint256 value) public initializer {",
          "46:         __SampleMother_init(value);",
          "47:     }",
          "50:     function __SampleMother_init(uint256 value) internal onlyInitializing {",
          "51:         __SampleHuman_init();",
          "52:         __SampleMother_init_unchained(value);",
          "53:     }",
          "56:     function __SampleMother_init_unchained(uint256 value) internal onlyInitializing {",
          "57:         mother = value;",
          "58:     }",
          "59: }",
          "64: contract SampleGramps is Initializable, SampleHuman {",
          "65:     string public gramps;",
          "67:     function initialize(string memory value) public initializer {",
          "68:         __SampleGramps_init(value);",
          "69:     }",
          "72:     function __SampleGramps_init(string memory value) internal onlyInitializing {",
          "73:         __SampleHuman_init();",
          "74:         __SampleGramps_init_unchained(value);",
          "75:     }",
          "78:     function __SampleGramps_init_unchained(string memory value) internal onlyInitializing {",
          "79:         gramps = value;",
          "80:     }",
          "81: }",
          "86: contract SampleFather is Initializable, SampleGramps {",
          "87:     uint256 public father;",
          "89:     function initialize(string memory _gramps, uint256 _father) public initializer {",
          "90:         __SampleFather_init(_gramps, _father);",
          "91:     }",
          "94:     function __SampleFather_init(string memory _gramps, uint256 _father) internal onlyInitializing {",
          "95:         __SampleGramps_init(_gramps);",
          "96:         __SampleFather_init_unchained(_father);",
          "97:     }",
          "100:     function __SampleFather_init_unchained(uint256 _father) internal onlyInitializing {",
          "101:         father = _father;",
          "102:     }",
          "103: }",
          "108: contract SampleChild is Initializable, SampleMother, SampleFather {",
          "109:     uint256 public child;",
          "111:     function initialize(uint256 _mother, string memory _gramps, uint256 _father, uint256 _child) public initializer {",
          "112:         __SampleChild_init(_mother, _gramps, _father, _child);",
          "113:     }",
          "116:     function __SampleChild_init(",
          "117:         uint256 _mother,",
          "118:         string memory _gramps,",
          "119:         uint256 _father,",
          "120:         uint256 _child",
          "121:     ) internal onlyInitializing {",
          "122:         __SampleMother_init(_mother);",
          "123:         __SampleFather_init(_gramps, _father);",
          "124:         __SampleChild_init_unchained(_child);",
          "125:     }",
          "128:     function __SampleChild_init_unchained(uint256 _child) internal onlyInitializing {",
          "129:         child = _child;",
          "130:     }",
          "131: }",
          "",
          "---------------"
        ],
        "contracts/mocks/PausableMockUpgradeable.sol||contracts/mocks/PausableMockUpgradeable.sol": [
          "File: contracts/mocks/PausableMockUpgradeable.sol -> contracts/mocks/PausableMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../security/PausableUpgradeable.sol\";",
          "6: import \"../proxy/utils/Initializable.sol\";",
          "8: contract PausableMockUpgradeable is Initializable, PausableUpgradeable {",
          "9:     bool public drasticMeasureTaken;",
          "10:     uint256 public count;",
          "12:     function __PausableMock_init() internal onlyInitializing {",
          "13:         __Pausable_init_unchained();",
          "14:         __PausableMock_init_unchained();",
          "15:     }",
          "17:     function __PausableMock_init_unchained() internal onlyInitializing {",
          "18:         drasticMeasureTaken = false;",
          "19:         count = 0;",
          "20:     }",
          "22:     function normalProcess() external whenNotPaused {",
          "23:         count++;",
          "24:     }",
          "26:     function drasticMeasure() external whenPaused {",
          "27:         drasticMeasureTaken = true;",
          "28:     }",
          "30:     function pause() external {",
          "31:         _pause();",
          "32:     }",
          "34:     function unpause() external {",
          "35:         _unpause();",
          "36:     }",
          "43:     uint256[48] private __gap;",
          "44: }",
          "",
          "---------------"
        ],
        "contracts/mocks/PullPaymentMockUpgradeable.sol||contracts/mocks/PullPaymentMockUpgradeable.sol": [
          "File: contracts/mocks/PullPaymentMockUpgradeable.sol -> contracts/mocks/PullPaymentMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../security/PullPaymentUpgradeable.sol\";",
          "6: import \"../proxy/utils/Initializable.sol\";",
          "9: contract PullPaymentMockUpgradeable is Initializable, PullPaymentUpgradeable {",
          "10:     function __PullPaymentMock_init() internal onlyInitializing {",
          "11:         __PullPayment_init_unchained();",
          "12:     }",
          "14:     function __PullPaymentMock_init_unchained() internal onlyInitializing {}",
          "17:     function callTransfer(address dest, uint256 amount) public {",
          "18:         _asyncTransfer(dest, amount);",
          "19:     }",
          "26:     uint256[50] private __gap;",
          "27: }",
          "",
          "---------------"
        ],
        "contracts/mocks/ReentrancyAttackUpgradeable.sol||contracts/mocks/ReentrancyAttackUpgradeable.sol": [
          "File: contracts/mocks/ReentrancyAttackUpgradeable.sol -> contracts/mocks/ReentrancyAttackUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../utils/ContextUpgradeable.sol\";",
          "6: import \"../proxy/utils/Initializable.sol\";",
          "8: contract ReentrancyAttackUpgradeable is Initializable, ContextUpgradeable {",
          "9:     function __ReentrancyAttack_init() internal onlyInitializing {",
          "10:     }",
          "12:     function __ReentrancyAttack_init_unchained() internal onlyInitializing {",
          "13:     }",
          "14:     function callSender(bytes4 data) public {",
          "15:         (bool success, ) = _msgSender().call(abi.encodeWithSelector(data));",
          "16:         require(success, \"ReentrancyAttack: failed call\");",
          "17:     }",
          "24:     uint256[50] private __gap;",
          "25: }",
          "",
          "---------------"
        ],
        "contracts/mocks/ReentrancyMockUpgradeable.sol||contracts/mocks/ReentrancyMockUpgradeable.sol": [
          "File: contracts/mocks/ReentrancyMockUpgradeable.sol -> contracts/mocks/ReentrancyMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../security/ReentrancyGuardUpgradeable.sol\";",
          "6: import \"./ReentrancyAttackUpgradeable.sol\";",
          "7: import \"../proxy/utils/Initializable.sol\";",
          "9: contract ReentrancyMockUpgradeable is Initializable, ReentrancyGuardUpgradeable {",
          "10:     uint256 public counter;",
          "12:     function __ReentrancyMock_init() internal onlyInitializing {",
          "13:         __ReentrancyGuard_init_unchained();",
          "14:         __ReentrancyMock_init_unchained();",
          "15:     }",
          "17:     function __ReentrancyMock_init_unchained() internal onlyInitializing {",
          "18:         counter = 0;",
          "19:     }",
          "21:     function callback() external nonReentrant {",
          "22:         _count();",
          "23:     }",
          "25:     function countLocalRecursive(uint256 n) public nonReentrant {",
          "26:         if (n > 0) {",
          "27:             _count();",
          "28:             countLocalRecursive(n - 1);",
          "29:         }",
          "30:     }",
          "32:     function countThisRecursive(uint256 n) public nonReentrant {",
          "33:         if (n > 0) {",
          "34:             _count();",
          "35:             (bool success, ) = address(this).call(abi.encodeWithSignature(\"countThisRecursive(uint256)\", n - 1));",
          "36:             require(success, \"ReentrancyMock: failed call\");",
          "37:         }",
          "38:     }",
          "40:     function countAndCall(ReentrancyAttackUpgradeable attacker) public nonReentrant {",
          "41:         _count();",
          "42:         bytes4 func = bytes4(keccak256(\"callback()\"));",
          "43:         attacker.callSender(func);",
          "44:     }",
          "46:     function _count() private {",
          "47:         counter += 1;",
          "48:     }",
          "50:     function guardedCheckEntered() public nonReentrant {",
          "51:         require(_reentrancyGuardEntered());",
          "52:     }",
          "54:     function unguardedCheckNotEntered() public view {",
          "55:         require(!_reentrancyGuardEntered());",
          "56:     }",
          "63:     uint256[49] private __gap;",
          "64: }",
          "",
          "---------------"
        ],
        "contracts/mocks/RegressionImplementation.sol||contracts/mocks/RegressionImplementation.sol": [
          "File: contracts/mocks/RegressionImplementation.sol -> contracts/mocks/RegressionImplementation.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../proxy/utils/Initializable.sol\";",
          "7: contract Implementation1 is Initializable {",
          "8:     uint256 internal _value;",
          "10:     function initialize() public initializer {}",
          "12:     function setValue(uint256 _number) public {",
          "13:         _value = _number;",
          "14:     }",
          "15: }",
          "17: contract Implementation2 is Initializable {",
          "18:     uint256 internal _value;",
          "20:     function initialize() public initializer {}",
          "22:     function setValue(uint256 _number) public {",
          "23:         _value = _number;",
          "24:     }",
          "26:     function getValue() public view returns (uint256) {",
          "27:         return _value;",
          "28:     }",
          "29: }",
          "31: contract Implementation3 is Initializable {",
          "32:     uint256 internal _value;",
          "34:     function initialize() public initializer {}",
          "36:     function setValue(uint256 _number) public {",
          "37:         _value = _number;",
          "38:     }",
          "40:     function getValue(uint256 _number) public view returns (uint256) {",
          "41:         return _value + _number;",
          "42:     }",
          "43: }",
          "45: contract Implementation4 is Initializable {",
          "46:     uint256 internal _value;",
          "48:     function initialize() public initializer {}",
          "50:     function setValue(uint256 _number) public {",
          "51:         _value = _number;",
          "52:     }",
          "54:     function getValue() public view returns (uint256) {",
          "55:         return _value;",
          "56:     }",
          "58:     fallback() external {",
          "59:         _value = 1;",
          "60:     }",
          "61: }",
          "",
          "---------------"
        ],
        "contracts/mocks/SafeMathMemoryCheckUpgradeable.sol||contracts/mocks/SafeMathMemoryCheckUpgradeable.sol": [
          "File: contracts/mocks/SafeMathMemoryCheckUpgradeable.sol -> contracts/mocks/SafeMathMemoryCheckUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../utils/math/SafeMathUpgradeable.sol\";",
          "7: library SafeMathMemoryCheckUpgradeable {",
          "8:     function addMemoryCheck() internal pure returns (uint256 mem) {",
          "9:         uint256 length = 32;",
          "10:         assembly {",
          "11:             mem := mload(0x40)",
          "12:         }",
          "13:         for (uint256 i = 0; i < length; ++i) {",
          "14:             SafeMathUpgradeable.add(1, 1);",
          "15:         }",
          "16:         assembly {",
          "17:             mem := sub(mload(0x40), mem)",
          "18:         }",
          "19:     }",
          "21:     function subMemoryCheck() internal pure returns (uint256 mem) {",
          "22:         uint256 length = 32;",
          "23:         assembly {",
          "24:             mem := mload(0x40)",
          "25:         }",
          "26:         for (uint256 i = 0; i < length; ++i) {",
          "27:             SafeMathUpgradeable.sub(1, 1);",
          "28:         }",
          "29:         assembly {",
          "30:             mem := sub(mload(0x40), mem)",
          "31:         }",
          "32:     }",
          "34:     function mulMemoryCheck() internal pure returns (uint256 mem) {",
          "35:         uint256 length = 32;",
          "36:         assembly {",
          "37:             mem := mload(0x40)",
          "38:         }",
          "39:         for (uint256 i = 0; i < length; ++i) {",
          "40:             SafeMathUpgradeable.mul(1, 1);",
          "41:         }",
          "42:         assembly {",
          "43:             mem := sub(mload(0x40), mem)",
          "44:         }",
          "45:     }",
          "47:     function divMemoryCheck() internal pure returns (uint256 mem) {",
          "48:         uint256 length = 32;",
          "49:         assembly {",
          "50:             mem := mload(0x40)",
          "51:         }",
          "52:         for (uint256 i = 0; i < length; ++i) {",
          "53:             SafeMathUpgradeable.div(1, 1);",
          "54:         }",
          "55:         assembly {",
          "56:             mem := sub(mload(0x40), mem)",
          "57:         }",
          "58:     }",
          "60:     function modMemoryCheck() internal pure returns (uint256 mem) {",
          "61:         uint256 length = 32;",
          "62:         assembly {",
          "63:             mem := mload(0x40)",
          "64:         }",
          "65:         for (uint256 i = 0; i < length; ++i) {",
          "66:             SafeMathUpgradeable.mod(1, 1);",
          "67:         }",
          "68:         assembly {",
          "69:             mem := sub(mload(0x40), mem)",
          "70:         }",
          "71:     }",
          "72: }",
          "",
          "---------------"
        ],
        "contracts/mocks/SingleInheritanceInitializableMocks.sol||contracts/mocks/SingleInheritanceInitializableMocks.sol": [
          "File: contracts/mocks/SingleInheritanceInitializableMocks.sol -> contracts/mocks/SingleInheritanceInitializableMocks.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../proxy/utils/Initializable.sol\";",
          "11: contract MigratableMockV1 is Initializable {",
          "12:     uint256 public x;",
          "14:     function initialize(uint256 value) public payable initializer {",
          "15:         x = value;",
          "16:     }",
          "17: }",
          "23: contract MigratableMockV2 is MigratableMockV1 {",
          "24:     bool internal _migratedV2;",
          "25:     uint256 public y;",
          "27:     function migrate(uint256 value, uint256 anotherValue) public payable {",
          "28:         require(!_migratedV2);",
          "29:         x = value;",
          "30:         y = anotherValue;",
          "31:         _migratedV2 = true;",
          "32:     }",
          "33: }",
          "39: contract MigratableMockV3 is MigratableMockV2 {",
          "40:     bool internal _migratedV3;",
          "42:     function migrate() public payable {",
          "43:         require(!_migratedV3);",
          "44:         uint256 oldX = x;",
          "45:         x = y;",
          "46:         y = oldX;",
          "47:         _migratedV3 = true;",
          "48:     }",
          "49: }",
          "",
          "---------------"
        ],
        "contracts/mocks/StorageSlotMockUpgradeable.sol||contracts/mocks/StorageSlotMockUpgradeable.sol": [
          "File: contracts/mocks/StorageSlotMockUpgradeable.sol -> contracts/mocks/StorageSlotMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../utils/StorageSlotUpgradeable.sol\";",
          "6: import \"../proxy/utils/Initializable.sol\";",
          "8: contract StorageSlotMockUpgradeable is Initializable {",
          "9:     function __StorageSlotMock_init() internal onlyInitializing {",
          "10:     }",
          "12:     function __StorageSlotMock_init_unchained() internal onlyInitializing {",
          "13:     }",
          "14:     using StorageSlotUpgradeable for *;",
          "16:     function setBoolean(bytes32 slot, bool value) public {",
          "17:         slot.getBooleanSlot().value = value;",
          "18:     }",
          "20:     function setAddress(bytes32 slot, address value) public {",
          "21:         slot.getAddressSlot().value = value;",
          "22:     }",
          "24:     function setBytes32(bytes32 slot, bytes32 value) public {",
          "25:         slot.getBytes32Slot().value = value;",
          "26:     }",
          "28:     function setUint256(bytes32 slot, uint256 value) public {",
          "29:         slot.getUint256Slot().value = value;",
          "30:     }",
          "32:     function getBoolean(bytes32 slot) public view returns (bool) {",
          "33:         return slot.getBooleanSlot().value;",
          "34:     }",
          "36:     function getAddress(bytes32 slot) public view returns (address) {",
          "37:         return slot.getAddressSlot().value;",
          "38:     }",
          "40:     function getBytes32(bytes32 slot) public view returns (bytes32) {",
          "41:         return slot.getBytes32Slot().value;",
          "42:     }",
          "44:     function getUint256(bytes32 slot) public view returns (uint256) {",
          "45:         return slot.getUint256Slot().value;",
          "46:     }",
          "48:     mapping(uint256 => string) public stringMap;",
          "50:     function setString(bytes32 slot, string calldata value) public {",
          "51:         slot.getStringSlot().value = value;",
          "52:     }",
          "54:     function setStringStorage(uint256 key, string calldata value) public {",
          "55:         stringMap[key].getStringSlot().value = value;",
          "56:     }",
          "58:     function getString(bytes32 slot) public view returns (string memory) {",
          "59:         return slot.getStringSlot().value;",
          "60:     }",
          "62:     function getStringStorage(uint256 key) public view returns (string memory) {",
          "63:         return stringMap[key].getStringSlot().value;",
          "64:     }",
          "66:     mapping(uint256 => bytes) public bytesMap;",
          "68:     function setBytes(bytes32 slot, bytes calldata value) public {",
          "69:         slot.getBytesSlot().value = value;",
          "70:     }",
          "72:     function setBytesStorage(uint256 key, bytes calldata value) public {",
          "73:         bytesMap[key].getBytesSlot().value = value;",
          "74:     }",
          "76:     function getBytes(bytes32 slot) public view returns (bytes memory) {",
          "77:         return slot.getBytesSlot().value;",
          "78:     }",
          "80:     function getBytesStorage(uint256 key) public view returns (bytes memory) {",
          "81:         return bytesMap[key].getBytesSlot().value;",
          "82:     }",
          "89:     uint256[48] private __gap;",
          "90: }",
          "",
          "---------------"
        ],
        "contracts/mocks/TimelockReentrantUpgradeable.sol||contracts/mocks/TimelockReentrantUpgradeable.sol": [
          "File: contracts/mocks/TimelockReentrantUpgradeable.sol -> contracts/mocks/TimelockReentrantUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: pragma solidity ^0.8.0;",
          "4: import \"../utils/AddressUpgradeable.sol\";",
          "5: import \"../proxy/utils/Initializable.sol\";",
          "7: contract TimelockReentrantUpgradeable is Initializable {",
          "8:     function __TimelockReentrant_init() internal onlyInitializing {",
          "9:     }",
          "11:     function __TimelockReentrant_init_unchained() internal onlyInitializing {",
          "12:     }",
          "13:     address private _reenterTarget;",
          "14:     bytes private _reenterData;",
          "15:     bool _reentered;",
          "17:     function disableReentrancy() external {",
          "18:         _reentered = true;",
          "19:     }",
          "21:     function enableRentrancy(address target, bytes calldata data) external {",
          "22:         _reenterTarget = target;",
          "23:         _reenterData = data;",
          "24:     }",
          "26:     function reenter() external {",
          "27:         if (!_reentered) {",
          "28:             _reentered = true;",
          "29:             AddressUpgradeable.functionCall(_reenterTarget, _reenterData);",
          "30:         }",
          "31:     }",
          "38:     uint256[47] private __gap;",
          "39: }",
          "",
          "---------------"
        ],
        "contracts/mocks/TimersBlockNumberImplUpgradeable.sol||contracts/mocks/TimersBlockNumberImplUpgradeable.sol": [
          "File: contracts/mocks/TimersBlockNumberImplUpgradeable.sol -> contracts/mocks/TimersBlockNumberImplUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../utils/TimersUpgradeable.sol\";",
          "6: import \"../proxy/utils/Initializable.sol\";",
          "8: contract TimersBlockNumberImplUpgradeable is Initializable {",
          "9:     function __TimersBlockNumberImpl_init() internal onlyInitializing {",
          "10:     }",
          "12:     function __TimersBlockNumberImpl_init_unchained() internal onlyInitializing {",
          "13:     }",
          "14:     using TimersUpgradeable for TimersUpgradeable.BlockNumber;",
          "16:     TimersUpgradeable.BlockNumber private _timer;",
          "18:     function getDeadline() public view returns (uint64) {",
          "19:         return _timer.getDeadline();",
          "20:     }",
          "22:     function setDeadline(uint64 timestamp) public {",
          "23:         _timer.setDeadline(timestamp);",
          "24:     }",
          "26:     function reset() public {",
          "27:         _timer.reset();",
          "28:     }",
          "30:     function isUnset() public view returns (bool) {",
          "31:         return _timer.isUnset();",
          "32:     }",
          "34:     function isStarted() public view returns (bool) {",
          "35:         return _timer.isStarted();",
          "36:     }",
          "38:     function isPending() public view returns (bool) {",
          "39:         return _timer.isPending();",
          "40:     }",
          "42:     function isExpired() public view returns (bool) {",
          "43:         return _timer.isExpired();",
          "44:     }",
          "51:     uint256[49] private __gap;",
          "52: }",
          "",
          "---------------"
        ],
        "contracts/mocks/TimersTimestampImplUpgradeable.sol||contracts/mocks/TimersTimestampImplUpgradeable.sol": [
          "File: contracts/mocks/TimersTimestampImplUpgradeable.sol -> contracts/mocks/TimersTimestampImplUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../utils/TimersUpgradeable.sol\";",
          "6: import \"../proxy/utils/Initializable.sol\";",
          "8: contract TimersTimestampImplUpgradeable is Initializable {",
          "9:     function __TimersTimestampImpl_init() internal onlyInitializing {",
          "10:     }",
          "12:     function __TimersTimestampImpl_init_unchained() internal onlyInitializing {",
          "13:     }",
          "14:     using TimersUpgradeable for TimersUpgradeable.Timestamp;",
          "16:     TimersUpgradeable.Timestamp private _timer;",
          "18:     function getDeadline() public view returns (uint64) {",
          "19:         return _timer.getDeadline();",
          "20:     }",
          "22:     function setDeadline(uint64 timestamp) public {",
          "23:         _timer.setDeadline(timestamp);",
          "24:     }",
          "26:     function reset() public {",
          "27:         _timer.reset();",
          "28:     }",
          "30:     function isUnset() public view returns (bool) {",
          "31:         return _timer.isUnset();",
          "32:     }",
          "34:     function isStarted() public view returns (bool) {",
          "35:         return _timer.isStarted();",
          "36:     }",
          "38:     function isPending() public view returns (bool) {",
          "39:         return _timer.isPending();",
          "40:     }",
          "42:     function isExpired() public view returns (bool) {",
          "43:         return _timer.isExpired();",
          "44:     }",
          "51:     uint256[49] private __gap;",
          "52: }",
          "",
          "---------------"
        ],
        "contracts/mocks/VotesMockUpgradeable.sol||contracts/mocks/VotesMockUpgradeable.sol": [
          "File: contracts/mocks/VotesMockUpgradeable.sol -> contracts/mocks/VotesMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../governance/utils/VotesUpgradeable.sol\";",
          "6: import \"../proxy/utils/Initializable.sol\";",
          "8: abstract contract VotesMockUpgradeable is Initializable, VotesUpgradeable {",
          "9:     function __VotesMock_init() internal onlyInitializing {",
          "10:     }",
          "12:     function __VotesMock_init_unchained() internal onlyInitializing {",
          "13:     }",
          "14:     mapping(address => uint256) private _balances;",
          "15:     mapping(uint256 => address) private _owners;",
          "17:     function getTotalSupply() public view returns (uint256) {",
          "18:         return _getTotalSupply();",
          "19:     }",
          "21:     function delegate(address account, address newDelegation) public {",
          "22:         return _delegate(account, newDelegation);",
          "23:     }",
          "25:     function _getVotingUnits(address account) internal view override returns (uint256) {",
          "26:         return _balances[account];",
          "27:     }",
          "29:     function _mint(address account, uint256 voteId) internal {",
          "30:         _balances[account] += 1;",
          "31:         _owners[voteId] = account;",
          "32:         _transferVotingUnits(address(0), account, 1);",
          "33:     }",
          "35:     function _burn(uint256 voteId) internal {",
          "36:         address owner = _owners[voteId];",
          "37:         _balances[owner] -= 1;",
          "38:         _transferVotingUnits(owner, address(0), 1);",
          "39:     }",
          "46:     uint256[48] private __gap;",
          "47: }",
          "49: abstract contract VotesTimestampMockUpgradeable is Initializable, VotesMockUpgradeable {",
          "50:     function __VotesTimestampMock_init() internal onlyInitializing {",
          "51:     }",
          "53:     function __VotesTimestampMock_init_unchained() internal onlyInitializing {",
          "54:     }",
          "55:     function clock() public view override returns (uint48) {",
          "56:         return uint48(block.timestamp);",
          "57:     }",
          "60:     function CLOCK_MODE() public view virtual override returns (string memory) {",
          "61:         return \"mode=timestamp\";",
          "62:     }",
          "69:     uint256[50] private __gap;",
          "70: }",
          "",
          "---------------"
        ],
        "contracts/mocks/WithInit.sol||contracts/mocks/WithInit.sol": [
          "File: contracts/mocks/WithInit.sol -> contracts/mocks/WithInit.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: pragma solidity >=0.7 <0.9;",
          "3: pragma experimental ABIEncoderV2;",
          "5: import \"../access/AccessControlUpgradeable.sol\";",
          "7: contract AccessControlUpgradeableWithInit is AccessControlUpgradeable {",
          "8:     constructor() payable initializer {",
          "9:         __AccessControl_init();",
          "10:     }",
          "11: }",
          "12: import \"../access/AccessControlDefaultAdminRulesUpgradeable.sol\";",
          "14: contract AccessControlDefaultAdminRulesUpgradeableWithInit is AccessControlDefaultAdminRulesUpgradeable {",
          "15:     constructor(uint48 initialDelay, address initialDefaultAdmin) payable initializer {",
          "16:         __AccessControlDefaultAdminRules_init(initialDelay, initialDefaultAdmin);",
          "17:     }",
          "18: }",
          "19: import \"../access/AccessControlEnumerableUpgradeable.sol\";",
          "21: contract AccessControlEnumerableUpgradeableWithInit is AccessControlEnumerableUpgradeable {",
          "22:     constructor() payable initializer {",
          "23:         __AccessControlEnumerable_init();",
          "24:     }",
          "25: }",
          "26: import \"../access/OwnableUpgradeable.sol\";",
          "28: contract OwnableUpgradeableWithInit is OwnableUpgradeable {",
          "29:     constructor() payable initializer {",
          "30:         __Ownable_init();",
          "31:     }",
          "32: }",
          "33: import \"../access/Ownable2StepUpgradeable.sol\";",
          "35: contract Ownable2StepUpgradeableWithInit is Ownable2StepUpgradeable {",
          "36:     constructor() payable initializer {",
          "37:         __Ownable2Step_init();",
          "38:     }",
          "39: }",
          "40: import \"../crosschain/amb/CrossChainEnabledAMBUpgradeable.sol\";",
          "42: contract CrossChainEnabledAMBUpgradeableWithInit is CrossChainEnabledAMBUpgradeable {",
          "43:     constructor(address bridge) CrossChainEnabledAMBUpgradeable(bridge) payable initializer {",
          "45:     }",
          "46: }",
          "47: import \"../crosschain/arbitrum/CrossChainEnabledArbitrumL1Upgradeable.sol\";",
          "49: contract CrossChainEnabledArbitrumL1UpgradeableWithInit is CrossChainEnabledArbitrumL1Upgradeable {",
          "50:     constructor(address bridge) CrossChainEnabledArbitrumL1Upgradeable(bridge) payable initializer {",
          "52:     }",
          "53: }",
          "54: import \"../crosschain/arbitrum/CrossChainEnabledArbitrumL2Upgradeable.sol\";",
          "56: contract CrossChainEnabledArbitrumL2UpgradeableWithInit is CrossChainEnabledArbitrumL2Upgradeable {",
          "57:     constructor() payable initializer {",
          "58:         __CrossChainEnabledArbitrumL2_init();",
          "59:     }",
          "60: }",
          "61: import \"../crosschain/optimism/CrossChainEnabledOptimismUpgradeable.sol\";",
          "63: contract CrossChainEnabledOptimismUpgradeableWithInit is CrossChainEnabledOptimismUpgradeable {",
          "64:     constructor(address messenger) CrossChainEnabledOptimismUpgradeable(messenger) payable initializer {",
          "66:     }",
          "67: }",
          "68: import \"../crosschain/polygon/CrossChainEnabledPolygonChildUpgradeable.sol\";",
          "70: contract CrossChainEnabledPolygonChildUpgradeableWithInit is CrossChainEnabledPolygonChildUpgradeable {",
          "71:     constructor(address fxChild) CrossChainEnabledPolygonChildUpgradeable(fxChild) payable initializer {",
          "73:     }",
          "74: }",
          "75: import \"../finance/PaymentSplitterUpgradeable.sol\";",
          "77: contract PaymentSplitterUpgradeableWithInit is PaymentSplitterUpgradeable {",
          "78:     constructor(address[] memory payees, uint256[] memory shares_) payable initializer {",
          "79:         __PaymentSplitter_init(payees, shares_);",
          "80:     }",
          "81: }",
          "82: import \"../finance/VestingWalletUpgradeable.sol\";",
          "84: contract VestingWalletUpgradeableWithInit is VestingWalletUpgradeable {",
          "85:     constructor(address beneficiaryAddress, uint64 startTimestamp, uint64 durationSeconds) payable initializer {",
          "86:         __VestingWallet_init(beneficiaryAddress, startTimestamp, durationSeconds);",
          "87:     }",
          "88: }",
          "89: import \"../governance/TimelockControllerUpgradeable.sol\";",
          "91: contract TimelockControllerUpgradeableWithInit is TimelockControllerUpgradeable {",
          "92:     constructor(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) payable initializer {",
          "93:         __TimelockController_init(minDelay, proposers, executors, admin);",
          "94:     }",
          "95: }",
          "96: import \"../governance/TimelockControllerWith46MigrationUpgradeable.sol\";",
          "98: contract TimelockControllerWith46MigrationUpgradeableWithInit is TimelockControllerWith46MigrationUpgradeable {",
          "99:     constructor(",
          "100:         uint256 minDelay,",
          "101:         address[] memory proposers,",
          "102:         address[] memory executors,",
          "103:         address admin",
          "104:     ) payable initializer {",
          "105:         __TimelockControllerWith46Migration_init(minDelay, proposers, executors, admin);",
          "106:     }",
          "107: }",
          "108: import \"../metatx/ERC2771ContextUpgradeable.sol\";",
          "110: contract ERC2771ContextUpgradeableWithInit is ERC2771ContextUpgradeable {",
          "111:     constructor(address trustedForwarder) ERC2771ContextUpgradeable(trustedForwarder) payable initializer {",
          "113:     }",
          "114: }",
          "115: import \"../metatx/MinimalForwarderUpgradeable.sol\";",
          "117: contract MinimalForwarderUpgradeableWithInit is MinimalForwarderUpgradeable {",
          "118:     constructor() payable initializer {",
          "119:         __MinimalForwarder_init();",
          "120:     }",
          "121: }",
          "122: import \"./AccessControlCrossChainMockUpgradeable.sol\";",
          "124: contract AccessControlCrossChainMockUpgradeableWithInit is AccessControlCrossChainMockUpgradeable {",
          "125:     constructor() payable initializer {",
          "126:         __AccessControlCrossChainMock_init();",
          "127:     }",
          "128: }",
          "129: import \"./ArraysMockUpgradeable.sol\";",
          "131: contract Uint256ArraysMockUpgradeableWithInit is Uint256ArraysMockUpgradeable {",
          "132:     constructor(uint256[] memory array) payable initializer {",
          "133:         __Uint256ArraysMock_init(array);",
          "134:     }",
          "135: }",
          "136: import \"./ArraysMockUpgradeable.sol\";",
          "138: contract AddressArraysMockUpgradeableWithInit is AddressArraysMockUpgradeable {",
          "139:     constructor(address[] memory array) payable initializer {",
          "140:         __AddressArraysMock_init(array);",
          "141:     }",
          "142: }",
          "143: import \"./ArraysMockUpgradeable.sol\";",
          "145: contract Bytes32ArraysMockUpgradeableWithInit is Bytes32ArraysMockUpgradeable {",
          "146:     constructor(bytes32[] memory array) payable initializer {",
          "147:         __Bytes32ArraysMock_init(array);",
          "148:     }",
          "149: }",
          "150: import \"./CallReceiverMockUpgradeable.sol\";",
          "152: contract CallReceiverMockUpgradeableWithInit is CallReceiverMockUpgradeable {",
          "153:     constructor() payable initializer {",
          "154:         __CallReceiverMock_init();",
          "155:     }",
          "156: }",
          "157: import \"./compound/CompTimelockUpgradeable.sol\";",
          "159: contract CompTimelockUpgradeableWithInit is CompTimelockUpgradeable {",
          "160:     constructor(address admin_, uint256 delay_) payable initializer {",
          "161:         __CompTimelock_init(admin_, delay_);",
          "162:     }",
          "163: }",
          "164: import \"./ConditionalEscrowMockUpgradeable.sol\";",
          "166: contract ConditionalEscrowMockUpgradeableWithInit is ConditionalEscrowMockUpgradeable {",
          "167:     constructor() payable initializer {",
          "168:         __ConditionalEscrowMock_init();",
          "169:     }",
          "170: }",
          "171: import \"./ContextMockUpgradeable.sol\";",
          "173: contract ContextMockUpgradeableWithInit is ContextMockUpgradeable {",
          "174:     constructor() payable initializer {",
          "175:         __ContextMock_init();",
          "176:     }",
          "177: }",
          "178: import \"./ContextMockUpgradeable.sol\";",
          "180: contract ContextMockCallerUpgradeableWithInit is ContextMockCallerUpgradeable {",
          "181:     constructor() payable initializer {",
          "182:         __ContextMockCaller_init();",
          "183:     }",
          "184: }",
          "185: import \"./crosschain/bridgesUpgradeable.sol\";",
          "187: contract BaseRelayMockUpgradeableWithInit is BaseRelayMockUpgradeable {",
          "188:     constructor() payable initializer {",
          "189:         __BaseRelayMock_init();",
          "190:     }",
          "191: }",
          "192: import \"./crosschain/bridgesUpgradeable.sol\";",
          "194: contract BridgeAMBMockUpgradeableWithInit is BridgeAMBMockUpgradeable {",
          "195:     constructor() payable initializer {",
          "196:         __BridgeAMBMock_init();",
          "197:     }",
          "198: }",
          "199: import \"./crosschain/bridgesUpgradeable.sol\";",
          "201: contract BridgeArbitrumL1MockUpgradeableWithInit is BridgeArbitrumL1MockUpgradeable {",
          "202:     constructor() payable initializer {",
          "203:         __BridgeArbitrumL1Mock_init();",
          "204:     }",
          "205: }",
          "206: import \"./crosschain/bridgesUpgradeable.sol\";",
          "208: contract BridgeArbitrumL1InboxUpgradeableWithInit is BridgeArbitrumL1InboxUpgradeable {",
          "209:     constructor() payable initializer {",
          "210:         __BridgeArbitrumL1Inbox_init();",
          "211:     }",
          "212: }",
          "213: import \"./crosschain/bridgesUpgradeable.sol\";",
          "215: contract BridgeArbitrumL1OutboxUpgradeableWithInit is BridgeArbitrumL1OutboxUpgradeable {",
          "216:     constructor() payable initializer {",
          "217:         __BridgeArbitrumL1Outbox_init();",
          "218:     }",
          "219: }",
          "220: import \"./crosschain/bridgesUpgradeable.sol\";",
          "222: contract BridgeArbitrumL2MockUpgradeableWithInit is BridgeArbitrumL2MockUpgradeable {",
          "223:     constructor() payable initializer {",
          "224:         __BridgeArbitrumL2Mock_init();",
          "225:     }",
          "226: }",
          "227: import \"./crosschain/bridgesUpgradeable.sol\";",
          "229: contract BridgeOptimismMockUpgradeableWithInit is BridgeOptimismMockUpgradeable {",
          "230:     constructor() payable initializer {",
          "231:         __BridgeOptimismMock_init();",
          "232:     }",
          "233: }",
          "234: import \"./crosschain/bridgesUpgradeable.sol\";",
          "236: contract BridgePolygonChildMockUpgradeableWithInit is BridgePolygonChildMockUpgradeable {",
          "237:     constructor() payable initializer {",
          "238:         __BridgePolygonChildMock_init();",
          "239:     }",
          "240: }",
          "241: import \"./crosschain/receiversUpgradeable.sol\";",
          "243: contract CrossChainEnabledAMBMockUpgradeableWithInit is CrossChainEnabledAMBMockUpgradeable {",
          "244:     constructor(address bridge) CrossChainEnabledAMBMockUpgradeable(bridge) payable initializer {",
          "246:     }",
          "247: }",
          "248: import \"./crosschain/receiversUpgradeable.sol\";",
          "250: contract CrossChainEnabledArbitrumL1MockUpgradeableWithInit is CrossChainEnabledArbitrumL1MockUpgradeable {",
          "251:     constructor(address bridge) CrossChainEnabledArbitrumL1MockUpgradeable(bridge) payable initializer {",
          "253:     }",
          "254: }",
          "255: import \"./crosschain/receiversUpgradeable.sol\";",
          "257: contract CrossChainEnabledArbitrumL2MockUpgradeableWithInit is CrossChainEnabledArbitrumL2MockUpgradeable {",
          "258:     constructor() payable initializer {",
          "259:         __CrossChainEnabledArbitrumL2Mock_init();",
          "260:     }",
          "261: }",
          "262: import \"./crosschain/receiversUpgradeable.sol\";",
          "264: contract CrossChainEnabledOptimismMockUpgradeableWithInit is CrossChainEnabledOptimismMockUpgradeable {",
          "265:     constructor(address bridge) CrossChainEnabledOptimismMockUpgradeable(bridge) payable initializer {",
          "267:     }",
          "268: }",
          "269: import \"./crosschain/receiversUpgradeable.sol\";",
          "271: contract CrossChainEnabledPolygonChildMockUpgradeableWithInit is CrossChainEnabledPolygonChildMockUpgradeable {",
          "272:     constructor(address bridge) CrossChainEnabledPolygonChildMockUpgradeable(bridge) payable initializer {",
          "274:     }",
          "275: }",
          "276: import \"./DummyImplementationUpgradeable.sol\";",
          "278: contract DummyImplementationUpgradeableWithInit is DummyImplementationUpgradeable {",
          "279:     constructor() payable initializer {",
          "280:         __DummyImplementation_init();",
          "281:     }",
          "282: }",
          "283: import \"./DummyImplementationUpgradeable.sol\";",
          "285: contract DummyImplementationV2UpgradeableWithInit is DummyImplementationV2Upgradeable {",
          "286:     constructor() payable initializer {",
          "287:         __DummyImplementationV2_init();",
          "288:     }",
          "289: }",
          "290: import \"./ERC1271WalletMockUpgradeable.sol\";",
          "292: contract ERC1271WalletMockUpgradeableWithInit is ERC1271WalletMockUpgradeable {",
          "293:     constructor(address originalOwner) payable initializer {",
          "294:         __ERC1271WalletMock_init(originalOwner);",
          "295:     }",
          "296: }",
          "297: import \"./ERC1271WalletMockUpgradeable.sol\";",
          "299: contract ERC1271MaliciousMockUpgradeableWithInit is ERC1271MaliciousMockUpgradeable {",
          "300:     constructor() payable initializer {",
          "301:         __ERC1271MaliciousMock_init();",
          "302:     }",
          "303: }",
          "304: import \"./ERC165/ERC165MaliciousDataUpgradeable.sol\";",
          "306: contract ERC165MaliciousDataUpgradeableWithInit is ERC165MaliciousDataUpgradeable {",
          "307:     constructor() payable initializer {",
          "308:         __ERC165MaliciousData_init();",
          "309:     }",
          "310: }",
          "311: import \"./ERC165/ERC165MissingDataUpgradeable.sol\";",
          "313: contract ERC165MissingDataUpgradeableWithInit is ERC165MissingDataUpgradeable {",
          "314:     constructor() payable initializer {",
          "315:         __ERC165MissingData_init();",
          "316:     }",
          "317: }",
          "318: import \"./ERC165/ERC165NotSupportedUpgradeable.sol\";",
          "320: contract ERC165NotSupportedUpgradeableWithInit is ERC165NotSupportedUpgradeable {",
          "321:     constructor() payable initializer {",
          "322:         __ERC165NotSupported_init();",
          "323:     }",
          "324: }",
          "325: import \"./ERC165/ERC165ReturnBombUpgradeable.sol\";",
          "327: contract ERC165ReturnBombMockUpgradeableWithInit is ERC165ReturnBombMockUpgradeable {",
          "328:     constructor() payable initializer {",
          "329:         __ERC165ReturnBombMock_init();",
          "330:     }",
          "331: }",
          "332: import \"./ERC20MockUpgradeable.sol\";",
          "334: contract ERC20MockUpgradeableWithInit is ERC20MockUpgradeable {",
          "335:     constructor() payable initializer {",
          "336:         __ERC20Mock_init();",
          "337:     }",
          "338: }",
          "339: import \"./ERC20ReentrantUpgradeable.sol\";",
          "341: contract ERC20ReentrantUpgradeableWithInit is ERC20ReentrantUpgradeable {",
          "342:     constructor() payable initializer {",
          "343:         __ERC20Reentrant_init();",
          "344:     }",
          "345: }",
          "346: import \"./ERC2771ContextMockUpgradeable.sol\";",
          "348: contract ERC2771ContextMockUpgradeableWithInit is ERC2771ContextMockUpgradeable {",
          "349:     constructor(address trustedForwarder) ERC2771ContextMockUpgradeable(trustedForwarder) payable initializer {",
          "351:     }",
          "352: }",
          "353: import \"./ERC3156FlashBorrowerMockUpgradeable.sol\";",
          "355: contract ERC3156FlashBorrowerMockUpgradeableWithInit is ERC3156FlashBorrowerMockUpgradeable {",
          "356:     constructor(bool enableReturn, bool enableApprove) payable initializer {",
          "357:         __ERC3156FlashBorrowerMock_init(enableReturn, enableApprove);",
          "358:     }",
          "359: }",
          "360: import \"./ERC4626MockUpgradeable.sol\";",
          "362: contract ERC4626MockUpgradeableWithInit is ERC4626MockUpgradeable {",
          "363:     constructor(address underlying) payable initializer {",
          "364:         __ERC4626Mock_init(underlying);",
          "365:     }",
          "366: }",
          "367: import \"./EtherReceiverMockUpgradeable.sol\";",
          "369: contract EtherReceiverMockUpgradeableWithInit is EtherReceiverMockUpgradeable {",
          "370:     constructor() payable initializer {",
          "371:         __EtherReceiverMock_init();",
          "372:     }",
          "373: }",
          "374: import \"./MulticallTestUpgradeable.sol\";",
          "376: contract MulticallTestUpgradeableWithInit is MulticallTestUpgradeable {",
          "377:     constructor() payable initializer {",
          "378:         __MulticallTest_init();",
          "379:     }",
          "380: }",
          "381: import \"./PausableMockUpgradeable.sol\";",
          "383: contract PausableMockUpgradeableWithInit is PausableMockUpgradeable {",
          "384:     constructor() payable initializer {",
          "385:         __PausableMock_init();",
          "386:     }",
          "387: }",
          "388: import \"./proxy/BadBeaconUpgradeable.sol\";",
          "390: contract BadBeaconNoImplUpgradeableWithInit is BadBeaconNoImplUpgradeable {",
          "391:     constructor() payable initializer {",
          "392:         __BadBeaconNoImpl_init();",
          "393:     }",
          "394: }",
          "395: import \"./proxy/BadBeaconUpgradeable.sol\";",
          "397: contract BadBeaconNotContractUpgradeableWithInit is BadBeaconNotContractUpgradeable {",
          "398:     constructor() payable initializer {",
          "399:         __BadBeaconNotContract_init();",
          "400:     }",
          "401: }",
          "402: import \"./proxy/ClashingImplementationUpgradeable.sol\";",
          "404: contract ClashingImplementationUpgradeableWithInit is ClashingImplementationUpgradeable {",
          "405:     constructor() payable initializer {",
          "406:         __ClashingImplementation_init();",
          "407:     }",
          "408: }",
          "409: import \"./proxy/UUPSLegacyUpgradeable.sol\";",
          "411: contract UUPSUpgradeableLegacyMockUpgradeableWithInit is UUPSUpgradeableLegacyMockUpgradeable {",
          "412:     constructor() payable initializer {",
          "413:         __UUPSUpgradeableLegacyMock_init();",
          "414:     }",
          "415: }",
          "416: import \"./proxy/UUPSUpgradeableMockUpgradeable.sol\";",
          "418: contract NonUpgradeableMockUpgradeableWithInit is NonUpgradeableMockUpgradeable {",
          "419:     constructor() payable initializer {",
          "420:         __NonUpgradeableMock_init();",
          "421:     }",
          "422: }",
          "423: import \"./proxy/UUPSUpgradeableMockUpgradeable.sol\";",
          "425: contract UUPSUpgradeableMockUpgradeableWithInit is UUPSUpgradeableMockUpgradeable {",
          "426:     constructor() payable initializer {",
          "427:         __UUPSUpgradeableMock_init();",
          "428:     }",
          "429: }",
          "430: import \"./proxy/UUPSUpgradeableMockUpgradeable.sol\";",
          "432: contract UUPSUpgradeableUnsafeMockUpgradeableWithInit is UUPSUpgradeableUnsafeMockUpgradeable {",
          "433:     constructor() payable initializer {",
          "434:         __UUPSUpgradeableUnsafeMock_init();",
          "435:     }",
          "436: }",
          "437: import \"./PullPaymentMockUpgradeable.sol\";",
          "439: contract PullPaymentMockUpgradeableWithInit is PullPaymentMockUpgradeable {",
          "440:     constructor() payable initializer {",
          "441:         __PullPaymentMock_init();",
          "442:     }",
          "443: }",
          "444: import \"./ReentrancyAttackUpgradeable.sol\";",
          "446: contract ReentrancyAttackUpgradeableWithInit is ReentrancyAttackUpgradeable {",
          "447:     constructor() payable initializer {",
          "448:         __ReentrancyAttack_init();",
          "449:     }",
          "450: }",
          "451: import \"./ReentrancyMockUpgradeable.sol\";",
          "453: contract ReentrancyMockUpgradeableWithInit is ReentrancyMockUpgradeable {",
          "454:     constructor() payable initializer {",
          "455:         __ReentrancyMock_init();",
          "456:     }",
          "457: }",
          "458: import \"./StorageSlotMockUpgradeable.sol\";",
          "460: contract StorageSlotMockUpgradeableWithInit is StorageSlotMockUpgradeable {",
          "461:     constructor() payable initializer {",
          "462:         __StorageSlotMock_init();",
          "463:     }",
          "464: }",
          "465: import \"./TimelockReentrantUpgradeable.sol\";",
          "467: contract TimelockReentrantUpgradeableWithInit is TimelockReentrantUpgradeable {",
          "468:     constructor() payable initializer {",
          "469:         __TimelockReentrant_init();",
          "470:     }",
          "471: }",
          "472: import \"./TimersBlockNumberImplUpgradeable.sol\";",
          "474: contract TimersBlockNumberImplUpgradeableWithInit is TimersBlockNumberImplUpgradeable {",
          "475:     constructor() payable initializer {",
          "476:         __TimersBlockNumberImpl_init();",
          "477:     }",
          "478: }",
          "479: import \"./TimersTimestampImplUpgradeable.sol\";",
          "481: contract TimersTimestampImplUpgradeableWithInit is TimersTimestampImplUpgradeable {",
          "482:     constructor() payable initializer {",
          "483:         __TimersTimestampImpl_init();",
          "484:     }",
          "485: }",
          "486: import \"./token/ERC1155ReceiverMockUpgradeable.sol\";",
          "488: contract ERC1155ReceiverMockUpgradeableWithInit is ERC1155ReceiverMockUpgradeable {",
          "489:     constructor(bytes4 recRetval, bool recReverts, bytes4 batRetval, bool batReverts) payable initializer {",
          "490:         __ERC1155ReceiverMock_init(recRetval, recReverts, batRetval, batReverts);",
          "491:     }",
          "492: }",
          "493: import \"./token/ERC20ExcessDecimalsMockUpgradeable.sol\";",
          "495: contract ERC20ExcessDecimalsMockUpgradeableWithInit is ERC20ExcessDecimalsMockUpgradeable {",
          "496:     constructor() payable initializer {",
          "497:         __ERC20ExcessDecimalsMock_init();",
          "498:     }",
          "499: }",
          "500: import \"./token/ERC721ConsecutiveEnumerableMockUpgradeable.sol\";",
          "502: contract ERC721ConsecutiveEnumerableMockUpgradeableWithInit is ERC721ConsecutiveEnumerableMockUpgradeable {",
          "503:     constructor(",
          "504:         string memory name,",
          "505:         string memory symbol,",
          "506:         address[] memory receivers,",
          "507:         uint96[] memory amounts",
          "508:     ) payable initializer {",
          "509:         __ERC721ConsecutiveEnumerableMock_init(name, symbol, receivers, amounts);",
          "510:     }",
          "511: }",
          "512: import \"./token/ERC721ConsecutiveMockUpgradeable.sol\";",
          "514: contract ERC721ConsecutiveMockUpgradeableWithInit is ERC721ConsecutiveMockUpgradeable {",
          "515:     constructor(",
          "516:         string memory name,",
          "517:         string memory symbol,",
          "518:         address[] memory delegates,",
          "519:         address[] memory receivers,",
          "520:         uint96[] memory amounts",
          "521:     ) payable initializer {",
          "522:         __ERC721ConsecutiveMock_init(name, symbol, delegates, receivers, amounts);",
          "523:     }",
          "524: }",
          "525: import \"./token/ERC721ConsecutiveMockUpgradeable.sol\";",
          "527: contract ERC721ConsecutiveNoConstructorMintMockUpgradeableWithInit is ERC721ConsecutiveNoConstructorMintMockUpgradeable {",
          "528:     constructor(string memory name, string memory symbol) payable initializer {",
          "529:         __ERC721ConsecutiveNoConstructorMintMock_init(name, symbol);",
          "530:     }",
          "531: }",
          "532: import \"./token/ERC721ReceiverMockUpgradeable.sol\";",
          "534: contract ERC721ReceiverMockUpgradeableWithInit is ERC721ReceiverMockUpgradeable {",
          "535:     constructor(bytes4 retval, Error error) payable initializer {",
          "536:         __ERC721ReceiverMock_init(retval, error);",
          "537:     }",
          "538: }",
          "539: import \"./token/ERC777SenderRecipientMockUpgradeable.sol\";",
          "541: contract ERC777SenderRecipientMockUpgradeableWithInit is ERC777SenderRecipientMockUpgradeable {",
          "542:     constructor() payable initializer {",
          "543:         __ERC777SenderRecipientMock_init();",
          "544:     }",
          "545: }",
          "546: import \"./wizard/MyGovernor1Upgradeable.sol\";",
          "548: contract MyGovernor1UpgradeableWithInit is MyGovernor1Upgradeable {",
          "549:     constructor(",
          "550:         IVotesUpgradeable _token,",
          "551:         TimelockControllerUpgradeable _timelock",
          "552:     ) payable initializer {",
          "553:         __MyGovernor1_init(_token, _timelock);",
          "554:     }",
          "555: }",
          "556: import \"./wizard/MyGovernor2Upgradeable.sol\";",
          "558: contract MyGovernor2UpgradeableWithInit is MyGovernor2Upgradeable {",
          "559:     constructor(",
          "560:         IVotesUpgradeable _token,",
          "561:         TimelockControllerUpgradeable _timelock",
          "562:     ) payable initializer {",
          "563:         __MyGovernor2_init(_token, _timelock);",
          "564:     }",
          "565: }",
          "566: import \"./wizard/MyGovernor3Upgradeable.sol\";",
          "568: contract MyGovernorUpgradeableWithInit is MyGovernorUpgradeable {",
          "569:     constructor(",
          "570:         IVotesUpgradeable _token,",
          "571:         TimelockControllerUpgradeable _timelock",
          "572:     ) payable initializer {",
          "573:         __MyGovernor_init(_token, _timelock);",
          "574:     }",
          "575: }",
          "576: import \"../proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\";",
          "578: contract ERC1967UpgradeUpgradeableWithInit is ERC1967UpgradeUpgradeable {",
          "579:     constructor() payable initializer {",
          "580:         __ERC1967Upgrade_init();",
          "581:     }",
          "582: }",
          "583: import \"../security/PausableUpgradeable.sol\";",
          "585: contract PausableUpgradeableWithInit is PausableUpgradeable {",
          "586:     constructor() payable initializer {",
          "587:         __Pausable_init();",
          "588:     }",
          "589: }",
          "590: import \"../security/PullPaymentUpgradeable.sol\";",
          "592: contract PullPaymentUpgradeableWithInit is PullPaymentUpgradeable {",
          "593:     constructor() payable initializer {",
          "594:         __PullPayment_init();",
          "595:     }",
          "596: }",
          "597: import \"../security/ReentrancyGuardUpgradeable.sol\";",
          "599: contract ReentrancyGuardUpgradeableWithInit is ReentrancyGuardUpgradeable {",
          "600:     constructor() payable initializer {",
          "601:         __ReentrancyGuard_init();",
          "602:     }",
          "603: }",
          "604: import \"../token/common/ERC2981Upgradeable.sol\";",
          "606: contract ERC2981UpgradeableWithInit is ERC2981Upgradeable {",
          "607:     constructor() payable initializer {",
          "608:         __ERC2981_init();",
          "609:     }",
          "610: }",
          "611: import \"../token/ERC1155/ERC1155Upgradeable.sol\";",
          "613: contract ERC1155UpgradeableWithInit is ERC1155Upgradeable {",
          "614:     constructor(string memory uri_) payable initializer {",
          "615:         __ERC1155_init(uri_);",
          "616:     }",
          "617: }",
          "618: import \"../token/ERC1155/presets/ERC1155PresetMinterPauserUpgradeable.sol\";",
          "620: contract ERC1155PresetMinterPauserUpgradeableWithInit is ERC1155PresetMinterPauserUpgradeable {",
          "621:     constructor(string memory uri) payable initializer {",
          "622:         __ERC1155PresetMinterPauser_init(uri);",
          "623:     }",
          "624: }",
          "625: import \"../token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";",
          "627: contract ERC1155HolderUpgradeableWithInit is ERC1155HolderUpgradeable {",
          "628:     constructor() payable initializer {",
          "629:         __ERC1155Holder_init();",
          "630:     }",
          "631: }",
          "632: import \"../token/ERC20/ERC20Upgradeable.sol\";",
          "634: contract ERC20UpgradeableWithInit is ERC20Upgradeable {",
          "635:     constructor(string memory name_, string memory symbol_) payable initializer {",
          "636:         __ERC20_init(name_, symbol_);",
          "637:     }",
          "638: }",
          "639: import \"../token/ERC20/presets/ERC20PresetFixedSupplyUpgradeable.sol\";",
          "641: contract ERC20PresetFixedSupplyUpgradeableWithInit is ERC20PresetFixedSupplyUpgradeable {",
          "642:     constructor(string memory name, string memory symbol, uint256 initialSupply, address owner) payable initializer {",
          "643:         __ERC20PresetFixedSupply_init(name, symbol, initialSupply, owner);",
          "644:     }",
          "645: }",
          "646: import \"../token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";",
          "648: contract ERC20PresetMinterPauserUpgradeableWithInit is ERC20PresetMinterPauserUpgradeable {",
          "649:     constructor(string memory name, string memory symbol) payable initializer {",
          "650:         __ERC20PresetMinterPauser_init(name, symbol);",
          "651:     }",
          "652: }",
          "653: import \"../token/ERC20/utils/TokenTimelockUpgradeable.sol\";",
          "655: contract TokenTimelockUpgradeableWithInit is TokenTimelockUpgradeable {",
          "656:     constructor(IERC20Upgradeable token_, address beneficiary_, uint256 releaseTime_) payable initializer {",
          "657:         __TokenTimelock_init(token_, beneficiary_, releaseTime_);",
          "658:     }",
          "659: }",
          "660: import \"../token/ERC721/ERC721Upgradeable.sol\";",
          "662: contract ERC721UpgradeableWithInit is ERC721Upgradeable {",
          "663:     constructor(string memory name_, string memory symbol_) payable initializer {",
          "664:         __ERC721_init(name_, symbol_);",
          "665:     }",
          "666: }",
          "667: import \"../token/ERC721/presets/ERC721PresetMinterPauserAutoIdUpgradeable.sol\";",
          "669: contract ERC721PresetMinterPauserAutoIdUpgradeableWithInit is ERC721PresetMinterPauserAutoIdUpgradeable {",
          "670:     constructor(string memory name, string memory symbol, string memory baseTokenURI) payable initializer {",
          "671:         __ERC721PresetMinterPauserAutoId_init(name, symbol, baseTokenURI);",
          "672:     }",
          "673: }",
          "674: import \"../token/ERC721/utils/ERC721HolderUpgradeable.sol\";",
          "676: contract ERC721HolderUpgradeableWithInit is ERC721HolderUpgradeable {",
          "677:     constructor() payable initializer {",
          "678:         __ERC721Holder_init();",
          "679:     }",
          "680: }",
          "681: import \"../token/ERC777/ERC777Upgradeable.sol\";",
          "683: contract ERC777UpgradeableWithInit is ERC777Upgradeable {",
          "684:     constructor(string memory name_, string memory symbol_, address[] memory defaultOperators_) payable initializer {",
          "685:         __ERC777_init(name_, symbol_, defaultOperators_);",
          "686:     }",
          "687: }",
          "688: import \"../token/ERC777/presets/ERC777PresetFixedSupplyUpgradeable.sol\";",
          "690: contract ERC777PresetFixedSupplyUpgradeableWithInit is ERC777PresetFixedSupplyUpgradeable {",
          "691:     constructor(",
          "692:         string memory name,",
          "693:         string memory symbol,",
          "694:         address[] memory defaultOperators,",
          "695:         uint256 initialSupply,",
          "696:         address owner",
          "697:     ) payable initializer {",
          "698:         __ERC777PresetFixedSupply_init(name, symbol, defaultOperators, initialSupply, owner);",
          "699:     }",
          "700: }",
          "701: import \"../utils/ContextUpgradeable.sol\";",
          "703: contract ContextUpgradeableWithInit is ContextUpgradeable {",
          "704:     constructor() payable initializer {",
          "705:         __Context_init();",
          "706:     }",
          "707: }",
          "708: import \"../utils/cryptography/EIP712Upgradeable.sol\";",
          "710: contract EIP712UpgradeableWithInit is EIP712Upgradeable {",
          "711:     constructor(string memory name, string memory version) payable initializer {",
          "712:         __EIP712_init(name, version);",
          "713:     }",
          "714: }",
          "715: import \"../utils/escrow/EscrowUpgradeable.sol\";",
          "717: contract EscrowUpgradeableWithInit is EscrowUpgradeable {",
          "718:     constructor() payable initializer {",
          "719:         __Escrow_init();",
          "720:     }",
          "721: }",
          "722: import \"../utils/escrow/RefundEscrowUpgradeable.sol\";",
          "724: contract RefundEscrowUpgradeableWithInit is RefundEscrowUpgradeable {",
          "725:     constructor(address payable beneficiary_) payable initializer {",
          "726:         __RefundEscrow_init(beneficiary_);",
          "727:     }",
          "728: }",
          "729: import \"../utils/introspection/ERC165Upgradeable.sol\";",
          "731: contract ERC165UpgradeableWithInit is ERC165Upgradeable {",
          "732:     constructor() payable initializer {",
          "733:         __ERC165_init();",
          "734:     }",
          "735: }",
          "736: import \"../utils/introspection/ERC165StorageUpgradeable.sol\";",
          "738: contract ERC165StorageUpgradeableWithInit is ERC165StorageUpgradeable {",
          "739:     constructor() payable initializer {",
          "740:         __ERC165Storage_init();",
          "741:     }",
          "742: }",
          "743: import \"../utils/introspection/ERC1820ImplementerUpgradeable.sol\";",
          "745: contract ERC1820ImplementerUpgradeableWithInit is ERC1820ImplementerUpgradeable {",
          "746:     constructor() payable initializer {",
          "747:         __ERC1820Implementer_init();",
          "748:     }",
          "749: }",
          "750: import \"../utils/MulticallUpgradeable.sol\";",
          "752: contract MulticallUpgradeableWithInit is MulticallUpgradeable {",
          "753:     constructor() payable initializer {",
          "754:         __Multicall_init();",
          "755:     }",
          "756: }",
          "",
          "---------------"
        ],
        "contracts/mocks/compound/CompTimelockUpgradeable.sol||contracts/mocks/compound/CompTimelockUpgradeable.sol": [
          "File: contracts/mocks/compound/CompTimelockUpgradeable.sol -> contracts/mocks/compound/CompTimelockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: pragma solidity ^0.8.0;",
          "28: import \"../../proxy/utils/Initializable.sol\";",
          "30: contract CompTimelockUpgradeable is Initializable {",
          "31:     event NewAdmin(address indexed newAdmin);",
          "32:     event NewPendingAdmin(address indexed newPendingAdmin);",
          "33:     event NewDelay(uint256 indexed newDelay);",
          "34:     event CancelTransaction(",
          "35:         bytes32 indexed txHash,",
          "36:         address indexed target,",
          "37:         uint256 value,",
          "38:         string signature,",
          "39:         bytes data,",
          "40:         uint256 eta",
          "41:     );",
          "42:     event ExecuteTransaction(",
          "43:         bytes32 indexed txHash,",
          "44:         address indexed target,",
          "45:         uint256 value,",
          "46:         string signature,",
          "47:         bytes data,",
          "48:         uint256 eta",
          "49:     );",
          "50:     event QueueTransaction(",
          "51:         bytes32 indexed txHash,",
          "52:         address indexed target,",
          "53:         uint256 value,",
          "54:         string signature,",
          "55:         bytes data,",
          "56:         uint256 eta",
          "57:     );",
          "59:     uint256 public constant GRACE_PERIOD = 14 days;",
          "60:     uint256 public constant MINIMUM_DELAY = 2 days;",
          "61:     uint256 public constant MAXIMUM_DELAY = 30 days;",
          "63:     address public admin;",
          "64:     address public pendingAdmin;",
          "65:     uint256 public delay;",
          "67:     mapping(bytes32 => bool) public queuedTransactions;",
          "69:     function __CompTimelock_init(address admin_, uint256 delay_) internal onlyInitializing {",
          "70:         __CompTimelock_init_unchained(admin_, delay_);",
          "71:     }",
          "73:     function __CompTimelock_init_unchained(address admin_, uint256 delay_) internal onlyInitializing {",
          "74:         require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");",
          "75:         require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");",
          "77:         admin = admin_;",
          "78:         delay = delay_;",
          "79:     }",
          "81:     receive() external payable {}",
          "83:     function setDelay(uint256 delay_) public {",
          "84:         require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");",
          "85:         require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");",
          "86:         require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");",
          "87:         delay = delay_;",
          "89:         emit NewDelay(delay);",
          "90:     }",
          "92:     function acceptAdmin() public {",
          "93:         require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");",
          "94:         admin = msg.sender;",
          "95:         pendingAdmin = address(0);",
          "97:         emit NewAdmin(admin);",
          "98:     }",
          "100:     function setPendingAdmin(address pendingAdmin_) public {",
          "101:         require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");",
          "102:         pendingAdmin = pendingAdmin_;",
          "104:         emit NewPendingAdmin(pendingAdmin);",
          "105:     }",
          "107:     function queueTransaction(",
          "108:         address target,",
          "109:         uint256 value,",
          "110:         string memory signature,",
          "111:         bytes memory data,",
          "112:         uint256 eta",
          "113:     ) public returns (bytes32) {",
          "114:         require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");",
          "115:         require(",
          "116:             eta >= getBlockTimestamp() + delay,",
          "117:             \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"",
          "118:         );",
          "120:         bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));",
          "121:         queuedTransactions[txHash] = true;",
          "123:         emit QueueTransaction(txHash, target, value, signature, data, eta);",
          "124:         return txHash;",
          "125:     }",
          "127:     function cancelTransaction(",
          "128:         address target,",
          "129:         uint256 value,",
          "130:         string memory signature,",
          "131:         bytes memory data,",
          "132:         uint256 eta",
          "133:     ) public {",
          "134:         require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");",
          "136:         bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));",
          "137:         queuedTransactions[txHash] = false;",
          "139:         emit CancelTransaction(txHash, target, value, signature, data, eta);",
          "140:     }",
          "142:     function executeTransaction(",
          "143:         address target,",
          "144:         uint256 value,",
          "145:         string memory signature,",
          "146:         bytes memory data,",
          "147:         uint256 eta",
          "148:     ) public payable returns (bytes memory) {",
          "149:         require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");",
          "151:         bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));",
          "152:         require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");",
          "153:         require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");",
          "154:         require(getBlockTimestamp() <= eta + GRACE_PERIOD, \"Timelock::executeTransaction: Transaction is stale.\");",
          "156:         queuedTransactions[txHash] = false;",
          "158:         bytes memory callData;",
          "160:         if (bytes(signature).length == 0) {",
          "161:             callData = data;",
          "162:         } else {",
          "163:             callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);",
          "164:         }",
          "167:         (bool success, bytes memory returnData) = target.call{value: value}(callData);",
          "168:         require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");",
          "170:         emit ExecuteTransaction(txHash, target, value, signature, data, eta);",
          "172:         return returnData;",
          "173:     }",
          "175:     function getBlockTimestamp() internal view returns (uint256) {",
          "177:         return block.timestamp;",
          "178:     }",
          "185:     uint256[46] private __gap;",
          "186: }",
          "",
          "---------------"
        ],
        "contracts/mocks/crosschain/bridgesUpgradeable.sol||contracts/mocks/crosschain/bridgesUpgradeable.sol": [
          "File: contracts/mocks/crosschain/bridgesUpgradeable.sol -> contracts/mocks/crosschain/bridgesUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../utils/AddressUpgradeable.sol\";",
          "6: import \"../../vendor/polygon/IFxMessageProcessorUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "9: abstract contract BaseRelayMockUpgradeable is Initializable {",
          "10:     function __BaseRelayMock_init() internal onlyInitializing {",
          "11:     }",
          "13:     function __BaseRelayMock_init_unchained() internal onlyInitializing {",
          "14:     }",
          "16:     error NotCrossChainCall();",
          "17:     error InvalidCrossChainSender(address sender, address expected);",
          "19:     address internal _currentSender;",
          "21:     function relayAs(address target, bytes calldata data, address sender) external virtual {",
          "22:         address previousSender = _currentSender;",
          "24:         _currentSender = sender;",
          "26:         (bool success, bytes memory returndata) = target.call(data);",
          "27:         AddressUpgradeable.verifyCallResultFromTarget(target, success, returndata, \"low-level call reverted\");",
          "29:         _currentSender = previousSender;",
          "30:     }",
          "37:     uint256[49] private __gap;",
          "38: }",
          "43: contract BridgeAMBMockUpgradeable is Initializable, BaseRelayMockUpgradeable {",
          "44:     function __BridgeAMBMock_init() internal onlyInitializing {",
          "45:     }",
          "47:     function __BridgeAMBMock_init_unchained() internal onlyInitializing {",
          "48:     }",
          "49:     function messageSender() public view returns (address) {",
          "50:         return _currentSender;",
          "51:     }",
          "58:     uint256[50] private __gap;",
          "59: }",
          "64: contract BridgeArbitrumL1MockUpgradeable is Initializable, BaseRelayMockUpgradeable {",
          "65:     function __BridgeArbitrumL1Mock_init() internal onlyInitializing {",
          "66:     }",
          "68:     function __BridgeArbitrumL1Mock_init_unchained() internal onlyInitializing {",
          "69:     }",
          "71:     address public immutable inbox = address(new BridgeArbitrumL1InboxUpgradeable());",
          "73:     address public immutable outbox = address(new BridgeArbitrumL1OutboxUpgradeable());",
          "75:     function activeOutbox() public view returns (address) {",
          "76:         return outbox;",
          "77:     }",
          "79:     function currentSender() public view returns (address) {",
          "80:         return _currentSender;",
          "81:     }",
          "88:     uint256[50] private __gap;",
          "89: }",
          "91: contract BridgeArbitrumL1InboxUpgradeable is Initializable {",
          "92:     function __BridgeArbitrumL1Inbox_init() internal onlyInitializing {",
          "93:     }",
          "95:     function __BridgeArbitrumL1Inbox_init_unchained() internal onlyInitializing {",
          "96:     }",
          "98:     address public immutable bridge = msg.sender;",
          "105:     uint256[50] private __gap;",
          "106: }",
          "108: contract BridgeArbitrumL1OutboxUpgradeable is Initializable {",
          "109:     function __BridgeArbitrumL1Outbox_init() internal onlyInitializing {",
          "110:     }",
          "112:     function __BridgeArbitrumL1Outbox_init_unchained() internal onlyInitializing {",
          "113:     }",
          "115:     address public immutable bridge = msg.sender;",
          "117:     function l2ToL1Sender() public view returns (address) {",
          "118:         return BridgeArbitrumL1MockUpgradeable(bridge).currentSender();",
          "119:     }",
          "126:     uint256[50] private __gap;",
          "127: }",
          "129: contract BridgeArbitrumL2MockUpgradeable is Initializable, BaseRelayMockUpgradeable {",
          "130:     function __BridgeArbitrumL2Mock_init() internal onlyInitializing {",
          "131:     }",
          "133:     function __BridgeArbitrumL2Mock_init_unchained() internal onlyInitializing {",
          "134:     }",
          "135:     function wasMyCallersAddressAliased() public view returns (bool) {",
          "136:         return _currentSender != address(0);",
          "137:     }",
          "139:     function myCallersAddressWithoutAliasing() public view returns (address) {",
          "140:         return _currentSender;",
          "141:     }",
          "148:     uint256[50] private __gap;",
          "149: }",
          "154: contract BridgeOptimismMockUpgradeable is Initializable, BaseRelayMockUpgradeable {",
          "155:     function __BridgeOptimismMock_init() internal onlyInitializing {",
          "156:     }",
          "158:     function __BridgeOptimismMock_init_unchained() internal onlyInitializing {",
          "159:     }",
          "160:     function xDomainMessageSender() public view returns (address) {",
          "161:         return _currentSender;",
          "162:     }",
          "169:     uint256[50] private __gap;",
          "170: }",
          "175: contract BridgePolygonChildMockUpgradeable is Initializable, BaseRelayMockUpgradeable {",
          "176:     function __BridgePolygonChildMock_init() internal onlyInitializing {",
          "177:     }",
          "179:     function __BridgePolygonChildMock_init_unchained() internal onlyInitializing {",
          "180:     }",
          "181:     function relayAs(address target, bytes calldata data, address sender) external override {",
          "182:         IFxMessageProcessorUpgradeable(target).processMessageFromRoot(0, sender, data);",
          "183:     }",
          "190:     uint256[50] private __gap;",
          "191: }",
          "",
          "---------------"
        ],
        "contracts/mocks/crosschain/receiversUpgradeable.sol||contracts/mocks/crosschain/receiversUpgradeable.sol": [
          "File: contracts/mocks/crosschain/receiversUpgradeable.sol -> contracts/mocks/crosschain/receiversUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.4;",
          "5: import \"../../access/OwnableUpgradeable.sol\";",
          "6: import \"../../crosschain/amb/CrossChainEnabledAMBUpgradeable.sol\";",
          "7: import \"../../crosschain/arbitrum/CrossChainEnabledArbitrumL1Upgradeable.sol\";",
          "8: import \"../../crosschain/arbitrum/CrossChainEnabledArbitrumL2Upgradeable.sol\";",
          "9: import \"../../crosschain/optimism/CrossChainEnabledOptimismUpgradeable.sol\";",
          "10: import \"../../crosschain/polygon/CrossChainEnabledPolygonChildUpgradeable.sol\";",
          "11: import \"../../proxy/utils/Initializable.sol\";",
          "13: abstract contract ReceiverUpgradeable is Initializable, CrossChainEnabledUpgradeable {",
          "14:     function __Receiver_init() internal onlyInitializing {",
          "15:     }",
          "17:     function __Receiver_init_unchained() internal onlyInitializing {",
          "18:     }",
          "21:     address public immutable owner = msg.sender;",
          "23:     function crossChainRestricted() external onlyCrossChain {}",
          "25:     function crossChainOwnerRestricted() external onlyCrossChainSender(owner) {}",
          "32:     uint256[50] private __gap;",
          "33: }",
          "38: contract CrossChainEnabledAMBMockUpgradeable is Initializable, ReceiverUpgradeable, CrossChainEnabledAMBUpgradeable {",
          "40:     constructor(address bridge) CrossChainEnabledAMBUpgradeable(bridge) {}",
          "47:     uint256[50] private __gap;",
          "48: }",
          "53: contract CrossChainEnabledArbitrumL1MockUpgradeable is Initializable, ReceiverUpgradeable, CrossChainEnabledArbitrumL1Upgradeable {",
          "55:     constructor(address bridge) CrossChainEnabledArbitrumL1Upgradeable(bridge) {}",
          "62:     uint256[50] private __gap;",
          "63: }",
          "65: contract CrossChainEnabledArbitrumL2MockUpgradeable is Initializable, ReceiverUpgradeable, CrossChainEnabledArbitrumL2Upgradeable {    function __CrossChainEnabledArbitrumL2Mock_init() internal onlyInitializing {",
          "66:     }",
          "68:     function __CrossChainEnabledArbitrumL2Mock_init_unchained() internal onlyInitializing {",
          "69:     }",
          "76:     uint256[50] private __gap;",
          "77: }",
          "82: contract CrossChainEnabledOptimismMockUpgradeable is Initializable, ReceiverUpgradeable, CrossChainEnabledOptimismUpgradeable {",
          "84:     constructor(address bridge) CrossChainEnabledOptimismUpgradeable(bridge) {}",
          "91:     uint256[50] private __gap;",
          "92: }",
          "97: contract CrossChainEnabledPolygonChildMockUpgradeable is Initializable, ReceiverUpgradeable, CrossChainEnabledPolygonChildUpgradeable {",
          "99:     constructor(address bridge) CrossChainEnabledPolygonChildUpgradeable(bridge) {}",
          "106:     uint256[50] private __gap;",
          "107: }",
          "",
          "---------------"
        ],
        "contracts/mocks/governance/GovernorCompMockUpgradeable.sol||contracts/mocks/governance/GovernorCompMockUpgradeable.sol": [
          "File: contracts/mocks/governance/GovernorCompMockUpgradeable.sol -> contracts/mocks/governance/GovernorCompMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../governance/extensions/GovernorCountingSimpleUpgradeable.sol\";",
          "6: import \"../../governance/extensions/GovernorVotesCompUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "9: abstract contract GovernorCompMockUpgradeable is Initializable, GovernorVotesCompUpgradeable, GovernorCountingSimpleUpgradeable {",
          "10:     function __GovernorCompMock_init() internal onlyInitializing {",
          "11:     }",
          "13:     function __GovernorCompMock_init_unchained() internal onlyInitializing {",
          "14:     }",
          "15:     function quorum(uint256) public pure override returns (uint256) {",
          "16:         return 0;",
          "17:     }",
          "19:     function votingDelay() public pure override returns (uint256) {",
          "20:         return 4;",
          "21:     }",
          "23:     function votingPeriod() public pure override returns (uint256) {",
          "24:         return 16;",
          "25:     }",
          "32:     uint256[50] private __gap;",
          "33: }",
          "",
          "---------------"
        ],
        "contracts/mocks/governance/GovernorCompatibilityBravoMockUpgradeable.sol||contracts/mocks/governance/GovernorCompatibilityBravoMockUpgradeable.sol": [
          "File: contracts/mocks/governance/GovernorCompatibilityBravoMockUpgradeable.sol -> contracts/mocks/governance/GovernorCompatibilityBravoMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol\";",
          "6: import \"../../governance/extensions/GovernorTimelockCompoundUpgradeable.sol\";",
          "7: import \"../../governance/extensions/GovernorSettingsUpgradeable.sol\";",
          "8: import \"../../governance/extensions/GovernorVotesCompUpgradeable.sol\";",
          "9: import \"../../proxy/utils/Initializable.sol\";",
          "11: abstract contract GovernorCompatibilityBravoMockUpgradeable is",
          "12:     Initializable, GovernorCompatibilityBravoUpgradeable,",
          "13:     GovernorSettingsUpgradeable,",
          "14:     GovernorTimelockCompoundUpgradeable,",
          "15:     GovernorVotesCompUpgradeable",
          "16: {",
          "17:     function __GovernorCompatibilityBravoMock_init() internal onlyInitializing {",
          "18:     }",
          "20:     function __GovernorCompatibilityBravoMock_init_unchained() internal onlyInitializing {",
          "21:     }",
          "22:     function quorum(uint256) public pure override returns (uint256) {",
          "23:         return 0;",
          "24:     }",
          "26:     function supportsInterface(",
          "27:         bytes4 interfaceId",
          "28:     ) public view override(IERC165Upgradeable, GovernorUpgradeable, GovernorTimelockCompoundUpgradeable) returns (bool) {",
          "29:         return super.supportsInterface(interfaceId);",
          "30:     }",
          "32:     function state(",
          "33:         uint256 proposalId",
          "34:     ) public view override(IGovernorUpgradeable, GovernorUpgradeable, GovernorTimelockCompoundUpgradeable) returns (ProposalState) {",
          "35:         return super.state(proposalId);",
          "36:     }",
          "38:     function proposalEta(",
          "39:         uint256 proposalId",
          "40:     ) public view override(IGovernorTimelockUpgradeable, GovernorTimelockCompoundUpgradeable) returns (uint256) {",
          "41:         return super.proposalEta(proposalId);",
          "42:     }",
          "44:     function proposalThreshold() public view override(GovernorUpgradeable, GovernorSettingsUpgradeable) returns (uint256) {",
          "45:         return super.proposalThreshold();",
          "46:     }",
          "48:     function propose(",
          "49:         address[] memory targets,",
          "50:         uint256[] memory values,",
          "51:         bytes[] memory calldatas,",
          "52:         string memory description",
          "53:     ) public override(IGovernorUpgradeable, GovernorUpgradeable, GovernorCompatibilityBravoUpgradeable) returns (uint256) {",
          "54:         return super.propose(targets, values, calldatas, description);",
          "55:     }",
          "57:     function queue(",
          "58:         address[] memory targets,",
          "59:         uint256[] memory values,",
          "60:         bytes[] memory calldatas,",
          "61:         bytes32 salt",
          "62:     ) public override(IGovernorTimelockUpgradeable, GovernorTimelockCompoundUpgradeable) returns (uint256) {",
          "63:         return super.queue(targets, values, calldatas, salt);",
          "64:     }",
          "66:     function execute(",
          "67:         address[] memory targets,",
          "68:         uint256[] memory values,",
          "69:         bytes[] memory calldatas,",
          "70:         bytes32 salt",
          "71:     ) public payable override(IGovernorUpgradeable, GovernorUpgradeable) returns (uint256) {",
          "72:         return super.execute(targets, values, calldatas, salt);",
          "73:     }",
          "75:     function cancel(",
          "76:         address[] memory targets,",
          "77:         uint256[] memory values,",
          "78:         bytes[] memory calldatas,",
          "79:         bytes32 descriptionHash",
          "80:     ) public override(GovernorUpgradeable, GovernorCompatibilityBravoUpgradeable, IGovernorUpgradeable) returns (uint256) {",
          "81:         return super.cancel(targets, values, calldatas, descriptionHash);",
          "82:     }",
          "84:     function _execute(",
          "85:         uint256 proposalId,",
          "86:         address[] memory targets,",
          "87:         uint256[] memory values,",
          "88:         bytes[] memory calldatas,",
          "89:         bytes32 descriptionHash",
          "90:     ) internal override(GovernorUpgradeable, GovernorTimelockCompoundUpgradeable) {",
          "91:         super._execute(proposalId, targets, values, calldatas, descriptionHash);",
          "92:     }",
          "94:     function _cancel(",
          "95:         address[] memory targets,",
          "96:         uint256[] memory values,",
          "97:         bytes[] memory calldatas,",
          "98:         bytes32 salt",
          "99:     ) internal override(GovernorUpgradeable, GovernorTimelockCompoundUpgradeable) returns (uint256 proposalId) {",
          "100:         return super._cancel(targets, values, calldatas, salt);",
          "101:     }",
          "103:     function _executor() internal view override(GovernorUpgradeable, GovernorTimelockCompoundUpgradeable) returns (address) {",
          "104:         return super._executor();",
          "105:     }",
          "112:     uint256[50] private __gap;",
          "113: }",
          "",
          "---------------"
        ],
        "contracts/mocks/governance/GovernorMockUpgradeable.sol||contracts/mocks/governance/GovernorMockUpgradeable.sol": [
          "File: contracts/mocks/governance/GovernorMockUpgradeable.sol -> contracts/mocks/governance/GovernorMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../governance/extensions/GovernorProposalThresholdUpgradeable.sol\";",
          "6: import \"../../governance/extensions/GovernorSettingsUpgradeable.sol\";",
          "7: import \"../../governance/extensions/GovernorCountingSimpleUpgradeable.sol\";",
          "8: import \"../../governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";",
          "9: import \"../../proxy/utils/Initializable.sol\";",
          "11: abstract contract GovernorMockUpgradeable is",
          "12:     Initializable, GovernorProposalThresholdUpgradeable,",
          "13:     GovernorSettingsUpgradeable,",
          "14:     GovernorVotesQuorumFractionUpgradeable,",
          "15:     GovernorCountingSimpleUpgradeable",
          "16: {",
          "17:     function __GovernorMock_init() internal onlyInitializing {",
          "18:     }",
          "20:     function __GovernorMock_init_unchained() internal onlyInitializing {",
          "21:     }",
          "22:     function proposalThreshold() public view override(GovernorUpgradeable, GovernorSettingsUpgradeable) returns (uint256) {",
          "23:         return super.proposalThreshold();",
          "24:     }",
          "26:     function propose(",
          "27:         address[] memory targets,",
          "28:         uint256[] memory values,",
          "29:         bytes[] memory calldatas,",
          "30:         string memory description",
          "31:     ) public override(GovernorUpgradeable, GovernorProposalThresholdUpgradeable) returns (uint256) {",
          "32:         return super.propose(targets, values, calldatas, description);",
          "33:     }",
          "40:     uint256[50] private __gap;",
          "41: }",
          "",
          "---------------"
        ],
        "contracts/mocks/governance/GovernorPreventLateQuorumMockUpgradeable.sol||contracts/mocks/governance/GovernorPreventLateQuorumMockUpgradeable.sol": [
          "File: contracts/mocks/governance/GovernorPreventLateQuorumMockUpgradeable.sol -> contracts/mocks/governance/GovernorPreventLateQuorumMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../governance/extensions/GovernorPreventLateQuorumUpgradeable.sol\";",
          "6: import \"../../governance/extensions/GovernorSettingsUpgradeable.sol\";",
          "7: import \"../../governance/extensions/GovernorCountingSimpleUpgradeable.sol\";",
          "8: import \"../../governance/extensions/GovernorVotesUpgradeable.sol\";",
          "9: import \"../../proxy/utils/Initializable.sol\";",
          "11: abstract contract GovernorPreventLateQuorumMockUpgradeable is",
          "12:     Initializable, GovernorSettingsUpgradeable,",
          "13:     GovernorVotesUpgradeable,",
          "14:     GovernorCountingSimpleUpgradeable,",
          "15:     GovernorPreventLateQuorumUpgradeable",
          "16: {",
          "17:     uint256 private _quorum;",
          "19:     function __GovernorPreventLateQuorumMock_init(uint256 quorum_) internal onlyInitializing {",
          "20:         __GovernorPreventLateQuorumMock_init_unchained(quorum_);",
          "21:     }",
          "23:     function __GovernorPreventLateQuorumMock_init_unchained(uint256 quorum_) internal onlyInitializing {",
          "24:         _quorum = quorum_;",
          "25:     }",
          "27:     function quorum(uint256) public view override returns (uint256) {",
          "28:         return _quorum;",
          "29:     }",
          "31:     function proposalDeadline(",
          "32:         uint256 proposalId",
          "33:     ) public view override(GovernorUpgradeable, GovernorPreventLateQuorumUpgradeable) returns (uint256) {",
          "34:         return super.proposalDeadline(proposalId);",
          "35:     }",
          "37:     function proposalThreshold() public view override(GovernorUpgradeable, GovernorSettingsUpgradeable) returns (uint256) {",
          "38:         return super.proposalThreshold();",
          "39:     }",
          "41:     function _castVote(",
          "42:         uint256 proposalId,",
          "43:         address account,",
          "44:         uint8 support,",
          "45:         string memory reason,",
          "46:         bytes memory params",
          "47:     ) internal override(GovernorUpgradeable, GovernorPreventLateQuorumUpgradeable) returns (uint256) {",
          "48:         return super._castVote(proposalId, account, support, reason, params);",
          "49:     }",
          "56:     uint256[49] private __gap;",
          "57: }",
          "",
          "---------------"
        ],
        "contracts/mocks/governance/GovernorTimelockCompoundMockUpgradeable.sol||contracts/mocks/governance/GovernorTimelockCompoundMockUpgradeable.sol": [
          "File: contracts/mocks/governance/GovernorTimelockCompoundMockUpgradeable.sol -> contracts/mocks/governance/GovernorTimelockCompoundMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../governance/extensions/GovernorTimelockCompoundUpgradeable.sol\";",
          "6: import \"../../governance/extensions/GovernorSettingsUpgradeable.sol\";",
          "7: import \"../../governance/extensions/GovernorCountingSimpleUpgradeable.sol\";",
          "8: import \"../../governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";",
          "9: import \"../../proxy/utils/Initializable.sol\";",
          "11: abstract contract GovernorTimelockCompoundMockUpgradeable is",
          "12:     Initializable, GovernorSettingsUpgradeable,",
          "13:     GovernorTimelockCompoundUpgradeable,",
          "14:     GovernorVotesQuorumFractionUpgradeable,",
          "15:     GovernorCountingSimpleUpgradeable",
          "16: {",
          "17:     function __GovernorTimelockCompoundMock_init() internal onlyInitializing {",
          "18:     }",
          "20:     function __GovernorTimelockCompoundMock_init_unchained() internal onlyInitializing {",
          "21:     }",
          "22:     function supportsInterface(",
          "23:         bytes4 interfaceId",
          "24:     ) public view override(GovernorUpgradeable, GovernorTimelockCompoundUpgradeable) returns (bool) {",
          "25:         return super.supportsInterface(interfaceId);",
          "26:     }",
          "28:     function quorum(",
          "29:         uint256 blockNumber",
          "30:     ) public view override(IGovernorUpgradeable, GovernorVotesQuorumFractionUpgradeable) returns (uint256) {",
          "31:         return super.quorum(blockNumber);",
          "32:     }",
          "34:     function state(",
          "35:         uint256 proposalId",
          "36:     ) public view override(GovernorUpgradeable, GovernorTimelockCompoundUpgradeable) returns (ProposalState) {",
          "37:         return super.state(proposalId);",
          "38:     }",
          "40:     function proposalThreshold() public view override(GovernorUpgradeable, GovernorSettingsUpgradeable) returns (uint256) {",
          "41:         return super.proposalThreshold();",
          "42:     }",
          "44:     function _execute(",
          "45:         uint256 proposalId,",
          "46:         address[] memory targets,",
          "47:         uint256[] memory values,",
          "48:         bytes[] memory calldatas,",
          "49:         bytes32 descriptionHash",
          "50:     ) internal override(GovernorUpgradeable, GovernorTimelockCompoundUpgradeable) {",
          "51:         super._execute(proposalId, targets, values, calldatas, descriptionHash);",
          "52:     }",
          "54:     function _cancel(",
          "55:         address[] memory targets,",
          "56:         uint256[] memory values,",
          "57:         bytes[] memory calldatas,",
          "58:         bytes32 salt",
          "59:     ) internal override(GovernorUpgradeable, GovernorTimelockCompoundUpgradeable) returns (uint256 proposalId) {",
          "60:         return super._cancel(targets, values, calldatas, salt);",
          "61:     }",
          "63:     function _executor() internal view override(GovernorUpgradeable, GovernorTimelockCompoundUpgradeable) returns (address) {",
          "64:         return super._executor();",
          "65:     }",
          "72:     uint256[50] private __gap;",
          "73: }",
          "",
          "---------------"
        ],
        "contracts/mocks/governance/GovernorTimelockControlMockUpgradeable.sol||contracts/mocks/governance/GovernorTimelockControlMockUpgradeable.sol": [
          "File: contracts/mocks/governance/GovernorTimelockControlMockUpgradeable.sol -> contracts/mocks/governance/GovernorTimelockControlMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../governance/extensions/GovernorTimelockControlUpgradeable.sol\";",
          "6: import \"../../governance/extensions/GovernorSettingsUpgradeable.sol\";",
          "7: import \"../../governance/extensions/GovernorCountingSimpleUpgradeable.sol\";",
          "8: import \"../../governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";",
          "9: import \"../../proxy/utils/Initializable.sol\";",
          "11: abstract contract GovernorTimelockControlMockUpgradeable is",
          "12:     Initializable, GovernorSettingsUpgradeable,",
          "13:     GovernorTimelockControlUpgradeable,",
          "14:     GovernorVotesQuorumFractionUpgradeable,",
          "15:     GovernorCountingSimpleUpgradeable",
          "16: {",
          "17:     function __GovernorTimelockControlMock_init() internal onlyInitializing {",
          "18:     }",
          "20:     function __GovernorTimelockControlMock_init_unchained() internal onlyInitializing {",
          "21:     }",
          "22:     function supportsInterface(",
          "23:         bytes4 interfaceId",
          "24:     ) public view override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (bool) {",
          "25:         return super.supportsInterface(interfaceId);",
          "26:     }",
          "28:     function quorum(",
          "29:         uint256 blockNumber",
          "30:     ) public view override(IGovernorUpgradeable, GovernorVotesQuorumFractionUpgradeable) returns (uint256) {",
          "31:         return super.quorum(blockNumber);",
          "32:     }",
          "34:     function state(uint256 proposalId) public view override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (ProposalState) {",
          "35:         return super.state(proposalId);",
          "36:     }",
          "38:     function proposalThreshold() public view override(GovernorUpgradeable, GovernorSettingsUpgradeable) returns (uint256) {",
          "39:         return super.proposalThreshold();",
          "40:     }",
          "42:     function _execute(",
          "43:         uint256 proposalId,",
          "44:         address[] memory targets,",
          "45:         uint256[] memory values,",
          "46:         bytes[] memory calldatas,",
          "47:         bytes32 descriptionHash",
          "48:     ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) {",
          "49:         super._execute(proposalId, targets, values, calldatas, descriptionHash);",
          "50:     }",
          "52:     function _cancel(",
          "53:         address[] memory targets,",
          "54:         uint256[] memory values,",
          "55:         bytes[] memory calldatas,",
          "56:         bytes32 descriptionHash",
          "57:     ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint256 proposalId) {",
          "58:         return super._cancel(targets, values, calldatas, descriptionHash);",
          "59:     }",
          "61:     function _executor() internal view override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (address) {",
          "62:         return super._executor();",
          "63:     }",
          "65:     function nonGovernanceFunction() external {}",
          "72:     uint256[50] private __gap;",
          "73: }",
          "",
          "---------------"
        ],
        "contracts/mocks/governance/GovernorVoteMockUpgradeable.sol||contracts/mocks/governance/GovernorVoteMockUpgradeable.sol": [
          "File: contracts/mocks/governance/GovernorVoteMockUpgradeable.sol -> contracts/mocks/governance/GovernorVoteMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../governance/extensions/GovernorCountingSimpleUpgradeable.sol\";",
          "6: import \"../../governance/extensions/GovernorVotesUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "9: abstract contract GovernorVoteMocksUpgradeable is Initializable, GovernorVotesUpgradeable, GovernorCountingSimpleUpgradeable {",
          "10:     function __GovernorVoteMocks_init() internal onlyInitializing {",
          "11:     }",
          "13:     function __GovernorVoteMocks_init_unchained() internal onlyInitializing {",
          "14:     }",
          "15:     function quorum(uint256) public pure override returns (uint256) {",
          "16:         return 0;",
          "17:     }",
          "19:     function votingDelay() public pure override returns (uint256) {",
          "20:         return 4;",
          "21:     }",
          "23:     function votingPeriod() public pure override returns (uint256) {",
          "24:         return 16;",
          "25:     }",
          "32:     uint256[50] private __gap;",
          "33: }",
          "",
          "---------------"
        ],
        "contracts/mocks/governance/GovernorWithParamsMockUpgradeable.sol||contracts/mocks/governance/GovernorWithParamsMockUpgradeable.sol": [
          "File: contracts/mocks/governance/GovernorWithParamsMockUpgradeable.sol -> contracts/mocks/governance/GovernorWithParamsMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../governance/extensions/GovernorCountingSimpleUpgradeable.sol\";",
          "6: import \"../../governance/extensions/GovernorVotesUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "9: abstract contract GovernorWithParamsMockUpgradeable is Initializable, GovernorVotesUpgradeable, GovernorCountingSimpleUpgradeable {",
          "10:     function __GovernorWithParamsMock_init() internal onlyInitializing {",
          "11:     }",
          "13:     function __GovernorWithParamsMock_init_unchained() internal onlyInitializing {",
          "14:     }",
          "15:     event CountParams(uint256 uintParam, string strParam);",
          "17:     function quorum(uint256) public pure override returns (uint256) {",
          "18:         return 0;",
          "19:     }",
          "21:     function votingDelay() public pure override returns (uint256) {",
          "22:         return 4;",
          "23:     }",
          "25:     function votingPeriod() public pure override returns (uint256) {",
          "26:         return 16;",
          "27:     }",
          "29:     function _getVotes(",
          "30:         address account,",
          "31:         uint256 blockNumber,",
          "32:         bytes memory params",
          "33:     ) internal view override(GovernorUpgradeable, GovernorVotesUpgradeable) returns (uint256) {",
          "34:         uint256 reduction = 0;",
          "36:         if (params.length > 0) {",
          "37:             (reduction, ) = abi.decode(params, (uint256, string));",
          "38:         }",
          "40:         return super._getVotes(account, blockNumber, params) - reduction;",
          "41:     }",
          "43:     function _countVote(",
          "44:         uint256 proposalId,",
          "45:         address account,",
          "46:         uint8 support,",
          "47:         uint256 weight,",
          "48:         bytes memory params",
          "49:     ) internal override(GovernorUpgradeable, GovernorCountingSimpleUpgradeable) {",
          "50:         if (params.length > 0) {",
          "51:             (uint256 _uintParam, string memory _strParam) = abi.decode(params, (uint256, string));",
          "52:             emit CountParams(_uintParam, _strParam);",
          "53:         }",
          "54:         return super._countVote(proposalId, account, support, weight, params);",
          "55:     }",
          "62:     uint256[50] private __gap;",
          "63: }",
          "",
          "---------------"
        ],
        "contracts/mocks/proxy/BadBeaconUpgradeable.sol||contracts/mocks/proxy/BadBeaconUpgradeable.sol": [
          "File: contracts/mocks/proxy/BadBeaconUpgradeable.sol -> contracts/mocks/proxy/BadBeaconUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "4: import \"../../proxy/utils/Initializable.sol\";",
          "6: contract BadBeaconNoImplUpgradeable is Initializable {    function __BadBeaconNoImpl_init() internal onlyInitializing {",
          "7:     }",
          "9:     function __BadBeaconNoImpl_init_unchained() internal onlyInitializing {",
          "10:     }",
          "17:     uint256[50] private __gap;",
          "18: }",
          "20: contract BadBeaconNotContractUpgradeable is Initializable {",
          "21:     function __BadBeaconNotContract_init() internal onlyInitializing {",
          "22:     }",
          "24:     function __BadBeaconNotContract_init_unchained() internal onlyInitializing {",
          "25:     }",
          "26:     function implementation() external pure returns (address) {",
          "27:         return address(0x1);",
          "28:     }",
          "35:     uint256[50] private __gap;",
          "36: }",
          "",
          "---------------"
        ],
        "contracts/mocks/proxy/ClashingImplementationUpgradeable.sol||contracts/mocks/proxy/ClashingImplementationUpgradeable.sol": [
          "File: contracts/mocks/proxy/ClashingImplementationUpgradeable.sol -> contracts/mocks/proxy/ClashingImplementationUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "4: import \"../../proxy/utils/Initializable.sol\";",
          "10: contract ClashingImplementationUpgradeable is Initializable {",
          "11:     function __ClashingImplementation_init() internal onlyInitializing {",
          "12:     }",
          "14:     function __ClashingImplementation_init_unchained() internal onlyInitializing {",
          "15:     }",
          "16:     function admin() external payable returns (address) {",
          "17:         return 0x0000000000000000000000000000000011111142;",
          "18:     }",
          "20:     function delegatedFunction() external pure returns (bool) {",
          "21:         return true;",
          "22:     }",
          "29:     uint256[50] private __gap;",
          "30: }",
          "",
          "---------------"
        ],
        "contracts/mocks/proxy/UUPSLegacyUpgradeable.sol||contracts/mocks/proxy/UUPSLegacyUpgradeable.sol": [
          "File: contracts/mocks/proxy/UUPSLegacyUpgradeable.sol -> contracts/mocks/proxy/UUPSLegacyUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"./UUPSUpgradeableMockUpgradeable.sol\";",
          "6: import \"../../proxy/utils/Initializable.sol\";",
          "10: contract UUPSUpgradeableLegacyMockUpgradeable is Initializable, UUPSUpgradeableMockUpgradeable {",
          "11:     function __UUPSUpgradeableLegacyMock_init() internal onlyInitializing {",
          "12:     }",
          "14:     function __UUPSUpgradeableLegacyMock_init_unchained() internal onlyInitializing {",
          "15:     }",
          "17:     bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;",
          "21:     function __setImplementation(address newImplementation) private {",
          "22:         require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");",
          "23:         StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;",
          "24:     }",
          "26:     function _upgradeToAndCallSecureLegacyV1(address newImplementation, bytes memory data, bool forceCall) internal {",
          "27:         address oldImplementation = _getImplementation();",
          "30:         __setImplementation(newImplementation);",
          "31:         if (data.length > 0 || forceCall) {",
          "32:             AddressUpgradeable.functionDelegateCall(newImplementation, data);",
          "33:         }",
          "36:         StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);",
          "37:         if (!rollbackTesting.value) {",
          "39:             rollbackTesting.value = true;",
          "40:             AddressUpgradeable.functionDelegateCall(",
          "41:                 newImplementation,",
          "42:                 abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)",
          "43:             );",
          "44:             rollbackTesting.value = false;",
          "46:             require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");",
          "48:             _upgradeTo(newImplementation);",
          "49:         }",
          "50:     }",
          "53:     function upgradeTo(address newImplementation) public override {",
          "54:         _upgradeToAndCallSecureLegacyV1(newImplementation, bytes(\"\"), false);",
          "55:     }",
          "57:     function upgradeToAndCall(address newImplementation, bytes memory data) public payable override {",
          "58:         _upgradeToAndCallSecureLegacyV1(newImplementation, data, false);",
          "59:     }",
          "66:     uint256[50] private __gap;",
          "67: }",
          "",
          "---------------"
        ],
        "contracts/mocks/proxy/UUPSUpgradeableMockUpgradeable.sol||contracts/mocks/proxy/UUPSUpgradeableMockUpgradeable.sol": [
          "File: contracts/mocks/proxy/UUPSUpgradeableMockUpgradeable.sol -> contracts/mocks/proxy/UUPSUpgradeableMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../proxy/utils/UUPSUpgradeable.sol\";",
          "6: import \"../../utils/CountersUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "9: contract NonUpgradeableMockUpgradeable is Initializable {",
          "10:     function __NonUpgradeableMock_init() internal onlyInitializing {",
          "11:     }",
          "13:     function __NonUpgradeableMock_init_unchained() internal onlyInitializing {",
          "14:     }",
          "15:     CountersUpgradeable.Counter internal _counter;",
          "17:     function current() external view returns (uint256) {",
          "18:         return CountersUpgradeable.current(_counter);",
          "19:     }",
          "21:     function increment() external {",
          "22:         return CountersUpgradeable.increment(_counter);",
          "23:     }",
          "30:     uint256[49] private __gap;",
          "31: }",
          "33: contract UUPSUpgradeableMockUpgradeable is Initializable, NonUpgradeableMockUpgradeable, UUPSUpgradeable {",
          "34:     function __UUPSUpgradeableMock_init() internal onlyInitializing {",
          "35:     }",
          "37:     function __UUPSUpgradeableMock_init_unchained() internal onlyInitializing {",
          "38:     }",
          "40:     function _authorizeUpgrade(address) internal override {}",
          "47:     uint256[50] private __gap;",
          "48: }",
          "50: contract UUPSUpgradeableUnsafeMockUpgradeable is Initializable, UUPSUpgradeableMockUpgradeable {",
          "51:     function __UUPSUpgradeableUnsafeMock_init() internal onlyInitializing {",
          "52:     }",
          "54:     function __UUPSUpgradeableUnsafeMock_init_unchained() internal onlyInitializing {",
          "55:     }",
          "56:     function upgradeTo(address newImplementation) public override {",
          "57:         ERC1967UpgradeUpgradeable._upgradeToAndCall(newImplementation, bytes(\"\"), false);",
          "58:     }",
          "60:     function upgradeToAndCall(address newImplementation, bytes memory data) public payable override {",
          "61:         ERC1967UpgradeUpgradeable._upgradeToAndCall(newImplementation, data, false);",
          "62:     }",
          "69:     uint256[50] private __gap;",
          "70: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC1155ReceiverMockUpgradeable.sol||contracts/mocks/token/ERC1155ReceiverMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC1155ReceiverMockUpgradeable.sol -> contracts/mocks/token/ERC1155ReceiverMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC1155/IERC1155ReceiverUpgradeable.sol\";",
          "6: import \"../../utils/introspection/ERC165Upgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "9: contract ERC1155ReceiverMockUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {",
          "10:     bytes4 private _recRetval;",
          "11:     bool private _recReverts;",
          "12:     bytes4 private _batRetval;",
          "13:     bool private _batReverts;",
          "15:     event Received(address operator, address from, uint256 id, uint256 value, bytes data, uint256 gas);",
          "16:     event BatchReceived(address operator, address from, uint256[] ids, uint256[] values, bytes data, uint256 gas);",
          "18:     function __ERC1155ReceiverMock_init(bytes4 recRetval, bool recReverts, bytes4 batRetval, bool batReverts) internal onlyInitializing {",
          "19:         __ERC1155ReceiverMock_init_unchained(recRetval, recReverts, batRetval, batReverts);",
          "20:     }",
          "22:     function __ERC1155ReceiverMock_init_unchained(bytes4 recRetval, bool recReverts, bytes4 batRetval, bool batReverts) internal onlyInitializing {",
          "23:         _recRetval = recRetval;",
          "24:         _recReverts = recReverts;",
          "25:         _batRetval = batRetval;",
          "26:         _batReverts = batReverts;",
          "27:     }",
          "29:     function onERC1155Received(",
          "30:         address operator,",
          "31:         address from,",
          "32:         uint256 id,",
          "33:         uint256 value,",
          "34:         bytes calldata data",
          "35:     ) external override returns (bytes4) {",
          "36:         require(!_recReverts, \"ERC1155ReceiverMock: reverting on receive\");",
          "37:         emit Received(operator, from, id, value, data, gasleft());",
          "38:         return _recRetval;",
          "39:     }",
          "41:     function onERC1155BatchReceived(",
          "42:         address operator,",
          "43:         address from,",
          "44:         uint256[] calldata ids,",
          "45:         uint256[] calldata values,",
          "46:         bytes calldata data",
          "47:     ) external override returns (bytes4) {",
          "48:         require(!_batReverts, \"ERC1155ReceiverMock: reverting on batch receive\");",
          "49:         emit BatchReceived(operator, from, ids, values, data, gasleft());",
          "50:         return _batRetval;",
          "51:     }",
          "58:     uint256[49] private __gap;",
          "59: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC20DecimalsMockUpgradeable.sol||contracts/mocks/token/ERC20DecimalsMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC20DecimalsMockUpgradeable.sol -> contracts/mocks/token/ERC20DecimalsMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC20/ERC20Upgradeable.sol\";",
          "6: import \"../../proxy/utils/Initializable.sol\";",
          "8: abstract contract ERC20DecimalsMockUpgradeable is Initializable, ERC20Upgradeable {",
          "9:     uint8 private _decimals;",
          "11:     function __ERC20DecimalsMock_init(uint8 decimals_) internal onlyInitializing {",
          "12:         __ERC20DecimalsMock_init_unchained(decimals_);",
          "13:     }",
          "15:     function __ERC20DecimalsMock_init_unchained(uint8 decimals_) internal onlyInitializing {",
          "16:         _decimals = decimals_;",
          "17:     }",
          "19:     function decimals() public view override returns (uint8) {",
          "20:         return _decimals;",
          "21:     }",
          "28:     uint256[49] private __gap;",
          "29: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC20ExcessDecimalsMockUpgradeable.sol||contracts/mocks/token/ERC20ExcessDecimalsMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC20ExcessDecimalsMockUpgradeable.sol -> contracts/mocks/token/ERC20ExcessDecimalsMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "4: import \"../../proxy/utils/Initializable.sol\";",
          "6: contract ERC20ExcessDecimalsMockUpgradeable is Initializable {",
          "7:     function __ERC20ExcessDecimalsMock_init() internal onlyInitializing {",
          "8:     }",
          "10:     function __ERC20ExcessDecimalsMock_init_unchained() internal onlyInitializing {",
          "11:     }",
          "12:     function decimals() public pure returns (uint256) {",
          "13:         return type(uint256).max;",
          "14:     }",
          "21:     uint256[50] private __gap;",
          "22: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC20FlashMintMockUpgradeable.sol||contracts/mocks/token/ERC20FlashMintMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC20FlashMintMockUpgradeable.sol -> contracts/mocks/token/ERC20FlashMintMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC20/extensions/ERC20FlashMintUpgradeable.sol\";",
          "6: import \"../../proxy/utils/Initializable.sol\";",
          "8: abstract contract ERC20FlashMintMockUpgradeable is Initializable, ERC20FlashMintUpgradeable {",
          "9:     function __ERC20FlashMintMock_init() internal onlyInitializing {",
          "10:     }",
          "12:     function __ERC20FlashMintMock_init_unchained() internal onlyInitializing {",
          "13:     }",
          "14:     uint256 _flashFeeAmount;",
          "15:     address _flashFeeReceiverAddress;",
          "17:     function setFlashFee(uint256 amount) public {",
          "18:         _flashFeeAmount = amount;",
          "19:     }",
          "21:     function _flashFee(address, uint256) internal view override returns (uint256) {",
          "22:         return _flashFeeAmount;",
          "23:     }",
          "25:     function setFlashFeeReceiver(address receiver) public {",
          "26:         _flashFeeReceiverAddress = receiver;",
          "27:     }",
          "29:     function _flashFeeReceiver() internal view override returns (address) {",
          "30:         return _flashFeeReceiverAddress;",
          "31:     }",
          "38:     uint256[48] private __gap;",
          "39: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC20ForceApproveMockUpgradeable.sol||contracts/mocks/token/ERC20ForceApproveMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC20ForceApproveMockUpgradeable.sol -> contracts/mocks/token/ERC20ForceApproveMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC20/ERC20Upgradeable.sol\";",
          "6: import \"../../proxy/utils/Initializable.sol\";",
          "9: abstract contract ERC20ForceApproveMockUpgradeable is Initializable, ERC20Upgradeable {",
          "10:     function __ERC20ForceApproveMock_init() internal onlyInitializing {",
          "11:     }",
          "13:     function __ERC20ForceApproveMock_init_unchained() internal onlyInitializing {",
          "14:     }",
          "15:     function approve(address spender, uint256 amount) public virtual override returns (bool) {",
          "16:         require(amount == 0 || allowance(msg.sender, spender) == 0, \"USDT approval failure\");",
          "17:         return super.approve(spender, amount);",
          "18:     }",
          "25:     uint256[50] private __gap;",
          "26: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC20MulticallMockUpgradeable.sol||contracts/mocks/token/ERC20MulticallMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC20MulticallMockUpgradeable.sol -> contracts/mocks/token/ERC20MulticallMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC20/ERC20Upgradeable.sol\";",
          "6: import \"../../utils/MulticallUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "9: abstract contract ERC20MulticallMockUpgradeable is Initializable, ERC20Upgradeable, MulticallUpgradeable {    function __ERC20MulticallMock_init() internal onlyInitializing {",
          "10:     }",
          "12:     function __ERC20MulticallMock_init_unchained() internal onlyInitializing {",
          "13:     }",
          "20:     uint256[50] private __gap;",
          "21: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC20NoReturnMockUpgradeable.sol||contracts/mocks/token/ERC20NoReturnMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC20NoReturnMockUpgradeable.sol -> contracts/mocks/token/ERC20NoReturnMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC20/ERC20Upgradeable.sol\";",
          "6: import \"../../proxy/utils/Initializable.sol\";",
          "8: abstract contract ERC20NoReturnMockUpgradeable is Initializable, ERC20Upgradeable {",
          "9:     function __ERC20NoReturnMock_init() internal onlyInitializing {",
          "10:     }",
          "12:     function __ERC20NoReturnMock_init_unchained() internal onlyInitializing {",
          "13:     }",
          "14:     function transfer(address to, uint256 amount) public override returns (bool) {",
          "15:         super.transfer(to, amount);",
          "16:         assembly {",
          "17:             return(0, 0)",
          "18:         }",
          "19:     }",
          "21:     function transferFrom(address from, address to, uint256 amount) public override returns (bool) {",
          "22:         super.transferFrom(from, to, amount);",
          "23:         assembly {",
          "24:             return(0, 0)",
          "25:         }",
          "26:     }",
          "28:     function approve(address spender, uint256 amount) public override returns (bool) {",
          "29:         super.approve(spender, amount);",
          "30:         assembly {",
          "31:             return(0, 0)",
          "32:         }",
          "33:     }",
          "40:     uint256[50] private __gap;",
          "41: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC20PermitNoRevertMockUpgradeable.sol||contracts/mocks/token/ERC20PermitNoRevertMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC20PermitNoRevertMockUpgradeable.sol -> contracts/mocks/token/ERC20PermitNoRevertMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC20/ERC20Upgradeable.sol\";",
          "6: import \"../../token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "9: abstract contract ERC20PermitNoRevertMockUpgradeable is Initializable, ERC20PermitUpgradeable {",
          "10:     function __ERC20PermitNoRevertMock_init() internal onlyInitializing {",
          "11:     }",
          "13:     function __ERC20PermitNoRevertMock_init_unchained() internal onlyInitializing {",
          "14:     }",
          "15:     function permitThatMayRevert(",
          "16:         address owner,",
          "17:         address spender,",
          "18:         uint256 value,",
          "19:         uint256 deadline,",
          "20:         uint8 v,",
          "21:         bytes32 r,",
          "22:         bytes32 s",
          "23:     ) public virtual {",
          "24:         super.permit(owner, spender, value, deadline, v, r, s);",
          "25:     }",
          "27:     function permit(",
          "28:         address owner,",
          "29:         address spender,",
          "30:         uint256 value,",
          "31:         uint256 deadline,",
          "32:         uint8 v,",
          "33:         bytes32 r,",
          "34:         bytes32 s",
          "35:     ) public virtual override {",
          "36:         try this.permitThatMayRevert(owner, spender, value, deadline, v, r, s) {",
          "38:         } catch {",
          "40:         }",
          "41:     }",
          "48:     uint256[50] private __gap;",
          "49: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC20ReturnFalseMockUpgradeable.sol||contracts/mocks/token/ERC20ReturnFalseMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC20ReturnFalseMockUpgradeable.sol -> contracts/mocks/token/ERC20ReturnFalseMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC20/ERC20Upgradeable.sol\";",
          "6: import \"../../proxy/utils/Initializable.sol\";",
          "8: abstract contract ERC20ReturnFalseMockUpgradeable is Initializable, ERC20Upgradeable {",
          "9:     function __ERC20ReturnFalseMock_init() internal onlyInitializing {",
          "10:     }",
          "12:     function __ERC20ReturnFalseMock_init_unchained() internal onlyInitializing {",
          "13:     }",
          "14:     function transfer(address, uint256) public pure override returns (bool) {",
          "15:         return false;",
          "16:     }",
          "18:     function transferFrom(address, address, uint256) public pure override returns (bool) {",
          "19:         return false;",
          "20:     }",
          "22:     function approve(address, uint256) public pure override returns (bool) {",
          "23:         return false;",
          "24:     }",
          "31:     uint256[50] private __gap;",
          "32: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC20VotesLegacyMockUpgradeable.sol||contracts/mocks/token/ERC20VotesLegacyMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC20VotesLegacyMockUpgradeable.sol -> contracts/mocks/token/ERC20VotesLegacyMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC20/extensions/ERC20PermitUpgradeable.sol\";",
          "6: import \"../../utils/math/MathUpgradeable.sol\";",
          "7: import \"../../governance/utils/IVotesUpgradeable.sol\";",
          "8: import \"../../utils/math/SafeCastUpgradeable.sol\";",
          "9: import \"../../utils/cryptography/ECDSAUpgradeable.sol\";",
          "10: import \"../../proxy/utils/Initializable.sol\";",
          "15: abstract contract ERC20VotesLegacyMockUpgradeable is Initializable, IVotesUpgradeable, ERC20PermitUpgradeable {",
          "16:     function __ERC20VotesLegacyMock_init() internal onlyInitializing {",
          "17:     }",
          "19:     function __ERC20VotesLegacyMock_init_unchained() internal onlyInitializing {",
          "20:     }",
          "21:     struct Checkpoint {",
          "22:         uint32 fromBlock;",
          "23:         uint224 votes;",
          "24:     }",
          "26:     bytes32 private constant _DELEGATION_TYPEHASH =",
          "27:         keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");",
          "29:     mapping(address => address) private _delegates;",
          "30:     mapping(address => Checkpoint[]) private _checkpoints;",
          "31:     Checkpoint[] private _totalSupplyCheckpoints;",
          "36:     function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {",
          "37:         return _checkpoints[account][pos];",
          "38:     }",
          "43:     function numCheckpoints(address account) public view virtual returns (uint32) {",
          "44:         return SafeCastUpgradeable.toUint32(_checkpoints[account].length);",
          "45:     }",
          "50:     function delegates(address account) public view virtual override returns (address) {",
          "51:         return _delegates[account];",
          "52:     }",
          "57:     function getVotes(address account) public view virtual override returns (uint256) {",
          "58:         uint256 pos = _checkpoints[account].length;",
          "59:         unchecked {",
          "60:             return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;",
          "61:         }",
          "62:     }",
          "71:     function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
          "72:         require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
          "73:         return _checkpointsLookup(_checkpoints[account], blockNumber);",
          "74:     }",
          "84:     function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
          "85:         require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
          "86:         return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);",
          "87:     }",
          "92:     function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {",
          "105:         uint256 length = ckpts.length;",
          "107:         uint256 low = 0;",
          "108:         uint256 high = length;",
          "110:         if (length > 5) {",
          "111:             uint256 mid = length - MathUpgradeable.sqrt(length);",
          "112:             if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
          "113:                 high = mid;",
          "114:             } else {",
          "115:                 low = mid + 1;",
          "116:             }",
          "117:         }",
          "119:         while (low < high) {",
          "120:             uint256 mid = MathUpgradeable.average(low, high);",
          "121:             if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
          "122:                 high = mid;",
          "123:             } else {",
          "124:                 low = mid + 1;",
          "125:             }",
          "126:         }",
          "128:         unchecked {",
          "129:             return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;",
          "130:         }",
          "131:     }",
          "136:     function delegate(address delegatee) public virtual override {",
          "137:         _delegate(_msgSender(), delegatee);",
          "138:     }",
          "143:     function delegateBySig(",
          "144:         address delegatee,",
          "145:         uint256 nonce,",
          "146:         uint256 expiry,",
          "147:         uint8 v,",
          "148:         bytes32 r,",
          "149:         bytes32 s",
          "150:     ) public virtual override {",
          "151:         require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");",
          "152:         address signer = ECDSAUpgradeable.recover(",
          "153:             _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),",
          "154:             v,",
          "155:             r,",
          "156:             s",
          "157:         );",
          "158:         require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");",
          "159:         _delegate(signer, delegatee);",
          "160:     }",
          "165:     function _maxSupply() internal view virtual returns (uint224) {",
          "166:         return type(uint224).max;",
          "167:     }",
          "172:     function _mint(address account, uint256 amount) internal virtual override {",
          "173:         super._mint(account, amount);",
          "174:         require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
          "176:         _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);",
          "177:     }",
          "182:     function _burn(address account, uint256 amount) internal virtual override {",
          "183:         super._burn(account, amount);",
          "185:         _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);",
          "186:     }",
          "193:     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {",
          "194:         super._afterTokenTransfer(from, to, amount);",
          "196:         _moveVotingPower(delegates(from), delegates(to), amount);",
          "197:     }",
          "204:     function _delegate(address delegator, address delegatee) internal virtual {",
          "205:         address currentDelegate = delegates(delegator);",
          "206:         uint256 delegatorBalance = balanceOf(delegator);",
          "207:         _delegates[delegator] = delegatee;",
          "209:         emit DelegateChanged(delegator, currentDelegate, delegatee);",
          "211:         _moveVotingPower(currentDelegate, delegatee, delegatorBalance);",
          "212:     }",
          "214:     function _moveVotingPower(address src, address dst, uint256 amount) private {",
          "215:         if (src != dst && amount > 0) {",
          "216:             if (src != address(0)) {",
          "217:                 (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);",
          "218:                 emit DelegateVotesChanged(src, oldWeight, newWeight);",
          "219:             }",
          "221:             if (dst != address(0)) {",
          "222:                 (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);",
          "223:                 emit DelegateVotesChanged(dst, oldWeight, newWeight);",
          "224:             }",
          "225:         }",
          "226:     }",
          "228:     function _writeCheckpoint(",
          "229:         Checkpoint[] storage ckpts,",
          "230:         function(uint256, uint256) view returns (uint256) op,",
          "231:         uint256 delta",
          "232:     ) private returns (uint256 oldWeight, uint256 newWeight) {",
          "233:         uint256 pos = ckpts.length;",
          "235:         unchecked {",
          "236:             Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);",
          "238:             oldWeight = oldCkpt.votes;",
          "239:             newWeight = op(oldWeight, delta);",
          "241:             if (pos > 0 && oldCkpt.fromBlock == block.number) {",
          "242:                 _unsafeAccess(ckpts, pos - 1).votes = SafeCastUpgradeable.toUint224(newWeight);",
          "243:             } else {",
          "244:                 ckpts.push(",
          "245:                     Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(block.number), votes: SafeCastUpgradeable.toUint224(newWeight)})",
          "246:                 );",
          "247:             }",
          "248:         }",
          "249:     }",
          "251:     function _add(uint256 a, uint256 b) private pure returns (uint256) {",
          "252:         return a + b;",
          "253:     }",
          "255:     function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
          "256:         return a - b;",
          "257:     }",
          "262:     function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {",
          "263:         assembly {",
          "264:             mstore(0, ckpts.slot)",
          "265:             result.slot := add(keccak256(0, 0x20), pos)",
          "266:         }",
          "267:     }",
          "274:     uint256[47] private __gap;",
          "275: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC4626OffsetMockUpgradeable.sol||contracts/mocks/token/ERC4626OffsetMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC4626OffsetMockUpgradeable.sol -> contracts/mocks/token/ERC4626OffsetMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC20/extensions/ERC4626Upgradeable.sol\";",
          "6: import \"../../proxy/utils/Initializable.sol\";",
          "8: abstract contract ERC4626OffsetMockUpgradeable is Initializable, ERC4626Upgradeable {",
          "9:     uint8 private _offset;",
          "11:     function __ERC4626OffsetMock_init(uint8 offset_) internal onlyInitializing {",
          "12:         __ERC4626OffsetMock_init_unchained(offset_);",
          "13:     }",
          "15:     function __ERC4626OffsetMock_init_unchained(uint8 offset_) internal onlyInitializing {",
          "16:         _offset = offset_;",
          "17:     }",
          "19:     function _decimalsOffset() internal view virtual override returns (uint8) {",
          "20:         return _offset;",
          "21:     }",
          "28:     uint256[49] private __gap;",
          "29: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC4646FeesMockUpgradeable.sol||contracts/mocks/token/ERC4646FeesMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC4646FeesMockUpgradeable.sol -> contracts/mocks/token/ERC4646FeesMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../docs/ERC4626FeesUpgradeable.sol\";",
          "6: import \"../../proxy/utils/Initializable.sol\";",
          "8: abstract contract ERC4626FeesMockUpgradeable is Initializable, ERC4626FeesUpgradeable {",
          "9:     uint256 private _entryFeeBasePointValue;",
          "10:     address private _entryFeeRecipientValue;",
          "11:     uint256 private _exitFeeBasePointValue;",
          "12:     address private _exitFeeRecipientValue;",
          "14:     function __ERC4626FeesMock_init(",
          "15:         uint256 entryFeeBasePoint,",
          "16:         address entryFeeRecipient,",
          "17:         uint256 exitFeeBasePoint,",
          "18:         address exitFeeRecipient",
          "19:     ) internal onlyInitializing {",
          "20:         __ERC4626FeesMock_init_unchained(entryFeeBasePoint, entryFeeRecipient, exitFeeBasePoint, exitFeeRecipient);",
          "21:     }",
          "23:     function __ERC4626FeesMock_init_unchained(",
          "24:         uint256 entryFeeBasePoint,",
          "25:         address entryFeeRecipient,",
          "26:         uint256 exitFeeBasePoint,",
          "27:         address exitFeeRecipient",
          "28:     ) internal onlyInitializing {",
          "29:         _entryFeeBasePointValue = entryFeeBasePoint;",
          "30:         _entryFeeRecipientValue = entryFeeRecipient;",
          "31:         _exitFeeBasePointValue = exitFeeBasePoint;",
          "32:         _exitFeeRecipientValue = exitFeeRecipient;",
          "33:     }",
          "35:     function _entryFeeBasePoint() internal view virtual override returns (uint256) {",
          "36:         return _entryFeeBasePointValue;",
          "37:     }",
          "39:     function _entryFeeRecipient() internal view virtual override returns (address) {",
          "40:         return _entryFeeRecipientValue;",
          "41:     }",
          "43:     function _exitFeeBasePoint() internal view virtual override returns (uint256) {",
          "44:         return _exitFeeBasePointValue;",
          "45:     }",
          "47:     function _exitFeeRecipient() internal view virtual override returns (address) {",
          "48:         return _exitFeeRecipientValue;",
          "49:     }",
          "56:     uint256[46] private __gap;",
          "57: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC721ConsecutiveEnumerableMockUpgradeable.sol||contracts/mocks/token/ERC721ConsecutiveEnumerableMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC721ConsecutiveEnumerableMockUpgradeable.sol -> contracts/mocks/token/ERC721ConsecutiveEnumerableMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC721/extensions/ERC721ConsecutiveUpgradeable.sol\";",
          "6: import \"../../token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "9: contract ERC721ConsecutiveEnumerableMockUpgradeable is Initializable, ERC721ConsecutiveUpgradeable, ERC721EnumerableUpgradeable {",
          "10:     function __ERC721ConsecutiveEnumerableMock_init(",
          "11:         string memory name,",
          "12:         string memory symbol,",
          "13:         address[] memory receivers,",
          "14:         uint96[] memory amounts",
          "15:     ) internal onlyInitializing {",
          "16:         __ERC721_init_unchained(name, symbol);",
          "17:         __ERC721ConsecutiveEnumerableMock_init_unchained(name, symbol, receivers, amounts);",
          "18:     }",
          "20:     function __ERC721ConsecutiveEnumerableMock_init_unchained(",
          "21:         string memory,",
          "22:         string memory,",
          "23:         address[] memory receivers,",
          "24:         uint96[] memory amounts",
          "25:     ) internal onlyInitializing {",
          "26:         for (uint256 i = 0; i < receivers.length; ++i) {",
          "27:             _mintConsecutive(receivers[i], amounts[i]);",
          "28:         }",
          "29:     }",
          "31:     function supportsInterface(",
          "32:         bytes4 interfaceId",
          "33:     ) public view virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable) returns (bool) {",
          "34:         return super.supportsInterface(interfaceId);",
          "35:     }",
          "37:     function _ownerOf(uint256 tokenId) internal view virtual override(ERC721Upgradeable, ERC721ConsecutiveUpgradeable) returns (address) {",
          "38:         return super._ownerOf(tokenId);",
          "39:     }",
          "41:     function _mint(address to, uint256 tokenId) internal virtual override(ERC721Upgradeable, ERC721ConsecutiveUpgradeable) {",
          "42:         super._mint(to, tokenId);",
          "43:     }",
          "45:     function _beforeTokenTransfer(",
          "46:         address from,",
          "47:         address to,",
          "48:         uint256 firstTokenId,",
          "49:         uint256 batchSize",
          "50:     ) internal virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {",
          "51:         super._beforeTokenTransfer(from, to, firstTokenId, batchSize);",
          "52:     }",
          "54:     function _afterTokenTransfer(",
          "55:         address from,",
          "56:         address to,",
          "57:         uint256 firstTokenId,",
          "58:         uint256 batchSize",
          "59:     ) internal virtual override(ERC721Upgradeable, ERC721ConsecutiveUpgradeable) {",
          "60:         super._afterTokenTransfer(from, to, firstTokenId, batchSize);",
          "61:     }",
          "68:     uint256[50] private __gap;",
          "69: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC721ConsecutiveMockUpgradeable.sol||contracts/mocks/token/ERC721ConsecutiveMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC721ConsecutiveMockUpgradeable.sol -> contracts/mocks/token/ERC721ConsecutiveMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC721/extensions/ERC721ConsecutiveUpgradeable.sol\";",
          "6: import \"../../token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";",
          "7: import \"../../token/ERC721/extensions/ERC721PausableUpgradeable.sol\";",
          "8: import \"../../token/ERC721/extensions/draft-ERC721VotesUpgradeable.sol\";",
          "9: import \"../../proxy/utils/Initializable.sol\";",
          "14: contract ERC721ConsecutiveMockUpgradeable is Initializable, ERC721ConsecutiveUpgradeable, ERC721PausableUpgradeable, ERC721VotesUpgradeable {",
          "15:     function __ERC721ConsecutiveMock_init(",
          "16:         string memory name,",
          "17:         string memory symbol,",
          "18:         address[] memory delegates,",
          "19:         address[] memory receivers,",
          "20:         uint96[] memory amounts",
          "21:     ) internal onlyInitializing {",
          "22:         __ERC721_init_unchained(name, symbol);",
          "23:         __Pausable_init_unchained();",
          "24:         __EIP712_init_unchained(name, \"1\");",
          "25:         __ERC721ConsecutiveMock_init_unchained(name, symbol, delegates, receivers, amounts);",
          "26:     }",
          "28:     function __ERC721ConsecutiveMock_init_unchained(",
          "29:         string memory,",
          "30:         string memory,",
          "31:         address[] memory delegates,",
          "32:         address[] memory receivers,",
          "33:         uint96[] memory amounts",
          "34:     ) internal onlyInitializing {",
          "35:         for (uint256 i = 0; i < delegates.length; ++i) {",
          "36:             _delegate(delegates[i], delegates[i]);",
          "37:         }",
          "39:         for (uint256 i = 0; i < receivers.length; ++i) {",
          "40:             _mintConsecutive(receivers[i], amounts[i]);",
          "41:         }",
          "42:     }",
          "44:     function _ownerOf(uint256 tokenId) internal view virtual override(ERC721Upgradeable, ERC721ConsecutiveUpgradeable) returns (address) {",
          "45:         return super._ownerOf(tokenId);",
          "46:     }",
          "48:     function _mint(address to, uint256 tokenId) internal virtual override(ERC721Upgradeable, ERC721ConsecutiveUpgradeable) {",
          "49:         super._mint(to, tokenId);",
          "50:     }",
          "52:     function _beforeTokenTransfer(",
          "53:         address from,",
          "54:         address to,",
          "55:         uint256 firstTokenId,",
          "56:         uint256 batchSize",
          "57:     ) internal virtual override(ERC721Upgradeable, ERC721PausableUpgradeable) {",
          "58:         super._beforeTokenTransfer(from, to, firstTokenId, batchSize);",
          "59:     }",
          "61:     function _afterTokenTransfer(",
          "62:         address from,",
          "63:         address to,",
          "64:         uint256 firstTokenId,",
          "65:         uint256 batchSize",
          "66:     ) internal virtual override(ERC721Upgradeable, ERC721VotesUpgradeable, ERC721ConsecutiveUpgradeable) {",
          "67:         super._afterTokenTransfer(from, to, firstTokenId, batchSize);",
          "68:     }",
          "75:     uint256[50] private __gap;",
          "76: }",
          "78: contract ERC721ConsecutiveNoConstructorMintMockUpgradeable is Initializable, ERC721ConsecutiveUpgradeable {",
          "79:     function __ERC721ConsecutiveNoConstructorMintMock_init(string memory name, string memory symbol) internal onlyInitializing {",
          "80:         __ERC721_init_unchained(name, symbol);",
          "81:         __ERC721ConsecutiveNoConstructorMintMock_init_unchained(name, symbol);",
          "82:     }",
          "84:     function __ERC721ConsecutiveNoConstructorMintMock_init_unchained(string memory, string memory) internal onlyInitializing {",
          "85:         _mint(msg.sender, 0);",
          "86:     }",
          "93:     uint256[50] private __gap;",
          "94: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC721ReceiverMockUpgradeable.sol||contracts/mocks/token/ERC721ReceiverMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC721ReceiverMockUpgradeable.sol -> contracts/mocks/token/ERC721ReceiverMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC721/IERC721ReceiverUpgradeable.sol\";",
          "6: import \"../../proxy/utils/Initializable.sol\";",
          "8: contract ERC721ReceiverMockUpgradeable is Initializable, IERC721ReceiverUpgradeable {",
          "9:     enum Error {",
          "10:         None,",
          "11:         RevertWithMessage,",
          "12:         RevertWithoutMessage,",
          "13:         Panic",
          "14:     }",
          "16:     bytes4 private _retval;",
          "17:     Error private _error;",
          "19:     event Received(address operator, address from, uint256 tokenId, bytes data, uint256 gas);",
          "21:     function __ERC721ReceiverMock_init(bytes4 retval, Error error) internal onlyInitializing {",
          "22:         __ERC721ReceiverMock_init_unchained(retval, error);",
          "23:     }",
          "25:     function __ERC721ReceiverMock_init_unchained(bytes4 retval, Error error) internal onlyInitializing {",
          "26:         _retval = retval;",
          "27:         _error = error;",
          "28:     }",
          "30:     function onERC721Received(",
          "31:         address operator,",
          "32:         address from,",
          "33:         uint256 tokenId,",
          "34:         bytes memory data",
          "35:     ) public override returns (bytes4) {",
          "36:         if (_error == Error.RevertWithMessage) {",
          "37:             revert(\"ERC721ReceiverMock: reverting\");",
          "38:         } else if (_error == Error.RevertWithoutMessage) {",
          "39:             revert();",
          "40:         } else if (_error == Error.Panic) {",
          "41:             uint256 a = uint256(0) / uint256(0);",
          "42:             a;",
          "43:         }",
          "44:         emit Received(operator, from, tokenId, data, gasleft());",
          "45:         return _retval;",
          "46:     }",
          "53:     uint256[49] private __gap;",
          "54: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC721URIStorageMockUpgradeable.sol||contracts/mocks/token/ERC721URIStorageMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC721URIStorageMockUpgradeable.sol -> contracts/mocks/token/ERC721URIStorageMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";",
          "6: import \"../../proxy/utils/Initializable.sol\";",
          "8: abstract contract ERC721URIStorageMockUpgradeable is Initializable, ERC721URIStorageUpgradeable {",
          "9:     function __ERC721URIStorageMock_init() internal onlyInitializing {",
          "10:     }",
          "12:     function __ERC721URIStorageMock_init_unchained() internal onlyInitializing {",
          "13:     }",
          "14:     string private _baseTokenURI;",
          "16:     function _baseURI() internal view virtual override returns (string memory) {",
          "17:         return _baseTokenURI;",
          "18:     }",
          "20:     function setBaseURI(string calldata newBaseTokenURI) public {",
          "21:         _baseTokenURI = newBaseTokenURI;",
          "22:     }",
          "29:     uint256[49] private __gap;",
          "30: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC777MockUpgradeable.sol||contracts/mocks/token/ERC777MockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC777MockUpgradeable.sol -> contracts/mocks/token/ERC777MockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC777/ERC777Upgradeable.sol\";",
          "6: import \"../../proxy/utils/Initializable.sol\";",
          "8: abstract contract ERC777MockUpgradeable is Initializable, ERC777Upgradeable {",
          "9:     function __ERC777Mock_init() internal onlyInitializing {",
          "10:     }",
          "12:     function __ERC777Mock_init_unchained() internal onlyInitializing {",
          "13:     }",
          "14:     event BeforeTokenTransfer();",
          "16:     function _beforeTokenTransfer(address, address, address, uint256) internal override {",
          "17:         emit BeforeTokenTransfer();",
          "18:     }",
          "25:     uint256[50] private __gap;",
          "26: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/ERC777SenderRecipientMockUpgradeable.sol||contracts/mocks/token/ERC777SenderRecipientMockUpgradeable.sol": [
          "File: contracts/mocks/token/ERC777SenderRecipientMockUpgradeable.sol -> contracts/mocks/token/ERC777SenderRecipientMockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC777/IERC777Upgradeable.sol\";",
          "6: import \"../../token/ERC777/IERC777SenderUpgradeable.sol\";",
          "7: import \"../../token/ERC777/IERC777RecipientUpgradeable.sol\";",
          "8: import \"../../utils/ContextUpgradeable.sol\";",
          "9: import \"../../utils/introspection/IERC1820RegistryUpgradeable.sol\";",
          "10: import \"../../utils/introspection/ERC1820ImplementerUpgradeable.sol\";",
          "11: import \"../../proxy/utils/Initializable.sol\";",
          "13: contract ERC777SenderRecipientMockUpgradeable is Initializable, ContextUpgradeable, IERC777SenderUpgradeable, IERC777RecipientUpgradeable, ERC1820ImplementerUpgradeable {",
          "14:     function __ERC777SenderRecipientMock_init() internal onlyInitializing {",
          "15:         __ERC777SenderRecipientMock_init_unchained();",
          "16:     }",
          "18:     function __ERC777SenderRecipientMock_init_unchained() internal onlyInitializing {",
          "19:         _erc1820 = IERC1820RegistryUpgradeable(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);",
          "20:     }",
          "21:     event TokensToSendCalled(",
          "22:         address operator,",
          "23:         address from,",
          "24:         address to,",
          "25:         uint256 amount,",
          "26:         bytes data,",
          "27:         bytes operatorData,",
          "28:         address token,",
          "29:         uint256 fromBalance,",
          "30:         uint256 toBalance",
          "31:     );",
          "33:     event TokensReceivedCalled(",
          "34:         address operator,",
          "35:         address from,",
          "36:         address to,",
          "37:         uint256 amount,",
          "38:         bytes data,",
          "39:         bytes operatorData,",
          "40:         address token,",
          "41:         uint256 fromBalance,",
          "42:         uint256 toBalance",
          "43:     );",
          "46:     event BeforeTokenTransfer();",
          "48:     bool private _shouldRevertSend;",
          "49:     bool private _shouldRevertReceive;",
          "51:     IERC1820RegistryUpgradeable private _erc1820;",
          "53:     bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256(\"ERC777TokensSender\");",
          "54:     bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");",
          "56:     function tokensToSend(",
          "57:         address operator,",
          "58:         address from,",
          "59:         address to,",
          "60:         uint256 amount,",
          "61:         bytes calldata userData,",
          "62:         bytes calldata operatorData",
          "63:     ) external override {",
          "64:         if (_shouldRevertSend) {",
          "65:             revert();",
          "66:         }",
          "68:         IERC777Upgradeable token = IERC777Upgradeable(_msgSender());",
          "70:         uint256 fromBalance = token.balanceOf(from);",
          "72:         uint256 toBalance = token.balanceOf(to);",
          "74:         emit TokensToSendCalled(",
          "75:             operator,",
          "76:             from,",
          "77:             to,",
          "78:             amount,",
          "79:             userData,",
          "80:             operatorData,",
          "81:             address(token),",
          "82:             fromBalance,",
          "83:             toBalance",
          "84:         );",
          "85:     }",
          "87:     function tokensReceived(",
          "88:         address operator,",
          "89:         address from,",
          "90:         address to,",
          "91:         uint256 amount,",
          "92:         bytes calldata userData,",
          "93:         bytes calldata operatorData",
          "94:     ) external override {",
          "95:         if (_shouldRevertReceive) {",
          "96:             revert();",
          "97:         }",
          "99:         IERC777Upgradeable token = IERC777Upgradeable(_msgSender());",
          "101:         uint256 fromBalance = token.balanceOf(from);",
          "103:         uint256 toBalance = token.balanceOf(to);",
          "105:         emit TokensReceivedCalled(",
          "106:             operator,",
          "107:             from,",
          "108:             to,",
          "109:             amount,",
          "110:             userData,",
          "111:             operatorData,",
          "112:             address(token),",
          "113:             fromBalance,",
          "114:             toBalance",
          "115:         );",
          "116:     }",
          "118:     function senderFor(address account) public {",
          "119:         _registerInterfaceForAddress(_TOKENS_SENDER_INTERFACE_HASH, account);",
          "121:         address self = address(this);",
          "122:         if (account == self) {",
          "123:             registerSender(self);",
          "124:         }",
          "125:     }",
          "127:     function registerSender(address sender) public {",
          "128:         _erc1820.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, sender);",
          "129:     }",
          "131:     function recipientFor(address account) public {",
          "132:         _registerInterfaceForAddress(_TOKENS_RECIPIENT_INTERFACE_HASH, account);",
          "134:         address self = address(this);",
          "135:         if (account == self) {",
          "136:             registerRecipient(self);",
          "137:         }",
          "138:     }",
          "140:     function registerRecipient(address recipient) public {",
          "141:         _erc1820.setInterfaceImplementer(address(this), _TOKENS_RECIPIENT_INTERFACE_HASH, recipient);",
          "142:     }",
          "144:     function setShouldRevertSend(bool shouldRevert) public {",
          "145:         _shouldRevertSend = shouldRevert;",
          "146:     }",
          "148:     function setShouldRevertReceive(bool shouldRevert) public {",
          "149:         _shouldRevertReceive = shouldRevert;",
          "150:     }",
          "152:     function send(IERC777Upgradeable token, address to, uint256 amount, bytes memory data) public {",
          "154:         token.send(to, amount, data); // solhint-disable-line check-send-result",
          "155:     }",
          "157:     function burn(IERC777Upgradeable token, uint256 amount, bytes memory data) public {",
          "158:         token.burn(amount, data);",
          "159:     }",
          "166:     uint256[49] private __gap;",
          "167: }",
          "",
          "---------------"
        ],
        "contracts/mocks/token/VotesTimestampUpgradeable.sol||contracts/mocks/token/VotesTimestampUpgradeable.sol": [
          "File: contracts/mocks/token/VotesTimestampUpgradeable.sol -> contracts/mocks/token/VotesTimestampUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../../token/ERC20/extensions/ERC20VotesUpgradeable.sol\";",
          "6: import \"../../token/ERC20/extensions/ERC20VotesCompUpgradeable.sol\";",
          "7: import \"../../token/ERC721/extensions/ERC721VotesUpgradeable.sol\";",
          "8: import \"../../proxy/utils/Initializable.sol\";",
          "10: abstract contract ERC20VotesTimestampMockUpgradeable is Initializable, ERC20VotesUpgradeable {",
          "11:     function __ERC20VotesTimestampMock_init() internal onlyInitializing {",
          "12:     }",
          "14:     function __ERC20VotesTimestampMock_init_unchained() internal onlyInitializing {",
          "15:     }",
          "16:     function clock() public view virtual override returns (uint48) {",
          "17:         return SafeCastUpgradeable.toUint48(block.timestamp);",
          "18:     }",
          "21:     function CLOCK_MODE() public view virtual override returns (string memory) {",
          "22:         return \"mode=timestamp\";",
          "23:     }",
          "30:     uint256[50] private __gap;",
          "31: }",
          "33: abstract contract ERC20VotesCompTimestampMockUpgradeable is Initializable, ERC20VotesCompUpgradeable {",
          "34:     function __ERC20VotesCompTimestampMock_init() internal onlyInitializing {",
          "35:     }",
          "37:     function __ERC20VotesCompTimestampMock_init_unchained() internal onlyInitializing {",
          "38:     }",
          "39:     function clock() public view virtual override returns (uint48) {",
          "40:         return SafeCastUpgradeable.toUint48(block.timestamp);",
          "41:     }",
          "44:     function CLOCK_MODE() public view virtual override returns (string memory) {",
          "45:         return \"mode=timestamp\";",
          "46:     }",
          "53:     uint256[50] private __gap;",
          "54: }",
          "56: abstract contract ERC721VotesTimestampMockUpgradeable is Initializable, ERC721VotesUpgradeable {",
          "57:     function __ERC721VotesTimestampMock_init() internal onlyInitializing {",
          "58:     }",
          "60:     function __ERC721VotesTimestampMock_init_unchained() internal onlyInitializing {",
          "61:     }",
          "62:     function clock() public view virtual override returns (uint48) {",
          "63:         return SafeCastUpgradeable.toUint48(block.timestamp);",
          "64:     }",
          "67:     function CLOCK_MODE() public view virtual override returns (string memory) {",
          "68:         return \"mode=timestamp\";",
          "69:     }",
          "76:     uint256[50] private __gap;",
          "77: }",
          "",
          "---------------"
        ],
        "contracts/mocks/wizard/MyGovernor1Upgradeable.sol||contracts/mocks/wizard/MyGovernor1Upgradeable.sol": [
          "File: contracts/mocks/wizard/MyGovernor1Upgradeable.sol -> contracts/mocks/wizard/MyGovernor1Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: pragma solidity ^0.8.2;",
          "4: import \"../../governance/GovernorUpgradeable.sol\";",
          "5: import \"../../governance/extensions/GovernorCountingSimpleUpgradeable.sol\";",
          "6: import \"../../governance/extensions/GovernorVotesUpgradeable.sol\";",
          "7: import \"../../governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";",
          "8: import \"../../governance/extensions/GovernorTimelockControlUpgradeable.sol\";",
          "9: import \"../../proxy/utils/Initializable.sol\";",
          "11: contract MyGovernor1Upgradeable is",
          "12:     Initializable, GovernorUpgradeable,",
          "13:     GovernorTimelockControlUpgradeable,",
          "14:     GovernorVotesUpgradeable,",
          "15:     GovernorVotesQuorumFractionUpgradeable,",
          "16:     GovernorCountingSimpleUpgradeable",
          "17: {",
          "18:     function __MyGovernor1_init(",
          "19:         IVotesUpgradeable _token,",
          "20:         TimelockControllerUpgradeable _timelock",
          "21:     ) internal onlyInitializing {",
          "22:         __EIP712_init_unchained(\"MyGovernor\", version());",
          "23:         __Governor_init_unchained(\"MyGovernor\");",
          "24:         __GovernorTimelockControl_init_unchained(_timelock);",
          "25:         __GovernorVotes_init_unchained(_token);",
          "26:         __GovernorVotesQuorumFraction_init_unchained(4);",
          "27:     }",
          "29:     function __MyGovernor1_init_unchained(",
          "30:         IVotesUpgradeable,",
          "31:         TimelockControllerUpgradeable",
          "32:     ) internal onlyInitializing {}",
          "34:     function votingDelay() public pure override returns (uint256) {",
          "35:         return 1; // 1 block",
          "36:     }",
          "38:     function votingPeriod() public pure override returns (uint256) {",
          "39:         return 45818; // 1 week",
          "40:     }",
          "44:     function quorum(",
          "45:         uint256 blockNumber",
          "46:     ) public view override(IGovernorUpgradeable, GovernorVotesQuorumFractionUpgradeable) returns (uint256) {",
          "47:         return super.quorum(blockNumber);",
          "48:     }",
          "50:     function state(uint256 proposalId) public view override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (ProposalState) {",
          "51:         return super.state(proposalId);",
          "52:     }",
          "54:     function propose(",
          "55:         address[] memory targets,",
          "56:         uint256[] memory values,",
          "57:         bytes[] memory calldatas,",
          "58:         string memory description",
          "59:     ) public override(GovernorUpgradeable, IGovernorUpgradeable) returns (uint256) {",
          "60:         return super.propose(targets, values, calldatas, description);",
          "61:     }",
          "63:     function _execute(",
          "64:         uint256 proposalId,",
          "65:         address[] memory targets,",
          "66:         uint256[] memory values,",
          "67:         bytes[] memory calldatas,",
          "68:         bytes32 descriptionHash",
          "69:     ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) {",
          "70:         super._execute(proposalId, targets, values, calldatas, descriptionHash);",
          "71:     }",
          "73:     function _cancel(",
          "74:         address[] memory targets,",
          "75:         uint256[] memory values,",
          "76:         bytes[] memory calldatas,",
          "77:         bytes32 descriptionHash",
          "78:     ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint256) {",
          "79:         return super._cancel(targets, values, calldatas, descriptionHash);",
          "80:     }",
          "82:     function _executor() internal view override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (address) {",
          "83:         return super._executor();",
          "84:     }",
          "86:     function supportsInterface(",
          "87:         bytes4 interfaceId",
          "88:     ) public view override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (bool) {",
          "89:         return super.supportsInterface(interfaceId);",
          "90:     }",
          "97:     uint256[50] private __gap;",
          "98: }",
          "",
          "---------------"
        ],
        "contracts/mocks/wizard/MyGovernor2Upgradeable.sol||contracts/mocks/wizard/MyGovernor2Upgradeable.sol": [
          "File: contracts/mocks/wizard/MyGovernor2Upgradeable.sol -> contracts/mocks/wizard/MyGovernor2Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: pragma solidity ^0.8.2;",
          "4: import \"../../governance/GovernorUpgradeable.sol\";",
          "5: import \"../../governance/extensions/GovernorProposalThresholdUpgradeable.sol\";",
          "6: import \"../../governance/extensions/GovernorCountingSimpleUpgradeable.sol\";",
          "7: import \"../../governance/extensions/GovernorVotesUpgradeable.sol\";",
          "8: import \"../../governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";",
          "9: import \"../../governance/extensions/GovernorTimelockControlUpgradeable.sol\";",
          "10: import \"../../proxy/utils/Initializable.sol\";",
          "12: contract MyGovernor2Upgradeable is",
          "13:     Initializable, GovernorUpgradeable,",
          "14:     GovernorTimelockControlUpgradeable,",
          "15:     GovernorProposalThresholdUpgradeable,",
          "16:     GovernorVotesUpgradeable,",
          "17:     GovernorVotesQuorumFractionUpgradeable,",
          "18:     GovernorCountingSimpleUpgradeable",
          "19: {",
          "20:     function __MyGovernor2_init(",
          "21:         IVotesUpgradeable _token,",
          "22:         TimelockControllerUpgradeable _timelock",
          "23:     ) internal onlyInitializing {",
          "24:         __EIP712_init_unchained(\"MyGovernor\", version());",
          "25:         __Governor_init_unchained(\"MyGovernor\");",
          "26:         __GovernorTimelockControl_init_unchained(_timelock);",
          "27:         __GovernorVotes_init_unchained(_token);",
          "28:         __GovernorVotesQuorumFraction_init_unchained(4);",
          "29:     }",
          "31:     function __MyGovernor2_init_unchained(",
          "32:         IVotesUpgradeable,",
          "33:         TimelockControllerUpgradeable",
          "34:     ) internal onlyInitializing {}",
          "36:     function votingDelay() public pure override returns (uint256) {",
          "37:         return 1; // 1 block",
          "38:     }",
          "40:     function votingPeriod() public pure override returns (uint256) {",
          "41:         return 45818; // 1 week",
          "42:     }",
          "44:     function proposalThreshold() public pure override returns (uint256) {",
          "45:         return 1000e18;",
          "46:     }",
          "50:     function quorum(",
          "51:         uint256 blockNumber",
          "52:     ) public view override(IGovernorUpgradeable, GovernorVotesQuorumFractionUpgradeable) returns (uint256) {",
          "53:         return super.quorum(blockNumber);",
          "54:     }",
          "56:     function state(uint256 proposalId) public view override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (ProposalState) {",
          "57:         return super.state(proposalId);",
          "58:     }",
          "60:     function propose(",
          "61:         address[] memory targets,",
          "62:         uint256[] memory values,",
          "63:         bytes[] memory calldatas,",
          "64:         string memory description",
          "65:     ) public override(GovernorUpgradeable, GovernorProposalThresholdUpgradeable, IGovernorUpgradeable) returns (uint256) {",
          "66:         return super.propose(targets, values, calldatas, description);",
          "67:     }",
          "69:     function _execute(",
          "70:         uint256 proposalId,",
          "71:         address[] memory targets,",
          "72:         uint256[] memory values,",
          "73:         bytes[] memory calldatas,",
          "74:         bytes32 descriptionHash",
          "75:     ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) {",
          "76:         super._execute(proposalId, targets, values, calldatas, descriptionHash);",
          "77:     }",
          "79:     function _cancel(",
          "80:         address[] memory targets,",
          "81:         uint256[] memory values,",
          "82:         bytes[] memory calldatas,",
          "83:         bytes32 descriptionHash",
          "84:     ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint256) {",
          "85:         return super._cancel(targets, values, calldatas, descriptionHash);",
          "86:     }",
          "88:     function _executor() internal view override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (address) {",
          "89:         return super._executor();",
          "90:     }",
          "92:     function supportsInterface(",
          "93:         bytes4 interfaceId",
          "94:     ) public view override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (bool) {",
          "95:         return super.supportsInterface(interfaceId);",
          "96:     }",
          "103:     uint256[50] private __gap;",
          "104: }",
          "",
          "---------------"
        ],
        "contracts/mocks/wizard/MyGovernor3Upgradeable.sol||contracts/mocks/wizard/MyGovernor3Upgradeable.sol": [
          "File: contracts/mocks/wizard/MyGovernor3Upgradeable.sol -> contracts/mocks/wizard/MyGovernor3Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: pragma solidity ^0.8.2;",
          "4: import \"../../governance/GovernorUpgradeable.sol\";",
          "5: import \"../../governance/compatibility/GovernorCompatibilityBravoUpgradeable.sol\";",
          "6: import \"../../governance/extensions/GovernorVotesUpgradeable.sol\";",
          "7: import \"../../governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";",
          "8: import \"../../governance/extensions/GovernorTimelockControlUpgradeable.sol\";",
          "9: import \"../../proxy/utils/Initializable.sol\";",
          "11: contract MyGovernorUpgradeable is",
          "12:     Initializable, GovernorUpgradeable,",
          "13:     GovernorTimelockControlUpgradeable,",
          "14:     GovernorCompatibilityBravoUpgradeable,",
          "15:     GovernorVotesUpgradeable,",
          "16:     GovernorVotesQuorumFractionUpgradeable",
          "17: {",
          "18:     function __MyGovernor_init(",
          "19:         IVotesUpgradeable _token,",
          "20:         TimelockControllerUpgradeable _timelock",
          "21:     ) internal onlyInitializing {",
          "22:         __EIP712_init_unchained(\"MyGovernor\", version());",
          "23:         __Governor_init_unchained(\"MyGovernor\");",
          "24:         __GovernorTimelockControl_init_unchained(_timelock);",
          "25:         __GovernorVotes_init_unchained(_token);",
          "26:         __GovernorVotesQuorumFraction_init_unchained(4);",
          "27:     }",
          "29:     function __MyGovernor_init_unchained(",
          "30:         IVotesUpgradeable,",
          "31:         TimelockControllerUpgradeable",
          "32:     ) internal onlyInitializing {}",
          "34:     function votingDelay() public pure override returns (uint256) {",
          "35:         return 1; // 1 block",
          "36:     }",
          "38:     function votingPeriod() public pure override returns (uint256) {",
          "39:         return 45818; // 1 week",
          "40:     }",
          "42:     function proposalThreshold() public pure override returns (uint256) {",
          "43:         return 1000e18;",
          "44:     }",
          "48:     function quorum(",
          "49:         uint256 blockNumber",
          "50:     ) public view override(IGovernorUpgradeable, GovernorVotesQuorumFractionUpgradeable) returns (uint256) {",
          "51:         return super.quorum(blockNumber);",
          "52:     }",
          "54:     function state(",
          "55:         uint256 proposalId",
          "56:     ) public view override(GovernorUpgradeable, IGovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (ProposalState) {",
          "57:         return super.state(proposalId);",
          "58:     }",
          "60:     function propose(",
          "61:         address[] memory targets,",
          "62:         uint256[] memory values,",
          "63:         bytes[] memory calldatas,",
          "64:         string memory description",
          "65:     ) public override(GovernorUpgradeable, GovernorCompatibilityBravoUpgradeable, IGovernorUpgradeable) returns (uint256) {",
          "66:         return super.propose(targets, values, calldatas, description);",
          "67:     }",
          "69:     function cancel(",
          "70:         address[] memory targets,",
          "71:         uint256[] memory values,",
          "72:         bytes[] memory calldatas,",
          "73:         bytes32 descriptionHash",
          "74:     ) public override(GovernorUpgradeable, GovernorCompatibilityBravoUpgradeable, IGovernorUpgradeable) returns (uint256) {",
          "75:         return super.cancel(targets, values, calldatas, descriptionHash);",
          "76:     }",
          "78:     function _execute(",
          "79:         uint256 proposalId,",
          "80:         address[] memory targets,",
          "81:         uint256[] memory values,",
          "82:         bytes[] memory calldatas,",
          "83:         bytes32 descriptionHash",
          "84:     ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) {",
          "85:         super._execute(proposalId, targets, values, calldatas, descriptionHash);",
          "86:     }",
          "88:     function _cancel(",
          "89:         address[] memory targets,",
          "90:         uint256[] memory values,",
          "91:         bytes[] memory calldatas,",
          "92:         bytes32 descriptionHash",
          "93:     ) internal override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (uint256) {",
          "94:         return super._cancel(targets, values, calldatas, descriptionHash);",
          "95:     }",
          "97:     function _executor() internal view override(GovernorUpgradeable, GovernorTimelockControlUpgradeable) returns (address) {",
          "98:         return super._executor();",
          "99:     }",
          "101:     function supportsInterface(",
          "102:         bytes4 interfaceId",
          "103:     ) public view override(GovernorUpgradeable, IERC165Upgradeable, GovernorTimelockControlUpgradeable) returns (bool) {",
          "104:         return super.supportsInterface(interfaceId);",
          "105:     }",
          "112:     uint256[50] private __gap;",
          "113: }",
          "",
          "---------------"
        ],
        "contracts/proxy/ClonesUpgradeable.sol||contracts/proxy/ClonesUpgradeable.sol": [
          "File: contracts/proxy/ClonesUpgradeable.sol -> contracts/proxy/ClonesUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "19: library ClonesUpgradeable {",
          "25:     function clone(address implementation) internal returns (address instance) {",
          "27:         assembly {",
          "30:             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))",
          "32:             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))",
          "33:             instance := create(0, 0x09, 0x37)",
          "34:         }",
          "35:         require(instance != address(0), \"ERC1167: create failed\");",
          "36:     }",
          "45:     function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {",
          "47:         assembly {",
          "50:             mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))",
          "52:             mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))",
          "53:             instance := create2(0, 0x09, 0x37, salt)",
          "54:         }",
          "55:         require(instance != address(0), \"ERC1167: create2 failed\");",
          "56:     }",
          "61:     function predictDeterministicAddress(",
          "62:         address implementation,",
          "63:         bytes32 salt,",
          "64:         address deployer",
          "65:     ) internal pure returns (address predicted) {",
          "67:         assembly {",
          "68:             let ptr := mload(0x40)",
          "69:             mstore(add(ptr, 0x38), deployer)",
          "70:             mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)",
          "71:             mstore(add(ptr, 0x14), implementation)",
          "72:             mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)",
          "73:             mstore(add(ptr, 0x58), salt)",
          "74:             mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))",
          "75:             predicted := keccak256(add(ptr, 0x43), 0x55)",
          "76:         }",
          "77:     }",
          "82:     function predictDeterministicAddress(",
          "83:         address implementation,",
          "84:         bytes32 salt",
          "85:     ) internal view returns (address predicted) {",
          "86:         return predictDeterministicAddress(implementation, salt, address(this));",
          "87:     }",
          "88: }",
          "",
          "---------------"
        ],
        "contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol||contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": [
          "File: contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol -> contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.2;",
          "6: import \"../beacon/IBeaconUpgradeable.sol\";",
          "7: import \"../../interfaces/IERC1967Upgradeable.sol\";",
          "8: import \"../../interfaces/draft-IERC1822Upgradeable.sol\";",
          "9: import \"../../utils/AddressUpgradeable.sol\";",
          "10: import \"../../utils/StorageSlotUpgradeable.sol\";",
          "11: import \"../utils/Initializable.sol\";",
          "19: abstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {",
          "20:     function __ERC1967Upgrade_init() internal onlyInitializing {",
          "21:     }",
          "23:     function __ERC1967Upgrade_init_unchained() internal onlyInitializing {",
          "24:     }",
          "26:     bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;",
          "33:     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;",
          "38:     function _getImplementation() internal view returns (address) {",
          "39:         return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;",
          "40:     }",
          "45:     function _setImplementation(address newImplementation) private {",
          "46:         require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");",
          "47:         StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;",
          "48:     }",
          "55:     function _upgradeTo(address newImplementation) internal {",
          "56:         _setImplementation(newImplementation);",
          "57:         emit Upgraded(newImplementation);",
          "58:     }",
          "65:     function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {",
          "66:         _upgradeTo(newImplementation);",
          "67:         if (data.length > 0 || forceCall) {",
          "68:             AddressUpgradeable.functionDelegateCall(newImplementation, data);",
          "69:         }",
          "70:     }",
          "77:     function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {",
          "81:         if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {",
          "82:             _setImplementation(newImplementation);",
          "83:         } else {",
          "84:             try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {",
          "85:                 require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");",
          "86:             } catch {",
          "87:                 revert(\"ERC1967Upgrade: new implementation is not UUPS\");",
          "88:             }",
          "89:             _upgradeToAndCall(newImplementation, data, forceCall);",
          "90:         }",
          "91:     }",
          "98:     bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;",
          "103:     function _getAdmin() internal view returns (address) {",
          "104:         return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;",
          "105:     }",
          "110:     function _setAdmin(address newAdmin) private {",
          "111:         require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");",
          "112:         StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;",
          "113:     }",
          "120:     function _changeAdmin(address newAdmin) internal {",
          "121:         emit AdminChanged(_getAdmin(), newAdmin);",
          "122:         _setAdmin(newAdmin);",
          "123:     }",
          "129:     bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;",
          "134:     function _getBeacon() internal view returns (address) {",
          "135:         return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;",
          "136:     }",
          "141:     function _setBeacon(address newBeacon) private {",
          "142:         require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");",
          "143:         require(",
          "144:             AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),",
          "145:             \"ERC1967: beacon implementation is not a contract\"",
          "146:         );",
          "147:         StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;",
          "148:     }",
          "156:     function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {",
          "157:         _setBeacon(newBeacon);",
          "158:         emit BeaconUpgraded(newBeacon);",
          "159:         if (data.length > 0 || forceCall) {",
          "160:             AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);",
          "161:         }",
          "162:     }",
          "169:     uint256[50] private __gap;",
          "170: }",
          "",
          "---------------"
        ],
        "contracts/proxy/beacon/IBeaconUpgradeable.sol||contracts/proxy/beacon/IBeaconUpgradeable.sol": [
          "File: contracts/proxy/beacon/IBeaconUpgradeable.sol -> contracts/proxy/beacon/IBeaconUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "9: interface IBeaconUpgradeable {",
          "15:     function implementation() external view returns (address);",
          "16: }",
          "",
          "---------------"
        ],
        "contracts/proxy/utils/Initializable.sol||contracts/proxy/utils/Initializable.sol": [
          "File: contracts/proxy/utils/Initializable.sol -> contracts/proxy/utils/Initializable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.2;",
          "6: import \"../../utils/AddressUpgradeable.sol\";",
          "58: abstract contract Initializable {",
          "63:     uint8 private _initialized;",
          "68:     bool private _initializing;",
          "73:     event Initialized(uint8 version);",
          "84:     modifier initializer() {",
          "85:         bool isTopLevelCall = !_initializing;",
          "86:         require(",
          "87:             (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),",
          "88:             \"Initializable: contract is already initialized\"",
          "89:         );",
          "90:         _initialized = 1;",
          "91:         if (isTopLevelCall) {",
          "92:             _initializing = true;",
          "93:         }",
          "94:         _;",
          "95:         if (isTopLevelCall) {",
          "96:             _initializing = false;",
          "97:             emit Initialized(1);",
          "98:         }",
          "99:     }",
          "119:     modifier reinitializer(uint8 version) {",
          "120:         require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");",
          "121:         _initialized = version;",
          "122:         _initializing = true;",
          "123:         _;",
          "124:         _initializing = false;",
          "125:         emit Initialized(version);",
          "126:     }",
          "132:     modifier onlyInitializing() {",
          "133:         require(_initializing, \"Initializable: contract is not initializing\");",
          "134:         _;",
          "135:     }",
          "145:     function _disableInitializers() internal virtual {",
          "146:         require(!_initializing, \"Initializable: contract is initializing\");",
          "147:         if (_initialized != type(uint8).max) {",
          "148:             _initialized = type(uint8).max;",
          "149:             emit Initialized(type(uint8).max);",
          "150:         }",
          "151:     }",
          "156:     function _getInitializedVersion() internal view returns (uint8) {",
          "157:         return _initialized;",
          "158:     }",
          "163:     function _isInitializing() internal view returns (bool) {",
          "164:         return _initializing;",
          "165:     }",
          "166: }",
          "",
          "---------------"
        ],
        "contracts/proxy/utils/UUPSUpgradeable.sol||contracts/proxy/utils/UUPSUpgradeable.sol": [
          "File: contracts/proxy/utils/UUPSUpgradeable.sol -> contracts/proxy/utils/UUPSUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../../interfaces/draft-IERC1822Upgradeable.sol\";",
          "7: import \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";",
          "8: import \"./Initializable.sol\";",
          "22: abstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {",
          "23:     function __UUPSUpgradeable_init() internal onlyInitializing {",
          "24:     }",
          "26:     function __UUPSUpgradeable_init_unchained() internal onlyInitializing {",
          "27:     }",
          "29:     address private immutable __self = address(this);",
          "38:     modifier onlyProxy() {",
          "39:         require(address(this) != __self, \"Function must be called through delegatecall\");",
          "40:         require(_getImplementation() == __self, \"Function must be called through active proxy\");",
          "41:         _;",
          "42:     }",
          "48:     modifier notDelegated() {",
          "49:         require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");",
          "50:         _;",
          "51:     }",
          "61:     function proxiableUUID() external view virtual override notDelegated returns (bytes32) {",
          "62:         return _IMPLEMENTATION_SLOT;",
          "63:     }",
          "74:     function upgradeTo(address newImplementation) public virtual onlyProxy {",
          "75:         _authorizeUpgrade(newImplementation);",
          "76:         _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);",
          "77:     }",
          "89:     function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {",
          "90:         _authorizeUpgrade(newImplementation);",
          "91:         _upgradeToAndCallUUPS(newImplementation, data, true);",
          "92:     }",
          "104:     function _authorizeUpgrade(address newImplementation) internal virtual;",
          "111:     uint256[50] private __gap;",
          "112: }",
          "",
          "---------------"
        ],
        "contracts/security/PausableUpgradeable.sol||contracts/security/PausableUpgradeable.sol": [
          "File: contracts/security/PausableUpgradeable.sol -> contracts/security/PausableUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../utils/ContextUpgradeable.sol\";",
          "7: import \"../proxy/utils/Initializable.sol\";",
          "18: abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {",
          "22:     event Paused(address account);",
          "27:     event Unpaused(address account);",
          "29:     bool private _paused;",
          "34:     function __Pausable_init() internal onlyInitializing {",
          "35:         __Pausable_init_unchained();",
          "36:     }",
          "38:     function __Pausable_init_unchained() internal onlyInitializing {",
          "39:         _paused = false;",
          "40:     }",
          "49:     modifier whenNotPaused() {",
          "50:         _requireNotPaused();",
          "51:         _;",
          "52:     }",
          "61:     modifier whenPaused() {",
          "62:         _requirePaused();",
          "63:         _;",
          "64:     }",
          "69:     function paused() public view virtual returns (bool) {",
          "70:         return _paused;",
          "71:     }",
          "76:     function _requireNotPaused() internal view virtual {",
          "77:         require(!paused(), \"Pausable: paused\");",
          "78:     }",
          "83:     function _requirePaused() internal view virtual {",
          "84:         require(paused(), \"Pausable: not paused\");",
          "85:     }",
          "94:     function _pause() internal virtual whenNotPaused {",
          "95:         _paused = true;",
          "96:         emit Paused(_msgSender());",
          "97:     }",
          "106:     function _unpause() internal virtual whenPaused {",
          "107:         _paused = false;",
          "108:         emit Unpaused(_msgSender());",
          "109:     }",
          "116:     uint256[49] private __gap;",
          "117: }",
          "",
          "---------------"
        ],
        "contracts/security/PullPaymentUpgradeable.sol||contracts/security/PullPaymentUpgradeable.sol": [
          "File: contracts/security/PullPaymentUpgradeable.sol -> contracts/security/PullPaymentUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../utils/escrow/EscrowUpgradeable.sol\";",
          "7: import \"../proxy/utils/Initializable.sol\";",
          "29: abstract contract PullPaymentUpgradeable is Initializable {",
          "30:     EscrowUpgradeable private _escrow;",
          "32:     function __PullPayment_init() internal onlyInitializing {",
          "33:         __PullPayment_init_unchained();",
          "34:     }",
          "36:     function __PullPayment_init_unchained() internal onlyInitializing {",
          "37:         _escrow = new EscrowUpgradeable();",
          "38:         _escrow.initialize();",
          "39:     }",
          "57:     function withdrawPayments(address payable payee) public virtual {",
          "58:         _escrow.withdraw(payee);",
          "59:     }",
          "65:     function payments(address dest) public view returns (uint256) {",
          "66:         return _escrow.depositsOf(dest);",
          "67:     }",
          "79:     function _asyncTransfer(address dest, uint256 amount) internal virtual {",
          "80:         _escrow.deposit{value: amount}(dest);",
          "81:     }",
          "88:     uint256[50] private __gap;",
          "89: }",
          "",
          "---------------"
        ],
        "contracts/security/ReentrancyGuardUpgradeable.sol||contracts/security/ReentrancyGuardUpgradeable.sol": [
          "File: contracts/security/ReentrancyGuardUpgradeable.sol -> contracts/security/ReentrancyGuardUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "5: import \"../proxy/utils/Initializable.sol\";",
          "23: abstract contract ReentrancyGuardUpgradeable is Initializable {",
          "35:     uint256 private constant _NOT_ENTERED = 1;",
          "36:     uint256 private constant _ENTERED = 2;",
          "38:     uint256 private _status;",
          "40:     function __ReentrancyGuard_init() internal onlyInitializing {",
          "41:         __ReentrancyGuard_init_unchained();",
          "42:     }",
          "44:     function __ReentrancyGuard_init_unchained() internal onlyInitializing {",
          "45:         _status = _NOT_ENTERED;",
          "46:     }",
          "55:     modifier nonReentrant() {",
          "56:         _nonReentrantBefore();",
          "57:         _;",
          "58:         _nonReentrantAfter();",
          "59:     }",
          "61:     function _nonReentrantBefore() private {",
          "63:         require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");",
          "66:         _status = _ENTERED;",
          "67:     }",
          "69:     function _nonReentrantAfter() private {",
          "72:         _status = _NOT_ENTERED;",
          "73:     }",
          "79:     function _reentrancyGuardEntered() internal view returns (bool) {",
          "80:         return _status == _ENTERED;",
          "81:     }",
          "88:     uint256[49] private __gap;",
          "89: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC1155/ERC1155Upgradeable.sol||contracts/token/ERC1155/ERC1155Upgradeable.sol": [
          "File: contracts/token/ERC1155/ERC1155Upgradeable.sol -> contracts/token/ERC1155/ERC1155Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IERC1155Upgradeable.sol\";",
          "7: import \"./IERC1155ReceiverUpgradeable.sol\";",
          "8: import \"./extensions/IERC1155MetadataURIUpgradeable.sol\";",
          "9: import \"../../utils/AddressUpgradeable.sol\";",
          "10: import \"../../utils/ContextUpgradeable.sol\";",
          "11: import \"../../utils/introspection/ERC165Upgradeable.sol\";",
          "12: import \"../../proxy/utils/Initializable.sol\";",
          "21: contract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {",
          "22:     using AddressUpgradeable for address;",
          "25:     mapping(uint256 => mapping(address => uint256)) private _balances;",
          "28:     mapping(address => mapping(address => bool)) private _operatorApprovals;",
          "31:     string private _uri;",
          "36:     function __ERC1155_init(string memory uri_) internal onlyInitializing {",
          "37:         __ERC1155_init_unchained(uri_);",
          "38:     }",
          "40:     function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {",
          "41:         _setURI(uri_);",
          "42:     }",
          "47:     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {",
          "48:         return",
          "49:             interfaceId == type(IERC1155Upgradeable).interfaceId ||",
          "50:             interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||",
          "51:             super.supportsInterface(interfaceId);",
          "52:     }",
          "64:     function uri(uint256) public view virtual override returns (string memory) {",
          "65:         return _uri;",
          "66:     }",
          "75:     function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {",
          "76:         require(account != address(0), \"ERC1155: address zero is not a valid owner\");",
          "77:         return _balances[id][account];",
          "78:     }",
          "87:     function balanceOfBatch(",
          "88:         address[] memory accounts,",
          "89:         uint256[] memory ids",
          "90:     ) public view virtual override returns (uint256[] memory) {",
          "91:         require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");",
          "93:         uint256[] memory batchBalances = new uint256[](accounts.length);",
          "95:         for (uint256 i = 0; i < accounts.length; ++i) {",
          "96:             batchBalances[i] = balanceOf(accounts[i], ids[i]);",
          "97:         }",
          "99:         return batchBalances;",
          "100:     }",
          "105:     function setApprovalForAll(address operator, bool approved) public virtual override {",
          "106:         _setApprovalForAll(_msgSender(), operator, approved);",
          "107:     }",
          "112:     function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {",
          "113:         return _operatorApprovals[account][operator];",
          "114:     }",
          "119:     function safeTransferFrom(",
          "120:         address from,",
          "121:         address to,",
          "122:         uint256 id,",
          "123:         uint256 amount,",
          "124:         bytes memory data",
          "125:     ) public virtual override {",
          "126:         require(",
          "127:             from == _msgSender() || isApprovedForAll(from, _msgSender()),",
          "128:             \"ERC1155: caller is not token owner or approved\"",
          "129:         );",
          "130:         _safeTransferFrom(from, to, id, amount, data);",
          "131:     }",
          "136:     function safeBatchTransferFrom(",
          "137:         address from,",
          "138:         address to,",
          "139:         uint256[] memory ids,",
          "140:         uint256[] memory amounts,",
          "141:         bytes memory data",
          "142:     ) public virtual override {",
          "143:         require(",
          "144:             from == _msgSender() || isApprovedForAll(from, _msgSender()),",
          "145:             \"ERC1155: caller is not token owner or approved\"",
          "146:         );",
          "147:         _safeBatchTransferFrom(from, to, ids, amounts, data);",
          "148:     }",
          "162:     function _safeTransferFrom(",
          "163:         address from,",
          "164:         address to,",
          "165:         uint256 id,",
          "166:         uint256 amount,",
          "167:         bytes memory data",
          "168:     ) internal virtual {",
          "169:         require(to != address(0), \"ERC1155: transfer to the zero address\");",
          "171:         address operator = _msgSender();",
          "172:         uint256[] memory ids = _asSingletonArray(id);",
          "173:         uint256[] memory amounts = _asSingletonArray(amount);",
          "175:         _beforeTokenTransfer(operator, from, to, ids, amounts, data);",
          "177:         uint256 fromBalance = _balances[id][from];",
          "178:         require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");",
          "179:         unchecked {",
          "180:             _balances[id][from] = fromBalance - amount;",
          "181:         }",
          "182:         _balances[id][to] += amount;",
          "184:         emit TransferSingle(operator, from, to, id, amount);",
          "186:         _afterTokenTransfer(operator, from, to, ids, amounts, data);",
          "188:         _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);",
          "189:     }",
          "201:     function _safeBatchTransferFrom(",
          "202:         address from,",
          "203:         address to,",
          "204:         uint256[] memory ids,",
          "205:         uint256[] memory amounts,",
          "206:         bytes memory data",
          "207:     ) internal virtual {",
          "208:         require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");",
          "209:         require(to != address(0), \"ERC1155: transfer to the zero address\");",
          "211:         address operator = _msgSender();",
          "213:         _beforeTokenTransfer(operator, from, to, ids, amounts, data);",
          "215:         for (uint256 i = 0; i < ids.length; ++i) {",
          "216:             uint256 id = ids[i];",
          "217:             uint256 amount = amounts[i];",
          "219:             uint256 fromBalance = _balances[id][from];",
          "220:             require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");",
          "221:             unchecked {",
          "222:                 _balances[id][from] = fromBalance - amount;",
          "223:             }",
          "224:             _balances[id][to] += amount;",
          "225:         }",
          "227:         emit TransferBatch(operator, from, to, ids, amounts);",
          "229:         _afterTokenTransfer(operator, from, to, ids, amounts, data);",
          "231:         _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);",
          "232:     }",
          "253:     function _setURI(string memory newuri) internal virtual {",
          "254:         _uri = newuri;",
          "255:     }",
          "268:     function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {",
          "269:         require(to != address(0), \"ERC1155: mint to the zero address\");",
          "271:         address operator = _msgSender();",
          "272:         uint256[] memory ids = _asSingletonArray(id);",
          "273:         uint256[] memory amounts = _asSingletonArray(amount);",
          "275:         _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);",
          "277:         _balances[id][to] += amount;",
          "278:         emit TransferSingle(operator, address(0), to, id, amount);",
          "280:         _afterTokenTransfer(operator, address(0), to, ids, amounts, data);",
          "282:         _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);",
          "283:     }",
          "296:     function _mintBatch(",
          "297:         address to,",
          "298:         uint256[] memory ids,",
          "299:         uint256[] memory amounts,",
          "300:         bytes memory data",
          "301:     ) internal virtual {",
          "302:         require(to != address(0), \"ERC1155: mint to the zero address\");",
          "303:         require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");",
          "305:         address operator = _msgSender();",
          "307:         _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);",
          "309:         for (uint256 i = 0; i < ids.length; i++) {",
          "310:             _balances[ids[i]][to] += amounts[i];",
          "311:         }",
          "313:         emit TransferBatch(operator, address(0), to, ids, amounts);",
          "315:         _afterTokenTransfer(operator, address(0), to, ids, amounts, data);",
          "317:         _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);",
          "318:     }",
          "330:     function _burn(address from, uint256 id, uint256 amount) internal virtual {",
          "331:         require(from != address(0), \"ERC1155: burn from the zero address\");",
          "333:         address operator = _msgSender();",
          "334:         uint256[] memory ids = _asSingletonArray(id);",
          "335:         uint256[] memory amounts = _asSingletonArray(amount);",
          "337:         _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");",
          "339:         uint256 fromBalance = _balances[id][from];",
          "340:         require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");",
          "341:         unchecked {",
          "342:             _balances[id][from] = fromBalance - amount;",
          "343:         }",
          "345:         emit TransferSingle(operator, from, address(0), id, amount);",
          "347:         _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");",
          "348:     }",
          "359:     function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal virtual {",
          "360:         require(from != address(0), \"ERC1155: burn from the zero address\");",
          "361:         require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");",
          "363:         address operator = _msgSender();",
          "365:         _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");",
          "367:         for (uint256 i = 0; i < ids.length; i++) {",
          "368:             uint256 id = ids[i];",
          "369:             uint256 amount = amounts[i];",
          "371:             uint256 fromBalance = _balances[id][from];",
          "372:             require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");",
          "373:             unchecked {",
          "374:                 _balances[id][from] = fromBalance - amount;",
          "375:             }",
          "376:         }",
          "378:         emit TransferBatch(operator, from, address(0), ids, amounts);",
          "380:         _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");",
          "381:     }",
          "388:     function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {",
          "389:         require(owner != operator, \"ERC1155: setting approval status for self\");",
          "390:         _operatorApprovals[owner][operator] = approved;",
          "391:         emit ApprovalForAll(owner, operator, approved);",
          "392:     }",
          "414:     function _beforeTokenTransfer(",
          "415:         address operator,",
          "416:         address from,",
          "417:         address to,",
          "418:         uint256[] memory ids,",
          "419:         uint256[] memory amounts,",
          "420:         bytes memory data",
          "421:     ) internal virtual {}",
          "443:     function _afterTokenTransfer(",
          "444:         address operator,",
          "445:         address from,",
          "446:         address to,",
          "447:         uint256[] memory ids,",
          "448:         uint256[] memory amounts,",
          "449:         bytes memory data",
          "450:     ) internal virtual {}",
          "452:     function _doSafeTransferAcceptanceCheck(",
          "453:         address operator,",
          "454:         address from,",
          "455:         address to,",
          "456:         uint256 id,",
          "457:         uint256 amount,",
          "458:         bytes memory data",
          "459:     ) private {",
          "460:         if (to.isContract()) {",
          "461:             try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {",
          "462:                 if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {",
          "463:                     revert(\"ERC1155: ERC1155Receiver rejected tokens\");",
          "464:                 }",
          "465:             } catch Error(string memory reason) {",
          "466:                 revert(reason);",
          "467:             } catch {",
          "468:                 revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");",
          "469:             }",
          "470:         }",
          "471:     }",
          "473:     function _doSafeBatchTransferAcceptanceCheck(",
          "474:         address operator,",
          "475:         address from,",
          "476:         address to,",
          "477:         uint256[] memory ids,",
          "478:         uint256[] memory amounts,",
          "479:         bytes memory data",
          "480:     ) private {",
          "481:         if (to.isContract()) {",
          "482:             try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (",
          "483:                 bytes4 response",
          "484:             ) {",
          "485:                 if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {",
          "486:                     revert(\"ERC1155: ERC1155Receiver rejected tokens\");",
          "487:                 }",
          "488:             } catch Error(string memory reason) {",
          "489:                 revert(reason);",
          "490:             } catch {",
          "491:                 revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");",
          "492:             }",
          "493:         }",
          "494:     }",
          "496:     function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {",
          "497:         uint256[] memory array = new uint256[](1);",
          "498:         array[0] = element;",
          "500:         return array;",
          "501:     }",
          "508:     uint256[47] private __gap;",
          "509: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC1155/IERC1155ReceiverUpgradeable.sol||contracts/token/ERC1155/IERC1155ReceiverUpgradeable.sol": [
          "File: contracts/token/ERC1155/IERC1155ReceiverUpgradeable.sol -> contracts/token/ERC1155/IERC1155ReceiverUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../../utils/introspection/IERC165Upgradeable.sol\";",
          "11: interface IERC1155ReceiverUpgradeable is IERC165Upgradeable {",
          "27:     function onERC1155Received(",
          "28:         address operator,",
          "29:         address from,",
          "30:         uint256 id,",
          "31:         uint256 value,",
          "32:         bytes calldata data",
          "33:     ) external returns (bytes4);",
          "51:     function onERC1155BatchReceived(",
          "52:         address operator,",
          "53:         address from,",
          "54:         uint256[] calldata ids,",
          "55:         uint256[] calldata values,",
          "56:         bytes calldata data",
          "57:     ) external returns (bytes4);",
          "58: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC1155/IERC1155Upgradeable.sol||contracts/token/ERC1155/IERC1155Upgradeable.sol": [
          "File: contracts/token/ERC1155/IERC1155Upgradeable.sol -> contracts/token/ERC1155/IERC1155Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../../utils/introspection/IERC165Upgradeable.sol\";",
          "14: interface IERC1155Upgradeable is IERC165Upgradeable {",
          "18:     event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);",
          "24:     event TransferBatch(",
          "25:         address indexed operator,",
          "26:         address indexed from,",
          "27:         address indexed to,",
          "28:         uint256[] ids,",
          "29:         uint256[] values",
          "30:     );",
          "36:     event ApprovalForAll(address indexed account, address indexed operator, bool approved);",
          "45:     event URI(string value, uint256 indexed id);",
          "54:     function balanceOf(address account, uint256 id) external view returns (uint256);",
          "63:     function balanceOfBatch(",
          "64:         address[] calldata accounts,",
          "65:         uint256[] calldata ids",
          "66:     ) external view returns (uint256[] memory);",
          "77:     function setApprovalForAll(address operator, bool approved) external;",
          "84:     function isApprovedForAll(address account, address operator) external view returns (bool);",
          "99:     function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;",
          "112:     function safeBatchTransferFrom(",
          "113:         address from,",
          "114:         address to,",
          "115:         uint256[] calldata ids,",
          "116:         uint256[] calldata amounts,",
          "117:         bytes calldata data",
          "118:     ) external;",
          "119: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol||contracts/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol": [
          "File: contracts/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol -> contracts/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC1155Upgradeable.sol\";",
          "7: import \"../../../proxy/utils/Initializable.sol\";",
          "15: abstract contract ERC1155BurnableUpgradeable is Initializable, ERC1155Upgradeable {",
          "16:     function __ERC1155Burnable_init() internal onlyInitializing {",
          "17:     }",
          "19:     function __ERC1155Burnable_init_unchained() internal onlyInitializing {",
          "20:     }",
          "21:     function burn(address account, uint256 id, uint256 value) public virtual {",
          "22:         require(",
          "23:             account == _msgSender() || isApprovedForAll(account, _msgSender()),",
          "24:             \"ERC1155: caller is not token owner or approved\"",
          "25:         );",
          "27:         _burn(account, id, value);",
          "28:     }",
          "30:     function burnBatch(address account, uint256[] memory ids, uint256[] memory values) public virtual {",
          "31:         require(",
          "32:             account == _msgSender() || isApprovedForAll(account, _msgSender()),",
          "33:             \"ERC1155: caller is not token owner or approved\"",
          "34:         );",
          "36:         _burnBatch(account, ids, values);",
          "37:     }",
          "44:     uint256[50] private __gap;",
          "45: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol||contracts/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol": [
          "File: contracts/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol -> contracts/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC1155Upgradeable.sol\";",
          "7: import \"../../../security/PausableUpgradeable.sol\";",
          "8: import \"../../../proxy/utils/Initializable.sol\";",
          "25: abstract contract ERC1155PausableUpgradeable is Initializable, ERC1155Upgradeable, PausableUpgradeable {",
          "26:     function __ERC1155Pausable_init() internal onlyInitializing {",
          "27:         __Pausable_init_unchained();",
          "28:     }",
          "30:     function __ERC1155Pausable_init_unchained() internal onlyInitializing {",
          "31:     }",
          "39:     function _beforeTokenTransfer(",
          "40:         address operator,",
          "41:         address from,",
          "42:         address to,",
          "43:         uint256[] memory ids,",
          "44:         uint256[] memory amounts,",
          "45:         bytes memory data",
          "46:     ) internal virtual override {",
          "47:         super._beforeTokenTransfer(operator, from, to, ids, amounts, data);",
          "49:         require(!paused(), \"ERC1155Pausable: token transfer while paused\");",
          "50:     }",
          "57:     uint256[50] private __gap;",
          "58: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol||contracts/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol": [
          "File: contracts/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol -> contracts/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC1155Upgradeable.sol\";",
          "7: import \"../../../proxy/utils/Initializable.sol\";",
          "17: abstract contract ERC1155SupplyUpgradeable is Initializable, ERC1155Upgradeable {",
          "18:     function __ERC1155Supply_init() internal onlyInitializing {",
          "19:     }",
          "21:     function __ERC1155Supply_init_unchained() internal onlyInitializing {",
          "22:     }",
          "23:     mapping(uint256 => uint256) private _totalSupply;",
          "28:     function totalSupply(uint256 id) public view virtual returns (uint256) {",
          "29:         return _totalSupply[id];",
          "30:     }",
          "35:     function exists(uint256 id) public view virtual returns (bool) {",
          "36:         return ERC1155SupplyUpgradeable.totalSupply(id) > 0;",
          "37:     }",
          "42:     function _beforeTokenTransfer(",
          "43:         address operator,",
          "44:         address from,",
          "45:         address to,",
          "46:         uint256[] memory ids,",
          "47:         uint256[] memory amounts,",
          "48:         bytes memory data",
          "49:     ) internal virtual override {",
          "50:         super._beforeTokenTransfer(operator, from, to, ids, amounts, data);",
          "52:         if (from == address(0)) {",
          "53:             for (uint256 i = 0; i < ids.length; ++i) {",
          "54:                 _totalSupply[ids[i]] += amounts[i];",
          "55:             }",
          "56:         }",
          "58:         if (to == address(0)) {",
          "59:             for (uint256 i = 0; i < ids.length; ++i) {",
          "60:                 uint256 id = ids[i];",
          "61:                 uint256 amount = amounts[i];",
          "62:                 uint256 supply = _totalSupply[id];",
          "63:                 require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");",
          "64:                 unchecked {",
          "65:                     _totalSupply[id] = supply - amount;",
          "66:                 }",
          "67:             }",
          "68:         }",
          "69:     }",
          "76:     uint256[49] private __gap;",
          "77: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC1155/extensions/ERC1155URIStorageUpgradeable.sol||contracts/token/ERC1155/extensions/ERC1155URIStorageUpgradeable.sol": [
          "File: contracts/token/ERC1155/extensions/ERC1155URIStorageUpgradeable.sol -> contracts/token/ERC1155/extensions/ERC1155URIStorageUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../../../utils/StringsUpgradeable.sol\";",
          "7: import \"../ERC1155Upgradeable.sol\";",
          "8: import \"../../../proxy/utils/Initializable.sol\";",
          "16: abstract contract ERC1155URIStorageUpgradeable is Initializable, ERC1155Upgradeable {",
          "17:     function __ERC1155URIStorage_init() internal onlyInitializing {",
          "18:         __ERC1155URIStorage_init_unchained();",
          "19:     }",
          "21:     function __ERC1155URIStorage_init_unchained() internal onlyInitializing {",
          "22:         _baseURI = \"\";",
          "23:     }",
          "24:     using StringsUpgradeable for uint256;",
          "27:     string private _baseURI;",
          "30:     mapping(uint256 => string) private _tokenURIs;",
          "50:     function uri(uint256 tokenId) public view virtual override returns (string memory) {",
          "51:         string memory tokenURI = _tokenURIs[tokenId];",
          "54:         return bytes(tokenURI).length > 0 ? string(abi.encodePacked(_baseURI, tokenURI)) : super.uri(tokenId);",
          "55:     }",
          "60:     function _setURI(uint256 tokenId, string memory tokenURI) internal virtual {",
          "61:         _tokenURIs[tokenId] = tokenURI;",
          "62:         emit URI(uri(tokenId), tokenId);",
          "63:     }",
          "68:     function _setBaseURI(string memory baseURI) internal virtual {",
          "69:         _baseURI = baseURI;",
          "70:     }",
          "77:     uint256[48] private __gap;",
          "78: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol||contracts/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol": [
          "File: contracts/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol -> contracts/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../IERC1155Upgradeable.sol\";",
          "14: interface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {",
          "21:     function uri(uint256 id) external view returns (string memory);",
          "22: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC1155/presets/ERC1155PresetMinterPauserUpgradeable.sol||contracts/token/ERC1155/presets/ERC1155PresetMinterPauserUpgradeable.sol": [
          "File: contracts/token/ERC1155/presets/ERC1155PresetMinterPauserUpgradeable.sol -> contracts/token/ERC1155/presets/ERC1155PresetMinterPauserUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC1155Upgradeable.sol\";",
          "7: import \"../extensions/ERC1155BurnableUpgradeable.sol\";",
          "8: import \"../extensions/ERC1155PausableUpgradeable.sol\";",
          "9: import \"../../../access/AccessControlEnumerableUpgradeable.sol\";",
          "10: import \"../../../utils/ContextUpgradeable.sol\";",
          "11: import \"../../../proxy/utils/Initializable.sol\";",
          "29: contract ERC1155PresetMinterPauserUpgradeable is Initializable, ContextUpgradeable, AccessControlEnumerableUpgradeable, ERC1155BurnableUpgradeable, ERC1155PausableUpgradeable {",
          "30:     function initialize(string memory uri) public virtual initializer {",
          "31:         __ERC1155PresetMinterPauser_init(uri);",
          "32:     }",
          "33:     bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");",
          "34:     bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");",
          "40:     function __ERC1155PresetMinterPauser_init(string memory uri) internal onlyInitializing {",
          "41:         __ERC1155_init_unchained(uri);",
          "42:         __Pausable_init_unchained();",
          "43:         __ERC1155PresetMinterPauser_init_unchained(uri);",
          "44:     }",
          "46:     function __ERC1155PresetMinterPauser_init_unchained(string memory) internal onlyInitializing {",
          "47:         _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());",
          "49:         _setupRole(MINTER_ROLE, _msgSender());",
          "50:         _setupRole(PAUSER_ROLE, _msgSender());",
          "51:     }",
          "62:     function mint(address to, uint256 id, uint256 amount, bytes memory data) public virtual {",
          "63:         require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");",
          "65:         _mint(to, id, amount, data);",
          "66:     }",
          "71:     function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public virtual {",
          "72:         require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");",
          "74:         _mintBatch(to, ids, amounts, data);",
          "75:     }",
          "86:     function pause() public virtual {",
          "87:         require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have pauser role to pause\");",
          "88:         _pause();",
          "89:     }",
          "100:     function unpause() public virtual {",
          "101:         require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have pauser role to unpause\");",
          "102:         _unpause();",
          "103:     }",
          "108:     function supportsInterface(",
          "109:         bytes4 interfaceId",
          "110:     ) public view virtual override(AccessControlEnumerableUpgradeable, ERC1155Upgradeable) returns (bool) {",
          "111:         return super.supportsInterface(interfaceId);",
          "112:     }",
          "114:     function _beforeTokenTransfer(",
          "115:         address operator,",
          "116:         address from,",
          "117:         address to,",
          "118:         uint256[] memory ids,",
          "119:         uint256[] memory amounts,",
          "120:         bytes memory data",
          "121:     ) internal virtual override(ERC1155Upgradeable, ERC1155PausableUpgradeable) {",
          "122:         super._beforeTokenTransfer(operator, from, to, ids, amounts, data);",
          "123:     }",
          "130:     uint256[50] private __gap;",
          "131: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol||contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol": [
          "File: contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol -> contracts/token/ERC1155/utils/ERC1155HolderUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./ERC1155ReceiverUpgradeable.sol\";",
          "7: import \"../../../proxy/utils/Initializable.sol\";",
          "17: contract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {",
          "18:     function __ERC1155Holder_init() internal onlyInitializing {",
          "19:     }",
          "21:     function __ERC1155Holder_init_unchained() internal onlyInitializing {",
          "22:     }",
          "23:     function onERC1155Received(",
          "24:         address,",
          "25:         address,",
          "26:         uint256,",
          "27:         uint256,",
          "28:         bytes memory",
          "29:     ) public virtual override returns (bytes4) {",
          "30:         return this.onERC1155Received.selector;",
          "31:     }",
          "33:     function onERC1155BatchReceived(",
          "34:         address,",
          "35:         address,",
          "36:         uint256[] memory,",
          "37:         uint256[] memory,",
          "38:         bytes memory",
          "39:     ) public virtual override returns (bytes4) {",
          "40:         return this.onERC1155BatchReceived.selector;",
          "41:     }",
          "48:     uint256[50] private __gap;",
          "49: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol||contracts/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol": [
          "File: contracts/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol -> contracts/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../IERC1155ReceiverUpgradeable.sol\";",
          "7: import \"../../../utils/introspection/ERC165Upgradeable.sol\";",
          "8: import \"../../../proxy/utils/Initializable.sol\";",
          "13: abstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {",
          "14:     function __ERC1155Receiver_init() internal onlyInitializing {",
          "15:     }",
          "17:     function __ERC1155Receiver_init_unchained() internal onlyInitializing {",
          "18:     }",
          "22:     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {",
          "23:         return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);",
          "24:     }",
          "31:     uint256[50] private __gap;",
          "32: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/ERC20Upgradeable.sol||contracts/token/ERC20/ERC20Upgradeable.sol": [
          "File: contracts/token/ERC20/ERC20Upgradeable.sol -> contracts/token/ERC20/ERC20Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IERC20Upgradeable.sol\";",
          "7: import \"./extensions/IERC20MetadataUpgradeable.sol\";",
          "8: import \"../../utils/ContextUpgradeable.sol\";",
          "9: import \"../../proxy/utils/Initializable.sol\";",
          "39: contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {",
          "40:     mapping(address => uint256) private _balances;",
          "42:     mapping(address => mapping(address => uint256)) private _allowances;",
          "44:     uint256 private _totalSupply;",
          "46:     string private _name;",
          "47:     string private _symbol;",
          "55:     function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {",
          "56:         __ERC20_init_unchained(name_, symbol_);",
          "57:     }",
          "59:     function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {",
          "60:         _name = name_;",
          "61:         _symbol = symbol_;",
          "62:     }",
          "67:     function name() public view virtual override returns (string memory) {",
          "68:         return _name;",
          "69:     }",
          "75:     function symbol() public view virtual override returns (string memory) {",
          "76:         return _symbol;",
          "77:     }",
          "92:     function decimals() public view virtual override returns (uint8) {",
          "93:         return 18;",
          "94:     }",
          "99:     function totalSupply() public view virtual override returns (uint256) {",
          "100:         return _totalSupply;",
          "101:     }",
          "106:     function balanceOf(address account) public view virtual override returns (uint256) {",
          "107:         return _balances[account];",
          "108:     }",
          "118:     function transfer(address to, uint256 amount) public virtual override returns (bool) {",
          "119:         address owner = _msgSender();",
          "120:         _transfer(owner, to, amount);",
          "121:         return true;",
          "122:     }",
          "127:     function allowance(address owner, address spender) public view virtual override returns (uint256) {",
          "128:         return _allowances[owner][spender];",
          "129:     }",
          "141:     function approve(address spender, uint256 amount) public virtual override returns (bool) {",
          "142:         address owner = _msgSender();",
          "143:         _approve(owner, spender, amount);",
          "144:         return true;",
          "145:     }",
          "163:     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {",
          "164:         address spender = _msgSender();",
          "165:         _spendAllowance(from, spender, amount);",
          "166:         _transfer(from, to, amount);",
          "167:         return true;",
          "168:     }",
          "182:     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {",
          "183:         address owner = _msgSender();",
          "184:         _approve(owner, spender, allowance(owner, spender) + addedValue);",
          "185:         return true;",
          "186:     }",
          "202:     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {",
          "203:         address owner = _msgSender();",
          "204:         uint256 currentAllowance = allowance(owner, spender);",
          "205:         require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");",
          "206:         unchecked {",
          "207:             _approve(owner, spender, currentAllowance - subtractedValue);",
          "208:         }",
          "210:         return true;",
          "211:     }",
          "227:     function _transfer(address from, address to, uint256 amount) internal virtual {",
          "228:         require(from != address(0), \"ERC20: transfer from the zero address\");",
          "229:         require(to != address(0), \"ERC20: transfer to the zero address\");",
          "231:         _beforeTokenTransfer(from, to, amount);",
          "233:         uint256 fromBalance = _balances[from];",
          "234:         require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");",
          "235:         unchecked {",
          "236:             _balances[from] = fromBalance - amount;",
          "239:             _balances[to] += amount;",
          "240:         }",
          "242:         emit Transfer(from, to, amount);",
          "244:         _afterTokenTransfer(from, to, amount);",
          "245:     }",
          "256:     function _mint(address account, uint256 amount) internal virtual {",
          "257:         require(account != address(0), \"ERC20: mint to the zero address\");",
          "259:         _beforeTokenTransfer(address(0), account, amount);",
          "261:         _totalSupply += amount;",
          "262:         unchecked {",
          "264:             _balances[account] += amount;",
          "265:         }",
          "266:         emit Transfer(address(0), account, amount);",
          "268:         _afterTokenTransfer(address(0), account, amount);",
          "269:     }",
          "282:     function _burn(address account, uint256 amount) internal virtual {",
          "283:         require(account != address(0), \"ERC20: burn from the zero address\");",
          "285:         _beforeTokenTransfer(account, address(0), amount);",
          "287:         uint256 accountBalance = _balances[account];",
          "288:         require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");",
          "289:         unchecked {",
          "290:             _balances[account] = accountBalance - amount;",
          "292:             _totalSupply -= amount;",
          "293:         }",
          "295:         emit Transfer(account, address(0), amount);",
          "297:         _afterTokenTransfer(account, address(0), amount);",
          "298:     }",
          "313:     function _approve(address owner, address spender, uint256 amount) internal virtual {",
          "314:         require(owner != address(0), \"ERC20: approve from the zero address\");",
          "315:         require(spender != address(0), \"ERC20: approve to the zero address\");",
          "317:         _allowances[owner][spender] = amount;",
          "318:         emit Approval(owner, spender, amount);",
          "319:     }",
          "329:     function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {",
          "330:         uint256 currentAllowance = allowance(owner, spender);",
          "331:         if (currentAllowance != type(uint256).max) {",
          "332:             require(currentAllowance >= amount, \"ERC20: insufficient allowance\");",
          "333:             unchecked {",
          "334:                 _approve(owner, spender, currentAllowance - amount);",
          "335:             }",
          "336:         }",
          "337:     }",
          "353:     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}",
          "369:     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}",
          "376:     uint256[45] private __gap;",
          "377: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/IERC20Upgradeable.sol||contracts/token/ERC20/IERC20Upgradeable.sol": [
          "File: contracts/token/ERC20/IERC20Upgradeable.sol -> contracts/token/ERC20/IERC20Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "9: interface IERC20Upgradeable {",
          "16:     event Transfer(address indexed from, address indexed to, uint256 value);",
          "22:     event Approval(address indexed owner, address indexed spender, uint256 value);",
          "27:     function totalSupply() external view returns (uint256);",
          "32:     function balanceOf(address account) external view returns (uint256);",
          "41:     function transfer(address to, uint256 amount) external returns (bool);",
          "50:     function allowance(address owner, address spender) external view returns (uint256);",
          "66:     function approve(address spender, uint256 amount) external returns (bool);",
          "77:     function transferFrom(address from, address to, uint256 amount) external returns (bool);",
          "78: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/extensions/ERC20BurnableUpgradeable.sol||contracts/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": [
          "File: contracts/token/ERC20/extensions/ERC20BurnableUpgradeable.sol -> contracts/token/ERC20/extensions/ERC20BurnableUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC20Upgradeable.sol\";",
          "7: import \"../../../utils/ContextUpgradeable.sol\";",
          "8: import \"../../../proxy/utils/Initializable.sol\";",
          "15: abstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {",
          "16:     function __ERC20Burnable_init() internal onlyInitializing {",
          "17:     }",
          "19:     function __ERC20Burnable_init_unchained() internal onlyInitializing {",
          "20:     }",
          "26:     function burn(uint256 amount) public virtual {",
          "27:         _burn(_msgSender(), amount);",
          "28:     }",
          "41:     function burnFrom(address account, uint256 amount) public virtual {",
          "42:         _spendAllowance(account, _msgSender(), amount);",
          "43:         _burn(account, amount);",
          "44:     }",
          "51:     uint256[50] private __gap;",
          "52: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/extensions/ERC20CappedUpgradeable.sol||contracts/token/ERC20/extensions/ERC20CappedUpgradeable.sol": [
          "File: contracts/token/ERC20/extensions/ERC20CappedUpgradeable.sol -> contracts/token/ERC20/extensions/ERC20CappedUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC20Upgradeable.sol\";",
          "7: import \"../../../proxy/utils/Initializable.sol\";",
          "14: abstract contract ERC20CappedUpgradeable is Initializable, ERC20Upgradeable {",
          "15:     uint256 private _cap;",
          "21:     function __ERC20Capped_init(uint256 cap_) internal onlyInitializing {",
          "22:         __ERC20Capped_init_unchained(cap_);",
          "23:     }",
          "25:     function __ERC20Capped_init_unchained(uint256 cap_) internal onlyInitializing {",
          "26:         require(cap_ > 0, \"ERC20Capped: cap is 0\");",
          "27:         _cap = cap_;",
          "28:     }",
          "33:     function cap() public view virtual returns (uint256) {",
          "34:         return _cap;",
          "35:     }",
          "40:     function _mint(address account, uint256 amount) internal virtual override {",
          "41:         require(ERC20Upgradeable.totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\");",
          "42:         super._mint(account, amount);",
          "43:     }",
          "50:     uint256[50] private __gap;",
          "51: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/extensions/ERC20FlashMintUpgradeable.sol||contracts/token/ERC20/extensions/ERC20FlashMintUpgradeable.sol": [
          "File: contracts/token/ERC20/extensions/ERC20FlashMintUpgradeable.sol -> contracts/token/ERC20/extensions/ERC20FlashMintUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../../../interfaces/IERC3156FlashBorrowerUpgradeable.sol\";",
          "7: import \"../../../interfaces/IERC3156FlashLenderUpgradeable.sol\";",
          "8: import \"../ERC20Upgradeable.sol\";",
          "9: import \"../../../proxy/utils/Initializable.sol\";",
          "20: abstract contract ERC20FlashMintUpgradeable is Initializable, ERC20Upgradeable, IERC3156FlashLenderUpgradeable {",
          "21:     function __ERC20FlashMint_init() internal onlyInitializing {",
          "22:     }",
          "24:     function __ERC20FlashMint_init_unchained() internal onlyInitializing {",
          "25:     }",
          "26:     bytes32 private constant _RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");",
          "33:     function maxFlashLoan(address token) public view virtual override returns (uint256) {",
          "34:         return token == address(this) ? type(uint256).max - ERC20Upgradeable.totalSupply() : 0;",
          "35:     }",
          "45:     function flashFee(address token, uint256 amount) public view virtual override returns (uint256) {",
          "46:         require(token == address(this), \"ERC20FlashMint: wrong token\");",
          "47:         return _flashFee(token, amount);",
          "48:     }",
          "58:     function _flashFee(address token, uint256 amount) internal view virtual returns (uint256) {",
          "60:         token;",
          "61:         amount;",
          "62:         return 0;",
          "63:     }",
          "71:     function _flashFeeReceiver() internal view virtual returns (address) {",
          "72:         return address(0);",
          "73:     }",
          "92:     function flashLoan(",
          "93:         IERC3156FlashBorrowerUpgradeable receiver,",
          "94:         address token,",
          "95:         uint256 amount,",
          "96:         bytes calldata data",
          "97:     ) public virtual override returns (bool) {",
          "98:         require(amount <= maxFlashLoan(token), \"ERC20FlashMint: amount exceeds maxFlashLoan\");",
          "99:         uint256 fee = flashFee(token, amount);",
          "100:         _mint(address(receiver), amount);",
          "101:         require(",
          "102:             receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE,",
          "103:             \"ERC20FlashMint: invalid return value\"",
          "104:         );",
          "105:         address flashFeeReceiver = _flashFeeReceiver();",
          "106:         _spendAllowance(address(receiver), address(this), amount + fee);",
          "107:         if (fee == 0 || flashFeeReceiver == address(0)) {",
          "108:             _burn(address(receiver), amount + fee);",
          "109:         } else {",
          "110:             _burn(address(receiver), amount);",
          "111:             _transfer(address(receiver), flashFeeReceiver, fee);",
          "112:         }",
          "113:         return true;",
          "114:     }",
          "121:     uint256[50] private __gap;",
          "122: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/extensions/ERC20PausableUpgradeable.sol||contracts/token/ERC20/extensions/ERC20PausableUpgradeable.sol": [
          "File: contracts/token/ERC20/extensions/ERC20PausableUpgradeable.sol -> contracts/token/ERC20/extensions/ERC20PausableUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC20Upgradeable.sol\";",
          "7: import \"../../../security/PausableUpgradeable.sol\";",
          "8: import \"../../../proxy/utils/Initializable.sol\";",
          "23: abstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {",
          "24:     function __ERC20Pausable_init() internal onlyInitializing {",
          "25:         __Pausable_init_unchained();",
          "26:     }",
          "28:     function __ERC20Pausable_init_unchained() internal onlyInitializing {",
          "29:     }",
          "37:     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {",
          "38:         super._beforeTokenTransfer(from, to, amount);",
          "40:         require(!paused(), \"ERC20Pausable: token transfer while paused\");",
          "41:     }",
          "48:     uint256[50] private __gap;",
          "49: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/extensions/ERC20PermitUpgradeable.sol||contracts/token/ERC20/extensions/ERC20PermitUpgradeable.sol": [
          "File: contracts/token/ERC20/extensions/ERC20PermitUpgradeable.sol -> contracts/token/ERC20/extensions/ERC20PermitUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IERC20PermitUpgradeable.sol\";",
          "7: import \"../ERC20Upgradeable.sol\";",
          "8: import \"../../../utils/cryptography/ECDSAUpgradeable.sol\";",
          "9: import \"../../../utils/cryptography/EIP712Upgradeable.sol\";",
          "10: import \"../../../utils/CountersUpgradeable.sol\";",
          "11: import \"../../../proxy/utils/Initializable.sol\";",
          "25: abstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {",
          "26:     using CountersUpgradeable for CountersUpgradeable.Counter;",
          "28:     mapping(address => CountersUpgradeable.Counter) private _nonces;",
          "31:     bytes32 private constant _PERMIT_TYPEHASH =",
          "32:         keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");",
          "40:     bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;",
          "47:     function __ERC20Permit_init(string memory name) internal onlyInitializing {",
          "48:         __EIP712_init_unchained(name, \"1\");",
          "49:     }",
          "51:     function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}",
          "56:     function permit(",
          "57:         address owner,",
          "58:         address spender,",
          "59:         uint256 value,",
          "60:         uint256 deadline,",
          "61:         uint8 v,",
          "62:         bytes32 r,",
          "63:         bytes32 s",
          "64:     ) public virtual override {",
          "65:         require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");",
          "67:         bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));",
          "69:         bytes32 hash = _hashTypedDataV4(structHash);",
          "71:         address signer = ECDSAUpgradeable.recover(hash, v, r, s);",
          "72:         require(signer == owner, \"ERC20Permit: invalid signature\");",
          "74:         _approve(owner, spender, value);",
          "75:     }",
          "80:     function nonces(address owner) public view virtual override returns (uint256) {",
          "81:         return _nonces[owner].current();",
          "82:     }",
          "88:     function DOMAIN_SEPARATOR() external view override returns (bytes32) {",
          "89:         return _domainSeparatorV4();",
          "90:     }",
          "97:     function _useNonce(address owner) internal virtual returns (uint256 current) {",
          "98:         CountersUpgradeable.Counter storage nonce = _nonces[owner];",
          "99:         current = nonce.current();",
          "100:         nonce.increment();",
          "101:     }",
          "108:     uint256[49] private __gap;",
          "109: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol||contracts/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol": [
          "File: contracts/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol -> contracts/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC20Upgradeable.sol\";",
          "7: import \"../../../utils/ArraysUpgradeable.sol\";",
          "8: import \"../../../utils/CountersUpgradeable.sol\";",
          "9: import \"../../../proxy/utils/Initializable.sol\";",
          "43: abstract contract ERC20SnapshotUpgradeable is Initializable, ERC20Upgradeable {",
          "44:     function __ERC20Snapshot_init() internal onlyInitializing {",
          "45:     }",
          "47:     function __ERC20Snapshot_init_unchained() internal onlyInitializing {",
          "48:     }",
          "52:     using ArraysUpgradeable for uint256[];",
          "53:     using CountersUpgradeable for CountersUpgradeable.Counter;",
          "57:     struct Snapshots {",
          "58:         uint256[] ids;",
          "59:         uint256[] values;",
          "60:     }",
          "62:     mapping(address => Snapshots) private _accountBalanceSnapshots;",
          "63:     Snapshots private _totalSupplySnapshots;",
          "66:     CountersUpgradeable.Counter private _currentSnapshotId;",
          "71:     event Snapshot(uint256 id);",
          "94:     function _snapshot() internal virtual returns (uint256) {",
          "95:         _currentSnapshotId.increment();",
          "97:         uint256 currentId = _getCurrentSnapshotId();",
          "98:         emit Snapshot(currentId);",
          "99:         return currentId;",
          "100:     }",
          "105:     function _getCurrentSnapshotId() internal view virtual returns (uint256) {",
          "106:         return _currentSnapshotId.current();",
          "107:     }",
          "112:     function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {",
          "113:         (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);",
          "115:         return snapshotted ? value : balanceOf(account);",
          "116:     }",
          "121:     function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {",
          "122:         (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);",
          "124:         return snapshotted ? value : totalSupply();",
          "125:     }",
          "129:     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {",
          "130:         super._beforeTokenTransfer(from, to, amount);",
          "132:         if (from == address(0)) {",
          "134:             _updateAccountSnapshot(to);",
          "135:             _updateTotalSupplySnapshot();",
          "136:         } else if (to == address(0)) {",
          "138:             _updateAccountSnapshot(from);",
          "139:             _updateTotalSupplySnapshot();",
          "140:         } else {",
          "142:             _updateAccountSnapshot(from);",
          "143:             _updateAccountSnapshot(to);",
          "144:         }",
          "145:     }",
          "147:     function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {",
          "148:         require(snapshotId > 0, \"ERC20Snapshot: id is 0\");",
          "149:         require(snapshotId <= _getCurrentSnapshotId(), \"ERC20Snapshot: nonexistent id\");",
          "165:         uint256 index = snapshots.ids.findUpperBound(snapshotId);",
          "167:         if (index == snapshots.ids.length) {",
          "168:             return (false, 0);",
          "169:         } else {",
          "170:             return (true, snapshots.values[index]);",
          "171:         }",
          "172:     }",
          "174:     function _updateAccountSnapshot(address account) private {",
          "175:         _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));",
          "176:     }",
          "178:     function _updateTotalSupplySnapshot() private {",
          "179:         _updateSnapshot(_totalSupplySnapshots, totalSupply());",
          "180:     }",
          "182:     function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {",
          "183:         uint256 currentId = _getCurrentSnapshotId();",
          "184:         if (_lastSnapshotId(snapshots.ids) < currentId) {",
          "185:             snapshots.ids.push(currentId);",
          "186:             snapshots.values.push(currentValue);",
          "187:         }",
          "188:     }",
          "190:     function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {",
          "191:         if (ids.length == 0) {",
          "192:             return 0;",
          "193:         } else {",
          "194:             return ids[ids.length - 1];",
          "195:         }",
          "196:     }",
          "203:     uint256[46] private __gap;",
          "204: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/extensions/ERC20VotesCompUpgradeable.sol||contracts/token/ERC20/extensions/ERC20VotesCompUpgradeable.sol": [
          "File: contracts/token/ERC20/extensions/ERC20VotesCompUpgradeable.sol -> contracts/token/ERC20/extensions/ERC20VotesCompUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./ERC20VotesUpgradeable.sol\";",
          "7: import \"../../../proxy/utils/Initializable.sol\";",
          "26: abstract contract ERC20VotesCompUpgradeable is Initializable, ERC20VotesUpgradeable {",
          "27:     function __ERC20VotesComp_init() internal onlyInitializing {",
          "28:     }",
          "30:     function __ERC20VotesComp_init_unchained() internal onlyInitializing {",
          "31:     }",
          "35:     function getCurrentVotes(address account) external view virtual returns (uint96) {",
          "36:         return SafeCastUpgradeable.toUint96(getVotes(account));",
          "37:     }",
          "42:     function getPriorVotes(address account, uint256 blockNumber) external view virtual returns (uint96) {",
          "43:         return SafeCastUpgradeable.toUint96(getPastVotes(account, blockNumber));",
          "44:     }",
          "49:     function _maxSupply() internal view virtual override returns (uint224) {",
          "50:         return type(uint96).max;",
          "51:     }",
          "58:     uint256[50] private __gap;",
          "59: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol||contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol": [
          "File: contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol -> contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./ERC20PermitUpgradeable.sol\";",
          "7: import \"../../../interfaces/IERC5805Upgradeable.sol\";",
          "8: import \"../../../utils/math/MathUpgradeable.sol\";",
          "9: import \"../../../utils/math/SafeCastUpgradeable.sol\";",
          "10: import \"../../../utils/cryptography/ECDSAUpgradeable.sol\";",
          "11: import \"../../../proxy/utils/Initializable.sol\";",
          "28: abstract contract ERC20VotesUpgradeable is Initializable, ERC20PermitUpgradeable, IERC5805Upgradeable {",
          "29:     function __ERC20Votes_init() internal onlyInitializing {",
          "30:     }",
          "32:     function __ERC20Votes_init_unchained() internal onlyInitializing {",
          "33:     }",
          "34:     struct Checkpoint {",
          "35:         uint32 fromBlock;",
          "36:         uint224 votes;",
          "37:     }",
          "39:     bytes32 private constant _DELEGATION_TYPEHASH =",
          "40:         keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");",
          "42:     mapping(address => address) private _delegates;",
          "43:     mapping(address => Checkpoint[]) private _checkpoints;",
          "44:     Checkpoint[] private _totalSupplyCheckpoints;",
          "49:     function clock() public view virtual override returns (uint48) {",
          "50:         return SafeCastUpgradeable.toUint48(block.number);",
          "51:     }",
          "57:     function CLOCK_MODE() public view virtual override returns (string memory) {",
          "59:         require(clock() == block.number, \"ERC20Votes: broken clock mode\");",
          "60:         return \"mode=blocknumber&from=default\";",
          "61:     }",
          "66:     function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {",
          "67:         return _checkpoints[account][pos];",
          "68:     }",
          "73:     function numCheckpoints(address account) public view virtual returns (uint32) {",
          "74:         return SafeCastUpgradeable.toUint32(_checkpoints[account].length);",
          "75:     }",
          "80:     function delegates(address account) public view virtual override returns (address) {",
          "81:         return _delegates[account];",
          "82:     }",
          "87:     function getVotes(address account) public view virtual override returns (uint256) {",
          "88:         uint256 pos = _checkpoints[account].length;",
          "89:         unchecked {",
          "90:             return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;",
          "91:         }",
          "92:     }",
          "101:     function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
          "102:         require(timepoint < clock(), \"ERC20Votes: future lookup\");",
          "103:         return _checkpointsLookup(_checkpoints[account], timepoint);",
          "104:     }",
          "114:     function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {",
          "115:         require(timepoint < clock(), \"ERC20Votes: future lookup\");",
          "116:         return _checkpointsLookup(_totalSupplyCheckpoints, timepoint);",
          "117:     }",
          "122:     function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 timepoint) private view returns (uint256) {",
          "135:         uint256 length = ckpts.length;",
          "137:         uint256 low = 0;",
          "138:         uint256 high = length;",
          "140:         if (length > 5) {",
          "141:             uint256 mid = length - MathUpgradeable.sqrt(length);",
          "142:             if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {",
          "143:                 high = mid;",
          "144:             } else {",
          "145:                 low = mid + 1;",
          "146:             }",
          "147:         }",
          "149:         while (low < high) {",
          "150:             uint256 mid = MathUpgradeable.average(low, high);",
          "151:             if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {",
          "152:                 high = mid;",
          "153:             } else {",
          "154:                 low = mid + 1;",
          "155:             }",
          "156:         }",
          "158:         unchecked {",
          "159:             return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;",
          "160:         }",
          "161:     }",
          "166:     function delegate(address delegatee) public virtual override {",
          "167:         _delegate(_msgSender(), delegatee);",
          "168:     }",
          "173:     function delegateBySig(",
          "174:         address delegatee,",
          "175:         uint256 nonce,",
          "176:         uint256 expiry,",
          "177:         uint8 v,",
          "178:         bytes32 r,",
          "179:         bytes32 s",
          "180:     ) public virtual override {",
          "181:         require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");",
          "182:         address signer = ECDSAUpgradeable.recover(",
          "183:             _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),",
          "184:             v,",
          "185:             r,",
          "186:             s",
          "187:         );",
          "188:         require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");",
          "189:         _delegate(signer, delegatee);",
          "190:     }",
          "195:     function _maxSupply() internal view virtual returns (uint224) {",
          "196:         return type(uint224).max;",
          "197:     }",
          "202:     function _mint(address account, uint256 amount) internal virtual override {",
          "203:         super._mint(account, amount);",
          "204:         require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
          "206:         _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);",
          "207:     }",
          "212:     function _burn(address account, uint256 amount) internal virtual override {",
          "213:         super._burn(account, amount);",
          "215:         _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);",
          "216:     }",
          "223:     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {",
          "224:         super._afterTokenTransfer(from, to, amount);",
          "226:         _moveVotingPower(delegates(from), delegates(to), amount);",
          "227:     }",
          "234:     function _delegate(address delegator, address delegatee) internal virtual {",
          "235:         address currentDelegate = delegates(delegator);",
          "236:         uint256 delegatorBalance = balanceOf(delegator);",
          "237:         _delegates[delegator] = delegatee;",
          "239:         emit DelegateChanged(delegator, currentDelegate, delegatee);",
          "241:         _moveVotingPower(currentDelegate, delegatee, delegatorBalance);",
          "242:     }",
          "244:     function _moveVotingPower(address src, address dst, uint256 amount) private {",
          "245:         if (src != dst && amount > 0) {",
          "246:             if (src != address(0)) {",
          "247:                 (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);",
          "248:                 emit DelegateVotesChanged(src, oldWeight, newWeight);",
          "249:             }",
          "251:             if (dst != address(0)) {",
          "252:                 (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);",
          "253:                 emit DelegateVotesChanged(dst, oldWeight, newWeight);",
          "254:             }",
          "255:         }",
          "256:     }",
          "258:     function _writeCheckpoint(",
          "259:         Checkpoint[] storage ckpts,",
          "260:         function(uint256, uint256) view returns (uint256) op,",
          "261:         uint256 delta",
          "262:     ) private returns (uint256 oldWeight, uint256 newWeight) {",
          "263:         uint256 pos = ckpts.length;",
          "265:         unchecked {",
          "266:             Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);",
          "268:             oldWeight = oldCkpt.votes;",
          "269:             newWeight = op(oldWeight, delta);",
          "271:             if (pos > 0 && oldCkpt.fromBlock == clock()) {",
          "272:                 _unsafeAccess(ckpts, pos - 1).votes = SafeCastUpgradeable.toUint224(newWeight);",
          "273:             } else {",
          "274:                 ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(clock()), votes: SafeCastUpgradeable.toUint224(newWeight)}));",
          "275:             }",
          "276:         }",
          "277:     }",
          "279:     function _add(uint256 a, uint256 b) private pure returns (uint256) {",
          "280:         return a + b;",
          "281:     }",
          "283:     function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
          "284:         return a - b;",
          "285:     }",
          "290:     function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {",
          "291:         assembly {",
          "292:             mstore(0, ckpts.slot)",
          "293:             result.slot := add(keccak256(0, 0x20), pos)",
          "294:         }",
          "295:     }",
          "302:     uint256[47] private __gap;",
          "303: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/extensions/ERC20WrapperUpgradeable.sol||contracts/token/ERC20/extensions/ERC20WrapperUpgradeable.sol": [
          "File: contracts/token/ERC20/extensions/ERC20WrapperUpgradeable.sol -> contracts/token/ERC20/extensions/ERC20WrapperUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC20Upgradeable.sol\";",
          "7: import \"../utils/SafeERC20Upgradeable.sol\";",
          "8: import \"../../../proxy/utils/Initializable.sol\";",
          "21: abstract contract ERC20WrapperUpgradeable is Initializable, ERC20Upgradeable {",
          "22:     IERC20Upgradeable private _underlying;",
          "24:     function __ERC20Wrapper_init(IERC20Upgradeable underlyingToken) internal onlyInitializing {",
          "25:         __ERC20Wrapper_init_unchained(underlyingToken);",
          "26:     }",
          "28:     function __ERC20Wrapper_init_unchained(IERC20Upgradeable underlyingToken) internal onlyInitializing {",
          "29:         require(underlyingToken != this, \"ERC20Wrapper: cannot self wrap\");",
          "30:         _underlying = underlyingToken;",
          "31:     }",
          "36:     function decimals() public view virtual override returns (uint8) {",
          "37:         try IERC20MetadataUpgradeable(address(_underlying)).decimals() returns (uint8 value) {",
          "38:             return value;",
          "39:         } catch {",
          "40:             return super.decimals();",
          "41:         }",
          "42:     }",
          "47:     function underlying() public view returns (IERC20Upgradeable) {",
          "48:         return _underlying;",
          "49:     }",
          "54:     function depositFor(address account, uint256 amount) public virtual returns (bool) {",
          "55:         address sender = _msgSender();",
          "56:         require(sender != address(this), \"ERC20Wrapper: wrapper can't deposit\");",
          "57:         SafeERC20Upgradeable.safeTransferFrom(_underlying, sender, address(this), amount);",
          "58:         _mint(account, amount);",
          "59:         return true;",
          "60:     }",
          "65:     function withdrawTo(address account, uint256 amount) public virtual returns (bool) {",
          "66:         _burn(_msgSender(), amount);",
          "67:         SafeERC20Upgradeable.safeTransfer(_underlying, account, amount);",
          "68:         return true;",
          "69:     }",
          "75:     function _recover(address account) internal virtual returns (uint256) {",
          "76:         uint256 value = _underlying.balanceOf(address(this)) - totalSupply();",
          "77:         _mint(account, value);",
          "78:         return value;",
          "79:     }",
          "86:     uint256[50] private __gap;",
          "87: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/extensions/ERC4626Upgradeable.sol||contracts/token/ERC20/extensions/ERC4626Upgradeable.sol": [
          "File: contracts/token/ERC20/extensions/ERC4626Upgradeable.sol -> contracts/token/ERC20/extensions/ERC4626Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC20Upgradeable.sol\";",
          "7: import \"../utils/SafeERC20Upgradeable.sol\";",
          "8: import \"../../../interfaces/IERC4626Upgradeable.sol\";",
          "9: import \"../../../utils/math/MathUpgradeable.sol\";",
          "10: import \"../../../proxy/utils/Initializable.sol\";",
          "51: abstract contract ERC4626Upgradeable is Initializable, ERC20Upgradeable, IERC4626Upgradeable {",
          "52:     using MathUpgradeable for uint256;",
          "54:     IERC20Upgradeable private _asset;",
          "55:     uint8 private _underlyingDecimals;",
          "60:     function __ERC4626_init(IERC20Upgradeable asset_) internal onlyInitializing {",
          "61:         __ERC4626_init_unchained(asset_);",
          "62:     }",
          "64:     function __ERC4626_init_unchained(IERC20Upgradeable asset_) internal onlyInitializing {",
          "65:         (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);",
          "66:         _underlyingDecimals = success ? assetDecimals : 18;",
          "67:         _asset = asset_;",
          "68:     }",
          "73:     function _tryGetAssetDecimals(IERC20Upgradeable asset_) private view returns (bool, uint8) {",
          "74:         (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(",
          "75:             abi.encodeWithSelector(IERC20MetadataUpgradeable.decimals.selector)",
          "76:         );",
          "77:         if (success && encodedDecimals.length >= 32) {",
          "78:             uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));",
          "79:             if (returnedDecimals <= type(uint8).max) {",
          "80:                 return (true, uint8(returnedDecimals));",
          "81:             }",
          "82:         }",
          "83:         return (false, 0);",
          "84:     }",
          "93:     function decimals() public view virtual override(IERC20MetadataUpgradeable, ERC20Upgradeable) returns (uint8) {",
          "94:         return _underlyingDecimals + _decimalsOffset();",
          "95:     }",
          "98:     function asset() public view virtual override returns (address) {",
          "99:         return address(_asset);",
          "100:     }",
          "103:     function totalAssets() public view virtual override returns (uint256) {",
          "104:         return _asset.balanceOf(address(this));",
          "105:     }",
          "108:     function convertToShares(uint256 assets) public view virtual override returns (uint256) {",
          "109:         return _convertToShares(assets, MathUpgradeable.Rounding.Down);",
          "110:     }",
          "113:     function convertToAssets(uint256 shares) public view virtual override returns (uint256) {",
          "114:         return _convertToAssets(shares, MathUpgradeable.Rounding.Down);",
          "115:     }",
          "118:     function maxDeposit(address) public view virtual override returns (uint256) {",
          "119:         return type(uint256).max;",
          "120:     }",
          "123:     function maxMint(address) public view virtual override returns (uint256) {",
          "124:         return type(uint256).max;",
          "125:     }",
          "128:     function maxWithdraw(address owner) public view virtual override returns (uint256) {",
          "129:         return _convertToAssets(balanceOf(owner), MathUpgradeable.Rounding.Down);",
          "130:     }",
          "133:     function maxRedeem(address owner) public view virtual override returns (uint256) {",
          "134:         return balanceOf(owner);",
          "135:     }",
          "138:     function previewDeposit(uint256 assets) public view virtual override returns (uint256) {",
          "139:         return _convertToShares(assets, MathUpgradeable.Rounding.Down);",
          "140:     }",
          "143:     function previewMint(uint256 shares) public view virtual override returns (uint256) {",
          "144:         return _convertToAssets(shares, MathUpgradeable.Rounding.Up);",
          "145:     }",
          "148:     function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {",
          "149:         return _convertToShares(assets, MathUpgradeable.Rounding.Up);",
          "150:     }",
          "153:     function previewRedeem(uint256 shares) public view virtual override returns (uint256) {",
          "154:         return _convertToAssets(shares, MathUpgradeable.Rounding.Down);",
          "155:     }",
          "158:     function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {",
          "159:         require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max\");",
          "161:         uint256 shares = previewDeposit(assets);",
          "162:         _deposit(_msgSender(), receiver, assets, shares);",
          "164:         return shares;",
          "165:     }",
          "172:     function mint(uint256 shares, address receiver) public virtual override returns (uint256) {",
          "173:         require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");",
          "175:         uint256 assets = previewMint(shares);",
          "176:         _deposit(_msgSender(), receiver, assets, shares);",
          "178:         return assets;",
          "179:     }",
          "182:     function withdraw(uint256 assets, address receiver, address owner) public virtual override returns (uint256) {",
          "183:         require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");",
          "185:         uint256 shares = previewWithdraw(assets);",
          "186:         _withdraw(_msgSender(), receiver, owner, assets, shares);",
          "188:         return shares;",
          "189:     }",
          "192:     function redeem(uint256 shares, address receiver, address owner) public virtual override returns (uint256) {",
          "193:         require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");",
          "195:         uint256 assets = previewRedeem(shares);",
          "196:         _withdraw(_msgSender(), receiver, owner, assets, shares);",
          "198:         return assets;",
          "199:     }",
          "204:     function _convertToShares(uint256 assets, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256) {",
          "205:         return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);",
          "206:     }",
          "211:     function _convertToAssets(uint256 shares, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256) {",
          "212:         return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);",
          "213:     }",
          "218:     function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {",
          "226:         SafeERC20Upgradeable.safeTransferFrom(_asset, caller, address(this), assets);",
          "227:         _mint(receiver, shares);",
          "229:         emit Deposit(caller, receiver, assets, shares);",
          "230:     }",
          "235:     function _withdraw(",
          "236:         address caller,",
          "237:         address receiver,",
          "238:         address owner,",
          "239:         uint256 assets,",
          "240:         uint256 shares",
          "241:     ) internal virtual {",
          "242:         if (caller != owner) {",
          "243:             _spendAllowance(owner, caller, shares);",
          "244:         }",
          "252:         _burn(owner, shares);",
          "253:         SafeERC20Upgradeable.safeTransfer(_asset, receiver, assets);",
          "255:         emit Withdraw(caller, receiver, owner, assets, shares);",
          "256:     }",
          "258:     function _decimalsOffset() internal view virtual returns (uint8) {",
          "259:         return 0;",
          "260:     }",
          "267:     uint256[49] private __gap;",
          "268: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol||contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": [
          "File: contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol -> contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../IERC20Upgradeable.sol\";",
          "13: interface IERC20MetadataUpgradeable is IERC20Upgradeable {",
          "17:     function name() external view returns (string memory);",
          "22:     function symbol() external view returns (string memory);",
          "27:     function decimals() external view returns (uint8);",
          "28: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/extensions/IERC20PermitUpgradeable.sol||contracts/token/ERC20/extensions/IERC20PermitUpgradeable.sol": [
          "File: contracts/token/ERC20/extensions/IERC20PermitUpgradeable.sol -> contracts/token/ERC20/extensions/IERC20PermitUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "14: interface IERC20PermitUpgradeable {",
          "36:     function permit(",
          "37:         address owner,",
          "38:         address spender,",
          "39:         uint256 value,",
          "40:         uint256 deadline,",
          "41:         uint8 v,",
          "42:         bytes32 r,",
          "43:         bytes32 s",
          "44:     ) external;",
          "53:     function nonces(address owner) external view returns (uint256);",
          "59:     function DOMAIN_SEPARATOR() external view returns (bytes32);",
          "60: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol||contracts/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": [
          "File: contracts/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol -> contracts/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "8: import \"./ERC20PermitUpgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol||contracts/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": [
          "File: contracts/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol -> contracts/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "7: import \"./IERC20PermitUpgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/presets/ERC20PresetFixedSupplyUpgradeable.sol||contracts/token/ERC20/presets/ERC20PresetFixedSupplyUpgradeable.sol": [
          "File: contracts/token/ERC20/presets/ERC20PresetFixedSupplyUpgradeable.sol -> contracts/token/ERC20/presets/ERC20PresetFixedSupplyUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../extensions/ERC20BurnableUpgradeable.sol\";",
          "6: import \"../../../proxy/utils/Initializable.sol\";",
          "22: contract ERC20PresetFixedSupplyUpgradeable is Initializable, ERC20BurnableUpgradeable {",
          "23:     function initialize(string memory name, string memory symbol, uint256 initialSupply, address owner) public virtual initializer {",
          "24:         __ERC20PresetFixedSupply_init(name, symbol, initialSupply, owner);",
          "25:     }",
          "31:     function __ERC20PresetFixedSupply_init(string memory name, string memory symbol, uint256 initialSupply, address owner) internal onlyInitializing {",
          "32:         __ERC20_init_unchained(name, symbol);",
          "33:         __ERC20PresetFixedSupply_init_unchained(name, symbol, initialSupply, owner);",
          "34:     }",
          "36:     function __ERC20PresetFixedSupply_init_unchained(string memory, string memory, uint256 initialSupply, address owner) internal onlyInitializing {",
          "37:         _mint(owner, initialSupply);",
          "38:     }",
          "45:     uint256[50] private __gap;",
          "46: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol||contracts/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol": [
          "File: contracts/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol -> contracts/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC20Upgradeable.sol\";",
          "7: import \"../extensions/ERC20BurnableUpgradeable.sol\";",
          "8: import \"../extensions/ERC20PausableUpgradeable.sol\";",
          "9: import \"../../../access/AccessControlEnumerableUpgradeable.sol\";",
          "10: import \"../../../utils/ContextUpgradeable.sol\";",
          "11: import \"../../../proxy/utils/Initializable.sol\";",
          "29: contract ERC20PresetMinterPauserUpgradeable is Initializable, ContextUpgradeable, AccessControlEnumerableUpgradeable, ERC20BurnableUpgradeable, ERC20PausableUpgradeable {",
          "30:     function initialize(string memory name, string memory symbol) public virtual initializer {",
          "31:         __ERC20PresetMinterPauser_init(name, symbol);",
          "32:     }",
          "33:     bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");",
          "34:     bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");",
          "42:     function __ERC20PresetMinterPauser_init(string memory name, string memory symbol) internal onlyInitializing {",
          "43:         __ERC20_init_unchained(name, symbol);",
          "44:         __Pausable_init_unchained();",
          "45:         __ERC20PresetMinterPauser_init_unchained(name, symbol);",
          "46:     }",
          "48:     function __ERC20PresetMinterPauser_init_unchained(string memory, string memory) internal onlyInitializing {",
          "49:         _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());",
          "51:         _setupRole(MINTER_ROLE, _msgSender());",
          "52:         _setupRole(PAUSER_ROLE, _msgSender());",
          "53:     }",
          "64:     function mint(address to, uint256 amount) public virtual {",
          "65:         require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");",
          "66:         _mint(to, amount);",
          "67:     }",
          "78:     function pause() public virtual {",
          "79:         require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");",
          "80:         _pause();",
          "81:     }",
          "92:     function unpause() public virtual {",
          "93:         require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");",
          "94:         _unpause();",
          "95:     }",
          "97:     function _beforeTokenTransfer(",
          "98:         address from,",
          "99:         address to,",
          "100:         uint256 amount",
          "101:     ) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {",
          "102:         super._beforeTokenTransfer(from, to, amount);",
          "103:     }",
          "110:     uint256[50] private __gap;",
          "111: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/utils/SafeERC20Upgradeable.sol||contracts/token/ERC20/utils/SafeERC20Upgradeable.sol": [
          "File: contracts/token/ERC20/utils/SafeERC20Upgradeable.sol -> contracts/token/ERC20/utils/SafeERC20Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../IERC20Upgradeable.sol\";",
          "7: import \"../extensions/IERC20PermitUpgradeable.sol\";",
          "8: import \"../../../utils/AddressUpgradeable.sol\";",
          "19: library SafeERC20Upgradeable {",
          "20:     using AddressUpgradeable for address;",
          "26:     function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {",
          "27:         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));",
          "28:     }",
          "34:     function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {",
          "35:         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));",
          "36:     }",
          "45:     function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {",
          "49:         require(",
          "50:             (value == 0) || (token.allowance(address(this), spender) == 0),",
          "51:             \"SafeERC20: approve from non-zero to non-zero allowance\"",
          "52:         );",
          "53:         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));",
          "54:     }",
          "60:     function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {",
          "61:         uint256 oldAllowance = token.allowance(address(this), spender);",
          "62:         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));",
          "63:     }",
          "69:     function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {",
          "70:         unchecked {",
          "71:             uint256 oldAllowance = token.allowance(address(this), spender);",
          "72:             require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");",
          "73:             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));",
          "74:         }",
          "75:     }",
          "82:     function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {",
          "83:         bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);",
          "85:         if (!_callOptionalReturnBool(token, approvalCall)) {",
          "86:             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));",
          "87:             _callOptionalReturn(token, approvalCall);",
          "88:         }",
          "89:     }",
          "95:     function safePermit(",
          "96:         IERC20PermitUpgradeable token,",
          "97:         address owner,",
          "98:         address spender,",
          "99:         uint256 value,",
          "100:         uint256 deadline,",
          "101:         uint8 v,",
          "102:         bytes32 r,",
          "103:         bytes32 s",
          "104:     ) internal {",
          "105:         uint256 nonceBefore = token.nonces(owner);",
          "106:         token.permit(owner, spender, value, deadline, v, r, s);",
          "107:         uint256 nonceAfter = token.nonces(owner);",
          "108:         require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");",
          "109:     }",
          "117:     function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {",
          "122:         bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");",
          "123:         require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");",
          "124:     }",
          "134:     function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {",
          "139:         (bool success, bytes memory returndata) = address(token).call(data);",
          "140:         return",
          "141:             success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));",
          "142:     }",
          "143: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC20/utils/TokenTimelockUpgradeable.sol||contracts/token/ERC20/utils/TokenTimelockUpgradeable.sol": [
          "File: contracts/token/ERC20/utils/TokenTimelockUpgradeable.sol -> contracts/token/ERC20/utils/TokenTimelockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./SafeERC20Upgradeable.sol\";",
          "7: import \"../../../proxy/utils/Initializable.sol\";",
          "18: contract TokenTimelockUpgradeable is Initializable {",
          "19:     using SafeERC20Upgradeable for IERC20Upgradeable;",
          "22:     IERC20Upgradeable private _token;",
          "25:     address private _beneficiary;",
          "28:     uint256 private _releaseTime;",
          "35:     function __TokenTimelock_init(IERC20Upgradeable token_, address beneficiary_, uint256 releaseTime_) internal onlyInitializing {",
          "36:         __TokenTimelock_init_unchained(token_, beneficiary_, releaseTime_);",
          "37:     }",
          "39:     function __TokenTimelock_init_unchained(IERC20Upgradeable token_, address beneficiary_, uint256 releaseTime_) internal onlyInitializing {",
          "40:         require(releaseTime_ > block.timestamp, \"TokenTimelock: release time is before current time\");",
          "41:         _token = token_;",
          "42:         _beneficiary = beneficiary_;",
          "43:         _releaseTime = releaseTime_;",
          "44:     }",
          "49:     function token() public view virtual returns (IERC20Upgradeable) {",
          "50:         return _token;",
          "51:     }",
          "56:     function beneficiary() public view virtual returns (address) {",
          "57:         return _beneficiary;",
          "58:     }",
          "63:     function releaseTime() public view virtual returns (uint256) {",
          "64:         return _releaseTime;",
          "65:     }",
          "71:     function release() public virtual {",
          "72:         require(block.timestamp >= releaseTime(), \"TokenTimelock: current time is before release time\");",
          "74:         uint256 amount = token().balanceOf(address(this));",
          "75:         require(amount > 0, \"TokenTimelock: no tokens to release\");",
          "77:         token().safeTransfer(beneficiary(), amount);",
          "78:     }",
          "85:     uint256[50] private __gap;",
          "86: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/ERC721Upgradeable.sol||contracts/token/ERC721/ERC721Upgradeable.sol": [
          "File: contracts/token/ERC721/ERC721Upgradeable.sol -> contracts/token/ERC721/ERC721Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IERC721Upgradeable.sol\";",
          "7: import \"./IERC721ReceiverUpgradeable.sol\";",
          "8: import \"./extensions/IERC721MetadataUpgradeable.sol\";",
          "9: import \"../../utils/AddressUpgradeable.sol\";",
          "10: import \"../../utils/ContextUpgradeable.sol\";",
          "11: import \"../../utils/StringsUpgradeable.sol\";",
          "12: import \"../../utils/introspection/ERC165Upgradeable.sol\";",
          "13: import \"../../proxy/utils/Initializable.sol\";",
          "20: contract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {",
          "21:     using AddressUpgradeable for address;",
          "22:     using StringsUpgradeable for uint256;",
          "25:     string private _name;",
          "28:     string private _symbol;",
          "31:     mapping(uint256 => address) private _owners;",
          "34:     mapping(address => uint256) private _balances;",
          "37:     mapping(uint256 => address) private _tokenApprovals;",
          "40:     mapping(address => mapping(address => bool)) private _operatorApprovals;",
          "45:     function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {",
          "46:         __ERC721_init_unchained(name_, symbol_);",
          "47:     }",
          "49:     function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {",
          "50:         _name = name_;",
          "51:         _symbol = symbol_;",
          "52:     }",
          "57:     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {",
          "58:         return",
          "59:             interfaceId == type(IERC721Upgradeable).interfaceId ||",
          "60:             interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||",
          "61:             super.supportsInterface(interfaceId);",
          "62:     }",
          "67:     function balanceOf(address owner) public view virtual override returns (uint256) {",
          "68:         require(owner != address(0), \"ERC721: address zero is not a valid owner\");",
          "69:         return _balances[owner];",
          "70:     }",
          "75:     function ownerOf(uint256 tokenId) public view virtual override returns (address) {",
          "76:         address owner = _ownerOf(tokenId);",
          "77:         require(owner != address(0), \"ERC721: invalid token ID\");",
          "78:         return owner;",
          "79:     }",
          "84:     function name() public view virtual override returns (string memory) {",
          "85:         return _name;",
          "86:     }",
          "91:     function symbol() public view virtual override returns (string memory) {",
          "92:         return _symbol;",
          "93:     }",
          "98:     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {",
          "99:         _requireMinted(tokenId);",
          "101:         string memory baseURI = _baseURI();",
          "102:         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";",
          "103:     }",
          "110:     function _baseURI() internal view virtual returns (string memory) {",
          "111:         return \"\";",
          "112:     }",
          "117:     function approve(address to, uint256 tokenId) public virtual override {",
          "118:         address owner = ERC721Upgradeable.ownerOf(tokenId);",
          "119:         require(to != owner, \"ERC721: approval to current owner\");",
          "121:         require(",
          "122:             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),",
          "123:             \"ERC721: approve caller is not token owner or approved for all\"",
          "124:         );",
          "126:         _approve(to, tokenId);",
          "127:     }",
          "132:     function getApproved(uint256 tokenId) public view virtual override returns (address) {",
          "133:         _requireMinted(tokenId);",
          "135:         return _tokenApprovals[tokenId];",
          "136:     }",
          "141:     function setApprovalForAll(address operator, bool approved) public virtual override {",
          "142:         _setApprovalForAll(_msgSender(), operator, approved);",
          "143:     }",
          "148:     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {",
          "149:         return _operatorApprovals[owner][operator];",
          "150:     }",
          "155:     function transferFrom(address from, address to, uint256 tokenId) public virtual override {",
          "157:         require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");",
          "159:         _transfer(from, to, tokenId);",
          "160:     }",
          "165:     function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {",
          "166:         safeTransferFrom(from, to, tokenId, \"\");",
          "167:     }",
          "172:     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {",
          "173:         require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");",
          "174:         _safeTransfer(from, to, tokenId, data);",
          "175:     }",
          "195:     function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {",
          "196:         _transfer(from, to, tokenId);",
          "197:         require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");",
          "198:     }",
          "203:     function _ownerOf(uint256 tokenId) internal view virtual returns (address) {",
          "204:         return _owners[tokenId];",
          "205:     }",
          "215:     function _exists(uint256 tokenId) internal view virtual returns (bool) {",
          "216:         return _ownerOf(tokenId) != address(0);",
          "217:     }",
          "226:     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {",
          "227:         address owner = ERC721Upgradeable.ownerOf(tokenId);",
          "228:         return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);",
          "229:     }",
          "241:     function _safeMint(address to, uint256 tokenId) internal virtual {",
          "242:         _safeMint(to, tokenId, \"\");",
          "243:     }",
          "249:     function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {",
          "250:         _mint(to, tokenId);",
          "251:         require(",
          "252:             _checkOnERC721Received(address(0), to, tokenId, data),",
          "253:             \"ERC721: transfer to non ERC721Receiver implementer\"",
          "254:         );",
          "255:     }",
          "269:     function _mint(address to, uint256 tokenId) internal virtual {",
          "270:         require(to != address(0), \"ERC721: mint to the zero address\");",
          "271:         require(!_exists(tokenId), \"ERC721: token already minted\");",
          "273:         _beforeTokenTransfer(address(0), to, tokenId, 1);",
          "276:         require(!_exists(tokenId), \"ERC721: token already minted\");",
          "278:         unchecked {",
          "283:             _balances[to] += 1;",
          "284:         }",
          "286:         _owners[tokenId] = to;",
          "288:         emit Transfer(address(0), to, tokenId);",
          "290:         _afterTokenTransfer(address(0), to, tokenId, 1);",
          "291:     }",
          "304:     function _burn(uint256 tokenId) internal virtual {",
          "305:         address owner = ERC721Upgradeable.ownerOf(tokenId);",
          "307:         _beforeTokenTransfer(owner, address(0), tokenId, 1);",
          "310:         owner = ERC721Upgradeable.ownerOf(tokenId);",
          "313:         delete _tokenApprovals[tokenId];",
          "315:         unchecked {",
          "318:             _balances[owner] -= 1;",
          "319:         }",
          "320:         delete _owners[tokenId];",
          "322:         emit Transfer(owner, address(0), tokenId);",
          "324:         _afterTokenTransfer(owner, address(0), tokenId, 1);",
          "325:     }",
          "338:     function _transfer(address from, address to, uint256 tokenId) internal virtual {",
          "339:         require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");",
          "340:         require(to != address(0), \"ERC721: transfer to the zero address\");",
          "342:         _beforeTokenTransfer(from, to, tokenId, 1);",
          "345:         require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");",
          "348:         delete _tokenApprovals[tokenId];",
          "350:         unchecked {",
          "356:             _balances[from] -= 1;",
          "357:             _balances[to] += 1;",
          "358:         }",
          "359:         _owners[tokenId] = to;",
          "361:         emit Transfer(from, to, tokenId);",
          "363:         _afterTokenTransfer(from, to, tokenId, 1);",
          "364:     }",
          "371:     function _approve(address to, uint256 tokenId) internal virtual {",
          "372:         _tokenApprovals[tokenId] = to;",
          "373:         emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);",
          "374:     }",
          "381:     function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {",
          "382:         require(owner != operator, \"ERC721: approve to caller\");",
          "383:         _operatorApprovals[owner][operator] = approved;",
          "384:         emit ApprovalForAll(owner, operator, approved);",
          "385:     }",
          "390:     function _requireMinted(uint256 tokenId) internal view virtual {",
          "391:         require(_exists(tokenId), \"ERC721: invalid token ID\");",
          "392:     }",
          "404:     function _checkOnERC721Received(",
          "405:         address from,",
          "406:         address to,",
          "407:         uint256 tokenId,",
          "408:         bytes memory data",
          "409:     ) private returns (bool) {",
          "410:         if (to.isContract()) {",
          "411:             try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {",
          "412:                 return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;",
          "413:             } catch (bytes memory reason) {",
          "414:                 if (reason.length == 0) {",
          "415:                     revert(\"ERC721: transfer to non ERC721Receiver implementer\");",
          "416:                 } else {",
          "418:                     assembly {",
          "419:                         revert(add(32, reason), mload(reason))",
          "420:                     }",
          "421:                 }",
          "422:             }",
          "423:         } else {",
          "424:             return true;",
          "425:         }",
          "426:     }",
          "442:     function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}",
          "458:     function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}",
          "468:     function __unsafe_increaseBalance(address account, uint256 amount) internal {",
          "469:         _balances[account] += amount;",
          "470:     }",
          "477:     uint256[44] private __gap;",
          "478: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/IERC721ReceiverUpgradeable.sol||contracts/token/ERC721/IERC721ReceiverUpgradeable.sol": [
          "File: contracts/token/ERC721/IERC721ReceiverUpgradeable.sol -> contracts/token/ERC721/IERC721ReceiverUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "11: interface IERC721ReceiverUpgradeable {",
          "21:     function onERC721Received(",
          "22:         address operator,",
          "23:         address from,",
          "24:         uint256 tokenId,",
          "25:         bytes calldata data",
          "26:     ) external returns (bytes4);",
          "27: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/IERC721Upgradeable.sol||contracts/token/ERC721/IERC721Upgradeable.sol": [
          "File: contracts/token/ERC721/IERC721Upgradeable.sol -> contracts/token/ERC721/IERC721Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../../utils/introspection/IERC165Upgradeable.sol\";",
          "11: interface IERC721Upgradeable is IERC165Upgradeable {",
          "15:     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);",
          "20:     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);",
          "25:     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);",
          "30:     function balanceOf(address owner) external view returns (uint256 balance);",
          "39:     function ownerOf(uint256 tokenId) external view returns (address owner);",
          "54:     function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;",
          "70:     function safeTransferFrom(address from, address to, uint256 tokenId) external;",
          "88:     function transferFrom(address from, address to, uint256 tokenId) external;",
          "103:     function approve(address to, uint256 tokenId) external;",
          "115:     function setApprovalForAll(address operator, bool approved) external;",
          "124:     function getApproved(uint256 tokenId) external view returns (address operator);",
          "131:     function isApprovedForAll(address owner, address operator) external view returns (bool);",
          "132: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/extensions/ERC721BurnableUpgradeable.sol||contracts/token/ERC721/extensions/ERC721BurnableUpgradeable.sol": [
          "File: contracts/token/ERC721/extensions/ERC721BurnableUpgradeable.sol -> contracts/token/ERC721/extensions/ERC721BurnableUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC721Upgradeable.sol\";",
          "7: import \"../../../utils/ContextUpgradeable.sol\";",
          "8: import \"../../../proxy/utils/Initializable.sol\";",
          "14: abstract contract ERC721BurnableUpgradeable is Initializable, ContextUpgradeable, ERC721Upgradeable {",
          "15:     function __ERC721Burnable_init() internal onlyInitializing {",
          "16:     }",
          "18:     function __ERC721Burnable_init_unchained() internal onlyInitializing {",
          "19:     }",
          "27:     function burn(uint256 tokenId) public virtual {",
          "29:         require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");",
          "30:         _burn(tokenId);",
          "31:     }",
          "38:     uint256[50] private __gap;",
          "39: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/extensions/ERC721ConsecutiveUpgradeable.sol||contracts/token/ERC721/extensions/ERC721ConsecutiveUpgradeable.sol": [
          "File: contracts/token/ERC721/extensions/ERC721ConsecutiveUpgradeable.sol -> contracts/token/ERC721/extensions/ERC721ConsecutiveUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC721Upgradeable.sol\";",
          "7: import \"../../../interfaces/IERC2309Upgradeable.sol\";",
          "8: import \"../../../utils/CheckpointsUpgradeable.sol\";",
          "9: import \"../../../utils/structs/BitMapsUpgradeable.sol\";",
          "10: import \"../../../proxy/utils/Initializable.sol\";",
          "33: abstract contract ERC721ConsecutiveUpgradeable is Initializable, IERC2309Upgradeable, ERC721Upgradeable {",
          "34:     function __ERC721Consecutive_init() internal onlyInitializing {",
          "35:     }",
          "37:     function __ERC721Consecutive_init_unchained() internal onlyInitializing {",
          "38:     }",
          "39:     using BitMapsUpgradeable for BitMapsUpgradeable.BitMap;",
          "40:     using CheckpointsUpgradeable for CheckpointsUpgradeable.Trace160;",
          "42:     CheckpointsUpgradeable.Trace160 private _sequentialOwnership;",
          "43:     BitMapsUpgradeable.BitMap private _sequentialBurn;",
          "53:     function _maxBatchSize() internal view virtual returns (uint96) {",
          "54:         return 5000;",
          "55:     }",
          "61:     function _ownerOf(uint256 tokenId) internal view virtual override returns (address) {",
          "62:         address owner = super._ownerOf(tokenId);",
          "65:         if (owner != address(0) || tokenId > type(uint96).max) {",
          "66:             return owner;",
          "67:         }",
          "71:         return _sequentialBurn.get(tokenId) ? address(0) : address(_sequentialOwnership.lowerLookup(uint96(tokenId)));",
          "72:     }",
          "90:     function _mintConsecutive(address to, uint96 batchSize) internal virtual returns (uint96) {",
          "91:         uint96 first = _totalConsecutiveSupply();",
          "94:         if (batchSize > 0) {",
          "95:             require(!AddressUpgradeable.isContract(address(this)), \"ERC721Consecutive: batch minting restricted to constructor\");",
          "96:             require(to != address(0), \"ERC721Consecutive: mint to the zero address\");",
          "97:             require(batchSize <= _maxBatchSize(), \"ERC721Consecutive: batch too large\");",
          "100:             _beforeTokenTransfer(address(0), to, first, batchSize);",
          "103:             uint96 last = first + batchSize - 1;",
          "104:             _sequentialOwnership.push(last, uint160(to));",
          "108:             __unsafe_increaseBalance(to, batchSize);",
          "110:             emit ConsecutiveTransfer(first, last, address(0), to);",
          "113:             _afterTokenTransfer(address(0), to, first, batchSize);",
          "114:         }",
          "116:         return first;",
          "117:     }",
          "125:     function _mint(address to, uint256 tokenId) internal virtual override {",
          "126:         require(AddressUpgradeable.isContract(address(this)), \"ERC721Consecutive: can't mint during construction\");",
          "127:         super._mint(to, tokenId);",
          "128:     }",
          "133:     function _afterTokenTransfer(",
          "134:         address from,",
          "135:         address to,",
          "136:         uint256 firstTokenId,",
          "137:         uint256 batchSize",
          "138:     ) internal virtual override {",
          "139:         if (",
          "140:             to == address(0) && // if we burn",
          "141:             firstTokenId < _totalConsecutiveSupply() && // and the tokenId was minted in a batch",
          "142:             !_sequentialBurn.get(firstTokenId) // and the token was never marked as burnt",
          "143:         ) {",
          "144:             require(batchSize == 1, \"ERC721Consecutive: batch burn not supported\");",
          "145:             _sequentialBurn.set(firstTokenId);",
          "146:         }",
          "147:         super._afterTokenTransfer(from, to, firstTokenId, batchSize);",
          "148:     }",
          "150:     function _totalConsecutiveSupply() private view returns (uint96) {",
          "151:         (bool exists, uint96 latestId, ) = _sequentialOwnership.latestCheckpoint();",
          "152:         return exists ? latestId + 1 : 0;",
          "153:     }",
          "160:     uint256[48] private __gap;",
          "161: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol||contracts/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": [
          "File: contracts/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol -> contracts/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC721Upgradeable.sol\";",
          "7: import \"./IERC721EnumerableUpgradeable.sol\";",
          "8: import \"../../../proxy/utils/Initializable.sol\";",
          "15: abstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {",
          "16:     function __ERC721Enumerable_init() internal onlyInitializing {",
          "17:     }",
          "19:     function __ERC721Enumerable_init_unchained() internal onlyInitializing {",
          "20:     }",
          "22:     mapping(address => mapping(uint256 => uint256)) private _ownedTokens;",
          "25:     mapping(uint256 => uint256) private _ownedTokensIndex;",
          "28:     uint256[] private _allTokens;",
          "31:     mapping(uint256 => uint256) private _allTokensIndex;",
          "36:     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {",
          "37:         return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);",
          "38:     }",
          "43:     function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {",
          "44:         require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");",
          "45:         return _ownedTokens[owner][index];",
          "46:     }",
          "51:     function totalSupply() public view virtual override returns (uint256) {",
          "52:         return _allTokens.length;",
          "53:     }",
          "58:     function tokenByIndex(uint256 index) public view virtual override returns (uint256) {",
          "59:         require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");",
          "60:         return _allTokens[index];",
          "61:     }",
          "66:     function _beforeTokenTransfer(",
          "67:         address from,",
          "68:         address to,",
          "69:         uint256 firstTokenId,",
          "70:         uint256 batchSize",
          "71:     ) internal virtual override {",
          "72:         super._beforeTokenTransfer(from, to, firstTokenId, batchSize);",
          "74:         if (batchSize > 1) {",
          "76:             revert(\"ERC721Enumerable: consecutive transfers not supported\");",
          "77:         }",
          "79:         uint256 tokenId = firstTokenId;",
          "81:         if (from == address(0)) {",
          "82:             _addTokenToAllTokensEnumeration(tokenId);",
          "83:         } else if (from != to) {",
          "84:             _removeTokenFromOwnerEnumeration(from, tokenId);",
          "85:         }",
          "86:         if (to == address(0)) {",
          "87:             _removeTokenFromAllTokensEnumeration(tokenId);",
          "88:         } else if (to != from) {",
          "89:             _addTokenToOwnerEnumeration(to, tokenId);",
          "90:         }",
          "91:     }",
          "98:     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {",
          "99:         uint256 length = ERC721Upgradeable.balanceOf(to);",
          "100:         _ownedTokens[to][length] = tokenId;",
          "101:         _ownedTokensIndex[tokenId] = length;",
          "102:     }",
          "108:     function _addTokenToAllTokensEnumeration(uint256 tokenId) private {",
          "109:         _allTokensIndex[tokenId] = _allTokens.length;",
          "110:         _allTokens.push(tokenId);",
          "111:     }",
          "121:     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {",
          "125:         uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;",
          "126:         uint256 tokenIndex = _ownedTokensIndex[tokenId];",
          "129:         if (tokenIndex != lastTokenIndex) {",
          "130:             uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];",
          "132:             _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token",
          "133:             _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index",
          "134:         }",
          "137:         delete _ownedTokensIndex[tokenId];",
          "138:         delete _ownedTokens[from][lastTokenIndex];",
          "139:     }",
          "146:     function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {",
          "150:         uint256 lastTokenIndex = _allTokens.length - 1;",
          "151:         uint256 tokenIndex = _allTokensIndex[tokenId];",
          "156:         uint256 lastTokenId = _allTokens[lastTokenIndex];",
          "158:         _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token",
          "159:         _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index",
          "162:         delete _allTokensIndex[tokenId];",
          "163:         _allTokens.pop();",
          "164:     }",
          "171:     uint256[46] private __gap;",
          "172: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/extensions/ERC721PausableUpgradeable.sol||contracts/token/ERC721/extensions/ERC721PausableUpgradeable.sol": [
          "File: contracts/token/ERC721/extensions/ERC721PausableUpgradeable.sol -> contracts/token/ERC721/extensions/ERC721PausableUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC721Upgradeable.sol\";",
          "7: import \"../../../security/PausableUpgradeable.sol\";",
          "8: import \"../../../proxy/utils/Initializable.sol\";",
          "23: abstract contract ERC721PausableUpgradeable is Initializable, ERC721Upgradeable, PausableUpgradeable {",
          "24:     function __ERC721Pausable_init() internal onlyInitializing {",
          "25:         __Pausable_init_unchained();",
          "26:     }",
          "28:     function __ERC721Pausable_init_unchained() internal onlyInitializing {",
          "29:     }",
          "37:     function _beforeTokenTransfer(",
          "38:         address from,",
          "39:         address to,",
          "40:         uint256 firstTokenId,",
          "41:         uint256 batchSize",
          "42:     ) internal virtual override {",
          "43:         super._beforeTokenTransfer(from, to, firstTokenId, batchSize);",
          "45:         require(!paused(), \"ERC721Pausable: token transfer while paused\");",
          "46:     }",
          "53:     uint256[50] private __gap;",
          "54: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/extensions/ERC721RoyaltyUpgradeable.sol||contracts/token/ERC721/extensions/ERC721RoyaltyUpgradeable.sol": [
          "File: contracts/token/ERC721/extensions/ERC721RoyaltyUpgradeable.sol -> contracts/token/ERC721/extensions/ERC721RoyaltyUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC721Upgradeable.sol\";",
          "7: import \"../../common/ERC2981Upgradeable.sol\";",
          "8: import \"../../../utils/introspection/ERC165Upgradeable.sol\";",
          "9: import \"../../../proxy/utils/Initializable.sol\";",
          "24: abstract contract ERC721RoyaltyUpgradeable is Initializable, ERC2981Upgradeable, ERC721Upgradeable {",
          "25:     function __ERC721Royalty_init() internal onlyInitializing {",
          "26:     }",
          "28:     function __ERC721Royalty_init_unchained() internal onlyInitializing {",
          "29:     }",
          "33:     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, ERC2981Upgradeable) returns (bool) {",
          "34:         return super.supportsInterface(interfaceId);",
          "35:     }",
          "40:     function _burn(uint256 tokenId) internal virtual override {",
          "41:         super._burn(tokenId);",
          "42:         _resetTokenRoyalty(tokenId);",
          "43:     }",
          "50:     uint256[50] private __gap;",
          "51: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol||contracts/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol": [
          "File: contracts/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol -> contracts/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC721Upgradeable.sol\";",
          "7: import \"../../../interfaces/IERC4906Upgradeable.sol\";",
          "8: import \"../../../proxy/utils/Initializable.sol\";",
          "13: abstract contract ERC721URIStorageUpgradeable is Initializable, IERC4906Upgradeable, ERC721Upgradeable {",
          "14:     function __ERC721URIStorage_init() internal onlyInitializing {",
          "15:     }",
          "17:     function __ERC721URIStorage_init_unchained() internal onlyInitializing {",
          "18:     }",
          "19:     using StringsUpgradeable for uint256;",
          "22:     mapping(uint256 => string) private _tokenURIs;",
          "27:     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, IERC165Upgradeable) returns (bool) {",
          "28:         return interfaceId == bytes4(0x49064906) || super.supportsInterface(interfaceId);",
          "29:     }",
          "34:     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {",
          "35:         _requireMinted(tokenId);",
          "37:         string memory _tokenURI = _tokenURIs[tokenId];",
          "38:         string memory base = _baseURI();",
          "41:         if (bytes(base).length == 0) {",
          "42:             return _tokenURI;",
          "43:         }",
          "45:         if (bytes(_tokenURI).length > 0) {",
          "46:             return string(abi.encodePacked(base, _tokenURI));",
          "47:         }",
          "49:         return super.tokenURI(tokenId);",
          "50:     }",
          "61:     function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {",
          "62:         require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");",
          "63:         _tokenURIs[tokenId] = _tokenURI;",
          "65:         emit MetadataUpdate(tokenId);",
          "66:     }",
          "73:     function _burn(uint256 tokenId) internal virtual override {",
          "74:         super._burn(tokenId);",
          "76:         if (bytes(_tokenURIs[tokenId]).length != 0) {",
          "77:             delete _tokenURIs[tokenId];",
          "78:         }",
          "79:     }",
          "86:     uint256[49] private __gap;",
          "87: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/extensions/ERC721VotesUpgradeable.sol||contracts/token/ERC721/extensions/ERC721VotesUpgradeable.sol": [
          "File: contracts/token/ERC721/extensions/ERC721VotesUpgradeable.sol -> contracts/token/ERC721/extensions/ERC721VotesUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC721Upgradeable.sol\";",
          "7: import \"../../../governance/utils/VotesUpgradeable.sol\";",
          "8: import \"../../../proxy/utils/Initializable.sol\";",
          "20: abstract contract ERC721VotesUpgradeable is Initializable, ERC721Upgradeable, VotesUpgradeable {",
          "21:     function __ERC721Votes_init() internal onlyInitializing {",
          "22:     }",
          "24:     function __ERC721Votes_init_unchained() internal onlyInitializing {",
          "25:     }",
          "31:     function _afterTokenTransfer(",
          "32:         address from,",
          "33:         address to,",
          "34:         uint256 firstTokenId,",
          "35:         uint256 batchSize",
          "36:     ) internal virtual override {",
          "37:         _transferVotingUnits(from, to, batchSize);",
          "38:         super._afterTokenTransfer(from, to, firstTokenId, batchSize);",
          "39:     }",
          "46:     function _getVotingUnits(address account) internal view virtual override returns (uint256) {",
          "47:         return balanceOf(account);",
          "48:     }",
          "55:     uint256[50] private __gap;",
          "56: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/extensions/ERC721WrapperUpgradeable.sol||contracts/token/ERC721/extensions/ERC721WrapperUpgradeable.sol": [
          "File: contracts/token/ERC721/extensions/ERC721WrapperUpgradeable.sol -> contracts/token/ERC721/extensions/ERC721WrapperUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../ERC721Upgradeable.sol\";",
          "6: import \"../../../proxy/utils/Initializable.sol\";",
          "17: abstract contract ERC721WrapperUpgradeable is Initializable, ERC721Upgradeable, IERC721ReceiverUpgradeable {",
          "18:     IERC721Upgradeable private _underlying;",
          "20:     function __ERC721Wrapper_init(IERC721Upgradeable underlyingToken) internal onlyInitializing {",
          "21:         __ERC721Wrapper_init_unchained(underlyingToken);",
          "22:     }",
          "24:     function __ERC721Wrapper_init_unchained(IERC721Upgradeable underlyingToken) internal onlyInitializing {",
          "25:         _underlying = underlyingToken;",
          "26:     }",
          "31:     function depositFor(address account, uint256[] memory tokenIds) public virtual returns (bool) {",
          "32:         uint256 length = tokenIds.length;",
          "33:         for (uint256 i = 0; i < length; ++i) {",
          "34:             uint256 tokenId = tokenIds[i];",
          "39:             underlying().transferFrom(_msgSender(), address(this), tokenId);",
          "40:             _safeMint(account, tokenId);",
          "41:         }",
          "43:         return true;",
          "44:     }",
          "49:     function withdrawTo(address account, uint256[] memory tokenIds) public virtual returns (bool) {",
          "50:         uint256 length = tokenIds.length;",
          "51:         for (uint256 i = 0; i < length; ++i) {",
          "52:             uint256 tokenId = tokenIds[i];",
          "53:             require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Wrapper: caller is not token owner or approved\");",
          "54:             _burn(tokenId);",
          "58:             underlying().safeTransferFrom(address(this), account, tokenId);",
          "59:         }",
          "61:         return true;",
          "62:     }",
          "74:     function onERC721Received(",
          "75:         address,",
          "76:         address from,",
          "77:         uint256 tokenId,",
          "78:         bytes memory",
          "79:     ) public virtual override returns (bytes4) {",
          "80:         require(address(underlying()) == _msgSender(), \"ERC721Wrapper: caller is not underlying\");",
          "81:         _safeMint(from, tokenId);",
          "82:         return IERC721ReceiverUpgradeable.onERC721Received.selector;",
          "83:     }",
          "89:     function _recover(address account, uint256 tokenId) internal virtual returns (uint256) {",
          "90:         require(underlying().ownerOf(tokenId) == address(this), \"ERC721Wrapper: wrapper is not token owner\");",
          "91:         _safeMint(account, tokenId);",
          "92:         return tokenId;",
          "93:     }",
          "98:     function underlying() public view virtual returns (IERC721Upgradeable) {",
          "99:         return _underlying;",
          "100:     }",
          "107:     uint256[49] private __gap;",
          "108: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol||contracts/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": [
          "File: contracts/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol -> contracts/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../IERC721Upgradeable.sol\";",
          "12: interface IERC721EnumerableUpgradeable is IERC721Upgradeable {",
          "16:     function totalSupply() external view returns (uint256);",
          "22:     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);",
          "28:     function tokenByIndex(uint256 index) external view returns (uint256);",
          "29: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/extensions/IERC721MetadataUpgradeable.sol||contracts/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": [
          "File: contracts/token/ERC721/extensions/IERC721MetadataUpgradeable.sol -> contracts/token/ERC721/extensions/IERC721MetadataUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../IERC721Upgradeable.sol\";",
          "12: interface IERC721MetadataUpgradeable is IERC721Upgradeable {",
          "16:     function name() external view returns (string memory);",
          "21:     function symbol() external view returns (string memory);",
          "26:     function tokenURI(uint256 tokenId) external view returns (string memory);",
          "27: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/extensions/draft-ERC721VotesUpgradeable.sol||contracts/token/ERC721/extensions/draft-ERC721VotesUpgradeable.sol": [
          "File: contracts/token/ERC721/extensions/draft-ERC721VotesUpgradeable.sol -> contracts/token/ERC721/extensions/draft-ERC721VotesUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "9: import \"./ERC721VotesUpgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/presets/ERC721PresetMinterPauserAutoIdUpgradeable.sol||contracts/token/ERC721/presets/ERC721PresetMinterPauserAutoIdUpgradeable.sol": [
          "File: contracts/token/ERC721/presets/ERC721PresetMinterPauserAutoIdUpgradeable.sol -> contracts/token/ERC721/presets/ERC721PresetMinterPauserAutoIdUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../ERC721Upgradeable.sol\";",
          "7: import \"../extensions/ERC721EnumerableUpgradeable.sol\";",
          "8: import \"../extensions/ERC721BurnableUpgradeable.sol\";",
          "9: import \"../extensions/ERC721PausableUpgradeable.sol\";",
          "10: import \"../../../access/AccessControlEnumerableUpgradeable.sol\";",
          "11: import \"../../../utils/ContextUpgradeable.sol\";",
          "12: import \"../../../utils/CountersUpgradeable.sol\";",
          "13: import \"../../../proxy/utils/Initializable.sol\";",
          "32: contract ERC721PresetMinterPauserAutoIdUpgradeable is",
          "33:     Initializable, ContextUpgradeable,",
          "34:     AccessControlEnumerableUpgradeable,",
          "35:     ERC721EnumerableUpgradeable,",
          "36:     ERC721BurnableUpgradeable,",
          "37:     ERC721PausableUpgradeable",
          "38: {",
          "39:     function initialize(string memory name, string memory symbol, string memory baseTokenURI) public virtual initializer {",
          "40:         __ERC721PresetMinterPauserAutoId_init(name, symbol, baseTokenURI);",
          "41:     }",
          "42:     using CountersUpgradeable for CountersUpgradeable.Counter;",
          "44:     bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");",
          "45:     bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");",
          "47:     CountersUpgradeable.Counter private _tokenIdTracker;",
          "49:     string private _baseTokenURI;",
          "58:     function __ERC721PresetMinterPauserAutoId_init(string memory name, string memory symbol, string memory baseTokenURI) internal onlyInitializing {",
          "59:         __ERC721_init_unchained(name, symbol);",
          "60:         __Pausable_init_unchained();",
          "61:         __ERC721PresetMinterPauserAutoId_init_unchained(name, symbol, baseTokenURI);",
          "62:     }",
          "64:     function __ERC721PresetMinterPauserAutoId_init_unchained(string memory, string memory, string memory baseTokenURI) internal onlyInitializing {",
          "65:         _baseTokenURI = baseTokenURI;",
          "67:         _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());",
          "69:         _setupRole(MINTER_ROLE, _msgSender());",
          "70:         _setupRole(PAUSER_ROLE, _msgSender());",
          "71:     }",
          "73:     function _baseURI() internal view virtual override returns (string memory) {",
          "74:         return _baseTokenURI;",
          "75:     }",
          "88:     function mint(address to) public virtual {",
          "89:         require(hasRole(MINTER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have minter role to mint\");",
          "93:         _mint(to, _tokenIdTracker.current());",
          "94:         _tokenIdTracker.increment();",
          "95:     }",
          "106:     function pause() public virtual {",
          "107:         require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\");",
          "108:         _pause();",
          "109:     }",
          "120:     function unpause() public virtual {",
          "121:         require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\");",
          "122:         _unpause();",
          "123:     }",
          "125:     function _beforeTokenTransfer(",
          "126:         address from,",
          "127:         address to,",
          "128:         uint256 firstTokenId,",
          "129:         uint256 batchSize",
          "130:     ) internal virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable, ERC721PausableUpgradeable) {",
          "131:         super._beforeTokenTransfer(from, to, firstTokenId, batchSize);",
          "132:     }",
          "137:     function supportsInterface(",
          "138:         bytes4 interfaceId",
          "139:     ) public view virtual override(AccessControlEnumerableUpgradeable, ERC721Upgradeable, ERC721EnumerableUpgradeable) returns (bool) {",
          "140:         return super.supportsInterface(interfaceId);",
          "141:     }",
          "148:     uint256[48] private __gap;",
          "149: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC721/utils/ERC721HolderUpgradeable.sol||contracts/token/ERC721/utils/ERC721HolderUpgradeable.sol": [
          "File: contracts/token/ERC721/utils/ERC721HolderUpgradeable.sol -> contracts/token/ERC721/utils/ERC721HolderUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../IERC721ReceiverUpgradeable.sol\";",
          "7: import \"../../../proxy/utils/Initializable.sol\";",
          "15: contract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {",
          "16:     function __ERC721Holder_init() internal onlyInitializing {",
          "17:     }",
          "19:     function __ERC721Holder_init_unchained() internal onlyInitializing {",
          "20:     }",
          "26:     function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {",
          "27:         return this.onERC721Received.selector;",
          "28:     }",
          "35:     uint256[50] private __gap;",
          "36: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC777/ERC777Upgradeable.sol||contracts/token/ERC777/ERC777Upgradeable.sol": [
          "File: contracts/token/ERC777/ERC777Upgradeable.sol -> contracts/token/ERC777/ERC777Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IERC777Upgradeable.sol\";",
          "7: import \"./IERC777RecipientUpgradeable.sol\";",
          "8: import \"./IERC777SenderUpgradeable.sol\";",
          "9: import \"../ERC20/IERC20Upgradeable.sol\";",
          "10: import \"../../utils/AddressUpgradeable.sol\";",
          "11: import \"../../utils/ContextUpgradeable.sol\";",
          "12: import \"../../utils/introspection/IERC1820RegistryUpgradeable.sol\";",
          "13: import \"../../proxy/utils/Initializable.sol\";",
          "32: contract ERC777Upgradeable is Initializable, ContextUpgradeable, IERC777Upgradeable, IERC20Upgradeable {",
          "33:     using AddressUpgradeable for address;",
          "35:     IERC1820RegistryUpgradeable internal constant _ERC1820_REGISTRY = IERC1820RegistryUpgradeable(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);",
          "37:     mapping(address => uint256) private _balances;",
          "39:     uint256 private _totalSupply;",
          "41:     string private _name;",
          "42:     string private _symbol;",
          "44:     bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256(\"ERC777TokensSender\");",
          "45:     bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");",
          "48:     address[] private _defaultOperatorsArray;",
          "51:     mapping(address => bool) private _defaultOperators;",
          "54:     mapping(address => mapping(address => bool)) private _operators;",
          "55:     mapping(address => mapping(address => bool)) private _revokedDefaultOperators;",
          "58:     mapping(address => mapping(address => uint256)) private _allowances;",
          "63:     function __ERC777_init(string memory name_, string memory symbol_, address[] memory defaultOperators_) internal onlyInitializing {",
          "64:         __ERC777_init_unchained(name_, symbol_, defaultOperators_);",
          "65:     }",
          "67:     function __ERC777_init_unchained(string memory name_, string memory symbol_, address[] memory defaultOperators_) internal onlyInitializing {",
          "68:         _name = name_;",
          "69:         _symbol = symbol_;",
          "71:         _defaultOperatorsArray = defaultOperators_;",
          "72:         for (uint256 i = 0; i < defaultOperators_.length; i++) {",
          "73:             _defaultOperators[defaultOperators_[i]] = true;",
          "74:         }",
          "77:         _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));",
          "78:         _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));",
          "79:     }",
          "84:     function name() public view virtual override returns (string memory) {",
          "85:         return _name;",
          "86:     }",
          "91:     function symbol() public view virtual override returns (string memory) {",
          "92:         return _symbol;",
          "93:     }",
          "101:     function decimals() public pure virtual returns (uint8) {",
          "102:         return 18;",
          "103:     }",
          "110:     function granularity() public view virtual override returns (uint256) {",
          "111:         return 1;",
          "112:     }",
          "117:     function totalSupply() public view virtual override(IERC20Upgradeable, IERC777Upgradeable) returns (uint256) {",
          "118:         return _totalSupply;",
          "119:     }",
          "124:     function balanceOf(address tokenHolder) public view virtual override(IERC20Upgradeable, IERC777Upgradeable) returns (uint256) {",
          "125:         return _balances[tokenHolder];",
          "126:     }",
          "133:     function send(address recipient, uint256 amount, bytes memory data) public virtual override {",
          "134:         _send(_msgSender(), recipient, amount, data, \"\", true);",
          "135:     }",
          "145:     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {",
          "146:         _send(_msgSender(), recipient, amount, \"\", \"\", false);",
          "147:         return true;",
          "148:     }",
          "155:     function burn(uint256 amount, bytes memory data) public virtual override {",
          "156:         _burn(_msgSender(), amount, data, \"\");",
          "157:     }",
          "162:     function isOperatorFor(address operator, address tokenHolder) public view virtual override returns (bool) {",
          "163:         return",
          "164:             operator == tokenHolder ||",
          "165:             (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||",
          "166:             _operators[tokenHolder][operator];",
          "167:     }",
          "172:     function authorizeOperator(address operator) public virtual override {",
          "173:         require(_msgSender() != operator, \"ERC777: authorizing self as operator\");",
          "175:         if (_defaultOperators[operator]) {",
          "176:             delete _revokedDefaultOperators[_msgSender()][operator];",
          "177:         } else {",
          "178:             _operators[_msgSender()][operator] = true;",
          "179:         }",
          "181:         emit AuthorizedOperator(operator, _msgSender());",
          "182:     }",
          "187:     function revokeOperator(address operator) public virtual override {",
          "188:         require(operator != _msgSender(), \"ERC777: revoking self as operator\");",
          "190:         if (_defaultOperators[operator]) {",
          "191:             _revokedDefaultOperators[_msgSender()][operator] = true;",
          "192:         } else {",
          "193:             delete _operators[_msgSender()][operator];",
          "194:         }",
          "196:         emit RevokedOperator(operator, _msgSender());",
          "197:     }",
          "202:     function defaultOperators() public view virtual override returns (address[] memory) {",
          "203:         return _defaultOperatorsArray;",
          "204:     }",
          "211:     function operatorSend(",
          "212:         address sender,",
          "213:         address recipient,",
          "214:         uint256 amount,",
          "215:         bytes memory data,",
          "216:         bytes memory operatorData",
          "217:     ) public virtual override {",
          "218:         require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");",
          "219:         _send(sender, recipient, amount, data, operatorData, true);",
          "220:     }",
          "227:     function operatorBurn(",
          "228:         address account,",
          "229:         uint256 amount,",
          "230:         bytes memory data,",
          "231:         bytes memory operatorData",
          "232:     ) public virtual override {",
          "233:         require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");",
          "234:         _burn(account, amount, data, operatorData);",
          "235:     }",
          "244:     function allowance(address holder, address spender) public view virtual override returns (uint256) {",
          "245:         return _allowances[holder][spender];",
          "246:     }",
          "256:     function approve(address spender, uint256 value) public virtual override returns (bool) {",
          "257:         address holder = _msgSender();",
          "258:         _approve(holder, spender, value);",
          "259:         return true;",
          "260:     }",
          "274:     function transferFrom(address holder, address recipient, uint256 amount) public virtual override returns (bool) {",
          "275:         address spender = _msgSender();",
          "276:         _spendAllowance(holder, spender, amount);",
          "277:         _send(holder, recipient, amount, \"\", \"\", false);",
          "278:         return true;",
          "279:     }",
          "299:     function _mint(address account, uint256 amount, bytes memory userData, bytes memory operatorData) internal virtual {",
          "300:         _mint(account, amount, userData, operatorData, true);",
          "301:     }",
          "321:     function _mint(",
          "322:         address account,",
          "323:         uint256 amount,",
          "324:         bytes memory userData,",
          "325:         bytes memory operatorData,",
          "326:         bool requireReceptionAck",
          "327:     ) internal virtual {",
          "328:         require(account != address(0), \"ERC777: mint to the zero address\");",
          "330:         address operator = _msgSender();",
          "332:         _beforeTokenTransfer(operator, address(0), account, amount);",
          "335:         _totalSupply += amount;",
          "336:         _balances[account] += amount;",
          "338:         _callTokensReceived(operator, address(0), account, amount, userData, operatorData, requireReceptionAck);",
          "340:         emit Minted(operator, account, amount, userData, operatorData);",
          "341:         emit Transfer(address(0), account, amount);",
          "342:     }",
          "353:     function _send(",
          "354:         address from,",
          "355:         address to,",
          "356:         uint256 amount,",
          "357:         bytes memory userData,",
          "358:         bytes memory operatorData,",
          "359:         bool requireReceptionAck",
          "360:     ) internal virtual {",
          "361:         require(from != address(0), \"ERC777: transfer from the zero address\");",
          "362:         require(to != address(0), \"ERC777: transfer to the zero address\");",
          "364:         address operator = _msgSender();",
          "366:         _callTokensToSend(operator, from, to, amount, userData, operatorData);",
          "368:         _move(operator, from, to, amount, userData, operatorData);",
          "370:         _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);",
          "371:     }",
          "380:     function _burn(address from, uint256 amount, bytes memory data, bytes memory operatorData) internal virtual {",
          "381:         require(from != address(0), \"ERC777: burn from the zero address\");",
          "383:         address operator = _msgSender();",
          "385:         _callTokensToSend(operator, from, address(0), amount, data, operatorData);",
          "387:         _beforeTokenTransfer(operator, from, address(0), amount);",
          "390:         uint256 fromBalance = _balances[from];",
          "391:         require(fromBalance >= amount, \"ERC777: burn amount exceeds balance\");",
          "392:         unchecked {",
          "393:             _balances[from] = fromBalance - amount;",
          "394:         }",
          "395:         _totalSupply -= amount;",
          "397:         emit Burned(operator, from, amount, data, operatorData);",
          "398:         emit Transfer(from, address(0), amount);",
          "399:     }",
          "401:     function _move(",
          "402:         address operator,",
          "403:         address from,",
          "404:         address to,",
          "405:         uint256 amount,",
          "406:         bytes memory userData,",
          "407:         bytes memory operatorData",
          "408:     ) private {",
          "409:         _beforeTokenTransfer(operator, from, to, amount);",
          "411:         uint256 fromBalance = _balances[from];",
          "412:         require(fromBalance >= amount, \"ERC777: transfer amount exceeds balance\");",
          "413:         unchecked {",
          "414:             _balances[from] = fromBalance - amount;",
          "415:         }",
          "416:         _balances[to] += amount;",
          "418:         emit Sent(operator, from, to, amount, userData, operatorData);",
          "419:         emit Transfer(from, to, amount);",
          "420:     }",
          "427:     function _approve(address holder, address spender, uint256 value) internal virtual {",
          "428:         require(holder != address(0), \"ERC777: approve from the zero address\");",
          "429:         require(spender != address(0), \"ERC777: approve to the zero address\");",
          "431:         _allowances[holder][spender] = value;",
          "432:         emit Approval(holder, spender, value);",
          "433:     }",
          "444:     function _callTokensToSend(",
          "445:         address operator,",
          "446:         address from,",
          "447:         address to,",
          "448:         uint256 amount,",
          "449:         bytes memory userData,",
          "450:         bytes memory operatorData",
          "451:     ) private {",
          "452:         address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);",
          "453:         if (implementer != address(0)) {",
          "454:             IERC777SenderUpgradeable(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);",
          "455:         }",
          "456:     }",
          "469:     function _callTokensReceived(",
          "470:         address operator,",
          "471:         address from,",
          "472:         address to,",
          "473:         uint256 amount,",
          "474:         bytes memory userData,",
          "475:         bytes memory operatorData,",
          "476:         bool requireReceptionAck",
          "477:     ) private {",
          "478:         address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(to, _TOKENS_RECIPIENT_INTERFACE_HASH);",
          "479:         if (implementer != address(0)) {",
          "480:             IERC777RecipientUpgradeable(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);",
          "481:         } else if (requireReceptionAck) {",
          "482:             require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");",
          "483:         }",
          "484:     }",
          "494:     function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {",
          "495:         uint256 currentAllowance = allowance(owner, spender);",
          "496:         if (currentAllowance != type(uint256).max) {",
          "497:             require(currentAllowance >= amount, \"ERC777: insufficient allowance\");",
          "498:             unchecked {",
          "499:                 _approve(owner, spender, currentAllowance - amount);",
          "500:             }",
          "501:         }",
          "502:     }",
          "518:     function _beforeTokenTransfer(address operator, address from, address to, uint256 amount) internal virtual {}",
          "525:     uint256[41] private __gap;",
          "526: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC777/IERC777RecipientUpgradeable.sol||contracts/token/ERC777/IERC777RecipientUpgradeable.sol": [
          "File: contracts/token/ERC777/IERC777RecipientUpgradeable.sol -> contracts/token/ERC777/IERC777RecipientUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "16: interface IERC777RecipientUpgradeable {",
          "27:     function tokensReceived(",
          "28:         address operator,",
          "29:         address from,",
          "30:         address to,",
          "31:         uint256 amount,",
          "32:         bytes calldata userData,",
          "33:         bytes calldata operatorData",
          "34:     ) external;",
          "35: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC777/IERC777SenderUpgradeable.sol||contracts/token/ERC777/IERC777SenderUpgradeable.sol": [
          "File: contracts/token/ERC777/IERC777SenderUpgradeable.sol -> contracts/token/ERC777/IERC777SenderUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "16: interface IERC777SenderUpgradeable {",
          "27:     function tokensToSend(",
          "28:         address operator,",
          "29:         address from,",
          "30:         address to,",
          "31:         uint256 amount,",
          "32:         bytes calldata userData,",
          "33:         bytes calldata operatorData",
          "34:     ) external;",
          "35: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC777/IERC777Upgradeable.sol||contracts/token/ERC777/IERC777Upgradeable.sol": [
          "File: contracts/token/ERC777/IERC777Upgradeable.sol -> contracts/token/ERC777/IERC777Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "15: interface IERC777Upgradeable {",
          "21:     event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);",
          "28:     event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);",
          "33:     event AuthorizedOperator(address indexed operator, address indexed tokenHolder);",
          "38:     event RevokedOperator(address indexed operator, address indexed tokenHolder);",
          "43:     function name() external view returns (string memory);",
          "49:     function symbol() external view returns (string memory);",
          "58:     function granularity() external view returns (uint256);",
          "63:     function totalSupply() external view returns (uint256);",
          "68:     function balanceOf(address owner) external view returns (uint256);",
          "86:     function send(address recipient, uint256 amount, bytes calldata data) external;",
          "101:     function burn(uint256 amount, bytes calldata data) external;",
          "110:     function isOperatorFor(address operator, address tokenHolder) external view returns (bool);",
          "123:     function authorizeOperator(address operator) external;",
          "136:     function revokeOperator(address operator) external;",
          "146:     function defaultOperators() external view returns (address[] memory);",
          "167:     function operatorSend(",
          "168:         address sender,",
          "169:         address recipient,",
          "170:         uint256 amount,",
          "171:         bytes calldata data,",
          "172:         bytes calldata operatorData",
          "173:     ) external;",
          "190:     function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external;",
          "192:     event Sent(",
          "193:         address indexed operator,",
          "194:         address indexed from,",
          "195:         address indexed to,",
          "196:         uint256 amount,",
          "197:         bytes data,",
          "198:         bytes operatorData",
          "199:     );",
          "200: }",
          "",
          "---------------"
        ],
        "contracts/token/ERC777/presets/ERC777PresetFixedSupplyUpgradeable.sol||contracts/token/ERC777/presets/ERC777PresetFixedSupplyUpgradeable.sol": [
          "File: contracts/token/ERC777/presets/ERC777PresetFixedSupplyUpgradeable.sol -> contracts/token/ERC777/presets/ERC777PresetFixedSupplyUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"../ERC777Upgradeable.sol\";",
          "6: import \"../../../proxy/utils/Initializable.sol\";",
          "16: contract ERC777PresetFixedSupplyUpgradeable is Initializable, ERC777Upgradeable {",
          "17:     function initialize(",
          "18:         string memory name,",
          "19:         string memory symbol,",
          "20:         address[] memory defaultOperators,",
          "21:         uint256 initialSupply,",
          "22:         address owner",
          "23:     ) public virtual initializer {",
          "24:         __ERC777PresetFixedSupply_init(name, symbol, defaultOperators, initialSupply, owner);",
          "25:     }",
          "31:     function __ERC777PresetFixedSupply_init(",
          "32:         string memory name,",
          "33:         string memory symbol,",
          "34:         address[] memory defaultOperators,",
          "35:         uint256 initialSupply,",
          "36:         address owner",
          "37:     ) internal onlyInitializing {",
          "38:         __ERC777_init_unchained(name, symbol, defaultOperators);",
          "39:         __ERC777PresetFixedSupply_init_unchained(name, symbol, defaultOperators, initialSupply, owner);",
          "40:     }",
          "42:     function __ERC777PresetFixedSupply_init_unchained(",
          "43:         string memory,",
          "44:         string memory,",
          "45:         address[] memory,",
          "46:         uint256 initialSupply,",
          "47:         address owner",
          "48:     ) internal onlyInitializing {",
          "49:         _mint(owner, initialSupply, \"\", \"\");",
          "50:     }",
          "57:     uint256[50] private __gap;",
          "58: }",
          "",
          "---------------"
        ],
        "contracts/token/common/ERC2981Upgradeable.sol||contracts/token/common/ERC2981Upgradeable.sol": [
          "File: contracts/token/common/ERC2981Upgradeable.sol -> contracts/token/common/ERC2981Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../../interfaces/IERC2981Upgradeable.sol\";",
          "7: import \"../../utils/introspection/ERC165Upgradeable.sol\";",
          "8: import \"../../proxy/utils/Initializable.sol\";",
          "25: abstract contract ERC2981Upgradeable is Initializable, IERC2981Upgradeable, ERC165Upgradeable {",
          "26:     function __ERC2981_init() internal onlyInitializing {",
          "27:     }",
          "29:     function __ERC2981_init_unchained() internal onlyInitializing {",
          "30:     }",
          "31:     struct RoyaltyInfo {",
          "32:         address receiver;",
          "33:         uint96 royaltyFraction;",
          "34:     }",
          "36:     RoyaltyInfo private _defaultRoyaltyInfo;",
          "37:     mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;",
          "42:     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC165Upgradeable) returns (bool) {",
          "43:         return interfaceId == type(IERC2981Upgradeable).interfaceId || super.supportsInterface(interfaceId);",
          "44:     }",
          "49:     function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual override returns (address, uint256) {",
          "50:         RoyaltyInfo memory royalty = _tokenRoyaltyInfo[tokenId];",
          "52:         if (royalty.receiver == address(0)) {",
          "53:             royalty = _defaultRoyaltyInfo;",
          "54:         }",
          "56:         uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();",
          "58:         return (royalty.receiver, royaltyAmount);",
          "59:     }",
          "66:     function _feeDenominator() internal pure virtual returns (uint96) {",
          "67:         return 10000;",
          "68:     }",
          "78:     function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {",
          "79:         require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");",
          "80:         require(receiver != address(0), \"ERC2981: invalid receiver\");",
          "82:         _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);",
          "83:     }",
          "88:     function _deleteDefaultRoyalty() internal virtual {",
          "89:         delete _defaultRoyaltyInfo;",
          "90:     }",
          "100:     function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {",
          "101:         require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");",
          "102:         require(receiver != address(0), \"ERC2981: Invalid parameters\");",
          "104:         _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);",
          "105:     }",
          "110:     function _resetTokenRoyalty(uint256 tokenId) internal virtual {",
          "111:         delete _tokenRoyaltyInfo[tokenId];",
          "112:     }",
          "119:     uint256[48] private __gap;",
          "120: }",
          "",
          "---------------"
        ],
        "contracts/utils/AddressUpgradeable.sol||contracts/utils/AddressUpgradeable.sol": [
          "File: contracts/utils/AddressUpgradeable.sol -> contracts/utils/AddressUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.1;",
          "9: library AddressUpgradeable {",
          "40:     function isContract(address account) internal view returns (bool) {",
          "45:         return account.code.length > 0;",
          "46:     }",
          "64:     function sendValue(address payable recipient, uint256 amount) internal {",
          "65:         require(address(this).balance >= amount, \"Address: insufficient balance\");",
          "67:         (bool success, ) = recipient.call{value: amount}(\"\");",
          "68:         require(success, \"Address: unable to send value, recipient may have reverted\");",
          "69:     }",
          "89:     function functionCall(address target, bytes memory data) internal returns (bytes memory) {",
          "90:         return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");",
          "91:     }",
          "99:     function functionCall(",
          "100:         address target,",
          "101:         bytes memory data,",
          "102:         string memory errorMessage",
          "103:     ) internal returns (bytes memory) {",
          "104:         return functionCallWithValue(target, data, 0, errorMessage);",
          "105:     }",
          "118:     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {",
          "119:         return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");",
          "120:     }",
          "128:     function functionCallWithValue(",
          "129:         address target,",
          "130:         bytes memory data,",
          "131:         uint256 value,",
          "132:         string memory errorMessage",
          "133:     ) internal returns (bytes memory) {",
          "134:         require(address(this).balance >= value, \"Address: insufficient balance for call\");",
          "135:         (bool success, bytes memory returndata) = target.call{value: value}(data);",
          "136:         return verifyCallResultFromTarget(target, success, returndata, errorMessage);",
          "137:     }",
          "145:     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {",
          "146:         return functionStaticCall(target, data, \"Address: low-level static call failed\");",
          "147:     }",
          "155:     function functionStaticCall(",
          "156:         address target,",
          "157:         bytes memory data,",
          "158:         string memory errorMessage",
          "159:     ) internal view returns (bytes memory) {",
          "160:         (bool success, bytes memory returndata) = target.staticcall(data);",
          "161:         return verifyCallResultFromTarget(target, success, returndata, errorMessage);",
          "162:     }",
          "170:     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {",
          "171:         return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");",
          "172:     }",
          "180:     function functionDelegateCall(",
          "181:         address target,",
          "182:         bytes memory data,",
          "183:         string memory errorMessage",
          "184:     ) internal returns (bytes memory) {",
          "185:         (bool success, bytes memory returndata) = target.delegatecall(data);",
          "186:         return verifyCallResultFromTarget(target, success, returndata, errorMessage);",
          "187:     }",
          "195:     function verifyCallResultFromTarget(",
          "196:         address target,",
          "197:         bool success,",
          "198:         bytes memory returndata,",
          "199:         string memory errorMessage",
          "200:     ) internal view returns (bytes memory) {",
          "201:         if (success) {",
          "202:             if (returndata.length == 0) {",
          "205:                 require(isContract(target), \"Address: call to non-contract\");",
          "206:             }",
          "207:             return returndata;",
          "208:         } else {",
          "209:             _revert(returndata, errorMessage);",
          "210:         }",
          "211:     }",
          "219:     function verifyCallResult(",
          "220:         bool success,",
          "221:         bytes memory returndata,",
          "222:         string memory errorMessage",
          "223:     ) internal pure returns (bytes memory) {",
          "224:         if (success) {",
          "225:             return returndata;",
          "226:         } else {",
          "227:             _revert(returndata, errorMessage);",
          "228:         }",
          "229:     }",
          "231:     function _revert(bytes memory returndata, string memory errorMessage) private pure {",
          "233:         if (returndata.length > 0) {",
          "236:             assembly {",
          "237:                 let returndata_size := mload(returndata)",
          "238:                 revert(add(32, returndata), returndata_size)",
          "239:             }",
          "240:         } else {",
          "241:             revert(errorMessage);",
          "242:         }",
          "243:     }",
          "244: }",
          "",
          "---------------"
        ],
        "contracts/utils/ArraysUpgradeable.sol||contracts/utils/ArraysUpgradeable.sol": [
          "File: contracts/utils/ArraysUpgradeable.sol -> contracts/utils/ArraysUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./StorageSlotUpgradeable.sol\";",
          "7: import \"./math/MathUpgradeable.sol\";",
          "12: library ArraysUpgradeable {",
          "13:     using StorageSlotUpgradeable for bytes32;",
          "24:     function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {",
          "25:         if (array.length == 0) {",
          "26:             return 0;",
          "27:         }",
          "29:         uint256 low = 0;",
          "30:         uint256 high = array.length;",
          "32:         while (low < high) {",
          "33:             uint256 mid = MathUpgradeable.average(low, high);",
          "37:             if (unsafeAccess(array, mid).value > element) {",
          "38:                 high = mid;",
          "39:             } else {",
          "40:                 low = mid + 1;",
          "41:             }",
          "42:         }",
          "45:         if (low > 0 && unsafeAccess(array, low - 1).value == element) {",
          "46:             return low - 1;",
          "47:         } else {",
          "48:             return low;",
          "49:         }",
          "50:     }",
          "57:     function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlotUpgradeable.AddressSlot storage) {",
          "58:         bytes32 slot;",
          "63:         assembly {",
          "64:             mstore(0, arr.slot)",
          "65:             slot := add(keccak256(0, 0x20), pos)",
          "66:         }",
          "67:         return slot.getAddressSlot();",
          "68:     }",
          "75:     function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlotUpgradeable.Bytes32Slot storage) {",
          "76:         bytes32 slot;",
          "81:         assembly {",
          "82:             mstore(0, arr.slot)",
          "83:             slot := add(keccak256(0, 0x20), pos)",
          "84:         }",
          "85:         return slot.getBytes32Slot();",
          "86:     }",
          "93:     function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlotUpgradeable.Uint256Slot storage) {",
          "94:         bytes32 slot;",
          "99:         assembly {",
          "100:             mstore(0, arr.slot)",
          "101:             slot := add(keccak256(0, 0x20), pos)",
          "102:         }",
          "103:         return slot.getUint256Slot();",
          "104:     }",
          "105: }",
          "",
          "---------------"
        ],
        "contracts/utils/Base64Upgradeable.sol||contracts/utils/Base64Upgradeable.sol": [
          "File: contracts/utils/Base64Upgradeable.sol -> contracts/utils/Base64Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "11: library Base64Upgradeable {",
          "15:     string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";",
          "20:     function encode(bytes memory data) internal pure returns (string memory) {",
          "25:         if (data.length == 0) return \"\";",
          "28:         string memory table = _TABLE;",
          "36:         string memory result = new string(4 * ((data.length + 2) / 3));",
          "39:         assembly {",
          "41:             let tablePtr := add(table, 1)",
          "44:             let resultPtr := add(result, 32)",
          "47:             for {",
          "48:                 let dataPtr := data",
          "49:                 let endPtr := add(data, mload(data))",
          "50:             } lt(dataPtr, endPtr) {",
          "52:             } {",
          "54:                 dataPtr := add(dataPtr, 3)",
          "55:                 let input := mload(dataPtr)",
          "65:                 mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))",
          "66:                 resultPtr := add(resultPtr, 1) // Advance",
          "68:                 mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))",
          "69:                 resultPtr := add(resultPtr, 1) // Advance",
          "71:                 mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))",
          "72:                 resultPtr := add(resultPtr, 1) // Advance",
          "74:                 mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))",
          "75:                 resultPtr := add(resultPtr, 1) // Advance",
          "76:             }",
          "80:             switch mod(mload(data), 3)",
          "81:             case 1 {",
          "82:                 mstore8(sub(resultPtr, 1), 0x3d)",
          "83:                 mstore8(sub(resultPtr, 2), 0x3d)",
          "84:             }",
          "85:             case 2 {",
          "86:                 mstore8(sub(resultPtr, 1), 0x3d)",
          "87:             }",
          "88:         }",
          "90:         return result;",
          "91:     }",
          "92: }",
          "",
          "---------------"
        ],
        "contracts/utils/CheckpointsUpgradeable.sol||contracts/utils/CheckpointsUpgradeable.sol": [
          "File: contracts/utils/CheckpointsUpgradeable.sol -> contracts/utils/CheckpointsUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: pragma solidity ^0.8.0;",
          "7: import \"./math/MathUpgradeable.sol\";",
          "8: import \"./math/SafeCastUpgradeable.sol\";",
          "19: library CheckpointsUpgradeable {",
          "20:     struct History {",
          "21:         Checkpoint[] _checkpoints;",
          "22:     }",
          "24:     struct Checkpoint {",
          "25:         uint32 _blockNumber;",
          "26:         uint224 _value;",
          "27:     }",
          "34:     function getAtBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {",
          "35:         require(blockNumber < block.number, \"Checkpoints: block not yet mined\");",
          "36:         uint32 key = SafeCastUpgradeable.toUint32(blockNumber);",
          "38:         uint256 len = self._checkpoints.length;",
          "39:         uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);",
          "40:         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
          "41:     }",
          "49:     function getAtProbablyRecentBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {",
          "50:         require(blockNumber < block.number, \"Checkpoints: block not yet mined\");",
          "51:         uint32 key = SafeCastUpgradeable.toUint32(blockNumber);",
          "53:         uint256 len = self._checkpoints.length;",
          "55:         uint256 low = 0;",
          "56:         uint256 high = len;",
          "58:         if (len > 5) {",
          "59:             uint256 mid = len - MathUpgradeable.sqrt(len);",
          "60:             if (key < _unsafeAccess(self._checkpoints, mid)._blockNumber) {",
          "61:                 high = mid;",
          "62:             } else {",
          "63:                 low = mid + 1;",
          "64:             }",
          "65:         }",
          "67:         uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
          "69:         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
          "70:     }",
          "77:     function push(History storage self, uint256 value) internal returns (uint256, uint256) {",
          "78:         return _insert(self._checkpoints, SafeCastUpgradeable.toUint32(block.number), SafeCastUpgradeable.toUint224(value));",
          "79:     }",
          "87:     function push(",
          "88:         History storage self,",
          "89:         function(uint256, uint256) view returns (uint256) op,",
          "90:         uint256 delta",
          "91:     ) internal returns (uint256, uint256) {",
          "92:         return push(self, op(latest(self), delta));",
          "93:     }",
          "98:     function latest(History storage self) internal view returns (uint224) {",
          "99:         uint256 pos = self._checkpoints.length;",
          "100:         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
          "101:     }",
          "107:     function latestCheckpoint(",
          "108:         History storage self",
          "109:     ) internal view returns (bool exists, uint32 _blockNumber, uint224 _value) {",
          "110:         uint256 pos = self._checkpoints.length;",
          "111:         if (pos == 0) {",
          "112:             return (false, 0, 0);",
          "113:         } else {",
          "114:             Checkpoint memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);",
          "115:             return (true, ckpt._blockNumber, ckpt._value);",
          "116:         }",
          "117:     }",
          "122:     function length(History storage self) internal view returns (uint256) {",
          "123:         return self._checkpoints.length;",
          "124:     }",
          "130:     function _insert(Checkpoint[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {",
          "131:         uint256 pos = self.length;",
          "133:         if (pos > 0) {",
          "135:             Checkpoint memory last = _unsafeAccess(self, pos - 1);",
          "138:             require(last._blockNumber <= key, \"Checkpoint: decreasing keys\");",
          "141:             if (last._blockNumber == key) {",
          "142:                 _unsafeAccess(self, pos - 1)._value = value;",
          "143:             } else {",
          "144:                 self.push(Checkpoint({_blockNumber: key, _value: value}));",
          "145:             }",
          "146:             return (last._value, value);",
          "147:         } else {",
          "148:             self.push(Checkpoint({_blockNumber: key, _value: value}));",
          "149:             return (0, value);",
          "150:         }",
          "151:     }",
          "159:     function _upperBinaryLookup(",
          "160:         Checkpoint[] storage self,",
          "161:         uint32 key,",
          "162:         uint256 low,",
          "163:         uint256 high",
          "164:     ) private view returns (uint256) {",
          "165:         while (low < high) {",
          "166:             uint256 mid = MathUpgradeable.average(low, high);",
          "167:             if (_unsafeAccess(self, mid)._blockNumber > key) {",
          "168:                 high = mid;",
          "169:             } else {",
          "170:                 low = mid + 1;",
          "171:             }",
          "172:         }",
          "173:         return high;",
          "174:     }",
          "182:     function _lowerBinaryLookup(",
          "183:         Checkpoint[] storage self,",
          "184:         uint32 key,",
          "185:         uint256 low,",
          "186:         uint256 high",
          "187:     ) private view returns (uint256) {",
          "188:         while (low < high) {",
          "189:             uint256 mid = MathUpgradeable.average(low, high);",
          "190:             if (_unsafeAccess(self, mid)._blockNumber < key) {",
          "191:                 low = mid + 1;",
          "192:             } else {",
          "193:                 high = mid;",
          "194:             }",
          "195:         }",
          "196:         return high;",
          "197:     }",
          "202:     function _unsafeAccess(Checkpoint[] storage self, uint256 pos) private pure returns (Checkpoint storage result) {",
          "203:         assembly {",
          "204:             mstore(0, self.slot)",
          "205:             result.slot := add(keccak256(0, 0x20), pos)",
          "206:         }",
          "207:     }",
          "209:     struct Trace224 {",
          "210:         Checkpoint224[] _checkpoints;",
          "211:     }",
          "213:     struct Checkpoint224 {",
          "214:         uint32 _key;",
          "215:         uint224 _value;",
          "216:     }",
          "223:     function push(Trace224 storage self, uint32 key, uint224 value) internal returns (uint224, uint224) {",
          "224:         return _insert(self._checkpoints, key, value);",
          "225:     }",
          "230:     function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {",
          "231:         uint256 len = self._checkpoints.length;",
          "232:         uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);",
          "233:         return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;",
          "234:     }",
          "239:     function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {",
          "240:         uint256 len = self._checkpoints.length;",
          "241:         uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);",
          "242:         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
          "243:     }",
          "250:     function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {",
          "251:         uint256 len = self._checkpoints.length;",
          "253:         uint256 low = 0;",
          "254:         uint256 high = len;",
          "256:         if (len > 5) {",
          "257:             uint256 mid = len - MathUpgradeable.sqrt(len);",
          "258:             if (key < _unsafeAccess(self._checkpoints, mid)._key) {",
          "259:                 high = mid;",
          "260:             } else {",
          "261:                 low = mid + 1;",
          "262:             }",
          "263:         }",
          "265:         uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
          "267:         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
          "268:     }",
          "273:     function latest(Trace224 storage self) internal view returns (uint224) {",
          "274:         uint256 pos = self._checkpoints.length;",
          "275:         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
          "276:     }",
          "282:     function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {",
          "283:         uint256 pos = self._checkpoints.length;",
          "284:         if (pos == 0) {",
          "285:             return (false, 0, 0);",
          "286:         } else {",
          "287:             Checkpoint224 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);",
          "288:             return (true, ckpt._key, ckpt._value);",
          "289:         }",
          "290:     }",
          "295:     function length(Trace224 storage self) internal view returns (uint256) {",
          "296:         return self._checkpoints.length;",
          "297:     }",
          "303:     function _insert(Checkpoint224[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {",
          "304:         uint256 pos = self.length;",
          "306:         if (pos > 0) {",
          "308:             Checkpoint224 memory last = _unsafeAccess(self, pos - 1);",
          "311:             require(last._key <= key, \"Checkpoint: decreasing keys\");",
          "314:             if (last._key == key) {",
          "315:                 _unsafeAccess(self, pos - 1)._value = value;",
          "316:             } else {",
          "317:                 self.push(Checkpoint224({_key: key, _value: value}));",
          "318:             }",
          "319:             return (last._value, value);",
          "320:         } else {",
          "321:             self.push(Checkpoint224({_key: key, _value: value}));",
          "322:             return (0, value);",
          "323:         }",
          "324:     }",
          "332:     function _upperBinaryLookup(",
          "333:         Checkpoint224[] storage self,",
          "334:         uint32 key,",
          "335:         uint256 low,",
          "336:         uint256 high",
          "337:     ) private view returns (uint256) {",
          "338:         while (low < high) {",
          "339:             uint256 mid = MathUpgradeable.average(low, high);",
          "340:             if (_unsafeAccess(self, mid)._key > key) {",
          "341:                 high = mid;",
          "342:             } else {",
          "343:                 low = mid + 1;",
          "344:             }",
          "345:         }",
          "346:         return high;",
          "347:     }",
          "355:     function _lowerBinaryLookup(",
          "356:         Checkpoint224[] storage self,",
          "357:         uint32 key,",
          "358:         uint256 low,",
          "359:         uint256 high",
          "360:     ) private view returns (uint256) {",
          "361:         while (low < high) {",
          "362:             uint256 mid = MathUpgradeable.average(low, high);",
          "363:             if (_unsafeAccess(self, mid)._key < key) {",
          "364:                 low = mid + 1;",
          "365:             } else {",
          "366:                 high = mid;",
          "367:             }",
          "368:         }",
          "369:         return high;",
          "370:     }",
          "375:     function _unsafeAccess(",
          "376:         Checkpoint224[] storage self,",
          "377:         uint256 pos",
          "378:     ) private pure returns (Checkpoint224 storage result) {",
          "379:         assembly {",
          "380:             mstore(0, self.slot)",
          "381:             result.slot := add(keccak256(0, 0x20), pos)",
          "382:         }",
          "383:     }",
          "385:     struct Trace160 {",
          "386:         Checkpoint160[] _checkpoints;",
          "387:     }",
          "389:     struct Checkpoint160 {",
          "390:         uint96 _key;",
          "391:         uint160 _value;",
          "392:     }",
          "399:     function push(Trace160 storage self, uint96 key, uint160 value) internal returns (uint160, uint160) {",
          "400:         return _insert(self._checkpoints, key, value);",
          "401:     }",
          "406:     function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {",
          "407:         uint256 len = self._checkpoints.length;",
          "408:         uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);",
          "409:         return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;",
          "410:     }",
          "415:     function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {",
          "416:         uint256 len = self._checkpoints.length;",
          "417:         uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);",
          "418:         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
          "419:     }",
          "426:     function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {",
          "427:         uint256 len = self._checkpoints.length;",
          "429:         uint256 low = 0;",
          "430:         uint256 high = len;",
          "432:         if (len > 5) {",
          "433:             uint256 mid = len - MathUpgradeable.sqrt(len);",
          "434:             if (key < _unsafeAccess(self._checkpoints, mid)._key) {",
          "435:                 high = mid;",
          "436:             } else {",
          "437:                 low = mid + 1;",
          "438:             }",
          "439:         }",
          "441:         uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
          "443:         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
          "444:     }",
          "449:     function latest(Trace160 storage self) internal view returns (uint160) {",
          "450:         uint256 pos = self._checkpoints.length;",
          "451:         return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
          "452:     }",
          "458:     function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {",
          "459:         uint256 pos = self._checkpoints.length;",
          "460:         if (pos == 0) {",
          "461:             return (false, 0, 0);",
          "462:         } else {",
          "463:             Checkpoint160 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);",
          "464:             return (true, ckpt._key, ckpt._value);",
          "465:         }",
          "466:     }",
          "471:     function length(Trace160 storage self) internal view returns (uint256) {",
          "472:         return self._checkpoints.length;",
          "473:     }",
          "479:     function _insert(Checkpoint160[] storage self, uint96 key, uint160 value) private returns (uint160, uint160) {",
          "480:         uint256 pos = self.length;",
          "482:         if (pos > 0) {",
          "484:             Checkpoint160 memory last = _unsafeAccess(self, pos - 1);",
          "487:             require(last._key <= key, \"Checkpoint: decreasing keys\");",
          "490:             if (last._key == key) {",
          "491:                 _unsafeAccess(self, pos - 1)._value = value;",
          "492:             } else {",
          "493:                 self.push(Checkpoint160({_key: key, _value: value}));",
          "494:             }",
          "495:             return (last._value, value);",
          "496:         } else {",
          "497:             self.push(Checkpoint160({_key: key, _value: value}));",
          "498:             return (0, value);",
          "499:         }",
          "500:     }",
          "508:     function _upperBinaryLookup(",
          "509:         Checkpoint160[] storage self,",
          "510:         uint96 key,",
          "511:         uint256 low,",
          "512:         uint256 high",
          "513:     ) private view returns (uint256) {",
          "514:         while (low < high) {",
          "515:             uint256 mid = MathUpgradeable.average(low, high);",
          "516:             if (_unsafeAccess(self, mid)._key > key) {",
          "517:                 high = mid;",
          "518:             } else {",
          "519:                 low = mid + 1;",
          "520:             }",
          "521:         }",
          "522:         return high;",
          "523:     }",
          "531:     function _lowerBinaryLookup(",
          "532:         Checkpoint160[] storage self,",
          "533:         uint96 key,",
          "534:         uint256 low,",
          "535:         uint256 high",
          "536:     ) private view returns (uint256) {",
          "537:         while (low < high) {",
          "538:             uint256 mid = MathUpgradeable.average(low, high);",
          "539:             if (_unsafeAccess(self, mid)._key < key) {",
          "540:                 low = mid + 1;",
          "541:             } else {",
          "542:                 high = mid;",
          "543:             }",
          "544:         }",
          "545:         return high;",
          "546:     }",
          "551:     function _unsafeAccess(",
          "552:         Checkpoint160[] storage self,",
          "553:         uint256 pos",
          "554:     ) private pure returns (Checkpoint160 storage result) {",
          "555:         assembly {",
          "556:             mstore(0, self.slot)",
          "557:             result.slot := add(keccak256(0, 0x20), pos)",
          "558:         }",
          "559:     }",
          "560: }",
          "",
          "---------------"
        ],
        "contracts/utils/ContextUpgradeable.sol||contracts/utils/ContextUpgradeable.sol": [
          "File: contracts/utils/ContextUpgradeable.sol -> contracts/utils/ContextUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "5: import \"../proxy/utils/Initializable.sol\";",
          "17: abstract contract ContextUpgradeable is Initializable {",
          "18:     function __Context_init() internal onlyInitializing {",
          "19:     }",
          "21:     function __Context_init_unchained() internal onlyInitializing {",
          "22:     }",
          "23:     function _msgSender() internal view virtual returns (address) {",
          "24:         return msg.sender;",
          "25:     }",
          "27:     function _msgData() internal view virtual returns (bytes calldata) {",
          "28:         return msg.data;",
          "29:     }",
          "36:     uint256[50] private __gap;",
          "37: }",
          "",
          "---------------"
        ],
        "contracts/utils/CountersUpgradeable.sol||contracts/utils/CountersUpgradeable.sol": [
          "File: contracts/utils/CountersUpgradeable.sol -> contracts/utils/CountersUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "14: library CountersUpgradeable {",
          "15:     struct Counter {",
          "19:         uint256 _value; // default: 0",
          "20:     }",
          "22:     function current(Counter storage counter) internal view returns (uint256) {",
          "23:         return counter._value;",
          "24:     }",
          "26:     function increment(Counter storage counter) internal {",
          "27:         unchecked {",
          "28:             counter._value += 1;",
          "29:         }",
          "30:     }",
          "32:     function decrement(Counter storage counter) internal {",
          "33:         uint256 value = counter._value;",
          "34:         require(value > 0, \"Counter: decrement overflow\");",
          "35:         unchecked {",
          "36:             counter._value = value - 1;",
          "37:         }",
          "38:     }",
          "40:     function reset(Counter storage counter) internal {",
          "41:         counter._value = 0;",
          "42:     }",
          "43: }",
          "",
          "---------------"
        ],
        "contracts/utils/Create2Upgradeable.sol||contracts/utils/Create2Upgradeable.sol": [
          "File: contracts/utils/Create2Upgradeable.sol -> contracts/utils/Create2Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "15: library Create2Upgradeable {",
          "30:     function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {",
          "31:         require(address(this).balance >= amount, \"Create2: insufficient balance\");",
          "32:         require(bytecode.length != 0, \"Create2: bytecode length is zero\");",
          "34:         assembly {",
          "35:             addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)",
          "36:         }",
          "37:         require(addr != address(0), \"Create2: Failed on deploy\");",
          "38:     }",
          "44:     function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {",
          "45:         return computeAddress(salt, bytecodeHash, address(this));",
          "46:     }",
          "52:     function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {",
          "54:         assembly {",
          "55:             let ptr := mload(0x40) // Get free memory pointer",
          "67:             mstore(add(ptr, 0x40), bytecodeHash)",
          "68:             mstore(add(ptr, 0x20), salt)",
          "69:             mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes",
          "70:             let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff",
          "71:             mstore8(start, 0xff)",
          "72:             addr := keccak256(start, 85)",
          "73:         }",
          "74:     }",
          "75: }",
          "",
          "---------------"
        ],
        "contracts/utils/MulticallUpgradeable.sol||contracts/utils/MulticallUpgradeable.sol": [
          "File: contracts/utils/MulticallUpgradeable.sol -> contracts/utils/MulticallUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./AddressUpgradeable.sol\";",
          "7: import \"../proxy/utils/Initializable.sol\";",
          "14: abstract contract MulticallUpgradeable is Initializable {",
          "15:     function __Multicall_init() internal onlyInitializing {",
          "16:     }",
          "18:     function __Multicall_init_unchained() internal onlyInitializing {",
          "19:     }",
          "24:     function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {",
          "25:         results = new bytes[](data.length);",
          "26:         for (uint256 i = 0; i < data.length; i++) {",
          "27:             results[i] = AddressUpgradeable.functionDelegateCall(address(this), data[i]);",
          "28:         }",
          "29:         return results;",
          "30:     }",
          "37:     uint256[50] private __gap;",
          "38: }",
          "",
          "---------------"
        ],
        "contracts/utils/ShortStringsUpgradeable.sol||contracts/utils/ShortStringsUpgradeable.sol": [
          "File: contracts/utils/ShortStringsUpgradeable.sol -> contracts/utils/ShortStringsUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.8;",
          "5: import \"./StorageSlotUpgradeable.sol\";",
          "9: type ShortString is bytes32;",
          "39: library ShortStringsUpgradeable {",
          "41:     bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;",
          "43:     error StringTooLong(string str);",
          "44:     error InvalidShortString();",
          "51:     function toShortString(string memory str) internal pure returns (ShortString) {",
          "52:         bytes memory bstr = bytes(str);",
          "53:         if (bstr.length > 31) {",
          "54:             revert StringTooLong(str);",
          "55:         }",
          "56:         return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));",
          "57:     }",
          "62:     function toString(ShortString sstr) internal pure returns (string memory) {",
          "63:         uint256 len = byteLength(sstr);",
          "65:         string memory str = new string(32);",
          "67:         assembly {",
          "68:             mstore(str, len)",
          "69:             mstore(add(str, 0x20), sstr)",
          "70:         }",
          "71:         return str;",
          "72:     }",
          "77:     function byteLength(ShortString sstr) internal pure returns (uint256) {",
          "78:         uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;",
          "79:         if (result > 31) {",
          "80:             revert InvalidShortString();",
          "81:         }",
          "82:         return result;",
          "83:     }",
          "88:     function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {",
          "89:         if (bytes(value).length < 32) {",
          "90:             return toShortString(value);",
          "91:         } else {",
          "92:             StorageSlotUpgradeable.getStringSlot(store).value = value;",
          "93:             return ShortString.wrap(_FALLBACK_SENTINEL);",
          "94:         }",
          "95:     }",
          "100:     function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {",
          "101:         if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {",
          "102:             return toString(value);",
          "103:         } else {",
          "104:             return store;",
          "105:         }",
          "106:     }",
          "114:     function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {",
          "115:         if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {",
          "116:             return byteLength(value);",
          "117:         } else {",
          "118:             return bytes(store).length;",
          "119:         }",
          "120:     }",
          "121: }",
          "",
          "---------------"
        ],
        "contracts/utils/StorageSlotUpgradeable.sol||contracts/utils/StorageSlotUpgradeable.sol": [
          "File: contracts/utils/StorageSlotUpgradeable.sol -> contracts/utils/StorageSlotUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: pragma solidity ^0.8.0;",
          "34: library StorageSlotUpgradeable {",
          "35:     struct AddressSlot {",
          "36:         address value;",
          "37:     }",
          "39:     struct BooleanSlot {",
          "40:         bool value;",
          "41:     }",
          "43:     struct Bytes32Slot {",
          "44:         bytes32 value;",
          "45:     }",
          "47:     struct Uint256Slot {",
          "48:         uint256 value;",
          "49:     }",
          "51:     struct StringSlot {",
          "52:         string value;",
          "53:     }",
          "55:     struct BytesSlot {",
          "56:         bytes value;",
          "57:     }",
          "62:     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {",
          "64:         assembly {",
          "65:             r.slot := slot",
          "66:         }",
          "67:     }",
          "72:     function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {",
          "74:         assembly {",
          "75:             r.slot := slot",
          "76:         }",
          "77:     }",
          "82:     function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {",
          "84:         assembly {",
          "85:             r.slot := slot",
          "86:         }",
          "87:     }",
          "92:     function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {",
          "94:         assembly {",
          "95:             r.slot := slot",
          "96:         }",
          "97:     }",
          "102:     function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {",
          "104:         assembly {",
          "105:             r.slot := slot",
          "106:         }",
          "107:     }",
          "112:     function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {",
          "114:         assembly {",
          "115:             r.slot := store.slot",
          "116:         }",
          "117:     }",
          "122:     function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {",
          "124:         assembly {",
          "125:             r.slot := slot",
          "126:         }",
          "127:     }",
          "132:     function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {",
          "134:         assembly {",
          "135:             r.slot := store.slot",
          "136:         }",
          "137:     }",
          "138: }",
          "",
          "---------------"
        ],
        "contracts/utils/StringsUpgradeable.sol||contracts/utils/StringsUpgradeable.sol": [
          "File: contracts/utils/StringsUpgradeable.sol -> contracts/utils/StringsUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./math/MathUpgradeable.sol\";",
          "7: import \"./math/SignedMathUpgradeable.sol\";",
          "12: library StringsUpgradeable {",
          "13:     bytes16 private constant _SYMBOLS = \"0123456789abcdef\";",
          "14:     uint8 private constant _ADDRESS_LENGTH = 20;",
          "19:     function toString(uint256 value) internal pure returns (string memory) {",
          "20:         unchecked {",
          "21:             uint256 length = MathUpgradeable.log10(value) + 1;",
          "22:             string memory buffer = new string(length);",
          "23:             uint256 ptr;",
          "25:             assembly {",
          "26:                 ptr := add(buffer, add(32, length))",
          "27:             }",
          "28:             while (true) {",
          "29:                 ptr--;",
          "31:                 assembly {",
          "32:                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))",
          "33:                 }",
          "34:                 value /= 10;",
          "35:                 if (value == 0) break;",
          "36:             }",
          "37:             return buffer;",
          "38:         }",
          "39:     }",
          "44:     function toString(int256 value) internal pure returns (string memory) {",
          "45:         return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));",
          "46:     }",
          "51:     function toHexString(uint256 value) internal pure returns (string memory) {",
          "52:         unchecked {",
          "53:             return toHexString(value, MathUpgradeable.log256(value) + 1);",
          "54:         }",
          "55:     }",
          "60:     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {",
          "61:         bytes memory buffer = new bytes(2 * length + 2);",
          "62:         buffer[0] = \"0\";",
          "63:         buffer[1] = \"x\";",
          "64:         for (uint256 i = 2 * length + 1; i > 1; --i) {",
          "65:             buffer[i] = _SYMBOLS[value & 0xf];",
          "66:             value >>= 4;",
          "67:         }",
          "68:         require(value == 0, \"Strings: hex length insufficient\");",
          "69:         return string(buffer);",
          "70:     }",
          "75:     function toHexString(address addr) internal pure returns (string memory) {",
          "76:         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);",
          "77:     }",
          "82:     function equal(string memory a, string memory b) internal pure returns (bool) {",
          "83:         return keccak256(bytes(a)) == keccak256(bytes(b));",
          "84:     }",
          "85: }",
          "",
          "---------------"
        ],
        "contracts/utils/TimersUpgradeable.sol||contracts/utils/TimersUpgradeable.sol": [
          "File: contracts/utils/TimersUpgradeable.sol -> contracts/utils/TimersUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "11: library TimersUpgradeable {",
          "12:     struct Timestamp {",
          "13:         uint64 _deadline;",
          "14:     }",
          "16:     function getDeadline(Timestamp memory timer) internal pure returns (uint64) {",
          "17:         return timer._deadline;",
          "18:     }",
          "20:     function setDeadline(Timestamp storage timer, uint64 timestamp) internal {",
          "21:         timer._deadline = timestamp;",
          "22:     }",
          "24:     function reset(Timestamp storage timer) internal {",
          "25:         timer._deadline = 0;",
          "26:     }",
          "28:     function isUnset(Timestamp memory timer) internal pure returns (bool) {",
          "29:         return timer._deadline == 0;",
          "30:     }",
          "32:     function isStarted(Timestamp memory timer) internal pure returns (bool) {",
          "33:         return timer._deadline > 0;",
          "34:     }",
          "36:     function isPending(Timestamp memory timer) internal view returns (bool) {",
          "37:         return timer._deadline > block.timestamp;",
          "38:     }",
          "40:     function isExpired(Timestamp memory timer) internal view returns (bool) {",
          "41:         return isStarted(timer) && timer._deadline <= block.timestamp;",
          "42:     }",
          "44:     struct BlockNumber {",
          "45:         uint64 _deadline;",
          "46:     }",
          "48:     function getDeadline(BlockNumber memory timer) internal pure returns (uint64) {",
          "49:         return timer._deadline;",
          "50:     }",
          "52:     function setDeadline(BlockNumber storage timer, uint64 timestamp) internal {",
          "53:         timer._deadline = timestamp;",
          "54:     }",
          "56:     function reset(BlockNumber storage timer) internal {",
          "57:         timer._deadline = 0;",
          "58:     }",
          "60:     function isUnset(BlockNumber memory timer) internal pure returns (bool) {",
          "61:         return timer._deadline == 0;",
          "62:     }",
          "64:     function isStarted(BlockNumber memory timer) internal pure returns (bool) {",
          "65:         return timer._deadline > 0;",
          "66:     }",
          "68:     function isPending(BlockNumber memory timer) internal view returns (bool) {",
          "69:         return timer._deadline > block.number;",
          "70:     }",
          "72:     function isExpired(BlockNumber memory timer) internal view returns (bool) {",
          "73:         return isStarted(timer) && timer._deadline <= block.number;",
          "74:     }",
          "75: }",
          "",
          "---------------"
        ],
        "contracts/utils/cryptography/ECDSAUpgradeable.sol||contracts/utils/cryptography/ECDSAUpgradeable.sol": [
          "File: contracts/utils/cryptography/ECDSAUpgradeable.sol -> contracts/utils/cryptography/ECDSAUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../StringsUpgradeable.sol\";",
          "14: library ECDSAUpgradeable {",
          "15:     enum RecoverError {",
          "16:         NoError,",
          "17:         InvalidSignature,",
          "18:         InvalidSignatureLength,",
          "19:         InvalidSignatureS,",
          "20:         InvalidSignatureV // Deprecated in v4.8",
          "21:     }",
          "23:     function _throwError(RecoverError error) private pure {",
          "24:         if (error == RecoverError.NoError) {",
          "25:             return; // no error: do nothing",
          "26:         } else if (error == RecoverError.InvalidSignature) {",
          "27:             revert(\"ECDSA: invalid signature\");",
          "28:         } else if (error == RecoverError.InvalidSignatureLength) {",
          "29:             revert(\"ECDSA: invalid signature length\");",
          "30:         } else if (error == RecoverError.InvalidSignatureS) {",
          "31:             revert(\"ECDSA: invalid signature 's' value\");",
          "32:         }",
          "33:     }",
          "55:     function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {",
          "56:         if (signature.length == 65) {",
          "57:             bytes32 r;",
          "58:             bytes32 s;",
          "59:             uint8 v;",
          "63:             assembly {",
          "64:                 r := mload(add(signature, 0x20))",
          "65:                 s := mload(add(signature, 0x40))",
          "66:                 v := byte(0, mload(add(signature, 0x60)))",
          "67:             }",
          "68:             return tryRecover(hash, v, r, s);",
          "69:         } else {",
          "70:             return (address(0), RecoverError.InvalidSignatureLength);",
          "71:         }",
          "72:     }",
          "88:     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {",
          "89:         (address recovered, RecoverError error) = tryRecover(hash, signature);",
          "90:         _throwError(error);",
          "91:         return recovered;",
          "92:     }",
          "101:     function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {",
          "102:         bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);",
          "103:         uint8 v = uint8((uint256(vs) >> 255) + 27);",
          "104:         return tryRecover(hash, v, r, s);",
          "105:     }",
          "112:     function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {",
          "113:         (address recovered, RecoverError error) = tryRecover(hash, r, vs);",
          "114:         _throwError(error);",
          "115:         return recovered;",
          "116:     }",
          "124:     function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {",
          "134:         if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {",
          "135:             return (address(0), RecoverError.InvalidSignatureS);",
          "136:         }",
          "139:         address signer = ecrecover(hash, v, r, s);",
          "140:         if (signer == address(0)) {",
          "141:             return (address(0), RecoverError.InvalidSignature);",
          "142:         }",
          "144:         return (signer, RecoverError.NoError);",
          "145:     }",
          "151:     function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {",
          "152:         (address recovered, RecoverError error) = tryRecover(hash, v, r, s);",
          "153:         _throwError(error);",
          "154:         return recovered;",
          "155:     }",
          "165:     function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {",
          "169:         assembly {",
          "170:             mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")",
          "171:             mstore(0x1c, hash)",
          "172:             message := keccak256(0x00, 0x3c)",
          "173:         }",
          "174:     }",
          "184:     function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {",
          "185:         return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));",
          "186:     }",
          "197:     function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {",
          "199:         assembly {",
          "200:             let ptr := mload(0x40)",
          "201:             mstore(ptr, \"\\x19\\x01\")",
          "202:             mstore(add(ptr, 0x02), domainSeparator)",
          "203:             mstore(add(ptr, 0x22), structHash)",
          "204:             data := keccak256(ptr, 0x42)",
          "205:         }",
          "206:     }",
          "214:     function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {",
          "215:         return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));",
          "216:     }",
          "217: }",
          "",
          "---------------"
        ],
        "contracts/utils/cryptography/EIP712Upgradeable.sol||contracts/utils/cryptography/EIP712Upgradeable.sol": [
          "File: contracts/utils/cryptography/EIP712Upgradeable.sol -> contracts/utils/cryptography/EIP712Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.8;",
          "6: import \"./ECDSAUpgradeable.sol\";",
          "7: import \"../../interfaces/IERC5267Upgradeable.sol\";",
          "8: import \"../../proxy/utils/Initializable.sol\";",
          "35: abstract contract EIP712Upgradeable is Initializable, IERC5267Upgradeable {",
          "36:     bytes32 private constant _TYPE_HASH =",
          "37:         keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");",
          "40:     bytes32 private _hashedName;",
          "42:     bytes32 private _hashedVersion;",
          "44:     string private _name;",
          "45:     string private _version;",
          "59:     function __EIP712_init(string memory name, string memory version) internal onlyInitializing {",
          "60:         __EIP712_init_unchained(name, version);",
          "61:     }",
          "63:     function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {",
          "64:         _name = name;",
          "65:         _version = version;",
          "68:         _hashedName = 0;",
          "69:         _hashedVersion = 0;",
          "70:     }",
          "75:     function _domainSeparatorV4() internal view returns (bytes32) {",
          "76:         return _buildDomainSeparator();",
          "77:     }",
          "79:     function _buildDomainSeparator() private view returns (bytes32) {",
          "80:         return keccak256(abi.encode(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));",
          "81:     }",
          "98:     function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {",
          "99:         return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);",
          "100:     }",
          "107:     function eip712Domain()",
          "108:         public",
          "109:         view",
          "110:         virtual",
          "111:         override",
          "112:         returns (",
          "113:             bytes1 fields,",
          "114:             string memory name,",
          "115:             string memory version,",
          "116:             uint256 chainId,",
          "117:             address verifyingContract,",
          "118:             bytes32 salt,",
          "119:             uint256[] memory extensions",
          "120:         )",
          "121:     {",
          "124:         require(_hashedName == 0 && _hashedVersion == 0, \"EIP712: Uninitialized\");",
          "126:         return (",
          "127:             hex\"0f\", // 01111",
          "128:             _EIP712Name(),",
          "129:             _EIP712Version(),",
          "130:             block.chainid,",
          "131:             address(this),",
          "132:             bytes32(0),",
          "133:             new uint256[](0)",
          "134:         );",
          "135:     }",
          "143:     function _EIP712Name() internal virtual view returns (string memory) {",
          "144:         return _name;",
          "145:     }",
          "153:     function _EIP712Version() internal virtual view returns (string memory) {",
          "154:         return _version;",
          "155:     }",
          "162:     function _EIP712NameHash() internal view returns (bytes32) {",
          "163:         string memory name = _EIP712Name();",
          "164:         if (bytes(name).length > 0) {",
          "165:             return keccak256(bytes(name));",
          "166:         } else {",
          "169:             bytes32 hashedName = _hashedName;",
          "170:             if (hashedName != 0) {",
          "171:                 return hashedName;",
          "172:             } else {",
          "173:                 return keccak256(\"\");",
          "174:             }",
          "175:         }",
          "176:     }",
          "183:     function _EIP712VersionHash() internal view returns (bytes32) {",
          "184:         string memory version = _EIP712Version();",
          "185:         if (bytes(version).length > 0) {",
          "186:             return keccak256(bytes(version));",
          "187:         } else {",
          "190:             bytes32 hashedVersion = _hashedVersion;",
          "191:             if (hashedVersion != 0) {",
          "192:                 return hashedVersion;",
          "193:             } else {",
          "194:                 return keccak256(\"\");",
          "195:             }",
          "196:         }",
          "197:     }",
          "204:     uint256[48] private __gap;",
          "205: }",
          "",
          "---------------"
        ],
        "contracts/utils/cryptography/MerkleProofUpgradeable.sol||contracts/utils/cryptography/MerkleProofUpgradeable.sol": [
          "File: contracts/utils/cryptography/MerkleProofUpgradeable.sol -> contracts/utils/cryptography/MerkleProofUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "20: library MerkleProofUpgradeable {",
          "27:     function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {",
          "28:         return processProof(proof, leaf) == root;",
          "29:     }",
          "36:     function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {",
          "37:         return processProofCalldata(proof, leaf) == root;",
          "38:     }",
          "48:     function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {",
          "49:         bytes32 computedHash = leaf;",
          "50:         for (uint256 i = 0; i < proof.length; i++) {",
          "51:             computedHash = _hashPair(computedHash, proof[i]);",
          "52:         }",
          "53:         return computedHash;",
          "54:     }",
          "61:     function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {",
          "62:         bytes32 computedHash = leaf;",
          "63:         for (uint256 i = 0; i < proof.length; i++) {",
          "64:             computedHash = _hashPair(computedHash, proof[i]);",
          "65:         }",
          "66:         return computedHash;",
          "67:     }",
          "77:     function multiProofVerify(",
          "78:         bytes32[] memory proof,",
          "79:         bool[] memory proofFlags,",
          "80:         bytes32 root,",
          "81:         bytes32[] memory leaves",
          "82:     ) internal pure returns (bool) {",
          "83:         return processMultiProof(proof, proofFlags, leaves) == root;",
          "84:     }",
          "93:     function multiProofVerifyCalldata(",
          "94:         bytes32[] calldata proof,",
          "95:         bool[] calldata proofFlags,",
          "96:         bytes32 root,",
          "97:         bytes32[] memory leaves",
          "98:     ) internal pure returns (bool) {",
          "99:         return processMultiProofCalldata(proof, proofFlags, leaves) == root;",
          "100:     }",
          "114:     function processMultiProof(",
          "115:         bytes32[] memory proof,",
          "116:         bool[] memory proofFlags,",
          "117:         bytes32[] memory leaves",
          "118:     ) internal pure returns (bytes32 merkleRoot) {",
          "123:         uint256 leavesLen = leaves.length;",
          "124:         uint256 totalHashes = proofFlags.length;",
          "127:         require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");",
          "131:         bytes32[] memory hashes = new bytes32[](totalHashes);",
          "132:         uint256 leafPos = 0;",
          "133:         uint256 hashPos = 0;",
          "134:         uint256 proofPos = 0;",
          "140:         for (uint256 i = 0; i < totalHashes; i++) {",
          "141:             bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];",
          "142:             bytes32 b = proofFlags[i]",
          "143:                 ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])",
          "144:                 : proof[proofPos++];",
          "145:             hashes[i] = _hashPair(a, b);",
          "146:         }",
          "148:         if (totalHashes > 0) {",
          "149:             unchecked {",
          "150:                 return hashes[totalHashes - 1];",
          "151:             }",
          "152:         } else if (leavesLen > 0) {",
          "153:             return leaves[0];",
          "154:         } else {",
          "155:             return proof[0];",
          "156:         }",
          "157:     }",
          "166:     function processMultiProofCalldata(",
          "167:         bytes32[] calldata proof,",
          "168:         bool[] calldata proofFlags,",
          "169:         bytes32[] memory leaves",
          "170:     ) internal pure returns (bytes32 merkleRoot) {",
          "175:         uint256 leavesLen = leaves.length;",
          "176:         uint256 totalHashes = proofFlags.length;",
          "179:         require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");",
          "183:         bytes32[] memory hashes = new bytes32[](totalHashes);",
          "184:         uint256 leafPos = 0;",
          "185:         uint256 hashPos = 0;",
          "186:         uint256 proofPos = 0;",
          "192:         for (uint256 i = 0; i < totalHashes; i++) {",
          "193:             bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];",
          "194:             bytes32 b = proofFlags[i]",
          "195:                 ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])",
          "196:                 : proof[proofPos++];",
          "197:             hashes[i] = _hashPair(a, b);",
          "198:         }",
          "200:         if (totalHashes > 0) {",
          "201:             unchecked {",
          "202:                 return hashes[totalHashes - 1];",
          "203:             }",
          "204:         } else if (leavesLen > 0) {",
          "205:             return leaves[0];",
          "206:         } else {",
          "207:             return proof[0];",
          "208:         }",
          "209:     }",
          "211:     function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {",
          "212:         return a < b ? _efficientHash(a, b) : _efficientHash(b, a);",
          "213:     }",
          "215:     function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {",
          "217:         assembly {",
          "218:             mstore(0x00, a)",
          "219:             mstore(0x20, b)",
          "220:             value := keccak256(0x00, 0x40)",
          "221:         }",
          "222:     }",
          "223: }",
          "",
          "---------------"
        ],
        "contracts/utils/cryptography/SignatureCheckerUpgradeable.sol||contracts/utils/cryptography/SignatureCheckerUpgradeable.sol": [
          "File: contracts/utils/cryptography/SignatureCheckerUpgradeable.sol -> contracts/utils/cryptography/SignatureCheckerUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./ECDSAUpgradeable.sol\";",
          "7: import \"../../interfaces/IERC1271Upgradeable.sol\";",
          "16: library SignatureCheckerUpgradeable {",
          "24:     function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {",
          "25:         (address recovered, ECDSAUpgradeable.RecoverError error) = ECDSAUpgradeable.tryRecover(hash, signature);",
          "26:         return",
          "27:             (error == ECDSAUpgradeable.RecoverError.NoError && recovered == signer) ||",
          "28:             isValidERC1271SignatureNow(signer, hash, signature);",
          "29:     }",
          "38:     function isValidERC1271SignatureNow(",
          "39:         address signer,",
          "40:         bytes32 hash,",
          "41:         bytes memory signature",
          "42:     ) internal view returns (bool) {",
          "43:         (bool success, bytes memory result) = signer.staticcall(",
          "44:             abi.encodeWithSelector(IERC1271Upgradeable.isValidSignature.selector, hash, signature)",
          "45:         );",
          "46:         return (success &&",
          "47:             result.length >= 32 &&",
          "48:             abi.decode(result, (bytes32)) == bytes32(IERC1271Upgradeable.isValidSignature.selector));",
          "49:     }",
          "50: }",
          "",
          "---------------"
        ],
        "contracts/utils/cryptography/draft-EIP712Upgradeable.sol||contracts/utils/cryptography/draft-EIP712Upgradeable.sol": [
          "File: contracts/utils/cryptography/draft-EIP712Upgradeable.sol -> contracts/utils/cryptography/draft-EIP712Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "8: import \"./EIP712Upgradeable.sol\";",
          "",
          "---------------"
        ],
        "contracts/utils/escrow/ConditionalEscrowUpgradeable.sol||contracts/utils/escrow/ConditionalEscrowUpgradeable.sol": [
          "File: contracts/utils/escrow/ConditionalEscrowUpgradeable.sol -> contracts/utils/escrow/ConditionalEscrowUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./EscrowUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "14: abstract contract ConditionalEscrowUpgradeable is Initializable, EscrowUpgradeable {",
          "15:     function __ConditionalEscrow_init() internal onlyInitializing {",
          "16:         __Ownable_init_unchained();",
          "17:     }",
          "19:     function __ConditionalEscrow_init_unchained() internal onlyInitializing {",
          "20:     }",
          "26:     function withdrawalAllowed(address payee) public view virtual returns (bool);",
          "28:     function withdraw(address payable payee) public virtual override {",
          "29:         require(withdrawalAllowed(payee), \"ConditionalEscrow: payee is not allowed to withdraw\");",
          "30:         super.withdraw(payee);",
          "31:     }",
          "38:     uint256[50] private __gap;",
          "39: }",
          "",
          "---------------"
        ],
        "contracts/utils/escrow/EscrowUpgradeable.sol||contracts/utils/escrow/EscrowUpgradeable.sol": [
          "File: contracts/utils/escrow/EscrowUpgradeable.sol -> contracts/utils/escrow/EscrowUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"../../access/OwnableUpgradeable.sol\";",
          "7: import \"../AddressUpgradeable.sol\";",
          "8: import \"../../proxy/utils/Initializable.sol\";",
          "23: contract EscrowUpgradeable is Initializable, OwnableUpgradeable {",
          "24:     function __Escrow_init() internal onlyInitializing {",
          "25:         __Ownable_init_unchained();",
          "26:     }",
          "28:     function __Escrow_init_unchained() internal onlyInitializing {",
          "29:     }",
          "30:     function initialize() public virtual initializer {",
          "31:         __Escrow_init();",
          "32:     }",
          "33:     using AddressUpgradeable for address payable;",
          "35:     event Deposited(address indexed payee, uint256 weiAmount);",
          "36:     event Withdrawn(address indexed payee, uint256 weiAmount);",
          "38:     mapping(address => uint256) private _deposits;",
          "40:     function depositsOf(address payee) public view returns (uint256) {",
          "41:         return _deposits[payee];",
          "42:     }",
          "50:     function deposit(address payee) public payable virtual onlyOwner {",
          "51:         uint256 amount = msg.value;",
          "52:         _deposits[payee] += amount;",
          "53:         emit Deposited(payee, amount);",
          "54:     }",
          "68:     function withdraw(address payable payee) public virtual onlyOwner {",
          "69:         uint256 payment = _deposits[payee];",
          "71:         _deposits[payee] = 0;",
          "73:         payee.sendValue(payment);",
          "75:         emit Withdrawn(payee, payment);",
          "76:     }",
          "83:     uint256[49] private __gap;",
          "84: }",
          "",
          "---------------"
        ],
        "contracts/utils/escrow/RefundEscrowUpgradeable.sol||contracts/utils/escrow/RefundEscrowUpgradeable.sol": [
          "File: contracts/utils/escrow/RefundEscrowUpgradeable.sol -> contracts/utils/escrow/RefundEscrowUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./ConditionalEscrowUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "19: contract RefundEscrowUpgradeable is Initializable, ConditionalEscrowUpgradeable {",
          "20:     using AddressUpgradeable for address payable;",
          "22:     enum State {",
          "23:         Active,",
          "24:         Refunding,",
          "25:         Closed",
          "26:     }",
          "28:     event RefundsClosed();",
          "29:     event RefundsEnabled();",
          "31:     State private _state;",
          "32:     address payable private _beneficiary;",
          "38:     function __RefundEscrow_init(address payable beneficiary_) internal onlyInitializing {",
          "39:         __Ownable_init_unchained();",
          "40:         __RefundEscrow_init_unchained(beneficiary_);",
          "41:     }",
          "43:     function __RefundEscrow_init_unchained(address payable beneficiary_) internal onlyInitializing {",
          "44:         require(beneficiary_ != address(0), \"RefundEscrow: beneficiary is the zero address\");",
          "45:         _beneficiary = beneficiary_;",
          "46:         _state = State.Active;",
          "47:     }",
          "52:     function state() public view virtual returns (State) {",
          "53:         return _state;",
          "54:     }",
          "59:     function beneficiary() public view virtual returns (address payable) {",
          "60:         return _beneficiary;",
          "61:     }",
          "67:     function deposit(address refundee) public payable virtual override {",
          "68:         require(state() == State.Active, \"RefundEscrow: can only deposit while active\");",
          "69:         super.deposit(refundee);",
          "70:     }",
          "76:     function close() public virtual onlyOwner {",
          "77:         require(state() == State.Active, \"RefundEscrow: can only close while active\");",
          "78:         _state = State.Closed;",
          "79:         emit RefundsClosed();",
          "80:     }",
          "85:     function enableRefunds() public virtual onlyOwner {",
          "86:         require(state() == State.Active, \"RefundEscrow: can only enable refunds while active\");",
          "87:         _state = State.Refunding;",
          "88:         emit RefundsEnabled();",
          "89:     }",
          "94:     function beneficiaryWithdraw() public virtual {",
          "95:         require(state() == State.Closed, \"RefundEscrow: beneficiary can only withdraw while closed\");",
          "96:         beneficiary().sendValue(address(this).balance);",
          "97:     }",
          "103:     function withdrawalAllowed(address) public view override returns (bool) {",
          "104:         return state() == State.Refunding;",
          "105:     }",
          "112:     uint256[49] private __gap;",
          "113: }",
          "",
          "---------------"
        ],
        "contracts/utils/introspection/ERC165CheckerUpgradeable.sol||contracts/utils/introspection/ERC165CheckerUpgradeable.sol": [
          "File: contracts/utils/introspection/ERC165CheckerUpgradeable.sol -> contracts/utils/introspection/ERC165CheckerUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IERC165Upgradeable.sol\";",
          "15: library ERC165CheckerUpgradeable {",
          "17:     bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;",
          "22:     function supportsERC165(address account) internal view returns (bool) {",
          "25:         return",
          "26:             supportsERC165InterfaceUnchecked(account, type(IERC165Upgradeable).interfaceId) &&",
          "27:             !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);",
          "28:     }",
          "36:     function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {",
          "38:         return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);",
          "39:     }",
          "51:     function getSupportedInterfaces(",
          "52:         address account,",
          "53:         bytes4[] memory interfaceIds",
          "54:     ) internal view returns (bool[] memory) {",
          "56:         bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);",
          "59:         if (supportsERC165(account)) {",
          "61:             for (uint256 i = 0; i < interfaceIds.length; i++) {",
          "62:                 interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);",
          "63:             }",
          "64:         }",
          "66:         return interfaceIdsSupported;",
          "67:     }",
          "78:     function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {",
          "80:         if (!supportsERC165(account)) {",
          "81:             return false;",
          "82:         }",
          "85:         for (uint256 i = 0; i < interfaceIds.length; i++) {",
          "86:             if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {",
          "87:                 return false;",
          "88:             }",
          "89:         }",
          "92:         return true;",
          "93:     }",
          "110:     function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {",
          "112:         bytes memory encodedParams = abi.encodeWithSelector(IERC165Upgradeable.supportsInterface.selector, interfaceId);",
          "115:         bool success;",
          "116:         uint256 returnSize;",
          "117:         uint256 returnValue;",
          "118:         assembly {",
          "119:             success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)",
          "120:             returnSize := returndatasize()",
          "121:             returnValue := mload(0x00)",
          "122:         }",
          "124:         return success && returnSize >= 0x20 && returnValue > 0;",
          "125:     }",
          "126: }",
          "",
          "---------------"
        ],
        "contracts/utils/introspection/ERC165StorageUpgradeable.sol||contracts/utils/introspection/ERC165StorageUpgradeable.sol": [
          "File: contracts/utils/introspection/ERC165StorageUpgradeable.sol -> contracts/utils/introspection/ERC165StorageUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./ERC165Upgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "15: abstract contract ERC165StorageUpgradeable is Initializable, ERC165Upgradeable {",
          "16:     function __ERC165Storage_init() internal onlyInitializing {",
          "17:     }",
          "19:     function __ERC165Storage_init_unchained() internal onlyInitializing {",
          "20:     }",
          "24:     mapping(bytes4 => bool) private _supportedInterfaces;",
          "29:     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {",
          "30:         return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];",
          "31:     }",
          "44:     function _registerInterface(bytes4 interfaceId) internal virtual {",
          "45:         require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");",
          "46:         _supportedInterfaces[interfaceId] = true;",
          "47:     }",
          "54:     uint256[49] private __gap;",
          "55: }",
          "",
          "---------------"
        ],
        "contracts/utils/introspection/ERC165Upgradeable.sol||contracts/utils/introspection/ERC165Upgradeable.sol": [
          "File: contracts/utils/introspection/ERC165Upgradeable.sol -> contracts/utils/introspection/ERC165Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IERC165Upgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "23: abstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {",
          "24:     function __ERC165_init() internal onlyInitializing {",
          "25:     }",
          "27:     function __ERC165_init_unchained() internal onlyInitializing {",
          "28:     }",
          "32:     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {",
          "33:         return interfaceId == type(IERC165Upgradeable).interfaceId;",
          "34:     }",
          "41:     uint256[50] private __gap;",
          "42: }",
          "",
          "---------------"
        ],
        "contracts/utils/introspection/ERC1820ImplementerUpgradeable.sol||contracts/utils/introspection/ERC1820ImplementerUpgradeable.sol": [
          "File: contracts/utils/introspection/ERC1820ImplementerUpgradeable.sol -> contracts/utils/introspection/ERC1820ImplementerUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"./IERC1820ImplementerUpgradeable.sol\";",
          "7: import \"../../proxy/utils/Initializable.sol\";",
          "19: contract ERC1820ImplementerUpgradeable is Initializable, IERC1820ImplementerUpgradeable {",
          "20:     function __ERC1820Implementer_init() internal onlyInitializing {",
          "21:     }",
          "23:     function __ERC1820Implementer_init_unchained() internal onlyInitializing {",
          "24:     }",
          "25:     bytes32 private constant _ERC1820_ACCEPT_MAGIC = keccak256(\"ERC1820_ACCEPT_MAGIC\");",
          "27:     mapping(bytes32 => mapping(address => bool)) private _supportedInterfaces;",
          "32:     function canImplementInterfaceForAddress(",
          "33:         bytes32 interfaceHash,",
          "34:         address account",
          "35:     ) public view virtual override returns (bytes32) {",
          "36:         return _supportedInterfaces[interfaceHash][account] ? _ERC1820_ACCEPT_MAGIC : bytes32(0x00);",
          "37:     }",
          "46:     function _registerInterfaceForAddress(bytes32 interfaceHash, address account) internal virtual {",
          "47:         _supportedInterfaces[interfaceHash][account] = true;",
          "48:     }",
          "55:     uint256[49] private __gap;",
          "56: }",
          "",
          "---------------"
        ],
        "contracts/utils/introspection/IERC165Upgradeable.sol||contracts/utils/introspection/IERC165Upgradeable.sol": [
          "File: contracts/utils/introspection/IERC165Upgradeable.sol -> contracts/utils/introspection/IERC165Upgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "15: interface IERC165Upgradeable {",
          "24:     function supportsInterface(bytes4 interfaceId) external view returns (bool);",
          "25: }",
          "",
          "---------------"
        ],
        "contracts/utils/introspection/IERC1820ImplementerUpgradeable.sol||contracts/utils/introspection/IERC1820ImplementerUpgradeable.sol": [
          "File: contracts/utils/introspection/IERC1820ImplementerUpgradeable.sol -> contracts/utils/introspection/IERC1820ImplementerUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "12: interface IERC1820ImplementerUpgradeable {",
          "19:     function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32);",
          "20: }",
          "",
          "---------------"
        ],
        "contracts/utils/introspection/IERC1820RegistryUpgradeable.sol||contracts/utils/introspection/IERC1820RegistryUpgradeable.sol": [
          "File: contracts/utils/introspection/IERC1820RegistryUpgradeable.sol -> contracts/utils/introspection/IERC1820RegistryUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "20: interface IERC1820RegistryUpgradeable {",
          "21:     event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);",
          "23:     event ManagerChanged(address indexed account, address indexed newManager);",
          "38:     function setManager(address account, address newManager) external;",
          "45:     function getManager(address account) external view returns (address);",
          "67:     function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;",
          "78:     function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);",
          "85:     function interfaceHash(string calldata interfaceName) external pure returns (bytes32);",
          "92:     function updateERC165Cache(address account, bytes4 interfaceId) external;",
          "103:     function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);",
          "111:     function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);",
          "112: }",
          "",
          "---------------"
        ],
        "contracts/utils/math/MathUpgradeable.sol||contracts/utils/math/MathUpgradeable.sol": [
          "File: contracts/utils/math/MathUpgradeable.sol -> contracts/utils/math/MathUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "9: library MathUpgradeable {",
          "10:     enum Rounding {",
          "11:         Down, // Toward negative infinity",
          "12:         Up, // Toward infinity",
          "13:         Zero // Toward zero",
          "14:     }",
          "19:     function max(uint256 a, uint256 b) internal pure returns (uint256) {",
          "20:         return a > b ? a : b;",
          "21:     }",
          "26:     function min(uint256 a, uint256 b) internal pure returns (uint256) {",
          "27:         return a < b ? a : b;",
          "28:     }",
          "34:     function average(uint256 a, uint256 b) internal pure returns (uint256) {",
          "36:         return (a & b) + (a ^ b) / 2;",
          "37:     }",
          "45:     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {",
          "47:         return a == 0 ? 0 : (a - 1) / b + 1;",
          "48:     }",
          "55:     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {",
          "56:         unchecked {",
          "60:             uint256 prod0; // Least significant 256 bits of the product",
          "61:             uint256 prod1; // Most significant 256 bits of the product",
          "62:             assembly {",
          "63:                 let mm := mulmod(x, y, not(0))",
          "64:                 prod0 := mul(x, y)",
          "65:                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))",
          "66:             }",
          "69:             if (prod1 == 0) {",
          "73:                 return prod0 / denominator;",
          "74:             }",
          "77:             require(denominator > prod1, \"Math: mulDiv overflow\");",
          "84:             uint256 remainder;",
          "85:             assembly {",
          "87:                 remainder := mulmod(x, y, denominator)",
          "90:                 prod1 := sub(prod1, gt(remainder, prod0))",
          "91:                 prod0 := sub(prod0, remainder)",
          "92:             }",
          "98:             uint256 twos = denominator & (~denominator + 1);",
          "99:             assembly {",
          "101:                 denominator := div(denominator, twos)",
          "104:                 prod0 := div(prod0, twos)",
          "107:                 twos := add(div(sub(0, twos), twos), 1)",
          "108:             }",
          "111:             prod0 |= prod1 * twos;",
          "116:             uint256 inverse = (3 * denominator) ^ 2;",
          "120:             inverse *= 2 - denominator * inverse; // inverse mod 2^8",
          "121:             inverse *= 2 - denominator * inverse; // inverse mod 2^16",
          "122:             inverse *= 2 - denominator * inverse; // inverse mod 2^32",
          "123:             inverse *= 2 - denominator * inverse; // inverse mod 2^64",
          "124:             inverse *= 2 - denominator * inverse; // inverse mod 2^128",
          "125:             inverse *= 2 - denominator * inverse; // inverse mod 2^256",
          "131:             result = prod0 * inverse;",
          "132:             return result;",
          "133:         }",
          "134:     }",
          "139:     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {",
          "140:         uint256 result = mulDiv(x, y, denominator);",
          "141:         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {",
          "142:             result += 1;",
          "143:         }",
          "144:         return result;",
          "145:     }",
          "152:     function sqrt(uint256 a) internal pure returns (uint256) {",
          "153:         if (a == 0) {",
          "154:             return 0;",
          "155:         }",
          "167:         uint256 result = 1 << (log2(a) >> 1);",
          "173:         unchecked {",
          "174:             result = (result + a / result) >> 1;",
          "175:             result = (result + a / result) >> 1;",
          "176:             result = (result + a / result) >> 1;",
          "177:             result = (result + a / result) >> 1;",
          "178:             result = (result + a / result) >> 1;",
          "179:             result = (result + a / result) >> 1;",
          "180:             result = (result + a / result) >> 1;",
          "181:             return min(result, a / result);",
          "182:         }",
          "183:     }",
          "188:     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {",
          "189:         unchecked {",
          "190:             uint256 result = sqrt(a);",
          "191:             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);",
          "192:         }",
          "193:     }",
          "199:     function log2(uint256 value) internal pure returns (uint256) {",
          "200:         uint256 result = 0;",
          "201:         unchecked {",
          "202:             if (value >> 128 > 0) {",
          "203:                 value >>= 128;",
          "204:                 result += 128;",
          "205:             }",
          "206:             if (value >> 64 > 0) {",
          "207:                 value >>= 64;",
          "208:                 result += 64;",
          "209:             }",
          "210:             if (value >> 32 > 0) {",
          "211:                 value >>= 32;",
          "212:                 result += 32;",
          "213:             }",
          "214:             if (value >> 16 > 0) {",
          "215:                 value >>= 16;",
          "216:                 result += 16;",
          "217:             }",
          "218:             if (value >> 8 > 0) {",
          "219:                 value >>= 8;",
          "220:                 result += 8;",
          "221:             }",
          "222:             if (value >> 4 > 0) {",
          "223:                 value >>= 4;",
          "224:                 result += 4;",
          "225:             }",
          "226:             if (value >> 2 > 0) {",
          "227:                 value >>= 2;",
          "228:                 result += 2;",
          "229:             }",
          "230:             if (value >> 1 > 0) {",
          "231:                 result += 1;",
          "232:             }",
          "233:         }",
          "234:         return result;",
          "235:     }",
          "241:     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {",
          "242:         unchecked {",
          "243:             uint256 result = log2(value);",
          "244:             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);",
          "245:         }",
          "246:     }",
          "252:     function log10(uint256 value) internal pure returns (uint256) {",
          "253:         uint256 result = 0;",
          "254:         unchecked {",
          "255:             if (value >= 10 ** 64) {",
          "256:                 value /= 10 ** 64;",
          "257:                 result += 64;",
          "258:             }",
          "259:             if (value >= 10 ** 32) {",
          "260:                 value /= 10 ** 32;",
          "261:                 result += 32;",
          "262:             }",
          "263:             if (value >= 10 ** 16) {",
          "264:                 value /= 10 ** 16;",
          "265:                 result += 16;",
          "266:             }",
          "267:             if (value >= 10 ** 8) {",
          "268:                 value /= 10 ** 8;",
          "269:                 result += 8;",
          "270:             }",
          "271:             if (value >= 10 ** 4) {",
          "272:                 value /= 10 ** 4;",
          "273:                 result += 4;",
          "274:             }",
          "275:             if (value >= 10 ** 2) {",
          "276:                 value /= 10 ** 2;",
          "277:                 result += 2;",
          "278:             }",
          "279:             if (value >= 10 ** 1) {",
          "280:                 result += 1;",
          "281:             }",
          "282:         }",
          "283:         return result;",
          "284:     }",
          "290:     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {",
          "291:         unchecked {",
          "292:             uint256 result = log10(value);",
          "293:             return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);",
          "294:         }",
          "295:     }",
          "303:     function log256(uint256 value) internal pure returns (uint256) {",
          "304:         uint256 result = 0;",
          "305:         unchecked {",
          "306:             if (value >> 128 > 0) {",
          "307:                 value >>= 128;",
          "308:                 result += 16;",
          "309:             }",
          "310:             if (value >> 64 > 0) {",
          "311:                 value >>= 64;",
          "312:                 result += 8;",
          "313:             }",
          "314:             if (value >> 32 > 0) {",
          "315:                 value >>= 32;",
          "316:                 result += 4;",
          "317:             }",
          "318:             if (value >> 16 > 0) {",
          "319:                 value >>= 16;",
          "320:                 result += 2;",
          "321:             }",
          "322:             if (value >> 8 > 0) {",
          "323:                 result += 1;",
          "324:             }",
          "325:         }",
          "326:         return result;",
          "327:     }",
          "333:     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {",
          "334:         unchecked {",
          "335:             uint256 result = log256(value);",
          "336:             return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);",
          "337:         }",
          "338:     }",
          "339: }",
          "",
          "---------------"
        ],
        "contracts/utils/math/SafeCastUpgradeable.sol||contracts/utils/math/SafeCastUpgradeable.sol": [
          "File: contracts/utils/math/SafeCastUpgradeable.sol -> contracts/utils/math/SafeCastUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: pragma solidity ^0.8.0;",
          "22: library SafeCastUpgradeable {",
          "35:     function toUint248(uint256 value) internal pure returns (uint248) {",
          "36:         require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");",
          "37:         return uint248(value);",
          "38:     }",
          "52:     function toUint240(uint256 value) internal pure returns (uint240) {",
          "53:         require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");",
          "54:         return uint240(value);",
          "55:     }",
          "69:     function toUint232(uint256 value) internal pure returns (uint232) {",
          "70:         require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");",
          "71:         return uint232(value);",
          "72:     }",
          "86:     function toUint224(uint256 value) internal pure returns (uint224) {",
          "87:         require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");",
          "88:         return uint224(value);",
          "89:     }",
          "103:     function toUint216(uint256 value) internal pure returns (uint216) {",
          "104:         require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");",
          "105:         return uint216(value);",
          "106:     }",
          "120:     function toUint208(uint256 value) internal pure returns (uint208) {",
          "121:         require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");",
          "122:         return uint208(value);",
          "123:     }",
          "137:     function toUint200(uint256 value) internal pure returns (uint200) {",
          "138:         require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");",
          "139:         return uint200(value);",
          "140:     }",
          "154:     function toUint192(uint256 value) internal pure returns (uint192) {",
          "155:         require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");",
          "156:         return uint192(value);",
          "157:     }",
          "171:     function toUint184(uint256 value) internal pure returns (uint184) {",
          "172:         require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");",
          "173:         return uint184(value);",
          "174:     }",
          "188:     function toUint176(uint256 value) internal pure returns (uint176) {",
          "189:         require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");",
          "190:         return uint176(value);",
          "191:     }",
          "205:     function toUint168(uint256 value) internal pure returns (uint168) {",
          "206:         require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");",
          "207:         return uint168(value);",
          "208:     }",
          "222:     function toUint160(uint256 value) internal pure returns (uint160) {",
          "223:         require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");",
          "224:         return uint160(value);",
          "225:     }",
          "239:     function toUint152(uint256 value) internal pure returns (uint152) {",
          "240:         require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");",
          "241:         return uint152(value);",
          "242:     }",
          "256:     function toUint144(uint256 value) internal pure returns (uint144) {",
          "257:         require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");",
          "258:         return uint144(value);",
          "259:     }",
          "273:     function toUint136(uint256 value) internal pure returns (uint136) {",
          "274:         require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");",
          "275:         return uint136(value);",
          "276:     }",
          "290:     function toUint128(uint256 value) internal pure returns (uint128) {",
          "291:         require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");",
          "292:         return uint128(value);",
          "293:     }",
          "307:     function toUint120(uint256 value) internal pure returns (uint120) {",
          "308:         require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");",
          "309:         return uint120(value);",
          "310:     }",
          "324:     function toUint112(uint256 value) internal pure returns (uint112) {",
          "325:         require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");",
          "326:         return uint112(value);",
          "327:     }",
          "341:     function toUint104(uint256 value) internal pure returns (uint104) {",
          "342:         require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");",
          "343:         return uint104(value);",
          "344:     }",
          "358:     function toUint96(uint256 value) internal pure returns (uint96) {",
          "359:         require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");",
          "360:         return uint96(value);",
          "361:     }",
          "375:     function toUint88(uint256 value) internal pure returns (uint88) {",
          "376:         require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");",
          "377:         return uint88(value);",
          "378:     }",
          "392:     function toUint80(uint256 value) internal pure returns (uint80) {",
          "393:         require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");",
          "394:         return uint80(value);",
          "395:     }",
          "409:     function toUint72(uint256 value) internal pure returns (uint72) {",
          "410:         require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");",
          "411:         return uint72(value);",
          "412:     }",
          "426:     function toUint64(uint256 value) internal pure returns (uint64) {",
          "427:         require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");",
          "428:         return uint64(value);",
          "429:     }",
          "443:     function toUint56(uint256 value) internal pure returns (uint56) {",
          "444:         require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");",
          "445:         return uint56(value);",
          "446:     }",
          "460:     function toUint48(uint256 value) internal pure returns (uint48) {",
          "461:         require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");",
          "462:         return uint48(value);",
          "463:     }",
          "477:     function toUint40(uint256 value) internal pure returns (uint40) {",
          "478:         require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");",
          "479:         return uint40(value);",
          "480:     }",
          "494:     function toUint32(uint256 value) internal pure returns (uint32) {",
          "495:         require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");",
          "496:         return uint32(value);",
          "497:     }",
          "511:     function toUint24(uint256 value) internal pure returns (uint24) {",
          "512:         require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");",
          "513:         return uint24(value);",
          "514:     }",
          "528:     function toUint16(uint256 value) internal pure returns (uint16) {",
          "529:         require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");",
          "530:         return uint16(value);",
          "531:     }",
          "545:     function toUint8(uint256 value) internal pure returns (uint8) {",
          "546:         require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");",
          "547:         return uint8(value);",
          "548:     }",
          "559:     function toUint256(int256 value) internal pure returns (uint256) {",
          "560:         require(value >= 0, \"SafeCast: value must be positive\");",
          "561:         return uint256(value);",
          "562:     }",
          "577:     function toInt248(int256 value) internal pure returns (int248 downcasted) {",
          "578:         downcasted = int248(value);",
          "579:         require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");",
          "580:     }",
          "595:     function toInt240(int256 value) internal pure returns (int240 downcasted) {",
          "596:         downcasted = int240(value);",
          "597:         require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");",
          "598:     }",
          "613:     function toInt232(int256 value) internal pure returns (int232 downcasted) {",
          "614:         downcasted = int232(value);",
          "615:         require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");",
          "616:     }",
          "631:     function toInt224(int256 value) internal pure returns (int224 downcasted) {",
          "632:         downcasted = int224(value);",
          "633:         require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");",
          "634:     }",
          "649:     function toInt216(int256 value) internal pure returns (int216 downcasted) {",
          "650:         downcasted = int216(value);",
          "651:         require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");",
          "652:     }",
          "667:     function toInt208(int256 value) internal pure returns (int208 downcasted) {",
          "668:         downcasted = int208(value);",
          "669:         require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");",
          "670:     }",
          "685:     function toInt200(int256 value) internal pure returns (int200 downcasted) {",
          "686:         downcasted = int200(value);",
          "687:         require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");",
          "688:     }",
          "703:     function toInt192(int256 value) internal pure returns (int192 downcasted) {",
          "704:         downcasted = int192(value);",
          "705:         require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");",
          "706:     }",
          "721:     function toInt184(int256 value) internal pure returns (int184 downcasted) {",
          "722:         downcasted = int184(value);",
          "723:         require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");",
          "724:     }",
          "739:     function toInt176(int256 value) internal pure returns (int176 downcasted) {",
          "740:         downcasted = int176(value);",
          "741:         require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");",
          "742:     }",
          "757:     function toInt168(int256 value) internal pure returns (int168 downcasted) {",
          "758:         downcasted = int168(value);",
          "759:         require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");",
          "760:     }",
          "775:     function toInt160(int256 value) internal pure returns (int160 downcasted) {",
          "776:         downcasted = int160(value);",
          "777:         require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");",
          "778:     }",
          "793:     function toInt152(int256 value) internal pure returns (int152 downcasted) {",
          "794:         downcasted = int152(value);",
          "795:         require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");",
          "796:     }",
          "811:     function toInt144(int256 value) internal pure returns (int144 downcasted) {",
          "812:         downcasted = int144(value);",
          "813:         require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");",
          "814:     }",
          "829:     function toInt136(int256 value) internal pure returns (int136 downcasted) {",
          "830:         downcasted = int136(value);",
          "831:         require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");",
          "832:     }",
          "847:     function toInt128(int256 value) internal pure returns (int128 downcasted) {",
          "848:         downcasted = int128(value);",
          "849:         require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");",
          "850:     }",
          "865:     function toInt120(int256 value) internal pure returns (int120 downcasted) {",
          "866:         downcasted = int120(value);",
          "867:         require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");",
          "868:     }",
          "883:     function toInt112(int256 value) internal pure returns (int112 downcasted) {",
          "884:         downcasted = int112(value);",
          "885:         require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");",
          "886:     }",
          "901:     function toInt104(int256 value) internal pure returns (int104 downcasted) {",
          "902:         downcasted = int104(value);",
          "903:         require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");",
          "904:     }",
          "919:     function toInt96(int256 value) internal pure returns (int96 downcasted) {",
          "920:         downcasted = int96(value);",
          "921:         require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");",
          "922:     }",
          "937:     function toInt88(int256 value) internal pure returns (int88 downcasted) {",
          "938:         downcasted = int88(value);",
          "939:         require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");",
          "940:     }",
          "955:     function toInt80(int256 value) internal pure returns (int80 downcasted) {",
          "956:         downcasted = int80(value);",
          "957:         require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");",
          "958:     }",
          "973:     function toInt72(int256 value) internal pure returns (int72 downcasted) {",
          "974:         downcasted = int72(value);",
          "975:         require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");",
          "976:     }",
          "991:     function toInt64(int256 value) internal pure returns (int64 downcasted) {",
          "992:         downcasted = int64(value);",
          "993:         require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");",
          "994:     }",
          "1009:     function toInt56(int256 value) internal pure returns (int56 downcasted) {",
          "1010:         downcasted = int56(value);",
          "1011:         require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");",
          "1012:     }",
          "1027:     function toInt48(int256 value) internal pure returns (int48 downcasted) {",
          "1028:         downcasted = int48(value);",
          "1029:         require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");",
          "1030:     }",
          "1045:     function toInt40(int256 value) internal pure returns (int40 downcasted) {",
          "1046:         downcasted = int40(value);",
          "1047:         require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");",
          "1048:     }",
          "1063:     function toInt32(int256 value) internal pure returns (int32 downcasted) {",
          "1064:         downcasted = int32(value);",
          "1065:         require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");",
          "1066:     }",
          "1081:     function toInt24(int256 value) internal pure returns (int24 downcasted) {",
          "1082:         downcasted = int24(value);",
          "1083:         require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");",
          "1084:     }",
          "1099:     function toInt16(int256 value) internal pure returns (int16 downcasted) {",
          "1100:         downcasted = int16(value);",
          "1101:         require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");",
          "1102:     }",
          "1117:     function toInt8(int256 value) internal pure returns (int8 downcasted) {",
          "1118:         downcasted = int8(value);",
          "1119:         require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");",
          "1120:     }",
          "1131:     function toInt256(uint256 value) internal pure returns (int256) {",
          "1133:         require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");",
          "1134:         return int256(value);",
          "1135:     }",
          "1136: }",
          "",
          "---------------"
        ],
        "contracts/utils/math/SafeMathUpgradeable.sol||contracts/utils/math/SafeMathUpgradeable.sol": [
          "File: contracts/utils/math/SafeMathUpgradeable.sol -> contracts/utils/math/SafeMathUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "16: library SafeMathUpgradeable {",
          "22:     function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {",
          "23:         unchecked {",
          "24:             uint256 c = a + b;",
          "25:             if (c < a) return (false, 0);",
          "26:             return (true, c);",
          "27:         }",
          "28:     }",
          "35:     function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {",
          "36:         unchecked {",
          "37:             if (b > a) return (false, 0);",
          "38:             return (true, a - b);",
          "39:         }",
          "40:     }",
          "47:     function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {",
          "48:         unchecked {",
          "52:             if (a == 0) return (true, 0);",
          "53:             uint256 c = a * b;",
          "54:             if (c / a != b) return (false, 0);",
          "55:             return (true, c);",
          "56:         }",
          "57:     }",
          "64:     function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {",
          "65:         unchecked {",
          "66:             if (b == 0) return (false, 0);",
          "67:             return (true, a / b);",
          "68:         }",
          "69:     }",
          "76:     function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {",
          "77:         unchecked {",
          "78:             if (b == 0) return (false, 0);",
          "79:             return (true, a % b);",
          "80:         }",
          "81:     }",
          "93:     function add(uint256 a, uint256 b) internal pure returns (uint256) {",
          "94:         return a + b;",
          "95:     }",
          "107:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {",
          "108:         return a - b;",
          "109:     }",
          "121:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {",
          "122:         return a * b;",
          "123:     }",
          "135:     function div(uint256 a, uint256 b) internal pure returns (uint256) {",
          "136:         return a / b;",
          "137:     }",
          "151:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {",
          "152:         return a % b;",
          "153:     }",
          "168:     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {",
          "169:         unchecked {",
          "170:             require(b <= a, errorMessage);",
          "171:             return a - b;",
          "172:         }",
          "173:     }",
          "187:     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {",
          "188:         unchecked {",
          "189:             require(b > 0, errorMessage);",
          "190:             return a / b;",
          "191:         }",
          "192:     }",
          "209:     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {",
          "210:         unchecked {",
          "211:             require(b > 0, errorMessage);",
          "212:             return a % b;",
          "213:         }",
          "214:     }",
          "215: }",
          "",
          "---------------"
        ],
        "contracts/utils/math/SignedMathUpgradeable.sol||contracts/utils/math/SignedMathUpgradeable.sol": [
          "File: contracts/utils/math/SignedMathUpgradeable.sol -> contracts/utils/math/SignedMathUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "9: library SignedMathUpgradeable {",
          "13:     function max(int256 a, int256 b) internal pure returns (int256) {",
          "14:         return a > b ? a : b;",
          "15:     }",
          "20:     function min(int256 a, int256 b) internal pure returns (int256) {",
          "21:         return a < b ? a : b;",
          "22:     }",
          "28:     function average(int256 a, int256 b) internal pure returns (int256) {",
          "30:         int256 x = (a & b) + ((a ^ b) >> 1);",
          "31:         return x + (int256(uint256(x) >> 255) & (a ^ b));",
          "32:     }",
          "37:     function abs(int256 n) internal pure returns (uint256) {",
          "38:         unchecked {",
          "40:             return uint256(n >= 0 ? n : -n);",
          "41:         }",
          "42:     }",
          "43: }",
          "",
          "---------------"
        ],
        "contracts/utils/math/SignedSafeMathUpgradeable.sol||contracts/utils/math/SignedSafeMathUpgradeable.sol": [
          "File: contracts/utils/math/SignedSafeMathUpgradeable.sol -> contracts/utils/math/SignedSafeMathUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "12: library SignedSafeMathUpgradeable {",
          "23:     function mul(int256 a, int256 b) internal pure returns (int256) {",
          "24:         return a * b;",
          "25:     }",
          "37:     function div(int256 a, int256 b) internal pure returns (int256) {",
          "38:         return a / b;",
          "39:     }",
          "51:     function sub(int256 a, int256 b) internal pure returns (int256) {",
          "52:         return a - b;",
          "53:     }",
          "65:     function add(int256 a, int256 b) internal pure returns (int256) {",
          "66:         return a + b;",
          "67:     }",
          "68: }",
          "",
          "---------------"
        ],
        "contracts/utils/structs/BitMapsUpgradeable.sol||contracts/utils/structs/BitMapsUpgradeable.sol": [
          "File: contracts/utils/structs/BitMapsUpgradeable.sol -> contracts/utils/structs/BitMapsUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "9: library BitMapsUpgradeable {",
          "10:     struct BitMap {",
          "11:         mapping(uint256 => uint256) _data;",
          "12:     }",
          "17:     function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {",
          "18:         uint256 bucket = index >> 8;",
          "19:         uint256 mask = 1 << (index & 0xff);",
          "20:         return bitmap._data[bucket] & mask != 0;",
          "21:     }",
          "26:     function setTo(BitMap storage bitmap, uint256 index, bool value) internal {",
          "27:         if (value) {",
          "28:             set(bitmap, index);",
          "29:         } else {",
          "30:             unset(bitmap, index);",
          "31:         }",
          "32:     }",
          "37:     function set(BitMap storage bitmap, uint256 index) internal {",
          "38:         uint256 bucket = index >> 8;",
          "39:         uint256 mask = 1 << (index & 0xff);",
          "40:         bitmap._data[bucket] |= mask;",
          "41:     }",
          "46:     function unset(BitMap storage bitmap, uint256 index) internal {",
          "47:         uint256 bucket = index >> 8;",
          "48:         uint256 mask = 1 << (index & 0xff);",
          "49:         bitmap._data[bucket] &= ~mask;",
          "50:     }",
          "51: }",
          "",
          "---------------"
        ],
        "contracts/utils/structs/DoubleEndedQueueUpgradeable.sol||contracts/utils/structs/DoubleEndedQueueUpgradeable.sol": [
          "File: contracts/utils/structs/DoubleEndedQueueUpgradeable.sol -> contracts/utils/structs/DoubleEndedQueueUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.4;",
          "5: import \"../math/SafeCastUpgradeable.sol\";",
          "21: library DoubleEndedQueueUpgradeable {",
          "25:     error Empty();",
          "30:     error OutOfBounds();",
          "44:     struct Bytes32Deque {",
          "45:         int128 _begin;",
          "46:         int128 _end;",
          "47:         mapping(int128 => bytes32) _data;",
          "48:     }",
          "53:     function pushBack(Bytes32Deque storage deque, bytes32 value) internal {",
          "54:         int128 backIndex = deque._end;",
          "55:         deque._data[backIndex] = value;",
          "56:         unchecked {",
          "57:             deque._end = backIndex + 1;",
          "58:         }",
          "59:     }",
          "66:     function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {",
          "67:         if (empty(deque)) revert Empty();",
          "68:         int128 backIndex;",
          "69:         unchecked {",
          "70:             backIndex = deque._end - 1;",
          "71:         }",
          "72:         value = deque._data[backIndex];",
          "73:         delete deque._data[backIndex];",
          "74:         deque._end = backIndex;",
          "75:     }",
          "80:     function pushFront(Bytes32Deque storage deque, bytes32 value) internal {",
          "81:         int128 frontIndex;",
          "82:         unchecked {",
          "83:             frontIndex = deque._begin - 1;",
          "84:         }",
          "85:         deque._data[frontIndex] = value;",
          "86:         deque._begin = frontIndex;",
          "87:     }",
          "94:     function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {",
          "95:         if (empty(deque)) revert Empty();",
          "96:         int128 frontIndex = deque._begin;",
          "97:         value = deque._data[frontIndex];",
          "98:         delete deque._data[frontIndex];",
          "99:         unchecked {",
          "100:             deque._begin = frontIndex + 1;",
          "101:         }",
          "102:     }",
          "109:     function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {",
          "110:         if (empty(deque)) revert Empty();",
          "111:         int128 frontIndex = deque._begin;",
          "112:         return deque._data[frontIndex];",
          "113:     }",
          "120:     function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {",
          "121:         if (empty(deque)) revert Empty();",
          "122:         int128 backIndex;",
          "123:         unchecked {",
          "124:             backIndex = deque._end - 1;",
          "125:         }",
          "126:         return deque._data[backIndex];",
          "127:     }",
          "135:     function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {",
          "137:         int128 idx = SafeCastUpgradeable.toInt128(int256(deque._begin) + SafeCastUpgradeable.toInt256(index));",
          "138:         if (idx >= deque._end) revert OutOfBounds();",
          "139:         return deque._data[idx];",
          "140:     }",
          "148:     function clear(Bytes32Deque storage deque) internal {",
          "149:         deque._begin = 0;",
          "150:         deque._end = 0;",
          "151:     }",
          "156:     function length(Bytes32Deque storage deque) internal view returns (uint256) {",
          "159:         unchecked {",
          "160:             return uint256(int256(deque._end) - int256(deque._begin));",
          "161:         }",
          "162:     }",
          "167:     function empty(Bytes32Deque storage deque) internal view returns (bool) {",
          "168:         return deque._end <= deque._begin;",
          "169:     }",
          "170: }",
          "",
          "---------------"
        ],
        "contracts/utils/structs/EnumerableMapUpgradeable.sol||contracts/utils/structs/EnumerableMapUpgradeable.sol": [
          "File: contracts/utils/structs/EnumerableMapUpgradeable.sol -> contracts/utils/structs/EnumerableMapUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: pragma solidity ^0.8.0;",
          "7: import \"./EnumerableSetUpgradeable.sol\";",
          "48: library EnumerableMapUpgradeable {",
          "49:     using EnumerableSetUpgradeable for EnumerableSetUpgradeable.Bytes32Set;",
          "60:     struct Bytes32ToBytes32Map {",
          "62:         EnumerableSetUpgradeable.Bytes32Set _keys;",
          "63:         mapping(bytes32 => bytes32) _values;",
          "64:     }",
          "73:     function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {",
          "74:         map._values[key] = value;",
          "75:         return map._keys.add(key);",
          "76:     }",
          "83:     function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {",
          "84:         delete map._values[key];",
          "85:         return map._keys.remove(key);",
          "86:     }",
          "91:     function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {",
          "92:         return map._keys.contains(key);",
          "93:     }",
          "98:     function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {",
          "99:         return map._keys.length();",
          "100:     }",
          "112:     function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {",
          "113:         bytes32 key = map._keys.at(index);",
          "114:         return (key, map._values[key]);",
          "115:     }",
          "121:     function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {",
          "122:         bytes32 value = map._values[key];",
          "123:         if (value == bytes32(0)) {",
          "124:             return (contains(map, key), bytes32(0));",
          "125:         } else {",
          "126:             return (true, value);",
          "127:         }",
          "128:     }",
          "137:     function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {",
          "138:         bytes32 value = map._values[key];",
          "139:         require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");",
          "140:         return value;",
          "141:     }",
          "149:     function get(",
          "150:         Bytes32ToBytes32Map storage map,",
          "151:         bytes32 key,",
          "152:         string memory errorMessage",
          "153:     ) internal view returns (bytes32) {",
          "154:         bytes32 value = map._values[key];",
          "155:         require(value != 0 || contains(map, key), errorMessage);",
          "156:         return value;",
          "157:     }",
          "167:     function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {",
          "168:         return map._keys.values();",
          "169:     }",
          "173:     struct UintToUintMap {",
          "174:         Bytes32ToBytes32Map _inner;",
          "175:     }",
          "184:     function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {",
          "185:         return set(map._inner, bytes32(key), bytes32(value));",
          "186:     }",
          "193:     function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {",
          "194:         return remove(map._inner, bytes32(key));",
          "195:     }",
          "200:     function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {",
          "201:         return contains(map._inner, bytes32(key));",
          "202:     }",
          "207:     function length(UintToUintMap storage map) internal view returns (uint256) {",
          "208:         return length(map._inner);",
          "209:     }",
          "220:     function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {",
          "221:         (bytes32 key, bytes32 value) = at(map._inner, index);",
          "222:         return (uint256(key), uint256(value));",
          "223:     }",
          "229:     function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {",
          "230:         (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));",
          "231:         return (success, uint256(value));",
          "232:     }",
          "241:     function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {",
          "242:         return uint256(get(map._inner, bytes32(key)));",
          "243:     }",
          "251:     function get(UintToUintMap storage map, uint256 key, string memory errorMessage) internal view returns (uint256) {",
          "252:         return uint256(get(map._inner, bytes32(key), errorMessage));",
          "253:     }",
          "263:     function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {",
          "264:         bytes32[] memory store = keys(map._inner);",
          "265:         uint256[] memory result;",
          "268:         assembly {",
          "269:             result := store",
          "270:         }",
          "272:         return result;",
          "273:     }",
          "277:     struct UintToAddressMap {",
          "278:         Bytes32ToBytes32Map _inner;",
          "279:     }",
          "288:     function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {",
          "289:         return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));",
          "290:     }",
          "297:     function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {",
          "298:         return remove(map._inner, bytes32(key));",
          "299:     }",
          "304:     function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {",
          "305:         return contains(map._inner, bytes32(key));",
          "306:     }",
          "311:     function length(UintToAddressMap storage map) internal view returns (uint256) {",
          "312:         return length(map._inner);",
          "313:     }",
          "324:     function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {",
          "325:         (bytes32 key, bytes32 value) = at(map._inner, index);",
          "326:         return (uint256(key), address(uint160(uint256(value))));",
          "327:     }",
          "333:     function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {",
          "334:         (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));",
          "335:         return (success, address(uint160(uint256(value))));",
          "336:     }",
          "345:     function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {",
          "346:         return address(uint160(uint256(get(map._inner, bytes32(key)))));",
          "347:     }",
          "355:     function get(",
          "356:         UintToAddressMap storage map,",
          "357:         uint256 key,",
          "358:         string memory errorMessage",
          "359:     ) internal view returns (address) {",
          "360:         return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));",
          "361:     }",
          "371:     function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {",
          "372:         bytes32[] memory store = keys(map._inner);",
          "373:         uint256[] memory result;",
          "376:         assembly {",
          "377:             result := store",
          "378:         }",
          "380:         return result;",
          "381:     }",
          "385:     struct AddressToUintMap {",
          "386:         Bytes32ToBytes32Map _inner;",
          "387:     }",
          "396:     function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {",
          "397:         return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));",
          "398:     }",
          "405:     function remove(AddressToUintMap storage map, address key) internal returns (bool) {",
          "406:         return remove(map._inner, bytes32(uint256(uint160(key))));",
          "407:     }",
          "412:     function contains(AddressToUintMap storage map, address key) internal view returns (bool) {",
          "413:         return contains(map._inner, bytes32(uint256(uint160(key))));",
          "414:     }",
          "419:     function length(AddressToUintMap storage map) internal view returns (uint256) {",
          "420:         return length(map._inner);",
          "421:     }",
          "432:     function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {",
          "433:         (bytes32 key, bytes32 value) = at(map._inner, index);",
          "434:         return (address(uint160(uint256(key))), uint256(value));",
          "435:     }",
          "441:     function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {",
          "442:         (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));",
          "443:         return (success, uint256(value));",
          "444:     }",
          "453:     function get(AddressToUintMap storage map, address key) internal view returns (uint256) {",
          "454:         return uint256(get(map._inner, bytes32(uint256(uint160(key)))));",
          "455:     }",
          "463:     function get(",
          "464:         AddressToUintMap storage map,",
          "465:         address key,",
          "466:         string memory errorMessage",
          "467:     ) internal view returns (uint256) {",
          "468:         return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));",
          "469:     }",
          "479:     function keys(AddressToUintMap storage map) internal view returns (address[] memory) {",
          "480:         bytes32[] memory store = keys(map._inner);",
          "481:         address[] memory result;",
          "484:         assembly {",
          "485:             result := store",
          "486:         }",
          "488:         return result;",
          "489:     }",
          "493:     struct Bytes32ToUintMap {",
          "494:         Bytes32ToBytes32Map _inner;",
          "495:     }",
          "504:     function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {",
          "505:         return set(map._inner, key, bytes32(value));",
          "506:     }",
          "513:     function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {",
          "514:         return remove(map._inner, key);",
          "515:     }",
          "520:     function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {",
          "521:         return contains(map._inner, key);",
          "522:     }",
          "527:     function length(Bytes32ToUintMap storage map) internal view returns (uint256) {",
          "528:         return length(map._inner);",
          "529:     }",
          "540:     function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {",
          "541:         (bytes32 key, bytes32 value) = at(map._inner, index);",
          "542:         return (key, uint256(value));",
          "543:     }",
          "549:     function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {",
          "550:         (bool success, bytes32 value) = tryGet(map._inner, key);",
          "551:         return (success, uint256(value));",
          "552:     }",
          "561:     function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {",
          "562:         return uint256(get(map._inner, key));",
          "563:     }",
          "571:     function get(",
          "572:         Bytes32ToUintMap storage map,",
          "573:         bytes32 key,",
          "574:         string memory errorMessage",
          "575:     ) internal view returns (uint256) {",
          "576:         return uint256(get(map._inner, key, errorMessage));",
          "577:     }",
          "587:     function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {",
          "588:         bytes32[] memory store = keys(map._inner);",
          "589:         bytes32[] memory result;",
          "592:         assembly {",
          "593:             result := store",
          "594:         }",
          "596:         return result;",
          "597:     }",
          "598: }",
          "",
          "---------------"
        ],
        "contracts/utils/structs/EnumerableSetUpgradeable.sol||contracts/utils/structs/EnumerableSetUpgradeable.sol": [
          "File: contracts/utils/structs/EnumerableSetUpgradeable.sol -> contracts/utils/structs/EnumerableSetUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: pragma solidity ^0.8.0;",
          "41: library EnumerableSetUpgradeable {",
          "51:     struct Set {",
          "53:         bytes32[] _values;",
          "56:         mapping(bytes32 => uint256) _indexes;",
          "57:     }",
          "65:     function _add(Set storage set, bytes32 value) private returns (bool) {",
          "66:         if (!_contains(set, value)) {",
          "67:             set._values.push(value);",
          "70:             set._indexes[value] = set._values.length;",
          "71:             return true;",
          "72:         } else {",
          "73:             return false;",
          "74:         }",
          "75:     }",
          "83:     function _remove(Set storage set, bytes32 value) private returns (bool) {",
          "85:         uint256 valueIndex = set._indexes[value];",
          "87:         if (valueIndex != 0) {",
          "93:             uint256 toDeleteIndex = valueIndex - 1;",
          "94:             uint256 lastIndex = set._values.length - 1;",
          "96:             if (lastIndex != toDeleteIndex) {",
          "97:                 bytes32 lastValue = set._values[lastIndex];",
          "100:                 set._values[toDeleteIndex] = lastValue;",
          "102:                 set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex",
          "103:             }",
          "106:             set._values.pop();",
          "109:             delete set._indexes[value];",
          "111:             return true;",
          "112:         } else {",
          "113:             return false;",
          "114:         }",
          "115:     }",
          "120:     function _contains(Set storage set, bytes32 value) private view returns (bool) {",
          "121:         return set._indexes[value] != 0;",
          "122:     }",
          "127:     function _length(Set storage set) private view returns (uint256) {",
          "128:         return set._values.length;",
          "129:     }",
          "141:     function _at(Set storage set, uint256 index) private view returns (bytes32) {",
          "142:         return set._values[index];",
          "143:     }",
          "153:     function _values(Set storage set) private view returns (bytes32[] memory) {",
          "154:         return set._values;",
          "155:     }",
          "159:     struct Bytes32Set {",
          "160:         Set _inner;",
          "161:     }",
          "169:     function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {",
          "170:         return _add(set._inner, value);",
          "171:     }",
          "179:     function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {",
          "180:         return _remove(set._inner, value);",
          "181:     }",
          "186:     function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {",
          "187:         return _contains(set._inner, value);",
          "188:     }",
          "193:     function length(Bytes32Set storage set) internal view returns (uint256) {",
          "194:         return _length(set._inner);",
          "195:     }",
          "207:     function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {",
          "208:         return _at(set._inner, index);",
          "209:     }",
          "219:     function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {",
          "220:         bytes32[] memory store = _values(set._inner);",
          "221:         bytes32[] memory result;",
          "224:         assembly {",
          "225:             result := store",
          "226:         }",
          "228:         return result;",
          "229:     }",
          "233:     struct AddressSet {",
          "234:         Set _inner;",
          "235:     }",
          "243:     function add(AddressSet storage set, address value) internal returns (bool) {",
          "244:         return _add(set._inner, bytes32(uint256(uint160(value))));",
          "245:     }",
          "253:     function remove(AddressSet storage set, address value) internal returns (bool) {",
          "254:         return _remove(set._inner, bytes32(uint256(uint160(value))));",
          "255:     }",
          "260:     function contains(AddressSet storage set, address value) internal view returns (bool) {",
          "261:         return _contains(set._inner, bytes32(uint256(uint160(value))));",
          "262:     }",
          "267:     function length(AddressSet storage set) internal view returns (uint256) {",
          "268:         return _length(set._inner);",
          "269:     }",
          "281:     function at(AddressSet storage set, uint256 index) internal view returns (address) {",
          "282:         return address(uint160(uint256(_at(set._inner, index))));",
          "283:     }",
          "293:     function values(AddressSet storage set) internal view returns (address[] memory) {",
          "294:         bytes32[] memory store = _values(set._inner);",
          "295:         address[] memory result;",
          "298:         assembly {",
          "299:             result := store",
          "300:         }",
          "302:         return result;",
          "303:     }",
          "307:     struct UintSet {",
          "308:         Set _inner;",
          "309:     }",
          "317:     function add(UintSet storage set, uint256 value) internal returns (bool) {",
          "318:         return _add(set._inner, bytes32(value));",
          "319:     }",
          "327:     function remove(UintSet storage set, uint256 value) internal returns (bool) {",
          "328:         return _remove(set._inner, bytes32(value));",
          "329:     }",
          "334:     function contains(UintSet storage set, uint256 value) internal view returns (bool) {",
          "335:         return _contains(set._inner, bytes32(value));",
          "336:     }",
          "341:     function length(UintSet storage set) internal view returns (uint256) {",
          "342:         return _length(set._inner);",
          "343:     }",
          "355:     function at(UintSet storage set, uint256 index) internal view returns (uint256) {",
          "356:         return uint256(_at(set._inner, index));",
          "357:     }",
          "367:     function values(UintSet storage set) internal view returns (uint256[] memory) {",
          "368:         bytes32[] memory store = _values(set._inner);",
          "369:         uint256[] memory result;",
          "372:         assembly {",
          "373:             result := store",
          "374:         }",
          "376:         return result;",
          "377:     }",
          "378: }",
          "",
          "---------------"
        ],
        "contracts/vendor/amb/IAMBUpgradeable.sol||contracts/vendor/amIAMBUpgradeable.sol": [
          "File: contracts/vendor/amb/IAMBUpgradeable.sol -> contracts/vendor/amIAMBUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "contracts/vendor/arbitrum/IArbSysUpgradeable.sol||contracts/vendor/arbitrum/IArbSysUpgradeable.sol": [
          "File: contracts/vendor/arbitrum/IArbSysUpgradeable.sol -> contracts/vendor/arbitrum/IArbSysUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: pragma solidity >=0.4.21 <0.9.0;",
          "13: interface IArbSysUpgradeable {",
          "18:     function arbBlockNumber() external view returns (uint256);",
          "24:     function arbBlockHash(uint256 arbBlockNum) external view returns (bytes32);",
          "30:     function arbChainID() external view returns (uint256);",
          "36:     function arbOSVersion() external view returns (uint256);",
          "42:     function getStorageGasAvailable() external view returns (uint256);",
          "49:     function isTopLevelCall() external view returns (bool);",
          "57:     function mapL1SenderContractAddressToL2Alias(address sender, address unused) external pure returns (address);",
          "63:     function wasMyCallersAddressAliased() external view returns (bool);",
          "69:     function myCallersAddressWithoutAliasing() external view returns (address);",
          "77:     function withdrawEth(address destination) external payable returns (uint256);",
          "87:     function sendTxToL1(address destination, bytes calldata data) external payable returns (uint256);",
          "95:     function sendMerkleTreeState() external view returns (uint256 size, bytes32 root, bytes32[] memory partials);",
          "101:     event L2ToL1Tx(",
          "102:         address caller,",
          "103:         address indexed destination,",
          "104:         uint256 indexed hash,",
          "105:         uint256 indexed position,",
          "106:         uint256 arbBlockNum,",
          "107:         uint256 ethBlockNum,",
          "108:         uint256 timestamp,",
          "109:         uint256 callvalue,",
          "110:         bytes data",
          "111:     );",
          "114:     event L2ToL1Transaction(",
          "115:         address caller,",
          "116:         address indexed destination,",
          "117:         uint256 indexed uniqueId,",
          "118:         uint256 indexed batchNumber,",
          "119:         uint256 indexInBatch,",
          "120:         uint256 arbBlockNum,",
          "121:         uint256 ethBlockNum,",
          "122:         uint256 timestamp,",
          "123:         uint256 callvalue,",
          "124:         bytes data",
          "125:     );",
          "133:     event SendMerkleUpdate(uint256 indexed reserved, bytes32 indexed hash, uint256 indexed position);",
          "134: }",
          "",
          "---------------"
        ],
        "contracts/vendor/arbitrum/IBridgeUpgradeable.sol||contracts/vendor/arbitrum/IBridgeUpgradeable.sol": [
          "File: contracts/vendor/arbitrum/IBridgeUpgradeable.sol -> contracts/vendor/arbitrum/IBridgeUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: pragma solidity >=0.6.9 <0.9.0;",
          "9: interface IBridgeUpgradeable {",
          "10:     event MessageDelivered(",
          "11:         uint256 indexed messageIndex,",
          "12:         bytes32 indexed beforeInboxAcc,",
          "13:         address inbox,",
          "14:         uint8 kind,",
          "15:         address sender,",
          "16:         bytes32 messageDataHash,",
          "17:         uint256 baseFeeL1,",
          "18:         uint64 timestamp",
          "19:     );",
          "21:     event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data);",
          "23:     event InboxToggle(address indexed inbox, bool enabled);",
          "25:     event OutboxToggle(address indexed outbox, bool enabled);",
          "27:     event SequencerInboxUpdated(address newSequencerInbox);",
          "29:     function allowedDelayedInboxList(uint256) external returns (address);",
          "31:     function allowedOutboxList(uint256) external returns (address);",
          "34:     function delayedInboxAccs(uint256) external view returns (bytes32);",
          "37:     function sequencerInboxAccs(uint256) external view returns (bytes32);",
          "40:     function rollup() external view returns (address);",
          "42:     function sequencerInbox() external view returns (address);",
          "44:     function activeOutbox() external view returns (address);",
          "46:     function allowedDelayedInboxes(address inbox) external view returns (bool);",
          "48:     function allowedOutboxes(address outbox) external view returns (bool);",
          "50:     function sequencerReportedSubMessageCount() external view returns (uint256);",
          "57:     function enqueueDelayedMessage(",
          "58:         uint8 kind,",
          "59:         address sender,",
          "60:         bytes32 messageDataHash",
          "61:     ) external payable returns (uint256);",
          "63:     function executeCall(",
          "64:         address to,",
          "65:         uint256 value,",
          "66:         bytes calldata data",
          "67:     ) external returns (bool success, bytes memory returnData);",
          "69:     function delayedMessageCount() external view returns (uint256);",
          "71:     function sequencerMessageCount() external view returns (uint256);",
          "75:     function enqueueSequencerMessage(",
          "76:         bytes32 dataHash,",
          "77:         uint256 afterDelayedMessagesRead,",
          "78:         uint256 prevMessageCount,",
          "79:         uint256 newMessageCount",
          "80:     ) external returns (uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc);",
          "88:     function submitBatchSpendingReport(address batchPoster, bytes32 dataHash) external returns (uint256 msgNum);",
          "92:     function setSequencerInbox(address _sequencerInbox) external;",
          "94:     function setDelayedInbox(address inbox, bool enabled) external;",
          "96:     function setOutbox(address inbox, bool enabled) external;",
          "101:     function initialize(address rollup_) external;",
          "102: }",
          "",
          "---------------"
        ],
        "contracts/vendor/arbitrum/IDelayedMessageProviderUpgradeable.sol||contracts/vendor/arbitrum/IDelayedMessageProviderUpgradeable.sol": [
          "File: contracts/vendor/arbitrum/IDelayedMessageProviderUpgradeable.sol -> contracts/vendor/arbitrum/IDelayedMessageProviderUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: pragma solidity >=0.6.9 <0.9.0;",
          "9: interface IDelayedMessageProviderUpgradeable {",
          "11:     event InboxMessageDelivered(uint256 indexed messageNum, bytes data);",
          "15:     event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);",
          "16: }",
          "",
          "---------------"
        ],
        "contracts/vendor/arbitrum/IInboxUpgradeable.sol||contracts/vendor/arbitrum/IInboxUpgradeable.sol": [
          "File: contracts/vendor/arbitrum/IInboxUpgradeable.sol -> contracts/vendor/arbitrum/IInboxUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: pragma solidity >=0.6.9 <0.9.0;",
          "9: import \"./IBridgeUpgradeable.sol\";",
          "10: import \"./IDelayedMessageProviderUpgradeable.sol\";",
          "12: interface IInboxUpgradeable is IDelayedMessageProviderUpgradeable {",
          "13:     function bridge() external view returns (IBridgeUpgradeable);",
          "16:     function sequencerInbox() external view returns (address);",
          "23:     function sendL2MessageFromOrigin(bytes calldata messageData) external returns (uint256);",
          "30:     function sendL2Message(bytes calldata messageData) external returns (uint256);",
          "32:     function sendL1FundedUnsignedTransaction(",
          "33:         uint256 gasLimit,",
          "34:         uint256 maxFeePerGas,",
          "35:         uint256 nonce,",
          "36:         address to,",
          "37:         bytes calldata data",
          "38:     ) external payable returns (uint256);",
          "40:     function sendL1FundedContractTransaction(",
          "41:         uint256 gasLimit,",
          "42:         uint256 maxFeePerGas,",
          "43:         address to,",
          "44:         bytes calldata data",
          "45:     ) external payable returns (uint256);",
          "47:     function sendUnsignedTransaction(",
          "48:         uint256 gasLimit,",
          "49:         uint256 maxFeePerGas,",
          "50:         uint256 nonce,",
          "51:         address to,",
          "52:         uint256 value,",
          "53:         bytes calldata data",
          "54:     ) external returns (uint256);",
          "56:     function sendContractTransaction(",
          "57:         uint256 gasLimit,",
          "58:         uint256 maxFeePerGas,",
          "59:         address to,",
          "60:         uint256 value,",
          "61:         bytes calldata data",
          "62:     ) external returns (uint256);",
          "71:     function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) external view returns (uint256);",
          "79:     function depositEth() external payable returns (uint256);",
          "95:     function createRetryableTicket(",
          "96:         address to,",
          "97:         uint256 l2CallValue,",
          "98:         uint256 maxSubmissionCost,",
          "99:         address excessFeeRefundAddress,",
          "100:         address callValueRefundAddress,",
          "101:         uint256 gasLimit,",
          "102:         uint256 maxFeePerGas,",
          "103:         bytes calldata data",
          "104:     ) external payable returns (uint256);",
          "123:     function unsafeCreateRetryableTicket(",
          "124:         address to,",
          "125:         uint256 l2CallValue,",
          "126:         uint256 maxSubmissionCost,",
          "127:         address excessFeeRefundAddress,",
          "128:         address callValueRefundAddress,",
          "129:         uint256 gasLimit,",
          "130:         uint256 maxFeePerGas,",
          "131:         bytes calldata data",
          "132:     ) external payable returns (uint256);",
          "137:     function pause() external;",
          "140:     function unpause() external;",
          "148:     function postUpgradeInit(IBridgeUpgradeable _bridge) external;",
          "151:     function initialize(IBridgeUpgradeable _bridge, address _sequencerInbox) external;",
          "152: }",
          "",
          "---------------"
        ],
        "contracts/vendor/arbitrum/IOutboxUpgradeable.sol||contracts/vendor/arbitrum/IOutboxUpgradeable.sol": [
          "File: contracts/vendor/arbitrum/IOutboxUpgradeable.sol -> contracts/vendor/arbitrum/IOutboxUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: pragma solidity >=0.6.9 <0.9.0;",
          "9: import \"./IBridgeUpgradeable.sol\";",
          "11: interface IOutboxUpgradeable {",
          "12:     event SendRootUpdated(bytes32 indexed blockHash, bytes32 indexed outputRoot);",
          "13:     event OutBoxTransactionExecuted(",
          "14:         address indexed to,",
          "15:         address indexed l2Sender,",
          "16:         uint256 indexed zero,",
          "17:         uint256 transactionIndex",
          "18:     );",
          "20:     function rollup() external view returns (address); // the rollup contract",
          "22:     function bridge() external view returns (IBridgeUpgradeable); // the bridge contract",
          "24:     function spent(uint256) external view returns (bytes32); // packed spent bitmap",
          "26:     function roots(bytes32) external view returns (bytes32); // maps root hashes => L2 block hash",
          "29:     function OUTBOX_VERSION() external view returns (uint128); // the outbox version",
          "31:     function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) external;",
          "36:     function l2ToL1Sender() external view returns (address);",
          "39:     function l2ToL1Block() external view returns (uint256);",
          "42:     function l2ToL1EthBlock() external view returns (uint256);",
          "45:     function l2ToL1Timestamp() external view returns (uint256);",
          "48:     function l2ToL1OutputId() external view returns (bytes32);",
          "66:     function executeTransaction(",
          "67:         bytes32[] calldata proof,",
          "68:         uint256 index,",
          "69:         address l2Sender,",
          "70:         address to,",
          "71:         uint256 l2Block,",
          "72:         uint256 l1Block,",
          "73:         uint256 l2Timestamp,",
          "74:         uint256 value,",
          "75:         bytes calldata data",
          "76:     ) external;",
          "89:     function executeTransactionSimulation(",
          "90:         uint256 index,",
          "91:         address l2Sender,",
          "92:         address to,",
          "93:         uint256 l2Block,",
          "94:         uint256 l1Block,",
          "95:         uint256 l2Timestamp,",
          "96:         uint256 value,",
          "97:         bytes calldata data",
          "98:     ) external;",
          "104:     function isSpent(uint256 index) external view returns (bool);",
          "106:     function calculateItemHash(",
          "107:         address l2Sender,",
          "108:         address to,",
          "109:         uint256 l2Block,",
          "110:         uint256 l1Block,",
          "111:         uint256 l2Timestamp,",
          "112:         uint256 value,",
          "113:         bytes calldata data",
          "114:     ) external pure returns (bytes32);",
          "116:     function calculateMerkleRoot(bytes32[] memory proof, uint256 path, bytes32 item) external pure returns (bytes32);",
          "117: }",
          "",
          "---------------"
        ],
        "contracts/vendor/compound/ICompoundTimelockUpgradeable.sol||contracts/vendor/compound/ICompoundTimelockUpgradeable.sol": [
          "File: contracts/vendor/compound/ICompoundTimelockUpgradeable.sol -> contracts/vendor/compound/ICompoundTimelockUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "9: interface ICompoundTimelockUpgradeable {",
          "10:     event NewAdmin(address indexed newAdmin);",
          "11:     event NewPendingAdmin(address indexed newPendingAdmin);",
          "12:     event NewDelay(uint256 indexed newDelay);",
          "13:     event CancelTransaction(",
          "14:         bytes32 indexed txHash,",
          "15:         address indexed target,",
          "16:         uint256 value,",
          "17:         string signature,",
          "18:         bytes data,",
          "19:         uint256 eta",
          "20:     );",
          "21:     event ExecuteTransaction(",
          "22:         bytes32 indexed txHash,",
          "23:         address indexed target,",
          "24:         uint256 value,",
          "25:         string signature,",
          "26:         bytes data,",
          "27:         uint256 eta",
          "28:     );",
          "29:     event QueueTransaction(",
          "30:         bytes32 indexed txHash,",
          "31:         address indexed target,",
          "32:         uint256 value,",
          "33:         string signature,",
          "34:         bytes data,",
          "35:         uint256 eta",
          "36:     );",
          "38:     receive() external payable;",
          "41:     function GRACE_PERIOD() external view returns (uint256);",
          "44:     function MINIMUM_DELAY() external view returns (uint256);",
          "47:     function MAXIMUM_DELAY() external view returns (uint256);",
          "49:     function admin() external view returns (address);",
          "51:     function pendingAdmin() external view returns (address);",
          "53:     function delay() external view returns (uint256);",
          "55:     function queuedTransactions(bytes32) external view returns (bool);",
          "57:     function setDelay(uint256) external;",
          "59:     function acceptAdmin() external;",
          "61:     function setPendingAdmin(address) external;",
          "63:     function queueTransaction(",
          "64:         address target,",
          "65:         uint256 value,",
          "66:         string memory signature,",
          "67:         bytes memory data,",
          "68:         uint256 eta",
          "69:     ) external returns (bytes32);",
          "71:     function cancelTransaction(",
          "72:         address target,",
          "73:         uint256 value,",
          "74:         string memory signature,",
          "75:         bytes memory data,",
          "76:         uint256 eta",
          "77:     ) external;",
          "79:     function executeTransaction(",
          "80:         address target,",
          "81:         uint256 value,",
          "82:         string memory signature,",
          "83:         bytes memory data,",
          "84:         uint256 eta",
          "85:     ) external payable returns (bytes memory);",
          "86: }",
          "",
          "---------------"
        ],
        "contracts/vendor/optimism/ICrossDomainMessengerUpgradeable.sol||contracts/vendor/optimism/ICrossDomainMessengerUpgradeable.sol": [
          "File: contracts/vendor/optimism/ICrossDomainMessengerUpgradeable.sol -> contracts/vendor/optimism/ICrossDomainMessengerUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity >0.5.0 <0.9.0;",
          "8: interface ICrossDomainMessengerUpgradeable {",
          "13:     event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit);",
          "14:     event RelayedMessage(bytes32 indexed msgHash);",
          "15:     event FailedRelayedMessage(bytes32 indexed msgHash);",
          "21:     function xDomainMessageSender() external view returns (address);",
          "33:     function sendMessage(address _target, bytes calldata _message, uint32 _gasLimit) external;",
          "34: }",
          "",
          "---------------"
        ],
        "contracts/vendor/polygon/IFxMessageProcessorUpgradeable.sol||contracts/vendor/polygon/IFxMessageProcessorUpgradeable.sol": [
          "File: contracts/vendor/polygon/IFxMessageProcessorUpgradeable.sol -> contracts/vendor/polygon/IFxMessageProcessorUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: interface IFxMessageProcessorUpgradeable {",
          "6:     function processMessageFromRoot(uint256 stateId, address rootMessageSender, bytes calldata data) external;",
          "7: }",
          "",
          "---------------"
        ],
        "hardhat.config.js||hardhat.config.js": [
          "File: hardhat.config.js -> hardhat.config.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: const fs = require('fs');",
          "10: const path = require('path');",
          "11: const argv = require('yargs/yargs')()",
          "12:   .env('')",
          "13:   .options({",
          "14:     coverage: {",
          "15:       type: 'boolean',",
          "16:       default: false,",
          "17:     },",
          "18:     gas: {",
          "19:       alias: 'enableGasReport',",
          "20:       type: 'boolean',",
          "21:       default: false,",
          "22:     },",
          "23:     gasReport: {",
          "24:       alias: 'enableGasReportPath',",
          "25:       type: 'string',",
          "26:       implies: 'gas',",
          "27:       default: undefined,",
          "28:     },",
          "29:     mode: {",
          "30:       alias: 'compileMode',",
          "31:       type: 'string',",
          "32:       choices: ['production', 'development'],",
          "33:       default: 'development',",
          "34:     },",
          "35:     ir: {",
          "36:       alias: 'enableIR',",
          "37:       type: 'boolean',",
          "38:       default: false,",
          "39:     },",
          "40:     compiler: {",
          "41:       alias: 'compileVersion',",
          "42:       type: 'string',",
          "43:       default: '0.8.13',",
          "44:     },",
          "45:     coinmarketcap: {",
          "46:       alias: 'coinmarketcapApiKey',",
          "47:       type: 'string',",
          "48:     },",
          "49:   }).argv;",
          "51: require('@nomiclabs/hardhat-truffle5');",
          "52: require('hardhat-ignore-warnings');",
          "53: require('hardhat-exposed');",
          "55: require('solidity-docgen');",
          "57: for (const f of fs.readdirSync(path.join(__dirname, 'hardhat'))) {",
          "58:   require(path.join(__dirname, 'hardhat', f));",
          "59: }",
          "61: const withOptimizations = argv.gas || argv.compileMode === 'production';",
          "66: module.exports = {",
          "67:   solidity: {",
          "68:     version: argv.compiler,",
          "69:     settings: {",
          "70:       optimizer: {",
          "71:         enabled: withOptimizations,",
          "72:         runs: 200,",
          "73:       },",
          "74:       viaIR: withOptimizations && argv.ir,",
          "75:       outputSelection: { '*': { '*': ['storageLayout'] } },",
          "76:     },",
          "77:   },",
          "78:   warnings: {",
          "79:     '*': {",
          "80:       'code-size': withOptimizations,",
          "81:       'unused-param': !argv.coverage, // coverage causes unused-param warnings",
          "82:       default: 'error',",
          "83:     },",
          "84:   },",
          "85:   networks: {",
          "86:     hardhat: {",
          "87:       blockGasLimit: 10000000,",
          "88:       allowUnlimitedContractSize: !withOptimizations,",
          "89:     },",
          "90:   },",
          "91:   exposed: {",
          "92:     initializers: true,",
          "93:     exclude: [",
          "94:       'vendor/**/*',",
          "96:       'utils/Timers{,Upgradeable}.sol',",
          "97:     ],",
          "98:   },",
          "99:   docgen: require('./docs/config'),",
          "100: };",
          "102: if (argv.gas) {",
          "103:   require('hardhat-gas-reporter');",
          "104:   module.exports.gasReporter = {",
          "105:     showMethodSig: true,",
          "106:     currency: 'USD',",
          "107:     outputFile: argv.gasReport,",
          "108:     coinmarketcap: argv.coinmarketcap,",
          "109:   };",
          "110: }",
          "112: if (argv.coverage) {",
          "113:   require('solidity-coverage');",
          "114:   module.exports.networks.hardhat.initialBaseFeePerGas = 0;",
          "115: }",
          "",
          "---------------"
        ],
        "hardhat/env-artifacts.js||hardhat/env-artifacts.js": [
          "File: hardhat/env-artifacts.js -> hardhat/env-artifacts.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { HardhatError } = require('hardhat/internal/core/errors');",
          "6: extendEnvironment(env => {",
          "7:   const artifactsRequire = env.artifacts.require;",
          "9:   env.artifacts.require = name => {",
          "10:     for (const suffix of ['UpgradeableWithInit', 'Upgradeable', '']) {",
          "11:       try {",
          "12:         return artifactsRequire(name + suffix);",
          "13:       } catch (e) {",
          "15:         if (HardhatError.isHardhatError(e) && e.number === 700 && suffix !== '') {",
          "16:           continue;",
          "17:         } else {",
          "18:           throw e;",
          "19:         }",
          "20:       }",
          "21:     }",
          "22:     throw new Error('Unreachable');",
          "23:   };",
          "24: });",
          "",
          "---------------"
        ],
        "hardhat/env-contract.js||hardhat/env-contract.js": [
          "File: hardhat/env-contract.js -> hardhat/env-contract.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: extendEnvironment(env => {",
          "2:   const { contract } = env;",
          "4:   env.contract = function (name, body) {",
          "8:     contract(name, accounts => body(accounts.slice(1)));",
          "9:   };",
          "10: });",
          "",
          "---------------"
        ],
        "hardhat/ignore-unreachable-warnings.js||hardhat/ignore-unreachable-warnings.js": [
          "File: hardhat/ignore-unreachable-warnings.js -> hardhat/ignore-unreachable-warnings.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: const { task } = require('hardhat/config');",
          "9: const {",
          "10:   TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE,",
          "11:   TASK_COMPILE_SOLIDITY_COMPILE,",
          "12: } = require('hardhat/builtin-tasks/task-names');",
          "14: const marker = Symbol('unreachable');",
          "15: const markedCache = new WeakMap();",
          "17: task(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE, async (params, _, runSuper) => {",
          "18:   const job = await runSuper(params);",
          "21:   if (params.file.sourceName.startsWith('contracts/mocks/') && /\\bunreachable\\b/.test(params.file.sourceName)) {",
          "22:     const originalConfig = job.solidityConfig;",
          "23:     let markedConfig = markedCache.get(originalConfig);",
          "24:     if (markedConfig === undefined) {",
          "25:       markedConfig = { ...originalConfig, [marker]: true };",
          "26:       markedCache.set(originalConfig, markedConfig);",
          "27:     }",
          "28:     job.solidityConfig = markedConfig;",
          "29:   }",
          "30:   return job;",
          "31: });",
          "33: const W_UNREACHABLE_CODE = '5740';",
          "35: task(TASK_COMPILE_SOLIDITY_COMPILE, async (params, _, runSuper) => {",
          "36:   const marked = params.compilationJob.solidityConfig[marker];",
          "37:   const result = await runSuper(params);",
          "38:   if (marked) {",
          "39:     result.output = {",
          "40:       ...result.output,",
          "41:       errors: result.output.errors?.filter(e => e.severity !== 'warning' || e.errorCode !== W_UNREACHABLE_CODE),",
          "42:     };",
          "43:   }",
          "44:   return result;",
          "45: });",
          "",
          "---------------"
        ],
        "hardhat/skip-foundry-tests.js||hardhat/skip-foundry-tests.js": [
          "File: hardhat/skip-foundry-tests.js -> hardhat/skip-foundry-tests.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { subtask } = require('hardhat/config');",
          "2: const { TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS } = require('hardhat/builtin-tasks/task-names');",
          "4: subtask(TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS).setAction(async (_, __, runSuper) =>",
          "5:   (await runSuper()).filter(path => !path.endsWith('.t.sol')),",
          "6: );",
          "",
          "---------------"
        ],
        "hardhat/task-test-get-files.js||hardhat/task-test-get-files.js": [
          "File: hardhat/task-test-get-files.js -> hardhat/task-test-get-files.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { internalTask } = require('hardhat/config');",
          "2: const { TASK_TEST_GET_TEST_FILES } = require('hardhat/builtin-tasks/task-names');",
          "6: internalTask(TASK_TEST_GET_TEST_FILES).setAction(async ({ testFiles }, { config }) => {",
          "7:   if (testFiles.length !== 0) {",
          "8:     return testFiles;",
          "9:   }",
          "11:   const globAsync = require('glob');",
          "12:   const path = require('path');",
          "13:   const { promises: fs } = require('fs');",
          "14:   const { promisify } = require('util');",
          "16:   const glob = promisify(globAsync);",
          "18:   const hasProxies = await fs",
          "19:     .access(path.join(config.paths.sources, 'proxy/Proxy.sol'))",
          "20:     .then(() => true)",
          "21:     .catch(() => false);",
          "23:   return await glob(path.join(config.paths.tests, '**/*.js'), {",
          "24:     ignore: hasProxies",
          "25:       ? []",
          "26:       : [",
          "27:           'proxy/beacon/BeaconProxy.test.js',",
          "28:           'proxy/beacon/UpgradeableBeacon.test.js',",
          "29:           'proxy/ERC1967/ERC1967Proxy.test.js',",
          "30:           'proxy/transparent/ProxyAdmin.test.js',",
          "31:           'proxy/transparent/TransparentUpgradeableProxy.test.js',",
          "32:           'proxy/utils/UUPSUpgradeable.test.js',",
          "33:         ].map(p => path.join(config.paths.tests, p)),",
          "34:   });",
          "35: });",
          "",
          "---------------"
        ],
        "scripts/checks/compare-layout.js||scripts/checks/compare-layout.js": [
          "File: scripts/checks/compare-layout.js -> scripts/checks/compare-layout.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const fs = require('fs');",
          "2: const { getStorageUpgradeReport } = require('@openzeppelin/upgrades-core/dist/storage');",
          "4: const { ref, head } = require('yargs').argv;",
          "6: const oldLayout = JSON.parse(fs.readFileSync(ref));",
          "7: const newLayout = JSON.parse(fs.readFileSync(head));",
          "9: for (const name in oldLayout) {",
          "10:   if (name in newLayout) {",
          "11:     const report = getStorageUpgradeReport(oldLayout[name], newLayout[name], {});",
          "12:     if (!report.ok) {",
          "13:       console.log(report.explain());",
          "14:       process.exitCode = 1;",
          "15:     }",
          "16:   } else {",
          "17:     console.log(`WARNING: ${name} is missing from the current branch`);",
          "18:   }",
          "19: }",
          "",
          "---------------"
        ],
        "scripts/checks/compareGasReports.js||scripts/checks/compareGasReports.js": [
          "File: scripts/checks/compareGasReports.js -> scripts/checks/compareGasReports.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env node",
          "3: const fs = require('fs');",
          "4: const chalk = require('chalk');",
          "5: const { argv } = require('yargs')",
          "6:   .env()",
          "7:   .options({",
          "8:     style: {",
          "9:       type: 'string',",
          "10:       choices: ['shell', 'markdown'],",
          "11:       default: 'shell',",
          "12:     },",
          "13:     hideEqual: {",
          "14:       type: 'boolean',",
          "15:       default: true,",
          "16:     },",
          "17:     strictTesting: {",
          "18:       type: 'boolean',",
          "19:       default: false,",
          "20:     },",
          "21:   });",
          "24: const BASE_TX_COST = 21000;",
          "27: function sum(...args) {",
          "28:   return args.reduce((a, b) => a + b, 0);",
          "29: }",
          "31: function average(...args) {",
          "32:   return sum(...args) / args.length;",
          "33: }",
          "35: function variation(current, previous, offset = 0) {",
          "36:   return {",
          "37:     value: current,",
          "38:     delta: current - previous,",
          "39:     prcnt: (100 * (current - previous)) / (previous - offset),",
          "40:   };",
          "41: }",
          "44: class Report {",
          "46:   static load(filepath) {",
          "47:     return JSON.parse(fs.readFileSync(filepath, 'utf8'));",
          "48:   }",
          "51:   static compare(update, ref, opts = { hideEqual: true, strictTesting: false }) {",
          "52:     if (JSON.stringify(update.config.metadata) !== JSON.stringify(ref.config.metadata)) {",
          "53:       throw new Error('Reports produced with non matching metadata');",
          "54:     }",
          "56:     const deployments = update.info.deployments",
          "57:       .map(contract =>",
          "58:         Object.assign(contract, { previousVersion: ref.info.deployments.find(({ name }) => name === contract.name) }),",
          "59:       )",
          "60:       .filter(contract => contract.gasData?.length && contract.previousVersion?.gasData?.length)",
          "61:       .flatMap(contract => [",
          "62:         {",
          "63:           contract: contract.name,",
          "64:           method: '[bytecode length]',",
          "65:           avg: variation(contract.bytecode.length / 2 - 1, contract.previousVersion.bytecode.length / 2 - 1),",
          "66:         },",
          "67:         {",
          "68:           contract: contract.name,",
          "69:           method: '[construction cost]',",
          "70:           avg: variation(",
          "71:             ...[contract.gasData, contract.previousVersion.gasData].map(x => Math.round(average(...x))),",
          "72:             BASE_TX_COST,",
          "73:           ),",
          "74:         },",
          "75:       ])",
          "76:       .sort((a, b) => `${a.contract}:${a.method}`.localeCompare(`${b.contract}:${b.method}`));",
          "78:     const methods = Object.keys(update.info.methods)",
          "79:       .filter(key => ref.info.methods[key])",
          "80:       .filter(key => update.info.methods[key].numberOfCalls > 0)",
          "81:       .filter(",
          "82:         key => !opts.strictTesting || update.info.methods[key].numberOfCalls === ref.info.methods[key].numberOfCalls,",
          "83:       )",
          "84:       .map(key => ({",
          "85:         contract: ref.info.methods[key].contract,",
          "86:         method: ref.info.methods[key].fnSig,",
          "87:         min: variation(...[update, ref].map(x => Math.min(...x.info.methods[key].gasData)), BASE_TX_COST),",
          "88:         max: variation(...[update, ref].map(x => Math.max(...x.info.methods[key].gasData)), BASE_TX_COST),",
          "89:         avg: variation(...[update, ref].map(x => Math.round(average(...x.info.methods[key].gasData))), BASE_TX_COST),",
          "90:       }))",
          "91:       .sort((a, b) => `${a.contract}:${a.method}`.localeCompare(`${b.contract}:${b.method}`));",
          "93:     return []",
          "94:       .concat(deployments, methods)",
          "95:       .filter(row => !opts.hideEqual || row.min?.delta || row.max?.delta || row.avg?.delta);",
          "96:   }",
          "97: }",
          "100: function center(text, length) {",
          "101:   return text.padStart((text.length + length) / 2).padEnd(length);",
          "102: }",
          "104: function plusSign(num) {",
          "105:   return num > 0 ? '+' : '';",
          "106: }",
          "108: function formatCellShell(cell) {",
          "109:   const format = chalk[cell?.delta > 0 ? 'red' : cell?.delta < 0 ? 'green' : 'reset'];",
          "110:   return [",
          "111:     format((!isFinite(cell?.value) ? '-' : cell.value.toString()).padStart(8)),",
          "112:     format((!isFinite(cell?.delta) ? '-' : plusSign(cell.delta) + cell.delta.toString()).padStart(8)),",
          "113:     format((!isFinite(cell?.prcnt) ? '-' : plusSign(cell.prcnt) + cell.prcnt.toFixed(2) + '%').padStart(8)),",
          "114:   ];",
          "115: }",
          "117: function formatCmpShell(rows) {",
          "118:   const contractLength = Math.max(8, ...rows.map(({ contract }) => contract.length));",
          "119:   const methodLength = Math.max(7, ...rows.map(({ method }) => method.length));",
          "121:   const COLS = [",
          "122:     { txt: '', length: 0 },",
          "123:     { txt: 'Contract', length: contractLength },",
          "124:     { txt: 'Method', length: methodLength },",
          "125:     { txt: 'Min', length: 30 },",
          "126:     { txt: 'Max', length: 30 },",
          "127:     { txt: 'Avg', length: 30 },",
          "128:     { txt: '', length: 0 },",
          "129:   ];",
          "130:   const HEADER = COLS.map(entry => chalk.bold(center(entry.txt, entry.length || 0)))",
          "131:     .join(' | ')",
          "132:     .trim();",
          "133:   const SEPARATOR = COLS.map(({ length }) => (length > 0 ? '-'.repeat(length + 2) : ''))",
          "134:     .join('|')",
          "135:     .trim();",
          "137:   return [",
          "138:     '',",
          "139:     HEADER,",
          "140:     ...rows.map(entry =>",
          "141:       [",
          "142:         '',",
          "143:         chalk.grey(entry.contract.padEnd(contractLength)),",
          "144:         entry.method.padEnd(methodLength),",
          "145:         ...formatCellShell(entry.min),",
          "146:         ...formatCellShell(entry.max),",
          "147:         ...formatCellShell(entry.avg),",
          "148:         '',",
          "149:       ]",
          "150:         .join(' | ')",
          "151:         .trim(),",
          "152:     ),",
          "153:     '',",
          "154:   ]",
          "155:     .join(`\\n${SEPARATOR}\\n`)",
          "156:     .trim();",
          "157: }",
          "159: function alignPattern(align) {",
          "160:   switch (align) {",
          "161:     case 'left':",
          "162:     case undefined:",
          "163:       return ':-';",
          "164:     case 'right':",
          "165:       return '-:';",
          "166:     case 'center':",
          "167:       return ':-:';",
          "168:   }",
          "169: }",
          "171: function trend(value) {",
          "172:   return value > 0 ? ':x:' : value < 0 ? ':heavy_check_mark:' : ':heavy_minus_sign:';",
          "173: }",
          "175: function formatCellMarkdown(cell) {",
          "176:   return [",
          "177:     !isFinite(cell?.value) ? '-' : cell.value.toString(),",
          "178:     !isFinite(cell?.delta) ? '-' : plusSign(cell.delta) + cell.delta.toString(),",
          "179:     !isFinite(cell?.prcnt) ? '-' : plusSign(cell.prcnt) + cell.prcnt.toFixed(2) + '%' + trend(cell.delta),",
          "180:   ];",
          "181: }",
          "183: function formatCmpMarkdown(rows) {",
          "184:   const COLS = [",
          "185:     { txt: '' },",
          "186:     { txt: 'Contract', align: 'left' },",
          "187:     { txt: 'Method', align: 'left' },",
          "188:     { txt: 'Min', align: 'right' },",
          "189:     { txt: '(+/-)', align: 'right' },",
          "190:     { txt: '%', align: 'right' },",
          "191:     { txt: 'Max', align: 'right' },",
          "192:     { txt: '(+/-)', align: 'right' },",
          "193:     { txt: '%', align: 'right' },",
          "194:     { txt: 'Avg', align: 'right' },",
          "195:     { txt: '(+/-)', align: 'right' },",
          "196:     { txt: '%', align: 'right' },",
          "197:     { txt: '' },",
          "198:   ];",
          "199:   const HEADER = COLS.map(entry => entry.txt)",
          "200:     .join(' | ')",
          "201:     .trim();",
          "202:   const SEPARATOR = COLS.map(entry => (entry.txt ? alignPattern(entry.align) : ''))",
          "203:     .join('|')",
          "204:     .trim();",
          "206:   return [",
          "207:     '# Changes to gas costs',",
          "208:     '',",
          "209:     HEADER,",
          "210:     SEPARATOR,",
          "211:     rows",
          "212:       .map(entry =>",
          "213:         [",
          "214:           '',",
          "215:           entry.contract,",
          "216:           entry.method,",
          "217:           ...formatCellMarkdown(entry.min),",
          "218:           ...formatCellMarkdown(entry.max),",
          "219:           ...formatCellMarkdown(entry.avg),",
          "220:           '',",
          "221:         ]",
          "222:           .join(' | ')",
          "223:           .trim(),",
          "224:       )",
          "225:       .join('\\n'),",
          "226:     '',",
          "227:   ]",
          "228:     .join('\\n')",
          "229:     .trim();",
          "230: }",
          "233: const report = Report.compare(Report.load(argv._[0]), Report.load(argv._[1]), argv);",
          "235: switch (argv.style) {",
          "236:   case 'markdown':",
          "237:     console.log(formatCmpMarkdown(report));",
          "238:     break;",
          "239:   case 'shell':",
          "240:   default:",
          "241:     console.log(formatCmpShell(report));",
          "242:     break;",
          "243: }",
          "",
          "---------------"
        ],
        "scripts/checks/extract-layout.js||scripts/checks/extract-layout.js": [
          "File: scripts/checks/extract-layout.js -> scripts/checks/extract-layout.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const fs = require('fs');",
          "2: const { findAll } = require('solidity-ast/utils');",
          "3: const { astDereferencer } = require('@openzeppelin/upgrades-core/dist/ast-dereferencer');",
          "4: const { solcInputOutputDecoder } = require('@openzeppelin/upgrades-core/dist/src-decoder');",
          "5: const { extractStorageLayout } = require('@openzeppelin/upgrades-core/dist/storage/extract');",
          "7: const { _ } = require('yargs').argv;",
          "9: const skipPath = ['contracts/mocks/', 'contracts-exposed/'];",
          "10: const skipKind = ['interface', 'library'];",
          "12: function extractLayouts(path) {",
          "13:   const layout = {};",
          "14:   const { input, output } = JSON.parse(fs.readFileSync(path));",
          "16:   const decoder = solcInputOutputDecoder(input, output);",
          "17:   const deref = astDereferencer(output);",
          "19:   for (const src in output.contracts) {",
          "20:     if (skipPath.some(prefix => src.startsWith(prefix))) {",
          "21:       continue;",
          "22:     }",
          "24:     for (const contractDef of findAll('ContractDefinition', output.sources[src].ast)) {",
          "25:       if (skipKind.includes(contractDef.contractKind)) {",
          "26:         continue;",
          "27:       }",
          "29:       layout[contractDef.name] = extractStorageLayout(",
          "30:         contractDef,",
          "31:         decoder,",
          "32:         deref,",
          "33:         output.contracts[src][contractDef.name].storageLayout,",
          "34:       );",
          "35:     }",
          "36:   }",
          "37:   return layout;",
          "38: }",
          "40: console.log(JSON.stringify(Object.assign(..._.map(extractLayouts))));",
          "",
          "---------------"
        ],
        "scripts/checks/generation.sh||scripts/checks/generation.sh": [
          "File: scripts/checks/generation.sh -> scripts/checks/generation.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail",
          "5: npm run generate",
          "6: git diff -R --exit-code",
          "",
          "---------------"
        ],
        "scripts/checks/inheritance-ordering.js||scripts/checks/inheritance-ordering.js": [
          "File: scripts/checks/inheritance-ordering.js -> scripts/checks/inheritance-ordering.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env node",
          "3: const path = require('path');",
          "4: const graphlib = require('graphlib');",
          "5: const { findAll } = require('solidity-ast/utils');",
          "6: const { _: artifacts } = require('yargs').argv;",
          "8: for (const artifact of artifacts) {",
          "9:   const { output: solcOutput } = require(path.resolve(__dirname, '../..', artifact));",
          "11:   const graph = new graphlib.Graph({ directed: true });",
          "12:   const names = {};",
          "13:   const linearized = [];",
          "15:   for (const source in solcOutput.contracts) {",
          "16:     if (source.includes('/mocks/')) {",
          "17:       continue;",
          "18:     }",
          "20:     for (const contractDef of findAll('ContractDefinition', solcOutput.sources[source].ast)) {",
          "21:       names[contractDef.id] = contractDef.name;",
          "22:       linearized.push(contractDef.linearizedBaseContracts);",
          "24:       contractDef.linearizedBaseContracts.forEach((c1, i, contracts) =>",
          "25:         contracts.slice(i + 1).forEach(c2 => {",
          "26:           graph.setEdge(c1, c2);",
          "27:         }),",
          "28:       );",
          "29:     }",
          "30:   }",
          "34:   graph.nodes().forEach((x, i, nodes) =>",
          "35:     nodes",
          "36:       .slice(i + 1)",
          "37:       .filter(y => graph.hasEdge(x, y) && graph.hasEdge(y, x))",
          "38:       .forEach(y => {",
          "39:         console.log(`Conflict between ${names[x]} and ${names[y]} detected in the following dependency chains:`);",
          "40:         linearized",
          "41:           .filter(chain => chain.includes(parseInt(x)) && chain.includes(parseInt(y)))",
          "42:           .forEach(chain => {",
          "43:             const comp = chain.indexOf(parseInt(x)) < chain.indexOf(parseInt(y)) ? '>' : '<';",
          "44:             console.log(`- ${names[x]} ${comp} ${names[y]} in ${names[chain.find(Boolean)]}`);",
          "46:           });",
          "47:         process.exitCode = 1;",
          "48:       }),",
          "49:   );",
          "50: }",
          "52: if (!process.exitCode) {",
          "53:   console.log('Contract ordering is consistent.');",
          "54: }",
          "",
          "---------------"
        ],
        "scripts/gen-nav.js||scripts/gen-nav.js": [
          "File: scripts/gen-nav.js -> scripts/gen-nav.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env node",
          "3: const path = require('path');",
          "4: const glob = require('glob');",
          "5: const startCase = require('lodash.startcase');",
          "7: const baseDir = process.argv[2];",
          "9: const files = glob.sync(baseDir + '/**/*.adoc').map(f => path.relative(baseDir, f));",
          "11: console.log('.API');",
          "13: function getPageTitle(directory) {",
          "14:   switch (directory) {",
          "15:     case 'metatx':",
          "16:       return 'Meta Transactions';",
          "17:     case 'common':",
          "18:       return 'Common (Tokens)';",
          "19:     default:",
          "20:       return startCase(directory);",
          "21:   }",
          "22: }",
          "24: const links = files.map(file => {",
          "25:   const doc = file.replace(baseDir, '');",
          "26:   const title = path.parse(file).name;",
          "28:   return {",
          "29:     xref: `* xref:${doc}[${getPageTitle(title)}]`,",
          "30:     title,",
          "31:   };",
          "32: });",
          "35: const sortedLinks = links.sort(function (a, b) {",
          "36:   return a.title.toLowerCase().localeCompare(b.title.toLowerCase(), undefined, { numeric: true });",
          "37: });",
          "39: for (const link of sortedLinks) {",
          "40:   console.log(link.xref);",
          "41: }",
          "",
          "---------------"
        ],
        "scripts/generate/format-lines.js||scripts/generate/format-lines.js": [
          "File: scripts/generate/format-lines.js -> scripts/generate/format-lines.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: function formatLines(...lines) {",
          "2:   return [...indentEach(0, lines)].join('\\n') + '\\n';",
          "3: }",
          "5: function* indentEach(indent, lines) {",
          "6:   for (const line of lines) {",
          "7:     if (Array.isArray(line)) {",
          "8:       yield* indentEach(indent + 1, line);",
          "9:     } else {",
          "10:       const padding = '    '.repeat(indent);",
          "11:       yield* line.split('\\n').map(subline => (subline === '' ? '' : padding + subline));",
          "12:     }",
          "13:   }",
          "14: }",
          "16: module.exports = formatLines;",
          "",
          "---------------"
        ],
        "scripts/generate/run.js||scripts/generate/run.js": [
          "File: scripts/generate/run.js -> scripts/generate/run.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env node",
          "3: const cp = require('child_process');",
          "4: const fs = require('fs');",
          "5: const path = require('path');",
          "6: const format = require('./format-lines');",
          "8: function getVersion(path) {",
          "9:   try {",
          "10:     return fs.readFileSync(path, 'utf8').match(/\\/\\/ OpenZeppelin Contracts \\(last updated v[^)]+\\)/)[0];",
          "11:   } catch (err) {",
          "12:     return null;",
          "13:   }",
          "14: }",
          "16: function generateFromTemplate(file, template, outputPrefix = '') {",
          "17:   const script = path.relative(path.join(__dirname, '../..'), __filename);",
          "18:   const input = path.join(path.dirname(script), template);",
          "19:   const output = path.join(outputPrefix, file);",
          "20:   const version = getVersion(output);",
          "21:   const content = format(",
          "22:     '// SPDX-License-Identifier: MIT',",
          "23:     ...(version ? [version + ` (${file})`] : []),",
          "24:     `// This file was procedurally generated from ${input}.`,",
          "25:     '',",
          "26:     require(template),",
          "27:   );",
          "29:   fs.writeFileSync(output, content);",
          "30:   cp.execFileSync('prettier', ['--write', output]);",
          "31: }",
          "34: for (const [file, template] of Object.entries({",
          "35:   'utils/math/SafeCast.sol': './templates/SafeCast.js',",
          "36:   'utils/structs/EnumerableSet.sol': './templates/EnumerableSet.js',",
          "37:   'utils/structs/EnumerableMap.sol': './templates/EnumerableMap.js',",
          "38:   'utils/Checkpoints.sol': './templates/Checkpoints.js',",
          "39:   'utils/StorageSlot.sol': './templates/StorageSlot.js',",
          "40: })) {",
          "41:   generateFromTemplate(file, template, './contracts/');",
          "42: }",
          "45: for (const [file, template] of Object.entries({",
          "46:   'utils/Checkpoints.t.sol': './templates/Checkpoints.t.js',",
          "47: })) {",
          "48:   generateFromTemplate(file, template, './test/');",
          "49: }",
          "",
          "---------------"
        ],
        "scripts/generate/templates/Checkpoints.js||scripts/generate/templates/Checkpoints.js": [
          "File: scripts/generate/templates/Checkpoints.js -> scripts/generate/templates/Checkpoints.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const format = require('../format-lines');",
          "2: const { OPTS, LEGACY_OPTS } = require('./Checkpoints.opts.js');",
          "5: const header = `\\",
          "6: pragma solidity ^0.8.0;",
          "8: import \"./math/Math.sol\";",
          "9: import \"./math/SafeCast.sol\";",
          "20: `;",
          "22: const types = opts => `\\",
          "23: struct ${opts.historyTypeName} {",
          "24:     ${opts.checkpointTypeName}[] ${opts.checkpointFieldName};",
          "25: }",
          "27: struct ${opts.checkpointTypeName} {",
          "28:     ${opts.keyTypeName} ${opts.keyFieldName};",
          "29:     ${opts.valueTypeName} ${opts.valueFieldName};",
          "30: }",
          "31: `;",
          "34: const operations = opts => `\\",
          "40: function push(",
          "41:     ${opts.historyTypeName} storage self,",
          "42:     ${opts.keyTypeName} key,",
          "43:     ${opts.valueTypeName} value",
          "44: ) internal returns (${opts.valueTypeName}, ${opts.valueTypeName}) {",
          "45:     return _insert(self.${opts.checkpointFieldName}, key, value);",
          "46: }",
          "51: function lowerLookup(${opts.historyTypeName} storage self, ${opts.keyTypeName} key) internal view returns (${opts.valueTypeName}) {",
          "52:     uint256 len = self.${opts.checkpointFieldName}.length;",
          "53:     uint256 pos = _lowerBinaryLookup(self.${opts.checkpointFieldName}, key, 0, len);",
          "54:     return pos == len ? 0 : _unsafeAccess(self.${opts.checkpointFieldName}, pos).${opts.valueFieldName};",
          "55: }",
          "60: function upperLookup(${opts.historyTypeName} storage self, ${opts.keyTypeName} key) internal view returns (${opts.valueTypeName}) {",
          "61:     uint256 len = self.${opts.checkpointFieldName}.length;",
          "62:     uint256 pos = _upperBinaryLookup(self.${opts.checkpointFieldName}, key, 0, len);",
          "63:     return pos == 0 ? 0 : _unsafeAccess(self.${opts.checkpointFieldName}, pos - 1).${opts.valueFieldName};",
          "64: }",
          "71: function upperLookupRecent(${opts.historyTypeName} storage self, ${opts.keyTypeName} key) internal view returns (${opts.valueTypeName}) {",
          "72:     uint256 len = self.${opts.checkpointFieldName}.length;",
          "74:     uint256 low = 0;",
          "75:     uint256 high = len;",
          "77:     if (len > 5) {",
          "78:         uint256 mid = len - Math.sqrt(len);",
          "79:         if (key < _unsafeAccess(self.${opts.checkpointFieldName}, mid)._key) {",
          "80:             high = mid;",
          "81:         } else {",
          "82:             low = mid + 1;",
          "83:         }",
          "84:     }",
          "86:     uint256 pos = _upperBinaryLookup(self.${opts.checkpointFieldName}, key, low, high);",
          "88:     return pos == 0 ? 0 : _unsafeAccess(self.${opts.checkpointFieldName}, pos - 1).${opts.valueFieldName};",
          "89: }",
          "90: `;",
          "92: const legacyOperations = opts => `\\",
          "98: function getAtBlock(${opts.historyTypeName} storage self, uint256 blockNumber) internal view returns (uint256) {",
          "99:     require(blockNumber < block.number, \"Checkpoints: block not yet mined\");",
          "100:     uint32 key = SafeCast.toUint32(blockNumber);",
          "102:     uint256 len = self.${opts.checkpointFieldName}.length;",
          "103:     uint256 pos = _upperBinaryLookup(self.${opts.checkpointFieldName}, key, 0, len);",
          "104:     return pos == 0 ? 0 : _unsafeAccess(self.${opts.checkpointFieldName}, pos - 1).${opts.valueFieldName};",
          "105: }",
          "113: function getAtProbablyRecentBlock(${opts.historyTypeName} storage self, uint256 blockNumber) internal view returns (uint256) {",
          "114:     require(blockNumber < block.number, \"Checkpoints: block not yet mined\");",
          "115:     uint32 key = SafeCast.toUint32(blockNumber);",
          "117:     uint256 len = self.${opts.checkpointFieldName}.length;",
          "119:     uint256 low = 0;",
          "120:     uint256 high = len;",
          "122:     if (len > 5) {",
          "123:         uint256 mid = len - Math.sqrt(len);",
          "124:         if (key < _unsafeAccess(self.${opts.checkpointFieldName}, mid)._blockNumber) {",
          "125:             high = mid;",
          "126:         } else {",
          "127:             low = mid + 1;",
          "128:         }",
          "129:     }",
          "131:     uint256 pos = _upperBinaryLookup(self.${opts.checkpointFieldName}, key, low, high);",
          "133:     return pos == 0 ? 0 : _unsafeAccess(self.${opts.checkpointFieldName}, pos - 1).${opts.valueFieldName};",
          "134: }",
          "141: function push(${opts.historyTypeName} storage self, uint256 value) internal returns (uint256, uint256) {",
          "142:     return _insert(self.${opts.checkpointFieldName}, SafeCast.toUint32(block.number), SafeCast.toUint224(value));",
          "143: }",
          "151: function push(",
          "152:     ${opts.historyTypeName} storage self,",
          "153:     function(uint256, uint256) view returns (uint256) op,",
          "154:     uint256 delta",
          "155: ) internal returns (uint256, uint256) {",
          "156:     return push(self, op(latest(self), delta));",
          "157: }",
          "158: `;",
          "160: const common = opts => `\\",
          "164: function latest(${opts.historyTypeName} storage self) internal view returns (${opts.valueTypeName}) {",
          "165:     uint256 pos = self.${opts.checkpointFieldName}.length;",
          "166:     return pos == 0 ? 0 : _unsafeAccess(self.${opts.checkpointFieldName}, pos - 1).${opts.valueFieldName};",
          "167: }",
          "173: function latestCheckpoint(${opts.historyTypeName} storage self)",
          "174:     internal",
          "175:     view",
          "176:     returns (",
          "177:         bool exists,",
          "178:         ${opts.keyTypeName} ${opts.keyFieldName},",
          "179:         ${opts.valueTypeName} ${opts.valueFieldName}",
          "180:     )",
          "181: {",
          "182:     uint256 pos = self.${opts.checkpointFieldName}.length;",
          "183:     if (pos == 0) {",
          "184:         return (false, 0, 0);",
          "185:     } else {",
          "186:         ${opts.checkpointTypeName} memory ckpt = _unsafeAccess(self.${opts.checkpointFieldName}, pos - 1);",
          "187:         return (true, ckpt.${opts.keyFieldName}, ckpt.${opts.valueFieldName});",
          "188:     }",
          "189: }",
          "194: function length(${opts.historyTypeName} storage self) internal view returns (uint256) {",
          "195:     return self.${opts.checkpointFieldName}.length;",
          "196: }",
          "202: function _insert(",
          "203:     ${opts.checkpointTypeName}[] storage self,",
          "204:     ${opts.keyTypeName} key,",
          "205:     ${opts.valueTypeName} value",
          "206: ) private returns (${opts.valueTypeName}, ${opts.valueTypeName}) {",
          "207:     uint256 pos = self.length;",
          "209:     if (pos > 0) {",
          "211:         ${opts.checkpointTypeName} memory last = _unsafeAccess(self, pos - 1);",
          "214:         require(last.${opts.keyFieldName} <= key, \"Checkpoint: decreasing keys\");",
          "217:         if (last.${opts.keyFieldName} == key) {",
          "218:             _unsafeAccess(self, pos - 1).${opts.valueFieldName} = value;",
          "219:         } else {",
          "220:             self.push(${opts.checkpointTypeName}({${opts.keyFieldName}: key, ${opts.valueFieldName}: value}));",
          "221:         }",
          "222:         return (last.${opts.valueFieldName}, value);",
          "223:     } else {",
          "224:         self.push(${opts.checkpointTypeName}({${opts.keyFieldName}: key, ${opts.valueFieldName}: value}));",
          "225:         return (0, value);",
          "226:     }",
          "227: }",
          "235: function _upperBinaryLookup(",
          "236:     ${opts.checkpointTypeName}[] storage self,",
          "237:     ${opts.keyTypeName} key,",
          "238:     uint256 low,",
          "239:     uint256 high",
          "240: ) private view returns (uint256) {",
          "241:     while (low < high) {",
          "242:         uint256 mid = Math.average(low, high);",
          "243:         if (_unsafeAccess(self, mid).${opts.keyFieldName} > key) {",
          "244:             high = mid;",
          "245:         } else {",
          "246:             low = mid + 1;",
          "247:         }",
          "248:     }",
          "249:     return high;",
          "250: }",
          "258: function _lowerBinaryLookup(",
          "259:     ${opts.checkpointTypeName}[] storage self,",
          "260:     ${opts.keyTypeName} key,",
          "261:     uint256 low,",
          "262:     uint256 high",
          "263: ) private view returns (uint256) {",
          "264:     while (low < high) {",
          "265:         uint256 mid = Math.average(low, high);",
          "266:         if (_unsafeAccess(self, mid).${opts.keyFieldName} < key) {",
          "267:             low = mid + 1;",
          "268:         } else {",
          "269:             high = mid;",
          "270:         }",
          "271:     }",
          "272:     return high;",
          "273: }",
          "278: function _unsafeAccess(${opts.checkpointTypeName}[] storage self, uint256 pos)",
          "279:     private",
          "280:     pure",
          "281:     returns (${opts.checkpointTypeName} storage result)",
          "282: {",
          "283:     assembly {",
          "284:         mstore(0, self.slot)",
          "285:         result.slot := add(keccak256(0, 0x20), pos)",
          "286:     }",
          "287: }",
          "288: `;",
          "292: module.exports = format(",
          "293:   header.trimEnd(),",
          "294:   'library Checkpoints {',",
          "295:   [",
          "297:     types(LEGACY_OPTS),",
          "298:     legacyOperations(LEGACY_OPTS),",
          "299:     common(LEGACY_OPTS),",
          "301:     ...OPTS.flatMap(opts => [types(opts), operations(opts), common(opts)]),",
          "302:   ],",
          "303:   '}',",
          "304: );",
          "",
          "---------------"
        ],
        "scripts/generate/templates/Checkpoints.opts.js||scripts/generate/templates/Checkpoints.opts.js": [
          "File: scripts/generate/templates/Checkpoints.opts.js -> scripts/generate/templates/Checkpoints.opts.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: const VALUE_SIZES = [224, 160];",
          "4: const defaultOpts = size => ({",
          "5:   historyTypeName: `Trace${size}`,",
          "6:   checkpointTypeName: `Checkpoint${size}`,",
          "7:   checkpointFieldName: '_checkpoints',",
          "8:   keyTypeName: `uint${256 - size}`,",
          "9:   keyFieldName: '_key',",
          "10:   valueTypeName: `uint${size}`,",
          "11:   valueFieldName: '_value',",
          "12: });",
          "14: module.exports = {",
          "15:   OPTS: VALUE_SIZES.map(size => defaultOpts(size)),",
          "16:   LEGACY_OPTS: {",
          "17:     ...defaultOpts(224),",
          "18:     historyTypeName: 'History',",
          "19:     checkpointTypeName: 'Checkpoint',",
          "20:     keyFieldName: '_blockNumber',",
          "21:   },",
          "22: };",
          "",
          "---------------"
        ],
        "scripts/generate/templates/Checkpoints.t.js||scripts/generate/templates/Checkpoints.t.js": [
          "File: scripts/generate/templates/Checkpoints.t.js -> scripts/generate/templates/Checkpoints.t.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const format = require('../format-lines');",
          "2: const { capitalize } = require('../../helpers');",
          "3: const { OPTS, LEGACY_OPTS } = require('./Checkpoints.opts.js');",
          "6: const header = `\\",
          "7: pragma solidity ^0.8.0;",
          "9: import \"forge-std/Test.sol\";",
          "10: import \"../../contracts/utils/Checkpoints.sol\";",
          "11: import \"../../contracts/utils/math/SafeCast.sol\";",
          "12: `;",
          "15: const common = opts => `\\",
          "16: using Checkpoints for Checkpoints.${opts.historyTypeName};",
          "20: uint8 internal constant _KEY_MAX_GAP = 64;",
          "22: Checkpoints.${opts.historyTypeName} internal _ckpts;",
          "25: function _bound${capitalize(opts.keyTypeName)}(",
          "26:     ${opts.keyTypeName} x,",
          "27:     ${opts.keyTypeName} min,",
          "28:     ${opts.keyTypeName} max",
          "29: ) internal view returns (${opts.keyTypeName}) {",
          "30:     return SafeCast.to${capitalize(opts.keyTypeName)}(bound(uint256(x), uint256(min), uint256(max)));",
          "31: }",
          "33: function _prepareKeys(",
          "34:     ${opts.keyTypeName}[] memory keys,",
          "35:     ${opts.keyTypeName} maxSpread",
          "36: ) internal view {",
          "37:     ${opts.keyTypeName} lastKey = 0;",
          "38:     for (uint256 i = 0; i < keys.length; ++i) {",
          "39:         ${opts.keyTypeName} key = _bound${capitalize(opts.keyTypeName)}(keys[i], lastKey, lastKey + maxSpread);",
          "40:         keys[i] = key;",
          "41:         lastKey = key;",
          "42:     }",
          "43: }",
          "45: function _assertLatestCheckpoint(",
          "46:     bool exist,",
          "47:     ${opts.keyTypeName} key,",
          "48:     ${opts.valueTypeName} value",
          "49: ) internal {",
          "50:     (bool _exist, ${opts.keyTypeName} _key, ${opts.valueTypeName} _value) = _ckpts.latestCheckpoint();",
          "51:     assertEq(_exist, exist);",
          "52:     assertEq(_key, key);",
          "53:     assertEq(_value, value);",
          "54: }",
          "55: `;",
          "57: const testTrace = opts => `\\",
          "59: function testPush(",
          "60:     ${opts.keyTypeName}[] memory keys,",
          "61:     ${opts.valueTypeName}[] memory values,",
          "62:     ${opts.keyTypeName} pastKey",
          "63: ) public {",
          "64:     vm.assume(values.length > 0 && values.length <= keys.length);",
          "65:     _prepareKeys(keys, _KEY_MAX_GAP);",
          "68:     assertEq(_ckpts.length(), 0);",
          "69:     assertEq(_ckpts.latest(), 0);",
          "70:     _assertLatestCheckpoint(false, 0, 0);",
          "72:     uint256 duplicates = 0;",
          "73:     for (uint256 i = 0; i < keys.length; ++i) {",
          "74:         ${opts.keyTypeName} key = keys[i];",
          "75:         ${opts.valueTypeName} value = values[i % values.length];",
          "76:         if (i > 0 && key == keys[i-1]) ++duplicates;",
          "79:         _ckpts.push(key, value);",
          "82:         assertEq(_ckpts.length(), i + 1 - duplicates);",
          "83:         assertEq(_ckpts.latest(), value);",
          "84:         _assertLatestCheckpoint(true, key, value);",
          "85:     }",
          "87:     if (keys.length > 0) {",
          "88:         ${opts.keyTypeName} lastKey = keys[keys.length - 1];",
          "89:         if (lastKey > 0) {",
          "90:             pastKey = _bound${capitalize(opts.keyTypeName)}(pastKey, 0, lastKey - 1);",
          "92:             vm.expectRevert();",
          "93:             this.push(pastKey, values[keys.length % values.length]);",
          "94:         }",
          "95:     }",
          "96: }",
          "99: function push(${opts.keyTypeName} key, ${opts.valueTypeName} value) external {",
          "100:   _ckpts.push(key, value);",
          "101: }",
          "103: function testLookup(",
          "104:     ${opts.keyTypeName}[] memory keys,",
          "105:     ${opts.valueTypeName}[] memory values,",
          "106:     ${opts.keyTypeName} lookup",
          "107: ) public {",
          "108:     vm.assume(values.length > 0 && values.length <= keys.length);",
          "109:     _prepareKeys(keys, _KEY_MAX_GAP);",
          "111:     ${opts.keyTypeName} lastKey = keys.length == 0 ? 0 : keys[keys.length - 1];",
          "112:     lookup = _bound${capitalize(opts.keyTypeName)}(lookup, 0, lastKey + _KEY_MAX_GAP);",
          "114:     ${opts.valueTypeName} upper = 0;",
          "115:     ${opts.valueTypeName} lower = 0;",
          "116:     ${opts.keyTypeName} lowerKey = type(${opts.keyTypeName}).max;",
          "117:     for (uint256 i = 0; i < keys.length; ++i) {",
          "118:         ${opts.keyTypeName} key = keys[i];",
          "119:         ${opts.valueTypeName} value = values[i % values.length];",
          "122:         _ckpts.push(key, value);",
          "125:         if (key <= lookup) {",
          "126:             upper = value;",
          "127:         }",
          "129:         if (key >= lookup && (i == 0 || keys[i-1] < lookup)) {",
          "130:             lowerKey = key;",
          "131:         }",
          "132:         if (key == lowerKey) {",
          "133:             lower = value;",
          "134:         }",
          "135:     }",
          "138:     assertEq(_ckpts.lowerLookup(lookup), lower);",
          "139:     assertEq(_ckpts.upperLookup(lookup), upper);",
          "140:     assertEq(_ckpts.upperLookupRecent(lookup), upper);",
          "141: }",
          "142: `;",
          "144: const testHistory = opts => `\\",
          "146: function testPush(",
          "147:     ${opts.keyTypeName}[] memory keys,",
          "148:     ${opts.valueTypeName}[] memory values,",
          "149:     ${opts.keyTypeName} pastKey",
          "150: ) public {",
          "151:     vm.assume(values.length > 0 && values.length <= keys.length);",
          "152:     _prepareKeys(keys, _KEY_MAX_GAP);",
          "155:     assertEq(_ckpts.length(), 0);",
          "156:     assertEq(_ckpts.latest(), 0);",
          "157:     _assertLatestCheckpoint(false, 0, 0);",
          "159:     uint256 duplicates = 0;",
          "160:     for (uint256 i = 0; i < keys.length; ++i) {",
          "161:         ${opts.keyTypeName} key = keys[i];",
          "162:         ${opts.valueTypeName} value = values[i % values.length];",
          "163:         if (i > 0 && key == keys[i - 1]) ++duplicates;",
          "166:         vm.roll(key);",
          "167:         _ckpts.push(value);",
          "170:         assertEq(_ckpts.length(), i + 1 - duplicates);",
          "171:         assertEq(_ckpts.latest(), value);",
          "172:         _assertLatestCheckpoint(true, key, value);",
          "173:     }",
          "176:     if (keys.length > 0) {",
          "177:         ${opts.keyTypeName} lastKey = keys[keys.length - 1];",
          "178:         if (lastKey > 0) {",
          "179:             pastKey = _bound${capitalize(opts.keyTypeName)}(pastKey, 0, lastKey - 1);",
          "181:             vm.roll(pastKey);",
          "182:             vm.expectRevert();",
          "183:             this.push(values[keys.length % values.length]);",
          "184:         }",
          "185:     }",
          "186: }",
          "189: function push(${opts.valueTypeName} value) external {",
          "190:   _ckpts.push(value);",
          "191: }",
          "193: function testLookup(",
          "194:     ${opts.keyTypeName}[] memory keys,",
          "195:     ${opts.valueTypeName}[] memory values,",
          "196:     ${opts.keyTypeName} lookup",
          "197: ) public {",
          "198:     vm.assume(keys.length > 0);",
          "199:     vm.assume(values.length > 0 && values.length <= keys.length);",
          "200:     _prepareKeys(keys, _KEY_MAX_GAP);",
          "202:     ${opts.keyTypeName} lastKey = keys[keys.length - 1];",
          "203:     vm.assume(lastKey > 0);",
          "204:     lookup = _bound${capitalize(opts.keyTypeName)}(lookup, 0, lastKey - 1);",
          "206:     ${opts.valueTypeName} upper = 0;",
          "207:     for (uint256 i = 0; i < keys.length; ++i) {",
          "208:         ${opts.keyTypeName} key = keys[i];",
          "209:         ${opts.valueTypeName} value = values[i % values.length];",
          "212:         vm.roll(key);",
          "213:         _ckpts.push(value);",
          "216:         if (key <= lookup) {",
          "217:             upper = value;",
          "218:         }",
          "219:     }",
          "222:     assertEq(_ckpts.getAtBlock(lookup), upper);",
          "223:     assertEq(_ckpts.getAtProbablyRecentBlock(lookup), upper);",
          "225:     vm.expectRevert(); this.getAtBlock(lastKey);",
          "226:     vm.expectRevert(); this.getAtBlock(lastKey + 1);",
          "227:     vm.expectRevert(); this.getAtProbablyRecentBlock(lastKey);",
          "228:     vm.expectRevert(); this.getAtProbablyRecentBlock(lastKey + 1);",
          "229: }",
          "232: function getAtBlock(${opts.keyTypeName} key) external view {",
          "233:   _ckpts.getAtBlock(key);",
          "234: }",
          "237: function getAtProbablyRecentBlock(${opts.keyTypeName} key) external view {",
          "238:   _ckpts.getAtProbablyRecentBlock(key);",
          "239: }",
          "240: `;",
          "244: module.exports = format(",
          "245:   header,",
          "247:   `contract Checkpoints${LEGACY_OPTS.historyTypeName}Test is Test {`,",
          "248:   [common(LEGACY_OPTS), testHistory(LEGACY_OPTS)],",
          "249:   '}',",
          "251:   ...OPTS.flatMap(opts => [",
          "252:     `contract Checkpoints${opts.historyTypeName}Test is Test {`,",
          "253:     [common(opts), testTrace(opts)],",
          "254:     '}',",
          "255:   ]),",
          "256: );",
          "",
          "---------------"
        ],
        "scripts/generate/templates/EnumerableMap.js||scripts/generate/templates/EnumerableMap.js": [
          "File: scripts/generate/templates/EnumerableMap.js -> scripts/generate/templates/EnumerableMap.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const format = require('../format-lines');",
          "2: const { fromBytes32, toBytes32 } = require('./conversion');",
          "4: const TYPES = [",
          "5:   { name: 'UintToUintMap', keyType: 'uint256', valueType: 'uint256' },",
          "6:   { name: 'UintToAddressMap', keyType: 'uint256', valueType: 'address' },",
          "7:   { name: 'AddressToUintMap', keyType: 'address', valueType: 'uint256' },",
          "8:   { name: 'Bytes32ToUintMap', keyType: 'bytes32', valueType: 'uint256' },",
          "9: ];",
          "12: const header = `\\",
          "13: pragma solidity ^0.8.0;",
          "15: import \"./EnumerableSet.sol\";",
          "56: `;",
          "59: const defaultMap = () => `\\",
          "69: struct Bytes32ToBytes32Map {",
          "71:     EnumerableSet.Bytes32Set _keys;",
          "72:     mapping(bytes32 => bytes32) _values;",
          "73: }",
          "82: function set(",
          "83:     Bytes32ToBytes32Map storage map,",
          "84:     bytes32 key,",
          "85:     bytes32 value",
          "86: ) internal returns (bool) {",
          "87:     map._values[key] = value;",
          "88:     return map._keys.add(key);",
          "89: }",
          "96: function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {",
          "97:     delete map._values[key];",
          "98:     return map._keys.remove(key);",
          "99: }",
          "104: function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {",
          "105:     return map._keys.contains(key);",
          "106: }",
          "111: function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {",
          "112:     return map._keys.length();",
          "113: }",
          "125: function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {",
          "126:     bytes32 key = map._keys.at(index);",
          "127:     return (key, map._values[key]);",
          "128: }",
          "134: function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {",
          "135:     bytes32 value = map._values[key];",
          "136:     if (value == bytes32(0)) {",
          "137:         return (contains(map, key), bytes32(0));",
          "138:     } else {",
          "139:         return (true, value);",
          "140:     }",
          "141: }",
          "150: function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {",
          "151:     bytes32 value = map._values[key];",
          "152:     require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");",
          "153:     return value;",
          "154: }",
          "162: function get(",
          "163:     Bytes32ToBytes32Map storage map,",
          "164:     bytes32 key,",
          "165:     string memory errorMessage",
          "166: ) internal view returns (bytes32) {",
          "167:     bytes32 value = map._values[key];",
          "168:     require(value != 0 || contains(map, key), errorMessage);",
          "169:     return value;",
          "170: }",
          "180: function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {",
          "181:     return map._keys.values();",
          "182: }",
          "183: `;",
          "185: const customMap = ({ name, keyType, valueType }) => `\\",
          "188: struct ${name} {",
          "189:     Bytes32ToBytes32Map _inner;",
          "190: }",
          "199: function set(",
          "200:     ${name} storage map,",
          "201:     ${keyType} key,",
          "202:     ${valueType} value",
          "203: ) internal returns (bool) {",
          "204:     return set(map._inner, ${toBytes32(keyType, 'key')}, ${toBytes32(valueType, 'value')});",
          "205: }",
          "212: function remove(${name} storage map, ${keyType} key) internal returns (bool) {",
          "213:     return remove(map._inner, ${toBytes32(keyType, 'key')});",
          "214: }",
          "219: function contains(${name} storage map, ${keyType} key) internal view returns (bool) {",
          "220:     return contains(map._inner, ${toBytes32(keyType, 'key')});",
          "221: }",
          "226: function length(${name} storage map) internal view returns (uint256) {",
          "227:     return length(map._inner);",
          "228: }",
          "239: function at(${name} storage map, uint256 index) internal view returns (${keyType}, ${valueType}) {",
          "240:     (bytes32 key, bytes32 value) = at(map._inner, index);",
          "241:     return (${fromBytes32(keyType, 'key')}, ${fromBytes32(valueType, 'value')});",
          "242: }",
          "248: function tryGet(${name} storage map, ${keyType} key) internal view returns (bool, ${valueType}) {",
          "249:     (bool success, bytes32 value) = tryGet(map._inner, ${toBytes32(keyType, 'key')});",
          "250:     return (success, ${fromBytes32(valueType, 'value')});",
          "251: }",
          "260: function get(${name} storage map, ${keyType} key) internal view returns (${valueType}) {",
          "261:     return ${fromBytes32(valueType, `get(map._inner, ${toBytes32(keyType, 'key')})`)};",
          "262: }",
          "270: function get(",
          "271:     ${name} storage map,",
          "272:     ${keyType} key,",
          "273:     string memory errorMessage",
          "274: ) internal view returns (${valueType}) {",
          "275:     return ${fromBytes32(valueType, `get(map._inner, ${toBytes32(keyType, 'key')}, errorMessage)`)};",
          "276: }",
          "286: function keys(${name} storage map) internal view returns (${keyType}[] memory) {",
          "287:     bytes32[] memory store = keys(map._inner);",
          "288:     ${keyType}[] memory result;",
          "291:     assembly {",
          "292:         result := store",
          "293:     }",
          "295:     return result;",
          "296: }",
          "297: `;",
          "300: module.exports = format(",
          "301:   header.trimEnd(),",
          "302:   'library EnumerableMap {',",
          "303:   [",
          "304:     'using EnumerableSet for EnumerableSet.Bytes32Set;',",
          "305:     '',",
          "306:     defaultMap(),",
          "307:     TYPES.map(details => customMap(details).trimEnd()).join('\\n\\n'),",
          "308:   ],",
          "309:   '}',",
          "310: );",
          "",
          "---------------"
        ],
        "scripts/generate/templates/EnumerableSet.js||scripts/generate/templates/EnumerableSet.js": [
          "File: scripts/generate/templates/EnumerableSet.js -> scripts/generate/templates/EnumerableSet.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const format = require('../format-lines');",
          "2: const { fromBytes32, toBytes32 } = require('./conversion');",
          "4: const TYPES = [",
          "5:   { name: 'Bytes32Set', type: 'bytes32' },",
          "6:   { name: 'AddressSet', type: 'address' },",
          "7:   { name: 'UintSet', type: 'uint256' },",
          "8: ];",
          "11: const header = `\\",
          "12: pragma solidity ^0.8.0;",
          "48: `;",
          "51: const defaultSet = () => `\\",
          "61: struct Set {",
          "63:     bytes32[] _values;",
          "66:     mapping(bytes32 => uint256) _indexes;",
          "67: }",
          "75: function _add(Set storage set, bytes32 value) private returns (bool) {",
          "76:     if (!_contains(set, value)) {",
          "77:         set._values.push(value);",
          "80:         set._indexes[value] = set._values.length;",
          "81:         return true;",
          "82:     } else {",
          "83:         return false;",
          "84:     }",
          "85: }",
          "93: function _remove(Set storage set, bytes32 value) private returns (bool) {",
          "95:     uint256 valueIndex = set._indexes[value];",
          "97:     if (valueIndex != 0) {",
          "103:         uint256 toDeleteIndex = valueIndex - 1;",
          "104:         uint256 lastIndex = set._values.length - 1;",
          "106:         if (lastIndex != toDeleteIndex) {",
          "107:             bytes32 lastValue = set._values[lastIndex];",
          "110:             set._values[toDeleteIndex] = lastValue;",
          "112:             set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex",
          "113:         }",
          "116:         set._values.pop();",
          "119:         delete set._indexes[value];",
          "121:         return true;",
          "122:     } else {",
          "123:         return false;",
          "124:     }",
          "125: }",
          "130: function _contains(Set storage set, bytes32 value) private view returns (bool) {",
          "131:     return set._indexes[value] != 0;",
          "132: }",
          "137: function _length(Set storage set) private view returns (uint256) {",
          "138:     return set._values.length;",
          "139: }",
          "151: function _at(Set storage set, uint256 index) private view returns (bytes32) {",
          "152:     return set._values[index];",
          "153: }",
          "163: function _values(Set storage set) private view returns (bytes32[] memory) {",
          "164:     return set._values;",
          "165: }",
          "166: `;",
          "168: const customSet = ({ name, type }) => `\\",
          "171: struct ${name} {",
          "172:     Set _inner;",
          "173: }",
          "181: function add(${name} storage set, ${type} value) internal returns (bool) {",
          "182:     return _add(set._inner, ${toBytes32(type, 'value')});",
          "183: }",
          "191: function remove(${name} storage set, ${type} value) internal returns (bool) {",
          "192:     return _remove(set._inner, ${toBytes32(type, 'value')});",
          "193: }",
          "198: function contains(${name} storage set, ${type} value) internal view returns (bool) {",
          "199:     return _contains(set._inner, ${toBytes32(type, 'value')});",
          "200: }",
          "205: function length(${name} storage set) internal view returns (uint256) {",
          "206:     return _length(set._inner);",
          "207: }",
          "219: function at(${name} storage set, uint256 index) internal view returns (${type}) {",
          "220:     return ${fromBytes32(type, '_at(set._inner, index)')};",
          "221: }",
          "231: function values(${name} storage set) internal view returns (${type}[] memory) {",
          "232:     bytes32[] memory store = _values(set._inner);",
          "233:     ${type}[] memory result;",
          "236:     assembly {",
          "237:         result := store",
          "238:     }",
          "240:     return result;",
          "241: }",
          "242: `;",
          "245: module.exports = format(",
          "246:   header.trimEnd(),",
          "247:   'library EnumerableSet {',",
          "248:   [defaultSet(), TYPES.map(details => customSet(details).trimEnd()).join('\\n\\n')],",
          "249:   '}',",
          "250: );",
          "",
          "---------------"
        ],
        "scripts/generate/templates/SafeCast.js||scripts/generate/templates/SafeCast.js": [
          "File: scripts/generate/templates/SafeCast.js -> scripts/generate/templates/SafeCast.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const assert = require('assert');",
          "2: const format = require('../format-lines');",
          "3: const { range } = require('../../helpers');",
          "5: const LENGTHS = range(8, 256, 8).reverse(); // 248 \u2192 8 (in steps of 8)",
          "9: const version = (selector, length) => {",
          "10:   switch (selector) {",
          "11:     case 'toUint(uint)': {",
          "12:       switch (length) {",
          "13:         case 8:",
          "14:         case 16:",
          "15:         case 32:",
          "16:         case 64:",
          "17:         case 128:",
          "18:           return '2.5';",
          "19:         case 96:",
          "20:         case 224:",
          "21:           return '4.2';",
          "22:         default:",
          "23:           assert(LENGTHS.includes(length));",
          "24:           return '4.7';",
          "25:       }",
          "26:     }",
          "27:     case 'toInt(int)': {",
          "28:       switch (length) {",
          "29:         case 8:",
          "30:         case 16:",
          "31:         case 32:",
          "32:         case 64:",
          "33:         case 128:",
          "34:           return '3.1';",
          "35:         default:",
          "36:           assert(LENGTHS.includes(length));",
          "37:           return '4.7';",
          "38:       }",
          "39:     }",
          "40:     case 'toUint(int)': {",
          "41:       switch (length) {",
          "42:         case 256:",
          "43:           return '3.0';",
          "44:         default:",
          "45:           assert(false);",
          "46:           return;",
          "47:       }",
          "48:     }",
          "49:     case 'toInt(uint)': {",
          "50:       switch (length) {",
          "51:         case 256:",
          "52:           return '3.0';",
          "53:         default:",
          "54:           assert(false);",
          "55:           return;",
          "56:       }",
          "57:     }",
          "58:     default:",
          "59:       assert(false);",
          "60:   }",
          "61: };",
          "63: const header = `\\",
          "64: pragma solidity ^0.8.0;",
          "81: `;",
          "83: const toUintDownCast = length => `\\",
          "96: function toUint${length}(uint256 value) internal pure returns (uint${length}) {",
          "97:     require(value <= type(uint${length}).max, \"SafeCast: value doesn't fit in ${length} bits\");",
          "98:     return uint${length}(value);",
          "99: }",
          "100: `;",
          "103: const toIntDownCast = length => `\\",
          "117: function toInt${length}(int256 value) internal pure returns (int${length} downcasted) {",
          "118:     downcasted = int${length}(value);",
          "119:     require(downcasted == value, \"SafeCast: value doesn't fit in ${length} bits\");",
          "120: }",
          "121: `;",
          "124: const toInt = length => `\\",
          "134: function toInt${length}(uint${length} value) internal pure returns (int${length}) {",
          "136:     require(value <= uint${length}(type(int${length}).max), \"SafeCast: value doesn't fit in an int${length}\");",
          "137:     return int${length}(value);",
          "138: }",
          "139: `;",
          "141: const toUint = length => `\\",
          "151: function toUint${length}(int${length} value) internal pure returns (uint${length}) {",
          "152:     require(value >= 0, \"SafeCast: value must be positive\");",
          "153:     return uint${length}(value);",
          "154: }",
          "155: `;",
          "158: module.exports = format(",
          "159:   header.trimEnd(),",
          "160:   'library SafeCast {',",
          "161:   [...LENGTHS.map(toUintDownCast), toUint(256), ...LENGTHS.map(toIntDownCast), toInt(256)],",
          "162:   '}',",
          "163: );",
          "",
          "---------------"
        ],
        "scripts/generate/templates/StorageSlot.js||scripts/generate/templates/StorageSlot.js": [
          "File: scripts/generate/templates/StorageSlot.js -> scripts/generate/templates/StorageSlot.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const format = require('../format-lines');",
          "2: const { capitalize, unique } = require('../../helpers');",
          "4: const TYPES = [",
          "5:   { type: 'address', isValueType: true, version: '4.1' },",
          "6:   { type: 'bool', isValueType: true, name: 'Boolean', version: '4.1' },",
          "7:   { type: 'bytes32', isValueType: true, version: '4.1' },",
          "8:   { type: 'uint256', isValueType: true, version: '4.1' },",
          "9:   { type: 'string', isValueType: false, version: '4.9' },",
          "10:   { type: 'bytes', isValueType: false, version: '4.9' },",
          "11: ].map(type => Object.assign(type, { struct: (type.name ?? capitalize(type.type)) + 'Slot' }));",
          "13: const VERSIONS = unique(TYPES.map(t => t.version)).map(",
          "14:   version =>",
          "15:     `_Available since v${version} for ${TYPES.filter(t => t.version == version)",
          "16:       .map(t => `\\`${t.type}\\``)",
          "17:       .join(', ')}._`,",
          "18: );",
          "20: const header = `\\",
          "21: pragma solidity ^0.8.0;",
          "47: ${VERSIONS.map(s => ` * ${s}`).join('\\n')}",
          "49: `;",
          "51: const struct = type => `\\",
          "52: struct ${type.struct} {",
          "53:   ${type.type} value;",
          "54: }",
          "55: `;",
          "57: const get = type => `\\",
          "61: function get${type.struct}(bytes32 slot) internal pure returns (${type.struct} storage r) {",
          "63:   assembly {",
          "64:       r.slot := slot",
          "65:   }",
          "66: }",
          "67: `;",
          "69: const getStorage = type => `\\",
          "73: function get${type.struct}(${type.type} storage store) internal pure returns (${type.struct} storage r) {",
          "75:   assembly {",
          "76:       r.slot := store.slot",
          "77:   }",
          "78: }",
          "79: `;",
          "82: module.exports = format(",
          "83:   header.trimEnd(),",
          "84:   'library StorageSlot {',",
          "85:   [...TYPES.map(struct), ...TYPES.flatMap(type => [get(type), type.isValueType ? '' : getStorage(type)])],",
          "86:   '}',",
          "87: );",
          "",
          "---------------"
        ],
        "scripts/generate/templates/conversion.js||scripts/generate/templates/conversion.js": [
          "File: scripts/generate/templates/conversion.js -> scripts/generate/templates/conversion.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: function toBytes32(type, value) {",
          "2:   switch (type) {",
          "3:     case 'bytes32':",
          "4:       return value;",
          "5:     case 'uint256':",
          "6:       return `bytes32(${value})`;",
          "7:     case 'address':",
          "8:       return `bytes32(uint256(uint160(${value})))`;",
          "9:     default:",
          "10:       throw new Error(`Conversion from ${type} to bytes32 not supported`);",
          "11:   }",
          "12: }",
          "14: function fromBytes32(type, value) {",
          "15:   switch (type) {",
          "16:     case 'bytes32':",
          "17:       return value;",
          "18:     case 'uint256':",
          "19:       return `uint256(${value})`;",
          "20:     case 'address':",
          "21:       return `address(uint160(uint256(${value})))`;",
          "22:     default:",
          "23:       throw new Error(`Conversion from bytes32 to ${type} not supported`);",
          "24:   }",
          "25: }",
          "27: module.exports = {",
          "28:   toBytes32,",
          "29:   fromBytes32,",
          "30: };",
          "",
          "---------------"
        ],
        "scripts/git-user-config.sh||scripts/git-user-config.sh": [
          "File: scripts/git-user-config.sh -> scripts/git-user-config.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail -x",
          "5: git config user.name 'github-actions'",
          "6: git config user.email '41898282+github-actions[bot]@users.noreply.github.com'",
          "",
          "---------------"
        ],
        "scripts/helpers.js||scripts/helpers.js": [
          "File: scripts/helpers.js -> scripts/helpers.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: function chunk(array, size = 1) {",
          "2:   return Array.range(Math.ceil(array.length / size)).map(i => array.slice(i * size, i * size + size));",
          "3: }",
          "5: function range(start, stop = undefined, step = 1) {",
          "6:   if (!stop) {",
          "7:     stop = start;",
          "8:     start = 0;",
          "9:   }",
          "10:   return start < stop",
          "11:     ? Array(Math.ceil((stop - start) / step))",
          "12:         .fill()",
          "13:         .map((_, i) => start + i * step)",
          "14:     : [];",
          "15: }",
          "17: function unique(array, op = x => x) {",
          "18:   return array.filter((obj, i) => array.findIndex(entry => op(obj) === op(entry)) === i);",
          "19: }",
          "21: function zip(...args) {",
          "22:   return Array(Math.max(...args.map(arg => arg.length)))",
          "23:     .fill(null)",
          "24:     .map((_, i) => args.map(arg => arg[i]));",
          "25: }",
          "27: function capitalize(str) {",
          "28:   return str.charAt(0).toUpperCase() + str.slice(1);",
          "29: }",
          "31: module.exports = {",
          "32:   chunk,",
          "33:   range,",
          "34:   unique,",
          "35:   zip,",
          "36:   capitalize,",
          "37: };",
          "",
          "---------------"
        ],
        "scripts/migrate-imports.js||scripts/migrate-imports.js": [
          "File: scripts/migrate-imports.js -> scripts/migrate-imports.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env node",
          "3: const { promises: fs } = require('fs');",
          "4: const path = require('path');",
          "6: const pathUpdates = {",
          "9:   'access/TimelockController.sol': 'governance/TimelockController.sol',",
          "10:   'cryptography/ECDSA.sol': 'utils/cryptography/ECDSA.sol',",
          "11:   'cryptography/MerkleProof.sol': 'utils/cryptography/MerkleProof.sol',",
          "12:   'drafts/EIP712.sol': 'utils/cryptography/EIP712.sol',",
          "13:   'drafts/ERC20Permit.sol': 'token/ERC20/extensions/ERC20Permit.sol',",
          "14:   'drafts/IERC20Permit.sol': 'token/ERC20/extensions/IERC20Permit.sol',",
          "15:   'GSN/Context.sol': 'utils/Context.sol',",
          "21:   'introspection/ERC165Checker.sol': 'utils/introspection/ERC165Checker.sol',",
          "22:   'introspection/ERC165.sol': 'utils/introspection/ERC165.sol',",
          "23:   'introspection/ERC1820Implementer.sol': 'utils/introspection/ERC1820Implementer.sol',",
          "24:   'introspection/IERC165.sol': 'utils/introspection/IERC165.sol',",
          "25:   'introspection/IERC1820Implementer.sol': 'utils/introspection/IERC1820Implementer.sol',",
          "26:   'introspection/IERC1820Registry.sol': 'utils/introspection/IERC1820Registry.sol',",
          "27:   'math/Math.sol': 'utils/math/Math.sol',",
          "28:   'math/SafeMath.sol': 'utils/math/SafeMath.sol',",
          "29:   'math/SignedSafeMath.sol': 'utils/math/SignedSafeMath.sol',",
          "30:   'payment/escrow/ConditionalEscrow.sol': 'utils/escrow/ConditionalEscrow.sol',",
          "31:   'payment/escrow/Escrow.sol': 'utils/escrow/Escrow.sol',",
          "32:   'payment/escrow/RefundEscrow.sol': 'utils/escrow/RefundEscrow.sol',",
          "33:   'payment/PaymentSplitter.sol': 'finance/PaymentSplitter.sol',",
          "34:   'utils/PaymentSplitter.sol': 'finance/PaymentSplitter.sol',",
          "35:   'payment/PullPayment.sol': 'security/PullPayment.sol',",
          "36:   'presets/ERC1155PresetMinterPauser.sol': 'token/ERC1155/presets/ERC1155PresetMinterPauser.sol',",
          "37:   'presets/ERC20PresetFixedSupply.sol': 'token/ERC20/presets/ERC20PresetFixedSupply.sol',",
          "38:   'presets/ERC20PresetMinterPauser.sol': 'token/ERC20/presets/ERC20PresetMinterPauser.sol',",
          "39:   'presets/ERC721PresetMinterPauserAutoId.sol': 'token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol',",
          "40:   'presets/ERC777PresetFixedSupply.sol': 'token/ERC777/presets/ERC777PresetFixedSupply.sol',",
          "41:   'proxy/BeaconProxy.sol': 'proxy/beacon/BeaconProxy.sol',",
          "43:   'proxy/IBeacon.sol': 'proxy/beacon/IBeacon.sol',",
          "44:   'proxy/Initializable.sol': 'proxy/utils/Initializable.sol',",
          "45:   'utils/Initializable.sol': 'proxy/utils/Initializable.sol',",
          "46:   'proxy/ProxyAdmin.sol': 'proxy/transparent/ProxyAdmin.sol',",
          "48:   'proxy/TransparentUpgradeableProxy.sol': 'proxy/transparent/TransparentUpgradeableProxy.sol',",
          "49:   'proxy/UpgradeableBeacon.sol': 'proxy/beacon/UpgradeableBeacon.sol',",
          "50:   'proxy/UpgradeableProxy.sol': 'proxy/ERC1967/ERC1967Proxy.sol',",
          "51:   'token/ERC1155/ERC1155Burnable.sol': 'token/ERC1155/extensions/ERC1155Burnable.sol',",
          "52:   'token/ERC1155/ERC1155Holder.sol': 'token/ERC1155/utils/ERC1155Holder.sol',",
          "53:   'token/ERC1155/ERC1155Pausable.sol': 'token/ERC1155/extensions/ERC1155Pausable.sol',",
          "54:   'token/ERC1155/ERC1155Receiver.sol': 'token/ERC1155/utils/ERC1155Receiver.sol',",
          "56:   'token/ERC1155/IERC1155MetadataURI.sol': 'token/ERC1155/extensions/IERC1155MetadataURI.sol',",
          "59:   'token/ERC20/ERC20Burnable.sol': 'token/ERC20/extensions/ERC20Burnable.sol',",
          "60:   'token/ERC20/ERC20Capped.sol': 'token/ERC20/extensions/ERC20Capped.sol',",
          "61:   'token/ERC20/ERC20Pausable.sol': 'token/ERC20/extensions/ERC20Pausable.sol',",
          "62:   'token/ERC20/ERC20Snapshot.sol': 'token/ERC20/extensions/ERC20Snapshot.sol',",
          "65:   'token/ERC20/SafeERC20.sol': 'token/ERC20/utils/SafeERC20.sol',",
          "66:   'token/ERC20/TokenTimelock.sol': 'token/ERC20/utils/TokenTimelock.sol',",
          "67:   'token/ERC721/ERC721Burnable.sol': 'token/ERC721/extensions/ERC721Burnable.sol',",
          "68:   'token/ERC721/ERC721Holder.sol': 'token/ERC721/utils/ERC721Holder.sol',",
          "69:   'token/ERC721/ERC721Pausable.sol': 'token/ERC721/extensions/ERC721Pausable.sol',",
          "71:   'token/ERC721/IERC721Enumerable.sol': 'token/ERC721/extensions/IERC721Enumerable.sol',",
          "72:   'token/ERC721/IERC721Metadata.sol': 'token/ERC721/extensions/IERC721Metadata.sol',",
          "84:   'utils/EnumerableMap.sol': 'utils/structs/EnumerableMap.sol',",
          "85:   'utils/EnumerableSet.sol': 'utils/structs/EnumerableSet.sol',",
          "86:   'utils/Pausable.sol': 'security/Pausable.sol',",
          "87:   'utils/ReentrancyGuard.sol': 'security/ReentrancyGuard.sol',",
          "88:   'utils/SafeCast.sol': 'utils/math/SafeCast.sol',",
          "90:   'utils/cryptography/draft-EIP712.sol': 'utils/cryptography/EIP712.sol',",
          "91:   'token/ERC20/extensions/draft-ERC20Permit.sol': 'token/ERC20/extensions/ERC20Permit.sol',",
          "92:   'token/ERC20/extensions/draft-IERC20Permit.sol': 'token/ERC20/extensions/IERC20Permit.sol',",
          "93: };",
          "95: async function main(paths = ['contracts']) {",
          "96:   const files = await listFilesRecursively(paths, /\\.sol$/);",
          "98:   const updatedFiles = [];",
          "99:   for (const file of files) {",
          "100:     if (await updateFile(file, updateImportPaths)) {",
          "101:       updatedFiles.push(file);",
          "102:     }",
          "103:   }",
          "105:   if (updatedFiles.length > 0) {",
          "106:     console.log(`${updatedFiles.length} file(s) were updated`);",
          "107:     for (const c of updatedFiles) {",
          "108:       console.log('-', c);",
          "109:     }",
          "110:   } else {",
          "111:     console.log('No files were updated');",
          "112:   }",
          "113: }",
          "115: async function listFilesRecursively(paths, filter) {",
          "116:   const queue = paths;",
          "117:   const files = [];",
          "119:   while (queue.length > 0) {",
          "120:     const top = queue.shift();",
          "121:     const stat = await fs.stat(top);",
          "122:     if (stat.isFile()) {",
          "123:       if (top.match(filter)) {",
          "124:         files.push(top);",
          "125:       }",
          "126:     } else if (stat.isDirectory()) {",
          "127:       for (const name of await fs.readdir(top)) {",
          "128:         queue.push(path.join(top, name));",
          "129:       }",
          "130:     }",
          "131:   }",
          "133:   return files;",
          "134: }",
          "136: async function updateFile(file, update) {",
          "137:   const content = await fs.readFile(file, 'utf8');",
          "138:   const updatedContent = update(content);",
          "139:   if (updatedContent !== content) {",
          "140:     await fs.writeFile(file, updatedContent);",
          "141:     return true;",
          "142:   } else {",
          "143:     return false;",
          "144:   }",
          "145: }",
          "147: function updateImportPaths(source) {",
          "148:   for (const [oldPath, newPath] of Object.entries(pathUpdates)) {",
          "149:     source = source.replace(",
          "150:       path.join('@openzeppelin/contracts', oldPath),",
          "151:       path.join('@openzeppelin/contracts', newPath),",
          "152:     );",
          "153:     source = source.replace(",
          "154:       path.join('@openzeppelin/contracts-upgradeable', getUpgradeablePath(oldPath)),",
          "155:       path.join('@openzeppelin/contracts-upgradeable', getUpgradeablePath(newPath)),",
          "156:     );",
          "157:   }",
          "159:   return source;",
          "160: }",
          "162: function getUpgradeablePath(file) {",
          "163:   const { dir, name, ext } = path.parse(file);",
          "164:   const upgradeableName = name + 'Upgradeable';",
          "165:   return path.format({ dir, ext, name: upgradeableName });",
          "166: }",
          "168: module.exports = {",
          "169:   pathUpdates,",
          "170:   updateImportPaths,",
          "171:   getUpgradeablePath,",
          "172: };",
          "174: if (require.main === module) {",
          "175:   const args = process.argv.length > 2 ? process.argv.slice(2) : undefined;",
          "176:   main(args).catch(e => {",
          "177:     console.error(e);",
          "178:     process.exit(1);",
          "179:   });",
          "180: }",
          "",
          "---------------"
        ],
        "scripts/prepack.sh||scripts/prepack.sh": [
          "File: scripts/prepack.sh -> scripts/prepack.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail",
          "4: shopt -s globstar",
          "6: # cross platform `mkdir -p`",
          "7: node -e 'fs.mkdirSync(\"build/contracts\", { recursive: true })'",
          "9: cp artifacts/contracts/**/*.json build/contracts",
          "10: rm build/contracts/*.dbg.json",
          "12: node scripts/remove-ignored-artifacts.js",
          "",
          "---------------"
        ],
        "scripts/prepare-contracts-package.sh||scripts/prepare-contracts-package.sh": [
          "File: scripts/prepare-contracts-package.sh -> scripts/prepare-contracts-package.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: # cd to the root of the repo",
          "4: cd \"$(git rev-parse --show-toplevel)\"",
          "6: # avoids re-compilation during publishing of both packages",
          "7: if [[ ! -v ALREADY_COMPILED ]]; then",
          "8:   npm run clean",
          "9:   npm run prepare",
          "10:   npm run prepack",
          "11: fi",
          "13: cp README.md contracts/",
          "14: mkdir contracts/build contracts/build/contracts",
          "15: cp -r build/contracts/*.json contracts/build/contracts",
          "",
          "---------------"
        ],
        "scripts/prepare-docs.sh||scripts/prepare-docs.sh": [
          "File: scripts/prepare-docs.sh -> scripts/prepare-docs.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail",
          "5: OUTDIR=\"$(node -p 'require(\"./docs/config.js\").outputDir')\"",
          "7: if [ ! -d node_modules ]; then",
          "8:   npm ci",
          "9: fi",
          "11: rm -rf \"$OUTDIR\"",
          "13: hardhat docgen",
          "15: # copy examples and adjust imports",
          "16: examples_dir=\"docs/modules/api/examples\"",
          "17: mkdir -p \"$examples_dir\"",
          "18: for f in contracts/mocks/docs/*.sol; do",
          "19:   name=\"$(basename \"$f\")\"",
          "20:   sed -e '/^import/s|\\.\\./\\.\\./|@openzeppelin/contracts/|' \"$f\" > \"docs/modules/api/examples/$name\"",
          "21: done",
          "23: node scripts/gen-nav.js \"$OUTDIR\" > \"$OUTDIR/../nav.adoc\"",
          "",
          "---------------"
        ],
        "scripts/prepare.sh||scripts/prepare.sh": [
          "File: scripts/prepare.sh -> scripts/prepare.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail",
          "5: if [ \"${SKIP_COMPILE:-}\" == true ]; then",
          "6:   exit",
          "7: fi",
          "9: npm run clean",
          "10: env COMPILE_MODE=production npm run compile",
          "",
          "---------------"
        ],
        "scripts/release/format-changelog.js||scripts/release/format-changelog.js": [
          "File: scripts/release/format-changelog.js -> scripts/release/format-changelog.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env node",
          "6: const fs = require('fs');",
          "7: const changelog = fs.readFileSync('CHANGELOG.md', 'utf8');",
          "12: const RELEASE_LINE_REGEX = /^- (\\[#.*?\\]\\(.*?\\))?.*?! - (.*)$/gm;",
          "15: const VERSION_TITLE_REGEX = /^## (\\d+\\.\\d+\\.\\d+(-rc\\.\\d+)?)$/gm;",
          "17: const isPrerelease = process.env.PRERELEASE === 'true';",
          "19: const formatted = changelog",
          "21:   .replace(/^### Major Changes\\n\\n/gm, '')",
          "22:   .replace(/^### Minor Changes\\n\\n/gm, '')",
          "23:   .replace(/^### Patch Changes\\n\\n/gm, '')",
          "25:   .replace(/^(- \\[.*\\n)\\n(?=-)/gm, '$1')",
          "27:   .replace(RELEASE_LINE_REGEX, (_, pr, entry) => (pr ? `- ${entry} (${pr})` : `- ${entry}`))",
          "29:   .replace(VERSION_TITLE_REGEX, `\\n## $1 (${new Date().toISOString().split('T')[0]})`)",
          "31:   .replace(/^## \\d\\.\\d\\.\\d-rc\\S+[^]+?(?=^#)/gm, section => (isPrerelease ? section : ''));",
          "33: fs.writeFileSync('CHANGELOG.md', formatted);",
          "",
          "---------------"
        ],
        "scripts/release/synchronize-versions.js||scripts/release/synchronize-versions.js": [
          "File: scripts/release/synchronize-versions.js -> scripts/release/synchronize-versions.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env node",
          "6: const fs = require('fs');",
          "8: setVersion('package.json', 'contracts/package.json');",
          "10: function setVersion(from, to) {",
          "11:   const fromJson = JSON.parse(fs.readFileSync(from));",
          "12:   const toJson = JSON.parse(fs.readFileSync(to));",
          "13:   toJson.version = fromJson.version;",
          "14:   fs.writeFileSync(to, JSON.stringify(toJson, null, 2) + '\\n');",
          "15: }",
          "",
          "---------------"
        ],
        "scripts/release/update-comment.js||scripts/release/update-comment.js": [
          "File: scripts/release/update-comment.js -> scripts/release/update-comment.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env node",
          "2: const fs = require('fs');",
          "3: const proc = require('child_process');",
          "4: const semver = require('semver');",
          "5: const run = (cmd, ...args) => proc.execFileSync(cmd, args, { encoding: 'utf8' }).trim();",
          "7: const gitStatus = run('git', 'status', '--porcelain', '-uno', 'contracts/**/*.sol');",
          "8: if (gitStatus.length > 0) {",
          "9:   console.error('Contracts directory is not clean');",
          "10:   process.exit(1);",
          "11: }",
          "13: const { version } = require('../../package.json');",
          "16: const [tag] = run('git', 'tag')",
          "17:   .split(/\\r?\\n/)",
          "18:   .filter(semver.coerce) // check version can be processed",
          "19:   .filter(v => semver.lt(semver.coerce(v), version)) // only consider older tags, ignore current prereleases",
          "20:   .sort(semver.rcompare);",
          "23: const files = run('git', 'diff', tag, 'HEAD', '--name-only', 'contracts/**/*.sol')",
          "24:   .split(/\\r?\\n/)",
          "25:   .filter(file => file && !file.match(/mock/i) && fs.existsSync(file));",
          "27: for (const file of files) {",
          "28:   const current = fs.readFileSync(file, 'utf8');",
          "29:   const updated = current.replace(",
          "30:     /(\\/\\/ SPDX-License-Identifier:.*)$(\\n\\/\\/ OpenZeppelin Contracts .*$)?/m,",
          "31:     `$1\\n// OpenZeppelin Contracts (last updated v${version}) (${file.replace('contracts/', '')})`,",
          "32:   );",
          "33:   fs.writeFileSync(file, updated);",
          "34: }",
          "",
          "---------------"
        ],
        "scripts/release/version.sh||scripts/release/version.sh": [
          "File: scripts/release/version.sh -> scripts/release/version.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail",
          "5: changeset version",
          "7: scripts/release/format-changelog.js",
          "8: scripts/release/synchronize-versions.js",
          "9: scripts/release/update-comment.js",
          "11: oz-docs update-version",
          "",
          "---------------"
        ],
        "scripts/release/workflow/exit-prerelease.sh||scripts/release/workflow/exit-prerelease.sh": [
          "File: scripts/release/workflow/exit-prerelease.sh -> scripts/release/workflow/exit-prerelease.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail",
          "5: npx changeset pre exit rc",
          "6: git add .",
          "7: git commit -m \"Exit release candidate\"",
          "8: git push origin",
          "",
          "---------------"
        ],
        "scripts/release/workflow/github-release.js||scripts/release/workflow/github-release.js": [
          "File: scripts/release/workflow/github-release.js -> scripts/release/workflow/github-release.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { readFileSync } = require('fs');",
          "2: const { join } = require('path');",
          "3: const { version } = require(join(__dirname, '../../../package.json'));",
          "5: module.exports = async ({ github, context }) => {",
          "6:   const changelog = readFileSync('CHANGELOG.md', 'utf8');",
          "8:   await github.rest.repos.createRelease({",
          "9:     owner: context.repo.owner,",
          "10:     repo: context.repo.repo,",
          "11:     tag_name: `v${version}`,",
          "12:     body: extractSection(changelog, version),",
          "13:     prerelease: process.env.PRERELEASE === 'true',",
          "14:   });",
          "15: };",
          "18: function makeWordRegExp(word) {",
          "19:   const start = word.length > 0 && /\\b/.test(word[0]) ? '\\\\b' : '';",
          "20:   const end = word.length > 0 && /\\b/.test(word[word.length - 1]) ? '\\\\b' : '';",
          "21:   return new RegExp(start + [...word].map(c => (/[a-z0-9]/i.test(c) ? c : '\\\\' + c)).join('') + end);",
          "22: }",
          "25: function extractSection(document, wantedHeading) {",
          "27:   const heading = /^ {0,3}(?<lead>#{1,6})(?: [ \\t\\v\\f]*(?<text>.*?)[ \\t\\v\\f]*)?(?:[\\n\\r]+|$)/gm;",
          "29:   const wantedHeadingRe = makeWordRegExp(wantedHeading);",
          "31:   let start, end;",
          "33:   for (const m of document.matchAll(heading)) {",
          "34:     if (!start) {",
          "35:       if (m.groups.text.search(wantedHeadingRe) === 0) {",
          "36:         start = m;",
          "37:       }",
          "38:     } else if (m.groups.lead.length <= start.groups.lead.length) {",
          "39:       end = m;",
          "40:       break;",
          "41:     }",
          "42:   }",
          "44:   if (start) {",
          "45:     return document.slice(start.index + start[0].length, end?.index);",
          "46:   }",
          "47: }",
          "",
          "---------------"
        ],
        "scripts/release/workflow/integrity-check.sh||scripts/release/workflow/integrity-check.sh": [
          "File: scripts/release/workflow/integrity-check.sh -> scripts/release/workflow/integrity-check.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail",
          "5: CHECKSUMS=\"$RUNNER_TEMP/checksums.txt\"",
          "7: # Extract tarball content into a tmp directory",
          "8: tar xf \"$TARBALL\" -C \"$RUNNER_TEMP\"",
          "10: # Move to extracted directory",
          "11: cd \"$RUNNER_TEMP/package\"",
          "13: # Checksum all Solidity files",
          "14: find . -type f -name \"*.sol\" | xargs shasum > \"$CHECKSUMS\"",
          "16: # Back to directory with git contents",
          "17: cd \"$GITHUB_WORKSPACE/contracts\"",
          "19: # Check against tarball contents",
          "20: shasum -c \"$CHECKSUMS\"",
          "",
          "---------------"
        ],
        "scripts/release/workflow/pack.sh||scripts/release/workflow/pack.sh": [
          "File: scripts/release/workflow/pack.sh -> scripts/release/workflow/pack.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail",
          "5: dist_tag() {",
          "6:   PACKAGE_JSON_NAME=\"$(jq -r .name ./package.json)\"",
          "7:   LATEST_NPM_VERSION=\"$(npm info \"$PACKAGE_JSON_NAME\" version)\"",
          "8:   PACKAGE_JSON_VERSION=\"$(jq -r .version ./package.json)\"",
          "10:   if [ \"$PRERELEASE\" = \"true\" ]; then",
          "11:     echo \"next\"",
          "12:   elif npx semver -r \">$LATEST_NPM_VERSION\" \"$PACKAGE_JSON_VERSION\" > /dev/null; then",
          "13:     echo \"latest\"",
          "14:   else",
          "15:     # This is a patch for an older version",
          "16:     # npm can't publish without a tag",
          "17:     echo \"tmp\"",
          "18:   fi",
          "19: }",
          "21: cd contracts",
          "22: TARBALL=\"$(npm pack | tee /dev/stderr | tail -1)\"",
          "23: echo \"tarball_name=$TARBALL\" >> $GITHUB_OUTPUT",
          "24: echo \"tarball=$(pwd)/$TARBALL\" >> $GITHUB_OUTPUT",
          "25: echo \"tag=$(dist_tag)\" >> $GITHUB_OUTPUT",
          "26: cd ..",
          "",
          "---------------"
        ],
        "scripts/release/workflow/prepare-release-merge.sh||scripts/release/workflow/prepare-release-merge.sh": [
          "File: scripts/release/workflow/prepare-release-merge.sh -> scripts/release/workflow/prepare-release-merge.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail",
          "5: # Define merge branch name",
          "6: MERGE_BRANCH=merge/$GITHUB_REF_NAME",
          "8: # Create the branch and force to start from ref",
          "9: git checkout -B \"$MERGE_BRANCH\" \"$GITHUB_REF_NAME\"",
          "11: # Get deleted changesets in this branch that might conflict with master",
          "12: readarray -t DELETED_CHANGESETS < <(git diff origin/master --name-only -- '.changeset/*.md')",
          "14: # Merge master, which will take those files cherry-picked. Auto-resolve conflicts favoring master.",
          "15: git merge origin/master -m \"Merge master to $GITHUB_REF_NAME\" -X theirs",
          "17: # Remove the originally deleted changesets to correctly sync with master",
          "18: rm -f \"${DELETED_CHANGESETS[@]}\"",
          "20: git add .changeset/",
          "22: # Allow empty here since there may be no changes if `rm -f` failed for all changesets",
          "23: git commit --allow-empty -m \"Sync changesets with master\"",
          "24: git push -f origin \"$MERGE_BRANCH\"",
          "",
          "---------------"
        ],
        "scripts/release/workflow/publish.sh||scripts/release/workflow/publish.sh": [
          "File: scripts/release/workflow/publish.sh -> scripts/release/workflow/publish.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail",
          "5: # Intentionally escape $ to avoid interpolation and writing the token to disk",
          "6: echo \"//registry.npmjs.org/:_authToken=\\${NPM_TOKEN}\" > .npmrc",
          "8: # Actual publish",
          "9: npm publish \"$TARBALL\" --tag \"$TAG\"",
          "11: delete_tag() {",
          "12:   PACKAGE_JSON_NAME=\"$(tar xfO \"$TARBALL\" package/package.json | jq -r .name)\"",
          "13:   npm dist-tag rm \"$PACKAGE_JSON_NAME\" \"$1\"",
          "14: }",
          "16: if [ \"$TAG\" = tmp ]; then",
          "17:   delete_tag \"$TAG\"",
          "18: elif [ \"$TAG\" = latest ]; then",
          "19:   delete_tag next",
          "20: fi",
          "",
          "---------------"
        ],
        "scripts/release/workflow/rerun.js||scripts/release/workflow/rerun.js": [
          "File: scripts/release/workflow/rerun.js -> scripts/release/workflow/rerun.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: module.exports = ({ github, context }) =>",
          "2:   github.rest.actions.createWorkflowDispatch({",
          "3:     owner: context.repo.owner,",
          "4:     repo: context.repo.repo,",
          "5:     workflow_id: 'release-cycle.yml',",
          "6:     ref: process.env.REF || process.env.GITHUB_REF_NAME,",
          "7:   });",
          "",
          "---------------"
        ],
        "scripts/release/workflow/set-changesets-pr-title.js||scripts/release/workflow/set-changesets-pr-title.js": [
          "File: scripts/release/workflow/set-changesets-pr-title.js -> scripts/release/workflow/set-changesets-pr-title.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { coerce, inc, rsort } = require('semver');",
          "2: const { join } = require('path');",
          "3: const { version } = require(join(__dirname, '../../../package.json'));",
          "5: module.exports = async ({ core }) => {",
          "7:   const refName = process.env.GITHUB_REF_NAME;",
          "12:   const branchPatch0 = coerce(refName.replace('release-v', '')).version;",
          "13:   const packageJsonNextPatch = inc(version, 'patch');",
          "14:   const [nextVersion] = rsort([branchPatch0, packageJsonNextPatch], false);",
          "16:   core.exportVariable('TITLE', `Release v${nextVersion}`);",
          "17: };",
          "",
          "---------------"
        ],
        "scripts/release/workflow/start.sh||scripts/release/workflow/start.sh": [
          "File: scripts/release/workflow/start.sh -> scripts/release/workflow/start.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail",
          "5: # Set changeset status location",
          "6: # This is needed because `changeset status --output` only works with relative routes",
          "7: CHANGESETS_STATUS_JSON=\"$(realpath --relative-to=. \"$RUNNER_TEMP/status.json\")\"",
          "9: # Save changeset status to temp file",
          "10: npx changeset status --output=\"$CHANGESETS_STATUS_JSON\"",
          "12: # Defensive assertion. SHOULD NOT BE REACHED",
          "13: if [ \"$(jq '.releases | length' \"$CHANGESETS_STATUS_JSON\")\" != 1 ]; then",
          "14:   echo \"::error file=$CHANGESETS_STATUS_JSON::The status doesn't contain only 1 release\"",
          "15:   exit 1;",
          "16: fi;",
          "18: # Create branch",
          "19: BRANCH_SUFFIX=\"$(jq -r '.releases[0].newVersion | gsub(\"\\\\.\\\\d+$\"; \"\")' $CHANGESETS_STATUS_JSON)\"",
          "20: RELEASE_BRANCH=\"release-v$BRANCH_SUFFIX\"",
          "21: git checkout -b \"$RELEASE_BRANCH\"",
          "23: # Output branch",
          "24: echo \"branch=$RELEASE_BRANCH\" >> $GITHUB_OUTPUT",
          "26: # Enter in prerelease state",
          "27: npx changeset pre enter rc",
          "28: git add .",
          "29: git commit -m \"Start release candidate\"",
          "31: # Push branch",
          "32: if ! git push origin \"$RELEASE_BRANCH\"; then",
          "33:   echo \"::error file=scripts/release/start.sh::Can't push $RELEASE_BRANCH. Did you forget to run this workflow from $RELEASE_BRANCH?\"",
          "34:   exit 1",
          "35: fi",
          "",
          "---------------"
        ],
        "scripts/release/workflow/state.js||scripts/release/workflow/state.js": [
          "File: scripts/release/workflow/state.js -> scripts/release/workflow/state.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { readPreState } = require('@changesets/pre');",
          "2: const { default: readChangesets } = require('@changesets/read');",
          "3: const { join } = require('path');",
          "4: const { version } = require(join(__dirname, '../../../package.json'));",
          "6: module.exports = async ({ github, context, core }) => {",
          "7:   const state = await getState({ github, context, core });",
          "9:   function setOutput(key, value) {",
          "10:     core.info(`State ${key} = ${value}`);",
          "11:     core.setOutput(key, value);",
          "12:   }",
          "15:   setOutput('start', shouldRunStart(state));",
          "16:   setOutput('promote', shouldRunPromote(state));",
          "17:   setOutput('changesets', shouldRunChangesets(state));",
          "18:   setOutput('publish', shouldRunPublish(state));",
          "19:   setOutput('merge', shouldRunMerge(state));",
          "22:   setOutput('is_prerelease', state.prerelease);",
          "23: };",
          "25: function shouldRunStart({ isMaster, isWorkflowDispatch, botRun }) {",
          "26:   return isMaster && isWorkflowDispatch && !botRun;",
          "27: }",
          "29: function shouldRunPromote({ isReleaseBranch, isWorkflowDispatch, botRun }) {",
          "30:   return isReleaseBranch && isWorkflowDispatch && !botRun;",
          "31: }",
          "33: function shouldRunChangesets({ isReleaseBranch, isPush, isWorkflowDispatch, botRun }) {",
          "34:   return (isReleaseBranch && isPush) || (isReleaseBranch && isWorkflowDispatch && botRun);",
          "35: }",
          "37: function shouldRunPublish({ isReleaseBranch, isPush, hasPendingChangesets }) {",
          "38:   return isReleaseBranch && isPush && !hasPendingChangesets;",
          "39: }",
          "41: function shouldRunMerge({",
          "42:   isReleaseBranch,",
          "43:   isPush,",
          "44:   prerelease,",
          "45:   isCurrentFinalVersion,",
          "46:   hasPendingChangesets,",
          "47:   prBackExists,",
          "48: }) {",
          "49:   return isReleaseBranch && isPush && !prerelease && isCurrentFinalVersion && !hasPendingChangesets && prBackExists;",
          "50: }",
          "52: async function getState({ github, context, core }) {",
          "54:   const refName = process.env.GITHUB_REF_NAME;",
          "55:   const botRun = process.env.TRIGGERING_ACTOR === 'github-actions[bot]';",
          "57:   const { changesets, preState } = await readChangesetState();",
          "60:   const state = {",
          "61:     refName,",
          "62:     hasPendingChangesets: changesets.length > 0,",
          "63:     prerelease: preState?.mode === 'pre',",
          "64:     isMaster: refName === 'master',",
          "65:     isReleaseBranch: refName.startsWith('release-v'),",
          "66:     isWorkflowDispatch: context.eventName === 'workflow_dispatch',",
          "67:     isPush: context.eventName === 'push',",
          "68:     isCurrentFinalVersion: !version.includes('-rc.'),",
          "69:     botRun,",
          "70:   };",
          "73:   const { data: prs } = await github.rest.pulls.list({",
          "74:     owner: context.repo.owner,",
          "75:     repo: context.repo.repo,",
          "76:     head: `${context.repo.owner}:merge/${state.refName}`,",
          "77:     base: 'master',",
          "78:     state: 'open',",
          "79:   });",
          "81:   state.prBackExists = prs.length === 0;",
          "84:   if (core.isDebug()) for (const [key, value] of Object.entries(state)) core.debug(`${key}: ${value}`);",
          "86:   return state;",
          "87: }",
          "90: async function readChangesetState(cwd = process.cwd()) {",
          "91:   const preState = await readPreState(cwd);",
          "92:   const isInPreMode = preState !== undefined && preState.mode === 'pre';",
          "94:   let changesets = await readChangesets(cwd);",
          "96:   if (isInPreMode) {",
          "97:     changesets = changesets.filter(x => !preState.changesets.includes(x.id));",
          "98:   }",
          "100:   return {",
          "101:     preState: isInPreMode ? preState : undefined,",
          "102:     changesets,",
          "103:   };",
          "104: }",
          "",
          "---------------"
        ],
        "scripts/remove-ignored-artifacts.js||scripts/remove-ignored-artifacts.js": [
          "File: scripts/remove-ignored-artifacts.js -> scripts/remove-ignored-artifacts.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env node",
          "5: const fs = require('fs');",
          "6: const path = require('path');",
          "7: const match = require('micromatch');",
          "9: function readJSON(path) {",
          "10:   return JSON.parse(fs.readFileSync(path));",
          "11: }",
          "13: const pkgFiles = readJSON('package.json').files;",
          "16: const ignorePatterns = pkgFiles",
          "17:   .filter(pat => pat.startsWith('!'))",
          "19:   .map(pat => pat.slice(1));",
          "21: const ignorePatternsSubtrees = ignorePatterns",
          "23:   .concat(ignorePatterns.map(pat => path.join(pat, '**/*')))",
          "24:   .map(p => p.replace(/^\\//, ''));",
          "26: const artifactsDir = 'build/contracts';",
          "27: const buildinfo = 'artifacts/build-info';",
          "28: const filenames = fs.readdirSync(buildinfo);",
          "30: let n = 0;",
          "32: for (const filename of filenames) {",
          "33:   const solcOutput = readJSON(path.join(buildinfo, filename)).output;",
          "34:   for (const sourcePath in solcOutput.contracts) {",
          "35:     const ignore = match.any(sourcePath, ignorePatternsSubtrees);",
          "36:     if (ignore) {",
          "37:       for (const contract in solcOutput.contracts[sourcePath]) {",
          "38:         fs.unlinkSync(path.join(artifactsDir, contract + '.json'));",
          "39:         n += 1;",
          "40:       }",
          "41:     }",
          "42:   }",
          "43: }",
          "45: console.error(`Removed ${n} mock artifacts`);",
          "",
          "---------------"
        ],
        "scripts/update-docs-branch.js||scripts/update-docs-branch.js": [
          "File: scripts/update-docs-branch.js -> scripts/update-docs-branch.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const proc = require('child_process');",
          "2: const read = cmd => proc.execSync(cmd, { encoding: 'utf8' }).trim();",
          "3: const run = cmd => {",
          "4:   proc.execSync(cmd, { stdio: 'inherit' });",
          "5: };",
          "6: const tryRead = cmd => {",
          "7:   try {",
          "8:     return read(cmd);",
          "9:   } catch (e) {",
          "10:     return undefined;",
          "11:   }",
          "12: };",
          "14: const releaseBranchRegex = /^release-v(?<version>(?<major>\\d+)\\.(?<minor>\\d+)(?:\\.(?<patch>\\d+))?)$/;",
          "16: const currentBranch = read('git rev-parse --abbrev-ref HEAD');",
          "17: const match = currentBranch.match(releaseBranchRegex);",
          "19: if (!match) {",
          "20:   console.error('Not currently on a release branch');",
          "21:   process.exit(1);",
          "22: }",
          "24: if (/-.*$/.test(require('../package.json').version)) {",
          "25:   console.error('Refusing to update docs: prerelease detected');",
          "26:   process.exit(0);",
          "27: }",
          "29: const current = match.groups;",
          "30: const docsBranch = `docs-v${current.major}.x`;",
          "33: run('git fetch --all --no-tags');",
          "34: const matchingDocsBranches = tryRead(`git rev-parse --glob='*/${docsBranch}'`);",
          "36: if (!matchingDocsBranches) {",
          "38:   run(`git checkout --orphan ${docsBranch}`);",
          "39: } else {",
          "40:   const [publishedRef, ...others] = new Set(matchingDocsBranches.split('\\n'));",
          "41:   if (others.length > 0) {",
          "42:     console.error(",
          "43:       `Found conflicting ${docsBranch} branches.\\n` +",
          "44:         'Either local branch is outdated or there are multiple matching remote branches.',",
          "45:     );",
          "46:     process.exit(1);",
          "47:   }",
          "48:   const publishedVersion = JSON.parse(read(`git show ${publishedRef}:package.json`)).version;",
          "49:   const publishedMinor = publishedVersion.match(/\\d+\\.(?<minor>\\d+)\\.\\d+/).groups.minor;",
          "50:   if (current.minor < publishedMinor) {",
          "51:     console.error('Refusing to update docs: newer version is published');",
          "52:     process.exit(0);",
          "53:   }",
          "55:   run('git checkout --quiet --detach');",
          "56:   run(`git reset --soft ${publishedRef}`);",
          "57:   run(`git checkout ${docsBranch}`);",
          "58: }",
          "60: run('npm run prepare-docs');",
          "61: run('git add -f docs'); // --force needed because generated docs files are gitignored",
          "62: run('git commit -m \"Update docs\"');",
          "63: run(`git checkout ${currentBranch}`);",
          "",
          "---------------"
        ],
        "scripts/upgradeable/patch-apply.sh||scripts/upgradeable/patch-apply.sh": [
          "File: scripts/upgradeable/patch-apply.sh -> scripts/upgradeable/patch-apply.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail",
          "5: DIRNAME=\"$(dirname -- \"${BASH_SOURCE[0]}\")\"",
          "6: PATCH=\"$DIRNAME/upgradeable.patch\"",
          "8: error() {",
          "9:   echo Error: \"$*\" >&2",
          "10:   exit 1",
          "11: }",
          "13: if ! git diff-files --quiet \":!$PATCH\" || ! git diff-index --quiet HEAD \":!$PATCH\"; then",
          "14:   error \"Repository must have no staged or unstaged changes\"",
          "15: fi",
          "17: if ! git apply -3 \"$PATCH\"; then",
          "18:   error \"Fix conflicts and run $DIRNAME/patch-save.sh\"",
          "19: fi",
          "",
          "---------------"
        ],
        "scripts/upgradeable/patch-save.sh||scripts/upgradeable/patch-save.sh": [
          "File: scripts/upgradeable/patch-save.sh -> scripts/upgradeable/patch-save.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail",
          "5: DIRNAME=\"$(dirname -- \"${BASH_SOURCE[0]}\")\"",
          "6: PATCH=\"$DIRNAME/upgradeable.patch\"",
          "8: error() {",
          "9:   echo Error: \"$*\" >&2",
          "10:   exit 1",
          "11: }",
          "13: if ! git diff-files --quiet \":!$PATCH\"; then",
          "14:   error \"Unstaged changes. Stage to include in patch or temporarily stash.\"",
          "15: fi",
          "17: git diff-index --cached --patch --output=\"$PATCH\" HEAD",
          "18: git restore --staged --worktree \":!$PATCH\"",
          "",
          "---------------"
        ],
        "scripts/upgradeable/transpile-onto.sh||scripts/upgradeable/transpile-onto.sh": [
          "File: scripts/upgradeable/transpile-onto.sh -> scripts/upgradeable/transpile-onto.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail",
          "5: if [ $# -lt 1 ]; then",
          "6:   echo \"usage: bash $0 <target> [<base>]\" >&2",
          "7:   exit 1",
          "8: fi",
          "10: set -x",
          "12: target=\"$1\"",
          "13: base=\"${2-}\"",
          "15: bash scripts/upgradeable/transpile.sh",
          "17: commit=\"$(git rev-parse --short HEAD)\"",
          "18: branch=\"$(git rev-parse --abbrev-ref HEAD)\"",
          "20: git add contracts",
          "22: # detach from the current branch to avoid making changes to it",
          "23: git checkout --quiet --detach",
          "25: # switch to the target branch, creating it if necessary",
          "26: if git rev-parse -q --verify \"$target\"; then",
          "27:   # if the branch exists, make it the current HEAD without checking out its contents",
          "28:   git reset --soft \"$target\"",
          "29:   git checkout \"$target\"",
          "30: else",
          "31:   # if the branch doesn't exist, create it as an orphan and check it out",
          "32:   git checkout --orphan \"$target\"",
          "33:   if [ -n \"$base\" ] && git rev-parse -q --verify \"$base\"; then",
          "34:     # if base was specified and it exists, set it as the branch history",
          "35:     git reset --soft \"$base\"",
          "36:   fi",
          "37: fi",
          "39: # commit if there are changes to commit",
          "40: if ! git diff --quiet --cached; then",
          "41:   git commit -m \"Transpile $commit\"",
          "42: fi",
          "44: git checkout \"$branch\"",
          "",
          "---------------"
        ],
        "scripts/upgradeable/transpile.sh||scripts/upgradeable/transpile.sh": [
          "File: scripts/upgradeable/transpile.sh -> scripts/upgradeable/transpile.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bash",
          "3: set -euo pipefail -x",
          "5: DIRNAME=\"$(dirname -- \"${BASH_SOURCE[0]}\")\"",
          "7: bash \"$DIRNAME/patch-apply.sh\"",
          "9: npm run clean",
          "10: npm run compile",
          "12: build_info=($(jq -r '.input.sources | keys | if any(test(\"^contracts/mocks/.*\\\\bunreachable\\\\b\")) then empty else input_filename end' artifacts/build-info/*))",
          "13: build_info_num=${#build_info[@]}",
          "15: if [ $build_info_num -ne 1 ]; then",
          "16:   echo \"found $build_info_num relevant build info files but expected just 1\"",
          "17:   exit 1",
          "18: fi",
          "20: # -D: delete original and excluded files",
          "21: # -b: use this build info file",
          "22: # -i: use included Initializable",
          "23: # -x: exclude proxy-related contracts with a few exceptions",
          "24: # -p: emit public initializer",
          "25: npx @openzeppelin/upgrade-safe-transpiler@latest -D \\",
          "26:   -b \"$build_info\" \\",
          "27:   -i contracts/proxy/utils/Initializable.sol \\",
          "28:   -x 'contracts-exposed/**/*' \\",
          "29:   -x 'contracts/proxy/**/*' \\",
          "30:   -x '!contracts/proxy/Clones.sol' \\",
          "31:   -x '!contracts/proxy/ERC1967/ERC1967Storage.sol' \\",
          "32:   -x '!contracts/proxy/ERC1967/ERC1967Upgrade.sol' \\",
          "33:   -x '!contracts/proxy/utils/UUPSUpgradeable.sol' \\",
          "34:   -x '!contracts/proxy/beacon/IBeacon.sol' \\",
          "35:   -p 'contracts/**/presets/**/*'",
          "",
          "---------------"
        ],
        "test/access/AccessControl.behavior.js||test/access/AccessControl.behavior.js": [
          "File: test/access/AccessControl.behavior.js -> test/access/AccessControl.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectEvent, expectRevert, constants, BN } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "4: const { time } = require('@nomicfoundation/hardhat-network-helpers');",
          "6: const { shouldSupportInterfaces } = require('../utils/introspection/SupportsInterface.behavior');",
          "7: const { network } = require('hardhat');",
          "8: const { ZERO_ADDRESS } = require('@openzeppelin/test-helpers/src/constants');",
          "10: const DEFAULT_ADMIN_ROLE = '0x0000000000000000000000000000000000000000000000000000000000000000';",
          "11: const ROLE = web3.utils.soliditySha3('ROLE');",
          "12: const OTHER_ROLE = web3.utils.soliditySha3('OTHER_ROLE');",
          "13: const ZERO = web3.utils.toBN(0);",
          "15: function shouldBehaveLikeAccessControl(errorPrefix, admin, authorized, other, otherAdmin) {",
          "16:   shouldSupportInterfaces(['AccessControl']);",
          "18:   describe('default admin', function () {",
          "19:     it('deployer has default admin role', async function () {",
          "20:       expect(await this.accessControl.hasRole(DEFAULT_ADMIN_ROLE, admin)).to.equal(true);",
          "21:     });",
          "23:     it(\"other roles's admin is the default admin role\", async function () {",
          "24:       expect(await this.accessControl.getRoleAdmin(ROLE)).to.equal(DEFAULT_ADMIN_ROLE);",
          "25:     });",
          "27:     it(\"default admin role's admin is itself\", async function () {",
          "28:       expect(await this.accessControl.getRoleAdmin(DEFAULT_ADMIN_ROLE)).to.equal(DEFAULT_ADMIN_ROLE);",
          "29:     });",
          "30:   });",
          "32:   describe('granting', function () {",
          "33:     beforeEach(async function () {",
          "34:       await this.accessControl.grantRole(ROLE, authorized, { from: admin });",
          "35:     });",
          "37:     it('non-admin cannot grant role to other accounts', async function () {",
          "38:       await expectRevert(",
          "39:         this.accessControl.grantRole(ROLE, authorized, { from: other }),",
          "40:         `${errorPrefix}: account ${other.toLowerCase()} is missing role ${DEFAULT_ADMIN_ROLE}`,",
          "41:       );",
          "42:     });",
          "44:     it('accounts can be granted a role multiple times', async function () {",
          "45:       await this.accessControl.grantRole(ROLE, authorized, { from: admin });",
          "46:       const receipt = await this.accessControl.grantRole(ROLE, authorized, { from: admin });",
          "47:       expectEvent.notEmitted(receipt, 'RoleGranted');",
          "48:     });",
          "49:   });",
          "51:   describe('revoking', function () {",
          "52:     it('roles that are not had can be revoked', async function () {",
          "53:       expect(await this.accessControl.hasRole(ROLE, authorized)).to.equal(false);",
          "55:       const receipt = await this.accessControl.revokeRole(ROLE, authorized, { from: admin });",
          "56:       expectEvent.notEmitted(receipt, 'RoleRevoked');",
          "57:     });",
          "59:     context('with granted role', function () {",
          "60:       beforeEach(async function () {",
          "61:         await this.accessControl.grantRole(ROLE, authorized, { from: admin });",
          "62:       });",
          "64:       it('admin can revoke role', async function () {",
          "65:         const receipt = await this.accessControl.revokeRole(ROLE, authorized, { from: admin });",
          "66:         expectEvent(receipt, 'RoleRevoked', { account: authorized, role: ROLE, sender: admin });",
          "68:         expect(await this.accessControl.hasRole(ROLE, authorized)).to.equal(false);",
          "69:       });",
          "71:       it('non-admin cannot revoke role', async function () {",
          "72:         await expectRevert(",
          "73:           this.accessControl.revokeRole(ROLE, authorized, { from: other }),",
          "74:           `${errorPrefix}: account ${other.toLowerCase()} is missing role ${DEFAULT_ADMIN_ROLE}`,",
          "75:         );",
          "76:       });",
          "78:       it('a role can be revoked multiple times', async function () {",
          "79:         await this.accessControl.revokeRole(ROLE, authorized, { from: admin });",
          "81:         const receipt = await this.accessControl.revokeRole(ROLE, authorized, { from: admin });",
          "82:         expectEvent.notEmitted(receipt, 'RoleRevoked');",
          "83:       });",
          "84:     });",
          "85:   });",
          "87:   describe('renouncing', function () {",
          "88:     it('roles that are not had can be renounced', async function () {",
          "89:       const receipt = await this.accessControl.renounceRole(ROLE, authorized, { from: authorized });",
          "90:       expectEvent.notEmitted(receipt, 'RoleRevoked');",
          "91:     });",
          "93:     context('with granted role', function () {",
          "94:       beforeEach(async function () {",
          "95:         await this.accessControl.grantRole(ROLE, authorized, { from: admin });",
          "96:       });",
          "98:       it('bearer can renounce role', async function () {",
          "99:         const receipt = await this.accessControl.renounceRole(ROLE, authorized, { from: authorized });",
          "100:         expectEvent(receipt, 'RoleRevoked', { account: authorized, role: ROLE, sender: authorized });",
          "102:         expect(await this.accessControl.hasRole(ROLE, authorized)).to.equal(false);",
          "103:       });",
          "105:       it('only the sender can renounce their roles', async function () {",
          "106:         await expectRevert(",
          "107:           this.accessControl.renounceRole(ROLE, authorized, { from: admin }),",
          "108:           `${errorPrefix}: can only renounce roles for self`,",
          "109:         );",
          "110:       });",
          "112:       it('a role can be renounced multiple times', async function () {",
          "113:         await this.accessControl.renounceRole(ROLE, authorized, { from: authorized });",
          "115:         const receipt = await this.accessControl.renounceRole(ROLE, authorized, { from: authorized });",
          "116:         expectEvent.notEmitted(receipt, 'RoleRevoked');",
          "117:       });",
          "118:     });",
          "119:   });",
          "121:   describe('setting role admin', function () {",
          "122:     beforeEach(async function () {",
          "123:       const receipt = await this.accessControl.$_setRoleAdmin(ROLE, OTHER_ROLE);",
          "124:       expectEvent(receipt, 'RoleAdminChanged', {",
          "125:         role: ROLE,",
          "126:         previousAdminRole: DEFAULT_ADMIN_ROLE,",
          "127:         newAdminRole: OTHER_ROLE,",
          "128:       });",
          "130:       await this.accessControl.grantRole(OTHER_ROLE, otherAdmin, { from: admin });",
          "131:     });",
          "133:     it(\"a role's admin role can be changed\", async function () {",
          "134:       expect(await this.accessControl.getRoleAdmin(ROLE)).to.equal(OTHER_ROLE);",
          "135:     });",
          "137:     it('the new admin can grant roles', async function () {",
          "138:       const receipt = await this.accessControl.grantRole(ROLE, authorized, { from: otherAdmin });",
          "139:       expectEvent(receipt, 'RoleGranted', { account: authorized, role: ROLE, sender: otherAdmin });",
          "140:     });",
          "142:     it('the new admin can revoke roles', async function () {",
          "143:       await this.accessControl.grantRole(ROLE, authorized, { from: otherAdmin });",
          "144:       const receipt = await this.accessControl.revokeRole(ROLE, authorized, { from: otherAdmin });",
          "145:       expectEvent(receipt, 'RoleRevoked', { account: authorized, role: ROLE, sender: otherAdmin });",
          "146:     });",
          "148:     it(\"a role's previous admins no longer grant roles\", async function () {",
          "149:       await expectRevert(",
          "150:         this.accessControl.grantRole(ROLE, authorized, { from: admin }),",
          "151:         `${errorPrefix}: account ${admin.toLowerCase()} is missing role ${OTHER_ROLE}`,",
          "152:       );",
          "153:     });",
          "155:     it(\"a role's previous admins no longer revoke roles\", async function () {",
          "156:       await expectRevert(",
          "157:         this.accessControl.revokeRole(ROLE, authorized, { from: admin }),",
          "158:         `${errorPrefix}: account ${admin.toLowerCase()} is missing role ${OTHER_ROLE}`,",
          "159:       );",
          "160:     });",
          "161:   });",
          "163:   describe('onlyRole modifier', function () {",
          "164:     beforeEach(async function () {",
          "165:       await this.accessControl.grantRole(ROLE, authorized, { from: admin });",
          "166:     });",
          "168:     it('do not revert if sender has role', async function () {",
          "169:       await this.accessControl.methods['$_checkRole(bytes32)'](ROLE, { from: authorized });",
          "170:     });",
          "172:     it(\"revert if sender doesn't have role #1\", async function () {",
          "173:       await expectRevert(",
          "174:         this.accessControl.methods['$_checkRole(bytes32)'](ROLE, { from: other }),",
          "175:         `${errorPrefix}: account ${other.toLowerCase()} is missing role ${ROLE}`,",
          "176:       );",
          "177:     });",
          "179:     it(\"revert if sender doesn't have role #2\", async function () {",
          "180:       await expectRevert(",
          "181:         this.accessControl.methods['$_checkRole(bytes32)'](OTHER_ROLE, { from: authorized }),",
          "182:         `${errorPrefix}: account ${authorized.toLowerCase()} is missing role ${OTHER_ROLE}`,",
          "183:       );",
          "184:     });",
          "185:   });",
          "186: }",
          "188: function shouldBehaveLikeAccessControlEnumerable(errorPrefix, admin, authorized, other, otherAdmin, otherAuthorized) {",
          "189:   shouldSupportInterfaces(['AccessControlEnumerable']);",
          "191:   describe('enumerating', function () {",
          "192:     it('role bearers can be enumerated', async function () {",
          "193:       await this.accessControl.grantRole(ROLE, authorized, { from: admin });",
          "194:       await this.accessControl.grantRole(ROLE, other, { from: admin });",
          "195:       await this.accessControl.grantRole(ROLE, otherAuthorized, { from: admin });",
          "196:       await this.accessControl.revokeRole(ROLE, other, { from: admin });",
          "198:       const memberCount = await this.accessControl.getRoleMemberCount(ROLE);",
          "199:       expect(memberCount).to.bignumber.equal('2');",
          "201:       const bearers = [];",
          "202:       for (let i = 0; i < memberCount; ++i) {",
          "203:         bearers.push(await this.accessControl.getRoleMember(ROLE, i));",
          "204:       }",
          "206:       expect(bearers).to.have.members([authorized, otherAuthorized]);",
          "207:     });",
          "208:     it('role enumeration should be in sync after renounceRole call', async function () {",
          "209:       expect(await this.accessControl.getRoleMemberCount(ROLE)).to.bignumber.equal('0');",
          "210:       await this.accessControl.grantRole(ROLE, admin, { from: admin });",
          "211:       expect(await this.accessControl.getRoleMemberCount(ROLE)).to.bignumber.equal('1');",
          "212:       await this.accessControl.renounceRole(ROLE, admin, { from: admin });",
          "213:       expect(await this.accessControl.getRoleMemberCount(ROLE)).to.bignumber.equal('0');",
          "214:     });",
          "215:   });",
          "216: }",
          "218: function shouldBehaveLikeAccessControlDefaultAdminRules(errorPrefix, delay, defaultAdmin, newDefaultAdmin, other) {",
          "219:   shouldSupportInterfaces(['AccessControlDefaultAdminRules']);",
          "221:   function expectNoEvent(receipt, eventName) {",
          "222:     try {",
          "223:       expectEvent(receipt, eventName);",
          "224:       throw new Error(`${eventName} event found`);",
          "225:     } catch (err) {",
          "226:       expect(err.message).to.eq(`No '${eventName}' events found: expected false to equal true`);",
          "227:     }",
          "228:   }",
          "230:   for (const getter of ['owner', 'defaultAdmin']) {",
          "231:     describe(`${getter}()`, function () {",
          "232:       it('has a default set to the initial default admin', async function () {",
          "233:         const value = await this.accessControl[getter]();",
          "234:         expect(value).to.equal(defaultAdmin);",
          "235:         expect(await this.accessControl.hasRole(DEFAULT_ADMIN_ROLE, value)).to.be.true;",
          "236:       });",
          "238:       it('changes if the default admin changes', async function () {",
          "240:         await this.accessControl.beginDefaultAdminTransfer(newDefaultAdmin, { from: defaultAdmin });",
          "243:         const acceptSchedule = web3.utils.toBN(await time.latest()).add(delay);",
          "244:         await time.setNextBlockTimestamp(acceptSchedule.addn(1));",
          "245:         await this.accessControl.acceptDefaultAdminTransfer({ from: newDefaultAdmin });",
          "247:         const value = await this.accessControl[getter]();",
          "248:         expect(value).to.equal(newDefaultAdmin);",
          "249:       });",
          "250:     });",
          "251:   }",
          "253:   describe('pendingDefaultAdmin()', function () {",
          "254:     it('returns 0 if no pending default admin transfer', async function () {",
          "255:       const { newAdmin, schedule } = await this.accessControl.pendingDefaultAdmin();",
          "256:       expect(newAdmin).to.eq(ZERO_ADDRESS);",
          "257:       expect(schedule).to.be.bignumber.eq(ZERO);",
          "258:     });",
          "260:     describe('when there is a scheduled default admin transfer', function () {",
          "261:       beforeEach('begins admin transfer', async function () {",
          "262:         await this.accessControl.beginDefaultAdminTransfer(newDefaultAdmin, { from: defaultAdmin });",
          "263:       });",
          "265:       for (const [fromSchedule, tag] of [",
          "266:         [-1, 'before'],",
          "267:         [0, 'exactly when'],",
          "268:         [1, 'after'],",
          "269:       ]) {",
          "270:         it(`returns pending admin and delay ${tag} delay schedule passes if not accepted`, async function () {",
          "272:           const { schedule: firstSchedule } = await this.accessControl.pendingDefaultAdmin();",
          "273:           await time.setNextBlockTimestamp(firstSchedule.toNumber() + fromSchedule);",
          "274:           await network.provider.send('evm_mine'); // Mine a block to force the timestamp",
          "276:           const { newAdmin, schedule } = await this.accessControl.pendingDefaultAdmin();",
          "277:           expect(newAdmin).to.eq(newDefaultAdmin);",
          "278:           expect(schedule).to.be.bignumber.eq(firstSchedule);",
          "279:         });",
          "280:       }",
          "282:       it('returns 0 after delay schedule passes and the transfer was accepted', async function () {",
          "284:         const { schedule: firstSchedule } = await this.accessControl.pendingDefaultAdmin();",
          "285:         await time.setNextBlockTimestamp(firstSchedule.addn(1));",
          "288:         await this.accessControl.acceptDefaultAdminTransfer({ from: newDefaultAdmin });",
          "290:         const { newAdmin, schedule } = await this.accessControl.pendingDefaultAdmin();",
          "291:         expect(newAdmin).to.eq(ZERO_ADDRESS);",
          "292:         expect(schedule).to.be.bignumber.eq(ZERO);",
          "293:       });",
          "294:     });",
          "295:   });",
          "297:   describe('defaultAdminDelay()', function () {",
          "298:     it('returns the current delay', async function () {",
          "299:       expect(await this.accessControl.defaultAdminDelay()).to.be.bignumber.eq(delay);",
          "300:     });",
          "302:     describe('when there is a scheduled delay change', function () {",
          "303:       const newDelay = web3.utils.toBN(0xdead); // Any change",
          "305:       beforeEach('begins delay change', async function () {",
          "306:         await this.accessControl.changeDefaultAdminDelay(newDelay, { from: defaultAdmin });",
          "307:       });",
          "309:       for (const [fromSchedule, tag, expectedDelay, delayTag] of [",
          "310:         [-1, 'before', delay, 'old'],",
          "311:         [0, 'exactly when', delay, 'old'],",
          "312:         [1, 'after', newDelay, 'new'],",
          "313:       ]) {",
          "314:         it(`returns ${delayTag} delay ${tag} delay schedule passes`, async function () {",
          "316:           const { schedule } = await this.accessControl.pendingDefaultAdminDelay();",
          "317:           await time.setNextBlockTimestamp(schedule.toNumber() + fromSchedule);",
          "318:           await network.provider.send('evm_mine'); // Mine a block to force the timestamp",
          "320:           const currentDelay = await this.accessControl.defaultAdminDelay();",
          "321:           expect(currentDelay).to.be.bignumber.eq(expectedDelay);",
          "322:         });",
          "323:       }",
          "324:     });",
          "325:   });",
          "327:   describe('pendingDefaultAdminDelay()', function () {",
          "328:     it('returns 0 if not set', async function () {",
          "329:       const { newDelay, schedule } = await this.accessControl.pendingDefaultAdminDelay();",
          "330:       expect(newDelay).to.be.bignumber.eq(ZERO);",
          "331:       expect(schedule).to.be.bignumber.eq(ZERO);",
          "332:     });",
          "334:     describe('when there is a scheduled delay change', function () {",
          "335:       const newDelay = web3.utils.toBN(0xdead); // Any change",
          "337:       beforeEach('begins admin transfer', async function () {",
          "338:         await this.accessControl.changeDefaultAdminDelay(newDelay, { from: defaultAdmin });",
          "339:       });",
          "341:       for (const [fromSchedule, tag, expectedDelay, delayTag, expectZeroSchedule] of [",
          "342:         [-1, 'before', newDelay, 'new'],",
          "343:         [0, 'exactly when', newDelay, 'new'],",
          "344:         [1, 'after', ZERO, 'zero', true],",
          "345:       ]) {",
          "346:         it(`returns ${delayTag} delay ${tag} delay schedule passes`, async function () {",
          "348:           const { schedule: firstSchedule } = await this.accessControl.pendingDefaultAdminDelay();",
          "349:           await time.setNextBlockTimestamp(firstSchedule.toNumber() + fromSchedule);",
          "350:           await network.provider.send('evm_mine'); // Mine a block to force the timestamp",
          "352:           const { newDelay, schedule } = await this.accessControl.pendingDefaultAdminDelay();",
          "353:           expect(newDelay).to.be.bignumber.eq(expectedDelay);",
          "354:           expect(schedule).to.be.bignumber.eq(expectZeroSchedule ? ZERO : firstSchedule);",
          "355:         });",
          "356:       }",
          "357:     });",
          "358:   });",
          "360:   describe('defaultAdminDelayIncreaseWait()', function () {",
          "361:     it('should return 5 days (default)', async function () {",
          "362:       expect(await this.accessControl.defaultAdminDelayIncreaseWait()).to.be.bignumber.eq(",
          "363:         web3.utils.toBN(time.duration.days(5)),",
          "364:       );",
          "365:     });",
          "366:   });",
          "368:   it('should revert if granting default admin role', async function () {",
          "369:     await expectRevert(",
          "370:       this.accessControl.grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin, { from: defaultAdmin }),",
          "371:       `${errorPrefix}: can't directly grant default admin role`,",
          "372:     );",
          "373:   });",
          "375:   it('should revert if revoking default admin role', async function () {",
          "376:     await expectRevert(",
          "377:       this.accessControl.revokeRole(DEFAULT_ADMIN_ROLE, defaultAdmin, { from: defaultAdmin }),",
          "378:       `${errorPrefix}: can't directly revoke default admin role`,",
          "379:     );",
          "380:   });",
          "382:   it(\"should revert if defaultAdmin's admin is changed\", async function () {",
          "383:     await expectRevert(",
          "384:       this.accessControl.$_setRoleAdmin(DEFAULT_ADMIN_ROLE, defaultAdmin),",
          "385:       `${errorPrefix}: can't violate default admin rules`,",
          "386:     );",
          "387:   });",
          "389:   it('should not grant the default admin role twice', async function () {",
          "390:     await expectRevert(",
          "391:       this.accessControl.$_grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin),",
          "392:       `${errorPrefix}: default admin already granted`,",
          "393:     );",
          "394:   });",
          "396:   describe('begins a default admin transfer', function () {",
          "397:     let receipt;",
          "398:     let acceptSchedule;",
          "400:     it('reverts if called by non default admin accounts', async function () {",
          "401:       await expectRevert(",
          "402:         this.accessControl.beginDefaultAdminTransfer(newDefaultAdmin, { from: other }),",
          "403:         `${errorPrefix}: account ${other.toLowerCase()} is missing role ${DEFAULT_ADMIN_ROLE}`,",
          "404:       );",
          "405:     });",
          "407:     describe('when there is no pending delay nor pending admin transfer', function () {",
          "408:       beforeEach('begins admin transfer', async function () {",
          "409:         receipt = await this.accessControl.beginDefaultAdminTransfer(newDefaultAdmin, { from: defaultAdmin });",
          "410:         acceptSchedule = web3.utils.toBN(await time.latest()).add(delay);",
          "411:       });",
          "413:       it('should set pending default admin and schedule', async function () {",
          "414:         const { newAdmin, schedule } = await this.accessControl.pendingDefaultAdmin();",
          "415:         expect(newAdmin).to.equal(newDefaultAdmin);",
          "416:         expect(schedule).to.be.bignumber.equal(acceptSchedule);",
          "417:         expectEvent(receipt, 'DefaultAdminTransferScheduled', {",
          "418:           newAdmin,",
          "419:           acceptSchedule,",
          "420:         });",
          "421:       });",
          "422:     });",
          "424:     describe('when there is a pending admin transfer', function () {",
          "425:       beforeEach('sets a pending default admin transfer', async function () {",
          "426:         await this.accessControl.beginDefaultAdminTransfer(newDefaultAdmin, { from: defaultAdmin });",
          "427:         acceptSchedule = web3.utils.toBN(await time.latest()).add(delay);",
          "428:       });",
          "430:       for (const [fromSchedule, tag] of [",
          "431:         [-1, 'before'],",
          "432:         [0, 'exactly when'],",
          "433:         [1, 'after'],",
          "434:       ]) {",
          "435:         it(`should be able to begin a transfer again ${tag} acceptSchedule passes`, async function () {",
          "437:           await time.setNextBlockTimestamp(acceptSchedule.toNumber() + fromSchedule);",
          "440:           const receipt = await this.accessControl.beginDefaultAdminTransfer(other, { from: defaultAdmin });",
          "441:           const newSchedule = web3.utils.toBN(await time.latest()).add(delay);",
          "442:           const { newAdmin, schedule } = await this.accessControl.pendingDefaultAdmin();",
          "443:           expect(newAdmin).to.equal(other);",
          "444:           expect(schedule).to.be.bignumber.equal(newSchedule);",
          "447:           expectEvent(receipt, 'DefaultAdminTransferCanceled');",
          "448:         });",
          "449:       }",
          "451:       it('should not emit a cancellation event if the new default admin accepted', async function () {",
          "453:         await time.setNextBlockTimestamp(acceptSchedule.addn(1));",
          "456:         await this.accessControl.acceptDefaultAdminTransfer({ from: newDefaultAdmin });",
          "457:         const receipt = await this.accessControl.beginDefaultAdminTransfer(other, { from: newDefaultAdmin });",
          "459:         expectNoEvent(receipt, 'DefaultAdminTransferCanceled');",
          "460:       });",
          "461:     });",
          "463:     describe('when there is a pending delay', function () {",
          "464:       const newDelay = web3.utils.toBN(time.duration.hours(3));",
          "466:       beforeEach('schedule a delay change', async function () {",
          "467:         await this.accessControl.changeDefaultAdminDelay(newDelay, { from: defaultAdmin });",
          "468:         const pendingDefaultAdminDelay = await this.accessControl.pendingDefaultAdminDelay();",
          "469:         acceptSchedule = pendingDefaultAdminDelay.schedule;",
          "470:       });",
          "472:       for (const [fromSchedule, schedulePassed, expectedDelay, delayTag] of [",
          "473:         [-1, 'before', delay, 'old'],",
          "474:         [0, 'exactly when', delay, 'old'],",
          "475:         [1, 'after', newDelay, 'new'],",
          "476:       ]) {",
          "477:         it(`should set the ${delayTag} delay and apply it to next default admin transfer schedule ${schedulePassed} acceptSchedule passed`, async function () {",
          "479:           await time.setNextBlockTimestamp(acceptSchedule.toNumber() + fromSchedule);",
          "482:           const receipt = await this.accessControl.beginDefaultAdminTransfer(newDefaultAdmin, { from: defaultAdmin });",
          "483:           const expectedAcceptSchedule = web3.utils.toBN(await time.latest()).add(expectedDelay);",
          "486:           const { newAdmin, schedule: transferSchedule } = await this.accessControl.pendingDefaultAdmin();",
          "487:           expect(newAdmin).to.equal(newDefaultAdmin);",
          "488:           expect(transferSchedule).to.be.bignumber.equal(expectedAcceptSchedule);",
          "490:           expectEvent(receipt, 'DefaultAdminTransferScheduled', {",
          "491:             newAdmin,",
          "492:             acceptSchedule: expectedAcceptSchedule,",
          "493:           });",
          "494:         });",
          "495:       }",
          "496:     });",
          "497:   });",
          "499:   describe('accepts transfer admin', function () {",
          "500:     let acceptSchedule;",
          "502:     beforeEach(async function () {",
          "503:       await this.accessControl.beginDefaultAdminTransfer(newDefaultAdmin, { from: defaultAdmin });",
          "504:       acceptSchedule = web3.utils.toBN(await time.latest()).add(delay);",
          "505:     });",
          "507:     it('should revert if caller is not pending default admin', async function () {",
          "508:       await time.setNextBlockTimestamp(acceptSchedule.addn(1));",
          "509:       await expectRevert(",
          "510:         this.accessControl.acceptDefaultAdminTransfer({ from: other }),",
          "511:         `${errorPrefix}: pending admin must accept`,",
          "512:       );",
          "513:     });",
          "515:     describe('when caller is pending default admin and delay has passed', function () {",
          "516:       beforeEach(async function () {",
          "517:         await time.setNextBlockTimestamp(acceptSchedule.addn(1));",
          "518:       });",
          "520:       it('accepts a transfer and changes default admin', async function () {",
          "521:         const receipt = await this.accessControl.acceptDefaultAdminTransfer({ from: newDefaultAdmin });",
          "524:         expect(await this.accessControl.hasRole(DEFAULT_ADMIN_ROLE, defaultAdmin)).to.be.false;",
          "525:         expect(await this.accessControl.hasRole(DEFAULT_ADMIN_ROLE, newDefaultAdmin)).to.be.true;",
          "526:         expect(await this.accessControl.owner()).to.equal(newDefaultAdmin);",
          "529:         expectEvent(receipt, 'RoleRevoked', {",
          "530:           role: DEFAULT_ADMIN_ROLE,",
          "531:           account: defaultAdmin,",
          "532:         });",
          "533:         expectEvent(receipt, 'RoleGranted', {",
          "534:           role: DEFAULT_ADMIN_ROLE,",
          "535:           account: newDefaultAdmin,",
          "536:         });",
          "539:         const { newAdmin, schedule } = await this.accessControl.pendingDefaultAdmin();",
          "540:         expect(newAdmin).to.equal(constants.ZERO_ADDRESS);",
          "541:         expect(schedule).to.be.bignumber.equal(ZERO);",
          "542:       });",
          "543:     });",
          "545:     describe('schedule not passed', function () {",
          "546:       for (const [fromSchedule, tag] of [",
          "547:         [-1, 'less'],",
          "548:         [0, 'equal'],",
          "549:       ]) {",
          "550:         it(`should revert if block.timestamp is ${tag} to schedule`, async function () {",
          "551:           await time.setNextBlockTimestamp(acceptSchedule.toNumber() + fromSchedule);",
          "552:           await expectRevert(",
          "553:             this.accessControl.acceptDefaultAdminTransfer({ from: newDefaultAdmin }),",
          "554:             `${errorPrefix}: transfer delay not passed`,",
          "555:           );",
          "556:         });",
          "557:       }",
          "558:     });",
          "559:   });",
          "561:   describe('cancels a default admin transfer', function () {",
          "562:     it('reverts if called by non default admin accounts', async function () {",
          "563:       await expectRevert(",
          "564:         this.accessControl.cancelDefaultAdminTransfer({ from: other }),",
          "565:         `${errorPrefix}: account ${other.toLowerCase()} is missing role ${DEFAULT_ADMIN_ROLE}`,",
          "566:       );",
          "567:     });",
          "569:     describe('when there is a pending default admin transfer', function () {",
          "570:       let acceptSchedule;",
          "572:       beforeEach(async function () {",
          "573:         await this.accessControl.beginDefaultAdminTransfer(newDefaultAdmin, { from: defaultAdmin });",
          "574:         acceptSchedule = web3.utils.toBN(await time.latest()).add(delay);",
          "575:       });",
          "577:       for (const [fromSchedule, tag] of [",
          "578:         [-1, 'before'],",
          "579:         [0, 'exactly when'],",
          "580:         [1, 'after'],",
          "581:       ]) {",
          "582:         it(`resets pending default admin and schedule ${tag} transfer schedule passes`, async function () {",
          "584:           await time.setNextBlockTimestamp(acceptSchedule.toNumber() + fromSchedule);",
          "586:           const receipt = await this.accessControl.cancelDefaultAdminTransfer({ from: defaultAdmin });",
          "588:           const { newAdmin, schedule } = await this.accessControl.pendingDefaultAdmin();",
          "589:           expect(newAdmin).to.equal(constants.ZERO_ADDRESS);",
          "590:           expect(schedule).to.be.bignumber.equal(ZERO);",
          "592:           expectEvent(receipt, 'DefaultAdminTransferCanceled');",
          "593:         });",
          "594:       }",
          "596:       it('should revert if the previous default admin tries to accept', async function () {",
          "597:         await this.accessControl.cancelDefaultAdminTransfer({ from: defaultAdmin });",
          "600:         await time.setNextBlockTimestamp(acceptSchedule.addn(1));",
          "603:         await expectRevert(",
          "604:           this.accessControl.acceptDefaultAdminTransfer({ from: newDefaultAdmin }),",
          "605:           `${errorPrefix}: pending admin must accept`,",
          "606:         );",
          "607:       });",
          "608:     });",
          "610:     describe('when there is no pending default admin transfer', async function () {",
          "611:       it('should succeed without changes', async function () {",
          "612:         const receipt = await this.accessControl.cancelDefaultAdminTransfer({ from: defaultAdmin });",
          "614:         const { newAdmin, schedule } = await this.accessControl.pendingDefaultAdmin();",
          "615:         expect(newAdmin).to.equal(constants.ZERO_ADDRESS);",
          "616:         expect(schedule).to.be.bignumber.equal(ZERO);",
          "618:         expectNoEvent(receipt, 'DefaultAdminTransferCanceled');",
          "619:       });",
          "620:     });",
          "621:   });",
          "623:   describe('renounces admin', function () {",
          "624:     let delayPassed;",
          "626:     beforeEach(async function () {",
          "627:       await this.accessControl.beginDefaultAdminTransfer(constants.ZERO_ADDRESS, { from: defaultAdmin });",
          "628:       delayPassed = web3.utils",
          "629:         .toBN(await time.latest())",
          "630:         .add(delay)",
          "631:         .addn(1);",
          "632:     });",
          "634:     it('reverts if caller is not default admin', async function () {",
          "635:       await time.setNextBlockTimestamp(delayPassed);",
          "636:       await expectRevert(",
          "637:         this.accessControl.renounceRole(DEFAULT_ADMIN_ROLE, other, { from: defaultAdmin }),",
          "638:         `${errorPrefix}: can only renounce roles for self`,",
          "639:       );",
          "640:     });",
          "642:     it('keeps defaultAdmin consistent with hasRole if another non-defaultAdmin user renounces the DEFAULT_ADMIN_ROLE', async function () {",
          "643:       await time.setNextBlockTimestamp(delayPassed);",
          "646:       await this.accessControl.renounceRole(DEFAULT_ADMIN_ROLE, other, { from: other });",
          "648:       expect(await this.accessControl.hasRole(DEFAULT_ADMIN_ROLE, defaultAdmin)).to.be.true;",
          "649:       expect(await this.accessControl.defaultAdmin()).to.be.equal(defaultAdmin);",
          "650:     });",
          "652:     it('renounces role', async function () {",
          "653:       await time.setNextBlockTimestamp(delayPassed);",
          "654:       const receipt = await this.accessControl.renounceRole(DEFAULT_ADMIN_ROLE, defaultAdmin, { from: defaultAdmin });",
          "656:       expect(await this.accessControl.hasRole(DEFAULT_ADMIN_ROLE, defaultAdmin)).to.be.false;",
          "657:       expect(await this.accessControl.defaultAdmin()).to.be.equal(constants.ZERO_ADDRESS);",
          "658:       expectEvent(receipt, 'RoleRevoked', {",
          "659:         role: DEFAULT_ADMIN_ROLE,",
          "660:         account: defaultAdmin,",
          "661:       });",
          "662:       expect(await this.accessControl.owner()).to.equal(constants.ZERO_ADDRESS);",
          "663:     });",
          "665:     it('allows to recover access using the internal _grantRole', async function () {",
          "666:       await time.setNextBlockTimestamp(delayPassed);",
          "667:       await this.accessControl.renounceRole(DEFAULT_ADMIN_ROLE, defaultAdmin, { from: defaultAdmin });",
          "669:       const grantRoleReceipt = await this.accessControl.$_grantRole(DEFAULT_ADMIN_ROLE, other);",
          "670:       expectEvent(grantRoleReceipt, 'RoleGranted', {",
          "671:         role: DEFAULT_ADMIN_ROLE,",
          "672:         account: other,",
          "673:       });",
          "674:     });",
          "676:     describe('schedule not passed', function () {",
          "677:       let delayNotPassed;",
          "679:       beforeEach(function () {",
          "680:         delayNotPassed = delayPassed.subn(1);",
          "681:       });",
          "683:       for (const [fromSchedule, tag] of [",
          "684:         [-1, 'less'],",
          "685:         [0, 'equal'],",
          "686:       ]) {",
          "687:         it(`reverts if block.timestamp is ${tag} to schedule`, async function () {",
          "688:           await time.setNextBlockTimestamp(delayNotPassed.toNumber() + fromSchedule);",
          "689:           await expectRevert(",
          "690:             this.accessControl.renounceRole(DEFAULT_ADMIN_ROLE, defaultAdmin, { from: defaultAdmin }),",
          "691:             `${errorPrefix}: only can renounce in two delayed steps`,",
          "692:           );",
          "693:         });",
          "694:       }",
          "695:     });",
          "696:   });",
          "698:   describe('changes delay', function () {",
          "699:     it('reverts if called by non default admin accounts', async function () {",
          "700:       await expectRevert(",
          "701:         this.accessControl.changeDefaultAdminDelay(time.duration.hours(4), {",
          "702:           from: other,",
          "703:         }),",
          "704:         `${errorPrefix}: account ${other.toLowerCase()} is missing role ${DEFAULT_ADMIN_ROLE}`,",
          "705:       );",
          "706:     });",
          "708:     for (const [newDefaultAdminDelay, delayChangeType] of [",
          "709:       [web3.utils.toBN(delay).subn(time.duration.hours(1)), 'decreased'],",
          "710:       [web3.utils.toBN(delay).addn(time.duration.hours(1)), 'increased'],",
          "711:       [web3.utils.toBN(delay).addn(time.duration.days(5)), 'increased to more than 5 days'],",
          "712:     ]) {",
          "713:       describe(`when the delay is ${delayChangeType}`, function () {",
          "714:         it('begins the delay change to the new delay', async function () {",
          "716:           const receipt = await this.accessControl.changeDefaultAdminDelay(newDefaultAdminDelay, {",
          "717:             from: defaultAdmin,",
          "718:           });",
          "721:           const cap = await this.accessControl.defaultAdminDelayIncreaseWait();",
          "722:           const changeDelay = newDefaultAdminDelay.lte(delay)",
          "723:             ? delay.sub(newDefaultAdminDelay)",
          "724:             : BN.min(newDefaultAdminDelay, cap);",
          "725:           const timestamp = web3.utils.toBN(await time.latest());",
          "726:           const effectSchedule = timestamp.add(changeDelay);",
          "729:           const { newDelay, schedule } = await this.accessControl.pendingDefaultAdminDelay();",
          "730:           expect(newDelay).to.be.bignumber.eq(newDefaultAdminDelay);",
          "731:           expect(schedule).to.be.bignumber.eq(effectSchedule);",
          "732:           expectEvent(receipt, 'DefaultAdminDelayChangeScheduled', {",
          "733:             newDelay,",
          "734:             effectSchedule,",
          "735:           });",
          "736:         });",
          "738:         describe('scheduling again', function () {",
          "739:           beforeEach('schedule once', async function () {",
          "740:             await this.accessControl.changeDefaultAdminDelay(newDefaultAdminDelay, { from: defaultAdmin });",
          "741:           });",
          "743:           for (const [fromSchedule, tag] of [",
          "744:             [-1, 'before'],",
          "745:             [0, 'exactly when'],",
          "746:             [1, 'after'],",
          "747:           ]) {",
          "748:             const passed = fromSchedule > 0;",
          "750:             it(`succeeds ${tag} the delay schedule passes`, async function () {",
          "752:               const { schedule: firstSchedule } = await this.accessControl.pendingDefaultAdminDelay();",
          "753:               await time.setNextBlockTimestamp(firstSchedule.toNumber() + fromSchedule);",
          "756:               const anotherNewDefaultAdminDelay = newDefaultAdminDelay.addn(time.duration.hours(2));",
          "757:               const receipt = await this.accessControl.changeDefaultAdminDelay(anotherNewDefaultAdminDelay, {",
          "758:                 from: defaultAdmin,",
          "759:               });",
          "762:               const cap = await this.accessControl.defaultAdminDelayIncreaseWait();",
          "763:               const timestamp = web3.utils.toBN(await time.latest());",
          "764:               const effectSchedule = timestamp.add(BN.min(cap, anotherNewDefaultAdminDelay));",
          "767:               const { newDelay, schedule } = await this.accessControl.pendingDefaultAdminDelay();",
          "768:               expect(newDelay).to.be.bignumber.eq(anotherNewDefaultAdminDelay);",
          "769:               expect(schedule).to.be.bignumber.eq(effectSchedule);",
          "770:               expectEvent(receipt, 'DefaultAdminDelayChangeScheduled', {",
          "771:                 newDelay,",
          "772:                 effectSchedule,",
          "773:               });",
          "774:             });",
          "776:             const emit = passed ? 'not emit' : 'emit';",
          "777:             it(`should ${emit} a cancellation event ${tag} the delay schedule passes`, async function () {",
          "779:               const { schedule: firstSchedule } = await this.accessControl.pendingDefaultAdminDelay();",
          "780:               await time.setNextBlockTimestamp(firstSchedule.toNumber() + fromSchedule);",
          "783:               const anotherNewDefaultAdminDelay = newDefaultAdminDelay.addn(time.duration.hours(2));",
          "784:               const receipt = await this.accessControl.changeDefaultAdminDelay(anotherNewDefaultAdminDelay, {",
          "785:                 from: defaultAdmin,",
          "786:               });",
          "788:               const eventMatcher = passed ? expectNoEvent : expectEvent;",
          "789:               eventMatcher(receipt, 'DefaultAdminDelayChangeCanceled');",
          "790:             });",
          "791:           }",
          "792:         });",
          "793:       });",
          "794:     }",
          "795:   });",
          "797:   describe('rollbacks a delay change', function () {",
          "798:     it('reverts if called by non default admin accounts', async function () {",
          "799:       await expectRevert(",
          "800:         this.accessControl.rollbackDefaultAdminDelay({ from: other }),",
          "801:         `${errorPrefix}: account ${other.toLowerCase()} is missing role ${DEFAULT_ADMIN_ROLE}`,",
          "802:       );",
          "803:     });",
          "805:     describe('when there is a pending delay', function () {",
          "806:       beforeEach('set pending delay', async function () {",
          "807:         await this.accessControl.changeDefaultAdminDelay(time.duration.hours(12), { from: defaultAdmin });",
          "808:       });",
          "810:       for (const [fromSchedule, tag] of [",
          "811:         [-1, 'before'],",
          "812:         [0, 'exactly when'],",
          "813:         [1, 'after'],",
          "814:       ]) {",
          "815:         const passed = fromSchedule > 0;",
          "817:         it(`resets pending delay and schedule ${tag} delay change schedule passes`, async function () {",
          "819:           const { schedule: firstSchedule } = await this.accessControl.pendingDefaultAdminDelay();",
          "820:           await time.setNextBlockTimestamp(firstSchedule.toNumber() + fromSchedule);",
          "822:           await this.accessControl.rollbackDefaultAdminDelay({ from: defaultAdmin });",
          "824:           const { newDelay, schedule } = await this.accessControl.pendingDefaultAdminDelay();",
          "825:           expect(newDelay).to.be.bignumber.eq(ZERO);",
          "826:           expect(schedule).to.be.bignumber.eq(ZERO);",
          "827:         });",
          "829:         const emit = passed ? 'not emit' : 'emit';",
          "830:         it(`should ${emit} a cancellation event ${tag} the delay schedule passes`, async function () {",
          "832:           const { schedule: firstSchedule } = await this.accessControl.pendingDefaultAdminDelay();",
          "833:           await time.setNextBlockTimestamp(firstSchedule.toNumber() + fromSchedule);",
          "835:           const receipt = await this.accessControl.rollbackDefaultAdminDelay({ from: defaultAdmin });",
          "837:           const eventMatcher = passed ? expectNoEvent : expectEvent;",
          "838:           eventMatcher(receipt, 'DefaultAdminDelayChangeCanceled');",
          "839:         });",
          "840:       }",
          "841:     });",
          "843:     describe('when there is no pending delay', function () {",
          "844:       it('succeeds without changes', async function () {",
          "845:         await this.accessControl.rollbackDefaultAdminDelay({ from: defaultAdmin });",
          "847:         const { newDelay, schedule } = await this.accessControl.pendingDefaultAdminDelay();",
          "848:         expect(newDelay).to.be.bignumber.eq(ZERO);",
          "849:         expect(schedule).to.be.bignumber.eq(ZERO);",
          "850:       });",
          "851:     });",
          "852:   });",
          "853: }",
          "855: module.exports = {",
          "856:   DEFAULT_ADMIN_ROLE,",
          "857:   shouldBehaveLikeAccessControl,",
          "858:   shouldBehaveLikeAccessControlEnumerable,",
          "859:   shouldBehaveLikeAccessControlDefaultAdminRules,",
          "860: };",
          "",
          "---------------"
        ],
        "test/access/AccessControl.test.js||test/access/AccessControl.test.js": [
          "File: test/access/AccessControl.test.js -> test/access/AccessControl.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { DEFAULT_ADMIN_ROLE, shouldBehaveLikeAccessControl } = require('./AccessControl.behavior.js');",
          "3: const AccessControl = artifacts.require('$AccessControl');",
          "5: contract('AccessControl', function (accounts) {",
          "6:   beforeEach(async function () {",
          "7:     this.accessControl = await AccessControl.new({ from: accounts[0] });",
          "8:     await this.accessControl.$_grantRole(DEFAULT_ADMIN_ROLE, accounts[0]);",
          "9:   });",
          "11:   shouldBehaveLikeAccessControl('AccessControl', ...accounts);",
          "12: });",
          "",
          "---------------"
        ],
        "test/access/AccessControlCrossChain.test.js||test/access/AccessControlCrossChain.test.js": [
          "File: test/access/AccessControlCrossChain.test.js -> test/access/AccessControlCrossChain.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { BridgeHelper } = require('../helpers/crosschain');",
          "4: const { DEFAULT_ADMIN_ROLE, shouldBehaveLikeAccessControl } = require('./AccessControl.behavior.js');",
          "6: const crossChainRoleAlias = role =>",
          "7:   web3.utils.leftPad(",
          "8:     web3.utils.toHex(web3.utils.toBN(role).xor(web3.utils.toBN(web3.utils.soliditySha3('CROSSCHAIN_ALIAS')))),",
          "9:     64,",
          "10:   );",
          "12: const AccessControlCrossChainMock = artifacts.require('$AccessControlCrossChainMock');",
          "14: const ROLE = web3.utils.soliditySha3('ROLE');",
          "16: contract('AccessControl', function (accounts) {",
          "17:   before(async function () {",
          "18:     this.bridge = await BridgeHelper.deploy();",
          "19:   });",
          "21:   beforeEach(async function () {",
          "22:     this.accessControl = await AccessControlCrossChainMock.new({ from: accounts[0] });",
          "23:     await this.accessControl.$_grantRole(DEFAULT_ADMIN_ROLE, accounts[0]);",
          "24:   });",
          "26:   shouldBehaveLikeAccessControl('AccessControl', ...accounts);",
          "28:   describe('CrossChain enabled', function () {",
          "29:     beforeEach(async function () {",
          "30:       await this.accessControl.grantRole(ROLE, accounts[0], { from: accounts[0] });",
          "31:       await this.accessControl.grantRole(crossChainRoleAlias(ROLE), accounts[1], { from: accounts[0] });",
          "32:     });",
          "34:     it('check alliassing', async function () {",
          "35:       expect(await this.accessControl.$_crossChainRoleAlias(ROLE)).to.be.bignumber.equal(crossChainRoleAlias(ROLE));",
          "36:     });",
          "38:     it('Crosschain calls not authorized to non-aliased addresses', async function () {",
          "39:       await expectRevert(",
          "40:         this.bridge.call(accounts[0], this.accessControl, '$_checkRole(bytes32)', [ROLE]),",
          "41:         `AccessControl: account ${accounts[0].toLowerCase()} is missing role ${crossChainRoleAlias(ROLE)}`,",
          "42:       );",
          "43:     });",
          "45:     it('Crosschain calls not authorized to non-aliased addresses', async function () {",
          "46:       await this.bridge.call(accounts[1], this.accessControl, '$_checkRole(bytes32)', [ROLE]);",
          "47:     });",
          "48:   });",
          "49: });",
          "",
          "---------------"
        ],
        "test/access/AccessControlDefaultAdminRules.test.js||test/access/AccessControlDefaultAdminRules.test.js": [
          "File: test/access/AccessControlDefaultAdminRules.test.js -> test/access/AccessControlDefaultAdminRules.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { time, constants, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const {",
          "3:   shouldBehaveLikeAccessControl,",
          "4:   shouldBehaveLikeAccessControlDefaultAdminRules,",
          "5: } = require('./AccessControl.behavior.js');",
          "7: const AccessControlDefaultAdminRules = artifacts.require('$AccessControlDefaultAdminRules');",
          "9: contract('AccessControlDefaultAdminRules', function (accounts) {",
          "10:   const delay = web3.utils.toBN(time.duration.hours(10));",
          "12:   beforeEach(async function () {",
          "13:     this.accessControl = await AccessControlDefaultAdminRules.new(delay, accounts[0], { from: accounts[0] });",
          "14:   });",
          "16:   it('initial admin not zero', async function () {",
          "17:     await expectRevert(",
          "18:       AccessControlDefaultAdminRules.new(delay, constants.ZERO_ADDRESS),",
          "19:       'AccessControl: 0 default admin',",
          "20:     );",
          "21:   });",
          "23:   shouldBehaveLikeAccessControl('AccessControl', ...accounts);",
          "24:   shouldBehaveLikeAccessControlDefaultAdminRules('AccessControl', delay, ...accounts);",
          "25: });",
          "",
          "---------------"
        ],
        "test/access/AccessControlEnumerable.test.js||test/access/AccessControlEnumerable.test.js": [
          "File: test/access/AccessControlEnumerable.test.js -> test/access/AccessControlEnumerable.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const {",
          "2:   DEFAULT_ADMIN_ROLE,",
          "3:   shouldBehaveLikeAccessControl,",
          "4:   shouldBehaveLikeAccessControlEnumerable,",
          "5: } = require('./AccessControl.behavior.js');",
          "7: const AccessControlEnumerable = artifacts.require('$AccessControlEnumerable');",
          "9: contract('AccessControl', function (accounts) {",
          "10:   beforeEach(async function () {",
          "11:     this.accessControl = await AccessControlEnumerable.new({ from: accounts[0] });",
          "12:     await this.accessControl.$_grantRole(DEFAULT_ADMIN_ROLE, accounts[0]);",
          "13:   });",
          "15:   shouldBehaveLikeAccessControl('AccessControl', ...accounts);",
          "16:   shouldBehaveLikeAccessControlEnumerable('AccessControl', ...accounts);",
          "17: });",
          "",
          "---------------"
        ],
        "test/access/Ownable.test.js||test/access/Ownable.test.js": [
          "File: test/access/Ownable.test.js -> test/access/Ownable.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS } = constants;",
          "4: const { expect } = require('chai');",
          "6: const Ownable = artifacts.require('$Ownable');",
          "8: contract('Ownable', function (accounts) {",
          "9:   const [owner, other] = accounts;",
          "11:   beforeEach(async function () {",
          "12:     this.ownable = await Ownable.new({ from: owner });",
          "13:   });",
          "15:   it('has an owner', async function () {",
          "16:     expect(await this.ownable.owner()).to.equal(owner);",
          "17:   });",
          "19:   describe('transfer ownership', function () {",
          "20:     it('changes owner after transfer', async function () {",
          "21:       const receipt = await this.ownable.transferOwnership(other, { from: owner });",
          "22:       expectEvent(receipt, 'OwnershipTransferred');",
          "24:       expect(await this.ownable.owner()).to.equal(other);",
          "25:     });",
          "27:     it('prevents non-owners from transferring', async function () {",
          "28:       await expectRevert(this.ownable.transferOwnership(other, { from: other }), 'Ownable: caller is not the owner');",
          "29:     });",
          "31:     it('guards ownership against stuck state', async function () {",
          "32:       await expectRevert(",
          "33:         this.ownable.transferOwnership(ZERO_ADDRESS, { from: owner }),",
          "34:         'Ownable: new owner is the zero address',",
          "35:       );",
          "36:     });",
          "37:   });",
          "39:   describe('renounce ownership', function () {",
          "40:     it('loses ownership after renouncement', async function () {",
          "41:       const receipt = await this.ownable.renounceOwnership({ from: owner });",
          "42:       expectEvent(receipt, 'OwnershipTransferred');",
          "44:       expect(await this.ownable.owner()).to.equal(ZERO_ADDRESS);",
          "45:     });",
          "47:     it('prevents non-owners from renouncement', async function () {",
          "48:       await expectRevert(this.ownable.renounceOwnership({ from: other }), 'Ownable: caller is not the owner');",
          "49:     });",
          "51:     it('allows to recover access using the internal _transferOwnership', async function () {",
          "52:       await this.ownable.renounceOwnership({ from: owner });",
          "53:       const receipt = await this.ownable.$_transferOwnership(other);",
          "54:       expectEvent(receipt, 'OwnershipTransferred');",
          "56:       expect(await this.ownable.owner()).to.equal(other);",
          "57:     });",
          "58:   });",
          "59: });",
          "",
          "---------------"
        ],
        "test/access/Ownable2Step.test.js||test/access/Ownable2Step.test.js": [
          "File: test/access/Ownable2Step.test.js -> test/access/Ownable2Step.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS } = constants;",
          "3: const { expect } = require('chai');",
          "5: const Ownable2Step = artifacts.require('$Ownable2Step');",
          "7: contract('Ownable2Step', function (accounts) {",
          "8:   const [owner, accountA, accountB] = accounts;",
          "10:   beforeEach(async function () {",
          "11:     this.ownable2Step = await Ownable2Step.new({ from: owner });",
          "12:   });",
          "14:   describe('transfer ownership', function () {",
          "15:     it('starting a transfer does not change owner', async function () {",
          "16:       const receipt = await this.ownable2Step.transferOwnership(accountA, { from: owner });",
          "17:       expectEvent(receipt, 'OwnershipTransferStarted', { previousOwner: owner, newOwner: accountA });",
          "18:       expect(await this.ownable2Step.owner()).to.equal(owner);",
          "19:       expect(await this.ownable2Step.pendingOwner()).to.equal(accountA);",
          "20:     });",
          "22:     it('changes owner after transfer', async function () {",
          "23:       await this.ownable2Step.transferOwnership(accountA, { from: owner });",
          "24:       const receipt = await this.ownable2Step.acceptOwnership({ from: accountA });",
          "25:       expectEvent(receipt, 'OwnershipTransferred', { previousOwner: owner, newOwner: accountA });",
          "26:       expect(await this.ownable2Step.owner()).to.equal(accountA);",
          "27:       expect(await this.ownable2Step.pendingOwner()).to.not.equal(accountA);",
          "28:     });",
          "30:     it('guards transfer against invalid user', async function () {",
          "31:       await this.ownable2Step.transferOwnership(accountA, { from: owner });",
          "32:       await expectRevert(",
          "33:         this.ownable2Step.acceptOwnership({ from: accountB }),",
          "34:         'Ownable2Step: caller is not the new owner',",
          "35:       );",
          "36:     });",
          "37:   });",
          "39:   it('renouncing ownership', async function () {",
          "40:     it('changes owner after renouncing ownership', async function () {",
          "41:       await this.ownable2Step.renounceOwnership({ from: owner });",
          "45:       expect(await this.ownable2Step.owner()).to.equal(ZERO_ADDRESS);",
          "46:     });",
          "48:     it('pending owner resets after renouncing ownership', async function () {",
          "49:       await this.ownable2Step.transferOwnership(accountA, { from: owner });",
          "50:       expect(await this.ownable2Step.pendingOwner()).to.equal(accountA);",
          "51:       await this.ownable2Step.renounceOwnership({ from: owner });",
          "52:       expect(await this.ownable2Step.pendingOwner()).to.equal(ZERO_ADDRESS);",
          "53:       await expectRevert(",
          "54:         this.ownable2Step.acceptOwnership({ from: accountA }),",
          "55:         'Ownable2Step: caller is not the new owner',",
          "56:       );",
          "57:     });",
          "59:     it('allows to recover access using the internal _transferOwnership', async function () {",
          "60:       await this.ownable.renounceOwnership({ from: owner });",
          "61:       const receipt = await this.ownable.$_transferOwnership(accountA);",
          "62:       expectEvent(receipt, 'OwnershipTransferred');",
          "64:       expect(await this.ownable.owner()).to.equal(accountA);",
          "65:     });",
          "66:   });",
          "67: });",
          "",
          "---------------"
        ],
        "test/crosschain/CrossChainEnabled.test.js||test/crosschain/CrossChainEnabled.test.js": [
          "File: test/crosschain/CrossChainEnabled.test.js -> test/crosschain/CrossChainEnabled.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BridgeHelper } = require('../helpers/crosschain');",
          "2: const { expectRevertCustomError } = require('../helpers/customError');",
          "4: function randomAddress() {",
          "5:   return web3.utils.toChecksumAddress(web3.utils.randomHex(20));",
          "6: }",
          "8: const CrossChainEnabledAMBMock = artifacts.require('CrossChainEnabledAMBMock');",
          "9: const CrossChainEnabledArbitrumL1Mock = artifacts.require('CrossChainEnabledArbitrumL1Mock');",
          "10: const CrossChainEnabledArbitrumL2Mock = artifacts.require('CrossChainEnabledArbitrumL2Mock');",
          "11: const CrossChainEnabledOptimismMock = artifacts.require('CrossChainEnabledOptimismMock');",
          "12: const CrossChainEnabledPolygonChildMock = artifacts.require('CrossChainEnabledPolygonChildMock');",
          "14: function shouldBehaveLikeReceiver(sender = randomAddress()) {",
          "15:   it('should reject same-chain calls', async function () {",
          "16:     await expectRevertCustomError(this.receiver.crossChainRestricted(), 'NotCrossChainCall()');",
          "18:     await expectRevertCustomError(this.receiver.crossChainOwnerRestricted(), 'NotCrossChainCall()');",
          "19:   });",
          "21:   it('should restrict to cross-chain call from a invalid sender', async function () {",
          "22:     await expectRevertCustomError(",
          "23:       this.bridge.call(sender, this.receiver, 'crossChainOwnerRestricted()'),",
          "24:       `InvalidCrossChainSender(\"${sender}\", \"${await this.receiver.owner()}\")`,",
          "25:     );",
          "26:   });",
          "28:   it('should grant access to cross-chain call from the owner', async function () {",
          "29:     await this.bridge.call(await this.receiver.owner(), this.receiver, 'crossChainOwnerRestricted()');",
          "30:   });",
          "31: }",
          "33: contract('CrossChainEnabled', function () {",
          "34:   describe('AMB', function () {",
          "35:     beforeEach(async function () {",
          "36:       this.bridge = await BridgeHelper.deploy('AMB');",
          "37:       this.receiver = await CrossChainEnabledAMBMock.new(this.bridge.address);",
          "38:     });",
          "40:     shouldBehaveLikeReceiver();",
          "41:   });",
          "43:   describe('Arbitrum-L1', function () {",
          "44:     beforeEach(async function () {",
          "45:       this.bridge = await BridgeHelper.deploy('Arbitrum-L1');",
          "46:       this.receiver = await CrossChainEnabledArbitrumL1Mock.new(this.bridge.address);",
          "47:     });",
          "49:     shouldBehaveLikeReceiver();",
          "50:   });",
          "52:   describe('Arbitrum-L2', function () {",
          "53:     beforeEach(async function () {",
          "54:       this.bridge = await BridgeHelper.deploy('Arbitrum-L2');",
          "55:       this.receiver = await CrossChainEnabledArbitrumL2Mock.new();",
          "56:     });",
          "58:     shouldBehaveLikeReceiver();",
          "59:   });",
          "61:   describe('Optimism', function () {",
          "62:     beforeEach(async function () {",
          "63:       this.bridge = await BridgeHelper.deploy('Optimism');",
          "64:       this.receiver = await CrossChainEnabledOptimismMock.new(this.bridge.address);",
          "65:     });",
          "67:     shouldBehaveLikeReceiver();",
          "68:   });",
          "70:   describe('Polygon-Child', function () {",
          "71:     beforeEach(async function () {",
          "72:       this.bridge = await BridgeHelper.deploy('Polygon-Child');",
          "73:       this.receiver = await CrossChainEnabledPolygonChildMock.new(this.bridge.address);",
          "74:     });",
          "76:     shouldBehaveLikeReceiver();",
          "77:   });",
          "78: });",
          "",
          "---------------"
        ],
        "test/finance/PaymentSplitter.test.js||test/finance/PaymentSplitter.test.js": [
          "File: test/finance/PaymentSplitter.test.js -> test/finance/PaymentSplitter.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { balance, constants, ether, expectEvent, send, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS } = constants;",
          "4: const { expect } = require('chai');",
          "6: const PaymentSplitter = artifacts.require('PaymentSplitter');",
          "7: const ERC20 = artifacts.require('$ERC20');",
          "9: contract('PaymentSplitter', function (accounts) {",
          "10:   const [owner, payee1, payee2, payee3, nonpayee1, payer1] = accounts;",
          "12:   const amount = ether('1');",
          "14:   it('rejects an empty set of payees', async function () {",
          "15:     await expectRevert(PaymentSplitter.new([], []), 'PaymentSplitter: no payees');",
          "16:   });",
          "18:   it('rejects more payees than shares', async function () {",
          "19:     await expectRevert(",
          "20:       PaymentSplitter.new([payee1, payee2, payee3], [20, 30]),",
          "21:       'PaymentSplitter: payees and shares length mismatch',",
          "22:     );",
          "23:   });",
          "25:   it('rejects more shares than payees', async function () {",
          "26:     await expectRevert(",
          "27:       PaymentSplitter.new([payee1, payee2], [20, 30, 40]),",
          "28:       'PaymentSplitter: payees and shares length mismatch',",
          "29:     );",
          "30:   });",
          "32:   it('rejects null payees', async function () {",
          "33:     await expectRevert(",
          "34:       PaymentSplitter.new([payee1, ZERO_ADDRESS], [20, 30]),",
          "35:       'PaymentSplitter: account is the zero address',",
          "36:     );",
          "37:   });",
          "39:   it('rejects zero-valued shares', async function () {",
          "40:     await expectRevert(PaymentSplitter.new([payee1, payee2], [20, 0]), 'PaymentSplitter: shares are 0');",
          "41:   });",
          "43:   it('rejects repeated payees', async function () {",
          "44:     await expectRevert(PaymentSplitter.new([payee1, payee1], [20, 30]), 'PaymentSplitter: account already has shares');",
          "45:   });",
          "47:   context('once deployed', function () {",
          "48:     beforeEach(async function () {",
          "49:       this.payees = [payee1, payee2, payee3];",
          "50:       this.shares = [20, 10, 70];",
          "52:       this.contract = await PaymentSplitter.new(this.payees, this.shares);",
          "53:       this.token = await ERC20.new('MyToken', 'MT');",
          "54:       await this.token.$_mint(owner, ether('1000'));",
          "55:     });",
          "57:     it('has total shares', async function () {",
          "58:       expect(await this.contract.totalShares()).to.be.bignumber.equal('100');",
          "59:     });",
          "61:     it('has payees', async function () {",
          "62:       await Promise.all(",
          "63:         this.payees.map(async (payee, index) => {",
          "64:           expect(await this.contract.payee(index)).to.equal(payee);",
          "65:           expect(await this.contract.released(payee)).to.be.bignumber.equal('0');",
          "66:           expect(await this.contract.releasable(payee)).to.be.bignumber.equal('0');",
          "67:         }),",
          "68:       );",
          "69:     });",
          "71:     describe('accepts payments', function () {",
          "72:       it('Ether', async function () {",
          "73:         await send.ether(owner, this.contract.address, amount);",
          "75:         expect(await balance.current(this.contract.address)).to.be.bignumber.equal(amount);",
          "76:       });",
          "78:       it('Token', async function () {",
          "79:         await this.token.transfer(this.contract.address, amount, { from: owner });",
          "81:         expect(await this.token.balanceOf(this.contract.address)).to.be.bignumber.equal(amount);",
          "82:       });",
          "83:     });",
          "85:     describe('shares', function () {",
          "86:       it('stores shares if address is payee', async function () {",
          "87:         expect(await this.contract.shares(payee1)).to.be.bignumber.not.equal('0');",
          "88:       });",
          "90:       it('does not store shares if address is not payee', async function () {",
          "91:         expect(await this.contract.shares(nonpayee1)).to.be.bignumber.equal('0');",
          "92:       });",
          "93:     });",
          "95:     describe('release', function () {",
          "96:       describe('Ether', function () {",
          "97:         it('reverts if no funds to claim', async function () {",
          "98:           await expectRevert(this.contract.release(payee1), 'PaymentSplitter: account is not due payment');",
          "99:         });",
          "100:         it('reverts if non-payee want to claim', async function () {",
          "101:           await send.ether(payer1, this.contract.address, amount);",
          "102:           await expectRevert(this.contract.release(nonpayee1), 'PaymentSplitter: account has no shares');",
          "103:         });",
          "104:       });",
          "106:       describe('Token', function () {",
          "107:         it('reverts if no funds to claim', async function () {",
          "108:           await expectRevert(",
          "109:             this.contract.release(this.token.address, payee1),",
          "110:             'PaymentSplitter: account is not due payment',",
          "111:           );",
          "112:         });",
          "113:         it('reverts if non-payee want to claim', async function () {",
          "114:           await this.token.transfer(this.contract.address, amount, { from: owner });",
          "115:           await expectRevert(",
          "116:             this.contract.release(this.token.address, nonpayee1),",
          "117:             'PaymentSplitter: account has no shares',",
          "118:           );",
          "119:         });",
          "120:       });",
          "121:     });",
          "123:     describe('tracks releasable and released', function () {",
          "124:       it('Ether', async function () {",
          "125:         await send.ether(payer1, this.contract.address, amount);",
          "126:         const payment = amount.divn(10);",
          "127:         expect(await this.contract.releasable(payee2)).to.be.bignumber.equal(payment);",
          "128:         await this.contract.release(payee2);",
          "129:         expect(await this.contract.releasable(payee2)).to.be.bignumber.equal('0');",
          "130:         expect(await this.contract.released(payee2)).to.be.bignumber.equal(payment);",
          "131:       });",
          "133:       it('Token', async function () {",
          "134:         await this.token.transfer(this.contract.address, amount, { from: owner });",
          "135:         const payment = amount.divn(10);",
          "136:         expect(await this.contract.releasable(this.token.address, payee2, {})).to.be.bignumber.equal(payment);",
          "137:         await this.contract.release(this.token.address, payee2);",
          "138:         expect(await this.contract.releasable(this.token.address, payee2, {})).to.be.bignumber.equal('0');",
          "139:         expect(await this.contract.released(this.token.address, payee2)).to.be.bignumber.equal(payment);",
          "140:       });",
          "141:     });",
          "143:     describe('distributes funds to payees', function () {",
          "144:       it('Ether', async function () {",
          "145:         await send.ether(payer1, this.contract.address, amount);",
          "148:         const initBalance = await balance.current(this.contract.address);",
          "149:         expect(initBalance).to.be.bignumber.equal(amount);",
          "153:         const tracker1 = await balance.tracker(payee1);",
          "154:         const receipt1 = await this.contract.release(payee1);",
          "155:         const profit1 = await tracker1.delta();",
          "156:         expect(profit1).to.be.bignumber.equal(ether('0.20'));",
          "157:         expectEvent(receipt1, 'PaymentReleased', { to: payee1, amount: profit1 });",
          "159:         const tracker2 = await balance.tracker(payee2);",
          "160:         const receipt2 = await this.contract.release(payee2);",
          "161:         const profit2 = await tracker2.delta();",
          "162:         expect(profit2).to.be.bignumber.equal(ether('0.10'));",
          "163:         expectEvent(receipt2, 'PaymentReleased', { to: payee2, amount: profit2 });",
          "165:         const tracker3 = await balance.tracker(payee3);",
          "166:         const receipt3 = await this.contract.release(payee3);",
          "167:         const profit3 = await tracker3.delta();",
          "168:         expect(profit3).to.be.bignumber.equal(ether('0.70'));",
          "169:         expectEvent(receipt3, 'PaymentReleased', { to: payee3, amount: profit3 });",
          "172:         expect(await balance.current(this.contract.address)).to.be.bignumber.equal('0');",
          "175:         expect(await this.contract.totalReleased()).to.be.bignumber.equal(initBalance);",
          "176:       });",
          "178:       it('Token', async function () {",
          "179:         expect(await this.token.balanceOf(payee1)).to.be.bignumber.equal('0');",
          "180:         expect(await this.token.balanceOf(payee2)).to.be.bignumber.equal('0');",
          "181:         expect(await this.token.balanceOf(payee3)).to.be.bignumber.equal('0');",
          "183:         await this.token.transfer(this.contract.address, amount, { from: owner });",
          "185:         expectEvent(await this.contract.release(this.token.address, payee1), 'ERC20PaymentReleased', {",
          "186:           token: this.token.address,",
          "187:           to: payee1,",
          "188:           amount: ether('0.20'),",
          "189:         });",
          "191:         await this.token.transfer(this.contract.address, amount, { from: owner });",
          "193:         expectEvent(await this.contract.release(this.token.address, payee1), 'ERC20PaymentReleased', {",
          "194:           token: this.token.address,",
          "195:           to: payee1,",
          "196:           amount: ether('0.20'),",
          "197:         });",
          "199:         expectEvent(await this.contract.release(this.token.address, payee2), 'ERC20PaymentReleased', {",
          "200:           token: this.token.address,",
          "201:           to: payee2,",
          "202:           amount: ether('0.20'),",
          "203:         });",
          "205:         expectEvent(await this.contract.release(this.token.address, payee3), 'ERC20PaymentReleased', {",
          "206:           token: this.token.address,",
          "207:           to: payee3,",
          "208:           amount: ether('1.40'),",
          "209:         });",
          "211:         expect(await this.token.balanceOf(payee1)).to.be.bignumber.equal(ether('0.40'));",
          "212:         expect(await this.token.balanceOf(payee2)).to.be.bignumber.equal(ether('0.20'));",
          "213:         expect(await this.token.balanceOf(payee3)).to.be.bignumber.equal(ether('1.40'));",
          "214:       });",
          "215:     });",
          "216:   });",
          "217: });",
          "",
          "---------------"
        ],
        "test/finance/VestingWallet.behavior.js||test/finance/VestingWallet.behavior.js": [
          "File: test/finance/VestingWallet.behavior.js -> test/finance/VestingWallet.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { time } = require('@nomicfoundation/hardhat-network-helpers');",
          "2: const { expectEvent } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: function releasedEvent(token, amount) {",
          "6:   return token ? ['ERC20Released', { token: token.address, amount }] : ['EtherReleased', { amount }];",
          "7: }",
          "9: function shouldBehaveLikeVesting(beneficiary) {",
          "10:   it('check vesting schedule', async function () {",
          "11:     const [vestedAmount, releasable, ...args] = this.token",
          "12:       ? ['vestedAmount(address,uint64)', 'releasable(address)', this.token.address]",
          "13:       : ['vestedAmount(uint64)', 'releasable()'];",
          "15:     for (const timestamp of this.schedule) {",
          "16:       await time.increaseTo(timestamp);",
          "17:       const vesting = this.vestingFn(timestamp);",
          "19:       expect(await this.mock.methods[vestedAmount](...args, timestamp)).to.be.bignumber.equal(vesting);",
          "21:       expect(await this.mock.methods[releasable](...args)).to.be.bignumber.equal(vesting);",
          "22:     }",
          "23:   });",
          "25:   it('execute vesting schedule', async function () {",
          "26:     const [release, ...args] = this.token ? ['release(address)', this.token.address] : ['release()'];",
          "28:     let released = web3.utils.toBN(0);",
          "29:     const before = await this.getBalance(beneficiary);",
          "31:     {",
          "32:       const receipt = await this.mock.methods[release](...args);",
          "34:       await expectEvent.inTransaction(receipt.tx, this.mock, ...releasedEvent(this.token, '0'));",
          "36:       await this.checkRelease(receipt, beneficiary, '0');",
          "38:       expect(await this.getBalance(beneficiary)).to.be.bignumber.equal(before);",
          "39:     }",
          "41:     for (const timestamp of this.schedule) {",
          "42:       await time.setNextBlockTimestamp(timestamp);",
          "43:       const vested = this.vestingFn(timestamp);",
          "45:       const receipt = await this.mock.methods[release](...args);",
          "46:       await expectEvent.inTransaction(receipt.tx, this.mock, ...releasedEvent(this.token, vested.sub(released)));",
          "48:       await this.checkRelease(receipt, beneficiary, vested.sub(released));",
          "50:       expect(await this.getBalance(beneficiary)).to.be.bignumber.equal(before.add(vested));",
          "52:       released = vested;",
          "53:     }",
          "54:   });",
          "55: }",
          "57: module.exports = {",
          "58:   shouldBehaveLikeVesting,",
          "59: };",
          "",
          "---------------"
        ],
        "test/finance/VestingWallet.test.js||test/finance/VestingWallet.test.js": [
          "File: test/finance/VestingWallet.test.js -> test/finance/VestingWallet.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { constants, expectEvent, expectRevert, time } = require('@openzeppelin/test-helpers');",
          "2: const { web3 } = require('@openzeppelin/test-helpers/src/setup');",
          "3: const { expect } = require('chai');",
          "5: const VestingWallet = artifacts.require('VestingWallet');",
          "6: const ERC20 = artifacts.require('$ERC20');",
          "8: const { shouldBehaveLikeVesting } = require('./VestingWallet.behavior');",
          "10: const min = (...args) => args.slice(1).reduce((x, y) => (x.lt(y) ? x : y), args[0]);",
          "12: contract('VestingWallet', function (accounts) {",
          "13:   const [sender, beneficiary] = accounts;",
          "15:   const amount = web3.utils.toBN(web3.utils.toWei('100'));",
          "16:   const duration = web3.utils.toBN(4 * 365 * 86400); // 4 years",
          "18:   beforeEach(async function () {",
          "19:     this.start = (await time.latest()).addn(3600); // in 1 hour",
          "20:     this.mock = await VestingWallet.new(beneficiary, this.start, duration);",
          "21:   });",
          "23:   it('rejects zero address for beneficiary', async function () {",
          "24:     await expectRevert(",
          "25:       VestingWallet.new(constants.ZERO_ADDRESS, this.start, duration),",
          "26:       'VestingWallet: beneficiary is zero address',",
          "27:     );",
          "28:   });",
          "30:   it('check vesting contract', async function () {",
          "31:     expect(await this.mock.beneficiary()).to.be.equal(beneficiary);",
          "32:     expect(await this.mock.start()).to.be.bignumber.equal(this.start);",
          "33:     expect(await this.mock.duration()).to.be.bignumber.equal(duration);",
          "34:   });",
          "36:   describe('vesting schedule', function () {",
          "37:     beforeEach(async function () {",
          "38:       this.schedule = Array(64)",
          "39:         .fill()",
          "40:         .map((_, i) => web3.utils.toBN(i).mul(duration).divn(60).add(this.start));",
          "41:       this.vestingFn = timestamp => min(amount, amount.mul(timestamp.sub(this.start)).div(duration));",
          "42:     });",
          "44:     describe('Eth vesting', function () {",
          "45:       beforeEach(async function () {",
          "46:         await web3.eth.sendTransaction({ from: sender, to: this.mock.address, value: amount });",
          "47:         this.getBalance = account => web3.eth.getBalance(account).then(web3.utils.toBN);",
          "48:         this.checkRelease = () => {};",
          "49:       });",
          "51:       shouldBehaveLikeVesting(beneficiary);",
          "52:     });",
          "54:     describe('ERC20 vesting', function () {",
          "55:       beforeEach(async function () {",
          "56:         this.token = await ERC20.new('Name', 'Symbol');",
          "57:         this.getBalance = account => this.token.balanceOf(account);",
          "58:         this.checkRelease = (receipt, to, value) =>",
          "59:           expectEvent.inTransaction(receipt.tx, this.token, 'Transfer', { from: this.mock.address, to, value });",
          "61:         await this.token.$_mint(this.mock.address, amount);",
          "62:       });",
          "64:       shouldBehaveLikeVesting(beneficiary);",
          "65:     });",
          "66:   });",
          "67: });",
          "",
          "---------------"
        ],
        "test/governance/Governor.test.js||test/governance/Governor.test.js": [
          "File: test/governance/Governor.test.js -> test/governance/Governor.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const ethSigUtil = require('eth-sig-util');",
          "4: const Wallet = require('ethereumjs-wallet').default;",
          "5: const { fromRpcSig } = require('ethereumjs-util');",
          "6: const Enums = require('../helpers/enums');",
          "7: const { getDomain, domainType } = require('../helpers/eip712');",
          "8: const { GovernorHelper } = require('../helpers/governance');",
          "9: const { clockFromReceipt } = require('../helpers/time');",
          "11: const { shouldSupportInterfaces } = require('../utils/introspection/SupportsInterface.behavior');",
          "12: const { shouldBehaveLikeEIP6372 } = require('./utils/EIP6372.behavior');",
          "14: const Governor = artifacts.require('$GovernorMock');",
          "15: const CallReceiver = artifacts.require('CallReceiverMock');",
          "16: const ERC721 = artifacts.require('$ERC721');",
          "17: const ERC1155 = artifacts.require('$ERC1155');",
          "19: const TOKENS = [",
          "20:   { Token: artifacts.require('$ERC20Votes'), mode: 'blocknumber' },",
          "21:   { Token: artifacts.require('$ERC20VotesTimestampMock'), mode: 'timestamp' },",
          "22:   { Token: artifacts.require('$ERC20VotesLegacyMock'), mode: 'blocknumber' },",
          "23: ];",
          "25: contract('Governor', function (accounts) {",
          "26:   const [owner, proposer, voter1, voter2, voter3, voter4] = accounts;",
          "28:   const name = 'OZ-Governor';",
          "29:   const tokenName = 'MockToken';",
          "30:   const tokenSymbol = 'MTKN';",
          "31:   const tokenSupply = web3.utils.toWei('100');",
          "32:   const votingDelay = web3.utils.toBN(4);",
          "33:   const votingPeriod = web3.utils.toBN(16);",
          "34:   const value = web3.utils.toWei('1');",
          "36:   for (const { mode, Token } of TOKENS) {",
          "37:     describe(`using ${Token._json.contractName}`, function () {",
          "38:       beforeEach(async function () {",
          "39:         this.chainId = await web3.eth.getChainId();",
          "40:         this.token = await Token.new(tokenName, tokenSymbol, tokenName);",
          "41:         this.mock = await Governor.new(",
          "42:           name, // name",
          "43:           votingDelay, // initialVotingDelay",
          "44:           votingPeriod, // initialVotingPeriod",
          "45:           0, // initialProposalThreshold",
          "46:           this.token.address, // tokenAddress",
          "47:           10, // quorumNumeratorValue",
          "48:         );",
          "49:         this.receiver = await CallReceiver.new();",
          "51:         this.helper = new GovernorHelper(this.mock, mode);",
          "53:         await web3.eth.sendTransaction({ from: owner, to: this.mock.address, value });",
          "55:         await this.token.$_mint(owner, tokenSupply);",
          "56:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: owner });",
          "57:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: owner });",
          "58:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: owner });",
          "59:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: owner });",
          "61:         this.proposal = this.helper.setProposal(",
          "62:           [",
          "63:             {",
          "64:               target: this.receiver.address,",
          "65:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "66:               value,",
          "67:             },",
          "68:           ],",
          "69:           '<proposal description>',",
          "70:         );",
          "71:       });",
          "73:       shouldSupportInterfaces(['ERC165', 'ERC1155Receiver', 'Governor', 'GovernorWithParams', 'GovernorCancel']);",
          "74:       shouldBehaveLikeEIP6372(mode);",
          "76:       it('deployment check', async function () {",
          "77:         expect(await this.mock.name()).to.be.equal(name);",
          "78:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "79:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "80:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "81:         expect(await this.mock.quorum(0)).to.be.bignumber.equal('0');",
          "82:         expect(await this.mock.COUNTING_MODE()).to.be.equal('support=bravo&quorum=for,abstain');",
          "83:       });",
          "85:       it('nominal workflow', async function () {",
          "87:         expect(await this.mock.proposalProposer(this.proposal.id)).to.be.equal(constants.ZERO_ADDRESS);",
          "88:         expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "89:         expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(false);",
          "90:         expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(false);",
          "91:         expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(value);",
          "92:         expect(await web3.eth.getBalance(this.receiver.address)).to.be.bignumber.equal('0');",
          "95:         const txPropose = await this.helper.propose({ from: proposer });",
          "97:         expectEvent(txPropose, 'ProposalCreated', {",
          "98:           proposalId: this.proposal.id,",
          "99:           proposer,",
          "100:           targets: this.proposal.targets,",
          "102:           signatures: this.proposal.signatures,",
          "103:           calldatas: this.proposal.data,",
          "104:           voteStart: web3.utils.toBN(await clockFromReceipt[mode](txPropose.receipt)).add(votingDelay),",
          "105:           voteEnd: web3.utils",
          "106:             .toBN(await clockFromReceipt[mode](txPropose.receipt))",
          "107:             .add(votingDelay)",
          "108:             .add(votingPeriod),",
          "109:           description: this.proposal.description,",
          "110:         });",
          "112:         await this.helper.waitForSnapshot();",
          "114:         expectEvent(",
          "115:           await this.helper.vote({ support: Enums.VoteType.For, reason: 'This is nice' }, { from: voter1 }),",
          "116:           'VoteCast',",
          "117:           {",
          "118:             voter: voter1,",
          "119:             support: Enums.VoteType.For,",
          "120:             reason: 'This is nice',",
          "121:             weight: web3.utils.toWei('10'),",
          "122:           },",
          "123:         );",
          "125:         expectEvent(await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 }), 'VoteCast', {",
          "126:           voter: voter2,",
          "127:           support: Enums.VoteType.For,",
          "128:           weight: web3.utils.toWei('7'),",
          "129:         });",
          "131:         expectEvent(await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 }), 'VoteCast', {",
          "132:           voter: voter3,",
          "133:           support: Enums.VoteType.Against,",
          "134:           weight: web3.utils.toWei('5'),",
          "135:         });",
          "137:         expectEvent(await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 }), 'VoteCast', {",
          "138:           voter: voter4,",
          "139:           support: Enums.VoteType.Abstain,",
          "140:           weight: web3.utils.toWei('2'),",
          "141:         });",
          "143:         await this.helper.waitForDeadline();",
          "145:         const txExecute = await this.helper.execute();",
          "147:         expectEvent(txExecute, 'ProposalExecuted', { proposalId: this.proposal.id });",
          "149:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'MockFunctionCalled');",
          "152:         expect(await this.mock.proposalProposer(this.proposal.id)).to.be.equal(proposer);",
          "153:         expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "154:         expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(true);",
          "155:         expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(true);",
          "156:         expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal('0');",
          "157:         expect(await web3.eth.getBalance(this.receiver.address)).to.be.bignumber.equal(value);",
          "158:       });",
          "160:       it('vote with signature', async function () {",
          "161:         const voterBySig = Wallet.generate();",
          "162:         const voterBySigAddress = web3.utils.toChecksumAddress(voterBySig.getAddressString());",
          "164:         const signature = (contract, message) =>",
          "165:           getDomain(contract)",
          "166:             .then(domain => ({",
          "167:               primaryType: 'Ballot',",
          "168:               types: {",
          "169:                 EIP712Domain: domainType(domain),",
          "170:                 Ballot: [",
          "171:                   { name: 'proposalId', type: 'uint256' },",
          "172:                   { name: 'support', type: 'uint8' },",
          "173:                 ],",
          "174:               },",
          "175:               domain,",
          "176:               message,",
          "177:             }))",
          "178:             .then(data => ethSigUtil.signTypedMessage(voterBySig.getPrivateKey(), { data }))",
          "179:             .then(fromRpcSig);",
          "181:         await this.token.delegate(voterBySigAddress, { from: voter1 });",
          "184:         await this.helper.propose();",
          "185:         await this.helper.waitForSnapshot();",
          "186:         expectEvent(await this.helper.vote({ support: Enums.VoteType.For, signature }), 'VoteCast', {",
          "187:           voter: voterBySigAddress,",
          "188:           support: Enums.VoteType.For,",
          "189:         });",
          "190:         await this.helper.waitForDeadline();",
          "191:         await this.helper.execute();",
          "194:         expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "195:         expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(false);",
          "196:         expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(false);",
          "197:         expect(await this.mock.hasVoted(this.proposal.id, voterBySigAddress)).to.be.equal(true);",
          "198:       });",
          "200:       it('send ethers', async function () {",
          "201:         const empty = web3.utils.toChecksumAddress(web3.utils.randomHex(20));",
          "203:         this.proposal = this.helper.setProposal(",
          "204:           [",
          "205:             {",
          "206:               target: empty,",
          "207:               value,",
          "208:             },",
          "209:           ],",
          "210:           '<proposal description>',",
          "211:         );",
          "214:         expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(value);",
          "215:         expect(await web3.eth.getBalance(empty)).to.be.bignumber.equal('0');",
          "218:         await this.helper.propose();",
          "219:         await this.helper.waitForSnapshot();",
          "220:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "221:         await this.helper.waitForDeadline();",
          "222:         await this.helper.execute();",
          "225:         expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal('0');",
          "226:         expect(await web3.eth.getBalance(empty)).to.be.bignumber.equal(value);",
          "227:       });",
          "229:       describe('should revert', function () {",
          "230:         describe('on propose', function () {",
          "231:           it('if proposal already exists', async function () {",
          "232:             await this.helper.propose();",
          "233:             await expectRevert(this.helper.propose(), 'Governor: proposal already exists');",
          "234:           });",
          "235:         });",
          "237:         describe('on vote', function () {",
          "238:           it('if proposal does not exist', async function () {",
          "239:             await expectRevert(",
          "240:               this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 }),",
          "241:               'Governor: unknown proposal id',",
          "242:             );",
          "243:           });",
          "245:           it('if voting has not started', async function () {",
          "246:             await this.helper.propose();",
          "247:             await expectRevert(",
          "248:               this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 }),",
          "249:               'Governor: vote not currently active',",
          "250:             );",
          "251:           });",
          "253:           it('if support value is invalid', async function () {",
          "254:             await this.helper.propose();",
          "255:             await this.helper.waitForSnapshot();",
          "256:             await expectRevert(",
          "257:               this.helper.vote({ support: web3.utils.toBN('255') }),",
          "258:               'GovernorVotingSimple: invalid value for enum VoteType',",
          "259:             );",
          "260:           });",
          "262:           it('if vote was already casted', async function () {",
          "263:             await this.helper.propose();",
          "264:             await this.helper.waitForSnapshot();",
          "265:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "266:             await expectRevert(",
          "267:               this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 }),",
          "268:               'GovernorVotingSimple: vote already cast',",
          "269:             );",
          "270:           });",
          "272:           it('if voting is over', async function () {",
          "273:             await this.helper.propose();",
          "274:             await this.helper.waitForDeadline();",
          "275:             await expectRevert(",
          "276:               this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 }),",
          "277:               'Governor: vote not currently active',",
          "278:             );",
          "279:           });",
          "280:         });",
          "282:         describe('on execute', function () {",
          "283:           it('if proposal does not exist', async function () {",
          "284:             await expectRevert(this.helper.execute(), 'Governor: unknown proposal id');",
          "285:           });",
          "287:           it('if quorum is not reached', async function () {",
          "288:             await this.helper.propose();",
          "289:             await this.helper.waitForSnapshot();",
          "290:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter3 });",
          "291:             await expectRevert(this.helper.execute(), 'Governor: proposal not successful');",
          "292:           });",
          "294:           it('if score not reached', async function () {",
          "295:             await this.helper.propose();",
          "296:             await this.helper.waitForSnapshot();",
          "297:             await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter1 });",
          "298:             await expectRevert(this.helper.execute(), 'Governor: proposal not successful');",
          "299:           });",
          "301:           it('if voting is not over', async function () {",
          "302:             await this.helper.propose();",
          "303:             await this.helper.waitForSnapshot();",
          "304:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "305:             await expectRevert(this.helper.execute(), 'Governor: proposal not successful');",
          "306:           });",
          "308:           it('if receiver revert without reason', async function () {",
          "309:             this.proposal = this.helper.setProposal(",
          "310:               [",
          "311:                 {",
          "312:                   target: this.receiver.address,",
          "313:                   data: this.receiver.contract.methods.mockFunctionRevertsNoReason().encodeABI(),",
          "314:                 },",
          "315:               ],",
          "316:               '<proposal description>',",
          "317:             );",
          "319:             await this.helper.propose();",
          "320:             await this.helper.waitForSnapshot();",
          "321:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "322:             await this.helper.waitForDeadline();",
          "323:             await expectRevert(this.helper.execute(), 'Governor: call reverted without message');",
          "324:           });",
          "326:           it('if receiver revert with reason', async function () {",
          "327:             this.proposal = this.helper.setProposal(",
          "328:               [",
          "329:                 {",
          "330:                   target: this.receiver.address,",
          "331:                   data: this.receiver.contract.methods.mockFunctionRevertsReason().encodeABI(),",
          "332:                 },",
          "333:               ],",
          "334:               '<proposal description>',",
          "335:             );",
          "337:             await this.helper.propose();",
          "338:             await this.helper.waitForSnapshot();",
          "339:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "340:             await this.helper.waitForDeadline();",
          "341:             await expectRevert(this.helper.execute(), 'CallReceiverMock: reverting');",
          "342:           });",
          "344:           it('if proposal was already executed', async function () {",
          "345:             await this.helper.propose();",
          "346:             await this.helper.waitForSnapshot();",
          "347:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "348:             await this.helper.waitForDeadline();",
          "349:             await this.helper.execute();",
          "350:             await expectRevert(this.helper.execute(), 'Governor: proposal not successful');",
          "351:           });",
          "352:         });",
          "353:       });",
          "355:       describe('state', function () {",
          "356:         it('Unset', async function () {",
          "357:           await expectRevert(this.mock.state(this.proposal.id), 'Governor: unknown proposal id');",
          "358:         });",
          "360:         it('Pending & Active', async function () {",
          "361:           await this.helper.propose();",
          "362:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Pending);",
          "363:           await this.helper.waitForSnapshot();",
          "364:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Pending);",
          "365:           await this.helper.waitForSnapshot(+1);",
          "366:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Active);",
          "367:         });",
          "369:         it('Defeated', async function () {",
          "370:           await this.helper.propose();",
          "371:           await this.helper.waitForDeadline();",
          "372:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Active);",
          "373:           await this.helper.waitForDeadline(+1);",
          "374:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Defeated);",
          "375:         });",
          "377:         it('Succeeded', async function () {",
          "378:           await this.helper.propose();",
          "379:           await this.helper.waitForSnapshot();",
          "380:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "381:           await this.helper.waitForDeadline();",
          "382:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Active);",
          "383:           await this.helper.waitForDeadline(+1);",
          "384:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Succeeded);",
          "385:         });",
          "387:         it('Executed', async function () {",
          "388:           await this.helper.propose();",
          "389:           await this.helper.waitForSnapshot();",
          "390:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "391:           await this.helper.waitForDeadline();",
          "392:           await this.helper.execute();",
          "393:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Executed);",
          "394:         });",
          "395:       });",
          "397:       describe('cancel', function () {",
          "398:         describe('internal', function () {",
          "399:           it('before proposal', async function () {",
          "400:             await expectRevert(this.helper.cancel('internal'), 'Governor: unknown proposal id');",
          "401:           });",
          "403:           it('after proposal', async function () {",
          "404:             await this.helper.propose();",
          "406:             await this.helper.cancel('internal');",
          "407:             expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "409:             await this.helper.waitForSnapshot();",
          "410:             await expectRevert(",
          "411:               this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 }),",
          "412:               'Governor: vote not currently active',",
          "413:             );",
          "414:           });",
          "416:           it('after vote', async function () {",
          "417:             await this.helper.propose();",
          "418:             await this.helper.waitForSnapshot();",
          "419:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "421:             await this.helper.cancel('internal');",
          "422:             expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "424:             await this.helper.waitForDeadline();",
          "425:             await expectRevert(this.helper.execute(), 'Governor: proposal not successful');",
          "426:           });",
          "428:           it('after deadline', async function () {",
          "429:             await this.helper.propose();",
          "430:             await this.helper.waitForSnapshot();",
          "431:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "432:             await this.helper.waitForDeadline();",
          "434:             await this.helper.cancel('internal');",
          "435:             expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "437:             await expectRevert(this.helper.execute(), 'Governor: proposal not successful');",
          "438:           });",
          "440:           it('after execution', async function () {",
          "441:             await this.helper.propose();",
          "442:             await this.helper.waitForSnapshot();",
          "443:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "444:             await this.helper.waitForDeadline();",
          "445:             await this.helper.execute();",
          "447:             await expectRevert(this.helper.cancel('internal'), 'Governor: proposal not active');",
          "448:           });",
          "449:         });",
          "451:         describe('public', function () {",
          "452:           it('before proposal', async function () {",
          "453:             await expectRevert(this.helper.cancel('external'), 'Governor: unknown proposal id');",
          "454:           });",
          "456:           it('after proposal', async function () {",
          "457:             await this.helper.propose();",
          "459:             await this.helper.cancel('external');",
          "460:           });",
          "462:           it('after proposal - restricted to proposer', async function () {",
          "463:             await this.helper.propose();",
          "465:             await expectRevert(this.helper.cancel('external', { from: owner }), 'Governor: only proposer can cancel');",
          "466:           });",
          "468:           it('after vote started', async function () {",
          "469:             await this.helper.propose();",
          "470:             await this.helper.waitForSnapshot(1); // snapshot + 1 block",
          "472:             await expectRevert(this.helper.cancel('external'), 'Governor: too late to cancel');",
          "473:           });",
          "475:           it('after vote', async function () {",
          "476:             await this.helper.propose();",
          "477:             await this.helper.waitForSnapshot();",
          "478:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "480:             await expectRevert(this.helper.cancel('external'), 'Governor: too late to cancel');",
          "481:           });",
          "483:           it('after deadline', async function () {",
          "484:             await this.helper.propose();",
          "485:             await this.helper.waitForSnapshot();",
          "486:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "487:             await this.helper.waitForDeadline();",
          "489:             await expectRevert(this.helper.cancel('external'), 'Governor: too late to cancel');",
          "490:           });",
          "492:           it('after execution', async function () {",
          "493:             await this.helper.propose();",
          "494:             await this.helper.waitForSnapshot();",
          "495:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "496:             await this.helper.waitForDeadline();",
          "497:             await this.helper.execute();",
          "499:             await expectRevert(this.helper.cancel('external'), 'Governor: too late to cancel');",
          "500:           });",
          "501:         });",
          "502:       });",
          "504:       describe('proposal length', function () {",
          "505:         it('empty', async function () {",
          "506:           this.helper.setProposal([], '<proposal description>');",
          "507:           await expectRevert(this.helper.propose(), 'Governor: empty proposal');",
          "508:         });",
          "510:         it('mismatch #1', async function () {",
          "511:           this.helper.setProposal(",
          "512:             {",
          "513:               targets: [],",
          "514:               values: [web3.utils.toWei('0')],",
          "515:               data: [this.receiver.contract.methods.mockFunction().encodeABI()],",
          "516:             },",
          "517:             '<proposal description>',",
          "518:           );",
          "519:           await expectRevert(this.helper.propose(), 'Governor: invalid proposal length');",
          "520:         });",
          "522:         it('mismatch #2', async function () {",
          "523:           this.helper.setProposal(",
          "524:             {",
          "525:               targets: [this.receiver.address],",
          "526:               values: [],",
          "527:               data: [this.receiver.contract.methods.mockFunction().encodeABI()],",
          "528:             },",
          "529:             '<proposal description>',",
          "530:           );",
          "531:           await expectRevert(this.helper.propose(), 'Governor: invalid proposal length');",
          "532:         });",
          "534:         it('mismatch #3', async function () {",
          "535:           this.helper.setProposal(",
          "536:             {",
          "537:               targets: [this.receiver.address],",
          "538:               values: [web3.utils.toWei('0')],",
          "539:               data: [],",
          "540:             },",
          "541:             '<proposal description>',",
          "542:           );",
          "543:           await expectRevert(this.helper.propose(), 'Governor: invalid proposal length');",
          "544:         });",
          "545:       });",
          "547:       describe('onlyGovernance updates', function () {",
          "548:         it('setVotingDelay is protected', async function () {",
          "549:           await expectRevert(this.mock.setVotingDelay('0'), 'Governor: onlyGovernance');",
          "550:         });",
          "552:         it('setVotingPeriod is protected', async function () {",
          "553:           await expectRevert(this.mock.setVotingPeriod('32'), 'Governor: onlyGovernance');",
          "554:         });",
          "556:         it('setProposalThreshold is protected', async function () {",
          "557:           await expectRevert(this.mock.setProposalThreshold('1000000000000000000'), 'Governor: onlyGovernance');",
          "558:         });",
          "560:         it('can setVotingDelay through governance', async function () {",
          "561:           this.helper.setProposal(",
          "562:             [",
          "563:               {",
          "564:                 target: this.mock.address,",
          "565:                 data: this.mock.contract.methods.setVotingDelay('0').encodeABI(),",
          "566:               },",
          "567:             ],",
          "568:             '<proposal description>',",
          "569:           );",
          "571:           await this.helper.propose();",
          "572:           await this.helper.waitForSnapshot();",
          "573:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "574:           await this.helper.waitForDeadline();",
          "576:           expectEvent(await this.helper.execute(), 'VotingDelaySet', { oldVotingDelay: '4', newVotingDelay: '0' });",
          "578:           expect(await this.mock.votingDelay()).to.be.bignumber.equal('0');",
          "579:         });",
          "581:         it('can setVotingPeriod through governance', async function () {",
          "582:           this.helper.setProposal(",
          "583:             [",
          "584:               {",
          "585:                 target: this.mock.address,",
          "586:                 data: this.mock.contract.methods.setVotingPeriod('32').encodeABI(),",
          "587:               },",
          "588:             ],",
          "589:             '<proposal description>',",
          "590:           );",
          "592:           await this.helper.propose();",
          "593:           await this.helper.waitForSnapshot();",
          "594:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "595:           await this.helper.waitForDeadline();",
          "597:           expectEvent(await this.helper.execute(), 'VotingPeriodSet', { oldVotingPeriod: '16', newVotingPeriod: '32' });",
          "599:           expect(await this.mock.votingPeriod()).to.be.bignumber.equal('32');",
          "600:         });",
          "602:         it('cannot setVotingPeriod to 0 through governance', async function () {",
          "603:           this.helper.setProposal(",
          "604:             [",
          "605:               {",
          "606:                 target: this.mock.address,",
          "607:                 data: this.mock.contract.methods.setVotingPeriod('0').encodeABI(),",
          "608:               },",
          "609:             ],",
          "610:             '<proposal description>',",
          "611:           );",
          "613:           await this.helper.propose();",
          "614:           await this.helper.waitForSnapshot();",
          "615:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "616:           await this.helper.waitForDeadline();",
          "618:           await expectRevert(this.helper.execute(), 'GovernorSettings: voting period too low');",
          "619:         });",
          "621:         it('can setProposalThreshold to 0 through governance', async function () {",
          "622:           this.helper.setProposal(",
          "623:             [",
          "624:               {",
          "625:                 target: this.mock.address,",
          "626:                 data: this.mock.contract.methods.setProposalThreshold('1000000000000000000').encodeABI(),",
          "627:               },",
          "628:             ],",
          "629:             '<proposal description>',",
          "630:           );",
          "632:           await this.helper.propose();",
          "633:           await this.helper.waitForSnapshot();",
          "634:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "635:           await this.helper.waitForDeadline();",
          "637:           expectEvent(await this.helper.execute(), 'ProposalThresholdSet', {",
          "638:             oldProposalThreshold: '0',",
          "639:             newProposalThreshold: '1000000000000000000',",
          "640:           });",
          "642:           expect(await this.mock.proposalThreshold()).to.be.bignumber.equal('1000000000000000000');",
          "643:         });",
          "644:       });",
          "646:       describe('safe receive', function () {",
          "647:         describe('ERC721', function () {",
          "648:           const name = 'Non Fungible Token';",
          "649:           const symbol = 'NFT';",
          "650:           const tokenId = web3.utils.toBN(1);",
          "652:           beforeEach(async function () {",
          "653:             this.token = await ERC721.new(name, symbol);",
          "654:             await this.token.$_mint(owner, tokenId);",
          "655:           });",
          "657:           it('can receive an ERC721 safeTransfer', async function () {",
          "658:             await this.token.safeTransferFrom(owner, this.mock.address, tokenId, { from: owner });",
          "659:           });",
          "660:         });",
          "662:         describe('ERC1155', function () {",
          "663:           const uri = 'https://token-cdn-domain/{id}.json';",
          "664:           const tokenIds = {",
          "665:             1: web3.utils.toBN(1000),",
          "666:             2: web3.utils.toBN(2000),",
          "667:             3: web3.utils.toBN(3000),",
          "668:           };",
          "670:           beforeEach(async function () {",
          "671:             this.token = await ERC1155.new(uri);",
          "672:             await this.token.$_mintBatch(owner, Object.keys(tokenIds), Object.values(tokenIds), '0x');",
          "673:           });",
          "675:           it('can receive ERC1155 safeTransfer', async function () {",
          "676:             await this.token.safeTransferFrom(",
          "677:               owner,",
          "678:               this.mock.address,",
          "679:               ...Object.entries(tokenIds)[0], // id + amount",
          "680:               '0x',",
          "681:               { from: owner },",
          "682:             );",
          "683:           });",
          "685:           it('can receive ERC1155 safeBatchTransfer', async function () {",
          "686:             await this.token.safeBatchTransferFrom(",
          "687:               owner,",
          "688:               this.mock.address,",
          "689:               Object.keys(tokenIds),",
          "690:               Object.values(tokenIds),",
          "691:               '0x',",
          "692:               { from: owner },",
          "693:             );",
          "694:           });",
          "695:         });",
          "696:       });",
          "697:     });",
          "698:   }",
          "699: });",
          "",
          "---------------"
        ],
        "test/governance/TimelockController.test.js||test/governance/TimelockController.test.js": [
          "File: test/governance/TimelockController.test.js -> test/governance/TimelockController.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectEvent, expectRevert, time } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS, ZERO_BYTES32 } = constants;",
          "4: const { expect } = require('chai');",
          "6: const { shouldSupportInterfaces } = require('../utils/introspection/SupportsInterface.behavior');",
          "8: const TimelockController = artifacts.require('TimelockController');",
          "9: const CallReceiverMock = artifacts.require('CallReceiverMock');",
          "10: const Implementation2 = artifacts.require('Implementation2');",
          "11: const ERC721 = artifacts.require('$ERC721');",
          "12: const ERC1155 = artifacts.require('$ERC1155');",
          "13: const TimelockReentrant = artifacts.require('$TimelockReentrant');",
          "15: const MINDELAY = time.duration.days(1);",
          "17: const salt = '0x025e7b0be353a74631ad648c667493c0e1cd31caa4cc2d3520fdc171ea0cc726'; // a random value",
          "19: function genOperation(target, value, data, predecessor, salt) {",
          "20:   const id = web3.utils.keccak256(",
          "21:     web3.eth.abi.encodeParameters(",
          "22:       ['address', 'uint256', 'bytes', 'uint256', 'bytes32'],",
          "23:       [target, value, data, predecessor, salt],",
          "24:     ),",
          "25:   );",
          "26:   return { id, target, value, data, predecessor, salt };",
          "27: }",
          "29: function genOperationBatch(targets, values, payloads, predecessor, salt) {",
          "30:   const id = web3.utils.keccak256(",
          "31:     web3.eth.abi.encodeParameters(",
          "32:       ['address[]', 'uint256[]', 'bytes[]', 'uint256', 'bytes32'],",
          "33:       [targets, values, payloads, predecessor, salt],",
          "34:     ),",
          "35:   );",
          "36:   return { id, targets, values, payloads, predecessor, salt };",
          "37: }",
          "39: contract('TimelockController', function (accounts) {",
          "40:   const [, admin, proposer, canceller, executor, other] = accounts;",
          "42:   const TIMELOCK_ADMIN_ROLE = web3.utils.soliditySha3('TIMELOCK_ADMIN_ROLE');",
          "43:   const PROPOSER_ROLE = web3.utils.soliditySha3('PROPOSER_ROLE');",
          "44:   const EXECUTOR_ROLE = web3.utils.soliditySha3('EXECUTOR_ROLE');",
          "45:   const CANCELLER_ROLE = web3.utils.soliditySha3('CANCELLER_ROLE');",
          "47:   beforeEach(async function () {",
          "49:     this.mock = await TimelockController.new(MINDELAY, [proposer], [executor], admin);",
          "51:     expect(await this.mock.hasRole(CANCELLER_ROLE, proposer)).to.be.equal(true);",
          "52:     await this.mock.revokeRole(CANCELLER_ROLE, proposer, { from: admin });",
          "53:     await this.mock.grantRole(CANCELLER_ROLE, canceller, { from: admin });",
          "56:     this.callreceivermock = await CallReceiverMock.new({ from: admin });",
          "57:     this.implementation2 = await Implementation2.new({ from: admin });",
          "58:   });",
          "60:   shouldSupportInterfaces(['ERC1155Receiver']);",
          "62:   it('initial state', async function () {",
          "63:     expect(await this.mock.getMinDelay()).to.be.bignumber.equal(MINDELAY);",
          "65:     expect(await this.mock.TIMELOCK_ADMIN_ROLE()).to.be.equal(TIMELOCK_ADMIN_ROLE);",
          "66:     expect(await this.mock.PROPOSER_ROLE()).to.be.equal(PROPOSER_ROLE);",
          "67:     expect(await this.mock.EXECUTOR_ROLE()).to.be.equal(EXECUTOR_ROLE);",
          "68:     expect(await this.mock.CANCELLER_ROLE()).to.be.equal(CANCELLER_ROLE);",
          "70:     expect(",
          "71:       await Promise.all([PROPOSER_ROLE, CANCELLER_ROLE, EXECUTOR_ROLE].map(role => this.mock.hasRole(role, proposer))),",
          "72:     ).to.be.deep.equal([true, false, false]);",
          "74:     expect(",
          "75:       await Promise.all([PROPOSER_ROLE, CANCELLER_ROLE, EXECUTOR_ROLE].map(role => this.mock.hasRole(role, canceller))),",
          "76:     ).to.be.deep.equal([false, true, false]);",
          "78:     expect(",
          "79:       await Promise.all([PROPOSER_ROLE, CANCELLER_ROLE, EXECUTOR_ROLE].map(role => this.mock.hasRole(role, executor))),",
          "80:     ).to.be.deep.equal([false, false, true]);",
          "81:   });",
          "83:   it('optional admin', async function () {",
          "84:     const mock = await TimelockController.new(MINDELAY, [proposer], [executor], ZERO_ADDRESS, { from: other });",
          "86:     expect(await mock.hasRole(TIMELOCK_ADMIN_ROLE, admin)).to.be.equal(false);",
          "87:     expect(await mock.hasRole(TIMELOCK_ADMIN_ROLE, other)).to.be.equal(false);",
          "88:   });",
          "90:   describe('methods', function () {",
          "91:     describe('operation hashing', function () {",
          "92:       it('hashOperation', async function () {",
          "93:         this.operation = genOperation(",
          "94:           '0x29cebefe301c6ce1bb36b58654fea275e1cacc83',",
          "95:           '0xf94fdd6e21da21d2',",
          "96:           '0xa3bc5104',",
          "97:           '0xba41db3be0a9929145cfe480bd0f1f003689104d275ae912099f925df424ef94',",
          "98:           '0x60d9109846ab510ed75c15f979ae366a8a2ace11d34ba9788c13ac296db50e6e',",
          "99:         );",
          "100:         expect(",
          "101:           await this.mock.hashOperation(",
          "102:             this.operation.target,",
          "103:             this.operation.value,",
          "104:             this.operation.data,",
          "105:             this.operation.predecessor,",
          "106:             this.operation.salt,",
          "107:           ),",
          "108:         ).to.be.equal(this.operation.id);",
          "109:       });",
          "111:       it('hashOperationBatch', async function () {",
          "112:         this.operation = genOperationBatch(",
          "113:           Array(8).fill('0x2d5f21620e56531c1d59c2df9b8e95d129571f71'),",
          "114:           Array(8).fill('0x2b993cfce932ccee'),",
          "115:           Array(8).fill('0xcf51966b'),",
          "116:           '0xce8f45069cc71d25f71ba05062de1a3974f9849b004de64a70998bca9d29c2e7',",
          "117:           '0x8952d74c110f72bfe5accdf828c74d53a7dfb71235dfa8a1e8c75d8576b372ff',",
          "118:         );",
          "119:         expect(",
          "120:           await this.mock.hashOperationBatch(",
          "121:             this.operation.targets,",
          "122:             this.operation.values,",
          "123:             this.operation.payloads,",
          "124:             this.operation.predecessor,",
          "125:             this.operation.salt,",
          "126:           ),",
          "127:         ).to.be.equal(this.operation.id);",
          "128:       });",
          "129:     });",
          "130:     describe('simple', function () {",
          "131:       describe('schedule', function () {",
          "132:         beforeEach(async function () {",
          "133:           this.operation = genOperation(",
          "134:             '0x31754f590B97fD975Eb86938f18Cc304E264D2F2',",
          "135:             0,",
          "136:             '0x3bf92ccc',",
          "137:             ZERO_BYTES32,",
          "138:             salt,",
          "139:           );",
          "140:         });",
          "142:         it('proposer can schedule', async function () {",
          "143:           const receipt = await this.mock.schedule(",
          "144:             this.operation.target,",
          "145:             this.operation.value,",
          "146:             this.operation.data,",
          "147:             this.operation.predecessor,",
          "148:             this.operation.salt,",
          "149:             MINDELAY,",
          "150:             { from: proposer },",
          "151:           );",
          "152:           expectEvent(receipt, 'CallScheduled', {",
          "153:             id: this.operation.id,",
          "154:             index: web3.utils.toBN(0),",
          "155:             target: this.operation.target,",
          "156:             value: web3.utils.toBN(this.operation.value),",
          "157:             data: this.operation.data,",
          "158:             predecessor: this.operation.predecessor,",
          "159:             delay: MINDELAY,",
          "160:           });",
          "162:           expectEvent(receipt, 'CallSalt', {",
          "163:             id: this.operation.id,",
          "164:             salt: this.operation.salt,",
          "165:           });",
          "167:           const block = await web3.eth.getBlock(receipt.receipt.blockHash);",
          "169:           expect(await this.mock.getTimestamp(this.operation.id)).to.be.bignumber.equal(",
          "170:             web3.utils.toBN(block.timestamp).add(MINDELAY),",
          "171:           );",
          "172:         });",
          "174:         it('prevent overwriting active operation', async function () {",
          "175:           await this.mock.schedule(",
          "176:             this.operation.target,",
          "177:             this.operation.value,",
          "178:             this.operation.data,",
          "179:             this.operation.predecessor,",
          "180:             this.operation.salt,",
          "181:             MINDELAY,",
          "182:             { from: proposer },",
          "183:           );",
          "185:           await expectRevert(",
          "186:             this.mock.schedule(",
          "187:               this.operation.target,",
          "188:               this.operation.value,",
          "189:               this.operation.data,",
          "190:               this.operation.predecessor,",
          "191:               this.operation.salt,",
          "192:               MINDELAY,",
          "193:               { from: proposer },",
          "194:             ),",
          "195:             'TimelockController: operation already scheduled',",
          "196:           );",
          "197:         });",
          "199:         it('prevent non-proposer from committing', async function () {",
          "200:           await expectRevert(",
          "201:             this.mock.schedule(",
          "202:               this.operation.target,",
          "203:               this.operation.value,",
          "204:               this.operation.data,",
          "205:               this.operation.predecessor,",
          "206:               this.operation.salt,",
          "207:               MINDELAY,",
          "208:               { from: other },",
          "209:             ),",
          "210:             `AccessControl: account ${other.toLowerCase()} is missing role ${PROPOSER_ROLE}`,",
          "211:           );",
          "212:         });",
          "214:         it('enforce minimum delay', async function () {",
          "215:           await expectRevert(",
          "216:             this.mock.schedule(",
          "217:               this.operation.target,",
          "218:               this.operation.value,",
          "219:               this.operation.data,",
          "220:               this.operation.predecessor,",
          "221:               this.operation.salt,",
          "222:               MINDELAY - 1,",
          "223:               { from: proposer },",
          "224:             ),",
          "225:             'TimelockController: insufficient delay',",
          "226:           );",
          "227:         });",
          "229:         it('schedule operation with salt zero', async function () {",
          "230:           const { receipt } = await this.mock.schedule(",
          "231:             this.operation.target,",
          "232:             this.operation.value,",
          "233:             this.operation.data,",
          "234:             this.operation.predecessor,",
          "235:             ZERO_BYTES32,",
          "236:             MINDELAY,",
          "237:             { from: proposer },",
          "238:           );",
          "239:           expectEvent.notEmitted(receipt, 'CallSalt');",
          "240:         });",
          "241:       });",
          "243:       describe('execute', function () {",
          "244:         beforeEach(async function () {",
          "245:           this.operation = genOperation(",
          "246:             '0xAe22104DCD970750610E6FE15E623468A98b15f7',",
          "247:             0,",
          "248:             '0x13e414de',",
          "249:             ZERO_BYTES32,",
          "250:             '0xc1059ed2dc130227aa1d1d539ac94c641306905c020436c636e19e3fab56fc7f',",
          "251:           );",
          "252:         });",
          "254:         it('revert if operation is not scheduled', async function () {",
          "255:           await expectRevert(",
          "256:             this.mock.execute(",
          "257:               this.operation.target,",
          "258:               this.operation.value,",
          "259:               this.operation.data,",
          "260:               this.operation.predecessor,",
          "261:               this.operation.salt,",
          "262:               { from: executor },",
          "263:             ),",
          "264:             'TimelockController: operation is not ready',",
          "265:           );",
          "266:         });",
          "268:         describe('with scheduled operation', function () {",
          "269:           beforeEach(async function () {",
          "270:             ({ receipt: this.receipt, logs: this.logs } = await this.mock.schedule(",
          "271:               this.operation.target,",
          "272:               this.operation.value,",
          "273:               this.operation.data,",
          "274:               this.operation.predecessor,",
          "275:               this.operation.salt,",
          "276:               MINDELAY,",
          "277:               { from: proposer },",
          "278:             ));",
          "279:           });",
          "281:           it('revert if execution comes too early 1/2', async function () {",
          "282:             await expectRevert(",
          "283:               this.mock.execute(",
          "284:                 this.operation.target,",
          "285:                 this.operation.value,",
          "286:                 this.operation.data,",
          "287:                 this.operation.predecessor,",
          "288:                 this.operation.salt,",
          "289:                 { from: executor },",
          "290:               ),",
          "291:               'TimelockController: operation is not ready',",
          "292:             );",
          "293:           });",
          "295:           it('revert if execution comes too early 2/2', async function () {",
          "296:             const timestamp = await this.mock.getTimestamp(this.operation.id);",
          "297:             await time.increaseTo(timestamp - 5); // -1 is too tight, test sometime fails",
          "299:             await expectRevert(",
          "300:               this.mock.execute(",
          "301:                 this.operation.target,",
          "302:                 this.operation.value,",
          "303:                 this.operation.data,",
          "304:                 this.operation.predecessor,",
          "305:                 this.operation.salt,",
          "306:                 { from: executor },",
          "307:               ),",
          "308:               'TimelockController: operation is not ready',",
          "309:             );",
          "310:           });",
          "312:           describe('on time', function () {",
          "313:             beforeEach(async function () {",
          "314:               const timestamp = await this.mock.getTimestamp(this.operation.id);",
          "315:               await time.increaseTo(timestamp);",
          "316:             });",
          "318:             it('executor can reveal', async function () {",
          "319:               const receipt = await this.mock.execute(",
          "320:                 this.operation.target,",
          "321:                 this.operation.value,",
          "322:                 this.operation.data,",
          "323:                 this.operation.predecessor,",
          "324:                 this.operation.salt,",
          "325:                 { from: executor },",
          "326:               );",
          "327:               expectEvent(receipt, 'CallExecuted', {",
          "328:                 id: this.operation.id,",
          "329:                 index: web3.utils.toBN(0),",
          "330:                 target: this.operation.target,",
          "331:                 value: web3.utils.toBN(this.operation.value),",
          "332:                 data: this.operation.data,",
          "333:               });",
          "334:             });",
          "336:             it('prevent non-executor from revealing', async function () {",
          "337:               await expectRevert(",
          "338:                 this.mock.execute(",
          "339:                   this.operation.target,",
          "340:                   this.operation.value,",
          "341:                   this.operation.data,",
          "342:                   this.operation.predecessor,",
          "343:                   this.operation.salt,",
          "344:                   { from: other },",
          "345:                 ),",
          "346:                 `AccessControl: account ${other.toLowerCase()} is missing role ${EXECUTOR_ROLE}`,",
          "347:               );",
          "348:             });",
          "350:             it('prevents reentrancy execution', async function () {",
          "352:               const reentrant = await TimelockReentrant.new();",
          "353:               const reentrantOperation = genOperation(",
          "354:                 reentrant.address,",
          "355:                 0,",
          "356:                 reentrant.contract.methods.reenter().encodeABI(),",
          "357:                 ZERO_BYTES32,",
          "358:                 salt,",
          "359:               );",
          "362:               await this.mock.schedule(",
          "363:                 reentrantOperation.target,",
          "364:                 reentrantOperation.value,",
          "365:                 reentrantOperation.data,",
          "366:                 reentrantOperation.predecessor,",
          "367:                 reentrantOperation.salt,",
          "368:                 MINDELAY,",
          "369:                 { from: proposer },",
          "370:               );",
          "373:               const timestamp = await this.mock.getTimestamp(reentrantOperation.id);",
          "374:               await time.increaseTo(timestamp);",
          "377:               await this.mock.grantRole(EXECUTOR_ROLE, reentrant.address, { from: admin });",
          "380:               const data = this.mock.contract.methods",
          "381:                 .execute(",
          "382:                   reentrantOperation.target,",
          "383:                   reentrantOperation.value,",
          "384:                   reentrantOperation.data,",
          "385:                   reentrantOperation.predecessor,",
          "386:                   reentrantOperation.salt,",
          "387:                 )",
          "388:                 .encodeABI();",
          "389:               await reentrant.enableRentrancy(this.mock.address, data);",
          "392:               await expectRevert(",
          "393:                 this.mock.execute(",
          "394:                   reentrantOperation.target,",
          "395:                   reentrantOperation.value,",
          "396:                   reentrantOperation.data,",
          "397:                   reentrantOperation.predecessor,",
          "398:                   reentrantOperation.salt,",
          "399:                   { from: executor },",
          "400:                 ),",
          "401:                 'TimelockController: operation is not ready',",
          "402:               );",
          "405:               await reentrant.disableReentrancy();",
          "406:               const nonReentrantOperation = reentrantOperation; // Not anymore",
          "409:               const receipt = await this.mock.execute(",
          "410:                 nonReentrantOperation.target,",
          "411:                 nonReentrantOperation.value,",
          "412:                 nonReentrantOperation.data,",
          "413:                 nonReentrantOperation.predecessor,",
          "414:                 nonReentrantOperation.salt,",
          "415:                 { from: executor },",
          "416:               );",
          "417:               expectEvent(receipt, 'CallExecuted', {",
          "418:                 id: nonReentrantOperation.id,",
          "419:                 index: web3.utils.toBN(0),",
          "420:                 target: nonReentrantOperation.target,",
          "421:                 value: web3.utils.toBN(nonReentrantOperation.value),",
          "422:                 data: nonReentrantOperation.data,",
          "423:               });",
          "424:             });",
          "425:           });",
          "426:         });",
          "427:       });",
          "428:     });",
          "430:     describe('batch', function () {",
          "431:       describe('schedule', function () {",
          "432:         beforeEach(async function () {",
          "433:           this.operation = genOperationBatch(",
          "434:             Array(8).fill('0xEd912250835c812D4516BBD80BdaEA1bB63a293C'),",
          "435:             Array(8).fill(0),",
          "436:             Array(8).fill('0x2fcb7a88'),",
          "437:             ZERO_BYTES32,",
          "438:             '0x6cf9d042ade5de78bed9ffd075eb4b2a4f6b1736932c2dc8af517d6e066f51f5',",
          "439:           );",
          "440:         });",
          "442:         it('proposer can schedule', async function () {",
          "443:           const receipt = await this.mock.scheduleBatch(",
          "444:             this.operation.targets,",
          "445:             this.operation.values,",
          "446:             this.operation.payloads,",
          "447:             this.operation.predecessor,",
          "448:             this.operation.salt,",
          "449:             MINDELAY,",
          "450:             { from: proposer },",
          "451:           );",
          "452:           for (const i in this.operation.targets) {",
          "453:             expectEvent(receipt, 'CallScheduled', {",
          "454:               id: this.operation.id,",
          "455:               index: web3.utils.toBN(i),",
          "456:               target: this.operation.targets[i],",
          "457:               value: web3.utils.toBN(this.operation.values[i]),",
          "458:               data: this.operation.payloads[i],",
          "459:               predecessor: this.operation.predecessor,",
          "460:               delay: MINDELAY,",
          "461:             });",
          "463:             expectEvent(receipt, 'CallSalt', {",
          "464:               id: this.operation.id,",
          "465:               salt: this.operation.salt,",
          "466:             });",
          "467:           }",
          "469:           const block = await web3.eth.getBlock(receipt.receipt.blockHash);",
          "471:           expect(await this.mock.getTimestamp(this.operation.id)).to.be.bignumber.equal(",
          "472:             web3.utils.toBN(block.timestamp).add(MINDELAY),",
          "473:           );",
          "474:         });",
          "476:         it('prevent overwriting active operation', async function () {",
          "477:           await this.mock.scheduleBatch(",
          "478:             this.operation.targets,",
          "479:             this.operation.values,",
          "480:             this.operation.payloads,",
          "481:             this.operation.predecessor,",
          "482:             this.operation.salt,",
          "483:             MINDELAY,",
          "484:             { from: proposer },",
          "485:           );",
          "487:           await expectRevert(",
          "488:             this.mock.scheduleBatch(",
          "489:               this.operation.targets,",
          "490:               this.operation.values,",
          "491:               this.operation.payloads,",
          "492:               this.operation.predecessor,",
          "493:               this.operation.salt,",
          "494:               MINDELAY,",
          "495:               { from: proposer },",
          "496:             ),",
          "497:             'TimelockController: operation already scheduled',",
          "498:           );",
          "499:         });",
          "501:         it('length of batch parameter must match #1', async function () {",
          "502:           await expectRevert(",
          "503:             this.mock.scheduleBatch(",
          "504:               this.operation.targets,",
          "505:               [],",
          "506:               this.operation.payloads,",
          "507:               this.operation.predecessor,",
          "508:               this.operation.salt,",
          "509:               MINDELAY,",
          "510:               { from: proposer },",
          "511:             ),",
          "512:             'TimelockController: length mismatch',",
          "513:           );",
          "514:         });",
          "516:         it('length of batch parameter must match #1', async function () {",
          "517:           await expectRevert(",
          "518:             this.mock.scheduleBatch(",
          "519:               this.operation.targets,",
          "520:               this.operation.values,",
          "521:               [],",
          "522:               this.operation.predecessor,",
          "523:               this.operation.salt,",
          "524:               MINDELAY,",
          "525:               { from: proposer },",
          "526:             ),",
          "527:             'TimelockController: length mismatch',",
          "528:           );",
          "529:         });",
          "531:         it('prevent non-proposer from committing', async function () {",
          "532:           await expectRevert(",
          "533:             this.mock.scheduleBatch(",
          "534:               this.operation.targets,",
          "535:               this.operation.values,",
          "536:               this.operation.payloads,",
          "537:               this.operation.predecessor,",
          "538:               this.operation.salt,",
          "539:               MINDELAY,",
          "540:               { from: other },",
          "541:             ),",
          "542:             `AccessControl: account ${other.toLowerCase()} is missing role ${PROPOSER_ROLE}`,",
          "543:           );",
          "544:         });",
          "546:         it('enforce minimum delay', async function () {",
          "547:           await expectRevert(",
          "548:             this.mock.scheduleBatch(",
          "549:               this.operation.targets,",
          "550:               this.operation.values,",
          "551:               this.operation.payloads,",
          "552:               this.operation.predecessor,",
          "553:               this.operation.salt,",
          "554:               MINDELAY - 1,",
          "555:               { from: proposer },",
          "556:             ),",
          "557:             'TimelockController: insufficient delay',",
          "558:           );",
          "559:         });",
          "560:       });",
          "562:       describe('execute', function () {",
          "563:         beforeEach(async function () {",
          "564:           this.operation = genOperationBatch(",
          "565:             Array(8).fill('0x76E53CcEb05131Ef5248553bEBDb8F70536830b1'),",
          "566:             Array(8).fill(0),",
          "567:             Array(8).fill('0x58a60f63'),",
          "568:             ZERO_BYTES32,",
          "569:             '0x9545eeabc7a7586689191f78a5532443698538e54211b5bd4d7dc0fc0102b5c7',",
          "570:           );",
          "571:         });",
          "573:         it('revert if operation is not scheduled', async function () {",
          "574:           await expectRevert(",
          "575:             this.mock.executeBatch(",
          "576:               this.operation.targets,",
          "577:               this.operation.values,",
          "578:               this.operation.payloads,",
          "579:               this.operation.predecessor,",
          "580:               this.operation.salt,",
          "581:               { from: executor },",
          "582:             ),",
          "583:             'TimelockController: operation is not ready',",
          "584:           );",
          "585:         });",
          "587:         describe('with scheduled operation', function () {",
          "588:           beforeEach(async function () {",
          "589:             ({ receipt: this.receipt, logs: this.logs } = await this.mock.scheduleBatch(",
          "590:               this.operation.targets,",
          "591:               this.operation.values,",
          "592:               this.operation.payloads,",
          "593:               this.operation.predecessor,",
          "594:               this.operation.salt,",
          "595:               MINDELAY,",
          "596:               { from: proposer },",
          "597:             ));",
          "598:           });",
          "600:           it('revert if execution comes too early 1/2', async function () {",
          "601:             await expectRevert(",
          "602:               this.mock.executeBatch(",
          "603:                 this.operation.targets,",
          "604:                 this.operation.values,",
          "605:                 this.operation.payloads,",
          "606:                 this.operation.predecessor,",
          "607:                 this.operation.salt,",
          "608:                 { from: executor },",
          "609:               ),",
          "610:               'TimelockController: operation is not ready',",
          "611:             );",
          "612:           });",
          "614:           it('revert if execution comes too early 2/2', async function () {",
          "615:             const timestamp = await this.mock.getTimestamp(this.operation.id);",
          "616:             await time.increaseTo(timestamp - 5); // -1 is to tight, test sometime fails",
          "618:             await expectRevert(",
          "619:               this.mock.executeBatch(",
          "620:                 this.operation.targets,",
          "621:                 this.operation.values,",
          "622:                 this.operation.payloads,",
          "623:                 this.operation.predecessor,",
          "624:                 this.operation.salt,",
          "625:                 { from: executor },",
          "626:               ),",
          "627:               'TimelockController: operation is not ready',",
          "628:             );",
          "629:           });",
          "631:           describe('on time', function () {",
          "632:             beforeEach(async function () {",
          "633:               const timestamp = await this.mock.getTimestamp(this.operation.id);",
          "634:               await time.increaseTo(timestamp);",
          "635:             });",
          "637:             it('executor can reveal', async function () {",
          "638:               const receipt = await this.mock.executeBatch(",
          "639:                 this.operation.targets,",
          "640:                 this.operation.values,",
          "641:                 this.operation.payloads,",
          "642:                 this.operation.predecessor,",
          "643:                 this.operation.salt,",
          "644:                 { from: executor },",
          "645:               );",
          "646:               for (const i in this.operation.targets) {",
          "647:                 expectEvent(receipt, 'CallExecuted', {",
          "648:                   id: this.operation.id,",
          "649:                   index: web3.utils.toBN(i),",
          "650:                   target: this.operation.targets[i],",
          "651:                   value: web3.utils.toBN(this.operation.values[i]),",
          "652:                   data: this.operation.payloads[i],",
          "653:                 });",
          "654:               }",
          "655:             });",
          "657:             it('prevent non-executor from revealing', async function () {",
          "658:               await expectRevert(",
          "659:                 this.mock.executeBatch(",
          "660:                   this.operation.targets,",
          "661:                   this.operation.values,",
          "662:                   this.operation.payloads,",
          "663:                   this.operation.predecessor,",
          "664:                   this.operation.salt,",
          "665:                   { from: other },",
          "666:                 ),",
          "667:                 `AccessControl: account ${other.toLowerCase()} is missing role ${EXECUTOR_ROLE}`,",
          "668:               );",
          "669:             });",
          "671:             it('length mismatch #1', async function () {",
          "672:               await expectRevert(",
          "673:                 this.mock.executeBatch(",
          "674:                   [],",
          "675:                   this.operation.values,",
          "676:                   this.operation.payloads,",
          "677:                   this.operation.predecessor,",
          "678:                   this.operation.salt,",
          "679:                   { from: executor },",
          "680:                 ),",
          "681:                 'TimelockController: length mismatch',",
          "682:               );",
          "683:             });",
          "685:             it('length mismatch #2', async function () {",
          "686:               await expectRevert(",
          "687:                 this.mock.executeBatch(",
          "688:                   this.operation.targets,",
          "689:                   [],",
          "690:                   this.operation.payloads,",
          "691:                   this.operation.predecessor,",
          "692:                   this.operation.salt,",
          "693:                   { from: executor },",
          "694:                 ),",
          "695:                 'TimelockController: length mismatch',",
          "696:               );",
          "697:             });",
          "699:             it('length mismatch #3', async function () {",
          "700:               await expectRevert(",
          "701:                 this.mock.executeBatch(",
          "702:                   this.operation.targets,",
          "703:                   this.operation.values,",
          "704:                   [],",
          "705:                   this.operation.predecessor,",
          "706:                   this.operation.salt,",
          "707:                   { from: executor },",
          "708:                 ),",
          "709:                 'TimelockController: length mismatch',",
          "710:               );",
          "711:             });",
          "713:             it('prevents reentrancy execution', async function () {",
          "715:               const reentrant = await TimelockReentrant.new();",
          "716:               const reentrantBatchOperation = genOperationBatch(",
          "717:                 [reentrant.address],",
          "718:                 [0],",
          "719:                 [reentrant.contract.methods.reenter().encodeABI()],",
          "720:                 ZERO_BYTES32,",
          "721:                 salt,",
          "722:               );",
          "725:               await this.mock.scheduleBatch(",
          "726:                 reentrantBatchOperation.targets,",
          "727:                 reentrantBatchOperation.values,",
          "728:                 reentrantBatchOperation.payloads,",
          "729:                 reentrantBatchOperation.predecessor,",
          "730:                 reentrantBatchOperation.salt,",
          "731:                 MINDELAY,",
          "732:                 { from: proposer },",
          "733:               );",
          "736:               const timestamp = await this.mock.getTimestamp(reentrantBatchOperation.id);",
          "737:               await time.increaseTo(timestamp);",
          "740:               await this.mock.grantRole(EXECUTOR_ROLE, reentrant.address, { from: admin });",
          "743:               const data = this.mock.contract.methods",
          "744:                 .executeBatch(",
          "745:                   reentrantBatchOperation.targets,",
          "746:                   reentrantBatchOperation.values,",
          "747:                   reentrantBatchOperation.payloads,",
          "748:                   reentrantBatchOperation.predecessor,",
          "749:                   reentrantBatchOperation.salt,",
          "750:                 )",
          "751:                 .encodeABI();",
          "752:               await reentrant.enableRentrancy(this.mock.address, data);",
          "755:               await expectRevert(",
          "756:                 this.mock.executeBatch(",
          "757:                   reentrantBatchOperation.targets,",
          "758:                   reentrantBatchOperation.values,",
          "759:                   reentrantBatchOperation.payloads,",
          "760:                   reentrantBatchOperation.predecessor,",
          "761:                   reentrantBatchOperation.salt,",
          "762:                   { from: executor },",
          "763:                 ),",
          "764:                 'TimelockController: operation is not ready',",
          "765:               );",
          "768:               await reentrant.disableReentrancy();",
          "769:               const nonReentrantBatchOperation = reentrantBatchOperation; // Not anymore",
          "772:               const receipt = await this.mock.executeBatch(",
          "773:                 nonReentrantBatchOperation.targets,",
          "774:                 nonReentrantBatchOperation.values,",
          "775:                 nonReentrantBatchOperation.payloads,",
          "776:                 nonReentrantBatchOperation.predecessor,",
          "777:                 nonReentrantBatchOperation.salt,",
          "778:                 { from: executor },",
          "779:               );",
          "780:               for (const i in nonReentrantBatchOperation.targets) {",
          "781:                 expectEvent(receipt, 'CallExecuted', {",
          "782:                   id: nonReentrantBatchOperation.id,",
          "783:                   index: web3.utils.toBN(i),",
          "784:                   target: nonReentrantBatchOperation.targets[i],",
          "785:                   value: web3.utils.toBN(nonReentrantBatchOperation.values[i]),",
          "786:                   data: nonReentrantBatchOperation.payloads[i],",
          "787:                 });",
          "788:               }",
          "789:             });",
          "790:           });",
          "791:         });",
          "793:         it('partial execution', async function () {",
          "794:           const operation = genOperationBatch(",
          "795:             [this.callreceivermock.address, this.callreceivermock.address, this.callreceivermock.address],",
          "796:             [0, 0, 0],",
          "797:             [",
          "798:               this.callreceivermock.contract.methods.mockFunction().encodeABI(),",
          "799:               this.callreceivermock.contract.methods.mockFunctionThrows().encodeABI(),",
          "800:               this.callreceivermock.contract.methods.mockFunction().encodeABI(),",
          "801:             ],",
          "802:             ZERO_BYTES32,",
          "803:             '0x8ac04aa0d6d66b8812fb41d39638d37af0a9ab11da507afd65c509f8ed079d3e',",
          "804:           );",
          "806:           await this.mock.scheduleBatch(",
          "807:             operation.targets,",
          "808:             operation.values,",
          "809:             operation.payloads,",
          "810:             operation.predecessor,",
          "811:             operation.salt,",
          "812:             MINDELAY,",
          "813:             { from: proposer },",
          "814:           );",
          "815:           await time.increase(MINDELAY);",
          "816:           await expectRevert(",
          "817:             this.mock.executeBatch(",
          "818:               operation.targets,",
          "819:               operation.values,",
          "820:               operation.payloads,",
          "821:               operation.predecessor,",
          "822:               operation.salt,",
          "823:               { from: executor },",
          "824:             ),",
          "825:             'TimelockController: underlying transaction reverted',",
          "826:           );",
          "827:         });",
          "828:       });",
          "829:     });",
          "831:     describe('cancel', function () {",
          "832:       beforeEach(async function () {",
          "833:         this.operation = genOperation(",
          "834:           '0xC6837c44AA376dbe1d2709F13879E040CAb653ca',",
          "835:           0,",
          "836:           '0x296e58dd',",
          "837:           ZERO_BYTES32,",
          "838:           '0xa2485763600634800df9fc9646fb2c112cf98649c55f63dd1d9c7d13a64399d9',",
          "839:         );",
          "840:         ({ receipt: this.receipt, logs: this.logs } = await this.mock.schedule(",
          "841:           this.operation.target,",
          "842:           this.operation.value,",
          "843:           this.operation.data,",
          "844:           this.operation.predecessor,",
          "845:           this.operation.salt,",
          "846:           MINDELAY,",
          "847:           { from: proposer },",
          "848:         ));",
          "849:       });",
          "851:       it('canceller can cancel', async function () {",
          "852:         const receipt = await this.mock.cancel(this.operation.id, { from: canceller });",
          "853:         expectEvent(receipt, 'Cancelled', { id: this.operation.id });",
          "854:       });",
          "856:       it('cannot cancel invalid operation', async function () {",
          "857:         await expectRevert(",
          "858:           this.mock.cancel(constants.ZERO_BYTES32, { from: canceller }),",
          "859:           'TimelockController: operation cannot be cancelled',",
          "860:         );",
          "861:       });",
          "863:       it('prevent non-canceller from canceling', async function () {",
          "864:         await expectRevert(",
          "865:           this.mock.cancel(this.operation.id, { from: other }),",
          "866:           `AccessControl: account ${other.toLowerCase()} is missing role ${CANCELLER_ROLE}`,",
          "867:         );",
          "868:       });",
          "869:     });",
          "870:   });",
          "872:   describe('maintenance', function () {",
          "873:     it('prevent unauthorized maintenance', async function () {",
          "874:       await expectRevert(this.mock.updateDelay(0, { from: other }), 'TimelockController: caller must be timelock');",
          "875:     });",
          "877:     it('timelock scheduled maintenance', async function () {",
          "878:       const newDelay = time.duration.hours(6);",
          "879:       const operation = genOperation(",
          "880:         this.mock.address,",
          "881:         0,",
          "882:         this.mock.contract.methods.updateDelay(newDelay.toString()).encodeABI(),",
          "883:         ZERO_BYTES32,",
          "884:         '0xf8e775b2c5f4d66fb5c7fa800f35ef518c262b6014b3c0aee6ea21bff157f108',",
          "885:       );",
          "887:       await this.mock.schedule(",
          "888:         operation.target,",
          "889:         operation.value,",
          "890:         operation.data,",
          "891:         operation.predecessor,",
          "892:         operation.salt,",
          "893:         MINDELAY,",
          "894:         { from: proposer },",
          "895:       );",
          "896:       await time.increase(MINDELAY);",
          "897:       const receipt = await this.mock.execute(",
          "898:         operation.target,",
          "899:         operation.value,",
          "900:         operation.data,",
          "901:         operation.predecessor,",
          "902:         operation.salt,",
          "903:         { from: executor },",
          "904:       );",
          "905:       expectEvent(receipt, 'MinDelayChange', { newDuration: newDelay.toString(), oldDuration: MINDELAY });",
          "907:       expect(await this.mock.getMinDelay()).to.be.bignumber.equal(newDelay);",
          "908:     });",
          "909:   });",
          "911:   describe('dependency', function () {",
          "912:     beforeEach(async function () {",
          "913:       this.operation1 = genOperation(",
          "914:         '0xdE66bD4c97304200A95aE0AadA32d6d01A867E39',",
          "915:         0,",
          "916:         '0x01dc731a',",
          "917:         ZERO_BYTES32,",
          "918:         '0x64e932133c7677402ead2926f86205e2ca4686aebecf5a8077627092b9bb2feb',",
          "919:       );",
          "920:       this.operation2 = genOperation(",
          "921:         '0x3c7944a3F1ee7fc8c5A5134ba7c79D11c3A1FCa3',",
          "922:         0,",
          "923:         '0x8f531849',",
          "924:         this.operation1.id,",
          "925:         '0x036e1311cac523f9548e6461e29fb1f8f9196b91910a41711ea22f5de48df07d',",
          "926:       );",
          "927:       await this.mock.schedule(",
          "928:         this.operation1.target,",
          "929:         this.operation1.value,",
          "930:         this.operation1.data,",
          "931:         this.operation1.predecessor,",
          "932:         this.operation1.salt,",
          "933:         MINDELAY,",
          "934:         { from: proposer },",
          "935:       );",
          "936:       await this.mock.schedule(",
          "937:         this.operation2.target,",
          "938:         this.operation2.value,",
          "939:         this.operation2.data,",
          "940:         this.operation2.predecessor,",
          "941:         this.operation2.salt,",
          "942:         MINDELAY,",
          "943:         { from: proposer },",
          "944:       );",
          "945:       await time.increase(MINDELAY);",
          "946:     });",
          "948:     it('cannot execute before dependency', async function () {",
          "949:       await expectRevert(",
          "950:         this.mock.execute(",
          "951:           this.operation2.target,",
          "952:           this.operation2.value,",
          "953:           this.operation2.data,",
          "954:           this.operation2.predecessor,",
          "955:           this.operation2.salt,",
          "956:           { from: executor },",
          "957:         ),",
          "958:         'TimelockController: missing dependency',",
          "959:       );",
          "960:     });",
          "962:     it('can execute after dependency', async function () {",
          "963:       await this.mock.execute(",
          "964:         this.operation1.target,",
          "965:         this.operation1.value,",
          "966:         this.operation1.data,",
          "967:         this.operation1.predecessor,",
          "968:         this.operation1.salt,",
          "969:         { from: executor },",
          "970:       );",
          "971:       await this.mock.execute(",
          "972:         this.operation2.target,",
          "973:         this.operation2.value,",
          "974:         this.operation2.data,",
          "975:         this.operation2.predecessor,",
          "976:         this.operation2.salt,",
          "977:         { from: executor },",
          "978:       );",
          "979:     });",
          "980:   });",
          "982:   describe('usage scenario', function () {",
          "983:     this.timeout(10000);",
          "985:     it('call', async function () {",
          "986:       const operation = genOperation(",
          "987:         this.implementation2.address,",
          "988:         0,",
          "989:         this.implementation2.contract.methods.setValue(42).encodeABI(),",
          "990:         ZERO_BYTES32,",
          "991:         '0x8043596363daefc89977b25f9d9b4d06c3910959ef0c4d213557a903e1b555e2',",
          "992:       );",
          "994:       await this.mock.schedule(",
          "995:         operation.target,",
          "996:         operation.value,",
          "997:         operation.data,",
          "998:         operation.predecessor,",
          "999:         operation.salt,",
          "1000:         MINDELAY,",
          "1001:         { from: proposer },",
          "1002:       );",
          "1003:       await time.increase(MINDELAY);",
          "1004:       await this.mock.execute(",
          "1005:         operation.target,",
          "1006:         operation.value,",
          "1007:         operation.data,",
          "1008:         operation.predecessor,",
          "1009:         operation.salt,",
          "1010:         { from: executor },",
          "1011:       );",
          "1013:       expect(await this.implementation2.getValue()).to.be.bignumber.equal(web3.utils.toBN(42));",
          "1014:     });",
          "1016:     it('call reverting', async function () {",
          "1017:       const operation = genOperation(",
          "1018:         this.callreceivermock.address,",
          "1019:         0,",
          "1020:         this.callreceivermock.contract.methods.mockFunctionRevertsNoReason().encodeABI(),",
          "1021:         ZERO_BYTES32,",
          "1022:         '0xb1b1b276fdf1a28d1e00537ea73b04d56639128b08063c1a2f70a52e38cba693',",
          "1023:       );",
          "1025:       await this.mock.schedule(",
          "1026:         operation.target,",
          "1027:         operation.value,",
          "1028:         operation.data,",
          "1029:         operation.predecessor,",
          "1030:         operation.salt,",
          "1031:         MINDELAY,",
          "1032:         { from: proposer },",
          "1033:       );",
          "1034:       await time.increase(MINDELAY);",
          "1035:       await expectRevert(",
          "1036:         this.mock.execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, {",
          "1037:           from: executor,",
          "1038:         }),",
          "1039:         'TimelockController: underlying transaction reverted',",
          "1040:       );",
          "1041:     });",
          "1043:     it('call throw', async function () {",
          "1044:       const operation = genOperation(",
          "1045:         this.callreceivermock.address,",
          "1046:         0,",
          "1047:         this.callreceivermock.contract.methods.mockFunctionThrows().encodeABI(),",
          "1048:         ZERO_BYTES32,",
          "1049:         '0xe5ca79f295fc8327ee8a765fe19afb58f4a0cbc5053642bfdd7e73bc68e0fc67',",
          "1050:       );",
          "1052:       await this.mock.schedule(",
          "1053:         operation.target,",
          "1054:         operation.value,",
          "1055:         operation.data,",
          "1056:         operation.predecessor,",
          "1057:         operation.salt,",
          "1058:         MINDELAY,",
          "1059:         { from: proposer },",
          "1060:       );",
          "1061:       await time.increase(MINDELAY);",
          "1062:       await expectRevert(",
          "1063:         this.mock.execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, {",
          "1064:           from: executor,",
          "1065:         }),",
          "1066:         'TimelockController: underlying transaction reverted',",
          "1067:       );",
          "1068:     });",
          "1070:     it('call out of gas', async function () {",
          "1071:       const operation = genOperation(",
          "1072:         this.callreceivermock.address,",
          "1073:         0,",
          "1074:         this.callreceivermock.contract.methods.mockFunctionOutOfGas().encodeABI(),",
          "1075:         ZERO_BYTES32,",
          "1076:         '0xf3274ce7c394c5b629d5215723563a744b817e1730cca5587c567099a14578fd',",
          "1077:       );",
          "1079:       await this.mock.schedule(",
          "1080:         operation.target,",
          "1081:         operation.value,",
          "1082:         operation.data,",
          "1083:         operation.predecessor,",
          "1084:         operation.salt,",
          "1085:         MINDELAY,",
          "1086:         { from: proposer },",
          "1087:       );",
          "1088:       await time.increase(MINDELAY);",
          "1089:       await expectRevert(",
          "1090:         this.mock.execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, {",
          "1091:           from: executor,",
          "1092:           gas: '70000',",
          "1093:         }),",
          "1094:         'TimelockController: underlying transaction reverted',",
          "1095:       );",
          "1096:     });",
          "1098:     it('call payable with eth', async function () {",
          "1099:       const operation = genOperation(",
          "1100:         this.callreceivermock.address,",
          "1101:         1,",
          "1102:         this.callreceivermock.contract.methods.mockFunction().encodeABI(),",
          "1103:         ZERO_BYTES32,",
          "1104:         '0x5ab73cd33477dcd36c1e05e28362719d0ed59a7b9ff14939de63a43073dc1f44',",
          "1105:       );",
          "1107:       await this.mock.schedule(",
          "1108:         operation.target,",
          "1109:         operation.value,",
          "1110:         operation.data,",
          "1111:         operation.predecessor,",
          "1112:         operation.salt,",
          "1113:         MINDELAY,",
          "1114:         { from: proposer },",
          "1115:       );",
          "1116:       await time.increase(MINDELAY);",
          "1118:       expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1119:       expect(await web3.eth.getBalance(this.callreceivermock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1121:       await this.mock.execute(",
          "1122:         operation.target,",
          "1123:         operation.value,",
          "1124:         operation.data,",
          "1125:         operation.predecessor,",
          "1126:         operation.salt,",
          "1127:         { from: executor, value: 1 },",
          "1128:       );",
          "1130:       expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1131:       expect(await web3.eth.getBalance(this.callreceivermock.address)).to.be.bignumber.equal(web3.utils.toBN(1));",
          "1132:     });",
          "1134:     it('call nonpayable with eth', async function () {",
          "1135:       const operation = genOperation(",
          "1136:         this.callreceivermock.address,",
          "1137:         1,",
          "1138:         this.callreceivermock.contract.methods.mockFunctionNonPayable().encodeABI(),",
          "1139:         ZERO_BYTES32,",
          "1140:         '0xb78edbd920c7867f187e5aa6294ae5a656cfbf0dea1ccdca3751b740d0f2bdf8',",
          "1141:       );",
          "1143:       await this.mock.schedule(",
          "1144:         operation.target,",
          "1145:         operation.value,",
          "1146:         operation.data,",
          "1147:         operation.predecessor,",
          "1148:         operation.salt,",
          "1149:         MINDELAY,",
          "1150:         { from: proposer },",
          "1151:       );",
          "1152:       await time.increase(MINDELAY);",
          "1154:       expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1155:       expect(await web3.eth.getBalance(this.callreceivermock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1157:       await expectRevert(",
          "1158:         this.mock.execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, {",
          "1159:           from: executor,",
          "1160:         }),",
          "1161:         'TimelockController: underlying transaction reverted',",
          "1162:       );",
          "1164:       expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1165:       expect(await web3.eth.getBalance(this.callreceivermock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1166:     });",
          "1168:     it('call reverting with eth', async function () {",
          "1169:       const operation = genOperation(",
          "1170:         this.callreceivermock.address,",
          "1171:         1,",
          "1172:         this.callreceivermock.contract.methods.mockFunctionRevertsNoReason().encodeABI(),",
          "1173:         ZERO_BYTES32,",
          "1174:         '0xdedb4563ef0095db01d81d3f2decf57cf83e4a72aa792af14c43a792b56f4de6',",
          "1175:       );",
          "1177:       await this.mock.schedule(",
          "1178:         operation.target,",
          "1179:         operation.value,",
          "1180:         operation.data,",
          "1181:         operation.predecessor,",
          "1182:         operation.salt,",
          "1183:         MINDELAY,",
          "1184:         { from: proposer },",
          "1185:       );",
          "1186:       await time.increase(MINDELAY);",
          "1188:       expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1189:       expect(await web3.eth.getBalance(this.callreceivermock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1191:       await expectRevert(",
          "1192:         this.mock.execute(operation.target, operation.value, operation.data, operation.predecessor, operation.salt, {",
          "1193:           from: executor,",
          "1194:         }),",
          "1195:         'TimelockController: underlying transaction reverted',",
          "1196:       );",
          "1198:       expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1199:       expect(await web3.eth.getBalance(this.callreceivermock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "1200:     });",
          "1201:   });",
          "1203:   describe('safe receive', function () {",
          "1204:     describe('ERC721', function () {",
          "1205:       const name = 'Non Fungible Token';",
          "1206:       const symbol = 'NFT';",
          "1207:       const tokenId = new BN(1);",
          "1209:       beforeEach(async function () {",
          "1210:         this.token = await ERC721.new(name, symbol);",
          "1211:         await this.token.$_mint(other, tokenId);",
          "1212:       });",
          "1214:       it('can receive an ERC721 safeTransfer', async function () {",
          "1215:         await this.token.safeTransferFrom(other, this.mock.address, tokenId, { from: other });",
          "1216:       });",
          "1217:     });",
          "1219:     describe('ERC1155', function () {",
          "1220:       const uri = 'https://token-cdn-domain/{id}.json';",
          "1221:       const tokenIds = {",
          "1222:         1: new BN(1000),",
          "1223:         2: new BN(2000),",
          "1224:         3: new BN(3000),",
          "1225:       };",
          "1227:       beforeEach(async function () {",
          "1228:         this.token = await ERC1155.new(uri);",
          "1229:         await this.token.$_mintBatch(other, Object.keys(tokenIds), Object.values(tokenIds), '0x');",
          "1230:       });",
          "1232:       it('can receive ERC1155 safeTransfer', async function () {",
          "1233:         await this.token.safeTransferFrom(",
          "1234:           other,",
          "1235:           this.mock.address,",
          "1236:           ...Object.entries(tokenIds)[0], // id + amount",
          "1237:           '0x',",
          "1238:           { from: other },",
          "1239:         );",
          "1240:       });",
          "1242:       it('can receive ERC1155 safeBatchTransfer', async function () {",
          "1243:         await this.token.safeBatchTransferFrom(",
          "1244:           other,",
          "1245:           this.mock.address,",
          "1246:           Object.keys(tokenIds),",
          "1247:           Object.values(tokenIds),",
          "1248:           '0x',",
          "1249:           { from: other },",
          "1250:         );",
          "1251:       });",
          "1252:     });",
          "1253:   });",
          "1254: });",
          "",
          "---------------"
        ],
        "test/governance/compatibility/GovernorCompatibilityBravo.test.js||test/governance/compatibility/GovernorCompatibilityBravo.test.js": [
          "File: test/governance/compatibility/GovernorCompatibilityBravo.test.js -> test/governance/compatibility/GovernorCompatibilityBravo.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const RLP = require('rlp');",
          "4: const Enums = require('../../helpers/enums');",
          "5: const { GovernorHelper } = require('../../helpers/governance');",
          "6: const { clockFromReceipt } = require('../../helpers/time');",
          "8: const Timelock = artifacts.require('CompTimelock');",
          "9: const Governor = artifacts.require('$GovernorCompatibilityBravoMock');",
          "10: const CallReceiver = artifacts.require('CallReceiverMock');",
          "12: const { shouldBehaveLikeEIP6372 } = require('../utils/EIP6372.behavior');",
          "14: function makeContractAddress(creator, nonce) {",
          "15:   return web3.utils.toChecksumAddress(",
          "16:     web3.utils",
          "17:       .sha3(RLP.encode([creator, nonce]))",
          "18:       .slice(12)",
          "19:       .substring(14),",
          "20:   );",
          "21: }",
          "23: const TOKENS = [",
          "24:   { Token: artifacts.require('$ERC20VotesComp'), mode: 'blocknumber' },",
          "25:   { Token: artifacts.require('$ERC20VotesCompTimestampMock'), mode: 'timestamp' },",
          "26: ];",
          "28: contract('GovernorCompatibilityBravo', function (accounts) {",
          "29:   const [owner, proposer, voter1, voter2, voter3, voter4, other] = accounts;",
          "31:   const name = 'OZ-Governor';",
          "33:   const tokenName = 'MockToken';",
          "34:   const tokenSymbol = 'MTKN';",
          "35:   const tokenSupply = web3.utils.toWei('100');",
          "36:   const votingDelay = web3.utils.toBN(4);",
          "37:   const votingPeriod = web3.utils.toBN(16);",
          "38:   const proposalThreshold = web3.utils.toWei('10');",
          "39:   const value = web3.utils.toWei('1');",
          "41:   for (const { mode, Token } of TOKENS) {",
          "42:     describe(`using ${Token._json.contractName}`, function () {",
          "43:       beforeEach(async function () {",
          "44:         const [deployer] = await web3.eth.getAccounts();",
          "46:         this.token = await Token.new(tokenName, tokenSymbol, tokenName);",
          "49:         const nonce = await web3.eth.getTransactionCount(deployer);",
          "50:         const predictGovernor = makeContractAddress(deployer, nonce + 1);",
          "52:         this.timelock = await Timelock.new(predictGovernor, 2 * 86400);",
          "53:         this.mock = await Governor.new(",
          "54:           name,",
          "55:           votingDelay,",
          "56:           votingPeriod,",
          "57:           proposalThreshold,",
          "58:           this.timelock.address,",
          "59:           this.token.address,",
          "60:         );",
          "61:         this.receiver = await CallReceiver.new();",
          "63:         this.helper = new GovernorHelper(this.mock, mode);",
          "65:         await web3.eth.sendTransaction({ from: owner, to: this.timelock.address, value });",
          "67:         await this.token.$_mint(owner, tokenSupply);",
          "68:         await this.helper.delegate({ token: this.token, to: proposer, value: proposalThreshold }, { from: owner });",
          "69:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: owner });",
          "70:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: owner });",
          "71:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: owner });",
          "72:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: owner });",
          "75:         this.proposal = this.helper.setProposal(",
          "76:           [",
          "77:             {",
          "78:               target: this.receiver.address,",
          "79:               value,",
          "80:               signature: 'mockFunction()',",
          "81:             },",
          "82:           ],",
          "83:           '<proposal description>',",
          "84:         );",
          "85:       });",
          "87:       shouldBehaveLikeEIP6372(mode);",
          "89:       it('deployment check', async function () {",
          "90:         expect(await this.mock.name()).to.be.equal(name);",
          "91:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "92:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "93:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "94:         expect(await this.mock.quorum(0)).to.be.bignumber.equal('0');",
          "95:         expect(await this.mock.quorumVotes()).to.be.bignumber.equal('0');",
          "96:         expect(await this.mock.COUNTING_MODE()).to.be.equal('support=bravo&quorum=bravo');",
          "97:       });",
          "99:       it('nominal workflow', async function () {",
          "101:         expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "102:         expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(false);",
          "103:         expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(false);",
          "104:         expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal('0');",
          "105:         expect(await web3.eth.getBalance(this.timelock.address)).to.be.bignumber.equal(value);",
          "106:         expect(await web3.eth.getBalance(this.receiver.address)).to.be.bignumber.equal('0');",
          "109:         const txPropose = await this.helper.propose({ from: proposer });",
          "110:         await this.helper.waitForSnapshot();",
          "111:         await this.helper.vote({ support: Enums.VoteType.For, reason: 'This is nice' }, { from: voter1 });",
          "112:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "113:         await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 });",
          "114:         await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 });",
          "115:         await this.helper.waitForDeadline();",
          "116:         await this.helper.queue();",
          "117:         await this.helper.waitForEta();",
          "118:         const txExecute = await this.helper.execute();",
          "121:         expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "122:         expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(true);",
          "123:         expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(true);",
          "124:         expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal('0');",
          "125:         expect(await web3.eth.getBalance(this.timelock.address)).to.be.bignumber.equal('0');",
          "126:         expect(await web3.eth.getBalance(this.receiver.address)).to.be.bignumber.equal(value);",
          "128:         const proposal = await this.mock.proposals(this.proposal.id);",
          "129:         expect(proposal.id).to.be.bignumber.equal(this.proposal.id);",
          "130:         expect(proposal.proposer).to.be.equal(proposer);",
          "131:         expect(proposal.eta).to.be.bignumber.equal(await this.mock.proposalEta(this.proposal.id));",
          "132:         expect(proposal.startBlock).to.be.bignumber.equal(await this.mock.proposalSnapshot(this.proposal.id));",
          "133:         expect(proposal.endBlock).to.be.bignumber.equal(await this.mock.proposalDeadline(this.proposal.id));",
          "134:         expect(proposal.canceled).to.be.equal(false);",
          "135:         expect(proposal.executed).to.be.equal(true);",
          "137:         const action = await this.mock.getActions(this.proposal.id);",
          "138:         expect(action.targets).to.be.deep.equal(this.proposal.targets);",
          "140:         expect(action.signatures).to.be.deep.equal(this.proposal.signatures);",
          "141:         expect(action.calldatas).to.be.deep.equal(this.proposal.data);",
          "143:         const voteReceipt1 = await this.mock.getReceipt(this.proposal.id, voter1);",
          "144:         expect(voteReceipt1.hasVoted).to.be.equal(true);",
          "145:         expect(voteReceipt1.support).to.be.bignumber.equal(Enums.VoteType.For);",
          "146:         expect(voteReceipt1.votes).to.be.bignumber.equal(web3.utils.toWei('10'));",
          "148:         const voteReceipt2 = await this.mock.getReceipt(this.proposal.id, voter2);",
          "149:         expect(voteReceipt2.hasVoted).to.be.equal(true);",
          "150:         expect(voteReceipt2.support).to.be.bignumber.equal(Enums.VoteType.For);",
          "151:         expect(voteReceipt2.votes).to.be.bignumber.equal(web3.utils.toWei('7'));",
          "153:         const voteReceipt3 = await this.mock.getReceipt(this.proposal.id, voter3);",
          "154:         expect(voteReceipt3.hasVoted).to.be.equal(true);",
          "155:         expect(voteReceipt3.support).to.be.bignumber.equal(Enums.VoteType.Against);",
          "156:         expect(voteReceipt3.votes).to.be.bignumber.equal(web3.utils.toWei('5'));",
          "158:         const voteReceipt4 = await this.mock.getReceipt(this.proposal.id, voter4);",
          "159:         expect(voteReceipt4.hasVoted).to.be.equal(true);",
          "160:         expect(voteReceipt4.support).to.be.bignumber.equal(Enums.VoteType.Abstain);",
          "161:         expect(voteReceipt4.votes).to.be.bignumber.equal(web3.utils.toWei('2'));",
          "163:         expectEvent(txPropose, 'ProposalCreated', {",
          "164:           proposalId: this.proposal.id,",
          "165:           proposer,",
          "166:           targets: this.proposal.targets,",
          "168:           signatures: this.proposal.signatures.map(() => ''), // this event doesn't contain the proposal detail",
          "169:           calldatas: this.proposal.fulldata,",
          "170:           voteStart: web3.utils.toBN(await clockFromReceipt[mode](txPropose.receipt)).add(votingDelay),",
          "171:           voteEnd: web3.utils",
          "172:             .toBN(await clockFromReceipt[mode](txPropose.receipt))",
          "173:             .add(votingDelay)",
          "174:             .add(votingPeriod),",
          "175:           description: this.proposal.description,",
          "176:         });",
          "177:         expectEvent(txExecute, 'ProposalExecuted', { proposalId: this.proposal.id });",
          "178:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'MockFunctionCalled');",
          "179:       });",
          "181:       it('double voting is forbidden', async function () {",
          "182:         await this.helper.propose({ from: proposer });",
          "183:         await this.helper.waitForSnapshot();",
          "184:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "185:         await expectRevert(",
          "186:           this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 }),",
          "187:           'GovernorCompatibilityBravo: vote already cast',",
          "188:         );",
          "189:       });",
          "191:       it('with function selector and arguments', async function () {",
          "192:         const target = this.receiver.address;",
          "193:         this.helper.setProposal(",
          "194:           [",
          "195:             { target, data: this.receiver.contract.methods.mockFunction().encodeABI() },",
          "196:             { target, data: this.receiver.contract.methods.mockFunctionWithArgs(17, 42).encodeABI() },",
          "197:             { target, signature: 'mockFunctionNonPayable()' },",
          "198:             {",
          "199:               target,",
          "200:               signature: 'mockFunctionWithArgs(uint256,uint256)',",
          "201:               data: web3.eth.abi.encodeParameters(['uint256', 'uint256'], [18, 43]),",
          "202:             },",
          "203:           ],",
          "204:           '<proposal description>',",
          "205:         );",
          "207:         await this.helper.propose({ from: proposer });",
          "208:         await this.helper.waitForSnapshot();",
          "209:         await this.helper.vote({ support: Enums.VoteType.For, reason: 'This is nice' }, { from: voter1 });",
          "210:         await this.helper.waitForDeadline();",
          "211:         await this.helper.queue();",
          "212:         await this.helper.waitForEta();",
          "213:         const txExecute = await this.helper.execute();",
          "215:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'MockFunctionCalled');",
          "216:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'MockFunctionCalled');",
          "217:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'MockFunctionCalledWithArgs', {",
          "218:           a: '17',",
          "219:           b: '42',",
          "220:         });",
          "221:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'MockFunctionCalledWithArgs', {",
          "222:           a: '18',",
          "223:           b: '43',",
          "224:         });",
          "225:       });",
          "227:       it('with inconsistent array size for selector and arguments', async function () {",
          "228:         const target = this.receiver.address;",
          "229:         this.helper.setProposal(",
          "230:           {",
          "231:             targets: [target, target],",
          "232:             values: [0, 0],",
          "233:             signatures: ['mockFunction()'], // One signature",
          "234:             data: ['0x', this.receiver.contract.methods.mockFunctionWithArgs(17, 42).encodeABI()], // Two data entries",
          "235:           },",
          "236:           '<proposal description>',",
          "237:         );",
          "239:         await expectRevert(this.helper.propose({ from: proposer }), 'GovernorBravo: invalid signatures length');",
          "240:       });",
          "242:       describe('should revert', function () {",
          "243:         describe('on propose', function () {",
          "244:           it('if proposal does not meet proposalThreshold', async function () {",
          "245:             await expectRevert(",
          "246:               this.helper.propose({ from: other }),",
          "247:               'Governor: proposer votes below proposal threshold',",
          "248:             );",
          "249:           });",
          "250:         });",
          "252:         describe('on vote', function () {",
          "253:           it('if vote type is invalide', async function () {",
          "254:             await this.helper.propose({ from: proposer });",
          "255:             await this.helper.waitForSnapshot();",
          "256:             await expectRevert(",
          "257:               this.helper.vote({ support: 5 }, { from: voter1 }),",
          "258:               'GovernorCompatibilityBravo: invalid vote type',",
          "259:             );",
          "260:           });",
          "261:         });",
          "262:       });",
          "264:       describe('cancel', function () {",
          "265:         it('proposer can cancel', async function () {",
          "266:           await this.helper.propose({ from: proposer });",
          "267:           await this.helper.cancel('external', { from: proposer });",
          "268:         });",
          "270:         it('anyone can cancel if proposer drop below threshold', async function () {",
          "271:           await this.helper.propose({ from: proposer });",
          "272:           await this.token.transfer(voter1, web3.utils.toWei('1'), { from: proposer });",
          "273:           await this.helper.cancel('external');",
          "274:         });",
          "276:         it('cannot cancel is proposer is still above threshold', async function () {",
          "277:           await this.helper.propose({ from: proposer });",
          "278:           await expectRevert(this.helper.cancel('external'), 'GovernorBravo: proposer above threshold');",
          "279:         });",
          "280:       });",
          "281:     });",
          "282:   }",
          "283: });",
          "",
          "---------------"
        ],
        "test/governance/extensions/GovernorComp.test.js||test/governance/extensions/GovernorComp.test.js": [
          "File: test/governance/extensions/GovernorComp.test.js -> test/governance/extensions/GovernorComp.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expect } = require('chai');",
          "2: const Enums = require('../../helpers/enums');",
          "3: const { GovernorHelper } = require('../../helpers/governance');",
          "5: const Governor = artifacts.require('$GovernorCompMock');",
          "6: const CallReceiver = artifacts.require('CallReceiverMock');",
          "8: const TOKENS = [",
          "9:   { Token: artifacts.require('$ERC20VotesComp'), mode: 'blocknumber' },",
          "10:   { Token: artifacts.require('$ERC20VotesCompTimestampMock'), mode: 'timestamp' },",
          "11: ];",
          "13: contract('GovernorComp', function (accounts) {",
          "14:   const [owner, voter1, voter2, voter3, voter4] = accounts;",
          "16:   const name = 'OZ-Governor';",
          "18:   const tokenName = 'MockToken';",
          "19:   const tokenSymbol = 'MTKN';",
          "20:   const tokenSupply = web3.utils.toWei('100');",
          "21:   const votingDelay = web3.utils.toBN(4);",
          "22:   const votingPeriod = web3.utils.toBN(16);",
          "23:   const value = web3.utils.toWei('1');",
          "25:   for (const { mode, Token } of TOKENS) {",
          "26:     describe(`using ${Token._json.contractName}`, function () {",
          "27:       beforeEach(async function () {",
          "28:         this.owner = owner;",
          "29:         this.token = await Token.new(tokenName, tokenSymbol, tokenName);",
          "30:         this.mock = await Governor.new(name, this.token.address);",
          "31:         this.receiver = await CallReceiver.new();",
          "33:         this.helper = new GovernorHelper(this.mock, mode);",
          "35:         await web3.eth.sendTransaction({ from: owner, to: this.mock.address, value });",
          "37:         await this.token.$_mint(owner, tokenSupply);",
          "38:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: owner });",
          "39:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: owner });",
          "40:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: owner });",
          "41:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: owner });",
          "44:         this.proposal = this.helper.setProposal(",
          "45:           [",
          "46:             {",
          "47:               target: this.receiver.address,",
          "48:               value,",
          "49:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "50:             },",
          "51:           ],",
          "52:           '<proposal description>',",
          "53:         );",
          "54:       });",
          "56:       it('deployment check', async function () {",
          "57:         expect(await this.mock.name()).to.be.equal(name);",
          "58:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "59:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "60:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "61:         expect(await this.mock.quorum(0)).to.be.bignumber.equal('0');",
          "62:       });",
          "64:       it('voting with comp token', async function () {",
          "65:         await this.helper.propose();",
          "66:         await this.helper.waitForSnapshot();",
          "67:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "68:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "69:         await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 });",
          "70:         await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 });",
          "71:         await this.helper.waitForDeadline();",
          "72:         await this.helper.execute();",
          "74:         expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "75:         expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(true);",
          "76:         expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(true);",
          "77:         expect(await this.mock.hasVoted(this.proposal.id, voter3)).to.be.equal(true);",
          "78:         expect(await this.mock.hasVoted(this.proposal.id, voter4)).to.be.equal(true);",
          "80:         await this.mock.proposalVotes(this.proposal.id).then(results => {",
          "81:           expect(results.forVotes).to.be.bignumber.equal(web3.utils.toWei('17'));",
          "82:           expect(results.againstVotes).to.be.bignumber.equal(web3.utils.toWei('5'));",
          "83:           expect(results.abstainVotes).to.be.bignumber.equal(web3.utils.toWei('2'));",
          "84:         });",
          "85:       });",
          "86:     });",
          "87:   }",
          "88: });",
          "",
          "---------------"
        ],
        "test/governance/extensions/GovernorERC721.test.js||test/governance/extensions/GovernorERC721.test.js": [
          "File: test/governance/extensions/GovernorERC721.test.js -> test/governance/extensions/GovernorERC721.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectEvent } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const Enums = require('../../helpers/enums');",
          "4: const { GovernorHelper } = require('../../helpers/governance');",
          "6: const Governor = artifacts.require('$GovernorVoteMocks');",
          "7: const CallReceiver = artifacts.require('CallReceiverMock');",
          "9: const TOKENS = [",
          "10:   { Token: artifacts.require('$ERC721Votes'), mode: 'blocknumber' },",
          "11:   { Token: artifacts.require('$ERC721VotesTimestampMock'), mode: 'timestamp' },",
          "12: ];",
          "14: contract('GovernorERC721', function (accounts) {",
          "15:   const [owner, voter1, voter2, voter3, voter4] = accounts;",
          "17:   const name = 'OZ-Governor';",
          "19:   const tokenName = 'MockNFToken';",
          "20:   const tokenSymbol = 'MTKN';",
          "21:   const NFT0 = web3.utils.toBN(0);",
          "22:   const NFT1 = web3.utils.toBN(1);",
          "23:   const NFT2 = web3.utils.toBN(2);",
          "24:   const NFT3 = web3.utils.toBN(3);",
          "25:   const NFT4 = web3.utils.toBN(4);",
          "26:   const votingDelay = web3.utils.toBN(4);",
          "27:   const votingPeriod = web3.utils.toBN(16);",
          "28:   const value = web3.utils.toWei('1');",
          "30:   for (const { mode, Token } of TOKENS) {",
          "31:     describe(`using ${Token._json.contractName}`, function () {",
          "32:       beforeEach(async function () {",
          "33:         this.owner = owner;",
          "34:         this.token = await Token.new(tokenName, tokenSymbol, tokenName, '1');",
          "35:         this.mock = await Governor.new(name, this.token.address);",
          "36:         this.receiver = await CallReceiver.new();",
          "38:         this.helper = new GovernorHelper(this.mock, mode);",
          "40:         await web3.eth.sendTransaction({ from: owner, to: this.mock.address, value });",
          "42:         await Promise.all([NFT0, NFT1, NFT2, NFT3, NFT4].map(tokenId => this.token.$_mint(owner, tokenId)));",
          "43:         await this.helper.delegate({ token: this.token, to: voter1, tokenId: NFT0 }, { from: owner });",
          "44:         await this.helper.delegate({ token: this.token, to: voter2, tokenId: NFT1 }, { from: owner });",
          "45:         await this.helper.delegate({ token: this.token, to: voter2, tokenId: NFT2 }, { from: owner });",
          "46:         await this.helper.delegate({ token: this.token, to: voter3, tokenId: NFT3 }, { from: owner });",
          "47:         await this.helper.delegate({ token: this.token, to: voter4, tokenId: NFT4 }, { from: owner });",
          "50:         this.proposal = this.helper.setProposal(",
          "51:           [",
          "52:             {",
          "53:               target: this.receiver.address,",
          "54:               value,",
          "55:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "56:             },",
          "57:           ],",
          "58:           '<proposal description>',",
          "59:         );",
          "60:       });",
          "62:       it('deployment check', async function () {",
          "63:         expect(await this.mock.name()).to.be.equal(name);",
          "64:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "65:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "66:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "67:         expect(await this.mock.quorum(0)).to.be.bignumber.equal('0');",
          "68:       });",
          "70:       it('voting with ERC721 token', async function () {",
          "71:         await this.helper.propose();",
          "72:         await this.helper.waitForSnapshot();",
          "74:         expectEvent(await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 }), 'VoteCast', {",
          "75:           voter: voter1,",
          "76:           support: Enums.VoteType.For,",
          "77:           weight: '1',",
          "78:         });",
          "80:         expectEvent(await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 }), 'VoteCast', {",
          "81:           voter: voter2,",
          "82:           support: Enums.VoteType.For,",
          "83:           weight: '2',",
          "84:         });",
          "86:         expectEvent(await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 }), 'VoteCast', {",
          "87:           voter: voter3,",
          "88:           support: Enums.VoteType.Against,",
          "89:           weight: '1',",
          "90:         });",
          "92:         expectEvent(await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 }), 'VoteCast', {",
          "93:           voter: voter4,",
          "94:           support: Enums.VoteType.Abstain,",
          "95:           weight: '1',",
          "96:         });",
          "98:         await this.helper.waitForDeadline();",
          "99:         await this.helper.execute();",
          "101:         expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "102:         expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(true);",
          "103:         expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(true);",
          "104:         expect(await this.mock.hasVoted(this.proposal.id, voter3)).to.be.equal(true);",
          "105:         expect(await this.mock.hasVoted(this.proposal.id, voter4)).to.be.equal(true);",
          "107:         await this.mock.proposalVotes(this.proposal.id).then(results => {",
          "108:           expect(results.forVotes).to.be.bignumber.equal('3');",
          "109:           expect(results.againstVotes).to.be.bignumber.equal('1');",
          "110:           expect(results.abstainVotes).to.be.bignumber.equal('1');",
          "111:         });",
          "112:       });",
          "113:     });",
          "114:   }",
          "115: });",
          "",
          "---------------"
        ],
        "test/governance/extensions/GovernorPreventLateQuorum.test.js||test/governance/extensions/GovernorPreventLateQuorum.test.js": [
          "File: test/governance/extensions/GovernorPreventLateQuorum.test.js -> test/governance/extensions/GovernorPreventLateQuorum.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const Enums = require('../../helpers/enums');",
          "4: const { GovernorHelper } = require('../../helpers/governance');",
          "5: const { clockFromReceipt } = require('../../helpers/time');",
          "7: const Governor = artifacts.require('$GovernorPreventLateQuorumMock');",
          "8: const CallReceiver = artifacts.require('CallReceiverMock');",
          "10: const TOKENS = [",
          "11:   { Token: artifacts.require('$ERC20Votes'), mode: 'blocknumber' },",
          "12:   { Token: artifacts.require('$ERC20VotesTimestampMock'), mode: 'timestamp' },",
          "13: ];",
          "15: contract('GovernorPreventLateQuorum', function (accounts) {",
          "16:   const [owner, proposer, voter1, voter2, voter3, voter4] = accounts;",
          "18:   const name = 'OZ-Governor';",
          "20:   const tokenName = 'MockToken';",
          "21:   const tokenSymbol = 'MTKN';",
          "22:   const tokenSupply = web3.utils.toWei('100');",
          "23:   const votingDelay = web3.utils.toBN(4);",
          "24:   const votingPeriod = web3.utils.toBN(16);",
          "25:   const lateQuorumVoteExtension = web3.utils.toBN(8);",
          "26:   const quorum = web3.utils.toWei('1');",
          "27:   const value = web3.utils.toWei('1');",
          "29:   for (const { mode, Token } of TOKENS) {",
          "30:     describe(`using ${Token._json.contractName}`, function () {",
          "31:       beforeEach(async function () {",
          "32:         this.owner = owner;",
          "33:         this.token = await Token.new(tokenName, tokenSymbol, tokenName);",
          "34:         this.mock = await Governor.new(",
          "35:           name,",
          "36:           votingDelay,",
          "37:           votingPeriod,",
          "38:           0,",
          "39:           this.token.address,",
          "40:           lateQuorumVoteExtension,",
          "41:           quorum,",
          "42:         );",
          "43:         this.receiver = await CallReceiver.new();",
          "45:         this.helper = new GovernorHelper(this.mock, mode);",
          "47:         await web3.eth.sendTransaction({ from: owner, to: this.mock.address, value });",
          "49:         await this.token.$_mint(owner, tokenSupply);",
          "50:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: owner });",
          "51:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: owner });",
          "52:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: owner });",
          "53:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: owner });",
          "56:         this.proposal = this.helper.setProposal(",
          "57:           [",
          "58:             {",
          "59:               target: this.receiver.address,",
          "60:               value,",
          "61:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "62:             },",
          "63:           ],",
          "64:           '<proposal description>',",
          "65:         );",
          "66:       });",
          "68:       it('deployment check', async function () {",
          "69:         expect(await this.mock.name()).to.be.equal(name);",
          "70:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "71:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "72:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "73:         expect(await this.mock.quorum(0)).to.be.bignumber.equal(quorum);",
          "74:         expect(await this.mock.lateQuorumVoteExtension()).to.be.bignumber.equal(lateQuorumVoteExtension);",
          "75:       });",
          "77:       it('nominal workflow unaffected', async function () {",
          "78:         const txPropose = await this.helper.propose({ from: proposer });",
          "79:         await this.helper.waitForSnapshot();",
          "80:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "81:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "82:         await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 });",
          "83:         await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 });",
          "84:         await this.helper.waitForDeadline();",
          "85:         await this.helper.execute();",
          "87:         expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "88:         expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(true);",
          "89:         expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(true);",
          "90:         expect(await this.mock.hasVoted(this.proposal.id, voter3)).to.be.equal(true);",
          "91:         expect(await this.mock.hasVoted(this.proposal.id, voter4)).to.be.equal(true);",
          "93:         await this.mock.proposalVotes(this.proposal.id).then(results => {",
          "94:           expect(results.forVotes).to.be.bignumber.equal(web3.utils.toWei('17'));",
          "95:           expect(results.againstVotes).to.be.bignumber.equal(web3.utils.toWei('5'));",
          "96:           expect(results.abstainVotes).to.be.bignumber.equal(web3.utils.toWei('2'));",
          "97:         });",
          "99:         const voteStart = web3.utils.toBN(await clockFromReceipt[mode](txPropose.receipt)).add(votingDelay);",
          "100:         const voteEnd = web3.utils",
          "101:           .toBN(await clockFromReceipt[mode](txPropose.receipt))",
          "102:           .add(votingDelay)",
          "103:           .add(votingPeriod);",
          "104:         expect(await this.mock.proposalSnapshot(this.proposal.id)).to.be.bignumber.equal(voteStart);",
          "105:         expect(await this.mock.proposalDeadline(this.proposal.id)).to.be.bignumber.equal(voteEnd);",
          "107:         expectEvent(txPropose, 'ProposalCreated', {",
          "108:           proposalId: this.proposal.id,",
          "109:           proposer,",
          "110:           targets: this.proposal.targets,",
          "112:           signatures: this.proposal.signatures,",
          "113:           calldatas: this.proposal.data,",
          "114:           voteStart,",
          "115:           voteEnd,",
          "116:           description: this.proposal.description,",
          "117:         });",
          "118:       });",
          "120:       it('Delay is extended to prevent last minute take-over', async function () {",
          "121:         const txPropose = await this.helper.propose({ from: proposer });",
          "124:         const startBlock = web3.utils.toBN(await clockFromReceipt[mode](txPropose.receipt)).add(votingDelay);",
          "125:         const endBlock = web3.utils",
          "126:           .toBN(await clockFromReceipt[mode](txPropose.receipt))",
          "127:           .add(votingDelay)",
          "128:           .add(votingPeriod);",
          "129:         expect(await this.mock.proposalSnapshot(this.proposal.id)).to.be.bignumber.equal(startBlock);",
          "130:         expect(await this.mock.proposalDeadline(this.proposal.id)).to.be.bignumber.equal(endBlock);",
          "133:         await this.helper.waitForDeadline(-1);",
          "134:         const txVote = await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "137:         expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Active);",
          "140:         const extendedDeadline = web3.utils",
          "141:           .toBN(await clockFromReceipt[mode](txVote.receipt))",
          "142:           .add(lateQuorumVoteExtension);",
          "143:         expect(await this.mock.proposalSnapshot(this.proposal.id)).to.be.bignumber.equal(startBlock);",
          "144:         expect(await this.mock.proposalDeadline(this.proposal.id)).to.be.bignumber.equal(extendedDeadline);",
          "147:         await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter1 });",
          "149:         await this.helper.waitForDeadline();",
          "150:         expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Active);",
          "151:         await this.helper.waitForDeadline(+1);",
          "152:         expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Defeated);",
          "155:         expectEvent(txVote, 'ProposalExtended', { proposalId: this.proposal.id, extendedDeadline });",
          "156:       });",
          "158:       describe('onlyGovernance updates', function () {",
          "159:         it('setLateQuorumVoteExtension is protected', async function () {",
          "160:           await expectRevert(this.mock.setLateQuorumVoteExtension(0), 'Governor: onlyGovernance');",
          "161:         });",
          "163:         it('can setLateQuorumVoteExtension through governance', async function () {",
          "164:           this.helper.setProposal(",
          "165:             [",
          "166:               {",
          "167:                 target: this.mock.address,",
          "168:                 data: this.mock.contract.methods.setLateQuorumVoteExtension('0').encodeABI(),",
          "169:               },",
          "170:             ],",
          "171:             '<proposal description>',",
          "172:           );",
          "174:           await this.helper.propose();",
          "175:           await this.helper.waitForSnapshot();",
          "176:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "177:           await this.helper.waitForDeadline();",
          "179:           expectEvent(await this.helper.execute(), 'LateQuorumVoteExtensionSet', {",
          "180:             oldVoteExtension: lateQuorumVoteExtension,",
          "181:             newVoteExtension: '0',",
          "182:           });",
          "184:           expect(await this.mock.lateQuorumVoteExtension()).to.be.bignumber.equal('0');",
          "185:         });",
          "186:       });",
          "187:     });",
          "188:   }",
          "189: });",
          "",
          "---------------"
        ],
        "test/governance/extensions/GovernorTimelockCompound.test.js||test/governance/extensions/GovernorTimelockCompound.test.js": [
          "File: test/governance/extensions/GovernorTimelockCompound.test.js -> test/governance/extensions/GovernorTimelockCompound.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const RLP = require('rlp');",
          "4: const Enums = require('../../helpers/enums');",
          "5: const { GovernorHelper } = require('../../helpers/governance');",
          "7: const { shouldSupportInterfaces } = require('../../utils/introspection/SupportsInterface.behavior');",
          "9: const Timelock = artifacts.require('CompTimelock');",
          "10: const Governor = artifacts.require('$GovernorTimelockCompoundMock');",
          "11: const CallReceiver = artifacts.require('CallReceiverMock');",
          "13: function makeContractAddress(creator, nonce) {",
          "14:   return web3.utils.toChecksumAddress(",
          "15:     web3.utils",
          "16:       .sha3(RLP.encode([creator, nonce]))",
          "17:       .slice(12)",
          "18:       .substring(14),",
          "19:   );",
          "20: }",
          "22: const TOKENS = [",
          "23:   { Token: artifacts.require('$ERC20Votes'), mode: 'blocknumber' },",
          "24:   { Token: artifacts.require('$ERC20VotesTimestampMock'), mode: 'timestamp' },",
          "25: ];",
          "27: contract('GovernorTimelockCompound', function (accounts) {",
          "28:   const [owner, voter1, voter2, voter3, voter4, other] = accounts;",
          "30:   const name = 'OZ-Governor';",
          "32:   const tokenName = 'MockToken';",
          "33:   const tokenSymbol = 'MTKN';",
          "34:   const tokenSupply = web3.utils.toWei('100');",
          "35:   const votingDelay = web3.utils.toBN(4);",
          "36:   const votingPeriod = web3.utils.toBN(16);",
          "37:   const value = web3.utils.toWei('1');",
          "39:   for (const { mode, Token } of TOKENS) {",
          "40:     describe(`using ${Token._json.contractName}`, function () {",
          "41:       beforeEach(async function () {",
          "42:         const [deployer] = await web3.eth.getAccounts();",
          "44:         this.token = await Token.new(tokenName, tokenSymbol, tokenName);",
          "47:         const nonce = await web3.eth.getTransactionCount(deployer);",
          "48:         const predictGovernor = makeContractAddress(deployer, nonce + 1);",
          "50:         this.timelock = await Timelock.new(predictGovernor, 2 * 86400);",
          "51:         this.mock = await Governor.new(",
          "52:           name,",
          "53:           votingDelay,",
          "54:           votingPeriod,",
          "55:           0,",
          "56:           this.timelock.address,",
          "57:           this.token.address,",
          "58:           0,",
          "59:         );",
          "60:         this.receiver = await CallReceiver.new();",
          "62:         this.helper = new GovernorHelper(this.mock, mode);",
          "64:         await web3.eth.sendTransaction({ from: owner, to: this.timelock.address, value });",
          "66:         await this.token.$_mint(owner, tokenSupply);",
          "67:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: owner });",
          "68:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: owner });",
          "69:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: owner });",
          "70:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: owner });",
          "73:         this.proposal = this.helper.setProposal(",
          "74:           [",
          "75:             {",
          "76:               target: this.receiver.address,",
          "77:               value,",
          "78:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "79:             },",
          "80:           ],",
          "81:           '<proposal description>',",
          "82:         );",
          "83:       });",
          "85:       shouldSupportInterfaces(['ERC165', 'Governor', 'GovernorWithParams', 'GovernorTimelock']);",
          "87:       it(\"doesn't accept ether transfers\", async function () {",
          "88:         await expectRevert.unspecified(web3.eth.sendTransaction({ from: owner, to: this.mock.address, value: 1 }));",
          "89:       });",
          "91:       it('post deployment check', async function () {",
          "92:         expect(await this.mock.name()).to.be.equal(name);",
          "93:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "94:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "95:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "96:         expect(await this.mock.quorum(0)).to.be.bignumber.equal('0');",
          "98:         expect(await this.mock.timelock()).to.be.equal(this.timelock.address);",
          "99:         expect(await this.timelock.admin()).to.be.equal(this.mock.address);",
          "100:       });",
          "102:       it('nominal', async function () {",
          "103:         await this.helper.propose();",
          "104:         await this.helper.waitForSnapshot();",
          "105:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "106:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "107:         await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 });",
          "108:         await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 });",
          "109:         await this.helper.waitForDeadline();",
          "110:         const txQueue = await this.helper.queue();",
          "111:         const eta = await this.mock.proposalEta(this.proposal.id);",
          "112:         await this.helper.waitForEta();",
          "113:         const txExecute = await this.helper.execute();",
          "115:         expectEvent(txQueue, 'ProposalQueued', { proposalId: this.proposal.id });",
          "116:         await expectEvent.inTransaction(txQueue.tx, this.timelock, 'QueueTransaction', { eta });",
          "118:         expectEvent(txExecute, 'ProposalExecuted', { proposalId: this.proposal.id });",
          "119:         await expectEvent.inTransaction(txExecute.tx, this.timelock, 'ExecuteTransaction', { eta });",
          "120:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'MockFunctionCalled');",
          "121:       });",
          "123:       describe('should revert', function () {",
          "124:         describe('on queue', function () {",
          "125:           it('if already queued', async function () {",
          "126:             await this.helper.propose();",
          "127:             await this.helper.waitForSnapshot();",
          "128:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "129:             await this.helper.waitForDeadline();",
          "130:             await this.helper.queue();",
          "131:             await expectRevert(this.helper.queue(), 'Governor: proposal not successful');",
          "132:           });",
          "134:           it('if proposal contains duplicate calls', async function () {",
          "135:             const action = {",
          "136:               target: this.token.address,",
          "137:               data: this.token.contract.methods.approve(this.receiver.address, constants.MAX_UINT256).encodeABI(),",
          "138:             };",
          "139:             this.helper.setProposal([action, action], '<proposal description>');",
          "141:             await this.helper.propose();",
          "142:             await this.helper.waitForSnapshot();",
          "143:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "144:             await this.helper.waitForDeadline();",
          "145:             await expectRevert(",
          "146:               this.helper.queue(),",
          "147:               'GovernorTimelockCompound: identical proposal action already queued',",
          "148:             );",
          "149:             await expectRevert(this.helper.execute(), 'GovernorTimelockCompound: proposal not yet queued');",
          "150:           });",
          "151:         });",
          "153:         describe('on execute', function () {",
          "154:           it('if not queued', async function () {",
          "155:             await this.helper.propose();",
          "156:             await this.helper.waitForSnapshot();",
          "157:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "158:             await this.helper.waitForDeadline(+1);",
          "160:             expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Succeeded);",
          "162:             await expectRevert(this.helper.execute(), 'GovernorTimelockCompound: proposal not yet queued');",
          "163:           });",
          "165:           it('if too early', async function () {",
          "166:             await this.helper.propose();",
          "167:             await this.helper.waitForSnapshot();",
          "168:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "169:             await this.helper.waitForDeadline();",
          "170:             await this.helper.queue();",
          "172:             expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Queued);",
          "174:             await expectRevert(",
          "175:               this.helper.execute(),",
          "176:               \"Timelock::executeTransaction: Transaction hasn't surpassed time lock\",",
          "177:             );",
          "178:           });",
          "180:           it('if too late', async function () {",
          "181:             await this.helper.propose();",
          "182:             await this.helper.waitForSnapshot();",
          "183:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "184:             await this.helper.waitForDeadline();",
          "185:             await this.helper.queue();",
          "186:             await this.helper.waitForEta(+30 * 86400);",
          "188:             expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Expired);",
          "190:             await expectRevert(this.helper.execute(), 'Governor: proposal not successful');",
          "191:           });",
          "193:           it('if already executed', async function () {",
          "194:             await this.helper.propose();",
          "195:             await this.helper.waitForSnapshot();",
          "196:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "197:             await this.helper.waitForDeadline();",
          "198:             await this.helper.queue();",
          "199:             await this.helper.waitForEta();",
          "200:             await this.helper.execute();",
          "201:             await expectRevert(this.helper.execute(), 'Governor: proposal not successful');",
          "202:           });",
          "203:         });",
          "204:       });",
          "206:       describe('cancel', function () {",
          "207:         it('cancel before queue prevents scheduling', async function () {",
          "208:           await this.helper.propose();",
          "209:           await this.helper.waitForSnapshot();",
          "210:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "211:           await this.helper.waitForDeadline();",
          "213:           expectEvent(await this.helper.cancel('internal'), 'ProposalCanceled', { proposalId: this.proposal.id });",
          "215:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "216:           await expectRevert(this.helper.queue(), 'Governor: proposal not successful');",
          "217:         });",
          "219:         it('cancel after queue prevents executing', async function () {",
          "220:           await this.helper.propose();",
          "221:           await this.helper.waitForSnapshot();",
          "222:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "223:           await this.helper.waitForDeadline();",
          "224:           await this.helper.queue();",
          "226:           expectEvent(await this.helper.cancel('internal'), 'ProposalCanceled', { proposalId: this.proposal.id });",
          "228:           expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "229:           await expectRevert(this.helper.execute(), 'Governor: proposal not successful');",
          "230:         });",
          "231:       });",
          "233:       describe('onlyGovernance', function () {",
          "234:         describe('relay', function () {",
          "235:           beforeEach(async function () {",
          "236:             await this.token.$_mint(this.mock.address, 1);",
          "237:           });",
          "239:           it('is protected', async function () {",
          "240:             await expectRevert(",
          "241:               this.mock.relay(this.token.address, 0, this.token.contract.methods.transfer(other, 1).encodeABI()),",
          "242:               'Governor: onlyGovernance',",
          "243:             );",
          "244:           });",
          "246:           it('can be executed through governance', async function () {",
          "247:             this.helper.setProposal(",
          "248:               [",
          "249:                 {",
          "250:                   target: this.mock.address,",
          "251:                   data: this.mock.contract.methods",
          "252:                     .relay(this.token.address, 0, this.token.contract.methods.transfer(other, 1).encodeABI())",
          "253:                     .encodeABI(),",
          "254:                 },",
          "255:               ],",
          "256:               '<proposal description>',",
          "257:             );",
          "259:             expect(await this.token.balanceOf(this.mock.address), 1);",
          "260:             expect(await this.token.balanceOf(other), 0);",
          "262:             await this.helper.propose();",
          "263:             await this.helper.waitForSnapshot();",
          "264:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "265:             await this.helper.waitForDeadline();",
          "266:             await this.helper.queue();",
          "267:             await this.helper.waitForEta();",
          "268:             const txExecute = await this.helper.execute();",
          "270:             expect(await this.token.balanceOf(this.mock.address), 0);",
          "271:             expect(await this.token.balanceOf(other), 1);",
          "273:             await expectEvent.inTransaction(txExecute.tx, this.token, 'Transfer', {",
          "274:               from: this.mock.address,",
          "275:               to: other,",
          "276:               value: '1',",
          "277:             });",
          "278:           });",
          "279:         });",
          "281:         describe('updateTimelock', function () {",
          "282:           beforeEach(async function () {",
          "283:             this.newTimelock = await Timelock.new(this.mock.address, 7 * 86400);",
          "284:           });",
          "286:           it('is protected', async function () {",
          "287:             await expectRevert(this.mock.updateTimelock(this.newTimelock.address), 'Governor: onlyGovernance');",
          "288:           });",
          "290:           it('can be executed through governance to', async function () {",
          "291:             this.helper.setProposal(",
          "292:               [",
          "293:                 {",
          "294:                   target: this.timelock.address,",
          "295:                   data: this.timelock.contract.methods.setPendingAdmin(owner).encodeABI(),",
          "296:                 },",
          "297:                 {",
          "298:                   target: this.mock.address,",
          "299:                   data: this.mock.contract.methods.updateTimelock(this.newTimelock.address).encodeABI(),",
          "300:                 },",
          "301:               ],",
          "302:               '<proposal description>',",
          "303:             );",
          "305:             await this.helper.propose();",
          "306:             await this.helper.waitForSnapshot();",
          "307:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "308:             await this.helper.waitForDeadline();",
          "309:             await this.helper.queue();",
          "310:             await this.helper.waitForEta();",
          "311:             const txExecute = await this.helper.execute();",
          "313:             expectEvent(txExecute, 'TimelockChange', {",
          "314:               oldTimelock: this.timelock.address,",
          "315:               newTimelock: this.newTimelock.address,",
          "316:             });",
          "318:             expect(await this.mock.timelock()).to.be.bignumber.equal(this.newTimelock.address);",
          "319:           });",
          "320:         });",
          "322:         it('can transfer timelock to new governor', async function () {",
          "323:           const newGovernor = await Governor.new(name, 8, 32, 0, this.timelock.address, this.token.address, 0);",
          "324:           this.helper.setProposal(",
          "325:             [",
          "326:               {",
          "327:                 target: this.timelock.address,",
          "328:                 data: this.timelock.contract.methods.setPendingAdmin(newGovernor.address).encodeABI(),",
          "329:               },",
          "330:             ],",
          "331:             '<proposal description>',",
          "332:           );",
          "334:           await this.helper.propose();",
          "335:           await this.helper.waitForSnapshot();",
          "336:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "337:           await this.helper.waitForDeadline();",
          "338:           await this.helper.queue();",
          "339:           await this.helper.waitForEta();",
          "340:           const txExecute = await this.helper.execute();",
          "342:           await expectEvent.inTransaction(txExecute.tx, this.timelock, 'NewPendingAdmin', {",
          "343:             newPendingAdmin: newGovernor.address,",
          "344:           });",
          "346:           await newGovernor.__acceptAdmin();",
          "347:           expect(await this.timelock.admin()).to.be.bignumber.equal(newGovernor.address);",
          "348:         });",
          "349:       });",
          "350:     });",
          "351:   }",
          "352: });",
          "",
          "---------------"
        ],
        "test/governance/extensions/GovernorTimelockControl.test.js||test/governance/extensions/GovernorTimelockControl.test.js": [
          "File: test/governance/extensions/GovernorTimelockControl.test.js -> test/governance/extensions/GovernorTimelockControl.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { constants, expectEvent, expectRevert, time } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const Enums = require('../../helpers/enums');",
          "4: const { GovernorHelper } = require('../../helpers/governance');",
          "6: const { shouldSupportInterfaces } = require('../../utils/introspection/SupportsInterface.behavior');",
          "8: const Timelock = artifacts.require('TimelockController');",
          "9: const Governor = artifacts.require('$GovernorTimelockControlMock');",
          "10: const CallReceiver = artifacts.require('CallReceiverMock');",
          "12: const TOKENS = [",
          "13:   { Token: artifacts.require('$ERC20Votes'), mode: 'blocknumber' },",
          "14:   { Token: artifacts.require('$ERC20VotesTimestampMock'), mode: 'timestamp' },",
          "15: ];",
          "17: contract('GovernorTimelockControl', function (accounts) {",
          "18:   const [owner, voter1, voter2, voter3, voter4, other] = accounts;",
          "20:   const TIMELOCK_ADMIN_ROLE = web3.utils.soliditySha3('TIMELOCK_ADMIN_ROLE');",
          "21:   const PROPOSER_ROLE = web3.utils.soliditySha3('PROPOSER_ROLE');",
          "22:   const EXECUTOR_ROLE = web3.utils.soliditySha3('EXECUTOR_ROLE');",
          "23:   const CANCELLER_ROLE = web3.utils.soliditySha3('CANCELLER_ROLE');",
          "25:   const name = 'OZ-Governor';",
          "27:   const tokenName = 'MockToken';",
          "28:   const tokenSymbol = 'MTKN';",
          "29:   const tokenSupply = web3.utils.toWei('100');",
          "30:   const votingDelay = web3.utils.toBN(4);",
          "31:   const votingPeriod = web3.utils.toBN(16);",
          "32:   const value = web3.utils.toWei('1');",
          "34:   for (const { mode, Token } of TOKENS) {",
          "35:     describe(`using ${Token._json.contractName}`, function () {",
          "36:       beforeEach(async function () {",
          "37:         const [deployer] = await web3.eth.getAccounts();",
          "39:         this.token = await Token.new(tokenName, tokenSymbol, tokenName);",
          "40:         this.timelock = await Timelock.new(3600, [], [], deployer);",
          "41:         this.mock = await Governor.new(",
          "42:           name,",
          "43:           votingDelay,",
          "44:           votingPeriod,",
          "45:           0,",
          "46:           this.timelock.address,",
          "47:           this.token.address,",
          "48:           0,",
          "49:         );",
          "50:         this.receiver = await CallReceiver.new();",
          "52:         this.helper = new GovernorHelper(this.mock, mode);",
          "54:         this.TIMELOCK_ADMIN_ROLE = await this.timelock.TIMELOCK_ADMIN_ROLE();",
          "55:         this.PROPOSER_ROLE = await this.timelock.PROPOSER_ROLE();",
          "56:         this.EXECUTOR_ROLE = await this.timelock.EXECUTOR_ROLE();",
          "57:         this.CANCELLER_ROLE = await this.timelock.CANCELLER_ROLE();",
          "59:         await web3.eth.sendTransaction({ from: owner, to: this.timelock.address, value });",
          "62:         await this.timelock.grantRole(PROPOSER_ROLE, this.mock.address);",
          "63:         await this.timelock.grantRole(PROPOSER_ROLE, owner);",
          "64:         await this.timelock.grantRole(CANCELLER_ROLE, this.mock.address);",
          "65:         await this.timelock.grantRole(CANCELLER_ROLE, owner);",
          "66:         await this.timelock.grantRole(EXECUTOR_ROLE, constants.ZERO_ADDRESS);",
          "67:         await this.timelock.revokeRole(TIMELOCK_ADMIN_ROLE, deployer);",
          "69:         await this.token.$_mint(owner, tokenSupply);",
          "70:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: owner });",
          "71:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: owner });",
          "72:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: owner });",
          "73:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: owner });",
          "76:         this.proposal = this.helper.setProposal(",
          "77:           [",
          "78:             {",
          "79:               target: this.receiver.address,",
          "80:               value,",
          "81:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "82:             },",
          "83:           ],",
          "84:           '<proposal description>',",
          "85:         );",
          "86:         this.proposal.timelockid = await this.timelock.hashOperationBatch(",
          "87:           ...this.proposal.shortProposal.slice(0, 3),",
          "88:           '0x0',",
          "89:           this.proposal.shortProposal[3],",
          "90:         );",
          "91:       });",
          "93:       shouldSupportInterfaces(['ERC165', 'Governor', 'GovernorWithParams', 'GovernorTimelock']);",
          "95:       it(\"doesn't accept ether transfers\", async function () {",
          "96:         await expectRevert.unspecified(web3.eth.sendTransaction({ from: owner, to: this.mock.address, value: 1 }));",
          "97:       });",
          "99:       it('post deployment check', async function () {",
          "100:         expect(await this.mock.name()).to.be.equal(name);",
          "101:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "102:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "103:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "104:         expect(await this.mock.quorum(0)).to.be.bignumber.equal('0');",
          "106:         expect(await this.mock.timelock()).to.be.equal(this.timelock.address);",
          "107:       });",
          "109:       it('nominal', async function () {",
          "110:         await this.helper.propose();",
          "111:         await this.helper.waitForSnapshot();",
          "112:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "113:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "114:         await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 });",
          "115:         await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 });",
          "116:         await this.helper.waitForDeadline();",
          "117:         const txQueue = await this.helper.queue();",
          "118:         await this.helper.waitForEta();",
          "119:         const txExecute = await this.helper.execute();",
          "121:         expectEvent(txQueue, 'ProposalQueued', { proposalId: this.proposal.id });",
          "122:         await expectEvent.inTransaction(txQueue.tx, this.timelock, 'CallScheduled', { id: this.proposal.timelockid });",
          "123:         await expectEvent.inTransaction(txQueue.tx, this.timelock, 'CallSalt', {",
          "124:           id: this.proposal.timelockid,",
          "125:         });",
          "127:         expectEvent(txExecute, 'ProposalExecuted', { proposalId: this.proposal.id });",
          "128:         await expectEvent.inTransaction(txExecute.tx, this.timelock, 'CallExecuted', { id: this.proposal.timelockid });",
          "129:         await expectEvent.inTransaction(txExecute.tx, this.receiver, 'MockFunctionCalled');",
          "130:       });",
          "132:       describe('should revert', function () {",
          "133:         describe('on queue', function () {",
          "134:           it('if already queued', async function () {",
          "135:             await this.helper.propose();",
          "136:             await this.helper.waitForSnapshot();",
          "137:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "138:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "139:             await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 });",
          "140:             await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 });",
          "141:             await this.helper.waitForDeadline();",
          "142:             const txQueue = await this.helper.queue();",
          "143:             await this.helper.waitForEta();",
          "144:             const txExecute = await this.helper.execute();",
          "146:             expectEvent(txQueue, 'ProposalQueued', { proposalId: this.proposal.id });",
          "147:             await expectEvent.inTransaction(txQueue.tx, this.timelock, 'CallScheduled', {",
          "148:               id: this.proposal.timelockid,",
          "149:             });",
          "151:             expectEvent(txExecute, 'ProposalExecuted', { proposalId: this.proposal.id });",
          "152:             await expectEvent.inTransaction(txExecute.tx, this.timelock, 'CallExecuted', {",
          "153:               id: this.proposal.timelockid,",
          "154:             });",
          "155:             await expectEvent.inTransaction(txExecute.tx, this.receiver, 'MockFunctionCalled');",
          "156:           });",
          "158:           describe('should revert', function () {",
          "159:             describe('on queue', function () {",
          "160:               it('if already queued', async function () {",
          "161:                 await this.helper.propose();",
          "162:                 await this.helper.waitForSnapshot();",
          "163:                 await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "164:                 await this.helper.waitForDeadline();",
          "165:                 await this.helper.queue();",
          "166:                 await expectRevert(this.helper.queue(), 'Governor: proposal not successful');",
          "167:               });",
          "168:             });",
          "170:             describe('on execute', function () {",
          "171:               it('if not queued', async function () {",
          "172:                 await this.helper.propose();",
          "173:                 await this.helper.waitForSnapshot();",
          "174:                 await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "175:                 await this.helper.waitForDeadline(+1);",
          "177:                 expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Succeeded);",
          "179:                 await expectRevert(this.helper.execute(), 'TimelockController: operation is not ready');",
          "180:               });",
          "182:               it('if too early', async function () {",
          "183:                 await this.helper.propose();",
          "184:                 await this.helper.waitForSnapshot();",
          "185:                 await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "186:                 await this.helper.waitForDeadline();",
          "187:                 await this.helper.queue();",
          "189:                 expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Queued);",
          "191:                 await expectRevert(this.helper.execute(), 'TimelockController: operation is not ready');",
          "192:               });",
          "194:               it('if already executed', async function () {",
          "195:                 await this.helper.propose();",
          "196:                 await this.helper.waitForSnapshot();",
          "197:                 await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "198:                 await this.helper.waitForDeadline();",
          "199:                 await this.helper.queue();",
          "200:                 await this.helper.waitForEta();",
          "201:                 await this.helper.execute();",
          "202:                 await expectRevert(this.helper.execute(), 'Governor: proposal not successful');",
          "203:               });",
          "205:               it('if already executed by another proposer', async function () {",
          "206:                 await this.helper.propose();",
          "207:                 await this.helper.waitForSnapshot();",
          "208:                 await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "209:                 await this.helper.waitForDeadline();",
          "210:                 await this.helper.queue();",
          "211:                 await this.helper.waitForEta();",
          "213:                 await this.timelock.executeBatch(",
          "214:                   ...this.proposal.shortProposal.slice(0, 3),",
          "215:                   '0x0',",
          "216:                   this.proposal.shortProposal[3],",
          "217:                 );",
          "219:                 await expectRevert(this.helper.execute(), 'Governor: proposal not successful');",
          "220:               });",
          "221:             });",
          "222:           });",
          "224:           describe('cancel', function () {",
          "225:             it('cancel before queue prevents scheduling', async function () {",
          "226:               await this.helper.propose();",
          "227:               await this.helper.waitForSnapshot();",
          "228:               await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "229:               await this.helper.waitForDeadline();",
          "231:               expectEvent(await this.helper.cancel('internal'), 'ProposalCanceled', { proposalId: this.proposal.id });",
          "233:               expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "234:               await expectRevert(this.helper.queue(), 'Governor: proposal not successful');",
          "235:             });",
          "237:             it('cancel after queue prevents executing', async function () {",
          "238:               await this.helper.propose();",
          "239:               await this.helper.waitForSnapshot();",
          "240:               await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "241:               await this.helper.waitForDeadline();",
          "242:               await this.helper.queue();",
          "244:               expectEvent(await this.helper.cancel('internal'), 'ProposalCanceled', { proposalId: this.proposal.id });",
          "246:               expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "247:               await expectRevert(this.helper.execute(), 'Governor: proposal not successful');",
          "248:             });",
          "250:             it('cancel on timelock is reflected on governor', async function () {",
          "251:               await this.helper.propose();",
          "252:               await this.helper.waitForSnapshot();",
          "253:               await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "254:               await this.helper.waitForDeadline();",
          "255:               await this.helper.queue();",
          "257:               expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Queued);",
          "259:               expectEvent(await this.timelock.cancel(this.proposal.timelockid, { from: owner }), 'Cancelled', {",
          "260:                 id: this.proposal.timelockid,",
          "261:               });",
          "263:               expect(await this.mock.state(this.proposal.id)).to.be.bignumber.equal(Enums.ProposalState.Canceled);",
          "264:             });",
          "265:           });",
          "267:           describe('onlyGovernance', function () {",
          "268:             describe('relay', function () {",
          "269:               beforeEach(async function () {",
          "270:                 await this.token.$_mint(this.mock.address, 1);",
          "271:               });",
          "273:               it('is protected', async function () {",
          "274:                 await expectRevert(",
          "275:                   this.mock.relay(this.token.address, 0, this.token.contract.methods.transfer(other, 1).encodeABI()),",
          "276:                   'Governor: onlyGovernance',",
          "277:                 );",
          "278:               });",
          "280:               it('can be executed through governance', async function () {",
          "281:                 this.helper.setProposal(",
          "282:                   [",
          "283:                     {",
          "284:                       target: this.mock.address,",
          "285:                       data: this.mock.contract.methods",
          "286:                         .relay(this.token.address, 0, this.token.contract.methods.transfer(other, 1).encodeABI())",
          "287:                         .encodeABI(),",
          "288:                     },",
          "289:                   ],",
          "290:                   '<proposal description>',",
          "291:                 );",
          "293:                 expect(await this.token.balanceOf(this.mock.address), 1);",
          "294:                 expect(await this.token.balanceOf(other), 0);",
          "296:                 await this.helper.propose();",
          "297:                 await this.helper.waitForSnapshot();",
          "298:                 await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "299:                 await this.helper.waitForDeadline();",
          "300:                 await this.helper.queue();",
          "301:                 await this.helper.waitForEta();",
          "302:                 const txExecute = await this.helper.execute();",
          "304:                 expect(await this.token.balanceOf(this.mock.address), 0);",
          "305:                 expect(await this.token.balanceOf(other), 1);",
          "307:                 await expectEvent.inTransaction(txExecute.tx, this.token, 'Transfer', {",
          "308:                   from: this.mock.address,",
          "309:                   to: other,",
          "310:                   value: '1',",
          "311:                 });",
          "312:               });",
          "314:               it('is payable and can transfer eth to EOA', async function () {",
          "315:                 const t2g = web3.utils.toBN(128); // timelock to governor",
          "316:                 const g2o = web3.utils.toBN(100); // governor to eoa (other)",
          "318:                 this.helper.setProposal(",
          "319:                   [",
          "320:                     {",
          "321:                       target: this.mock.address,",
          "322:                       value: t2g,",
          "323:                       data: this.mock.contract.methods.relay(other, g2o, '0x').encodeABI(),",
          "324:                     },",
          "325:                   ],",
          "326:                   '<proposal description>',",
          "327:                 );",
          "329:                 expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "330:                 const timelockBalance = await web3.eth.getBalance(this.timelock.address).then(web3.utils.toBN);",
          "331:                 const otherBalance = await web3.eth.getBalance(other).then(web3.utils.toBN);",
          "333:                 await this.helper.propose();",
          "334:                 await this.helper.waitForSnapshot();",
          "335:                 await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "336:                 await this.helper.waitForDeadline();",
          "337:                 await this.helper.queue();",
          "338:                 await this.helper.waitForEta();",
          "339:                 await this.helper.execute();",
          "341:                 expect(await web3.eth.getBalance(this.timelock.address)).to.be.bignumber.equal(",
          "342:                   timelockBalance.sub(t2g),",
          "343:                 );",
          "344:                 expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal(t2g.sub(g2o));",
          "345:                 expect(await web3.eth.getBalance(other)).to.be.bignumber.equal(otherBalance.add(g2o));",
          "346:               });",
          "348:               it('protected against other proposers', async function () {",
          "349:                 await this.timelock.schedule(",
          "350:                   this.mock.address,",
          "351:                   web3.utils.toWei('0'),",
          "352:                   this.mock.contract.methods.relay(constants.ZERO_ADDRESS, 0, '0x').encodeABI(),",
          "353:                   constants.ZERO_BYTES32,",
          "354:                   constants.ZERO_BYTES32,",
          "355:                   3600,",
          "356:                   { from: owner },",
          "357:                 );",
          "359:                 await time.increase(3600);",
          "361:                 await expectRevert(",
          "362:                   this.timelock.execute(",
          "363:                     this.mock.address,",
          "364:                     web3.utils.toWei('0'),",
          "365:                     this.mock.contract.methods.relay(constants.ZERO_ADDRESS, 0, '0x').encodeABI(),",
          "366:                     constants.ZERO_BYTES32,",
          "367:                     constants.ZERO_BYTES32,",
          "368:                     { from: owner },",
          "369:                   ),",
          "370:                   'TimelockController: underlying transaction reverted',",
          "371:                 );",
          "372:               });",
          "373:             });",
          "375:             describe('updateTimelock', function () {",
          "376:               beforeEach(async function () {",
          "377:                 this.newTimelock = await Timelock.new(",
          "378:                   3600,",
          "379:                   [this.mock.address],",
          "380:                   [this.mock.address],",
          "381:                   constants.ZERO_ADDRESS,",
          "382:                 );",
          "383:               });",
          "385:               it('is protected', async function () {",
          "386:                 await expectRevert(this.mock.updateTimelock(this.newTimelock.address), 'Governor: onlyGovernance');",
          "387:               });",
          "389:               it('can be executed through governance to', async function () {",
          "390:                 this.helper.setProposal(",
          "391:                   [",
          "392:                     {",
          "393:                       target: this.mock.address,",
          "394:                       data: this.mock.contract.methods.updateTimelock(this.newTimelock.address).encodeABI(),",
          "395:                     },",
          "396:                   ],",
          "397:                   '<proposal description>',",
          "398:                 );",
          "400:                 await this.helper.propose();",
          "401:                 await this.helper.waitForSnapshot();",
          "402:                 await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "403:                 await this.helper.waitForDeadline();",
          "404:                 await this.helper.queue();",
          "405:                 await this.helper.waitForEta();",
          "406:                 const txExecute = await this.helper.execute();",
          "408:                 expectEvent(txExecute, 'TimelockChange', {",
          "409:                   oldTimelock: this.timelock.address,",
          "410:                   newTimelock: this.newTimelock.address,",
          "411:                 });",
          "413:                 expect(await this.mock.timelock()).to.be.bignumber.equal(this.newTimelock.address);",
          "414:               });",
          "415:             });",
          "416:           });",
          "418:           it('clear queue of pending governor calls', async function () {",
          "419:             this.helper.setProposal(",
          "420:               [",
          "421:                 {",
          "422:                   target: this.mock.address,",
          "423:                   data: this.mock.contract.methods.nonGovernanceFunction().encodeABI(),",
          "424:                 },",
          "425:               ],",
          "426:               '<proposal description>',",
          "427:             );",
          "429:             await this.helper.propose();",
          "430:             await this.helper.waitForSnapshot();",
          "431:             await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "432:             await this.helper.waitForDeadline();",
          "433:             await this.helper.queue();",
          "434:             await this.helper.waitForEta();",
          "435:             await this.helper.execute();",
          "440:           });",
          "441:         });",
          "442:       });",
          "443:     });",
          "444:   }",
          "445: });",
          "",
          "---------------"
        ],
        "test/governance/extensions/GovernorVotesQuorumFraction.test.js||test/governance/extensions/GovernorVotesQuorumFraction.test.js": [
          "File: test/governance/extensions/GovernorVotesQuorumFraction.test.js -> test/governance/extensions/GovernorVotesQuorumFraction.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectEvent, expectRevert, time } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const Enums = require('../../helpers/enums');",
          "4: const { GovernorHelper } = require('../../helpers/governance');",
          "5: const { clock } = require('../../helpers/time');",
          "7: const Governor = artifacts.require('$GovernorMock');",
          "8: const CallReceiver = artifacts.require('CallReceiverMock');",
          "10: const TOKENS = [",
          "11:   { Token: artifacts.require('$ERC20Votes'), mode: 'blocknumber' },",
          "12:   { Token: artifacts.require('$ERC20VotesTimestampMock'), mode: 'timestamp' },",
          "13: ];",
          "15: contract('GovernorVotesQuorumFraction', function (accounts) {",
          "16:   const [owner, voter1, voter2, voter3, voter4] = accounts;",
          "18:   const name = 'OZ-Governor';",
          "20:   const tokenName = 'MockToken';",
          "21:   const tokenSymbol = 'MTKN';",
          "22:   const tokenSupply = web3.utils.toBN(web3.utils.toWei('100'));",
          "23:   const ratio = web3.utils.toBN(8); // percents",
          "24:   const newRatio = web3.utils.toBN(6); // percents",
          "25:   const votingDelay = web3.utils.toBN(4);",
          "26:   const votingPeriod = web3.utils.toBN(16);",
          "27:   const value = web3.utils.toWei('1');",
          "29:   for (const { mode, Token } of TOKENS) {",
          "30:     describe(`using ${Token._json.contractName}`, function () {",
          "31:       beforeEach(async function () {",
          "32:         this.owner = owner;",
          "33:         this.token = await Token.new(tokenName, tokenSymbol, tokenName);",
          "34:         this.mock = await Governor.new(name, votingDelay, votingPeriod, 0, this.token.address, ratio);",
          "35:         this.receiver = await CallReceiver.new();",
          "37:         this.helper = new GovernorHelper(this.mock, mode);",
          "39:         await web3.eth.sendTransaction({ from: owner, to: this.mock.address, value });",
          "41:         await this.token.$_mint(owner, tokenSupply);",
          "42:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: owner });",
          "43:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: owner });",
          "44:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: owner });",
          "45:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: owner });",
          "48:         this.proposal = this.helper.setProposal(",
          "49:           [",
          "50:             {",
          "51:               target: this.receiver.address,",
          "52:               value,",
          "53:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "54:             },",
          "55:           ],",
          "56:           '<proposal description>',",
          "57:         );",
          "58:       });",
          "60:       it('deployment check', async function () {",
          "61:         expect(await this.mock.name()).to.be.equal(name);",
          "62:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "63:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "64:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "65:         expect(await this.mock.quorum(0)).to.be.bignumber.equal('0');",
          "66:         expect(await this.mock.quorumNumerator()).to.be.bignumber.equal(ratio);",
          "67:         expect(await this.mock.quorumDenominator()).to.be.bignumber.equal('100');",
          "68:         expect(await clock[mode]().then(timepoint => this.mock.quorum(timepoint - 1))).to.be.bignumber.equal(",
          "69:           tokenSupply.mul(ratio).divn(100),",
          "70:         );",
          "71:       });",
          "73:       it('quroum reached', async function () {",
          "74:         await this.helper.propose();",
          "75:         await this.helper.waitForSnapshot();",
          "76:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "77:         await this.helper.waitForDeadline();",
          "78:         await this.helper.execute();",
          "79:       });",
          "81:       it('quroum not reached', async function () {",
          "82:         await this.helper.propose();",
          "83:         await this.helper.waitForSnapshot();",
          "84:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "85:         await this.helper.waitForDeadline();",
          "86:         await expectRevert(this.helper.execute(), 'Governor: proposal not successful');",
          "87:       });",
          "89:       describe('onlyGovernance updates', function () {",
          "90:         it('updateQuorumNumerator is protected', async function () {",
          "91:           await expectRevert(this.mock.updateQuorumNumerator(newRatio), 'Governor: onlyGovernance');",
          "92:         });",
          "94:         it('can updateQuorumNumerator through governance', async function () {",
          "95:           this.helper.setProposal(",
          "96:             [",
          "97:               {",
          "98:                 target: this.mock.address,",
          "99:                 data: this.mock.contract.methods.updateQuorumNumerator(newRatio).encodeABI(),",
          "100:               },",
          "101:             ],",
          "102:             '<proposal description>',",
          "103:           );",
          "105:           await this.helper.propose();",
          "106:           await this.helper.waitForSnapshot();",
          "107:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "108:           await this.helper.waitForDeadline();",
          "110:           expectEvent(await this.helper.execute(), 'QuorumNumeratorUpdated', {",
          "111:             oldQuorumNumerator: ratio,",
          "112:             newQuorumNumerator: newRatio,",
          "113:           });",
          "115:           expect(await this.mock.quorumNumerator()).to.be.bignumber.equal(newRatio);",
          "116:           expect(await this.mock.quorumDenominator()).to.be.bignumber.equal('100');",
          "119:           expect(await clock[mode]().then(blockNumber => this.mock.quorum(blockNumber - 1))).to.be.bignumber.equal(",
          "120:             tokenSupply.mul(ratio).divn(100),",
          "121:           );",
          "123:           await time.advanceBlock();",
          "125:           expect(await clock[mode]().then(blockNumber => this.mock.quorum(blockNumber - 1))).to.be.bignumber.equal(",
          "126:             tokenSupply.mul(newRatio).divn(100),",
          "127:           );",
          "128:         });",
          "130:         it('cannot updateQuorumNumerator over the maximum', async function () {",
          "131:           this.helper.setProposal(",
          "132:             [",
          "133:               {",
          "134:                 target: this.mock.address,",
          "135:                 data: this.mock.contract.methods.updateQuorumNumerator('101').encodeABI(),",
          "136:               },",
          "137:             ],",
          "138:             '<proposal description>',",
          "139:           );",
          "141:           await this.helper.propose();",
          "142:           await this.helper.waitForSnapshot();",
          "143:           await this.helper.vote({ support: Enums.VoteType.For }, { from: voter1 });",
          "144:           await this.helper.waitForDeadline();",
          "146:           await expectRevert(",
          "147:             this.helper.execute(),",
          "148:             'GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator',",
          "149:           );",
          "150:         });",
          "151:       });",
          "152:     });",
          "153:   }",
          "154: });",
          "",
          "---------------"
        ],
        "test/governance/extensions/GovernorWithParams.test.js||test/governance/extensions/GovernorWithParams.test.js": [
          "File: test/governance/extensions/GovernorWithParams.test.js -> test/governance/extensions/GovernorWithParams.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectEvent } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const ethSigUtil = require('eth-sig-util');",
          "4: const Wallet = require('ethereumjs-wallet').default;",
          "5: const { fromRpcSig } = require('ethereumjs-util');",
          "6: const Enums = require('../../helpers/enums');",
          "7: const { getDomain, domainType } = require('../../helpers/eip712');",
          "8: const { GovernorHelper } = require('../../helpers/governance');",
          "10: const Governor = artifacts.require('$GovernorWithParamsMock');",
          "11: const CallReceiver = artifacts.require('CallReceiverMock');",
          "13: const rawParams = {",
          "14:   uintParam: web3.utils.toBN('42'),",
          "15:   strParam: 'These are my params',",
          "16: };",
          "18: const encodedParams = web3.eth.abi.encodeParameters(['uint256', 'string'], Object.values(rawParams));",
          "20: const TOKENS = [",
          "21:   { Token: artifacts.require('$ERC20Votes'), mode: 'blocknumber' },",
          "22:   { Token: artifacts.require('$ERC20VotesTimestampMock'), mode: 'timestamp' },",
          "23: ];",
          "25: contract('GovernorWithParams', function (accounts) {",
          "26:   const [owner, proposer, voter1, voter2, voter3, voter4] = accounts;",
          "28:   const name = 'OZ-Governor';",
          "29:   const tokenName = 'MockToken';",
          "30:   const tokenSymbol = 'MTKN';",
          "31:   const tokenSupply = web3.utils.toWei('100');",
          "32:   const votingDelay = web3.utils.toBN(4);",
          "33:   const votingPeriod = web3.utils.toBN(16);",
          "34:   const value = web3.utils.toWei('1');",
          "36:   for (const { mode, Token } of TOKENS) {",
          "37:     describe(`using ${Token._json.contractName}`, function () {",
          "38:       beforeEach(async function () {",
          "39:         this.chainId = await web3.eth.getChainId();",
          "40:         this.token = await Token.new(tokenName, tokenSymbol, tokenName);",
          "41:         this.mock = await Governor.new(name, this.token.address);",
          "42:         this.receiver = await CallReceiver.new();",
          "44:         this.helper = new GovernorHelper(this.mock, mode);",
          "46:         await web3.eth.sendTransaction({ from: owner, to: this.mock.address, value });",
          "48:         await this.token.$_mint(owner, tokenSupply);",
          "49:         await this.helper.delegate({ token: this.token, to: voter1, value: web3.utils.toWei('10') }, { from: owner });",
          "50:         await this.helper.delegate({ token: this.token, to: voter2, value: web3.utils.toWei('7') }, { from: owner });",
          "51:         await this.helper.delegate({ token: this.token, to: voter3, value: web3.utils.toWei('5') }, { from: owner });",
          "52:         await this.helper.delegate({ token: this.token, to: voter4, value: web3.utils.toWei('2') }, { from: owner });",
          "55:         this.proposal = this.helper.setProposal(",
          "56:           [",
          "57:             {",
          "58:               target: this.receiver.address,",
          "59:               value,",
          "60:               data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "61:             },",
          "62:           ],",
          "63:           '<proposal description>',",
          "64:         );",
          "65:       });",
          "67:       it('deployment check', async function () {",
          "68:         expect(await this.mock.name()).to.be.equal(name);",
          "69:         expect(await this.mock.token()).to.be.equal(this.token.address);",
          "70:         expect(await this.mock.votingDelay()).to.be.bignumber.equal(votingDelay);",
          "71:         expect(await this.mock.votingPeriod()).to.be.bignumber.equal(votingPeriod);",
          "72:       });",
          "74:       it('nominal is unaffected', async function () {",
          "75:         await this.helper.propose({ from: proposer });",
          "76:         await this.helper.waitForSnapshot();",
          "77:         await this.helper.vote({ support: Enums.VoteType.For, reason: 'This is nice' }, { from: voter1 });",
          "78:         await this.helper.vote({ support: Enums.VoteType.For }, { from: voter2 });",
          "79:         await this.helper.vote({ support: Enums.VoteType.Against }, { from: voter3 });",
          "80:         await this.helper.vote({ support: Enums.VoteType.Abstain }, { from: voter4 });",
          "81:         await this.helper.waitForDeadline();",
          "82:         await this.helper.execute();",
          "84:         expect(await this.mock.hasVoted(this.proposal.id, owner)).to.be.equal(false);",
          "85:         expect(await this.mock.hasVoted(this.proposal.id, voter1)).to.be.equal(true);",
          "86:         expect(await this.mock.hasVoted(this.proposal.id, voter2)).to.be.equal(true);",
          "87:         expect(await web3.eth.getBalance(this.mock.address)).to.be.bignumber.equal('0');",
          "88:         expect(await web3.eth.getBalance(this.receiver.address)).to.be.bignumber.equal(value);",
          "89:       });",
          "91:       it('Voting with params is properly supported', async function () {",
          "92:         await this.helper.propose({ from: proposer });",
          "93:         await this.helper.waitForSnapshot();",
          "95:         const weight = web3.utils.toBN(web3.utils.toWei('7')).sub(rawParams.uintParam);",
          "97:         const tx = await this.helper.vote(",
          "98:           {",
          "99:             support: Enums.VoteType.For,",
          "100:             reason: 'no particular reason',",
          "101:             params: encodedParams,",
          "102:           },",
          "103:           { from: voter2 },",
          "104:         );",
          "106:         expectEvent(tx, 'CountParams', { ...rawParams });",
          "107:         expectEvent(tx, 'VoteCastWithParams', {",
          "108:           voter: voter2,",
          "109:           proposalId: this.proposal.id,",
          "110:           support: Enums.VoteType.For,",
          "111:           weight,",
          "112:           reason: 'no particular reason',",
          "113:           params: encodedParams,",
          "114:         });",
          "116:         const votes = await this.mock.proposalVotes(this.proposal.id);",
          "117:         expect(votes.forVotes).to.be.bignumber.equal(weight);",
          "118:       });",
          "120:       it('Voting with params by signature is properly supported', async function () {",
          "121:         const voterBySig = Wallet.generate();",
          "122:         const voterBySigAddress = web3.utils.toChecksumAddress(voterBySig.getAddressString());",
          "124:         const signature = (contract, message) =>",
          "125:           getDomain(contract)",
          "126:             .then(domain => ({",
          "127:               primaryType: 'ExtendedBallot',",
          "128:               types: {",
          "129:                 EIP712Domain: domainType(domain),",
          "130:                 ExtendedBallot: [",
          "131:                   { name: 'proposalId', type: 'uint256' },",
          "132:                   { name: 'support', type: 'uint8' },",
          "133:                   { name: 'reason', type: 'string' },",
          "134:                   { name: 'params', type: 'bytes' },",
          "135:                 ],",
          "136:               },",
          "137:               domain,",
          "138:               message,",
          "139:             }))",
          "140:             .then(data => ethSigUtil.signTypedMessage(voterBySig.getPrivateKey(), { data }))",
          "141:             .then(fromRpcSig);",
          "143:         await this.token.delegate(voterBySigAddress, { from: voter2 });",
          "146:         await this.helper.propose();",
          "147:         await this.helper.waitForSnapshot();",
          "149:         const weight = web3.utils.toBN(web3.utils.toWei('7')).sub(rawParams.uintParam);",
          "151:         const tx = await this.helper.vote({",
          "152:           support: Enums.VoteType.For,",
          "153:           reason: 'no particular reason',",
          "154:           params: encodedParams,",
          "155:           signature,",
          "156:         });",
          "158:         expectEvent(tx, 'CountParams', { ...rawParams });",
          "159:         expectEvent(tx, 'VoteCastWithParams', {",
          "160:           voter: voterBySigAddress,",
          "161:           proposalId: this.proposal.id,",
          "162:           support: Enums.VoteType.For,",
          "163:           weight,",
          "164:           reason: 'no particular reason',",
          "165:           params: encodedParams,",
          "166:         });",
          "168:         const votes = await this.mock.proposalVotes(this.proposal.id);",
          "169:         expect(votes.forVotes).to.be.bignumber.equal(weight);",
          "170:       });",
          "171:     });",
          "172:   }",
          "173: });",
          "",
          "---------------"
        ],
        "test/governance/utils/EIP6372.behavior.js||test/governance/utils/EIP6372.behavior.js": [
          "File: test/governance/utils/EIP6372.behavior.js -> test/governance/utils/EIP6372.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { clock } = require('../../helpers/time');",
          "3: function shouldBehaveLikeEIP6372(mode = 'blocknumber') {",
          "4:   describe('should implement EIP6372', function () {",
          "5:     beforeEach(async function () {",
          "6:       this.mock = this.mock ?? this.token ?? this.votes;",
          "7:     });",
          "9:     it('clock is correct', async function () {",
          "10:       expect(await this.mock.clock()).to.be.bignumber.equal(await clock[mode]().then(web3.utils.toBN));",
          "11:     });",
          "13:     it('CLOCK_MODE is correct', async function () {",
          "14:       const params = new URLSearchParams(await this.mock.CLOCK_MODE());",
          "15:       expect(params.get('mode')).to.be.equal(mode);",
          "16:       expect(params.get('from')).to.be.equal(mode == 'blocknumber' ? 'default' : null);",
          "17:     });",
          "18:   });",
          "19: }",
          "21: module.exports = {",
          "22:   shouldBehaveLikeEIP6372,",
          "23: };",
          "",
          "---------------"
        ],
        "test/governance/utils/Votes.behavior.js||test/governance/utils/Votes.behavior.js": [
          "File: test/governance/utils/Votes.behavior.js -> test/governance/utils/Votes.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { constants, expectEvent, expectRevert, time } = require('@openzeppelin/test-helpers');",
          "3: const { MAX_UINT256, ZERO_ADDRESS } = constants;",
          "5: const { fromRpcSig } = require('ethereumjs-util');",
          "6: const ethSigUtil = require('eth-sig-util');",
          "7: const Wallet = require('ethereumjs-wallet').default;",
          "9: const { shouldBehaveLikeEIP6372 } = require('./EIP6372.behavior');",
          "11: const { getDomain, domainType, domainSeparator } = require('../../helpers/eip712');",
          "12: const { clockFromReceipt } = require('../../helpers/time');",
          "14: const Delegation = [",
          "15:   { name: 'delegatee', type: 'address' },",
          "16:   { name: 'nonce', type: 'uint256' },",
          "17:   { name: 'expiry', type: 'uint256' },",
          "18: ];",
          "20: function shouldBehaveLikeVotes(mode = 'blocknumber') {",
          "21:   shouldBehaveLikeEIP6372(mode);",
          "23:   describe('run votes workflow', function () {",
          "24:     it('initial nonce is 0', async function () {",
          "25:       expect(await this.votes.nonces(this.account1)).to.be.bignumber.equal('0');",
          "26:     });",
          "28:     it('domain separator', async function () {",
          "29:       expect(await this.votes.DOMAIN_SEPARATOR()).to.equal(domainSeparator(await getDomain(this.votes)));",
          "30:     });",
          "32:     describe('delegation with signature', function () {",
          "33:       const delegator = Wallet.generate();",
          "34:       const delegatorAddress = web3.utils.toChecksumAddress(delegator.getAddressString());",
          "35:       const nonce = 0;",
          "37:       const buildAndSignData = async (contract, message, pk) => {",
          "38:         const data = await getDomain(contract).then(domain => ({",
          "39:           primaryType: 'Delegation',",
          "40:           types: { EIP712Domain: domainType(domain), Delegation },",
          "41:           domain,",
          "42:           message,",
          "43:         }));",
          "44:         return fromRpcSig(ethSigUtil.signTypedMessage(pk, { data }));",
          "45:       };",
          "47:       beforeEach(async function () {",
          "48:         await this.votes.$_mint(delegatorAddress, this.NFT0);",
          "49:       });",
          "51:       it('accept signed delegation', async function () {",
          "52:         const { v, r, s } = await buildAndSignData(",
          "53:           this.votes,",
          "54:           {",
          "55:             delegatee: delegatorAddress,",
          "56:             nonce,",
          "57:             expiry: MAX_UINT256,",
          "58:           },",
          "59:           delegator.getPrivateKey(),",
          "60:         );",
          "62:         expect(await this.votes.delegates(delegatorAddress)).to.be.equal(ZERO_ADDRESS);",
          "64:         const { receipt } = await this.votes.delegateBySig(delegatorAddress, nonce, MAX_UINT256, v, r, s);",
          "65:         const timepoint = await clockFromReceipt[mode](receipt);",
          "67:         expectEvent(receipt, 'DelegateChanged', {",
          "68:           delegator: delegatorAddress,",
          "69:           fromDelegate: ZERO_ADDRESS,",
          "70:           toDelegate: delegatorAddress,",
          "71:         });",
          "72:         expectEvent(receipt, 'DelegateVotesChanged', {",
          "73:           delegate: delegatorAddress,",
          "74:           previousBalance: '0',",
          "75:           newBalance: '1',",
          "76:         });",
          "78:         expect(await this.votes.delegates(delegatorAddress)).to.be.equal(delegatorAddress);",
          "80:         expect(await this.votes.getVotes(delegatorAddress)).to.be.bignumber.equal('1');",
          "81:         expect(await this.votes.getPastVotes(delegatorAddress, timepoint - 1)).to.be.bignumber.equal('0');",
          "82:         await time.advanceBlock();",
          "83:         expect(await this.votes.getPastVotes(delegatorAddress, timepoint)).to.be.bignumber.equal('1');",
          "84:       });",
          "86:       it('rejects reused signature', async function () {",
          "87:         const { v, r, s } = await buildAndSignData(",
          "88:           this.votes,",
          "89:           {",
          "90:             delegatee: delegatorAddress,",
          "91:             nonce,",
          "92:             expiry: MAX_UINT256,",
          "93:           },",
          "94:           delegator.getPrivateKey(),",
          "95:         );",
          "97:         await this.votes.delegateBySig(delegatorAddress, nonce, MAX_UINT256, v, r, s);",
          "99:         await expectRevert(",
          "100:           this.votes.delegateBySig(delegatorAddress, nonce, MAX_UINT256, v, r, s),",
          "101:           'Votes: invalid nonce',",
          "102:         );",
          "103:       });",
          "105:       it('rejects bad delegatee', async function () {",
          "106:         const { v, r, s } = await buildAndSignData(",
          "107:           this.votes,",
          "108:           {",
          "109:             delegatee: delegatorAddress,",
          "110:             nonce,",
          "111:             expiry: MAX_UINT256,",
          "112:           },",
          "113:           delegator.getPrivateKey(),",
          "114:         );",
          "116:         const receipt = await this.votes.delegateBySig(this.account1Delegatee, nonce, MAX_UINT256, v, r, s);",
          "117:         const { args } = receipt.logs.find(({ event }) => event === 'DelegateChanged');",
          "118:         expect(args.delegator).to.not.be.equal(delegatorAddress);",
          "119:         expect(args.fromDelegate).to.be.equal(ZERO_ADDRESS);",
          "120:         expect(args.toDelegate).to.be.equal(this.account1Delegatee);",
          "121:       });",
          "123:       it('rejects bad nonce', async function () {",
          "124:         const { v, r, s } = await buildAndSignData(",
          "125:           this.votes,",
          "126:           {",
          "127:             delegatee: delegatorAddress,",
          "128:             nonce,",
          "129:             expiry: MAX_UINT256,",
          "130:           },",
          "131:           delegator.getPrivateKey(),",
          "132:         );",
          "134:         await expectRevert(",
          "135:           this.votes.delegateBySig(delegatorAddress, nonce + 1, MAX_UINT256, v, r, s),",
          "136:           'Votes: invalid nonce',",
          "137:         );",
          "138:       });",
          "140:       it('rejects expired permit', async function () {",
          "141:         const expiry = (await time.latest()) - time.duration.weeks(1);",
          "143:         const { v, r, s } = await buildAndSignData(",
          "144:           this.votes,",
          "145:           {",
          "146:             delegatee: delegatorAddress,",
          "147:             nonce,",
          "148:             expiry,",
          "149:           },",
          "150:           delegator.getPrivateKey(),",
          "151:         );",
          "153:         await expectRevert(",
          "154:           this.votes.delegateBySig(delegatorAddress, nonce, expiry, v, r, s),",
          "155:           'Votes: signature expired',",
          "156:         );",
          "157:       });",
          "158:     });",
          "160:     describe('set delegation', function () {",
          "161:       describe('call', function () {",
          "162:         it('delegation with tokens', async function () {",
          "163:           await this.votes.$_mint(this.account1, this.NFT0);",
          "164:           expect(await this.votes.delegates(this.account1)).to.be.equal(ZERO_ADDRESS);",
          "166:           const { receipt } = await this.votes.delegate(this.account1, { from: this.account1 });",
          "167:           const timepoint = await clockFromReceipt[mode](receipt);",
          "169:           expectEvent(receipt, 'DelegateChanged', {",
          "170:             delegator: this.account1,",
          "171:             fromDelegate: ZERO_ADDRESS,",
          "172:             toDelegate: this.account1,",
          "173:           });",
          "174:           expectEvent(receipt, 'DelegateVotesChanged', {",
          "175:             delegate: this.account1,",
          "176:             previousBalance: '0',",
          "177:             newBalance: '1',",
          "178:           });",
          "180:           expect(await this.votes.delegates(this.account1)).to.be.equal(this.account1);",
          "182:           expect(await this.votes.getVotes(this.account1)).to.be.bignumber.equal('1');",
          "183:           expect(await this.votes.getPastVotes(this.account1, timepoint - 1)).to.be.bignumber.equal('0');",
          "184:           await time.advanceBlock();",
          "185:           expect(await this.votes.getPastVotes(this.account1, timepoint)).to.be.bignumber.equal('1');",
          "186:         });",
          "188:         it('delegation without tokens', async function () {",
          "189:           expect(await this.votes.delegates(this.account1)).to.be.equal(ZERO_ADDRESS);",
          "191:           const { receipt } = await this.votes.delegate(this.account1, { from: this.account1 });",
          "192:           expectEvent(receipt, 'DelegateChanged', {",
          "193:             delegator: this.account1,",
          "194:             fromDelegate: ZERO_ADDRESS,",
          "195:             toDelegate: this.account1,",
          "196:           });",
          "197:           expectEvent.notEmitted(receipt, 'DelegateVotesChanged');",
          "199:           expect(await this.votes.delegates(this.account1)).to.be.equal(this.account1);",
          "200:         });",
          "201:       });",
          "202:     });",
          "204:     describe('change delegation', function () {",
          "205:       beforeEach(async function () {",
          "206:         await this.votes.$_mint(this.account1, this.NFT0);",
          "207:         await this.votes.delegate(this.account1, { from: this.account1 });",
          "208:       });",
          "210:       it('call', async function () {",
          "211:         expect(await this.votes.delegates(this.account1)).to.be.equal(this.account1);",
          "213:         const { receipt } = await this.votes.delegate(this.account1Delegatee, { from: this.account1 });",
          "214:         const timepoint = await clockFromReceipt[mode](receipt);",
          "216:         expectEvent(receipt, 'DelegateChanged', {",
          "217:           delegator: this.account1,",
          "218:           fromDelegate: this.account1,",
          "219:           toDelegate: this.account1Delegatee,",
          "220:         });",
          "221:         expectEvent(receipt, 'DelegateVotesChanged', {",
          "222:           delegate: this.account1,",
          "223:           previousBalance: '1',",
          "224:           newBalance: '0',",
          "225:         });",
          "226:         expectEvent(receipt, 'DelegateVotesChanged', {",
          "227:           delegate: this.account1Delegatee,",
          "228:           previousBalance: '0',",
          "229:           newBalance: '1',",
          "230:         });",
          "232:         expect(await this.votes.delegates(this.account1)).to.be.equal(this.account1Delegatee);",
          "234:         expect(await this.votes.getVotes(this.account1)).to.be.bignumber.equal('0');",
          "235:         expect(await this.votes.getVotes(this.account1Delegatee)).to.be.bignumber.equal('1');",
          "236:         expect(await this.votes.getPastVotes(this.account1, timepoint - 1)).to.be.bignumber.equal('1');",
          "237:         expect(await this.votes.getPastVotes(this.account1Delegatee, timepoint - 1)).to.be.bignumber.equal('0');",
          "238:         await time.advanceBlock();",
          "239:         expect(await this.votes.getPastVotes(this.account1, timepoint)).to.be.bignumber.equal('0');",
          "240:         expect(await this.votes.getPastVotes(this.account1Delegatee, timepoint)).to.be.bignumber.equal('1');",
          "241:       });",
          "242:     });",
          "244:     describe('getPastTotalSupply', function () {",
          "245:       beforeEach(async function () {",
          "246:         await this.votes.delegate(this.account1, { from: this.account1 });",
          "247:       });",
          "249:       it('reverts if block number >= current block', async function () {",
          "250:         await expectRevert(this.votes.getPastTotalSupply(5e10), 'future lookup');",
          "251:       });",
          "253:       it('returns 0 if there are no checkpoints', async function () {",
          "254:         expect(await this.votes.getPastTotalSupply(0)).to.be.bignumber.equal('0');",
          "255:       });",
          "257:       it('returns the latest block if >= last checkpoint block', async function () {",
          "258:         const { receipt } = await this.votes.$_mint(this.account1, this.NFT0);",
          "259:         const timepoint = await clockFromReceipt[mode](receipt);",
          "260:         await time.advanceBlock();",
          "261:         await time.advanceBlock();",
          "263:         expect(await this.votes.getPastTotalSupply(timepoint - 1)).to.be.bignumber.equal('0');",
          "264:         expect(await this.votes.getPastTotalSupply(timepoint + 1)).to.be.bignumber.equal('1');",
          "265:       });",
          "267:       it('returns zero if < first checkpoint block', async function () {",
          "268:         await time.advanceBlock();",
          "269:         const { receipt } = await this.votes.$_mint(this.account1, this.NFT1);",
          "270:         const timepoint = await clockFromReceipt[mode](receipt);",
          "271:         await time.advanceBlock();",
          "272:         await time.advanceBlock();",
          "274:         expect(await this.votes.getPastTotalSupply(timepoint - 1)).to.be.bignumber.equal('0');",
          "275:         expect(await this.votes.getPastTotalSupply(timepoint + 1)).to.be.bignumber.equal('1');",
          "276:       });",
          "278:       it('generally returns the voting balance at the appropriate checkpoint', async function () {",
          "279:         const t1 = await this.votes.$_mint(this.account1, this.NFT1);",
          "280:         await time.advanceBlock();",
          "281:         await time.advanceBlock();",
          "282:         const t2 = await this.votes.$_burn(this.NFT1);",
          "283:         await time.advanceBlock();",
          "284:         await time.advanceBlock();",
          "285:         const t3 = await this.votes.$_mint(this.account1, this.NFT2);",
          "286:         await time.advanceBlock();",
          "287:         await time.advanceBlock();",
          "288:         const t4 = await this.votes.$_burn(this.NFT2);",
          "289:         await time.advanceBlock();",
          "290:         await time.advanceBlock();",
          "291:         const t5 = await this.votes.$_mint(this.account1, this.NFT3);",
          "292:         await time.advanceBlock();",
          "293:         await time.advanceBlock();",
          "295:         t1.timepoint = await clockFromReceipt[mode](t1.receipt);",
          "296:         t2.timepoint = await clockFromReceipt[mode](t2.receipt);",
          "297:         t3.timepoint = await clockFromReceipt[mode](t3.receipt);",
          "298:         t4.timepoint = await clockFromReceipt[mode](t4.receipt);",
          "299:         t5.timepoint = await clockFromReceipt[mode](t5.receipt);",
          "301:         expect(await this.votes.getPastTotalSupply(t1.timepoint - 1)).to.be.bignumber.equal('0');",
          "302:         expect(await this.votes.getPastTotalSupply(t1.timepoint)).to.be.bignumber.equal('1');",
          "303:         expect(await this.votes.getPastTotalSupply(t1.timepoint + 1)).to.be.bignumber.equal('1');",
          "304:         expect(await this.votes.getPastTotalSupply(t2.timepoint)).to.be.bignumber.equal('0');",
          "305:         expect(await this.votes.getPastTotalSupply(t2.timepoint + 1)).to.be.bignumber.equal('0');",
          "306:         expect(await this.votes.getPastTotalSupply(t3.timepoint)).to.be.bignumber.equal('1');",
          "307:         expect(await this.votes.getPastTotalSupply(t3.timepoint + 1)).to.be.bignumber.equal('1');",
          "308:         expect(await this.votes.getPastTotalSupply(t4.timepoint)).to.be.bignumber.equal('0');",
          "309:         expect(await this.votes.getPastTotalSupply(t4.timepoint + 1)).to.be.bignumber.equal('0');",
          "310:         expect(await this.votes.getPastTotalSupply(t5.timepoint)).to.be.bignumber.equal('1');",
          "311:         expect(await this.votes.getPastTotalSupply(t5.timepoint + 1)).to.be.bignumber.equal('1');",
          "312:       });",
          "313:     });",
          "317:     describe('Compound test suite', function () {",
          "318:       beforeEach(async function () {",
          "319:         await this.votes.$_mint(this.account1, this.NFT0);",
          "320:         await this.votes.$_mint(this.account1, this.NFT1);",
          "321:         await this.votes.$_mint(this.account1, this.NFT2);",
          "322:         await this.votes.$_mint(this.account1, this.NFT3);",
          "323:       });",
          "325:       describe('getPastVotes', function () {",
          "326:         it('reverts if block number >= current block', async function () {",
          "327:           await expectRevert(this.votes.getPastVotes(this.account2, 5e10), 'future lookup');",
          "328:         });",
          "330:         it('returns 0 if there are no checkpoints', async function () {",
          "331:           expect(await this.votes.getPastVotes(this.account2, 0)).to.be.bignumber.equal('0');",
          "332:         });",
          "334:         it('returns the latest block if >= last checkpoint block', async function () {",
          "335:           const { receipt } = await this.votes.delegate(this.account2, { from: this.account1 });",
          "336:           const timepoint = await clockFromReceipt[mode](receipt);",
          "337:           await time.advanceBlock();",
          "338:           await time.advanceBlock();",
          "340:           const latest = await this.votes.getVotes(this.account2);",
          "341:           expect(await this.votes.getPastVotes(this.account2, timepoint)).to.be.bignumber.equal(latest);",
          "342:           expect(await this.votes.getPastVotes(this.account2, timepoint + 1)).to.be.bignumber.equal(latest);",
          "343:         });",
          "345:         it('returns zero if < first checkpoint block', async function () {",
          "346:           await time.advanceBlock();",
          "347:           const { receipt } = await this.votes.delegate(this.account2, { from: this.account1 });",
          "348:           const timepoint = await clockFromReceipt[mode](receipt);",
          "349:           await time.advanceBlock();",
          "350:           await time.advanceBlock();",
          "352:           expect(await this.votes.getPastVotes(this.account2, timepoint - 1)).to.be.bignumber.equal('0');",
          "353:         });",
          "354:       });",
          "355:     });",
          "356:   });",
          "357: }",
          "359: module.exports = {",
          "360:   shouldBehaveLikeVotes,",
          "361: };",
          "",
          "---------------"
        ],
        "test/governance/utils/Votes.test.js||test/governance/utils/Votes.test.js": [
          "File: test/governance/utils/Votes.test.js -> test/governance/utils/Votes.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectRevert, BN } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const { getChainId } = require('../../helpers/chainid');",
          "6: const { clockFromReceipt } = require('../../helpers/time');",
          "8: const { shouldBehaveLikeVotes } = require('./Votes.behavior');",
          "10: const MODES = {",
          "11:   blocknumber: artifacts.require('$VotesMock'),",
          "12:   timestamp: artifacts.require('$VotesTimestampMock'),",
          "13: };",
          "15: contract('Votes', function (accounts) {",
          "16:   const [account1, account2, account3] = accounts;",
          "18:   for (const [mode, artifact] of Object.entries(MODES)) {",
          "19:     describe(`vote with ${mode}`, function () {",
          "20:       beforeEach(async function () {",
          "21:         this.name = 'My Vote';",
          "22:         this.votes = await artifact.new(this.name, '1');",
          "23:       });",
          "25:       it('starts with zero votes', async function () {",
          "26:         expect(await this.votes.getTotalSupply()).to.be.bignumber.equal('0');",
          "27:       });",
          "29:       describe('performs voting operations', function () {",
          "30:         beforeEach(async function () {",
          "31:           this.tx1 = await this.votes.$_mint(account1, 1);",
          "32:           this.tx2 = await this.votes.$_mint(account2, 1);",
          "33:           this.tx3 = await this.votes.$_mint(account3, 1);",
          "34:           this.tx1.timepoint = await clockFromReceipt[mode](this.tx1.receipt);",
          "35:           this.tx2.timepoint = await clockFromReceipt[mode](this.tx2.receipt);",
          "36:           this.tx3.timepoint = await clockFromReceipt[mode](this.tx3.receipt);",
          "37:         });",
          "39:         it('reverts if block number >= current block', async function () {",
          "40:           await expectRevert(this.votes.getPastTotalSupply(this.tx3.timepoint + 1), 'Votes: future lookup');",
          "41:         });",
          "43:         it('delegates', async function () {",
          "44:           await this.votes.delegate(account3, account2);",
          "46:           expect(await this.votes.delegates(account3)).to.be.equal(account2);",
          "47:         });",
          "49:         it('returns total amount of votes', async function () {",
          "50:           expect(await this.votes.getTotalSupply()).to.be.bignumber.equal('3');",
          "51:         });",
          "52:       });",
          "54:       describe('performs voting workflow', function () {",
          "55:         beforeEach(async function () {",
          "56:           this.chainId = await getChainId();",
          "57:           this.account1 = account1;",
          "58:           this.account2 = account2;",
          "59:           this.account1Delegatee = account2;",
          "60:           this.NFT0 = new BN('10000000000000000000000000');",
          "61:           this.NFT1 = new BN('10');",
          "62:           this.NFT2 = new BN('20');",
          "63:           this.NFT3 = new BN('30');",
          "64:         });",
          "67:         shouldBehaveLikeVotes(mode);",
          "68:       });",
          "69:     });",
          "70:   }",
          "71: });",
          "",
          "---------------"
        ],
        "test/helpers/chainid.js||test/helpers/chainid.js": [
          "File: test/helpers/chainid.js -> test/helpers/chainid.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const hre = require('hardhat');",
          "3: async function getChainId() {",
          "4:   const chainIdHex = await hre.network.provider.send('eth_chainId', []);",
          "5:   return new hre.web3.utils.BN(chainIdHex, 'hex');",
          "6: }",
          "8: module.exports = {",
          "9:   getChainId,",
          "10: };",
          "",
          "---------------"
        ],
        "test/helpers/create2.js||test/helpers/create2.js": [
          "File: test/helpers/create2.js -> test/helpers/create2.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: function computeCreate2Address(saltHex, bytecode, deployer) {",
          "2:   return web3.utils.toChecksumAddress(",
          "3:     `0x${web3.utils",
          "4:       .sha3(`0x${['ff', deployer, saltHex, web3.utils.soliditySha3(bytecode)].map(x => x.replace(/0x/, '')).join('')}`)",
          "5:       .slice(-40)}`,",
          "6:   );",
          "7: }",
          "9: module.exports = {",
          "10:   computeCreate2Address,",
          "11: };",
          "",
          "---------------"
        ],
        "test/helpers/crosschain.js||test/helpers/crosschain.js": [
          "File: test/helpers/crosschain.js -> test/helpers/crosschain.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { promisify } = require('util');",
          "3: const BridgeAMBMock = artifacts.require('BridgeAMBMock');",
          "4: const BridgeArbitrumL1Mock = artifacts.require('BridgeArbitrumL1Mock');",
          "5: const BridgeArbitrumL2Mock = artifacts.require('BridgeArbitrumL2Mock');",
          "6: const BridgeOptimismMock = artifacts.require('BridgeOptimismMock');",
          "7: const BridgePolygonChildMock = artifacts.require('BridgePolygonChildMock');",
          "9: class BridgeHelper {",
          "10:   static async deploy(type) {",
          "11:     return new BridgeHelper(await deployBridge(type));",
          "12:   }",
          "14:   constructor(bridge) {",
          "15:     this.bridge = bridge;",
          "16:     this.address = bridge.address;",
          "17:   }",
          "19:   call(from, target, selector = undefined, args = []) {",
          "20:     return this.bridge.relayAs(",
          "21:       target.address || target,",
          "22:       selector ? target.contract.methods[selector](...args).encodeABI() : '0x',",
          "23:       from,",
          "24:     );",
          "25:   }",
          "26: }",
          "28: async function deployBridge(type = 'Arbitrum-L2') {",
          "29:   switch (type) {",
          "30:     case 'AMB':",
          "31:       return BridgeAMBMock.new();",
          "33:     case 'Arbitrum-L1':",
          "34:       return BridgeArbitrumL1Mock.new();",
          "36:     case 'Arbitrum-L2': {",
          "37:       const instance = await BridgeArbitrumL2Mock.new();",
          "38:       const code = await web3.eth.getCode(instance.address);",
          "39:       await promisify(web3.currentProvider.send.bind(web3.currentProvider))({",
          "40:         jsonrpc: '2.0',",
          "41:         method: 'hardhat_setCode',",
          "42:         params: ['0x0000000000000000000000000000000000000064', code],",
          "43:         id: new Date().getTime(),",
          "44:       });",
          "45:       return BridgeArbitrumL2Mock.at('0x0000000000000000000000000000000000000064');",
          "46:     }",
          "48:     case 'Optimism':",
          "49:       return BridgeOptimismMock.new();",
          "51:     case 'Polygon-Child':",
          "52:       return BridgePolygonChildMock.new();",
          "54:     default:",
          "55:       throw new Error(`CrossChain: ${type} is not supported`);",
          "56:   }",
          "57: }",
          "59: module.exports = {",
          "60:   BridgeHelper,",
          "61: };",
          "",
          "---------------"
        ],
        "test/helpers/customError.js||test/helpers/customError.js": [
          "File: test/helpers/customError.js -> test/helpers/customError.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { config } = require('hardhat');",
          "3: const optimizationsEnabled = config.solidity.compilers.some(c => c.settings.optimizer.enabled);",
          "6: async function expectRevertCustomError(promise, reason) {",
          "7:   try {",
          "8:     await promise;",
          "9:     expect.fail(\"Expected promise to throw but it didn't\");",
          "10:   } catch (revert) {",
          "11:     if (reason) {",
          "12:       if (optimizationsEnabled) {",
          "14:         expect(revert.message).to.include.oneOf([reason, 'unrecognized return data or custom error']);",
          "15:       } else {",
          "16:         expect(revert.message).to.include(reason);",
          "17:       }",
          "18:     }",
          "19:   }",
          "20: }",
          "22: module.exports = {",
          "23:   expectRevertCustomError,",
          "24: };",
          "",
          "---------------"
        ],
        "test/helpers/eip712.js||test/helpers/eip712.js": [
          "File: test/helpers/eip712.js -> test/helpers/eip712.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const ethSigUtil = require('eth-sig-util');",
          "2: const keccak256 = require('keccak256');",
          "4: const EIP712Domain = [",
          "5:   { name: 'name', type: 'string' },",
          "6:   { name: 'version', type: 'string' },",
          "7:   { name: 'chainId', type: 'uint256' },",
          "8:   { name: 'verifyingContract', type: 'address' },",
          "9:   { name: 'salt', type: 'bytes32' },",
          "10: ];",
          "12: const Permit = [",
          "13:   { name: 'owner', type: 'address' },",
          "14:   { name: 'spender', type: 'address' },",
          "15:   { name: 'value', type: 'uint256' },",
          "16:   { name: 'nonce', type: 'uint256' },",
          "17:   { name: 'deadline', type: 'uint256' },",
          "18: ];",
          "20: function bufferToHexString(buffer) {",
          "21:   return '0x' + buffer.toString('hex');",
          "22: }",
          "24: function hexStringToBuffer(hexstr) {",
          "25:   return Buffer.from(hexstr.replace(/^0x/, ''), 'hex');",
          "26: }",
          "28: async function getDomain(contract) {",
          "29:   const { fields, name, version, chainId, verifyingContract, salt, extensions } = await contract.eip712Domain();",
          "31:   if (extensions.length > 0) {",
          "32:     throw Error('Extensions not implemented');",
          "33:   }",
          "35:   const domain = { name, version, chainId, verifyingContract, salt };",
          "36:   for (const [i, { name }] of EIP712Domain.entries()) {",
          "37:     if (!(fields & (1 << i))) {",
          "38:       delete domain[name];",
          "39:     }",
          "40:   }",
          "42:   return domain;",
          "43: }",
          "45: function domainType(domain) {",
          "46:   return EIP712Domain.filter(({ name }) => domain[name] !== undefined);",
          "47: }",
          "49: function domainSeparator(domain) {",
          "50:   return bufferToHexString(",
          "51:     ethSigUtil.TypedDataUtils.hashStruct('EIP712Domain', domain, { EIP712Domain: domainType(domain) }),",
          "52:   );",
          "53: }",
          "55: function hashTypedData(domain, structHash) {",
          "56:   return bufferToHexString(",
          "57:     keccak256(Buffer.concat(['0x1901', domainSeparator(domain), structHash].map(str => hexStringToBuffer(str)))),",
          "58:   );",
          "59: }",
          "61: module.exports = {",
          "62:   Permit,",
          "63:   getDomain,",
          "64:   domainType,",
          "65:   domainSeparator,",
          "66:   hashTypedData,",
          "67: };",
          "",
          "---------------"
        ],
        "test/helpers/enums.js||test/helpers/enums.js": [
          "File: test/helpers/enums.js -> test/helpers/enums.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN } = require('@openzeppelin/test-helpers');",
          "3: function Enum(...options) {",
          "4:   return Object.fromEntries(options.map((key, i) => [key, new BN(i)]));",
          "5: }",
          "7: module.exports = {",
          "8:   Enum,",
          "9:   ProposalState: Enum('Pending', 'Active', 'Canceled', 'Defeated', 'Succeeded', 'Queued', 'Expired', 'Executed'),",
          "10:   VoteType: Enum('Against', 'For', 'Abstain'),",
          "11:   Rounding: Enum('Down', 'Up', 'Zero'),",
          "12: };",
          "",
          "---------------"
        ],
        "test/helpers/erc1967.js||test/helpers/erc1967.js": [
          "File: test/helpers/erc1967.js -> test/helpers/erc1967.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const ImplementationLabel = 'eip1967.proxy.implementation';",
          "2: const AdminLabel = 'eip1967.proxy.admin';",
          "3: const BeaconLabel = 'eip1967.proxy.beacon';",
          "5: function labelToSlot(label) {",
          "6:   return '0x' + web3.utils.toBN(web3.utils.keccak256(label)).subn(1).toString(16);",
          "7: }",
          "9: function getSlot(address, slot) {",
          "10:   return web3.eth.getStorageAt(",
          "11:     web3.utils.isAddress(address) ? address : address.address,",
          "12:     web3.utils.isHex(slot) ? slot : labelToSlot(slot),",
          "13:   );",
          "14: }",
          "16: module.exports = {",
          "17:   ImplementationLabel,",
          "18:   AdminLabel,",
          "19:   BeaconLabel,",
          "20:   ImplementationSlot: labelToSlot(ImplementationLabel),",
          "21:   AdminSlot: labelToSlot(AdminLabel),",
          "22:   BeaconSlot: labelToSlot(BeaconLabel),",
          "23:   getSlot,",
          "24: };",
          "",
          "---------------"
        ],
        "test/helpers/governance.js||test/helpers/governance.js": [
          "File: test/helpers/governance.js -> test/helpers/governance.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { forward } = require('../helpers/time');",
          "3: function zip(...args) {",
          "4:   return Array(Math.max(...args.map(array => array.length)))",
          "5:     .fill()",
          "6:     .map((_, i) => args.map(array => array[i]));",
          "7: }",
          "9: function concatHex(...args) {",
          "10:   return web3.utils.bytesToHex([].concat(...args.map(h => web3.utils.hexToBytes(h || '0x'))));",
          "11: }",
          "13: function concatOpts(args, opts = null) {",
          "14:   return opts ? args.concat(opts) : args;",
          "15: }",
          "17: class GovernorHelper {",
          "18:   constructor(governor, mode = 'blocknumber') {",
          "19:     this.governor = governor;",
          "20:     this.mode = mode;",
          "21:   }",
          "23:   delegate(delegation = {}, opts = null) {",
          "24:     return Promise.all([",
          "25:       delegation.token.delegate(delegation.to, { from: delegation.to }),",
          "26:       delegation.value && delegation.token.transfer(...concatOpts([delegation.to, delegation.value]), opts),",
          "27:       delegation.tokenId &&",
          "28:         delegation.token",
          "29:           .ownerOf(delegation.tokenId)",
          "30:           .then(owner =>",
          "31:             delegation.token.transferFrom(...concatOpts([owner, delegation.to, delegation.tokenId], opts)),",
          "32:           ),",
          "33:     ]);",
          "34:   }",
          "36:   propose(opts = null) {",
          "37:     const proposal = this.currentProposal;",
          "39:     return this.governor.methods[",
          "40:       proposal.useCompatibilityInterface",
          "41:         ? 'propose(address[],uint256[],string[],bytes[],string)'",
          "42:         : 'propose(address[],uint256[],bytes[],string)'",
          "43:     ](...concatOpts(proposal.fullProposal, opts));",
          "44:   }",
          "46:   queue(opts = null) {",
          "47:     const proposal = this.currentProposal;",
          "49:     return proposal.useCompatibilityInterface",
          "50:       ? this.governor.methods['queue(uint256)'](...concatOpts([proposal.id], opts))",
          "51:       : this.governor.methods['queue(address[],uint256[],bytes[],bytes32)'](",
          "52:           ...concatOpts(proposal.shortProposal, opts),",
          "53:         );",
          "54:   }",
          "56:   execute(opts = null) {",
          "57:     const proposal = this.currentProposal;",
          "59:     return proposal.useCompatibilityInterface",
          "60:       ? this.governor.methods['execute(uint256)'](...concatOpts([proposal.id], opts))",
          "61:       : this.governor.methods['execute(address[],uint256[],bytes[],bytes32)'](",
          "62:           ...concatOpts(proposal.shortProposal, opts),",
          "63:         );",
          "64:   }",
          "66:   cancel(visibility = 'external', opts = null) {",
          "67:     const proposal = this.currentProposal;",
          "69:     switch (visibility) {",
          "70:       case 'external':",
          "71:         if (proposal.useCompatibilityInterface) {",
          "72:           return this.governor.methods['cancel(uint256)'](...concatOpts([proposal.id], opts));",
          "73:         } else {",
          "74:           return this.governor.methods['cancel(address[],uint256[],bytes[],bytes32)'](",
          "75:             ...concatOpts(proposal.shortProposal, opts),",
          "76:           );",
          "77:         }",
          "78:       case 'internal':",
          "79:         return this.governor.methods['$_cancel(address[],uint256[],bytes[],bytes32)'](",
          "80:           ...concatOpts(proposal.shortProposal, opts),",
          "81:         );",
          "82:       default:",
          "83:         throw new Error(`unsuported visibility \"${visibility}\"`);",
          "84:     }",
          "85:   }",
          "87:   vote(vote = {}, opts = null) {",
          "88:     const proposal = this.currentProposal;",
          "90:     return vote.signature",
          "91:       ? // if signature, and either params or reason \u2192",
          "92:         vote.params || vote.reason",
          "93:         ? vote",
          "94:             .signature(this.governor, {",
          "95:               proposalId: proposal.id,",
          "96:               support: vote.support,",
          "97:               reason: vote.reason || '',",
          "98:               params: vote.params || '',",
          "99:             })",
          "100:             .then(({ v, r, s }) =>",
          "101:               this.governor.castVoteWithReasonAndParamsBySig(",
          "102:                 ...concatOpts([proposal.id, vote.support, vote.reason || '', vote.params || '', v, r, s], opts),",
          "103:               ),",
          "104:             )",
          "105:         : vote",
          "106:             .signature(this.governor, {",
          "107:               proposalId: proposal.id,",
          "108:               support: vote.support,",
          "109:             })",
          "110:             .then(({ v, r, s }) =>",
          "111:               this.governor.castVoteBySig(...concatOpts([proposal.id, vote.support, v, r, s], opts)),",
          "112:             )",
          "113:       : vote.params",
          "114:       ? // otherwise if params",
          "115:         this.governor.castVoteWithReasonAndParams(",
          "116:           ...concatOpts([proposal.id, vote.support, vote.reason || '', vote.params], opts),",
          "117:         )",
          "118:       : vote.reason",
          "119:       ? // otherwise if reason",
          "120:         this.governor.castVoteWithReason(...concatOpts([proposal.id, vote.support, vote.reason], opts))",
          "121:       : this.governor.castVote(...concatOpts([proposal.id, vote.support], opts));",
          "122:   }",
          "124:   async waitForSnapshot(offset = 0) {",
          "125:     const proposal = this.currentProposal;",
          "126:     const timepoint = await this.governor.proposalSnapshot(proposal.id);",
          "127:     return forward[this.mode](timepoint.addn(offset));",
          "128:   }",
          "130:   async waitForDeadline(offset = 0) {",
          "131:     const proposal = this.currentProposal;",
          "132:     const timepoint = await this.governor.proposalDeadline(proposal.id);",
          "133:     return forward[this.mode](timepoint.addn(offset));",
          "134:   }",
          "136:   async waitForEta(offset = 0) {",
          "137:     const proposal = this.currentProposal;",
          "138:     const timestamp = await this.governor.proposalEta(proposal.id);",
          "139:     return forward.timestamp(timestamp.addn(offset));",
          "140:   }",
          "147:   setProposal(actions, description) {",
          "148:     let targets, values, signatures, data, useCompatibilityInterface;",
          "150:     if (Array.isArray(actions)) {",
          "151:       useCompatibilityInterface = actions.some(a => 'signature' in a);",
          "152:       targets = actions.map(a => a.target);",
          "153:       values = actions.map(a => a.value || '0');",
          "154:       signatures = actions.map(a => a.signature || '');",
          "155:       data = actions.map(a => a.data || '0x');",
          "156:     } else {",
          "157:       useCompatibilityInterface = Array.isArray(actions.signatures);",
          "158:       ({ targets, values, signatures = [], data } = actions);",
          "159:     }",
          "161:     const fulldata = zip(",
          "162:       signatures.map(s => s && web3.eth.abi.encodeFunctionSignature(s)),",
          "163:       data,",
          "164:     ).map(hexs => concatHex(...hexs));",
          "166:     const descriptionHash = web3.utils.keccak256(description);",
          "169:     const shortProposal = [targets, values, fulldata, descriptionHash];",
          "172:     const fullProposal = [targets, values, ...(useCompatibilityInterface ? [signatures] : []), data, description];",
          "175:     const id = web3.utils.toBN(",
          "176:       web3.utils.keccak256(",
          "177:         web3.eth.abi.encodeParameters(['address[]', 'uint256[]', 'bytes[]', 'bytes32'], shortProposal),",
          "178:       ),",
          "179:     );",
          "181:     this.currentProposal = {",
          "182:       id,",
          "183:       targets,",
          "184:       values,",
          "185:       signatures,",
          "186:       data,",
          "187:       fulldata,",
          "188:       description,",
          "189:       descriptionHash,",
          "190:       shortProposal,",
          "191:       fullProposal,",
          "192:       useCompatibilityInterface,",
          "193:     };",
          "195:     return this.currentProposal;",
          "196:   }",
          "197: }",
          "199: module.exports = {",
          "200:   GovernorHelper,",
          "201: };",
          "",
          "---------------"
        ],
        "test/helpers/map-values.js||test/helpers/map-values.js": [
          "File: test/helpers/map-values.js -> test/helpers/map-values.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: function mapValues(obj, fn) {",
          "2:   return Object.fromEntries([...Object.entries(obj)].map(([k, v]) => [k, fn(v)]));",
          "3: }",
          "5: module.exports = {",
          "6:   mapValues,",
          "7: };",
          "",
          "---------------"
        ],
        "test/helpers/sign.js||test/helpers/sign.js": [
          "File: test/helpers/sign.js -> test/helpers/sign.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: function toEthSignedMessageHash(messageHex) {",
          "2:   const messageBuffer = Buffer.from(messageHex.substring(2), 'hex');",
          "3:   const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${messageBuffer.length}`);",
          "4:   return web3.utils.sha3(Buffer.concat([prefix, messageBuffer]));",
          "5: }",
          "12: function toDataWithIntendedValidatorHash(validatorAddress, dataHex) {",
          "13:   const validatorBuffer = Buffer.from(web3.utils.hexToBytes(validatorAddress));",
          "14:   const dataBuffer = Buffer.from(web3.utils.hexToBytes(dataHex));",
          "15:   const preambleBuffer = Buffer.from('\\x19');",
          "16:   const versionBuffer = Buffer.from('\\x00');",
          "17:   const ethMessage = Buffer.concat([preambleBuffer, versionBuffer, validatorBuffer, dataBuffer]);",
          "19:   return web3.utils.sha3(ethMessage);",
          "20: }",
          "31: const getSignFor =",
          "32:   (contract, signer) =>",
          "33:   (redeemer, methodName, methodArgs = []) => {",
          "34:     const parts = [contract.address, redeemer];",
          "36:     const REAL_SIGNATURE_SIZE = 2 * 65; // 65 bytes in hexadecimal string length",
          "37:     const PADDED_SIGNATURE_SIZE = 2 * 96; // 96 bytes in hexadecimal string length",
          "38:     const DUMMY_SIGNATURE = `0x${web3.utils.padLeft('', REAL_SIGNATURE_SIZE)}`;",
          "41:     if (methodName) {",
          "42:       if (methodArgs.length > 0) {",
          "43:         parts.push(",
          "44:           contract.contract.methods[methodName](...methodArgs.concat([DUMMY_SIGNATURE]))",
          "45:             .encodeABI()",
          "46:             .slice(0, -1 * PADDED_SIGNATURE_SIZE),",
          "47:         );",
          "48:       } else {",
          "49:         const abi = contract.abi.find(abi => abi.name === methodName);",
          "50:         parts.push(abi.signature);",
          "51:       }",
          "52:     }",
          "55:     const messageHex = web3.utils.soliditySha3(...parts);",
          "56:     return web3.eth.sign(messageHex, signer);",
          "57:   };",
          "59: module.exports = {",
          "60:   toEthSignedMessageHash,",
          "61:   toDataWithIntendedValidatorHash,",
          "62:   getSignFor,",
          "63: };",
          "",
          "---------------"
        ],
        "test/helpers/time.js||test/helpers/time.js": [
          "File: test/helpers/time.js -> test/helpers/time.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const ozHelpers = require('@openzeppelin/test-helpers');",
          "2: const helpers = require('@nomicfoundation/hardhat-network-helpers');",
          "4: module.exports = {",
          "5:   clock: {",
          "6:     blocknumber: () => helpers.time.latestBlock(),",
          "7:     timestamp: () => helpers.time.latest(),",
          "8:   },",
          "9:   clockFromReceipt: {",
          "10:     blocknumber: receipt => Promise.resolve(receipt.blockNumber),",
          "11:     timestamp: receipt => web3.eth.getBlock(receipt.blockNumber).then(block => block.timestamp),",
          "12:   },",
          "13:   forward: {",
          "14:     blocknumber: ozHelpers.time.advanceBlockTo,",
          "15:     timestamp: helpers.time.increaseTo,",
          "16:   },",
          "17: };",
          "",
          "---------------"
        ],
        "test/helpers/txpool.js||test/helpers/txpool.js": [
          "File: test/helpers/txpool.js -> test/helpers/txpool.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { network } = require('hardhat');",
          "2: const { promisify } = require('util');",
          "4: const queue = promisify(setImmediate);",
          "6: async function countPendingTransactions() {",
          "7:   return parseInt(await network.provider.send('eth_getBlockTransactionCountByNumber', ['pending']));",
          "8: }",
          "10: async function batchInBlock(txs) {",
          "11:   try {",
          "13:     await network.provider.send('evm_setAutomine', [false]);",
          "15:     const promises = txs.map(fn => fn());",
          "17:     while (txs.length > (await countPendingTransactions())) {",
          "18:       await queue();",
          "19:     }",
          "21:     await network.provider.send('evm_mine');",
          "23:     const receipts = await Promise.all(promises);",
          "25:     const minedBlocks = new Set(receipts.map(({ receipt }) => receipt.blockNumber));",
          "26:     expect(minedBlocks.size).to.equal(1);",
          "28:     return receipts;",
          "29:   } finally {",
          "31:     await network.provider.send('evm_setAutomine', [true]);",
          "32:   }",
          "33: }",
          "35: module.exports = {",
          "36:   countPendingTransactions,",
          "37:   batchInBlock,",
          "38: };",
          "",
          "---------------"
        ],
        "test/metatx/ERC2771Context.test.js||test/metatx/ERC2771Context.test.js": [
          "File: test/metatx/ERC2771Context.test.js -> test/metatx/ERC2771Context.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const ethSigUtil = require('eth-sig-util');",
          "2: const Wallet = require('ethereumjs-wallet').default;",
          "3: const { getDomain, domainType } = require('../helpers/eip712');",
          "5: const { expectEvent } = require('@openzeppelin/test-helpers');",
          "6: const { expect } = require('chai');",
          "8: const ERC2771ContextMock = artifacts.require('ERC2771ContextMock');",
          "9: const MinimalForwarder = artifacts.require('MinimalForwarder');",
          "10: const ContextMockCaller = artifacts.require('ContextMockCaller');",
          "12: const { shouldBehaveLikeRegularContext } = require('../utils/Context.behavior');",
          "14: contract('ERC2771Context', function (accounts) {",
          "15:   beforeEach(async function () {",
          "16:     this.forwarder = await MinimalForwarder.new();",
          "17:     this.recipient = await ERC2771ContextMock.new(this.forwarder.address);",
          "19:     this.domain = await getDomain(this.forwarder);",
          "20:     this.types = {",
          "21:       EIP712Domain: domainType(this.domain),",
          "22:       ForwardRequest: [",
          "23:         { name: 'from', type: 'address' },",
          "24:         { name: 'to', type: 'address' },",
          "25:         { name: 'value', type: 'uint256' },",
          "26:         { name: 'gas', type: 'uint256' },",
          "27:         { name: 'nonce', type: 'uint256' },",
          "28:         { name: 'data', type: 'bytes' },",
          "29:       ],",
          "30:     };",
          "31:   });",
          "33:   it('recognize trusted forwarder', async function () {",
          "34:     expect(await this.recipient.isTrustedForwarder(this.forwarder.address));",
          "35:   });",
          "37:   context('when called directly', function () {",
          "38:     beforeEach(async function () {",
          "39:       this.context = this.recipient; // The Context behavior expects the contract in this.context",
          "40:       this.caller = await ContextMockCaller.new();",
          "41:     });",
          "43:     shouldBehaveLikeRegularContext(...accounts);",
          "44:   });",
          "46:   context('when receiving a relayed call', function () {",
          "47:     beforeEach(async function () {",
          "48:       this.wallet = Wallet.generate();",
          "49:       this.sender = web3.utils.toChecksumAddress(this.wallet.getAddressString());",
          "50:       this.data = {",
          "51:         types: this.types,",
          "52:         domain: this.domain,",
          "53:         primaryType: 'ForwardRequest',",
          "54:       };",
          "55:     });",
          "57:     describe('msgSender', function () {",
          "58:       it('returns the relayed transaction original sender', async function () {",
          "59:         const data = this.recipient.contract.methods.msgSender().encodeABI();",
          "61:         const req = {",
          "62:           from: this.sender,",
          "63:           to: this.recipient.address,",
          "64:           value: '0',",
          "65:           gas: '100000',",
          "66:           nonce: (await this.forwarder.getNonce(this.sender)).toString(),",
          "67:           data,",
          "68:         };",
          "70:         const sign = ethSigUtil.signTypedMessage(this.wallet.getPrivateKey(), { data: { ...this.data, message: req } });",
          "71:         expect(await this.forwarder.verify(req, sign)).to.equal(true);",
          "73:         const { tx } = await this.forwarder.execute(req, sign);",
          "74:         await expectEvent.inTransaction(tx, ERC2771ContextMock, 'Sender', { sender: this.sender });",
          "75:       });",
          "76:     });",
          "78:     describe('msgData', function () {",
          "79:       it('returns the relayed transaction original data', async function () {",
          "80:         const integerValue = '42';",
          "81:         const stringValue = 'OpenZeppelin';",
          "82:         const data = this.recipient.contract.methods.msgData(integerValue, stringValue).encodeABI();",
          "84:         const req = {",
          "85:           from: this.sender,",
          "86:           to: this.recipient.address,",
          "87:           value: '0',",
          "88:           gas: '100000',",
          "89:           nonce: (await this.forwarder.getNonce(this.sender)).toString(),",
          "90:           data,",
          "91:         };",
          "93:         const sign = ethSigUtil.signTypedMessage(this.wallet.getPrivateKey(), { data: { ...this.data, message: req } });",
          "94:         expect(await this.forwarder.verify(req, sign)).to.equal(true);",
          "96:         const { tx } = await this.forwarder.execute(req, sign);",
          "97:         await expectEvent.inTransaction(tx, ERC2771ContextMock, 'Data', { data, integerValue, stringValue });",
          "98:       });",
          "99:     });",
          "100:   });",
          "101: });",
          "",
          "---------------"
        ],
        "test/metatx/MinimalForwarder.test.js||test/metatx/MinimalForwarder.test.js": [
          "File: test/metatx/MinimalForwarder.test.js -> test/metatx/MinimalForwarder.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const ethSigUtil = require('eth-sig-util');",
          "2: const Wallet = require('ethereumjs-wallet').default;",
          "3: const { getDomain, domainType } = require('../helpers/eip712');",
          "5: const { expectRevert, constants } = require('@openzeppelin/test-helpers');",
          "6: const { expect } = require('chai');",
          "8: const MinimalForwarder = artifacts.require('MinimalForwarder');",
          "9: const CallReceiverMock = artifacts.require('CallReceiverMock');",
          "11: contract('MinimalForwarder', function (accounts) {",
          "12:   beforeEach(async function () {",
          "13:     this.forwarder = await MinimalForwarder.new();",
          "15:     this.domain = await getDomain(this.forwarder);",
          "16:     this.types = {",
          "17:       EIP712Domain: domainType(this.domain),",
          "18:       ForwardRequest: [",
          "19:         { name: 'from', type: 'address' },",
          "20:         { name: 'to', type: 'address' },",
          "21:         { name: 'value', type: 'uint256' },",
          "22:         { name: 'gas', type: 'uint256' },",
          "23:         { name: 'nonce', type: 'uint256' },",
          "24:         { name: 'data', type: 'bytes' },",
          "25:       ],",
          "26:     };",
          "27:   });",
          "29:   context('with message', function () {",
          "30:     beforeEach(async function () {",
          "31:       this.wallet = Wallet.generate();",
          "32:       this.sender = web3.utils.toChecksumAddress(this.wallet.getAddressString());",
          "33:       this.req = {",
          "34:         from: this.sender,",
          "35:         to: constants.ZERO_ADDRESS,",
          "36:         value: '0',",
          "37:         gas: '100000',",
          "38:         nonce: Number(await this.forwarder.getNonce(this.sender)),",
          "39:         data: '0x',",
          "40:       };",
          "41:       this.sign = () =>",
          "42:         ethSigUtil.signTypedMessage(this.wallet.getPrivateKey(), {",
          "43:           data: {",
          "44:             types: this.types,",
          "45:             domain: this.domain,",
          "46:             primaryType: 'ForwardRequest',",
          "47:             message: this.req,",
          "48:           },",
          "49:         });",
          "50:     });",
          "52:     context('verify', function () {",
          "53:       context('valid signature', function () {",
          "54:         beforeEach(async function () {",
          "55:           expect(await this.forwarder.getNonce(this.req.from)).to.be.bignumber.equal(web3.utils.toBN(this.req.nonce));",
          "56:         });",
          "58:         it('success', async function () {",
          "59:           expect(await this.forwarder.verify(this.req, this.sign())).to.be.equal(true);",
          "60:         });",
          "62:         afterEach(async function () {",
          "63:           expect(await this.forwarder.getNonce(this.req.from)).to.be.bignumber.equal(web3.utils.toBN(this.req.nonce));",
          "64:         });",
          "65:       });",
          "67:       context('invalid signature', function () {",
          "68:         it('tampered from', async function () {",
          "69:           expect(await this.forwarder.verify({ ...this.req, from: accounts[0] }, this.sign())).to.be.equal(false);",
          "70:         });",
          "71:         it('tampered to', async function () {",
          "72:           expect(await this.forwarder.verify({ ...this.req, to: accounts[0] }, this.sign())).to.be.equal(false);",
          "73:         });",
          "74:         it('tampered value', async function () {",
          "75:           expect(await this.forwarder.verify({ ...this.req, value: web3.utils.toWei('1') }, this.sign())).to.be.equal(",
          "76:             false,",
          "77:           );",
          "78:         });",
          "79:         it('tampered nonce', async function () {",
          "80:           expect(await this.forwarder.verify({ ...this.req, nonce: this.req.nonce + 1 }, this.sign())).to.be.equal(",
          "81:             false,",
          "82:           );",
          "83:         });",
          "84:         it('tampered data', async function () {",
          "85:           expect(await this.forwarder.verify({ ...this.req, data: '0x1742' }, this.sign())).to.be.equal(false);",
          "86:         });",
          "87:         it('tampered signature', async function () {",
          "88:           const tamperedsign = web3.utils.hexToBytes(this.sign());",
          "89:           tamperedsign[42] ^= 0xff;",
          "90:           expect(await this.forwarder.verify(this.req, web3.utils.bytesToHex(tamperedsign))).to.be.equal(false);",
          "91:         });",
          "92:       });",
          "93:     });",
          "95:     context('execute', function () {",
          "96:       context('valid signature', function () {",
          "97:         beforeEach(async function () {",
          "98:           expect(await this.forwarder.getNonce(this.req.from)).to.be.bignumber.equal(web3.utils.toBN(this.req.nonce));",
          "99:         });",
          "101:         it('success', async function () {",
          "102:           await this.forwarder.execute(this.req, this.sign()); // expect to not revert",
          "103:         });",
          "105:         afterEach(async function () {",
          "106:           expect(await this.forwarder.getNonce(this.req.from)).to.be.bignumber.equal(",
          "107:             web3.utils.toBN(this.req.nonce + 1),",
          "108:           );",
          "109:         });",
          "110:       });",
          "112:       context('invalid signature', function () {",
          "113:         it('tampered from', async function () {",
          "114:           await expectRevert(",
          "115:             this.forwarder.execute({ ...this.req, from: accounts[0] }, this.sign()),",
          "116:             'MinimalForwarder: signature does not match request',",
          "117:           );",
          "118:         });",
          "119:         it('tampered to', async function () {",
          "120:           await expectRevert(",
          "121:             this.forwarder.execute({ ...this.req, to: accounts[0] }, this.sign()),",
          "122:             'MinimalForwarder: signature does not match request',",
          "123:           );",
          "124:         });",
          "125:         it('tampered value', async function () {",
          "126:           await expectRevert(",
          "127:             this.forwarder.execute({ ...this.req, value: web3.utils.toWei('1') }, this.sign()),",
          "128:             'MinimalForwarder: signature does not match request',",
          "129:           );",
          "130:         });",
          "131:         it('tampered nonce', async function () {",
          "132:           await expectRevert(",
          "133:             this.forwarder.execute({ ...this.req, nonce: this.req.nonce + 1 }, this.sign()),",
          "134:             'MinimalForwarder: signature does not match request',",
          "135:           );",
          "136:         });",
          "137:         it('tampered data', async function () {",
          "138:           await expectRevert(",
          "139:             this.forwarder.execute({ ...this.req, data: '0x1742' }, this.sign()),",
          "140:             'MinimalForwarder: signature does not match request',",
          "141:           );",
          "142:         });",
          "143:         it('tampered signature', async function () {",
          "144:           const tamperedsign = web3.utils.hexToBytes(this.sign());",
          "145:           tamperedsign[42] ^= 0xff;",
          "146:           await expectRevert(",
          "147:             this.forwarder.execute(this.req, web3.utils.bytesToHex(tamperedsign)),",
          "148:             'MinimalForwarder: signature does not match request',",
          "149:           );",
          "150:         });",
          "151:       });",
          "153:       it('bubble out of gas', async function () {",
          "154:         const receiver = await CallReceiverMock.new();",
          "155:         const gasAvailable = 100000;",
          "156:         this.req.to = receiver.address;",
          "157:         this.req.data = receiver.contract.methods.mockFunctionOutOfGas().encodeABI();",
          "158:         this.req.gas = 1000000;",
          "160:         await expectRevert.assertion(this.forwarder.execute(this.req, this.sign(), { gas: gasAvailable }));",
          "162:         const { transactions } = await web3.eth.getBlock('latest');",
          "163:         const { gasUsed } = await web3.eth.getTransactionReceipt(transactions[0]);",
          "165:         expect(gasUsed).to.be.equal(gasAvailable);",
          "166:       });",
          "167:     });",
          "168:   });",
          "169: });",
          "",
          "---------------"
        ],
        "test/migrate-imports.test.js||test/migrate-imports.test.js": [
          "File: test/migrate-imports.test.js -> test/migrate-imports.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const path = require('path');",
          "2: const {",
          "3:   promises: fs,",
          "4:   constants: { F_OK },",
          "5: } = require('fs');",
          "6: const { expect } = require('chai');",
          "8: const { pathUpdates, updateImportPaths, getUpgradeablePath } = require('../scripts/migrate-imports.js');",
          "10: describe('migrate-imports.js', function () {",
          "11:   it('every new path exists', async function () {",
          "12:     for (const p of Object.values(pathUpdates)) {",
          "13:       try {",
          "14:         await fs.access(path.join('contracts', p), F_OK);",
          "15:       } catch (e) {",
          "16:         if (p.startsWith('proxy/')) continue; // excluded from transpilation of upgradeable contracts",
          "17:         await fs.access(path.join('contracts', getUpgradeablePath(p)), F_OK);",
          "18:       }",
          "19:     }",
          "20:   });",
          "22:   it('replaces import paths in a file', async function () {",
          "23:     const source = `",
          "24: import '@openzeppelin/contracts/math/Math.sol';",
          "25: import '@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol';",
          "26:     `;",
          "27:     const expected = `",
          "28: import '@openzeppelin/contracts/utils/math/Math.sol';",
          "29: import '@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol';",
          "30:     `;",
          "31:     expect(updateImportPaths(source)).to.equal(expected);",
          "32:   });",
          "33: });",
          "",
          "---------------"
        ],
        "test/proxy/Clones.behaviour.js||test/proxy/Clones.behaviour.js": [
          "File: test/proxy/Clones.behaviour.js -> test/proxy/Clones.behaviour.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const DummyImplementation = artifacts.require('DummyImplementation');",
          "7: module.exports = function shouldBehaveLikeClone(createClone) {",
          "8:   before('deploy implementation', async function () {",
          "9:     this.implementation = web3.utils.toChecksumAddress((await DummyImplementation.new()).address);",
          "10:   });",
          "12:   const assertProxyInitialization = function ({ value, balance }) {",
          "13:     it('initializes the proxy', async function () {",
          "14:       const dummy = new DummyImplementation(this.proxy);",
          "15:       expect(await dummy.value()).to.be.bignumber.equal(value.toString());",
          "16:     });",
          "18:     it('has expected balance', async function () {",
          "19:       expect(await web3.eth.getBalance(this.proxy)).to.be.bignumber.equal(balance.toString());",
          "20:     });",
          "21:   };",
          "23:   describe('initialization without parameters', function () {",
          "24:     describe('non payable', function () {",
          "25:       const expectedInitializedValue = 10;",
          "26:       const initializeData = new DummyImplementation('').contract.methods['initializeNonPayable()']().encodeABI();",
          "28:       describe('when not sending balance', function () {",
          "29:         beforeEach('creating proxy', async function () {",
          "30:           this.proxy = (await createClone(this.implementation, initializeData)).address;",
          "31:         });",
          "33:         assertProxyInitialization({",
          "34:           value: expectedInitializedValue,",
          "35:           balance: 0,",
          "36:         });",
          "37:       });",
          "39:       describe('when sending some balance', function () {",
          "40:         const value = 10e5;",
          "42:         it('reverts', async function () {",
          "43:           await expectRevert.unspecified(createClone(this.implementation, initializeData, { value }));",
          "44:         });",
          "45:       });",
          "46:     });",
          "48:     describe('payable', function () {",
          "49:       const expectedInitializedValue = 100;",
          "50:       const initializeData = new DummyImplementation('').contract.methods['initializePayable()']().encodeABI();",
          "52:       describe('when not sending balance', function () {",
          "53:         beforeEach('creating proxy', async function () {",
          "54:           this.proxy = (await createClone(this.implementation, initializeData)).address;",
          "55:         });",
          "57:         assertProxyInitialization({",
          "58:           value: expectedInitializedValue,",
          "59:           balance: 0,",
          "60:         });",
          "61:       });",
          "63:       describe('when sending some balance', function () {",
          "64:         const value = 10e5;",
          "66:         beforeEach('creating proxy', async function () {",
          "67:           this.proxy = (await createClone(this.implementation, initializeData, { value })).address;",
          "68:         });",
          "70:         assertProxyInitialization({",
          "71:           value: expectedInitializedValue,",
          "72:           balance: value,",
          "73:         });",
          "74:       });",
          "75:     });",
          "76:   });",
          "78:   describe('initialization with parameters', function () {",
          "79:     describe('non payable', function () {",
          "80:       const expectedInitializedValue = 10;",
          "81:       const initializeData = new DummyImplementation('').contract.methods",
          "82:         .initializeNonPayableWithValue(expectedInitializedValue)",
          "83:         .encodeABI();",
          "85:       describe('when not sending balance', function () {",
          "86:         beforeEach('creating proxy', async function () {",
          "87:           this.proxy = (await createClone(this.implementation, initializeData)).address;",
          "88:         });",
          "90:         assertProxyInitialization({",
          "91:           value: expectedInitializedValue,",
          "92:           balance: 0,",
          "93:         });",
          "94:       });",
          "96:       describe('when sending some balance', function () {",
          "97:         const value = 10e5;",
          "99:         it('reverts', async function () {",
          "100:           await expectRevert.unspecified(createClone(this.implementation, initializeData, { value }));",
          "101:         });",
          "102:       });",
          "103:     });",
          "105:     describe('payable', function () {",
          "106:       const expectedInitializedValue = 42;",
          "107:       const initializeData = new DummyImplementation('').contract.methods",
          "108:         .initializePayableWithValue(expectedInitializedValue)",
          "109:         .encodeABI();",
          "111:       describe('when not sending balance', function () {",
          "112:         beforeEach('creating proxy', async function () {",
          "113:           this.proxy = (await createClone(this.implementation, initializeData)).address;",
          "114:         });",
          "116:         assertProxyInitialization({",
          "117:           value: expectedInitializedValue,",
          "118:           balance: 0,",
          "119:         });",
          "120:       });",
          "122:       describe('when sending some balance', function () {",
          "123:         const value = 10e5;",
          "125:         beforeEach('creating proxy', async function () {",
          "126:           this.proxy = (await createClone(this.implementation, initializeData, { value })).address;",
          "127:         });",
          "129:         assertProxyInitialization({",
          "130:           value: expectedInitializedValue,",
          "131:           balance: value,",
          "132:         });",
          "133:       });",
          "134:     });",
          "135:   });",
          "136: };",
          "",
          "---------------"
        ],
        "test/proxy/Clones.test.js||test/proxy/Clones.test.js": [
          "File: test/proxy/Clones.test.js -> test/proxy/Clones.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { computeCreate2Address } = require('../helpers/create2');",
          "3: const { expect } = require('chai');",
          "5: const shouldBehaveLikeClone = require('./Clones.behaviour');",
          "7: const Clones = artifacts.require('$Clones');",
          "9: contract('Clones', function (accounts) {",
          "10:   const [deployer] = accounts;",
          "12:   describe('clone', function () {",
          "13:     shouldBehaveLikeClone(async (implementation, initData, opts = {}) => {",
          "14:       const factory = await Clones.new();",
          "15:       const receipt = await factory.$clone(implementation);",
          "16:       const address = receipt.logs.find(({ event }) => event === 'return$clone').args.instance;",
          "17:       await web3.eth.sendTransaction({ from: deployer, to: address, value: opts.value, data: initData });",
          "18:       return { address };",
          "19:     });",
          "20:   });",
          "22:   describe('cloneDeterministic', function () {",
          "23:     shouldBehaveLikeClone(async (implementation, initData, opts = {}) => {",
          "24:       const salt = web3.utils.randomHex(32);",
          "25:       const factory = await Clones.new();",
          "26:       const receipt = await factory.$cloneDeterministic(implementation, salt);",
          "27:       const address = receipt.logs.find(({ event }) => event === 'return$cloneDeterministic').args.instance;",
          "28:       await web3.eth.sendTransaction({ from: deployer, to: address, value: opts.value, data: initData });",
          "29:       return { address };",
          "30:     });",
          "32:     it('address already used', async function () {",
          "33:       const implementation = web3.utils.randomHex(20);",
          "34:       const salt = web3.utils.randomHex(32);",
          "35:       const factory = await Clones.new();",
          "37:       expectEvent(await factory.$cloneDeterministic(implementation, salt), 'return$cloneDeterministic');",
          "39:       await expectRevert(factory.$cloneDeterministic(implementation, salt), 'ERC1167: create2 failed');",
          "40:     });",
          "42:     it('address prediction', async function () {",
          "43:       const implementation = web3.utils.randomHex(20);",
          "44:       const salt = web3.utils.randomHex(32);",
          "45:       const factory = await Clones.new();",
          "46:       const predicted = await factory.$predictDeterministicAddress(implementation, salt);",
          "48:       const creationCode = [",
          "49:         '0x3d602d80600a3d3981f3363d3d373d3d3d363d73',",
          "50:         implementation.replace(/0x/, '').toLowerCase(),",
          "51:         '5af43d82803e903d91602b57fd5bf3',",
          "52:       ].join('');",
          "54:       expect(computeCreate2Address(salt, creationCode, factory.address)).to.be.equal(predicted);",
          "56:       expectEvent(await factory.$cloneDeterministic(implementation, salt), 'return$cloneDeterministic', {",
          "57:         instance: predicted,",
          "58:       });",
          "59:     });",
          "60:   });",
          "61: });",
          "",
          "---------------"
        ],
        "test/proxy/ERC1967/ERC1967Proxy.test.js||test/proxy/ERC1967/ERC1967Proxy.test.js": [
          "File: test/proxy/ERC1967/ERC1967Proxy.test.js -> test/proxy/ERC1967/ERC1967Proxy.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const shouldBehaveLikeProxy = require('../Proxy.behaviour');",
          "3: const ERC1967Proxy = artifacts.require('ERC1967Proxy');",
          "5: contract('ERC1967Proxy', function (accounts) {",
          "6:   const [proxyAdminOwner] = accounts;",
          "8:   const createProxy = async function (implementation, _admin, initData, opts) {",
          "9:     return ERC1967Proxy.new(implementation, initData, opts);",
          "10:   };",
          "12:   shouldBehaveLikeProxy(createProxy, undefined, proxyAdminOwner);",
          "13: });",
          "",
          "---------------"
        ],
        "test/proxy/Proxy.behaviour.js||test/proxy/Proxy.behaviour.js": [
          "File: test/proxy/Proxy.behaviour.js -> test/proxy/Proxy.behaviour.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { getSlot, ImplementationSlot } = require('../helpers/erc1967');",
          "4: const { expect } = require('chai');",
          "6: const DummyImplementation = artifacts.require('DummyImplementation');",
          "8: module.exports = function shouldBehaveLikeProxy(createProxy, proxyAdminAddress, proxyCreator) {",
          "9:   it('cannot be initialized with a non-contract address', async function () {",
          "10:     const nonContractAddress = proxyCreator;",
          "11:     const initializeData = Buffer.from('');",
          "12:     await expectRevert.unspecified(",
          "13:       createProxy(nonContractAddress, proxyAdminAddress, initializeData, {",
          "14:         from: proxyCreator,",
          "15:       }),",
          "16:     );",
          "17:   });",
          "19:   before('deploy implementation', async function () {",
          "20:     this.implementation = web3.utils.toChecksumAddress((await DummyImplementation.new()).address);",
          "21:   });",
          "23:   const assertProxyInitialization = function ({ value, balance }) {",
          "24:     it('sets the implementation address', async function () {",
          "25:       const implementationSlot = await getSlot(this.proxy, ImplementationSlot);",
          "26:       const implementationAddress = web3.utils.toChecksumAddress(implementationSlot.substr(-40));",
          "27:       expect(implementationAddress).to.be.equal(this.implementation);",
          "28:     });",
          "30:     it('initializes the proxy', async function () {",
          "31:       const dummy = new DummyImplementation(this.proxy);",
          "32:       expect(await dummy.value()).to.be.bignumber.equal(value.toString());",
          "33:     });",
          "35:     it('has expected balance', async function () {",
          "36:       expect(await web3.eth.getBalance(this.proxy)).to.be.bignumber.equal(balance.toString());",
          "37:     });",
          "38:   };",
          "40:   describe('without initialization', function () {",
          "41:     const initializeData = Buffer.from('');",
          "43:     describe('when not sending balance', function () {",
          "44:       beforeEach('creating proxy', async function () {",
          "45:         this.proxy = (",
          "46:           await createProxy(this.implementation, proxyAdminAddress, initializeData, {",
          "47:             from: proxyCreator,",
          "48:           })",
          "49:         ).address;",
          "50:       });",
          "52:       assertProxyInitialization({ value: 0, balance: 0 });",
          "53:     });",
          "55:     describe('when sending some balance', function () {",
          "56:       const value = 10e5;",
          "58:       beforeEach('creating proxy', async function () {",
          "59:         this.proxy = (",
          "60:           await createProxy(this.implementation, proxyAdminAddress, initializeData, {",
          "61:             from: proxyCreator,",
          "62:             value,",
          "63:           })",
          "64:         ).address;",
          "65:       });",
          "67:       assertProxyInitialization({ value: 0, balance: value });",
          "68:     });",
          "69:   });",
          "71:   describe('initialization without parameters', function () {",
          "72:     describe('non payable', function () {",
          "73:       const expectedInitializedValue = 10;",
          "74:       const initializeData = new DummyImplementation('').contract.methods['initializeNonPayable()']().encodeABI();",
          "76:       describe('when not sending balance', function () {",
          "77:         beforeEach('creating proxy', async function () {",
          "78:           this.proxy = (",
          "79:             await createProxy(this.implementation, proxyAdminAddress, initializeData, {",
          "80:               from: proxyCreator,",
          "81:             })",
          "82:           ).address;",
          "83:         });",
          "85:         assertProxyInitialization({",
          "86:           value: expectedInitializedValue,",
          "87:           balance: 0,",
          "88:         });",
          "89:       });",
          "91:       describe('when sending some balance', function () {",
          "92:         const value = 10e5;",
          "94:         it('reverts', async function () {",
          "95:           await expectRevert.unspecified(",
          "96:             createProxy(this.implementation, proxyAdminAddress, initializeData, { from: proxyCreator, value }),",
          "97:           );",
          "98:         });",
          "99:       });",
          "100:     });",
          "102:     describe('payable', function () {",
          "103:       const expectedInitializedValue = 100;",
          "104:       const initializeData = new DummyImplementation('').contract.methods['initializePayable()']().encodeABI();",
          "106:       describe('when not sending balance', function () {",
          "107:         beforeEach('creating proxy', async function () {",
          "108:           this.proxy = (",
          "109:             await createProxy(this.implementation, proxyAdminAddress, initializeData, {",
          "110:               from: proxyCreator,",
          "111:             })",
          "112:           ).address;",
          "113:         });",
          "115:         assertProxyInitialization({",
          "116:           value: expectedInitializedValue,",
          "117:           balance: 0,",
          "118:         });",
          "119:       });",
          "121:       describe('when sending some balance', function () {",
          "122:         const value = 10e5;",
          "124:         beforeEach('creating proxy', async function () {",
          "125:           this.proxy = (",
          "126:             await createProxy(this.implementation, proxyAdminAddress, initializeData, {",
          "127:               from: proxyCreator,",
          "128:               value,",
          "129:             })",
          "130:           ).address;",
          "131:         });",
          "133:         assertProxyInitialization({",
          "134:           value: expectedInitializedValue,",
          "135:           balance: value,",
          "136:         });",
          "137:       });",
          "138:     });",
          "139:   });",
          "141:   describe('initialization with parameters', function () {",
          "142:     describe('non payable', function () {",
          "143:       const expectedInitializedValue = 10;",
          "144:       const initializeData = new DummyImplementation('').contract.methods",
          "145:         .initializeNonPayableWithValue(expectedInitializedValue)",
          "146:         .encodeABI();",
          "148:       describe('when not sending balance', function () {",
          "149:         beforeEach('creating proxy', async function () {",
          "150:           this.proxy = (",
          "151:             await createProxy(this.implementation, proxyAdminAddress, initializeData, {",
          "152:               from: proxyCreator,",
          "153:             })",
          "154:           ).address;",
          "155:         });",
          "157:         assertProxyInitialization({",
          "158:           value: expectedInitializedValue,",
          "159:           balance: 0,",
          "160:         });",
          "161:       });",
          "163:       describe('when sending some balance', function () {",
          "164:         const value = 10e5;",
          "166:         it('reverts', async function () {",
          "167:           await expectRevert.unspecified(",
          "168:             createProxy(this.implementation, proxyAdminAddress, initializeData, { from: proxyCreator, value }),",
          "169:           );",
          "170:         });",
          "171:       });",
          "172:     });",
          "174:     describe('payable', function () {",
          "175:       const expectedInitializedValue = 42;",
          "176:       const initializeData = new DummyImplementation('').contract.methods",
          "177:         .initializePayableWithValue(expectedInitializedValue)",
          "178:         .encodeABI();",
          "180:       describe('when not sending balance', function () {",
          "181:         beforeEach('creating proxy', async function () {",
          "182:           this.proxy = (",
          "183:             await createProxy(this.implementation, proxyAdminAddress, initializeData, {",
          "184:               from: proxyCreator,",
          "185:             })",
          "186:           ).address;",
          "187:         });",
          "189:         assertProxyInitialization({",
          "190:           value: expectedInitializedValue,",
          "191:           balance: 0,",
          "192:         });",
          "193:       });",
          "195:       describe('when sending some balance', function () {",
          "196:         const value = 10e5;",
          "198:         beforeEach('creating proxy', async function () {",
          "199:           this.proxy = (",
          "200:             await createProxy(this.implementation, proxyAdminAddress, initializeData, {",
          "201:               from: proxyCreator,",
          "202:               value,",
          "203:             })",
          "204:           ).address;",
          "205:         });",
          "207:         assertProxyInitialization({",
          "208:           value: expectedInitializedValue,",
          "209:           balance: value,",
          "210:         });",
          "211:       });",
          "212:     });",
          "214:     describe('reverting initialization', function () {",
          "215:       const initializeData = new DummyImplementation('').contract.methods.reverts().encodeABI();",
          "217:       it('reverts', async function () {",
          "218:         await expectRevert(",
          "219:           createProxy(this.implementation, proxyAdminAddress, initializeData, { from: proxyCreator }),",
          "220:           'DummyImplementation reverted',",
          "221:         );",
          "222:       });",
          "223:     });",
          "224:   });",
          "225: };",
          "",
          "---------------"
        ],
        "test/proxy/beacon/BeaconProxy.test.js||test/proxy/beacon/BeaconProxy.test.js": [
          "File: test/proxy/beacon/BeaconProxy.test.js -> test/proxy/beacon/BeaconProxy.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { getSlot, BeaconSlot } = require('../../helpers/erc1967');",
          "4: const { expect } = require('chai');",
          "6: const UpgradeableBeacon = artifacts.require('UpgradeableBeacon');",
          "7: const BeaconProxy = artifacts.require('BeaconProxy');",
          "8: const DummyImplementation = artifacts.require('DummyImplementation');",
          "9: const DummyImplementationV2 = artifacts.require('DummyImplementationV2');",
          "10: const BadBeaconNoImpl = artifacts.require('BadBeaconNoImpl');",
          "11: const BadBeaconNotContract = artifacts.require('BadBeaconNotContract');",
          "13: contract('BeaconProxy', function (accounts) {",
          "14:   const [anotherAccount] = accounts;",
          "16:   describe('bad beacon is not accepted', async function () {",
          "17:     it('non-contract beacon', async function () {",
          "18:       await expectRevert(BeaconProxy.new(anotherAccount, '0x'), 'ERC1967: new beacon is not a contract');",
          "19:     });",
          "21:     it('non-compliant beacon', async function () {",
          "22:       const beacon = await BadBeaconNoImpl.new();",
          "23:       await expectRevert.unspecified(BeaconProxy.new(beacon.address, '0x'));",
          "24:     });",
          "26:     it('non-contract implementation', async function () {",
          "27:       const beacon = await BadBeaconNotContract.new();",
          "28:       await expectRevert(BeaconProxy.new(beacon.address, '0x'), 'ERC1967: beacon implementation is not a contract');",
          "29:     });",
          "30:   });",
          "32:   before('deploy implementation', async function () {",
          "33:     this.implementationV0 = await DummyImplementation.new();",
          "34:     this.implementationV1 = await DummyImplementationV2.new();",
          "35:   });",
          "37:   describe('initialization', function () {",
          "38:     before(function () {",
          "39:       this.assertInitialized = async ({ value, balance }) => {",
          "40:         const beaconSlot = await getSlot(this.proxy, BeaconSlot);",
          "41:         const beaconAddress = web3.utils.toChecksumAddress(beaconSlot.substr(-40));",
          "42:         expect(beaconAddress).to.equal(this.beacon.address);",
          "44:         const dummy = new DummyImplementation(this.proxy.address);",
          "45:         expect(await dummy.value()).to.bignumber.eq(value);",
          "47:         expect(await web3.eth.getBalance(this.proxy.address)).to.bignumber.eq(balance);",
          "48:       };",
          "49:     });",
          "51:     beforeEach('deploy beacon', async function () {",
          "52:       this.beacon = await UpgradeableBeacon.new(this.implementationV0.address);",
          "53:     });",
          "55:     it('no initialization', async function () {",
          "56:       const data = Buffer.from('');",
          "57:       const balance = '10';",
          "58:       this.proxy = await BeaconProxy.new(this.beacon.address, data, { value: balance });",
          "59:       await this.assertInitialized({ value: '0', balance });",
          "60:     });",
          "62:     it('non-payable initialization', async function () {",
          "63:       const value = '55';",
          "64:       const data = this.implementationV0.contract.methods.initializeNonPayableWithValue(value).encodeABI();",
          "65:       this.proxy = await BeaconProxy.new(this.beacon.address, data);",
          "66:       await this.assertInitialized({ value, balance: '0' });",
          "67:     });",
          "69:     it('payable initialization', async function () {",
          "70:       const value = '55';",
          "71:       const data = this.implementationV0.contract.methods.initializePayableWithValue(value).encodeABI();",
          "72:       const balance = '100';",
          "73:       this.proxy = await BeaconProxy.new(this.beacon.address, data, { value: balance });",
          "74:       await this.assertInitialized({ value, balance });",
          "75:     });",
          "77:     it('reverting initialization', async function () {",
          "78:       const data = this.implementationV0.contract.methods.reverts().encodeABI();",
          "79:       await expectRevert(BeaconProxy.new(this.beacon.address, data), 'DummyImplementation reverted');",
          "80:     });",
          "81:   });",
          "83:   it('upgrade a proxy by upgrading its beacon', async function () {",
          "84:     const beacon = await UpgradeableBeacon.new(this.implementationV0.address);",
          "86:     const value = '10';",
          "87:     const data = this.implementationV0.contract.methods.initializeNonPayableWithValue(value).encodeABI();",
          "88:     const proxy = await BeaconProxy.new(beacon.address, data);",
          "90:     const dummy = new DummyImplementation(proxy.address);",
          "93:     expect(await dummy.value()).to.bignumber.eq(value);",
          "96:     expect(await dummy.version()).to.eq('V1');",
          "99:     await beacon.upgradeTo(this.implementationV1.address);",
          "102:     expect(await dummy.version()).to.eq('V2');",
          "103:   });",
          "105:   it('upgrade 2 proxies by upgrading shared beacon', async function () {",
          "106:     const value1 = '10';",
          "107:     const value2 = '42';",
          "109:     const beacon = await UpgradeableBeacon.new(this.implementationV0.address);",
          "111:     const proxy1InitializeData = this.implementationV0.contract.methods",
          "112:       .initializeNonPayableWithValue(value1)",
          "113:       .encodeABI();",
          "114:     const proxy1 = await BeaconProxy.new(beacon.address, proxy1InitializeData);",
          "116:     const proxy2InitializeData = this.implementationV0.contract.methods",
          "117:       .initializeNonPayableWithValue(value2)",
          "118:       .encodeABI();",
          "119:     const proxy2 = await BeaconProxy.new(beacon.address, proxy2InitializeData);",
          "121:     const dummy1 = new DummyImplementation(proxy1.address);",
          "122:     const dummy2 = new DummyImplementation(proxy2.address);",
          "125:     expect(await dummy1.value()).to.bignumber.eq(value1);",
          "126:     expect(await dummy2.value()).to.bignumber.eq(value2);",
          "129:     expect(await dummy1.version()).to.eq('V1');",
          "130:     expect(await dummy2.version()).to.eq('V1');",
          "133:     await beacon.upgradeTo(this.implementationV1.address);",
          "136:     expect(await dummy1.version()).to.eq('V2');",
          "137:     expect(await dummy2.version()).to.eq('V2');",
          "138:   });",
          "139: });",
          "",
          "---------------"
        ],
        "test/proxy/beacon/UpgradeableBeacon.test.js||test/proxy/beacon/UpgradeableBeacon.test.js": [
          "File: test/proxy/beacon/UpgradeableBeacon.test.js -> test/proxy/beacon/UpgradeableBeacon.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectRevert, expectEvent } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "4: const UpgradeableBeacon = artifacts.require('UpgradeableBeacon');",
          "5: const Implementation1 = artifacts.require('Implementation1');",
          "6: const Implementation2 = artifacts.require('Implementation2');",
          "8: contract('UpgradeableBeacon', function (accounts) {",
          "9:   const [owner, other] = accounts;",
          "11:   it('cannot be created with non-contract implementation', async function () {",
          "12:     await expectRevert(UpgradeableBeacon.new(accounts[0]), 'UpgradeableBeacon: implementation is not a contract');",
          "13:   });",
          "15:   context('once deployed', async function () {",
          "16:     beforeEach('deploying beacon', async function () {",
          "17:       this.v1 = await Implementation1.new();",
          "18:       this.beacon = await UpgradeableBeacon.new(this.v1.address, { from: owner });",
          "19:     });",
          "21:     it('returns implementation', async function () {",
          "22:       expect(await this.beacon.implementation()).to.equal(this.v1.address);",
          "23:     });",
          "25:     it('can be upgraded by the owner', async function () {",
          "26:       const v2 = await Implementation2.new();",
          "27:       const receipt = await this.beacon.upgradeTo(v2.address, { from: owner });",
          "28:       expectEvent(receipt, 'Upgraded', { implementation: v2.address });",
          "29:       expect(await this.beacon.implementation()).to.equal(v2.address);",
          "30:     });",
          "32:     it('cannot be upgraded to a non-contract', async function () {",
          "33:       await expectRevert(",
          "34:         this.beacon.upgradeTo(other, { from: owner }),",
          "35:         'UpgradeableBeacon: implementation is not a contract',",
          "36:       );",
          "37:     });",
          "39:     it('cannot be upgraded by other account', async function () {",
          "40:       const v2 = await Implementation2.new();",
          "41:       await expectRevert(this.beacon.upgradeTo(v2.address, { from: other }), 'Ownable: caller is not the owner');",
          "42:     });",
          "43:   });",
          "44: });",
          "",
          "---------------"
        ],
        "test/proxy/transparent/ProxyAdmin.test.js||test/proxy/transparent/ProxyAdmin.test.js": [
          "File: test/proxy/transparent/ProxyAdmin.test.js -> test/proxy/transparent/ProxyAdmin.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const ImplV1 = artifacts.require('DummyImplementation');",
          "6: const ImplV2 = artifacts.require('DummyImplementationV2');",
          "7: const ProxyAdmin = artifacts.require('ProxyAdmin');",
          "8: const TransparentUpgradeableProxy = artifacts.require('TransparentUpgradeableProxy');",
          "9: const ITransparentUpgradeableProxy = artifacts.require('ITransparentUpgradeableProxy');",
          "11: contract('ProxyAdmin', function (accounts) {",
          "12:   const [proxyAdminOwner, newAdmin, anotherAccount] = accounts;",
          "14:   before('set implementations', async function () {",
          "15:     this.implementationV1 = await ImplV1.new();",
          "16:     this.implementationV2 = await ImplV2.new();",
          "17:   });",
          "19:   beforeEach(async function () {",
          "20:     const initializeData = Buffer.from('');",
          "21:     this.proxyAdmin = await ProxyAdmin.new({ from: proxyAdminOwner });",
          "22:     const proxy = await TransparentUpgradeableProxy.new(",
          "23:       this.implementationV1.address,",
          "24:       this.proxyAdmin.address,",
          "25:       initializeData,",
          "26:       { from: proxyAdminOwner },",
          "27:     );",
          "28:     this.proxy = await ITransparentUpgradeableProxy.at(proxy.address);",
          "29:   });",
          "31:   it('has an owner', async function () {",
          "32:     expect(await this.proxyAdmin.owner()).to.equal(proxyAdminOwner);",
          "33:   });",
          "35:   describe('#getProxyAdmin', function () {",
          "36:     it('returns proxyAdmin as admin of the proxy', async function () {",
          "37:       const admin = await this.proxyAdmin.getProxyAdmin(this.proxy.address);",
          "38:       expect(admin).to.be.equal(this.proxyAdmin.address);",
          "39:     });",
          "41:     it('call to invalid proxy', async function () {",
          "42:       await expectRevert.unspecified(this.proxyAdmin.getProxyAdmin(this.implementationV1.address));",
          "43:     });",
          "44:   });",
          "46:   describe('#changeProxyAdmin', function () {",
          "47:     it('fails to change proxy admin if its not the proxy owner', async function () {",
          "48:       await expectRevert(",
          "49:         this.proxyAdmin.changeProxyAdmin(this.proxy.address, newAdmin, { from: anotherAccount }),",
          "50:         'caller is not the owner',",
          "51:       );",
          "52:     });",
          "54:     it('changes proxy admin', async function () {",
          "55:       await this.proxyAdmin.changeProxyAdmin(this.proxy.address, newAdmin, { from: proxyAdminOwner });",
          "56:       expect(await this.proxy.admin.call({ from: newAdmin })).to.eq(newAdmin);",
          "57:     });",
          "58:   });",
          "60:   describe('#getProxyImplementation', function () {",
          "61:     it('returns proxy implementation address', async function () {",
          "62:       const implementationAddress = await this.proxyAdmin.getProxyImplementation(this.proxy.address);",
          "63:       expect(implementationAddress).to.be.equal(this.implementationV1.address);",
          "64:     });",
          "66:     it('call to invalid proxy', async function () {",
          "67:       await expectRevert.unspecified(this.proxyAdmin.getProxyImplementation(this.implementationV1.address));",
          "68:     });",
          "69:   });",
          "71:   describe('#upgrade', function () {",
          "72:     context('with unauthorized account', function () {",
          "73:       it('fails to upgrade', async function () {",
          "74:         await expectRevert(",
          "75:           this.proxyAdmin.upgrade(this.proxy.address, this.implementationV2.address, { from: anotherAccount }),",
          "76:           'caller is not the owner',",
          "77:         );",
          "78:       });",
          "79:     });",
          "81:     context('with authorized account', function () {",
          "82:       it('upgrades implementation', async function () {",
          "83:         await this.proxyAdmin.upgrade(this.proxy.address, this.implementationV2.address, { from: proxyAdminOwner });",
          "84:         const implementationAddress = await this.proxyAdmin.getProxyImplementation(this.proxy.address);",
          "85:         expect(implementationAddress).to.be.equal(this.implementationV2.address);",
          "86:       });",
          "87:     });",
          "88:   });",
          "90:   describe('#upgradeAndCall', function () {",
          "91:     context('with unauthorized account', function () {",
          "92:       it('fails to upgrade', async function () {",
          "93:         const callData = new ImplV1('').contract.methods.initializeNonPayableWithValue(1337).encodeABI();",
          "94:         await expectRevert(",
          "95:           this.proxyAdmin.upgradeAndCall(this.proxy.address, this.implementationV2.address, callData, {",
          "96:             from: anotherAccount,",
          "97:           }),",
          "98:           'caller is not the owner',",
          "99:         );",
          "100:       });",
          "101:     });",
          "103:     context('with authorized account', function () {",
          "104:       context('with invalid callData', function () {",
          "105:         it('fails to upgrade', async function () {",
          "106:           const callData = '0x12345678';",
          "107:           await expectRevert.unspecified(",
          "108:             this.proxyAdmin.upgradeAndCall(this.proxy.address, this.implementationV2.address, callData, {",
          "109:               from: proxyAdminOwner,",
          "110:             }),",
          "111:           );",
          "112:         });",
          "113:       });",
          "115:       context('with valid callData', function () {",
          "116:         it('upgrades implementation', async function () {",
          "117:           const callData = new ImplV1('').contract.methods.initializeNonPayableWithValue(1337).encodeABI();",
          "118:           await this.proxyAdmin.upgradeAndCall(this.proxy.address, this.implementationV2.address, callData, {",
          "119:             from: proxyAdminOwner,",
          "120:           });",
          "121:           const implementationAddress = await this.proxyAdmin.getProxyImplementation(this.proxy.address);",
          "122:           expect(implementationAddress).to.be.equal(this.implementationV2.address);",
          "123:         });",
          "124:       });",
          "125:     });",
          "126:   });",
          "127: });",
          "",
          "---------------"
        ],
        "test/proxy/transparent/TransparentUpgradeableProxy.behaviour.js||test/proxy/transparent/TransparentUpgradeableProxy.behaviour.js": [
          "File: test/proxy/transparent/TransparentUpgradeableProxy.behaviour.js -> test/proxy/transparent/TransparentUpgradeableProxy.behaviour.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, expectRevert, expectEvent, constants } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS } = constants;",
          "3: const { getSlot, ImplementationSlot, AdminSlot } = require('../../helpers/erc1967');",
          "5: const { expect } = require('chai');",
          "6: const { web3 } = require('hardhat');",
          "8: const Implementation1 = artifacts.require('Implementation1');",
          "9: const Implementation2 = artifacts.require('Implementation2');",
          "10: const Implementation3 = artifacts.require('Implementation3');",
          "11: const Implementation4 = artifacts.require('Implementation4');",
          "12: const MigratableMockV1 = artifacts.require('MigratableMockV1');",
          "13: const MigratableMockV2 = artifacts.require('MigratableMockV2');",
          "14: const MigratableMockV3 = artifacts.require('MigratableMockV3');",
          "15: const InitializableMock = artifacts.require('InitializableMock');",
          "16: const DummyImplementation = artifacts.require('DummyImplementation');",
          "17: const ClashingImplementation = artifacts.require('ClashingImplementation');",
          "19: module.exports = function shouldBehaveLikeTransparentUpgradeableProxy(createProxy, accounts) {",
          "20:   const [proxyAdminAddress, proxyAdminOwner, anotherAccount] = accounts;",
          "22:   before(async function () {",
          "23:     this.implementationV0 = (await DummyImplementation.new()).address;",
          "24:     this.implementationV1 = (await DummyImplementation.new()).address;",
          "25:   });",
          "27:   beforeEach(async function () {",
          "28:     const initializeData = Buffer.from('');",
          "29:     this.proxy = await createProxy(this.implementationV0, proxyAdminAddress, initializeData, {",
          "30:       from: proxyAdminOwner,",
          "31:     });",
          "32:     this.proxyAddress = this.proxy.address;",
          "33:   });",
          "35:   describe('implementation', function () {",
          "36:     it('returns the current implementation address', async function () {",
          "37:       const implementation = await this.proxy.implementation({ from: proxyAdminAddress });",
          "39:       expect(implementation).to.be.equal(this.implementationV0);",
          "40:     });",
          "42:     it('delegates to the implementation', async function () {",
          "43:       const dummy = new DummyImplementation(this.proxyAddress);",
          "44:       const value = await dummy.get();",
          "46:       expect(value).to.equal(true);",
          "47:     });",
          "48:   });",
          "50:   describe('upgradeTo', function () {",
          "51:     describe('when the sender is the admin', function () {",
          "52:       const from = proxyAdminAddress;",
          "54:       describe('when the given implementation is different from the current one', function () {",
          "55:         it('upgrades to the requested implementation', async function () {",
          "56:           await this.proxy.upgradeTo(this.implementationV1, { from });",
          "58:           const implementation = await this.proxy.implementation({ from: proxyAdminAddress });",
          "59:           expect(implementation).to.be.equal(this.implementationV1);",
          "60:         });",
          "62:         it('emits an event', async function () {",
          "63:           expectEvent(await this.proxy.upgradeTo(this.implementationV1, { from }), 'Upgraded', {",
          "64:             implementation: this.implementationV1,",
          "65:           });",
          "66:         });",
          "67:       });",
          "69:       describe('when the given implementation is the zero address', function () {",
          "70:         it('reverts', async function () {",
          "71:           await expectRevert(",
          "72:             this.proxy.upgradeTo(ZERO_ADDRESS, { from }),",
          "73:             'ERC1967: new implementation is not a contract',",
          "74:           );",
          "75:         });",
          "76:       });",
          "77:     });",
          "79:     describe('when the sender is not the admin', function () {",
          "80:       const from = anotherAccount;",
          "82:       it('reverts', async function () {",
          "83:         await expectRevert.unspecified(this.proxy.upgradeTo(this.implementationV1, { from }));",
          "84:       });",
          "85:     });",
          "86:   });",
          "88:   describe('upgradeToAndCall', function () {",
          "89:     describe('without migrations', function () {",
          "90:       beforeEach(async function () {",
          "91:         this.behavior = await InitializableMock.new();",
          "92:       });",
          "94:       describe('when the call does not fail', function () {",
          "95:         const initializeData = new InitializableMock('').contract.methods['initializeWithX(uint256)'](42).encodeABI();",
          "97:         describe('when the sender is the admin', function () {",
          "98:           const from = proxyAdminAddress;",
          "99:           const value = 1e5;",
          "101:           beforeEach(async function () {",
          "102:             this.receipt = await this.proxy.upgradeToAndCall(this.behavior.address, initializeData, { from, value });",
          "103:           });",
          "105:           it('upgrades to the requested implementation', async function () {",
          "106:             const implementation = await this.proxy.implementation({ from: proxyAdminAddress });",
          "107:             expect(implementation).to.be.equal(this.behavior.address);",
          "108:           });",
          "110:           it('emits an event', function () {",
          "111:             expectEvent(this.receipt, 'Upgraded', { implementation: this.behavior.address });",
          "112:           });",
          "114:           it('calls the initializer function', async function () {",
          "115:             const migratable = new InitializableMock(this.proxyAddress);",
          "116:             const x = await migratable.x();",
          "117:             expect(x).to.be.bignumber.equal('42');",
          "118:           });",
          "120:           it('sends given value to the proxy', async function () {",
          "121:             const balance = await web3.eth.getBalance(this.proxyAddress);",
          "122:             expect(balance.toString()).to.be.bignumber.equal(value.toString());",
          "123:           });",
          "125:           it('uses the storage of the proxy', async function () {",
          "129:             const storedValue = await web3.eth.getStorageAt(this.proxyAddress, 1);",
          "130:             expect(parseInt(storedValue)).to.eq(42);",
          "131:           });",
          "132:         });",
          "134:         describe('when the sender is not the admin', function () {",
          "135:           it('reverts', async function () {",
          "136:             await expectRevert.unspecified(",
          "137:               this.proxy.upgradeToAndCall(this.behavior.address, initializeData, { from: anotherAccount }),",
          "138:             );",
          "139:           });",
          "140:         });",
          "141:       });",
          "143:       describe('when the call does fail', function () {",
          "144:         const initializeData = new InitializableMock('').contract.methods.fail().encodeABI();",
          "146:         it('reverts', async function () {",
          "147:           await expectRevert.unspecified(",
          "148:             this.proxy.upgradeToAndCall(this.behavior.address, initializeData, { from: proxyAdminAddress }),",
          "149:           );",
          "150:         });",
          "151:       });",
          "152:     });",
          "154:     describe('with migrations', function () {",
          "155:       describe('when the sender is the admin', function () {",
          "156:         const from = proxyAdminAddress;",
          "157:         const value = 1e5;",
          "159:         describe('when upgrading to V1', function () {",
          "160:           const v1MigrationData = new MigratableMockV1('').contract.methods.initialize(42).encodeABI();",
          "162:           beforeEach(async function () {",
          "163:             this.behaviorV1 = await MigratableMockV1.new();",
          "164:             this.balancePreviousV1 = new BN(await web3.eth.getBalance(this.proxyAddress));",
          "165:             this.receipt = await this.proxy.upgradeToAndCall(this.behaviorV1.address, v1MigrationData, { from, value });",
          "166:           });",
          "168:           it('upgrades to the requested version and emits an event', async function () {",
          "169:             const implementation = await this.proxy.implementation({ from: proxyAdminAddress });",
          "170:             expect(implementation).to.be.equal(this.behaviorV1.address);",
          "171:             expectEvent(this.receipt, 'Upgraded', { implementation: this.behaviorV1.address });",
          "172:           });",
          "174:           it(\"calls the 'initialize' function and sends given value to the proxy\", async function () {",
          "175:             const migratable = new MigratableMockV1(this.proxyAddress);",
          "177:             const x = await migratable.x();",
          "178:             expect(x).to.be.bignumber.equal('42');",
          "180:             const balance = await web3.eth.getBalance(this.proxyAddress);",
          "181:             expect(new BN(balance)).to.be.bignumber.equal(this.balancePreviousV1.addn(value));",
          "182:           });",
          "184:           describe('when upgrading to V2', function () {",
          "185:             const v2MigrationData = new MigratableMockV2('').contract.methods.migrate(10, 42).encodeABI();",
          "187:             beforeEach(async function () {",
          "188:               this.behaviorV2 = await MigratableMockV2.new();",
          "189:               this.balancePreviousV2 = new BN(await web3.eth.getBalance(this.proxyAddress));",
          "190:               this.receipt = await this.proxy.upgradeToAndCall(this.behaviorV2.address, v2MigrationData, {",
          "191:                 from,",
          "192:                 value,",
          "193:               });",
          "194:             });",
          "196:             it('upgrades to the requested version and emits an event', async function () {",
          "197:               const implementation = await this.proxy.implementation({ from: proxyAdminAddress });",
          "198:               expect(implementation).to.be.equal(this.behaviorV2.address);",
          "199:               expectEvent(this.receipt, 'Upgraded', { implementation: this.behaviorV2.address });",
          "200:             });",
          "202:             it(\"calls the 'migrate' function and sends given value to the proxy\", async function () {",
          "203:               const migratable = new MigratableMockV2(this.proxyAddress);",
          "205:               const x = await migratable.x();",
          "206:               expect(x).to.be.bignumber.equal('10');",
          "208:               const y = await migratable.y();",
          "209:               expect(y).to.be.bignumber.equal('42');",
          "211:               const balance = new BN(await web3.eth.getBalance(this.proxyAddress));",
          "212:               expect(balance).to.be.bignumber.equal(this.balancePreviousV2.addn(value));",
          "213:             });",
          "215:             describe('when upgrading to V3', function () {",
          "216:               const v3MigrationData = new MigratableMockV3('').contract.methods['migrate()']().encodeABI();",
          "218:               beforeEach(async function () {",
          "219:                 this.behaviorV3 = await MigratableMockV3.new();",
          "220:                 this.balancePreviousV3 = new BN(await web3.eth.getBalance(this.proxyAddress));",
          "221:                 this.receipt = await this.proxy.upgradeToAndCall(this.behaviorV3.address, v3MigrationData, {",
          "222:                   from,",
          "223:                   value,",
          "224:                 });",
          "225:               });",
          "227:               it('upgrades to the requested version and emits an event', async function () {",
          "228:                 const implementation = await this.proxy.implementation({ from: proxyAdminAddress });",
          "229:                 expect(implementation).to.be.equal(this.behaviorV3.address);",
          "230:                 expectEvent(this.receipt, 'Upgraded', { implementation: this.behaviorV3.address });",
          "231:               });",
          "233:               it(\"calls the 'migrate' function and sends given value to the proxy\", async function () {",
          "234:                 const migratable = new MigratableMockV3(this.proxyAddress);",
          "236:                 const x = await migratable.x();",
          "237:                 expect(x).to.be.bignumber.equal('42');",
          "239:                 const y = await migratable.y();",
          "240:                 expect(y).to.be.bignumber.equal('10');",
          "242:                 const balance = new BN(await web3.eth.getBalance(this.proxyAddress));",
          "243:                 expect(balance).to.be.bignumber.equal(this.balancePreviousV3.addn(value));",
          "244:               });",
          "245:             });",
          "246:           });",
          "247:         });",
          "248:       });",
          "250:       describe('when the sender is not the admin', function () {",
          "251:         const from = anotherAccount;",
          "253:         it('reverts', async function () {",
          "254:           const behaviorV1 = await MigratableMockV1.new();",
          "255:           const v1MigrationData = new MigratableMockV1('').contract.methods.initialize(42).encodeABI();",
          "256:           await expectRevert.unspecified(this.proxy.upgradeToAndCall(behaviorV1.address, v1MigrationData, { from }));",
          "257:         });",
          "258:       });",
          "259:     });",
          "260:   });",
          "262:   describe('changeAdmin', function () {",
          "263:     describe('when the new proposed admin is not the zero address', function () {",
          "264:       const newAdmin = anotherAccount;",
          "266:       describe('when the sender is the admin', function () {",
          "267:         beforeEach('transferring', async function () {",
          "268:           this.receipt = await this.proxy.changeAdmin(newAdmin, { from: proxyAdminAddress });",
          "269:         });",
          "271:         it('assigns new proxy admin', async function () {",
          "272:           const newProxyAdmin = await this.proxy.admin({ from: newAdmin });",
          "273:           expect(newProxyAdmin).to.be.equal(anotherAccount);",
          "274:         });",
          "276:         it('emits an event', function () {",
          "277:           expectEvent(this.receipt, 'AdminChanged', {",
          "278:             previousAdmin: proxyAdminAddress,",
          "279:             newAdmin: newAdmin,",
          "280:           });",
          "281:         });",
          "282:       });",
          "284:       describe('when the sender is not the admin', function () {",
          "285:         it('reverts', async function () {",
          "286:           await expectRevert.unspecified(this.proxy.changeAdmin(newAdmin, { from: anotherAccount }));",
          "287:         });",
          "288:       });",
          "289:     });",
          "291:     describe('when the new proposed admin is the zero address', function () {",
          "292:       it('reverts', async function () {",
          "293:         await expectRevert(",
          "294:           this.proxy.changeAdmin(ZERO_ADDRESS, { from: proxyAdminAddress }),",
          "295:           'ERC1967: new admin is the zero address',",
          "296:         );",
          "297:       });",
          "298:     });",
          "299:   });",
          "301:   describe('storage', function () {",
          "302:     it('should store the implementation address in specified location', async function () {",
          "303:       const implementationSlot = await getSlot(this.proxy, ImplementationSlot);",
          "304:       const implementationAddress = web3.utils.toChecksumAddress(implementationSlot.substr(-40));",
          "305:       expect(implementationAddress).to.be.equal(this.implementationV0);",
          "306:     });",
          "308:     it('should store the admin proxy in specified location', async function () {",
          "309:       const proxyAdminSlot = await getSlot(this.proxy, AdminSlot);",
          "310:       const proxyAdminAddress = web3.utils.toChecksumAddress(proxyAdminSlot.substr(-40));",
          "311:       expect(proxyAdminAddress).to.be.equal(proxyAdminAddress);",
          "312:     });",
          "313:   });",
          "315:   describe('transparent proxy', function () {",
          "316:     beforeEach('creating proxy', async function () {",
          "317:       const initializeData = Buffer.from('');",
          "318:       this.impl = await ClashingImplementation.new();",
          "319:       this.proxy = await createProxy(this.impl.address, proxyAdminAddress, initializeData, { from: proxyAdminOwner });",
          "321:       this.clashing = new ClashingImplementation(this.proxy.address);",
          "322:     });",
          "324:     it('proxy admin cannot call delegated functions', async function () {",
          "325:       await expectRevert(",
          "326:         this.clashing.delegatedFunction({ from: proxyAdminAddress }),",
          "327:         'TransparentUpgradeableProxy: admin cannot fallback to proxy target',",
          "328:       );",
          "329:     });",
          "331:     describe('when function names clash', function () {",
          "332:       it('when sender is proxy admin should run the proxy function', async function () {",
          "333:         const value = await this.proxy.admin({ from: proxyAdminAddress, value: 0 });",
          "334:         expect(value).to.be.equal(proxyAdminAddress);",
          "335:       });",
          "337:       it('when sender is other should delegate to implementation', async function () {",
          "338:         const value = await this.proxy.admin({ from: anotherAccount, value: 0 });",
          "339:         expect(value).to.be.equal('0x0000000000000000000000000000000011111142');",
          "340:       });",
          "342:       it('when sender is proxy admin value should not be accepted', async function () {",
          "343:         await expectRevert.unspecified(this.proxy.admin({ from: proxyAdminAddress, value: 1 }));",
          "344:       });",
          "346:       it('when sender is other value should be accepted', async function () {",
          "347:         const value = await this.proxy.admin({ from: anotherAccount, value: 1 });",
          "348:         expect(value).to.be.equal('0x0000000000000000000000000000000011111142');",
          "349:       });",
          "350:     });",
          "351:   });",
          "353:   describe('regression', () => {",
          "354:     const initializeData = Buffer.from('');",
          "356:     it('should add new function', async () => {",
          "357:       const instance1 = await Implementation1.new();",
          "358:       const proxy = await createProxy(instance1.address, proxyAdminAddress, initializeData, { from: proxyAdminOwner });",
          "360:       const proxyInstance1 = new Implementation1(proxy.address);",
          "361:       await proxyInstance1.setValue(42);",
          "363:       const instance2 = await Implementation2.new();",
          "364:       await proxy.upgradeTo(instance2.address, { from: proxyAdminAddress });",
          "366:       const proxyInstance2 = new Implementation2(proxy.address);",
          "367:       const res = await proxyInstance2.getValue();",
          "368:       expect(res.toString()).to.eq('42');",
          "369:     });",
          "371:     it('should remove function', async () => {",
          "372:       const instance2 = await Implementation2.new();",
          "373:       const proxy = await createProxy(instance2.address, proxyAdminAddress, initializeData, { from: proxyAdminOwner });",
          "375:       const proxyInstance2 = new Implementation2(proxy.address);",
          "376:       await proxyInstance2.setValue(42);",
          "377:       const res = await proxyInstance2.getValue();",
          "378:       expect(res.toString()).to.eq('42');",
          "380:       const instance1 = await Implementation1.new();",
          "381:       await proxy.upgradeTo(instance1.address, { from: proxyAdminAddress });",
          "383:       const proxyInstance1 = new Implementation2(proxy.address);",
          "384:       await expectRevert.unspecified(proxyInstance1.getValue());",
          "385:     });",
          "387:     it('should change function signature', async () => {",
          "388:       const instance1 = await Implementation1.new();",
          "389:       const proxy = await createProxy(instance1.address, proxyAdminAddress, initializeData, { from: proxyAdminOwner });",
          "391:       const proxyInstance1 = new Implementation1(proxy.address);",
          "392:       await proxyInstance1.setValue(42);",
          "394:       const instance3 = await Implementation3.new();",
          "395:       await proxy.upgradeTo(instance3.address, { from: proxyAdminAddress });",
          "396:       const proxyInstance3 = new Implementation3(proxy.address);",
          "398:       const res = await proxyInstance3.getValue(8);",
          "399:       expect(res.toString()).to.eq('50');",
          "400:     });",
          "402:     it('should add fallback function', async () => {",
          "403:       const initializeData = Buffer.from('');",
          "404:       const instance1 = await Implementation1.new();",
          "405:       const proxy = await createProxy(instance1.address, proxyAdminAddress, initializeData, { from: proxyAdminOwner });",
          "407:       const instance4 = await Implementation4.new();",
          "408:       await proxy.upgradeTo(instance4.address, { from: proxyAdminAddress });",
          "409:       const proxyInstance4 = new Implementation4(proxy.address);",
          "411:       const data = '0x';",
          "412:       await web3.eth.sendTransaction({ to: proxy.address, from: anotherAccount, data });",
          "414:       const res = await proxyInstance4.getValue();",
          "415:       expect(res.toString()).to.eq('1');",
          "416:     });",
          "418:     it('should remove fallback function', async () => {",
          "419:       const instance4 = await Implementation4.new();",
          "420:       const proxy = await createProxy(instance4.address, proxyAdminAddress, initializeData, { from: proxyAdminOwner });",
          "422:       const instance2 = await Implementation2.new();",
          "423:       await proxy.upgradeTo(instance2.address, { from: proxyAdminAddress });",
          "425:       const data = '0x';",
          "426:       await expectRevert.unspecified(web3.eth.sendTransaction({ to: proxy.address, from: anotherAccount, data }));",
          "428:       const proxyInstance2 = new Implementation2(proxy.address);",
          "429:       const res = await proxyInstance2.getValue();",
          "430:       expect(res.toString()).to.eq('0');",
          "431:     });",
          "432:   });",
          "433: };",
          "",
          "---------------"
        ],
        "test/proxy/transparent/TransparentUpgradeableProxy.test.js||test/proxy/transparent/TransparentUpgradeableProxy.test.js": [
          "File: test/proxy/transparent/TransparentUpgradeableProxy.test.js -> test/proxy/transparent/TransparentUpgradeableProxy.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const shouldBehaveLikeProxy = require('../Proxy.behaviour');",
          "2: const shouldBehaveLikeTransparentUpgradeableProxy = require('./TransparentUpgradeableProxy.behaviour');",
          "4: const TransparentUpgradeableProxy = artifacts.require('TransparentUpgradeableProxy');",
          "5: const ITransparentUpgradeableProxy = artifacts.require('ITransparentUpgradeableProxy');",
          "7: contract('TransparentUpgradeableProxy', function (accounts) {",
          "8:   const [proxyAdminAddress, proxyAdminOwner] = accounts;",
          "10:   const createProxy = async function (logic, admin, initData, opts) {",
          "11:     const { address } = await TransparentUpgradeableProxy.new(logic, admin, initData, opts);",
          "12:     return ITransparentUpgradeableProxy.at(address);",
          "13:   };",
          "15:   shouldBehaveLikeProxy(createProxy, proxyAdminAddress, proxyAdminOwner);",
          "16:   shouldBehaveLikeTransparentUpgradeableProxy(createProxy, accounts);",
          "17: });",
          "",
          "---------------"
        ],
        "test/proxy/utils/Initializable.test.js||test/proxy/utils/Initializable.test.js": [
          "File: test/proxy/utils/Initializable.test.js -> test/proxy/utils/Initializable.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "4: const InitializableMock = artifacts.require('InitializableMock');",
          "5: const ConstructorInitializableMock = artifacts.require('ConstructorInitializableMock');",
          "6: const ChildConstructorInitializableMock = artifacts.require('ChildConstructorInitializableMock');",
          "7: const ReinitializerMock = artifacts.require('ReinitializerMock');",
          "8: const SampleChild = artifacts.require('SampleChild');",
          "9: const DisableBad1 = artifacts.require('DisableBad1');",
          "10: const DisableBad2 = artifacts.require('DisableBad2');",
          "11: const DisableOk = artifacts.require('DisableOk');",
          "13: contract('Initializable', function () {",
          "14:   describe('basic testing without inheritance', function () {",
          "15:     beforeEach('deploying', async function () {",
          "16:       this.contract = await InitializableMock.new();",
          "17:     });",
          "19:     describe('before initialize', function () {",
          "20:       it('initializer has not run', async function () {",
          "21:         expect(await this.contract.initializerRan()).to.equal(false);",
          "22:       });",
          "24:       it('_initializing returns false before initialization', async function () {",
          "25:         expect(await this.contract.isInitializing()).to.equal(false);",
          "26:       });",
          "27:     });",
          "29:     describe('after initialize', function () {",
          "30:       beforeEach('initializing', async function () {",
          "31:         await this.contract.initialize();",
          "32:       });",
          "34:       it('initializer has run', async function () {",
          "35:         expect(await this.contract.initializerRan()).to.equal(true);",
          "36:       });",
          "38:       it('_initializing returns false after initialization', async function () {",
          "39:         expect(await this.contract.isInitializing()).to.equal(false);",
          "40:       });",
          "42:       it('initializer does not run again', async function () {",
          "43:         await expectRevert(this.contract.initialize(), 'Initializable: contract is already initialized');",
          "44:       });",
          "45:     });",
          "47:     describe('nested under an initializer', function () {",
          "48:       it('initializer modifier reverts', async function () {",
          "49:         await expectRevert(this.contract.initializerNested(), 'Initializable: contract is already initialized');",
          "50:       });",
          "52:       it('onlyInitializing modifier succeeds', async function () {",
          "53:         await this.contract.onlyInitializingNested();",
          "54:         expect(await this.contract.onlyInitializingRan()).to.equal(true);",
          "55:       });",
          "56:     });",
          "58:     it('cannot call onlyInitializable function outside the scope of an initializable function', async function () {",
          "59:       await expectRevert(this.contract.initializeOnlyInitializing(), 'Initializable: contract is not initializing');",
          "60:     });",
          "61:   });",
          "63:   it('nested initializer can run during construction', async function () {",
          "64:     const contract2 = await ConstructorInitializableMock.new();",
          "65:     expect(await contract2.initializerRan()).to.equal(true);",
          "66:     expect(await contract2.onlyInitializingRan()).to.equal(true);",
          "67:   });",
          "69:   it('multiple constructor levels can be initializers', async function () {",
          "70:     const contract2 = await ChildConstructorInitializableMock.new();",
          "71:     expect(await contract2.initializerRan()).to.equal(true);",
          "72:     expect(await contract2.childInitializerRan()).to.equal(true);",
          "73:     expect(await contract2.onlyInitializingRan()).to.equal(true);",
          "74:   });",
          "76:   describe('reinitialization', function () {",
          "77:     beforeEach('deploying', async function () {",
          "78:       this.contract = await ReinitializerMock.new();",
          "79:     });",
          "81:     it('can reinitialize', async function () {",
          "82:       expect(await this.contract.counter()).to.be.bignumber.equal('0');",
          "83:       await this.contract.initialize();",
          "84:       expect(await this.contract.counter()).to.be.bignumber.equal('1');",
          "85:       await this.contract.reinitialize(2);",
          "86:       expect(await this.contract.counter()).to.be.bignumber.equal('2');",
          "87:       await this.contract.reinitialize(3);",
          "88:       expect(await this.contract.counter()).to.be.bignumber.equal('3');",
          "89:     });",
          "91:     it('can jump multiple steps', async function () {",
          "92:       expect(await this.contract.counter()).to.be.bignumber.equal('0');",
          "93:       await this.contract.initialize();",
          "94:       expect(await this.contract.counter()).to.be.bignumber.equal('1');",
          "95:       await this.contract.reinitialize(128);",
          "96:       expect(await this.contract.counter()).to.be.bignumber.equal('2');",
          "97:     });",
          "99:     it('cannot nest reinitializers', async function () {",
          "100:       expect(await this.contract.counter()).to.be.bignumber.equal('0');",
          "101:       await expectRevert(this.contract.nestedReinitialize(2, 2), 'Initializable: contract is already initialized');",
          "102:       await expectRevert(this.contract.nestedReinitialize(2, 3), 'Initializable: contract is already initialized');",
          "103:       await expectRevert(this.contract.nestedReinitialize(3, 2), 'Initializable: contract is already initialized');",
          "104:     });",
          "106:     it('can chain reinitializers', async function () {",
          "107:       expect(await this.contract.counter()).to.be.bignumber.equal('0');",
          "108:       await this.contract.chainReinitialize(2, 3);",
          "109:       expect(await this.contract.counter()).to.be.bignumber.equal('2');",
          "110:     });",
          "112:     it('_getInitializedVersion returns right version', async function () {",
          "113:       await this.contract.initialize();",
          "114:       expect(await this.contract.getInitializedVersion()).to.be.bignumber.equal('1');",
          "115:       await this.contract.reinitialize(12);",
          "116:       expect(await this.contract.getInitializedVersion()).to.be.bignumber.equal('12');",
          "117:     });",
          "119:     describe('contract locking', function () {",
          "120:       it('prevents initialization', async function () {",
          "121:         await this.contract.disableInitializers();",
          "122:         await expectRevert(this.contract.initialize(), 'Initializable: contract is already initialized');",
          "123:       });",
          "125:       it('prevents re-initialization', async function () {",
          "126:         await this.contract.disableInitializers();",
          "127:         await expectRevert(this.contract.reinitialize(255), 'Initializable: contract is already initialized');",
          "128:       });",
          "130:       it('can lock contract after initialization', async function () {",
          "131:         await this.contract.initialize();",
          "132:         await this.contract.disableInitializers();",
          "133:         await expectRevert(this.contract.reinitialize(255), 'Initializable: contract is already initialized');",
          "134:       });",
          "135:     });",
          "136:   });",
          "138:   describe('events', function () {",
          "139:     it('constructor initialization emits event', async function () {",
          "140:       const contract = await ConstructorInitializableMock.new();",
          "142:       await expectEvent.inTransaction(contract.transactionHash, contract, 'Initialized', { version: '1' });",
          "143:     });",
          "145:     it('initialization emits event', async function () {",
          "146:       const contract = await ReinitializerMock.new();",
          "148:       const { receipt } = await contract.initialize();",
          "149:       expect(receipt.logs.filter(({ event }) => event === 'Initialized').length).to.be.equal(1);",
          "150:       expectEvent(receipt, 'Initialized', { version: '1' });",
          "151:     });",
          "153:     it('reinitialization emits event', async function () {",
          "154:       const contract = await ReinitializerMock.new();",
          "156:       const { receipt } = await contract.reinitialize(128);",
          "157:       expect(receipt.logs.filter(({ event }) => event === 'Initialized').length).to.be.equal(1);",
          "158:       expectEvent(receipt, 'Initialized', { version: '128' });",
          "159:     });",
          "161:     it('chained reinitialization emits multiple events', async function () {",
          "162:       const contract = await ReinitializerMock.new();",
          "164:       const { receipt } = await contract.chainReinitialize(2, 3);",
          "165:       expect(receipt.logs.filter(({ event }) => event === 'Initialized').length).to.be.equal(2);",
          "166:       expectEvent(receipt, 'Initialized', { version: '2' });",
          "167:       expectEvent(receipt, 'Initialized', { version: '3' });",
          "168:     });",
          "169:   });",
          "171:   describe('complex testing with inheritance', function () {",
          "172:     const mother = '12';",
          "173:     const gramps = '56';",
          "174:     const father = '34';",
          "175:     const child = '78';",
          "177:     beforeEach('deploying', async function () {",
          "178:       this.contract = await SampleChild.new();",
          "179:     });",
          "181:     beforeEach('initializing', async function () {",
          "182:       await this.contract.initialize(mother, gramps, father, child);",
          "183:     });",
          "185:     it('initializes human', async function () {",
          "186:       expect(await this.contract.isHuman()).to.be.equal(true);",
          "187:     });",
          "189:     it('initializes mother', async function () {",
          "190:       expect(await this.contract.mother()).to.be.bignumber.equal(mother);",
          "191:     });",
          "193:     it('initializes gramps', async function () {",
          "194:       expect(await this.contract.gramps()).to.be.bignumber.equal(gramps);",
          "195:     });",
          "197:     it('initializes father', async function () {",
          "198:       expect(await this.contract.father()).to.be.bignumber.equal(father);",
          "199:     });",
          "201:     it('initializes child', async function () {",
          "202:       expect(await this.contract.child()).to.be.bignumber.equal(child);",
          "203:     });",
          "204:   });",
          "206:   describe('disabling initialization', function () {",
          "207:     it('old and new patterns in bad sequence', async function () {",
          "208:       await expectRevert(DisableBad1.new(), 'Initializable: contract is already initialized');",
          "209:       await expectRevert(DisableBad2.new(), 'Initializable: contract is initializing');",
          "210:     });",
          "212:     it('old and new patterns in good sequence', async function () {",
          "213:       const ok = await DisableOk.new();",
          "214:       await expectEvent.inConstruction(ok, 'Initialized', { version: '1' });",
          "215:       await expectEvent.inConstruction(ok, 'Initialized', { version: '255' });",
          "216:     });",
          "217:   });",
          "218: });",
          "",
          "---------------"
        ],
        "test/proxy/utils/UUPSUpgradeable.test.js||test/proxy/utils/UUPSUpgradeable.test.js": [
          "File: test/proxy/utils/UUPSUpgradeable.test.js -> test/proxy/utils/UUPSUpgradeable.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { web3 } = require('@openzeppelin/test-helpers/src/setup');",
          "3: const { getSlot, ImplementationSlot } = require('../../helpers/erc1967');",
          "5: const ERC1967Proxy = artifacts.require('ERC1967Proxy');",
          "6: const UUPSUpgradeableMock = artifacts.require('UUPSUpgradeableMock');",
          "7: const UUPSUpgradeableUnsafeMock = artifacts.require('UUPSUpgradeableUnsafeMock');",
          "8: const UUPSUpgradeableLegacyMock = artifacts.require('UUPSUpgradeableLegacyMock');",
          "9: const NonUpgradeableMock = artifacts.require('NonUpgradeableMock');",
          "11: contract('UUPSUpgradeable', function () {",
          "12:   before(async function () {",
          "13:     this.implInitial = await UUPSUpgradeableMock.new();",
          "14:     this.implUpgradeOk = await UUPSUpgradeableMock.new();",
          "15:     this.implUpgradeUnsafe = await UUPSUpgradeableUnsafeMock.new();",
          "16:     this.implUpgradeNonUUPS = await NonUpgradeableMock.new();",
          "17:   });",
          "19:   beforeEach(async function () {",
          "20:     const { address } = await ERC1967Proxy.new(this.implInitial.address, '0x');",
          "21:     this.instance = await UUPSUpgradeableMock.at(address);",
          "22:   });",
          "24:   it('upgrade to upgradeable implementation', async function () {",
          "25:     const { receipt } = await this.instance.upgradeTo(this.implUpgradeOk.address);",
          "26:     expect(receipt.logs.filter(({ event }) => event === 'Upgraded').length).to.be.equal(1);",
          "27:     expectEvent(receipt, 'Upgraded', { implementation: this.implUpgradeOk.address });",
          "28:   });",
          "30:   it('upgrade to upgradeable implementation with call', async function () {",
          "31:     expect(await this.instance.current()).to.be.bignumber.equal('0');",
          "33:     const { receipt } = await this.instance.upgradeToAndCall(",
          "34:       this.implUpgradeOk.address,",
          "35:       this.implUpgradeOk.contract.methods.increment().encodeABI(),",
          "36:     );",
          "37:     expect(receipt.logs.filter(({ event }) => event === 'Upgraded').length).to.be.equal(1);",
          "38:     expectEvent(receipt, 'Upgraded', { implementation: this.implUpgradeOk.address });",
          "40:     expect(await this.instance.current()).to.be.bignumber.equal('1');",
          "41:   });",
          "43:   it('upgrade to and unsafe upgradeable implementation', async function () {",
          "44:     const { receipt } = await this.instance.upgradeTo(this.implUpgradeUnsafe.address);",
          "45:     expectEvent(receipt, 'Upgraded', { implementation: this.implUpgradeUnsafe.address });",
          "46:   });",
          "49:   it('reject upgrade to non uups implementation', async function () {",
          "50:     await expectRevert(",
          "51:       this.instance.upgradeTo(this.implUpgradeNonUUPS.address),",
          "52:       'ERC1967Upgrade: new implementation is not UUPS',",
          "53:     );",
          "54:   });",
          "56:   it('reject proxy address as implementation', async function () {",
          "57:     const { address } = await ERC1967Proxy.new(this.implInitial.address, '0x');",
          "58:     const otherInstance = await UUPSUpgradeableMock.at(address);",
          "60:     await expectRevert(",
          "61:       this.instance.upgradeTo(otherInstance.address),",
          "62:       'ERC1967Upgrade: new implementation is not UUPS',",
          "63:     );",
          "64:   });",
          "66:   it('can upgrade from legacy implementations', async function () {",
          "67:     const legacyImpl = await UUPSUpgradeableLegacyMock.new();",
          "68:     const legacyInstance = await ERC1967Proxy.new(legacyImpl.address, '0x').then(({ address }) =>",
          "69:       UUPSUpgradeableLegacyMock.at(address),",
          "70:     );",
          "72:     const receipt = await legacyInstance.upgradeTo(this.implInitial.address);",
          "74:     const UpgradedEvents = receipt.logs.filter(",
          "75:       ({ address, event }) => address === legacyInstance.address && event === 'Upgraded',",
          "76:     );",
          "77:     expect(UpgradedEvents.length).to.be.equal(1);",
          "79:     expectEvent(receipt, 'Upgraded', { implementation: this.implInitial.address });",
          "81:     const implementationSlot = await getSlot(legacyInstance, ImplementationSlot);",
          "82:     const implementationAddress = web3.utils.toChecksumAddress(implementationSlot.substr(-40));",
          "83:     expect(implementationAddress).to.be.equal(this.implInitial.address);",
          "84:   });",
          "85: });",
          "",
          "---------------"
        ],
        "test/security/Pausable.test.js||test/security/Pausable.test.js": [
          "File: test/security/Pausable.test.js -> test/security/Pausable.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const PausableMock = artifacts.require('PausableMock');",
          "7: contract('Pausable', function (accounts) {",
          "8:   const [pauser] = accounts;",
          "10:   beforeEach(async function () {",
          "11:     this.pausable = await PausableMock.new();",
          "12:   });",
          "14:   context('when unpaused', function () {",
          "15:     beforeEach(async function () {",
          "16:       expect(await this.pausable.paused()).to.equal(false);",
          "17:     });",
          "19:     it('can perform normal process in non-pause', async function () {",
          "20:       expect(await this.pausable.count()).to.be.bignumber.equal('0');",
          "22:       await this.pausable.normalProcess();",
          "23:       expect(await this.pausable.count()).to.be.bignumber.equal('1');",
          "24:     });",
          "26:     it('cannot take drastic measure in non-pause', async function () {",
          "27:       await expectRevert(this.pausable.drasticMeasure(), 'Pausable: not paused');",
          "28:       expect(await this.pausable.drasticMeasureTaken()).to.equal(false);",
          "29:     });",
          "31:     context('when paused', function () {",
          "32:       beforeEach(async function () {",
          "33:         this.receipt = await this.pausable.pause({ from: pauser });",
          "34:       });",
          "36:       it('emits a Paused event', function () {",
          "37:         expectEvent(this.receipt, 'Paused', { account: pauser });",
          "38:       });",
          "40:       it('cannot perform normal process in pause', async function () {",
          "41:         await expectRevert(this.pausable.normalProcess(), 'Pausable: paused');",
          "42:       });",
          "44:       it('can take a drastic measure in a pause', async function () {",
          "45:         await this.pausable.drasticMeasure();",
          "46:         expect(await this.pausable.drasticMeasureTaken()).to.equal(true);",
          "47:       });",
          "49:       it('reverts when re-pausing', async function () {",
          "50:         await expectRevert(this.pausable.pause(), 'Pausable: paused');",
          "51:       });",
          "53:       describe('unpausing', function () {",
          "54:         it('is unpausable by the pauser', async function () {",
          "55:           await this.pausable.unpause();",
          "56:           expect(await this.pausable.paused()).to.equal(false);",
          "57:         });",
          "59:         context('when unpaused', function () {",
          "60:           beforeEach(async function () {",
          "61:             this.receipt = await this.pausable.unpause({ from: pauser });",
          "62:           });",
          "64:           it('emits an Unpaused event', function () {",
          "65:             expectEvent(this.receipt, 'Unpaused', { account: pauser });",
          "66:           });",
          "68:           it('should resume allowing normal process', async function () {",
          "69:             expect(await this.pausable.count()).to.be.bignumber.equal('0');",
          "70:             await this.pausable.normalProcess();",
          "71:             expect(await this.pausable.count()).to.be.bignumber.equal('1');",
          "72:           });",
          "74:           it('should prevent drastic measure', async function () {",
          "75:             await expectRevert(this.pausable.drasticMeasure(), 'Pausable: not paused');",
          "76:           });",
          "78:           it('reverts when re-unpausing', async function () {",
          "79:             await expectRevert(this.pausable.unpause(), 'Pausable: not paused');",
          "80:           });",
          "81:         });",
          "82:       });",
          "83:     });",
          "84:   });",
          "85: });",
          "",
          "---------------"
        ],
        "test/security/PullPayment.test.js||test/security/PullPayment.test.js": [
          "File: test/security/PullPayment.test.js -> test/security/PullPayment.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { balance, ether } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const PullPaymentMock = artifacts.require('PullPaymentMock');",
          "7: contract('PullPayment', function (accounts) {",
          "8:   const [payer, payee1, payee2] = accounts;",
          "10:   const amount = ether('17');",
          "12:   beforeEach(async function () {",
          "13:     this.contract = await PullPaymentMock.new({ value: amount });",
          "14:   });",
          "16:   describe('payments', function () {",
          "17:     it('can record an async payment correctly', async function () {",
          "18:       await this.contract.callTransfer(payee1, 100, { from: payer });",
          "19:       expect(await this.contract.payments(payee1)).to.be.bignumber.equal('100');",
          "20:     });",
          "22:     it('can add multiple balances on one account', async function () {",
          "23:       await this.contract.callTransfer(payee1, 200, { from: payer });",
          "24:       await this.contract.callTransfer(payee1, 300, { from: payer });",
          "25:       expect(await this.contract.payments(payee1)).to.be.bignumber.equal('500');",
          "26:     });",
          "28:     it('can add balances on multiple accounts', async function () {",
          "29:       await this.contract.callTransfer(payee1, 200, { from: payer });",
          "30:       await this.contract.callTransfer(payee2, 300, { from: payer });",
          "32:       expect(await this.contract.payments(payee1)).to.be.bignumber.equal('200');",
          "34:       expect(await this.contract.payments(payee2)).to.be.bignumber.equal('300');",
          "35:     });",
          "36:   });",
          "38:   describe('withdrawPayments', function () {",
          "39:     it('can withdraw payment', async function () {",
          "40:       const balanceTracker = await balance.tracker(payee1);",
          "42:       await this.contract.callTransfer(payee1, amount, { from: payer });",
          "43:       expect(await this.contract.payments(payee1)).to.be.bignumber.equal(amount);",
          "45:       await this.contract.withdrawPayments(payee1);",
          "47:       expect(await balanceTracker.delta()).to.be.bignumber.equal(amount);",
          "48:       expect(await this.contract.payments(payee1)).to.be.bignumber.equal('0');",
          "49:     });",
          "50:   });",
          "51: });",
          "",
          "---------------"
        ],
        "test/security/ReentrancyGuard.test.js||test/security/ReentrancyGuard.test.js": [
          "File: test/security/ReentrancyGuard.test.js -> test/security/ReentrancyGuard.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const ReentrancyMock = artifacts.require('ReentrancyMock');",
          "6: const ReentrancyAttack = artifacts.require('ReentrancyAttack');",
          "8: contract('ReentrancyGuard', function () {",
          "9:   beforeEach(async function () {",
          "10:     this.reentrancyMock = await ReentrancyMock.new();",
          "11:     expect(await this.reentrancyMock.counter()).to.be.bignumber.equal('0');",
          "12:   });",
          "14:   it('nonReentrant function can be called', async function () {",
          "15:     expect(await this.reentrancyMock.counter()).to.be.bignumber.equal('0');",
          "16:     await this.reentrancyMock.callback();",
          "17:     expect(await this.reentrancyMock.counter()).to.be.bignumber.equal('1');",
          "18:   });",
          "20:   it('does not allow remote callback', async function () {",
          "21:     const attacker = await ReentrancyAttack.new();",
          "22:     await expectRevert(this.reentrancyMock.countAndCall(attacker.address), 'ReentrancyAttack: failed call');",
          "23:   });",
          "25:   it('_reentrancyGuardEntered should be true when guarded', async function () {",
          "26:     await this.reentrancyMock.guardedCheckEntered();",
          "27:   });",
          "29:   it('_reentrancyGuardEntered should be false when unguarded', async function () {",
          "30:     await this.reentrancyMock.unguardedCheckNotEntered();",
          "31:   });",
          "36:   it('does not allow local recursion', async function () {",
          "37:     await expectRevert(this.reentrancyMock.countLocalRecursive(10), 'ReentrancyGuard: reentrant call');",
          "38:   });",
          "40:   it('does not allow indirect local recursion', async function () {",
          "41:     await expectRevert(this.reentrancyMock.countThisRecursive(10), 'ReentrancyMock: failed call');",
          "42:   });",
          "43: });",
          "",
          "---------------"
        ],
        "test/token/ERC1155/ERC1155.behavior.js||test/token/ERC1155/ERC1155.behavior.js": [
          "File: test/token/ERC1155/ERC1155.behavior.js -> test/token/ERC1155/ERC1155.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS } = constants;",
          "4: const { expect } = require('chai');",
          "6: const { shouldSupportInterfaces } = require('../../utils/introspection/SupportsInterface.behavior');",
          "8: const ERC1155ReceiverMock = artifacts.require('ERC1155ReceiverMock');",
          "10: function shouldBehaveLikeERC1155([minter, firstTokenHolder, secondTokenHolder, multiTokenHolder, recipient, proxy]) {",
          "11:   const firstTokenId = new BN(1);",
          "12:   const secondTokenId = new BN(2);",
          "13:   const unknownTokenId = new BN(3);",
          "15:   const firstAmount = new BN(1000);",
          "16:   const secondAmount = new BN(2000);",
          "18:   const RECEIVER_SINGLE_MAGIC_VALUE = '0xf23a6e61';",
          "19:   const RECEIVER_BATCH_MAGIC_VALUE = '0xbc197c81';",
          "21:   describe('like an ERC1155', function () {",
          "22:     describe('balanceOf', function () {",
          "23:       it('reverts when queried about the zero address', async function () {",
          "24:         await expectRevert(",
          "25:           this.token.balanceOf(ZERO_ADDRESS, firstTokenId),",
          "26:           'ERC1155: address zero is not a valid owner',",
          "27:         );",
          "28:       });",
          "30:       context(\"when accounts don't own tokens\", function () {",
          "31:         it('returns zero for given addresses', async function () {",
          "32:           expect(await this.token.balanceOf(firstTokenHolder, firstTokenId)).to.be.bignumber.equal('0');",
          "34:           expect(await this.token.balanceOf(secondTokenHolder, secondTokenId)).to.be.bignumber.equal('0');",
          "36:           expect(await this.token.balanceOf(firstTokenHolder, unknownTokenId)).to.be.bignumber.equal('0');",
          "37:         });",
          "38:       });",
          "40:       context('when accounts own some tokens', function () {",
          "41:         beforeEach(async function () {",
          "42:           await this.token.$_mint(firstTokenHolder, firstTokenId, firstAmount, '0x', {",
          "43:             from: minter,",
          "44:           });",
          "45:           await this.token.$_mint(secondTokenHolder, secondTokenId, secondAmount, '0x', {",
          "46:             from: minter,",
          "47:           });",
          "48:         });",
          "50:         it('returns the amount of tokens owned by the given addresses', async function () {",
          "51:           expect(await this.token.balanceOf(firstTokenHolder, firstTokenId)).to.be.bignumber.equal(firstAmount);",
          "53:           expect(await this.token.balanceOf(secondTokenHolder, secondTokenId)).to.be.bignumber.equal(secondAmount);",
          "55:           expect(await this.token.balanceOf(firstTokenHolder, unknownTokenId)).to.be.bignumber.equal('0');",
          "56:         });",
          "57:       });",
          "58:     });",
          "60:     describe('balanceOfBatch', function () {",
          "61:       it(\"reverts when input arrays don't match up\", async function () {",
          "62:         await expectRevert(",
          "63:           this.token.balanceOfBatch(",
          "64:             [firstTokenHolder, secondTokenHolder, firstTokenHolder, secondTokenHolder],",
          "65:             [firstTokenId, secondTokenId, unknownTokenId],",
          "66:           ),",
          "67:           'ERC1155: accounts and ids length mismatch',",
          "68:         );",
          "70:         await expectRevert(",
          "71:           this.token.balanceOfBatch(",
          "72:             [firstTokenHolder, secondTokenHolder],",
          "73:             [firstTokenId, secondTokenId, unknownTokenId],",
          "74:           ),",
          "75:           'ERC1155: accounts and ids length mismatch',",
          "76:         );",
          "77:       });",
          "79:       it('reverts when one of the addresses is the zero address', async function () {",
          "80:         await expectRevert(",
          "81:           this.token.balanceOfBatch(",
          "82:             [firstTokenHolder, secondTokenHolder, ZERO_ADDRESS],",
          "83:             [firstTokenId, secondTokenId, unknownTokenId],",
          "84:           ),",
          "85:           'ERC1155: address zero is not a valid owner',",
          "86:         );",
          "87:       });",
          "89:       context(\"when accounts don't own tokens\", function () {",
          "90:         it('returns zeros for each account', async function () {",
          "91:           const result = await this.token.balanceOfBatch(",
          "92:             [firstTokenHolder, secondTokenHolder, firstTokenHolder],",
          "93:             [firstTokenId, secondTokenId, unknownTokenId],",
          "94:           );",
          "95:           expect(result).to.be.an('array');",
          "96:           expect(result[0]).to.be.a.bignumber.equal('0');",
          "97:           expect(result[1]).to.be.a.bignumber.equal('0');",
          "98:           expect(result[2]).to.be.a.bignumber.equal('0');",
          "99:         });",
          "100:       });",
          "102:       context('when accounts own some tokens', function () {",
          "103:         beforeEach(async function () {",
          "104:           await this.token.$_mint(firstTokenHolder, firstTokenId, firstAmount, '0x', {",
          "105:             from: minter,",
          "106:           });",
          "107:           await this.token.$_mint(secondTokenHolder, secondTokenId, secondAmount, '0x', {",
          "108:             from: minter,",
          "109:           });",
          "110:         });",
          "112:         it('returns amounts owned by each account in order passed', async function () {",
          "113:           const result = await this.token.balanceOfBatch(",
          "114:             [secondTokenHolder, firstTokenHolder, firstTokenHolder],",
          "115:             [secondTokenId, firstTokenId, unknownTokenId],",
          "116:           );",
          "117:           expect(result).to.be.an('array');",
          "118:           expect(result[0]).to.be.a.bignumber.equal(secondAmount);",
          "119:           expect(result[1]).to.be.a.bignumber.equal(firstAmount);",
          "120:           expect(result[2]).to.be.a.bignumber.equal('0');",
          "121:         });",
          "123:         it('returns multiple times the balance of the same address when asked', async function () {",
          "124:           const result = await this.token.balanceOfBatch(",
          "125:             [firstTokenHolder, secondTokenHolder, firstTokenHolder],",
          "126:             [firstTokenId, secondTokenId, firstTokenId],",
          "127:           );",
          "128:           expect(result).to.be.an('array');",
          "129:           expect(result[0]).to.be.a.bignumber.equal(result[2]);",
          "130:           expect(result[0]).to.be.a.bignumber.equal(firstAmount);",
          "131:           expect(result[1]).to.be.a.bignumber.equal(secondAmount);",
          "132:           expect(result[2]).to.be.a.bignumber.equal(firstAmount);",
          "133:         });",
          "134:       });",
          "135:     });",
          "137:     describe('setApprovalForAll', function () {",
          "138:       let receipt;",
          "139:       beforeEach(async function () {",
          "140:         receipt = await this.token.setApprovalForAll(proxy, true, { from: multiTokenHolder });",
          "141:       });",
          "143:       it('sets approval status which can be queried via isApprovedForAll', async function () {",
          "144:         expect(await this.token.isApprovedForAll(multiTokenHolder, proxy)).to.be.equal(true);",
          "145:       });",
          "147:       it('emits an ApprovalForAll log', function () {",
          "148:         expectEvent(receipt, 'ApprovalForAll', { account: multiTokenHolder, operator: proxy, approved: true });",
          "149:       });",
          "151:       it('can unset approval for an operator', async function () {",
          "152:         await this.token.setApprovalForAll(proxy, false, { from: multiTokenHolder });",
          "153:         expect(await this.token.isApprovedForAll(multiTokenHolder, proxy)).to.be.equal(false);",
          "154:       });",
          "156:       it('reverts if attempting to approve self as an operator', async function () {",
          "157:         await expectRevert(",
          "158:           this.token.setApprovalForAll(multiTokenHolder, true, { from: multiTokenHolder }),",
          "159:           'ERC1155: setting approval status for self',",
          "160:         );",
          "161:       });",
          "162:     });",
          "164:     describe('safeTransferFrom', function () {",
          "165:       beforeEach(async function () {",
          "166:         await this.token.$_mint(multiTokenHolder, firstTokenId, firstAmount, '0x', {",
          "167:           from: minter,",
          "168:         });",
          "169:         await this.token.$_mint(multiTokenHolder, secondTokenId, secondAmount, '0x', {",
          "170:           from: minter,",
          "171:         });",
          "172:       });",
          "174:       it('reverts when transferring more than balance', async function () {",
          "175:         await expectRevert(",
          "176:           this.token.safeTransferFrom(multiTokenHolder, recipient, firstTokenId, firstAmount.addn(1), '0x', {",
          "177:             from: multiTokenHolder,",
          "178:           }),",
          "179:           'ERC1155: insufficient balance for transfer',",
          "180:         );",
          "181:       });",
          "183:       it('reverts when transferring to zero address', async function () {",
          "184:         await expectRevert(",
          "185:           this.token.safeTransferFrom(multiTokenHolder, ZERO_ADDRESS, firstTokenId, firstAmount, '0x', {",
          "186:             from: multiTokenHolder,",
          "187:           }),",
          "188:           'ERC1155: transfer to the zero address',",
          "189:         );",
          "190:       });",
          "192:       function transferWasSuccessful({ operator, from, id, value }) {",
          "193:         it('debits transferred balance from sender', async function () {",
          "194:           const newBalance = await this.token.balanceOf(from, id);",
          "195:           expect(newBalance).to.be.a.bignumber.equal('0');",
          "196:         });",
          "198:         it('credits transferred balance to receiver', async function () {",
          "199:           const newBalance = await this.token.balanceOf(this.toWhom, id);",
          "200:           expect(newBalance).to.be.a.bignumber.equal(value);",
          "201:         });",
          "203:         it('emits a TransferSingle log', function () {",
          "204:           expectEvent(this.transferLogs, 'TransferSingle', {",
          "205:             operator,",
          "206:             from,",
          "207:             to: this.toWhom,",
          "208:             id,",
          "209:             value,",
          "210:           });",
          "211:         });",
          "212:       }",
          "214:       context('when called by the multiTokenHolder', async function () {",
          "215:         beforeEach(async function () {",
          "216:           this.toWhom = recipient;",
          "217:           this.transferLogs = await this.token.safeTransferFrom(",
          "218:             multiTokenHolder,",
          "219:             recipient,",
          "220:             firstTokenId,",
          "221:             firstAmount,",
          "222:             '0x',",
          "223:             {",
          "224:               from: multiTokenHolder,",
          "225:             },",
          "226:           );",
          "227:         });",
          "229:         transferWasSuccessful.call(this, {",
          "230:           operator: multiTokenHolder,",
          "231:           from: multiTokenHolder,",
          "232:           id: firstTokenId,",
          "233:           value: firstAmount,",
          "234:         });",
          "236:         it('preserves existing balances which are not transferred by multiTokenHolder', async function () {",
          "237:           const balance1 = await this.token.balanceOf(multiTokenHolder, secondTokenId);",
          "238:           expect(balance1).to.be.a.bignumber.equal(secondAmount);",
          "240:           const balance2 = await this.token.balanceOf(recipient, secondTokenId);",
          "241:           expect(balance2).to.be.a.bignumber.equal('0');",
          "242:         });",
          "243:       });",
          "245:       context('when called by an operator on behalf of the multiTokenHolder', function () {",
          "246:         context('when operator is not approved by multiTokenHolder', function () {",
          "247:           beforeEach(async function () {",
          "248:             await this.token.setApprovalForAll(proxy, false, { from: multiTokenHolder });",
          "249:           });",
          "251:           it('reverts', async function () {",
          "252:             await expectRevert(",
          "253:               this.token.safeTransferFrom(multiTokenHolder, recipient, firstTokenId, firstAmount, '0x', {",
          "254:                 from: proxy,",
          "255:               }),",
          "256:               'ERC1155: caller is not token owner or approved',",
          "257:             );",
          "258:           });",
          "259:         });",
          "261:         context('when operator is approved by multiTokenHolder', function () {",
          "262:           beforeEach(async function () {",
          "263:             this.toWhom = recipient;",
          "264:             await this.token.setApprovalForAll(proxy, true, { from: multiTokenHolder });",
          "265:             this.transferLogs = await this.token.safeTransferFrom(",
          "266:               multiTokenHolder,",
          "267:               recipient,",
          "268:               firstTokenId,",
          "269:               firstAmount,",
          "270:               '0x',",
          "271:               {",
          "272:                 from: proxy,",
          "273:               },",
          "274:             );",
          "275:           });",
          "277:           transferWasSuccessful.call(this, {",
          "278:             operator: proxy,",
          "279:             from: multiTokenHolder,",
          "280:             id: firstTokenId,",
          "281:             value: firstAmount,",
          "282:           });",
          "284:           it(\"preserves operator's balances not involved in the transfer\", async function () {",
          "285:             const balance1 = await this.token.balanceOf(proxy, firstTokenId);",
          "286:             expect(balance1).to.be.a.bignumber.equal('0');",
          "288:             const balance2 = await this.token.balanceOf(proxy, secondTokenId);",
          "289:             expect(balance2).to.be.a.bignumber.equal('0');",
          "290:           });",
          "291:         });",
          "292:       });",
          "294:       context('when sending to a valid receiver', function () {",
          "295:         beforeEach(async function () {",
          "296:           this.receiver = await ERC1155ReceiverMock.new(",
          "297:             RECEIVER_SINGLE_MAGIC_VALUE,",
          "298:             false,",
          "299:             RECEIVER_BATCH_MAGIC_VALUE,",
          "300:             false,",
          "301:           );",
          "302:         });",
          "304:         context('without data', function () {",
          "305:           beforeEach(async function () {",
          "306:             this.toWhom = this.receiver.address;",
          "307:             this.transferReceipt = await this.token.safeTransferFrom(",
          "308:               multiTokenHolder,",
          "309:               this.receiver.address,",
          "310:               firstTokenId,",
          "311:               firstAmount,",
          "312:               '0x',",
          "313:               { from: multiTokenHolder },",
          "314:             );",
          "315:             this.transferLogs = this.transferReceipt;",
          "316:           });",
          "318:           transferWasSuccessful.call(this, {",
          "319:             operator: multiTokenHolder,",
          "320:             from: multiTokenHolder,",
          "321:             id: firstTokenId,",
          "322:             value: firstAmount,",
          "323:           });",
          "325:           it('calls onERC1155Received', async function () {",
          "326:             await expectEvent.inTransaction(this.transferReceipt.tx, ERC1155ReceiverMock, 'Received', {",
          "327:               operator: multiTokenHolder,",
          "328:               from: multiTokenHolder,",
          "329:               id: firstTokenId,",
          "330:               value: firstAmount,",
          "331:               data: null,",
          "332:             });",
          "333:           });",
          "334:         });",
          "336:         context('with data', function () {",
          "337:           const data = '0xf00dd00d';",
          "338:           beforeEach(async function () {",
          "339:             this.toWhom = this.receiver.address;",
          "340:             this.transferReceipt = await this.token.safeTransferFrom(",
          "341:               multiTokenHolder,",
          "342:               this.receiver.address,",
          "343:               firstTokenId,",
          "344:               firstAmount,",
          "345:               data,",
          "346:               { from: multiTokenHolder },",
          "347:             );",
          "348:             this.transferLogs = this.transferReceipt;",
          "349:           });",
          "351:           transferWasSuccessful.call(this, {",
          "352:             operator: multiTokenHolder,",
          "353:             from: multiTokenHolder,",
          "354:             id: firstTokenId,",
          "355:             value: firstAmount,",
          "356:           });",
          "358:           it('calls onERC1155Received', async function () {",
          "359:             await expectEvent.inTransaction(this.transferReceipt.tx, ERC1155ReceiverMock, 'Received', {",
          "360:               operator: multiTokenHolder,",
          "361:               from: multiTokenHolder,",
          "362:               id: firstTokenId,",
          "363:               value: firstAmount,",
          "364:               data,",
          "365:             });",
          "366:           });",
          "367:         });",
          "368:       });",
          "370:       context('to a receiver contract returning unexpected value', function () {",
          "371:         beforeEach(async function () {",
          "372:           this.receiver = await ERC1155ReceiverMock.new('0x00c0ffee', false, RECEIVER_BATCH_MAGIC_VALUE, false);",
          "373:         });",
          "375:         it('reverts', async function () {",
          "376:           await expectRevert(",
          "377:             this.token.safeTransferFrom(multiTokenHolder, this.receiver.address, firstTokenId, firstAmount, '0x', {",
          "378:               from: multiTokenHolder,",
          "379:             }),",
          "380:             'ERC1155: ERC1155Receiver rejected tokens',",
          "381:           );",
          "382:         });",
          "383:       });",
          "385:       context('to a receiver contract that reverts', function () {",
          "386:         beforeEach(async function () {",
          "387:           this.receiver = await ERC1155ReceiverMock.new(",
          "388:             RECEIVER_SINGLE_MAGIC_VALUE,",
          "389:             true,",
          "390:             RECEIVER_BATCH_MAGIC_VALUE,",
          "391:             false,",
          "392:           );",
          "393:         });",
          "395:         it('reverts', async function () {",
          "396:           await expectRevert(",
          "397:             this.token.safeTransferFrom(multiTokenHolder, this.receiver.address, firstTokenId, firstAmount, '0x', {",
          "398:               from: multiTokenHolder,",
          "399:             }),",
          "400:             'ERC1155ReceiverMock: reverting on receive',",
          "401:           );",
          "402:         });",
          "403:       });",
          "405:       context('to a contract that does not implement the required function', function () {",
          "406:         it('reverts', async function () {",
          "407:           const invalidReceiver = this.token;",
          "408:           await expectRevert.unspecified(",
          "409:             this.token.safeTransferFrom(multiTokenHolder, invalidReceiver.address, firstTokenId, firstAmount, '0x', {",
          "410:               from: multiTokenHolder,",
          "411:             }),",
          "412:           );",
          "413:         });",
          "414:       });",
          "415:     });",
          "417:     describe('safeBatchTransferFrom', function () {",
          "418:       beforeEach(async function () {",
          "419:         await this.token.$_mint(multiTokenHolder, firstTokenId, firstAmount, '0x', {",
          "420:           from: minter,",
          "421:         });",
          "422:         await this.token.$_mint(multiTokenHolder, secondTokenId, secondAmount, '0x', {",
          "423:           from: minter,",
          "424:         });",
          "425:       });",
          "427:       it('reverts when transferring amount more than any of balances', async function () {",
          "428:         await expectRevert(",
          "429:           this.token.safeBatchTransferFrom(",
          "430:             multiTokenHolder,",
          "431:             recipient,",
          "432:             [firstTokenId, secondTokenId],",
          "433:             [firstAmount, secondAmount.addn(1)],",
          "434:             '0x',",
          "435:             { from: multiTokenHolder },",
          "436:           ),",
          "437:           'ERC1155: insufficient balance for transfer',",
          "438:         );",
          "439:       });",
          "441:       it(\"reverts when ids array length doesn't match amounts array length\", async function () {",
          "442:         await expectRevert(",
          "443:           this.token.safeBatchTransferFrom(",
          "444:             multiTokenHolder,",
          "445:             recipient,",
          "446:             [firstTokenId],",
          "447:             [firstAmount, secondAmount],",
          "448:             '0x',",
          "449:             { from: multiTokenHolder },",
          "450:           ),",
          "451:           'ERC1155: ids and amounts length mismatch',",
          "452:         );",
          "454:         await expectRevert(",
          "455:           this.token.safeBatchTransferFrom(",
          "456:             multiTokenHolder,",
          "457:             recipient,",
          "458:             [firstTokenId, secondTokenId],",
          "459:             [firstAmount],",
          "460:             '0x',",
          "461:             { from: multiTokenHolder },",
          "462:           ),",
          "463:           'ERC1155: ids and amounts length mismatch',",
          "464:         );",
          "465:       });",
          "467:       it('reverts when transferring to zero address', async function () {",
          "468:         await expectRevert(",
          "469:           this.token.safeBatchTransferFrom(",
          "470:             multiTokenHolder,",
          "471:             ZERO_ADDRESS,",
          "472:             [firstTokenId, secondTokenId],",
          "473:             [firstAmount, secondAmount],",
          "474:             '0x',",
          "475:             { from: multiTokenHolder },",
          "476:           ),",
          "477:           'ERC1155: transfer to the zero address',",
          "478:         );",
          "479:       });",
          "481:       function batchTransferWasSuccessful({ operator, from, ids, values }) {",
          "482:         it('debits transferred balances from sender', async function () {",
          "483:           const newBalances = await this.token.balanceOfBatch(new Array(ids.length).fill(from), ids);",
          "484:           for (const newBalance of newBalances) {",
          "485:             expect(newBalance).to.be.a.bignumber.equal('0');",
          "486:           }",
          "487:         });",
          "489:         it('credits transferred balances to receiver', async function () {",
          "490:           const newBalances = await this.token.balanceOfBatch(new Array(ids.length).fill(this.toWhom), ids);",
          "491:           for (let i = 0; i < newBalances.length; i++) {",
          "492:             expect(newBalances[i]).to.be.a.bignumber.equal(values[i]);",
          "493:           }",
          "494:         });",
          "496:         it('emits a TransferBatch log', function () {",
          "497:           expectEvent(this.transferLogs, 'TransferBatch', {",
          "498:             operator,",
          "499:             from,",
          "500:             to: this.toWhom,",
          "503:           });",
          "504:         });",
          "505:       }",
          "507:       context('when called by the multiTokenHolder', async function () {",
          "508:         beforeEach(async function () {",
          "509:           this.toWhom = recipient;",
          "510:           this.transferLogs = await this.token.safeBatchTransferFrom(",
          "511:             multiTokenHolder,",
          "512:             recipient,",
          "513:             [firstTokenId, secondTokenId],",
          "514:             [firstAmount, secondAmount],",
          "515:             '0x',",
          "516:             { from: multiTokenHolder },",
          "517:           );",
          "518:         });",
          "520:         batchTransferWasSuccessful.call(this, {",
          "521:           operator: multiTokenHolder,",
          "522:           from: multiTokenHolder,",
          "523:           ids: [firstTokenId, secondTokenId],",
          "524:           values: [firstAmount, secondAmount],",
          "525:         });",
          "526:       });",
          "528:       context('when called by an operator on behalf of the multiTokenHolder', function () {",
          "529:         context('when operator is not approved by multiTokenHolder', function () {",
          "530:           beforeEach(async function () {",
          "531:             await this.token.setApprovalForAll(proxy, false, { from: multiTokenHolder });",
          "532:           });",
          "534:           it('reverts', async function () {",
          "535:             await expectRevert(",
          "536:               this.token.safeBatchTransferFrom(",
          "537:                 multiTokenHolder,",
          "538:                 recipient,",
          "539:                 [firstTokenId, secondTokenId],",
          "540:                 [firstAmount, secondAmount],",
          "541:                 '0x',",
          "542:                 { from: proxy },",
          "543:               ),",
          "544:               'ERC1155: caller is not token owner or approved',",
          "545:             );",
          "546:           });",
          "547:         });",
          "549:         context('when operator is approved by multiTokenHolder', function () {",
          "550:           beforeEach(async function () {",
          "551:             this.toWhom = recipient;",
          "552:             await this.token.setApprovalForAll(proxy, true, { from: multiTokenHolder });",
          "553:             this.transferLogs = await this.token.safeBatchTransferFrom(",
          "554:               multiTokenHolder,",
          "555:               recipient,",
          "556:               [firstTokenId, secondTokenId],",
          "557:               [firstAmount, secondAmount],",
          "558:               '0x',",
          "559:               { from: proxy },",
          "560:             );",
          "561:           });",
          "563:           batchTransferWasSuccessful.call(this, {",
          "564:             operator: proxy,",
          "565:             from: multiTokenHolder,",
          "566:             ids: [firstTokenId, secondTokenId],",
          "567:             values: [firstAmount, secondAmount],",
          "568:           });",
          "570:           it(\"preserves operator's balances not involved in the transfer\", async function () {",
          "571:             const balance1 = await this.token.balanceOf(proxy, firstTokenId);",
          "572:             expect(balance1).to.be.a.bignumber.equal('0');",
          "573:             const balance2 = await this.token.balanceOf(proxy, secondTokenId);",
          "574:             expect(balance2).to.be.a.bignumber.equal('0');",
          "575:           });",
          "576:         });",
          "577:       });",
          "579:       context('when sending to a valid receiver', function () {",
          "580:         beforeEach(async function () {",
          "581:           this.receiver = await ERC1155ReceiverMock.new(",
          "582:             RECEIVER_SINGLE_MAGIC_VALUE,",
          "583:             false,",
          "584:             RECEIVER_BATCH_MAGIC_VALUE,",
          "585:             false,",
          "586:           );",
          "587:         });",
          "589:         context('without data', function () {",
          "590:           beforeEach(async function () {",
          "591:             this.toWhom = this.receiver.address;",
          "592:             this.transferReceipt = await this.token.safeBatchTransferFrom(",
          "593:               multiTokenHolder,",
          "594:               this.receiver.address,",
          "595:               [firstTokenId, secondTokenId],",
          "596:               [firstAmount, secondAmount],",
          "597:               '0x',",
          "598:               { from: multiTokenHolder },",
          "599:             );",
          "600:             this.transferLogs = this.transferReceipt;",
          "601:           });",
          "603:           batchTransferWasSuccessful.call(this, {",
          "604:             operator: multiTokenHolder,",
          "605:             from: multiTokenHolder,",
          "606:             ids: [firstTokenId, secondTokenId],",
          "607:             values: [firstAmount, secondAmount],",
          "608:           });",
          "610:           it('calls onERC1155BatchReceived', async function () {",
          "611:             await expectEvent.inTransaction(this.transferReceipt.tx, ERC1155ReceiverMock, 'BatchReceived', {",
          "612:               operator: multiTokenHolder,",
          "613:               from: multiTokenHolder,",
          "616:               data: null,",
          "617:             });",
          "618:           });",
          "619:         });",
          "621:         context('with data', function () {",
          "622:           const data = '0xf00dd00d';",
          "623:           beforeEach(async function () {",
          "624:             this.toWhom = this.receiver.address;",
          "625:             this.transferReceipt = await this.token.safeBatchTransferFrom(",
          "626:               multiTokenHolder,",
          "627:               this.receiver.address,",
          "628:               [firstTokenId, secondTokenId],",
          "629:               [firstAmount, secondAmount],",
          "630:               data,",
          "631:               { from: multiTokenHolder },",
          "632:             );",
          "633:             this.transferLogs = this.transferReceipt;",
          "634:           });",
          "636:           batchTransferWasSuccessful.call(this, {",
          "637:             operator: multiTokenHolder,",
          "638:             from: multiTokenHolder,",
          "639:             ids: [firstTokenId, secondTokenId],",
          "640:             values: [firstAmount, secondAmount],",
          "641:           });",
          "643:           it('calls onERC1155Received', async function () {",
          "644:             await expectEvent.inTransaction(this.transferReceipt.tx, ERC1155ReceiverMock, 'BatchReceived', {",
          "645:               operator: multiTokenHolder,",
          "646:               from: multiTokenHolder,",
          "649:               data,",
          "650:             });",
          "651:           });",
          "652:         });",
          "653:       });",
          "655:       context('to a receiver contract returning unexpected value', function () {",
          "656:         beforeEach(async function () {",
          "657:           this.receiver = await ERC1155ReceiverMock.new(",
          "658:             RECEIVER_SINGLE_MAGIC_VALUE,",
          "659:             false,",
          "660:             RECEIVER_SINGLE_MAGIC_VALUE,",
          "661:             false,",
          "662:           );",
          "663:         });",
          "665:         it('reverts', async function () {",
          "666:           await expectRevert(",
          "667:             this.token.safeBatchTransferFrom(",
          "668:               multiTokenHolder,",
          "669:               this.receiver.address,",
          "670:               [firstTokenId, secondTokenId],",
          "671:               [firstAmount, secondAmount],",
          "672:               '0x',",
          "673:               { from: multiTokenHolder },",
          "674:             ),",
          "675:             'ERC1155: ERC1155Receiver rejected tokens',",
          "676:           );",
          "677:         });",
          "678:       });",
          "680:       context('to a receiver contract that reverts', function () {",
          "681:         beforeEach(async function () {",
          "682:           this.receiver = await ERC1155ReceiverMock.new(",
          "683:             RECEIVER_SINGLE_MAGIC_VALUE,",
          "684:             false,",
          "685:             RECEIVER_BATCH_MAGIC_VALUE,",
          "686:             true,",
          "687:           );",
          "688:         });",
          "690:         it('reverts', async function () {",
          "691:           await expectRevert(",
          "692:             this.token.safeBatchTransferFrom(",
          "693:               multiTokenHolder,",
          "694:               this.receiver.address,",
          "695:               [firstTokenId, secondTokenId],",
          "696:               [firstAmount, secondAmount],",
          "697:               '0x',",
          "698:               { from: multiTokenHolder },",
          "699:             ),",
          "700:             'ERC1155ReceiverMock: reverting on batch receive',",
          "701:           );",
          "702:         });",
          "703:       });",
          "705:       context('to a receiver contract that reverts only on single transfers', function () {",
          "706:         beforeEach(async function () {",
          "707:           this.receiver = await ERC1155ReceiverMock.new(",
          "708:             RECEIVER_SINGLE_MAGIC_VALUE,",
          "709:             true,",
          "710:             RECEIVER_BATCH_MAGIC_VALUE,",
          "711:             false,",
          "712:           );",
          "714:           this.toWhom = this.receiver.address;",
          "715:           this.transferReceipt = await this.token.safeBatchTransferFrom(",
          "716:             multiTokenHolder,",
          "717:             this.receiver.address,",
          "718:             [firstTokenId, secondTokenId],",
          "719:             [firstAmount, secondAmount],",
          "720:             '0x',",
          "721:             { from: multiTokenHolder },",
          "722:           );",
          "723:           this.transferLogs = this.transferReceipt;",
          "724:         });",
          "726:         batchTransferWasSuccessful.call(this, {",
          "727:           operator: multiTokenHolder,",
          "728:           from: multiTokenHolder,",
          "729:           ids: [firstTokenId, secondTokenId],",
          "730:           values: [firstAmount, secondAmount],",
          "731:         });",
          "733:         it('calls onERC1155BatchReceived', async function () {",
          "734:           await expectEvent.inTransaction(this.transferReceipt.tx, ERC1155ReceiverMock, 'BatchReceived', {",
          "735:             operator: multiTokenHolder,",
          "736:             from: multiTokenHolder,",
          "739:             data: null,",
          "740:           });",
          "741:         });",
          "742:       });",
          "744:       context('to a contract that does not implement the required function', function () {",
          "745:         it('reverts', async function () {",
          "746:           const invalidReceiver = this.token;",
          "747:           await expectRevert.unspecified(",
          "748:             this.token.safeBatchTransferFrom(",
          "749:               multiTokenHolder,",
          "750:               invalidReceiver.address,",
          "751:               [firstTokenId, secondTokenId],",
          "752:               [firstAmount, secondAmount],",
          "753:               '0x',",
          "754:               { from: multiTokenHolder },",
          "755:             ),",
          "756:           );",
          "757:         });",
          "758:       });",
          "759:     });",
          "761:     shouldSupportInterfaces(['ERC165', 'ERC1155']);",
          "762:   });",
          "763: }",
          "765: module.exports = {",
          "766:   shouldBehaveLikeERC1155,",
          "767: };",
          "",
          "---------------"
        ],
        "test/token/ERC1155/ERC1155.test.js||test/token/ERC1155/ERC1155.test.js": [
          "File: test/token/ERC1155/ERC1155.test.js -> test/token/ERC1155/ERC1155.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS } = constants;",
          "4: const { expect } = require('chai');",
          "6: const { shouldBehaveLikeERC1155 } = require('./ERC1155.behavior');",
          "7: const ERC1155Mock = artifacts.require('$ERC1155');",
          "9: contract('ERC1155', function (accounts) {",
          "10:   const [operator, tokenHolder, tokenBatchHolder, ...otherAccounts] = accounts;",
          "12:   const initialURI = 'https://token-cdn-domain/{id}.json';",
          "14:   beforeEach(async function () {",
          "15:     this.token = await ERC1155Mock.new(initialURI);",
          "16:   });",
          "18:   shouldBehaveLikeERC1155(otherAccounts);",
          "20:   describe('internal functions', function () {",
          "21:     const tokenId = new BN(1990);",
          "22:     const mintAmount = new BN(9001);",
          "23:     const burnAmount = new BN(3000);",
          "25:     const tokenBatchIds = [new BN(2000), new BN(2010), new BN(2020)];",
          "26:     const mintAmounts = [new BN(5000), new BN(10000), new BN(42195)];",
          "27:     const burnAmounts = [new BN(5000), new BN(9001), new BN(195)];",
          "29:     const data = '0x12345678';",
          "31:     describe('_mint', function () {",
          "32:       it('reverts with a zero destination address', async function () {",
          "33:         await expectRevert(",
          "34:           this.token.$_mint(ZERO_ADDRESS, tokenId, mintAmount, data),",
          "35:           'ERC1155: mint to the zero address',",
          "36:         );",
          "37:       });",
          "39:       context('with minted tokens', function () {",
          "40:         beforeEach(async function () {",
          "41:           this.receipt = await this.token.$_mint(tokenHolder, tokenId, mintAmount, data, { from: operator });",
          "42:         });",
          "44:         it('emits a TransferSingle event', function () {",
          "45:           expectEvent(this.receipt, 'TransferSingle', {",
          "46:             operator,",
          "47:             from: ZERO_ADDRESS,",
          "48:             to: tokenHolder,",
          "49:             id: tokenId,",
          "50:             value: mintAmount,",
          "51:           });",
          "52:         });",
          "54:         it('credits the minted amount of tokens', async function () {",
          "55:           expect(await this.token.balanceOf(tokenHolder, tokenId)).to.be.bignumber.equal(mintAmount);",
          "56:         });",
          "57:       });",
          "58:     });",
          "60:     describe('_mintBatch', function () {",
          "61:       it('reverts with a zero destination address', async function () {",
          "62:         await expectRevert(",
          "63:           this.token.$_mintBatch(ZERO_ADDRESS, tokenBatchIds, mintAmounts, data),",
          "64:           'ERC1155: mint to the zero address',",
          "65:         );",
          "66:       });",
          "68:       it('reverts if length of inputs do not match', async function () {",
          "69:         await expectRevert(",
          "70:           this.token.$_mintBatch(tokenBatchHolder, tokenBatchIds, mintAmounts.slice(1), data),",
          "71:           'ERC1155: ids and amounts length mismatch',",
          "72:         );",
          "74:         await expectRevert(",
          "75:           this.token.$_mintBatch(tokenBatchHolder, tokenBatchIds.slice(1), mintAmounts, data),",
          "76:           'ERC1155: ids and amounts length mismatch',",
          "77:         );",
          "78:       });",
          "80:       context('with minted batch of tokens', function () {",
          "81:         beforeEach(async function () {",
          "82:           this.receipt = await this.token.$_mintBatch(tokenBatchHolder, tokenBatchIds, mintAmounts, data, {",
          "83:             from: operator,",
          "84:           });",
          "85:         });",
          "87:         it('emits a TransferBatch event', function () {",
          "88:           expectEvent(this.receipt, 'TransferBatch', {",
          "89:             operator,",
          "90:             from: ZERO_ADDRESS,",
          "91:             to: tokenBatchHolder,",
          "92:           });",
          "93:         });",
          "95:         it('credits the minted batch of tokens', async function () {",
          "96:           const holderBatchBalances = await this.token.balanceOfBatch(",
          "97:             new Array(tokenBatchIds.length).fill(tokenBatchHolder),",
          "98:             tokenBatchIds,",
          "99:           );",
          "101:           for (let i = 0; i < holderBatchBalances.length; i++) {",
          "102:             expect(holderBatchBalances[i]).to.be.bignumber.equal(mintAmounts[i]);",
          "103:           }",
          "104:         });",
          "105:       });",
          "106:     });",
          "108:     describe('_burn', function () {",
          "109:       it(\"reverts when burning the zero account's tokens\", async function () {",
          "110:         await expectRevert(this.token.$_burn(ZERO_ADDRESS, tokenId, mintAmount), 'ERC1155: burn from the zero address');",
          "111:       });",
          "113:       it('reverts when burning a non-existent token id', async function () {",
          "114:         await expectRevert(this.token.$_burn(tokenHolder, tokenId, mintAmount), 'ERC1155: burn amount exceeds balance');",
          "115:       });",
          "117:       it('reverts when burning more than available tokens', async function () {",
          "118:         await this.token.$_mint(tokenHolder, tokenId, mintAmount, data, { from: operator });",
          "120:         await expectRevert(",
          "121:           this.token.$_burn(tokenHolder, tokenId, mintAmount.addn(1)),",
          "122:           'ERC1155: burn amount exceeds balance',",
          "123:         );",
          "124:       });",
          "126:       context('with minted-then-burnt tokens', function () {",
          "127:         beforeEach(async function () {",
          "128:           await this.token.$_mint(tokenHolder, tokenId, mintAmount, data);",
          "129:           this.receipt = await this.token.$_burn(tokenHolder, tokenId, burnAmount, { from: operator });",
          "130:         });",
          "132:         it('emits a TransferSingle event', function () {",
          "133:           expectEvent(this.receipt, 'TransferSingle', {",
          "134:             operator,",
          "135:             from: tokenHolder,",
          "136:             to: ZERO_ADDRESS,",
          "137:             id: tokenId,",
          "138:             value: burnAmount,",
          "139:           });",
          "140:         });",
          "142:         it('accounts for both minting and burning', async function () {",
          "143:           expect(await this.token.balanceOf(tokenHolder, tokenId)).to.be.bignumber.equal(mintAmount.sub(burnAmount));",
          "144:         });",
          "145:       });",
          "146:     });",
          "148:     describe('_burnBatch', function () {",
          "149:       it(\"reverts when burning the zero account's tokens\", async function () {",
          "150:         await expectRevert(",
          "151:           this.token.$_burnBatch(ZERO_ADDRESS, tokenBatchIds, burnAmounts),",
          "152:           'ERC1155: burn from the zero address',",
          "153:         );",
          "154:       });",
          "156:       it('reverts if length of inputs do not match', async function () {",
          "157:         await expectRevert(",
          "158:           this.token.$_burnBatch(tokenBatchHolder, tokenBatchIds, burnAmounts.slice(1)),",
          "159:           'ERC1155: ids and amounts length mismatch',",
          "160:         );",
          "162:         await expectRevert(",
          "163:           this.token.$_burnBatch(tokenBatchHolder, tokenBatchIds.slice(1), burnAmounts),",
          "164:           'ERC1155: ids and amounts length mismatch',",
          "165:         );",
          "166:       });",
          "168:       it('reverts when burning a non-existent token id', async function () {",
          "169:         await expectRevert(",
          "170:           this.token.$_burnBatch(tokenBatchHolder, tokenBatchIds, burnAmounts),",
          "171:           'ERC1155: burn amount exceeds balance',",
          "172:         );",
          "173:       });",
          "175:       context('with minted-then-burnt tokens', function () {",
          "176:         beforeEach(async function () {",
          "177:           await this.token.$_mintBatch(tokenBatchHolder, tokenBatchIds, mintAmounts, data);",
          "178:           this.receipt = await this.token.$_burnBatch(tokenBatchHolder, tokenBatchIds, burnAmounts, { from: operator });",
          "179:         });",
          "181:         it('emits a TransferBatch event', function () {",
          "182:           expectEvent(this.receipt, 'TransferBatch', {",
          "183:             operator,",
          "184:             from: tokenBatchHolder,",
          "185:             to: ZERO_ADDRESS,",
          "188:           });",
          "189:         });",
          "191:         it('accounts for both minting and burning', async function () {",
          "192:           const holderBatchBalances = await this.token.balanceOfBatch(",
          "193:             new Array(tokenBatchIds.length).fill(tokenBatchHolder),",
          "194:             tokenBatchIds,",
          "195:           );",
          "197:           for (let i = 0; i < holderBatchBalances.length; i++) {",
          "198:             expect(holderBatchBalances[i]).to.be.bignumber.equal(mintAmounts[i].sub(burnAmounts[i]));",
          "199:           }",
          "200:         });",
          "201:       });",
          "202:     });",
          "203:   });",
          "205:   describe('ERC1155MetadataURI', function () {",
          "206:     const firstTokenID = new BN('42');",
          "207:     const secondTokenID = new BN('1337');",
          "209:     it('emits no URI event in constructor', async function () {",
          "210:       await expectEvent.notEmitted.inConstruction(this.token, 'URI');",
          "211:     });",
          "213:     it('sets the initial URI for all token types', async function () {",
          "214:       expect(await this.token.uri(firstTokenID)).to.be.equal(initialURI);",
          "215:       expect(await this.token.uri(secondTokenID)).to.be.equal(initialURI);",
          "216:     });",
          "218:     describe('_setURI', function () {",
          "219:       const newURI = 'https://token-cdn-domain/{locale}/{id}.json';",
          "221:       it('emits no URI event', async function () {",
          "222:         const receipt = await this.token.$_setURI(newURI);",
          "224:         expectEvent.notEmitted(receipt, 'URI');",
          "225:       });",
          "227:       it('sets the new URI for all token types', async function () {",
          "228:         await this.token.$_setURI(newURI);",
          "230:         expect(await this.token.uri(firstTokenID)).to.be.equal(newURI);",
          "231:         expect(await this.token.uri(secondTokenID)).to.be.equal(newURI);",
          "232:       });",
          "233:     });",
          "234:   });",
          "235: });",
          "",
          "---------------"
        ],
        "test/token/ERC1155/extensions/ERC1155Burnable.test.js||test/token/ERC1155/extensions/ERC1155Burnable.test.js": [
          "File: test/token/ERC1155/extensions/ERC1155Burnable.test.js -> test/token/ERC1155/extensions/ERC1155Burnable.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const ERC1155Burnable = artifacts.require('$ERC1155Burnable');",
          "7: contract('ERC1155Burnable', function (accounts) {",
          "8:   const [holder, operator, other] = accounts;",
          "10:   const uri = 'https://token.com';",
          "12:   const tokenIds = [new BN('42'), new BN('1137')];",
          "13:   const amounts = [new BN('3000'), new BN('9902')];",
          "15:   beforeEach(async function () {",
          "16:     this.token = await ERC1155Burnable.new(uri);",
          "18:     await this.token.$_mint(holder, tokenIds[0], amounts[0], '0x');",
          "19:     await this.token.$_mint(holder, tokenIds[1], amounts[1], '0x');",
          "20:   });",
          "22:   describe('burn', function () {",
          "23:     it('holder can burn their tokens', async function () {",
          "24:       await this.token.burn(holder, tokenIds[0], amounts[0].subn(1), { from: holder });",
          "26:       expect(await this.token.balanceOf(holder, tokenIds[0])).to.be.bignumber.equal('1');",
          "27:     });",
          "29:     it(\"approved operators can burn the holder's tokens\", async function () {",
          "30:       await this.token.setApprovalForAll(operator, true, { from: holder });",
          "31:       await this.token.burn(holder, tokenIds[0], amounts[0].subn(1), { from: operator });",
          "33:       expect(await this.token.balanceOf(holder, tokenIds[0])).to.be.bignumber.equal('1');",
          "34:     });",
          "36:     it(\"unapproved accounts cannot burn the holder's tokens\", async function () {",
          "37:       await expectRevert(",
          "38:         this.token.burn(holder, tokenIds[0], amounts[0].subn(1), { from: other }),",
          "39:         'ERC1155: caller is not token owner or approved',",
          "40:       );",
          "41:     });",
          "42:   });",
          "44:   describe('burnBatch', function () {",
          "45:     it('holder can burn their tokens', async function () {",
          "46:       await this.token.burnBatch(holder, tokenIds, [amounts[0].subn(1), amounts[1].subn(2)], { from: holder });",
          "48:       expect(await this.token.balanceOf(holder, tokenIds[0])).to.be.bignumber.equal('1');",
          "49:       expect(await this.token.balanceOf(holder, tokenIds[1])).to.be.bignumber.equal('2');",
          "50:     });",
          "52:     it(\"approved operators can burn the holder's tokens\", async function () {",
          "53:       await this.token.setApprovalForAll(operator, true, { from: holder });",
          "54:       await this.token.burnBatch(holder, tokenIds, [amounts[0].subn(1), amounts[1].subn(2)], { from: operator });",
          "56:       expect(await this.token.balanceOf(holder, tokenIds[0])).to.be.bignumber.equal('1');",
          "57:       expect(await this.token.balanceOf(holder, tokenIds[1])).to.be.bignumber.equal('2');",
          "58:     });",
          "60:     it(\"unapproved accounts cannot burn the holder's tokens\", async function () {",
          "61:       await expectRevert(",
          "62:         this.token.burnBatch(holder, tokenIds, [amounts[0].subn(1), amounts[1].subn(2)], { from: other }),",
          "63:         'ERC1155: caller is not token owner or approved',",
          "64:       );",
          "65:     });",
          "66:   });",
          "67: });",
          "",
          "---------------"
        ],
        "test/token/ERC1155/extensions/ERC1155Pausable.test.js||test/token/ERC1155/extensions/ERC1155Pausable.test.js": [
          "File: test/token/ERC1155/extensions/ERC1155Pausable.test.js -> test/token/ERC1155/extensions/ERC1155Pausable.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const ERC1155Pausable = artifacts.require('$ERC1155Pausable');",
          "7: contract('ERC1155Pausable', function (accounts) {",
          "8:   const [holder, operator, receiver, other] = accounts;",
          "10:   const uri = 'https://token.com';",
          "12:   beforeEach(async function () {",
          "13:     this.token = await ERC1155Pausable.new(uri);",
          "14:   });",
          "16:   context('when token is paused', function () {",
          "17:     const firstTokenId = new BN('37');",
          "18:     const firstTokenAmount = new BN('42');",
          "20:     const secondTokenId = new BN('19842');",
          "21:     const secondTokenAmount = new BN('23');",
          "23:     beforeEach(async function () {",
          "24:       await this.token.setApprovalForAll(operator, true, { from: holder });",
          "25:       await this.token.$_mint(holder, firstTokenId, firstTokenAmount, '0x');",
          "27:       await this.token.$_pause();",
          "28:     });",
          "30:     it('reverts when trying to safeTransferFrom from holder', async function () {",
          "31:       await expectRevert(",
          "32:         this.token.safeTransferFrom(holder, receiver, firstTokenId, firstTokenAmount, '0x', { from: holder }),",
          "33:         'ERC1155Pausable: token transfer while paused',",
          "34:       );",
          "35:     });",
          "37:     it('reverts when trying to safeTransferFrom from operator', async function () {",
          "38:       await expectRevert(",
          "39:         this.token.safeTransferFrom(holder, receiver, firstTokenId, firstTokenAmount, '0x', { from: operator }),",
          "40:         'ERC1155Pausable: token transfer while paused',",
          "41:       );",
          "42:     });",
          "44:     it('reverts when trying to safeBatchTransferFrom from holder', async function () {",
          "45:       await expectRevert(",
          "46:         this.token.safeBatchTransferFrom(holder, receiver, [firstTokenId], [firstTokenAmount], '0x', { from: holder }),",
          "47:         'ERC1155Pausable: token transfer while paused',",
          "48:       );",
          "49:     });",
          "51:     it('reverts when trying to safeBatchTransferFrom from operator', async function () {",
          "52:       await expectRevert(",
          "53:         this.token.safeBatchTransferFrom(holder, receiver, [firstTokenId], [firstTokenAmount], '0x', {",
          "54:           from: operator,",
          "55:         }),",
          "56:         'ERC1155Pausable: token transfer while paused',",
          "57:       );",
          "58:     });",
          "60:     it('reverts when trying to mint', async function () {",
          "61:       await expectRevert(",
          "62:         this.token.$_mint(holder, secondTokenId, secondTokenAmount, '0x'),",
          "63:         'ERC1155Pausable: token transfer while paused',",
          "64:       );",
          "65:     });",
          "67:     it('reverts when trying to mintBatch', async function () {",
          "68:       await expectRevert(",
          "69:         this.token.$_mintBatch(holder, [secondTokenId], [secondTokenAmount], '0x'),",
          "70:         'ERC1155Pausable: token transfer while paused',",
          "71:       );",
          "72:     });",
          "74:     it('reverts when trying to burn', async function () {",
          "75:       await expectRevert(",
          "76:         this.token.$_burn(holder, firstTokenId, firstTokenAmount),",
          "77:         'ERC1155Pausable: token transfer while paused',",
          "78:       );",
          "79:     });",
          "81:     it('reverts when trying to burnBatch', async function () {",
          "82:       await expectRevert(",
          "83:         this.token.$_burnBatch(holder, [firstTokenId], [firstTokenAmount]),",
          "84:         'ERC1155Pausable: token transfer while paused',",
          "85:       );",
          "86:     });",
          "88:     describe('setApprovalForAll', function () {",
          "89:       it('approves an operator', async function () {",
          "90:         await this.token.setApprovalForAll(other, true, { from: holder });",
          "91:         expect(await this.token.isApprovedForAll(holder, other)).to.equal(true);",
          "92:       });",
          "93:     });",
          "95:     describe('balanceOf', function () {",
          "96:       it('returns the amount of tokens owned by the given address', async function () {",
          "97:         const balance = await this.token.balanceOf(holder, firstTokenId);",
          "98:         expect(balance).to.be.bignumber.equal(firstTokenAmount);",
          "99:       });",
          "100:     });",
          "102:     describe('isApprovedForAll', function () {",
          "103:       it('returns the approval of the operator', async function () {",
          "104:         expect(await this.token.isApprovedForAll(holder, operator)).to.equal(true);",
          "105:       });",
          "106:     });",
          "107:   });",
          "108: });",
          "",
          "---------------"
        ],
        "test/token/ERC1155/extensions/ERC1155Supply.test.js||test/token/ERC1155/extensions/ERC1155Supply.test.js": [
          "File: test/token/ERC1155/extensions/ERC1155Supply.test.js -> test/token/ERC1155/extensions/ERC1155Supply.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const ERC1155Supply = artifacts.require('$ERC1155Supply');",
          "7: contract('ERC1155Supply', function (accounts) {",
          "8:   const [holder] = accounts;",
          "10:   const uri = 'https://token.com';",
          "12:   const firstTokenId = new BN('37');",
          "13:   const firstTokenAmount = new BN('42');",
          "15:   const secondTokenId = new BN('19842');",
          "16:   const secondTokenAmount = new BN('23');",
          "18:   beforeEach(async function () {",
          "19:     this.token = await ERC1155Supply.new(uri);",
          "20:   });",
          "22:   context('before mint', function () {",
          "23:     it('exist', async function () {",
          "24:       expect(await this.token.exists(firstTokenId)).to.be.equal(false);",
          "25:     });",
          "27:     it('totalSupply', async function () {",
          "28:       expect(await this.token.totalSupply(firstTokenId)).to.be.bignumber.equal('0');",
          "29:     });",
          "30:   });",
          "32:   context('after mint', function () {",
          "33:     context('single', function () {",
          "34:       beforeEach(async function () {",
          "35:         await this.token.$_mint(holder, firstTokenId, firstTokenAmount, '0x');",
          "36:       });",
          "38:       it('exist', async function () {",
          "39:         expect(await this.token.exists(firstTokenId)).to.be.equal(true);",
          "40:       });",
          "42:       it('totalSupply', async function () {",
          "43:         expect(await this.token.totalSupply(firstTokenId)).to.be.bignumber.equal(firstTokenAmount);",
          "44:       });",
          "45:     });",
          "47:     context('batch', function () {",
          "48:       beforeEach(async function () {",
          "49:         await this.token.$_mintBatch(",
          "50:           holder,",
          "51:           [firstTokenId, secondTokenId],",
          "52:           [firstTokenAmount, secondTokenAmount],",
          "53:           '0x',",
          "54:         );",
          "55:       });",
          "57:       it('exist', async function () {",
          "58:         expect(await this.token.exists(firstTokenId)).to.be.equal(true);",
          "59:         expect(await this.token.exists(secondTokenId)).to.be.equal(true);",
          "60:       });",
          "62:       it('totalSupply', async function () {",
          "63:         expect(await this.token.totalSupply(firstTokenId)).to.be.bignumber.equal(firstTokenAmount);",
          "64:         expect(await this.token.totalSupply(secondTokenId)).to.be.bignumber.equal(secondTokenAmount);",
          "65:       });",
          "66:     });",
          "67:   });",
          "69:   context('after burn', function () {",
          "70:     context('single', function () {",
          "71:       beforeEach(async function () {",
          "72:         await this.token.$_mint(holder, firstTokenId, firstTokenAmount, '0x');",
          "73:         await this.token.$_burn(holder, firstTokenId, firstTokenAmount);",
          "74:       });",
          "76:       it('exist', async function () {",
          "77:         expect(await this.token.exists(firstTokenId)).to.be.equal(false);",
          "78:       });",
          "80:       it('totalSupply', async function () {",
          "81:         expect(await this.token.totalSupply(firstTokenId)).to.be.bignumber.equal('0');",
          "82:       });",
          "83:     });",
          "85:     context('batch', function () {",
          "86:       beforeEach(async function () {",
          "87:         await this.token.$_mintBatch(",
          "88:           holder,",
          "89:           [firstTokenId, secondTokenId],",
          "90:           [firstTokenAmount, secondTokenAmount],",
          "91:           '0x',",
          "92:         );",
          "93:         await this.token.$_burnBatch(holder, [firstTokenId, secondTokenId], [firstTokenAmount, secondTokenAmount]);",
          "94:       });",
          "96:       it('exist', async function () {",
          "97:         expect(await this.token.exists(firstTokenId)).to.be.equal(false);",
          "98:         expect(await this.token.exists(secondTokenId)).to.be.equal(false);",
          "99:       });",
          "101:       it('totalSupply', async function () {",
          "102:         expect(await this.token.totalSupply(firstTokenId)).to.be.bignumber.equal('0');",
          "103:         expect(await this.token.totalSupply(secondTokenId)).to.be.bignumber.equal('0');",
          "104:       });",
          "105:     });",
          "106:   });",
          "107: });",
          "",
          "---------------"
        ],
        "test/token/ERC1155/extensions/ERC1155URIStorage.test.js||test/token/ERC1155/extensions/ERC1155URIStorage.test.js": [
          "File: test/token/ERC1155/extensions/ERC1155URIStorage.test.js -> test/token/ERC1155/extensions/ERC1155URIStorage.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, expectEvent } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "4: const { artifacts } = require('hardhat');",
          "6: const ERC1155URIStorage = artifacts.require('$ERC1155URIStorage');",
          "8: contract(['ERC1155URIStorage'], function (accounts) {",
          "9:   const [holder] = accounts;",
          "11:   const erc1155Uri = 'https://token.com/nfts/';",
          "12:   const baseUri = 'https://token.com/';",
          "14:   const tokenId = new BN('1');",
          "15:   const amount = new BN('3000');",
          "17:   describe('with base uri set', function () {",
          "18:     beforeEach(async function () {",
          "19:       this.token = await ERC1155URIStorage.new(erc1155Uri);",
          "20:       await this.token.$_setBaseURI(baseUri);",
          "22:       await this.token.$_mint(holder, tokenId, amount, '0x');",
          "23:     });",
          "25:     it('can request the token uri, returning the erc1155 uri if no token uri was set', async function () {",
          "26:       const receivedTokenUri = await this.token.uri(tokenId);",
          "28:       expect(receivedTokenUri).to.be.equal(erc1155Uri);",
          "29:     });",
          "31:     it('can request the token uri, returning the concatenated uri if a token uri was set', async function () {",
          "32:       const tokenUri = '1234/';",
          "33:       const receipt = await this.token.$_setURI(tokenId, tokenUri);",
          "35:       const receivedTokenUri = await this.token.uri(tokenId);",
          "37:       const expectedUri = `${baseUri}${tokenUri}`;",
          "38:       expect(receivedTokenUri).to.be.equal(expectedUri);",
          "39:       expectEvent(receipt, 'URI', { value: expectedUri, id: tokenId });",
          "40:     });",
          "41:   });",
          "43:   describe('with base uri set to the empty string', function () {",
          "44:     beforeEach(async function () {",
          "45:       this.token = await ERC1155URIStorage.new('');",
          "47:       await this.token.$_mint(holder, tokenId, amount, '0x');",
          "48:     });",
          "50:     it('can request the token uri, returning an empty string if no token uri was set', async function () {",
          "51:       const receivedTokenUri = await this.token.uri(tokenId);",
          "53:       expect(receivedTokenUri).to.be.equal('');",
          "54:     });",
          "56:     it('can request the token uri, returning the token uri if a token uri was set', async function () {",
          "57:       const tokenUri = 'ipfs://1234/';",
          "58:       const receipt = await this.token.$_setURI(tokenId, tokenUri);",
          "60:       const receivedTokenUri = await this.token.uri(tokenId);",
          "62:       expect(receivedTokenUri).to.be.equal(tokenUri);",
          "63:       expectEvent(receipt, 'URI', { value: tokenUri, id: tokenId });",
          "64:     });",
          "65:   });",
          "66: });",
          "",
          "---------------"
        ],
        "test/token/ERC1155/presets/ERC1155PresetMinterPauser.test.js||test/token/ERC1155/presets/ERC1155PresetMinterPauser.test.js": [
          "File: test/token/ERC1155/presets/ERC1155PresetMinterPauser.test.js -> test/token/ERC1155/presets/ERC1155PresetMinterPauser.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS } = constants;",
          "3: const { shouldSupportInterfaces } = require('../../../utils/introspection/SupportsInterface.behavior');",
          "5: const { expect } = require('chai');",
          "7: const ERC1155PresetMinterPauser = artifacts.require('ERC1155PresetMinterPauser');",
          "9: contract('ERC1155PresetMinterPauser', function (accounts) {",
          "10:   const [deployer, other] = accounts;",
          "12:   const firstTokenId = new BN('845');",
          "13:   const firstTokenIdAmount = new BN('5000');",
          "15:   const secondTokenId = new BN('48324');",
          "16:   const secondTokenIdAmount = new BN('77875');",
          "18:   const DEFAULT_ADMIN_ROLE = '0x0000000000000000000000000000000000000000000000000000000000000000';",
          "19:   const MINTER_ROLE = web3.utils.soliditySha3('MINTER_ROLE');",
          "20:   const PAUSER_ROLE = web3.utils.soliditySha3('PAUSER_ROLE');",
          "22:   const uri = 'https://token.com';",
          "24:   beforeEach(async function () {",
          "25:     this.token = await ERC1155PresetMinterPauser.new(uri, { from: deployer });",
          "26:   });",
          "28:   shouldSupportInterfaces(['ERC1155', 'AccessControl', 'AccessControlEnumerable']);",
          "30:   it('deployer has the default admin role', async function () {",
          "31:     expect(await this.token.getRoleMemberCount(DEFAULT_ADMIN_ROLE)).to.be.bignumber.equal('1');",
          "32:     expect(await this.token.getRoleMember(DEFAULT_ADMIN_ROLE, 0)).to.equal(deployer);",
          "33:   });",
          "35:   it('deployer has the minter role', async function () {",
          "36:     expect(await this.token.getRoleMemberCount(MINTER_ROLE)).to.be.bignumber.equal('1');",
          "37:     expect(await this.token.getRoleMember(MINTER_ROLE, 0)).to.equal(deployer);",
          "38:   });",
          "40:   it('deployer has the pauser role', async function () {",
          "41:     expect(await this.token.getRoleMemberCount(PAUSER_ROLE)).to.be.bignumber.equal('1');",
          "42:     expect(await this.token.getRoleMember(PAUSER_ROLE, 0)).to.equal(deployer);",
          "43:   });",
          "45:   it('minter and pauser role admin is the default admin', async function () {",
          "46:     expect(await this.token.getRoleAdmin(MINTER_ROLE)).to.equal(DEFAULT_ADMIN_ROLE);",
          "47:     expect(await this.token.getRoleAdmin(PAUSER_ROLE)).to.equal(DEFAULT_ADMIN_ROLE);",
          "48:   });",
          "50:   describe('minting', function () {",
          "51:     it('deployer can mint tokens', async function () {",
          "52:       const receipt = await this.token.mint(other, firstTokenId, firstTokenIdAmount, '0x', { from: deployer });",
          "53:       expectEvent(receipt, 'TransferSingle', {",
          "54:         operator: deployer,",
          "55:         from: ZERO_ADDRESS,",
          "56:         to: other,",
          "57:         value: firstTokenIdAmount,",
          "58:         id: firstTokenId,",
          "59:       });",
          "61:       expect(await this.token.balanceOf(other, firstTokenId)).to.be.bignumber.equal(firstTokenIdAmount);",
          "62:     });",
          "64:     it('other accounts cannot mint tokens', async function () {",
          "65:       await expectRevert(",
          "66:         this.token.mint(other, firstTokenId, firstTokenIdAmount, '0x', { from: other }),",
          "67:         'ERC1155PresetMinterPauser: must have minter role to mint',",
          "68:       );",
          "69:     });",
          "70:   });",
          "72:   describe('batched minting', function () {",
          "73:     it('deployer can batch mint tokens', async function () {",
          "74:       const receipt = await this.token.mintBatch(",
          "75:         other,",
          "76:         [firstTokenId, secondTokenId],",
          "77:         [firstTokenIdAmount, secondTokenIdAmount],",
          "78:         '0x',",
          "79:         { from: deployer },",
          "80:       );",
          "82:       expectEvent(receipt, 'TransferBatch', { operator: deployer, from: ZERO_ADDRESS, to: other });",
          "84:       expect(await this.token.balanceOf(other, firstTokenId)).to.be.bignumber.equal(firstTokenIdAmount);",
          "85:     });",
          "87:     it('other accounts cannot batch mint tokens', async function () {",
          "88:       await expectRevert(",
          "89:         this.token.mintBatch(other, [firstTokenId, secondTokenId], [firstTokenIdAmount, secondTokenIdAmount], '0x', {",
          "90:           from: other,",
          "91:         }),",
          "92:         'ERC1155PresetMinterPauser: must have minter role to mint',",
          "93:       );",
          "94:     });",
          "95:   });",
          "97:   describe('pausing', function () {",
          "98:     it('deployer can pause', async function () {",
          "99:       const receipt = await this.token.pause({ from: deployer });",
          "100:       expectEvent(receipt, 'Paused', { account: deployer });",
          "102:       expect(await this.token.paused()).to.equal(true);",
          "103:     });",
          "105:     it('deployer can unpause', async function () {",
          "106:       await this.token.pause({ from: deployer });",
          "108:       const receipt = await this.token.unpause({ from: deployer });",
          "109:       expectEvent(receipt, 'Unpaused', { account: deployer });",
          "111:       expect(await this.token.paused()).to.equal(false);",
          "112:     });",
          "114:     it('cannot mint while paused', async function () {",
          "115:       await this.token.pause({ from: deployer });",
          "117:       await expectRevert(",
          "118:         this.token.mint(other, firstTokenId, firstTokenIdAmount, '0x', { from: deployer }),",
          "119:         'ERC1155Pausable: token transfer while paused',",
          "120:       );",
          "121:     });",
          "123:     it('other accounts cannot pause', async function () {",
          "124:       await expectRevert(",
          "125:         this.token.pause({ from: other }),",
          "126:         'ERC1155PresetMinterPauser: must have pauser role to pause',",
          "127:       );",
          "128:     });",
          "130:     it('other accounts cannot unpause', async function () {",
          "131:       await this.token.pause({ from: deployer });",
          "133:       await expectRevert(",
          "134:         this.token.unpause({ from: other }),",
          "135:         'ERC1155PresetMinterPauser: must have pauser role to unpause',",
          "136:       );",
          "137:     });",
          "138:   });",
          "140:   describe('burning', function () {",
          "141:     it('holders can burn their tokens', async function () {",
          "142:       await this.token.mint(other, firstTokenId, firstTokenIdAmount, '0x', { from: deployer });",
          "144:       const receipt = await this.token.burn(other, firstTokenId, firstTokenIdAmount.subn(1), { from: other });",
          "145:       expectEvent(receipt, 'TransferSingle', {",
          "146:         operator: other,",
          "147:         from: other,",
          "148:         to: ZERO_ADDRESS,",
          "149:         value: firstTokenIdAmount.subn(1),",
          "150:         id: firstTokenId,",
          "151:       });",
          "153:       expect(await this.token.balanceOf(other, firstTokenId)).to.be.bignumber.equal('1');",
          "154:     });",
          "155:   });",
          "156: });",
          "",
          "---------------"
        ],
        "test/token/ERC1155/utils/ERC1155Holder.test.js||test/token/ERC1155/utils/ERC1155Holder.test.js": [
          "File: test/token/ERC1155/utils/ERC1155Holder.test.js -> test/token/ERC1155/utils/ERC1155Holder.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN } = require('@openzeppelin/test-helpers');",
          "3: const ERC1155Holder = artifacts.require('ERC1155Holder');",
          "4: const ERC1155 = artifacts.require('$ERC1155');",
          "6: const { expect } = require('chai');",
          "8: const { shouldSupportInterfaces } = require('../../../utils/introspection/SupportsInterface.behavior');",
          "10: contract('ERC1155Holder', function (accounts) {",
          "11:   const [creator] = accounts;",
          "12:   const uri = 'https://token-cdn-domain/{id}.json';",
          "13:   const multiTokenIds = [new BN(1), new BN(2), new BN(3)];",
          "14:   const multiTokenAmounts = [new BN(1000), new BN(2000), new BN(3000)];",
          "15:   const transferData = '0x12345678';",
          "17:   beforeEach(async function () {",
          "18:     this.multiToken = await ERC1155.new(uri);",
          "19:     this.holder = await ERC1155Holder.new();",
          "20:     await this.multiToken.$_mintBatch(creator, multiTokenIds, multiTokenAmounts, '0x');",
          "21:   });",
          "23:   shouldSupportInterfaces(['ERC165', 'ERC1155Receiver']);",
          "25:   it('receives ERC1155 tokens from a single ID', async function () {",
          "26:     await this.multiToken.safeTransferFrom(",
          "27:       creator,",
          "28:       this.holder.address,",
          "29:       multiTokenIds[0],",
          "30:       multiTokenAmounts[0],",
          "31:       transferData,",
          "32:       { from: creator },",
          "33:     );",
          "35:     expect(await this.multiToken.balanceOf(this.holder.address, multiTokenIds[0])).to.be.bignumber.equal(",
          "36:       multiTokenAmounts[0],",
          "37:     );",
          "39:     for (let i = 1; i < multiTokenIds.length; i++) {",
          "40:       expect(await this.multiToken.balanceOf(this.holder.address, multiTokenIds[i])).to.be.bignumber.equal(new BN(0));",
          "41:     }",
          "42:   });",
          "44:   it('receives ERC1155 tokens from a multiple IDs', async function () {",
          "45:     for (let i = 0; i < multiTokenIds.length; i++) {",
          "46:       expect(await this.multiToken.balanceOf(this.holder.address, multiTokenIds[i])).to.be.bignumber.equal(new BN(0));",
          "47:     }",
          "49:     await this.multiToken.safeBatchTransferFrom(",
          "50:       creator,",
          "51:       this.holder.address,",
          "52:       multiTokenIds,",
          "53:       multiTokenAmounts,",
          "54:       transferData,",
          "55:       { from: creator },",
          "56:     );",
          "58:     for (let i = 0; i < multiTokenIds.length; i++) {",
          "59:       expect(await this.multiToken.balanceOf(this.holder.address, multiTokenIds[i])).to.be.bignumber.equal(",
          "60:         multiTokenAmounts[i],",
          "61:       );",
          "62:     }",
          "63:   });",
          "64: });",
          "",
          "---------------"
        ],
        "test/token/ERC20/ERC20.behavior.js||test/token/ERC20/ERC20.behavior.js": [
          "File: test/token/ERC20/ERC20.behavior.js -> test/token/ERC20/ERC20.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const { ZERO_ADDRESS, MAX_UINT256 } = constants;",
          "5: function shouldBehaveLikeERC20(errorPrefix, initialSupply, initialHolder, recipient, anotherAccount) {",
          "6:   describe('total supply', function () {",
          "7:     it('returns the total amount of tokens', async function () {",
          "8:       expect(await this.token.totalSupply()).to.be.bignumber.equal(initialSupply);",
          "9:     });",
          "10:   });",
          "12:   describe('balanceOf', function () {",
          "13:     describe('when the requested account has no tokens', function () {",
          "14:       it('returns zero', async function () {",
          "15:         expect(await this.token.balanceOf(anotherAccount)).to.be.bignumber.equal('0');",
          "16:       });",
          "17:     });",
          "19:     describe('when the requested account has some tokens', function () {",
          "20:       it('returns the total amount of tokens', async function () {",
          "21:         expect(await this.token.balanceOf(initialHolder)).to.be.bignumber.equal(initialSupply);",
          "22:       });",
          "23:     });",
          "24:   });",
          "26:   describe('transfer', function () {",
          "27:     shouldBehaveLikeERC20Transfer(errorPrefix, initialHolder, recipient, initialSupply, function (from, to, value) {",
          "28:       return this.token.transfer(to, value, { from });",
          "29:     });",
          "30:   });",
          "32:   describe('transfer from', function () {",
          "33:     const spender = recipient;",
          "35:     describe('when the token owner is not the zero address', function () {",
          "36:       const tokenOwner = initialHolder;",
          "38:       describe('when the recipient is not the zero address', function () {",
          "39:         const to = anotherAccount;",
          "41:         describe('when the spender has enough allowance', function () {",
          "42:           beforeEach(async function () {",
          "43:             await this.token.approve(spender, initialSupply, { from: initialHolder });",
          "44:           });",
          "46:           describe('when the token owner has enough balance', function () {",
          "47:             const amount = initialSupply;",
          "49:             it('transfers the requested amount', async function () {",
          "50:               await this.token.transferFrom(tokenOwner, to, amount, { from: spender });",
          "52:               expect(await this.token.balanceOf(tokenOwner)).to.be.bignumber.equal('0');",
          "54:               expect(await this.token.balanceOf(to)).to.be.bignumber.equal(amount);",
          "55:             });",
          "57:             it('decreases the spender allowance', async function () {",
          "58:               await this.token.transferFrom(tokenOwner, to, amount, { from: spender });",
          "60:               expect(await this.token.allowance(tokenOwner, spender)).to.be.bignumber.equal('0');",
          "61:             });",
          "63:             it('emits a transfer event', async function () {",
          "64:               expectEvent(await this.token.transferFrom(tokenOwner, to, amount, { from: spender }), 'Transfer', {",
          "65:                 from: tokenOwner,",
          "66:                 to: to,",
          "67:                 value: amount,",
          "68:               });",
          "69:             });",
          "71:             it('emits an approval event', async function () {",
          "72:               expectEvent(await this.token.transferFrom(tokenOwner, to, amount, { from: spender }), 'Approval', {",
          "73:                 owner: tokenOwner,",
          "74:                 spender: spender,",
          "75:                 value: await this.token.allowance(tokenOwner, spender),",
          "76:               });",
          "77:             });",
          "78:           });",
          "80:           describe('when the token owner does not have enough balance', function () {",
          "81:             const amount = initialSupply;",
          "83:             beforeEach('reducing balance', async function () {",
          "84:               await this.token.transfer(to, 1, { from: tokenOwner });",
          "85:             });",
          "87:             it('reverts', async function () {",
          "88:               await expectRevert(",
          "89:                 this.token.transferFrom(tokenOwner, to, amount, { from: spender }),",
          "90:                 `${errorPrefix}: transfer amount exceeds balance`,",
          "91:               );",
          "92:             });",
          "93:           });",
          "94:         });",
          "96:         describe('when the spender does not have enough allowance', function () {",
          "97:           const allowance = initialSupply.subn(1);",
          "99:           beforeEach(async function () {",
          "100:             await this.token.approve(spender, allowance, { from: tokenOwner });",
          "101:           });",
          "103:           describe('when the token owner has enough balance', function () {",
          "104:             const amount = initialSupply;",
          "106:             it('reverts', async function () {",
          "107:               await expectRevert(",
          "108:                 this.token.transferFrom(tokenOwner, to, amount, { from: spender }),",
          "109:                 `${errorPrefix}: insufficient allowance`,",
          "110:               );",
          "111:             });",
          "112:           });",
          "114:           describe('when the token owner does not have enough balance', function () {",
          "115:             const amount = allowance;",
          "117:             beforeEach('reducing balance', async function () {",
          "118:               await this.token.transfer(to, 2, { from: tokenOwner });",
          "119:             });",
          "121:             it('reverts', async function () {",
          "122:               await expectRevert(",
          "123:                 this.token.transferFrom(tokenOwner, to, amount, { from: spender }),",
          "124:                 `${errorPrefix}: transfer amount exceeds balance`,",
          "125:               );",
          "126:             });",
          "127:           });",
          "128:         });",
          "130:         describe('when the spender has unlimited allowance', function () {",
          "131:           beforeEach(async function () {",
          "132:             await this.token.approve(spender, MAX_UINT256, { from: initialHolder });",
          "133:           });",
          "135:           it('does not decrease the spender allowance', async function () {",
          "136:             await this.token.transferFrom(tokenOwner, to, 1, { from: spender });",
          "138:             expect(await this.token.allowance(tokenOwner, spender)).to.be.bignumber.equal(MAX_UINT256);",
          "139:           });",
          "141:           it('does not emit an approval event', async function () {",
          "142:             expectEvent.notEmitted(await this.token.transferFrom(tokenOwner, to, 1, { from: spender }), 'Approval');",
          "143:           });",
          "144:         });",
          "145:       });",
          "147:       describe('when the recipient is the zero address', function () {",
          "148:         const amount = initialSupply;",
          "149:         const to = ZERO_ADDRESS;",
          "151:         beforeEach(async function () {",
          "152:           await this.token.approve(spender, amount, { from: tokenOwner });",
          "153:         });",
          "155:         it('reverts', async function () {",
          "156:           await expectRevert(",
          "157:             this.token.transferFrom(tokenOwner, to, amount, { from: spender }),",
          "158:             `${errorPrefix}: transfer to the zero address`,",
          "159:           );",
          "160:         });",
          "161:       });",
          "162:     });",
          "164:     describe('when the token owner is the zero address', function () {",
          "165:       const amount = 0;",
          "166:       const tokenOwner = ZERO_ADDRESS;",
          "167:       const to = recipient;",
          "169:       it('reverts', async function () {",
          "170:         await expectRevert(this.token.transferFrom(tokenOwner, to, amount, { from: spender }), 'from the zero address');",
          "171:       });",
          "172:     });",
          "173:   });",
          "175:   describe('approve', function () {",
          "176:     shouldBehaveLikeERC20Approve(",
          "177:       errorPrefix,",
          "178:       initialHolder,",
          "179:       recipient,",
          "180:       initialSupply,",
          "181:       function (owner, spender, amount) {",
          "182:         return this.token.approve(spender, amount, { from: owner });",
          "183:       },",
          "184:     );",
          "185:   });",
          "186: }",
          "188: function shouldBehaveLikeERC20Transfer(errorPrefix, from, to, balance, transfer) {",
          "189:   describe('when the recipient is not the zero address', function () {",
          "190:     describe('when the sender does not have enough balance', function () {",
          "191:       const amount = balance.addn(1);",
          "193:       it('reverts', async function () {",
          "194:         await expectRevert(transfer.call(this, from, to, amount), `${errorPrefix}: transfer amount exceeds balance`);",
          "195:       });",
          "196:     });",
          "198:     describe('when the sender transfers all balance', function () {",
          "199:       const amount = balance;",
          "201:       it('transfers the requested amount', async function () {",
          "202:         await transfer.call(this, from, to, amount);",
          "204:         expect(await this.token.balanceOf(from)).to.be.bignumber.equal('0');",
          "206:         expect(await this.token.balanceOf(to)).to.be.bignumber.equal(amount);",
          "207:       });",
          "209:       it('emits a transfer event', async function () {",
          "210:         expectEvent(await transfer.call(this, from, to, amount), 'Transfer', { from, to, value: amount });",
          "211:       });",
          "212:     });",
          "214:     describe('when the sender transfers zero tokens', function () {",
          "215:       const amount = new BN('0');",
          "217:       it('transfers the requested amount', async function () {",
          "218:         await transfer.call(this, from, to, amount);",
          "220:         expect(await this.token.balanceOf(from)).to.be.bignumber.equal(balance);",
          "222:         expect(await this.token.balanceOf(to)).to.be.bignumber.equal('0');",
          "223:       });",
          "225:       it('emits a transfer event', async function () {",
          "226:         expectEvent(await transfer.call(this, from, to, amount), 'Transfer', { from, to, value: amount });",
          "227:       });",
          "228:     });",
          "229:   });",
          "231:   describe('when the recipient is the zero address', function () {",
          "232:     it('reverts', async function () {",
          "233:       await expectRevert(",
          "234:         transfer.call(this, from, ZERO_ADDRESS, balance),",
          "235:         `${errorPrefix}: transfer to the zero address`,",
          "236:       );",
          "237:     });",
          "238:   });",
          "239: }",
          "241: function shouldBehaveLikeERC20Approve(errorPrefix, owner, spender, supply, approve) {",
          "242:   describe('when the spender is not the zero address', function () {",
          "243:     describe('when the sender has enough balance', function () {",
          "244:       const amount = supply;",
          "246:       it('emits an approval event', async function () {",
          "247:         expectEvent(await approve.call(this, owner, spender, amount), 'Approval', {",
          "248:           owner: owner,",
          "249:           spender: spender,",
          "250:           value: amount,",
          "251:         });",
          "252:       });",
          "254:       describe('when there was no approved amount before', function () {",
          "255:         it('approves the requested amount', async function () {",
          "256:           await approve.call(this, owner, spender, amount);",
          "258:           expect(await this.token.allowance(owner, spender)).to.be.bignumber.equal(amount);",
          "259:         });",
          "260:       });",
          "262:       describe('when the spender had an approved amount', function () {",
          "263:         beforeEach(async function () {",
          "264:           await approve.call(this, owner, spender, new BN(1));",
          "265:         });",
          "267:         it('approves the requested amount and replaces the previous one', async function () {",
          "268:           await approve.call(this, owner, spender, amount);",
          "270:           expect(await this.token.allowance(owner, spender)).to.be.bignumber.equal(amount);",
          "271:         });",
          "272:       });",
          "273:     });",
          "275:     describe('when the sender does not have enough balance', function () {",
          "276:       const amount = supply.addn(1);",
          "278:       it('emits an approval event', async function () {",
          "279:         expectEvent(await approve.call(this, owner, spender, amount), 'Approval', {",
          "280:           owner: owner,",
          "281:           spender: spender,",
          "282:           value: amount,",
          "283:         });",
          "284:       });",
          "286:       describe('when there was no approved amount before', function () {",
          "287:         it('approves the requested amount', async function () {",
          "288:           await approve.call(this, owner, spender, amount);",
          "290:           expect(await this.token.allowance(owner, spender)).to.be.bignumber.equal(amount);",
          "291:         });",
          "292:       });",
          "294:       describe('when the spender had an approved amount', function () {",
          "295:         beforeEach(async function () {",
          "296:           await approve.call(this, owner, spender, new BN(1));",
          "297:         });",
          "299:         it('approves the requested amount and replaces the previous one', async function () {",
          "300:           await approve.call(this, owner, spender, amount);",
          "302:           expect(await this.token.allowance(owner, spender)).to.be.bignumber.equal(amount);",
          "303:         });",
          "304:       });",
          "305:     });",
          "306:   });",
          "308:   describe('when the spender is the zero address', function () {",
          "309:     it('reverts', async function () {",
          "310:       await expectRevert(",
          "311:         approve.call(this, owner, ZERO_ADDRESS, supply),",
          "312:         `${errorPrefix}: approve to the zero address`,",
          "313:       );",
          "314:     });",
          "315:   });",
          "316: }",
          "318: module.exports = {",
          "319:   shouldBehaveLikeERC20,",
          "320:   shouldBehaveLikeERC20Transfer,",
          "321:   shouldBehaveLikeERC20Approve,",
          "322: };",
          "",
          "---------------"
        ],
        "test/token/ERC20/ERC20.test.js||test/token/ERC20/ERC20.test.js": [
          "File: test/token/ERC20/ERC20.test.js -> test/token/ERC20/ERC20.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const { ZERO_ADDRESS } = constants;",
          "5: const {",
          "6:   shouldBehaveLikeERC20,",
          "7:   shouldBehaveLikeERC20Transfer,",
          "8:   shouldBehaveLikeERC20Approve,",
          "9: } = require('./ERC20.behavior');",
          "11: const ERC20 = artifacts.require('$ERC20');",
          "12: const ERC20Decimals = artifacts.require('$ERC20DecimalsMock');",
          "14: contract('ERC20', function (accounts) {",
          "15:   const [initialHolder, recipient, anotherAccount] = accounts;",
          "17:   const name = 'My Token';",
          "18:   const symbol = 'MTKN';",
          "20:   const initialSupply = new BN(100);",
          "22:   beforeEach(async function () {",
          "23:     this.token = await ERC20.new(name, symbol);",
          "24:     await this.token.$_mint(initialHolder, initialSupply);",
          "25:   });",
          "27:   it('has a name', async function () {",
          "28:     expect(await this.token.name()).to.equal(name);",
          "29:   });",
          "31:   it('has a symbol', async function () {",
          "32:     expect(await this.token.symbol()).to.equal(symbol);",
          "33:   });",
          "35:   it('has 18 decimals', async function () {",
          "36:     expect(await this.token.decimals()).to.be.bignumber.equal('18');",
          "37:   });",
          "39:   describe('set decimals', function () {",
          "40:     const decimals = new BN(6);",
          "42:     it('can set decimals during construction', async function () {",
          "43:       const token = await ERC20Decimals.new(name, symbol, decimals);",
          "44:       expect(await token.decimals()).to.be.bignumber.equal(decimals);",
          "45:     });",
          "46:   });",
          "48:   shouldBehaveLikeERC20('ERC20', initialSupply, initialHolder, recipient, anotherAccount);",
          "50:   describe('decrease allowance', function () {",
          "51:     describe('when the spender is not the zero address', function () {",
          "52:       const spender = recipient;",
          "54:       function shouldDecreaseApproval(amount) {",
          "55:         describe('when there was no approved amount before', function () {",
          "56:           it('reverts', async function () {",
          "57:             await expectRevert(",
          "58:               this.token.decreaseAllowance(spender, amount, { from: initialHolder }),",
          "59:               'ERC20: decreased allowance below zero',",
          "60:             );",
          "61:           });",
          "62:         });",
          "64:         describe('when the spender had an approved amount', function () {",
          "65:           const approvedAmount = amount;",
          "67:           beforeEach(async function () {",
          "68:             await this.token.approve(spender, approvedAmount, { from: initialHolder });",
          "69:           });",
          "71:           it('emits an approval event', async function () {",
          "72:             expectEvent(",
          "73:               await this.token.decreaseAllowance(spender, approvedAmount, { from: initialHolder }),",
          "74:               'Approval',",
          "75:               { owner: initialHolder, spender: spender, value: new BN(0) },",
          "76:             );",
          "77:           });",
          "79:           it('decreases the spender allowance subtracting the requested amount', async function () {",
          "80:             await this.token.decreaseAllowance(spender, approvedAmount.subn(1), { from: initialHolder });",
          "82:             expect(await this.token.allowance(initialHolder, spender)).to.be.bignumber.equal('1');",
          "83:           });",
          "85:           it('sets the allowance to zero when all allowance is removed', async function () {",
          "86:             await this.token.decreaseAllowance(spender, approvedAmount, { from: initialHolder });",
          "87:             expect(await this.token.allowance(initialHolder, spender)).to.be.bignumber.equal('0');",
          "88:           });",
          "90:           it('reverts when more than the full allowance is removed', async function () {",
          "91:             await expectRevert(",
          "92:               this.token.decreaseAllowance(spender, approvedAmount.addn(1), { from: initialHolder }),",
          "93:               'ERC20: decreased allowance below zero',",
          "94:             );",
          "95:           });",
          "96:         });",
          "97:       }",
          "99:       describe('when the sender has enough balance', function () {",
          "100:         const amount = initialSupply;",
          "102:         shouldDecreaseApproval(amount);",
          "103:       });",
          "105:       describe('when the sender does not have enough balance', function () {",
          "106:         const amount = initialSupply.addn(1);",
          "108:         shouldDecreaseApproval(amount);",
          "109:       });",
          "110:     });",
          "112:     describe('when the spender is the zero address', function () {",
          "113:       const amount = initialSupply;",
          "114:       const spender = ZERO_ADDRESS;",
          "116:       it('reverts', async function () {",
          "117:         await expectRevert(",
          "118:           this.token.decreaseAllowance(spender, amount, { from: initialHolder }),",
          "119:           'ERC20: decreased allowance below zero',",
          "120:         );",
          "121:       });",
          "122:     });",
          "123:   });",
          "125:   describe('increase allowance', function () {",
          "126:     const amount = initialSupply;",
          "128:     describe('when the spender is not the zero address', function () {",
          "129:       const spender = recipient;",
          "131:       describe('when the sender has enough balance', function () {",
          "132:         it('emits an approval event', async function () {",
          "133:           expectEvent(await this.token.increaseAllowance(spender, amount, { from: initialHolder }), 'Approval', {",
          "134:             owner: initialHolder,",
          "135:             spender: spender,",
          "136:             value: amount,",
          "137:           });",
          "138:         });",
          "140:         describe('when there was no approved amount before', function () {",
          "141:           it('approves the requested amount', async function () {",
          "142:             await this.token.increaseAllowance(spender, amount, { from: initialHolder });",
          "144:             expect(await this.token.allowance(initialHolder, spender)).to.be.bignumber.equal(amount);",
          "145:           });",
          "146:         });",
          "148:         describe('when the spender had an approved amount', function () {",
          "149:           beforeEach(async function () {",
          "150:             await this.token.approve(spender, new BN(1), { from: initialHolder });",
          "151:           });",
          "153:           it('increases the spender allowance adding the requested amount', async function () {",
          "154:             await this.token.increaseAllowance(spender, amount, { from: initialHolder });",
          "156:             expect(await this.token.allowance(initialHolder, spender)).to.be.bignumber.equal(amount.addn(1));",
          "157:           });",
          "158:         });",
          "159:       });",
          "161:       describe('when the sender does not have enough balance', function () {",
          "162:         const amount = initialSupply.addn(1);",
          "164:         it('emits an approval event', async function () {",
          "165:           expectEvent(await this.token.increaseAllowance(spender, amount, { from: initialHolder }), 'Approval', {",
          "166:             owner: initialHolder,",
          "167:             spender: spender,",
          "168:             value: amount,",
          "169:           });",
          "170:         });",
          "172:         describe('when there was no approved amount before', function () {",
          "173:           it('approves the requested amount', async function () {",
          "174:             await this.token.increaseAllowance(spender, amount, { from: initialHolder });",
          "176:             expect(await this.token.allowance(initialHolder, spender)).to.be.bignumber.equal(amount);",
          "177:           });",
          "178:         });",
          "180:         describe('when the spender had an approved amount', function () {",
          "181:           beforeEach(async function () {",
          "182:             await this.token.approve(spender, new BN(1), { from: initialHolder });",
          "183:           });",
          "185:           it('increases the spender allowance adding the requested amount', async function () {",
          "186:             await this.token.increaseAllowance(spender, amount, { from: initialHolder });",
          "188:             expect(await this.token.allowance(initialHolder, spender)).to.be.bignumber.equal(amount.addn(1));",
          "189:           });",
          "190:         });",
          "191:       });",
          "192:     });",
          "194:     describe('when the spender is the zero address', function () {",
          "195:       const spender = ZERO_ADDRESS;",
          "197:       it('reverts', async function () {",
          "198:         await expectRevert(",
          "199:           this.token.increaseAllowance(spender, amount, { from: initialHolder }),",
          "200:           'ERC20: approve to the zero address',",
          "201:         );",
          "202:       });",
          "203:     });",
          "204:   });",
          "206:   describe('_mint', function () {",
          "207:     const amount = new BN(50);",
          "208:     it('rejects a null account', async function () {",
          "209:       await expectRevert(this.token.$_mint(ZERO_ADDRESS, amount), 'ERC20: mint to the zero address');",
          "210:     });",
          "212:     describe('for a non zero account', function () {",
          "213:       beforeEach('minting', async function () {",
          "214:         this.receipt = await this.token.$_mint(recipient, amount);",
          "215:       });",
          "217:       it('increments totalSupply', async function () {",
          "218:         const expectedSupply = initialSupply.add(amount);",
          "219:         expect(await this.token.totalSupply()).to.be.bignumber.equal(expectedSupply);",
          "220:       });",
          "222:       it('increments recipient balance', async function () {",
          "223:         expect(await this.token.balanceOf(recipient)).to.be.bignumber.equal(amount);",
          "224:       });",
          "226:       it('emits Transfer event', async function () {",
          "227:         const event = expectEvent(this.receipt, 'Transfer', { from: ZERO_ADDRESS, to: recipient });",
          "229:         expect(event.args.value).to.be.bignumber.equal(amount);",
          "230:       });",
          "231:     });",
          "232:   });",
          "234:   describe('_burn', function () {",
          "235:     it('rejects a null account', async function () {",
          "236:       await expectRevert(this.token.$_burn(ZERO_ADDRESS, new BN(1)), 'ERC20: burn from the zero address');",
          "237:     });",
          "239:     describe('for a non zero account', function () {",
          "240:       it('rejects burning more than balance', async function () {",
          "241:         await expectRevert(",
          "242:           this.token.$_burn(initialHolder, initialSupply.addn(1)),",
          "243:           'ERC20: burn amount exceeds balance',",
          "244:         );",
          "245:       });",
          "247:       const describeBurn = function (description, amount) {",
          "248:         describe(description, function () {",
          "249:           beforeEach('burning', async function () {",
          "250:             this.receipt = await this.token.$_burn(initialHolder, amount);",
          "251:           });",
          "253:           it('decrements totalSupply', async function () {",
          "254:             const expectedSupply = initialSupply.sub(amount);",
          "255:             expect(await this.token.totalSupply()).to.be.bignumber.equal(expectedSupply);",
          "256:           });",
          "258:           it('decrements initialHolder balance', async function () {",
          "259:             const expectedBalance = initialSupply.sub(amount);",
          "260:             expect(await this.token.balanceOf(initialHolder)).to.be.bignumber.equal(expectedBalance);",
          "261:           });",
          "263:           it('emits Transfer event', async function () {",
          "264:             const event = expectEvent(this.receipt, 'Transfer', { from: initialHolder, to: ZERO_ADDRESS });",
          "266:             expect(event.args.value).to.be.bignumber.equal(amount);",
          "267:           });",
          "268:         });",
          "269:       };",
          "271:       describeBurn('for entire balance', initialSupply);",
          "272:       describeBurn('for less amount than balance', initialSupply.subn(1));",
          "273:     });",
          "274:   });",
          "276:   describe('_transfer', function () {",
          "277:     shouldBehaveLikeERC20Transfer('ERC20', initialHolder, recipient, initialSupply, function (from, to, amount) {",
          "278:       return this.token.$_transfer(from, to, amount);",
          "279:     });",
          "281:     describe('when the sender is the zero address', function () {",
          "282:       it('reverts', async function () {",
          "283:         await expectRevert(",
          "284:           this.token.$_transfer(ZERO_ADDRESS, recipient, initialSupply),",
          "285:           'ERC20: transfer from the zero address',",
          "286:         );",
          "287:       });",
          "288:     });",
          "289:   });",
          "291:   describe('_approve', function () {",
          "292:     shouldBehaveLikeERC20Approve('ERC20', initialHolder, recipient, initialSupply, function (owner, spender, amount) {",
          "293:       return this.token.$_approve(owner, spender, amount);",
          "294:     });",
          "296:     describe('when the owner is the zero address', function () {",
          "297:       it('reverts', async function () {",
          "298:         await expectRevert(",
          "299:           this.token.$_approve(ZERO_ADDRESS, recipient, initialSupply),",
          "300:           'ERC20: approve from the zero address',",
          "301:         );",
          "302:       });",
          "303:     });",
          "304:   });",
          "305: });",
          "",
          "---------------"
        ],
        "test/token/ERC20/extensions/ERC20Burnable.behavior.js||test/token/ERC20/extensions/ERC20Burnable.behavior.js": [
          "File: test/token/ERC20/extensions/ERC20Burnable.behavior.js -> test/token/ERC20/extensions/ERC20Burnable.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS } = constants;",
          "4: const { expect } = require('chai');",
          "6: function shouldBehaveLikeERC20Burnable(owner, initialBalance, [burner]) {",
          "7:   describe('burn', function () {",
          "8:     describe('when the given amount is not greater than balance of the sender', function () {",
          "9:       context('for a zero amount', function () {",
          "10:         shouldBurn(new BN(0));",
          "11:       });",
          "13:       context('for a non-zero amount', function () {",
          "14:         shouldBurn(new BN(100));",
          "15:       });",
          "17:       function shouldBurn(amount) {",
          "18:         beforeEach(async function () {",
          "19:           this.receipt = await this.token.burn(amount, { from: owner });",
          "20:         });",
          "22:         it('burns the requested amount', async function () {",
          "23:           expect(await this.token.balanceOf(owner)).to.be.bignumber.equal(initialBalance.sub(amount));",
          "24:         });",
          "26:         it('emits a transfer event', async function () {",
          "27:           expectEvent(this.receipt, 'Transfer', {",
          "28:             from: owner,",
          "29:             to: ZERO_ADDRESS,",
          "30:             value: amount,",
          "31:           });",
          "32:         });",
          "33:       }",
          "34:     });",
          "36:     describe('when the given amount is greater than the balance of the sender', function () {",
          "37:       const amount = initialBalance.addn(1);",
          "39:       it('reverts', async function () {",
          "40:         await expectRevert(this.token.burn(amount, { from: owner }), 'ERC20: burn amount exceeds balance');",
          "41:       });",
          "42:     });",
          "43:   });",
          "45:   describe('burnFrom', function () {",
          "46:     describe('on success', function () {",
          "47:       context('for a zero amount', function () {",
          "48:         shouldBurnFrom(new BN(0));",
          "49:       });",
          "51:       context('for a non-zero amount', function () {",
          "52:         shouldBurnFrom(new BN(100));",
          "53:       });",
          "55:       function shouldBurnFrom(amount) {",
          "56:         const originalAllowance = amount.muln(3);",
          "58:         beforeEach(async function () {",
          "59:           await this.token.approve(burner, originalAllowance, { from: owner });",
          "60:           this.receipt = await this.token.burnFrom(owner, amount, { from: burner });",
          "61:         });",
          "63:         it('burns the requested amount', async function () {",
          "64:           expect(await this.token.balanceOf(owner)).to.be.bignumber.equal(initialBalance.sub(amount));",
          "65:         });",
          "67:         it('decrements allowance', async function () {",
          "68:           expect(await this.token.allowance(owner, burner)).to.be.bignumber.equal(originalAllowance.sub(amount));",
          "69:         });",
          "71:         it('emits a transfer event', async function () {",
          "72:           expectEvent(this.receipt, 'Transfer', {",
          "73:             from: owner,",
          "74:             to: ZERO_ADDRESS,",
          "75:             value: amount,",
          "76:           });",
          "77:         });",
          "78:       }",
          "79:     });",
          "81:     describe('when the given amount is greater than the balance of the sender', function () {",
          "82:       const amount = initialBalance.addn(1);",
          "84:       it('reverts', async function () {",
          "85:         await this.token.approve(burner, amount, { from: owner });",
          "86:         await expectRevert(this.token.burnFrom(owner, amount, { from: burner }), 'ERC20: burn amount exceeds balance');",
          "87:       });",
          "88:     });",
          "90:     describe('when the given amount is greater than the allowance', function () {",
          "91:       const allowance = new BN(100);",
          "93:       it('reverts', async function () {",
          "94:         await this.token.approve(burner, allowance, { from: owner });",
          "95:         await expectRevert(",
          "96:           this.token.burnFrom(owner, allowance.addn(1), { from: burner }),",
          "97:           'ERC20: insufficient allowance',",
          "98:         );",
          "99:       });",
          "100:     });",
          "101:   });",
          "102: }",
          "104: module.exports = {",
          "105:   shouldBehaveLikeERC20Burnable,",
          "106: };",
          "",
          "---------------"
        ],
        "test/token/ERC20/extensions/ERC20Burnable.test.js||test/token/ERC20/extensions/ERC20Burnable.test.js": [
          "File: test/token/ERC20/extensions/ERC20Burnable.test.js -> test/token/ERC20/extensions/ERC20Burnable.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN } = require('@openzeppelin/test-helpers');",
          "3: const { shouldBehaveLikeERC20Burnable } = require('./ERC20Burnable.behavior');",
          "4: const ERC20Burnable = artifacts.require('$ERC20Burnable');",
          "6: contract('ERC20Burnable', function (accounts) {",
          "7:   const [owner, ...otherAccounts] = accounts;",
          "9:   const initialBalance = new BN(1000);",
          "11:   const name = 'My Token';",
          "12:   const symbol = 'MTKN';",
          "14:   beforeEach(async function () {",
          "15:     this.token = await ERC20Burnable.new(name, symbol, { from: owner });",
          "16:     await this.token.$_mint(owner, initialBalance);",
          "17:   });",
          "19:   shouldBehaveLikeERC20Burnable(owner, initialBalance, otherAccounts);",
          "20: });",
          "",
          "---------------"
        ],
        "test/token/ERC20/extensions/ERC20Capped.behavior.js||test/token/ERC20/extensions/ERC20Capped.behavior.js": [
          "File: test/token/ERC20/extensions/ERC20Capped.behavior.js -> test/token/ERC20/extensions/ERC20Capped.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: function shouldBehaveLikeERC20Capped(accounts, cap) {",
          "6:   describe('capped token', function () {",
          "7:     const user = accounts[0];",
          "9:     it('starts with the correct cap', async function () {",
          "10:       expect(await this.token.cap()).to.be.bignumber.equal(cap);",
          "11:     });",
          "13:     it('mints when amount is less than cap', async function () {",
          "14:       await this.token.$_mint(user, cap.subn(1));",
          "15:       expect(await this.token.totalSupply()).to.be.bignumber.equal(cap.subn(1));",
          "16:     });",
          "18:     it('fails to mint if the amount exceeds the cap', async function () {",
          "19:       await this.token.$_mint(user, cap.subn(1));",
          "20:       await expectRevert(this.token.$_mint(user, 2), 'ERC20Capped: cap exceeded');",
          "21:     });",
          "23:     it('fails to mint after cap is reached', async function () {",
          "24:       await this.token.$_mint(user, cap);",
          "25:       await expectRevert(this.token.$_mint(user, 1), 'ERC20Capped: cap exceeded');",
          "26:     });",
          "27:   });",
          "28: }",
          "30: module.exports = {",
          "31:   shouldBehaveLikeERC20Capped,",
          "32: };",
          "",
          "---------------"
        ],
        "test/token/ERC20/extensions/ERC20Capped.test.js||test/token/ERC20/extensions/ERC20Capped.test.js": [
          "File: test/token/ERC20/extensions/ERC20Capped.test.js -> test/token/ERC20/extensions/ERC20Capped.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { ether, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { shouldBehaveLikeERC20Capped } = require('./ERC20Capped.behavior');",
          "4: const ERC20Capped = artifacts.require('$ERC20Capped');",
          "6: contract('ERC20Capped', function (accounts) {",
          "7:   const cap = ether('1000');",
          "9:   const name = 'My Token';",
          "10:   const symbol = 'MTKN';",
          "12:   it('requires a non-zero cap', async function () {",
          "13:     await expectRevert(ERC20Capped.new(name, symbol, 0), 'ERC20Capped: cap is 0');",
          "14:   });",
          "16:   context('once deployed', async function () {",
          "17:     beforeEach(async function () {",
          "18:       this.token = await ERC20Capped.new(name, symbol, cap);",
          "19:     });",
          "21:     shouldBehaveLikeERC20Capped(accounts, cap);",
          "22:   });",
          "23: });",
          "",
          "---------------"
        ],
        "test/token/ERC20/extensions/ERC20FlashMint.test.js||test/token/ERC20/extensions/ERC20FlashMint.test.js": [
          "File: test/token/ERC20/extensions/ERC20FlashMint.test.js -> test/token/ERC20/extensions/ERC20FlashMint.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: const { BN, constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "4: const { expect } = require('chai');",
          "5: const { MAX_UINT256, ZERO_ADDRESS } = constants;",
          "7: const ERC20FlashMintMock = artifacts.require('$ERC20FlashMintMock');",
          "8: const ERC3156FlashBorrowerMock = artifacts.require('ERC3156FlashBorrowerMock');",
          "10: contract('ERC20FlashMint', function (accounts) {",
          "11:   const [initialHolder, other, anotherAccount] = accounts;",
          "13:   const name = 'My Token';",
          "14:   const symbol = 'MTKN';",
          "16:   const initialSupply = new BN(100);",
          "17:   const loanAmount = new BN(10000000000000);",
          "19:   beforeEach(async function () {",
          "20:     this.token = await ERC20FlashMintMock.new(name, symbol);",
          "21:     await this.token.$_mint(initialHolder, initialSupply);",
          "22:   });",
          "24:   describe('maxFlashLoan', function () {",
          "25:     it('token match', async function () {",
          "26:       expect(await this.token.maxFlashLoan(this.token.address)).to.be.bignumber.equal(MAX_UINT256.sub(initialSupply));",
          "27:     });",
          "29:     it('token mismatch', async function () {",
          "30:       expect(await this.token.maxFlashLoan(ZERO_ADDRESS)).to.be.bignumber.equal('0');",
          "31:     });",
          "32:   });",
          "34:   describe('flashFee', function () {",
          "35:     it('token match', async function () {",
          "36:       expect(await this.token.flashFee(this.token.address, loanAmount)).to.be.bignumber.equal('0');",
          "37:     });",
          "39:     it('token mismatch', async function () {",
          "40:       await expectRevert(this.token.flashFee(ZERO_ADDRESS, loanAmount), 'ERC20FlashMint: wrong token');",
          "41:     });",
          "42:   });",
          "44:   describe('flashFeeReceiver', function () {",
          "45:     it('default receiver', async function () {",
          "46:       expect(await this.token.$_flashFeeReceiver()).to.be.eq(ZERO_ADDRESS);",
          "47:     });",
          "48:   });",
          "50:   describe('flashLoan', function () {",
          "51:     it('success', async function () {",
          "52:       const receiver = await ERC3156FlashBorrowerMock.new(true, true);",
          "53:       const { tx } = await this.token.flashLoan(receiver.address, this.token.address, loanAmount, '0x');",
          "55:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "56:         from: ZERO_ADDRESS,",
          "57:         to: receiver.address,",
          "58:         value: loanAmount,",
          "59:       });",
          "60:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "61:         from: receiver.address,",
          "62:         to: ZERO_ADDRESS,",
          "63:         value: loanAmount,",
          "64:       });",
          "65:       await expectEvent.inTransaction(tx, receiver, 'BalanceOf', {",
          "66:         token: this.token.address,",
          "67:         account: receiver.address,",
          "68:         value: loanAmount,",
          "69:       });",
          "70:       await expectEvent.inTransaction(tx, receiver, 'TotalSupply', {",
          "71:         token: this.token.address,",
          "72:         value: initialSupply.add(loanAmount),",
          "73:       });",
          "75:       expect(await this.token.totalSupply()).to.be.bignumber.equal(initialSupply);",
          "76:       expect(await this.token.balanceOf(receiver.address)).to.be.bignumber.equal('0');",
          "77:       expect(await this.token.allowance(receiver.address, this.token.address)).to.be.bignumber.equal('0');",
          "78:     });",
          "80:     it('missing return value', async function () {",
          "81:       const receiver = await ERC3156FlashBorrowerMock.new(false, true);",
          "82:       await expectRevert(",
          "83:         this.token.flashLoan(receiver.address, this.token.address, loanAmount, '0x'),",
          "84:         'ERC20FlashMint: invalid return value',",
          "85:       );",
          "86:     });",
          "88:     it('missing approval', async function () {",
          "89:       const receiver = await ERC3156FlashBorrowerMock.new(true, false);",
          "90:       await expectRevert(",
          "91:         this.token.flashLoan(receiver.address, this.token.address, loanAmount, '0x'),",
          "92:         'ERC20: insufficient allowance',",
          "93:       );",
          "94:     });",
          "96:     it('unavailable funds', async function () {",
          "97:       const receiver = await ERC3156FlashBorrowerMock.new(true, true);",
          "98:       const data = this.token.contract.methods.transfer(other, 10).encodeABI();",
          "99:       await expectRevert(",
          "100:         this.token.flashLoan(receiver.address, this.token.address, loanAmount, data),",
          "101:         'ERC20: burn amount exceeds balance',",
          "102:       );",
          "103:     });",
          "105:     it('more than maxFlashLoan', async function () {",
          "106:       const receiver = await ERC3156FlashBorrowerMock.new(true, true);",
          "107:       const data = this.token.contract.methods.transfer(other, 10).encodeABI();",
          "109:       await expectRevert.unspecified(this.token.flashLoan(receiver.address, this.token.address, MAX_UINT256, data));",
          "110:     });",
          "112:     describe('custom flash fee & custom fee receiver', function () {",
          "113:       const receiverInitialBalance = new BN(200000);",
          "114:       const flashFee = new BN(5000);",
          "116:       beforeEach('init receiver balance & set flash fee', async function () {",
          "117:         this.receiver = await ERC3156FlashBorrowerMock.new(true, true);",
          "118:         const receipt = await this.token.$_mint(this.receiver.address, receiverInitialBalance);",
          "119:         await expectEvent(receipt, 'Transfer', {",
          "120:           from: ZERO_ADDRESS,",
          "121:           to: this.receiver.address,",
          "122:           value: receiverInitialBalance,",
          "123:         });",
          "124:         expect(await this.token.balanceOf(this.receiver.address)).to.be.bignumber.equal(receiverInitialBalance);",
          "126:         await this.token.setFlashFee(flashFee);",
          "127:         expect(await this.token.flashFee(this.token.address, loanAmount)).to.be.bignumber.equal(flashFee);",
          "128:       });",
          "130:       it('default flash fee receiver', async function () {",
          "131:         const { tx } = await this.token.flashLoan(this.receiver.address, this.token.address, loanAmount, '0x');",
          "132:         await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "133:           from: ZERO_ADDRESS,",
          "134:           to: this.receiver.address,",
          "135:           value: loanAmount,",
          "136:         });",
          "137:         await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "138:           from: this.receiver.address,",
          "139:           to: ZERO_ADDRESS,",
          "140:           value: loanAmount.add(flashFee),",
          "141:         });",
          "142:         await expectEvent.inTransaction(tx, this.receiver, 'BalanceOf', {",
          "143:           token: this.token.address,",
          "144:           account: this.receiver.address,",
          "145:           value: receiverInitialBalance.add(loanAmount),",
          "146:         });",
          "147:         await expectEvent.inTransaction(tx, this.receiver, 'TotalSupply', {",
          "148:           token: this.token.address,",
          "149:           value: initialSupply.add(receiverInitialBalance).add(loanAmount),",
          "150:         });",
          "152:         expect(await this.token.totalSupply()).to.be.bignumber.equal(",
          "153:           initialSupply.add(receiverInitialBalance).sub(flashFee),",
          "154:         );",
          "155:         expect(await this.token.balanceOf(this.receiver.address)).to.be.bignumber.equal(",
          "156:           receiverInitialBalance.sub(flashFee),",
          "157:         );",
          "158:         expect(await this.token.balanceOf(await this.token.$_flashFeeReceiver())).to.be.bignumber.equal('0');",
          "159:         expect(await this.token.allowance(this.receiver.address, this.token.address)).to.be.bignumber.equal('0');",
          "160:       });",
          "162:       it('custom flash fee receiver', async function () {",
          "163:         const flashFeeReceiverAddress = anotherAccount;",
          "164:         await this.token.setFlashFeeReceiver(flashFeeReceiverAddress);",
          "165:         expect(await this.token.$_flashFeeReceiver()).to.be.eq(flashFeeReceiverAddress);",
          "167:         expect(await this.token.balanceOf(flashFeeReceiverAddress)).to.be.bignumber.equal('0');",
          "169:         const { tx } = await this.token.flashLoan(this.receiver.address, this.token.address, loanAmount, '0x');",
          "170:         await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "171:           from: ZERO_ADDRESS,",
          "172:           to: this.receiver.address,",
          "173:           value: loanAmount,",
          "174:         });",
          "175:         await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "176:           from: this.receiver.address,",
          "177:           to: ZERO_ADDRESS,",
          "178:           value: loanAmount,",
          "179:         });",
          "180:         await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "181:           from: this.receiver.address,",
          "182:           to: flashFeeReceiverAddress,",
          "183:           value: flashFee,",
          "184:         });",
          "185:         await expectEvent.inTransaction(tx, this.receiver, 'BalanceOf', {",
          "186:           token: this.token.address,",
          "187:           account: this.receiver.address,",
          "188:           value: receiverInitialBalance.add(loanAmount),",
          "189:         });",
          "190:         await expectEvent.inTransaction(tx, this.receiver, 'TotalSupply', {",
          "191:           token: this.token.address,",
          "192:           value: initialSupply.add(receiverInitialBalance).add(loanAmount),",
          "193:         });",
          "195:         expect(await this.token.totalSupply()).to.be.bignumber.equal(initialSupply.add(receiverInitialBalance));",
          "196:         expect(await this.token.balanceOf(this.receiver.address)).to.be.bignumber.equal(",
          "197:           receiverInitialBalance.sub(flashFee),",
          "198:         );",
          "199:         expect(await this.token.balanceOf(flashFeeReceiverAddress)).to.be.bignumber.equal(flashFee);",
          "200:         expect(await this.token.allowance(this.receiver.address, flashFeeReceiverAddress)).to.be.bignumber.equal('0');",
          "201:       });",
          "202:     });",
          "203:   });",
          "204: });",
          "",
          "---------------"
        ],
        "test/token/ERC20/extensions/ERC20Pausable.test.js||test/token/ERC20/extensions/ERC20Pausable.test.js": [
          "File: test/token/ERC20/extensions/ERC20Pausable.test.js -> test/token/ERC20/extensions/ERC20Pausable.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const ERC20Pausable = artifacts.require('$ERC20Pausable');",
          "7: contract('ERC20Pausable', function (accounts) {",
          "8:   const [holder, recipient, anotherAccount] = accounts;",
          "10:   const initialSupply = new BN(100);",
          "12:   const name = 'My Token';",
          "13:   const symbol = 'MTKN';",
          "15:   beforeEach(async function () {",
          "16:     this.token = await ERC20Pausable.new(name, symbol);",
          "17:     await this.token.$_mint(holder, initialSupply);",
          "18:   });",
          "20:   describe('pausable token', function () {",
          "21:     describe('transfer', function () {",
          "22:       it('allows to transfer when unpaused', async function () {",
          "23:         await this.token.transfer(recipient, initialSupply, { from: holder });",
          "25:         expect(await this.token.balanceOf(holder)).to.be.bignumber.equal('0');",
          "26:         expect(await this.token.balanceOf(recipient)).to.be.bignumber.equal(initialSupply);",
          "27:       });",
          "29:       it('allows to transfer when paused and then unpaused', async function () {",
          "30:         await this.token.$_pause();",
          "31:         await this.token.$_unpause();",
          "33:         await this.token.transfer(recipient, initialSupply, { from: holder });",
          "35:         expect(await this.token.balanceOf(holder)).to.be.bignumber.equal('0');",
          "36:         expect(await this.token.balanceOf(recipient)).to.be.bignumber.equal(initialSupply);",
          "37:       });",
          "39:       it('reverts when trying to transfer when paused', async function () {",
          "40:         await this.token.$_pause();",
          "42:         await expectRevert(",
          "43:           this.token.transfer(recipient, initialSupply, { from: holder }),",
          "44:           'ERC20Pausable: token transfer while paused',",
          "45:         );",
          "46:       });",
          "47:     });",
          "49:     describe('transfer from', function () {",
          "50:       const allowance = new BN(40);",
          "52:       beforeEach(async function () {",
          "53:         await this.token.approve(anotherAccount, allowance, { from: holder });",
          "54:       });",
          "56:       it('allows to transfer from when unpaused', async function () {",
          "57:         await this.token.transferFrom(holder, recipient, allowance, { from: anotherAccount });",
          "59:         expect(await this.token.balanceOf(recipient)).to.be.bignumber.equal(allowance);",
          "60:         expect(await this.token.balanceOf(holder)).to.be.bignumber.equal(initialSupply.sub(allowance));",
          "61:       });",
          "63:       it('allows to transfer when paused and then unpaused', async function () {",
          "64:         await this.token.$_pause();",
          "65:         await this.token.$_unpause();",
          "67:         await this.token.transferFrom(holder, recipient, allowance, { from: anotherAccount });",
          "69:         expect(await this.token.balanceOf(recipient)).to.be.bignumber.equal(allowance);",
          "70:         expect(await this.token.balanceOf(holder)).to.be.bignumber.equal(initialSupply.sub(allowance));",
          "71:       });",
          "73:       it('reverts when trying to transfer from when paused', async function () {",
          "74:         await this.token.$_pause();",
          "76:         await expectRevert(",
          "77:           this.token.transferFrom(holder, recipient, allowance, { from: anotherAccount }),",
          "78:           'ERC20Pausable: token transfer while paused',",
          "79:         );",
          "80:       });",
          "81:     });",
          "83:     describe('mint', function () {",
          "84:       const amount = new BN('42');",
          "86:       it('allows to mint when unpaused', async function () {",
          "87:         await this.token.$_mint(recipient, amount);",
          "89:         expect(await this.token.balanceOf(recipient)).to.be.bignumber.equal(amount);",
          "90:       });",
          "92:       it('allows to mint when paused and then unpaused', async function () {",
          "93:         await this.token.$_pause();",
          "94:         await this.token.$_unpause();",
          "96:         await this.token.$_mint(recipient, amount);",
          "98:         expect(await this.token.balanceOf(recipient)).to.be.bignumber.equal(amount);",
          "99:       });",
          "101:       it('reverts when trying to mint when paused', async function () {",
          "102:         await this.token.$_pause();",
          "104:         await expectRevert(this.token.$_mint(recipient, amount), 'ERC20Pausable: token transfer while paused');",
          "105:       });",
          "106:     });",
          "108:     describe('burn', function () {",
          "109:       const amount = new BN('42');",
          "111:       it('allows to burn when unpaused', async function () {",
          "112:         await this.token.$_burn(holder, amount);",
          "114:         expect(await this.token.balanceOf(holder)).to.be.bignumber.equal(initialSupply.sub(amount));",
          "115:       });",
          "117:       it('allows to burn when paused and then unpaused', async function () {",
          "118:         await this.token.$_pause();",
          "119:         await this.token.$_unpause();",
          "121:         await this.token.$_burn(holder, amount);",
          "123:         expect(await this.token.balanceOf(holder)).to.be.bignumber.equal(initialSupply.sub(amount));",
          "124:       });",
          "126:       it('reverts when trying to burn when paused', async function () {",
          "127:         await this.token.$_pause();",
          "129:         await expectRevert(this.token.$_burn(holder, amount), 'ERC20Pausable: token transfer while paused');",
          "130:       });",
          "131:     });",
          "132:   });",
          "133: });",
          "",
          "---------------"
        ],
        "test/token/ERC20/extensions/ERC20Snapshot.test.js||test/token/ERC20/extensions/ERC20Snapshot.test.js": [
          "File: test/token/ERC20/extensions/ERC20Snapshot.test.js -> test/token/ERC20/extensions/ERC20Snapshot.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const ERC20Snapshot = artifacts.require('$ERC20Snapshot');",
          "4: const { expect } = require('chai');",
          "6: contract('ERC20Snapshot', function (accounts) {",
          "7:   const [initialHolder, recipient, other] = accounts;",
          "9:   const initialSupply = new BN(100);",
          "11:   const name = 'My Token';",
          "12:   const symbol = 'MTKN';",
          "14:   beforeEach(async function () {",
          "15:     this.token = await ERC20Snapshot.new(name, symbol);",
          "16:     await this.token.$_mint(initialHolder, initialSupply);",
          "17:   });",
          "19:   describe('snapshot', function () {",
          "20:     it('emits a snapshot event', async function () {",
          "21:       const receipt = await this.token.$_snapshot();",
          "22:       expectEvent(receipt, 'Snapshot');",
          "23:     });",
          "25:     it('creates increasing snapshots ids, starting from 1', async function () {",
          "26:       for (const id of ['1', '2', '3', '4', '5']) {",
          "27:         const receipt = await this.token.$_snapshot();",
          "28:         expectEvent(receipt, 'Snapshot', { id });",
          "29:       }",
          "30:     });",
          "31:   });",
          "33:   describe('totalSupplyAt', function () {",
          "34:     it('reverts with a snapshot id of 0', async function () {",
          "35:       await expectRevert(this.token.totalSupplyAt(0), 'ERC20Snapshot: id is 0');",
          "36:     });",
          "38:     it('reverts with a not-yet-created snapshot id', async function () {",
          "39:       await expectRevert(this.token.totalSupplyAt(1), 'ERC20Snapshot: nonexistent id');",
          "40:     });",
          "42:     context('with initial snapshot', function () {",
          "43:       beforeEach(async function () {",
          "44:         this.initialSnapshotId = new BN('1');",
          "46:         const receipt = await this.token.$_snapshot();",
          "47:         expectEvent(receipt, 'Snapshot', { id: this.initialSnapshotId });",
          "48:       });",
          "50:       context('with no supply changes after the snapshot', function () {",
          "51:         it('returns the current total supply', async function () {",
          "52:           expect(await this.token.totalSupplyAt(this.initialSnapshotId)).to.be.bignumber.equal(initialSupply);",
          "53:         });",
          "54:       });",
          "56:       context('with supply changes after the snapshot', function () {",
          "57:         beforeEach(async function () {",
          "58:           await this.token.$_mint(other, new BN('50'));",
          "59:           await this.token.$_burn(initialHolder, new BN('20'));",
          "60:         });",
          "62:         it('returns the total supply before the changes', async function () {",
          "63:           expect(await this.token.totalSupplyAt(this.initialSnapshotId)).to.be.bignumber.equal(initialSupply);",
          "64:         });",
          "66:         context('with a second snapshot after supply changes', function () {",
          "67:           beforeEach(async function () {",
          "68:             this.secondSnapshotId = new BN('2');",
          "70:             const receipt = await this.token.$_snapshot();",
          "71:             expectEvent(receipt, 'Snapshot', { id: this.secondSnapshotId });",
          "72:           });",
          "74:           it('snapshots return the supply before and after the changes', async function () {",
          "75:             expect(await this.token.totalSupplyAt(this.initialSnapshotId)).to.be.bignumber.equal(initialSupply);",
          "77:             expect(await this.token.totalSupplyAt(this.secondSnapshotId)).to.be.bignumber.equal(",
          "78:               await this.token.totalSupply(),",
          "79:             );",
          "80:           });",
          "81:         });",
          "83:         context('with multiple snapshots after supply changes', function () {",
          "84:           beforeEach(async function () {",
          "85:             this.secondSnapshotIds = ['2', '3', '4'];",
          "87:             for (const id of this.secondSnapshotIds) {",
          "88:               const receipt = await this.token.$_snapshot();",
          "89:               expectEvent(receipt, 'Snapshot', { id });",
          "90:             }",
          "91:           });",
          "93:           it('all posterior snapshots return the supply after the changes', async function () {",
          "94:             expect(await this.token.totalSupplyAt(this.initialSnapshotId)).to.be.bignumber.equal(initialSupply);",
          "96:             const currentSupply = await this.token.totalSupply();",
          "98:             for (const id of this.secondSnapshotIds) {",
          "99:               expect(await this.token.totalSupplyAt(id)).to.be.bignumber.equal(currentSupply);",
          "100:             }",
          "101:           });",
          "102:         });",
          "103:       });",
          "104:     });",
          "105:   });",
          "107:   describe('balanceOfAt', function () {",
          "108:     it('reverts with a snapshot id of 0', async function () {",
          "109:       await expectRevert(this.token.balanceOfAt(other, 0), 'ERC20Snapshot: id is 0');",
          "110:     });",
          "112:     it('reverts with a not-yet-created snapshot id', async function () {",
          "113:       await expectRevert(this.token.balanceOfAt(other, 1), 'ERC20Snapshot: nonexistent id');",
          "114:     });",
          "116:     context('with initial snapshot', function () {",
          "117:       beforeEach(async function () {",
          "118:         this.initialSnapshotId = new BN('1');",
          "120:         const receipt = await this.token.$_snapshot();",
          "121:         expectEvent(receipt, 'Snapshot', { id: this.initialSnapshotId });",
          "122:       });",
          "124:       context('with no balance changes after the snapshot', function () {",
          "125:         it('returns the current balance for all accounts', async function () {",
          "126:           expect(await this.token.balanceOfAt(initialHolder, this.initialSnapshotId)).to.be.bignumber.equal(",
          "127:             initialSupply,",
          "128:           );",
          "129:           expect(await this.token.balanceOfAt(recipient, this.initialSnapshotId)).to.be.bignumber.equal('0');",
          "130:           expect(await this.token.balanceOfAt(other, this.initialSnapshotId)).to.be.bignumber.equal('0');",
          "131:         });",
          "132:       });",
          "134:       context('with balance changes after the snapshot', function () {",
          "135:         beforeEach(async function () {",
          "136:           await this.token.transfer(recipient, new BN('10'), { from: initialHolder });",
          "137:           await this.token.$_mint(other, new BN('50'));",
          "138:           await this.token.$_burn(initialHolder, new BN('20'));",
          "139:         });",
          "141:         it('returns the balances before the changes', async function () {",
          "142:           expect(await this.token.balanceOfAt(initialHolder, this.initialSnapshotId)).to.be.bignumber.equal(",
          "143:             initialSupply,",
          "144:           );",
          "145:           expect(await this.token.balanceOfAt(recipient, this.initialSnapshotId)).to.be.bignumber.equal('0');",
          "146:           expect(await this.token.balanceOfAt(other, this.initialSnapshotId)).to.be.bignumber.equal('0');",
          "147:         });",
          "149:         context('with a second snapshot after supply changes', function () {",
          "150:           beforeEach(async function () {",
          "151:             this.secondSnapshotId = new BN('2');",
          "153:             const receipt = await this.token.$_snapshot();",
          "154:             expectEvent(receipt, 'Snapshot', { id: this.secondSnapshotId });",
          "155:           });",
          "157:           it('snapshots return the balances before and after the changes', async function () {",
          "158:             expect(await this.token.balanceOfAt(initialHolder, this.initialSnapshotId)).to.be.bignumber.equal(",
          "159:               initialSupply,",
          "160:             );",
          "161:             expect(await this.token.balanceOfAt(recipient, this.initialSnapshotId)).to.be.bignumber.equal('0');",
          "162:             expect(await this.token.balanceOfAt(other, this.initialSnapshotId)).to.be.bignumber.equal('0');",
          "164:             expect(await this.token.balanceOfAt(initialHolder, this.secondSnapshotId)).to.be.bignumber.equal(",
          "165:               await this.token.balanceOf(initialHolder),",
          "166:             );",
          "167:             expect(await this.token.balanceOfAt(recipient, this.secondSnapshotId)).to.be.bignumber.equal(",
          "168:               await this.token.balanceOf(recipient),",
          "169:             );",
          "170:             expect(await this.token.balanceOfAt(other, this.secondSnapshotId)).to.be.bignumber.equal(",
          "171:               await this.token.balanceOf(other),",
          "172:             );",
          "173:           });",
          "174:         });",
          "176:         context('with multiple snapshots after supply changes', function () {",
          "177:           beforeEach(async function () {",
          "178:             this.secondSnapshotIds = ['2', '3', '4'];",
          "180:             for (const id of this.secondSnapshotIds) {",
          "181:               const receipt = await this.token.$_snapshot();",
          "182:               expectEvent(receipt, 'Snapshot', { id });",
          "183:             }",
          "184:           });",
          "186:           it('all posterior snapshots return the supply after the changes', async function () {",
          "187:             expect(await this.token.balanceOfAt(initialHolder, this.initialSnapshotId)).to.be.bignumber.equal(",
          "188:               initialSupply,",
          "189:             );",
          "190:             expect(await this.token.balanceOfAt(recipient, this.initialSnapshotId)).to.be.bignumber.equal('0');",
          "191:             expect(await this.token.balanceOfAt(other, this.initialSnapshotId)).to.be.bignumber.equal('0');",
          "193:             for (const id of this.secondSnapshotIds) {",
          "194:               expect(await this.token.balanceOfAt(initialHolder, id)).to.be.bignumber.equal(",
          "195:                 await this.token.balanceOf(initialHolder),",
          "196:               );",
          "197:               expect(await this.token.balanceOfAt(recipient, id)).to.be.bignumber.equal(",
          "198:                 await this.token.balanceOf(recipient),",
          "199:               );",
          "200:               expect(await this.token.balanceOfAt(other, id)).to.be.bignumber.equal(await this.token.balanceOf(other));",
          "201:             }",
          "202:           });",
          "203:         });",
          "204:       });",
          "205:     });",
          "206:   });",
          "207: });",
          "",
          "---------------"
        ],
        "test/token/ERC20/extensions/ERC20Votes.test.js||test/token/ERC20/extensions/ERC20Votes.test.js": [
          "File: test/token/ERC20/extensions/ERC20Votes.test.js -> test/token/ERC20/extensions/ERC20Votes.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: const { BN, constants, expectEvent, expectRevert, time } = require('@openzeppelin/test-helpers');",
          "4: const { expect } = require('chai');",
          "5: const { MAX_UINT256, ZERO_ADDRESS } = constants;",
          "7: const { fromRpcSig } = require('ethereumjs-util');",
          "8: const ethSigUtil = require('eth-sig-util');",
          "9: const Wallet = require('ethereumjs-wallet').default;",
          "11: const { batchInBlock } = require('../../../helpers/txpool');",
          "12: const { getDomain, domainType, domainSeparator } = require('../../../helpers/eip712');",
          "13: const { clock, clockFromReceipt } = require('../../../helpers/time');",
          "15: const { shouldBehaveLikeEIP6372 } = require('../../../governance/utils/EIP6372.behavior');",
          "17: const Delegation = [",
          "18:   { name: 'delegatee', type: 'address' },",
          "19:   { name: 'nonce', type: 'uint256' },",
          "20:   { name: 'expiry', type: 'uint256' },",
          "21: ];",
          "23: const MODES = {",
          "24:   blocknumber: artifacts.require('$ERC20Votes'),",
          "25:   timestamp: artifacts.require('$ERC20VotesTimestampMock'),",
          "26: };",
          "28: contract('ERC20Votes', function (accounts) {",
          "29:   const [holder, recipient, holderDelegatee, other1, other2] = accounts;",
          "31:   const name = 'My Token';",
          "32:   const symbol = 'MTKN';",
          "33:   const supply = new BN('10000000000000000000000000');",
          "35:   for (const [mode, artifact] of Object.entries(MODES)) {",
          "36:     describe(`vote with ${mode}`, function () {",
          "37:       beforeEach(async function () {",
          "38:         this.token = await artifact.new(name, symbol, name);",
          "39:       });",
          "41:       shouldBehaveLikeEIP6372(mode);",
          "43:       it('initial nonce is 0', async function () {",
          "44:         expect(await this.token.nonces(holder)).to.be.bignumber.equal('0');",
          "45:       });",
          "47:       it('domain separator', async function () {",
          "48:         expect(await this.token.DOMAIN_SEPARATOR()).to.equal(await getDomain(this.token).then(domainSeparator));",
          "49:       });",
          "51:       it('minting restriction', async function () {",
          "52:         const amount = new BN('2').pow(new BN('224'));",
          "53:         await expectRevert(this.token.$_mint(holder, amount), 'ERC20Votes: total supply risks overflowing votes');",
          "54:       });",
          "56:       it('recent checkpoints', async function () {",
          "57:         await this.token.delegate(holder, { from: holder });",
          "58:         for (let i = 0; i < 6; i++) {",
          "59:           await this.token.$_mint(holder, 1);",
          "60:         }",
          "61:         const block = await clock[mode]();",
          "62:         expect(await this.token.numCheckpoints(holder)).to.be.bignumber.equal('6');",
          "64:         expect(await this.token.getPastVotes(holder, block - 1)).to.be.bignumber.equal('5');",
          "66:         expect(await this.token.getPastVotes(holder, block - 6)).to.be.bignumber.equal('0');",
          "67:       });",
          "69:       describe('set delegation', function () {",
          "70:         describe('call', function () {",
          "71:           it('delegation with balance', async function () {",
          "72:             await this.token.$_mint(holder, supply);",
          "73:             expect(await this.token.delegates(holder)).to.be.equal(ZERO_ADDRESS);",
          "75:             const { receipt } = await this.token.delegate(holder, { from: holder });",
          "76:             const timepoint = await clockFromReceipt[mode](receipt);",
          "78:             expectEvent(receipt, 'DelegateChanged', {",
          "79:               delegator: holder,",
          "80:               fromDelegate: ZERO_ADDRESS,",
          "81:               toDelegate: holder,",
          "82:             });",
          "83:             expectEvent(receipt, 'DelegateVotesChanged', {",
          "84:               delegate: holder,",
          "85:               previousBalance: '0',",
          "86:               newBalance: supply,",
          "87:             });",
          "89:             expect(await this.token.delegates(holder)).to.be.equal(holder);",
          "91:             expect(await this.token.getVotes(holder)).to.be.bignumber.equal(supply);",
          "92:             expect(await this.token.getPastVotes(holder, timepoint - 1)).to.be.bignumber.equal('0');",
          "93:             await time.advanceBlock();",
          "94:             expect(await this.token.getPastVotes(holder, timepoint)).to.be.bignumber.equal(supply);",
          "95:           });",
          "97:           it('delegation without balance', async function () {",
          "98:             expect(await this.token.delegates(holder)).to.be.equal(ZERO_ADDRESS);",
          "100:             const { receipt } = await this.token.delegate(holder, { from: holder });",
          "101:             expectEvent(receipt, 'DelegateChanged', {",
          "102:               delegator: holder,",
          "103:               fromDelegate: ZERO_ADDRESS,",
          "104:               toDelegate: holder,",
          "105:             });",
          "106:             expectEvent.notEmitted(receipt, 'DelegateVotesChanged');",
          "108:             expect(await this.token.delegates(holder)).to.be.equal(holder);",
          "109:           });",
          "110:         });",
          "112:         describe('with signature', function () {",
          "113:           const delegator = Wallet.generate();",
          "114:           const delegatorAddress = web3.utils.toChecksumAddress(delegator.getAddressString());",
          "115:           const nonce = 0;",
          "117:           const buildData = (contract, message) =>",
          "118:             getDomain(contract).then(domain => ({",
          "119:               primaryType: 'Delegation',",
          "120:               types: { EIP712Domain: domainType(domain), Delegation },",
          "121:               domain,",
          "122:               message,",
          "123:             }));",
          "125:           beforeEach(async function () {",
          "126:             await this.token.$_mint(delegatorAddress, supply);",
          "127:           });",
          "129:           it('accept signed delegation', async function () {",
          "130:             const { v, r, s } = await buildData(this.token, {",
          "131:               delegatee: delegatorAddress,",
          "132:               nonce,",
          "133:               expiry: MAX_UINT256,",
          "134:             }).then(data => fromRpcSig(ethSigUtil.signTypedMessage(delegator.getPrivateKey(), { data })));",
          "136:             expect(await this.token.delegates(delegatorAddress)).to.be.equal(ZERO_ADDRESS);",
          "138:             const { receipt } = await this.token.delegateBySig(delegatorAddress, nonce, MAX_UINT256, v, r, s);",
          "139:             const timepoint = await clockFromReceipt[mode](receipt);",
          "141:             expectEvent(receipt, 'DelegateChanged', {",
          "142:               delegator: delegatorAddress,",
          "143:               fromDelegate: ZERO_ADDRESS,",
          "144:               toDelegate: delegatorAddress,",
          "145:             });",
          "146:             expectEvent(receipt, 'DelegateVotesChanged', {",
          "147:               delegate: delegatorAddress,",
          "148:               previousBalance: '0',",
          "149:               newBalance: supply,",
          "150:             });",
          "152:             expect(await this.token.delegates(delegatorAddress)).to.be.equal(delegatorAddress);",
          "154:             expect(await this.token.getVotes(delegatorAddress)).to.be.bignumber.equal(supply);",
          "155:             expect(await this.token.getPastVotes(delegatorAddress, timepoint - 1)).to.be.bignumber.equal('0');",
          "156:             await time.advanceBlock();",
          "157:             expect(await this.token.getPastVotes(delegatorAddress, timepoint)).to.be.bignumber.equal(supply);",
          "158:           });",
          "160:           it('rejects reused signature', async function () {",
          "161:             const { v, r, s } = await buildData(this.token, {",
          "162:               delegatee: delegatorAddress,",
          "163:               nonce,",
          "164:               expiry: MAX_UINT256,",
          "165:             }).then(data => fromRpcSig(ethSigUtil.signTypedMessage(delegator.getPrivateKey(), { data })));",
          "167:             await this.token.delegateBySig(delegatorAddress, nonce, MAX_UINT256, v, r, s);",
          "169:             await expectRevert(",
          "170:               this.token.delegateBySig(delegatorAddress, nonce, MAX_UINT256, v, r, s),",
          "171:               'ERC20Votes: invalid nonce',",
          "172:             );",
          "173:           });",
          "175:           it('rejects bad delegatee', async function () {",
          "176:             const { v, r, s } = await buildData(this.token, {",
          "177:               delegatee: delegatorAddress,",
          "178:               nonce,",
          "179:               expiry: MAX_UINT256,",
          "180:             }).then(data => fromRpcSig(ethSigUtil.signTypedMessage(delegator.getPrivateKey(), { data })));",
          "182:             const receipt = await this.token.delegateBySig(holderDelegatee, nonce, MAX_UINT256, v, r, s);",
          "183:             const { args } = receipt.logs.find(({ event }) => event == 'DelegateChanged');",
          "184:             expect(args.delegator).to.not.be.equal(delegatorAddress);",
          "185:             expect(args.fromDelegate).to.be.equal(ZERO_ADDRESS);",
          "186:             expect(args.toDelegate).to.be.equal(holderDelegatee);",
          "187:           });",
          "189:           it('rejects bad nonce', async function () {",
          "190:             const { v, r, s } = await buildData(this.token, {",
          "191:               delegatee: delegatorAddress,",
          "192:               nonce,",
          "193:               expiry: MAX_UINT256,",
          "194:             }).then(data => fromRpcSig(ethSigUtil.signTypedMessage(delegator.getPrivateKey(), { data })));",
          "196:             await expectRevert(",
          "197:               this.token.delegateBySig(delegatorAddress, nonce + 1, MAX_UINT256, v, r, s),",
          "198:               'ERC20Votes: invalid nonce',",
          "199:             );",
          "200:           });",
          "202:           it('rejects expired permit', async function () {",
          "203:             const expiry = (await time.latest()) - time.duration.weeks(1);",
          "204:             const { v, r, s } = await buildData(this.token, {",
          "205:               delegatee: delegatorAddress,",
          "206:               nonce,",
          "207:               expiry,",
          "208:             }).then(data => fromRpcSig(ethSigUtil.signTypedMessage(delegator.getPrivateKey(), { data })));",
          "210:             await expectRevert(",
          "211:               this.token.delegateBySig(delegatorAddress, nonce, expiry, v, r, s),",
          "212:               'ERC20Votes: signature expired',",
          "213:             );",
          "214:           });",
          "215:         });",
          "216:       });",
          "218:       describe('change delegation', function () {",
          "219:         beforeEach(async function () {",
          "220:           await this.token.$_mint(holder, supply);",
          "221:           await this.token.delegate(holder, { from: holder });",
          "222:         });",
          "224:         it('call', async function () {",
          "225:           expect(await this.token.delegates(holder)).to.be.equal(holder);",
          "227:           const { receipt } = await this.token.delegate(holderDelegatee, { from: holder });",
          "228:           const timepoint = await clockFromReceipt[mode](receipt);",
          "230:           expectEvent(receipt, 'DelegateChanged', {",
          "231:             delegator: holder,",
          "232:             fromDelegate: holder,",
          "233:             toDelegate: holderDelegatee,",
          "234:           });",
          "235:           expectEvent(receipt, 'DelegateVotesChanged', {",
          "236:             delegate: holder,",
          "237:             previousBalance: supply,",
          "238:             newBalance: '0',",
          "239:           });",
          "240:           expectEvent(receipt, 'DelegateVotesChanged', {",
          "241:             delegate: holderDelegatee,",
          "242:             previousBalance: '0',",
          "243:             newBalance: supply,",
          "244:           });",
          "246:           expect(await this.token.delegates(holder)).to.be.equal(holderDelegatee);",
          "248:           expect(await this.token.getVotes(holder)).to.be.bignumber.equal('0');",
          "249:           expect(await this.token.getVotes(holderDelegatee)).to.be.bignumber.equal(supply);",
          "250:           expect(await this.token.getPastVotes(holder, timepoint - 1)).to.be.bignumber.equal(supply);",
          "251:           expect(await this.token.getPastVotes(holderDelegatee, timepoint - 1)).to.be.bignumber.equal('0');",
          "252:           await time.advanceBlock();",
          "253:           expect(await this.token.getPastVotes(holder, timepoint)).to.be.bignumber.equal('0');",
          "254:           expect(await this.token.getPastVotes(holderDelegatee, timepoint)).to.be.bignumber.equal(supply);",
          "255:         });",
          "256:       });",
          "258:       describe('transfers', function () {",
          "259:         beforeEach(async function () {",
          "260:           await this.token.$_mint(holder, supply);",
          "261:         });",
          "263:         it('no delegation', async function () {",
          "264:           const { receipt } = await this.token.transfer(recipient, 1, { from: holder });",
          "265:           expectEvent(receipt, 'Transfer', { from: holder, to: recipient, value: '1' });",
          "266:           expectEvent.notEmitted(receipt, 'DelegateVotesChanged');",
          "268:           this.holderVotes = '0';",
          "269:           this.recipientVotes = '0';",
          "270:         });",
          "272:         it('sender delegation', async function () {",
          "273:           await this.token.delegate(holder, { from: holder });",
          "275:           const { receipt } = await this.token.transfer(recipient, 1, { from: holder });",
          "276:           expectEvent(receipt, 'Transfer', { from: holder, to: recipient, value: '1' });",
          "277:           expectEvent(receipt, 'DelegateVotesChanged', {",
          "278:             delegate: holder,",
          "279:             previousBalance: supply,",
          "280:             newBalance: supply.subn(1),",
          "281:           });",
          "283:           const { logIndex: transferLogIndex } = receipt.logs.find(({ event }) => event == 'Transfer');",
          "284:           expect(",
          "285:             receipt.logs",
          "286:               .filter(({ event }) => event == 'DelegateVotesChanged')",
          "287:               .every(({ logIndex }) => transferLogIndex < logIndex),",
          "288:           ).to.be.equal(true);",
          "290:           this.holderVotes = supply.subn(1);",
          "291:           this.recipientVotes = '0';",
          "292:         });",
          "294:         it('receiver delegation', async function () {",
          "295:           await this.token.delegate(recipient, { from: recipient });",
          "297:           const { receipt } = await this.token.transfer(recipient, 1, { from: holder });",
          "298:           expectEvent(receipt, 'Transfer', { from: holder, to: recipient, value: '1' });",
          "299:           expectEvent(receipt, 'DelegateVotesChanged', { delegate: recipient, previousBalance: '0', newBalance: '1' });",
          "301:           const { logIndex: transferLogIndex } = receipt.logs.find(({ event }) => event == 'Transfer');",
          "302:           expect(",
          "303:             receipt.logs",
          "304:               .filter(({ event }) => event == 'DelegateVotesChanged')",
          "305:               .every(({ logIndex }) => transferLogIndex < logIndex),",
          "306:           ).to.be.equal(true);",
          "308:           this.holderVotes = '0';",
          "309:           this.recipientVotes = '1';",
          "310:         });",
          "312:         it('full delegation', async function () {",
          "313:           await this.token.delegate(holder, { from: holder });",
          "314:           await this.token.delegate(recipient, { from: recipient });",
          "316:           const { receipt } = await this.token.transfer(recipient, 1, { from: holder });",
          "317:           expectEvent(receipt, 'Transfer', { from: holder, to: recipient, value: '1' });",
          "318:           expectEvent(receipt, 'DelegateVotesChanged', {",
          "319:             delegate: holder,",
          "320:             previousBalance: supply,",
          "321:             newBalance: supply.subn(1),",
          "322:           });",
          "323:           expectEvent(receipt, 'DelegateVotesChanged', { delegate: recipient, previousBalance: '0', newBalance: '1' });",
          "325:           const { logIndex: transferLogIndex } = receipt.logs.find(({ event }) => event == 'Transfer');",
          "326:           expect(",
          "327:             receipt.logs",
          "328:               .filter(({ event }) => event == 'DelegateVotesChanged')",
          "329:               .every(({ logIndex }) => transferLogIndex < logIndex),",
          "330:           ).to.be.equal(true);",
          "332:           this.holderVotes = supply.subn(1);",
          "333:           this.recipientVotes = '1';",
          "334:         });",
          "336:         afterEach(async function () {",
          "337:           expect(await this.token.getVotes(holder)).to.be.bignumber.equal(this.holderVotes);",
          "338:           expect(await this.token.getVotes(recipient)).to.be.bignumber.equal(this.recipientVotes);",
          "341:           const timepoint = await clock[mode]();",
          "342:           await time.advanceBlock();",
          "343:           expect(await this.token.getPastVotes(holder, timepoint)).to.be.bignumber.equal(this.holderVotes);",
          "344:           expect(await this.token.getPastVotes(recipient, timepoint)).to.be.bignumber.equal(this.recipientVotes);",
          "345:         });",
          "346:       });",
          "349:       describe('Compound test suite', function () {",
          "350:         beforeEach(async function () {",
          "351:           await this.token.$_mint(holder, supply);",
          "352:         });",
          "354:         describe('balanceOf', function () {",
          "355:           it('grants to initial account', async function () {",
          "356:             expect(await this.token.balanceOf(holder)).to.be.bignumber.equal('10000000000000000000000000');",
          "357:           });",
          "358:         });",
          "360:         describe('numCheckpoints', function () {",
          "361:           it('returns the number of checkpoints for a delegate', async function () {",
          "362:             await this.token.transfer(recipient, '100', { from: holder }); //give an account a few tokens for readability",
          "363:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('0');",
          "365:             const t1 = await this.token.delegate(other1, { from: recipient });",
          "366:             t1.timepoint = await clockFromReceipt[mode](t1.receipt);",
          "367:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('1');",
          "369:             const t2 = await this.token.transfer(other2, 10, { from: recipient });",
          "370:             t2.timepoint = await clockFromReceipt[mode](t2.receipt);",
          "371:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('2');",
          "373:             const t3 = await this.token.transfer(other2, 10, { from: recipient });",
          "374:             t3.timepoint = await clockFromReceipt[mode](t3.receipt);",
          "375:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('3');",
          "377:             const t4 = await this.token.transfer(recipient, 20, { from: holder });",
          "378:             t4.timepoint = await clockFromReceipt[mode](t4.receipt);",
          "379:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('4');",
          "381:             expect(await this.token.checkpoints(other1, 0)).to.be.deep.equal([t1.timepoint.toString(), '100']);",
          "382:             expect(await this.token.checkpoints(other1, 1)).to.be.deep.equal([t2.timepoint.toString(), '90']);",
          "383:             expect(await this.token.checkpoints(other1, 2)).to.be.deep.equal([t3.timepoint.toString(), '80']);",
          "384:             expect(await this.token.checkpoints(other1, 3)).to.be.deep.equal([t4.timepoint.toString(), '100']);",
          "386:             await time.advanceBlock();",
          "387:             expect(await this.token.getPastVotes(other1, t1.timepoint)).to.be.bignumber.equal('100');",
          "388:             expect(await this.token.getPastVotes(other1, t2.timepoint)).to.be.bignumber.equal('90');",
          "389:             expect(await this.token.getPastVotes(other1, t3.timepoint)).to.be.bignumber.equal('80');",
          "390:             expect(await this.token.getPastVotes(other1, t4.timepoint)).to.be.bignumber.equal('100');",
          "391:           });",
          "393:           it('does not add more than one checkpoint in a block', async function () {",
          "394:             await this.token.transfer(recipient, '100', { from: holder });",
          "395:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('0');",
          "397:             const [t1, t2, t3] = await batchInBlock([",
          "398:               () => this.token.delegate(other1, { from: recipient, gas: 100000 }),",
          "399:               () => this.token.transfer(other2, 10, { from: recipient, gas: 100000 }),",
          "400:               () => this.token.transfer(other2, 10, { from: recipient, gas: 100000 }),",
          "401:             ]);",
          "402:             t1.timepoint = await clockFromReceipt[mode](t1.receipt);",
          "403:             t2.timepoint = await clockFromReceipt[mode](t2.receipt);",
          "404:             t3.timepoint = await clockFromReceipt[mode](t3.receipt);",
          "406:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('1');",
          "407:             expect(await this.token.checkpoints(other1, 0)).to.be.deep.equal([t1.timepoint.toString(), '80']);",
          "409:             const t4 = await this.token.transfer(recipient, 20, { from: holder });",
          "410:             t4.timepoint = await clockFromReceipt[mode](t4.receipt);",
          "412:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('2');",
          "413:             expect(await this.token.checkpoints(other1, 1)).to.be.deep.equal([t4.timepoint.toString(), '100']);",
          "414:           });",
          "415:         });",
          "417:         describe('getPastVotes', function () {",
          "418:           it('reverts if block number >= current block', async function () {",
          "419:             await expectRevert(this.token.getPastVotes(other1, 5e10), 'ERC20Votes: future lookup');",
          "420:           });",
          "422:           it('returns 0 if there are no checkpoints', async function () {",
          "423:             expect(await this.token.getPastVotes(other1, 0)).to.be.bignumber.equal('0');",
          "424:           });",
          "426:           it('returns the latest block if >= last checkpoint block', async function () {",
          "427:             const { receipt } = await this.token.delegate(other1, { from: holder });",
          "428:             const timepoint = await clockFromReceipt[mode](receipt);",
          "429:             await time.advanceBlock();",
          "430:             await time.advanceBlock();",
          "432:             expect(await this.token.getPastVotes(other1, timepoint)).to.be.bignumber.equal(",
          "433:               '10000000000000000000000000',",
          "434:             );",
          "435:             expect(await this.token.getPastVotes(other1, timepoint + 1)).to.be.bignumber.equal(",
          "436:               '10000000000000000000000000',",
          "437:             );",
          "438:           });",
          "440:           it('returns zero if < first checkpoint block', async function () {",
          "441:             await time.advanceBlock();",
          "442:             const { receipt } = await this.token.delegate(other1, { from: holder });",
          "443:             const timepoint = await clockFromReceipt[mode](receipt);",
          "444:             await time.advanceBlock();",
          "445:             await time.advanceBlock();",
          "447:             expect(await this.token.getPastVotes(other1, timepoint - 1)).to.be.bignumber.equal('0');",
          "448:             expect(await this.token.getPastVotes(other1, timepoint + 1)).to.be.bignumber.equal(",
          "449:               '10000000000000000000000000',",
          "450:             );",
          "451:           });",
          "453:           it('generally returns the voting balance at the appropriate checkpoint', async function () {",
          "454:             const t1 = await this.token.delegate(other1, { from: holder });",
          "455:             await time.advanceBlock();",
          "456:             await time.advanceBlock();",
          "457:             const t2 = await this.token.transfer(other2, 10, { from: holder });",
          "458:             await time.advanceBlock();",
          "459:             await time.advanceBlock();",
          "460:             const t3 = await this.token.transfer(other2, 10, { from: holder });",
          "461:             await time.advanceBlock();",
          "462:             await time.advanceBlock();",
          "463:             const t4 = await this.token.transfer(holder, 20, { from: other2 });",
          "464:             await time.advanceBlock();",
          "465:             await time.advanceBlock();",
          "467:             t1.timepoint = await clockFromReceipt[mode](t1.receipt);",
          "468:             t2.timepoint = await clockFromReceipt[mode](t2.receipt);",
          "469:             t3.timepoint = await clockFromReceipt[mode](t3.receipt);",
          "470:             t4.timepoint = await clockFromReceipt[mode](t4.receipt);",
          "472:             expect(await this.token.getPastVotes(other1, t1.timepoint - 1)).to.be.bignumber.equal('0');",
          "473:             expect(await this.token.getPastVotes(other1, t1.timepoint)).to.be.bignumber.equal(",
          "474:               '10000000000000000000000000',",
          "475:             );",
          "476:             expect(await this.token.getPastVotes(other1, t1.timepoint + 1)).to.be.bignumber.equal(",
          "477:               '10000000000000000000000000',",
          "478:             );",
          "479:             expect(await this.token.getPastVotes(other1, t2.timepoint)).to.be.bignumber.equal(",
          "480:               '9999999999999999999999990',",
          "481:             );",
          "482:             expect(await this.token.getPastVotes(other1, t2.timepoint + 1)).to.be.bignumber.equal(",
          "483:               '9999999999999999999999990',",
          "484:             );",
          "485:             expect(await this.token.getPastVotes(other1, t3.timepoint)).to.be.bignumber.equal(",
          "486:               '9999999999999999999999980',",
          "487:             );",
          "488:             expect(await this.token.getPastVotes(other1, t3.timepoint + 1)).to.be.bignumber.equal(",
          "489:               '9999999999999999999999980',",
          "490:             );",
          "491:             expect(await this.token.getPastVotes(other1, t4.timepoint)).to.be.bignumber.equal(",
          "492:               '10000000000000000000000000',",
          "493:             );",
          "494:             expect(await this.token.getPastVotes(other1, t4.timepoint + 1)).to.be.bignumber.equal(",
          "495:               '10000000000000000000000000',",
          "496:             );",
          "497:           });",
          "498:         });",
          "499:       });",
          "501:       describe('getPastTotalSupply', function () {",
          "502:         beforeEach(async function () {",
          "503:           await this.token.delegate(holder, { from: holder });",
          "504:         });",
          "506:         it('reverts if block number >= current block', async function () {",
          "507:           await expectRevert(this.token.getPastTotalSupply(5e10), 'ERC20Votes: future lookup');",
          "508:         });",
          "510:         it('returns 0 if there are no checkpoints', async function () {",
          "511:           expect(await this.token.getPastTotalSupply(0)).to.be.bignumber.equal('0');",
          "512:         });",
          "514:         it('returns the latest block if >= last checkpoint block', async function () {",
          "515:           const { receipt } = await this.token.$_mint(holder, supply);",
          "516:           const timepoint = await clockFromReceipt[mode](receipt);",
          "518:           await time.advanceBlock();",
          "519:           await time.advanceBlock();",
          "521:           expect(await this.token.getPastTotalSupply(timepoint)).to.be.bignumber.equal(supply);",
          "522:           expect(await this.token.getPastTotalSupply(timepoint + 1)).to.be.bignumber.equal(supply);",
          "523:         });",
          "525:         it('returns zero if < first checkpoint block', async function () {",
          "526:           await time.advanceBlock();",
          "527:           const { receipt } = await this.token.$_mint(holder, supply);",
          "528:           const timepoint = await clockFromReceipt[mode](receipt);",
          "529:           await time.advanceBlock();",
          "530:           await time.advanceBlock();",
          "532:           expect(await this.token.getPastTotalSupply(timepoint - 1)).to.be.bignumber.equal('0');",
          "533:           expect(await this.token.getPastTotalSupply(timepoint + 1)).to.be.bignumber.equal(",
          "534:             '10000000000000000000000000',",
          "535:           );",
          "536:         });",
          "538:         it('generally returns the voting balance at the appropriate checkpoint', async function () {",
          "539:           const t1 = await this.token.$_mint(holder, supply);",
          "540:           await time.advanceBlock();",
          "541:           await time.advanceBlock();",
          "542:           const t2 = await this.token.$_burn(holder, 10);",
          "543:           await time.advanceBlock();",
          "544:           await time.advanceBlock();",
          "545:           const t3 = await this.token.$_burn(holder, 10);",
          "546:           await time.advanceBlock();",
          "547:           await time.advanceBlock();",
          "548:           const t4 = await this.token.$_mint(holder, 20);",
          "549:           await time.advanceBlock();",
          "550:           await time.advanceBlock();",
          "552:           t1.timepoint = await clockFromReceipt[mode](t1.receipt);",
          "553:           t2.timepoint = await clockFromReceipt[mode](t2.receipt);",
          "554:           t3.timepoint = await clockFromReceipt[mode](t3.receipt);",
          "555:           t4.timepoint = await clockFromReceipt[mode](t4.receipt);",
          "557:           expect(await this.token.getPastTotalSupply(t1.timepoint - 1)).to.be.bignumber.equal('0');",
          "558:           expect(await this.token.getPastTotalSupply(t1.timepoint)).to.be.bignumber.equal('10000000000000000000000000');",
          "559:           expect(await this.token.getPastTotalSupply(t1.timepoint + 1)).to.be.bignumber.equal(",
          "560:             '10000000000000000000000000',",
          "561:           );",
          "562:           expect(await this.token.getPastTotalSupply(t2.timepoint)).to.be.bignumber.equal('9999999999999999999999990');",
          "563:           expect(await this.token.getPastTotalSupply(t2.timepoint + 1)).to.be.bignumber.equal(",
          "564:             '9999999999999999999999990',",
          "565:           );",
          "566:           expect(await this.token.getPastTotalSupply(t3.timepoint)).to.be.bignumber.equal('9999999999999999999999980');",
          "567:           expect(await this.token.getPastTotalSupply(t3.timepoint + 1)).to.be.bignumber.equal(",
          "568:             '9999999999999999999999980',",
          "569:           );",
          "570:           expect(await this.token.getPastTotalSupply(t4.timepoint)).to.be.bignumber.equal('10000000000000000000000000');",
          "571:           expect(await this.token.getPastTotalSupply(t4.timepoint + 1)).to.be.bignumber.equal(",
          "572:             '10000000000000000000000000',",
          "573:           );",
          "574:         });",
          "575:       });",
          "576:     });",
          "577:   }",
          "578: });",
          "",
          "---------------"
        ],
        "test/token/ERC20/extensions/ERC20VotesComp.test.js||test/token/ERC20/extensions/ERC20VotesComp.test.js": [
          "File: test/token/ERC20/extensions/ERC20VotesComp.test.js -> test/token/ERC20/extensions/ERC20VotesComp.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: const { BN, constants, expectEvent, expectRevert, time } = require('@openzeppelin/test-helpers');",
          "4: const { expect } = require('chai');",
          "5: const { MAX_UINT256, ZERO_ADDRESS } = constants;",
          "7: const { fromRpcSig } = require('ethereumjs-util');",
          "8: const ethSigUtil = require('eth-sig-util');",
          "9: const Wallet = require('ethereumjs-wallet').default;",
          "11: const { batchInBlock } = require('../../../helpers/txpool');",
          "12: const { getDomain, domainType, domainSeparator } = require('../../../helpers/eip712');",
          "13: const { clock, clockFromReceipt } = require('../../../helpers/time');",
          "15: const { shouldBehaveLikeEIP6372 } = require('../../../governance/utils/EIP6372.behavior');",
          "17: const Delegation = [",
          "18:   { name: 'delegatee', type: 'address' },",
          "19:   { name: 'nonce', type: 'uint256' },",
          "20:   { name: 'expiry', type: 'uint256' },",
          "21: ];",
          "23: const MODES = {",
          "24:   blocknumber: artifacts.require('$ERC20VotesComp'),",
          "26: };",
          "28: contract('ERC20VotesComp', function (accounts) {",
          "29:   const [holder, recipient, holderDelegatee, other1, other2] = accounts;",
          "31:   const name = 'My Token';",
          "32:   const symbol = 'MTKN';",
          "33:   const supply = new BN('10000000000000000000000000');",
          "35:   for (const [mode, artifact] of Object.entries(MODES)) {",
          "36:     describe(`vote with ${mode}`, function () {",
          "37:       beforeEach(async function () {",
          "38:         this.token = await artifact.new(name, symbol, name);",
          "39:       });",
          "41:       shouldBehaveLikeEIP6372(mode);",
          "43:       it('initial nonce is 0', async function () {",
          "44:         expect(await this.token.nonces(holder)).to.be.bignumber.equal('0');",
          "45:       });",
          "47:       it('domain separator', async function () {",
          "48:         expect(await this.token.DOMAIN_SEPARATOR()).to.equal(await getDomain(this.token).then(domainSeparator));",
          "49:       });",
          "51:       it('minting restriction', async function () {",
          "52:         const amount = new BN('2').pow(new BN('96'));",
          "53:         await expectRevert(this.token.$_mint(holder, amount), 'ERC20Votes: total supply risks overflowing votes');",
          "54:       });",
          "56:       describe('set delegation', function () {",
          "57:         describe('call', function () {",
          "58:           it('delegation with balance', async function () {",
          "59:             await this.token.$_mint(holder, supply);",
          "60:             expect(await this.token.delegates(holder)).to.be.equal(ZERO_ADDRESS);",
          "62:             const { receipt } = await this.token.delegate(holder, { from: holder });",
          "63:             const timepoint = await clockFromReceipt[mode](receipt);",
          "65:             expectEvent(receipt, 'DelegateChanged', {",
          "66:               delegator: holder,",
          "67:               fromDelegate: ZERO_ADDRESS,",
          "68:               toDelegate: holder,",
          "69:             });",
          "70:             expectEvent(receipt, 'DelegateVotesChanged', {",
          "71:               delegate: holder,",
          "72:               previousBalance: '0',",
          "73:               newBalance: supply,",
          "74:             });",
          "76:             expect(await this.token.delegates(holder)).to.be.equal(holder);",
          "78:             expect(await this.token.getCurrentVotes(holder)).to.be.bignumber.equal(supply);",
          "79:             expect(await this.token.getPriorVotes(holder, timepoint - 1)).to.be.bignumber.equal('0');",
          "80:             await time.advanceBlock();",
          "81:             expect(await this.token.getPriorVotes(holder, timepoint)).to.be.bignumber.equal(supply);",
          "82:           });",
          "84:           it('delegation without balance', async function () {",
          "85:             expect(await this.token.delegates(holder)).to.be.equal(ZERO_ADDRESS);",
          "87:             const { receipt } = await this.token.delegate(holder, { from: holder });",
          "88:             expectEvent(receipt, 'DelegateChanged', {",
          "89:               delegator: holder,",
          "90:               fromDelegate: ZERO_ADDRESS,",
          "91:               toDelegate: holder,",
          "92:             });",
          "93:             expectEvent.notEmitted(receipt, 'DelegateVotesChanged');",
          "95:             expect(await this.token.delegates(holder)).to.be.equal(holder);",
          "96:           });",
          "97:         });",
          "99:         describe('with signature', function () {",
          "100:           const delegator = Wallet.generate();",
          "101:           const delegatorAddress = web3.utils.toChecksumAddress(delegator.getAddressString());",
          "102:           const nonce = 0;",
          "104:           const buildData = (contract, message) =>",
          "105:             getDomain(contract).then(domain => ({",
          "106:               primaryType: 'Delegation',",
          "107:               types: { EIP712Domain: domainType(domain), Delegation },",
          "108:               domain,",
          "109:               message,",
          "110:             }));",
          "112:           beforeEach(async function () {",
          "113:             await this.token.$_mint(delegatorAddress, supply);",
          "114:           });",
          "116:           it('accept signed delegation', async function () {",
          "117:             const { v, r, s } = await buildData(this.token, {",
          "118:               delegatee: delegatorAddress,",
          "119:               nonce,",
          "120:               expiry: MAX_UINT256,",
          "121:             }).then(data => fromRpcSig(ethSigUtil.signTypedMessage(delegator.getPrivateKey(), { data })));",
          "123:             expect(await this.token.delegates(delegatorAddress)).to.be.equal(ZERO_ADDRESS);",
          "125:             const { receipt } = await this.token.delegateBySig(delegatorAddress, nonce, MAX_UINT256, v, r, s);",
          "126:             const timepoint = await clockFromReceipt[mode](receipt);",
          "128:             expectEvent(receipt, 'DelegateChanged', {",
          "129:               delegator: delegatorAddress,",
          "130:               fromDelegate: ZERO_ADDRESS,",
          "131:               toDelegate: delegatorAddress,",
          "132:             });",
          "133:             expectEvent(receipt, 'DelegateVotesChanged', {",
          "134:               delegate: delegatorAddress,",
          "135:               previousBalance: '0',",
          "136:               newBalance: supply,",
          "137:             });",
          "139:             expect(await this.token.delegates(delegatorAddress)).to.be.equal(delegatorAddress);",
          "141:             expect(await this.token.getCurrentVotes(delegatorAddress)).to.be.bignumber.equal(supply);",
          "142:             expect(await this.token.getPriorVotes(delegatorAddress, timepoint - 1)).to.be.bignumber.equal('0');",
          "143:             await time.advanceBlock();",
          "144:             expect(await this.token.getPriorVotes(delegatorAddress, timepoint)).to.be.bignumber.equal(supply);",
          "145:           });",
          "147:           it('rejects reused signature', async function () {",
          "148:             const { v, r, s } = await buildData(this.token, {",
          "149:               delegatee: delegatorAddress,",
          "150:               nonce,",
          "151:               expiry: MAX_UINT256,",
          "152:             }).then(data => fromRpcSig(ethSigUtil.signTypedMessage(delegator.getPrivateKey(), { data })));",
          "154:             await this.token.delegateBySig(delegatorAddress, nonce, MAX_UINT256, v, r, s);",
          "156:             await expectRevert(",
          "157:               this.token.delegateBySig(delegatorAddress, nonce, MAX_UINT256, v, r, s),",
          "158:               'ERC20Votes: invalid nonce',",
          "159:             );",
          "160:           });",
          "162:           it('rejects bad delegatee', async function () {",
          "163:             const { v, r, s } = await buildData(this.token, {",
          "164:               delegatee: delegatorAddress,",
          "165:               nonce,",
          "166:               expiry: MAX_UINT256,",
          "167:             }).then(data => fromRpcSig(ethSigUtil.signTypedMessage(delegator.getPrivateKey(), { data })));",
          "169:             const receipt = await this.token.delegateBySig(holderDelegatee, nonce, MAX_UINT256, v, r, s);",
          "170:             const { args } = receipt.logs.find(({ event }) => event == 'DelegateChanged');",
          "171:             expect(args.delegator).to.not.be.equal(delegatorAddress);",
          "172:             expect(args.fromDelegate).to.be.equal(ZERO_ADDRESS);",
          "173:             expect(args.toDelegate).to.be.equal(holderDelegatee);",
          "174:           });",
          "176:           it('rejects bad nonce', async function () {",
          "177:             const { v, r, s } = await buildData(this.token, {",
          "178:               delegatee: delegatorAddress,",
          "179:               nonce,",
          "180:               expiry: MAX_UINT256,",
          "181:             }).then(data => fromRpcSig(ethSigUtil.signTypedMessage(delegator.getPrivateKey(), { data })));",
          "183:             await expectRevert(",
          "184:               this.token.delegateBySig(delegatorAddress, nonce + 1, MAX_UINT256, v, r, s),",
          "185:               'ERC20Votes: invalid nonce',",
          "186:             );",
          "187:           });",
          "189:           it('rejects expired permit', async function () {",
          "190:             const expiry = (await time.latest()) - time.duration.weeks(1);",
          "191:             const { v, r, s } = await buildData(this.token, {",
          "192:               delegatee: delegatorAddress,",
          "193:               nonce,",
          "194:               expiry,",
          "195:             }).then(data => fromRpcSig(ethSigUtil.signTypedMessage(delegator.getPrivateKey(), { data })));",
          "197:             await expectRevert(",
          "198:               this.token.delegateBySig(delegatorAddress, nonce, expiry, v, r, s),",
          "199:               'ERC20Votes: signature expired',",
          "200:             );",
          "201:           });",
          "202:         });",
          "203:       });",
          "205:       describe('change delegation', function () {",
          "206:         beforeEach(async function () {",
          "207:           await this.token.$_mint(holder, supply);",
          "208:           await this.token.delegate(holder, { from: holder });",
          "209:         });",
          "211:         it('call', async function () {",
          "212:           expect(await this.token.delegates(holder)).to.be.equal(holder);",
          "214:           const { receipt } = await this.token.delegate(holderDelegatee, { from: holder });",
          "215:           const timepoint = await clockFromReceipt[mode](receipt);",
          "217:           expectEvent(receipt, 'DelegateChanged', {",
          "218:             delegator: holder,",
          "219:             fromDelegate: holder,",
          "220:             toDelegate: holderDelegatee,",
          "221:           });",
          "222:           expectEvent(receipt, 'DelegateVotesChanged', {",
          "223:             delegate: holder,",
          "224:             previousBalance: supply,",
          "225:             newBalance: '0',",
          "226:           });",
          "227:           expectEvent(receipt, 'DelegateVotesChanged', {",
          "228:             delegate: holderDelegatee,",
          "229:             previousBalance: '0',",
          "230:             newBalance: supply,",
          "231:           });",
          "233:           expect(await this.token.delegates(holder)).to.be.equal(holderDelegatee);",
          "235:           expect(await this.token.getCurrentVotes(holder)).to.be.bignumber.equal('0');",
          "236:           expect(await this.token.getCurrentVotes(holderDelegatee)).to.be.bignumber.equal(supply);",
          "237:           expect(await this.token.getPriorVotes(holder, timepoint - 1)).to.be.bignumber.equal(supply);",
          "238:           expect(await this.token.getPriorVotes(holderDelegatee, timepoint - 1)).to.be.bignumber.equal('0');",
          "239:           await time.advanceBlock();",
          "240:           expect(await this.token.getPriorVotes(holder, timepoint)).to.be.bignumber.equal('0');",
          "241:           expect(await this.token.getPriorVotes(holderDelegatee, timepoint)).to.be.bignumber.equal(supply);",
          "242:         });",
          "243:       });",
          "245:       describe('transfers', function () {",
          "246:         beforeEach(async function () {",
          "247:           await this.token.$_mint(holder, supply);",
          "248:         });",
          "250:         it('no delegation', async function () {",
          "251:           const { receipt } = await this.token.transfer(recipient, 1, { from: holder });",
          "252:           expectEvent(receipt, 'Transfer', { from: holder, to: recipient, value: '1' });",
          "253:           expectEvent.notEmitted(receipt, 'DelegateVotesChanged');",
          "255:           this.holderVotes = '0';",
          "256:           this.recipientVotes = '0';",
          "257:         });",
          "259:         it('sender delegation', async function () {",
          "260:           await this.token.delegate(holder, { from: holder });",
          "262:           const { receipt } = await this.token.transfer(recipient, 1, { from: holder });",
          "263:           expectEvent(receipt, 'Transfer', { from: holder, to: recipient, value: '1' });",
          "264:           expectEvent(receipt, 'DelegateVotesChanged', {",
          "265:             delegate: holder,",
          "266:             previousBalance: supply,",
          "267:             newBalance: supply.subn(1),",
          "268:           });",
          "270:           this.holderVotes = supply.subn(1);",
          "271:           this.recipientVotes = '0';",
          "272:         });",
          "274:         it('receiver delegation', async function () {",
          "275:           await this.token.delegate(recipient, { from: recipient });",
          "277:           const { receipt } = await this.token.transfer(recipient, 1, { from: holder });",
          "278:           expectEvent(receipt, 'Transfer', { from: holder, to: recipient, value: '1' });",
          "279:           expectEvent(receipt, 'DelegateVotesChanged', { delegate: recipient, previousBalance: '0', newBalance: '1' });",
          "281:           this.holderVotes = '0';",
          "282:           this.recipientVotes = '1';",
          "283:         });",
          "285:         it('full delegation', async function () {",
          "286:           await this.token.delegate(holder, { from: holder });",
          "287:           await this.token.delegate(recipient, { from: recipient });",
          "289:           const { receipt } = await this.token.transfer(recipient, 1, { from: holder });",
          "290:           expectEvent(receipt, 'Transfer', { from: holder, to: recipient, value: '1' });",
          "291:           expectEvent(receipt, 'DelegateVotesChanged', {",
          "292:             delegate: holder,",
          "293:             previousBalance: supply,",
          "294:             newBalance: supply.subn(1),",
          "295:           });",
          "296:           expectEvent(receipt, 'DelegateVotesChanged', { delegate: recipient, previousBalance: '0', newBalance: '1' });",
          "298:           this.holderVotes = supply.subn(1);",
          "299:           this.recipientVotes = '1';",
          "300:         });",
          "302:         afterEach(async function () {",
          "303:           expect(await this.token.getCurrentVotes(holder)).to.be.bignumber.equal(this.holderVotes);",
          "304:           expect(await this.token.getCurrentVotes(recipient)).to.be.bignumber.equal(this.recipientVotes);",
          "307:           const timepoint = await clock[mode]();",
          "308:           await time.advanceBlock();",
          "309:           expect(await this.token.getPriorVotes(holder, timepoint)).to.be.bignumber.equal(this.holderVotes);",
          "310:           expect(await this.token.getPriorVotes(recipient, timepoint)).to.be.bignumber.equal(this.recipientVotes);",
          "311:         });",
          "312:       });",
          "315:       describe('Compound test suite', function () {",
          "316:         beforeEach(async function () {",
          "317:           await this.token.$_mint(holder, supply);",
          "318:         });",
          "320:         describe('balanceOf', function () {",
          "321:           it('grants to initial account', async function () {",
          "322:             expect(await this.token.balanceOf(holder)).to.be.bignumber.equal('10000000000000000000000000');",
          "323:           });",
          "324:         });",
          "326:         describe('numCheckpoints', function () {",
          "327:           it('returns the number of checkpoints for a delegate', async function () {",
          "328:             await this.token.transfer(recipient, '100', { from: holder }); //give an account a few tokens for readability",
          "329:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('0');",
          "331:             const t1 = await this.token.delegate(other1, { from: recipient });",
          "332:             t1.timepoint = await clockFromReceipt[mode](t1.receipt);",
          "333:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('1');",
          "335:             const t2 = await this.token.transfer(other2, 10, { from: recipient });",
          "336:             t2.timepoint = await clockFromReceipt[mode](t2.receipt);",
          "337:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('2');",
          "339:             const t3 = await this.token.transfer(other2, 10, { from: recipient });",
          "340:             t3.timepoint = await clockFromReceipt[mode](t3.receipt);",
          "341:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('3');",
          "343:             const t4 = await this.token.transfer(recipient, 20, { from: holder });",
          "344:             t4.timepoint = await clockFromReceipt[mode](t4.receipt);",
          "345:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('4');",
          "347:             expect(await this.token.checkpoints(other1, 0)).to.be.deep.equal([t1.timepoint.toString(), '100']);",
          "348:             expect(await this.token.checkpoints(other1, 1)).to.be.deep.equal([t2.timepoint.toString(), '90']);",
          "349:             expect(await this.token.checkpoints(other1, 2)).to.be.deep.equal([t3.timepoint.toString(), '80']);",
          "350:             expect(await this.token.checkpoints(other1, 3)).to.be.deep.equal([t4.timepoint.toString(), '100']);",
          "352:             await time.advanceBlock();",
          "353:             expect(await this.token.getPriorVotes(other1, t1.timepoint)).to.be.bignumber.equal('100');",
          "354:             expect(await this.token.getPriorVotes(other1, t2.timepoint)).to.be.bignumber.equal('90');",
          "355:             expect(await this.token.getPriorVotes(other1, t3.timepoint)).to.be.bignumber.equal('80');",
          "356:             expect(await this.token.getPriorVotes(other1, t4.timepoint)).to.be.bignumber.equal('100');",
          "357:           });",
          "359:           it('does not add more than one checkpoint in a block', async function () {",
          "360:             await this.token.transfer(recipient, '100', { from: holder });",
          "361:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('0');",
          "363:             const [t1, t2, t3] = await batchInBlock([",
          "364:               () => this.token.delegate(other1, { from: recipient, gas: 100000 }),",
          "365:               () => this.token.transfer(other2, 10, { from: recipient, gas: 100000 }),",
          "366:               () => this.token.transfer(other2, 10, { from: recipient, gas: 100000 }),",
          "367:             ]);",
          "368:             t1.timepoint = await clockFromReceipt[mode](t1.receipt);",
          "369:             t2.timepoint = await clockFromReceipt[mode](t2.receipt);",
          "370:             t3.timepoint = await clockFromReceipt[mode](t3.receipt);",
          "372:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('1');",
          "373:             expect(await this.token.checkpoints(other1, 0)).to.be.deep.equal([t1.timepoint.toString(), '80']);",
          "375:             const t4 = await this.token.transfer(recipient, 20, { from: holder });",
          "376:             t4.timepoint = await clockFromReceipt[mode](t4.receipt);",
          "378:             expect(await this.token.numCheckpoints(other1)).to.be.bignumber.equal('2');",
          "379:             expect(await this.token.checkpoints(other1, 1)).to.be.deep.equal([t4.timepoint.toString(), '100']);",
          "380:           });",
          "381:         });",
          "383:         describe('getPriorVotes', function () {",
          "384:           it('reverts if block number >= current block', async function () {",
          "385:             await expectRevert(this.token.getPriorVotes(other1, 5e10), 'ERC20Votes: future lookup');",
          "386:           });",
          "388:           it('returns 0 if there are no checkpoints', async function () {",
          "389:             expect(await this.token.getPriorVotes(other1, 0)).to.be.bignumber.equal('0');",
          "390:           });",
          "392:           it('returns the latest block if >= last checkpoint block', async function () {",
          "393:             const { receipt } = await this.token.delegate(other1, { from: holder });",
          "394:             const timepoint = await clockFromReceipt[mode](receipt);",
          "395:             await time.advanceBlock();",
          "396:             await time.advanceBlock();",
          "398:             expect(await this.token.getPriorVotes(other1, timepoint)).to.be.bignumber.equal(",
          "399:               '10000000000000000000000000',",
          "400:             );",
          "401:             expect(await this.token.getPriorVotes(other1, timepoint + 1)).to.be.bignumber.equal(",
          "402:               '10000000000000000000000000',",
          "403:             );",
          "404:           });",
          "406:           it('returns zero if < first checkpoint block', async function () {",
          "407:             await time.advanceBlock();",
          "408:             const { receipt } = await this.token.delegate(other1, { from: holder });",
          "409:             const timepoint = await clockFromReceipt[mode](receipt);",
          "410:             await time.advanceBlock();",
          "411:             await time.advanceBlock();",
          "413:             expect(await this.token.getPriorVotes(other1, timepoint - 1)).to.be.bignumber.equal('0');",
          "414:             expect(await this.token.getPriorVotes(other1, timepoint + 1)).to.be.bignumber.equal(",
          "415:               '10000000000000000000000000',",
          "416:             );",
          "417:           });",
          "419:           it('generally returns the voting balance at the appropriate checkpoint', async function () {",
          "420:             const t1 = await this.token.delegate(other1, { from: holder });",
          "421:             await time.advanceBlock();",
          "422:             await time.advanceBlock();",
          "423:             const t2 = await this.token.transfer(other2, 10, { from: holder });",
          "424:             await time.advanceBlock();",
          "425:             await time.advanceBlock();",
          "426:             const t3 = await this.token.transfer(other2, 10, { from: holder });",
          "427:             await time.advanceBlock();",
          "428:             await time.advanceBlock();",
          "429:             const t4 = await this.token.transfer(holder, 20, { from: other2 });",
          "430:             await time.advanceBlock();",
          "431:             await time.advanceBlock();",
          "433:             t1.timepoint = await clockFromReceipt[mode](t1.receipt);",
          "434:             t2.timepoint = await clockFromReceipt[mode](t2.receipt);",
          "435:             t3.timepoint = await clockFromReceipt[mode](t3.receipt);",
          "436:             t4.timepoint = await clockFromReceipt[mode](t4.receipt);",
          "438:             expect(await this.token.getPriorVotes(other1, t1.timepoint - 1)).to.be.bignumber.equal('0');",
          "439:             expect(await this.token.getPriorVotes(other1, t1.timepoint)).to.be.bignumber.equal(",
          "440:               '10000000000000000000000000',",
          "441:             );",
          "442:             expect(await this.token.getPriorVotes(other1, t1.timepoint + 1)).to.be.bignumber.equal(",
          "443:               '10000000000000000000000000',",
          "444:             );",
          "445:             expect(await this.token.getPriorVotes(other1, t2.timepoint)).to.be.bignumber.equal(",
          "446:               '9999999999999999999999990',",
          "447:             );",
          "448:             expect(await this.token.getPriorVotes(other1, t2.timepoint + 1)).to.be.bignumber.equal(",
          "449:               '9999999999999999999999990',",
          "450:             );",
          "451:             expect(await this.token.getPriorVotes(other1, t3.timepoint)).to.be.bignumber.equal(",
          "452:               '9999999999999999999999980',",
          "453:             );",
          "454:             expect(await this.token.getPriorVotes(other1, t3.timepoint + 1)).to.be.bignumber.equal(",
          "455:               '9999999999999999999999980',",
          "456:             );",
          "457:             expect(await this.token.getPriorVotes(other1, t4.timepoint)).to.be.bignumber.equal(",
          "458:               '10000000000000000000000000',",
          "459:             );",
          "460:             expect(await this.token.getPriorVotes(other1, t4.timepoint + 1)).to.be.bignumber.equal(",
          "461:               '10000000000000000000000000',",
          "462:             );",
          "463:           });",
          "464:         });",
          "465:       });",
          "467:       describe('getPastTotalSupply', function () {",
          "468:         beforeEach(async function () {",
          "469:           await this.token.delegate(holder, { from: holder });",
          "470:         });",
          "472:         it('reverts if block number >= current block', async function () {",
          "473:           await expectRevert(this.token.getPastTotalSupply(5e10), 'ERC20Votes: future lookup');",
          "474:         });",
          "476:         it('returns 0 if there are no checkpoints', async function () {",
          "477:           expect(await this.token.getPastTotalSupply(0)).to.be.bignumber.equal('0');",
          "478:         });",
          "480:         it('returns the latest block if >= last checkpoint block', async function () {",
          "481:           const { receipt } = await this.token.$_mint(holder, supply);",
          "482:           const timepoint = await clockFromReceipt[mode](receipt);",
          "483:           await time.advanceBlock();",
          "484:           await time.advanceBlock();",
          "486:           expect(await this.token.getPastTotalSupply(timepoint)).to.be.bignumber.equal(supply);",
          "487:           expect(await this.token.getPastTotalSupply(timepoint + 1)).to.be.bignumber.equal(supply);",
          "488:         });",
          "490:         it('returns zero if < first checkpoint block', async function () {",
          "491:           await time.advanceBlock();",
          "492:           const { receipt } = await this.token.$_mint(holder, supply);",
          "493:           const timepoint = await clockFromReceipt[mode](receipt);",
          "494:           await time.advanceBlock();",
          "495:           await time.advanceBlock();",
          "497:           expect(await this.token.getPastTotalSupply(timepoint - 1)).to.be.bignumber.equal('0');",
          "498:           expect(await this.token.getPastTotalSupply(timepoint + 1)).to.be.bignumber.equal(",
          "499:             '10000000000000000000000000',",
          "500:           );",
          "501:         });",
          "503:         it('generally returns the voting balance at the appropriate checkpoint', async function () {",
          "504:           const t1 = await this.token.$_mint(holder, supply);",
          "505:           await time.advanceBlock();",
          "506:           await time.advanceBlock();",
          "507:           const t2 = await this.token.$_burn(holder, 10);",
          "508:           await time.advanceBlock();",
          "509:           await time.advanceBlock();",
          "510:           const t3 = await this.token.$_burn(holder, 10);",
          "511:           await time.advanceBlock();",
          "512:           await time.advanceBlock();",
          "513:           const t4 = await this.token.$_mint(holder, 20);",
          "514:           await time.advanceBlock();",
          "515:           await time.advanceBlock();",
          "517:           t1.timepoint = await clockFromReceipt[mode](t1.receipt);",
          "518:           t2.timepoint = await clockFromReceipt[mode](t2.receipt);",
          "519:           t3.timepoint = await clockFromReceipt[mode](t3.receipt);",
          "520:           t4.timepoint = await clockFromReceipt[mode](t4.receipt);",
          "522:           expect(await this.token.getPastTotalSupply(t1.timepoint - 1)).to.be.bignumber.equal('0');",
          "523:           expect(await this.token.getPastTotalSupply(t1.timepoint)).to.be.bignumber.equal('10000000000000000000000000');",
          "524:           expect(await this.token.getPastTotalSupply(t1.timepoint + 1)).to.be.bignumber.equal(",
          "525:             '10000000000000000000000000',",
          "526:           );",
          "527:           expect(await this.token.getPastTotalSupply(t2.timepoint)).to.be.bignumber.equal('9999999999999999999999990');",
          "528:           expect(await this.token.getPastTotalSupply(t2.timepoint + 1)).to.be.bignumber.equal(",
          "529:             '9999999999999999999999990',",
          "530:           );",
          "531:           expect(await this.token.getPastTotalSupply(t3.timepoint)).to.be.bignumber.equal('9999999999999999999999980');",
          "532:           expect(await this.token.getPastTotalSupply(t3.timepoint + 1)).to.be.bignumber.equal(",
          "533:             '9999999999999999999999980',",
          "534:           );",
          "535:           expect(await this.token.getPastTotalSupply(t4.timepoint)).to.be.bignumber.equal('10000000000000000000000000');",
          "536:           expect(await this.token.getPastTotalSupply(t4.timepoint + 1)).to.be.bignumber.equal(",
          "537:             '10000000000000000000000000',",
          "538:           );",
          "539:         });",
          "540:       });",
          "541:     });",
          "542:   }",
          "543: });",
          "",
          "---------------"
        ],
        "test/token/ERC20/extensions/ERC20Wrapper.test.js||test/token/ERC20/extensions/ERC20Wrapper.test.js": [
          "File: test/token/ERC20/extensions/ERC20Wrapper.test.js -> test/token/ERC20/extensions/ERC20Wrapper.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const { ZERO_ADDRESS, MAX_UINT256 } = constants;",
          "5: const { shouldBehaveLikeERC20 } = require('../ERC20.behavior');",
          "7: const NotAnERC20 = artifacts.require('CallReceiverMock');",
          "8: const ERC20Decimals = artifacts.require('$ERC20DecimalsMock');",
          "9: const ERC20Wrapper = artifacts.require('$ERC20Wrapper');",
          "11: contract('ERC20', function (accounts) {",
          "12:   const [initialHolder, recipient, anotherAccount] = accounts;",
          "14:   const name = 'My Token';",
          "15:   const symbol = 'MTKN';",
          "17:   const initialSupply = new BN(100);",
          "19:   beforeEach(async function () {",
          "20:     this.underlying = await ERC20Decimals.new(name, symbol, 9);",
          "21:     await this.underlying.$_mint(initialHolder, initialSupply);",
          "23:     this.token = await ERC20Wrapper.new(`Wrapped ${name}`, `W${symbol}`, this.underlying.address);",
          "24:   });",
          "26:   afterEach(async function () {",
          "27:     expect(await this.underlying.balanceOf(this.token.address)).to.be.bignumber.equal(await this.token.totalSupply());",
          "28:   });",
          "30:   it('has a name', async function () {",
          "31:     expect(await this.token.name()).to.equal(`Wrapped ${name}`);",
          "32:   });",
          "34:   it('has a symbol', async function () {",
          "35:     expect(await this.token.symbol()).to.equal(`W${symbol}`);",
          "36:   });",
          "38:   it('has the same decimals as the underlying token', async function () {",
          "39:     expect(await this.token.decimals()).to.be.bignumber.equal('9');",
          "40:   });",
          "42:   it('decimals default back to 18 if token has no metadata', async function () {",
          "43:     const noDecimals = await NotAnERC20.new();",
          "44:     const otherToken = await ERC20Wrapper.new(`Wrapped ${name}`, `W${symbol}`, noDecimals.address);",
          "45:     expect(await otherToken.decimals()).to.be.bignumber.equal('18');",
          "46:   });",
          "48:   it('has underlying', async function () {",
          "49:     expect(await this.token.underlying()).to.be.bignumber.equal(this.underlying.address);",
          "50:   });",
          "52:   describe('deposit', function () {",
          "53:     it('valid', async function () {",
          "54:       await this.underlying.approve(this.token.address, initialSupply, { from: initialHolder });",
          "55:       const { tx } = await this.token.depositFor(initialHolder, initialSupply, { from: initialHolder });",
          "56:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "57:         from: initialHolder,",
          "58:         to: this.token.address,",
          "59:         value: initialSupply,",
          "60:       });",
          "61:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "62:         from: ZERO_ADDRESS,",
          "63:         to: initialHolder,",
          "64:         value: initialSupply,",
          "65:       });",
          "66:     });",
          "68:     it('missing approval', async function () {",
          "69:       await expectRevert(",
          "70:         this.token.depositFor(initialHolder, initialSupply, { from: initialHolder }),",
          "71:         'ERC20: insufficient allowance',",
          "72:       );",
          "73:     });",
          "75:     it('missing balance', async function () {",
          "76:       await this.underlying.approve(this.token.address, MAX_UINT256, { from: initialHolder });",
          "77:       await expectRevert(",
          "78:         this.token.depositFor(initialHolder, MAX_UINT256, { from: initialHolder }),",
          "79:         'ERC20: transfer amount exceeds balance',",
          "80:       );",
          "81:     });",
          "83:     it('to other account', async function () {",
          "84:       await this.underlying.approve(this.token.address, initialSupply, { from: initialHolder });",
          "85:       const { tx } = await this.token.depositFor(anotherAccount, initialSupply, { from: initialHolder });",
          "86:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "87:         from: initialHolder,",
          "88:         to: this.token.address,",
          "89:         value: initialSupply,",
          "90:       });",
          "91:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "92:         from: ZERO_ADDRESS,",
          "93:         to: anotherAccount,",
          "94:         value: initialSupply,",
          "95:       });",
          "96:     });",
          "97:   });",
          "99:   describe('withdraw', function () {",
          "100:     beforeEach(async function () {",
          "101:       await this.underlying.approve(this.token.address, initialSupply, { from: initialHolder });",
          "102:       await this.token.depositFor(initialHolder, initialSupply, { from: initialHolder });",
          "103:     });",
          "105:     it('missing balance', async function () {",
          "106:       await expectRevert(",
          "107:         this.token.withdrawTo(initialHolder, MAX_UINT256, { from: initialHolder }),",
          "108:         'ERC20: burn amount exceeds balance',",
          "109:       );",
          "110:     });",
          "112:     it('valid', async function () {",
          "113:       const value = new BN(42);",
          "115:       const { tx } = await this.token.withdrawTo(initialHolder, value, { from: initialHolder });",
          "116:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "117:         from: this.token.address,",
          "118:         to: initialHolder,",
          "119:         value: value,",
          "120:       });",
          "121:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "122:         from: initialHolder,",
          "123:         to: ZERO_ADDRESS,",
          "124:         value: value,",
          "125:       });",
          "126:     });",
          "128:     it('entire balance', async function () {",
          "129:       const { tx } = await this.token.withdrawTo(initialHolder, initialSupply, { from: initialHolder });",
          "130:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "131:         from: this.token.address,",
          "132:         to: initialHolder,",
          "133:         value: initialSupply,",
          "134:       });",
          "135:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "136:         from: initialHolder,",
          "137:         to: ZERO_ADDRESS,",
          "138:         value: initialSupply,",
          "139:       });",
          "140:     });",
          "142:     it('to other account', async function () {",
          "143:       const { tx } = await this.token.withdrawTo(anotherAccount, initialSupply, { from: initialHolder });",
          "144:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "145:         from: this.token.address,",
          "146:         to: anotherAccount,",
          "147:         value: initialSupply,",
          "148:       });",
          "149:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "150:         from: initialHolder,",
          "151:         to: ZERO_ADDRESS,",
          "152:         value: initialSupply,",
          "153:       });",
          "154:     });",
          "155:   });",
          "157:   describe('recover', function () {",
          "158:     it('nothing to recover', async function () {",
          "159:       await this.underlying.approve(this.token.address, initialSupply, { from: initialHolder });",
          "160:       await this.token.depositFor(initialHolder, initialSupply, { from: initialHolder });",
          "162:       const { tx } = await this.token.$_recover(anotherAccount);",
          "163:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "164:         from: ZERO_ADDRESS,",
          "165:         to: anotherAccount,",
          "166:         value: '0',",
          "167:       });",
          "168:     });",
          "170:     it('something to recover', async function () {",
          "171:       await this.underlying.transfer(this.token.address, initialSupply, { from: initialHolder });",
          "173:       const { tx } = await this.token.$_recover(anotherAccount);",
          "174:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "175:         from: ZERO_ADDRESS,",
          "176:         to: anotherAccount,",
          "177:         value: initialSupply,",
          "178:       });",
          "179:     });",
          "180:   });",
          "182:   describe('erc20 behaviour', function () {",
          "183:     beforeEach(async function () {",
          "184:       await this.underlying.approve(this.token.address, initialSupply, { from: initialHolder });",
          "185:       await this.token.depositFor(initialHolder, initialSupply, { from: initialHolder });",
          "186:     });",
          "188:     shouldBehaveLikeERC20('ERC20', initialSupply, initialHolder, recipient, anotherAccount);",
          "189:   });",
          "190: });",
          "",
          "---------------"
        ],
        "test/token/ERC20/extensions/ERC4626.t.sol||test/token/ERC20/extensions/ERC4626.t.sol": [
          "File: test/token/ERC20/extensions/ERC4626.t.sol -> test/token/ERC20/extensions/ERC4626.t.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: pragma solidity ^0.8.0;",
          "4: import {ERC4626Test} from \"erc4626-tests/ERC4626.test.sol\";",
          "6: import {SafeCast} from \"openzeppelin/utils/math/SafeCast.sol\";",
          "7: import {ERC20} from \"openzeppelin/token/ERC20/ERC20.sol\";",
          "8: import {ERC4626} from \"openzeppelin/token/ERC20/extensions/ERC4626.sol\";",
          "10: import {ERC20Mock} from \"openzeppelin/mocks/ERC20Mock.sol\";",
          "11: import {ERC4626Mock} from \"openzeppelin/mocks/ERC4626Mock.sol\";",
          "12: import {ERC4626OffsetMock} from \"openzeppelin/mocks/token/ERC4626OffsetMock.sol\";",
          "14: contract ERC4626VaultOffsetMock is ERC4626OffsetMock {",
          "15:     constructor(",
          "16:         ERC20 underlying_,",
          "17:         uint8 offset_",
          "18:     ) ERC20(\"My Token Vault\", \"MTKNV\") ERC4626(underlying_) ERC4626OffsetMock(offset_) {}",
          "19: }",
          "21: contract ERC4626StdTest is ERC4626Test {",
          "22:     ERC20 private _underlying = new ERC20Mock();",
          "24:     function setUp() public override {",
          "25:         _underlying_ = address(_underlying);",
          "26:         _vault_ = address(new ERC4626Mock(_underlying_));",
          "27:         _delta_ = 0;",
          "28:         _vaultMayBeEmpty = true;",
          "29:         _unlimitedAmount = true;",
          "30:     }",
          "35:     function testFuzzDecimalsOverflow(uint8 offset) public {",
          "37:         offset = uint8(bound(uint256(offset), 238, uint256(type(uint8).max)));",
          "38:         ERC4626VaultOffsetMock erc4626VaultOffsetMock = new ERC4626VaultOffsetMock(_underlying, offset);",
          "39:         vm.expectRevert();",
          "40:         erc4626VaultOffsetMock.decimals();",
          "41:     }",
          "42: }",
          "",
          "---------------"
        ],
        "test/token/ERC20/extensions/ERC4626.test.js||test/token/ERC20/extensions/ERC4626.test.js": [
          "File: test/token/ERC20/extensions/ERC4626.test.js -> test/token/ERC20/extensions/ERC4626.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "4: const { Enum } = require('../../../helpers/enums');",
          "6: const ERC20Decimals = artifacts.require('$ERC20DecimalsMock');",
          "7: const ERC4626 = artifacts.require('$ERC4626');",
          "8: const ERC4626OffsetMock = artifacts.require('$ERC4626OffsetMock');",
          "9: const ERC4626FeesMock = artifacts.require('$ERC4626FeesMock');",
          "10: const ERC20ExcessDecimalsMock = artifacts.require('ERC20ExcessDecimalsMock');",
          "11: const ERC20Reentrant = artifacts.require('$ERC20Reentrant');",
          "13: contract('ERC4626', function (accounts) {",
          "14:   const [holder, recipient, spender, other, user1, user2] = accounts;",
          "16:   const name = 'My Token';",
          "17:   const symbol = 'MTKN';",
          "18:   const decimals = web3.utils.toBN(18);",
          "20:   it('inherit decimals if from asset', async function () {",
          "21:     for (const decimals of [0, 9, 12, 18, 36].map(web3.utils.toBN)) {",
          "22:       const token = await ERC20Decimals.new('', '', decimals);",
          "23:       const vault = await ERC4626.new('', '', token.address);",
          "24:       expect(await vault.decimals()).to.be.bignumber.equal(decimals);",
          "25:     }",
          "26:   });",
          "28:   it('asset has not yet been created', async function () {",
          "29:     const vault = await ERC4626.new('', '', other);",
          "30:     expect(await vault.decimals()).to.be.bignumber.equal(decimals);",
          "31:   });",
          "33:   it('underlying excess decimals', async function () {",
          "34:     const token = await ERC20ExcessDecimalsMock.new();",
          "35:     const vault = await ERC4626.new('', '', token.address);",
          "36:     expect(await vault.decimals()).to.be.bignumber.equal(decimals);",
          "37:   });",
          "39:   it('decimals overflow', async function () {",
          "40:     for (const offset of [243, 250, 255].map(web3.utils.toBN)) {",
          "41:       const token = await ERC20Decimals.new('', '', decimals);",
          "42:       const vault = await ERC4626OffsetMock.new(name + ' Vault', symbol + 'V', token.address, offset);",
          "43:       await expectRevert(",
          "44:         vault.decimals(),",
          "45:         'reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)',",
          "46:       );",
          "47:     }",
          "48:   });",
          "50:   describe('reentrancy', async function () {",
          "51:     const reenterType = Enum('No', 'Before', 'After');",
          "53:     const amount = web3.utils.toBN(1000000000000000000);",
          "54:     const reenterAmount = web3.utils.toBN(1000000000);",
          "55:     let token;",
          "56:     let vault;",
          "58:     beforeEach(async function () {",
          "59:       token = await ERC20Reentrant.new();",
          "61:       vault = await ERC4626OffsetMock.new('', '', token.address, 1);",
          "63:       await token.$_mint(holder, amount);",
          "64:       await token.$_mint(other, amount);",
          "65:       await token.$_approve(holder, vault.address, constants.MAX_UINT256);",
          "66:       await token.$_approve(other, vault.address, constants.MAX_UINT256);",
          "67:       await token.$_approve(token.address, vault.address, constants.MAX_UINT256);",
          "68:     });",
          "74:     it('correct share price is observed during reentrancy before deposit', async function () {",
          "76:       await token.$_mint(token.address, reenterAmount);",
          "79:       await token.scheduleReenter(",
          "80:         reenterType.Before,",
          "81:         vault.address,",
          "82:         vault.contract.methods.deposit(reenterAmount, holder).encodeABI(),",
          "83:       );",
          "86:       const sharesForDeposit = await vault.previewDeposit(amount, { from: holder });",
          "87:       const sharesForReenter = await vault.previewDeposit(reenterAmount, { from: holder });",
          "90:       const receipt = await vault.deposit(amount, holder, { from: holder });",
          "93:       await expectEvent(receipt, 'Deposit', {",
          "94:         sender: holder,",
          "95:         owner: holder,",
          "96:         assets: amount,",
          "97:         shares: sharesForDeposit,",
          "98:       });",
          "100:       await expectEvent(receipt, 'Deposit', {",
          "101:         sender: token.address,",
          "102:         owner: holder,",
          "103:         assets: reenterAmount,",
          "104:         shares: sharesForReenter,",
          "105:       });",
          "108:       const sharesAfter = await vault.previewDeposit(amount, { from: holder });",
          "109:       expect(sharesForDeposit).to.be.bignumber.eq(sharesAfter);",
          "110:     });",
          "116:     it('correct share price is observed during reentrancy after withdraw', async function () {",
          "118:       await vault.deposit(amount, holder, { from: holder });",
          "119:       await vault.deposit(reenterAmount, token.address, { from: other });",
          "122:       await token.scheduleReenter(",
          "123:         reenterType.After,",
          "124:         vault.address,",
          "125:         vault.contract.methods.withdraw(reenterAmount, holder, token.address).encodeABI(),",
          "126:       );",
          "129:       const sharesForWithdraw = await vault.previewWithdraw(amount, { from: holder });",
          "130:       const sharesForReenter = await vault.previewWithdraw(reenterAmount, { from: holder });",
          "133:       const receipt = await vault.withdraw(amount, holder, holder, { from: holder });",
          "136:       await expectEvent(receipt, 'Withdraw', {",
          "137:         sender: holder,",
          "138:         receiver: holder,",
          "139:         owner: holder,",
          "140:         assets: amount,",
          "141:         shares: sharesForWithdraw,",
          "142:       });",
          "144:       await expectEvent(receipt, 'Withdraw', {",
          "145:         sender: token.address,",
          "146:         receiver: holder,",
          "147:         owner: token.address,",
          "148:         assets: reenterAmount,",
          "149:         shares: sharesForReenter,",
          "150:       });",
          "153:       const sharesAfter = await vault.previewWithdraw(amount, { from: holder });",
          "154:       expect(sharesForWithdraw).to.be.bignumber.eq(sharesAfter);",
          "155:     });",
          "160:     it('share price change during reentracy does not affect deposit', async function () {",
          "162:       await token.scheduleReenter(",
          "163:         reenterType.Before,",
          "164:         token.address,",
          "165:         token.contract.methods.$_mint(vault.address, reenterAmount).encodeABI(),",
          "166:       );",
          "169:       const sharesBefore = await vault.previewDeposit(amount);",
          "172:       const receipt = await vault.deposit(amount, holder, { from: holder });",
          "175:       await expectEvent(receipt, 'Deposit', {",
          "176:         sender: holder,",
          "177:         owner: holder,",
          "178:         assets: amount,",
          "179:         shares: sharesBefore,",
          "180:       });",
          "183:       const sharesAfter = await vault.previewDeposit(amount);",
          "184:       expect(sharesAfter).to.be.bignumber.lt(sharesBefore);",
          "185:     });",
          "190:     it('share price change during reentracy does not affect withdraw', async function () {",
          "191:       await vault.deposit(amount, other, { from: other });",
          "192:       await vault.deposit(amount, holder, { from: holder });",
          "195:       await token.scheduleReenter(",
          "196:         reenterType.After,",
          "197:         token.address,",
          "198:         token.contract.methods.$_burn(vault.address, reenterAmount).encodeABI(),",
          "199:       );",
          "202:       const sharesBefore = await vault.previewWithdraw(amount);",
          "205:       const receipt = await vault.withdraw(amount, holder, holder, { from: holder });",
          "208:       await expectEvent(receipt, 'Withdraw', {",
          "209:         sender: holder,",
          "210:         receiver: holder,",
          "211:         owner: holder,",
          "212:         assets: amount,",
          "213:         shares: sharesBefore,",
          "214:       });",
          "217:       const sharesAfter = await vault.previewWithdraw(amount);",
          "218:       expect(sharesAfter).to.be.bignumber.gt(sharesBefore);",
          "219:     });",
          "220:   });",
          "222:   for (const offset of [0, 6, 18].map(web3.utils.toBN)) {",
          "223:     const parseToken = token => web3.utils.toBN(10).pow(decimals).muln(token);",
          "224:     const parseShare = share => web3.utils.toBN(10).pow(decimals.add(offset)).muln(share);",
          "226:     const virtualAssets = web3.utils.toBN(1);",
          "227:     const virtualShares = web3.utils.toBN(10).pow(offset);",
          "229:     describe(`offset: ${offset}`, function () {",
          "230:       beforeEach(async function () {",
          "231:         this.token = await ERC20Decimals.new(name, symbol, decimals);",
          "232:         this.vault = await ERC4626OffsetMock.new(name + ' Vault', symbol + 'V', this.token.address, offset);",
          "234:         await this.token.$_mint(holder, constants.MAX_INT256); // 50% of maximum",
          "235:         await this.token.approve(this.vault.address, constants.MAX_UINT256, { from: holder });",
          "236:         await this.vault.approve(spender, constants.MAX_UINT256, { from: holder });",
          "237:       });",
          "239:       it('metadata', async function () {",
          "240:         expect(await this.vault.name()).to.be.equal(name + ' Vault');",
          "241:         expect(await this.vault.symbol()).to.be.equal(symbol + 'V');",
          "242:         expect(await this.vault.decimals()).to.be.bignumber.equal(decimals.add(offset));",
          "243:         expect(await this.vault.asset()).to.be.equal(this.token.address);",
          "244:       });",
          "246:       describe('empty vault: no assets & no shares', function () {",
          "247:         it('status', async function () {",
          "248:           expect(await this.vault.totalAssets()).to.be.bignumber.equal('0');",
          "249:         });",
          "251:         it('deposit', async function () {",
          "252:           expect(await this.vault.maxDeposit(holder)).to.be.bignumber.equal(constants.MAX_UINT256);",
          "253:           expect(await this.vault.previewDeposit(parseToken(1))).to.be.bignumber.equal(parseShare(1));",
          "255:           const { tx } = await this.vault.deposit(parseToken(1), recipient, { from: holder });",
          "257:           await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "258:             from: holder,",
          "259:             to: this.vault.address,",
          "260:             value: parseToken(1),",
          "261:           });",
          "263:           await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "264:             from: constants.ZERO_ADDRESS,",
          "265:             to: recipient,",
          "266:             value: parseShare(1),",
          "267:           });",
          "269:           await expectEvent.inTransaction(tx, this.vault, 'Deposit', {",
          "270:             sender: holder,",
          "271:             owner: recipient,",
          "272:             assets: parseToken(1),",
          "273:             shares: parseShare(1),",
          "274:           });",
          "275:         });",
          "277:         it('mint', async function () {",
          "278:           expect(await this.vault.maxMint(holder)).to.be.bignumber.equal(constants.MAX_UINT256);",
          "279:           expect(await this.vault.previewMint(parseShare(1))).to.be.bignumber.equal(parseToken(1));",
          "281:           const { tx } = await this.vault.mint(parseShare(1), recipient, { from: holder });",
          "283:           await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "284:             from: holder,",
          "285:             to: this.vault.address,",
          "286:             value: parseToken(1),",
          "287:           });",
          "289:           await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "290:             from: constants.ZERO_ADDRESS,",
          "291:             to: recipient,",
          "292:             value: parseShare(1),",
          "293:           });",
          "295:           await expectEvent.inTransaction(tx, this.vault, 'Deposit', {",
          "296:             sender: holder,",
          "297:             owner: recipient,",
          "298:             assets: parseToken(1),",
          "299:             shares: parseShare(1),",
          "300:           });",
          "301:         });",
          "303:         it('withdraw', async function () {",
          "304:           expect(await this.vault.maxWithdraw(holder)).to.be.bignumber.equal('0');",
          "305:           expect(await this.vault.previewWithdraw('0')).to.be.bignumber.equal('0');",
          "307:           const { tx } = await this.vault.withdraw('0', recipient, holder, { from: holder });",
          "309:           await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "310:             from: this.vault.address,",
          "311:             to: recipient,",
          "312:             value: '0',",
          "313:           });",
          "315:           await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "316:             from: holder,",
          "317:             to: constants.ZERO_ADDRESS,",
          "318:             value: '0',",
          "319:           });",
          "321:           await expectEvent.inTransaction(tx, this.vault, 'Withdraw', {",
          "322:             sender: holder,",
          "323:             receiver: recipient,",
          "324:             owner: holder,",
          "325:             assets: '0',",
          "326:             shares: '0',",
          "327:           });",
          "328:         });",
          "330:         it('redeem', async function () {",
          "331:           expect(await this.vault.maxRedeem(holder)).to.be.bignumber.equal('0');",
          "332:           expect(await this.vault.previewRedeem('0')).to.be.bignumber.equal('0');",
          "334:           const { tx } = await this.vault.redeem('0', recipient, holder, { from: holder });",
          "336:           await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "337:             from: this.vault.address,",
          "338:             to: recipient,",
          "339:             value: '0',",
          "340:           });",
          "342:           await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "343:             from: holder,",
          "344:             to: constants.ZERO_ADDRESS,",
          "345:             value: '0',",
          "346:           });",
          "348:           await expectEvent.inTransaction(tx, this.vault, 'Withdraw', {",
          "349:             sender: holder,",
          "350:             receiver: recipient,",
          "351:             owner: holder,",
          "352:             assets: '0',",
          "353:             shares: '0',",
          "354:           });",
          "355:         });",
          "356:       });",
          "358:       describe('inflation attack: offset price by direct deposit of assets', function () {",
          "359:         beforeEach(async function () {",
          "361:           await this.token.$_mint(this.vault.address, parseToken(1));",
          "362:         });",
          "364:         it('status', async function () {",
          "365:           expect(await this.vault.totalSupply()).to.be.bignumber.equal('0');",
          "366:           expect(await this.vault.totalAssets()).to.be.bignumber.equal(parseToken(1));",
          "367:         });",
          "380:         it('deposit', async function () {",
          "381:           const effectiveAssets = await this.vault.totalAssets().then(x => x.add(virtualAssets));",
          "382:           const effectiveShares = await this.vault.totalSupply().then(x => x.add(virtualShares));",
          "384:           const depositAssets = parseToken(1);",
          "385:           const expectedShares = depositAssets.mul(effectiveShares).div(effectiveAssets);",
          "387:           expect(await this.vault.maxDeposit(holder)).to.be.bignumber.equal(constants.MAX_UINT256);",
          "388:           expect(await this.vault.previewDeposit(depositAssets)).to.be.bignumber.equal(expectedShares);",
          "390:           const { tx } = await this.vault.deposit(depositAssets, recipient, { from: holder });",
          "392:           await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "393:             from: holder,",
          "394:             to: this.vault.address,",
          "395:             value: depositAssets,",
          "396:           });",
          "398:           await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "399:             from: constants.ZERO_ADDRESS,",
          "400:             to: recipient,",
          "401:             value: expectedShares,",
          "402:           });",
          "404:           await expectEvent.inTransaction(tx, this.vault, 'Deposit', {",
          "405:             sender: holder,",
          "406:             owner: recipient,",
          "407:             assets: depositAssets,",
          "408:             shares: expectedShares,",
          "409:           });",
          "410:         });",
          "423:         it('mint', async function () {",
          "424:           const effectiveAssets = await this.vault.totalAssets().then(x => x.add(virtualAssets));",
          "425:           const effectiveShares = await this.vault.totalSupply().then(x => x.add(virtualShares));",
          "427:           const mintShares = parseShare(1);",
          "428:           const expectedAssets = mintShares.mul(effectiveAssets).div(effectiveShares);",
          "430:           expect(await this.vault.maxMint(holder)).to.be.bignumber.equal(constants.MAX_UINT256);",
          "431:           expect(await this.vault.previewMint(mintShares)).to.be.bignumber.equal(expectedAssets);",
          "433:           const { tx } = await this.vault.mint(mintShares, recipient, { from: holder });",
          "435:           await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "436:             from: holder,",
          "437:             to: this.vault.address,",
          "438:             value: expectedAssets,",
          "439:           });",
          "441:           await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "442:             from: constants.ZERO_ADDRESS,",
          "443:             to: recipient,",
          "444:             value: mintShares,",
          "445:           });",
          "447:           await expectEvent.inTransaction(tx, this.vault, 'Deposit', {",
          "448:             sender: holder,",
          "449:             owner: recipient,",
          "450:             assets: expectedAssets,",
          "451:             shares: mintShares,",
          "452:           });",
          "453:         });",
          "455:         it('withdraw', async function () {",
          "456:           expect(await this.vault.maxWithdraw(holder)).to.be.bignumber.equal('0');",
          "457:           expect(await this.vault.previewWithdraw('0')).to.be.bignumber.equal('0');",
          "459:           const { tx } = await this.vault.withdraw('0', recipient, holder, { from: holder });",
          "461:           await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "462:             from: this.vault.address,",
          "463:             to: recipient,",
          "464:             value: '0',",
          "465:           });",
          "467:           await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "468:             from: holder,",
          "469:             to: constants.ZERO_ADDRESS,",
          "470:             value: '0',",
          "471:           });",
          "473:           await expectEvent.inTransaction(tx, this.vault, 'Withdraw', {",
          "474:             sender: holder,",
          "475:             receiver: recipient,",
          "476:             owner: holder,",
          "477:             assets: '0',",
          "478:             shares: '0',",
          "479:           });",
          "480:         });",
          "482:         it('redeem', async function () {",
          "483:           expect(await this.vault.maxRedeem(holder)).to.be.bignumber.equal('0');",
          "484:           expect(await this.vault.previewRedeem('0')).to.be.bignumber.equal('0');",
          "486:           const { tx } = await this.vault.redeem('0', recipient, holder, { from: holder });",
          "488:           await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "489:             from: this.vault.address,",
          "490:             to: recipient,",
          "491:             value: '0',",
          "492:           });",
          "494:           await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "495:             from: holder,",
          "496:             to: constants.ZERO_ADDRESS,",
          "497:             value: '0',",
          "498:           });",
          "500:           await expectEvent.inTransaction(tx, this.vault, 'Withdraw', {",
          "501:             sender: holder,",
          "502:             receiver: recipient,",
          "503:             owner: holder,",
          "504:             assets: '0',",
          "505:             shares: '0',",
          "506:           });",
          "507:         });",
          "508:       });",
          "510:       describe('full vault: assets & shares', function () {",
          "511:         beforeEach(async function () {",
          "513:           await this.token.$_mint(this.vault.address, parseToken(1));",
          "514:           await this.vault.$_mint(holder, parseShare(100));",
          "515:         });",
          "517:         it('status', async function () {",
          "518:           expect(await this.vault.totalSupply()).to.be.bignumber.equal(parseShare(100));",
          "519:           expect(await this.vault.totalAssets()).to.be.bignumber.equal(parseToken(1));",
          "520:         });",
          "531:         it('deposit', async function () {",
          "532:           const effectiveAssets = await this.vault.totalAssets().then(x => x.add(virtualAssets));",
          "533:           const effectiveShares = await this.vault.totalSupply().then(x => x.add(virtualShares));",
          "535:           const depositAssets = parseToken(1);",
          "536:           const expectedShares = depositAssets.mul(effectiveShares).div(effectiveAssets);",
          "538:           expect(await this.vault.maxDeposit(holder)).to.be.bignumber.equal(constants.MAX_UINT256);",
          "539:           expect(await this.vault.previewDeposit(depositAssets)).to.be.bignumber.equal(expectedShares);",
          "541:           const { tx } = await this.vault.deposit(depositAssets, recipient, { from: holder });",
          "543:           await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "544:             from: holder,",
          "545:             to: this.vault.address,",
          "546:             value: depositAssets,",
          "547:           });",
          "549:           await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "550:             from: constants.ZERO_ADDRESS,",
          "551:             to: recipient,",
          "552:             value: expectedShares,",
          "553:           });",
          "555:           await expectEvent.inTransaction(tx, this.vault, 'Deposit', {",
          "556:             sender: holder,",
          "557:             owner: recipient,",
          "558:             assets: depositAssets,",
          "559:             shares: expectedShares,",
          "560:           });",
          "561:         });",
          "572:         it('mint', async function () {",
          "573:           const effectiveAssets = await this.vault.totalAssets().then(x => x.add(virtualAssets));",
          "574:           const effectiveShares = await this.vault.totalSupply().then(x => x.add(virtualShares));",
          "576:           const mintShares = parseShare(1);",
          "577:           const expectedAssets = mintShares.mul(effectiveAssets).div(effectiveShares).addn(1); // add for the rounding",
          "579:           expect(await this.vault.maxMint(holder)).to.be.bignumber.equal(constants.MAX_UINT256);",
          "580:           expect(await this.vault.previewMint(mintShares)).to.be.bignumber.equal(expectedAssets);",
          "582:           const { tx } = await this.vault.mint(mintShares, recipient, { from: holder });",
          "584:           await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "585:             from: holder,",
          "586:             to: this.vault.address,",
          "587:             value: expectedAssets,",
          "588:           });",
          "590:           await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "591:             from: constants.ZERO_ADDRESS,",
          "592:             to: recipient,",
          "593:             value: mintShares,",
          "594:           });",
          "596:           await expectEvent.inTransaction(tx, this.vault, 'Deposit', {",
          "597:             sender: holder,",
          "598:             owner: recipient,",
          "599:             assets: expectedAssets,",
          "600:             shares: mintShares,",
          "601:           });",
          "602:         });",
          "604:         it('withdraw', async function () {",
          "605:           const effectiveAssets = await this.vault.totalAssets().then(x => x.add(virtualAssets));",
          "606:           const effectiveShares = await this.vault.totalSupply().then(x => x.add(virtualShares));",
          "608:           const withdrawAssets = parseToken(1);",
          "609:           const expectedShares = withdrawAssets.mul(effectiveShares).div(effectiveAssets).addn(1); // add for the rounding",
          "611:           expect(await this.vault.maxWithdraw(holder)).to.be.bignumber.equal(withdrawAssets);",
          "612:           expect(await this.vault.previewWithdraw(withdrawAssets)).to.be.bignumber.equal(expectedShares);",
          "614:           const { tx } = await this.vault.withdraw(withdrawAssets, recipient, holder, { from: holder });",
          "616:           await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "617:             from: this.vault.address,",
          "618:             to: recipient,",
          "619:             value: withdrawAssets,",
          "620:           });",
          "622:           await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "623:             from: holder,",
          "624:             to: constants.ZERO_ADDRESS,",
          "625:             value: expectedShares,",
          "626:           });",
          "628:           await expectEvent.inTransaction(tx, this.vault, 'Withdraw', {",
          "629:             sender: holder,",
          "630:             receiver: recipient,",
          "631:             owner: holder,",
          "632:             assets: withdrawAssets,",
          "633:             shares: expectedShares,",
          "634:           });",
          "635:         });",
          "637:         it('withdraw with approval', async function () {",
          "638:           await expectRevert(",
          "639:             this.vault.withdraw(parseToken(1), recipient, holder, { from: other }),",
          "640:             'ERC20: insufficient allowance',",
          "641:           );",
          "643:           await this.vault.withdraw(parseToken(1), recipient, holder, { from: spender });",
          "644:         });",
          "646:         it('redeem', async function () {",
          "647:           const effectiveAssets = await this.vault.totalAssets().then(x => x.add(virtualAssets));",
          "648:           const effectiveShares = await this.vault.totalSupply().then(x => x.add(virtualShares));",
          "650:           const redeemShares = parseShare(100);",
          "651:           const expectedAssets = redeemShares.mul(effectiveAssets).div(effectiveShares);",
          "653:           expect(await this.vault.maxRedeem(holder)).to.be.bignumber.equal(redeemShares);",
          "654:           expect(await this.vault.previewRedeem(redeemShares)).to.be.bignumber.equal(expectedAssets);",
          "656:           const { tx } = await this.vault.redeem(redeemShares, recipient, holder, { from: holder });",
          "658:           await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "659:             from: this.vault.address,",
          "660:             to: recipient,",
          "661:             value: expectedAssets,",
          "662:           });",
          "664:           await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "665:             from: holder,",
          "666:             to: constants.ZERO_ADDRESS,",
          "667:             value: redeemShares,",
          "668:           });",
          "670:           await expectEvent.inTransaction(tx, this.vault, 'Withdraw', {",
          "671:             sender: holder,",
          "672:             receiver: recipient,",
          "673:             owner: holder,",
          "674:             assets: expectedAssets,",
          "675:             shares: redeemShares,",
          "676:           });",
          "677:         });",
          "679:         it('redeem with approval', async function () {",
          "680:           await expectRevert(",
          "681:             this.vault.redeem(parseShare(100), recipient, holder, { from: other }),",
          "682:             'ERC20: insufficient allowance',",
          "683:           );",
          "685:           await this.vault.redeem(parseShare(100), recipient, holder, { from: spender });",
          "686:         });",
          "687:       });",
          "688:     });",
          "689:   }",
          "691:   describe('ERC4626Fees', function () {",
          "692:     const feeBasePoint = web3.utils.toBN(5e3);",
          "693:     const amountWithoutFees = web3.utils.toBN(10000);",
          "694:     const fees = amountWithoutFees.mul(feeBasePoint).divn(1e5);",
          "695:     const amountWithFees = amountWithoutFees.add(fees);",
          "697:     describe('input fees', function () {",
          "698:       beforeEach(async function () {",
          "699:         this.token = await ERC20Decimals.new(name, symbol, 18);",
          "700:         this.vault = await ERC4626FeesMock.new(",
          "701:           name + ' Vault',",
          "702:           symbol + 'V',",
          "703:           this.token.address,",
          "704:           feeBasePoint,",
          "705:           other,",
          "706:           0,",
          "707:           constants.ZERO_ADDRESS,",
          "708:         );",
          "710:         await this.token.$_mint(holder, constants.MAX_INT256);",
          "711:         await this.token.approve(this.vault.address, constants.MAX_INT256, { from: holder });",
          "712:       });",
          "714:       it('deposit', async function () {",
          "715:         expect(await this.vault.previewDeposit(amountWithFees)).to.be.bignumber.equal(amountWithoutFees);",
          "716:         ({ tx: this.tx } = await this.vault.deposit(amountWithFees, recipient, { from: holder }));",
          "717:       });",
          "719:       it('mint', async function () {",
          "720:         expect(await this.vault.previewMint(amountWithoutFees)).to.be.bignumber.equal(amountWithFees);",
          "721:         ({ tx: this.tx } = await this.vault.mint(amountWithoutFees, recipient, { from: holder }));",
          "722:       });",
          "724:       afterEach(async function () {",
          "726:         await expectEvent.inTransaction(this.tx, this.token, 'Transfer', {",
          "727:           from: holder,",
          "728:           to: this.vault.address,",
          "729:           value: amountWithFees,",
          "730:         });",
          "733:         await expectEvent.inTransaction(this.tx, this.token, 'Transfer', {",
          "734:           from: this.vault.address,",
          "735:           to: other,",
          "736:           value: fees,",
          "737:         });",
          "740:         await expectEvent.inTransaction(this.tx, this.vault, 'Transfer', {",
          "741:           from: constants.ZERO_ADDRESS,",
          "742:           to: recipient,",
          "743:           value: amountWithoutFees,",
          "744:         });",
          "747:         await expectEvent.inTransaction(this.tx, this.vault, 'Deposit', {",
          "748:           sender: holder,",
          "749:           owner: recipient,",
          "750:           assets: amountWithFees,",
          "751:           shares: amountWithoutFees,",
          "752:         });",
          "753:       });",
          "754:     });",
          "756:     describe('output fees', function () {",
          "757:       beforeEach(async function () {",
          "758:         this.token = await ERC20Decimals.new(name, symbol, 18);",
          "759:         this.vault = await ERC4626FeesMock.new(",
          "760:           name + ' Vault',",
          "761:           symbol + 'V',",
          "762:           this.token.address,",
          "763:           0,",
          "764:           constants.ZERO_ADDRESS,",
          "765:           5e3, // 5%",
          "766:           other,",
          "767:         );",
          "769:         await this.token.$_mint(this.vault.address, constants.MAX_INT256);",
          "770:         await this.vault.$_mint(holder, constants.MAX_INT256);",
          "771:       });",
          "773:       it('redeem', async function () {",
          "774:         expect(await this.vault.previewRedeem(amountWithFees)).to.be.bignumber.equal(amountWithoutFees);",
          "775:         ({ tx: this.tx } = await this.vault.redeem(amountWithFees, recipient, holder, { from: holder }));",
          "776:       });",
          "778:       it('withdraw', async function () {",
          "779:         expect(await this.vault.previewWithdraw(amountWithoutFees)).to.be.bignumber.equal(amountWithFees);",
          "780:         ({ tx: this.tx } = await this.vault.withdraw(amountWithoutFees, recipient, holder, { from: holder }));",
          "781:       });",
          "783:       afterEach(async function () {",
          "785:         await expectEvent.inTransaction(this.tx, this.token, 'Transfer', {",
          "786:           from: this.vault.address,",
          "787:           to: recipient,",
          "788:           value: amountWithoutFees,",
          "789:         });",
          "792:         await expectEvent.inTransaction(this.tx, this.token, 'Transfer', {",
          "793:           from: this.vault.address,",
          "794:           to: other,",
          "795:           value: fees,",
          "796:         });",
          "799:         await expectEvent.inTransaction(this.tx, this.vault, 'Transfer', {",
          "800:           from: holder,",
          "801:           to: constants.ZERO_ADDRESS,",
          "802:           value: amountWithFees,",
          "803:         });",
          "806:         await expectEvent.inTransaction(this.tx, this.vault, 'Withdraw', {",
          "807:           sender: holder,",
          "808:           receiver: recipient,",
          "809:           owner: holder,",
          "810:           assets: amountWithoutFees,",
          "811:           shares: amountWithFees,",
          "812:         });",
          "813:       });",
          "814:     });",
          "815:   });",
          "819:   it('multiple mint, deposit, redeem & withdrawal', async function () {",
          "821:     this.token = await ERC20Decimals.new(name, symbol, 18);",
          "822:     this.vault = await ERC4626.new(name + ' Vault', symbol + 'V', this.token.address);",
          "824:     await this.token.$_mint(user1, 4000);",
          "825:     await this.token.$_mint(user2, 7001);",
          "826:     await this.token.approve(this.vault.address, 4000, { from: user1 });",
          "827:     await this.token.approve(this.vault.address, 7001, { from: user2 });",
          "830:     {",
          "831:       const { tx } = await this.vault.mint(2000, user1, { from: user1 });",
          "832:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "833:         from: user1,",
          "834:         to: this.vault.address,",
          "835:         value: '2000',",
          "836:       });",
          "837:       await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "838:         from: constants.ZERO_ADDRESS,",
          "839:         to: user1,",
          "840:         value: '2000',",
          "841:       });",
          "843:       expect(await this.vault.previewDeposit(2000)).to.be.bignumber.equal('2000');",
          "844:       expect(await this.vault.balanceOf(user1)).to.be.bignumber.equal('2000');",
          "845:       expect(await this.vault.balanceOf(user2)).to.be.bignumber.equal('0');",
          "846:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user1))).to.be.bignumber.equal('2000');",
          "847:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user2))).to.be.bignumber.equal('0');",
          "848:       expect(await this.vault.totalSupply()).to.be.bignumber.equal('2000');",
          "849:       expect(await this.vault.totalAssets()).to.be.bignumber.equal('2000');",
          "850:     }",
          "853:     {",
          "854:       const { tx } = await this.vault.mint(4000, user2, { from: user2 });",
          "855:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "856:         from: user2,",
          "857:         to: this.vault.address,",
          "858:         value: '4000',",
          "859:       });",
          "860:       await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "861:         from: constants.ZERO_ADDRESS,",
          "862:         to: user2,",
          "863:         value: '4000',",
          "864:       });",
          "866:       expect(await this.vault.previewDeposit(4000)).to.be.bignumber.equal('4000');",
          "867:       expect(await this.vault.balanceOf(user1)).to.be.bignumber.equal('2000');",
          "868:       expect(await this.vault.balanceOf(user2)).to.be.bignumber.equal('4000');",
          "869:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user1))).to.be.bignumber.equal('2000');",
          "870:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user2))).to.be.bignumber.equal('4000');",
          "871:       expect(await this.vault.totalSupply()).to.be.bignumber.equal('6000');",
          "872:       expect(await this.vault.totalAssets()).to.be.bignumber.equal('6000');",
          "873:     }",
          "876:     await this.token.$_mint(this.vault.address, 3000);",
          "878:     expect(await this.vault.balanceOf(user1)).to.be.bignumber.equal('2000');",
          "879:     expect(await this.vault.balanceOf(user2)).to.be.bignumber.equal('4000');",
          "880:     expect(await this.vault.convertToAssets(await this.vault.balanceOf(user1))).to.be.bignumber.equal('2999'); // used to be 3000, but virtual assets/shares captures part of the yield",
          "881:     expect(await this.vault.convertToAssets(await this.vault.balanceOf(user2))).to.be.bignumber.equal('5999'); // used to be 6000, but virtual assets/shares captures part of the yield",
          "882:     expect(await this.vault.totalSupply()).to.be.bignumber.equal('6000');",
          "883:     expect(await this.vault.totalAssets()).to.be.bignumber.equal('9000');",
          "886:     {",
          "887:       const { tx } = await this.vault.deposit(2000, user1, { from: user1 });",
          "888:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "889:         from: user1,",
          "890:         to: this.vault.address,",
          "891:         value: '2000',",
          "892:       });",
          "893:       await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "894:         from: constants.ZERO_ADDRESS,",
          "895:         to: user1,",
          "896:         value: '1333',",
          "897:       });",
          "899:       expect(await this.vault.balanceOf(user1)).to.be.bignumber.equal('3333');",
          "900:       expect(await this.vault.balanceOf(user2)).to.be.bignumber.equal('4000');",
          "901:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user1))).to.be.bignumber.equal('4999');",
          "902:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user2))).to.be.bignumber.equal('6000');",
          "903:       expect(await this.vault.totalSupply()).to.be.bignumber.equal('7333');",
          "904:       expect(await this.vault.totalAssets()).to.be.bignumber.equal('11000');",
          "905:     }",
          "910:     {",
          "911:       const { tx } = await this.vault.mint(2000, user2, { from: user2 });",
          "912:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "913:         from: user2,",
          "914:         to: this.vault.address,",
          "915:         value: '3000', // used to be 3001",
          "916:       });",
          "917:       await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "918:         from: constants.ZERO_ADDRESS,",
          "919:         to: user2,",
          "920:         value: '2000',",
          "921:       });",
          "923:       expect(await this.vault.balanceOf(user1)).to.be.bignumber.equal('3333');",
          "924:       expect(await this.vault.balanceOf(user2)).to.be.bignumber.equal('6000');",
          "925:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user1))).to.be.bignumber.equal('4999'); // used to be 5000",
          "926:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user2))).to.be.bignumber.equal('9000');",
          "927:       expect(await this.vault.totalSupply()).to.be.bignumber.equal('9333');",
          "928:       expect(await this.vault.totalAssets()).to.be.bignumber.equal('14000'); // used to be 14001",
          "929:     }",
          "933:     await this.token.$_mint(this.vault.address, 3000);",
          "935:     expect(await this.vault.balanceOf(user1)).to.be.bignumber.equal('3333');",
          "936:     expect(await this.vault.balanceOf(user2)).to.be.bignumber.equal('6000');",
          "937:     expect(await this.vault.convertToAssets(await this.vault.balanceOf(user1))).to.be.bignumber.equal('6070'); // used to be 6071",
          "938:     expect(await this.vault.convertToAssets(await this.vault.balanceOf(user2))).to.be.bignumber.equal('10928'); // used to be 10929",
          "939:     expect(await this.vault.totalSupply()).to.be.bignumber.equal('9333');",
          "940:     expect(await this.vault.totalAssets()).to.be.bignumber.equal('17000'); // used to be 17001",
          "943:     {",
          "944:       const { tx } = await this.vault.redeem(1333, user1, user1, { from: user1 });",
          "945:       await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "946:         from: user1,",
          "947:         to: constants.ZERO_ADDRESS,",
          "948:         value: '1333',",
          "949:       });",
          "950:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "951:         from: this.vault.address,",
          "952:         to: user1,",
          "953:         value: '2427', // used to be 2428",
          "954:       });",
          "956:       expect(await this.vault.balanceOf(user1)).to.be.bignumber.equal('2000');",
          "957:       expect(await this.vault.balanceOf(user2)).to.be.bignumber.equal('6000');",
          "958:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user1))).to.be.bignumber.equal('3643');",
          "959:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user2))).to.be.bignumber.equal('10929');",
          "960:       expect(await this.vault.totalSupply()).to.be.bignumber.equal('8000');",
          "961:       expect(await this.vault.totalAssets()).to.be.bignumber.equal('14573');",
          "962:     }",
          "965:     {",
          "966:       const { tx } = await this.vault.withdraw(2929, user2, user2, { from: user2 });",
          "967:       await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "968:         from: user2,",
          "969:         to: constants.ZERO_ADDRESS,",
          "970:         value: '1608',",
          "971:       });",
          "972:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "973:         from: this.vault.address,",
          "974:         to: user2,",
          "975:         value: '2929',",
          "976:       });",
          "978:       expect(await this.vault.balanceOf(user1)).to.be.bignumber.equal('2000');",
          "979:       expect(await this.vault.balanceOf(user2)).to.be.bignumber.equal('4392');",
          "980:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user1))).to.be.bignumber.equal('3643');",
          "981:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user2))).to.be.bignumber.equal('8000');",
          "982:       expect(await this.vault.totalSupply()).to.be.bignumber.equal('6392');",
          "983:       expect(await this.vault.totalAssets()).to.be.bignumber.equal('11644');",
          "984:     }",
          "988:     {",
          "989:       const { tx } = await this.vault.withdraw(3643, user1, user1, { from: user1 });",
          "990:       await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "991:         from: user1,",
          "992:         to: constants.ZERO_ADDRESS,",
          "993:         value: '2000',",
          "994:       });",
          "995:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "996:         from: this.vault.address,",
          "997:         to: user1,",
          "998:         value: '3643',",
          "999:       });",
          "1001:       expect(await this.vault.balanceOf(user1)).to.be.bignumber.equal('0');",
          "1002:       expect(await this.vault.balanceOf(user2)).to.be.bignumber.equal('4392');",
          "1003:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user1))).to.be.bignumber.equal('0');",
          "1004:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user2))).to.be.bignumber.equal('8000'); // used to be 8001",
          "1005:       expect(await this.vault.totalSupply()).to.be.bignumber.equal('4392');",
          "1006:       expect(await this.vault.totalAssets()).to.be.bignumber.equal('8001');",
          "1007:     }",
          "1010:     {",
          "1011:       const { tx } = await this.vault.redeem(4392, user2, user2, { from: user2 });",
          "1012:       await expectEvent.inTransaction(tx, this.vault, 'Transfer', {",
          "1013:         from: user2,",
          "1014:         to: constants.ZERO_ADDRESS,",
          "1015:         value: '4392',",
          "1016:       });",
          "1017:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "1018:         from: this.vault.address,",
          "1019:         to: user2,",
          "1020:         value: '8000', // used to be 8001",
          "1021:       });",
          "1023:       expect(await this.vault.balanceOf(user1)).to.be.bignumber.equal('0');",
          "1024:       expect(await this.vault.balanceOf(user2)).to.be.bignumber.equal('0');",
          "1025:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user1))).to.be.bignumber.equal('0');",
          "1026:       expect(await this.vault.convertToAssets(await this.vault.balanceOf(user2))).to.be.bignumber.equal('0');",
          "1027:       expect(await this.vault.totalSupply()).to.be.bignumber.equal('0');",
          "1028:       expect(await this.vault.totalAssets()).to.be.bignumber.equal('1'); // used to be 0",
          "1029:     }",
          "1030:   });",
          "1031: });",
          "",
          "---------------"
        ],
        "test/token/ERC20/extensions/draft-ERC20Permit.test.js||test/token/ERC20/extensions/draft-ERC20Permit.test.js": [
          "File: test/token/ERC20/extensions/draft-ERC20Permit.test.js -> test/token/ERC20/extensions/draft-ERC20Permit.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: const { BN, constants, expectRevert, time } = require('@openzeppelin/test-helpers');",
          "4: const { expect } = require('chai');",
          "5: const { MAX_UINT256 } = constants;",
          "7: const { fromRpcSig } = require('ethereumjs-util');",
          "8: const ethSigUtil = require('eth-sig-util');",
          "9: const Wallet = require('ethereumjs-wallet').default;",
          "11: const ERC20Permit = artifacts.require('$ERC20Permit');",
          "13: const { Permit, getDomain, domainType, domainSeparator } = require('../../../helpers/eip712');",
          "14: const { getChainId } = require('../../../helpers/chainid');",
          "16: contract('ERC20Permit', function (accounts) {",
          "17:   const [initialHolder, spender] = accounts;",
          "19:   const name = 'My Token';",
          "20:   const symbol = 'MTKN';",
          "21:   const version = '1';",
          "23:   const initialSupply = new BN(100);",
          "25:   beforeEach(async function () {",
          "26:     this.chainId = await getChainId();",
          "28:     this.token = await ERC20Permit.new(name, symbol, name);",
          "29:     await this.token.$_mint(initialHolder, initialSupply);",
          "30:   });",
          "32:   it('initial nonce is 0', async function () {",
          "33:     expect(await this.token.nonces(initialHolder)).to.be.bignumber.equal('0');",
          "34:   });",
          "36:   it('domain separator', async function () {",
          "37:     expect(await this.token.DOMAIN_SEPARATOR()).to.equal(await getDomain(this.token).then(domainSeparator));",
          "38:   });",
          "40:   describe('permit', function () {",
          "41:     const wallet = Wallet.generate();",
          "43:     const owner = wallet.getAddressString();",
          "44:     const value = new BN(42);",
          "45:     const nonce = 0;",
          "46:     const maxDeadline = MAX_UINT256;",
          "48:     const buildData = (contract, deadline = maxDeadline) =>",
          "49:       getDomain(contract).then(domain => ({",
          "50:         primaryType: 'Permit',",
          "51:         types: { EIP712Domain: domainType(domain), Permit },",
          "52:         domain,",
          "53:         message: { owner, spender, value, nonce, deadline },",
          "54:       }));",
          "56:     it('accepts owner signature', async function () {",
          "57:       const { v, r, s } = await buildData(this.token)",
          "58:         .then(data => ethSigUtil.signTypedMessage(wallet.getPrivateKey(), { data }))",
          "59:         .then(fromRpcSig);",
          "61:       await this.token.permit(owner, spender, value, maxDeadline, v, r, s);",
          "63:       expect(await this.token.nonces(owner)).to.be.bignumber.equal('1');",
          "64:       expect(await this.token.allowance(owner, spender)).to.be.bignumber.equal(value);",
          "65:     });",
          "67:     it('rejects reused signature', async function () {",
          "68:       const { v, r, s } = await buildData(this.token)",
          "69:         .then(data => ethSigUtil.signTypedMessage(wallet.getPrivateKey(), { data }))",
          "70:         .then(fromRpcSig);",
          "72:       await this.token.permit(owner, spender, value, maxDeadline, v, r, s);",
          "74:       await expectRevert(",
          "75:         this.token.permit(owner, spender, value, maxDeadline, v, r, s),",
          "76:         'ERC20Permit: invalid signature',",
          "77:       );",
          "78:     });",
          "80:     it('rejects other signature', async function () {",
          "81:       const otherWallet = Wallet.generate();",
          "83:       const { v, r, s } = await buildData(this.token)",
          "84:         .then(data => ethSigUtil.signTypedMessage(otherWallet.getPrivateKey(), { data }))",
          "85:         .then(fromRpcSig);",
          "87:       await expectRevert(",
          "88:         this.token.permit(owner, spender, value, maxDeadline, v, r, s),",
          "89:         'ERC20Permit: invalid signature',",
          "90:       );",
          "91:     });",
          "93:     it('rejects expired permit', async function () {",
          "94:       const deadline = (await time.latest()) - time.duration.weeks(1);",
          "96:       const { v, r, s } = await buildData(this.token, deadline)",
          "97:         .then(data => ethSigUtil.signTypedMessage(wallet.getPrivateKey(), { data }))",
          "98:         .then(fromRpcSig);",
          "100:       await expectRevert(this.token.permit(owner, spender, value, deadline, v, r, s), 'ERC20Permit: expired deadline');",
          "101:     });",
          "102:   });",
          "103: });",
          "",
          "---------------"
        ],
        "test/token/ERC20/presets/ERC20PresetFixedSupply.test.js||test/token/ERC20/presets/ERC20PresetFixedSupply.test.js": [
          "File: test/token/ERC20/presets/ERC20PresetFixedSupply.test.js -> test/token/ERC20/presets/ERC20PresetFixedSupply.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectEvent } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS } = constants;",
          "4: const { expect } = require('chai');",
          "6: const ERC20PresetFixedSupply = artifacts.require('ERC20PresetFixedSupply');",
          "8: contract('ERC20PresetFixedSupply', function (accounts) {",
          "9:   const [deployer, owner] = accounts;",
          "11:   const name = 'PresetFixedSupply';",
          "12:   const symbol = 'PFS';",
          "14:   const initialSupply = new BN('50000');",
          "15:   const amount = new BN('10000');",
          "17:   before(async function () {",
          "18:     this.token = await ERC20PresetFixedSupply.new(name, symbol, initialSupply, owner, { from: deployer });",
          "19:   });",
          "21:   it('deployer has the balance equal to initial supply', async function () {",
          "22:     expect(await this.token.balanceOf(owner)).to.be.bignumber.equal(initialSupply);",
          "23:   });",
          "25:   it('total supply is equal to initial supply', async function () {",
          "26:     expect(await this.token.totalSupply()).to.be.bignumber.equal(initialSupply);",
          "27:   });",
          "29:   describe('burning', function () {",
          "30:     it('holders can burn their tokens', async function () {",
          "31:       const remainingBalance = initialSupply.sub(amount);",
          "32:       const receipt = await this.token.burn(amount, { from: owner });",
          "33:       expectEvent(receipt, 'Transfer', { from: owner, to: ZERO_ADDRESS, value: amount });",
          "34:       expect(await this.token.balanceOf(owner)).to.be.bignumber.equal(remainingBalance);",
          "35:     });",
          "37:     it('decrements totalSupply', async function () {",
          "38:       const expectedSupply = initialSupply.sub(amount);",
          "39:       expect(await this.token.totalSupply()).to.be.bignumber.equal(expectedSupply);",
          "40:     });",
          "41:   });",
          "42: });",
          "",
          "---------------"
        ],
        "test/token/ERC20/presets/ERC20PresetMinterPauser.test.js||test/token/ERC20/presets/ERC20PresetMinterPauser.test.js": [
          "File: test/token/ERC20/presets/ERC20PresetMinterPauser.test.js -> test/token/ERC20/presets/ERC20PresetMinterPauser.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS } = constants;",
          "4: const { expect } = require('chai');",
          "6: const ERC20PresetMinterPauser = artifacts.require('ERC20PresetMinterPauser');",
          "8: contract('ERC20PresetMinterPauser', function (accounts) {",
          "9:   const [deployer, other] = accounts;",
          "11:   const name = 'MinterPauserToken';",
          "12:   const symbol = 'DRT';",
          "14:   const amount = new BN('5000');",
          "16:   const DEFAULT_ADMIN_ROLE = '0x0000000000000000000000000000000000000000000000000000000000000000';",
          "17:   const MINTER_ROLE = web3.utils.soliditySha3('MINTER_ROLE');",
          "18:   const PAUSER_ROLE = web3.utils.soliditySha3('PAUSER_ROLE');",
          "20:   beforeEach(async function () {",
          "21:     this.token = await ERC20PresetMinterPauser.new(name, symbol, { from: deployer });",
          "22:   });",
          "24:   it('deployer has the default admin role', async function () {",
          "25:     expect(await this.token.getRoleMemberCount(DEFAULT_ADMIN_ROLE)).to.be.bignumber.equal('1');",
          "26:     expect(await this.token.getRoleMember(DEFAULT_ADMIN_ROLE, 0)).to.equal(deployer);",
          "27:   });",
          "29:   it('deployer has the minter role', async function () {",
          "30:     expect(await this.token.getRoleMemberCount(MINTER_ROLE)).to.be.bignumber.equal('1');",
          "31:     expect(await this.token.getRoleMember(MINTER_ROLE, 0)).to.equal(deployer);",
          "32:   });",
          "34:   it('deployer has the pauser role', async function () {",
          "35:     expect(await this.token.getRoleMemberCount(PAUSER_ROLE)).to.be.bignumber.equal('1');",
          "36:     expect(await this.token.getRoleMember(PAUSER_ROLE, 0)).to.equal(deployer);",
          "37:   });",
          "39:   it('minter and pauser role admin is the default admin', async function () {",
          "40:     expect(await this.token.getRoleAdmin(MINTER_ROLE)).to.equal(DEFAULT_ADMIN_ROLE);",
          "41:     expect(await this.token.getRoleAdmin(PAUSER_ROLE)).to.equal(DEFAULT_ADMIN_ROLE);",
          "42:   });",
          "44:   describe('minting', function () {",
          "45:     it('deployer can mint tokens', async function () {",
          "46:       const receipt = await this.token.mint(other, amount, { from: deployer });",
          "47:       expectEvent(receipt, 'Transfer', { from: ZERO_ADDRESS, to: other, value: amount });",
          "49:       expect(await this.token.balanceOf(other)).to.be.bignumber.equal(amount);",
          "50:     });",
          "52:     it('other accounts cannot mint tokens', async function () {",
          "53:       await expectRevert(",
          "54:         this.token.mint(other, amount, { from: other }),",
          "55:         'ERC20PresetMinterPauser: must have minter role to mint',",
          "56:       );",
          "57:     });",
          "58:   });",
          "60:   describe('pausing', function () {",
          "61:     it('deployer can pause', async function () {",
          "62:       const receipt = await this.token.pause({ from: deployer });",
          "63:       expectEvent(receipt, 'Paused', { account: deployer });",
          "65:       expect(await this.token.paused()).to.equal(true);",
          "66:     });",
          "68:     it('deployer can unpause', async function () {",
          "69:       await this.token.pause({ from: deployer });",
          "71:       const receipt = await this.token.unpause({ from: deployer });",
          "72:       expectEvent(receipt, 'Unpaused', { account: deployer });",
          "74:       expect(await this.token.paused()).to.equal(false);",
          "75:     });",
          "77:     it('cannot mint while paused', async function () {",
          "78:       await this.token.pause({ from: deployer });",
          "80:       await expectRevert(",
          "81:         this.token.mint(other, amount, { from: deployer }),",
          "82:         'ERC20Pausable: token transfer while paused',",
          "83:       );",
          "84:     });",
          "86:     it('other accounts cannot pause', async function () {",
          "87:       await expectRevert(this.token.pause({ from: other }), 'ERC20PresetMinterPauser: must have pauser role to pause');",
          "88:     });",
          "90:     it('other accounts cannot unpause', async function () {",
          "91:       await this.token.pause({ from: deployer });",
          "93:       await expectRevert(",
          "94:         this.token.unpause({ from: other }),",
          "95:         'ERC20PresetMinterPauser: must have pauser role to unpause',",
          "96:       );",
          "97:     });",
          "98:   });",
          "100:   describe('burning', function () {",
          "101:     it('holders can burn their tokens', async function () {",
          "102:       await this.token.mint(other, amount, { from: deployer });",
          "104:       const receipt = await this.token.burn(amount.subn(1), { from: other });",
          "105:       expectEvent(receipt, 'Transfer', { from: other, to: ZERO_ADDRESS, value: amount.subn(1) });",
          "107:       expect(await this.token.balanceOf(other)).to.be.bignumber.equal('1');",
          "108:     });",
          "109:   });",
          "110: });",
          "",
          "---------------"
        ],
        "test/token/ERC20/utils/SafeERC20.test.js||test/token/ERC20/utils/SafeERC20.test.js": [
          "File: test/token/ERC20/utils/SafeERC20.test.js -> test/token/ERC20/utils/SafeERC20.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const SafeERC20 = artifacts.require('$SafeERC20');",
          "4: const ERC20ReturnFalseMock = artifacts.require('$ERC20ReturnFalseMock');",
          "5: const ERC20ReturnTrueMock = artifacts.require('$ERC20'); // default implementation returns true",
          "6: const ERC20NoReturnMock = artifacts.require('$ERC20NoReturnMock');",
          "7: const ERC20PermitNoRevertMock = artifacts.require('$ERC20PermitNoRevertMock');",
          "8: const ERC20ForceApproveMock = artifacts.require('$ERC20ForceApproveMock');",
          "10: const { getDomain, domainType, Permit } = require('../../../helpers/eip712');",
          "12: const { fromRpcSig } = require('ethereumjs-util');",
          "13: const ethSigUtil = require('eth-sig-util');",
          "14: const Wallet = require('ethereumjs-wallet').default;",
          "16: const name = 'ERC20Mock';",
          "17: const symbol = 'ERC20Mock';",
          "19: contract('SafeERC20', function (accounts) {",
          "20:   const [hasNoCode] = accounts;",
          "22:   before(async function () {",
          "23:     this.mock = await SafeERC20.new();",
          "24:   });",
          "26:   describe('with address that has no contract code', function () {",
          "27:     beforeEach(async function () {",
          "28:       this.token = { address: hasNoCode };",
          "29:     });",
          "31:     shouldRevertOnAllCalls(accounts, 'Address: call to non-contract');",
          "32:   });",
          "34:   describe('with token that returns false on all calls', function () {",
          "35:     beforeEach(async function () {",
          "36:       this.token = await ERC20ReturnFalseMock.new(name, symbol);",
          "37:     });",
          "39:     shouldRevertOnAllCalls(accounts, 'SafeERC20: ERC20 operation did not succeed');",
          "40:   });",
          "42:   describe('with token that returns true on all calls', function () {",
          "43:     beforeEach(async function () {",
          "44:       this.token = await ERC20ReturnTrueMock.new(name, symbol);",
          "45:     });",
          "47:     shouldOnlyRevertOnErrors(accounts);",
          "48:   });",
          "50:   describe('with token that returns no boolean values', function () {",
          "51:     beforeEach(async function () {",
          "52:       this.token = await ERC20NoReturnMock.new(name, symbol);",
          "53:     });",
          "55:     shouldOnlyRevertOnErrors(accounts);",
          "56:   });",
          "58:   describe(\"with token that doesn't revert on invalid permit\", function () {",
          "59:     const wallet = Wallet.generate();",
          "60:     const owner = wallet.getAddressString();",
          "61:     const spender = hasNoCode;",
          "63:     beforeEach(async function () {",
          "64:       this.token = await ERC20PermitNoRevertMock.new(name, symbol, name);",
          "66:       this.data = await getDomain(this.token).then(domain => ({",
          "67:         primaryType: 'Permit',",
          "68:         types: { EIP712Domain: domainType(domain), Permit },",
          "69:         domain,",
          "70:         message: { owner, spender, value: '42', nonce: '0', deadline: constants.MAX_UINT256 },",
          "71:       }));",
          "73:       this.signature = fromRpcSig(ethSigUtil.signTypedMessage(wallet.getPrivateKey(), { data: this.data }));",
          "74:     });",
          "76:     it('accepts owner signature', async function () {",
          "77:       expect(await this.token.nonces(owner)).to.be.bignumber.equal('0');",
          "78:       expect(await this.token.allowance(owner, spender)).to.be.bignumber.equal('0');",
          "80:       await this.mock.$safePermit(",
          "81:         this.token.address,",
          "82:         this.data.message.owner,",
          "83:         this.data.message.spender,",
          "84:         this.data.message.value,",
          "85:         this.data.message.deadline,",
          "86:         this.signature.v,",
          "87:         this.signature.r,",
          "88:         this.signature.s,",
          "89:       );",
          "91:       expect(await this.token.nonces(owner)).to.be.bignumber.equal('1');",
          "92:       expect(await this.token.allowance(owner, spender)).to.be.bignumber.equal(this.data.message.value);",
          "93:     });",
          "95:     it('revert on reused signature', async function () {",
          "96:       expect(await this.token.nonces(owner)).to.be.bignumber.equal('0');",
          "98:       await this.mock.$safePermit(",
          "99:         this.token.address,",
          "100:         this.data.message.owner,",
          "101:         this.data.message.spender,",
          "102:         this.data.message.value,",
          "103:         this.data.message.deadline,",
          "104:         this.signature.v,",
          "105:         this.signature.r,",
          "106:         this.signature.s,",
          "107:       );",
          "108:       expect(await this.token.nonces(owner)).to.be.bignumber.equal('1');",
          "110:       await this.token.permit(",
          "111:         this.data.message.owner,",
          "112:         this.data.message.spender,",
          "113:         this.data.message.value,",
          "114:         this.data.message.deadline,",
          "115:         this.signature.v,",
          "116:         this.signature.r,",
          "117:         this.signature.s,",
          "118:       );",
          "119:       expect(await this.token.nonces(owner)).to.be.bignumber.equal('1');",
          "121:       await expectRevert(",
          "122:         this.mock.$safePermit(",
          "123:           this.token.address,",
          "124:           this.data.message.owner,",
          "125:           this.data.message.spender,",
          "126:           this.data.message.value,",
          "127:           this.data.message.deadline,",
          "128:           this.signature.v,",
          "129:           this.signature.r,",
          "130:           this.signature.s,",
          "131:         ),",
          "132:         'SafeERC20: permit did not succeed',",
          "133:       );",
          "134:       expect(await this.token.nonces(owner)).to.be.bignumber.equal('1');",
          "135:     });",
          "137:     it('revert on invalid signature', async function () {",
          "139:       const invalidSignature = {",
          "140:         v: 27,",
          "141:         r: '0x71753dc5ecb5b4bfc0e3bc530d79ce5988760ed3f3a234c86a5546491f540775',",
          "142:         s: '0x0049cedee5aed990aabed5ad6a9f6e3c565b63379894b5fa8b512eb2b79e485d',",
          "143:       };",
          "146:       await this.token.permit(",
          "147:         this.data.message.owner,",
          "148:         this.data.message.spender,",
          "149:         this.data.message.value,",
          "150:         this.data.message.deadline,",
          "151:         invalidSignature.v,",
          "152:         invalidSignature.r,",
          "153:         invalidSignature.s,",
          "154:       );",
          "157:       await expectRevert(",
          "158:         this.mock.$safePermit(",
          "159:           this.token.address,",
          "160:           this.data.message.owner,",
          "161:           this.data.message.spender,",
          "162:           this.data.message.value,",
          "163:           this.data.message.deadline,",
          "164:           invalidSignature.v,",
          "165:           invalidSignature.r,",
          "166:           invalidSignature.s,",
          "167:         ),",
          "168:         'SafeERC20: permit did not succeed',",
          "169:       );",
          "170:     });",
          "171:   });",
          "173:   describe('with usdt approval beaviour', function () {",
          "174:     const spender = hasNoCode;",
          "176:     beforeEach(async function () {",
          "177:       this.token = await ERC20ForceApproveMock.new(name, symbol);",
          "178:     });",
          "180:     describe('with initial approval', function () {",
          "181:       beforeEach(async function () {",
          "182:         await this.token.$_approve(this.mock.address, spender, 100);",
          "183:       });",
          "185:       it('safeApprove fails to update approval to non-zero', async function () {",
          "186:         await expectRevert(",
          "187:           this.mock.$safeApprove(this.token.address, spender, 200),",
          "188:           'SafeERC20: approve from non-zero to non-zero allowance',",
          "189:         );",
          "190:       });",
          "192:       it('safeApprove can update approval to zero', async function () {",
          "193:         await this.mock.$safeApprove(this.token.address, spender, 0);",
          "194:       });",
          "196:       it('safeApprove can increase approval', async function () {",
          "197:         await expectRevert(this.mock.$safeIncreaseAllowance(this.token.address, spender, 10), 'USDT approval failure');",
          "198:       });",
          "200:       it('safeApprove can decrease approval', async function () {",
          "201:         await expectRevert(this.mock.$safeDecreaseAllowance(this.token.address, spender, 10), 'USDT approval failure');",
          "202:       });",
          "204:       it('forceApprove works', async function () {",
          "205:         await this.mock.$forceApprove(this.token.address, spender, 200);",
          "206:       });",
          "207:     });",
          "208:   });",
          "209: });",
          "211: function shouldRevertOnAllCalls([receiver, spender], reason) {",
          "212:   it('reverts on transfer', async function () {",
          "213:     await expectRevert(this.mock.$safeTransfer(this.token.address, receiver, 0), reason);",
          "214:   });",
          "216:   it('reverts on transferFrom', async function () {",
          "217:     await expectRevert(this.mock.$safeTransferFrom(this.token.address, this.mock.address, receiver, 0), reason);",
          "218:   });",
          "220:   it('reverts on approve', async function () {",
          "221:     await expectRevert(this.mock.$safeApprove(this.token.address, spender, 0), reason);",
          "222:   });",
          "224:   it('reverts on increaseAllowance', async function () {",
          "226:     await expectRevert.unspecified(this.mock.$safeIncreaseAllowance(this.token.address, spender, 0));",
          "227:   });",
          "229:   it('reverts on decreaseAllowance', async function () {",
          "231:     await expectRevert.unspecified(this.mock.$safeDecreaseAllowance(this.token.address, spender, 0));",
          "232:   });",
          "234:   it('reverts on forceApprove', async function () {",
          "235:     await expectRevert(this.mock.$forceApprove(this.token.address, spender, 0), reason);",
          "236:   });",
          "237: }",
          "239: function shouldOnlyRevertOnErrors([owner, receiver, spender]) {",
          "240:   describe('transfers', function () {",
          "241:     beforeEach(async function () {",
          "242:       await this.token.$_mint(owner, 100);",
          "243:       await this.token.$_mint(this.mock.address, 100);",
          "244:       await this.token.approve(this.mock.address, constants.MAX_UINT256, { from: owner });",
          "245:     });",
          "247:     it(\"doesn't revert on transfer\", async function () {",
          "248:       const { tx } = await this.mock.$safeTransfer(this.token.address, receiver, 10);",
          "249:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "250:         from: this.mock.address,",
          "251:         to: receiver,",
          "252:         value: '10',",
          "253:       });",
          "254:     });",
          "256:     it(\"doesn't revert on transferFrom\", async function () {",
          "257:       const { tx } = await this.mock.$safeTransferFrom(this.token.address, owner, receiver, 10);",
          "258:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "259:         from: owner,",
          "260:         to: receiver,",
          "261:         value: '10',",
          "262:       });",
          "263:     });",
          "264:   });",
          "266:   describe('approvals', function () {",
          "267:     context('with zero allowance', function () {",
          "268:       beforeEach(async function () {",
          "269:         await this.token.$_approve(this.mock.address, spender, 0);",
          "270:       });",
          "272:       it(\"doesn't revert when approving a non-zero allowance\", async function () {",
          "273:         await this.mock.$safeApprove(this.token.address, spender, 100);",
          "274:         expect(await this.token.allowance(this.mock.address, spender)).to.be.bignumber.equal('100');",
          "275:       });",
          "277:       it(\"doesn't revert when approving a zero allowance\", async function () {",
          "278:         await this.mock.$safeApprove(this.token.address, spender, 0);",
          "279:         expect(await this.token.allowance(this.mock.address, spender)).to.be.bignumber.equal('0');",
          "280:       });",
          "282:       it(\"doesn't revert when force approving a non-zero allowance\", async function () {",
          "283:         await this.mock.$forceApprove(this.token.address, spender, 100);",
          "284:         expect(await this.token.allowance(this.mock.address, spender)).to.be.bignumber.equal('100');",
          "285:       });",
          "287:       it(\"doesn't revert when force approving a zero allowance\", async function () {",
          "288:         await this.mock.$forceApprove(this.token.address, spender, 0);",
          "289:         expect(await this.token.allowance(this.mock.address, spender)).to.be.bignumber.equal('0');",
          "290:       });",
          "292:       it(\"doesn't revert when increasing the allowance\", async function () {",
          "293:         await this.mock.$safeIncreaseAllowance(this.token.address, spender, 10);",
          "294:         expect(await this.token.allowance(this.mock.address, spender)).to.be.bignumber.equal('10');",
          "295:       });",
          "297:       it('reverts when decreasing the allowance', async function () {",
          "298:         await expectRevert(",
          "299:           this.mock.$safeDecreaseAllowance(this.token.address, spender, 10),",
          "300:           'SafeERC20: decreased allowance below zero',",
          "301:         );",
          "302:       });",
          "303:     });",
          "305:     context('with non-zero allowance', function () {",
          "306:       beforeEach(async function () {",
          "307:         await this.token.$_approve(this.mock.address, spender, 100);",
          "308:       });",
          "310:       it('reverts when approving a non-zero allowance', async function () {",
          "311:         await expectRevert(",
          "312:           this.mock.$safeApprove(this.token.address, spender, 20),",
          "313:           'SafeERC20: approve from non-zero to non-zero allowance',",
          "314:         );",
          "315:       });",
          "317:       it(\"doesn't revert when approving a zero allowance\", async function () {",
          "318:         await this.mock.$safeApprove(this.token.address, spender, 0);",
          "319:         expect(await this.token.allowance(this.mock.address, spender)).to.be.bignumber.equal('0');",
          "320:       });",
          "322:       it(\"doesn't revert when force approving a non-zero allowance\", async function () {",
          "323:         await this.mock.$forceApprove(this.token.address, spender, 20);",
          "324:         expect(await this.token.allowance(this.mock.address, spender)).to.be.bignumber.equal('20');",
          "325:       });",
          "327:       it(\"doesn't revert when force approving a zero allowance\", async function () {",
          "328:         await this.mock.$forceApprove(this.token.address, spender, 0);",
          "329:         expect(await this.token.allowance(this.mock.address, spender)).to.be.bignumber.equal('0');",
          "330:       });",
          "332:       it(\"doesn't revert when increasing the allowance\", async function () {",
          "333:         await this.mock.$safeIncreaseAllowance(this.token.address, spender, 10);",
          "334:         expect(await this.token.allowance(this.mock.address, spender)).to.be.bignumber.equal('110');",
          "335:       });",
          "337:       it(\"doesn't revert when decreasing the allowance to a positive value\", async function () {",
          "338:         await this.mock.$safeDecreaseAllowance(this.token.address, spender, 50);",
          "339:         expect(await this.token.allowance(this.mock.address, spender)).to.be.bignumber.equal('50');",
          "340:       });",
          "342:       it('reverts when decreasing the allowance to a negative value', async function () {",
          "343:         await expectRevert(",
          "344:           this.mock.$safeDecreaseAllowance(this.token.address, spender, 200),",
          "345:           'SafeERC20: decreased allowance below zero',",
          "346:         );",
          "347:       });",
          "348:     });",
          "349:   });",
          "350: }",
          "",
          "---------------"
        ],
        "test/token/ERC20/utils/TokenTimelock.test.js||test/token/ERC20/utils/TokenTimelock.test.js": [
          "File: test/token/ERC20/utils/TokenTimelock.test.js -> test/token/ERC20/utils/TokenTimelock.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, expectRevert, time } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const ERC20 = artifacts.require('$ERC20');",
          "6: const TokenTimelock = artifacts.require('TokenTimelock');",
          "8: contract('TokenTimelock', function (accounts) {",
          "9:   const [beneficiary] = accounts;",
          "11:   const name = 'My Token';",
          "12:   const symbol = 'MTKN';",
          "14:   const amount = new BN(100);",
          "16:   context('with token', function () {",
          "17:     beforeEach(async function () {",
          "18:       this.token = await ERC20.new(name, symbol);",
          "19:     });",
          "21:     it('rejects a release time in the past', async function () {",
          "22:       const pastReleaseTime = (await time.latest()).sub(time.duration.years(1));",
          "23:       await expectRevert(",
          "24:         TokenTimelock.new(this.token.address, beneficiary, pastReleaseTime),",
          "25:         'TokenTimelock: release time is before current time',",
          "26:       );",
          "27:     });",
          "29:     context('once deployed', function () {",
          "30:       beforeEach(async function () {",
          "31:         this.releaseTime = (await time.latest()).add(time.duration.years(1));",
          "32:         this.timelock = await TokenTimelock.new(this.token.address, beneficiary, this.releaseTime);",
          "33:         await this.token.$_mint(this.timelock.address, amount);",
          "34:       });",
          "36:       it('can get state', async function () {",
          "37:         expect(await this.timelock.token()).to.equal(this.token.address);",
          "38:         expect(await this.timelock.beneficiary()).to.equal(beneficiary);",
          "39:         expect(await this.timelock.releaseTime()).to.be.bignumber.equal(this.releaseTime);",
          "40:       });",
          "42:       it('cannot be released before time limit', async function () {",
          "43:         await expectRevert(this.timelock.release(), 'TokenTimelock: current time is before release time');",
          "44:       });",
          "46:       it('cannot be released just before time limit', async function () {",
          "47:         await time.increaseTo(this.releaseTime.sub(time.duration.seconds(3)));",
          "48:         await expectRevert(this.timelock.release(), 'TokenTimelock: current time is before release time');",
          "49:       });",
          "51:       it('can be released just after limit', async function () {",
          "52:         await time.increaseTo(this.releaseTime.add(time.duration.seconds(1)));",
          "53:         await this.timelock.release();",
          "54:         expect(await this.token.balanceOf(beneficiary)).to.be.bignumber.equal(amount);",
          "55:       });",
          "57:       it('can be released after time limit', async function () {",
          "58:         await time.increaseTo(this.releaseTime.add(time.duration.years(1)));",
          "59:         await this.timelock.release();",
          "60:         expect(await this.token.balanceOf(beneficiary)).to.be.bignumber.equal(amount);",
          "61:       });",
          "63:       it('cannot be released twice', async function () {",
          "64:         await time.increaseTo(this.releaseTime.add(time.duration.years(1)));",
          "65:         await this.timelock.release();",
          "66:         await expectRevert(this.timelock.release(), 'TokenTimelock: no tokens to release');",
          "67:         expect(await this.token.balanceOf(beneficiary)).to.be.bignumber.equal(amount);",
          "68:       });",
          "69:     });",
          "70:   });",
          "71: });",
          "",
          "---------------"
        ],
        "test/token/ERC721/ERC721.behavior.js||test/token/ERC721/ERC721.behavior.js": [
          "File: test/token/ERC721/ERC721.behavior.js -> test/token/ERC721/ERC721.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const { ZERO_ADDRESS } = constants;",
          "5: const { shouldSupportInterfaces } = require('../../utils/introspection/SupportsInterface.behavior');",
          "7: const ERC721ReceiverMock = artifacts.require('ERC721ReceiverMock');",
          "8: const NonERC721ReceiverMock = artifacts.require('CallReceiverMock');",
          "10: const Error = ['None', 'RevertWithMessage', 'RevertWithoutMessage', 'Panic'].reduce(",
          "11:   (acc, entry, idx) => Object.assign({ [entry]: idx }, acc),",
          "12:   {},",
          "13: );",
          "15: const firstTokenId = new BN('5042');",
          "16: const secondTokenId = new BN('79217');",
          "17: const nonExistentTokenId = new BN('13');",
          "18: const fourthTokenId = new BN(4);",
          "19: const baseURI = 'https://api.example.com/v1/';",
          "21: const RECEIVER_MAGIC_VALUE = '0x150b7a02';",
          "23: function shouldBehaveLikeERC721(errorPrefix, owner, newOwner, approved, anotherApproved, operator, other) {",
          "24:   shouldSupportInterfaces(['ERC165', 'ERC721']);",
          "26:   context('with minted tokens', function () {",
          "27:     beforeEach(async function () {",
          "28:       await this.token.$_mint(owner, firstTokenId);",
          "29:       await this.token.$_mint(owner, secondTokenId);",
          "30:       this.toWhom = other; // default to other for toWhom in context-dependent tests",
          "31:     });",
          "33:     describe('balanceOf', function () {",
          "34:       context('when the given address owns some tokens', function () {",
          "35:         it('returns the amount of tokens owned by the given address', async function () {",
          "36:           expect(await this.token.balanceOf(owner)).to.be.bignumber.equal('2');",
          "37:         });",
          "38:       });",
          "40:       context('when the given address does not own any tokens', function () {",
          "41:         it('returns 0', async function () {",
          "42:           expect(await this.token.balanceOf(other)).to.be.bignumber.equal('0');",
          "43:         });",
          "44:       });",
          "46:       context('when querying the zero address', function () {",
          "47:         it('throws', async function () {",
          "48:           await expectRevert(this.token.balanceOf(ZERO_ADDRESS), 'ERC721: address zero is not a valid owner');",
          "49:         });",
          "50:       });",
          "51:     });",
          "53:     describe('ownerOf', function () {",
          "54:       context('when the given token ID was tracked by this token', function () {",
          "55:         const tokenId = firstTokenId;",
          "57:         it('returns the owner of the given token ID', async function () {",
          "58:           expect(await this.token.ownerOf(tokenId)).to.be.equal(owner);",
          "59:         });",
          "60:       });",
          "62:       context('when the given token ID was not tracked by this token', function () {",
          "63:         const tokenId = nonExistentTokenId;",
          "65:         it('reverts', async function () {",
          "66:           await expectRevert(this.token.ownerOf(tokenId), 'ERC721: invalid token ID');",
          "67:         });",
          "68:       });",
          "69:     });",
          "71:     describe('transfers', function () {",
          "72:       const tokenId = firstTokenId;",
          "73:       const data = '0x42';",
          "75:       let receipt = null;",
          "77:       beforeEach(async function () {",
          "78:         await this.token.approve(approved, tokenId, { from: owner });",
          "79:         await this.token.setApprovalForAll(operator, true, { from: owner });",
          "80:       });",
          "82:       const transferWasSuccessful = function ({ owner, tokenId }) {",
          "83:         it('transfers the ownership of the given token ID to the given address', async function () {",
          "84:           expect(await this.token.ownerOf(tokenId)).to.be.equal(this.toWhom);",
          "85:         });",
          "87:         it('emits a Transfer event', async function () {",
          "88:           expectEvent(receipt, 'Transfer', { from: owner, to: this.toWhom, tokenId: tokenId });",
          "89:         });",
          "91:         it('clears the approval for the token ID', async function () {",
          "92:           expect(await this.token.getApproved(tokenId)).to.be.equal(ZERO_ADDRESS);",
          "93:         });",
          "95:         it('adjusts owners balances', async function () {",
          "96:           expect(await this.token.balanceOf(owner)).to.be.bignumber.equal('1');",
          "97:         });",
          "99:         it('adjusts owners tokens by index', async function () {",
          "100:           if (!this.token.tokenOfOwnerByIndex) return;",
          "102:           expect(await this.token.tokenOfOwnerByIndex(this.toWhom, 0)).to.be.bignumber.equal(tokenId);",
          "104:           expect(await this.token.tokenOfOwnerByIndex(owner, 0)).to.be.bignumber.not.equal(tokenId);",
          "105:         });",
          "106:       };",
          "108:       const shouldTransferTokensByUsers = function (transferFunction) {",
          "109:         context('when called by the owner', function () {",
          "110:           beforeEach(async function () {",
          "111:             receipt = await transferFunction.call(this, owner, this.toWhom, tokenId, { from: owner });",
          "112:           });",
          "113:           transferWasSuccessful({ owner, tokenId, approved });",
          "114:         });",
          "116:         context('when called by the approved individual', function () {",
          "117:           beforeEach(async function () {",
          "118:             receipt = await transferFunction.call(this, owner, this.toWhom, tokenId, { from: approved });",
          "119:           });",
          "120:           transferWasSuccessful({ owner, tokenId, approved });",
          "121:         });",
          "123:         context('when called by the operator', function () {",
          "124:           beforeEach(async function () {",
          "125:             receipt = await transferFunction.call(this, owner, this.toWhom, tokenId, { from: operator });",
          "126:           });",
          "127:           transferWasSuccessful({ owner, tokenId, approved });",
          "128:         });",
          "130:         context('when called by the owner without an approved user', function () {",
          "131:           beforeEach(async function () {",
          "132:             await this.token.approve(ZERO_ADDRESS, tokenId, { from: owner });",
          "133:             receipt = await transferFunction.call(this, owner, this.toWhom, tokenId, { from: operator });",
          "134:           });",
          "135:           transferWasSuccessful({ owner, tokenId, approved: null });",
          "136:         });",
          "138:         context('when sent to the owner', function () {",
          "139:           beforeEach(async function () {",
          "140:             receipt = await transferFunction.call(this, owner, owner, tokenId, { from: owner });",
          "141:           });",
          "143:           it('keeps ownership of the token', async function () {",
          "144:             expect(await this.token.ownerOf(tokenId)).to.be.equal(owner);",
          "145:           });",
          "147:           it('clears the approval for the token ID', async function () {",
          "148:             expect(await this.token.getApproved(tokenId)).to.be.equal(ZERO_ADDRESS);",
          "149:           });",
          "151:           it('emits only a transfer event', async function () {",
          "152:             expectEvent(receipt, 'Transfer', {",
          "153:               from: owner,",
          "154:               to: owner,",
          "155:               tokenId: tokenId,",
          "156:             });",
          "157:           });",
          "159:           it('keeps the owner balance', async function () {",
          "160:             expect(await this.token.balanceOf(owner)).to.be.bignumber.equal('2');",
          "161:           });",
          "163:           it('keeps same tokens by index', async function () {",
          "164:             if (!this.token.tokenOfOwnerByIndex) return;",
          "165:             const tokensListed = await Promise.all([0, 1].map(i => this.token.tokenOfOwnerByIndex(owner, i)));",
          "166:             expect(tokensListed.map(t => t.toNumber())).to.have.members([",
          "167:               firstTokenId.toNumber(),",
          "168:               secondTokenId.toNumber(),",
          "169:             ]);",
          "170:           });",
          "171:         });",
          "173:         context('when the address of the previous owner is incorrect', function () {",
          "174:           it('reverts', async function () {",
          "175:             await expectRevert(",
          "176:               transferFunction.call(this, other, other, tokenId, { from: owner }),",
          "177:               'ERC721: transfer from incorrect owner',",
          "178:             );",
          "179:           });",
          "180:         });",
          "182:         context('when the sender is not authorized for the token id', function () {",
          "183:           it('reverts', async function () {",
          "184:             await expectRevert(",
          "185:               transferFunction.call(this, owner, other, tokenId, { from: other }),",
          "186:               'ERC721: caller is not token owner or approved',",
          "187:             );",
          "188:           });",
          "189:         });",
          "191:         context('when the given token ID does not exist', function () {",
          "192:           it('reverts', async function () {",
          "193:             await expectRevert(",
          "194:               transferFunction.call(this, owner, other, nonExistentTokenId, { from: owner }),",
          "195:               'ERC721: invalid token ID',",
          "196:             );",
          "197:           });",
          "198:         });",
          "200:         context('when the address to transfer the token to is the zero address', function () {",
          "201:           it('reverts', async function () {",
          "202:             await expectRevert(",
          "203:               transferFunction.call(this, owner, ZERO_ADDRESS, tokenId, { from: owner }),",
          "204:               'ERC721: transfer to the zero address',",
          "205:             );",
          "206:           });",
          "207:         });",
          "208:       };",
          "210:       describe('via transferFrom', function () {",
          "211:         shouldTransferTokensByUsers(function (from, to, tokenId, opts) {",
          "212:           return this.token.transferFrom(from, to, tokenId, opts);",
          "213:         });",
          "214:       });",
          "216:       describe('via safeTransferFrom', function () {",
          "217:         const safeTransferFromWithData = function (from, to, tokenId, opts) {",
          "218:           return this.token.methods['safeTransferFrom(address,address,uint256,bytes)'](from, to, tokenId, data, opts);",
          "219:         };",
          "221:         const safeTransferFromWithoutData = function (from, to, tokenId, opts) {",
          "222:           return this.token.methods['safeTransferFrom(address,address,uint256)'](from, to, tokenId, opts);",
          "223:         };",
          "225:         const shouldTransferSafely = function (transferFun, data) {",
          "226:           describe('to a user account', function () {",
          "227:             shouldTransferTokensByUsers(transferFun);",
          "228:           });",
          "230:           describe('to a valid receiver contract', function () {",
          "231:             beforeEach(async function () {",
          "232:               this.receiver = await ERC721ReceiverMock.new(RECEIVER_MAGIC_VALUE, Error.None);",
          "233:               this.toWhom = this.receiver.address;",
          "234:             });",
          "236:             shouldTransferTokensByUsers(transferFun);",
          "238:             it('calls onERC721Received', async function () {",
          "239:               const receipt = await transferFun.call(this, owner, this.receiver.address, tokenId, { from: owner });",
          "241:               await expectEvent.inTransaction(receipt.tx, ERC721ReceiverMock, 'Received', {",
          "242:                 operator: owner,",
          "243:                 from: owner,",
          "244:                 tokenId: tokenId,",
          "245:                 data: data,",
          "246:               });",
          "247:             });",
          "249:             it('calls onERC721Received from approved', async function () {",
          "250:               const receipt = await transferFun.call(this, owner, this.receiver.address, tokenId, { from: approved });",
          "252:               await expectEvent.inTransaction(receipt.tx, ERC721ReceiverMock, 'Received', {",
          "253:                 operator: approved,",
          "254:                 from: owner,",
          "255:                 tokenId: tokenId,",
          "256:                 data: data,",
          "257:               });",
          "258:             });",
          "260:             describe('with an invalid token id', function () {",
          "261:               it('reverts', async function () {",
          "262:                 await expectRevert(",
          "263:                   transferFun.call(this, owner, this.receiver.address, nonExistentTokenId, { from: owner }),",
          "264:                   'ERC721: invalid token ID',",
          "265:                 );",
          "266:               });",
          "267:             });",
          "268:           });",
          "269:         };",
          "271:         describe('with data', function () {",
          "272:           shouldTransferSafely(safeTransferFromWithData, data);",
          "273:         });",
          "275:         describe('without data', function () {",
          "276:           shouldTransferSafely(safeTransferFromWithoutData, null);",
          "277:         });",
          "279:         describe('to a receiver contract returning unexpected value', function () {",
          "280:           it('reverts', async function () {",
          "281:             const invalidReceiver = await ERC721ReceiverMock.new('0x42', Error.None);",
          "282:             await expectRevert(",
          "283:               this.token.safeTransferFrom(owner, invalidReceiver.address, tokenId, { from: owner }),",
          "284:               'ERC721: transfer to non ERC721Receiver implementer',",
          "285:             );",
          "286:           });",
          "287:         });",
          "289:         describe('to a receiver contract that reverts with message', function () {",
          "290:           it('reverts', async function () {",
          "291:             const revertingReceiver = await ERC721ReceiverMock.new(RECEIVER_MAGIC_VALUE, Error.RevertWithMessage);",
          "292:             await expectRevert(",
          "293:               this.token.safeTransferFrom(owner, revertingReceiver.address, tokenId, { from: owner }),",
          "294:               'ERC721ReceiverMock: reverting',",
          "295:             );",
          "296:           });",
          "297:         });",
          "299:         describe('to a receiver contract that reverts without message', function () {",
          "300:           it('reverts', async function () {",
          "301:             const revertingReceiver = await ERC721ReceiverMock.new(RECEIVER_MAGIC_VALUE, Error.RevertWithoutMessage);",
          "302:             await expectRevert(",
          "303:               this.token.safeTransferFrom(owner, revertingReceiver.address, tokenId, { from: owner }),",
          "304:               'ERC721: transfer to non ERC721Receiver implementer',",
          "305:             );",
          "306:           });",
          "307:         });",
          "309:         describe('to a receiver contract that panics', function () {",
          "310:           it('reverts', async function () {",
          "311:             const revertingReceiver = await ERC721ReceiverMock.new(RECEIVER_MAGIC_VALUE, Error.Panic);",
          "312:             await expectRevert.unspecified(",
          "313:               this.token.safeTransferFrom(owner, revertingReceiver.address, tokenId, { from: owner }),",
          "314:             );",
          "315:           });",
          "316:         });",
          "318:         describe('to a contract that does not implement the required function', function () {",
          "319:           it('reverts', async function () {",
          "320:             const nonReceiver = await NonERC721ReceiverMock.new();",
          "321:             await expectRevert(",
          "322:               this.token.safeTransferFrom(owner, nonReceiver.address, tokenId, { from: owner }),",
          "323:               'ERC721: transfer to non ERC721Receiver implementer',",
          "324:             );",
          "325:           });",
          "326:         });",
          "327:       });",
          "328:     });",
          "330:     describe('safe mint', function () {",
          "331:       const tokenId = fourthTokenId;",
          "332:       const data = '0x42';",
          "334:       describe('via safeMint', function () {",
          "336:         it('calls onERC721Received \u2014 with data', async function () {",
          "337:           this.receiver = await ERC721ReceiverMock.new(RECEIVER_MAGIC_VALUE, Error.None);",
          "338:           const receipt = await this.token.$_safeMint(this.receiver.address, tokenId, data);",
          "340:           await expectEvent.inTransaction(receipt.tx, ERC721ReceiverMock, 'Received', {",
          "341:             from: ZERO_ADDRESS,",
          "342:             tokenId: tokenId,",
          "343:             data: data,",
          "344:           });",
          "345:         });",
          "347:         it('calls onERC721Received \u2014 without data', async function () {",
          "348:           this.receiver = await ERC721ReceiverMock.new(RECEIVER_MAGIC_VALUE, Error.None);",
          "349:           const receipt = await this.token.$_safeMint(this.receiver.address, tokenId);",
          "351:           await expectEvent.inTransaction(receipt.tx, ERC721ReceiverMock, 'Received', {",
          "352:             from: ZERO_ADDRESS,",
          "353:             tokenId: tokenId,",
          "354:           });",
          "355:         });",
          "357:         context('to a receiver contract returning unexpected value', function () {",
          "358:           it('reverts', async function () {",
          "359:             const invalidReceiver = await ERC721ReceiverMock.new('0x42', Error.None);",
          "360:             await expectRevert(",
          "361:               this.token.$_safeMint(invalidReceiver.address, tokenId),",
          "362:               'ERC721: transfer to non ERC721Receiver implementer',",
          "363:             );",
          "364:           });",
          "365:         });",
          "367:         context('to a receiver contract that reverts with message', function () {",
          "368:           it('reverts', async function () {",
          "369:             const revertingReceiver = await ERC721ReceiverMock.new(RECEIVER_MAGIC_VALUE, Error.RevertWithMessage);",
          "370:             await expectRevert(",
          "371:               this.token.$_safeMint(revertingReceiver.address, tokenId),",
          "372:               'ERC721ReceiverMock: reverting',",
          "373:             );",
          "374:           });",
          "375:         });",
          "377:         context('to a receiver contract that reverts without message', function () {",
          "378:           it('reverts', async function () {",
          "379:             const revertingReceiver = await ERC721ReceiverMock.new(RECEIVER_MAGIC_VALUE, Error.RevertWithoutMessage);",
          "380:             await expectRevert(",
          "381:               this.token.$_safeMint(revertingReceiver.address, tokenId),",
          "382:               'ERC721: transfer to non ERC721Receiver implementer',",
          "383:             );",
          "384:           });",
          "385:         });",
          "387:         context('to a receiver contract that panics', function () {",
          "388:           it('reverts', async function () {",
          "389:             const revertingReceiver = await ERC721ReceiverMock.new(RECEIVER_MAGIC_VALUE, Error.Panic);",
          "390:             await expectRevert.unspecified(this.token.$_safeMint(revertingReceiver.address, tokenId));",
          "391:           });",
          "392:         });",
          "394:         context('to a contract that does not implement the required function', function () {",
          "395:           it('reverts', async function () {",
          "396:             const nonReceiver = await NonERC721ReceiverMock.new();",
          "397:             await expectRevert(",
          "398:               this.token.$_safeMint(nonReceiver.address, tokenId),",
          "399:               'ERC721: transfer to non ERC721Receiver implementer',",
          "400:             );",
          "401:           });",
          "402:         });",
          "403:       });",
          "404:     });",
          "406:     describe('approve', function () {",
          "407:       const tokenId = firstTokenId;",
          "409:       let receipt = null;",
          "411:       const itClearsApproval = function () {",
          "412:         it('clears approval for the token', async function () {",
          "413:           expect(await this.token.getApproved(tokenId)).to.be.equal(ZERO_ADDRESS);",
          "414:         });",
          "415:       };",
          "417:       const itApproves = function (address) {",
          "418:         it('sets the approval for the target address', async function () {",
          "419:           expect(await this.token.getApproved(tokenId)).to.be.equal(address);",
          "420:         });",
          "421:       };",
          "423:       const itEmitsApprovalEvent = function (address) {",
          "424:         it('emits an approval event', async function () {",
          "425:           expectEvent(receipt, 'Approval', {",
          "426:             owner: owner,",
          "427:             approved: address,",
          "428:             tokenId: tokenId,",
          "429:           });",
          "430:         });",
          "431:       };",
          "433:       context('when clearing approval', function () {",
          "434:         context('when there was no prior approval', function () {",
          "435:           beforeEach(async function () {",
          "436:             receipt = await this.token.approve(ZERO_ADDRESS, tokenId, { from: owner });",
          "437:           });",
          "439:           itClearsApproval();",
          "440:           itEmitsApprovalEvent(ZERO_ADDRESS);",
          "441:         });",
          "443:         context('when there was a prior approval', function () {",
          "444:           beforeEach(async function () {",
          "445:             await this.token.approve(approved, tokenId, { from: owner });",
          "446:             receipt = await this.token.approve(ZERO_ADDRESS, tokenId, { from: owner });",
          "447:           });",
          "449:           itClearsApproval();",
          "450:           itEmitsApprovalEvent(ZERO_ADDRESS);",
          "451:         });",
          "452:       });",
          "454:       context('when approving a non-zero address', function () {",
          "455:         context('when there was no prior approval', function () {",
          "456:           beforeEach(async function () {",
          "457:             receipt = await this.token.approve(approved, tokenId, { from: owner });",
          "458:           });",
          "460:           itApproves(approved);",
          "461:           itEmitsApprovalEvent(approved);",
          "462:         });",
          "464:         context('when there was a prior approval to the same address', function () {",
          "465:           beforeEach(async function () {",
          "466:             await this.token.approve(approved, tokenId, { from: owner });",
          "467:             receipt = await this.token.approve(approved, tokenId, { from: owner });",
          "468:           });",
          "470:           itApproves(approved);",
          "471:           itEmitsApprovalEvent(approved);",
          "472:         });",
          "474:         context('when there was a prior approval to a different address', function () {",
          "475:           beforeEach(async function () {",
          "476:             await this.token.approve(anotherApproved, tokenId, { from: owner });",
          "477:             receipt = await this.token.approve(anotherApproved, tokenId, { from: owner });",
          "478:           });",
          "480:           itApproves(anotherApproved);",
          "481:           itEmitsApprovalEvent(anotherApproved);",
          "482:         });",
          "483:       });",
          "485:       context('when the address that receives the approval is the owner', function () {",
          "486:         it('reverts', async function () {",
          "487:           await expectRevert(this.token.approve(owner, tokenId, { from: owner }), 'ERC721: approval to current owner');",
          "488:         });",
          "489:       });",
          "491:       context('when the sender does not own the given token ID', function () {",
          "492:         it('reverts', async function () {",
          "493:           await expectRevert(",
          "494:             this.token.approve(approved, tokenId, { from: other }),",
          "495:             'ERC721: approve caller is not token owner or approved',",
          "496:           );",
          "497:         });",
          "498:       });",
          "500:       context('when the sender is approved for the given token ID', function () {",
          "501:         it('reverts', async function () {",
          "502:           await this.token.approve(approved, tokenId, { from: owner });",
          "503:           await expectRevert(",
          "504:             this.token.approve(anotherApproved, tokenId, { from: approved }),",
          "505:             'ERC721: approve caller is not token owner or approved for all',",
          "506:           );",
          "507:         });",
          "508:       });",
          "510:       context('when the sender is an operator', function () {",
          "511:         beforeEach(async function () {",
          "512:           await this.token.setApprovalForAll(operator, true, { from: owner });",
          "513:           receipt = await this.token.approve(approved, tokenId, { from: operator });",
          "514:         });",
          "516:         itApproves(approved);",
          "517:         itEmitsApprovalEvent(approved);",
          "518:       });",
          "520:       context('when the given token ID does not exist', function () {",
          "521:         it('reverts', async function () {",
          "522:           await expectRevert(",
          "523:             this.token.approve(approved, nonExistentTokenId, { from: operator }),",
          "524:             'ERC721: invalid token ID',",
          "525:           );",
          "526:         });",
          "527:       });",
          "528:     });",
          "530:     describe('setApprovalForAll', function () {",
          "531:       context('when the operator willing to approve is not the owner', function () {",
          "532:         context('when there is no operator approval set by the sender', function () {",
          "533:           it('approves the operator', async function () {",
          "534:             await this.token.setApprovalForAll(operator, true, { from: owner });",
          "536:             expect(await this.token.isApprovedForAll(owner, operator)).to.equal(true);",
          "537:           });",
          "539:           it('emits an approval event', async function () {",
          "540:             const receipt = await this.token.setApprovalForAll(operator, true, { from: owner });",
          "542:             expectEvent(receipt, 'ApprovalForAll', {",
          "543:               owner: owner,",
          "544:               operator: operator,",
          "545:               approved: true,",
          "546:             });",
          "547:           });",
          "548:         });",
          "550:         context('when the operator was set as not approved', function () {",
          "551:           beforeEach(async function () {",
          "552:             await this.token.setApprovalForAll(operator, false, { from: owner });",
          "553:           });",
          "555:           it('approves the operator', async function () {",
          "556:             await this.token.setApprovalForAll(operator, true, { from: owner });",
          "558:             expect(await this.token.isApprovedForAll(owner, operator)).to.equal(true);",
          "559:           });",
          "561:           it('emits an approval event', async function () {",
          "562:             const receipt = await this.token.setApprovalForAll(operator, true, { from: owner });",
          "564:             expectEvent(receipt, 'ApprovalForAll', {",
          "565:               owner: owner,",
          "566:               operator: operator,",
          "567:               approved: true,",
          "568:             });",
          "569:           });",
          "571:           it('can unset the operator approval', async function () {",
          "572:             await this.token.setApprovalForAll(operator, false, { from: owner });",
          "574:             expect(await this.token.isApprovedForAll(owner, operator)).to.equal(false);",
          "575:           });",
          "576:         });",
          "578:         context('when the operator was already approved', function () {",
          "579:           beforeEach(async function () {",
          "580:             await this.token.setApprovalForAll(operator, true, { from: owner });",
          "581:           });",
          "583:           it('keeps the approval to the given address', async function () {",
          "584:             await this.token.setApprovalForAll(operator, true, { from: owner });",
          "586:             expect(await this.token.isApprovedForAll(owner, operator)).to.equal(true);",
          "587:           });",
          "589:           it('emits an approval event', async function () {",
          "590:             const receipt = await this.token.setApprovalForAll(operator, true, { from: owner });",
          "592:             expectEvent(receipt, 'ApprovalForAll', {",
          "593:               owner: owner,",
          "594:               operator: operator,",
          "595:               approved: true,",
          "596:             });",
          "597:           });",
          "598:         });",
          "599:       });",
          "601:       context('when the operator is the owner', function () {",
          "602:         it('reverts', async function () {",
          "603:           await expectRevert(this.token.setApprovalForAll(owner, true, { from: owner }), 'ERC721: approve to caller');",
          "604:         });",
          "605:       });",
          "606:     });",
          "608:     describe('getApproved', async function () {",
          "609:       context('when token is not minted', async function () {",
          "610:         it('reverts', async function () {",
          "611:           await expectRevert(this.token.getApproved(nonExistentTokenId), 'ERC721: invalid token ID');",
          "612:         });",
          "613:       });",
          "615:       context('when token has been minted ', async function () {",
          "616:         it('should return the zero address', async function () {",
          "617:           expect(await this.token.getApproved(firstTokenId)).to.be.equal(ZERO_ADDRESS);",
          "618:         });",
          "620:         context('when account has been approved', async function () {",
          "621:           beforeEach(async function () {",
          "622:             await this.token.approve(approved, firstTokenId, { from: owner });",
          "623:           });",
          "625:           it('returns approved account', async function () {",
          "626:             expect(await this.token.getApproved(firstTokenId)).to.be.equal(approved);",
          "627:           });",
          "628:         });",
          "629:       });",
          "630:     });",
          "631:   });",
          "633:   describe('_mint(address, uint256)', function () {",
          "634:     it('reverts with a null destination address', async function () {",
          "635:       await expectRevert(this.token.$_mint(ZERO_ADDRESS, firstTokenId), 'ERC721: mint to the zero address');",
          "636:     });",
          "638:     context('with minted token', async function () {",
          "639:       beforeEach(async function () {",
          "640:         this.receipt = await this.token.$_mint(owner, firstTokenId);",
          "641:       });",
          "643:       it('emits a Transfer event', function () {",
          "644:         expectEvent(this.receipt, 'Transfer', { from: ZERO_ADDRESS, to: owner, tokenId: firstTokenId });",
          "645:       });",
          "647:       it('creates the token', async function () {",
          "648:         expect(await this.token.balanceOf(owner)).to.be.bignumber.equal('1');",
          "649:         expect(await this.token.ownerOf(firstTokenId)).to.equal(owner);",
          "650:       });",
          "652:       it('reverts when adding a token id that already exists', async function () {",
          "653:         await expectRevert(this.token.$_mint(owner, firstTokenId), 'ERC721: token already minted');",
          "654:       });",
          "655:     });",
          "656:   });",
          "658:   describe('_burn', function () {",
          "659:     it('reverts when burning a non-existent token id', async function () {",
          "660:       await expectRevert(this.token.$_burn(nonExistentTokenId), 'ERC721: invalid token ID');",
          "661:     });",
          "663:     context('with minted tokens', function () {",
          "664:       beforeEach(async function () {",
          "665:         await this.token.$_mint(owner, firstTokenId);",
          "666:         await this.token.$_mint(owner, secondTokenId);",
          "667:       });",
          "669:       context('with burnt token', function () {",
          "670:         beforeEach(async function () {",
          "671:           this.receipt = await this.token.$_burn(firstTokenId);",
          "672:         });",
          "674:         it('emits a Transfer event', function () {",
          "675:           expectEvent(this.receipt, 'Transfer', { from: owner, to: ZERO_ADDRESS, tokenId: firstTokenId });",
          "676:         });",
          "678:         it('deletes the token', async function () {",
          "679:           expect(await this.token.balanceOf(owner)).to.be.bignumber.equal('1');",
          "680:           await expectRevert(this.token.ownerOf(firstTokenId), 'ERC721: invalid token ID');",
          "681:         });",
          "683:         it('reverts when burning a token id that has been deleted', async function () {",
          "684:           await expectRevert(this.token.$_burn(firstTokenId), 'ERC721: invalid token ID');",
          "685:         });",
          "686:       });",
          "687:     });",
          "688:   });",
          "689: }",
          "691: function shouldBehaveLikeERC721Enumerable(errorPrefix, owner, newOwner, approved, anotherApproved, operator, other) {",
          "692:   shouldSupportInterfaces(['ERC721Enumerable']);",
          "694:   context('with minted tokens', function () {",
          "695:     beforeEach(async function () {",
          "696:       await this.token.$_mint(owner, firstTokenId);",
          "697:       await this.token.$_mint(owner, secondTokenId);",
          "698:       this.toWhom = other; // default to other for toWhom in context-dependent tests",
          "699:     });",
          "701:     describe('totalSupply', function () {",
          "702:       it('returns total token supply', async function () {",
          "703:         expect(await this.token.totalSupply()).to.be.bignumber.equal('2');",
          "704:       });",
          "705:     });",
          "707:     describe('tokenOfOwnerByIndex', function () {",
          "708:       describe('when the given index is lower than the amount of tokens owned by the given address', function () {",
          "709:         it('returns the token ID placed at the given index', async function () {",
          "710:           expect(await this.token.tokenOfOwnerByIndex(owner, 0)).to.be.bignumber.equal(firstTokenId);",
          "711:         });",
          "712:       });",
          "714:       describe('when the index is greater than or equal to the total tokens owned by the given address', function () {",
          "715:         it('reverts', async function () {",
          "716:           await expectRevert(this.token.tokenOfOwnerByIndex(owner, 2), 'ERC721Enumerable: owner index out of bounds');",
          "717:         });",
          "718:       });",
          "720:       describe('when the given address does not own any token', function () {",
          "721:         it('reverts', async function () {",
          "722:           await expectRevert(this.token.tokenOfOwnerByIndex(other, 0), 'ERC721Enumerable: owner index out of bounds');",
          "723:         });",
          "724:       });",
          "726:       describe('after transferring all tokens to another user', function () {",
          "727:         beforeEach(async function () {",
          "728:           await this.token.transferFrom(owner, other, firstTokenId, { from: owner });",
          "729:           await this.token.transferFrom(owner, other, secondTokenId, { from: owner });",
          "730:         });",
          "732:         it('returns correct token IDs for target', async function () {",
          "733:           expect(await this.token.balanceOf(other)).to.be.bignumber.equal('2');",
          "734:           const tokensListed = await Promise.all([0, 1].map(i => this.token.tokenOfOwnerByIndex(other, i)));",
          "735:           expect(tokensListed.map(t => t.toNumber())).to.have.members([",
          "736:             firstTokenId.toNumber(),",
          "737:             secondTokenId.toNumber(),",
          "738:           ]);",
          "739:         });",
          "741:         it('returns empty collection for original owner', async function () {",
          "742:           expect(await this.token.balanceOf(owner)).to.be.bignumber.equal('0');",
          "743:           await expectRevert(this.token.tokenOfOwnerByIndex(owner, 0), 'ERC721Enumerable: owner index out of bounds');",
          "744:         });",
          "745:       });",
          "746:     });",
          "748:     describe('tokenByIndex', function () {",
          "749:       it('returns all tokens', async function () {",
          "750:         const tokensListed = await Promise.all([0, 1].map(i => this.token.tokenByIndex(i)));",
          "751:         expect(tokensListed.map(t => t.toNumber())).to.have.members([",
          "752:           firstTokenId.toNumber(),",
          "753:           secondTokenId.toNumber(),",
          "754:         ]);",
          "755:       });",
          "757:       it('reverts if index is greater than supply', async function () {",
          "758:         await expectRevert(this.token.tokenByIndex(2), 'ERC721Enumerable: global index out of bounds');",
          "759:       });",
          "761:       [firstTokenId, secondTokenId].forEach(function (tokenId) {",
          "762:         it(`returns all tokens after burning token ${tokenId} and minting new tokens`, async function () {",
          "763:           const newTokenId = new BN(300);",
          "764:           const anotherNewTokenId = new BN(400);",
          "766:           await this.token.$_burn(tokenId);",
          "767:           await this.token.$_mint(newOwner, newTokenId);",
          "768:           await this.token.$_mint(newOwner, anotherNewTokenId);",
          "770:           expect(await this.token.totalSupply()).to.be.bignumber.equal('3');",
          "772:           const tokensListed = await Promise.all([0, 1, 2].map(i => this.token.tokenByIndex(i)));",
          "773:           const expectedTokens = [firstTokenId, secondTokenId, newTokenId, anotherNewTokenId].filter(",
          "774:             x => x !== tokenId,",
          "775:           );",
          "776:           expect(tokensListed.map(t => t.toNumber())).to.have.members(expectedTokens.map(t => t.toNumber()));",
          "777:         });",
          "778:       });",
          "779:     });",
          "780:   });",
          "782:   describe('_mint(address, uint256)', function () {",
          "783:     it('reverts with a null destination address', async function () {",
          "784:       await expectRevert(this.token.$_mint(ZERO_ADDRESS, firstTokenId), 'ERC721: mint to the zero address');",
          "785:     });",
          "787:     context('with minted token', async function () {",
          "788:       beforeEach(async function () {",
          "789:         this.receipt = await this.token.$_mint(owner, firstTokenId);",
          "790:       });",
          "792:       it('adjusts owner tokens by index', async function () {",
          "793:         expect(await this.token.tokenOfOwnerByIndex(owner, 0)).to.be.bignumber.equal(firstTokenId);",
          "794:       });",
          "796:       it('adjusts all tokens list', async function () {",
          "797:         expect(await this.token.tokenByIndex(0)).to.be.bignumber.equal(firstTokenId);",
          "798:       });",
          "799:     });",
          "800:   });",
          "802:   describe('_burn', function () {",
          "803:     it('reverts when burning a non-existent token id', async function () {",
          "804:       await expectRevert(this.token.$_burn(firstTokenId), 'ERC721: invalid token ID');",
          "805:     });",
          "807:     context('with minted tokens', function () {",
          "808:       beforeEach(async function () {",
          "809:         await this.token.$_mint(owner, firstTokenId);",
          "810:         await this.token.$_mint(owner, secondTokenId);",
          "811:       });",
          "813:       context('with burnt token', function () {",
          "814:         beforeEach(async function () {",
          "815:           this.receipt = await this.token.$_burn(firstTokenId);",
          "816:         });",
          "818:         it('removes that token from the token list of the owner', async function () {",
          "819:           expect(await this.token.tokenOfOwnerByIndex(owner, 0)).to.be.bignumber.equal(secondTokenId);",
          "820:         });",
          "822:         it('adjusts all tokens list', async function () {",
          "823:           expect(await this.token.tokenByIndex(0)).to.be.bignumber.equal(secondTokenId);",
          "824:         });",
          "826:         it('burns all tokens', async function () {",
          "827:           await this.token.$_burn(secondTokenId, { from: owner });",
          "828:           expect(await this.token.totalSupply()).to.be.bignumber.equal('0');",
          "829:           await expectRevert(this.token.tokenByIndex(0), 'ERC721Enumerable: global index out of bounds');",
          "830:         });",
          "831:       });",
          "832:     });",
          "833:   });",
          "834: }",
          "836: function shouldBehaveLikeERC721Metadata(errorPrefix, name, symbol, owner) {",
          "837:   shouldSupportInterfaces(['ERC721Metadata']);",
          "839:   describe('metadata', function () {",
          "840:     it('has a name', async function () {",
          "841:       expect(await this.token.name()).to.be.equal(name);",
          "842:     });",
          "844:     it('has a symbol', async function () {",
          "845:       expect(await this.token.symbol()).to.be.equal(symbol);",
          "846:     });",
          "848:     describe('token URI', function () {",
          "849:       beforeEach(async function () {",
          "850:         await this.token.$_mint(owner, firstTokenId);",
          "851:       });",
          "853:       it('return empty string by default', async function () {",
          "854:         expect(await this.token.tokenURI(firstTokenId)).to.be.equal('');",
          "855:       });",
          "857:       it('reverts when queried for non existent token id', async function () {",
          "858:         await expectRevert(this.token.tokenURI(nonExistentTokenId), 'ERC721: invalid token ID');",
          "859:       });",
          "861:       describe('base URI', function () {",
          "862:         beforeEach(function () {",
          "863:           if (this.token.setBaseURI === undefined) {",
          "864:             this.skip();",
          "865:           }",
          "866:         });",
          "868:         it('base URI can be set', async function () {",
          "869:           await this.token.setBaseURI(baseURI);",
          "870:           expect(await this.token.baseURI()).to.equal(baseURI);",
          "871:         });",
          "873:         it('base URI is added as a prefix to the token URI', async function () {",
          "874:           await this.token.setBaseURI(baseURI);",
          "875:           expect(await this.token.tokenURI(firstTokenId)).to.be.equal(baseURI + firstTokenId.toString());",
          "876:         });",
          "878:         it('token URI can be changed by changing the base URI', async function () {",
          "879:           await this.token.setBaseURI(baseURI);",
          "880:           const newBaseURI = 'https://api.example.com/v2/';",
          "881:           await this.token.setBaseURI(newBaseURI);",
          "882:           expect(await this.token.tokenURI(firstTokenId)).to.be.equal(newBaseURI + firstTokenId.toString());",
          "883:         });",
          "884:       });",
          "885:     });",
          "886:   });",
          "887: }",
          "889: module.exports = {",
          "890:   shouldBehaveLikeERC721,",
          "891:   shouldBehaveLikeERC721Enumerable,",
          "892:   shouldBehaveLikeERC721Metadata,",
          "893: };",
          "",
          "---------------"
        ],
        "test/token/ERC721/ERC721.test.js||test/token/ERC721/ERC721.test.js": [
          "File: test/token/ERC721/ERC721.test.js -> test/token/ERC721/ERC721.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { shouldBehaveLikeERC721, shouldBehaveLikeERC721Metadata } = require('./ERC721.behavior');",
          "3: const ERC721 = artifacts.require('$ERC721');",
          "5: contract('ERC721', function (accounts) {",
          "6:   const name = 'Non Fungible Token';",
          "7:   const symbol = 'NFT';",
          "9:   beforeEach(async function () {",
          "10:     this.token = await ERC721.new(name, symbol);",
          "11:   });",
          "13:   shouldBehaveLikeERC721('ERC721', ...accounts);",
          "14:   shouldBehaveLikeERC721Metadata('ERC721', name, symbol, ...accounts);",
          "15: });",
          "",
          "---------------"
        ],
        "test/token/ERC721/ERC721Enumerable.test.js||test/token/ERC721/ERC721Enumerable.test.js": [
          "File: test/token/ERC721/ERC721Enumerable.test.js -> test/token/ERC721/ERC721Enumerable.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const {",
          "2:   shouldBehaveLikeERC721,",
          "3:   shouldBehaveLikeERC721Metadata,",
          "4:   shouldBehaveLikeERC721Enumerable,",
          "5: } = require('./ERC721.behavior');",
          "7: const ERC721Enumerable = artifacts.require('$ERC721Enumerable');",
          "9: contract('ERC721Enumerable', function (accounts) {",
          "10:   const name = 'Non Fungible Token';",
          "11:   const symbol = 'NFT';",
          "13:   beforeEach(async function () {",
          "14:     this.token = await ERC721Enumerable.new(name, symbol);",
          "15:   });",
          "17:   shouldBehaveLikeERC721('ERC721', ...accounts);",
          "18:   shouldBehaveLikeERC721Metadata('ERC721', name, symbol, ...accounts);",
          "19:   shouldBehaveLikeERC721Enumerable('ERC721', ...accounts);",
          "20: });",
          "",
          "---------------"
        ],
        "test/token/ERC721/extensions/ERC721Burnable.test.js||test/token/ERC721/extensions/ERC721Burnable.test.js": [
          "File: test/token/ERC721/extensions/ERC721Burnable.test.js -> test/token/ERC721/extensions/ERC721Burnable.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const ERC721Burnable = artifacts.require('$ERC721Burnable');",
          "7: contract('ERC721Burnable', function (accounts) {",
          "8:   const [owner, approved] = accounts;",
          "10:   const firstTokenId = new BN(1);",
          "11:   const secondTokenId = new BN(2);",
          "12:   const unknownTokenId = new BN(3);",
          "14:   const name = 'Non Fungible Token';",
          "15:   const symbol = 'NFT';",
          "17:   beforeEach(async function () {",
          "18:     this.token = await ERC721Burnable.new(name, symbol);",
          "19:   });",
          "21:   describe('like a burnable ERC721', function () {",
          "22:     beforeEach(async function () {",
          "23:       await this.token.$_mint(owner, firstTokenId);",
          "24:       await this.token.$_mint(owner, secondTokenId);",
          "25:     });",
          "27:     describe('burn', function () {",
          "28:       const tokenId = firstTokenId;",
          "29:       let receipt = null;",
          "31:       describe('when successful', function () {",
          "32:         beforeEach(async function () {",
          "33:           receipt = await this.token.burn(tokenId, { from: owner });",
          "34:         });",
          "36:         it('burns the given token ID and adjusts the balance of the owner', async function () {",
          "37:           await expectRevert(this.token.ownerOf(tokenId), 'ERC721: invalid token ID');",
          "38:           expect(await this.token.balanceOf(owner)).to.be.bignumber.equal('1');",
          "39:         });",
          "41:         it('emits a burn event', async function () {",
          "42:           expectEvent(receipt, 'Transfer', {",
          "43:             from: owner,",
          "44:             to: constants.ZERO_ADDRESS,",
          "45:             tokenId: tokenId,",
          "46:           });",
          "47:         });",
          "48:       });",
          "50:       describe('when there is a previous approval burned', function () {",
          "51:         beforeEach(async function () {",
          "52:           await this.token.approve(approved, tokenId, { from: owner });",
          "53:           receipt = await this.token.burn(tokenId, { from: owner });",
          "54:         });",
          "56:         context('getApproved', function () {",
          "57:           it('reverts', async function () {",
          "58:             await expectRevert(this.token.getApproved(tokenId), 'ERC721: invalid token ID');",
          "59:           });",
          "60:         });",
          "61:       });",
          "63:       describe('when the given token ID was not tracked by this contract', function () {",
          "64:         it('reverts', async function () {",
          "65:           await expectRevert(this.token.burn(unknownTokenId, { from: owner }), 'ERC721: invalid token ID');",
          "66:         });",
          "67:       });",
          "68:     });",
          "69:   });",
          "70: });",
          "",
          "---------------"
        ],
        "test/token/ERC721/extensions/ERC721Consecutive.t.sol||test/token/ERC721/extensions/ERC721Consecutive.t.sol": [
          "File: test/token/ERC721/extensions/ERC721Consecutive.t.sol -> test/token/ERC721/extensions/ERC721Consecutive.t.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "7: import \"../../../../contracts/token/ERC721/extensions/ERC721Consecutive.sol\";",
          "8: import \"forge-std/Test.sol\";",
          "10: function toSingleton(address account) pure returns (address[] memory) {",
          "11:     address[] memory accounts = new address[](1);",
          "12:     accounts[0] = account;",
          "13:     return accounts;",
          "14: }",
          "16: contract ERC721ConsecutiveTarget is StdUtils, ERC721Consecutive {",
          "17:     uint256 public totalMinted = 0;",
          "19:     constructor(address[] memory receivers, uint256[] memory batches) ERC721(\"\", \"\") {",
          "20:         for (uint256 i = 0; i < batches.length; i++) {",
          "21:             address receiver = receivers[i % receivers.length];",
          "22:             uint96 batchSize = uint96(bound(batches[i], 0, _maxBatchSize()));",
          "23:             _mintConsecutive(receiver, batchSize);",
          "24:             totalMinted += batchSize;",
          "25:         }",
          "26:     }",
          "28:     function burn(uint256 tokenId) public {",
          "29:         _burn(tokenId);",
          "30:     }",
          "31: }",
          "33: contract ERC721ConsecutiveTest is Test {",
          "34:     function test_balance(address receiver, uint256[] calldata batches) public {",
          "35:         vm.assume(receiver != address(0));",
          "37:         ERC721ConsecutiveTarget token = new ERC721ConsecutiveTarget(toSingleton(receiver), batches);",
          "39:         assertEq(token.balanceOf(receiver), token.totalMinted());",
          "40:     }",
          "42:     function test_ownership(address receiver, uint256[] calldata batches, uint256[2] calldata unboundedTokenId) public {",
          "43:         vm.assume(receiver != address(0));",
          "45:         ERC721ConsecutiveTarget token = new ERC721ConsecutiveTarget(toSingleton(receiver), batches);",
          "47:         if (token.totalMinted() > 0) {",
          "48:             uint256 validTokenId = bound(unboundedTokenId[0], 0, token.totalMinted() - 1);",
          "49:             assertEq(token.ownerOf(validTokenId), receiver);",
          "50:         }",
          "52:         uint256 invalidTokenId = bound(unboundedTokenId[1], token.totalMinted(), type(uint256).max);",
          "53:         vm.expectRevert();",
          "54:         token.ownerOf(invalidTokenId);",
          "55:     }",
          "57:     function test_burn(address receiver, uint256[] calldata batches, uint256 unboundedTokenId) public {",
          "58:         vm.assume(receiver != address(0));",
          "60:         ERC721ConsecutiveTarget token = new ERC721ConsecutiveTarget(toSingleton(receiver), batches);",
          "63:         uint256 supply = token.totalMinted();",
          "64:         vm.assume(supply > 0);",
          "67:         uint256 tokenId = bound(unboundedTokenId, 0, supply - 1);",
          "68:         token.burn(tokenId);",
          "71:         assertEq(token.balanceOf(receiver), supply - 1);",
          "74:         vm.expectRevert();",
          "75:         token.ownerOf(tokenId);",
          "76:     }",
          "78:     function test_transfer(",
          "79:         address[2] calldata accounts,",
          "80:         uint256[2] calldata unboundedBatches,",
          "81:         uint256[2] calldata unboundedTokenId",
          "82:     ) public {",
          "83:         vm.assume(accounts[0] != address(0));",
          "84:         vm.assume(accounts[1] != address(0));",
          "85:         vm.assume(accounts[0] != accounts[1]);",
          "87:         address[] memory receivers = new address[](2);",
          "88:         receivers[0] = accounts[0];",
          "89:         receivers[1] = accounts[1];",
          "92:         uint256[] memory batches = new uint256[](2);",
          "93:         batches[0] = bound(unboundedBatches[0], 1, 5000);",
          "94:         batches[1] = bound(unboundedBatches[1], 1, 5000);",
          "96:         ERC721ConsecutiveTarget token = new ERC721ConsecutiveTarget(receivers, batches);",
          "98:         uint256 tokenId0 = bound(unboundedTokenId[0], 0, batches[0] - 1);",
          "99:         uint256 tokenId1 = bound(unboundedTokenId[1], 0, batches[1] - 1) + batches[0];",
          "101:         assertEq(token.ownerOf(tokenId0), accounts[0]);",
          "102:         assertEq(token.ownerOf(tokenId1), accounts[1]);",
          "103:         assertEq(token.balanceOf(accounts[0]), batches[0]);",
          "104:         assertEq(token.balanceOf(accounts[1]), batches[1]);",
          "106:         vm.prank(accounts[0]);",
          "107:         token.transferFrom(accounts[0], accounts[1], tokenId0);",
          "109:         assertEq(token.ownerOf(tokenId0), accounts[1]);",
          "110:         assertEq(token.ownerOf(tokenId1), accounts[1]);",
          "111:         assertEq(token.balanceOf(accounts[0]), batches[0] - 1);",
          "112:         assertEq(token.balanceOf(accounts[1]), batches[1] + 1);",
          "114:         vm.prank(accounts[1]);",
          "115:         token.transferFrom(accounts[1], accounts[0], tokenId1);",
          "117:         assertEq(token.ownerOf(tokenId0), accounts[1]);",
          "118:         assertEq(token.ownerOf(tokenId1), accounts[0]);",
          "119:         assertEq(token.balanceOf(accounts[0]), batches[0]);",
          "120:         assertEq(token.balanceOf(accounts[1]), batches[1]);",
          "121:     }",
          "122: }",
          "",
          "---------------"
        ],
        "test/token/ERC721/extensions/ERC721Consecutive.test.js||test/token/ERC721/extensions/ERC721Consecutive.test.js": [
          "File: test/token/ERC721/extensions/ERC721Consecutive.test.js -> test/token/ERC721/extensions/ERC721Consecutive.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "4: const ERC721ConsecutiveMock = artifacts.require('$ERC721ConsecutiveMock');",
          "5: const ERC721ConsecutiveEnumerableMock = artifacts.require('$ERC721ConsecutiveEnumerableMock');",
          "6: const ERC721ConsecutiveNoConstructorMintMock = artifacts.require('$ERC721ConsecutiveNoConstructorMintMock');",
          "8: contract('ERC721Consecutive', function (accounts) {",
          "9:   const [user1, user2, user3, receiver] = accounts;",
          "11:   const name = 'Non Fungible Token';",
          "12:   const symbol = 'NFT';",
          "13:   const batches = [",
          "14:     { receiver: user1, amount: 0 },",
          "15:     { receiver: user1, amount: 1 },",
          "16:     { receiver: user1, amount: 2 },",
          "17:     { receiver: user2, amount: 5 },",
          "18:     { receiver: user3, amount: 0 },",
          "19:     { receiver: user1, amount: 7 },",
          "20:   ];",
          "21:   const delegates = [user1, user3];",
          "23:   describe('with valid batches', function () {",
          "24:     beforeEach(async function () {",
          "25:       this.token = await ERC721ConsecutiveMock.new(",
          "26:         name,",
          "27:         symbol,",
          "28:         delegates,",
          "29:         batches.map(({ receiver }) => receiver),",
          "30:         batches.map(({ amount }) => amount),",
          "31:       );",
          "32:     });",
          "34:     describe('minting during construction', function () {",
          "35:       it('events are emitted at construction', async function () {",
          "36:         let first = 0;",
          "38:         for (const batch of batches) {",
          "39:           if (batch.amount > 0) {",
          "40:             await expectEvent.inConstruction(this.token, 'ConsecutiveTransfer', {",
          "41:               fromTokenId: web3.utils.toBN(first),",
          "42:               toTokenId: web3.utils.toBN(first + batch.amount - 1),",
          "43:               fromAddress: constants.ZERO_ADDRESS,",
          "44:               toAddress: batch.receiver,",
          "45:             });",
          "46:           } else {",
          "48:           }",
          "49:           first += batch.amount;",
          "50:         }",
          "51:       });",
          "53:       it('ownership is set', async function () {",
          "54:         const owners = batches.flatMap(({ receiver, amount }) => Array(amount).fill(receiver));",
          "56:         for (const tokenId in owners) {",
          "57:           expect(await this.token.ownerOf(tokenId)).to.be.equal(owners[tokenId]);",
          "58:         }",
          "59:       });",
          "61:       it('balance & voting power are set', async function () {",
          "62:         for (const account of accounts) {",
          "63:           const balance = batches",
          "64:             .filter(({ receiver }) => receiver === account)",
          "65:             .map(({ amount }) => amount)",
          "66:             .reduce((a, b) => a + b, 0);",
          "68:           expect(await this.token.balanceOf(account)).to.be.bignumber.equal(web3.utils.toBN(balance));",
          "71:           if (!delegates.includes(account)) {",
          "72:             expect(await this.token.getVotes(account)).to.be.bignumber.equal(web3.utils.toBN(0));",
          "74:             await this.token.delegate(account, { from: account });",
          "75:           }",
          "78:           expect(await this.token.getVotes(account)).to.be.bignumber.equal(web3.utils.toBN(balance));",
          "79:         }",
          "80:       });",
          "81:     });",
          "83:     describe('minting after construction', function () {",
          "84:       it('consecutive minting is not possible after construction', async function () {",
          "85:         await expectRevert(",
          "86:           this.token.$_mintConsecutive(user1, 10),",
          "87:           'ERC721Consecutive: batch minting restricted to constructor',",
          "88:         );",
          "89:       });",
          "91:       it('simple minting is possible after construction', async function () {",
          "92:         const tokenId = batches.reduce((acc, { amount }) => acc + amount, 0);",
          "94:         expect(await this.token.$_exists(tokenId)).to.be.equal(false);",
          "96:         expectEvent(await this.token.$_mint(user1, tokenId), 'Transfer', {",
          "97:           from: constants.ZERO_ADDRESS,",
          "98:           to: user1,",
          "99:           tokenId: tokenId.toString(),",
          "100:         });",
          "101:       });",
          "103:       it('cannot mint a token that has been batched minted', async function () {",
          "104:         const tokenId = batches.reduce((acc, { amount }) => acc + amount, 0) - 1;",
          "106:         expect(await this.token.$_exists(tokenId)).to.be.equal(true);",
          "108:         await expectRevert(this.token.$_mint(user1, tokenId), 'ERC721: token already minted');",
          "109:       });",
          "110:     });",
          "112:     describe('ERC721 behavior', function () {",
          "113:       it('core takes over ownership on transfer', async function () {",
          "114:         await this.token.transferFrom(user1, receiver, 1, { from: user1 });",
          "116:         expect(await this.token.ownerOf(1)).to.be.equal(receiver);",
          "117:       });",
          "119:       it('tokens can be burned and re-minted #1', async function () {",
          "120:         expectEvent(await this.token.$_burn(1, { from: user1 }), 'Transfer', {",
          "121:           from: user1,",
          "122:           to: constants.ZERO_ADDRESS,",
          "123:           tokenId: '1',",
          "124:         });",
          "126:         await expectRevert(this.token.ownerOf(1), 'ERC721: invalid token ID');",
          "128:         expectEvent(await this.token.$_mint(user2, 1), 'Transfer', {",
          "129:           from: constants.ZERO_ADDRESS,",
          "130:           to: user2,",
          "131:           tokenId: '1',",
          "132:         });",
          "134:         expect(await this.token.ownerOf(1)).to.be.equal(user2);",
          "135:       });",
          "137:       it('tokens can be burned and re-minted #2', async function () {",
          "138:         const tokenId = batches.reduce((acc, { amount }) => acc.addn(amount), web3.utils.toBN(0));",
          "140:         expect(await this.token.$_exists(tokenId)).to.be.equal(false);",
          "141:         await expectRevert(this.token.ownerOf(tokenId), 'ERC721: invalid token ID');",
          "144:         await this.token.$_mint(user1, tokenId);",
          "146:         expect(await this.token.$_exists(tokenId)).to.be.equal(true);",
          "147:         expect(await this.token.ownerOf(tokenId), user1);",
          "150:         expectEvent(await this.token.$_burn(tokenId, { from: user1 }), 'Transfer', {",
          "151:           from: user1,",
          "152:           to: constants.ZERO_ADDRESS,",
          "153:           tokenId,",
          "154:         });",
          "156:         expect(await this.token.$_exists(tokenId)).to.be.equal(false);",
          "157:         await expectRevert(this.token.ownerOf(tokenId), 'ERC721: invalid token ID');",
          "160:         expectEvent(await this.token.$_mint(user2, tokenId), 'Transfer', {",
          "161:           from: constants.ZERO_ADDRESS,",
          "162:           to: user2,",
          "163:           tokenId,",
          "164:         });",
          "166:         expect(await this.token.$_exists(tokenId)).to.be.equal(true);",
          "167:         expect(await this.token.ownerOf(tokenId), user2);",
          "168:       });",
          "169:     });",
          "170:   });",
          "172:   describe('invalid use', function () {",
          "173:     it('cannot mint a batch larger than 5000', async function () {",
          "174:       await expectRevert(",
          "175:         ERC721ConsecutiveMock.new(name, symbol, [], [user1], ['5001']),",
          "176:         'ERC721Consecutive: batch too large',",
          "177:       );",
          "178:     });",
          "180:     it('cannot use single minting during construction', async function () {",
          "181:       await expectRevert(",
          "182:         ERC721ConsecutiveNoConstructorMintMock.new(name, symbol),",
          "183:         \"ERC721Consecutive: can't mint during construction\",",
          "184:       );",
          "185:     });",
          "187:     it('cannot use single minting during construction', async function () {",
          "188:       await expectRevert(",
          "189:         ERC721ConsecutiveNoConstructorMintMock.new(name, symbol),",
          "190:         \"ERC721Consecutive: can't mint during construction\",",
          "191:       );",
          "192:     });",
          "194:     it('consecutive mint not compatible with enumerability', async function () {",
          "195:       await expectRevert(",
          "196:         ERC721ConsecutiveEnumerableMock.new(",
          "197:           name,",
          "198:           symbol,",
          "199:           batches.map(({ receiver }) => receiver),",
          "200:           batches.map(({ amount }) => amount),",
          "201:         ),",
          "202:         'ERC721Enumerable: consecutive transfers not supported',",
          "203:       );",
          "204:     });",
          "205:   });",
          "206: });",
          "",
          "---------------"
        ],
        "test/token/ERC721/extensions/ERC721Pausable.test.js||test/token/ERC721/extensions/ERC721Pausable.test.js": [
          "File: test/token/ERC721/extensions/ERC721Pausable.test.js -> test/token/ERC721/extensions/ERC721Pausable.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const ERC721Pausable = artifacts.require('$ERC721Pausable');",
          "7: contract('ERC721Pausable', function (accounts) {",
          "8:   const [owner, receiver, operator] = accounts;",
          "10:   const name = 'Non Fungible Token';",
          "11:   const symbol = 'NFT';",
          "13:   beforeEach(async function () {",
          "14:     this.token = await ERC721Pausable.new(name, symbol);",
          "15:   });",
          "17:   context('when token is paused', function () {",
          "18:     const firstTokenId = new BN(1);",
          "19:     const secondTokenId = new BN(1337);",
          "21:     const mockData = '0x42';",
          "23:     beforeEach(async function () {",
          "24:       await this.token.$_mint(owner, firstTokenId, { from: owner });",
          "25:       await this.token.$_pause();",
          "26:     });",
          "28:     it('reverts when trying to transferFrom', async function () {",
          "29:       await expectRevert(",
          "30:         this.token.transferFrom(owner, receiver, firstTokenId, { from: owner }),",
          "31:         'ERC721Pausable: token transfer while paused',",
          "32:       );",
          "33:     });",
          "35:     it('reverts when trying to safeTransferFrom', async function () {",
          "36:       await expectRevert(",
          "37:         this.token.safeTransferFrom(owner, receiver, firstTokenId, { from: owner }),",
          "38:         'ERC721Pausable: token transfer while paused',",
          "39:       );",
          "40:     });",
          "42:     it('reverts when trying to safeTransferFrom with data', async function () {",
          "43:       await expectRevert(",
          "44:         this.token.methods['safeTransferFrom(address,address,uint256,bytes)'](owner, receiver, firstTokenId, mockData, {",
          "45:           from: owner,",
          "46:         }),",
          "47:         'ERC721Pausable: token transfer while paused',",
          "48:       );",
          "49:     });",
          "51:     it('reverts when trying to mint', async function () {",
          "52:       await expectRevert(this.token.$_mint(receiver, secondTokenId), 'ERC721Pausable: token transfer while paused');",
          "53:     });",
          "55:     it('reverts when trying to burn', async function () {",
          "56:       await expectRevert(this.token.$_burn(firstTokenId), 'ERC721Pausable: token transfer while paused');",
          "57:     });",
          "59:     describe('getApproved', function () {",
          "60:       it('returns approved address', async function () {",
          "61:         const approvedAccount = await this.token.getApproved(firstTokenId);",
          "62:         expect(approvedAccount).to.equal(constants.ZERO_ADDRESS);",
          "63:       });",
          "64:     });",
          "66:     describe('balanceOf', function () {",
          "67:       it('returns the amount of tokens owned by the given address', async function () {",
          "68:         const balance = await this.token.balanceOf(owner);",
          "69:         expect(balance).to.be.bignumber.equal('1');",
          "70:       });",
          "71:     });",
          "73:     describe('ownerOf', function () {",
          "74:       it('returns the amount of tokens owned by the given address', async function () {",
          "75:         const ownerOfToken = await this.token.ownerOf(firstTokenId);",
          "76:         expect(ownerOfToken).to.equal(owner);",
          "77:       });",
          "78:     });",
          "80:     describe('exists', function () {",
          "81:       it('returns token existence', async function () {",
          "82:         expect(await this.token.$_exists(firstTokenId)).to.equal(true);",
          "83:       });",
          "84:     });",
          "86:     describe('isApprovedForAll', function () {",
          "87:       it('returns the approval of the operator', async function () {",
          "88:         expect(await this.token.isApprovedForAll(owner, operator)).to.equal(false);",
          "89:       });",
          "90:     });",
          "91:   });",
          "92: });",
          "",
          "---------------"
        ],
        "test/token/ERC721/extensions/ERC721Royalty.test.js||test/token/ERC721/extensions/ERC721Royalty.test.js": [
          "File: test/token/ERC721/extensions/ERC721Royalty.test.js -> test/token/ERC721/extensions/ERC721Royalty.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants } = require('@openzeppelin/test-helpers');",
          "3: const { shouldBehaveLikeERC2981 } = require('../../common/ERC2981.behavior');",
          "5: const ERC721Royalty = artifacts.require('$ERC721Royalty');",
          "7: contract('ERC721Royalty', function (accounts) {",
          "8:   const [account1, account2] = accounts;",
          "9:   const tokenId1 = new BN('1');",
          "10:   const tokenId2 = new BN('2');",
          "11:   const royalty = new BN('200');",
          "12:   const salePrice = new BN('1000');",
          "14:   beforeEach(async function () {",
          "15:     this.token = await ERC721Royalty.new('My Token', 'TKN');",
          "17:     await this.token.$_mint(account1, tokenId1);",
          "18:     await this.token.$_mint(account1, tokenId2);",
          "19:     this.account1 = account1;",
          "20:     this.account2 = account2;",
          "21:     this.tokenId1 = tokenId1;",
          "22:     this.tokenId2 = tokenId2;",
          "23:     this.salePrice = salePrice;",
          "24:   });",
          "26:   describe('token specific functions', function () {",
          "27:     beforeEach(async function () {",
          "28:       await this.token.$_setTokenRoyalty(tokenId1, account1, royalty);",
          "29:     });",
          "31:     it('removes royalty information after burn', async function () {",
          "32:       await this.token.$_burn(tokenId1);",
          "33:       const tokenInfo = await this.token.royaltyInfo(tokenId1, salePrice);",
          "35:       expect(tokenInfo[0]).to.be.equal(constants.ZERO_ADDRESS);",
          "36:       expect(tokenInfo[1]).to.be.bignumber.equal(new BN('0'));",
          "37:     });",
          "38:   });",
          "40:   shouldBehaveLikeERC2981();",
          "41: });",
          "",
          "---------------"
        ],
        "test/token/ERC721/extensions/ERC721URIStorage.test.js||test/token/ERC721/extensions/ERC721URIStorage.test.js": [
          "File: test/token/ERC721/extensions/ERC721URIStorage.test.js -> test/token/ERC721/extensions/ERC721URIStorage.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "4: const { shouldSupportInterfaces } = require('../../../utils/introspection/SupportsInterface.behavior');",
          "6: const ERC721URIStorageMock = artifacts.require('$ERC721URIStorageMock');",
          "8: contract('ERC721URIStorage', function (accounts) {",
          "9:   const [owner] = accounts;",
          "11:   const name = 'Non Fungible Token';",
          "12:   const symbol = 'NFT';",
          "14:   const firstTokenId = new BN('5042');",
          "15:   const nonExistentTokenId = new BN('13');",
          "17:   beforeEach(async function () {",
          "18:     this.token = await ERC721URIStorageMock.new(name, symbol);",
          "19:   });",
          "21:   shouldSupportInterfaces(['0x49064906']);",
          "23:   describe('token URI', function () {",
          "24:     beforeEach(async function () {",
          "25:       await this.token.$_mint(owner, firstTokenId);",
          "26:     });",
          "28:     const baseURI = 'https://api.example.com/v1/';",
          "29:     const sampleUri = 'mock://mytoken';",
          "31:     it('it is empty by default', async function () {",
          "32:       expect(await this.token.tokenURI(firstTokenId)).to.be.equal('');",
          "33:     });",
          "35:     it('reverts when queried for non existent token id', async function () {",
          "36:       await expectRevert(this.token.tokenURI(nonExistentTokenId), 'ERC721: invalid token ID');",
          "37:     });",
          "39:     it('can be set for a token id', async function () {",
          "40:       await this.token.$_setTokenURI(firstTokenId, sampleUri);",
          "41:       expect(await this.token.tokenURI(firstTokenId)).to.be.equal(sampleUri);",
          "42:     });",
          "44:     it('setting the uri emits an event', async function () {",
          "45:       expectEvent(await this.token.$_setTokenURI(firstTokenId, sampleUri), 'MetadataUpdate', {",
          "46:         _tokenId: firstTokenId,",
          "47:       });",
          "48:     });",
          "50:     it('reverts when setting for non existent token id', async function () {",
          "51:       await expectRevert(",
          "52:         this.token.$_setTokenURI(nonExistentTokenId, sampleUri),",
          "53:         'ERC721URIStorage: URI set of nonexistent token',",
          "54:       );",
          "55:     });",
          "57:     it('base URI can be set', async function () {",
          "58:       await this.token.setBaseURI(baseURI);",
          "59:       expect(await this.token.$_baseURI()).to.equal(baseURI);",
          "60:     });",
          "62:     it('base URI is added as a prefix to the token URI', async function () {",
          "63:       await this.token.setBaseURI(baseURI);",
          "64:       await this.token.$_setTokenURI(firstTokenId, sampleUri);",
          "66:       expect(await this.token.tokenURI(firstTokenId)).to.be.equal(baseURI + sampleUri);",
          "67:     });",
          "69:     it('token URI can be changed by changing the base URI', async function () {",
          "70:       await this.token.setBaseURI(baseURI);",
          "71:       await this.token.$_setTokenURI(firstTokenId, sampleUri);",
          "73:       const newBaseURI = 'https://api.example.com/v2/';",
          "74:       await this.token.setBaseURI(newBaseURI);",
          "75:       expect(await this.token.tokenURI(firstTokenId)).to.be.equal(newBaseURI + sampleUri);",
          "76:     });",
          "78:     it('tokenId is appended to base URI for tokens with no URI', async function () {",
          "79:       await this.token.setBaseURI(baseURI);",
          "81:       expect(await this.token.tokenURI(firstTokenId)).to.be.equal(baseURI + firstTokenId);",
          "82:     });",
          "84:     it('tokens without URI can be burnt ', async function () {",
          "85:       await this.token.$_burn(firstTokenId, { from: owner });",
          "87:       expect(await this.token.$_exists(firstTokenId)).to.equal(false);",
          "88:       await expectRevert(this.token.tokenURI(firstTokenId), 'ERC721: invalid token ID');",
          "89:     });",
          "91:     it('tokens with URI can be burnt ', async function () {",
          "92:       await this.token.$_setTokenURI(firstTokenId, sampleUri);",
          "94:       await this.token.$_burn(firstTokenId, { from: owner });",
          "96:       expect(await this.token.$_exists(firstTokenId)).to.equal(false);",
          "97:       await expectRevert(this.token.tokenURI(firstTokenId), 'ERC721: invalid token ID');",
          "98:     });",
          "99:   });",
          "100: });",
          "",
          "---------------"
        ],
        "test/token/ERC721/extensions/ERC721Votes.test.js||test/token/ERC721/extensions/ERC721Votes.test.js": [
          "File: test/token/ERC721/extensions/ERC721Votes.test.js -> test/token/ERC721/extensions/ERC721Votes.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: const { BN, expectEvent, time } = require('@openzeppelin/test-helpers');",
          "4: const { expect } = require('chai');",
          "6: const { getChainId } = require('../../../helpers/chainid');",
          "8: const { shouldBehaveLikeVotes } = require('../../../governance/utils/Votes.behavior');",
          "10: const ERC721Votes = artifacts.require('$ERC721Votes');",
          "12: contract('ERC721Votes', function (accounts) {",
          "13:   const [account1, account2, account1Delegatee, other1, other2] = accounts;",
          "15:   const name = 'My Vote';",
          "16:   const symbol = 'MTKN';",
          "18:   beforeEach(async function () {",
          "19:     this.chainId = await getChainId();",
          "21:     this.votes = await ERC721Votes.new(name, symbol, name, '1');",
          "23:     this.NFT0 = new BN('10000000000000000000000000');",
          "24:     this.NFT1 = new BN('10');",
          "25:     this.NFT2 = new BN('20');",
          "26:     this.NFT3 = new BN('30');",
          "27:   });",
          "29:   describe('balanceOf', function () {",
          "30:     beforeEach(async function () {",
          "31:       await this.votes.$_mint(account1, this.NFT0);",
          "32:       await this.votes.$_mint(account1, this.NFT1);",
          "33:       await this.votes.$_mint(account1, this.NFT2);",
          "34:       await this.votes.$_mint(account1, this.NFT3);",
          "35:     });",
          "37:     it('grants to initial account', async function () {",
          "38:       expect(await this.votes.balanceOf(account1)).to.be.bignumber.equal('4');",
          "39:     });",
          "40:   });",
          "42:   describe('transfers', function () {",
          "43:     beforeEach(async function () {",
          "44:       await this.votes.$_mint(account1, this.NFT0);",
          "45:     });",
          "47:     it('no delegation', async function () {",
          "48:       const { receipt } = await this.votes.transferFrom(account1, account2, this.NFT0, { from: account1 });",
          "49:       expectEvent(receipt, 'Transfer', { from: account1, to: account2, tokenId: this.NFT0 });",
          "50:       expectEvent.notEmitted(receipt, 'DelegateVotesChanged');",
          "52:       this.account1Votes = '0';",
          "53:       this.account2Votes = '0';",
          "54:     });",
          "56:     it('sender delegation', async function () {",
          "57:       await this.votes.delegate(account1, { from: account1 });",
          "59:       const { receipt } = await this.votes.transferFrom(account1, account2, this.NFT0, { from: account1 });",
          "60:       expectEvent(receipt, 'Transfer', { from: account1, to: account2, tokenId: this.NFT0 });",
          "61:       expectEvent(receipt, 'DelegateVotesChanged', { delegate: account1, previousBalance: '1', newBalance: '0' });",
          "63:       const { logIndex: transferLogIndex } = receipt.logs.find(({ event }) => event == 'Transfer');",
          "64:       expect(",
          "65:         receipt.logs",
          "66:           .filter(({ event }) => event == 'DelegateVotesChanged')",
          "67:           .every(({ logIndex }) => transferLogIndex < logIndex),",
          "68:       ).to.be.equal(true);",
          "70:       this.account1Votes = '0';",
          "71:       this.account2Votes = '0';",
          "72:     });",
          "74:     it('receiver delegation', async function () {",
          "75:       await this.votes.delegate(account2, { from: account2 });",
          "77:       const { receipt } = await this.votes.transferFrom(account1, account2, this.NFT0, { from: account1 });",
          "78:       expectEvent(receipt, 'Transfer', { from: account1, to: account2, tokenId: this.NFT0 });",
          "79:       expectEvent(receipt, 'DelegateVotesChanged', { delegate: account2, previousBalance: '0', newBalance: '1' });",
          "81:       const { logIndex: transferLogIndex } = receipt.logs.find(({ event }) => event == 'Transfer');",
          "82:       expect(",
          "83:         receipt.logs",
          "84:           .filter(({ event }) => event == 'DelegateVotesChanged')",
          "85:           .every(({ logIndex }) => transferLogIndex < logIndex),",
          "86:       ).to.be.equal(true);",
          "88:       this.account1Votes = '0';",
          "89:       this.account2Votes = '1';",
          "90:     });",
          "92:     it('full delegation', async function () {",
          "93:       await this.votes.delegate(account1, { from: account1 });",
          "94:       await this.votes.delegate(account2, { from: account2 });",
          "96:       const { receipt } = await this.votes.transferFrom(account1, account2, this.NFT0, { from: account1 });",
          "97:       expectEvent(receipt, 'Transfer', { from: account1, to: account2, tokenId: this.NFT0 });",
          "98:       expectEvent(receipt, 'DelegateVotesChanged', { delegate: account1, previousBalance: '1', newBalance: '0' });",
          "99:       expectEvent(receipt, 'DelegateVotesChanged', { delegate: account2, previousBalance: '0', newBalance: '1' });",
          "101:       const { logIndex: transferLogIndex } = receipt.logs.find(({ event }) => event == 'Transfer');",
          "102:       expect(",
          "103:         receipt.logs",
          "104:           .filter(({ event }) => event == 'DelegateVotesChanged')",
          "105:           .every(({ logIndex }) => transferLogIndex < logIndex),",
          "106:       ).to.be.equal(true);",
          "108:       this.account1Votes = '0';",
          "109:       this.account2Votes = '1';",
          "110:     });",
          "112:     it('returns the same total supply on transfers', async function () {",
          "113:       await this.votes.delegate(account1, { from: account1 });",
          "115:       const { receipt } = await this.votes.transferFrom(account1, account2, this.NFT0, { from: account1 });",
          "117:       await time.advanceBlock();",
          "118:       await time.advanceBlock();",
          "120:       expect(await this.votes.getPastTotalSupply(receipt.blockNumber - 1)).to.be.bignumber.equal('1');",
          "121:       expect(await this.votes.getPastTotalSupply(receipt.blockNumber + 1)).to.be.bignumber.equal('1');",
          "123:       this.account1Votes = '0';",
          "124:       this.account2Votes = '0';",
          "125:     });",
          "127:     it('generally returns the voting balance at the appropriate checkpoint', async function () {",
          "128:       await this.votes.$_mint(account1, this.NFT1);",
          "129:       await this.votes.$_mint(account1, this.NFT2);",
          "130:       await this.votes.$_mint(account1, this.NFT3);",
          "132:       const total = await this.votes.balanceOf(account1);",
          "134:       const t1 = await this.votes.delegate(other1, { from: account1 });",
          "135:       await time.advanceBlock();",
          "136:       await time.advanceBlock();",
          "137:       const t2 = await this.votes.transferFrom(account1, other2, this.NFT0, { from: account1 });",
          "138:       await time.advanceBlock();",
          "139:       await time.advanceBlock();",
          "140:       const t3 = await this.votes.transferFrom(account1, other2, this.NFT2, { from: account1 });",
          "141:       await time.advanceBlock();",
          "142:       await time.advanceBlock();",
          "143:       const t4 = await this.votes.transferFrom(other2, account1, this.NFT2, { from: other2 });",
          "144:       await time.advanceBlock();",
          "145:       await time.advanceBlock();",
          "147:       expect(await this.votes.getPastVotes(other1, t1.receipt.blockNumber - 1)).to.be.bignumber.equal('0');",
          "148:       expect(await this.votes.getPastVotes(other1, t1.receipt.blockNumber)).to.be.bignumber.equal(total);",
          "149:       expect(await this.votes.getPastVotes(other1, t1.receipt.blockNumber + 1)).to.be.bignumber.equal(total);",
          "150:       expect(await this.votes.getPastVotes(other1, t2.receipt.blockNumber)).to.be.bignumber.equal('3');",
          "151:       expect(await this.votes.getPastVotes(other1, t2.receipt.blockNumber + 1)).to.be.bignumber.equal('3');",
          "152:       expect(await this.votes.getPastVotes(other1, t3.receipt.blockNumber)).to.be.bignumber.equal('2');",
          "153:       expect(await this.votes.getPastVotes(other1, t3.receipt.blockNumber + 1)).to.be.bignumber.equal('2');",
          "154:       expect(await this.votes.getPastVotes(other1, t4.receipt.blockNumber)).to.be.bignumber.equal('3');",
          "155:       expect(await this.votes.getPastVotes(other1, t4.receipt.blockNumber + 1)).to.be.bignumber.equal('3');",
          "157:       this.account1Votes = '0';",
          "158:       this.account2Votes = '0';",
          "159:     });",
          "161:     afterEach(async function () {",
          "162:       expect(await this.votes.getVotes(account1)).to.be.bignumber.equal(this.account1Votes);",
          "163:       expect(await this.votes.getVotes(account2)).to.be.bignumber.equal(this.account2Votes);",
          "166:       const blockNumber = await time.latestBlock();",
          "167:       await time.advanceBlock();",
          "168:       expect(await this.votes.getPastVotes(account1, blockNumber)).to.be.bignumber.equal(this.account1Votes);",
          "169:       expect(await this.votes.getPastVotes(account2, blockNumber)).to.be.bignumber.equal(this.account2Votes);",
          "170:     });",
          "171:   });",
          "173:   describe('Voting workflow', function () {",
          "174:     beforeEach(async function () {",
          "175:       this.account1 = account1;",
          "176:       this.account1Delegatee = account1Delegatee;",
          "177:       this.account2 = account2;",
          "178:       this.name = 'My Vote';",
          "179:     });",
          "182:     shouldBehaveLikeVotes();",
          "183:   });",
          "184: });",
          "",
          "---------------"
        ],
        "test/token/ERC721/extensions/ERC721Wrapper.test.js||test/token/ERC721/extensions/ERC721Wrapper.test.js": [
          "File: test/token/ERC721/extensions/ERC721Wrapper.test.js -> test/token/ERC721/extensions/ERC721Wrapper.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, expectEvent, constants, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "4: const { shouldBehaveLikeERC721 } = require('../ERC721.behavior');",
          "6: const ERC721 = artifacts.require('$ERC721');",
          "7: const ERC721Wrapper = artifacts.require('$ERC721Wrapper');",
          "9: contract('ERC721Wrapper', function (accounts) {",
          "10:   const [initialHolder, anotherAccount, approvedAccount] = accounts;",
          "12:   const name = 'My Token';",
          "13:   const symbol = 'MTKN';",
          "14:   const firstTokenId = new BN(1);",
          "15:   const secondTokenId = new BN(2);",
          "17:   beforeEach(async function () {",
          "18:     this.underlying = await ERC721.new(name, symbol);",
          "19:     this.token = await ERC721Wrapper.new(`Wrapped ${name}`, `W${symbol}`, this.underlying.address);",
          "21:     await this.underlying.$_safeMint(initialHolder, firstTokenId);",
          "22:     await this.underlying.$_safeMint(initialHolder, secondTokenId);",
          "23:   });",
          "25:   it('has a name', async function () {",
          "26:     expect(await this.token.name()).to.equal(`Wrapped ${name}`);",
          "27:   });",
          "29:   it('has a symbol', async function () {",
          "30:     expect(await this.token.symbol()).to.equal(`W${symbol}`);",
          "31:   });",
          "33:   it('has underlying', async function () {",
          "34:     expect(await this.token.underlying()).to.be.bignumber.equal(this.underlying.address);",
          "35:   });",
          "37:   describe('depositFor', function () {",
          "38:     it('works with token approval', async function () {",
          "39:       await this.underlying.approve(this.token.address, firstTokenId, { from: initialHolder });",
          "41:       const { tx } = await this.token.depositFor(initialHolder, [firstTokenId], { from: initialHolder });",
          "43:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "44:         from: initialHolder,",
          "45:         to: this.token.address,",
          "46:         tokenId: firstTokenId,",
          "47:       });",
          "48:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "49:         from: constants.ZERO_ADDRESS,",
          "50:         to: initialHolder,",
          "51:         tokenId: firstTokenId,",
          "52:       });",
          "53:     });",
          "55:     it('works with approval for all', async function () {",
          "56:       await this.underlying.setApprovalForAll(this.token.address, true, { from: initialHolder });",
          "58:       const { tx } = await this.token.depositFor(initialHolder, [firstTokenId], { from: initialHolder });",
          "60:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "61:         from: initialHolder,",
          "62:         to: this.token.address,",
          "63:         tokenId: firstTokenId,",
          "64:       });",
          "65:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "66:         from: constants.ZERO_ADDRESS,",
          "67:         to: initialHolder,",
          "68:         tokenId: firstTokenId,",
          "69:       });",
          "70:     });",
          "72:     it('works sending to another account', async function () {",
          "73:       await this.underlying.approve(this.token.address, firstTokenId, { from: initialHolder });",
          "75:       const { tx } = await this.token.depositFor(anotherAccount, [firstTokenId], { from: initialHolder });",
          "77:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "78:         from: initialHolder,",
          "79:         to: this.token.address,",
          "80:         tokenId: firstTokenId,",
          "81:       });",
          "82:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "83:         from: constants.ZERO_ADDRESS,",
          "84:         to: anotherAccount,",
          "85:         tokenId: firstTokenId,",
          "86:       });",
          "87:     });",
          "89:     it('works with multiple tokens', async function () {",
          "90:       await this.underlying.approve(this.token.address, firstTokenId, { from: initialHolder });",
          "91:       await this.underlying.approve(this.token.address, secondTokenId, { from: initialHolder });",
          "93:       const { tx } = await this.token.depositFor(initialHolder, [firstTokenId, secondTokenId], { from: initialHolder });",
          "95:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "96:         from: initialHolder,",
          "97:         to: this.token.address,",
          "98:         tokenId: firstTokenId,",
          "99:       });",
          "100:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "101:         from: constants.ZERO_ADDRESS,",
          "102:         to: initialHolder,",
          "103:         tokenId: firstTokenId,",
          "104:       });",
          "105:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "106:         from: initialHolder,",
          "107:         to: this.token.address,",
          "108:         tokenId: secondTokenId,",
          "109:       });",
          "110:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "111:         from: constants.ZERO_ADDRESS,",
          "112:         to: initialHolder,",
          "113:         tokenId: secondTokenId,",
          "114:       });",
          "115:     });",
          "117:     it('reverts with missing approval', async function () {",
          "118:       await expectRevert(",
          "119:         this.token.depositFor(initialHolder, [firstTokenId], { from: initialHolder }),",
          "120:         'ERC721: caller is not token owner or approved',",
          "121:       );",
          "122:     });",
          "123:   });",
          "125:   describe('withdrawTo', function () {",
          "126:     beforeEach(async function () {",
          "127:       await this.underlying.approve(this.token.address, firstTokenId, { from: initialHolder });",
          "128:       await this.token.depositFor(initialHolder, [firstTokenId], { from: initialHolder });",
          "129:     });",
          "131:     it('works for an owner', async function () {",
          "132:       const { tx } = await this.token.withdrawTo(initialHolder, [firstTokenId], { from: initialHolder });",
          "134:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "135:         from: this.token.address,",
          "136:         to: initialHolder,",
          "137:         tokenId: firstTokenId,",
          "138:       });",
          "139:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "140:         from: initialHolder,",
          "141:         to: constants.ZERO_ADDRESS,",
          "142:         tokenId: firstTokenId,",
          "143:       });",
          "144:     });",
          "146:     it('works for an approved', async function () {",
          "147:       await this.token.approve(approvedAccount, firstTokenId, { from: initialHolder });",
          "149:       const { tx } = await this.token.withdrawTo(initialHolder, [firstTokenId], { from: approvedAccount });",
          "151:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "152:         from: this.token.address,",
          "153:         to: initialHolder,",
          "154:         tokenId: firstTokenId,",
          "155:       });",
          "156:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "157:         from: initialHolder,",
          "158:         to: constants.ZERO_ADDRESS,",
          "159:         tokenId: firstTokenId,",
          "160:       });",
          "161:     });",
          "163:     it('works for an approved for all', async function () {",
          "164:       await this.token.setApprovalForAll(approvedAccount, true, { from: initialHolder });",
          "166:       const { tx } = await this.token.withdrawTo(initialHolder, [firstTokenId], { from: approvedAccount });",
          "168:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "169:         from: this.token.address,",
          "170:         to: initialHolder,",
          "171:         tokenId: firstTokenId,",
          "172:       });",
          "173:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "174:         from: initialHolder,",
          "175:         to: constants.ZERO_ADDRESS,",
          "176:         tokenId: firstTokenId,",
          "177:       });",
          "178:     });",
          "180:     it(\"doesn't work for a non-owner nor approved\", async function () {",
          "181:       await expectRevert(",
          "182:         this.token.withdrawTo(initialHolder, [firstTokenId], { from: anotherAccount }),",
          "183:         'ERC721Wrapper: caller is not token owner or approved',",
          "184:       );",
          "185:     });",
          "187:     it('works with multiple tokens', async function () {",
          "188:       await this.underlying.approve(this.token.address, secondTokenId, { from: initialHolder });",
          "189:       await this.token.depositFor(initialHolder, [secondTokenId], { from: initialHolder });",
          "191:       const { tx } = await this.token.withdrawTo(initialHolder, [firstTokenId, secondTokenId], { from: initialHolder });",
          "193:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "194:         from: this.token.address,",
          "195:         to: initialHolder,",
          "196:         tokenId: firstTokenId,",
          "197:       });",
          "198:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "199:         from: this.token.address,",
          "200:         to: initialHolder,",
          "201:         tokenId: secondTokenId,",
          "202:       });",
          "203:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "204:         from: initialHolder,",
          "205:         to: constants.ZERO_ADDRESS,",
          "206:         tokenId: firstTokenId,",
          "207:       });",
          "208:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "209:         from: initialHolder,",
          "210:         to: constants.ZERO_ADDRESS,",
          "211:         tokenId: secondTokenId,",
          "212:       });",
          "213:     });",
          "215:     it('works to another account', async function () {",
          "216:       const { tx } = await this.token.withdrawTo(anotherAccount, [firstTokenId], { from: initialHolder });",
          "218:       await expectEvent.inTransaction(tx, this.underlying, 'Transfer', {",
          "219:         from: this.token.address,",
          "220:         to: anotherAccount,",
          "221:         tokenId: firstTokenId,",
          "222:       });",
          "223:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "224:         from: initialHolder,",
          "225:         to: constants.ZERO_ADDRESS,",
          "226:         tokenId: firstTokenId,",
          "227:       });",
          "228:     });",
          "229:   });",
          "231:   describe('onERC721Received', function () {",
          "232:     it('only allows calls from underlying', async function () {",
          "233:       await expectRevert(",
          "234:         this.token.onERC721Received(",
          "235:           initialHolder,",
          "236:           this.token.address,",
          "237:           firstTokenId,",
          "238:           anotherAccount, // Correct data",
          "239:           { from: anotherAccount },",
          "240:         ),",
          "241:         'ERC721Wrapper: caller is not underlying',",
          "242:       );",
          "243:     });",
          "245:     it('mints a token to from', async function () {",
          "246:       const { tx } = await this.underlying.safeTransferFrom(initialHolder, this.token.address, firstTokenId, {",
          "247:         from: initialHolder,",
          "248:       });",
          "250:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "251:         from: constants.ZERO_ADDRESS,",
          "252:         to: initialHolder,",
          "253:         tokenId: firstTokenId,",
          "254:       });",
          "255:     });",
          "256:   });",
          "258:   describe('_recover', function () {",
          "259:     it('works if there is something to recover', async function () {",
          "261:       await this.underlying.transferFrom(initialHolder, this.token.address, firstTokenId, { from: initialHolder });",
          "263:       const { tx } = await this.token.$_recover(anotherAccount, firstTokenId);",
          "265:       await expectEvent.inTransaction(tx, this.token, 'Transfer', {",
          "266:         from: constants.ZERO_ADDRESS,",
          "267:         to: anotherAccount,",
          "268:         tokenId: firstTokenId,",
          "269:       });",
          "270:     });",
          "272:     it('reverts if there is nothing to recover', async function () {",
          "273:       await expectRevert(",
          "274:         this.token.$_recover(initialHolder, firstTokenId),",
          "275:         'ERC721Wrapper: wrapper is not token owner',",
          "276:       );",
          "277:     });",
          "278:   });",
          "280:   describe('ERC712 behavior', function () {",
          "281:     shouldBehaveLikeERC721('ERC721', ...accounts);",
          "282:   });",
          "283: });",
          "",
          "---------------"
        ],
        "test/token/ERC721/presets/ERC721PresetMinterPauserAutoId.test.js||test/token/ERC721/presets/ERC721PresetMinterPauserAutoId.test.js": [
          "File: test/token/ERC721/presets/ERC721PresetMinterPauserAutoId.test.js -> test/token/ERC721/presets/ERC721PresetMinterPauserAutoId.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS } = constants;",
          "3: const { shouldSupportInterfaces } = require('../../../utils/introspection/SupportsInterface.behavior');",
          "5: const { expect } = require('chai');",
          "7: const ERC721PresetMinterPauserAutoId = artifacts.require('ERC721PresetMinterPauserAutoId');",
          "9: contract('ERC721PresetMinterPauserAutoId', function (accounts) {",
          "10:   const [deployer, other] = accounts;",
          "12:   const name = 'MinterAutoIDToken';",
          "13:   const symbol = 'MAIT';",
          "14:   const baseURI = 'my.app/';",
          "16:   const DEFAULT_ADMIN_ROLE = '0x0000000000000000000000000000000000000000000000000000000000000000';",
          "17:   const MINTER_ROLE = web3.utils.soliditySha3('MINTER_ROLE');",
          "19:   beforeEach(async function () {",
          "20:     this.token = await ERC721PresetMinterPauserAutoId.new(name, symbol, baseURI, { from: deployer });",
          "21:   });",
          "23:   shouldSupportInterfaces(['ERC721', 'ERC721Enumerable', 'AccessControl', 'AccessControlEnumerable']);",
          "25:   it('token has correct name', async function () {",
          "26:     expect(await this.token.name()).to.equal(name);",
          "27:   });",
          "29:   it('token has correct symbol', async function () {",
          "30:     expect(await this.token.symbol()).to.equal(symbol);",
          "31:   });",
          "33:   it('deployer has the default admin role', async function () {",
          "34:     expect(await this.token.getRoleMemberCount(DEFAULT_ADMIN_ROLE)).to.be.bignumber.equal('1');",
          "35:     expect(await this.token.getRoleMember(DEFAULT_ADMIN_ROLE, 0)).to.equal(deployer);",
          "36:   });",
          "38:   it('deployer has the minter role', async function () {",
          "39:     expect(await this.token.getRoleMemberCount(MINTER_ROLE)).to.be.bignumber.equal('1');",
          "40:     expect(await this.token.getRoleMember(MINTER_ROLE, 0)).to.equal(deployer);",
          "41:   });",
          "43:   it('minter role admin is the default admin', async function () {",
          "44:     expect(await this.token.getRoleAdmin(MINTER_ROLE)).to.equal(DEFAULT_ADMIN_ROLE);",
          "45:   });",
          "47:   describe('minting', function () {",
          "48:     it('deployer can mint tokens', async function () {",
          "49:       const tokenId = new BN('0');",
          "51:       const receipt = await this.token.mint(other, { from: deployer });",
          "52:       expectEvent(receipt, 'Transfer', { from: ZERO_ADDRESS, to: other, tokenId });",
          "54:       expect(await this.token.balanceOf(other)).to.be.bignumber.equal('1');",
          "55:       expect(await this.token.ownerOf(tokenId)).to.equal(other);",
          "57:       expect(await this.token.tokenURI(tokenId)).to.equal(baseURI + tokenId);",
          "58:     });",
          "60:     it('other accounts cannot mint tokens', async function () {",
          "61:       await expectRevert(",
          "62:         this.token.mint(other, { from: other }),",
          "63:         'ERC721PresetMinterPauserAutoId: must have minter role to mint',",
          "64:       );",
          "65:     });",
          "66:   });",
          "68:   describe('pausing', function () {",
          "69:     it('deployer can pause', async function () {",
          "70:       const receipt = await this.token.pause({ from: deployer });",
          "71:       expectEvent(receipt, 'Paused', { account: deployer });",
          "73:       expect(await this.token.paused()).to.equal(true);",
          "74:     });",
          "76:     it('deployer can unpause', async function () {",
          "77:       await this.token.pause({ from: deployer });",
          "79:       const receipt = await this.token.unpause({ from: deployer });",
          "80:       expectEvent(receipt, 'Unpaused', { account: deployer });",
          "82:       expect(await this.token.paused()).to.equal(false);",
          "83:     });",
          "85:     it('cannot mint while paused', async function () {",
          "86:       await this.token.pause({ from: deployer });",
          "88:       await expectRevert(this.token.mint(other, { from: deployer }), 'ERC721Pausable: token transfer while paused');",
          "89:     });",
          "91:     it('other accounts cannot pause', async function () {",
          "92:       await expectRevert(",
          "93:         this.token.pause({ from: other }),",
          "94:         'ERC721PresetMinterPauserAutoId: must have pauser role to pause',",
          "95:       );",
          "96:     });",
          "98:     it('other accounts cannot unpause', async function () {",
          "99:       await this.token.pause({ from: deployer });",
          "101:       await expectRevert(",
          "102:         this.token.unpause({ from: other }),",
          "103:         'ERC721PresetMinterPauserAutoId: must have pauser role to unpause',",
          "104:       );",
          "105:     });",
          "106:   });",
          "108:   describe('burning', function () {",
          "109:     it('holders can burn their tokens', async function () {",
          "110:       const tokenId = new BN('0');",
          "112:       await this.token.mint(other, { from: deployer });",
          "114:       const receipt = await this.token.burn(tokenId, { from: other });",
          "116:       expectEvent(receipt, 'Transfer', { from: other, to: ZERO_ADDRESS, tokenId });",
          "118:       expect(await this.token.balanceOf(other)).to.be.bignumber.equal('0');",
          "119:       expect(await this.token.totalSupply()).to.be.bignumber.equal('0');",
          "120:     });",
          "121:   });",
          "122: });",
          "",
          "---------------"
        ],
        "test/token/ERC721/utils/ERC721Holder.test.js||test/token/ERC721/utils/ERC721Holder.test.js": [
          "File: test/token/ERC721/utils/ERC721Holder.test.js -> test/token/ERC721/utils/ERC721Holder.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expect } = require('chai');",
          "3: const ERC721Holder = artifacts.require('ERC721Holder');",
          "4: const ERC721 = artifacts.require('$ERC721');",
          "6: contract('ERC721Holder', function (accounts) {",
          "7:   const [owner] = accounts;",
          "9:   const name = 'Non Fungible Token';",
          "10:   const symbol = 'NFT';",
          "11:   const tokenId = web3.utils.toBN(1);",
          "13:   it('receives an ERC721 token', async function () {",
          "14:     const token = await ERC721.new(name, symbol);",
          "15:     await token.$_mint(owner, tokenId);",
          "17:     const receiver = await ERC721Holder.new();",
          "18:     await token.safeTransferFrom(owner, receiver.address, tokenId, { from: owner });",
          "20:     expect(await token.ownerOf(tokenId)).to.be.equal(receiver.address);",
          "21:   });",
          "22: });",
          "",
          "---------------"
        ],
        "test/token/ERC777/ERC777.behavior.js||test/token/ERC777/ERC777.behavior.js": [
          "File: test/token/ERC777/ERC777.behavior.js -> test/token/ERC777/ERC777.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS } = constants;",
          "4: const { expect } = require('chai');",
          "6: const ERC777SenderRecipientMock = artifacts.require('ERC777SenderRecipientMock');",
          "8: function shouldBehaveLikeERC777DirectSendBurn(holder, recipient, data) {",
          "9:   shouldBehaveLikeERC777DirectSend(holder, recipient, data);",
          "10:   shouldBehaveLikeERC777DirectBurn(holder, data);",
          "11: }",
          "13: function shouldBehaveLikeERC777OperatorSendBurn(holder, recipient, operator, data, operatorData) {",
          "14:   shouldBehaveLikeERC777OperatorSend(holder, recipient, operator, data, operatorData);",
          "15:   shouldBehaveLikeERC777OperatorBurn(holder, operator, data, operatorData);",
          "16: }",
          "18: function shouldBehaveLikeERC777UnauthorizedOperatorSendBurn(holder, recipient, operator, data, operatorData) {",
          "19:   shouldBehaveLikeERC777UnauthorizedOperatorSend(holder, recipient, operator, data, operatorData);",
          "20:   shouldBehaveLikeERC777UnauthorizedOperatorBurn(holder, operator, data, operatorData);",
          "21: }",
          "23: function shouldBehaveLikeERC777DirectSend(holder, recipient, data) {",
          "24:   describe('direct send', function () {",
          "25:     context('when the sender has tokens', function () {",
          "26:       shouldDirectSendTokens(holder, recipient, new BN('0'), data);",
          "27:       shouldDirectSendTokens(holder, recipient, new BN('1'), data);",
          "29:       it('reverts when sending more than the balance', async function () {",
          "30:         const balance = await this.token.balanceOf(holder);",
          "31:         await expectRevert.unspecified(this.token.send(recipient, balance.addn(1), data, { from: holder }));",
          "32:       });",
          "34:       it('reverts when sending to the zero address', async function () {",
          "35:         await expectRevert.unspecified(this.token.send(ZERO_ADDRESS, new BN('1'), data, { from: holder }));",
          "36:       });",
          "37:     });",
          "39:     context('when the sender has no tokens', function () {",
          "40:       removeBalance(holder);",
          "42:       shouldDirectSendTokens(holder, recipient, new BN('0'), data);",
          "44:       it('reverts when sending a non-zero amount', async function () {",
          "45:         await expectRevert.unspecified(this.token.send(recipient, new BN('1'), data, { from: holder }));",
          "46:       });",
          "47:     });",
          "48:   });",
          "49: }",
          "51: function shouldBehaveLikeERC777OperatorSend(holder, recipient, operator, data, operatorData) {",
          "52:   describe('operator send', function () {",
          "53:     context('when the sender has tokens', async function () {",
          "54:       shouldOperatorSendTokens(holder, operator, recipient, new BN('0'), data, operatorData);",
          "55:       shouldOperatorSendTokens(holder, operator, recipient, new BN('1'), data, operatorData);",
          "57:       it('reverts when sending more than the balance', async function () {",
          "58:         const balance = await this.token.balanceOf(holder);",
          "59:         await expectRevert.unspecified(",
          "60:           this.token.operatorSend(holder, recipient, balance.addn(1), data, operatorData, { from: operator }),",
          "61:         );",
          "62:       });",
          "64:       it('reverts when sending to the zero address', async function () {",
          "65:         await expectRevert.unspecified(",
          "66:           this.token.operatorSend(holder, ZERO_ADDRESS, new BN('1'), data, operatorData, { from: operator }),",
          "67:         );",
          "68:       });",
          "69:     });",
          "71:     context('when the sender has no tokens', function () {",
          "72:       removeBalance(holder);",
          "74:       shouldOperatorSendTokens(holder, operator, recipient, new BN('0'), data, operatorData);",
          "76:       it('reverts when sending a non-zero amount', async function () {",
          "77:         await expectRevert.unspecified(",
          "78:           this.token.operatorSend(holder, recipient, new BN('1'), data, operatorData, { from: operator }),",
          "79:         );",
          "80:       });",
          "82:       it('reverts when sending from the zero address', async function () {",
          "84:         await expectRevert.unspecified(",
          "85:           this.token.operatorSend(ZERO_ADDRESS, recipient, new BN('0'), data, operatorData, { from: operator }),",
          "86:         );",
          "87:       });",
          "88:     });",
          "89:   });",
          "90: }",
          "92: function shouldBehaveLikeERC777UnauthorizedOperatorSend(holder, recipient, operator, data, operatorData) {",
          "93:   describe('operator send', function () {",
          "94:     it('reverts', async function () {",
          "95:       await expectRevert.unspecified(this.token.operatorSend(holder, recipient, new BN('0'), data, operatorData));",
          "96:     });",
          "97:   });",
          "98: }",
          "100: function shouldBehaveLikeERC777DirectBurn(holder, data) {",
          "101:   describe('direct burn', function () {",
          "102:     context('when the sender has tokens', function () {",
          "103:       shouldDirectBurnTokens(holder, new BN('0'), data);",
          "104:       shouldDirectBurnTokens(holder, new BN('1'), data);",
          "106:       it('reverts when burning more than the balance', async function () {",
          "107:         const balance = await this.token.balanceOf(holder);",
          "108:         await expectRevert.unspecified(this.token.burn(balance.addn(1), data, { from: holder }));",
          "109:       });",
          "110:     });",
          "112:     context('when the sender has no tokens', function () {",
          "113:       removeBalance(holder);",
          "115:       shouldDirectBurnTokens(holder, new BN('0'), data);",
          "117:       it('reverts when burning a non-zero amount', async function () {",
          "118:         await expectRevert.unspecified(this.token.burn(new BN('1'), data, { from: holder }));",
          "119:       });",
          "120:     });",
          "121:   });",
          "122: }",
          "124: function shouldBehaveLikeERC777OperatorBurn(holder, operator, data, operatorData) {",
          "125:   describe('operator burn', function () {",
          "126:     context('when the sender has tokens', async function () {",
          "127:       shouldOperatorBurnTokens(holder, operator, new BN('0'), data, operatorData);",
          "128:       shouldOperatorBurnTokens(holder, operator, new BN('1'), data, operatorData);",
          "130:       it('reverts when burning more than the balance', async function () {",
          "131:         const balance = await this.token.balanceOf(holder);",
          "132:         await expectRevert.unspecified(",
          "133:           this.token.operatorBurn(holder, balance.addn(1), data, operatorData, { from: operator }),",
          "134:         );",
          "135:       });",
          "136:     });",
          "138:     context('when the sender has no tokens', function () {",
          "139:       removeBalance(holder);",
          "141:       shouldOperatorBurnTokens(holder, operator, new BN('0'), data, operatorData);",
          "143:       it('reverts when burning a non-zero amount', async function () {",
          "144:         await expectRevert.unspecified(",
          "145:           this.token.operatorBurn(holder, new BN('1'), data, operatorData, { from: operator }),",
          "146:         );",
          "147:       });",
          "149:       it('reverts when burning from the zero address', async function () {",
          "151:         await expectRevert.unspecified(",
          "152:           this.token.operatorBurn(ZERO_ADDRESS, new BN('0'), data, operatorData, { from: operator }),",
          "153:         );",
          "154:       });",
          "155:     });",
          "156:   });",
          "157: }",
          "159: function shouldBehaveLikeERC777UnauthorizedOperatorBurn(holder, operator, data, operatorData) {",
          "160:   describe('operator burn', function () {",
          "161:     it('reverts', async function () {",
          "162:       await expectRevert.unspecified(this.token.operatorBurn(holder, new BN('0'), data, operatorData));",
          "163:     });",
          "164:   });",
          "165: }",
          "167: function shouldDirectSendTokens(from, to, amount, data) {",
          "168:   shouldSendTokens(from, null, to, amount, data, null);",
          "169: }",
          "171: function shouldOperatorSendTokens(from, operator, to, amount, data, operatorData) {",
          "172:   shouldSendTokens(from, operator, to, amount, data, operatorData);",
          "173: }",
          "175: function shouldSendTokens(from, operator, to, amount, data, operatorData) {",
          "176:   const operatorCall = operator !== null;",
          "178:   it(`${operatorCall ? 'operator ' : ''}can send an amount of ${amount}`, async function () {",
          "179:     const initialTotalSupply = await this.token.totalSupply();",
          "180:     const initialFromBalance = await this.token.balanceOf(from);",
          "181:     const initialToBalance = await this.token.balanceOf(to);",
          "183:     let receipt;",
          "184:     if (!operatorCall) {",
          "185:       receipt = await this.token.send(to, amount, data, { from });",
          "186:       expectEvent(receipt, 'Sent', {",
          "187:         operator: from,",
          "188:         from,",
          "189:         to,",
          "190:         amount,",
          "191:         data,",
          "192:         operatorData: null,",
          "193:       });",
          "194:     } else {",
          "195:       receipt = await this.token.operatorSend(from, to, amount, data, operatorData, { from: operator });",
          "196:       expectEvent(receipt, 'Sent', {",
          "197:         operator,",
          "198:         from,",
          "199:         to,",
          "200:         amount,",
          "201:         data,",
          "202:         operatorData,",
          "203:       });",
          "204:     }",
          "206:     expectEvent(receipt, 'Transfer', {",
          "207:       from,",
          "208:       to,",
          "209:       value: amount,",
          "210:     });",
          "212:     const finalTotalSupply = await this.token.totalSupply();",
          "213:     const finalFromBalance = await this.token.balanceOf(from);",
          "214:     const finalToBalance = await this.token.balanceOf(to);",
          "216:     expect(finalTotalSupply).to.be.bignumber.equal(initialTotalSupply);",
          "217:     expect(finalToBalance.sub(initialToBalance)).to.be.bignumber.equal(amount);",
          "218:     expect(finalFromBalance.sub(initialFromBalance)).to.be.bignumber.equal(amount.neg());",
          "219:   });",
          "220: }",
          "222: function shouldDirectBurnTokens(from, amount, data) {",
          "223:   shouldBurnTokens(from, null, amount, data, null);",
          "224: }",
          "226: function shouldOperatorBurnTokens(from, operator, amount, data, operatorData) {",
          "227:   shouldBurnTokens(from, operator, amount, data, operatorData);",
          "228: }",
          "230: function shouldBurnTokens(from, operator, amount, data, operatorData) {",
          "231:   const operatorCall = operator !== null;",
          "233:   it(`${operatorCall ? 'operator ' : ''}can burn an amount of ${amount}`, async function () {",
          "234:     const initialTotalSupply = await this.token.totalSupply();",
          "235:     const initialFromBalance = await this.token.balanceOf(from);",
          "237:     let receipt;",
          "238:     if (!operatorCall) {",
          "239:       receipt = await this.token.burn(amount, data, { from });",
          "240:       expectEvent(receipt, 'Burned', {",
          "241:         operator: from,",
          "242:         from,",
          "243:         amount,",
          "244:         data,",
          "245:         operatorData: null,",
          "246:       });",
          "247:     } else {",
          "248:       receipt = await this.token.operatorBurn(from, amount, data, operatorData, { from: operator });",
          "249:       expectEvent(receipt, 'Burned', {",
          "250:         operator,",
          "251:         from,",
          "252:         amount,",
          "253:         data,",
          "254:         operatorData,",
          "255:       });",
          "256:     }",
          "258:     expectEvent(receipt, 'Transfer', {",
          "259:       from,",
          "260:       to: ZERO_ADDRESS,",
          "261:       value: amount,",
          "262:     });",
          "264:     const finalTotalSupply = await this.token.totalSupply();",
          "265:     const finalFromBalance = await this.token.balanceOf(from);",
          "267:     expect(finalTotalSupply.sub(initialTotalSupply)).to.be.bignumber.equal(amount.neg());",
          "268:     expect(finalFromBalance.sub(initialFromBalance)).to.be.bignumber.equal(amount.neg());",
          "269:   });",
          "270: }",
          "272: function shouldBehaveLikeERC777InternalMint(recipient, operator, amount, data, operatorData) {",
          "273:   shouldInternalMintTokens(operator, recipient, new BN('0'), data, operatorData);",
          "274:   shouldInternalMintTokens(operator, recipient, amount, data, operatorData);",
          "276:   it('reverts when minting tokens for the zero address', async function () {",
          "277:     await expectRevert.unspecified(",
          "278:       this.token.$_mint(ZERO_ADDRESS, amount, data, operatorData, true, { from: operator }),",
          "279:     );",
          "280:   });",
          "281: }",
          "283: function shouldInternalMintTokens(operator, to, amount, data, operatorData) {",
          "284:   it(`can (internal) mint an amount of ${amount}`, async function () {",
          "285:     const initialTotalSupply = await this.token.totalSupply();",
          "286:     const initialToBalance = await this.token.balanceOf(to);",
          "288:     const receipt = await this.token.$_mint(to, amount, data, operatorData, true, { from: operator });",
          "290:     expectEvent(receipt, 'Minted', {",
          "291:       operator,",
          "292:       to,",
          "293:       amount,",
          "294:       data,",
          "295:       operatorData,",
          "296:     });",
          "298:     expectEvent(receipt, 'Transfer', {",
          "299:       from: ZERO_ADDRESS,",
          "300:       to,",
          "301:       value: amount,",
          "302:     });",
          "304:     const finalTotalSupply = await this.token.totalSupply();",
          "305:     const finalToBalance = await this.token.balanceOf(to);",
          "307:     expect(finalTotalSupply.sub(initialTotalSupply)).to.be.bignumber.equal(amount);",
          "308:     expect(finalToBalance.sub(initialToBalance)).to.be.bignumber.equal(amount);",
          "309:   });",
          "310: }",
          "312: function shouldBehaveLikeERC777SendBurnMintInternalWithReceiveHook(operator, amount, data, operatorData) {",
          "313:   context('when TokensRecipient reverts', function () {",
          "314:     beforeEach(async function () {",
          "315:       await this.tokensRecipientImplementer.setShouldRevertReceive(true);",
          "316:     });",
          "318:     it('send reverts', async function () {",
          "319:       await expectRevert.unspecified(sendFromHolder(this.token, this.sender, this.recipient, amount, data));",
          "320:     });",
          "322:     it('operatorSend reverts', async function () {",
          "323:       await expectRevert.unspecified(",
          "324:         this.token.operatorSend(this.sender, this.recipient, amount, data, operatorData, { from: operator }),",
          "325:       );",
          "326:     });",
          "328:     it('mint (internal) reverts', async function () {",
          "329:       await expectRevert.unspecified(",
          "330:         this.token.$_mint(this.recipient, amount, data, operatorData, true, { from: operator }),",
          "331:       );",
          "332:     });",
          "333:   });",
          "335:   context('when TokensRecipient does not revert', function () {",
          "336:     beforeEach(async function () {",
          "337:       await this.tokensRecipientImplementer.setShouldRevertSend(false);",
          "338:     });",
          "340:     it('TokensRecipient receives send data and is called after state mutation', async function () {",
          "341:       const { tx } = await sendFromHolder(this.token, this.sender, this.recipient, amount, data);",
          "343:       const postSenderBalance = await this.token.balanceOf(this.sender);",
          "344:       const postRecipientBalance = await this.token.balanceOf(this.recipient);",
          "346:       await assertTokensReceivedCalled(",
          "347:         this.token,",
          "348:         tx,",
          "349:         this.sender,",
          "350:         this.sender,",
          "351:         this.recipient,",
          "352:         amount,",
          "353:         data,",
          "354:         null,",
          "355:         postSenderBalance,",
          "356:         postRecipientBalance,",
          "357:       );",
          "358:     });",
          "360:     it('TokensRecipient receives operatorSend data and is called after state mutation', async function () {",
          "361:       const { tx } = await this.token.operatorSend(this.sender, this.recipient, amount, data, operatorData, {",
          "362:         from: operator,",
          "363:       });",
          "365:       const postSenderBalance = await this.token.balanceOf(this.sender);",
          "366:       const postRecipientBalance = await this.token.balanceOf(this.recipient);",
          "368:       await assertTokensReceivedCalled(",
          "369:         this.token,",
          "370:         tx,",
          "371:         operator,",
          "372:         this.sender,",
          "373:         this.recipient,",
          "374:         amount,",
          "375:         data,",
          "376:         operatorData,",
          "377:         postSenderBalance,",
          "378:         postRecipientBalance,",
          "379:       );",
          "380:     });",
          "382:     it('TokensRecipient receives mint (internal) data and is called after state mutation', async function () {",
          "383:       const { tx } = await this.token.$_mint(this.recipient, amount, data, operatorData, true, { from: operator });",
          "385:       const postRecipientBalance = await this.token.balanceOf(this.recipient);",
          "387:       await assertTokensReceivedCalled(",
          "388:         this.token,",
          "389:         tx,",
          "390:         operator,",
          "391:         ZERO_ADDRESS,",
          "392:         this.recipient,",
          "393:         amount,",
          "394:         data,",
          "395:         operatorData,",
          "396:         new BN('0'),",
          "397:         postRecipientBalance,",
          "398:       );",
          "399:     });",
          "400:   });",
          "401: }",
          "403: function shouldBehaveLikeERC777SendBurnWithSendHook(operator, amount, data, operatorData) {",
          "404:   context('when TokensSender reverts', function () {",
          "405:     beforeEach(async function () {",
          "406:       await this.tokensSenderImplementer.setShouldRevertSend(true);",
          "407:     });",
          "409:     it('send reverts', async function () {",
          "410:       await expectRevert.unspecified(sendFromHolder(this.token, this.sender, this.recipient, amount, data));",
          "411:     });",
          "413:     it('operatorSend reverts', async function () {",
          "414:       await expectRevert.unspecified(",
          "415:         this.token.operatorSend(this.sender, this.recipient, amount, data, operatorData, { from: operator }),",
          "416:       );",
          "417:     });",
          "419:     it('burn reverts', async function () {",
          "420:       await expectRevert.unspecified(burnFromHolder(this.token, this.sender, amount, data));",
          "421:     });",
          "423:     it('operatorBurn reverts', async function () {",
          "424:       await expectRevert.unspecified(",
          "425:         this.token.operatorBurn(this.sender, amount, data, operatorData, { from: operator }),",
          "426:       );",
          "427:     });",
          "428:   });",
          "430:   context('when TokensSender does not revert', function () {",
          "431:     beforeEach(async function () {",
          "432:       await this.tokensSenderImplementer.setShouldRevertSend(false);",
          "433:     });",
          "435:     it('TokensSender receives send data and is called before state mutation', async function () {",
          "436:       const preSenderBalance = await this.token.balanceOf(this.sender);",
          "437:       const preRecipientBalance = await this.token.balanceOf(this.recipient);",
          "439:       const { tx } = await sendFromHolder(this.token, this.sender, this.recipient, amount, data);",
          "441:       await assertTokensToSendCalled(",
          "442:         this.token,",
          "443:         tx,",
          "444:         this.sender,",
          "445:         this.sender,",
          "446:         this.recipient,",
          "447:         amount,",
          "448:         data,",
          "449:         null,",
          "450:         preSenderBalance,",
          "451:         preRecipientBalance,",
          "452:       );",
          "453:     });",
          "455:     it('TokensSender receives operatorSend data and is called before state mutation', async function () {",
          "456:       const preSenderBalance = await this.token.balanceOf(this.sender);",
          "457:       const preRecipientBalance = await this.token.balanceOf(this.recipient);",
          "459:       const { tx } = await this.token.operatorSend(this.sender, this.recipient, amount, data, operatorData, {",
          "460:         from: operator,",
          "461:       });",
          "463:       await assertTokensToSendCalled(",
          "464:         this.token,",
          "465:         tx,",
          "466:         operator,",
          "467:         this.sender,",
          "468:         this.recipient,",
          "469:         amount,",
          "470:         data,",
          "471:         operatorData,",
          "472:         preSenderBalance,",
          "473:         preRecipientBalance,",
          "474:       );",
          "475:     });",
          "477:     it('TokensSender receives burn data and is called before state mutation', async function () {",
          "478:       const preSenderBalance = await this.token.balanceOf(this.sender);",
          "480:       const { tx } = await burnFromHolder(this.token, this.sender, amount, data, { from: this.sender });",
          "482:       await assertTokensToSendCalled(",
          "483:         this.token,",
          "484:         tx,",
          "485:         this.sender,",
          "486:         this.sender,",
          "487:         ZERO_ADDRESS,",
          "488:         amount,",
          "489:         data,",
          "490:         null,",
          "491:         preSenderBalance,",
          "492:       );",
          "493:     });",
          "495:     it('TokensSender receives operatorBurn data and is called before state mutation', async function () {",
          "496:       const preSenderBalance = await this.token.balanceOf(this.sender);",
          "498:       const { tx } = await this.token.operatorBurn(this.sender, amount, data, operatorData, { from: operator });",
          "500:       await assertTokensToSendCalled(",
          "501:         this.token,",
          "502:         tx,",
          "503:         operator,",
          "504:         this.sender,",
          "505:         ZERO_ADDRESS,",
          "506:         amount,",
          "507:         data,",
          "508:         operatorData,",
          "509:         preSenderBalance,",
          "510:       );",
          "511:     });",
          "512:   });",
          "513: }",
          "515: function removeBalance(holder) {",
          "516:   beforeEach(async function () {",
          "517:     await this.token.burn(await this.token.balanceOf(holder), '0x', { from: holder });",
          "518:     expect(await this.token.balanceOf(holder)).to.be.bignumber.equal('0');",
          "519:   });",
          "520: }",
          "522: async function assertTokensReceivedCalled(",
          "523:   token,",
          "524:   txHash,",
          "525:   operator,",
          "526:   from,",
          "527:   to,",
          "528:   amount,",
          "529:   data,",
          "530:   operatorData,",
          "531:   fromBalance,",
          "532:   toBalance = '0',",
          "533: ) {",
          "534:   await expectEvent.inTransaction(txHash, ERC777SenderRecipientMock, 'TokensReceivedCalled', {",
          "535:     operator,",
          "536:     from,",
          "537:     to,",
          "538:     amount,",
          "539:     data,",
          "540:     operatorData,",
          "541:     token: token.address,",
          "542:     fromBalance,",
          "543:     toBalance,",
          "544:   });",
          "545: }",
          "547: async function assertTokensToSendCalled(",
          "548:   token,",
          "549:   txHash,",
          "550:   operator,",
          "551:   from,",
          "552:   to,",
          "553:   amount,",
          "554:   data,",
          "555:   operatorData,",
          "556:   fromBalance,",
          "557:   toBalance = '0',",
          "558: ) {",
          "559:   await expectEvent.inTransaction(txHash, ERC777SenderRecipientMock, 'TokensToSendCalled', {",
          "560:     operator,",
          "561:     from,",
          "562:     to,",
          "563:     amount,",
          "564:     data,",
          "565:     operatorData,",
          "566:     token: token.address,",
          "567:     fromBalance,",
          "568:     toBalance,",
          "569:   });",
          "570: }",
          "572: async function sendFromHolder(token, holder, to, amount, data) {",
          "573:   if ((await web3.eth.getCode(holder)).length <= '0x'.length) {",
          "574:     return token.send(to, amount, data, { from: holder });",
          "575:   } else {",
          "577:     return (await ERC777SenderRecipientMock.at(holder)).send(token.address, to, amount, data);",
          "578:   }",
          "579: }",
          "581: async function burnFromHolder(token, holder, amount, data) {",
          "582:   if ((await web3.eth.getCode(holder)).length <= '0x'.length) {",
          "583:     return token.burn(amount, data, { from: holder });",
          "584:   } else {",
          "586:     return (await ERC777SenderRecipientMock.at(holder)).burn(token.address, amount, data);",
          "587:   }",
          "588: }",
          "590: module.exports = {",
          "591:   shouldBehaveLikeERC777DirectSendBurn,",
          "592:   shouldBehaveLikeERC777OperatorSendBurn,",
          "593:   shouldBehaveLikeERC777UnauthorizedOperatorSendBurn,",
          "594:   shouldBehaveLikeERC777InternalMint,",
          "595:   shouldBehaveLikeERC777SendBurnMintInternalWithReceiveHook,",
          "596:   shouldBehaveLikeERC777SendBurnWithSendHook,",
          "597: };",
          "",
          "---------------"
        ],
        "test/token/ERC777/ERC777.test.js||test/token/ERC777/ERC777.test.js": [
          "File: test/token/ERC777/ERC777.test.js -> test/token/ERC777/ERC777.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectEvent, expectRevert, singletons } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS } = constants;",
          "4: const { expect } = require('chai');",
          "6: const {",
          "7:   shouldBehaveLikeERC777DirectSendBurn,",
          "8:   shouldBehaveLikeERC777OperatorSendBurn,",
          "9:   shouldBehaveLikeERC777UnauthorizedOperatorSendBurn,",
          "10:   shouldBehaveLikeERC777InternalMint,",
          "11:   shouldBehaveLikeERC777SendBurnMintInternalWithReceiveHook,",
          "12:   shouldBehaveLikeERC777SendBurnWithSendHook,",
          "13: } = require('./ERC777.behavior');",
          "15: const { shouldBehaveLikeERC20, shouldBehaveLikeERC20Approve } = require('../ERC20/ERC20.behavior');",
          "17: const ERC777 = artifacts.require('$ERC777Mock');",
          "18: const ERC777SenderRecipientMock = artifacts.require('$ERC777SenderRecipientMock');",
          "20: contract('ERC777', function (accounts) {",
          "21:   const [registryFunder, holder, defaultOperatorA, defaultOperatorB, newOperator, anyone] = accounts;",
          "23:   const initialSupply = new BN('10000');",
          "24:   const name = 'ERC777Test';",
          "25:   const symbol = '777T';",
          "26:   const data = web3.utils.sha3('OZ777TestData');",
          "27:   const operatorData = web3.utils.sha3('OZ777TestOperatorData');",
          "29:   const defaultOperators = [defaultOperatorA, defaultOperatorB];",
          "31:   beforeEach(async function () {",
          "32:     this.erc1820 = await singletons.ERC1820Registry(registryFunder);",
          "33:   });",
          "35:   context('with default operators', function () {",
          "36:     beforeEach(async function () {",
          "37:       this.token = await ERC777.new(name, symbol, defaultOperators);",
          "38:       await this.token.$_mint(holder, initialSupply, '0x', '0x');",
          "39:     });",
          "41:     describe('as an ERC20 token', function () {",
          "42:       shouldBehaveLikeERC20('ERC777', initialSupply, holder, anyone, defaultOperatorA);",
          "44:       describe('_approve', function () {",
          "45:         shouldBehaveLikeERC20Approve('ERC777', holder, anyone, initialSupply, function (owner, spender, amount) {",
          "46:           return this.token.$_approve(owner, spender, amount);",
          "47:         });",
          "49:         describe('when the owner is the zero address', function () {",
          "50:           it('reverts', async function () {",
          "51:             await expectRevert(",
          "52:               this.token.$_approve(ZERO_ADDRESS, anyone, initialSupply),",
          "53:               'ERC777: approve from the zero address',",
          "54:             );",
          "55:           });",
          "56:         });",
          "57:       });",
          "58:     });",
          "60:     it('does not emit AuthorizedOperator events for default operators', async function () {",
          "61:       await expectEvent.notEmitted.inConstruction(this.token, 'AuthorizedOperator');",
          "62:     });",
          "64:     describe('basic information', function () {",
          "65:       it('returns the name', async function () {",
          "66:         expect(await this.token.name()).to.equal(name);",
          "67:       });",
          "69:       it('returns the symbol', async function () {",
          "70:         expect(await this.token.symbol()).to.equal(symbol);",
          "71:       });",
          "73:       it('returns a granularity of 1', async function () {",
          "74:         expect(await this.token.granularity()).to.be.bignumber.equal('1');",
          "75:       });",
          "77:       it('returns the default operators', async function () {",
          "78:         expect(await this.token.defaultOperators()).to.deep.equal(defaultOperators);",
          "79:       });",
          "81:       it('default operators are operators for all accounts', async function () {",
          "82:         for (const operator of defaultOperators) {",
          "83:           expect(await this.token.isOperatorFor(operator, anyone)).to.equal(true);",
          "84:         }",
          "85:       });",
          "87:       it('returns the total supply', async function () {",
          "88:         expect(await this.token.totalSupply()).to.be.bignumber.equal(initialSupply);",
          "89:       });",
          "91:       it('returns 18 when decimals is called', async function () {",
          "92:         expect(await this.token.decimals()).to.be.bignumber.equal('18');",
          "93:       });",
          "95:       it('the ERC777Token interface is registered in the registry', async function () {",
          "96:         expect(",
          "97:           await this.erc1820.getInterfaceImplementer(this.token.address, web3.utils.soliditySha3('ERC777Token')),",
          "98:         ).to.equal(this.token.address);",
          "99:       });",
          "101:       it('the ERC20Token interface is registered in the registry', async function () {",
          "102:         expect(",
          "103:           await this.erc1820.getInterfaceImplementer(this.token.address, web3.utils.soliditySha3('ERC20Token')),",
          "104:         ).to.equal(this.token.address);",
          "105:       });",
          "106:     });",
          "108:     describe('balanceOf', function () {",
          "109:       context('for an account with no tokens', function () {",
          "110:         it('returns zero', async function () {",
          "111:           expect(await this.token.balanceOf(anyone)).to.be.bignumber.equal('0');",
          "112:         });",
          "113:       });",
          "115:       context('for an account with tokens', function () {",
          "116:         it('returns their balance', async function () {",
          "117:           expect(await this.token.balanceOf(holder)).to.be.bignumber.equal(initialSupply);",
          "118:         });",
          "119:       });",
          "120:     });",
          "122:     context('with no ERC777TokensSender and no ERC777TokensRecipient implementers', function () {",
          "123:       describe('send/burn', function () {",
          "124:         shouldBehaveLikeERC777DirectSendBurn(holder, anyone, data);",
          "126:         context('with self operator', function () {",
          "127:           shouldBehaveLikeERC777OperatorSendBurn(holder, anyone, holder, data, operatorData);",
          "128:         });",
          "130:         context('with first default operator', function () {",
          "131:           shouldBehaveLikeERC777OperatorSendBurn(holder, anyone, defaultOperatorA, data, operatorData);",
          "132:         });",
          "134:         context('with second default operator', function () {",
          "135:           shouldBehaveLikeERC777OperatorSendBurn(holder, anyone, defaultOperatorB, data, operatorData);",
          "136:         });",
          "138:         context('before authorizing a new operator', function () {",
          "139:           shouldBehaveLikeERC777UnauthorizedOperatorSendBurn(holder, anyone, newOperator, data, operatorData);",
          "140:         });",
          "142:         context('with new authorized operator', function () {",
          "143:           beforeEach(async function () {",
          "144:             await this.token.authorizeOperator(newOperator, { from: holder });",
          "145:           });",
          "147:           shouldBehaveLikeERC777OperatorSendBurn(holder, anyone, newOperator, data, operatorData);",
          "149:           context('with revoked operator', function () {",
          "150:             beforeEach(async function () {",
          "151:               await this.token.revokeOperator(newOperator, { from: holder });",
          "152:             });",
          "154:             shouldBehaveLikeERC777UnauthorizedOperatorSendBurn(holder, anyone, newOperator, data, operatorData);",
          "155:           });",
          "156:         });",
          "157:       });",
          "159:       describe('mint (internal)', function () {",
          "160:         const to = anyone;",
          "161:         const amount = new BN('5');",
          "163:         context('with default operator', function () {",
          "164:           const operator = defaultOperatorA;",
          "166:           shouldBehaveLikeERC777InternalMint(to, operator, amount, data, operatorData);",
          "167:         });",
          "169:         context('with non operator', function () {",
          "170:           const operator = newOperator;",
          "172:           shouldBehaveLikeERC777InternalMint(to, operator, amount, data, operatorData);",
          "173:         });",
          "174:       });",
          "176:       describe('mint (internal extended)', function () {",
          "177:         const amount = new BN('5');",
          "179:         context('to anyone', function () {",
          "180:           beforeEach(async function () {",
          "181:             this.recipient = anyone;",
          "182:           });",
          "184:           context('with default operator', function () {",
          "185:             const operator = defaultOperatorA;",
          "187:             it('without requireReceptionAck', async function () {",
          "188:               await this.token.$_mint(this.recipient, amount, data, operatorData, false, { from: operator });",
          "189:             });",
          "191:             it('with requireReceptionAck', async function () {",
          "192:               await this.token.$_mint(this.recipient, amount, data, operatorData, true, { from: operator });",
          "193:             });",
          "194:           });",
          "196:           context('with non operator', function () {",
          "197:             const operator = newOperator;",
          "199:             it('without requireReceptionAck', async function () {",
          "200:               await this.token.$_mint(this.recipient, amount, data, operatorData, false, { from: operator });",
          "201:             });",
          "203:             it('with requireReceptionAck', async function () {",
          "204:               await this.token.$_mint(this.recipient, amount, data, operatorData, true, { from: operator });",
          "205:             });",
          "206:           });",
          "207:         });",
          "209:         context('to non ERC777TokensRecipient implementer', function () {",
          "210:           beforeEach(async function () {",
          "211:             this.tokensRecipientImplementer = await ERC777SenderRecipientMock.new();",
          "212:             this.recipient = this.tokensRecipientImplementer.address;",
          "213:           });",
          "215:           context('with default operator', function () {",
          "216:             const operator = defaultOperatorA;",
          "218:             it('without requireReceptionAck', async function () {",
          "219:               await this.token.$_mint(this.recipient, amount, data, operatorData, false, { from: operator });",
          "220:             });",
          "222:             it('with requireReceptionAck', async function () {",
          "223:               await expectRevert(",
          "224:                 this.token.$_mint(this.recipient, amount, data, operatorData, true, { from: operator }),",
          "225:                 'ERC777: token recipient contract has no implementer for ERC777TokensRecipient',",
          "226:               );",
          "227:             });",
          "228:           });",
          "230:           context('with non operator', function () {",
          "231:             const operator = newOperator;",
          "233:             it('without requireReceptionAck', async function () {",
          "234:               await this.token.$_mint(this.recipient, amount, data, operatorData, false, { from: operator });",
          "235:             });",
          "237:             it('with requireReceptionAck', async function () {",
          "238:               await expectRevert(",
          "239:                 this.token.$_mint(this.recipient, amount, data, operatorData, true, { from: operator }),",
          "240:                 'ERC777: token recipient contract has no implementer for ERC777TokensRecipient',",
          "241:               );",
          "242:             });",
          "243:           });",
          "244:         });",
          "245:       });",
          "246:     });",
          "248:     describe('operator management', function () {",
          "249:       it('accounts are their own operator', async function () {",
          "250:         expect(await this.token.isOperatorFor(holder, holder)).to.equal(true);",
          "251:       });",
          "253:       it('reverts when self-authorizing', async function () {",
          "254:         await expectRevert(",
          "255:           this.token.authorizeOperator(holder, { from: holder }),",
          "256:           'ERC777: authorizing self as operator',",
          "257:         );",
          "258:       });",
          "260:       it('reverts when self-revoking', async function () {",
          "261:         await expectRevert(this.token.revokeOperator(holder, { from: holder }), 'ERC777: revoking self as operator');",
          "262:       });",
          "264:       it('non-operators can be revoked', async function () {",
          "265:         expect(await this.token.isOperatorFor(newOperator, holder)).to.equal(false);",
          "267:         const receipt = await this.token.revokeOperator(newOperator, { from: holder });",
          "268:         expectEvent(receipt, 'RevokedOperator', { operator: newOperator, tokenHolder: holder });",
          "270:         expect(await this.token.isOperatorFor(newOperator, holder)).to.equal(false);",
          "271:       });",
          "273:       it('non-operators can be authorized', async function () {",
          "274:         expect(await this.token.isOperatorFor(newOperator, holder)).to.equal(false);",
          "276:         const receipt = await this.token.authorizeOperator(newOperator, { from: holder });",
          "277:         expectEvent(receipt, 'AuthorizedOperator', { operator: newOperator, tokenHolder: holder });",
          "279:         expect(await this.token.isOperatorFor(newOperator, holder)).to.equal(true);",
          "280:       });",
          "282:       describe('new operators', function () {",
          "283:         beforeEach(async function () {",
          "284:           await this.token.authorizeOperator(newOperator, { from: holder });",
          "285:         });",
          "287:         it('are not added to the default operators list', async function () {",
          "288:           expect(await this.token.defaultOperators()).to.deep.equal(defaultOperators);",
          "289:         });",
          "291:         it('can be re-authorized', async function () {",
          "292:           const receipt = await this.token.authorizeOperator(newOperator, { from: holder });",
          "293:           expectEvent(receipt, 'AuthorizedOperator', { operator: newOperator, tokenHolder: holder });",
          "295:           expect(await this.token.isOperatorFor(newOperator, holder)).to.equal(true);",
          "296:         });",
          "298:         it('can be revoked', async function () {",
          "299:           const receipt = await this.token.revokeOperator(newOperator, { from: holder });",
          "300:           expectEvent(receipt, 'RevokedOperator', { operator: newOperator, tokenHolder: holder });",
          "302:           expect(await this.token.isOperatorFor(newOperator, holder)).to.equal(false);",
          "303:         });",
          "304:       });",
          "306:       describe('default operators', function () {",
          "307:         it('can be re-authorized', async function () {",
          "308:           const receipt = await this.token.authorizeOperator(defaultOperatorA, { from: holder });",
          "309:           expectEvent(receipt, 'AuthorizedOperator', { operator: defaultOperatorA, tokenHolder: holder });",
          "311:           expect(await this.token.isOperatorFor(defaultOperatorA, holder)).to.equal(true);",
          "312:         });",
          "314:         it('can be revoked', async function () {",
          "315:           const receipt = await this.token.revokeOperator(defaultOperatorA, { from: holder });",
          "316:           expectEvent(receipt, 'RevokedOperator', { operator: defaultOperatorA, tokenHolder: holder });",
          "318:           expect(await this.token.isOperatorFor(defaultOperatorA, holder)).to.equal(false);",
          "319:         });",
          "321:         it('cannot be revoked for themselves', async function () {",
          "322:           await expectRevert(",
          "323:             this.token.revokeOperator(defaultOperatorA, { from: defaultOperatorA }),",
          "324:             'ERC777: revoking self as operator',",
          "325:           );",
          "326:         });",
          "328:         context('with revoked default operator', function () {",
          "329:           beforeEach(async function () {",
          "330:             await this.token.revokeOperator(defaultOperatorA, { from: holder });",
          "331:           });",
          "333:           it('default operator is not revoked for other holders', async function () {",
          "334:             expect(await this.token.isOperatorFor(defaultOperatorA, anyone)).to.equal(true);",
          "335:           });",
          "337:           it('other default operators are not revoked', async function () {",
          "338:             expect(await this.token.isOperatorFor(defaultOperatorB, holder)).to.equal(true);",
          "339:           });",
          "341:           it('default operators list is not modified', async function () {",
          "342:             expect(await this.token.defaultOperators()).to.deep.equal(defaultOperators);",
          "343:           });",
          "345:           it('revoked default operator can be re-authorized', async function () {",
          "346:             const receipt = await this.token.authorizeOperator(defaultOperatorA, { from: holder });",
          "347:             expectEvent(receipt, 'AuthorizedOperator', { operator: defaultOperatorA, tokenHolder: holder });",
          "349:             expect(await this.token.isOperatorFor(defaultOperatorA, holder)).to.equal(true);",
          "350:           });",
          "351:         });",
          "352:       });",
          "353:     });",
          "355:     describe('send and receive hooks', function () {",
          "356:       const amount = new BN('1');",
          "357:       const operator = defaultOperatorA;",
          "360:       describe('tokensReceived', function () {",
          "361:         beforeEach(function () {",
          "362:           this.sender = holder;",
          "363:         });",
          "365:         context('with no ERC777TokensRecipient implementer', function () {",
          "366:           context('with contract recipient', function () {",
          "367:             beforeEach(async function () {",
          "368:               this.tokensRecipientImplementer = await ERC777SenderRecipientMock.new();",
          "369:               this.recipient = this.tokensRecipientImplementer.address;",
          "372:             });",
          "374:             it('send reverts', async function () {",
          "375:               await expectRevert(",
          "376:                 this.token.send(this.recipient, amount, data, { from: holder }),",
          "377:                 'ERC777: token recipient contract has no implementer for ERC777TokensRecipient',",
          "378:               );",
          "379:             });",
          "381:             it('operatorSend reverts', async function () {",
          "382:               await expectRevert(",
          "383:                 this.token.operatorSend(this.sender, this.recipient, amount, data, operatorData, { from: operator }),",
          "384:                 'ERC777: token recipient contract has no implementer for ERC777TokensRecipient',",
          "385:               );",
          "386:             });",
          "388:             it('mint (internal) reverts', async function () {",
          "389:               await expectRevert(",
          "390:                 this.token.$_mint(this.recipient, amount, data, operatorData, true, { from: operator }),",
          "391:                 'ERC777: token recipient contract has no implementer for ERC777TokensRecipient',",
          "392:               );",
          "393:             });",
          "395:             it('(ERC20) transfer succeeds', async function () {",
          "396:               await this.token.transfer(this.recipient, amount, { from: holder });",
          "397:             });",
          "399:             it('(ERC20) transferFrom succeeds', async function () {",
          "400:               const approved = anyone;",
          "401:               await this.token.approve(approved, amount, { from: this.sender });",
          "402:               await this.token.transferFrom(this.sender, this.recipient, amount, { from: approved });",
          "403:             });",
          "404:           });",
          "405:         });",
          "407:         context('with ERC777TokensRecipient implementer', function () {",
          "408:           context('with contract as implementer for an externally owned account', function () {",
          "409:             beforeEach(async function () {",
          "410:               this.tokensRecipientImplementer = await ERC777SenderRecipientMock.new();",
          "411:               this.recipient = anyone;",
          "413:               await this.tokensRecipientImplementer.recipientFor(this.recipient);",
          "415:               await this.erc1820.setInterfaceImplementer(",
          "416:                 this.recipient,",
          "417:                 web3.utils.soliditySha3('ERC777TokensRecipient'),",
          "418:                 this.tokensRecipientImplementer.address,",
          "419:                 { from: this.recipient },",
          "420:               );",
          "421:             });",
          "423:             shouldBehaveLikeERC777SendBurnMintInternalWithReceiveHook(operator, amount, data, operatorData);",
          "424:           });",
          "426:           context('with contract as implementer for another contract', function () {",
          "427:             beforeEach(async function () {",
          "428:               this.recipientContract = await ERC777SenderRecipientMock.new();",
          "429:               this.recipient = this.recipientContract.address;",
          "431:               this.tokensRecipientImplementer = await ERC777SenderRecipientMock.new();",
          "432:               await this.tokensRecipientImplementer.recipientFor(this.recipient);",
          "433:               await this.recipientContract.registerRecipient(this.tokensRecipientImplementer.address);",
          "434:             });",
          "436:             shouldBehaveLikeERC777SendBurnMintInternalWithReceiveHook(operator, amount, data, operatorData);",
          "437:           });",
          "439:           context('with contract as implementer for itself', function () {",
          "440:             beforeEach(async function () {",
          "441:               this.tokensRecipientImplementer = await ERC777SenderRecipientMock.new();",
          "442:               this.recipient = this.tokensRecipientImplementer.address;",
          "444:               await this.tokensRecipientImplementer.recipientFor(this.recipient);",
          "445:             });",
          "447:             shouldBehaveLikeERC777SendBurnMintInternalWithReceiveHook(operator, amount, data, operatorData);",
          "448:           });",
          "449:         });",
          "450:       });",
          "452:       describe('tokensToSend', function () {",
          "453:         beforeEach(function () {",
          "454:           this.recipient = anyone;",
          "455:         });",
          "457:         context('with a contract as implementer for an externally owned account', function () {",
          "458:           beforeEach(async function () {",
          "459:             this.tokensSenderImplementer = await ERC777SenderRecipientMock.new();",
          "460:             this.sender = holder;",
          "462:             await this.tokensSenderImplementer.senderFor(this.sender);",
          "464:             await this.erc1820.setInterfaceImplementer(",
          "465:               this.sender,",
          "466:               web3.utils.soliditySha3('ERC777TokensSender'),",
          "467:               this.tokensSenderImplementer.address,",
          "468:               { from: this.sender },",
          "469:             );",
          "470:           });",
          "472:           shouldBehaveLikeERC777SendBurnWithSendHook(operator, amount, data, operatorData);",
          "473:         });",
          "475:         context('with contract as implementer for another contract', function () {",
          "476:           beforeEach(async function () {",
          "477:             this.senderContract = await ERC777SenderRecipientMock.new();",
          "478:             this.sender = this.senderContract.address;",
          "480:             this.tokensSenderImplementer = await ERC777SenderRecipientMock.new();",
          "481:             await this.tokensSenderImplementer.senderFor(this.sender);",
          "482:             await this.senderContract.registerSender(this.tokensSenderImplementer.address);",
          "487:             await this.senderContract.recipientFor(this.sender);",
          "488:             await this.token.send(this.sender, amount, data, { from: holder });",
          "489:           });",
          "491:           shouldBehaveLikeERC777SendBurnWithSendHook(operator, amount, data, operatorData);",
          "492:         });",
          "494:         context('with a contract as implementer for itself', function () {",
          "495:           beforeEach(async function () {",
          "496:             this.tokensSenderImplementer = await ERC777SenderRecipientMock.new();",
          "497:             this.sender = this.tokensSenderImplementer.address;",
          "499:             await this.tokensSenderImplementer.senderFor(this.sender);",
          "504:             await this.tokensSenderImplementer.recipientFor(this.sender);",
          "505:             await this.token.send(this.sender, amount, data, { from: holder });",
          "506:           });",
          "508:           shouldBehaveLikeERC777SendBurnWithSendHook(operator, amount, data, operatorData);",
          "509:         });",
          "510:       });",
          "511:     });",
          "512:   });",
          "514:   context('with no default operators', function () {",
          "515:     beforeEach(async function () {",
          "516:       this.token = await ERC777.new(name, symbol, []);",
          "517:     });",
          "519:     it('default operators list is empty', async function () {",
          "520:       expect(await this.token.defaultOperators()).to.deep.equal([]);",
          "521:     });",
          "522:   });",
          "524:   describe('relative order of hooks', function () {",
          "525:     beforeEach(async function () {",
          "526:       await singletons.ERC1820Registry(registryFunder);",
          "527:       this.sender = await ERC777SenderRecipientMock.new();",
          "528:       await this.sender.registerRecipient(this.sender.address);",
          "529:       await this.sender.registerSender(this.sender.address);",
          "530:       this.token = await ERC777.new(name, symbol, []);",
          "531:       await this.token.$_mint(this.sender.address, 1, '0x', '0x');",
          "532:     });",
          "534:     it('send', async function () {",
          "535:       const { receipt } = await this.sender.send(this.token.address, anyone, 1, '0x');",
          "537:       const internalBeforeHook = receipt.logs.findIndex(l => l.event === 'BeforeTokenTransfer');",
          "538:       expect(internalBeforeHook).to.be.gte(0);",
          "539:       const externalSendHook = receipt.logs.findIndex(l => l.event === 'TokensToSendCalled');",
          "540:       expect(externalSendHook).to.be.gte(0);",
          "542:       expect(externalSendHook).to.be.lt(internalBeforeHook);",
          "543:     });",
          "545:     it('burn', async function () {",
          "546:       const { receipt } = await this.sender.burn(this.token.address, 1, '0x');",
          "548:       const internalBeforeHook = receipt.logs.findIndex(l => l.event === 'BeforeTokenTransfer');",
          "549:       expect(internalBeforeHook).to.be.gte(0);",
          "550:       const externalSendHook = receipt.logs.findIndex(l => l.event === 'TokensToSendCalled');",
          "551:       expect(externalSendHook).to.be.gte(0);",
          "553:       expect(externalSendHook).to.be.lt(internalBeforeHook);",
          "554:     });",
          "555:   });",
          "556: });",
          "",
          "---------------"
        ],
        "test/token/ERC777/presets/ERC777PresetFixedSupply.test.js||test/token/ERC777/presets/ERC777PresetFixedSupply.test.js": [
          "File: test/token/ERC777/presets/ERC777PresetFixedSupply.test.js -> test/token/ERC777/presets/ERC777PresetFixedSupply.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, singletons } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const ERC777PresetFixedSupply = artifacts.require('ERC777PresetFixedSupply');",
          "7: contract('ERC777PresetFixedSupply', function (accounts) {",
          "8:   const [registryFunder, owner, defaultOperatorA, defaultOperatorB, anyone] = accounts;",
          "10:   const initialSupply = new BN('10000');",
          "11:   const name = 'ERC777Preset';",
          "12:   const symbol = '777P';",
          "14:   const defaultOperators = [defaultOperatorA, defaultOperatorB];",
          "16:   before(async function () {",
          "17:     await singletons.ERC1820Registry(registryFunder);",
          "18:   });",
          "20:   beforeEach(async function () {",
          "21:     this.token = await ERC777PresetFixedSupply.new(name, symbol, defaultOperators, initialSupply, owner);",
          "22:   });",
          "24:   it('returns the name', async function () {",
          "25:     expect(await this.token.name()).to.equal(name);",
          "26:   });",
          "28:   it('returns the symbol', async function () {",
          "29:     expect(await this.token.symbol()).to.equal(symbol);",
          "30:   });",
          "32:   it('returns the default operators', async function () {",
          "33:     expect(await this.token.defaultOperators()).to.deep.equal(defaultOperators);",
          "34:   });",
          "36:   it('default operators are operators for all accounts', async function () {",
          "37:     for (const operator of defaultOperators) {",
          "38:       expect(await this.token.isOperatorFor(operator, anyone)).to.equal(true);",
          "39:     }",
          "40:   });",
          "42:   it('returns the total supply equal to initial supply', async function () {",
          "43:     expect(await this.token.totalSupply()).to.be.bignumber.equal(initialSupply);",
          "44:   });",
          "46:   it('returns the balance of owner equal to initial supply', async function () {",
          "47:     expect(await this.token.balanceOf(owner)).to.be.bignumber.equal(initialSupply);",
          "48:   });",
          "49: });",
          "",
          "---------------"
        ],
        "test/token/common/ERC2981.behavior.js||test/token/common/ERC2981.behavior.js": [
          "File: test/token/common/ERC2981.behavior.js -> test/token/common/ERC2981.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const { ZERO_ADDRESS } = constants;",
          "5: const { shouldSupportInterfaces } = require('../../utils/introspection/SupportsInterface.behavior');",
          "7: function shouldBehaveLikeERC2981() {",
          "8:   const royaltyFraction = new BN('10');",
          "10:   shouldSupportInterfaces(['ERC2981']);",
          "12:   describe('default royalty', function () {",
          "13:     beforeEach(async function () {",
          "14:       await this.token.$_setDefaultRoyalty(this.account1, royaltyFraction);",
          "15:     });",
          "17:     it('checks royalty is set', async function () {",
          "18:       const royalty = new BN((this.salePrice * royaltyFraction) / 10000);",
          "20:       const initInfo = await this.token.royaltyInfo(this.tokenId1, this.salePrice);",
          "22:       expect(initInfo[0]).to.be.equal(this.account1);",
          "23:       expect(initInfo[1]).to.be.bignumber.equal(royalty);",
          "24:     });",
          "26:     it('updates royalty amount', async function () {",
          "27:       const newPercentage = new BN('25');",
          "30:       await this.token.$_setDefaultRoyalty(this.account1, newPercentage);",
          "31:       const royalty = new BN((this.salePrice * newPercentage) / 10000);",
          "32:       const newInfo = await this.token.royaltyInfo(this.tokenId1, this.salePrice);",
          "34:       expect(newInfo[0]).to.be.equal(this.account1);",
          "35:       expect(newInfo[1]).to.be.bignumber.equal(royalty);",
          "36:     });",
          "38:     it('holds same royalty value for different tokens', async function () {",
          "39:       const newPercentage = new BN('20');",
          "40:       await this.token.$_setDefaultRoyalty(this.account1, newPercentage);",
          "42:       const token1Info = await this.token.royaltyInfo(this.tokenId1, this.salePrice);",
          "43:       const token2Info = await this.token.royaltyInfo(this.tokenId2, this.salePrice);",
          "45:       expect(token1Info[1]).to.be.bignumber.equal(token2Info[1]);",
          "46:     });",
          "48:     it('Remove royalty information', async function () {",
          "49:       const newValue = new BN('0');",
          "50:       await this.token.$_deleteDefaultRoyalty();",
          "52:       const token1Info = await this.token.royaltyInfo(this.tokenId1, this.salePrice);",
          "53:       const token2Info = await this.token.royaltyInfo(this.tokenId2, this.salePrice);",
          "55:       expect(token1Info[0]).to.be.bignumber.equal(token2Info[0]);",
          "56:       expect(token1Info[1]).to.be.bignumber.equal(token2Info[1]);",
          "58:       expect(token1Info[0]).to.be.equal(ZERO_ADDRESS);",
          "59:       expect(token1Info[1]).to.be.bignumber.equal(newValue);",
          "60:     });",
          "62:     it('reverts if invalid parameters', async function () {",
          "63:       await expectRevert(this.token.$_setDefaultRoyalty(ZERO_ADDRESS, royaltyFraction), 'ERC2981: invalid receiver');",
          "65:       await expectRevert(",
          "66:         this.token.$_setDefaultRoyalty(this.account1, new BN('11000')),",
          "67:         'ERC2981: royalty fee will exceed salePrice',",
          "68:       );",
          "69:     });",
          "70:   });",
          "72:   describe('token based royalty', function () {",
          "73:     beforeEach(async function () {",
          "74:       await this.token.$_setTokenRoyalty(this.tokenId1, this.account1, royaltyFraction);",
          "75:     });",
          "77:     it('updates royalty amount', async function () {",
          "78:       const newPercentage = new BN('25');",
          "79:       let royalty = new BN((this.salePrice * royaltyFraction) / 10000);",
          "81:       const initInfo = await this.token.royaltyInfo(this.tokenId1, this.salePrice);",
          "83:       expect(initInfo[0]).to.be.equal(this.account1);",
          "84:       expect(initInfo[1]).to.be.bignumber.equal(royalty);",
          "87:       await this.token.$_setTokenRoyalty(this.tokenId1, this.account1, newPercentage);",
          "88:       royalty = new BN((this.salePrice * newPercentage) / 10000);",
          "89:       const newInfo = await this.token.royaltyInfo(this.tokenId1, this.salePrice);",
          "91:       expect(newInfo[0]).to.be.equal(this.account1);",
          "92:       expect(newInfo[1]).to.be.bignumber.equal(royalty);",
          "93:     });",
          "95:     it('holds different values for different tokens', async function () {",
          "96:       const newPercentage = new BN('20');",
          "97:       await this.token.$_setTokenRoyalty(this.tokenId2, this.account1, newPercentage);",
          "99:       const token1Info = await this.token.royaltyInfo(this.tokenId1, this.salePrice);",
          "100:       const token2Info = await this.token.royaltyInfo(this.tokenId2, this.salePrice);",
          "103:       expect(token1Info[1]).to.not.be.equal(token2Info.royaltyFraction);",
          "104:     });",
          "106:     it('reverts if invalid parameters', async function () {",
          "107:       await expectRevert(",
          "108:         this.token.$_setTokenRoyalty(this.tokenId1, ZERO_ADDRESS, royaltyFraction),",
          "109:         'ERC2981: Invalid parameters',",
          "110:       );",
          "112:       await expectRevert(",
          "113:         this.token.$_setTokenRoyalty(this.tokenId1, this.account1, new BN('11000')),",
          "114:         'ERC2981: royalty fee will exceed salePrice',",
          "115:       );",
          "116:     });",
          "118:     it('can reset token after setting royalty', async function () {",
          "119:       const newPercentage = new BN('30');",
          "120:       const royalty = new BN((this.salePrice * newPercentage) / 10000);",
          "121:       await this.token.$_setTokenRoyalty(this.tokenId1, this.account2, newPercentage);",
          "123:       const tokenInfo = await this.token.royaltyInfo(this.tokenId1, this.salePrice);",
          "126:       expect(tokenInfo[1]).to.be.bignumber.equal(royalty);",
          "127:       expect(tokenInfo[0]).to.be.equal(this.account2);",
          "129:       await this.token.$_setTokenRoyalty(this.tokenId2, this.account1, new BN('0'));",
          "130:       const result = await this.token.royaltyInfo(this.tokenId2, this.salePrice);",
          "132:       expect(result[0]).to.be.equal(this.account1);",
          "133:       expect(result[1]).to.be.bignumber.equal(new BN('0'));",
          "134:     });",
          "136:     it('can hold default and token royalty information', async function () {",
          "137:       const newPercentage = new BN('30');",
          "138:       const royalty = new BN((this.salePrice * newPercentage) / 10000);",
          "140:       await this.token.$_setTokenRoyalty(this.tokenId2, this.account2, newPercentage);",
          "142:       const token1Info = await this.token.royaltyInfo(this.tokenId1, this.salePrice);",
          "143:       const token2Info = await this.token.royaltyInfo(this.tokenId2, this.salePrice);",
          "145:       expect(token1Info[1]).to.not.be.bignumber.equal(token2Info[1]);",
          "146:       expect(token1Info[0]).to.not.be.equal(token2Info[0]);",
          "149:       expect(token2Info[0]).to.be.equal(this.account2);",
          "150:       expect(token2Info[1]).to.be.bignumber.equal(royalty);",
          "151:     });",
          "152:   });",
          "153: }",
          "155: module.exports = {",
          "156:   shouldBehaveLikeERC2981,",
          "157: };",
          "",
          "---------------"
        ],
        "test/utils/Address.test.js||test/utils/Address.test.js": [
          "File: test/utils/Address.test.js -> test/utils/Address.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { balance, constants, ether, expectRevert, send, expectEvent } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "4: const Address = artifacts.require('$Address');",
          "5: const EtherReceiver = artifacts.require('EtherReceiverMock');",
          "6: const CallReceiverMock = artifacts.require('CallReceiverMock');",
          "8: contract('Address', function (accounts) {",
          "9:   const [recipient, other] = accounts;",
          "11:   beforeEach(async function () {",
          "12:     this.mock = await Address.new();",
          "13:   });",
          "15:   describe('isContract', function () {",
          "16:     it('returns false for account address', async function () {",
          "17:       expect(await this.mock.$isContract(other)).to.equal(false);",
          "18:     });",
          "20:     it('returns true for contract address', async function () {",
          "21:       expect(await this.mock.$isContract(this.mock.address)).to.equal(true);",
          "22:     });",
          "23:   });",
          "25:   describe('sendValue', function () {",
          "26:     beforeEach(async function () {",
          "27:       this.recipientTracker = await balance.tracker(recipient);",
          "28:     });",
          "30:     context('when sender contract has no funds', function () {",
          "31:       it('sends 0 wei', async function () {",
          "32:         await this.mock.$sendValue(other, 0);",
          "34:         expect(await this.recipientTracker.delta()).to.be.bignumber.equal('0');",
          "35:       });",
          "37:       it('reverts when sending non-zero amounts', async function () {",
          "38:         await expectRevert(this.mock.$sendValue(other, 1), 'Address: insufficient balance');",
          "39:       });",
          "40:     });",
          "42:     context('when sender contract has funds', function () {",
          "43:       const funds = ether('1');",
          "44:       beforeEach(async function () {",
          "45:         await send.ether(other, this.mock.address, funds);",
          "46:       });",
          "48:       it('sends 0 wei', async function () {",
          "49:         await this.mock.$sendValue(recipient, 0);",
          "50:         expect(await this.recipientTracker.delta()).to.be.bignumber.equal('0');",
          "51:       });",
          "53:       it('sends non-zero amounts', async function () {",
          "54:         await this.mock.$sendValue(recipient, funds.subn(1));",
          "55:         expect(await this.recipientTracker.delta()).to.be.bignumber.equal(funds.subn(1));",
          "56:       });",
          "58:       it('sends the whole balance', async function () {",
          "59:         await this.mock.$sendValue(recipient, funds);",
          "60:         expect(await this.recipientTracker.delta()).to.be.bignumber.equal(funds);",
          "61:         expect(await balance.current(this.mock.address)).to.be.bignumber.equal('0');",
          "62:       });",
          "64:       it('reverts when sending more than the balance', async function () {",
          "65:         await expectRevert(this.mock.$sendValue(recipient, funds.addn(1)), 'Address: insufficient balance');",
          "66:       });",
          "68:       context('with contract recipient', function () {",
          "69:         beforeEach(async function () {",
          "70:           this.target = await EtherReceiver.new();",
          "71:         });",
          "73:         it('sends funds', async function () {",
          "74:           const tracker = await balance.tracker(this.target.address);",
          "76:           await this.target.setAcceptEther(true);",
          "77:           await this.mock.$sendValue(this.target.address, funds);",
          "79:           expect(await tracker.delta()).to.be.bignumber.equal(funds);",
          "80:         });",
          "82:         it('reverts on recipient revert', async function () {",
          "83:           await this.target.setAcceptEther(false);",
          "84:           await expectRevert(",
          "85:             this.mock.$sendValue(this.target.address, funds),",
          "86:             'Address: unable to send value, recipient may have reverted',",
          "87:           );",
          "88:         });",
          "89:       });",
          "90:     });",
          "91:   });",
          "93:   describe('functionCall', function () {",
          "94:     beforeEach(async function () {",
          "95:       this.target = await CallReceiverMock.new();",
          "96:     });",
          "98:     context('with valid contract receiver', function () {",
          "99:       it('calls the requested function', async function () {",
          "100:         const abiEncodedCall = this.target.contract.methods.mockFunction().encodeABI();",
          "102:         const receipt = await this.mock.$functionCall(this.target.address, abiEncodedCall);",
          "104:         expectEvent(receipt, 'return$functionCall_address_bytes', {",
          "105:           ret0: web3.eth.abi.encodeParameters(['string'], ['0x1234']),",
          "106:         });",
          "107:         await expectEvent.inTransaction(receipt.tx, CallReceiverMock, 'MockFunctionCalled');",
          "108:       });",
          "110:       it('calls the requested empty return function', async function () {",
          "111:         const abiEncodedCall = this.target.contract.methods.mockFunctionEmptyReturn().encodeABI();",
          "113:         const receipt = await this.mock.$functionCall(this.target.address, abiEncodedCall);",
          "115:         await expectEvent.inTransaction(receipt.tx, CallReceiverMock, 'MockFunctionCalled');",
          "116:       });",
          "118:       it('reverts when the called function reverts with no reason', async function () {",
          "119:         const abiEncodedCall = this.target.contract.methods.mockFunctionRevertsNoReason().encodeABI();",
          "121:         await expectRevert(",
          "122:           this.mock.$functionCall(this.target.address, abiEncodedCall),",
          "123:           'Address: low-level call failed',",
          "124:         );",
          "125:       });",
          "127:       it('reverts when the called function reverts, bubbling up the revert reason', async function () {",
          "128:         const abiEncodedCall = this.target.contract.methods.mockFunctionRevertsReason().encodeABI();",
          "130:         await expectRevert(this.mock.$functionCall(this.target.address, abiEncodedCall), 'CallReceiverMock: reverting');",
          "131:       });",
          "133:       it('reverts when the called function runs out of gas', async function () {",
          "134:         const abiEncodedCall = this.target.contract.methods.mockFunctionOutOfGas().encodeABI();",
          "136:         await expectRevert(",
          "137:           this.mock.$functionCall(this.target.address, abiEncodedCall, { gas: '120000' }),",
          "138:           'Address: low-level call failed',",
          "139:         );",
          "140:       });",
          "142:       it('reverts when the called function throws', async function () {",
          "143:         const abiEncodedCall = this.target.contract.methods.mockFunctionThrows().encodeABI();",
          "145:         await expectRevert.unspecified(this.mock.$functionCall(this.target.address, abiEncodedCall));",
          "146:       });",
          "148:       it('bubbles up error message if specified', async function () {",
          "149:         const errorMsg = 'Address: expected error';",
          "150:         await expectRevert(this.mock.$functionCall(this.target.address, '0x12345678', errorMsg), errorMsg);",
          "151:       });",
          "153:       it('reverts when function does not exist', async function () {",
          "154:         const abiEncodedCall = web3.eth.abi.encodeFunctionCall(",
          "155:           {",
          "156:             name: 'mockFunctionDoesNotExist',",
          "157:             type: 'function',",
          "158:             inputs: [],",
          "159:           },",
          "160:           [],",
          "161:         );",
          "163:         await expectRevert(",
          "164:           this.mock.$functionCall(this.target.address, abiEncodedCall),",
          "165:           'Address: low-level call failed',",
          "166:         );",
          "167:       });",
          "168:     });",
          "170:     context('with non-contract receiver', function () {",
          "171:       it('reverts when address is not a contract', async function () {",
          "172:         const [recipient] = accounts;",
          "173:         const abiEncodedCall = this.target.contract.methods.mockFunction().encodeABI();",
          "175:         await expectRevert(this.mock.$functionCall(recipient, abiEncodedCall), 'Address: call to non-contract');",
          "176:       });",
          "177:     });",
          "178:   });",
          "180:   describe('functionCallWithValue', function () {",
          "181:     beforeEach(async function () {",
          "182:       this.target = await CallReceiverMock.new();",
          "183:     });",
          "185:     context('with zero value', function () {",
          "186:       it('calls the requested function', async function () {",
          "187:         const abiEncodedCall = this.target.contract.methods.mockFunction().encodeABI();",
          "189:         const receipt = await this.mock.$functionCallWithValue(this.target.address, abiEncodedCall, 0);",
          "190:         expectEvent(receipt, 'return$functionCallWithValue_address_bytes_uint256', {",
          "191:           ret0: web3.eth.abi.encodeParameters(['string'], ['0x1234']),",
          "192:         });",
          "193:         await expectEvent.inTransaction(receipt.tx, CallReceiverMock, 'MockFunctionCalled');",
          "194:       });",
          "195:     });",
          "197:     context('with non-zero value', function () {",
          "198:       const amount = ether('1.2');",
          "200:       it('reverts if insufficient sender balance', async function () {",
          "201:         const abiEncodedCall = this.target.contract.methods.mockFunction().encodeABI();",
          "203:         await expectRevert(",
          "204:           this.mock.$functionCallWithValue(this.target.address, abiEncodedCall, amount),",
          "205:           'Address: insufficient balance for call',",
          "206:         );",
          "207:       });",
          "209:       it('calls the requested function with existing value', async function () {",
          "210:         const abiEncodedCall = this.target.contract.methods.mockFunction().encodeABI();",
          "212:         const tracker = await balance.tracker(this.target.address);",
          "214:         await send.ether(other, this.mock.address, amount);",
          "216:         const receipt = await this.mock.$functionCallWithValue(this.target.address, abiEncodedCall, amount);",
          "217:         expectEvent(receipt, 'return$functionCallWithValue_address_bytes_uint256', {",
          "218:           ret0: web3.eth.abi.encodeParameters(['string'], ['0x1234']),",
          "219:         });",
          "220:         await expectEvent.inTransaction(receipt.tx, CallReceiverMock, 'MockFunctionCalled');",
          "222:         expect(await tracker.delta()).to.be.bignumber.equal(amount);",
          "223:       });",
          "225:       it('calls the requested function with transaction funds', async function () {",
          "226:         const abiEncodedCall = this.target.contract.methods.mockFunction().encodeABI();",
          "228:         const tracker = await balance.tracker(this.target.address);",
          "230:         expect(await balance.current(this.mock.address)).to.be.bignumber.equal('0');",
          "232:         const receipt = await this.mock.$functionCallWithValue(this.target.address, abiEncodedCall, amount, {",
          "233:           from: other,",
          "234:           value: amount,",
          "235:         });",
          "236:         expectEvent(receipt, 'return$functionCallWithValue_address_bytes_uint256', {",
          "237:           ret0: web3.eth.abi.encodeParameters(['string'], ['0x1234']),",
          "238:         });",
          "239:         await expectEvent.inTransaction(receipt.tx, CallReceiverMock, 'MockFunctionCalled');",
          "241:         expect(await tracker.delta()).to.be.bignumber.equal(amount);",
          "242:       });",
          "244:       it('reverts when calling non-payable functions', async function () {",
          "245:         const abiEncodedCall = this.target.contract.methods.mockFunctionNonPayable().encodeABI();",
          "247:         await send.ether(other, this.mock.address, amount);",
          "248:         await expectRevert(",
          "249:           this.mock.$functionCallWithValue(this.target.address, abiEncodedCall, amount),",
          "250:           'Address: low-level call with value failed',",
          "251:         );",
          "252:       });",
          "254:       it('bubbles up error message if specified', async function () {",
          "255:         const errorMsg = 'Address: expected error';",
          "256:         await expectRevert(this.mock.$functionCallWithValue(this.target.address, '0x12345678', 0, errorMsg), errorMsg);",
          "257:       });",
          "258:     });",
          "259:   });",
          "261:   describe('functionStaticCall', function () {",
          "262:     beforeEach(async function () {",
          "263:       this.target = await CallReceiverMock.new();",
          "264:     });",
          "266:     it('calls the requested function', async function () {",
          "267:       const abiEncodedCall = this.target.contract.methods.mockStaticFunction().encodeABI();",
          "269:       expect(await this.mock.$functionStaticCall(this.target.address, abiEncodedCall)).to.be.equal(",
          "270:         web3.eth.abi.encodeParameters(['string'], ['0x1234']),",
          "271:       );",
          "272:     });",
          "274:     it('reverts on a non-static function', async function () {",
          "275:       const abiEncodedCall = this.target.contract.methods.mockFunction().encodeABI();",
          "277:       await expectRevert(",
          "278:         this.mock.$functionStaticCall(this.target.address, abiEncodedCall),",
          "279:         'Address: low-level static call failed',",
          "280:       );",
          "281:     });",
          "283:     it('bubbles up revert reason', async function () {",
          "284:       const abiEncodedCall = this.target.contract.methods.mockFunctionRevertsReason().encodeABI();",
          "286:       await expectRevert(",
          "287:         this.mock.$functionStaticCall(this.target.address, abiEncodedCall),",
          "288:         'CallReceiverMock: reverting',",
          "289:       );",
          "290:     });",
          "292:     it('reverts when address is not a contract', async function () {",
          "293:       const [recipient] = accounts;",
          "294:       const abiEncodedCall = this.target.contract.methods.mockFunction().encodeABI();",
          "296:       await expectRevert(this.mock.$functionStaticCall(recipient, abiEncodedCall), 'Address: call to non-contract');",
          "297:     });",
          "299:     it('bubbles up error message if specified', async function () {",
          "300:       const errorMsg = 'Address: expected error';",
          "301:       await expectRevert(this.mock.$functionCallWithValue(this.target.address, '0x12345678', 0, errorMsg), errorMsg);",
          "302:     });",
          "303:   });",
          "305:   describe('functionDelegateCall', function () {",
          "306:     beforeEach(async function () {",
          "307:       this.target = await CallReceiverMock.new();",
          "308:     });",
          "310:     it('delegate calls the requested function', async function () {",
          "312:       const slot = '0x93e4c53af435ddf777c3de84bb9a953a777788500e229a468ea1036496ab66a0';",
          "313:       const value = '0x6a465d1c49869f71fb65562bcbd7e08c8044074927f0297127203f2a9924ff5b';",
          "315:       const abiEncodedCall = this.target.contract.methods.mockFunctionWritesStorage(slot, value).encodeABI();",
          "317:       expect(await web3.eth.getStorageAt(this.mock.address, slot)).to.be.equal(constants.ZERO_BYTES32);",
          "319:       expectEvent(",
          "320:         await this.mock.$functionDelegateCall(this.target.address, abiEncodedCall),",
          "321:         'return$functionDelegateCall_address_bytes',",
          "322:         { ret0: web3.eth.abi.encodeParameters(['string'], ['0x1234']) },",
          "323:       );",
          "325:       expect(await web3.eth.getStorageAt(this.mock.address, slot)).to.be.equal(value);",
          "326:     });",
          "328:     it('bubbles up revert reason', async function () {",
          "329:       const abiEncodedCall = this.target.contract.methods.mockFunctionRevertsReason().encodeABI();",
          "331:       await expectRevert(",
          "332:         this.mock.$functionDelegateCall(this.target.address, abiEncodedCall),",
          "333:         'CallReceiverMock: reverting',",
          "334:       );",
          "335:     });",
          "337:     it('reverts when address is not a contract', async function () {",
          "338:       const [recipient] = accounts;",
          "339:       const abiEncodedCall = this.target.contract.methods.mockFunction().encodeABI();",
          "341:       await expectRevert(this.mock.$functionDelegateCall(recipient, abiEncodedCall), 'Address: call to non-contract');",
          "342:     });",
          "344:     it('bubbles up error message if specified', async function () {",
          "345:       const errorMsg = 'Address: expected error';",
          "346:       await expectRevert(this.mock.$functionCallWithValue(this.target.address, '0x12345678', 0, errorMsg), errorMsg);",
          "347:     });",
          "348:   });",
          "350:   describe('verifyCallResult', function () {",
          "351:     it('returns returndata on success', async function () {",
          "352:       const returndata = '0x123abc';",
          "353:       expect(await this.mock.$verifyCallResult(true, returndata, '')).to.equal(returndata);",
          "354:     });",
          "356:     it('reverts with return data and error m', async function () {",
          "357:       const errorMsg = 'Address: expected error';",
          "358:       await expectRevert(this.mock.$verifyCallResult(false, '0x', errorMsg), errorMsg);",
          "359:     });",
          "360:   });",
          "361: });",
          "",
          "---------------"
        ],
        "test/utils/Arrays.test.js||test/utils/Arrays.test.js": [
          "File: test/utils/Arrays.test.js -> test/utils/Arrays.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const AddressArraysMock = artifacts.require('AddressArraysMock');",
          "6: const Bytes32ArraysMock = artifacts.require('Bytes32ArraysMock');",
          "7: const Uint256ArraysMock = artifacts.require('Uint256ArraysMock');",
          "9: contract('Arrays', function () {",
          "10:   describe('findUpperBound', function () {",
          "11:     context('Even number of elements', function () {",
          "12:       const EVEN_ELEMENTS_ARRAY = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20];",
          "14:       beforeEach(async function () {",
          "15:         this.arrays = await Uint256ArraysMock.new(EVEN_ELEMENTS_ARRAY);",
          "16:       });",
          "18:       it('returns correct index for the basic case', async function () {",
          "19:         expect(await this.arrays.findUpperBound(16)).to.be.bignumber.equal('5');",
          "20:       });",
          "22:       it('returns 0 for the first element', async function () {",
          "23:         expect(await this.arrays.findUpperBound(11)).to.be.bignumber.equal('0');",
          "24:       });",
          "26:       it('returns index of the last element', async function () {",
          "27:         expect(await this.arrays.findUpperBound(20)).to.be.bignumber.equal('9');",
          "28:       });",
          "30:       it('returns first index after last element if searched value is over the upper boundary', async function () {",
          "31:         expect(await this.arrays.findUpperBound(32)).to.be.bignumber.equal('10');",
          "32:       });",
          "34:       it('returns 0 for the element under the lower boundary', async function () {",
          "35:         expect(await this.arrays.findUpperBound(2)).to.be.bignumber.equal('0');",
          "36:       });",
          "37:     });",
          "39:     context('Odd number of elements', function () {",
          "40:       const ODD_ELEMENTS_ARRAY = [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21];",
          "42:       beforeEach(async function () {",
          "43:         this.arrays = await Uint256ArraysMock.new(ODD_ELEMENTS_ARRAY);",
          "44:       });",
          "46:       it('returns correct index for the basic case', async function () {",
          "47:         expect(await this.arrays.findUpperBound(16)).to.be.bignumber.equal('5');",
          "48:       });",
          "50:       it('returns 0 for the first element', async function () {",
          "51:         expect(await this.arrays.findUpperBound(11)).to.be.bignumber.equal('0');",
          "52:       });",
          "54:       it('returns index of the last element', async function () {",
          "55:         expect(await this.arrays.findUpperBound(21)).to.be.bignumber.equal('10');",
          "56:       });",
          "58:       it('returns first index after last element if searched value is over the upper boundary', async function () {",
          "59:         expect(await this.arrays.findUpperBound(32)).to.be.bignumber.equal('11');",
          "60:       });",
          "62:       it('returns 0 for the element under the lower boundary', async function () {",
          "63:         expect(await this.arrays.findUpperBound(2)).to.be.bignumber.equal('0');",
          "64:       });",
          "65:     });",
          "67:     context('Array with gap', function () {",
          "68:       const WITH_GAP_ARRAY = [11, 12, 13, 14, 15, 20, 21, 22, 23, 24];",
          "70:       beforeEach(async function () {",
          "71:         this.arrays = await Uint256ArraysMock.new(WITH_GAP_ARRAY);",
          "72:       });",
          "74:       it('returns index of first element in next filled range', async function () {",
          "75:         expect(await this.arrays.findUpperBound(17)).to.be.bignumber.equal('5');",
          "76:       });",
          "77:     });",
          "79:     context('Empty array', function () {",
          "80:       beforeEach(async function () {",
          "81:         this.arrays = await Uint256ArraysMock.new([]);",
          "82:       });",
          "84:       it('always returns 0 for empty array', async function () {",
          "85:         expect(await this.arrays.findUpperBound(10)).to.be.bignumber.equal('0');",
          "86:       });",
          "87:     });",
          "88:   });",
          "90:   describe('unsafeAccess', function () {",
          "91:     for (const { type, artifact, elements } of [",
          "92:       {",
          "93:         type: 'address',",
          "94:         artifact: AddressArraysMock,",
          "95:         elements: Array(10)",
          "96:           .fill()",
          "97:           .map(() => web3.utils.randomHex(20)),",
          "98:       },",
          "99:       {",
          "100:         type: 'bytes32',",
          "101:         artifact: Bytes32ArraysMock,",
          "102:         elements: Array(10)",
          "103:           .fill()",
          "104:           .map(() => web3.utils.randomHex(32)),",
          "105:       },",
          "106:       {",
          "107:         type: 'uint256',",
          "108:         artifact: Uint256ArraysMock,",
          "109:         elements: Array(10)",
          "110:           .fill()",
          "111:           .map(() => web3.utils.randomHex(32)),",
          "112:       },",
          "113:     ]) {",
          "114:       it(type, async function () {",
          "115:         const contract = await artifact.new(elements);",
          "117:         for (const i in elements) {",
          "118:           expect(await contract.unsafeAccess(i)).to.be.bignumber.equal(elements[i]);",
          "119:         }",
          "120:       });",
          "121:     }",
          "122:   });",
          "123: });",
          "",
          "---------------"
        ],
        "test/utils/Base64.test.js||test/utils/Base64.test.js": [
          "File: test/utils/Base64.test.js -> test/utils/Base64.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expect } = require('chai');",
          "3: const Base64 = artifacts.require('$Base64');",
          "5: contract('Strings', function () {",
          "6:   beforeEach(async function () {",
          "7:     this.base64 = await Base64.new();",
          "8:   });",
          "10:   describe('from bytes - base64', function () {",
          "11:     it('converts to base64 encoded string with double padding', async function () {",
          "12:       const TEST_MESSAGE = 'test';",
          "13:       const input = web3.utils.asciiToHex(TEST_MESSAGE);",
          "14:       expect(await this.base64.$encode(input)).to.equal('dGVzdA==');",
          "15:     });",
          "17:     it('converts to base64 encoded string with single padding', async function () {",
          "18:       const TEST_MESSAGE = 'test1';",
          "19:       const input = web3.utils.asciiToHex(TEST_MESSAGE);",
          "20:       expect(await this.base64.$encode(input)).to.equal('dGVzdDE=');",
          "21:     });",
          "23:     it('converts to base64 encoded string without padding', async function () {",
          "24:       const TEST_MESSAGE = 'test12';",
          "25:       const input = web3.utils.asciiToHex(TEST_MESSAGE);",
          "26:       expect(await this.base64.$encode(input)).to.equal('dGVzdDEy');",
          "27:     });",
          "29:     it('empty bytes', async function () {",
          "30:       expect(await this.base64.$encode([])).to.equal('');",
          "31:     });",
          "32:   });",
          "33: });",
          "",
          "---------------"
        ],
        "test/utils/Checkpoints.t.sol||test/utils/Checkpoints.t.sol": [
          "File: test/utils/Checkpoints.t.sol -> test/utils/Checkpoints.t.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: pragma solidity ^0.8.0;",
          "6: import \"forge-std/Test.sol\";",
          "7: import \"../../contracts/utils/Checkpoints.sol\";",
          "8: import \"../../contracts/utils/math/SafeCast.sol\";",
          "10: contract CheckpointsHistoryTest is Test {",
          "11:     using Checkpoints for Checkpoints.History;",
          "15:     uint8 internal constant _KEY_MAX_GAP = 64;",
          "17:     Checkpoints.History internal _ckpts;",
          "20:     function _boundUint32(uint32 x, uint32 min, uint32 max) internal view returns (uint32) {",
          "21:         return SafeCast.toUint32(bound(uint256(x), uint256(min), uint256(max)));",
          "22:     }",
          "24:     function _prepareKeys(uint32[] memory keys, uint32 maxSpread) internal view {",
          "25:         uint32 lastKey = 0;",
          "26:         for (uint256 i = 0; i < keys.length; ++i) {",
          "27:             uint32 key = _boundUint32(keys[i], lastKey, lastKey + maxSpread);",
          "28:             keys[i] = key;",
          "29:             lastKey = key;",
          "30:         }",
          "31:     }",
          "33:     function _assertLatestCheckpoint(bool exist, uint32 key, uint224 value) internal {",
          "34:         (bool _exist, uint32 _key, uint224 _value) = _ckpts.latestCheckpoint();",
          "35:         assertEq(_exist, exist);",
          "36:         assertEq(_key, key);",
          "37:         assertEq(_value, value);",
          "38:     }",
          "41:     function testPush(uint32[] memory keys, uint224[] memory values, uint32 pastKey) public {",
          "42:         vm.assume(values.length > 0 && values.length <= keys.length);",
          "43:         _prepareKeys(keys, _KEY_MAX_GAP);",
          "46:         assertEq(_ckpts.length(), 0);",
          "47:         assertEq(_ckpts.latest(), 0);",
          "48:         _assertLatestCheckpoint(false, 0, 0);",
          "50:         uint256 duplicates = 0;",
          "51:         for (uint256 i = 0; i < keys.length; ++i) {",
          "52:             uint32 key = keys[i];",
          "53:             uint224 value = values[i % values.length];",
          "54:             if (i > 0 && key == keys[i - 1]) ++duplicates;",
          "57:             vm.roll(key);",
          "58:             _ckpts.push(value);",
          "61:             assertEq(_ckpts.length(), i + 1 - duplicates);",
          "62:             assertEq(_ckpts.latest(), value);",
          "63:             _assertLatestCheckpoint(true, key, value);",
          "64:         }",
          "67:         if (keys.length > 0) {",
          "68:             uint32 lastKey = keys[keys.length - 1];",
          "69:             if (lastKey > 0) {",
          "70:                 pastKey = _boundUint32(pastKey, 0, lastKey - 1);",
          "72:                 vm.roll(pastKey);",
          "73:                 vm.expectRevert();",
          "74:                 this.push(values[keys.length % values.length]);",
          "75:             }",
          "76:         }",
          "77:     }",
          "80:     function push(uint224 value) external {",
          "81:         _ckpts.push(value);",
          "82:     }",
          "84:     function testLookup(uint32[] memory keys, uint224[] memory values, uint32 lookup) public {",
          "85:         vm.assume(keys.length > 0);",
          "86:         vm.assume(values.length > 0 && values.length <= keys.length);",
          "87:         _prepareKeys(keys, _KEY_MAX_GAP);",
          "89:         uint32 lastKey = keys[keys.length - 1];",
          "90:         vm.assume(lastKey > 0);",
          "91:         lookup = _boundUint32(lookup, 0, lastKey - 1);",
          "93:         uint224 upper = 0;",
          "94:         for (uint256 i = 0; i < keys.length; ++i) {",
          "95:             uint32 key = keys[i];",
          "96:             uint224 value = values[i % values.length];",
          "99:             vm.roll(key);",
          "100:             _ckpts.push(value);",
          "103:             if (key <= lookup) {",
          "104:                 upper = value;",
          "105:             }",
          "106:         }",
          "109:         assertEq(_ckpts.getAtBlock(lookup), upper);",
          "110:         assertEq(_ckpts.getAtProbablyRecentBlock(lookup), upper);",
          "112:         vm.expectRevert();",
          "113:         this.getAtBlock(lastKey);",
          "114:         vm.expectRevert();",
          "115:         this.getAtBlock(lastKey + 1);",
          "116:         vm.expectRevert();",
          "117:         this.getAtProbablyRecentBlock(lastKey);",
          "118:         vm.expectRevert();",
          "119:         this.getAtProbablyRecentBlock(lastKey + 1);",
          "120:     }",
          "123:     function getAtBlock(uint32 key) external view {",
          "124:         _ckpts.getAtBlock(key);",
          "125:     }",
          "128:     function getAtProbablyRecentBlock(uint32 key) external view {",
          "129:         _ckpts.getAtProbablyRecentBlock(key);",
          "130:     }",
          "131: }",
          "133: contract CheckpointsTrace224Test is Test {",
          "134:     using Checkpoints for Checkpoints.Trace224;",
          "138:     uint8 internal constant _KEY_MAX_GAP = 64;",
          "140:     Checkpoints.Trace224 internal _ckpts;",
          "143:     function _boundUint32(uint32 x, uint32 min, uint32 max) internal view returns (uint32) {",
          "144:         return SafeCast.toUint32(bound(uint256(x), uint256(min), uint256(max)));",
          "145:     }",
          "147:     function _prepareKeys(uint32[] memory keys, uint32 maxSpread) internal view {",
          "148:         uint32 lastKey = 0;",
          "149:         for (uint256 i = 0; i < keys.length; ++i) {",
          "150:             uint32 key = _boundUint32(keys[i], lastKey, lastKey + maxSpread);",
          "151:             keys[i] = key;",
          "152:             lastKey = key;",
          "153:         }",
          "154:     }",
          "156:     function _assertLatestCheckpoint(bool exist, uint32 key, uint224 value) internal {",
          "157:         (bool _exist, uint32 _key, uint224 _value) = _ckpts.latestCheckpoint();",
          "158:         assertEq(_exist, exist);",
          "159:         assertEq(_key, key);",
          "160:         assertEq(_value, value);",
          "161:     }",
          "164:     function testPush(uint32[] memory keys, uint224[] memory values, uint32 pastKey) public {",
          "165:         vm.assume(values.length > 0 && values.length <= keys.length);",
          "166:         _prepareKeys(keys, _KEY_MAX_GAP);",
          "169:         assertEq(_ckpts.length(), 0);",
          "170:         assertEq(_ckpts.latest(), 0);",
          "171:         _assertLatestCheckpoint(false, 0, 0);",
          "173:         uint256 duplicates = 0;",
          "174:         for (uint256 i = 0; i < keys.length; ++i) {",
          "175:             uint32 key = keys[i];",
          "176:             uint224 value = values[i % values.length];",
          "177:             if (i > 0 && key == keys[i - 1]) ++duplicates;",
          "180:             _ckpts.push(key, value);",
          "183:             assertEq(_ckpts.length(), i + 1 - duplicates);",
          "184:             assertEq(_ckpts.latest(), value);",
          "185:             _assertLatestCheckpoint(true, key, value);",
          "186:         }",
          "188:         if (keys.length > 0) {",
          "189:             uint32 lastKey = keys[keys.length - 1];",
          "190:             if (lastKey > 0) {",
          "191:                 pastKey = _boundUint32(pastKey, 0, lastKey - 1);",
          "193:                 vm.expectRevert();",
          "194:                 this.push(pastKey, values[keys.length % values.length]);",
          "195:             }",
          "196:         }",
          "197:     }",
          "200:     function push(uint32 key, uint224 value) external {",
          "201:         _ckpts.push(key, value);",
          "202:     }",
          "204:     function testLookup(uint32[] memory keys, uint224[] memory values, uint32 lookup) public {",
          "205:         vm.assume(values.length > 0 && values.length <= keys.length);",
          "206:         _prepareKeys(keys, _KEY_MAX_GAP);",
          "208:         uint32 lastKey = keys.length == 0 ? 0 : keys[keys.length - 1];",
          "209:         lookup = _boundUint32(lookup, 0, lastKey + _KEY_MAX_GAP);",
          "211:         uint224 upper = 0;",
          "212:         uint224 lower = 0;",
          "213:         uint32 lowerKey = type(uint32).max;",
          "214:         for (uint256 i = 0; i < keys.length; ++i) {",
          "215:             uint32 key = keys[i];",
          "216:             uint224 value = values[i % values.length];",
          "219:             _ckpts.push(key, value);",
          "222:             if (key <= lookup) {",
          "223:                 upper = value;",
          "224:             }",
          "226:             if (key >= lookup && (i == 0 || keys[i - 1] < lookup)) {",
          "227:                 lowerKey = key;",
          "228:             }",
          "229:             if (key == lowerKey) {",
          "230:                 lower = value;",
          "231:             }",
          "232:         }",
          "235:         assertEq(_ckpts.lowerLookup(lookup), lower);",
          "236:         assertEq(_ckpts.upperLookup(lookup), upper);",
          "237:         assertEq(_ckpts.upperLookupRecent(lookup), upper);",
          "238:     }",
          "239: }",
          "241: contract CheckpointsTrace160Test is Test {",
          "242:     using Checkpoints for Checkpoints.Trace160;",
          "246:     uint8 internal constant _KEY_MAX_GAP = 64;",
          "248:     Checkpoints.Trace160 internal _ckpts;",
          "251:     function _boundUint96(uint96 x, uint96 min, uint96 max) internal view returns (uint96) {",
          "252:         return SafeCast.toUint96(bound(uint256(x), uint256(min), uint256(max)));",
          "253:     }",
          "255:     function _prepareKeys(uint96[] memory keys, uint96 maxSpread) internal view {",
          "256:         uint96 lastKey = 0;",
          "257:         for (uint256 i = 0; i < keys.length; ++i) {",
          "258:             uint96 key = _boundUint96(keys[i], lastKey, lastKey + maxSpread);",
          "259:             keys[i] = key;",
          "260:             lastKey = key;",
          "261:         }",
          "262:     }",
          "264:     function _assertLatestCheckpoint(bool exist, uint96 key, uint160 value) internal {",
          "265:         (bool _exist, uint96 _key, uint160 _value) = _ckpts.latestCheckpoint();",
          "266:         assertEq(_exist, exist);",
          "267:         assertEq(_key, key);",
          "268:         assertEq(_value, value);",
          "269:     }",
          "272:     function testPush(uint96[] memory keys, uint160[] memory values, uint96 pastKey) public {",
          "273:         vm.assume(values.length > 0 && values.length <= keys.length);",
          "274:         _prepareKeys(keys, _KEY_MAX_GAP);",
          "277:         assertEq(_ckpts.length(), 0);",
          "278:         assertEq(_ckpts.latest(), 0);",
          "279:         _assertLatestCheckpoint(false, 0, 0);",
          "281:         uint256 duplicates = 0;",
          "282:         for (uint256 i = 0; i < keys.length; ++i) {",
          "283:             uint96 key = keys[i];",
          "284:             uint160 value = values[i % values.length];",
          "285:             if (i > 0 && key == keys[i - 1]) ++duplicates;",
          "288:             _ckpts.push(key, value);",
          "291:             assertEq(_ckpts.length(), i + 1 - duplicates);",
          "292:             assertEq(_ckpts.latest(), value);",
          "293:             _assertLatestCheckpoint(true, key, value);",
          "294:         }",
          "296:         if (keys.length > 0) {",
          "297:             uint96 lastKey = keys[keys.length - 1];",
          "298:             if (lastKey > 0) {",
          "299:                 pastKey = _boundUint96(pastKey, 0, lastKey - 1);",
          "301:                 vm.expectRevert();",
          "302:                 this.push(pastKey, values[keys.length % values.length]);",
          "303:             }",
          "304:         }",
          "305:     }",
          "308:     function push(uint96 key, uint160 value) external {",
          "309:         _ckpts.push(key, value);",
          "310:     }",
          "312:     function testLookup(uint96[] memory keys, uint160[] memory values, uint96 lookup) public {",
          "313:         vm.assume(values.length > 0 && values.length <= keys.length);",
          "314:         _prepareKeys(keys, _KEY_MAX_GAP);",
          "316:         uint96 lastKey = keys.length == 0 ? 0 : keys[keys.length - 1];",
          "317:         lookup = _boundUint96(lookup, 0, lastKey + _KEY_MAX_GAP);",
          "319:         uint160 upper = 0;",
          "320:         uint160 lower = 0;",
          "321:         uint96 lowerKey = type(uint96).max;",
          "322:         for (uint256 i = 0; i < keys.length; ++i) {",
          "323:             uint96 key = keys[i];",
          "324:             uint160 value = values[i % values.length];",
          "327:             _ckpts.push(key, value);",
          "330:             if (key <= lookup) {",
          "331:                 upper = value;",
          "332:             }",
          "334:             if (key >= lookup && (i == 0 || keys[i - 1] < lookup)) {",
          "335:                 lowerKey = key;",
          "336:             }",
          "337:             if (key == lowerKey) {",
          "338:                 lower = value;",
          "339:             }",
          "340:         }",
          "343:         assertEq(_ckpts.lowerLookup(lookup), lower);",
          "344:         assertEq(_ckpts.upperLookup(lookup), upper);",
          "345:         assertEq(_ckpts.upperLookupRecent(lookup), upper);",
          "346:     }",
          "347: }",
          "",
          "---------------"
        ],
        "test/utils/Checkpoints.test.js||test/utils/Checkpoints.test.js": [
          "File: test/utils/Checkpoints.test.js -> test/utils/Checkpoints.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectRevert, time } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const { batchInBlock } = require('../helpers/txpool');",
          "7: const $Checkpoints = artifacts.require('$Checkpoints');",
          "10: const libraryName = $Checkpoints._json.contractName.replace(/^\\$/, '');",
          "12: const traceLengths = [160, 224];",
          "14: const first = array => (array.length ? array[0] : undefined);",
          "15: const last = array => (array.length ? array[array.length - 1] : undefined);",
          "17: contract('Checkpoints', function () {",
          "18:   beforeEach(async function () {",
          "19:     this.mock = await $Checkpoints.new();",
          "21:     this.methods = { trace: {} };",
          "22:     this.methods.history = {",
          "23:       latest: (...args) => this.mock.methods[`$latest_${libraryName}_History(uint256)`](0, ...args),",
          "24:       latestCheckpoint: (...args) => this.mock.methods[`$latestCheckpoint_${libraryName}_History(uint256)`](0, ...args),",
          "25:       length: (...args) => this.mock.methods[`$length_${libraryName}_History(uint256)`](0, ...args),",
          "26:       push: (...args) => this.mock.methods['$push(uint256,uint256)'](0, ...args),",
          "27:       getAtBlock: (...args) => this.mock.$getAtBlock(0, ...args),",
          "28:       getAtRecentBlock: (...args) => this.mock.$getAtProbablyRecentBlock(0, ...args),",
          "29:     };",
          "30:     for (const length of traceLengths) {",
          "31:       this.methods.trace[length] = {",
          "32:         latest: (...args) => this.mock.methods[`$latest_${libraryName}_Trace${length}(uint256)`](0, ...args),",
          "33:         latestCheckpoint: (...args) =>",
          "34:           this.mock.methods[`$latestCheckpoint_${libraryName}_Trace${length}(uint256)`](0, ...args),",
          "35:         length: (...args) => this.mock.methods[`$length_${libraryName}_Trace${length}(uint256)`](0, ...args),",
          "36:         push: (...args) => this.mock.methods[`$push(uint256,uint${256 - length},uint${length})`](0, ...args),",
          "37:         lowerLookup: (...args) => this.mock.methods[`$lowerLookup(uint256,uint${256 - length})`](0, ...args),",
          "38:         upperLookup: (...args) => this.mock.methods[`$upperLookup(uint256,uint${256 - length})`](0, ...args),",
          "39:         upperLookupRecent: (...args) =>",
          "40:           this.mock.methods[`$upperLookupRecent(uint256,uint${256 - length})`](0, ...args),",
          "41:       };",
          "42:     }",
          "43:   });",
          "45:   describe('History checkpoints', function () {",
          "46:     describe('without checkpoints', function () {",
          "47:       it('returns zero as latest value', async function () {",
          "48:         expect(await this.methods.history.latest()).to.be.bignumber.equal('0');",
          "50:         const ckpt = await this.methods.history.latestCheckpoint();",
          "51:         expect(ckpt[0]).to.be.equal(false);",
          "52:         expect(ckpt[1]).to.be.bignumber.equal('0');",
          "53:         expect(ckpt[2]).to.be.bignumber.equal('0');",
          "54:       });",
          "56:       it('returns zero as past value', async function () {",
          "57:         await time.advanceBlock();",
          "58:         expect(await this.methods.history.getAtBlock((await web3.eth.getBlockNumber()) - 1)).to.be.bignumber.equal('0');",
          "59:         expect(",
          "60:           await this.methods.history.getAtRecentBlock((await web3.eth.getBlockNumber()) - 1),",
          "61:         ).to.be.bignumber.equal('0');",
          "62:       });",
          "63:     });",
          "65:     describe('with checkpoints', function () {",
          "66:       beforeEach('pushing checkpoints', async function () {",
          "67:         this.tx1 = await this.methods.history.push(1);",
          "68:         this.tx2 = await this.methods.history.push(2);",
          "69:         await time.advanceBlock();",
          "70:         this.tx3 = await this.methods.history.push(3);",
          "71:         await time.advanceBlock();",
          "72:         await time.advanceBlock();",
          "73:       });",
          "75:       it('returns latest value', async function () {",
          "76:         expect(await this.methods.history.latest()).to.be.bignumber.equal('3');",
          "78:         const ckpt = await this.methods.history.latestCheckpoint();",
          "79:         expect(ckpt[0]).to.be.equal(true);",
          "80:         expect(ckpt[1]).to.be.bignumber.equal(web3.utils.toBN(this.tx3.receipt.blockNumber));",
          "81:         expect(ckpt[2]).to.be.bignumber.equal(web3.utils.toBN('3'));",
          "82:       });",
          "84:       for (const getAtBlockVariant of ['getAtBlock', 'getAtRecentBlock']) {",
          "85:         describe(`lookup: ${getAtBlockVariant}`, function () {",
          "86:           it('returns past values', async function () {",
          "87:             expect(",
          "88:               await this.methods.history[getAtBlockVariant](this.tx1.receipt.blockNumber - 1),",
          "89:             ).to.be.bignumber.equal('0');",
          "90:             expect(await this.methods.history[getAtBlockVariant](this.tx1.receipt.blockNumber)).to.be.bignumber.equal(",
          "91:               '1',",
          "92:             );",
          "93:             expect(await this.methods.history[getAtBlockVariant](this.tx2.receipt.blockNumber)).to.be.bignumber.equal(",
          "94:               '2',",
          "95:             );",
          "97:             expect(",
          "98:               await this.methods.history[getAtBlockVariant](this.tx2.receipt.blockNumber + 1),",
          "99:             ).to.be.bignumber.equal('2');",
          "100:             expect(await this.methods.history[getAtBlockVariant](this.tx3.receipt.blockNumber)).to.be.bignumber.equal(",
          "101:               '3',",
          "102:             );",
          "103:             expect(",
          "104:               await this.methods.history[getAtBlockVariant](this.tx3.receipt.blockNumber + 1),",
          "105:             ).to.be.bignumber.equal('3');",
          "106:           });",
          "107:           it('reverts if block number >= current block', async function () {",
          "108:             await expectRevert(",
          "109:               this.methods.history[getAtBlockVariant](await web3.eth.getBlockNumber()),",
          "110:               'Checkpoints: block not yet mined',",
          "111:             );",
          "113:             await expectRevert(",
          "114:               this.methods.history[getAtBlockVariant]((await web3.eth.getBlockNumber()) + 1),",
          "115:               'Checkpoints: block not yet mined',",
          "116:             );",
          "117:           });",
          "118:         });",
          "119:       }",
          "121:       it('multiple checkpoints in the same block', async function () {",
          "122:         const lengthBefore = await this.methods.history.length();",
          "124:         await batchInBlock([",
          "125:           () => this.methods.history.push(8, { gas: 100000 }),",
          "126:           () => this.methods.history.push(9, { gas: 100000 }),",
          "127:           () => this.methods.history.push(10, { gas: 100000 }),",
          "128:         ]);",
          "130:         expect(await this.methods.history.length()).to.be.bignumber.equal(lengthBefore.addn(1));",
          "131:         expect(await this.methods.history.latest()).to.be.bignumber.equal('10');",
          "132:       });",
          "134:       it('more than 5 checkpoints', async function () {",
          "135:         for (let i = 4; i <= 6; i++) {",
          "136:           await this.methods.history.push(i);",
          "137:         }",
          "138:         expect(await this.methods.history.length()).to.be.bignumber.equal('6');",
          "139:         const block = await web3.eth.getBlockNumber();",
          "141:         expect(await this.methods.history.getAtRecentBlock(block - 1)).to.be.bignumber.equal('5');",
          "143:         expect(await this.methods.history.getAtRecentBlock(block - 9)).to.be.bignumber.equal('0');",
          "144:       });",
          "145:     });",
          "146:   });",
          "148:   for (const length of traceLengths) {",
          "149:     describe(`Trace${length}`, function () {",
          "150:       describe('without checkpoints', function () {",
          "151:         it('returns zero as latest value', async function () {",
          "152:           expect(await this.methods.trace[length].latest()).to.be.bignumber.equal('0');",
          "154:           const ckpt = await this.methods.trace[length].latestCheckpoint();",
          "155:           expect(ckpt[0]).to.be.equal(false);",
          "156:           expect(ckpt[1]).to.be.bignumber.equal('0');",
          "157:           expect(ckpt[2]).to.be.bignumber.equal('0');",
          "158:         });",
          "160:         it('lookup returns 0', async function () {",
          "161:           expect(await this.methods.trace[length].lowerLookup(0)).to.be.bignumber.equal('0');",
          "162:           expect(await this.methods.trace[length].upperLookup(0)).to.be.bignumber.equal('0');",
          "163:           expect(await this.methods.trace[length].upperLookupRecent(0)).to.be.bignumber.equal('0');",
          "164:         });",
          "165:       });",
          "167:       describe('with checkpoints', function () {",
          "168:         beforeEach('pushing checkpoints', async function () {",
          "169:           this.checkpoints = [",
          "170:             { key: '2', value: '17' },",
          "171:             { key: '3', value: '42' },",
          "172:             { key: '5', value: '101' },",
          "173:             { key: '7', value: '23' },",
          "174:             { key: '11', value: '99' },",
          "175:           ];",
          "176:           for (const { key, value } of this.checkpoints) {",
          "177:             await this.methods.trace[length].push(key, value);",
          "178:           }",
          "179:         });",
          "181:         it('length', async function () {",
          "182:           expect(await this.methods.trace[length].length()).to.be.bignumber.equal(this.checkpoints.length.toString());",
          "183:         });",
          "185:         it('returns latest value', async function () {",
          "186:           expect(await this.methods.trace[length].latest()).to.be.bignumber.equal(last(this.checkpoints).value);",
          "188:           const ckpt = await this.methods.trace[length].latestCheckpoint();",
          "189:           expect(ckpt[0]).to.be.equal(true);",
          "190:           expect(ckpt[1]).to.be.bignumber.equal(last(this.checkpoints).key);",
          "191:           expect(ckpt[2]).to.be.bignumber.equal(last(this.checkpoints).value);",
          "192:         });",
          "194:         it('cannot push values in the past', async function () {",
          "195:           await expectRevert(",
          "196:             this.methods.trace[length].push(last(this.checkpoints).key - 1, '0'),",
          "197:             'Checkpoint: decreasing keys',",
          "198:           );",
          "199:         });",
          "201:         it('can update last value', async function () {",
          "202:           const newValue = '42';",
          "205:           expect(await this.methods.trace[length].length()).to.be.bignumber.equal(this.checkpoints.length.toString());",
          "208:           await this.methods.trace[length].push(last(this.checkpoints).key, newValue);",
          "209:           expect(await this.methods.trace[length].latest()).to.be.bignumber.equal(newValue);",
          "212:           expect(await this.methods.trace[length].length()).to.be.bignumber.equal(this.checkpoints.length.toString());",
          "213:         });",
          "215:         it('lower lookup', async function () {",
          "216:           for (let i = 0; i < 14; ++i) {",
          "217:             const value = first(this.checkpoints.filter(x => i <= x.key))?.value || '0';",
          "219:             expect(await this.methods.trace[length].lowerLookup(i)).to.be.bignumber.equal(value);",
          "220:           }",
          "221:         });",
          "223:         it('upper lookup & upperLookupRecent', async function () {",
          "224:           for (let i = 0; i < 14; ++i) {",
          "225:             const value = last(this.checkpoints.filter(x => i >= x.key))?.value || '0';",
          "227:             expect(await this.methods.trace[length].upperLookup(i)).to.be.bignumber.equal(value);",
          "228:             expect(await this.methods.trace[length].upperLookupRecent(i)).to.be.bignumber.equal(value);",
          "229:           }",
          "230:         });",
          "232:         it('upperLookupRecent with more than 5 checkpoints', async function () {",
          "233:           const moreCheckpoints = [",
          "234:             { key: '12', value: '22' },",
          "235:             { key: '13', value: '131' },",
          "236:             { key: '17', value: '45' },",
          "237:             { key: '19', value: '31452' },",
          "238:             { key: '21', value: '0' },",
          "239:           ];",
          "240:           const allCheckpoints = [].concat(this.checkpoints, moreCheckpoints);",
          "242:           for (const { key, value } of moreCheckpoints) {",
          "243:             await this.methods.trace[length].push(key, value);",
          "244:           }",
          "246:           for (let i = 0; i < 25; ++i) {",
          "247:             const value = last(allCheckpoints.filter(x => i >= x.key))?.value || '0';",
          "248:             expect(await this.methods.trace[length].upperLookup(i)).to.be.bignumber.equal(value);",
          "249:             expect(await this.methods.trace[length].upperLookupRecent(i)).to.be.bignumber.equal(value);",
          "250:           }",
          "251:         });",
          "252:       });",
          "253:     });",
          "254:   }",
          "255: });",
          "",
          "---------------"
        ],
        "test/utils/Context.behavior.js||test/utils/Context.behavior.js": [
          "File: test/utils/Context.behavior.js -> test/utils/Context.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, expectEvent } = require('@openzeppelin/test-helpers');",
          "3: const ContextMock = artifacts.require('ContextMock');",
          "5: function shouldBehaveLikeRegularContext(sender) {",
          "6:   describe('msgSender', function () {",
          "7:     it('returns the transaction sender when called from an EOA', async function () {",
          "8:       const receipt = await this.context.msgSender({ from: sender });",
          "9:       expectEvent(receipt, 'Sender', { sender });",
          "10:     });",
          "12:     it('returns the transaction sender when from another contract', async function () {",
          "13:       const { tx } = await this.caller.callSender(this.context.address, { from: sender });",
          "14:       await expectEvent.inTransaction(tx, ContextMock, 'Sender', { sender: this.caller.address });",
          "15:     });",
          "16:   });",
          "18:   describe('msgData', function () {",
          "19:     const integerValue = new BN('42');",
          "20:     const stringValue = 'OpenZeppelin';",
          "22:     let callData;",
          "24:     beforeEach(async function () {",
          "25:       callData = this.context.contract.methods.msgData(integerValue.toString(), stringValue).encodeABI();",
          "26:     });",
          "28:     it('returns the transaction data when called from an EOA', async function () {",
          "29:       const receipt = await this.context.msgData(integerValue, stringValue);",
          "30:       expectEvent(receipt, 'Data', { data: callData, integerValue, stringValue });",
          "31:     });",
          "33:     it('returns the transaction sender when from another contract', async function () {",
          "34:       const { tx } = await this.caller.callData(this.context.address, integerValue, stringValue);",
          "35:       await expectEvent.inTransaction(tx, ContextMock, 'Data', { data: callData, integerValue, stringValue });",
          "36:     });",
          "37:   });",
          "38: }",
          "40: module.exports = {",
          "41:   shouldBehaveLikeRegularContext,",
          "42: };",
          "",
          "---------------"
        ],
        "test/utils/Context.test.js||test/utils/Context.test.js": [
          "File: test/utils/Context.test.js -> test/utils/Context.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: require('@openzeppelin/test-helpers');",
          "3: const ContextMock = artifacts.require('ContextMock');",
          "4: const ContextMockCaller = artifacts.require('ContextMockCaller');",
          "6: const { shouldBehaveLikeRegularContext } = require('./Context.behavior');",
          "8: contract('Context', function (accounts) {",
          "9:   const [sender] = accounts;",
          "11:   beforeEach(async function () {",
          "12:     this.context = await ContextMock.new();",
          "13:     this.caller = await ContextMockCaller.new();",
          "14:   });",
          "16:   shouldBehaveLikeRegularContext(sender);",
          "17: });",
          "",
          "---------------"
        ],
        "test/utils/Counters.test.js||test/utils/Counters.test.js": [
          "File: test/utils/Counters.test.js -> test/utils/Counters.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const Counters = artifacts.require('$Counters');",
          "7: contract('Counters', function () {",
          "8:   beforeEach(async function () {",
          "9:     this.counter = await Counters.new();",
          "10:   });",
          "12:   it('starts at zero', async function () {",
          "13:     expect(await this.counter.$current(0)).to.be.bignumber.equal('0');",
          "14:   });",
          "16:   describe('increment', function () {",
          "17:     context('starting from 0', function () {",
          "18:       it('increments the current value by one', async function () {",
          "19:         await this.counter.$increment(0);",
          "20:         expect(await this.counter.$current(0)).to.be.bignumber.equal('1');",
          "21:       });",
          "23:       it('can be called multiple times', async function () {",
          "24:         await this.counter.$increment(0);",
          "25:         await this.counter.$increment(0);",
          "26:         await this.counter.$increment(0);",
          "28:         expect(await this.counter.$current(0)).to.be.bignumber.equal('3');",
          "29:       });",
          "30:     });",
          "31:   });",
          "33:   describe('decrement', function () {",
          "34:     beforeEach(async function () {",
          "35:       await this.counter.$increment(0);",
          "36:       expect(await this.counter.$current(0)).to.be.bignumber.equal('1');",
          "37:     });",
          "38:     context('starting from 1', function () {",
          "39:       it('decrements the current value by one', async function () {",
          "40:         await this.counter.$decrement(0);",
          "41:         expect(await this.counter.$current(0)).to.be.bignumber.equal('0');",
          "42:       });",
          "44:       it('reverts if the current value is 0', async function () {",
          "45:         await this.counter.$decrement(0);",
          "46:         await expectRevert(this.counter.$decrement(0), 'Counter: decrement overflow');",
          "47:       });",
          "48:     });",
          "49:     context('after incremented to 3', function () {",
          "50:       it('can be called multiple times', async function () {",
          "51:         await this.counter.$increment(0);",
          "52:         await this.counter.$increment(0);",
          "54:         expect(await this.counter.$current(0)).to.be.bignumber.equal('3');",
          "56:         await this.counter.$decrement(0);",
          "57:         await this.counter.$decrement(0);",
          "58:         await this.counter.$decrement(0);",
          "60:         expect(await this.counter.$current(0)).to.be.bignumber.equal('0');",
          "61:       });",
          "62:     });",
          "63:   });",
          "65:   describe('reset', function () {",
          "66:     context('null counter', function () {",
          "67:       it('does not throw', async function () {",
          "68:         await this.counter.$reset(0);",
          "69:         expect(await this.counter.$current(0)).to.be.bignumber.equal('0');",
          "70:       });",
          "71:     });",
          "73:     context('non null counter', function () {",
          "74:       beforeEach(async function () {",
          "75:         await this.counter.$increment(0);",
          "76:         expect(await this.counter.$current(0)).to.be.bignumber.equal('1');",
          "77:       });",
          "78:       it('reset to 0', async function () {",
          "79:         await this.counter.$reset(0);",
          "80:         expect(await this.counter.$current(0)).to.be.bignumber.equal('0');",
          "81:       });",
          "82:     });",
          "83:   });",
          "84: });",
          "",
          "---------------"
        ],
        "test/utils/Create2.test.js||test/utils/Create2.test.js": [
          "File: test/utils/Create2.test.js -> test/utils/Create2.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { balance, ether, expectEvent, expectRevert, send } = require('@openzeppelin/test-helpers');",
          "2: const { computeCreate2Address } = require('../helpers/create2');",
          "3: const { expect } = require('chai');",
          "5: const Create2 = artifacts.require('$Create2');",
          "6: const VestingWallet = artifacts.require('VestingWallet');",
          "7: const ERC1820Implementer = artifacts.require('$ERC1820Implementer');",
          "9: contract('Create2', function (accounts) {",
          "10:   const [deployerAccount, other] = accounts;",
          "12:   const salt = 'salt message';",
          "13:   const saltHex = web3.utils.soliditySha3(salt);",
          "15:   const encodedParams = web3.eth.abi.encodeParameters(['address', 'uint64', 'uint64'], [other, 0, 0]).slice(2);",
          "17:   const constructorByteCode = `${VestingWallet.bytecode}${encodedParams}`;",
          "19:   beforeEach(async function () {",
          "20:     this.factory = await Create2.new();",
          "21:   });",
          "22:   describe('computeAddress', function () {",
          "23:     it('computes the correct contract address', async function () {",
          "24:       const onChainComputed = await this.factory.$computeAddress(saltHex, web3.utils.keccak256(constructorByteCode));",
          "25:       const offChainComputed = computeCreate2Address(saltHex, constructorByteCode, this.factory.address);",
          "26:       expect(onChainComputed).to.equal(offChainComputed);",
          "27:     });",
          "29:     it('computes the correct contract address with deployer', async function () {",
          "30:       const onChainComputed = await this.factory.$computeAddress(",
          "31:         saltHex,",
          "32:         web3.utils.keccak256(constructorByteCode),",
          "33:         deployerAccount,",
          "34:       );",
          "35:       const offChainComputed = computeCreate2Address(saltHex, constructorByteCode, deployerAccount);",
          "36:       expect(onChainComputed).to.equal(offChainComputed);",
          "37:     });",
          "38:   });",
          "40:   describe('deploy', function () {",
          "41:     it('deploys a ERC1820Implementer from inline assembly code', async function () {",
          "42:       const offChainComputed = computeCreate2Address(saltHex, ERC1820Implementer.bytecode, this.factory.address);",
          "44:       expectEvent(await this.factory.$deploy(0, saltHex, ERC1820Implementer.bytecode), 'return$deploy', {",
          "45:         addr: offChainComputed,",
          "46:       });",
          "48:       expect(ERC1820Implementer.bytecode).to.include((await web3.eth.getCode(offChainComputed)).slice(2));",
          "49:     });",
          "51:     it('deploys a contract with constructor arguments', async function () {",
          "52:       const offChainComputed = computeCreate2Address(saltHex, constructorByteCode, this.factory.address);",
          "54:       expectEvent(await this.factory.$deploy(0, saltHex, constructorByteCode), 'return$deploy', {",
          "55:         addr: offChainComputed,",
          "56:       });",
          "58:       expect(await VestingWallet.at(offChainComputed).then(instance => instance.beneficiary())).to.be.equal(other);",
          "59:     });",
          "61:     it('deploys a contract with funds deposited in the factory', async function () {",
          "62:       const deposit = ether('2');",
          "63:       await send.ether(deployerAccount, this.factory.address, deposit);",
          "64:       expect(await balance.current(this.factory.address)).to.be.bignumber.equal(deposit);",
          "66:       const offChainComputed = computeCreate2Address(saltHex, constructorByteCode, this.factory.address);",
          "68:       expectEvent(await this.factory.$deploy(deposit, saltHex, constructorByteCode), 'return$deploy', {",
          "69:         addr: offChainComputed,",
          "70:       });",
          "72:       expect(await balance.current(offChainComputed)).to.be.bignumber.equal(deposit);",
          "73:     });",
          "75:     it('fails deploying a contract in an existent address', async function () {",
          "76:       expectEvent(await this.factory.$deploy(0, saltHex, constructorByteCode), 'return$deploy');",
          "78:       await expectRevert(this.factory.$deploy(0, saltHex, constructorByteCode), 'Create2: Failed on deploy');",
          "79:     });",
          "81:     it('fails deploying a contract if the bytecode length is zero', async function () {",
          "82:       await expectRevert(this.factory.$deploy(0, saltHex, '0x'), 'Create2: bytecode length is zero');",
          "83:     });",
          "85:     it('fails deploying a contract if factory contract does not have sufficient balance', async function () {",
          "86:       await expectRevert(this.factory.$deploy(1, saltHex, constructorByteCode), 'Create2: insufficient balance');",
          "87:     });",
          "88:   });",
          "89: });",
          "",
          "---------------"
        ],
        "test/utils/Multicall.test.js||test/utils/Multicall.test.js": [
          "File: test/utils/Multicall.test.js -> test/utils/Multicall.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const ERC20MulticallMock = artifacts.require('$ERC20MulticallMock');",
          "5: contract('Multicall', function (accounts) {",
          "6:   const [deployer, alice, bob] = accounts;",
          "7:   const amount = 12000;",
          "9:   beforeEach(async function () {",
          "10:     this.multicallToken = await ERC20MulticallMock.new('name', 'symbol');",
          "11:     await this.multicallToken.$_mint(deployer, amount);",
          "12:   });",
          "14:   it('batches function calls', async function () {",
          "15:     expect(await this.multicallToken.balanceOf(alice)).to.be.bignumber.equal(new BN('0'));",
          "16:     expect(await this.multicallToken.balanceOf(bob)).to.be.bignumber.equal(new BN('0'));",
          "18:     await this.multicallToken.multicall(",
          "19:       [",
          "20:         this.multicallToken.contract.methods.transfer(alice, amount / 2).encodeABI(),",
          "21:         this.multicallToken.contract.methods.transfer(bob, amount / 3).encodeABI(),",
          "22:       ],",
          "23:       { from: deployer },",
          "24:     );",
          "26:     expect(await this.multicallToken.balanceOf(alice)).to.be.bignumber.equal(new BN(amount / 2));",
          "27:     expect(await this.multicallToken.balanceOf(bob)).to.be.bignumber.equal(new BN(amount / 3));",
          "28:   });",
          "30:   it('returns an array with the result of each call', async function () {",
          "31:     const MulticallTest = artifacts.require('MulticallTest');",
          "32:     const multicallTest = await MulticallTest.new({ from: deployer });",
          "33:     await this.multicallToken.transfer(multicallTest.address, amount, { from: deployer });",
          "34:     expect(await this.multicallToken.balanceOf(multicallTest.address)).to.be.bignumber.equal(new BN(amount));",
          "36:     const recipients = [alice, bob];",
          "37:     const amounts = [amount / 2, amount / 3].map(n => new BN(n));",
          "39:     await multicallTest.checkReturnValues(this.multicallToken.address, recipients, amounts);",
          "40:   });",
          "42:   it('reverts previous calls', async function () {",
          "43:     expect(await this.multicallToken.balanceOf(alice)).to.be.bignumber.equal(new BN('0'));",
          "45:     const call = this.multicallToken.multicall(",
          "46:       [",
          "47:         this.multicallToken.contract.methods.transfer(alice, amount).encodeABI(),",
          "48:         this.multicallToken.contract.methods.transfer(bob, amount).encodeABI(),",
          "49:       ],",
          "50:       { from: deployer },",
          "51:     );",
          "53:     await expectRevert(call, 'ERC20: transfer amount exceeds balance');",
          "54:     expect(await this.multicallToken.balanceOf(alice)).to.be.bignumber.equal(new BN('0'));",
          "55:   });",
          "57:   it('bubbles up revert reasons', async function () {",
          "58:     const call = this.multicallToken.multicall(",
          "59:       [",
          "60:         this.multicallToken.contract.methods.transfer(alice, amount).encodeABI(),",
          "61:         this.multicallToken.contract.methods.transfer(bob, amount).encodeABI(),",
          "62:       ],",
          "63:       { from: deployer },",
          "64:     );",
          "66:     await expectRevert(call, 'ERC20: transfer amount exceeds balance');",
          "67:   });",
          "68: });",
          "",
          "---------------"
        ],
        "test/utils/ShortStrings.t.sol||test/utils/ShortStrings.t.sol": [
          "File: test/utils/ShortStrings.t.sol -> test/utils/ShortStrings.t.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"forge-std/Test.sol\";",
          "7: import \"../../contracts/utils/ShortStrings.sol\";",
          "9: contract ShortStringsTest is Test {",
          "10:     string _fallback;",
          "12:     function testRoundtripShort(string memory input) external {",
          "13:         vm.assume(_isShort(input));",
          "14:         ShortString short = ShortStrings.toShortString(input);",
          "15:         string memory output = ShortStrings.toString(short);",
          "16:         assertEq(input, output);",
          "17:     }",
          "19:     function testRoundtripWithFallback(string memory input, string memory fallbackInitial) external {",
          "20:         _fallback = fallbackInitial; // Make sure that the initial value has no effect",
          "21:         ShortString short = ShortStrings.toShortStringWithFallback(input, _fallback);",
          "22:         string memory output = ShortStrings.toStringWithFallback(short, _fallback);",
          "23:         assertEq(input, output);",
          "24:     }",
          "26:     function testRevertLong(string memory input) external {",
          "27:         vm.assume(!_isShort(input));",
          "28:         vm.expectRevert(abi.encodeWithSelector(ShortStrings.StringTooLong.selector, input));",
          "29:         this.toShortString(input);",
          "30:     }",
          "32:     function testLengthShort(string memory input) external {",
          "33:         vm.assume(_isShort(input));",
          "34:         uint256 inputLength = bytes(input).length;",
          "35:         ShortString short = ShortStrings.toShortString(input);",
          "36:         uint256 shortLength = ShortStrings.byteLength(short);",
          "37:         assertEq(inputLength, shortLength);",
          "38:     }",
          "40:     function testLengthWithFallback(string memory input, string memory fallbackInitial) external {",
          "41:         _fallback = fallbackInitial;",
          "42:         uint256 inputLength = bytes(input).length;",
          "43:         ShortString short = ShortStrings.toShortStringWithFallback(input, _fallback);",
          "44:         uint256 shortLength = ShortStrings.byteLengthWithFallback(short, _fallback);",
          "45:         assertEq(inputLength, shortLength);",
          "46:     }",
          "48:     function toShortString(string memory input) external pure returns (ShortString) {",
          "49:         return ShortStrings.toShortString(input);",
          "50:     }",
          "52:     function _isShort(string memory input) internal pure returns (bool) {",
          "53:         return bytes(input).length < 32;",
          "54:     }",
          "55: }",
          "",
          "---------------"
        ],
        "test/utils/ShortStrings.test.js||test/utils/ShortStrings.test.js": [
          "File: test/utils/ShortStrings.test.js -> test/utils/ShortStrings.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expect } = require('chai');",
          "2: const { expectRevertCustomError } = require('../helpers/customError');",
          "4: const ShortStrings = artifacts.require('$ShortStrings');",
          "6: function length(sstr) {",
          "7:   return parseInt(sstr.slice(64), 16);",
          "8: }",
          "10: function decode(sstr) {",
          "11:   return web3.utils.toUtf8(sstr).slice(0, length(sstr));",
          "12: }",
          "14: contract('ShortStrings', function () {",
          "15:   before(async function () {",
          "16:     this.mock = await ShortStrings.new();",
          "17:   });",
          "19:   for (const str of [0, 1, 16, 31, 32, 64, 1024].map(length => 'a'.repeat(length))) {",
          "20:     describe(`with string length ${str.length}`, function () {",
          "21:       it('encode / decode', async function () {",
          "22:         if (str.length < 32) {",
          "23:           const encoded = await this.mock.$toShortString(str);",
          "24:           expect(decode(encoded)).to.be.equal(str);",
          "26:           const length = await this.mock.$byteLength(encoded);",
          "27:           expect(length.toNumber()).to.be.equal(str.length);",
          "29:           const decoded = await this.mock.$toString(encoded);",
          "30:           expect(decoded).to.be.equal(str);",
          "31:         } else {",
          "32:           await expectRevertCustomError(this.mock.$toShortString(str), `StringTooLong(\"${str}\")`);",
          "33:         }",
          "34:       });",
          "36:       it('set / get with fallback', async function () {",
          "37:         const { logs } = await this.mock.$toShortStringWithFallback(str, 0);",
          "38:         const { ret0 } = logs.find(({ event }) => event == 'return$toShortStringWithFallback').args;",
          "40:         const promise = this.mock.$toString(ret0);",
          "41:         if (str.length < 32) {",
          "42:           expect(await promise).to.be.equal(str);",
          "43:         } else {",
          "44:           await expectRevertCustomError(promise, 'InvalidShortString()');",
          "45:         }",
          "47:         const length = await this.mock.$byteLengthWithFallback(ret0, 0);",
          "48:         expect(length.toNumber()).to.be.equal(str.length);",
          "50:         const recovered = await this.mock.$toStringWithFallback(ret0, 0);",
          "51:         expect(recovered).to.be.equal(str);",
          "52:       });",
          "53:     });",
          "54:   }",
          "55: });",
          "",
          "---------------"
        ],
        "test/utils/StorageSlot.test.js||test/utils/StorageSlot.test.js": [
          "File: test/utils/StorageSlot.test.js -> test/utils/StorageSlot.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { constants, BN } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const StorageSlotMock = artifacts.require('StorageSlotMock');",
          "7: const slot = web3.utils.keccak256('some.storage.slot');",
          "8: const otherSlot = web3.utils.keccak256('some.other.storage.slot');",
          "10: contract('StorageSlot', function (accounts) {",
          "11:   beforeEach(async function () {",
          "12:     this.store = await StorageSlotMock.new();",
          "13:   });",
          "15:   describe('boolean storage slot', function () {",
          "16:     beforeEach(async function () {",
          "17:       this.value = true;",
          "18:     });",
          "20:     it('set', async function () {",
          "21:       await this.store.setBoolean(slot, this.value);",
          "22:     });",
          "24:     describe('get', function () {",
          "25:       beforeEach(async function () {",
          "26:         await this.store.setBoolean(slot, this.value);",
          "27:       });",
          "29:       it('from right slot', async function () {",
          "30:         expect(await this.store.getBoolean(slot)).to.be.equal(this.value);",
          "31:       });",
          "33:       it('from other slot', async function () {",
          "34:         expect(await this.store.getBoolean(otherSlot)).to.be.equal(false);",
          "35:       });",
          "36:     });",
          "37:   });",
          "39:   describe('address storage slot', function () {",
          "40:     beforeEach(async function () {",
          "41:       this.value = accounts[1];",
          "42:     });",
          "44:     it('set', async function () {",
          "45:       await this.store.setAddress(slot, this.value);",
          "46:     });",
          "48:     describe('get', function () {",
          "49:       beforeEach(async function () {",
          "50:         await this.store.setAddress(slot, this.value);",
          "51:       });",
          "53:       it('from right slot', async function () {",
          "54:         expect(await this.store.getAddress(slot)).to.be.equal(this.value);",
          "55:       });",
          "57:       it('from other slot', async function () {",
          "58:         expect(await this.store.getAddress(otherSlot)).to.be.equal(constants.ZERO_ADDRESS);",
          "59:       });",
          "60:     });",
          "61:   });",
          "63:   describe('bytes32 storage slot', function () {",
          "64:     beforeEach(async function () {",
          "65:       this.value = web3.utils.keccak256('some byte32 value');",
          "66:     });",
          "68:     it('set', async function () {",
          "69:       await this.store.setBytes32(slot, this.value);",
          "70:     });",
          "72:     describe('get', function () {",
          "73:       beforeEach(async function () {",
          "74:         await this.store.setBytes32(slot, this.value);",
          "75:       });",
          "77:       it('from right slot', async function () {",
          "78:         expect(await this.store.getBytes32(slot)).to.be.equal(this.value);",
          "79:       });",
          "81:       it('from other slot', async function () {",
          "82:         expect(await this.store.getBytes32(otherSlot)).to.be.equal(constants.ZERO_BYTES32);",
          "83:       });",
          "84:     });",
          "85:   });",
          "87:   describe('uint256 storage slot', function () {",
          "88:     beforeEach(async function () {",
          "89:       this.value = new BN(1742);",
          "90:     });",
          "92:     it('set', async function () {",
          "93:       await this.store.setUint256(slot, this.value);",
          "94:     });",
          "96:     describe('get', function () {",
          "97:       beforeEach(async function () {",
          "98:         await this.store.setUint256(slot, this.value);",
          "99:       });",
          "101:       it('from right slot', async function () {",
          "102:         expect(await this.store.getUint256(slot)).to.be.bignumber.equal(this.value);",
          "103:       });",
          "105:       it('from other slot', async function () {",
          "106:         expect(await this.store.getUint256(otherSlot)).to.be.bignumber.equal('0');",
          "107:       });",
          "108:     });",
          "109:   });",
          "111:   describe('string storage slot', function () {",
          "112:     beforeEach(async function () {",
          "113:       this.value = 'lorem ipsum';",
          "114:     });",
          "116:     it('set', async function () {",
          "117:       await this.store.setString(slot, this.value);",
          "118:     });",
          "120:     describe('get', function () {",
          "121:       beforeEach(async function () {",
          "122:         await this.store.setString(slot, this.value);",
          "123:       });",
          "125:       it('from right slot', async function () {",
          "126:         expect(await this.store.getString(slot)).to.be.equal(this.value);",
          "127:       });",
          "129:       it('from other slot', async function () {",
          "130:         expect(await this.store.getString(otherSlot)).to.be.equal('');",
          "131:       });",
          "132:     });",
          "133:   });",
          "135:   describe('string storage pointer', function () {",
          "136:     beforeEach(async function () {",
          "137:       this.value = 'lorem ipsum';",
          "138:     });",
          "140:     it('set', async function () {",
          "141:       await this.store.setStringStorage(slot, this.value);",
          "142:     });",
          "144:     describe('get', function () {",
          "145:       beforeEach(async function () {",
          "146:         await this.store.setStringStorage(slot, this.value);",
          "147:       });",
          "149:       it('from right slot', async function () {",
          "150:         expect(await this.store.stringMap(slot)).to.be.equal(this.value);",
          "151:         expect(await this.store.getStringStorage(slot)).to.be.equal(this.value);",
          "152:       });",
          "154:       it('from other slot', async function () {",
          "155:         expect(await this.store.stringMap(otherSlot)).to.be.equal('');",
          "156:         expect(await this.store.getStringStorage(otherSlot)).to.be.equal('');",
          "157:       });",
          "158:     });",
          "159:   });",
          "161:   describe('bytes storage slot', function () {",
          "162:     beforeEach(async function () {",
          "163:       this.value = web3.utils.randomHex(128);",
          "164:     });",
          "166:     it('set', async function () {",
          "167:       await this.store.setBytes(slot, this.value);",
          "168:     });",
          "170:     describe('get', function () {",
          "171:       beforeEach(async function () {",
          "172:         await this.store.setBytes(slot, this.value);",
          "173:       });",
          "175:       it('from right slot', async function () {",
          "176:         expect(await this.store.getBytes(slot)).to.be.equal(this.value);",
          "177:       });",
          "179:       it('from other slot', async function () {",
          "180:         expect(await this.store.getBytes(otherSlot)).to.be.equal(null);",
          "181:       });",
          "182:     });",
          "183:   });",
          "185:   describe('bytes storage pointer', function () {",
          "186:     beforeEach(async function () {",
          "187:       this.value = web3.utils.randomHex(128);",
          "188:     });",
          "190:     it('set', async function () {",
          "191:       await this.store.setBytesStorage(slot, this.value);",
          "192:     });",
          "194:     describe('get', function () {",
          "195:       beforeEach(async function () {",
          "196:         await this.store.setBytesStorage(slot, this.value);",
          "197:       });",
          "199:       it('from right slot', async function () {",
          "200:         expect(await this.store.bytesMap(slot)).to.be.equal(this.value);",
          "201:         expect(await this.store.getBytesStorage(slot)).to.be.equal(this.value);",
          "202:       });",
          "204:       it('from other slot', async function () {",
          "205:         expect(await this.store.bytesMap(otherSlot)).to.be.equal(null);",
          "206:         expect(await this.store.getBytesStorage(otherSlot)).to.be.equal(null);",
          "207:       });",
          "208:     });",
          "209:   });",
          "210: });",
          "",
          "---------------"
        ],
        "test/utils/Strings.test.js||test/utils/Strings.test.js": [
          "File: test/utils/Strings.test.js -> test/utils/Strings.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const Strings = artifacts.require('$Strings');",
          "7: contract('Strings', function () {",
          "8:   before(async function () {",
          "9:     this.strings = await Strings.new();",
          "10:   });",
          "12:   describe('toString', function () {",
          "13:     const values = [",
          "14:       '0',",
          "15:       '7',",
          "16:       '10',",
          "17:       '99',",
          "18:       '100',",
          "19:       '101',",
          "20:       '123',",
          "21:       '4132',",
          "22:       '12345',",
          "23:       '1234567',",
          "24:       '1234567890',",
          "25:       '123456789012345',",
          "26:       '12345678901234567890',",
          "27:       '123456789012345678901234567890',",
          "28:       '1234567890123456789012345678901234567890',",
          "29:       '12345678901234567890123456789012345678901234567890',",
          "30:       '123456789012345678901234567890123456789012345678901234567890',",
          "31:       '1234567890123456789012345678901234567890123456789012345678901234567890',",
          "32:     ];",
          "34:     describe('uint256', function () {",
          "35:       it('converts MAX_UINT256', async function () {",
          "36:         const value = constants.MAX_UINT256;",
          "37:         expect(await this.strings.methods['$toString(uint256)'](value)).to.equal(value.toString(10));",
          "38:       });",
          "40:       for (const value of values) {",
          "41:         it(`converts ${value}`, async function () {",
          "42:           expect(await this.strings.methods['$toString(uint256)'](value)).to.equal(value);",
          "43:         });",
          "44:       }",
          "45:     });",
          "47:     describe('int256', function () {",
          "48:       it('converts MAX_INT256', async function () {",
          "49:         const value = constants.MAX_INT256;",
          "50:         expect(await this.strings.methods['$toString(int256)'](value)).to.equal(value.toString(10));",
          "51:       });",
          "53:       it('converts MIN_INT256', async function () {",
          "54:         const value = constants.MIN_INT256;",
          "55:         expect(await this.strings.methods['$toString(int256)'](value)).to.equal(value.toString(10));",
          "56:       });",
          "58:       for (const value of values) {",
          "59:         it(`convert ${value}`, async function () {",
          "60:           expect(await this.strings.methods['$toString(int256)'](value)).to.equal(value);",
          "61:         });",
          "63:         it(`convert negative ${value}`, async function () {",
          "64:           const negated = new BN(value).neg();",
          "65:           expect(await this.strings.methods['$toString(int256)'](negated)).to.equal(negated.toString(10));",
          "66:         });",
          "67:       }",
          "68:     });",
          "69:   });",
          "71:   describe('toHexString', function () {",
          "72:     it('converts 0', async function () {",
          "73:       expect(await this.strings.methods['$toHexString(uint256)'](0)).to.equal('0x00');",
          "74:     });",
          "76:     it('converts a positive number', async function () {",
          "77:       expect(await this.strings.methods['$toHexString(uint256)'](0x4132)).to.equal('0x4132');",
          "78:     });",
          "80:     it('converts MAX_UINT256', async function () {",
          "81:       expect(await this.strings.methods['$toHexString(uint256)'](constants.MAX_UINT256)).to.equal(",
          "82:         web3.utils.toHex(constants.MAX_UINT256),",
          "83:       );",
          "84:     });",
          "85:   });",
          "87:   describe('toHexString fixed', function () {",
          "88:     it('converts a positive number (long)', async function () {",
          "89:       expect(await this.strings.methods['$toHexString(uint256,uint256)'](0x4132, 32)).to.equal(",
          "90:         '0x0000000000000000000000000000000000000000000000000000000000004132',",
          "91:       );",
          "92:     });",
          "94:     it('converts a positive number (short)', async function () {",
          "95:       await expectRevert(",
          "96:         this.strings.methods['$toHexString(uint256,uint256)'](0x4132, 1),",
          "97:         'Strings: hex length insufficient',",
          "98:       );",
          "99:     });",
          "101:     it('converts MAX_UINT256', async function () {",
          "102:       expect(await this.strings.methods['$toHexString(uint256,uint256)'](constants.MAX_UINT256, 32)).to.equal(",
          "103:         web3.utils.toHex(constants.MAX_UINT256),",
          "104:       );",
          "105:     });",
          "106:   });",
          "108:   describe('toHexString address', function () {",
          "109:     it('converts a random address', async function () {",
          "110:       const addr = '0xa9036907dccae6a1e0033479b12e837e5cf5a02f';",
          "111:       expect(await this.strings.methods['$toHexString(address)'](addr)).to.equal(addr);",
          "112:     });",
          "114:     it('converts an address with leading zeros', async function () {",
          "115:       const addr = '0x0000e0ca771e21bd00057f54a68c30d400000000';",
          "116:       expect(await this.strings.methods['$toHexString(address)'](addr)).to.equal(addr);",
          "117:     });",
          "118:   });",
          "120:   describe('equal', function () {",
          "121:     it('compares two empty strings', async function () {",
          "122:       expect(await this.strings.methods['$equal(string,string)']('', '')).to.equal(true);",
          "123:     });",
          "125:     it('compares two equal strings', async function () {",
          "126:       expect(await this.strings.methods['$equal(string,string)']('a', 'a')).to.equal(true);",
          "127:     });",
          "129:     it('compares two different strings', async function () {",
          "130:       expect(await this.strings.methods['$equal(string,string)']('a', 'b')).to.equal(false);",
          "131:     });",
          "133:     it('compares two different strings of different lengths', async function () {",
          "134:       expect(await this.strings.methods['$equal(string,string)']('a', 'aa')).to.equal(false);",
          "135:       expect(await this.strings.methods['$equal(string,string)']('aa', 'a')).to.equal(false);",
          "136:     });",
          "138:     it('compares two different large strings', async function () {",
          "139:       const str1 = 'a'.repeat(201);",
          "140:       const str2 = 'a'.repeat(200) + 'b';",
          "141:       expect(await this.strings.methods['$equal(string,string)'](str1, str2)).to.equal(false);",
          "142:     });",
          "144:     it('compares two equal large strings', async function () {",
          "145:       const str1 = 'a'.repeat(201);",
          "146:       const str2 = 'a'.repeat(201);",
          "147:       expect(await this.strings.methods['$equal(string,string)'](str1, str2)).to.equal(true);",
          "148:     });",
          "149:   });",
          "150: });",
          "",
          "---------------"
        ],
        "test/utils/TimersBlockNumberImpl.test.js||test/utils/TimersBlockNumberImpl.test.js": [
          "File: test/utils/TimersBlockNumberImpl.test.js -> test/utils/TimersBlockNumberImpl.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, time } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "4: const TimersBlockNumberImpl = artifacts.require('TimersBlockNumberImpl');",
          "6: contract('TimersBlockNumber', function () {",
          "7:   beforeEach(async function () {",
          "8:     this.instance = await TimersBlockNumberImpl.new();",
          "9:     this.now = await web3.eth.getBlock('latest').then(({ number }) => number);",
          "10:   });",
          "12:   it('unset', async function () {",
          "13:     expect(await this.instance.getDeadline()).to.be.bignumber.equal('0');",
          "14:     expect(await this.instance.isUnset()).to.be.equal(true);",
          "15:     expect(await this.instance.isStarted()).to.be.equal(false);",
          "16:     expect(await this.instance.isPending()).to.be.equal(false);",
          "17:     expect(await this.instance.isExpired()).to.be.equal(false);",
          "18:   });",
          "20:   it('pending', async function () {",
          "21:     await this.instance.setDeadline(this.now + 3);",
          "22:     expect(await this.instance.getDeadline()).to.be.bignumber.equal(new BN(this.now + 3));",
          "23:     expect(await this.instance.isUnset()).to.be.equal(false);",
          "24:     expect(await this.instance.isStarted()).to.be.equal(true);",
          "25:     expect(await this.instance.isPending()).to.be.equal(true);",
          "26:     expect(await this.instance.isExpired()).to.be.equal(false);",
          "27:   });",
          "29:   it('expired', async function () {",
          "30:     await this.instance.setDeadline(this.now - 3);",
          "31:     expect(await this.instance.getDeadline()).to.be.bignumber.equal(new BN(this.now - 3));",
          "32:     expect(await this.instance.isUnset()).to.be.equal(false);",
          "33:     expect(await this.instance.isStarted()).to.be.equal(true);",
          "34:     expect(await this.instance.isPending()).to.be.equal(false);",
          "35:     expect(await this.instance.isExpired()).to.be.equal(true);",
          "36:   });",
          "38:   it('reset', async function () {",
          "39:     await this.instance.reset();",
          "40:     expect(await this.instance.getDeadline()).to.be.bignumber.equal(new BN(0));",
          "41:     expect(await this.instance.isUnset()).to.be.equal(true);",
          "42:     expect(await this.instance.isStarted()).to.be.equal(false);",
          "43:     expect(await this.instance.isPending()).to.be.equal(false);",
          "44:     expect(await this.instance.isExpired()).to.be.equal(false);",
          "45:   });",
          "47:   it('fast forward', async function () {",
          "48:     await this.instance.setDeadline(this.now + 3);",
          "49:     expect(await this.instance.isPending()).to.be.equal(true);",
          "50:     expect(await this.instance.isExpired()).to.be.equal(false);",
          "51:     await time.advanceBlockTo(this.now + 3);",
          "52:     expect(await this.instance.isPending()).to.be.equal(false);",
          "53:     expect(await this.instance.isExpired()).to.be.equal(true);",
          "54:   });",
          "55: });",
          "",
          "---------------"
        ],
        "test/utils/TimersTimestamp.test.js||test/utils/TimersTimestamp.test.js": [
          "File: test/utils/TimersTimestamp.test.js -> test/utils/TimersTimestamp.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, time } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "4: const TimersTimestampImpl = artifacts.require('TimersTimestampImpl');",
          "6: contract('TimersTimestamp', function () {",
          "7:   beforeEach(async function () {",
          "8:     this.instance = await TimersTimestampImpl.new();",
          "9:     this.now = await web3.eth.getBlock('latest').then(({ timestamp }) => timestamp);",
          "10:   });",
          "12:   it('unset', async function () {",
          "13:     expect(await this.instance.getDeadline()).to.be.bignumber.equal('0');",
          "14:     expect(await this.instance.isUnset()).to.be.equal(true);",
          "15:     expect(await this.instance.isStarted()).to.be.equal(false);",
          "16:     expect(await this.instance.isPending()).to.be.equal(false);",
          "17:     expect(await this.instance.isExpired()).to.be.equal(false);",
          "18:   });",
          "20:   it('pending', async function () {",
          "21:     await this.instance.setDeadline(this.now + 100);",
          "22:     expect(await this.instance.getDeadline()).to.be.bignumber.equal(new BN(this.now + 100));",
          "23:     expect(await this.instance.isUnset()).to.be.equal(false);",
          "24:     expect(await this.instance.isStarted()).to.be.equal(true);",
          "25:     expect(await this.instance.isPending()).to.be.equal(true);",
          "26:     expect(await this.instance.isExpired()).to.be.equal(false);",
          "27:   });",
          "29:   it('expired', async function () {",
          "30:     await this.instance.setDeadline(this.now - 100);",
          "31:     expect(await this.instance.getDeadline()).to.be.bignumber.equal(new BN(this.now - 100));",
          "32:     expect(await this.instance.isUnset()).to.be.equal(false);",
          "33:     expect(await this.instance.isStarted()).to.be.equal(true);",
          "34:     expect(await this.instance.isPending()).to.be.equal(false);",
          "35:     expect(await this.instance.isExpired()).to.be.equal(true);",
          "36:   });",
          "38:   it('reset', async function () {",
          "39:     await this.instance.reset();",
          "40:     expect(await this.instance.getDeadline()).to.be.bignumber.equal(new BN(0));",
          "41:     expect(await this.instance.isUnset()).to.be.equal(true);",
          "42:     expect(await this.instance.isStarted()).to.be.equal(false);",
          "43:     expect(await this.instance.isPending()).to.be.equal(false);",
          "44:     expect(await this.instance.isExpired()).to.be.equal(false);",
          "45:   });",
          "47:   it('fast forward', async function () {",
          "48:     await this.instance.setDeadline(this.now + 100);",
          "49:     expect(await this.instance.isPending()).to.be.equal(true);",
          "50:     expect(await this.instance.isExpired()).to.be.equal(false);",
          "51:     await time.increaseTo(this.now + 100);",
          "52:     expect(await this.instance.isPending()).to.be.equal(false);",
          "53:     expect(await this.instance.isExpired()).to.be.equal(true);",
          "54:   });",
          "55: });",
          "",
          "---------------"
        ],
        "test/utils/cryptography/ECDSA.test.js||test/utils/cryptography/ECDSA.test.js": [
          "File: test/utils/cryptography/ECDSA.test.js -> test/utils/cryptography/ECDSA.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { toEthSignedMessageHash, toDataWithIntendedValidatorHash } = require('../../helpers/sign');",
          "4: const { expect } = require('chai');",
          "6: const ECDSA = artifacts.require('$ECDSA');",
          "8: const TEST_MESSAGE = web3.utils.sha3('OpenZeppelin');",
          "9: const WRONG_MESSAGE = web3.utils.sha3('Nope');",
          "10: const NON_HASH_MESSAGE = '0x' + Buffer.from('abcd').toString('hex');",
          "11: const RANDOM_ADDRESS = web3.utils.toChecksumAddress(web3.utils.randomHex(20));",
          "13: function to2098Format(signature) {",
          "14:   const long = web3.utils.hexToBytes(signature);",
          "15:   if (long.length !== 65) {",
          "16:     throw new Error('invalid signature length (expected long format)');",
          "17:   }",
          "18:   if (long[32] >> 7 === 1) {",
          "19:     throw new Error(\"invalid signature 's' value\");",
          "20:   }",
          "21:   const short = long.slice(0, 64);",
          "22:   short[32] |= long[64] % 27 << 7; // set the first bit of the 32nd byte to the v parity bit",
          "23:   return web3.utils.bytesToHex(short);",
          "24: }",
          "26: function split(signature) {",
          "27:   const raw = web3.utils.hexToBytes(signature);",
          "28:   switch (raw.length) {",
          "29:     case 64:",
          "30:       return [",
          "31:         web3.utils.bytesToHex(raw.slice(0, 32)), // r",
          "32:         web3.utils.bytesToHex(raw.slice(32, 64)), // vs",
          "33:       ];",
          "34:     case 65:",
          "35:       return [",
          "36:         raw[64], // v",
          "37:         web3.utils.bytesToHex(raw.slice(0, 32)), // r",
          "38:         web3.utils.bytesToHex(raw.slice(32, 64)), // s",
          "39:       ];",
          "40:     default:",
          "41:       expect.fail('Invalid signature length, cannot split');",
          "42:   }",
          "43: }",
          "45: contract('ECDSA', function (accounts) {",
          "46:   const [other] = accounts;",
          "48:   beforeEach(async function () {",
          "49:     this.ecdsa = await ECDSA.new();",
          "50:   });",
          "52:   context('recover with invalid signature', function () {",
          "53:     it('with short signature', async function () {",
          "54:       await expectRevert(this.ecdsa.$recover(TEST_MESSAGE, '0x1234'), 'ECDSA: invalid signature length');",
          "55:     });",
          "57:     it('with long signature', async function () {",
          "58:       await expectRevert(",
          "60:         this.ecdsa.$recover(",
          "61:           TEST_MESSAGE,",
          "62:           '0x01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789',",
          "63:         ),",
          "64:         'ECDSA: invalid signature length',",
          "65:       );",
          "66:     });",
          "67:   });",
          "69:   context('recover with valid signature', function () {",
          "70:     context('using web3.eth.sign', function () {",
          "71:       it('returns signer address with correct signature', async function () {",
          "73:         const signature = await web3.eth.sign(TEST_MESSAGE, other);",
          "76:         expect(await this.ecdsa.$recover(toEthSignedMessageHash(TEST_MESSAGE), signature)).to.equal(other);",
          "77:       });",
          "79:       it('returns signer address with correct signature for arbitrary length message', async function () {",
          "81:         const signature = await web3.eth.sign(NON_HASH_MESSAGE, other);",
          "84:         expect(await this.ecdsa.$recover(toEthSignedMessageHash(NON_HASH_MESSAGE), signature)).to.equal(other);",
          "85:       });",
          "87:       it('returns a different address', async function () {",
          "88:         const signature = await web3.eth.sign(TEST_MESSAGE, other);",
          "89:         expect(await this.ecdsa.$recover(WRONG_MESSAGE, signature)).to.not.equal(other);",
          "90:       });",
          "92:       it('reverts with invalid signature', async function () {",
          "94:         const signature =",
          "95:           '0x332ce75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e01c';",
          "96:         await expectRevert(this.ecdsa.$recover(TEST_MESSAGE, signature), 'ECDSA: invalid signature');",
          "97:       });",
          "98:     });",
          "100:     context('with v=27 signature', function () {",
          "102:       const signer = '0x2cc1166f6212628A0deEf2B33BEFB2187D35b86c';",
          "104:       const signatureWithoutV =",
          "105:         '0x5d99b6f7f6d1f73d1a26497f2b1c89b24c0993913f86e9a2d02cd69887d9c94f3c880358579d811b21dd1b7fd9bb01c1d81d10e69f0384e675c32b39643be892';",
          "107:       it('works with correct v value', async function () {",
          "108:         const v = '1b'; // 27 = 1b.",
          "109:         const signature = signatureWithoutV + v;",
          "110:         expect(await this.ecdsa.$recover(TEST_MESSAGE, signature)).to.equal(signer);",
          "112:         expect(",
          "113:           await this.ecdsa.methods['$recover(bytes32,uint8,bytes32,bytes32)'](TEST_MESSAGE, ...split(signature)),",
          "114:         ).to.equal(signer);",
          "116:         expect(",
          "117:           await this.ecdsa.methods['$recover(bytes32,bytes32,bytes32)'](",
          "118:             TEST_MESSAGE,",
          "119:             ...split(to2098Format(signature)),",
          "120:           ),",
          "121:         ).to.equal(signer);",
          "122:       });",
          "124:       it('rejects incorrect v value', async function () {",
          "125:         const v = '1c'; // 28 = 1c.",
          "126:         const signature = signatureWithoutV + v;",
          "127:         expect(await this.ecdsa.$recover(TEST_MESSAGE, signature)).to.not.equal(signer);",
          "129:         expect(",
          "130:           await this.ecdsa.methods['$recover(bytes32,uint8,bytes32,bytes32)'](TEST_MESSAGE, ...split(signature)),",
          "131:         ).to.not.equal(signer);",
          "133:         expect(",
          "134:           await this.ecdsa.methods['$recover(bytes32,bytes32,bytes32)'](",
          "135:             TEST_MESSAGE,",
          "136:             ...split(to2098Format(signature)),",
          "137:           ),",
          "138:         ).to.not.equal(signer);",
          "139:       });",
          "141:       it('reverts wrong v values', async function () {",
          "142:         for (const v of ['00', '01']) {",
          "143:           const signature = signatureWithoutV + v;",
          "144:           await expectRevert(this.ecdsa.$recover(TEST_MESSAGE, signature), 'ECDSA: invalid signature');",
          "146:           await expectRevert(",
          "147:             this.ecdsa.methods['$recover(bytes32,uint8,bytes32,bytes32)'](TEST_MESSAGE, ...split(signature)),",
          "148:             'ECDSA: invalid signature',",
          "149:           );",
          "150:         }",
          "151:       });",
          "153:       it('rejects short EIP2098 format', async function () {",
          "154:         const v = '1b'; // 27 = 1b.",
          "155:         const signature = signatureWithoutV + v;",
          "156:         await expectRevert(",
          "157:           this.ecdsa.$recover(TEST_MESSAGE, to2098Format(signature)),",
          "158:           'ECDSA: invalid signature length',",
          "159:         );",
          "160:       });",
          "161:     });",
          "163:     context('with v=28 signature', function () {",
          "164:       const signer = '0x1E318623aB09Fe6de3C9b8672098464Aeda9100E';",
          "166:       const signatureWithoutV =",
          "167:         '0x331fe75a821c982f9127538858900d87d3ec1f9f737338ad67cad133fa48feff48e6fa0c18abc62e42820f05943e47af3e9fbe306ce74d64094bdf1691ee53e0';",
          "169:       it('works with correct v value', async function () {",
          "170:         const v = '1c'; // 28 = 1c.",
          "171:         const signature = signatureWithoutV + v;",
          "172:         expect(await this.ecdsa.$recover(TEST_MESSAGE, signature)).to.equal(signer);",
          "174:         expect(",
          "175:           await this.ecdsa.methods['$recover(bytes32,uint8,bytes32,bytes32)'](TEST_MESSAGE, ...split(signature)),",
          "176:         ).to.equal(signer);",
          "178:         expect(",
          "179:           await this.ecdsa.methods['$recover(bytes32,bytes32,bytes32)'](",
          "180:             TEST_MESSAGE,",
          "181:             ...split(to2098Format(signature)),",
          "182:           ),",
          "183:         ).to.equal(signer);",
          "184:       });",
          "186:       it('rejects incorrect v value', async function () {",
          "187:         const v = '1b'; // 27 = 1b.",
          "188:         const signature = signatureWithoutV + v;",
          "189:         expect(await this.ecdsa.$recover(TEST_MESSAGE, signature)).to.not.equal(signer);",
          "191:         expect(",
          "192:           await this.ecdsa.methods['$recover(bytes32,uint8,bytes32,bytes32)'](TEST_MESSAGE, ...split(signature)),",
          "193:         ).to.not.equal(signer);",
          "195:         expect(",
          "196:           await this.ecdsa.methods['$recover(bytes32,bytes32,bytes32)'](",
          "197:             TEST_MESSAGE,",
          "198:             ...split(to2098Format(signature)),",
          "199:           ),",
          "200:         ).to.not.equal(signer);",
          "201:       });",
          "203:       it('reverts invalid v values', async function () {",
          "204:         for (const v of ['00', '01']) {",
          "205:           const signature = signatureWithoutV + v;",
          "206:           await expectRevert(this.ecdsa.$recover(TEST_MESSAGE, signature), 'ECDSA: invalid signature');",
          "208:           await expectRevert(",
          "209:             this.ecdsa.methods['$recover(bytes32,uint8,bytes32,bytes32)'](TEST_MESSAGE, ...split(signature)),",
          "210:             'ECDSA: invalid signature',",
          "211:           );",
          "212:         }",
          "213:       });",
          "215:       it('rejects short EIP2098 format', async function () {",
          "216:         const v = '1c'; // 27 = 1b.",
          "217:         const signature = signatureWithoutV + v;",
          "218:         await expectRevert(",
          "219:           this.ecdsa.$recover(TEST_MESSAGE, to2098Format(signature)),",
          "220:           'ECDSA: invalid signature length',",
          "221:         );",
          "222:       });",
          "223:     });",
          "225:     it('reverts with high-s value signature', async function () {",
          "226:       const message = '0xb94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9';",
          "228:       const highSSignature =",
          "229:         '0xe742ff452d41413616a5bf43fe15dd88294e983d3d36206c2712f39083d638bde0a0fc89be718fbc1033e1d30d78be1c68081562ed2e97af876f286f3453231d1b';",
          "230:       await expectRevert(this.ecdsa.$recover(message, highSSignature), \"ECDSA: invalid signature 's' value\");",
          "231:       await expectRevert(",
          "232:         this.ecdsa.methods['$recover(bytes32,uint8,bytes32,bytes32)'](TEST_MESSAGE, ...split(highSSignature)),",
          "233:         \"ECDSA: invalid signature 's' value\",",
          "234:       );",
          "235:       expect(() => to2098Format(highSSignature)).to.throw(\"invalid signature 's' value\");",
          "236:     });",
          "237:   });",
          "239:   context('toEthSignedMessageHash', function () {",
          "240:     it('prefixes bytes32 data correctly', async function () {",
          "241:       expect(await this.ecdsa.methods['$toEthSignedMessageHash(bytes32)'](TEST_MESSAGE)).to.equal(",
          "242:         toEthSignedMessageHash(TEST_MESSAGE),",
          "243:       );",
          "244:     });",
          "246:     it('prefixes dynamic length data correctly', async function () {",
          "247:       expect(await this.ecdsa.methods['$toEthSignedMessageHash(bytes)'](NON_HASH_MESSAGE)).to.equal(",
          "248:         toEthSignedMessageHash(NON_HASH_MESSAGE),",
          "249:       );",
          "250:     });",
          "251:   });",
          "253:   context('toDataWithIntendedValidatorHash', function () {",
          "254:     it('returns the hash correctly', async function () {",
          "255:       expect(",
          "256:         await this.ecdsa.methods['$toDataWithIntendedValidatorHash(address,bytes)'](RANDOM_ADDRESS, NON_HASH_MESSAGE),",
          "257:       ).to.equal(toDataWithIntendedValidatorHash(RANDOM_ADDRESS, NON_HASH_MESSAGE));",
          "258:     });",
          "259:   });",
          "260: });",
          "",
          "---------------"
        ],
        "test/utils/cryptography/EIP712.test.js||test/utils/cryptography/EIP712.test.js": [
          "File: test/utils/cryptography/EIP712.test.js -> test/utils/cryptography/EIP712.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const ethSigUtil = require('eth-sig-util');",
          "2: const Wallet = require('ethereumjs-wallet').default;",
          "4: const { getDomain, domainType, domainSeparator, hashTypedData } = require('../../helpers/eip712');",
          "5: const { getChainId } = require('../../helpers/chainid');",
          "6: const { mapValues } = require('../../helpers/map-values');",
          "8: const EIP712Verifier = artifacts.require('$EIP712Verifier');",
          "9: const Clones = artifacts.require('$Clones');",
          "11: contract('EIP712', function (accounts) {",
          "12:   const [mailTo] = accounts;",
          "14:   const shortName = 'A Name';",
          "15:   const shortVersion = '1';",
          "17:   const longName = 'A'.repeat(40);",
          "18:   const longVersion = 'B'.repeat(40);",
          "20:   const cases = [",
          "21:     ['short', shortName, shortVersion],",
          "22:     ['long', longName, longVersion],",
          "23:   ];",
          "25:   for (const [shortOrLong, name, version] of cases) {",
          "26:     describe(`with ${shortOrLong} name and version`, function () {",
          "27:       beforeEach('deploying', async function () {",
          "28:         this.eip712 = await EIP712Verifier.new(name, version);",
          "30:         this.domain = {",
          "31:           name,",
          "32:           version,",
          "33:           chainId: await getChainId(),",
          "34:           verifyingContract: this.eip712.address,",
          "35:         };",
          "36:         this.domainType = domainType(this.domain);",
          "37:       });",
          "39:       describe('domain separator', function () {",
          "40:         it('is internally available', async function () {",
          "41:           const expected = await domainSeparator(this.domain);",
          "43:           expect(await this.eip712.$_domainSeparatorV4()).to.equal(expected);",
          "44:         });",
          "46:         it(\"can be rebuilt using EIP-5267's eip712Domain\", async function () {",
          "47:           const rebuildDomain = await getDomain(this.eip712);",
          "48:           expect(mapValues(rebuildDomain, String)).to.be.deep.equal(mapValues(this.domain, String));",
          "49:         });",
          "50:       });",
          "52:       it('hash digest', async function () {",
          "53:         const structhash = web3.utils.randomHex(32);",
          "54:         expect(await this.eip712.$_hashTypedDataV4(structhash)).to.be.equal(hashTypedData(this.domain, structhash));",
          "55:       });",
          "57:       it('digest', async function () {",
          "58:         const message = {",
          "59:           to: mailTo,",
          "60:           contents: 'very interesting',",
          "61:         };",
          "63:         const data = {",
          "64:           types: {",
          "65:             EIP712Domain: this.domainType,",
          "66:             Mail: [",
          "67:               { name: 'to', type: 'address' },",
          "68:               { name: 'contents', type: 'string' },",
          "69:             ],",
          "70:           },",
          "71:           domain: this.domain,",
          "72:           primaryType: 'Mail',",
          "73:           message,",
          "74:         };",
          "76:         const wallet = Wallet.generate();",
          "77:         const signature = ethSigUtil.signTypedMessage(wallet.getPrivateKey(), { data });",
          "79:         await this.eip712.verify(signature, wallet.getAddressString(), message.to, message.contents);",
          "80:       });",
          "81:     });",
          "82:   }",
          "83: });",
          "",
          "---------------"
        ],
        "test/utils/cryptography/MerkleProof.test.js||test/utils/cryptography/MerkleProof.test.js": [
          "File: test/utils/cryptography/MerkleProof.test.js -> test/utils/cryptography/MerkleProof.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: require('@openzeppelin/test-helpers');",
          "3: const { expectRevert } = require('@openzeppelin/test-helpers');",
          "4: const { MerkleTree } = require('merkletreejs');",
          "5: const keccak256 = require('keccak256');",
          "7: const { expect } = require('chai');",
          "9: const MerkleProof = artifacts.require('$MerkleProof');",
          "11: contract('MerkleProof', function () {",
          "12:   beforeEach(async function () {",
          "13:     this.merkleProof = await MerkleProof.new();",
          "14:   });",
          "16:   describe('verify', function () {",
          "17:     it('returns true for a valid Merkle proof', async function () {",
          "18:       const elements = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('');",
          "19:       const merkleTree = new MerkleTree(elements, keccak256, { hashLeaves: true, sortPairs: true });",
          "21:       const root = merkleTree.getHexRoot();",
          "23:       const leaf = keccak256(elements[0]);",
          "25:       const proof = merkleTree.getHexProof(leaf);",
          "27:       expect(await this.merkleProof.$verify(proof, root, leaf)).to.equal(true);",
          "28:       expect(await this.merkleProof.$verifyCalldata(proof, root, leaf)).to.equal(true);",
          "31:       const noSuchLeaf = keccak256(",
          "32:         Buffer.concat([keccak256(elements[0]), keccak256(elements[1])].sort(Buffer.compare)),",
          "33:       );",
          "34:       expect(await this.merkleProof.$verify(proof.slice(1), root, noSuchLeaf)).to.equal(true);",
          "35:       expect(await this.merkleProof.$verifyCalldata(proof.slice(1), root, noSuchLeaf)).to.equal(true);",
          "36:     });",
          "38:     it('returns false for an invalid Merkle proof', async function () {",
          "39:       const correctElements = ['a', 'b', 'c'];",
          "40:       const correctMerkleTree = new MerkleTree(correctElements, keccak256, { hashLeaves: true, sortPairs: true });",
          "42:       const correctRoot = correctMerkleTree.getHexRoot();",
          "44:       const correctLeaf = keccak256(correctElements[0]);",
          "46:       const badElements = ['d', 'e', 'f'];",
          "47:       const badMerkleTree = new MerkleTree(badElements);",
          "49:       const badProof = badMerkleTree.getHexProof(badElements[0]);",
          "51:       expect(await this.merkleProof.$verify(badProof, correctRoot, correctLeaf)).to.equal(false);",
          "52:       expect(await this.merkleProof.$verifyCalldata(badProof, correctRoot, correctLeaf)).to.equal(false);",
          "53:     });",
          "55:     it('returns false for a Merkle proof of invalid length', async function () {",
          "56:       const elements = ['a', 'b', 'c'];",
          "57:       const merkleTree = new MerkleTree(elements, keccak256, { hashLeaves: true, sortPairs: true });",
          "59:       const root = merkleTree.getHexRoot();",
          "61:       const leaf = keccak256(elements[0]);",
          "63:       const proof = merkleTree.getHexProof(leaf);",
          "64:       const badProof = proof.slice(0, proof.length - 5);",
          "66:       expect(await this.merkleProof.$verify(badProof, root, leaf)).to.equal(false);",
          "67:       expect(await this.merkleProof.$verifyCalldata(badProof, root, leaf)).to.equal(false);",
          "68:     });",
          "69:   });",
          "71:   describe('multiProofVerify', function () {",
          "72:     it('returns true for a valid Merkle multi proof', async function () {",
          "73:       const leaves = ['a', 'b', 'c', 'd', 'e', 'f'].map(keccak256).sort(Buffer.compare);",
          "74:       const merkleTree = new MerkleTree(leaves, keccak256, { sort: true });",
          "76:       const root = merkleTree.getRoot();",
          "77:       const proofLeaves = ['b', 'f', 'd'].map(keccak256).sort(Buffer.compare);",
          "78:       const proof = merkleTree.getMultiProof(proofLeaves);",
          "79:       const proofFlags = merkleTree.getProofFlags(proofLeaves, proof);",
          "81:       expect(await this.merkleProof.$multiProofVerify(proof, proofFlags, root, proofLeaves)).to.equal(true);",
          "82:       expect(await this.merkleProof.$multiProofVerifyCalldata(proof, proofFlags, root, proofLeaves)).to.equal(true);",
          "83:     });",
          "85:     it('returns false for an invalid Merkle multi proof', async function () {",
          "86:       const leaves = ['a', 'b', 'c', 'd', 'e', 'f'].map(keccak256).sort(Buffer.compare);",
          "87:       const merkleTree = new MerkleTree(leaves, keccak256, { sort: true });",
          "89:       const root = merkleTree.getRoot();",
          "90:       const badProofLeaves = ['g', 'h', 'i'].map(keccak256).sort(Buffer.compare);",
          "91:       const badMerkleTree = new MerkleTree(badProofLeaves);",
          "92:       const badProof = badMerkleTree.getMultiProof(badProofLeaves);",
          "93:       const badProofFlags = badMerkleTree.getProofFlags(badProofLeaves, badProof);",
          "95:       expect(await this.merkleProof.$multiProofVerify(badProof, badProofFlags, root, badProofLeaves)).to.equal(false);",
          "96:       expect(await this.merkleProof.$multiProofVerifyCalldata(badProof, badProofFlags, root, badProofLeaves)).to.equal(",
          "97:         false,",
          "98:       );",
          "99:     });",
          "101:     it('revert with invalid multi proof #1', async function () {",
          "102:       const fill = Buffer.alloc(32); // This could be anything, we are reconstructing a fake branch",
          "103:       const leaves = ['a', 'b', 'c', 'd'].map(keccak256).sort(Buffer.compare);",
          "104:       const badLeaf = keccak256('e');",
          "105:       const merkleTree = new MerkleTree(leaves, keccak256, { sort: true });",
          "107:       const root = merkleTree.getRoot();",
          "109:       await expectRevert(",
          "110:         this.merkleProof.$multiProofVerify(",
          "111:           [leaves[1], fill, merkleTree.layers[1][1]],",
          "112:           [false, false, false],",
          "113:           root,",
          "114:           [leaves[0], badLeaf], // A, E",
          "115:         ),",
          "116:         'MerkleProof: invalid multiproof',",
          "117:       );",
          "118:       await expectRevert(",
          "119:         this.merkleProof.$multiProofVerifyCalldata(",
          "120:           [leaves[1], fill, merkleTree.layers[1][1]],",
          "121:           [false, false, false],",
          "122:           root,",
          "123:           [leaves[0], badLeaf], // A, E",
          "124:         ),",
          "125:         'MerkleProof: invalid multiproof',",
          "126:       );",
          "127:     });",
          "129:     it('revert with invalid multi proof #2', async function () {",
          "130:       const fill = Buffer.alloc(32); // This could be anything, we are reconstructing a fake branch",
          "131:       const leaves = ['a', 'b', 'c', 'd'].map(keccak256).sort(Buffer.compare);",
          "132:       const badLeaf = keccak256('e');",
          "133:       const merkleTree = new MerkleTree(leaves, keccak256, { sort: true });",
          "135:       const root = merkleTree.getRoot();",
          "137:       await expectRevert(",
          "138:         this.merkleProof.$multiProofVerify(",
          "139:           [leaves[1], fill, merkleTree.layers[1][1]],",
          "140:           [false, false, false, false],",
          "141:           root,",
          "142:           [badLeaf, leaves[0]], // A, E",
          "143:         ),",
          "144:         'reverted with panic code 0x32',",
          "145:       );",
          "147:       await expectRevert(",
          "148:         this.merkleProof.$multiProofVerifyCalldata(",
          "149:           [leaves[1], fill, merkleTree.layers[1][1]],",
          "150:           [false, false, false, false],",
          "151:           root,",
          "152:           [badLeaf, leaves[0]], // A, E",
          "153:         ),",
          "154:         'reverted with panic code 0x32',",
          "155:       );",
          "156:     });",
          "158:     it('limit case: works for tree containing a single leaf', async function () {",
          "159:       const leaves = ['a'].map(keccak256).sort(Buffer.compare);",
          "160:       const merkleTree = new MerkleTree(leaves, keccak256, { sort: true });",
          "162:       const root = merkleTree.getRoot();",
          "163:       const proofLeaves = ['a'].map(keccak256).sort(Buffer.compare);",
          "164:       const proof = merkleTree.getMultiProof(proofLeaves);",
          "165:       const proofFlags = merkleTree.getProofFlags(proofLeaves, proof);",
          "167:       expect(await this.merkleProof.$multiProofVerify(proof, proofFlags, root, proofLeaves)).to.equal(true);",
          "168:       expect(await this.merkleProof.$multiProofVerifyCalldata(proof, proofFlags, root, proofLeaves)).to.equal(true);",
          "169:     });",
          "171:     it('limit case: can prove empty leaves', async function () {",
          "172:       const leaves = ['a', 'b', 'c', 'd'].map(keccak256).sort(Buffer.compare);",
          "173:       const merkleTree = new MerkleTree(leaves, keccak256, { sort: true });",
          "175:       const root = merkleTree.getRoot();",
          "176:       expect(await this.merkleProof.$multiProofVerify([root], [], root, [])).to.equal(true);",
          "177:       expect(await this.merkleProof.$multiProofVerifyCalldata([root], [], root, [])).to.equal(true);",
          "178:     });",
          "179:   });",
          "180: });",
          "",
          "---------------"
        ],
        "test/utils/cryptography/SignatureChecker.test.js||test/utils/cryptography/SignatureChecker.test.js": [
          "File: test/utils/cryptography/SignatureChecker.test.js -> test/utils/cryptography/SignatureChecker.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { toEthSignedMessageHash } = require('../../helpers/sign');",
          "3: const { expect } = require('chai');",
          "5: const SignatureChecker = artifacts.require('$SignatureChecker');",
          "6: const ERC1271WalletMock = artifacts.require('ERC1271WalletMock');",
          "7: const ERC1271MaliciousMock = artifacts.require('ERC1271MaliciousMock');",
          "9: const TEST_MESSAGE = web3.utils.sha3('OpenZeppelin');",
          "10: const WRONG_MESSAGE = web3.utils.sha3('Nope');",
          "12: contract('SignatureChecker (ERC1271)', function (accounts) {",
          "13:   const [signer, other] = accounts;",
          "15:   before('deploying', async function () {",
          "16:     this.signaturechecker = await SignatureChecker.new();",
          "17:     this.wallet = await ERC1271WalletMock.new(signer);",
          "18:     this.malicious = await ERC1271MaliciousMock.new();",
          "19:     this.signature = await web3.eth.sign(TEST_MESSAGE, signer);",
          "20:   });",
          "22:   context('EOA account', function () {",
          "23:     it('with matching signer and signature', async function () {",
          "24:       expect(",
          "25:         await this.signaturechecker.$isValidSignatureNow(signer, toEthSignedMessageHash(TEST_MESSAGE), this.signature),",
          "26:       ).to.equal(true);",
          "27:     });",
          "29:     it('with invalid signer', async function () {",
          "30:       expect(",
          "31:         await this.signaturechecker.$isValidSignatureNow(other, toEthSignedMessageHash(TEST_MESSAGE), this.signature),",
          "32:       ).to.equal(false);",
          "33:     });",
          "35:     it('with invalid signature', async function () {",
          "36:       expect(",
          "37:         await this.signaturechecker.$isValidSignatureNow(signer, toEthSignedMessageHash(WRONG_MESSAGE), this.signature),",
          "38:       ).to.equal(false);",
          "39:     });",
          "40:   });",
          "42:   context('ERC1271 wallet', function () {",
          "43:     for (const signature of ['isValidERC1271SignatureNow', 'isValidSignatureNow']) {",
          "44:       context(signature, function () {",
          "45:         it('with matching signer and signature', async function () {",
          "46:           expect(",
          "47:             await this.signaturechecker[`$${signature}`](",
          "48:               this.wallet.address,",
          "49:               toEthSignedMessageHash(TEST_MESSAGE),",
          "50:               this.signature,",
          "51:             ),",
          "52:           ).to.equal(true);",
          "53:         });",
          "55:         it('with invalid signer', async function () {",
          "56:           expect(",
          "57:             await this.signaturechecker[`$${signature}`](",
          "58:               this.signaturechecker.address,",
          "59:               toEthSignedMessageHash(TEST_MESSAGE),",
          "60:               this.signature,",
          "61:             ),",
          "62:           ).to.equal(false);",
          "63:         });",
          "65:         it('with invalid signature', async function () {",
          "66:           expect(",
          "67:             await this.signaturechecker[`$${signature}`](",
          "68:               this.wallet.address,",
          "69:               toEthSignedMessageHash(WRONG_MESSAGE),",
          "70:               this.signature,",
          "71:             ),",
          "72:           ).to.equal(false);",
          "73:         });",
          "75:         it('with malicious wallet', async function () {",
          "76:           expect(",
          "77:             await this.signaturechecker[`$${signature}`](",
          "78:               this.malicious.address,",
          "79:               toEthSignedMessageHash(TEST_MESSAGE),",
          "80:               this.signature,",
          "81:             ),",
          "82:           ).to.equal(false);",
          "83:         });",
          "84:       });",
          "85:     }",
          "86:   });",
          "87: });",
          "",
          "---------------"
        ],
        "test/utils/escrow/ConditionalEscrow.test.js||test/utils/escrow/ConditionalEscrow.test.js": [
          "File: test/utils/escrow/ConditionalEscrow.test.js -> test/utils/escrow/ConditionalEscrow.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { ether, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { shouldBehaveLikeEscrow } = require('./Escrow.behavior');",
          "4: const ConditionalEscrowMock = artifacts.require('ConditionalEscrowMock');",
          "6: contract('ConditionalEscrow', function (accounts) {",
          "7:   const [owner, payee, ...otherAccounts] = accounts;",
          "9:   beforeEach(async function () {",
          "10:     this.escrow = await ConditionalEscrowMock.new({ from: owner });",
          "11:   });",
          "13:   context('when withdrawal is allowed', function () {",
          "14:     beforeEach(async function () {",
          "15:       await Promise.all(otherAccounts.map(payee => this.escrow.setAllowed(payee, true)));",
          "16:     });",
          "18:     shouldBehaveLikeEscrow(owner, otherAccounts);",
          "19:   });",
          "21:   context('when withdrawal is disallowed', function () {",
          "22:     const amount = ether('23');",
          "24:     beforeEach(async function () {",
          "25:       await this.escrow.setAllowed(payee, false);",
          "26:     });",
          "28:     it('reverts on withdrawals', async function () {",
          "29:       await this.escrow.deposit(payee, { from: owner, value: amount });",
          "31:       await expectRevert(",
          "32:         this.escrow.withdraw(payee, { from: owner }),",
          "33:         'ConditionalEscrow: payee is not allowed to withdraw',",
          "34:       );",
          "35:     });",
          "36:   });",
          "37: });",
          "",
          "---------------"
        ],
        "test/utils/escrow/Escrow.behavior.js||test/utils/escrow/Escrow.behavior.js": [
          "File: test/utils/escrow/Escrow.behavior.js -> test/utils/escrow/Escrow.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { balance, ether, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: function shouldBehaveLikeEscrow(owner, [payee1, payee2]) {",
          "6:   const amount = ether('42');",
          "8:   describe('as an escrow', function () {",
          "9:     describe('deposits', function () {",
          "10:       it('can accept a single deposit', async function () {",
          "11:         await this.escrow.deposit(payee1, { from: owner, value: amount });",
          "13:         expect(await balance.current(this.escrow.address)).to.be.bignumber.equal(amount);",
          "15:         expect(await this.escrow.depositsOf(payee1)).to.be.bignumber.equal(amount);",
          "16:       });",
          "18:       it('can accept an empty deposit', async function () {",
          "19:         await this.escrow.deposit(payee1, { from: owner, value: 0 });",
          "20:       });",
          "22:       it('only the owner can deposit', async function () {",
          "23:         await expectRevert(this.escrow.deposit(payee1, { from: payee2 }), 'Ownable: caller is not the owner');",
          "24:       });",
          "26:       it('emits a deposited event', async function () {",
          "27:         const receipt = await this.escrow.deposit(payee1, { from: owner, value: amount });",
          "28:         expectEvent(receipt, 'Deposited', {",
          "29:           payee: payee1,",
          "30:           weiAmount: amount,",
          "31:         });",
          "32:       });",
          "34:       it('can add multiple deposits on a single account', async function () {",
          "35:         await this.escrow.deposit(payee1, { from: owner, value: amount });",
          "36:         await this.escrow.deposit(payee1, { from: owner, value: amount.muln(2) });",
          "38:         expect(await balance.current(this.escrow.address)).to.be.bignumber.equal(amount.muln(3));",
          "40:         expect(await this.escrow.depositsOf(payee1)).to.be.bignumber.equal(amount.muln(3));",
          "41:       });",
          "43:       it('can track deposits to multiple accounts', async function () {",
          "44:         await this.escrow.deposit(payee1, { from: owner, value: amount });",
          "45:         await this.escrow.deposit(payee2, { from: owner, value: amount.muln(2) });",
          "47:         expect(await balance.current(this.escrow.address)).to.be.bignumber.equal(amount.muln(3));",
          "49:         expect(await this.escrow.depositsOf(payee1)).to.be.bignumber.equal(amount);",
          "51:         expect(await this.escrow.depositsOf(payee2)).to.be.bignumber.equal(amount.muln(2));",
          "52:       });",
          "53:     });",
          "55:     describe('withdrawals', async function () {",
          "56:       it('can withdraw payments', async function () {",
          "57:         const balanceTracker = await balance.tracker(payee1);",
          "59:         await this.escrow.deposit(payee1, { from: owner, value: amount });",
          "60:         await this.escrow.withdraw(payee1, { from: owner });",
          "62:         expect(await balanceTracker.delta()).to.be.bignumber.equal(amount);",
          "64:         expect(await balance.current(this.escrow.address)).to.be.bignumber.equal('0');",
          "65:         expect(await this.escrow.depositsOf(payee1)).to.be.bignumber.equal('0');",
          "66:       });",
          "68:       it('can do an empty withdrawal', async function () {",
          "69:         await this.escrow.withdraw(payee1, { from: owner });",
          "70:       });",
          "72:       it('only the owner can withdraw', async function () {",
          "73:         await expectRevert(this.escrow.withdraw(payee1, { from: payee1 }), 'Ownable: caller is not the owner');",
          "74:       });",
          "76:       it('emits a withdrawn event', async function () {",
          "77:         await this.escrow.deposit(payee1, { from: owner, value: amount });",
          "78:         const receipt = await this.escrow.withdraw(payee1, { from: owner });",
          "79:         expectEvent(receipt, 'Withdrawn', {",
          "80:           payee: payee1,",
          "81:           weiAmount: amount,",
          "82:         });",
          "83:       });",
          "84:     });",
          "85:   });",
          "86: }",
          "88: module.exports = {",
          "89:   shouldBehaveLikeEscrow,",
          "90: };",
          "",
          "---------------"
        ],
        "test/utils/escrow/Escrow.test.js||test/utils/escrow/Escrow.test.js": [
          "File: test/utils/escrow/Escrow.test.js -> test/utils/escrow/Escrow.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: require('@openzeppelin/test-helpers');",
          "2: const { shouldBehaveLikeEscrow } = require('./Escrow.behavior');",
          "4: const Escrow = artifacts.require('Escrow');",
          "6: contract('Escrow', function (accounts) {",
          "7:   const [owner, ...otherAccounts] = accounts;",
          "9:   beforeEach(async function () {",
          "10:     this.escrow = await Escrow.new({ from: owner });",
          "11:   });",
          "13:   shouldBehaveLikeEscrow(owner, otherAccounts);",
          "14: });",
          "",
          "---------------"
        ],
        "test/utils/escrow/RefundEscrow.test.js||test/utils/escrow/RefundEscrow.test.js": [
          "File: test/utils/escrow/RefundEscrow.test.js -> test/utils/escrow/RefundEscrow.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { balance, constants, ether, expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { ZERO_ADDRESS } = constants;",
          "4: const { expect } = require('chai');",
          "6: const RefundEscrow = artifacts.require('RefundEscrow');",
          "8: contract('RefundEscrow', function (accounts) {",
          "9:   const [owner, beneficiary, refundee1, refundee2] = accounts;",
          "11:   const amount = ether('54');",
          "12:   const refundees = [refundee1, refundee2];",
          "14:   it('requires a non-null beneficiary', async function () {",
          "15:     await expectRevert(",
          "16:       RefundEscrow.new(ZERO_ADDRESS, { from: owner }),",
          "17:       'RefundEscrow: beneficiary is the zero address',",
          "18:     );",
          "19:   });",
          "21:   context('once deployed', function () {",
          "22:     beforeEach(async function () {",
          "23:       this.escrow = await RefundEscrow.new(beneficiary, { from: owner });",
          "24:     });",
          "26:     context('active state', function () {",
          "27:       it('has beneficiary and state', async function () {",
          "28:         expect(await this.escrow.beneficiary()).to.equal(beneficiary);",
          "29:         expect(await this.escrow.state()).to.be.bignumber.equal('0');",
          "30:       });",
          "32:       it('accepts deposits', async function () {",
          "33:         await this.escrow.deposit(refundee1, { from: owner, value: amount });",
          "35:         expect(await this.escrow.depositsOf(refundee1)).to.be.bignumber.equal(amount);",
          "36:       });",
          "38:       it('does not refund refundees', async function () {",
          "39:         await this.escrow.deposit(refundee1, { from: owner, value: amount });",
          "40:         await expectRevert(this.escrow.withdraw(refundee1), 'ConditionalEscrow: payee is not allowed to withdraw');",
          "41:       });",
          "43:       it('does not allow beneficiary withdrawal', async function () {",
          "44:         await this.escrow.deposit(refundee1, { from: owner, value: amount });",
          "45:         await expectRevert(",
          "46:           this.escrow.beneficiaryWithdraw(),",
          "47:           'RefundEscrow: beneficiary can only withdraw while closed',",
          "48:         );",
          "49:       });",
          "50:     });",
          "52:     it('only the owner can enter closed state', async function () {",
          "53:       await expectRevert(this.escrow.close({ from: beneficiary }), 'Ownable: caller is not the owner');",
          "55:       const receipt = await this.escrow.close({ from: owner });",
          "56:       expectEvent(receipt, 'RefundsClosed');",
          "57:     });",
          "59:     context('closed state', function () {",
          "60:       beforeEach(async function () {",
          "61:         await Promise.all(refundees.map(refundee => this.escrow.deposit(refundee, { from: owner, value: amount })));",
          "63:         await this.escrow.close({ from: owner });",
          "64:       });",
          "66:       it('rejects deposits', async function () {",
          "67:         await expectRevert(",
          "68:           this.escrow.deposit(refundee1, { from: owner, value: amount }),",
          "69:           'RefundEscrow: can only deposit while active',",
          "70:         );",
          "71:       });",
          "73:       it('does not refund refundees', async function () {",
          "74:         await expectRevert(this.escrow.withdraw(refundee1), 'ConditionalEscrow: payee is not allowed to withdraw');",
          "75:       });",
          "77:       it('allows beneficiary withdrawal', async function () {",
          "78:         const balanceTracker = await balance.tracker(beneficiary);",
          "79:         await this.escrow.beneficiaryWithdraw();",
          "80:         expect(await balanceTracker.delta()).to.be.bignumber.equal(amount.muln(refundees.length));",
          "81:       });",
          "83:       it('prevents entering the refund state', async function () {",
          "84:         await expectRevert(",
          "85:           this.escrow.enableRefunds({ from: owner }),",
          "86:           'RefundEscrow: can only enable refunds while active',",
          "87:         );",
          "88:       });",
          "90:       it('prevents re-entering the closed state', async function () {",
          "91:         await expectRevert(this.escrow.close({ from: owner }), 'RefundEscrow: can only close while active');",
          "92:       });",
          "93:     });",
          "95:     it('only the owner can enter refund state', async function () {",
          "96:       await expectRevert(this.escrow.enableRefunds({ from: beneficiary }), 'Ownable: caller is not the owner');",
          "98:       const receipt = await this.escrow.enableRefunds({ from: owner });",
          "99:       expectEvent(receipt, 'RefundsEnabled');",
          "100:     });",
          "102:     context('refund state', function () {",
          "103:       beforeEach(async function () {",
          "104:         await Promise.all(refundees.map(refundee => this.escrow.deposit(refundee, { from: owner, value: amount })));",
          "106:         await this.escrow.enableRefunds({ from: owner });",
          "107:       });",
          "109:       it('rejects deposits', async function () {",
          "110:         await expectRevert(",
          "111:           this.escrow.deposit(refundee1, { from: owner, value: amount }),",
          "112:           'RefundEscrow: can only deposit while active',",
          "113:         );",
          "114:       });",
          "116:       it('refunds refundees', async function () {",
          "117:         for (const refundee of [refundee1, refundee2]) {",
          "118:           const balanceTracker = await balance.tracker(refundee);",
          "119:           await this.escrow.withdraw(refundee, { from: owner });",
          "120:           expect(await balanceTracker.delta()).to.be.bignumber.equal(amount);",
          "121:         }",
          "122:       });",
          "124:       it('does not allow beneficiary withdrawal', async function () {",
          "125:         await expectRevert(",
          "126:           this.escrow.beneficiaryWithdraw(),",
          "127:           'RefundEscrow: beneficiary can only withdraw while closed',",
          "128:         );",
          "129:       });",
          "131:       it('prevents entering the closed state', async function () {",
          "132:         await expectRevert(this.escrow.close({ from: owner }), 'RefundEscrow: can only close while active');",
          "133:       });",
          "135:       it('prevents re-entering the refund state', async function () {",
          "136:         await expectRevert(",
          "137:           this.escrow.enableRefunds({ from: owner }),",
          "138:           'RefundEscrow: can only enable refunds while active',",
          "139:         );",
          "140:       });",
          "141:     });",
          "142:   });",
          "143: });",
          "",
          "---------------"
        ],
        "test/utils/introspection/ERC165.test.js||test/utils/introspection/ERC165.test.js": [
          "File: test/utils/introspection/ERC165.test.js -> test/utils/introspection/ERC165.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { shouldSupportInterfaces } = require('./SupportsInterface.behavior');",
          "3: const ERC165 = artifacts.require('$ERC165');",
          "5: contract('ERC165', function () {",
          "6:   beforeEach(async function () {",
          "7:     this.mock = await ERC165.new();",
          "8:   });",
          "10:   shouldSupportInterfaces(['ERC165']);",
          "11: });",
          "",
          "---------------"
        ],
        "test/utils/introspection/ERC165Checker.test.js||test/utils/introspection/ERC165Checker.test.js": [
          "File: test/utils/introspection/ERC165Checker.test.js -> test/utils/introspection/ERC165Checker.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const ERC165Checker = artifacts.require('$ERC165Checker');",
          "6: const ERC165Storage = artifacts.require('$ERC165Storage');",
          "7: const ERC165MissingData = artifacts.require('ERC165MissingData');",
          "8: const ERC165MaliciousData = artifacts.require('ERC165MaliciousData');",
          "9: const ERC165NotSupported = artifacts.require('ERC165NotSupported');",
          "10: const ERC165ReturnBombMock = artifacts.require('ERC165ReturnBombMock');",
          "12: const DUMMY_ID = '0xdeadbeef';",
          "13: const DUMMY_ID_2 = '0xcafebabe';",
          "14: const DUMMY_ID_3 = '0xdecafbad';",
          "15: const DUMMY_UNSUPPORTED_ID = '0xbaddcafe';",
          "16: const DUMMY_UNSUPPORTED_ID_2 = '0xbaadcafe';",
          "17: const DUMMY_ACCOUNT = '0x1111111111111111111111111111111111111111';",
          "19: contract('ERC165Checker', function () {",
          "20:   beforeEach(async function () {",
          "21:     this.mock = await ERC165Checker.new();",
          "22:   });",
          "24:   context('ERC165 missing return data', function () {",
          "25:     beforeEach(async function () {",
          "26:       this.target = await ERC165MissingData.new();",
          "27:     });",
          "29:     it('does not support ERC165', async function () {",
          "30:       const supported = await this.mock.$supportsERC165(this.target.address);",
          "31:       expect(supported).to.equal(false);",
          "32:     });",
          "34:     it('does not support mock interface via supportsInterface', async function () {",
          "35:       const supported = await this.mock.$supportsInterface(this.target.address, DUMMY_ID);",
          "36:       expect(supported).to.equal(false);",
          "37:     });",
          "39:     it('does not support mock interface via supportsAllInterfaces', async function () {",
          "40:       const supported = await this.mock.$supportsAllInterfaces(this.target.address, [DUMMY_ID]);",
          "41:       expect(supported).to.equal(false);",
          "42:     });",
          "44:     it('does not support mock interface via getSupportedInterfaces', async function () {",
          "45:       const supported = await this.mock.$getSupportedInterfaces(this.target.address, [DUMMY_ID]);",
          "46:       expect(supported.length).to.equal(1);",
          "47:       expect(supported[0]).to.equal(false);",
          "48:     });",
          "50:     it('does not support mock interface via supportsERC165InterfaceUnchecked', async function () {",
          "51:       const supported = await this.mock.$supportsERC165InterfaceUnchecked(this.target.address, DUMMY_ID);",
          "52:       expect(supported).to.equal(false);",
          "53:     });",
          "54:   });",
          "56:   context('ERC165 malicious return data', function () {",
          "57:     beforeEach(async function () {",
          "58:       this.target = await ERC165MaliciousData.new();",
          "59:     });",
          "61:     it('does not support ERC165', async function () {",
          "62:       const supported = await this.mock.$supportsERC165(this.target.address);",
          "63:       expect(supported).to.equal(false);",
          "64:     });",
          "66:     it('does not support mock interface via supportsInterface', async function () {",
          "67:       const supported = await this.mock.$supportsInterface(this.target.address, DUMMY_ID);",
          "68:       expect(supported).to.equal(false);",
          "69:     });",
          "71:     it('does not support mock interface via supportsAllInterfaces', async function () {",
          "72:       const supported = await this.mock.$supportsAllInterfaces(this.target.address, [DUMMY_ID]);",
          "73:       expect(supported).to.equal(false);",
          "74:     });",
          "76:     it('does not support mock interface via getSupportedInterfaces', async function () {",
          "77:       const supported = await this.mock.$getSupportedInterfaces(this.target.address, [DUMMY_ID]);",
          "78:       expect(supported.length).to.equal(1);",
          "79:       expect(supported[0]).to.equal(false);",
          "80:     });",
          "82:     it('does not support mock interface via supportsERC165InterfaceUnchecked', async function () {",
          "83:       const supported = await this.mock.$supportsERC165InterfaceUnchecked(this.target.address, DUMMY_ID);",
          "84:       expect(supported).to.equal(true);",
          "85:     });",
          "86:   });",
          "88:   context('ERC165 not supported', function () {",
          "89:     beforeEach(async function () {",
          "90:       this.target = await ERC165NotSupported.new();",
          "91:     });",
          "93:     it('does not support ERC165', async function () {",
          "94:       const supported = await this.mock.$supportsERC165(this.target.address);",
          "95:       expect(supported).to.equal(false);",
          "96:     });",
          "98:     it('does not support mock interface via supportsInterface', async function () {",
          "99:       const supported = await this.mock.$supportsInterface(this.target.address, DUMMY_ID);",
          "100:       expect(supported).to.equal(false);",
          "101:     });",
          "103:     it('does not support mock interface via supportsAllInterfaces', async function () {",
          "104:       const supported = await this.mock.$supportsAllInterfaces(this.target.address, [DUMMY_ID]);",
          "105:       expect(supported).to.equal(false);",
          "106:     });",
          "108:     it('does not support mock interface via getSupportedInterfaces', async function () {",
          "109:       const supported = await this.mock.$getSupportedInterfaces(this.target.address, [DUMMY_ID]);",
          "110:       expect(supported.length).to.equal(1);",
          "111:       expect(supported[0]).to.equal(false);",
          "112:     });",
          "114:     it('does not support mock interface via supportsERC165InterfaceUnchecked', async function () {",
          "115:       const supported = await this.mock.$supportsERC165InterfaceUnchecked(this.target.address, DUMMY_ID);",
          "116:       expect(supported).to.equal(false);",
          "117:     });",
          "118:   });",
          "120:   context('ERC165 supported', function () {",
          "121:     beforeEach(async function () {",
          "122:       this.target = await ERC165Storage.new();",
          "123:     });",
          "125:     it('supports ERC165', async function () {",
          "126:       const supported = await this.mock.$supportsERC165(this.target.address);",
          "127:       expect(supported).to.equal(true);",
          "128:     });",
          "130:     it('does not support mock interface via supportsInterface', async function () {",
          "131:       const supported = await this.mock.$supportsInterface(this.target.address, DUMMY_ID);",
          "132:       expect(supported).to.equal(false);",
          "133:     });",
          "135:     it('does not support mock interface via supportsAllInterfaces', async function () {",
          "136:       const supported = await this.mock.$supportsAllInterfaces(this.target.address, [DUMMY_ID]);",
          "137:       expect(supported).to.equal(false);",
          "138:     });",
          "140:     it('does not support mock interface via getSupportedInterfaces', async function () {",
          "141:       const supported = await this.mock.$getSupportedInterfaces(this.target.address, [DUMMY_ID]);",
          "142:       expect(supported.length).to.equal(1);",
          "143:       expect(supported[0]).to.equal(false);",
          "144:     });",
          "146:     it('does not support mock interface via supportsERC165InterfaceUnchecked', async function () {",
          "147:       const supported = await this.mock.$supportsERC165InterfaceUnchecked(this.target.address, DUMMY_ID);",
          "148:       expect(supported).to.equal(false);",
          "149:     });",
          "150:   });",
          "152:   context('ERC165 and single interface supported', function () {",
          "153:     beforeEach(async function () {",
          "154:       this.target = await ERC165Storage.new();",
          "155:       await this.target.$_registerInterface(DUMMY_ID);",
          "156:     });",
          "158:     it('supports ERC165', async function () {",
          "159:       const supported = await this.mock.$supportsERC165(this.target.address);",
          "160:       expect(supported).to.equal(true);",
          "161:     });",
          "163:     it('supports mock interface via supportsInterface', async function () {",
          "164:       const supported = await this.mock.$supportsInterface(this.target.address, DUMMY_ID);",
          "165:       expect(supported).to.equal(true);",
          "166:     });",
          "168:     it('supports mock interface via supportsAllInterfaces', async function () {",
          "169:       const supported = await this.mock.$supportsAllInterfaces(this.target.address, [DUMMY_ID]);",
          "170:       expect(supported).to.equal(true);",
          "171:     });",
          "173:     it('supports mock interface via getSupportedInterfaces', async function () {",
          "174:       const supported = await this.mock.$getSupportedInterfaces(this.target.address, [DUMMY_ID]);",
          "175:       expect(supported.length).to.equal(1);",
          "176:       expect(supported[0]).to.equal(true);",
          "177:     });",
          "179:     it('supports mock interface via supportsERC165InterfaceUnchecked', async function () {",
          "180:       const supported = await this.mock.$supportsERC165InterfaceUnchecked(this.target.address, DUMMY_ID);",
          "181:       expect(supported).to.equal(true);",
          "182:     });",
          "183:   });",
          "185:   context('ERC165 and many interfaces supported', function () {",
          "186:     beforeEach(async function () {",
          "187:       this.supportedInterfaces = [DUMMY_ID, DUMMY_ID_2, DUMMY_ID_3];",
          "188:       this.target = await ERC165Storage.new();",
          "189:       await Promise.all(this.supportedInterfaces.map(interfaceId => this.target.$_registerInterface(interfaceId)));",
          "190:     });",
          "192:     it('supports ERC165', async function () {",
          "193:       const supported = await this.mock.$supportsERC165(this.target.address);",
          "194:       expect(supported).to.equal(true);",
          "195:     });",
          "197:     it('supports each interfaceId via supportsInterface', async function () {",
          "198:       for (const interfaceId of this.supportedInterfaces) {",
          "199:         const supported = await this.mock.$supportsInterface(this.target.address, interfaceId);",
          "200:         expect(supported).to.equal(true);",
          "201:       }",
          "202:     });",
          "204:     it('supports all interfaceIds via supportsAllInterfaces', async function () {",
          "205:       const supported = await this.mock.$supportsAllInterfaces(this.target.address, this.supportedInterfaces);",
          "206:       expect(supported).to.equal(true);",
          "207:     });",
          "209:     it('supports none of the interfaces queried via supportsAllInterfaces', async function () {",
          "210:       const interfaceIdsToTest = [DUMMY_UNSUPPORTED_ID, DUMMY_UNSUPPORTED_ID_2];",
          "212:       const supported = await this.mock.$supportsAllInterfaces(this.target.address, interfaceIdsToTest);",
          "213:       expect(supported).to.equal(false);",
          "214:     });",
          "216:     it('supports not all of the interfaces queried via supportsAllInterfaces', async function () {",
          "217:       const interfaceIdsToTest = [...this.supportedInterfaces, DUMMY_UNSUPPORTED_ID];",
          "219:       const supported = await this.mock.$supportsAllInterfaces(this.target.address, interfaceIdsToTest);",
          "220:       expect(supported).to.equal(false);",
          "221:     });",
          "223:     it('supports all interfaceIds via getSupportedInterfaces', async function () {",
          "224:       const supported = await this.mock.$getSupportedInterfaces(this.target.address, this.supportedInterfaces);",
          "225:       expect(supported.length).to.equal(3);",
          "226:       expect(supported[0]).to.equal(true);",
          "227:       expect(supported[1]).to.equal(true);",
          "228:       expect(supported[2]).to.equal(true);",
          "229:     });",
          "231:     it('supports none of the interfaces queried via getSupportedInterfaces', async function () {",
          "232:       const interfaceIdsToTest = [DUMMY_UNSUPPORTED_ID, DUMMY_UNSUPPORTED_ID_2];",
          "234:       const supported = await this.mock.$getSupportedInterfaces(this.target.address, interfaceIdsToTest);",
          "235:       expect(supported.length).to.equal(2);",
          "236:       expect(supported[0]).to.equal(false);",
          "237:       expect(supported[1]).to.equal(false);",
          "238:     });",
          "240:     it('supports not all of the interfaces queried via getSupportedInterfaces', async function () {",
          "241:       const interfaceIdsToTest = [...this.supportedInterfaces, DUMMY_UNSUPPORTED_ID];",
          "243:       const supported = await this.mock.$getSupportedInterfaces(this.target.address, interfaceIdsToTest);",
          "244:       expect(supported.length).to.equal(4);",
          "245:       expect(supported[0]).to.equal(true);",
          "246:       expect(supported[1]).to.equal(true);",
          "247:       expect(supported[2]).to.equal(true);",
          "248:       expect(supported[3]).to.equal(false);",
          "249:     });",
          "251:     it('supports each interfaceId via supportsERC165InterfaceUnchecked', async function () {",
          "252:       for (const interfaceId of this.supportedInterfaces) {",
          "253:         const supported = await this.mock.$supportsERC165InterfaceUnchecked(this.target.address, interfaceId);",
          "254:         expect(supported).to.equal(true);",
          "255:       }",
          "256:     });",
          "257:   });",
          "259:   context('account address does not support ERC165', function () {",
          "260:     it('does not support ERC165', async function () {",
          "261:       const supported = await this.mock.$supportsERC165(DUMMY_ACCOUNT);",
          "262:       expect(supported).to.equal(false);",
          "263:     });",
          "265:     it('does not support mock interface via supportsInterface', async function () {",
          "266:       const supported = await this.mock.$supportsInterface(DUMMY_ACCOUNT, DUMMY_ID);",
          "267:       expect(supported).to.equal(false);",
          "268:     });",
          "270:     it('does not support mock interface via supportsAllInterfaces', async function () {",
          "271:       const supported = await this.mock.$supportsAllInterfaces(DUMMY_ACCOUNT, [DUMMY_ID]);",
          "272:       expect(supported).to.equal(false);",
          "273:     });",
          "275:     it('does not support mock interface via getSupportedInterfaces', async function () {",
          "276:       const supported = await this.mock.$getSupportedInterfaces(DUMMY_ACCOUNT, [DUMMY_ID]);",
          "277:       expect(supported.length).to.equal(1);",
          "278:       expect(supported[0]).to.equal(false);",
          "279:     });",
          "281:     it('does not support mock interface via supportsERC165InterfaceUnchecked', async function () {",
          "282:       const supported = await this.mock.$supportsERC165InterfaceUnchecked(DUMMY_ACCOUNT, DUMMY_ID);",
          "283:       expect(supported).to.equal(false);",
          "284:     });",
          "285:   });",
          "287:   it('Return bomb resistance', async function () {",
          "288:     this.target = await ERC165ReturnBombMock.new();",
          "290:     const tx1 = await this.mock.$supportsInterface.sendTransaction(this.target.address, DUMMY_ID);",
          "291:     expect(tx1.receipt.gasUsed).to.be.lessThan(120000); // 3*30k + 21k + some margin",
          "293:     const tx2 = await this.mock.$getSupportedInterfaces.sendTransaction(this.target.address, [",
          "294:       DUMMY_ID,",
          "295:       DUMMY_ID_2,",
          "296:       DUMMY_ID_3,",
          "297:       DUMMY_UNSUPPORTED_ID,",
          "298:       DUMMY_UNSUPPORTED_ID_2,",
          "299:     ]);",
          "300:     expect(tx2.receipt.gasUsed).to.be.lessThan(250000); // (2+5)*30k + 21k + some margin",
          "301:   });",
          "302: });",
          "",
          "---------------"
        ],
        "test/utils/introspection/ERC165Storage.test.js||test/utils/introspection/ERC165Storage.test.js": [
          "File: test/utils/introspection/ERC165Storage.test.js -> test/utils/introspection/ERC165Storage.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectRevert } = require('@openzeppelin/test-helpers');",
          "3: const { shouldSupportInterfaces } = require('./SupportsInterface.behavior');",
          "5: const ERC165Storage = artifacts.require('$ERC165Storage');",
          "7: contract('ERC165Storage', function () {",
          "8:   beforeEach(async function () {",
          "9:     this.mock = await ERC165Storage.new();",
          "10:   });",
          "12:   it('register interface', async function () {",
          "13:     expect(await this.mock.supportsInterface('0x00000001')).to.be.equal(false);",
          "14:     await this.mock.$_registerInterface('0x00000001');",
          "15:     expect(await this.mock.supportsInterface('0x00000001')).to.be.equal(true);",
          "16:   });",
          "18:   it('does not allow 0xffffffff', async function () {",
          "19:     await expectRevert(this.mock.$_registerInterface('0xffffffff'), 'ERC165: invalid interface id');",
          "20:   });",
          "22:   shouldSupportInterfaces(['ERC165']);",
          "23: });",
          "",
          "---------------"
        ],
        "test/utils/introspection/ERC1820Implementer.test.js||test/utils/introspection/ERC1820Implementer.test.js": [
          "File: test/utils/introspection/ERC1820Implementer.test.js -> test/utils/introspection/ERC1820Implementer.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectRevert, singletons } = require('@openzeppelin/test-helpers');",
          "2: const { bufferToHex, keccakFromString } = require('ethereumjs-util');",
          "4: const { expect } = require('chai');",
          "6: const ERC1820Implementer = artifacts.require('$ERC1820Implementer');",
          "8: contract('ERC1820Implementer', function (accounts) {",
          "9:   const [registryFunder, implementee, other] = accounts;",
          "11:   const ERC1820_ACCEPT_MAGIC = bufferToHex(keccakFromString('ERC1820_ACCEPT_MAGIC'));",
          "13:   beforeEach(async function () {",
          "14:     this.implementer = await ERC1820Implementer.new();",
          "15:     this.registry = await singletons.ERC1820Registry(registryFunder);",
          "17:     this.interfaceA = bufferToHex(keccakFromString('interfaceA'));",
          "18:     this.interfaceB = bufferToHex(keccakFromString('interfaceB'));",
          "19:   });",
          "21:   context('with no registered interfaces', function () {",
          "22:     it('returns false when interface implementation is queried', async function () {",
          "23:       expect(await this.implementer.canImplementInterfaceForAddress(this.interfaceA, implementee)).to.not.equal(",
          "24:         ERC1820_ACCEPT_MAGIC,",
          "25:       );",
          "26:     });",
          "28:     it('reverts when attempting to set as implementer in the registry', async function () {",
          "29:       await expectRevert(",
          "30:         this.registry.setInterfaceImplementer(implementee, this.interfaceA, this.implementer.address, {",
          "31:           from: implementee,",
          "32:         }),",
          "33:         'Does not implement the interface',",
          "34:       );",
          "35:     });",
          "36:   });",
          "38:   context('with registered interfaces', function () {",
          "39:     beforeEach(async function () {",
          "40:       await this.implementer.$_registerInterfaceForAddress(this.interfaceA, implementee);",
          "41:     });",
          "43:     it('returns true when interface implementation is queried', async function () {",
          "44:       expect(await this.implementer.canImplementInterfaceForAddress(this.interfaceA, implementee)).to.equal(",
          "45:         ERC1820_ACCEPT_MAGIC,",
          "46:       );",
          "47:     });",
          "49:     it('returns false when interface implementation for non-supported interfaces is queried', async function () {",
          "50:       expect(await this.implementer.canImplementInterfaceForAddress(this.interfaceB, implementee)).to.not.equal(",
          "51:         ERC1820_ACCEPT_MAGIC,",
          "52:       );",
          "53:     });",
          "55:     it('returns false when interface implementation for non-supported addresses is queried', async function () {",
          "56:       expect(await this.implementer.canImplementInterfaceForAddress(this.interfaceA, other)).to.not.equal(",
          "57:         ERC1820_ACCEPT_MAGIC,",
          "58:       );",
          "59:     });",
          "61:     it('can be set as an implementer for supported interfaces in the registry', async function () {",
          "62:       await this.registry.setInterfaceImplementer(implementee, this.interfaceA, this.implementer.address, {",
          "63:         from: implementee,",
          "64:       });",
          "66:       expect(await this.registry.getInterfaceImplementer(implementee, this.interfaceA)).to.equal(",
          "67:         this.implementer.address,",
          "68:       );",
          "69:     });",
          "70:   });",
          "71: });",
          "",
          "---------------"
        ],
        "test/utils/introspection/SupportsInterface.behavior.js||test/utils/introspection/SupportsInterface.behavior.js": [
          "File: test/utils/introspection/SupportsInterface.behavior.js -> test/utils/introspection/SupportsInterface.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { makeInterfaceId } = require('@openzeppelin/test-helpers');",
          "3: const { expect } = require('chai');",
          "5: const INTERFACES = {",
          "6:   ERC165: ['supportsInterface(bytes4)'],",
          "7:   ERC721: [",
          "8:     'balanceOf(address)',",
          "9:     'ownerOf(uint256)',",
          "10:     'approve(address,uint256)',",
          "11:     'getApproved(uint256)',",
          "12:     'setApprovalForAll(address,bool)',",
          "13:     'isApprovedForAll(address,address)',",
          "14:     'transferFrom(address,address,uint256)',",
          "15:     'safeTransferFrom(address,address,uint256)',",
          "16:     'safeTransferFrom(address,address,uint256,bytes)',",
          "17:   ],",
          "18:   ERC721Enumerable: ['totalSupply()', 'tokenOfOwnerByIndex(address,uint256)', 'tokenByIndex(uint256)'],",
          "19:   ERC721Metadata: ['name()', 'symbol()', 'tokenURI(uint256)'],",
          "20:   ERC1155: [",
          "21:     'balanceOf(address,uint256)',",
          "22:     'balanceOfBatch(address[],uint256[])',",
          "23:     'setApprovalForAll(address,bool)',",
          "24:     'isApprovedForAll(address,address)',",
          "25:     'safeTransferFrom(address,address,uint256,uint256,bytes)',",
          "26:     'safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)',",
          "27:   ],",
          "28:   ERC1155Receiver: [",
          "29:     'onERC1155Received(address,address,uint256,uint256,bytes)',",
          "30:     'onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)',",
          "31:   ],",
          "32:   AccessControl: [",
          "33:     'hasRole(bytes32,address)',",
          "34:     'getRoleAdmin(bytes32)',",
          "35:     'grantRole(bytes32,address)',",
          "36:     'revokeRole(bytes32,address)',",
          "37:     'renounceRole(bytes32,address)',",
          "38:   ],",
          "39:   AccessControlEnumerable: ['getRoleMember(bytes32,uint256)', 'getRoleMemberCount(bytes32)'],",
          "40:   AccessControlDefaultAdminRules: [",
          "41:     'defaultAdminDelay()',",
          "42:     'pendingDefaultAdminDelay()',",
          "43:     'defaultAdmin()',",
          "44:     'pendingDefaultAdmin()',",
          "45:     'defaultAdminDelayIncreaseWait()',",
          "46:     'changeDefaultAdminDelay(uint48)',",
          "47:     'rollbackDefaultAdminDelay()',",
          "48:     'beginDefaultAdminTransfer(address)',",
          "49:     'acceptDefaultAdminTransfer()',",
          "50:     'cancelDefaultAdminTransfer()',",
          "51:   ],",
          "52:   Governor: [",
          "53:     'name()',",
          "54:     'version()',",
          "55:     'COUNTING_MODE()',",
          "56:     'hashProposal(address[],uint256[],bytes[],bytes32)',",
          "57:     'state(uint256)',",
          "58:     'proposalSnapshot(uint256)',",
          "59:     'proposalDeadline(uint256)',",
          "60:     'votingDelay()',",
          "61:     'votingPeriod()',",
          "62:     'quorum(uint256)',",
          "63:     'getVotes(address,uint256)',",
          "64:     'hasVoted(uint256,address)',",
          "65:     'propose(address[],uint256[],bytes[],string)',",
          "66:     'execute(address[],uint256[],bytes[],bytes32)',",
          "67:     'castVote(uint256,uint8)',",
          "68:     'castVoteWithReason(uint256,uint8,string)',",
          "69:     'castVoteBySig(uint256,uint8,uint8,bytes32,bytes32)',",
          "70:   ],",
          "71:   GovernorWithParams: [",
          "72:     'name()',",
          "73:     'version()',",
          "74:     'COUNTING_MODE()',",
          "75:     'hashProposal(address[],uint256[],bytes[],bytes32)',",
          "76:     'state(uint256)',",
          "77:     'proposalSnapshot(uint256)',",
          "78:     'proposalDeadline(uint256)',",
          "79:     'votingDelay()',",
          "80:     'votingPeriod()',",
          "81:     'quorum(uint256)',",
          "82:     'getVotes(address,uint256)',",
          "83:     'getVotesWithParams(address,uint256,bytes)',",
          "84:     'hasVoted(uint256,address)',",
          "85:     'propose(address[],uint256[],bytes[],string)',",
          "86:     'execute(address[],uint256[],bytes[],bytes32)',",
          "87:     'castVote(uint256,uint8)',",
          "88:     'castVoteWithReason(uint256,uint8,string)',",
          "89:     'castVoteWithReasonAndParams(uint256,uint8,string,bytes)',",
          "90:     'castVoteBySig(uint256,uint8,uint8,bytes32,bytes32)',",
          "91:     'castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32)',",
          "92:   ],",
          "93:   GovernorCancel: ['proposalProposer(uint256)', 'cancel(address[],uint256[],bytes[],bytes32)'],",
          "94:   GovernorTimelock: ['timelock()', 'proposalEta(uint256)', 'queue(address[],uint256[],bytes[],bytes32)'],",
          "95:   ERC2981: ['royaltyInfo(uint256,uint256)'],",
          "96: };",
          "98: const INTERFACE_IDS = {};",
          "99: const FN_SIGNATURES = {};",
          "100: for (const k of Object.getOwnPropertyNames(INTERFACES)) {",
          "101:   INTERFACE_IDS[k] = makeInterfaceId.ERC165(INTERFACES[k]);",
          "102:   for (const fnName of INTERFACES[k]) {",
          "104:     FN_SIGNATURES[fnName] = makeInterfaceId.ERC165([fnName]);",
          "105:   }",
          "106: }",
          "108: function shouldSupportInterfaces(interfaces = []) {",
          "109:   describe('ERC165', function () {",
          "110:     beforeEach(function () {",
          "111:       this.contractUnderTest = this.mock || this.token || this.holder || this.accessControl;",
          "112:     });",
          "114:     it('supportsInterface uses less than 30k gas', async function () {",
          "115:       for (const k of interfaces) {",
          "116:         const interfaceId = INTERFACE_IDS[k] ?? k;",
          "117:         expect(await this.contractUnderTest.supportsInterface.estimateGas(interfaceId)).to.be.lte(30000);",
          "118:       }",
          "119:     });",
          "121:     it('all interfaces are reported as supported', async function () {",
          "122:       for (const k of interfaces) {",
          "123:         const interfaceId = INTERFACE_IDS[k] ?? k;",
          "124:         expect(await this.contractUnderTest.supportsInterface(interfaceId)).to.equal(true, `does not support ${k}`);",
          "125:       }",
          "126:     });",
          "128:     it('all interface functions are in ABI', async function () {",
          "129:       for (const k of interfaces) {",
          "131:         if (INTERFACES[k] === undefined) continue;",
          "132:         for (const fnName of INTERFACES[k]) {",
          "133:           const fnSig = FN_SIGNATURES[fnName];",
          "134:           expect(this.contractUnderTest.abi.filter(fn => fn.signature === fnSig).length).to.equal(",
          "135:             1,",
          "136:             `did not find ${fnName}`,",
          "137:           );",
          "138:         }",
          "139:       }",
          "140:     });",
          "141:   });",
          "142: }",
          "144: module.exports = {",
          "145:   shouldSupportInterfaces,",
          "146: };",
          "",
          "---------------"
        ],
        "test/utils/math/Math.t.sol||test/utils/math/Math.t.sol": [
          "File: test/utils/math/Math.t.sol -> test/utils/math/Math.t.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.0;",
          "5: import \"forge-std/Test.sol\";",
          "7: import \"../../../contracts/utils/math/Math.sol\";",
          "8: import \"../../../contracts/utils/math/SafeMath.sol\";",
          "10: contract MathTest is Test {",
          "12:     function testCeilDiv(uint256 a, uint256 b) public {",
          "13:         vm.assume(b > 0);",
          "15:         uint256 result = Math.ceilDiv(a, b);",
          "17:         if (result == 0) {",
          "18:             assertEq(a, 0);",
          "19:         } else {",
          "20:             uint256 maxdiv = UINT256_MAX / b;",
          "21:             bool overflow = maxdiv * b < a;",
          "22:             assertTrue(a > b * (result - 1));",
          "23:             assertTrue(overflow ? result == maxdiv + 1 : a <= b * result);",
          "24:         }",
          "25:     }",
          "28:     function testSqrt(uint256 input, uint8 r) public {",
          "29:         Math.Rounding rounding = _asRounding(r);",
          "31:         uint256 result = Math.sqrt(input, rounding);",
          "34:         if (_squareBigger(result, input)) {",
          "35:             assertTrue(rounding == Math.Rounding.Up);",
          "36:             assertTrue(_squareSmaller(result - 1, input));",
          "37:         }",
          "39:         else if (_squareSmaller(result, input)) {",
          "40:             assertFalse(rounding == Math.Rounding.Up);",
          "41:             assertTrue(_squareBigger(result + 1, input));",
          "42:         }",
          "44:         else {",
          "45:             assertEq(result * result, input);",
          "46:         }",
          "47:     }",
          "49:     function _squareBigger(uint256 value, uint256 ref) private pure returns (bool) {",
          "50:         (bool noOverflow, uint256 square) = SafeMath.tryMul(value, value);",
          "51:         return !noOverflow || square > ref;",
          "52:     }",
          "54:     function _squareSmaller(uint256 value, uint256 ref) private pure returns (bool) {",
          "55:         return value * value < ref;",
          "56:     }",
          "59:     function testLog2(uint256 input, uint8 r) public {",
          "60:         Math.Rounding rounding = _asRounding(r);",
          "62:         uint256 result = Math.log2(input, rounding);",
          "64:         if (input == 0) {",
          "65:             assertEq(result, 0);",
          "66:         } else if (_powerOf2Bigger(result, input)) {",
          "67:             assertTrue(rounding == Math.Rounding.Up);",
          "68:             assertTrue(_powerOf2Smaller(result - 1, input));",
          "69:         } else if (_powerOf2Smaller(result, input)) {",
          "70:             assertFalse(rounding == Math.Rounding.Up);",
          "71:             assertTrue(_powerOf2Bigger(result + 1, input));",
          "72:         } else {",
          "73:             assertEq(2 ** result, input);",
          "74:         }",
          "75:     }",
          "77:     function _powerOf2Bigger(uint256 value, uint256 ref) private pure returns (bool) {",
          "78:         return value >= 256 || 2 ** value > ref; // 2**256 overflows uint256",
          "79:     }",
          "81:     function _powerOf2Smaller(uint256 value, uint256 ref) private pure returns (bool) {",
          "82:         return 2 ** value < ref;",
          "83:     }",
          "86:     function testLog10(uint256 input, uint8 r) public {",
          "87:         Math.Rounding rounding = _asRounding(r);",
          "89:         uint256 result = Math.log10(input, rounding);",
          "91:         if (input == 0) {",
          "92:             assertEq(result, 0);",
          "93:         } else if (_powerOf10Bigger(result, input)) {",
          "94:             assertTrue(rounding == Math.Rounding.Up);",
          "95:             assertTrue(_powerOf10Smaller(result - 1, input));",
          "96:         } else if (_powerOf10Smaller(result, input)) {",
          "97:             assertFalse(rounding == Math.Rounding.Up);",
          "98:             assertTrue(_powerOf10Bigger(result + 1, input));",
          "99:         } else {",
          "100:             assertEq(10 ** result, input);",
          "101:         }",
          "102:     }",
          "104:     function _powerOf10Bigger(uint256 value, uint256 ref) private pure returns (bool) {",
          "105:         return value >= 78 || 10 ** value > ref; // 10**78 overflows uint256",
          "106:     }",
          "108:     function _powerOf10Smaller(uint256 value, uint256 ref) private pure returns (bool) {",
          "109:         return 10 ** value < ref;",
          "110:     }",
          "113:     function testLog256(uint256 input, uint8 r) public {",
          "114:         Math.Rounding rounding = _asRounding(r);",
          "116:         uint256 result = Math.log256(input, rounding);",
          "118:         if (input == 0) {",
          "119:             assertEq(result, 0);",
          "120:         } else if (_powerOf256Bigger(result, input)) {",
          "121:             assertTrue(rounding == Math.Rounding.Up);",
          "122:             assertTrue(_powerOf256Smaller(result - 1, input));",
          "123:         } else if (_powerOf256Smaller(result, input)) {",
          "124:             assertFalse(rounding == Math.Rounding.Up);",
          "125:             assertTrue(_powerOf256Bigger(result + 1, input));",
          "126:         } else {",
          "127:             assertEq(256 ** result, input);",
          "128:         }",
          "129:     }",
          "131:     function _powerOf256Bigger(uint256 value, uint256 ref) private pure returns (bool) {",
          "132:         return value >= 32 || 256 ** value > ref; // 256**32 overflows uint256",
          "133:     }",
          "135:     function _powerOf256Smaller(uint256 value, uint256 ref) private pure returns (bool) {",
          "136:         return 256 ** value < ref;",
          "137:     }",
          "140:     function testMulDiv(uint256 x, uint256 y, uint256 d) public {",
          "142:         (uint256 xyHi, uint256 xyLo) = _mulHighLow(x, y);",
          "146:         vm.assume(xyHi < d);",
          "149:         uint256 q = Math.mulDiv(x, y, d);",
          "152:         (uint256 qdHi, uint256 qdLo) = _mulHighLow(q, d);",
          "154:         (uint256 qdRemLo, uint256 c) = _addCarry(qdLo, _mulmod(x, y, d));",
          "155:         uint256 qdRemHi = qdHi + c;",
          "158:         assertEq(xyHi, qdRemHi);",
          "159:         assertEq(xyLo, qdRemLo);",
          "160:     }",
          "162:     function testMulDivDomain(uint256 x, uint256 y, uint256 d) public {",
          "163:         (uint256 xyHi, ) = _mulHighLow(x, y);",
          "166:         vm.assume(xyHi >= d);",
          "169:         try this.muldiv(x, y, d) returns (uint256) {",
          "170:             fail();",
          "171:         } catch {}",
          "172:     }",
          "175:     function muldiv(uint256 x, uint256 y, uint256 d) external pure returns (uint256) {",
          "176:         return Math.mulDiv(x, y, d);",
          "177:     }",
          "180:     function _asRounding(uint8 r) private pure returns (Math.Rounding) {",
          "181:         vm.assume(r < uint8(type(Math.Rounding).max));",
          "182:         return Math.Rounding(r);",
          "183:     }",
          "185:     function _mulmod(uint256 x, uint256 y, uint256 z) private pure returns (uint256 r) {",
          "186:         assembly {",
          "187:             r := mulmod(x, y, z)",
          "188:         }",
          "189:     }",
          "191:     function _mulHighLow(uint256 x, uint256 y) private pure returns (uint256 high, uint256 low) {",
          "192:         (uint256 x0, uint256 x1) = (x & type(uint128).max, x >> 128);",
          "193:         (uint256 y0, uint256 y1) = (y & type(uint128).max, y >> 128);",
          "197:         uint256 z2 = x1 * y1;",
          "198:         uint256 z1a = x1 * y0;",
          "199:         uint256 z1b = x0 * y1;",
          "200:         uint256 z0 = x0 * y0;",
          "202:         uint256 carry = ((z1a & type(uint128).max) + (z1b & type(uint128).max) + (z0 >> 128)) >> 128;",
          "204:         high = z2 + (z1a >> 128) + (z1b >> 128) + carry;",
          "206:         unchecked {",
          "207:             low = x * y;",
          "208:         }",
          "209:     }",
          "211:     function _addCarry(uint256 x, uint256 y) private pure returns (uint256 res, uint256 carry) {",
          "212:         unchecked {",
          "213:             res = x + y;",
          "214:         }",
          "215:         carry = res < x ? 1 : 0;",
          "216:     }",
          "217: }",
          "",
          "---------------"
        ],
        "test/utils/math/Math.test.js||test/utils/math/Math.test.js": [
          "File: test/utils/math/Math.test.js -> test/utils/math/Math.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const { MAX_UINT256 } = constants;",
          "4: const { Rounding } = require('../../helpers/enums.js');",
          "6: const Math = artifacts.require('$Math');",
          "8: contract('Math', function () {",
          "9:   const min = new BN('1234');",
          "10:   const max = new BN('5678');",
          "11:   const MAX_UINT256_SUB1 = MAX_UINT256.sub(new BN('1'));",
          "12:   const MAX_UINT256_SUB2 = MAX_UINT256.sub(new BN('2'));",
          "14:   beforeEach(async function () {",
          "15:     this.math = await Math.new();",
          "16:   });",
          "18:   describe('max', function () {",
          "19:     it('is correctly detected in first argument position', async function () {",
          "20:       expect(await this.math.$max(max, min)).to.be.bignumber.equal(max);",
          "21:     });",
          "23:     it('is correctly detected in second argument position', async function () {",
          "24:       expect(await this.math.$max(min, max)).to.be.bignumber.equal(max);",
          "25:     });",
          "26:   });",
          "28:   describe('min', function () {",
          "29:     it('is correctly detected in first argument position', async function () {",
          "30:       expect(await this.math.$min(min, max)).to.be.bignumber.equal(min);",
          "31:     });",
          "33:     it('is correctly detected in second argument position', async function () {",
          "34:       expect(await this.math.$min(max, min)).to.be.bignumber.equal(min);",
          "35:     });",
          "36:   });",
          "38:   describe('average', function () {",
          "39:     function bnAverage(a, b) {",
          "40:       return a.add(b).divn(2);",
          "41:     }",
          "43:     it('is correctly calculated with two odd numbers', async function () {",
          "44:       const a = new BN('57417');",
          "45:       const b = new BN('95431');",
          "46:       expect(await this.math.$average(a, b)).to.be.bignumber.equal(bnAverage(a, b));",
          "47:     });",
          "49:     it('is correctly calculated with two even numbers', async function () {",
          "50:       const a = new BN('42304');",
          "51:       const b = new BN('84346');",
          "52:       expect(await this.math.$average(a, b)).to.be.bignumber.equal(bnAverage(a, b));",
          "53:     });",
          "55:     it('is correctly calculated with one even and one odd number', async function () {",
          "56:       const a = new BN('57417');",
          "57:       const b = new BN('84346');",
          "58:       expect(await this.math.$average(a, b)).to.be.bignumber.equal(bnAverage(a, b));",
          "59:     });",
          "61:     it('is correctly calculated with two max uint256 numbers', async function () {",
          "62:       const a = MAX_UINT256;",
          "63:       expect(await this.math.$average(a, a)).to.be.bignumber.equal(bnAverage(a, a));",
          "64:     });",
          "65:   });",
          "67:   describe('ceilDiv', function () {",
          "68:     it('does not round up on exact division', async function () {",
          "69:       const a = new BN('10');",
          "70:       const b = new BN('5');",
          "71:       expect(await this.math.$ceilDiv(a, b)).to.be.bignumber.equal('2');",
          "72:     });",
          "74:     it('rounds up on division with remainders', async function () {",
          "75:       const a = new BN('42');",
          "76:       const b = new BN('13');",
          "77:       expect(await this.math.$ceilDiv(a, b)).to.be.bignumber.equal('4');",
          "78:     });",
          "80:     it('does not overflow', async function () {",
          "81:       const b = new BN('2');",
          "82:       const result = new BN('1').shln(255);",
          "83:       expect(await this.math.$ceilDiv(MAX_UINT256, b)).to.be.bignumber.equal(result);",
          "84:     });",
          "86:     it('correctly computes max uint256 divided by 1', async function () {",
          "87:       const b = new BN('1');",
          "88:       expect(await this.math.$ceilDiv(MAX_UINT256, b)).to.be.bignumber.equal(MAX_UINT256);",
          "89:     });",
          "90:   });",
          "92:   describe('muldiv', function () {",
          "93:     it('divide by 0', async function () {",
          "94:       await expectRevert.unspecified(this.math.$mulDiv(1, 1, 0, Rounding.Down));",
          "95:     });",
          "97:     describe('does round down', async function () {",
          "98:       it('small values', async function () {",
          "99:         expect(await this.math.$mulDiv('3', '4', '5', Rounding.Down)).to.be.bignumber.equal('2');",
          "100:         expect(await this.math.$mulDiv('3', '5', '5', Rounding.Down)).to.be.bignumber.equal('3');",
          "101:       });",
          "103:       it('large values', async function () {",
          "104:         expect(",
          "105:           await this.math.$mulDiv(new BN('42'), MAX_UINT256_SUB1, MAX_UINT256, Rounding.Down),",
          "106:         ).to.be.bignumber.equal(new BN('41'));",
          "108:         expect(await this.math.$mulDiv(new BN('17'), MAX_UINT256, MAX_UINT256, Rounding.Down)).to.be.bignumber.equal(",
          "109:           new BN('17'),",
          "110:         );",
          "112:         expect(",
          "113:           await this.math.$mulDiv(MAX_UINT256_SUB1, MAX_UINT256_SUB1, MAX_UINT256, Rounding.Down),",
          "114:         ).to.be.bignumber.equal(MAX_UINT256_SUB2);",
          "116:         expect(",
          "117:           await this.math.$mulDiv(MAX_UINT256, MAX_UINT256_SUB1, MAX_UINT256, Rounding.Down),",
          "118:         ).to.be.bignumber.equal(MAX_UINT256_SUB1);",
          "120:         expect(await this.math.$mulDiv(MAX_UINT256, MAX_UINT256, MAX_UINT256, Rounding.Down)).to.be.bignumber.equal(",
          "121:           MAX_UINT256,",
          "122:         );",
          "123:       });",
          "124:     });",
          "126:     describe('does round up', async function () {",
          "127:       it('small values', async function () {",
          "128:         expect(await this.math.$mulDiv('3', '4', '5', Rounding.Up)).to.be.bignumber.equal('3');",
          "129:         expect(await this.math.$mulDiv('3', '5', '5', Rounding.Up)).to.be.bignumber.equal('3');",
          "130:       });",
          "132:       it('large values', async function () {",
          "133:         expect(await this.math.$mulDiv(new BN('42'), MAX_UINT256_SUB1, MAX_UINT256, Rounding.Up)).to.be.bignumber.equal(",
          "134:           new BN('42'),",
          "135:         );",
          "137:         expect(await this.math.$mulDiv(new BN('17'), MAX_UINT256, MAX_UINT256, Rounding.Up)).to.be.bignumber.equal(",
          "138:           new BN('17'),",
          "139:         );",
          "141:         expect(",
          "142:           await this.math.$mulDiv(MAX_UINT256_SUB1, MAX_UINT256_SUB1, MAX_UINT256, Rounding.Up),",
          "143:         ).to.be.bignumber.equal(MAX_UINT256_SUB1);",
          "145:         expect(await this.math.$mulDiv(MAX_UINT256, MAX_UINT256_SUB1, MAX_UINT256, Rounding.Up)).to.be.bignumber.equal(",
          "146:           MAX_UINT256_SUB1,",
          "147:         );",
          "149:         expect(await this.math.$mulDiv(MAX_UINT256, MAX_UINT256, MAX_UINT256, Rounding.Up)).to.be.bignumber.equal(",
          "150:           MAX_UINT256,",
          "151:         );",
          "152:       });",
          "153:     });",
          "154:   });",
          "156:   describe('sqrt', function () {",
          "157:     it('rounds down', async function () {",
          "158:       expect(await this.math.$sqrt('0', Rounding.Down)).to.be.bignumber.equal('0');",
          "159:       expect(await this.math.$sqrt('1', Rounding.Down)).to.be.bignumber.equal('1');",
          "160:       expect(await this.math.$sqrt('2', Rounding.Down)).to.be.bignumber.equal('1');",
          "161:       expect(await this.math.$sqrt('3', Rounding.Down)).to.be.bignumber.equal('1');",
          "162:       expect(await this.math.$sqrt('4', Rounding.Down)).to.be.bignumber.equal('2');",
          "163:       expect(await this.math.$sqrt('144', Rounding.Down)).to.be.bignumber.equal('12');",
          "164:       expect(await this.math.$sqrt('999999', Rounding.Down)).to.be.bignumber.equal('999');",
          "165:       expect(await this.math.$sqrt('1000000', Rounding.Down)).to.be.bignumber.equal('1000');",
          "166:       expect(await this.math.$sqrt('1000001', Rounding.Down)).to.be.bignumber.equal('1000');",
          "167:       expect(await this.math.$sqrt('1002000', Rounding.Down)).to.be.bignumber.equal('1000');",
          "168:       expect(await this.math.$sqrt('1002001', Rounding.Down)).to.be.bignumber.equal('1001');",
          "169:       expect(await this.math.$sqrt(MAX_UINT256, Rounding.Down)).to.be.bignumber.equal(",
          "170:         '340282366920938463463374607431768211455',",
          "171:       );",
          "172:     });",
          "174:     it('rounds up', async function () {",
          "175:       expect(await this.math.$sqrt('0', Rounding.Up)).to.be.bignumber.equal('0');",
          "176:       expect(await this.math.$sqrt('1', Rounding.Up)).to.be.bignumber.equal('1');",
          "177:       expect(await this.math.$sqrt('2', Rounding.Up)).to.be.bignumber.equal('2');",
          "178:       expect(await this.math.$sqrt('3', Rounding.Up)).to.be.bignumber.equal('2');",
          "179:       expect(await this.math.$sqrt('4', Rounding.Up)).to.be.bignumber.equal('2');",
          "180:       expect(await this.math.$sqrt('144', Rounding.Up)).to.be.bignumber.equal('12');",
          "181:       expect(await this.math.$sqrt('999999', Rounding.Up)).to.be.bignumber.equal('1000');",
          "182:       expect(await this.math.$sqrt('1000000', Rounding.Up)).to.be.bignumber.equal('1000');",
          "183:       expect(await this.math.$sqrt('1000001', Rounding.Up)).to.be.bignumber.equal('1001');",
          "184:       expect(await this.math.$sqrt('1002000', Rounding.Up)).to.be.bignumber.equal('1001');",
          "185:       expect(await this.math.$sqrt('1002001', Rounding.Up)).to.be.bignumber.equal('1001');",
          "186:       expect(await this.math.$sqrt(MAX_UINT256, Rounding.Up)).to.be.bignumber.equal(",
          "187:         '340282366920938463463374607431768211456',",
          "188:       );",
          "189:     });",
          "190:   });",
          "192:   describe('log', function () {",
          "193:     describe('log2', function () {",
          "194:       it('rounds down', async function () {",
          "196:         expect(await this.math.methods['$log2(uint256,uint8)']('0', Rounding.Down)).to.be.bignumber.equal('0');",
          "197:         expect(await this.math.methods['$log2(uint256,uint8)']('1', Rounding.Down)).to.be.bignumber.equal('0');",
          "198:         expect(await this.math.methods['$log2(uint256,uint8)']('2', Rounding.Down)).to.be.bignumber.equal('1');",
          "199:         expect(await this.math.methods['$log2(uint256,uint8)']('3', Rounding.Down)).to.be.bignumber.equal('1');",
          "200:         expect(await this.math.methods['$log2(uint256,uint8)']('4', Rounding.Down)).to.be.bignumber.equal('2');",
          "201:         expect(await this.math.methods['$log2(uint256,uint8)']('5', Rounding.Down)).to.be.bignumber.equal('2');",
          "202:         expect(await this.math.methods['$log2(uint256,uint8)']('6', Rounding.Down)).to.be.bignumber.equal('2');",
          "203:         expect(await this.math.methods['$log2(uint256,uint8)']('7', Rounding.Down)).to.be.bignumber.equal('2');",
          "204:         expect(await this.math.methods['$log2(uint256,uint8)']('8', Rounding.Down)).to.be.bignumber.equal('3');",
          "205:         expect(await this.math.methods['$log2(uint256,uint8)']('9', Rounding.Down)).to.be.bignumber.equal('3');",
          "206:         expect(await this.math.methods['$log2(uint256,uint8)'](MAX_UINT256, Rounding.Down)).to.be.bignumber.equal(",
          "207:           '255',",
          "208:         );",
          "209:       });",
          "211:       it('rounds up', async function () {",
          "213:         expect(await this.math.methods['$log2(uint256,uint8)']('0', Rounding.Up)).to.be.bignumber.equal('0');",
          "214:         expect(await this.math.methods['$log2(uint256,uint8)']('1', Rounding.Up)).to.be.bignumber.equal('0');",
          "215:         expect(await this.math.methods['$log2(uint256,uint8)']('2', Rounding.Up)).to.be.bignumber.equal('1');",
          "216:         expect(await this.math.methods['$log2(uint256,uint8)']('3', Rounding.Up)).to.be.bignumber.equal('2');",
          "217:         expect(await this.math.methods['$log2(uint256,uint8)']('4', Rounding.Up)).to.be.bignumber.equal('2');",
          "218:         expect(await this.math.methods['$log2(uint256,uint8)']('5', Rounding.Up)).to.be.bignumber.equal('3');",
          "219:         expect(await this.math.methods['$log2(uint256,uint8)']('6', Rounding.Up)).to.be.bignumber.equal('3');",
          "220:         expect(await this.math.methods['$log2(uint256,uint8)']('7', Rounding.Up)).to.be.bignumber.equal('3');",
          "221:         expect(await this.math.methods['$log2(uint256,uint8)']('8', Rounding.Up)).to.be.bignumber.equal('3');",
          "222:         expect(await this.math.methods['$log2(uint256,uint8)']('9', Rounding.Up)).to.be.bignumber.equal('4');",
          "223:         expect(await this.math.methods['$log2(uint256,uint8)'](MAX_UINT256, Rounding.Up)).to.be.bignumber.equal('256');",
          "224:       });",
          "225:     });",
          "227:     describe('log10', function () {",
          "228:       it('rounds down', async function () {",
          "229:         expect(await this.math.$log10('0', Rounding.Down)).to.be.bignumber.equal('0');",
          "230:         expect(await this.math.$log10('1', Rounding.Down)).to.be.bignumber.equal('0');",
          "231:         expect(await this.math.$log10('2', Rounding.Down)).to.be.bignumber.equal('0');",
          "232:         expect(await this.math.$log10('9', Rounding.Down)).to.be.bignumber.equal('0');",
          "233:         expect(await this.math.$log10('10', Rounding.Down)).to.be.bignumber.equal('1');",
          "234:         expect(await this.math.$log10('11', Rounding.Down)).to.be.bignumber.equal('1');",
          "235:         expect(await this.math.$log10('99', Rounding.Down)).to.be.bignumber.equal('1');",
          "236:         expect(await this.math.$log10('100', Rounding.Down)).to.be.bignumber.equal('2');",
          "237:         expect(await this.math.$log10('101', Rounding.Down)).to.be.bignumber.equal('2');",
          "238:         expect(await this.math.$log10('999', Rounding.Down)).to.be.bignumber.equal('2');",
          "239:         expect(await this.math.$log10('1000', Rounding.Down)).to.be.bignumber.equal('3');",
          "240:         expect(await this.math.$log10('1001', Rounding.Down)).to.be.bignumber.equal('3');",
          "241:         expect(await this.math.$log10(MAX_UINT256, Rounding.Down)).to.be.bignumber.equal('77');",
          "242:       });",
          "244:       it('rounds up', async function () {",
          "245:         expect(await this.math.$log10('0', Rounding.Up)).to.be.bignumber.equal('0');",
          "246:         expect(await this.math.$log10('1', Rounding.Up)).to.be.bignumber.equal('0');",
          "247:         expect(await this.math.$log10('2', Rounding.Up)).to.be.bignumber.equal('1');",
          "248:         expect(await this.math.$log10('9', Rounding.Up)).to.be.bignumber.equal('1');",
          "249:         expect(await this.math.$log10('10', Rounding.Up)).to.be.bignumber.equal('1');",
          "250:         expect(await this.math.$log10('11', Rounding.Up)).to.be.bignumber.equal('2');",
          "251:         expect(await this.math.$log10('99', Rounding.Up)).to.be.bignumber.equal('2');",
          "252:         expect(await this.math.$log10('100', Rounding.Up)).to.be.bignumber.equal('2');",
          "253:         expect(await this.math.$log10('101', Rounding.Up)).to.be.bignumber.equal('3');",
          "254:         expect(await this.math.$log10('999', Rounding.Up)).to.be.bignumber.equal('3');",
          "255:         expect(await this.math.$log10('1000', Rounding.Up)).to.be.bignumber.equal('3');",
          "256:         expect(await this.math.$log10('1001', Rounding.Up)).to.be.bignumber.equal('4');",
          "257:         expect(await this.math.$log10(MAX_UINT256, Rounding.Up)).to.be.bignumber.equal('78');",
          "258:       });",
          "259:     });",
          "261:     describe('log256', function () {",
          "262:       it('rounds down', async function () {",
          "263:         expect(await this.math.$log256('0', Rounding.Down)).to.be.bignumber.equal('0');",
          "264:         expect(await this.math.$log256('1', Rounding.Down)).to.be.bignumber.equal('0');",
          "265:         expect(await this.math.$log256('2', Rounding.Down)).to.be.bignumber.equal('0');",
          "266:         expect(await this.math.$log256('255', Rounding.Down)).to.be.bignumber.equal('0');",
          "267:         expect(await this.math.$log256('256', Rounding.Down)).to.be.bignumber.equal('1');",
          "268:         expect(await this.math.$log256('257', Rounding.Down)).to.be.bignumber.equal('1');",
          "269:         expect(await this.math.$log256('65535', Rounding.Down)).to.be.bignumber.equal('1');",
          "270:         expect(await this.math.$log256('65536', Rounding.Down)).to.be.bignumber.equal('2');",
          "271:         expect(await this.math.$log256('65537', Rounding.Down)).to.be.bignumber.equal('2');",
          "272:         expect(await this.math.$log256(MAX_UINT256, Rounding.Down)).to.be.bignumber.equal('31');",
          "273:       });",
          "275:       it('rounds up', async function () {",
          "276:         expect(await this.math.$log256('0', Rounding.Up)).to.be.bignumber.equal('0');",
          "277:         expect(await this.math.$log256('1', Rounding.Up)).to.be.bignumber.equal('0');",
          "278:         expect(await this.math.$log256('2', Rounding.Up)).to.be.bignumber.equal('1');",
          "279:         expect(await this.math.$log256('255', Rounding.Up)).to.be.bignumber.equal('1');",
          "280:         expect(await this.math.$log256('256', Rounding.Up)).to.be.bignumber.equal('1');",
          "281:         expect(await this.math.$log256('257', Rounding.Up)).to.be.bignumber.equal('2');",
          "282:         expect(await this.math.$log256('65535', Rounding.Up)).to.be.bignumber.equal('2');",
          "283:         expect(await this.math.$log256('65536', Rounding.Up)).to.be.bignumber.equal('2');",
          "284:         expect(await this.math.$log256('65537', Rounding.Up)).to.be.bignumber.equal('3');",
          "285:         expect(await this.math.$log256(MAX_UINT256, Rounding.Up)).to.be.bignumber.equal('32');",
          "286:       });",
          "287:     });",
          "288:   });",
          "289: });",
          "",
          "---------------"
        ],
        "test/utils/math/SafeCast.test.js||test/utils/math/SafeCast.test.js": [
          "File: test/utils/math/SafeCast.test.js -> test/utils/math/SafeCast.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const { range } = require('../../../scripts/helpers');",
          "5: const SafeCast = artifacts.require('$SafeCast');",
          "7: contract('SafeCast', async function () {",
          "8:   beforeEach(async function () {",
          "9:     this.safeCast = await SafeCast.new();",
          "10:   });",
          "12:   function testToUint(bits) {",
          "13:     describe(`toUint${bits}`, () => {",
          "14:       const maxValue = new BN('2').pow(new BN(bits)).subn(1);",
          "16:       it('downcasts 0', async function () {",
          "17:         expect(await this.safeCast[`$toUint${bits}`](0)).to.be.bignumber.equal('0');",
          "18:       });",
          "20:       it('downcasts 1', async function () {",
          "21:         expect(await this.safeCast[`$toUint${bits}`](1)).to.be.bignumber.equal('1');",
          "22:       });",
          "24:       it(`downcasts 2^${bits} - 1 (${maxValue})`, async function () {",
          "25:         expect(await this.safeCast[`$toUint${bits}`](maxValue)).to.be.bignumber.equal(maxValue);",
          "26:       });",
          "28:       it(`reverts when downcasting 2^${bits} (${maxValue.addn(1)})`, async function () {",
          "29:         await expectRevert(",
          "30:           this.safeCast[`$toUint${bits}`](maxValue.addn(1)),",
          "31:           `SafeCast: value doesn't fit in ${bits} bits`,",
          "32:         );",
          "33:       });",
          "35:       it(`reverts when downcasting 2^${bits} + 1 (${maxValue.addn(2)})`, async function () {",
          "36:         await expectRevert(",
          "37:           this.safeCast[`$toUint${bits}`](maxValue.addn(2)),",
          "38:           `SafeCast: value doesn't fit in ${bits} bits`,",
          "39:         );",
          "40:       });",
          "41:     });",
          "42:   }",
          "44:   range(8, 256, 8).forEach(bits => testToUint(bits));",
          "46:   describe('toUint256', () => {",
          "47:     const maxInt256 = new BN('2').pow(new BN(255)).subn(1);",
          "48:     const minInt256 = new BN('2').pow(new BN(255)).neg();",
          "50:     it('casts 0', async function () {",
          "51:       expect(await this.safeCast.$toUint256(0)).to.be.bignumber.equal('0');",
          "52:     });",
          "54:     it('casts 1', async function () {",
          "55:       expect(await this.safeCast.$toUint256(1)).to.be.bignumber.equal('1');",
          "56:     });",
          "58:     it(`casts INT256_MAX (${maxInt256})`, async function () {",
          "59:       expect(await this.safeCast.$toUint256(maxInt256)).to.be.bignumber.equal(maxInt256);",
          "60:     });",
          "62:     it('reverts when casting -1', async function () {",
          "63:       await expectRevert(this.safeCast.$toUint256(-1), 'SafeCast: value must be positive');",
          "64:     });",
          "66:     it(`reverts when casting INT256_MIN (${minInt256})`, async function () {",
          "67:       await expectRevert(this.safeCast.$toUint256(minInt256), 'SafeCast: value must be positive');",
          "68:     });",
          "69:   });",
          "71:   function testToInt(bits) {",
          "72:     describe(`toInt${bits}`, () => {",
          "73:       const minValue = new BN('-2').pow(new BN(bits - 1));",
          "74:       const maxValue = new BN('2').pow(new BN(bits - 1)).subn(1);",
          "76:       it('downcasts 0', async function () {",
          "77:         expect(await this.safeCast[`$toInt${bits}`](0)).to.be.bignumber.equal('0');",
          "78:       });",
          "80:       it('downcasts 1', async function () {",
          "81:         expect(await this.safeCast[`$toInt${bits}`](1)).to.be.bignumber.equal('1');",
          "82:       });",
          "84:       it('downcasts -1', async function () {",
          "85:         expect(await this.safeCast[`$toInt${bits}`](-1)).to.be.bignumber.equal('-1');",
          "86:       });",
          "88:       it(`downcasts -2^${bits - 1} (${minValue})`, async function () {",
          "89:         expect(await this.safeCast[`$toInt${bits}`](minValue)).to.be.bignumber.equal(minValue);",
          "90:       });",
          "92:       it(`downcasts 2^${bits - 1} - 1 (${maxValue})`, async function () {",
          "93:         expect(await this.safeCast[`$toInt${bits}`](maxValue)).to.be.bignumber.equal(maxValue);",
          "94:       });",
          "96:       it(`reverts when downcasting -2^${bits - 1} - 1 (${minValue.subn(1)})`, async function () {",
          "97:         await expectRevert(",
          "98:           this.safeCast[`$toInt${bits}`](minValue.subn(1)),",
          "99:           `SafeCast: value doesn't fit in ${bits} bits`,",
          "100:         );",
          "101:       });",
          "103:       it(`reverts when downcasting -2^${bits - 1} - 2 (${minValue.subn(2)})`, async function () {",
          "104:         await expectRevert(",
          "105:           this.safeCast[`$toInt${bits}`](minValue.subn(2)),",
          "106:           `SafeCast: value doesn't fit in ${bits} bits`,",
          "107:         );",
          "108:       });",
          "110:       it(`reverts when downcasting 2^${bits - 1} (${maxValue.addn(1)})`, async function () {",
          "111:         await expectRevert(",
          "112:           this.safeCast[`$toInt${bits}`](maxValue.addn(1)),",
          "113:           `SafeCast: value doesn't fit in ${bits} bits`,",
          "114:         );",
          "115:       });",
          "117:       it(`reverts when downcasting 2^${bits - 1} + 1 (${maxValue.addn(2)})`, async function () {",
          "118:         await expectRevert(",
          "119:           this.safeCast[`$toInt${bits}`](maxValue.addn(2)),",
          "120:           `SafeCast: value doesn't fit in ${bits} bits`,",
          "121:         );",
          "122:       });",
          "123:     });",
          "124:   }",
          "126:   range(8, 256, 8).forEach(bits => testToInt(bits));",
          "128:   describe('toInt256', () => {",
          "129:     const maxUint256 = new BN('2').pow(new BN(256)).subn(1);",
          "130:     const maxInt256 = new BN('2').pow(new BN(255)).subn(1);",
          "132:     it('casts 0', async function () {",
          "133:       expect(await this.safeCast.$toInt256(0)).to.be.bignumber.equal('0');",
          "134:     });",
          "136:     it('casts 1', async function () {",
          "137:       expect(await this.safeCast.$toInt256(1)).to.be.bignumber.equal('1');",
          "138:     });",
          "140:     it(`casts INT256_MAX (${maxInt256})`, async function () {",
          "141:       expect(await this.safeCast.$toInt256(maxInt256)).to.be.bignumber.equal(maxInt256);",
          "142:     });",
          "144:     it(`reverts when casting INT256_MAX + 1 (${maxInt256.addn(1)})`, async function () {",
          "145:       await expectRevert(this.safeCast.$toInt256(maxInt256.addn(1)), \"SafeCast: value doesn't fit in an int256\");",
          "146:     });",
          "148:     it(`reverts when casting UINT256_MAX (${maxUint256})`, async function () {",
          "149:       await expectRevert(this.safeCast.$toInt256(maxUint256), \"SafeCast: value doesn't fit in an int256\");",
          "150:     });",
          "151:   });",
          "152: });",
          "",
          "---------------"
        ],
        "test/utils/math/SafeMath.test.js||test/utils/math/SafeMath.test.js": [
          "File: test/utils/math/SafeMath.test.js -> test/utils/math/SafeMath.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { MAX_UINT256 } = constants;",
          "4: const { expect } = require('chai');",
          "6: const SafeMath = artifacts.require('$SafeMath');",
          "7: const SafeMathMemoryCheck = artifacts.require('$SafeMathMemoryCheck');",
          "9: function expectStruct(value, expected) {",
          "10:   for (const key in expected) {",
          "11:     if (BN.isBN(value[key])) {",
          "12:       expect(value[key]).to.be.bignumber.equal(expected[key]);",
          "13:     } else {",
          "14:       expect(value[key]).to.be.equal(expected[key]);",
          "15:     }",
          "16:   }",
          "17: }",
          "19: contract('SafeMath', function () {",
          "20:   beforeEach(async function () {",
          "21:     this.safeMath = await SafeMath.new();",
          "22:   });",
          "24:   async function testCommutative(fn, lhs, rhs, expected, ...extra) {",
          "25:     expect(await fn(lhs, rhs, ...extra)).to.be.bignumber.equal(expected);",
          "26:     expect(await fn(rhs, lhs, ...extra)).to.be.bignumber.equal(expected);",
          "27:   }",
          "29:   async function testFailsCommutative(fn, lhs, rhs, reason, ...extra) {",
          "30:     if (reason === undefined) {",
          "31:       await expectRevert.unspecified(fn(lhs, rhs, ...extra));",
          "32:       await expectRevert.unspecified(fn(rhs, lhs, ...extra));",
          "33:     } else {",
          "34:       await expectRevert(fn(lhs, rhs, ...extra), reason);",
          "35:       await expectRevert(fn(rhs, lhs, ...extra), reason);",
          "36:     }",
          "37:   }",
          "39:   async function testCommutativeIterable(fn, lhs, rhs, expected, ...extra) {",
          "40:     expectStruct(await fn(lhs, rhs, ...extra), expected);",
          "41:     expectStruct(await fn(rhs, lhs, ...extra), expected);",
          "42:   }",
          "44:   describe('with flag', function () {",
          "45:     describe('add', function () {",
          "46:       it('adds correctly', async function () {",
          "47:         const a = new BN('5678');",
          "48:         const b = new BN('1234');",
          "50:         testCommutativeIterable(this.safeMath.$tryAdd, a, b, [true, a.add(b)]);",
          "51:       });",
          "53:       it('reverts on addition overflow', async function () {",
          "54:         const a = MAX_UINT256;",
          "55:         const b = new BN('1');",
          "57:         testCommutativeIterable(this.safeMath.$tryAdd, a, b, [false, '0']);",
          "58:       });",
          "59:     });",
          "61:     describe('sub', function () {",
          "62:       it('subtracts correctly', async function () {",
          "63:         const a = new BN('5678');",
          "64:         const b = new BN('1234');",
          "66:         expectStruct(await this.safeMath.$trySub(a, b), [true, a.sub(b)]);",
          "67:       });",
          "69:       it('reverts if subtraction result would be negative', async function () {",
          "70:         const a = new BN('1234');",
          "71:         const b = new BN('5678');",
          "73:         expectStruct(await this.safeMath.$trySub(a, b), [false, '0']);",
          "74:       });",
          "75:     });",
          "77:     describe('mul', function () {",
          "78:       it('multiplies correctly', async function () {",
          "79:         const a = new BN('1234');",
          "80:         const b = new BN('5678');",
          "82:         testCommutativeIterable(this.safeMath.$tryMul, a, b, [true, a.mul(b)]);",
          "83:       });",
          "85:       it('multiplies by zero correctly', async function () {",
          "86:         const a = new BN('0');",
          "87:         const b = new BN('5678');",
          "89:         testCommutativeIterable(this.safeMath.$tryMul, a, b, [true, a.mul(b)]);",
          "90:       });",
          "92:       it('reverts on multiplication overflow', async function () {",
          "93:         const a = MAX_UINT256;",
          "94:         const b = new BN('2');",
          "96:         testCommutativeIterable(this.safeMath.$tryMul, a, b, [false, '0']);",
          "97:       });",
          "98:     });",
          "100:     describe('div', function () {",
          "101:       it('divides correctly', async function () {",
          "102:         const a = new BN('5678');",
          "103:         const b = new BN('5678');",
          "105:         expectStruct(await this.safeMath.$tryDiv(a, b), [true, a.div(b)]);",
          "106:       });",
          "108:       it('divides zero correctly', async function () {",
          "109:         const a = new BN('0');",
          "110:         const b = new BN('5678');",
          "112:         expectStruct(await this.safeMath.$tryDiv(a, b), [true, a.div(b)]);",
          "113:       });",
          "115:       it('returns complete number result on non-even division', async function () {",
          "116:         const a = new BN('7000');",
          "117:         const b = new BN('5678');",
          "119:         expectStruct(await this.safeMath.$tryDiv(a, b), [true, a.div(b)]);",
          "120:       });",
          "122:       it('reverts on division by zero', async function () {",
          "123:         const a = new BN('5678');",
          "124:         const b = new BN('0');",
          "126:         expectStruct(await this.safeMath.$tryDiv(a, b), [false, '0']);",
          "127:       });",
          "128:     });",
          "130:     describe('mod', function () {",
          "131:       describe('modulos correctly', async function () {",
          "132:         it('when the dividend is smaller than the divisor', async function () {",
          "133:           const a = new BN('284');",
          "134:           const b = new BN('5678');",
          "136:           expectStruct(await this.safeMath.$tryMod(a, b), [true, a.mod(b)]);",
          "137:         });",
          "139:         it('when the dividend is equal to the divisor', async function () {",
          "140:           const a = new BN('5678');",
          "141:           const b = new BN('5678');",
          "143:           expectStruct(await this.safeMath.$tryMod(a, b), [true, a.mod(b)]);",
          "144:         });",
          "146:         it('when the dividend is larger than the divisor', async function () {",
          "147:           const a = new BN('7000');",
          "148:           const b = new BN('5678');",
          "150:           expectStruct(await this.safeMath.$tryMod(a, b), [true, a.mod(b)]);",
          "151:         });",
          "153:         it('when the dividend is a multiple of the divisor', async function () {",
          "154:           const a = new BN('17034'); // 17034 == 5678 * 3",
          "155:           const b = new BN('5678');",
          "157:           expectStruct(await this.safeMath.$tryMod(a, b), [true, a.mod(b)]);",
          "158:         });",
          "159:       });",
          "161:       it('reverts with a 0 divisor', async function () {",
          "162:         const a = new BN('5678');",
          "163:         const b = new BN('0');",
          "165:         expectStruct(await this.safeMath.$tryMod(a, b), [false, '0']);",
          "166:       });",
          "167:     });",
          "168:   });",
          "170:   describe('with default revert message', function () {",
          "171:     describe('add', function () {",
          "172:       it('adds correctly', async function () {",
          "173:         const a = new BN('5678');",
          "174:         const b = new BN('1234');",
          "176:         await testCommutative(this.safeMath.$add, a, b, a.add(b));",
          "177:       });",
          "179:       it('reverts on addition overflow', async function () {",
          "180:         const a = MAX_UINT256;",
          "181:         const b = new BN('1');",
          "183:         await testFailsCommutative(this.safeMath.$add, a, b, undefined);",
          "184:       });",
          "185:     });",
          "187:     describe('sub', function () {",
          "188:       it('subtracts correctly', async function () {",
          "189:         const a = new BN('5678');",
          "190:         const b = new BN('1234');",
          "192:         expect(await this.safeMath.$sub(a, b)).to.be.bignumber.equal(a.sub(b));",
          "193:       });",
          "195:       it('reverts if subtraction result would be negative', async function () {",
          "196:         const a = new BN('1234');",
          "197:         const b = new BN('5678');",
          "199:         await expectRevert.unspecified(this.safeMath.$sub(a, b));",
          "200:       });",
          "201:     });",
          "203:     describe('mul', function () {",
          "204:       it('multiplies correctly', async function () {",
          "205:         const a = new BN('1234');",
          "206:         const b = new BN('5678');",
          "208:         await testCommutative(this.safeMath.$mul, a, b, a.mul(b));",
          "209:       });",
          "211:       it('multiplies by zero correctly', async function () {",
          "212:         const a = new BN('0');",
          "213:         const b = new BN('5678');",
          "215:         await testCommutative(this.safeMath.$mul, a, b, '0');",
          "216:       });",
          "218:       it('reverts on multiplication overflow', async function () {",
          "219:         const a = MAX_UINT256;",
          "220:         const b = new BN('2');",
          "222:         await testFailsCommutative(this.safeMath.$mul, a, b, undefined);",
          "223:       });",
          "224:     });",
          "226:     describe('div', function () {",
          "227:       it('divides correctly', async function () {",
          "228:         const a = new BN('5678');",
          "229:         const b = new BN('5678');",
          "231:         expect(await this.safeMath.$div(a, b)).to.be.bignumber.equal(a.div(b));",
          "232:       });",
          "234:       it('divides zero correctly', async function () {",
          "235:         const a = new BN('0');",
          "236:         const b = new BN('5678');",
          "238:         expect(await this.safeMath.$div(a, b)).to.be.bignumber.equal('0');",
          "239:       });",
          "241:       it('returns complete number result on non-even division', async function () {",
          "242:         const a = new BN('7000');",
          "243:         const b = new BN('5678');",
          "245:         expect(await this.safeMath.$div(a, b)).to.be.bignumber.equal('1');",
          "246:       });",
          "248:       it('reverts on division by zero', async function () {",
          "249:         const a = new BN('5678');",
          "250:         const b = new BN('0');",
          "252:         await expectRevert.unspecified(this.safeMath.$div(a, b));",
          "253:       });",
          "254:     });",
          "256:     describe('mod', function () {",
          "257:       describe('modulos correctly', async function () {",
          "258:         it('when the dividend is smaller than the divisor', async function () {",
          "259:           const a = new BN('284');",
          "260:           const b = new BN('5678');",
          "262:           expect(await this.safeMath.$mod(a, b)).to.be.bignumber.equal(a.mod(b));",
          "263:         });",
          "265:         it('when the dividend is equal to the divisor', async function () {",
          "266:           const a = new BN('5678');",
          "267:           const b = new BN('5678');",
          "269:           expect(await this.safeMath.$mod(a, b)).to.be.bignumber.equal(a.mod(b));",
          "270:         });",
          "272:         it('when the dividend is larger than the divisor', async function () {",
          "273:           const a = new BN('7000');",
          "274:           const b = new BN('5678');",
          "276:           expect(await this.safeMath.$mod(a, b)).to.be.bignumber.equal(a.mod(b));",
          "277:         });",
          "279:         it('when the dividend is a multiple of the divisor', async function () {",
          "280:           const a = new BN('17034'); // 17034 == 5678 * 3",
          "281:           const b = new BN('5678');",
          "283:           expect(await this.safeMath.$mod(a, b)).to.be.bignumber.equal(a.mod(b));",
          "284:         });",
          "285:       });",
          "287:       it('reverts with a 0 divisor', async function () {",
          "288:         const a = new BN('5678');",
          "289:         const b = new BN('0');",
          "291:         await expectRevert.unspecified(this.safeMath.$mod(a, b));",
          "292:       });",
          "293:     });",
          "294:   });",
          "296:   describe('with custom revert message', function () {",
          "297:     describe('sub', function () {",
          "298:       it('subtracts correctly', async function () {",
          "299:         const a = new BN('5678');",
          "300:         const b = new BN('1234');",
          "302:         expect(",
          "303:           await this.safeMath.methods['$sub(uint256,uint256,string)'](a, b, 'MyErrorMessage'),",
          "304:         ).to.be.bignumber.equal(a.sub(b));",
          "305:       });",
          "307:       it('reverts if subtraction result would be negative', async function () {",
          "308:         const a = new BN('1234');",
          "309:         const b = new BN('5678');",
          "311:         await expectRevert(",
          "312:           this.safeMath.methods['$sub(uint256,uint256,string)'](a, b, 'MyErrorMessage'),",
          "313:           'MyErrorMessage',",
          "314:         );",
          "315:       });",
          "316:     });",
          "318:     describe('div', function () {",
          "319:       it('divides correctly', async function () {",
          "320:         const a = new BN('5678');",
          "321:         const b = new BN('5678');",
          "323:         expect(",
          "324:           await this.safeMath.methods['$div(uint256,uint256,string)'](a, b, 'MyErrorMessage'),",
          "325:         ).to.be.bignumber.equal(a.div(b));",
          "326:       });",
          "328:       it('divides zero correctly', async function () {",
          "329:         const a = new BN('0');",
          "330:         const b = new BN('5678');",
          "332:         expect(",
          "333:           await this.safeMath.methods['$div(uint256,uint256,string)'](a, b, 'MyErrorMessage'),",
          "334:         ).to.be.bignumber.equal('0');",
          "335:       });",
          "337:       it('returns complete number result on non-even division', async function () {",
          "338:         const a = new BN('7000');",
          "339:         const b = new BN('5678');",
          "341:         expect(",
          "342:           await this.safeMath.methods['$div(uint256,uint256,string)'](a, b, 'MyErrorMessage'),",
          "343:         ).to.be.bignumber.equal('1');",
          "344:       });",
          "346:       it('reverts on division by zero', async function () {",
          "347:         const a = new BN('5678');",
          "348:         const b = new BN('0');",
          "350:         await expectRevert(",
          "351:           this.safeMath.methods['$div(uint256,uint256,string)'](a, b, 'MyErrorMessage'),",
          "352:           'MyErrorMessage',",
          "353:         );",
          "354:       });",
          "355:     });",
          "357:     describe('mod', function () {",
          "358:       describe('modulos correctly', async function () {",
          "359:         it('when the dividend is smaller than the divisor', async function () {",
          "360:           const a = new BN('284');",
          "361:           const b = new BN('5678');",
          "363:           expect(",
          "364:             await this.safeMath.methods['$mod(uint256,uint256,string)'](a, b, 'MyErrorMessage'),",
          "365:           ).to.be.bignumber.equal(a.mod(b));",
          "366:         });",
          "368:         it('when the dividend is equal to the divisor', async function () {",
          "369:           const a = new BN('5678');",
          "370:           const b = new BN('5678');",
          "372:           expect(",
          "373:             await this.safeMath.methods['$mod(uint256,uint256,string)'](a, b, 'MyErrorMessage'),",
          "374:           ).to.be.bignumber.equal(a.mod(b));",
          "375:         });",
          "377:         it('when the dividend is larger than the divisor', async function () {",
          "378:           const a = new BN('7000');",
          "379:           const b = new BN('5678');",
          "381:           expect(",
          "382:             await this.safeMath.methods['$mod(uint256,uint256,string)'](a, b, 'MyErrorMessage'),",
          "383:           ).to.be.bignumber.equal(a.mod(b));",
          "384:         });",
          "386:         it('when the dividend is a multiple of the divisor', async function () {",
          "387:           const a = new BN('17034'); // 17034 == 5678 * 3",
          "388:           const b = new BN('5678');",
          "390:           expect(",
          "391:             await this.safeMath.methods['$mod(uint256,uint256,string)'](a, b, 'MyErrorMessage'),",
          "392:           ).to.be.bignumber.equal(a.mod(b));",
          "393:         });",
          "394:       });",
          "396:       it('reverts with a 0 divisor', async function () {",
          "397:         const a = new BN('5678');",
          "398:         const b = new BN('0');",
          "400:         await expectRevert(",
          "401:           this.safeMath.methods['$mod(uint256,uint256,string)'](a, b, 'MyErrorMessage'),",
          "402:           'MyErrorMessage',",
          "403:         );",
          "404:       });",
          "405:     });",
          "406:   });",
          "408:   describe('memory leakage', function () {",
          "409:     beforeEach(async function () {",
          "410:       this.safeMathMemoryCheck = await SafeMathMemoryCheck.new();",
          "411:     });",
          "413:     it('add', async function () {",
          "414:       expect(await this.safeMathMemoryCheck.$addMemoryCheck()).to.be.bignumber.equal('0');",
          "415:     });",
          "417:     it('sub', async function () {",
          "418:       expect(await this.safeMathMemoryCheck.$subMemoryCheck()).to.be.bignumber.equal('0');",
          "419:     });",
          "421:     it('mul', async function () {",
          "422:       expect(await this.safeMathMemoryCheck.$mulMemoryCheck()).to.be.bignumber.equal('0');",
          "423:     });",
          "425:     it('div', async function () {",
          "426:       expect(await this.safeMathMemoryCheck.$divMemoryCheck()).to.be.bignumber.equal('0');",
          "427:     });",
          "429:     it('mod', async function () {",
          "430:       expect(await this.safeMathMemoryCheck.$modMemoryCheck()).to.be.bignumber.equal('0');",
          "431:     });",
          "432:   });",
          "433: });",
          "",
          "---------------"
        ],
        "test/utils/math/SignedMath.test.js||test/utils/math/SignedMath.test.js": [
          "File: test/utils/math/SignedMath.test.js -> test/utils/math/SignedMath.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "3: const { MIN_INT256, MAX_INT256 } = constants;",
          "5: const SignedMath = artifacts.require('$SignedMath');",
          "7: contract('SignedMath', function () {",
          "8:   const min = new BN('-1234');",
          "9:   const max = new BN('5678');",
          "11:   beforeEach(async function () {",
          "12:     this.math = await SignedMath.new();",
          "13:   });",
          "15:   describe('max', function () {",
          "16:     it('is correctly detected in first argument position', async function () {",
          "17:       expect(await this.math.$max(max, min)).to.be.bignumber.equal(max);",
          "18:     });",
          "20:     it('is correctly detected in second argument position', async function () {",
          "21:       expect(await this.math.$max(min, max)).to.be.bignumber.equal(max);",
          "22:     });",
          "23:   });",
          "25:   describe('min', function () {",
          "26:     it('is correctly detected in first argument position', async function () {",
          "27:       expect(await this.math.$min(min, max)).to.be.bignumber.equal(min);",
          "28:     });",
          "30:     it('is correctly detected in second argument position', async function () {",
          "31:       expect(await this.math.$min(max, min)).to.be.bignumber.equal(min);",
          "32:     });",
          "33:   });",
          "35:   describe('average', function () {",
          "36:     function bnAverage(a, b) {",
          "37:       return a.add(b).divn(2);",
          "38:     }",
          "40:     it('is correctly calculated with various input', async function () {",
          "41:       const valuesX = [",
          "42:         new BN('0'),",
          "43:         new BN('3'),",
          "44:         new BN('-3'),",
          "45:         new BN('4'),",
          "46:         new BN('-4'),",
          "47:         new BN('57417'),",
          "48:         new BN('-57417'),",
          "49:         new BN('42304'),",
          "50:         new BN('-42304'),",
          "51:         MIN_INT256,",
          "52:         MAX_INT256,",
          "53:       ];",
          "55:       const valuesY = [",
          "56:         new BN('0'),",
          "57:         new BN('5'),",
          "58:         new BN('-5'),",
          "59:         new BN('2'),",
          "60:         new BN('-2'),",
          "61:         new BN('57417'),",
          "62:         new BN('-57417'),",
          "63:         new BN('42304'),",
          "64:         new BN('-42304'),",
          "65:         MIN_INT256,",
          "66:         MAX_INT256,",
          "67:       ];",
          "69:       for (const x of valuesX) {",
          "70:         for (const y of valuesY) {",
          "71:           expect(await this.math.$average(x, y)).to.be.bignumber.equal(",
          "72:             bnAverage(x, y),",
          "73:             `Bad result for average(${x}, ${y})`,",
          "74:           );",
          "75:         }",
          "76:       }",
          "77:     });",
          "78:   });",
          "80:   describe('abs', function () {",
          "81:     for (const n of [",
          "82:       MIN_INT256,",
          "83:       MIN_INT256.addn(1),",
          "84:       new BN('-1'),",
          "85:       new BN('0'),",
          "86:       new BN('1'),",
          "87:       MAX_INT256.subn(1),",
          "88:       MAX_INT256,",
          "89:     ]) {",
          "90:       it(`correctly computes the absolute value of ${n}`, async function () {",
          "91:         expect(await this.math.$abs(n)).to.be.bignumber.equal(n.abs());",
          "92:       });",
          "93:     }",
          "94:   });",
          "95: });",
          "",
          "---------------"
        ],
        "test/utils/math/SignedSafeMath.test.js||test/utils/math/SignedSafeMath.test.js": [
          "File: test/utils/math/SignedSafeMath.test.js -> test/utils/math/SignedSafeMath.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { MAX_INT256, MIN_INT256 } = constants;",
          "4: const { expect } = require('chai');",
          "6: const SignedSafeMath = artifacts.require('$SignedSafeMath');",
          "8: contract('SignedSafeMath', function () {",
          "9:   beforeEach(async function () {",
          "10:     this.safeMath = await SignedSafeMath.new();",
          "11:   });",
          "13:   async function testCommutative(fn, lhs, rhs, expected) {",
          "14:     expect(await fn(lhs, rhs)).to.be.bignumber.equal(expected);",
          "15:     expect(await fn(rhs, lhs)).to.be.bignumber.equal(expected);",
          "16:   }",
          "18:   async function testFailsCommutative(fn, lhs, rhs) {",
          "19:     await expectRevert.unspecified(fn(lhs, rhs));",
          "20:     await expectRevert.unspecified(fn(rhs, lhs));",
          "21:   }",
          "23:   describe('add', function () {",
          "24:     it('adds correctly if it does not overflow and the result is positive', async function () {",
          "25:       const a = new BN('1234');",
          "26:       const b = new BN('5678');",
          "28:       await testCommutative(this.safeMath.$add, a, b, a.add(b));",
          "29:     });",
          "31:     it('adds correctly if it does not overflow and the result is negative', async function () {",
          "32:       const a = MAX_INT256;",
          "33:       const b = MIN_INT256;",
          "35:       await testCommutative(this.safeMath.$add, a, b, a.add(b));",
          "36:     });",
          "38:     it('reverts on positive addition overflow', async function () {",
          "39:       const a = MAX_INT256;",
          "40:       const b = new BN('1');",
          "42:       await testFailsCommutative(this.safeMath.$add, a, b);",
          "43:     });",
          "45:     it('reverts on negative addition overflow', async function () {",
          "46:       const a = MIN_INT256;",
          "47:       const b = new BN('-1');",
          "49:       await testFailsCommutative(this.safeMath.$add, a, b);",
          "50:     });",
          "51:   });",
          "53:   describe('sub', function () {",
          "54:     it('subtracts correctly if it does not overflow and the result is positive', async function () {",
          "55:       const a = new BN('5678');",
          "56:       const b = new BN('1234');",
          "58:       const result = await this.safeMath.$sub(a, b);",
          "59:       expect(result).to.be.bignumber.equal(a.sub(b));",
          "60:     });",
          "62:     it('subtracts correctly if it does not overflow and the result is negative', async function () {",
          "63:       const a = new BN('1234');",
          "64:       const b = new BN('5678');",
          "66:       const result = await this.safeMath.$sub(a, b);",
          "67:       expect(result).to.be.bignumber.equal(a.sub(b));",
          "68:     });",
          "70:     it('reverts on positive subtraction overflow', async function () {",
          "71:       const a = MAX_INT256;",
          "72:       const b = new BN('-1');",
          "74:       await expectRevert.unspecified(this.safeMath.$sub(a, b));",
          "75:     });",
          "77:     it('reverts on negative subtraction overflow', async function () {",
          "78:       const a = MIN_INT256;",
          "79:       const b = new BN('1');",
          "81:       await expectRevert.unspecified(this.safeMath.$sub(a, b));",
          "82:     });",
          "83:   });",
          "85:   describe('mul', function () {",
          "86:     it('multiplies correctly', async function () {",
          "87:       const a = new BN('5678');",
          "88:       const b = new BN('-1234');",
          "90:       await testCommutative(this.safeMath.$mul, a, b, a.mul(b));",
          "91:     });",
          "93:     it('multiplies by zero correctly', async function () {",
          "94:       const a = new BN('0');",
          "95:       const b = new BN('5678');",
          "97:       await testCommutative(this.safeMath.$mul, a, b, '0');",
          "98:     });",
          "100:     it('reverts on multiplication overflow, positive operands', async function () {",
          "101:       const a = MAX_INT256;",
          "102:       const b = new BN('2');",
          "104:       await testFailsCommutative(this.safeMath.$mul, a, b);",
          "105:     });",
          "107:     it('reverts when minimum integer is multiplied by -1', async function () {",
          "108:       const a = MIN_INT256;",
          "109:       const b = new BN('-1');",
          "111:       await testFailsCommutative(this.safeMath.$mul, a, b);",
          "112:     });",
          "113:   });",
          "115:   describe('div', function () {",
          "116:     it('divides correctly', async function () {",
          "117:       const a = new BN('-5678');",
          "118:       const b = new BN('5678');",
          "120:       const result = await this.safeMath.$div(a, b);",
          "121:       expect(result).to.be.bignumber.equal(a.div(b));",
          "122:     });",
          "124:     it('divides zero correctly', async function () {",
          "125:       const a = new BN('0');",
          "126:       const b = new BN('5678');",
          "128:       expect(await this.safeMath.$div(a, b)).to.be.bignumber.equal('0');",
          "129:     });",
          "131:     it('returns complete number result on non-even division', async function () {",
          "132:       const a = new BN('7000');",
          "133:       const b = new BN('5678');",
          "135:       expect(await this.safeMath.$div(a, b)).to.be.bignumber.equal('1');",
          "136:     });",
          "138:     it('reverts on division by zero', async function () {",
          "139:       const a = new BN('-5678');",
          "140:       const b = new BN('0');",
          "142:       await expectRevert.unspecified(this.safeMath.$div(a, b));",
          "143:     });",
          "145:     it('reverts on overflow, negative second', async function () {",
          "146:       const a = new BN(MIN_INT256);",
          "147:       const b = new BN('-1');",
          "149:       await expectRevert.unspecified(this.safeMath.$div(a, b));",
          "150:     });",
          "151:   });",
          "152: });",
          "",
          "---------------"
        ],
        "test/utils/structs/BitMap.test.js||test/utils/structs/BitMap.test.js": [
          "File: test/utils/structs/BitMap.test.js -> test/utils/structs/BitMap.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "4: const BitMap = artifacts.require('$BitMaps');",
          "6: contract('BitMap', function () {",
          "7:   const keyA = new BN('7891');",
          "8:   const keyB = new BN('451');",
          "9:   const keyC = new BN('9592328');",
          "11:   beforeEach(async function () {",
          "12:     this.bitmap = await BitMap.new();",
          "13:   });",
          "15:   it('starts empty', async function () {",
          "16:     expect(await this.bitmap.$get(0, keyA)).to.equal(false);",
          "17:     expect(await this.bitmap.$get(0, keyB)).to.equal(false);",
          "18:     expect(await this.bitmap.$get(0, keyC)).to.equal(false);",
          "19:   });",
          "21:   describe('setTo', function () {",
          "22:     it('set a key to true', async function () {",
          "23:       await this.bitmap.$setTo(0, keyA, true);",
          "24:       expect(await this.bitmap.$get(0, keyA)).to.equal(true);",
          "25:       expect(await this.bitmap.$get(0, keyB)).to.equal(false);",
          "26:       expect(await this.bitmap.$get(0, keyC)).to.equal(false);",
          "27:     });",
          "29:     it('set a key to false', async function () {",
          "30:       await this.bitmap.$setTo(0, keyA, true);",
          "31:       await this.bitmap.$setTo(0, keyA, false);",
          "32:       expect(await this.bitmap.$get(0, keyA)).to.equal(false);",
          "33:       expect(await this.bitmap.$get(0, keyB)).to.equal(false);",
          "34:       expect(await this.bitmap.$get(0, keyC)).to.equal(false);",
          "35:     });",
          "37:     it('set several consecutive keys', async function () {",
          "38:       await this.bitmap.$setTo(0, keyA.addn(0), true);",
          "39:       await this.bitmap.$setTo(0, keyA.addn(1), true);",
          "40:       await this.bitmap.$setTo(0, keyA.addn(2), true);",
          "41:       await this.bitmap.$setTo(0, keyA.addn(3), true);",
          "42:       await this.bitmap.$setTo(0, keyA.addn(4), true);",
          "43:       await this.bitmap.$setTo(0, keyA.addn(2), false);",
          "44:       await this.bitmap.$setTo(0, keyA.addn(4), false);",
          "45:       expect(await this.bitmap.$get(0, keyA.addn(0))).to.equal(true);",
          "46:       expect(await this.bitmap.$get(0, keyA.addn(1))).to.equal(true);",
          "47:       expect(await this.bitmap.$get(0, keyA.addn(2))).to.equal(false);",
          "48:       expect(await this.bitmap.$get(0, keyA.addn(3))).to.equal(true);",
          "49:       expect(await this.bitmap.$get(0, keyA.addn(4))).to.equal(false);",
          "50:     });",
          "51:   });",
          "53:   describe('set', function () {",
          "54:     it('adds a key', async function () {",
          "55:       await this.bitmap.$set(0, keyA);",
          "56:       expect(await this.bitmap.$get(0, keyA)).to.equal(true);",
          "57:       expect(await this.bitmap.$get(0, keyB)).to.equal(false);",
          "58:       expect(await this.bitmap.$get(0, keyC)).to.equal(false);",
          "59:     });",
          "61:     it('adds several keys', async function () {",
          "62:       await this.bitmap.$set(0, keyA);",
          "63:       await this.bitmap.$set(0, keyB);",
          "64:       expect(await this.bitmap.$get(0, keyA)).to.equal(true);",
          "65:       expect(await this.bitmap.$get(0, keyB)).to.equal(true);",
          "66:       expect(await this.bitmap.$get(0, keyC)).to.equal(false);",
          "67:     });",
          "69:     it('adds several consecutive keys', async function () {",
          "70:       await this.bitmap.$set(0, keyA.addn(0));",
          "71:       await this.bitmap.$set(0, keyA.addn(1));",
          "72:       await this.bitmap.$set(0, keyA.addn(3));",
          "73:       expect(await this.bitmap.$get(0, keyA.addn(0))).to.equal(true);",
          "74:       expect(await this.bitmap.$get(0, keyA.addn(1))).to.equal(true);",
          "75:       expect(await this.bitmap.$get(0, keyA.addn(2))).to.equal(false);",
          "76:       expect(await this.bitmap.$get(0, keyA.addn(3))).to.equal(true);",
          "77:       expect(await this.bitmap.$get(0, keyA.addn(4))).to.equal(false);",
          "78:     });",
          "79:   });",
          "81:   describe('unset', function () {",
          "82:     it('removes added keys', async function () {",
          "83:       await this.bitmap.$set(0, keyA);",
          "84:       await this.bitmap.$set(0, keyB);",
          "85:       await this.bitmap.$unset(0, keyA);",
          "86:       expect(await this.bitmap.$get(0, keyA)).to.equal(false);",
          "87:       expect(await this.bitmap.$get(0, keyB)).to.equal(true);",
          "88:       expect(await this.bitmap.$get(0, keyC)).to.equal(false);",
          "89:     });",
          "91:     it('removes consecutive added keys', async function () {",
          "92:       await this.bitmap.$set(0, keyA.addn(0));",
          "93:       await this.bitmap.$set(0, keyA.addn(1));",
          "94:       await this.bitmap.$set(0, keyA.addn(3));",
          "95:       await this.bitmap.$unset(0, keyA.addn(1));",
          "96:       expect(await this.bitmap.$get(0, keyA.addn(0))).to.equal(true);",
          "97:       expect(await this.bitmap.$get(0, keyA.addn(1))).to.equal(false);",
          "98:       expect(await this.bitmap.$get(0, keyA.addn(2))).to.equal(false);",
          "99:       expect(await this.bitmap.$get(0, keyA.addn(3))).to.equal(true);",
          "100:       expect(await this.bitmap.$get(0, keyA.addn(4))).to.equal(false);",
          "101:     });",
          "103:     it('adds and removes multiple keys', async function () {",
          "106:       await this.bitmap.$set(0, keyA);",
          "107:       await this.bitmap.$set(0, keyC);",
          "111:       await this.bitmap.$unset(0, keyA);",
          "112:       await this.bitmap.$unset(0, keyB);",
          "116:       await this.bitmap.$set(0, keyB);",
          "120:       await this.bitmap.$set(0, keyA);",
          "121:       await this.bitmap.$unset(0, keyC);",
          "125:       await this.bitmap.$set(0, keyA);",
          "126:       await this.bitmap.$set(0, keyB);",
          "130:       await this.bitmap.$set(0, keyC);",
          "131:       await this.bitmap.$unset(0, keyA);",
          "135:       await this.bitmap.$set(0, keyA);",
          "136:       await this.bitmap.$unset(0, keyB);",
          "140:       expect(await this.bitmap.$get(0, keyA)).to.equal(true);",
          "141:       expect(await this.bitmap.$get(0, keyB)).to.equal(false);",
          "142:       expect(await this.bitmap.$get(0, keyC)).to.equal(true);",
          "143:     });",
          "144:   });",
          "145: });",
          "",
          "---------------"
        ],
        "test/utils/structs/DoubleEndedQueue.test.js||test/utils/structs/DoubleEndedQueue.test.js": [
          "File: test/utils/structs/DoubleEndedQueue.test.js -> test/utils/structs/DoubleEndedQueue.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectEvent } = require('@openzeppelin/test-helpers');",
          "2: const { expectRevertCustomError } = require('../../helpers/customError');",
          "4: const DoubleEndedQueue = artifacts.require('$DoubleEndedQueue');",
          "7: const getContent = deque =>",
          "8:   deque.$length(0).then(bn =>",
          "9:     Promise.all(",
          "10:       Array(bn.toNumber())",
          "11:         .fill()",
          "12:         .map((_, i) => deque.$at(0, i)),",
          "13:     ),",
          "14:   );",
          "16: contract('DoubleEndedQueue', function () {",
          "17:   const bytesA = '0xdeadbeef'.padEnd(66, '0');",
          "18:   const bytesB = '0x0123456789'.padEnd(66, '0');",
          "19:   const bytesC = '0x42424242'.padEnd(66, '0');",
          "20:   const bytesD = '0x171717'.padEnd(66, '0');",
          "22:   beforeEach(async function () {",
          "23:     this.deque = await DoubleEndedQueue.new();",
          "24:   });",
          "26:   describe('when empty', function () {",
          "27:     it('getters', async function () {",
          "28:       expect(await this.deque.$empty(0)).to.be.equal(true);",
          "29:       expect(await getContent(this.deque)).to.have.ordered.members([]);",
          "30:     });",
          "32:     it('reverts on accesses', async function () {",
          "33:       await expectRevertCustomError(this.deque.$popBack(0), 'Empty()');",
          "34:       await expectRevertCustomError(this.deque.$popFront(0), 'Empty()');",
          "35:       await expectRevertCustomError(this.deque.$back(0), 'Empty()');",
          "36:       await expectRevertCustomError(this.deque.$front(0), 'Empty()');",
          "37:     });",
          "38:   });",
          "40:   describe('when not empty', function () {",
          "41:     beforeEach(async function () {",
          "42:       await this.deque.$pushBack(0, bytesB);",
          "43:       await this.deque.$pushFront(0, bytesA);",
          "44:       await this.deque.$pushBack(0, bytesC);",
          "45:       this.content = [bytesA, bytesB, bytesC];",
          "46:     });",
          "48:     it('getters', async function () {",
          "49:       expect(await this.deque.$empty(0)).to.be.equal(false);",
          "50:       expect(await this.deque.$length(0)).to.be.bignumber.equal(this.content.length.toString());",
          "51:       expect(await this.deque.$front(0)).to.be.equal(this.content[0]);",
          "52:       expect(await this.deque.$back(0)).to.be.equal(this.content[this.content.length - 1]);",
          "53:       expect(await getContent(this.deque)).to.have.ordered.members(this.content);",
          "54:     });",
          "56:     it('out of bounds access', async function () {",
          "57:       await expectRevertCustomError(this.deque.$at(0, this.content.length), 'OutOfBounds()');",
          "58:     });",
          "60:     describe('push', function () {",
          "61:       it('front', async function () {",
          "62:         await this.deque.$pushFront(0, bytesD);",
          "63:         this.content.unshift(bytesD); // add element at the beginning",
          "65:         expect(await getContent(this.deque)).to.have.ordered.members(this.content);",
          "66:       });",
          "68:       it('back', async function () {",
          "69:         await this.deque.$pushBack(0, bytesD);",
          "70:         this.content.push(bytesD); // add element at the end",
          "72:         expect(await getContent(this.deque)).to.have.ordered.members(this.content);",
          "73:       });",
          "74:     });",
          "76:     describe('pop', function () {",
          "77:       it('front', async function () {",
          "78:         const value = this.content.shift(); // remove first element",
          "79:         expectEvent(await this.deque.$popFront(0), 'return$popFront', { value });",
          "81:         expect(await getContent(this.deque)).to.have.ordered.members(this.content);",
          "82:       });",
          "84:       it('back', async function () {",
          "85:         const value = this.content.pop(); // remove last element",
          "86:         expectEvent(await this.deque.$popBack(0), 'return$popBack', { value });",
          "88:         expect(await getContent(this.deque)).to.have.ordered.members(this.content);",
          "89:       });",
          "90:     });",
          "92:     it('clear', async function () {",
          "93:       await this.deque.$clear(0);",
          "95:       expect(await this.deque.$empty(0)).to.be.equal(true);",
          "96:       expect(await getContent(this.deque)).to.have.ordered.members([]);",
          "97:     });",
          "98:   });",
          "99: });",
          "",
          "---------------"
        ],
        "test/utils/structs/EnumerableMap.behavior.js||test/utils/structs/EnumerableMap.behavior.js": [
          "File: test/utils/structs/EnumerableMap.behavior.js -> test/utils/structs/EnumerableMap.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "4: const zip = require('lodash.zip');",
          "6: function shouldBehaveLikeMap(keys, values, zeroValue, methods, events) {",
          "7:   const [keyA, keyB, keyC] = keys;",
          "8:   const [valueA, valueB, valueC] = values;",
          "10:   async function expectMembersMatch(map, keys, values) {",
          "11:     expect(keys.length).to.equal(values.length);",
          "13:     await Promise.all(keys.map(async key => expect(await methods.contains(map, key)).to.equal(true)));",
          "15:     expect(await methods.length(map)).to.bignumber.equal(keys.length.toString());",
          "17:     expect((await Promise.all(keys.map(key => methods.get(map, key)))).map(k => k.toString())).to.have.same.members(",
          "18:       values.map(value => value.toString()),",
          "19:     );",
          "23:     expect(",
          "24:       await Promise.all(",
          "25:         [...Array(keys.length).keys()].map(async index => {",
          "26:           const entry = await methods.at(map, index);",
          "27:           return [entry[0].toString(), entry[1].toString()];",
          "28:         }),",
          "29:       ),",
          "30:     ).to.have.same.deep.members(",
          "31:       zip(",
          "32:         keys.map(k => k.toString()),",
          "33:         values.map(v => v.toString()),",
          "34:       ),",
          "35:     );",
          "38:     expect((await methods.keys(map)).map(k => k.toString())).to.have.same.members(keys.map(key => key.toString()));",
          "39:   }",
          "41:   it('starts empty', async function () {",
          "42:     expect(await methods.contains(this.map, keyA)).to.equal(false);",
          "44:     await expectMembersMatch(this.map, [], []);",
          "45:   });",
          "47:   describe('set', function () {",
          "48:     it('adds a key', async function () {",
          "49:       const receipt = await methods.set(this.map, keyA, valueA);",
          "50:       expectEvent(receipt, events.setReturn, { ret0: true });",
          "52:       await expectMembersMatch(this.map, [keyA], [valueA]);",
          "53:     });",
          "55:     it('adds several keys', async function () {",
          "56:       await methods.set(this.map, keyA, valueA);",
          "57:       await methods.set(this.map, keyB, valueB);",
          "59:       await expectMembersMatch(this.map, [keyA, keyB], [valueA, valueB]);",
          "60:       expect(await methods.contains(this.map, keyC)).to.equal(false);",
          "61:     });",
          "63:     it('returns false when adding keys already in the set', async function () {",
          "64:       await methods.set(this.map, keyA, valueA);",
          "66:       const receipt = await methods.set(this.map, keyA, valueA);",
          "67:       expectEvent(receipt, events.setReturn, { ret0: false });",
          "69:       await expectMembersMatch(this.map, [keyA], [valueA]);",
          "70:     });",
          "72:     it('updates values for keys already in the set', async function () {",
          "73:       await methods.set(this.map, keyA, valueA);",
          "74:       await methods.set(this.map, keyA, valueB);",
          "76:       await expectMembersMatch(this.map, [keyA], [valueB]);",
          "77:     });",
          "78:   });",
          "80:   describe('remove', function () {",
          "81:     it('removes added keys', async function () {",
          "82:       await methods.set(this.map, keyA, valueA);",
          "84:       const receipt = await methods.remove(this.map, keyA);",
          "85:       expectEvent(receipt, events.removeReturn, { ret0: true });",
          "87:       expect(await methods.contains(this.map, keyA)).to.equal(false);",
          "88:       await expectMembersMatch(this.map, [], []);",
          "89:     });",
          "91:     it('returns false when removing keys not in the set', async function () {",
          "92:       const receipt = await methods.remove(this.map, keyA);",
          "93:       expectEvent(receipt, events.removeReturn, { ret0: false });",
          "95:       expect(await methods.contains(this.map, keyA)).to.equal(false);",
          "96:     });",
          "98:     it('adds and removes multiple keys', async function () {",
          "101:       await methods.set(this.map, keyA, valueA);",
          "102:       await methods.set(this.map, keyC, valueC);",
          "106:       await methods.remove(this.map, keyA);",
          "107:       await methods.remove(this.map, keyB);",
          "111:       await methods.set(this.map, keyB, valueB);",
          "115:       await methods.set(this.map, keyA, valueA);",
          "116:       await methods.remove(this.map, keyC);",
          "120:       await methods.set(this.map, keyA, valueA);",
          "121:       await methods.set(this.map, keyB, valueB);",
          "125:       await methods.set(this.map, keyC, valueC);",
          "126:       await methods.remove(this.map, keyA);",
          "130:       await methods.set(this.map, keyA, valueA);",
          "131:       await methods.remove(this.map, keyB);",
          "135:       await expectMembersMatch(this.map, [keyA, keyC], [valueA, valueC]);",
          "137:       expect(await methods.contains(this.map, keyA)).to.equal(true);",
          "138:       expect(await methods.contains(this.map, keyB)).to.equal(false);",
          "139:       expect(await methods.contains(this.map, keyC)).to.equal(true);",
          "140:     });",
          "141:   });",
          "143:   describe('read', function () {",
          "144:     beforeEach(async function () {",
          "145:       await methods.set(this.map, keyA, valueA);",
          "146:     });",
          "148:     describe('get', function () {",
          "149:       it('existing value', async function () {",
          "150:         expect(await methods.get(this.map, keyA).then(r => r.toString())).to.be.equal(valueA.toString());",
          "151:       });",
          "152:       it('missing value', async function () {",
          "153:         await expectRevert(methods.get(this.map, keyB), 'EnumerableMap: nonexistent key');",
          "154:       });",
          "155:     });",
          "157:     describe('get with message', function () {",
          "158:       it('existing value', async function () {",
          "159:         expect(await methods.getWithMessage(this.map, keyA, 'custom error string').then(r => r.toString())).to.be.equal(",
          "160:           valueA.toString(),",
          "161:         );",
          "162:       });",
          "163:       it('missing value', async function () {",
          "164:         await expectRevert(methods.getWithMessage(this.map, keyB, 'custom error string'), 'custom error string');",
          "165:       });",
          "166:     });",
          "168:     describe('tryGet', function () {",
          "169:       it('existing value', async function () {",
          "170:         const result = await methods.tryGet(this.map, keyA);",
          "171:         expect(result['0']).to.be.equal(true);",
          "172:         expect(result['1'].toString()).to.be.equal(valueA.toString());",
          "173:       });",
          "174:       it('missing value', async function () {",
          "175:         const result = await methods.tryGet(this.map, keyB);",
          "176:         expect(result['0']).to.be.equal(false);",
          "177:         expect(result['1'].toString()).to.be.equal(zeroValue.toString());",
          "178:       });",
          "179:     });",
          "180:   });",
          "181: }",
          "183: module.exports = {",
          "184:   shouldBehaveLikeMap,",
          "185: };",
          "",
          "---------------"
        ],
        "test/utils/structs/EnumerableMap.test.js||test/utils/structs/EnumerableMap.test.js": [
          "File: test/utils/structs/EnumerableMap.test.js -> test/utils/structs/EnumerableMap.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { BN, constants } = require('@openzeppelin/test-helpers');",
          "2: const { mapValues } = require('../../helpers/map-values');",
          "4: const EnumerableMap = artifacts.require('$EnumerableMap');",
          "6: const { shouldBehaveLikeMap } = require('./EnumerableMap.behavior');",
          "8: const getMethods = ms => {",
          "9:   return mapValues(",
          "10:     ms,",
          "11:     m =>",
          "12:       (self, ...args) =>",
          "13:         self.methods[m](0, ...args),",
          "14:   );",
          "15: };",
          "18: const library = EnumerableMap._json.contractName.replace(/^\\$/, '');",
          "20: contract('EnumerableMap', function (accounts) {",
          "21:   const [accountA, accountB, accountC] = accounts;",
          "23:   const keyA = new BN('7891');",
          "24:   const keyB = new BN('451');",
          "25:   const keyC = new BN('9592328');",
          "27:   const bytesA = '0xdeadbeef'.padEnd(66, '0');",
          "28:   const bytesB = '0x0123456789'.padEnd(66, '0');",
          "29:   const bytesC = '0x42424242'.padEnd(66, '0');",
          "31:   beforeEach(async function () {",
          "32:     this.map = await EnumerableMap.new();",
          "33:   });",
          "36:   describe('AddressToUintMap', function () {",
          "37:     shouldBehaveLikeMap(",
          "38:       [accountA, accountB, accountC],",
          "39:       [keyA, keyB, keyC],",
          "40:       new BN('0'),",
          "41:       getMethods({",
          "42:         set: '$set(uint256,address,uint256)',",
          "43:         get: '$get(uint256,address)',",
          "44:         getWithMessage: '$get(uint256,address,string)',",
          "45:         tryGet: '$tryGet(uint256,address)',",
          "46:         remove: '$remove(uint256,address)',",
          "47:         length: `$length_${library}_AddressToUintMap(uint256)`,",
          "48:         at: `$at_${library}_AddressToUintMap(uint256,uint256)`,",
          "49:         contains: '$contains(uint256,address)',",
          "50:         keys: `$keys_${library}_AddressToUintMap(uint256)`,",
          "51:       }),",
          "52:       {",
          "53:         setReturn: `return$set_${library}_AddressToUintMap_address_uint256`,",
          "54:         removeReturn: `return$remove_${library}_AddressToUintMap_address`,",
          "55:       },",
          "56:     );",
          "57:   });",
          "60:   describe('UintToAddressMap', function () {",
          "61:     shouldBehaveLikeMap(",
          "62:       [keyA, keyB, keyC],",
          "63:       [accountA, accountB, accountC],",
          "64:       constants.ZERO_ADDRESS,",
          "65:       getMethods({",
          "66:         set: '$set(uint256,uint256,address)',",
          "67:         get: `$get_${library}_UintToAddressMap(uint256,uint256)`,",
          "68:         getWithMessage: `$get_${library}_UintToAddressMap(uint256,uint256,string)`,",
          "69:         tryGet: `$tryGet_${library}_UintToAddressMap(uint256,uint256)`,",
          "70:         remove: `$remove_${library}_UintToAddressMap(uint256,uint256)`,",
          "71:         length: `$length_${library}_UintToAddressMap(uint256)`,",
          "72:         at: `$at_${library}_UintToAddressMap(uint256,uint256)`,",
          "73:         contains: `$contains_${library}_UintToAddressMap(uint256,uint256)`,",
          "74:         keys: `$keys_${library}_UintToAddressMap(uint256)`,",
          "75:       }),",
          "76:       {",
          "77:         setReturn: `return$set_${library}_UintToAddressMap_uint256_address`,",
          "78:         removeReturn: `return$remove_${library}_UintToAddressMap_uint256`,",
          "79:       },",
          "80:     );",
          "81:   });",
          "84:   describe('Bytes32ToBytes32Map', function () {",
          "85:     shouldBehaveLikeMap(",
          "86:       [keyA, keyB, keyC].map(k => '0x' + k.toString(16).padEnd(64, '0')),",
          "87:       [bytesA, bytesB, bytesC],",
          "88:       constants.ZERO_BYTES32,",
          "89:       getMethods({",
          "90:         set: '$set(uint256,bytes32,bytes32)',",
          "91:         get: `$get_${library}_Bytes32ToBytes32Map(uint256,bytes32)`,",
          "92:         getWithMessage: `$get_${library}_Bytes32ToBytes32Map(uint256,bytes32,string)`,",
          "93:         tryGet: `$tryGet_${library}_Bytes32ToBytes32Map(uint256,bytes32)`,",
          "94:         remove: `$remove_${library}_Bytes32ToBytes32Map(uint256,bytes32)`,",
          "95:         length: `$length_${library}_Bytes32ToBytes32Map(uint256)`,",
          "96:         at: `$at_${library}_Bytes32ToBytes32Map(uint256,uint256)`,",
          "97:         contains: `$contains_${library}_Bytes32ToBytes32Map(uint256,bytes32)`,",
          "98:         keys: `$keys_${library}_Bytes32ToBytes32Map(uint256)`,",
          "99:       }),",
          "100:       {",
          "101:         setReturn: `return$set_${library}_Bytes32ToBytes32Map_bytes32_bytes32`,",
          "102:         removeReturn: `return$remove_${library}_Bytes32ToBytes32Map_bytes32`,",
          "103:       },",
          "104:     );",
          "105:   });",
          "108:   describe('UintToUintMap', function () {",
          "109:     shouldBehaveLikeMap(",
          "110:       [keyA, keyB, keyC],",
          "111:       [keyA, keyB, keyC].map(k => k.add(new BN('1332'))),",
          "112:       new BN('0'),",
          "113:       getMethods({",
          "114:         set: '$set(uint256,uint256,uint256)',",
          "115:         get: `$get_${library}_UintToUintMap(uint256,uint256)`,",
          "116:         getWithMessage: `$get_${library}_UintToUintMap(uint256,uint256,string)`,",
          "117:         tryGet: `$tryGet_${library}_UintToUintMap(uint256,uint256)`,",
          "118:         remove: `$remove_${library}_UintToUintMap(uint256,uint256)`,",
          "119:         length: `$length_${library}_UintToUintMap(uint256)`,",
          "120:         at: `$at_${library}_UintToUintMap(uint256,uint256)`,",
          "121:         contains: `$contains_${library}_UintToUintMap(uint256,uint256)`,",
          "122:         keys: `$keys_${library}_UintToUintMap(uint256)`,",
          "123:       }),",
          "124:       {",
          "125:         setReturn: `return$set_${library}_UintToUintMap_uint256_uint256`,",
          "126:         removeReturn: `return$remove_${library}_UintToUintMap_uint256`,",
          "127:       },",
          "128:     );",
          "129:   });",
          "132:   describe('Bytes32ToUintMap', function () {",
          "133:     shouldBehaveLikeMap(",
          "134:       [bytesA, bytesB, bytesC],",
          "135:       [keyA, keyB, keyC],",
          "136:       new BN('0'),",
          "137:       getMethods({",
          "138:         set: '$set(uint256,bytes32,uint256)',",
          "139:         get: `$get_${library}_Bytes32ToUintMap(uint256,bytes32)`,",
          "140:         getWithMessage: `$get_${library}_Bytes32ToUintMap(uint256,bytes32,string)`,",
          "141:         tryGet: `$tryGet_${library}_Bytes32ToUintMap(uint256,bytes32)`,",
          "142:         remove: `$remove_${library}_Bytes32ToUintMap(uint256,bytes32)`,",
          "143:         length: `$length_${library}_Bytes32ToUintMap(uint256)`,",
          "144:         at: `$at_${library}_Bytes32ToUintMap(uint256,uint256)`,",
          "145:         contains: `$contains_${library}_Bytes32ToUintMap(uint256,bytes32)`,",
          "146:         keys: `$keys_${library}_Bytes32ToUintMap(uint256)`,",
          "147:       }),",
          "148:       {",
          "149:         setReturn: `return$set_${library}_Bytes32ToUintMap_bytes32_uint256`,",
          "150:         removeReturn: `return$remove_${library}_Bytes32ToUintMap_bytes32`,",
          "151:       },",
          "152:     );",
          "153:   });",
          "154: });",
          "",
          "---------------"
        ],
        "test/utils/structs/EnumerableSet.behavior.js||test/utils/structs/EnumerableSet.behavior.js": [
          "File: test/utils/structs/EnumerableSet.behavior.js -> test/utils/structs/EnumerableSet.behavior.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const { expectEvent, expectRevert } = require('@openzeppelin/test-helpers');",
          "2: const { expect } = require('chai');",
          "4: function shouldBehaveLikeSet(values, methods, events) {",
          "5:   const [valueA, valueB, valueC] = values;",
          "7:   async function expectMembersMatch(set, values) {",
          "8:     const contains = await Promise.all(values.map(value => methods.contains(set, value)));",
          "9:     expect(contains.every(Boolean)).to.be.equal(true);",
          "11:     const length = await methods.length(set);",
          "12:     expect(length).to.bignumber.equal(values.length.toString());",
          "16:     const indexedValues = await Promise.all(",
          "17:       Array(values.length)",
          "18:         .fill()",
          "19:         .map((_, index) => methods.at(set, index)),",
          "20:     );",
          "21:     expect(indexedValues.map(v => v.toString())).to.have.same.members(values.map(v => v.toString()));",
          "23:     const returnedValues = await methods.values(set);",
          "24:     expect(returnedValues.map(v => v.toString())).to.have.same.members(values.map(v => v.toString()));",
          "25:   }",
          "27:   it('starts empty', async function () {",
          "28:     expect(await methods.contains(this.set, valueA)).to.equal(false);",
          "30:     await expectMembersMatch(this.set, []);",
          "31:   });",
          "33:   describe('add', function () {",
          "34:     it('adds a value', async function () {",
          "35:       const receipt = await methods.add(this.set, valueA);",
          "36:       expectEvent(receipt, events.addReturn, { ret0: true });",
          "38:       await expectMembersMatch(this.set, [valueA]);",
          "39:     });",
          "41:     it('adds several values', async function () {",
          "42:       await methods.add(this.set, valueA);",
          "43:       await methods.add(this.set, valueB);",
          "45:       await expectMembersMatch(this.set, [valueA, valueB]);",
          "46:       expect(await methods.contains(this.set, valueC)).to.equal(false);",
          "47:     });",
          "49:     it('returns false when adding values already in the set', async function () {",
          "50:       await methods.add(this.set, valueA);",
          "52:       const receipt = await methods.add(this.set, valueA);",
          "53:       expectEvent(receipt, events.addReturn, { ret0: false });",
          "55:       await expectMembersMatch(this.set, [valueA]);",
          "56:     });",
          "57:   });",
          "59:   describe('at', function () {",
          "60:     it('reverts when retrieving non-existent elements', async function () {",
          "61:       await expectRevert.unspecified(methods.at(this.set, 0));",
          "62:     });",
          "63:   });",
          "65:   describe('remove', function () {",
          "66:     it('removes added values', async function () {",
          "67:       await methods.add(this.set, valueA);",
          "69:       const receipt = await methods.remove(this.set, valueA);",
          "70:       expectEvent(receipt, events.removeReturn, { ret0: true });",
          "72:       expect(await methods.contains(this.set, valueA)).to.equal(false);",
          "73:       await expectMembersMatch(this.set, []);",
          "74:     });",
          "76:     it('returns false when removing values not in the set', async function () {",
          "77:       const receipt = await methods.remove(this.set, valueA);",
          "78:       expectEvent(receipt, events.removeReturn, { ret0: false });",
          "80:       expect(await methods.contains(this.set, valueA)).to.equal(false);",
          "81:     });",
          "83:     it('adds and removes multiple values', async function () {",
          "86:       await methods.add(this.set, valueA);",
          "87:       await methods.add(this.set, valueC);",
          "91:       await methods.remove(this.set, valueA);",
          "92:       await methods.remove(this.set, valueB);",
          "96:       await methods.add(this.set, valueB);",
          "100:       await methods.add(this.set, valueA);",
          "101:       await methods.remove(this.set, valueC);",
          "105:       await methods.add(this.set, valueA);",
          "106:       await methods.add(this.set, valueB);",
          "110:       await methods.add(this.set, valueC);",
          "111:       await methods.remove(this.set, valueA);",
          "115:       await methods.add(this.set, valueA);",
          "116:       await methods.remove(this.set, valueB);",
          "120:       await expectMembersMatch(this.set, [valueA, valueC]);",
          "122:       expect(await methods.contains(this.set, valueB)).to.equal(false);",
          "123:     });",
          "124:   });",
          "125: }",
          "127: module.exports = {",
          "128:   shouldBehaveLikeSet,",
          "129: };",
          "",
          "---------------"
        ],
        "test/utils/structs/EnumerableSet.test.js||test/utils/structs/EnumerableSet.test.js": [
          "File: test/utils/structs/EnumerableSet.test.js -> test/utils/structs/EnumerableSet.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: const EnumerableSet = artifacts.require('$EnumerableSet');",
          "2: const { mapValues } = require('../../helpers/map-values');",
          "4: const { shouldBehaveLikeSet } = require('./EnumerableSet.behavior');",
          "6: const getMethods = ms => {",
          "7:   return mapValues(",
          "8:     ms,",
          "9:     m =>",
          "10:       (self, ...args) =>",
          "11:         self.methods[m](0, ...args),",
          "12:   );",
          "13: };",
          "16: const library = EnumerableSet._json.contractName.replace(/^\\$/, '');",
          "18: contract('EnumerableSet', function (accounts) {",
          "19:   beforeEach(async function () {",
          "20:     this.set = await EnumerableSet.new();",
          "21:   });",
          "24:   describe('EnumerableBytes32Set', function () {",
          "25:     shouldBehaveLikeSet(",
          "26:       ['0xdeadbeef', '0x0123456789', '0x42424242'].map(e => e.padEnd(66, '0')),",
          "27:       getMethods({",
          "28:         add: '$add(uint256,bytes32)',",
          "29:         remove: '$remove(uint256,bytes32)',",
          "30:         contains: '$contains(uint256,bytes32)',",
          "31:         length: `$length_${library}_Bytes32Set(uint256)`,",
          "32:         at: `$at_${library}_Bytes32Set(uint256,uint256)`,",
          "33:         values: `$values_${library}_Bytes32Set(uint256)`,",
          "34:       }),",
          "35:       {",
          "36:         addReturn: `return$add_${library}_Bytes32Set_bytes32`,",
          "37:         removeReturn: `return$remove_${library}_Bytes32Set_bytes32`,",
          "38:       },",
          "39:     );",
          "40:   });",
          "43:   describe('EnumerableAddressSet', function () {",
          "44:     shouldBehaveLikeSet(",
          "45:       accounts,",
          "46:       getMethods({",
          "47:         add: '$add(uint256,address)',",
          "48:         remove: '$remove(uint256,address)',",
          "49:         contains: '$contains(uint256,address)',",
          "50:         length: `$length_${library}_AddressSet(uint256)`,",
          "51:         at: `$at_${library}_AddressSet(uint256,uint256)`,",
          "52:         values: `$values_${library}_AddressSet(uint256)`,",
          "53:       }),",
          "54:       {",
          "55:         addReturn: `return$add_${library}_AddressSet_address`,",
          "56:         removeReturn: `return$remove_${library}_AddressSet_address`,",
          "57:       },",
          "58:     );",
          "59:   });",
          "62:   describe('EnumerableUintSet', function () {",
          "63:     shouldBehaveLikeSet(",
          "64:       [1234, 5678, 9101112].map(e => web3.utils.toBN(e)),",
          "65:       getMethods({",
          "66:         add: '$add(uint256,uint256)',",
          "67:         remove: '$remove(uint256,uint256)',",
          "68:         contains: '$contains(uint256,uint256)',",
          "69:         length: `$length_${library}_UintSet(uint256)`,",
          "70:         at: `$at_${library}_UintSet(uint256,uint256)`,",
          "71:         values: `$values_${library}_UintSet(uint256)`,",
          "72:       }),",
          "73:       {",
          "74:         addReturn: `return$add_${library}_UintSet_uint256`,",
          "75:         removeReturn: `return$remove_${library}_UintSet_uint256`,",
          "76:       },",
          "77:     );",
          "78:   });",
          "79: });",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e29e42a529dafcdb5d792cfef97ce71ea0388045",
      "candidate_info": {
        "commit_hash": "e29e42a529dafcdb5d792cfef97ce71ea0388045",
        "repo": "OpenZeppelin/openzeppelin-contracts-upgradeable",
        "commit_url": "https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/commit/e29e42a529dafcdb5d792cfef97ce71ea0388045",
        "files": [
          ".changeset/swift-bags-divide.md",
          "contracts/governance/GovernorUpgradeable.sol",
          "test/governance/Governor.t.sol",
          "test/governance/Governor.test.js"
        ],
        "message": "Transpile d9474327",
        "before_after_code_files": [
          "contracts/governance/GovernorUpgradeable.sol||contracts/governance/GovernorUpgradeable.sol",
          "test/governance/Governor.t.sol||test/governance/Governor.t.sol",
          "test/governance/Governor.test.js||test/governance/Governor.test.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "contracts/governance/GovernorUpgradeable.sol||contracts/governance/GovernorUpgradeable.sol",
            "test/governance/Governor.t.sol||test/governance/Governor.t.sol",
            "test/governance/Governor.test.js||test/governance/Governor.test.js"
          ],
          "candidate": [
            "contracts/governance/GovernorUpgradeable.sol||contracts/governance/GovernorUpgradeable.sol",
            "test/governance/Governor.t.sol||test/governance/Governor.t.sol",
            "test/governance/Governor.test.js||test/governance/Governor.test.js"
          ]
        }
      },
      "candidate_diff": {
        "contracts/governance/GovernorUpgradeable.sol||contracts/governance/GovernorUpgradeable.sol": [
          "File: contracts/governance/GovernorUpgradeable.sol -> contracts/governance/GovernorUpgradeable.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "278:         string memory description",
          "279:     ) public virtual override returns (uint256) {",
          "280:         address proposer = _msgSender();",
          "283:         require(",
          "284:             getVotes(proposer, currentTimepoint - 1) >= proposalThreshold(),",
          "285:             \"Governor: proposer votes below proposal threshold\"",
          "",
          "[Removed Lines]",
          "281:         uint256 currentTimepoint = clock();",
          "",
          "[Added Lines]",
          "281:         require(_isValidDescriptionForProposer(proposer, description), \"Governor: proposer restricted\");",
          "283:         uint256 currentTimepoint = clock();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "635:         return this.onERC1155BatchReceived.selector;",
          "636:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "656:     function _isValidDescriptionForProposer(",
          "657:         address proposer,",
          "658:         string memory description",
          "659:     ) internal view virtual returns (bool) {",
          "660:         uint256 len = bytes(description).length;",
          "663:         if (len < 52) {",
          "664:             return true;",
          "665:         }",
          "668:         bytes12 marker;",
          "669:         assembly {",
          "676:             marker := mload(add(description, sub(len, 20)))",
          "677:         }",
          "680:         if (marker != bytes12(\"#proposer=0x\")) {",
          "681:             return true;",
          "682:         }",
          "685:         uint160 recovered = 0;",
          "686:         for (uint256 i = len - 40; i < len; ++i) {",
          "687:             (bool isHex, uint8 value) = _tryHexToUint(bytes(description)[i]);",
          "689:             if (!isHex) {",
          "690:                 return true;",
          "691:             }",
          "692:             recovered = (recovered << 4) | value;",
          "693:         }",
          "695:         return recovered == uint160(proposer);",
          "696:     }",
          "702:     function _tryHexToUint(bytes1 char) private pure returns (bool, uint8) {",
          "703:         uint8 c = uint8(char);",
          "704:         unchecked {",
          "706:             if (47 < c && c < 58) {",
          "707:                 return (true, c - 48);",
          "708:             }",
          "710:             else if (64 < c && c < 71) {",
          "711:                 return (true, c - 55);",
          "712:             }",
          "714:             else if (96 < c && c < 103) {",
          "715:                 return (true, c - 87);",
          "716:             }",
          "718:             else {",
          "719:                 return (false, 0);",
          "720:             }",
          "721:         }",
          "722:     }",
          "",
          "---------------"
        ],
        "test/governance/Governor.t.sol||test/governance/Governor.t.sol": [
          "File: test/governance/Governor.t.sol -> test/governance/Governor.t.sol",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: pragma solidity ^0.8.19;",
          "5: import \"forge-std/Test.sol\";",
          "6: import \"../../contracts/utils/Strings.sol\";",
          "7: import \"../../contracts/governance/Governor.sol\";",
          "9: contract GovernorInternalTest is Test, Governor {",
          "10:     constructor() Governor(\"\") {}",
          "12:     function testValidDescriptionForProposer(string memory description, address proposer, bool includeProposer) public {",
          "13:         if (includeProposer) {",
          "14:             description = string.concat(description, \"#proposer=\", Strings.toHexString(proposer));",
          "15:         }",
          "16:         assertTrue(_isValidDescriptionForProposer(proposer, description));",
          "17:     }",
          "19:     function testInvalidDescriptionForProposer(",
          "20:         string memory description,",
          "21:         address commitProposer,",
          "22:         address actualProposer",
          "23:     ) public {",
          "24:         vm.assume(commitProposer != actualProposer);",
          "25:         description = string.concat(description, \"#proposer=\", Strings.toHexString(commitProposer));",
          "26:         assertFalse(_isValidDescriptionForProposer(actualProposer, description));",
          "27:     }",
          "32:     function clock() public pure override returns (uint48) {}",
          "35:     function CLOCK_MODE() public pure override returns (string memory) {}",
          "38:     function COUNTING_MODE() public pure virtual override returns (string memory) {}",
          "40:     function votingDelay() public pure virtual override returns (uint256) {}",
          "42:     function votingPeriod() public pure virtual override returns (uint256) {}",
          "44:     function quorum(uint256) public pure virtual override returns (uint256) {}",
          "46:     function hasVoted(uint256, address) public pure virtual override returns (bool) {}",
          "48:     function _quorumReached(uint256) internal pure virtual override returns (bool) {}",
          "50:     function _voteSucceeded(uint256) internal pure virtual override returns (bool) {}",
          "52:     function _getVotes(address, uint256, bytes memory) internal pure virtual override returns (uint256) {}",
          "54:     function _countVote(uint256, address, uint8, uint256, bytes memory) internal virtual override {}",
          "55: }",
          "",
          "---------------"
        ],
        "test/governance/Governor.test.js||test/governance/Governor.test.js": [
          "File: test/governance/Governor.test.js -> test/governance/Governor.test.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "551:         });",
          "552:       });",
          "554:       describe('onlyGovernance updates', function () {",
          "555:         it('setVotingDelay is protected', async function () {",
          "556:           await expectRevert(this.mock.setVotingDelay('0'), 'Governor: onlyGovernance');",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "554:       describe('frontrun protection using description suffix', function () {",
          "555:         describe('without protection', function () {",
          "556:           describe('without suffix', function () {",
          "557:             it('proposer can propose', async function () {",
          "558:               expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
          "559:             });",
          "561:             it('someone else can propose', async function () {",
          "562:               expectEvent(await this.helper.propose({ from: voter1 }), 'ProposalCreated');",
          "563:             });",
          "564:           });",
          "566:           describe('with different suffix', function () {",
          "567:             beforeEach(async function () {",
          "568:               this.proposal = this.helper.setProposal(",
          "569:                 [",
          "570:                   {",
          "571:                     target: this.receiver.address,",
          "572:                     data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "573:                     value,",
          "574:                   },",
          "575:                 ],",
          "576:                 `<proposal description>#wrong-suffix=${proposer}`,",
          "577:               );",
          "578:             });",
          "580:             it('proposer can propose', async function () {",
          "581:               expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
          "582:             });",
          "584:             it('someone else can propose', async function () {",
          "585:               expectEvent(await this.helper.propose({ from: voter1 }), 'ProposalCreated');",
          "586:             });",
          "587:           });",
          "589:           describe('with proposer suffix but bad address part', function () {",
          "590:             beforeEach(async function () {",
          "591:               this.proposal = this.helper.setProposal(",
          "592:                 [",
          "593:                   {",
          "594:                     target: this.receiver.address,",
          "595:                     data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "596:                     value,",
          "597:                   },",
          "598:                 ],",
          "599:                 `<proposal description>#proposer=0x3C44CdDdB6a900fa2b585dd299e03d12FA429XYZ`, // XYZ are not a valid hex char",
          "600:               );",
          "601:             });",
          "603:             it('propose can propose', async function () {",
          "604:               expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
          "605:             });",
          "607:             it('someone else can propose', async function () {",
          "608:               expectEvent(await this.helper.propose({ from: voter1 }), 'ProposalCreated');",
          "609:             });",
          "610:           });",
          "611:         });",
          "613:         describe('with protection via proposer suffix', function () {",
          "614:           beforeEach(async function () {",
          "615:             this.proposal = this.helper.setProposal(",
          "616:               [",
          "617:                 {",
          "618:                   target: this.receiver.address,",
          "619:                   data: this.receiver.contract.methods.mockFunction().encodeABI(),",
          "620:                   value,",
          "621:                 },",
          "622:               ],",
          "623:               `<proposal description>#proposer=${proposer}`,",
          "624:             );",
          "625:           });",
          "627:           it('proposer can propose', async function () {",
          "628:             expectEvent(await this.helper.propose({ from: proposer }), 'ProposalCreated');",
          "629:           });",
          "631:           it('someone else cannot propose', async function () {",
          "632:             await expectRevert(this.helper.propose({ from: voter1 }), 'Governor: proposer restricted');",
          "633:           });",
          "634:         });",
          "635:       });",
          "",
          "---------------"
        ]
      }
    }
  ]
}
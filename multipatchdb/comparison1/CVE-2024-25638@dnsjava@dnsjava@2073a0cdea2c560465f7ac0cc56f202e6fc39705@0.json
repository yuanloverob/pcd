{
  "cve_id": "CVE-2024-25638",
  "cve_desc": "dnsjava is an implementation of DNS in Java. Records in DNS replies are not checked for their relevance to the query, allowing an attacker to respond with RRs from different zones. This vulnerability is fixed in 3.6.0.",
  "repo": "dnsjava/dnsjava",
  "patch_hash": "2073a0cdea2c560465f7ac0cc56f202e6fc39705",
  "patch_info": {
    "commit_hash": "2073a0cdea2c560465f7ac0cc56f202e6fc39705",
    "repo": "dnsjava/dnsjava",
    "commit_url": "https://github.com/dnsjava/dnsjava/commit/2073a0cdea2c560465f7ac0cc56f202e6fc39705",
    "files": [
      "README.adoc",
      "pom.xml",
      "src/main/java/org/xbill/DNS/Cache.java",
      "src/main/java/org/xbill/DNS/Lookup.java",
      "src/main/java/org/xbill/DNS/Message.java",
      "src/main/java/org/xbill/DNS/RRset.java",
      "src/main/java/org/xbill/DNS/Record.java",
      "src/main/java/org/xbill/DNS/Section.java",
      "src/main/java/org/xbill/DNS/SetResponse.java",
      "src/main/java/org/xbill/DNS/SetResponseType.java",
      "src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java",
      "src/main/java/org/xbill/DNS/lookup/IrrelevantRecordMode.java",
      "src/main/java/org/xbill/DNS/lookup/LookupResult.java",
      "src/main/java/org/xbill/DNS/lookup/LookupSession.java",
      "src/main/java/org/xbill/DNS/lookup/NoSuchDomainException.java",
      "src/main/java/org/xbill/DNS/lookup/NoSuchRRSetException.java",
      "src/main/java/org/xbill/DNS/lookup/RedirectOverflowException.java",
      "src/test/java/org/xbill/DNS/LookupTest.java",
      "src/test/java/org/xbill/DNS/MessageTest.java",
      "src/test/java/org/xbill/DNS/SetResponseTest.java",
      "src/test/java/org/xbill/DNS/dnssec/Rpl.java",
      "src/test/java/org/xbill/DNS/dnssec/RplParser.java",
      "src/test/java/org/xbill/DNS/dnssec/TestBase.java",
      "src/test/java/org/xbill/DNS/dnssec/UnboundTests.java",
      "src/test/java/org/xbill/DNS/lookup/LookupResultTest.java",
      "src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java",
      "src/test/resources/unbound/val_adcopy.rpl",
      "src/test/resources/unbound/val_unalgo_anchor.rpl"
    ],
    "message": "CVE-2024-25638: Message normalization",
    "before_after_code_files": [
      "src/main/java/org/xbill/DNS/Cache.java||src/main/java/org/xbill/DNS/Cache.java",
      "src/main/java/org/xbill/DNS/Lookup.java||src/main/java/org/xbill/DNS/Lookup.java",
      "src/main/java/org/xbill/DNS/Message.java||src/main/java/org/xbill/DNS/Message.java",
      "src/main/java/org/xbill/DNS/RRset.java||src/main/java/org/xbill/DNS/RRset.java",
      "src/main/java/org/xbill/DNS/Record.java||src/main/java/org/xbill/DNS/Record.java",
      "src/main/java/org/xbill/DNS/Section.java||src/main/java/org/xbill/DNS/Section.java",
      "src/main/java/org/xbill/DNS/SetResponse.java||src/main/java/org/xbill/DNS/SetResponse.java",
      "src/main/java/org/xbill/DNS/SetResponseType.java||src/main/java/org/xbill/DNS/SetResponseType.java",
      "src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java||src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java",
      "src/main/java/org/xbill/DNS/lookup/IrrelevantRecordMode.java||src/main/java/org/xbill/DNS/lookup/IrrelevantRecordMode.java",
      "src/main/java/org/xbill/DNS/lookup/LookupResult.java||src/main/java/org/xbill/DNS/lookup/LookupResult.java",
      "src/main/java/org/xbill/DNS/lookup/LookupSession.java||src/main/java/org/xbill/DNS/lookup/LookupSession.java",
      "src/main/java/org/xbill/DNS/lookup/NoSuchDomainException.java||src/main/java/org/xbill/DNS/lookup/NoSuchDomainException.java",
      "src/main/java/org/xbill/DNS/lookup/NoSuchRRSetException.java||src/main/java/org/xbill/DNS/lookup/NoSuchRRSetException.java",
      "src/main/java/org/xbill/DNS/lookup/RedirectOverflowException.java||src/main/java/org/xbill/DNS/lookup/RedirectOverflowException.java",
      "src/test/java/org/xbill/DNS/LookupTest.java||src/test/java/org/xbill/DNS/LookupTest.java",
      "src/test/java/org/xbill/DNS/MessageTest.java||src/test/java/org/xbill/DNS/MessageTest.java",
      "src/test/java/org/xbill/DNS/SetResponseTest.java||src/test/java/org/xbill/DNS/SetResponseTest.java",
      "src/test/java/org/xbill/DNS/dnssec/Rpl.java||src/test/java/org/xbill/DNS/dnssec/Rpl.java",
      "src/test/java/org/xbill/DNS/dnssec/RplParser.java||src/test/java/org/xbill/DNS/dnssec/RplParser.java",
      "src/test/java/org/xbill/DNS/dnssec/TestBase.java||src/test/java/org/xbill/DNS/dnssec/TestBase.java",
      "src/test/java/org/xbill/DNS/dnssec/UnboundTests.java||src/test/java/org/xbill/DNS/dnssec/UnboundTests.java",
      "src/test/java/org/xbill/DNS/lookup/LookupResultTest.java||src/test/java/org/xbill/DNS/lookup/LookupResultTest.java",
      "src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java||src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java",
      "src/test/resources/unbound/val_adcopy.rpl||src/test/resources/unbound/val_adcopy.rpl",
      "src/test/resources/unbound/val_unalgo_anchor.rpl||src/test/resources/unbound/val_unalgo_anchor.rpl"
    ]
  },
  "patch_diff": {
    "src/main/java/org/xbill/DNS/Cache.java||src/main/java/org/xbill/DNS/Cache.java": [
      "File: src/main/java/org/xbill/DNS/Cache.java -> src/main/java/org/xbill/DNS/Cache.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "31:     int compareCredibility(int cred);",
      "33:     int getType();",
      "34:   }",
      "36:   private static int limitExpire(long ttl, long maxttl) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "35:     boolean isAuthenticated();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "44:     return (int) expire;",
      "45:   }",
      "50:     int credibility;",
      "51:     int expire;",
      "55:       this.credibility = cred;",
      "56:       this.expire = limitExpire(rec.getTTL(), maxttl);",
      "57:       addRR(rec);",
      "58:     }",
      "61:       super(rrset);",
      "62:       this.credibility = cred;",
      "63:       this.expire = limitExpire(rrset.getTTL(), maxttl);",
      "64:     }",
      "66:     @Override",
      "",
      "[Removed Lines]",
      "47:   private static class CacheRRset extends RRset implements Element {",
      "48:     private static final long serialVersionUID = 5971755205903597024L;",
      "53:     public CacheRRset(Record rec, int cred, long maxttl) {",
      "54:       super();",
      "60:     public CacheRRset(RRset rrset, int cred, long maxttl) {",
      "",
      "[Added Lines]",
      "49:   static class CacheRRset extends RRset implements Element {",
      "52:     boolean isAuthenticated;",
      "54:     public CacheRRset(Record rec, int cred, long maxttl, boolean isAuthenticated) {",
      "57:       this.isAuthenticated = isAuthenticated;",
      "61:     public CacheRRset(RRset rrset, int cred, long maxttl, boolean isAuthenticated) {",
      "65:       this.isAuthenticated = isAuthenticated;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "78:     public String toString() {",
      "79:       return super.toString() + \" cl = \" + credibility;",
      "80:     }",
      "81:   }",
      "83:   private static class NegativeElement implements Element {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "84:     @Override",
      "85:     public boolean isAuthenticated() {",
      "86:       return isAuthenticated;",
      "87:     }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "85:     Name name;",
      "86:     int credibility;",
      "87:     int expire;",
      "90:       this.name = name;",
      "91:       this.type = type;",
      "92:       long cttl = 0;",
      "",
      "[Removed Lines]",
      "89:     public NegativeElement(Name name, int type, SOARecord soa, int cred, long maxttl) {",
      "",
      "[Added Lines]",
      "95:     boolean isAuthenticated;",
      "97:     public NegativeElement(",
      "98:         Name name, int type, SOARecord soa, int cred, long maxttl, boolean isAuthenticated) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "95:       }",
      "96:       this.credibility = cred;",
      "97:       this.expire = limitExpire(cttl, maxttl);",
      "98:     }",
      "100:     @Override",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "107:       this.isAuthenticated = isAuthenticated;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "113:       return credibility - cred;",
      "114:     }",
      "116:     @Override",
      "117:     public String toString() {",
      "118:       StringBuilder sb = new StringBuilder();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "126:     @Override",
      "127:     public boolean isAuthenticated() {",
      "128:       return isAuthenticated;",
      "129:     }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "328:   @Deprecated",
      "329:   public synchronized void addRecord(Record r, int cred, Object o) {",
      "331:   }",
      "",
      "[Removed Lines]",
      "330:     addRecord(r, cred);",
      "",
      "[Added Lines]",
      "345:     addRecord(r, cred, false);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "340:   public synchronized void addRecord(Record r, int cred) {",
      "341:     Name name = r.getName();",
      "342:     int type = r.getRRsetType();",
      "343:     if (!Type.isRR(type)) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "356:     addRecord(r, cred, false);",
      "357:   }",
      "359:   private synchronized void addRecord(Record r, int cred, boolean isAuthenticated) {",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "345:     }",
      "346:     Element element = findElement(name, type, cred);",
      "347:     if (element == null) {",
      "350:     } else if (element.compareCredibility(cred) == 0) {",
      "351:       if (element instanceof CacheRRset) {",
      "352:         CacheRRset crrset = (CacheRRset) element;",
      "",
      "[Removed Lines]",
      "348:       CacheRRset crrset = new CacheRRset(r, cred, maxcache);",
      "349:       addRRset(crrset, cred);",
      "",
      "[Added Lines]",
      "367:       CacheRRset crrset = new CacheRRset(r, cred, maxcache, isAuthenticated);",
      "368:       addRRset(crrset, cred, isAuthenticated);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "365:   public synchronized <T extends Record> void addRRset(RRset rrset, int cred) {",
      "366:     long ttl = rrset.getTTL();",
      "367:     Name name = rrset.getName();",
      "368:     int type = rrset.getType();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "385:     addRRset(rrset, cred, false);",
      "386:   }",
      "388:   private synchronized <T extends Record> void addRRset(",
      "389:       RRset rrset, int cred, boolean isAuthenticated) {",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "380:         if (rrset instanceof CacheRRset) {",
      "381:           crrset = (CacheRRset) rrset;",
      "382:         } else {",
      "384:         }",
      "385:         addElement(name, crrset);",
      "386:       }",
      "",
      "[Removed Lines]",
      "383:           crrset = new CacheRRset(rrset, cred, maxcache);",
      "",
      "[Added Lines]",
      "407:           crrset = new CacheRRset(rrset, cred, maxcache, isAuthenticated);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "399:   public synchronized void addNegative(Name name, int type, SOARecord soa, int cred) {",
      "400:     long ttl = 0;",
      "401:     if (soa != null) {",
      "402:       ttl = Math.min(soa.getMinimum(), soa.getTTL());",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "424:     addNegative(name, type, soa, cred, false);",
      "425:   }",
      "427:   private synchronized void addNegative(",
      "428:       Name name, int type, SOARecord soa, int cred, boolean isAuthenticated) {",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "411:         element = null;",
      "412:       }",
      "413:       if (element == null) {",
      "415:       }",
      "416:     }",
      "417:   }",
      "",
      "[Removed Lines]",
      "414:         addElement(name, new NegativeElement(name, type, soa, cred, maxncache));",
      "",
      "[Added Lines]",
      "443:         addElement(name, new NegativeElement(name, type, soa, cred, maxncache, isAuthenticated));",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "602:   public SetResponse addMessage(Message in) {",
      "604:     Record question = in.getQuestion();",
      "605:     Name qname;",
      "606:     Name curname;",
      "",
      "[Removed Lines]",
      "603:     boolean isAuth = in.getHeader().getFlag(Flags.AA);",
      "",
      "[Added Lines]",
      "632:     boolean isAuthoritative = in.getHeader().getFlag(Flags.AA);",
      "633:     boolean isAuthenticated = in.getHeader().getFlag(Flags.AD);",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "626:     additionalNames = new HashSet<>();",
      "628:     answers = in.getSectionRRsets(Section.ANSWER);",
      "630:       if (answer.getDClass() != qclass) {",
      "631:         continue;",
      "632:       }",
      "633:       int type = answer.getType();",
      "634:       Name name = answer.getName();",
      "636:       if ((type == qtype || qtype == Type.ANY) && name.equals(curname)) {",
      "638:         completed = true;",
      "639:         if (curname == qname) {",
      "640:           if (response == null) {",
      "",
      "[Removed Lines]",
      "629:     for (RRset answer : answers) {",
      "635:       cred = getCred(Section.ANSWER, isAuth);",
      "637:         addRRset(answer, cred);",
      "",
      "[Added Lines]",
      "659:     for (int i = 0; i < answers.size(); i++) {",
      "660:       RRset answer = answers.get(i);",
      "666:       cred = getCred(Section.ANSWER, isAuthoritative);",
      "668:         addRRset(answer, cred, isAuthenticated);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "643:           response.addRRset(answer);",
      "644:         }",
      "645:         markAdditional(answer, additionalNames);",
      "654:       } else if (type == Type.DNAME && curname.subdomain(name)) {",
      "655:         DNAMERecord dname;",
      "657:         if (curname == qname) {",
      "659:         }",
      "660:         dname = (DNAMERecord) answer.first();",
      "661:         try {",
      "662:           curname = curname.fromDNAME(dname);",
      "663:         } catch (NameTooLongException e) {",
      "664:           break;",
      "665:         }",
      "666:       }",
      "667:     }",
      "",
      "[Removed Lines]",
      "646:       } else if (type == Type.CNAME && name.equals(curname)) {",
      "647:         CNAMERecord cname;",
      "648:         addRRset(answer, cred);",
      "649:         if (curname == qname) {",
      "650:           response = SetResponse.ofType(SetResponseType.CNAME, answer);",
      "651:         }",
      "652:         cname = (CNAMERecord) answer.first();",
      "653:         curname = cname.getTarget();",
      "656:         addRRset(answer, cred);",
      "658:           response = SetResponse.ofType(SetResponseType.DNAME, answer);",
      "",
      "[Added Lines]",
      "679:         addRRset(answer, cred, isAuthenticated);",
      "681:           response = SetResponse.ofType(SetResponseType.DNAME, answer, isAuthenticated);",
      "682:         }",
      "684:         if (i + 1 < answers.size()) {",
      "685:           RRset next = answers.get(i + 1);",
      "686:           if (next.getType() == Type.CNAME && next.getName().equals(curname)) {",
      "689:             continue;",
      "690:           }",
      "699:       } else if (type == Type.CNAME && name.equals(curname)) {",
      "700:         CNAMERecord cname;",
      "701:         addRRset(answer, cred, isAuthenticated);",
      "702:         if (curname == qname) {",
      "703:           response = SetResponse.ofType(SetResponseType.CNAME, answer, isAuthenticated);",
      "704:         }",
      "705:         cname = (CNAMERecord) answer.first();",
      "706:         curname = cname.getTarget();",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "681:       int cachetype = (rcode == Rcode.NXDOMAIN) ? 0 : qtype;",
      "682:       if (rcode == Rcode.NXDOMAIN || soa != null || ns == null) {",
      "685:         SOARecord soarec = null;",
      "686:         if (soa != null) {",
      "687:           soarec = (SOARecord) soa.first();",
      "688:         }",
      "690:         if (response == null) {",
      "691:           SetResponseType responseType;",
      "692:           if (rcode == Rcode.NXDOMAIN) {",
      "",
      "[Removed Lines]",
      "684:         cred = getCred(Section.AUTHORITY, isAuth);",
      "689:         addNegative(curname, cachetype, soarec, cred);",
      "",
      "[Added Lines]",
      "725:         cred = getCred(Section.AUTHORITY, isAuthoritative);",
      "730:         addNegative(curname, cachetype, soarec, cred, isAuthenticated);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "700:       } else {",
      "704:         markAdditional(ns, additionalNames);",
      "705:         if (response == null) {",
      "707:         }",
      "708:       }",
      "709:     } else if (rcode == Rcode.NOERROR && ns != null) {",
      "713:       markAdditional(ns, additionalNames);",
      "714:     }",
      "",
      "[Removed Lines]",
      "702:         cred = getCred(Section.AUTHORITY, isAuth);",
      "703:         addRRset(ns, cred);",
      "706:           response = SetResponse.ofType(SetResponseType.DELEGATION, ns);",
      "711:       cred = getCred(Section.AUTHORITY, isAuth);",
      "712:       addRRset(ns, cred);",
      "",
      "[Added Lines]",
      "743:         cred = getCred(Section.AUTHORITY, isAuthoritative);",
      "744:         addRRset(ns, cred, isAuthenticated);",
      "747:           response = SetResponse.ofType(SetResponseType.DELEGATION, ns, isAuthenticated);",
      "752:       cred = getCred(Section.AUTHORITY, isAuthoritative);",
      "753:       addRRset(ns, cred, isAuthenticated);",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "723:       if (!additionalNames.contains(name)) {",
      "724:         continue;",
      "725:       }",
      "728:     }",
      "730:     log.debug(",
      "",
      "[Removed Lines]",
      "726:       cred = getCred(Section.ADDITIONAL, isAuth);",
      "727:       addRRset(rRset, cred);",
      "",
      "[Added Lines]",
      "767:       cred = getCred(Section.ADDITIONAL, isAuthoritative);",
      "768:       addRRset(rRset, cred, isAuthenticated);",
      "",
      "---------------"
    ],
    "src/main/java/org/xbill/DNS/Lookup.java||src/main/java/org/xbill/DNS/Lookup.java": [
      "File: src/main/java/org/xbill/DNS/Lookup.java -> src/main/java/org/xbill/DNS/Lookup.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "437:   public void setCache(Cache cache) {",
      "438:     if (cache == null) {",
      "439:       this.cache = new Cache(dclass);",
      "440:       this.temporary_cache = true;",
      "441:     } else {",
      "442:       this.cache = cache;",
      "443:       this.temporary_cache = false;",
      "444:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "443:       if (cache.getDClass() != dclass) {",
      "444:         throw new IllegalArgumentException(",
      "445:             \"DClass of cache doesn't match DClass of this Lookup instance\");",
      "446:       }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "571:     Message query = Message.newQuery(question);",
      "572:     Message response;",
      "573:     try {",
      "575:     } catch (IOException e) {",
      "576:       log.debug(",
      "577:           \"Lookup for {}/{}, id={} failed using resolver {}\",",
      "",
      "[Removed Lines]",
      "574:       response = resolver.send(query);",
      "",
      "[Added Lines]",
      "580:       response = resolver.send(query).normalize(query);",
      "",
      "---------------"
    ],
    "src/main/java/org/xbill/DNS/Message.java||src/main/java/org/xbill/DNS/Message.java": [
      "File: src/main/java/org/xbill/DNS/Message.java -> src/main/java/org/xbill/DNS/Message.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "7: import java.nio.ByteBuffer;",
      "8: import java.util.ArrayList;",
      "9: import java.util.Collections;",
      "11: import java.util.LinkedList;",
      "12: import java.util.List;",
      "13: import java.util.Optional;",
      "15: import lombok.SneakyThrows;",
      "",
      "[Removed Lines]",
      "10: import java.util.HashSet;",
      "14: import java.util.Set;",
      "",
      "[Added Lines]",
      "15: import lombok.extern.slf4j.Slf4j;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "26: public class Message implements Cloneable {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "26: @Slf4j",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "194:   public boolean removeRecord(Record r, int section) {",
      "195:     if (sections[section] != null && sections[section].remove(r)) {",
      "196:       header.decCount(section);",
      "197:       return true;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "196:     Section.check(section);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "209:   public void removeAllRecords(int section) {",
      "210:     sections[section] = null;",
      "211:     header.setCount(section, 0);",
      "212:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "212:     Section.check(section);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "220:   public boolean findRecord(Record r, int section) {",
      "221:     return sections[section] != null && sections[section].contains(r);",
      "222:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "224:     Section.check(section);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "245:   public boolean findRRset(Name name, int type, int section) {",
      "246:     if (sections[section] == null) {",
      "247:       return false;",
      "248:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "250:     Type.check(type);",
      "251:     Section.check(section);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "365:   @Deprecated",
      "366:   public Record[] getSectionArray(int section) {",
      "367:     if (sections[section] == null) {",
      "368:       return emptyRecordArray;",
      "369:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "373:     Section.check(section);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "380:   public List<Record> getSection(int section) {",
      "381:     if (sections[section] == null) {",
      "382:       return Collections.emptyList();",
      "383:     }",
      "384:     return Collections.unmodifiableList(sections[section]);",
      "385:   }",
      "399:   public List<RRset> getSectionRRsets(int section) {",
      "400:     if (sections[section] == null) {",
      "401:       return Collections.emptyList();",
      "402:     }",
      "403:     List<RRset> sets = new LinkedList<>();",
      "418:         }",
      "419:       }",
      "425:     }",
      "426:     return sets;",
      "427:   }",
      "",
      "[Removed Lines]",
      "387:   private static boolean sameSet(Record r1, Record r2) {",
      "388:     return r1.getRRsetType() == r2.getRRsetType()",
      "389:         && r1.getDClass() == r2.getDClass()",
      "390:         && r1.getName().equals(r2.getName());",
      "391:   }",
      "404:     Set<Name> hash = new HashSet<>();",
      "405:     for (Record rec : getSection(section)) {",
      "406:       Name name = rec.getName();",
      "407:       boolean newset = true;",
      "408:       if (hash.contains(name)) {",
      "409:         for (int j = sets.size() - 1; j >= 0; j--) {",
      "410:           RRset set = sets.get(j);",
      "411:           if (set.getType() == rec.getRRsetType()",
      "412:               && set.getDClass() == rec.getDClass()",
      "413:               && set.getName().equals(name)) {",
      "414:             set.addRR(rec);",
      "415:             newset = false;",
      "416:             break;",
      "417:           }",
      "420:       if (newset) {",
      "421:         RRset set = new RRset(rec);",
      "422:         sets.add(set);",
      "423:         hash.add(name);",
      "424:       }",
      "",
      "[Added Lines]",
      "388:     Section.check(section);",
      "401:   @SuppressWarnings(\"java:S1119\") // label",
      "403:     Section.check(section);",
      "409:     record_iteration:",
      "410:     for (Record rec : sections[section]) {",
      "411:       for (int j = sets.size() - 1; j >= 0; j--) {",
      "412:         RRset set = sets.get(j);",
      "413:         if (rec.sameRRset(set)) {",
      "414:           set.addRR(rec);",
      "417:           continue record_iteration;",
      "422:       sets.add(new RRset(rec));",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "453:         continue;",
      "454:       }",
      "457:         pos = out.current();",
      "458:         rendered = count;",
      "459:       }",
      "",
      "[Removed Lines]",
      "456:       if (lastrec != null && !sameSet(rec, lastrec)) {",
      "",
      "[Added Lines]",
      "455:       if (lastrec != null && !rec.sameRRset(lastrec)) {",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "612:     StringBuilder sb = new StringBuilder();",
      "614:     return sb.toString();",
      "615:   }",
      "",
      "[Removed Lines]",
      "607:   public String sectionToString(int i) {",
      "608:     if (i > 3) {",
      "609:       return null;",
      "610:     }",
      "613:     sectionToString(sb, i);",
      "",
      "[Added Lines]",
      "606:   public String sectionToString(int section) {",
      "607:     Section.check(section);",
      "609:     sectionToString(sb, section);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "678:   @Override",
      "679:   @SneakyThrows(CloneNotSupportedException.class)",
      "681:   public Message clone() {",
      "682:     Message m = (Message) super.clone();",
      "684:     for (int i = 0; i < sections.length; i++) {",
      "685:       if (sections[i] != null) {",
      "686:         m.sections[i] = new LinkedList<>(sections[i]);",
      "",
      "[Removed Lines]",
      "680:   @SuppressWarnings(\"unchecked\")",
      "683:     m.sections = (List<Record>[]) new List[sections.length];",
      "",
      "[Added Lines]",
      "676:   @SuppressWarnings({\"unchecked\", \"java:S2975\"})",
      "679:     m.sections = new List[sections.length];",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "705:   public Optional<Resolver> getResolver() {",
      "706:     return Optional.ofNullable(resolver);",
      "707:   }",
      "708: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "710:   boolean isTypeAllowedInSection(int type, int section) {",
      "711:     Type.check(type);",
      "712:     Section.check(section);",
      "713:     switch (section) {",
      "714:       case Section.AUTHORITY:",
      "715:         if (type == Type.SOA",
      "716:             || type == Type.NS",
      "717:             || type == Type.DS",
      "718:             || type == Type.NSEC",
      "719:             || type == Type.NSEC3) {",
      "720:           return true;",
      "721:         }",
      "722:         break;",
      "723:       case Section.ADDITIONAL:",
      "724:         if (type == Type.A || type == Type.AAAA) {",
      "725:           return true;",
      "726:         }",
      "727:         break;",
      "728:     }",
      "730:     return !Boolean.parseBoolean(System.getProperty(\"dnsjava.harden_unknown_additional\", \"true\"));",
      "731:   }",
      "747:   public Message normalize(Message query) {",
      "748:     try {",
      "749:       return normalize(query, false);",
      "750:     } catch (WireParseException e) {",
      "752:     }",
      "754:     return null;",
      "755:   }",
      "772:   public Message normalize(Message query, boolean throwOnIrrelevantRecord)",
      "773:       throws WireParseException {",
      "774:     if (getRcode() != Rcode.NOERROR && getRcode() != Rcode.NXDOMAIN) {",
      "775:       return this;",
      "776:     }",
      "778:     Name sname = query.getQuestion().getName();",
      "779:     List<RRset> answerSectionSets = getSectionRRsets(Section.ANSWER);",
      "780:     List<RRset> additionalSectionSets = getSectionRRsets(Section.ADDITIONAL);",
      "781:     List<RRset> authoritySectionSets = getSectionRRsets(Section.AUTHORITY);",
      "783:     List<RRset> cleanedAnswerSection = new ArrayList<>();",
      "784:     List<RRset> cleanedAuthoritySection = new ArrayList<>();",
      "785:     List<RRset> cleanedAdditionalSection = new ArrayList<>();",
      "786:     boolean hadNsInAuthority = false;",
      "790:     for (int i = 0; i < answerSectionSets.size(); i++) {",
      "791:       RRset rrset = answerSectionSets.get(i);",
      "792:       Name oldSname = sname;",
      "794:       if (rrset.getType() == Type.DNAME && sname.subdomain(rrset.getName())) {",
      "795:         if (rrset.size() > 1) {",
      "796:           String template =",
      "797:               \"Normalization failed in response to <{}/{}/{}> (id {}), found {} entries (instead of just one) in DNAME RRSet <{}/{}>\";",
      "798:           if (throwOnIrrelevantRecord) {",
      "799:             throw new WireParseException(template.replace(\"{}\", \"%s\"));",
      "800:           }",
      "801:           log.warn(",
      "802:               template,",
      "803:               sname,",
      "804:               Type.string(query.getQuestion().getType()),",
      "805:               DClass.string(query.getQuestion().getDClass()),",
      "806:               getHeader().getID(),",
      "807:               rrset.size(),",
      "808:               rrset.getName(),",
      "809:               DClass.string(rrset.getDClass()));",
      "810:           return null;",
      "811:         }",
      "814:         if (query.getQuestion().getType() != Type.DNAME) {",
      "816:           cleanedAnswerSection.add(rrset);",
      "819:           RRset nextRRSet = answerSectionSets.size() >= i + 2 ? answerSectionSets.get(i + 1) : null;",
      "820:           DNAMERecord dname = ((DNAMERecord) rrset.first());",
      "821:           try {",
      "823:             if (nextRRSet != null",
      "824:                 && nextRRSet.getType() == Type.CNAME",
      "825:                 && nextRRSet.getName().equals(sname)) {",
      "826:               Name expected =",
      "827:                   Name.concatenate(",
      "828:                       nextRRSet.getName().relativize(dname.getName()), dname.getTarget());",
      "829:               if (expected.equals(((CNAMERecord) nextRRSet.first()).getTarget())) {",
      "830:                 continue;",
      "831:               }",
      "832:             }",
      "835:             Name dnameTarget = sname.fromDNAME(dname);",
      "836:             cleanedAnswerSection.add(",
      "837:                 new RRset(new CNAMERecord(sname, dname.getDClass(), 0, dnameTarget)));",
      "838:             sname = dnameTarget;",
      "841:             if (query.getQuestion().getType() == Type.ANY) {",
      "842:               for (i++; i < answerSectionSets.size(); i++) {",
      "843:                 rrset = answerSectionSets.get(i);",
      "844:                 if (rrset.getName().equals(oldSname)) {",
      "845:                   cleanedAnswerSection.add(rrset);",
      "846:                 } else {",
      "847:                   break;",
      "848:                 }",
      "849:               }",
      "850:             }",
      "852:             continue;",
      "853:           } catch (NameTooLongException e) {",
      "854:             String template =",
      "855:                 \"Normalization failed in response to <{}/{}/{}> (id {}), could not synthesize CNAME for DNAME <{}/{}>\";",
      "856:             if (throwOnIrrelevantRecord) {",
      "857:               throw new WireParseException(template.replace(\"{}\", \"%s\"), e);",
      "858:             }",
      "859:             log.warn(",
      "860:                 template,",
      "861:                 sname,",
      "862:                 Type.string(query.getQuestion().getType()),",
      "863:                 DClass.string(query.getQuestion().getDClass()),",
      "864:                 getHeader().getID(),",
      "865:                 rrset.getName(),",
      "866:                 DClass.string(rrset.getDClass()));",
      "867:             return null;",
      "868:           }",
      "869:         }",
      "870:       }",
      "873:       if (!sname.equals(rrset.getName())) {",
      "874:         logOrThrow(",
      "875:             throwOnIrrelevantRecord,",
      "876:             \"Ignoring irrelevant RRset <{}/{}/{}> in response to <{}/{}/{}> (id {})\",",
      "877:             rrset,",
      "878:             sname,",
      "879:             query);",
      "880:         continue;",
      "881:       }",
      "884:       if (rrset.getType() == Type.CNAME && query.getQuestion().getType() != Type.CNAME) {",
      "885:         if (rrset.size() > 1) {",
      "886:           String template =",
      "887:               \"Found {} CNAMEs in <{}/{}> response to <{}/{}/{}> (id {}), removing all but the first\";",
      "888:           if (throwOnIrrelevantRecord) {",
      "889:             throw new WireParseException(",
      "890:                 String.format(",
      "891:                     template.replace(\"{}\", \"%s\"),",
      "892:                     rrset.rrs(false).size(),",
      "893:                     rrset.getName(),",
      "894:                     DClass.string(rrset.getDClass()),",
      "895:                     sname,",
      "896:                     Type.string(query.getQuestion().getType()),",
      "897:                     DClass.string(query.getQuestion().getDClass()),",
      "898:                     getHeader().getID()));",
      "899:           }",
      "900:           log.warn(",
      "901:               template,",
      "902:               rrset.rrs(false).size(),",
      "903:               rrset.getName(),",
      "904:               DClass.string(rrset.getDClass()),",
      "905:               sname,",
      "906:               Type.string(query.getQuestion().getType()),",
      "907:               DClass.string(query.getQuestion().getDClass()),",
      "908:               getHeader().getID());",
      "909:           List<Record> cnameRRset = rrset.rrs(false);",
      "910:           for (int cnameIndex = 1; cnameIndex < cnameRRset.size(); cnameIndex++) {",
      "911:             rrset.deleteRR(cnameRRset.get(i));",
      "912:           }",
      "913:         }",
      "915:         sname = ((CNAMERecord) rrset.first()).getTarget();",
      "916:         cleanedAnswerSection.add(rrset);",
      "919:         if (query.getQuestion().getType() == Type.ANY) {",
      "920:           for (i++; i < answerSectionSets.size(); i++) {",
      "921:             rrset = answerSectionSets.get(i);",
      "922:             if (rrset.getName().equals(oldSname)) {",
      "923:               cleanedAnswerSection.add(rrset);",
      "924:             } else {",
      "925:               break;",
      "926:             }",
      "927:           }",
      "928:         }",
      "930:         continue;",
      "931:       }",
      "934:       int qtype = getQuestion().getType();",
      "935:       if (qtype != Type.ANY && rrset.getActualType() != qtype) {",
      "936:         logOrThrow(",
      "937:             throwOnIrrelevantRecord,",
      "938:             \"Ignoring irrelevant RRset <{}/{}/{}> in ANSWER section response to <{}/{}/{}> (id {})\",",
      "939:             rrset,",
      "940:             sname,",
      "941:             query);",
      "942:         continue;",
      "943:       }",
      "946:       cleanedAnswerSection.add(rrset);",
      "947:       if (sname.equals(rrset.getName())) {",
      "948:         addAdditionalRRset(rrset, additionalSectionSets, cleanedAdditionalSection);",
      "949:       }",
      "950:     }",
      "952:     for (RRset rrset : authoritySectionSets) {",
      "953:       switch (rrset.getType()) {",
      "954:         case Type.DNAME:",
      "955:         case Type.CNAME:",
      "956:         case Type.A:",
      "957:         case Type.AAAA:",
      "958:           logOrThrow(",
      "959:               throwOnIrrelevantRecord,",
      "960:               \"Ignoring forbidden RRset <{}/{}/{}> in AUTHORITY section response to <{}/{}/{}> (id {})\",",
      "961:               rrset,",
      "962:               sname,",
      "963:               query);",
      "964:           continue;",
      "965:       }",
      "967:       if (!isTypeAllowedInSection(rrset.getType(), Section.AUTHORITY)) {",
      "968:         logOrThrow(",
      "969:             throwOnIrrelevantRecord,",
      "970:             \"Ignoring disallowed RRset <{}/{}/{}> in AUTHORITY section response to <{}/{}/{}> (id {})\",",
      "971:             rrset,",
      "972:             sname,",
      "973:             query);",
      "974:         continue;",
      "975:       }",
      "977:       if (rrset.getType() == Type.NS) {",
      "979:         if (!sname.subdomain(rrset.getName())) {",
      "980:           logOrThrow(",
      "981:               throwOnIrrelevantRecord,",
      "982:               \"Ignoring disallowed RRset <{}/{}/{}> in AUTHORITY section response to <{}/{}/{}> (id {}), not a subdomain of the query\",",
      "983:               rrset,",
      "984:               sname,",
      "985:               query);",
      "986:           continue;",
      "987:         }",
      "992:         if (getRcode() == Rcode.NXDOMAIN",
      "993:             || (getRcode() == Rcode.NOERROR",
      "994:                 && authoritySectionSets.stream().anyMatch(set -> set.getType() == Type.SOA)",
      "995:                 && sections[Section.ANSWER] == null)) {",
      "996:           logOrThrow(",
      "997:               throwOnIrrelevantRecord,",
      "998:               \"Ignoring disallowed RRset <{}/{}/{}> in AUTHORITY section response to <{}/{}/{}> (id {}), NXDOMAIN or NODATA\",",
      "999:               rrset,",
      "1000:               sname,",
      "1001:               query);",
      "1002:           continue;",
      "1003:         }",
      "1005:         if (!hadNsInAuthority) {",
      "1006:           hadNsInAuthority = true;",
      "1007:         } else {",
      "1008:           logOrThrow(",
      "1009:               throwOnIrrelevantRecord,",
      "1010:               \"Ignoring disallowed RRset <{}/{}/{}> in AUTHORITY section response to <{}/{}/{}> (id {}), already seen another NS\",",
      "1011:               rrset,",
      "1012:               sname,",
      "1013:               query);",
      "1014:           continue;",
      "1015:         }",
      "1016:       }",
      "1018:       cleanedAuthoritySection.add(rrset);",
      "1019:       addAdditionalRRset(rrset, additionalSectionSets, cleanedAdditionalSection);",
      "1020:     }",
      "1022:     Message cleanedMessage = new Message(this.getHeader());",
      "1023:     cleanedMessage.sections[Section.QUESTION] = this.sections[Section.QUESTION];",
      "1024:     cleanedMessage.sections[Section.ANSWER] = rrsetListToRecords(cleanedAnswerSection);",
      "1025:     cleanedMessage.sections[Section.AUTHORITY] = rrsetListToRecords(cleanedAuthoritySection);",
      "1026:     cleanedMessage.sections[Section.ADDITIONAL] = rrsetListToRecords(cleanedAdditionalSection);",
      "1027:     return cleanedMessage;",
      "1028:   }",
      "1030:   private void logOrThrow(",
      "1031:       boolean throwOnIrrelevantRecord, String format, RRset rrset, Name sname, Message query)",
      "1032:       throws WireParseException {",
      "1033:     if (throwOnIrrelevantRecord) {",
      "1034:       throw new WireParseException(",
      "1035:           String.format(",
      "1036:               format.replace(\"{}\", \"%s\") + this,",
      "1037:               rrset.getName(),",
      "1038:               DClass.string(rrset.getDClass()),",
      "1039:               Type.string(rrset.getType()),",
      "1040:               sname,",
      "1041:               Type.string(query.getQuestion().getType()),",
      "1042:               DClass.string(query.getQuestion().getDClass()),",
      "1043:               getHeader().getID()));",
      "1044:     }",
      "1045:     log.debug(",
      "1046:         format,",
      "1047:         rrset.getName(),",
      "1048:         DClass.string(rrset.getDClass()),",
      "1049:         Type.string(rrset.getType()),",
      "1050:         sname,",
      "1051:         Type.string(query.getQuestion().getType()),",
      "1052:         DClass.string(query.getQuestion().getDClass()),",
      "1053:         getHeader().getID());",
      "1054:   }",
      "1056:   private List<Record> rrsetListToRecords(List<RRset> rrsets) {",
      "1057:     if (rrsets.isEmpty()) {",
      "1058:       return null;",
      "1059:     }",
      "1061:     List<Record> result = new ArrayList<>(rrsets.size());",
      "1062:     for (RRset set : rrsets) {",
      "1063:       result.addAll(set.rrs(false));",
      "1064:       result.addAll(set.sigs());",
      "1065:     }",
      "1067:     return result;",
      "1068:   }",
      "1070:   private void addAdditionalRRset(",
      "1071:       RRset rrset, List<RRset> additionalSectionSets, List<RRset> cleanedAdditionalSection) {",
      "1072:     if (!doesTypeHaveAdditionalRecords(rrset.getType())) {",
      "1073:       return;",
      "1074:     }",
      "1076:     for (Record r : rrset.rrs(false)) {",
      "1077:       for (RRset set : additionalSectionSets) {",
      "1078:         if (set.getName().equals(r.getAdditionalName())",
      "1079:             && isTypeAllowedInSection(set.getType(), Section.ADDITIONAL)) {",
      "1080:           cleanedAdditionalSection.add(set);",
      "1081:         }",
      "1082:       }",
      "1083:     }",
      "1084:   }",
      "1086:   private boolean doesTypeHaveAdditionalRecords(int type) {",
      "1087:     switch (type) {",
      "1088:       case Type.MB:",
      "1089:       case Type.MD:",
      "1090:       case Type.MF:",
      "1091:       case Type.NS:",
      "1092:       case Type.MX:",
      "1093:       case Type.KX:",
      "1094:       case Type.SRV:",
      "1095:       case Type.NAPTR:",
      "1096:         return true;",
      "1097:     }",
      "1099:     return false;",
      "1100:   }",
      "",
      "---------------"
    ],
    "src/main/java/org/xbill/DNS/RRset.java||src/main/java/org/xbill/DNS/RRset.java": [
      "File: src/main/java/org/xbill/DNS/RRset.java -> src/main/java/org/xbill/DNS/RRset.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "214:     return first().getRRsetType();",
      "215:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "224:   int getActualType() {",
      "225:     return first().getType();",
      "226:   }",
      "",
      "---------------"
    ],
    "src/main/java/org/xbill/DNS/Record.java||src/main/java/org/xbill/DNS/Record.java": [
      "File: src/main/java/org/xbill/DNS/Record.java -> src/main/java/org/xbill/DNS/Record.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "566:     return getRRsetType() == rec.getRRsetType() && dclass == rec.dclass && name.equals(rec.name);",
      "567:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "575:   public boolean sameRRset(RRset set) {",
      "576:     return getRRsetType() == set.getType()",
      "577:         && dclass == set.getDClass()",
      "578:         && name.equals(set.getName());",
      "579:   }",
      "",
      "---------------"
    ],
    "src/main/java/org/xbill/DNS/Section.java||src/main/java/org/xbill/DNS/Section.java": [
      "File: src/main/java/org/xbill/DNS/Section.java -> src/main/java/org/xbill/DNS/Section.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "79:   public static int value(String s) {",
      "80:     return sections.getValue(s);",
      "81:   }",
      "82: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "88:   public static void check(int section) {",
      "89:     sections.check(section);",
      "90:   }",
      "",
      "---------------"
    ],
    "src/main/java/org/xbill/DNS/SetResponse.java||src/main/java/org/xbill/DNS/SetResponse.java": [
      "File: src/main/java/org/xbill/DNS/SetResponse.java -> src/main/java/org/xbill/DNS/SetResponse.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "14: import java.util.ArrayList;",
      "15: import java.util.List;",
      "16: import lombok.Getter;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "16: import lombok.AccessLevel;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "34:   private final SetResponseType type;",
      "41:   private List<RRset> data;",
      "",
      "[Removed Lines]",
      "39:   @Getter private boolean isAuthenticated;",
      "",
      "[Added Lines]",
      "37:   @Getter(AccessLevel.PACKAGE)",
      "38:   private boolean isAuthenticated;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "56:     return ofType(type, rrset, false);",
      "57:   }",
      "59:   static SetResponse ofType(SetResponseType type, RRset rrset, boolean isAuthenticated) {",
      "60:     switch (type) {",
      "61:       case UNKNOWN:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "58:   static SetResponse ofType(SetResponseType type, Cache.CacheRRset rrset) {",
      "59:     return ofType(type, rrset, rrset.isAuthenticated());",
      "60:   }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "82:     if (data == null) {",
      "83:       data = new ArrayList<>();",
      "84:     }",
      "86:     data.add(rrset);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "87:       if (rrset instanceof Cache.CacheRRset) {",
      "88:         isAuthenticated = ((Cache.CacheRRset) rrset).isAuthenticated();",
      "89:       }",
      "90:     } else {",
      "91:       if (rrset instanceof Cache.CacheRRset && isAuthenticated) {",
      "92:         isAuthenticated = ((Cache.CacheRRset) rrset).isAuthenticated();",
      "93:       }",
      "",
      "---------------"
    ],
    "src/main/java/org/xbill/DNS/SetResponseType.java||src/main/java/org/xbill/DNS/SetResponseType.java": [
      "File: src/main/java/org/xbill/DNS/SetResponseType.java -> src/main/java/org/xbill/DNS/SetResponseType.java"
    ],
    "src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java||src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java": [
      "File: src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java -> src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java"
    ],
    "src/main/java/org/xbill/DNS/lookup/IrrelevantRecordMode.java||src/main/java/org/xbill/DNS/lookup/IrrelevantRecordMode.java": [
      "File: src/main/java/org/xbill/DNS/lookup/IrrelevantRecordMode.java -> src/main/java/org/xbill/DNS/lookup/IrrelevantRecordMode.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: package org.xbill.DNS.lookup;",
      "5: enum IrrelevantRecordMode {",
      "7:   REMOVE,",
      "9:   THROW,",
      "10: }",
      "",
      "---------------"
    ],
    "src/main/java/org/xbill/DNS/lookup/LookupResult.java||src/main/java/org/xbill/DNS/lookup/LookupResult.java": [
      "File: src/main/java/org/xbill/DNS/lookup/LookupResult.java -> src/main/java/org/xbill/DNS/lookup/LookupResult.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "4: import java.util.ArrayList;",
      "5: import java.util.Collections;",
      "6: import java.util.List;",
      "7: import lombok.Data;",
      "8: import org.xbill.DNS.Name;",
      "9: import org.xbill.DNS.Record;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6: import java.util.HashMap;",
      "8: import java.util.Map;",
      "9: import java.util.Objects;",
      "10: import lombok.AccessLevel;",
      "12: import lombok.Getter;",
      "13: import org.xbill.DNS.Flags;",
      "14: import org.xbill.DNS.Message;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "27:   private final List<Name> aliases;",
      "36:   public LookupResult(List<Record> records, List<Name> aliases) {",
      "37:     this.records = Collections.unmodifiableList(new ArrayList<>(records));",
      "38:     this.aliases =",
      "39:         aliases == null",
      "40:             ? Collections.emptyList()",
      "41:             : Collections.unmodifiableList(new ArrayList<>(aliases));",
      "42:   }",
      "43: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "37:   @Getter(AccessLevel.PACKAGE)",
      "38:   private final Map<Record, Message> queryResponsePairs;",
      "53:   @Getter(AccessLevel.PACKAGE)",
      "54:   private final boolean isAuthenticated;",
      "64:   @Deprecated",
      "71:     queryResponsePairs = Collections.emptyMap();",
      "72:     isAuthenticated = false;",
      "73:   }",
      "75:   LookupResult(boolean isAuthenticated) {",
      "76:     queryResponsePairs = Collections.emptyMap();",
      "77:     this.isAuthenticated = isAuthenticated;",
      "78:     records = Collections.emptyList();",
      "79:     aliases = Collections.emptyList();",
      "80:   }",
      "82:   LookupResult(Record query, boolean isAuthenticated, Record record) {",
      "83:     this.queryResponsePairs = Collections.singletonMap(query, null);",
      "84:     this.isAuthenticated = isAuthenticated;",
      "85:     this.records = Collections.singletonList(record);",
      "86:     this.aliases = Collections.emptyList();",
      "87:   }",
      "89:   LookupResult(",
      "90:       LookupResult previous,",
      "91:       Record query,",
      "92:       Message answer,",
      "93:       boolean isAuthenticated,",
      "94:       List<Record> records,",
      "95:       List<Name> aliases) {",
      "96:     Map<Record, Message> map = new HashMap<>(previous.queryResponsePairs.size() + 1);",
      "97:     map.putAll(previous.queryResponsePairs);",
      "98:     map.put(query, answer);",
      "99:     this.queryResponsePairs = Collections.unmodifiableMap(map);",
      "100:     this.isAuthenticated =",
      "101:         previous.isAuthenticated",
      "102:             && isAuthenticated",
      "103:             && this.queryResponsePairs.values().stream()",
      "104:                 .filter(Objects::nonNull)",
      "105:                 .allMatch(a -> a.getHeader().getFlag(Flags.AD));",
      "106:     this.records = Collections.unmodifiableList(new ArrayList<>(records));",
      "107:     this.aliases = Collections.unmodifiableList(new ArrayList<>(aliases));",
      "",
      "---------------"
    ],
    "src/main/java/org/xbill/DNS/lookup/LookupSession.java||src/main/java/org/xbill/DNS/lookup/LookupSession.java": [
      "File: src/main/java/org/xbill/DNS/lookup/LookupSession.java -> src/main/java/org/xbill/DNS/lookup/LookupSession.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "43: import org.xbill.DNS.SetResponse;",
      "44: import org.xbill.DNS.SimpleResolver;",
      "45: import org.xbill.DNS.Type;",
      "46: import org.xbill.DNS.hosts.HostsFileParser;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "46: import org.xbill.DNS.WireParseException;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "65:   private final Map<Integer, Cache> caches;",
      "66:   private final HostsFileParser hostsFileParser;",
      "67:   private final Executor executor;",
      "69:   private LookupSession(",
      "70:       @NonNull Resolver resolver,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "69:   private IrrelevantRecordMode irrelevantRecordMode;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "74:       boolean cycleResults,",
      "75:       List<Cache> caches,",
      "76:       HostsFileParser hostsFileParser,",
      "78:     this.resolver = resolver;",
      "79:     this.maxRedirects = maxRedirects;",
      "80:     this.ndots = ndots;",
      "",
      "[Removed Lines]",
      "77:       Executor executor) {",
      "",
      "[Added Lines]",
      "79:       Executor executor,",
      "80:       IrrelevantRecordMode irrelevantRecordMode) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "86:             : caches.stream().collect(Collectors.toMap(Cache::getDClass, e -> e));",
      "87:     this.hostsFileParser = hostsFileParser;",
      "88:     this.executor = executor == null ? ForkJoinPool.commonPool() : executor;",
      "89:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "92:     this.irrelevantRecordMode = irrelevantRecordMode;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "104:     private List<Cache> caches;",
      "105:     private HostsFileParser hostsFileParser;",
      "106:     private Executor executor;",
      "108:     private LookupSessionBuilder() {}",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "111:     private IrrelevantRecordMode irrelevantRecordMode = IrrelevantRecordMode.REMOVE;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "210:       return this;",
      "211:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "224:     LookupSessionBuilder irrelevantRecordMode(IrrelevantRecordMode irrelevantRecordMode) {",
      "225:       this.irrelevantRecordMode = irrelevantRecordMode;",
      "226:       return this;",
      "227:     }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "322:           cycleResults,",
      "323:           caches,",
      "324:           hostsFileParser,",
      "326:     }",
      "327:   }",
      "",
      "[Removed Lines]",
      "325:           executor);",
      "",
      "[Added Lines]",
      "341:           executor,",
      "342:           irrelevantRecordMode);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "360:         .defaultHostsFileParser();",
      "361:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "381:   Cache getCache(int dclass) {",
      "382:     return caches.get(dclass);",
      "383:   }",
      "392:   public CompletionStage<LookupResult> lookupAsync(Record question) {",
      "393:     return lookupAsync(question.getName(), question.getType(), question.getDClass());",
      "394:   }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "434:             } else {",
      "435:               r = new AAAARecord(name, DClass.IN, 0, result.get());",
      "436:             }",
      "438:           }",
      "439:         }",
      "440:       } catch (IOException e) {",
      "",
      "[Removed Lines]",
      "437:             return new LookupResult(Collections.singletonList(r), Collections.emptyList());",
      "",
      "[Added Lines]",
      "471:             return new LookupResult(Record.newRecord(name, type, DClass.IN), true, r);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "458:                 if (names.hasNext()) {",
      "459:                   return lookupUntilSuccess(names, type, dclass);",
      "460:                 } else {",
      "462:                 }",
      "463:               } else if (cause != null) {",
      "465:               } else {",
      "466:                 return CompletableFuture.completedFuture(result);",
      "467:               }",
      "",
      "[Removed Lines]",
      "461:                   return completeExceptionally(cause);",
      "464:                 return completeExceptionally(cause);",
      "",
      "[Added Lines]",
      "495:                   return this.<Throwable, LookupResult>completeExceptionally(cause);",
      "498:                 return this.<Throwable, LookupResult>completeExceptionally(cause);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "472:   private CompletionStage<LookupResult> lookupWithCache(Record queryRecord, List<Name> aliases) {",
      "473:     return Optional.ofNullable(caches.get(queryRecord.getDClass()))",
      "475:         .map(setResponse -> setResponseToMessageFuture(setResponse, queryRecord, aliases))",
      "476:         .orElseGet(() -> lookupWithResolver(queryRecord, aliases));",
      "477:   }",
      "479:   private CompletionStage<LookupResult> lookupWithResolver(Record queryRecord, List<Name> aliases) {",
      "480:     return resolver",
      "482:         .thenApply(this::maybeAddToCache)",
      "483:         .thenApply(answer -> buildResult(answer, aliases, queryRecord));",
      "484:   }",
      "",
      "[Removed Lines]",
      "474:         .map(c -> c.lookupRecords(queryRecord.getName(), queryRecord.getType(), Credibility.NORMAL))",
      "481:         .sendAsync(Message.newQuery(queryRecord), executor)",
      "",
      "[Added Lines]",
      "508:         .map(",
      "509:             c -> {",
      "510:               log.debug(",
      "511:                   \"Looking for <{}/{}/{}> in cache\",",
      "512:                   queryRecord.getName(),",
      "513:                   Type.string(queryRecord.getType()),",
      "514:                   DClass.string(queryRecord.getDClass()));",
      "515:               return c.lookupRecords(",
      "516:                   queryRecord.getName(), queryRecord.getType(), Credibility.NORMAL);",
      "517:             })",
      "523:     Message query = Message.newQuery(queryRecord);",
      "524:     log.debug(",
      "525:         \"Asking {} for <{}/{}/{}>\",",
      "526:         resolver,",
      "527:         queryRecord.getName(),",
      "528:         Type.string(queryRecord.getType()),",
      "529:         DClass.string(queryRecord.getDClass()));",
      "531:         .sendAsync(query, executor)",
      "532:         .thenCompose(",
      "533:             m -> {",
      "534:               try {",
      "535:                 Message normalized =",
      "536:                     m.normalize(query, irrelevantRecordMode == IrrelevantRecordMode.THROW);",
      "538:                 log.trace(",
      "539:                     \"Normalized response for <{}/{}/{}> from \\n{}\\ninto\\n{}\",",
      "540:                     queryRecord.getName(),",
      "541:                     Type.string(queryRecord.getType()),",
      "542:                     DClass.string(queryRecord.getDClass()),",
      "543:                     m,",
      "544:                     normalized);",
      "545:                 if (normalized == null) {",
      "546:                   return completeExceptionally(",
      "547:                       new InvalidZoneDataException(\"Failed to normalize message\"));",
      "548:                 }",
      "549:                 return CompletableFuture.completedFuture(normalized);",
      "550:               } catch (WireParseException e) {",
      "551:                 return completeExceptionally(",
      "552:                     new LookupFailedException(",
      "553:                         \"Message normalization failed, refusing to return it\", e));",
      "554:               }",
      "555:             })",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "494:     return message;",
      "495:   }",
      "497:   private CompletionStage<LookupResult> setResponseToMessageFuture(",
      "498:       SetResponse setResponse, Record queryRecord, List<Name> aliases) {",
      "499:     if (setResponse.isNXDOMAIN()) {",
      "500:       return completeExceptionally(",
      "501:           new NoSuchDomainException(queryRecord.getName(), queryRecord.getType()));",
      "502:     }",
      "503:     if (setResponse.isNXRRSET()) {",
      "504:       return completeExceptionally(",
      "505:           new NoSuchRRSetException(queryRecord.getName(), queryRecord.getType()));",
      "506:     }",
      "507:     if (setResponse.isSuccessful()) {",
      "508:       List<Record> records =",
      "509:           setResponse.answers().stream()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "571:   @SuppressWarnings(\"deprecated\")",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "511:               .collect(Collectors.toList());",
      "512:       return CompletableFuture.completedFuture(new LookupResult(records, aliases));",
      "513:     }",
      "514:     return null;",
      "515:   }",
      "519:     future.completeExceptionally(failure);",
      "520:     return future;",
      "521:   }",
      "523:   private CompletionStage<LookupResult> resolveRedirects(LookupResult response, Record query) {",
      "525:   }",
      "527:   private CompletionStage<LookupResult> maybeFollowRedirect(",
      "",
      "[Removed Lines]",
      "517:   private <T extends Throwable> CompletionStage<LookupResult> completeExceptionally(T failure) {",
      "518:     CompletableFuture<LookupResult> future = new CompletableFuture<>();",
      "524:     return maybeFollowRedirect(response, query, 1);",
      "",
      "[Added Lines]",
      "595:   private <T extends Throwable, R> CompletionStage<R> completeExceptionally(T failure) {",
      "596:     CompletableFuture<R> future = new CompletableFuture<>();",
      "602:     return maybeFollowRedirect(response, query, 0);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "540:     }",
      "541:   }",
      "543:   private CompletionStage<LookupResult> maybeFollowRedirectsInAnswer(",
      "544:       LookupResult response, Record query, int redirectCount) {",
      "545:     List<Name> aliases = new ArrayList<>(response.getAliases());",
      "546:     List<Record> results = new ArrayList<>();",
      "547:     Name current = query.getName();",
      "548:     for (Record r : response.getRecords()) {",
      "550:         throw new RedirectOverflowException(maxRedirects);",
      "551:       }",
      "",
      "[Removed Lines]",
      "549:       if (redirectCount > maxRedirects) {",
      "",
      "[Added Lines]",
      "621:   @SuppressWarnings(\"deprecated\")",
      "630:       if (aliases.contains(current)) {",
      "631:         return completeExceptionally(new RedirectLoopException(maxRedirects));",
      "632:       }",
      "634:       if (redirectCount >= maxRedirects) {",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "576:       return CompletableFuture.completedFuture(new LookupResult(results, aliases));",
      "577:     }",
      "580:       throw new RedirectOverflowException(maxRedirects);",
      "581:     }",
      "584:     Record redirectQuery = Record.newRecord(current, query.getType(), query.getDClass());",
      "585:     return lookupWithCache(redirectQuery, aliases)",
      "586:         .thenCompose(",
      "",
      "[Removed Lines]",
      "579:     if (redirectCount > maxRedirects) {",
      "583:     int finalRedirectCount = redirectCount + 1;",
      "",
      "[Added Lines]",
      "666:     if (aliases.contains(current)) {",
      "667:       return completeExceptionally(new RedirectLoopException(maxRedirects));",
      "668:     }",
      "670:     if (redirectCount >= maxRedirects) {",
      "674:     int finalRedirectCount = redirectCount;",
      "",
      "---------------"
    ],
    "src/main/java/org/xbill/DNS/lookup/NoSuchDomainException.java||src/main/java/org/xbill/DNS/lookup/NoSuchDomainException.java": [
      "File: src/main/java/org/xbill/DNS/lookup/NoSuchDomainException.java -> src/main/java/org/xbill/DNS/lookup/NoSuchDomainException.java"
    ],
    "src/main/java/org/xbill/DNS/lookup/NoSuchRRSetException.java||src/main/java/org/xbill/DNS/lookup/NoSuchRRSetException.java": [
      "File: src/main/java/org/xbill/DNS/lookup/NoSuchRRSetException.java -> src/main/java/org/xbill/DNS/lookup/NoSuchRRSetException.java"
    ],
    "src/main/java/org/xbill/DNS/lookup/RedirectOverflowException.java||src/main/java/org/xbill/DNS/lookup/RedirectOverflowException.java": [
      "File: src/main/java/org/xbill/DNS/lookup/RedirectOverflowException.java -> src/main/java/org/xbill/DNS/lookup/RedirectOverflowException.java"
    ],
    "src/test/java/org/xbill/DNS/LookupTest.java||src/test/java/org/xbill/DNS/LookupTest.java": [
      "File: src/test/java/org/xbill/DNS/LookupTest.java -> src/test/java/org/xbill/DNS/LookupTest.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "445:       if (DUMMY_NAME.equals(response.getName())) {",
      "446:         response = response.withName(query.getQuestion().getName());",
      "447:       }",
      "448:       answer.addRecord(response, Section.ANSWER);",
      "449:     }",
      "450:     return answer;",
      "451:   }",
      "452: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "448:       response.setTTL(120);",
      "454:   public static Message multiAnswer(Message query, Function<Name, Record[]> recordMaker) {",
      "455:     Message answer = new Message(query.getHeader().getID());",
      "456:     answer.addRecord(query.getQuestion(), Section.QUESTION);",
      "457:     Name questionName = query.getQuestion().getName();",
      "458:     Record[] response = recordMaker.apply(questionName);",
      "459:     if (response == null) {",
      "460:       answer.getHeader().setRcode(Rcode.NXDOMAIN);",
      "461:     } else {",
      "462:       for (Record r : response) {",
      "463:         if (DUMMY_NAME.equals(r.getName())) {",
      "464:           r = r.withName(query.getQuestion().getName());",
      "465:         }",
      "466:         r.setTTL(120);",
      "467:         answer.addRecord(r, Section.ANSWER);",
      "468:       }",
      "469:     }",
      "470:     return answer;",
      "471:   }",
      "",
      "---------------"
    ],
    "src/test/java/org/xbill/DNS/MessageTest.java||src/test/java/org/xbill/DNS/MessageTest.java": [
      "File: src/test/java/org/xbill/DNS/MessageTest.java -> src/test/java/org/xbill/DNS/MessageTest.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "53:     Message m = new Message();",
      "54:     assertTrue(m.getSection(0).isEmpty());",
      "55:     assertTrue(m.getSection(1).isEmpty());",
      "57:     assertTrue(m.getSection(2).isEmpty());",
      "59:     Header h = m.getHeader();",
      "60:     assertEquals(0, h.getCount(0));",
      "61:     assertEquals(0, h.getCount(1));",
      "",
      "[Removed Lines]",
      "56:     assertTrue(m.getSection(3).isEmpty());",
      "58:     assertThrows(IndexOutOfBoundsException.class, () -> m.getSection(4));",
      "",
      "[Added Lines]",
      "57:     assertTrue(m.getSection(3).isEmpty());",
      "58:     assertThrows(IllegalArgumentException.class, () -> m.getSection(4));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "71:     assertTrue(m.getSection(1).isEmpty());",
      "72:     assertTrue(m.getSection(2).isEmpty());",
      "73:     assertTrue(m.getSection(3).isEmpty());",
      "75:     Header h = m.getHeader();",
      "76:     assertEquals(0, h.getCount(0));",
      "77:     assertEquals(0, h.getCount(1));",
      "",
      "[Removed Lines]",
      "74:     assertThrows(IndexOutOfBoundsException.class, () -> m.getSection(4));",
      "",
      "[Added Lines]",
      "74:     assertThrows(IllegalArgumentException.class, () -> m.getSection(4));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "167:     assertEquals(clone.getQuestion(), response.getQuestion());",
      "168:     assertEquals(clone.getSection(Section.ANSWER), response.getSection(Section.ANSWER));",
      "169:   }",
      "170: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "171:   @Test",
      "172:   void normalize() throws WireParseException {",
      "173:     Record queryRecord =",
      "174:         Record.newRecord(Name.fromConstantString(\"example.com.\"), Type.MX, DClass.IN);",
      "175:     Message query = Message.newQuery(queryRecord);",
      "176:     Message response = new Message();",
      "177:     response.addRecord(queryRecord, Section.QUESTION);",
      "178:     response.addRecord(queryRecord, Section.ADDITIONAL);",
      "179:     response = response.normalize(query, true);",
      "180:     assertTrue(response.getSection(Section.ANSWER).isEmpty());",
      "181:     assertTrue(response.getSection(Section.ADDITIONAL).isEmpty());",
      "182:   }",
      "",
      "---------------"
    ],
    "src/test/java/org/xbill/DNS/SetResponseTest.java||src/test/java/org/xbill/DNS/SetResponseTest.java": [
      "File: src/test/java/org/xbill/DNS/SetResponseTest.java -> src/test/java/org/xbill/DNS/SetResponseTest.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "46: import java.net.UnknownHostException;",
      "47: import org.junit.jupiter.api.Test;",
      "48: import org.junit.jupiter.params.ParameterizedTest;",
      "49: import org.junit.jupiter.params.provider.EnumSource;",
      "51: class SetResponseTest {",
      "52:   private static final ARecord A_RECORD_1 =",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "49: import org.junit.jupiter.params.provider.CsvSource;",
      "51: import org.junit.jupiter.params.provider.ValueSource;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "129:     assertArrayEquals(exp, sr.answers().toArray());",
      "130:   }",
      "132:   @Test",
      "133:   void addRRset_multiple() throws TextParseException, UnknownHostException {",
      "134:     RRset rrs = new RRset();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "134:   @ParameterizedTest",
      "135:   @ValueSource(booleans = {false, true})",
      "136:   void ofTypeWithCachedRRset(boolean isAuthenticated) {",
      "137:     SetResponse sr =",
      "138:         SetResponse.ofType(",
      "139:             SetResponseType.SUCCESSFUL,",
      "140:             new Cache.CacheRRset(new RRset(A_RECORD_1), 0, 0, isAuthenticated));",
      "141:     assertEquals(isAuthenticated, sr.isAuthenticated());",
      "142:   }",
      "144:   @ParameterizedTest",
      "145:   @CsvSource({",
      "146:     \"false,true,true,true,true\",",
      "147:     \"false,false,true,false,false\",",
      "148:     \"true,true,false,true,false\",",
      "149:     \"true,false,false,false,false\",",
      "150:   })",
      "151:   void addRRsetAuthenticated(",
      "152:       boolean addInitial,",
      "153:       boolean first,",
      "154:       boolean second,",
      "155:       boolean firstResult,",
      "156:       boolean secondResult) {",
      "157:     RRset rrs = new RRset(A_RECORD_1);",
      "158:     SetResponse sr;",
      "159:     if (addInitial) {",
      "160:       sr = SetResponse.ofType(SetResponseType.SUCCESSFUL, rrs, first);",
      "161:     } else {",
      "162:       sr = SetResponse.ofType(SetResponseType.SUCCESSFUL);",
      "163:       sr.addRRset(new Cache.CacheRRset(rrs, 0, 0, first));",
      "164:     }",
      "166:     RRset[] exp = new RRset[] {rrs};",
      "167:     assertArrayEquals(exp, sr.answers().toArray());",
      "168:     assertEquals(firstResult, sr.isAuthenticated());",
      "170:     sr.addRRset(new Cache.CacheRRset(new RRset(A_RECORD_1), 0, 0, second));",
      "171:     assertEquals(secondResult, sr.isAuthenticated());",
      "172:     assertEquals(2, sr.answers().size());",
      "173:   }",
      "",
      "---------------"
    ],
    "src/test/java/org/xbill/DNS/dnssec/Rpl.java||src/test/java/org/xbill/DNS/dnssec/Rpl.java": [
      "File: src/test/java/org/xbill/DNS/dnssec/Rpl.java -> src/test/java/org/xbill/DNS/dnssec/Rpl.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "17:   TreeMap<Integer, Integer> nsec3iterations;",
      "18:   String digestPreference;",
      "19:   boolean hardenAlgoDowngrade;",
      "20:   boolean enableSha1;",
      "21:   boolean enableDsa;",
      "22:   boolean loadBouncyCastle;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "20:   boolean hardenUnknownAdditional = true;",
      "",
      "---------------"
    ],
    "src/test/java/org/xbill/DNS/dnssec/RplParser.java||src/test/java/org/xbill/DNS/dnssec/RplParser.java": [
      "File: src/test/java/org/xbill/DNS/dnssec/RplParser.java -> src/test/java/org/xbill/DNS/dnssec/RplParser.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "73:           if (line.startsWith(\"server:\")) {",
      "74:             state = ParseState.Server;",
      "75:           } else if (line.startsWith(\"SCENARIO_BEGIN\")) {",
      "77:             rpl.replays = new LinkedList<>();",
      "78:             rpl.checks = new TreeMap<>();",
      "79:           } else if (line.startsWith(\"ENTRY_BEGIN\")) {",
      "",
      "[Removed Lines]",
      "76:             rpl.scenario = line.substring(line.indexOf(\" \"));",
      "",
      "[Added Lines]",
      "76:             rpl.scenario = line.substring(line.indexOf(\" \")).trim();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "128:             rpl.enableSha1 = \"yes\".equalsIgnoreCase(line.split(\":\")[1].trim());",
      "129:           } else if (line.matches(\"\\\\s*fake-dsa:.*\")) {",
      "130:             rpl.enableDsa = \"yes\".equalsIgnoreCase(line.split(\":\")[1].trim());",
      "131:           } else if (line.matches(\"\\\\s*bouncycastle:.*\")) {",
      "132:             rpl.loadBouncyCastle = \"yes\".equalsIgnoreCase(line.split(\":\")[1].trim());",
      "133:           } else if (line.startsWith(\"CONFIG_END\")) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "131:           } else if (line.matches(\"\\\\s*harden-unknown-additional:.*\")) {",
      "132:             rpl.hardenUnknownAdditional = \"yes\".equalsIgnoreCase(line.split(\":\")[1].trim());",
      "",
      "---------------"
    ],
    "src/test/java/org/xbill/DNS/dnssec/TestBase.java||src/test/java/org/xbill/DNS/dnssec/TestBase.java": [
      "File: src/test/java/org/xbill/DNS/dnssec/TestBase.java -> src/test/java/org/xbill/DNS/dnssec/TestBase.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "28: import java.util.concurrent.CompletionStage;",
      "29: import java.util.concurrent.ExecutionException;",
      "30: import java.util.concurrent.Executor;",
      "31: import org.junit.jupiter.api.AfterEach;",
      "32: import org.junit.jupiter.api.BeforeAll;",
      "33: import org.junit.jupiter.api.BeforeEach;",
      "34: import org.junit.jupiter.api.TestInfo;",
      "37: import org.xbill.DNS.ARecord;",
      "38: import org.xbill.DNS.DClass;",
      "39: import org.xbill.DNS.DNSSEC.DNSSECException;",
      "",
      "[Removed Lines]",
      "35: import org.slf4j.Logger;",
      "36: import org.slf4j.LoggerFactory;",
      "",
      "[Added Lines]",
      "31: import lombok.extern.slf4j.Slf4j;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "49: import org.xbill.DNS.TXTRecord;",
      "50: import org.xbill.DNS.Type;",
      "52: public abstract class TestBase {",
      "55:   private static final boolean offline = !Boolean.getBoolean(\"dnsjava.dnssec.online\");",
      "56:   private static final boolean partialOffline =",
      "57:       \"partial\".equals(System.getProperty(\"dnsjava.dnssec.offline\"));",
      "",
      "[Removed Lines]",
      "53:   private static final Logger logger = LoggerFactory.getLogger(TestBase.class);",
      "",
      "[Added Lines]",
      "51: @Slf4j",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "127:           Message m;",
      "128:           while ((m = messageReader.readMessage(r)) != null) {",
      "129:             queryResponsePairs.put(key(m), m);",
      "130:           }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "127:             m = m.normalize(Message.newQuery(m.getQuestion()), true);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "163:             new SimpleResolver(\"8.8.4.4\") {",
      "164:               @Override",
      "165:               public CompletionStage<Message> sendAsync(Message query, Executor executor) {",
      "167:                 Message response = queryResponsePairs.get(key(query));",
      "168:                 if (response != null) {",
      "169:                   return CompletableFuture.completedFuture(response);",
      "170:                 } else if ((offline && !partialOffline) || unboundTest || alwaysOffline) {",
      "171:                   fail(\"Response for \" + key(query) + \" not found.\");",
      "",
      "[Removed Lines]",
      "166:                 logger.info(\"---{}\", key(query));",
      "",
      "[Added Lines]",
      "167:                   if (!log.isTraceEnabled()) {",
      "168:                     log.debug(\"---{}\", key(query));",
      "169:                   }",
      "171:                   log.trace(\"---{}\\n{}\", key(query), response);",
      "",
      "---------------"
    ],
    "src/test/java/org/xbill/DNS/dnssec/UnboundTests.java||src/test/java/org/xbill/DNS/dnssec/UnboundTests.java": [
      "File: src/test/java/org/xbill/DNS/dnssec/UnboundTests.java -> src/test/java/org/xbill/DNS/dnssec/UnboundTests.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "5: import static org.mockito.Mockito.when;",
      "7: import java.io.File;",
      "8: import java.io.IOException;",
      "9: import java.io.InputStream;",
      "10: import java.security.Security;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "8: import java.io.FileInputStream;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "15: import java.util.Map;",
      "16: import java.util.Map.Entry;",
      "17: import java.util.Properties;",
      "18: import org.bouncycastle.jce.provider.BouncyCastleProvider;",
      "19: import org.junit.jupiter.api.Disabled;",
      "20: import org.junit.jupiter.api.Test;",
      "21: import org.xbill.DNS.CNAMERecord;",
      "22: import org.xbill.DNS.DNAMERecord;",
      "23: import org.xbill.DNS.DNSSEC;",
      "24: import org.xbill.DNS.Flags;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "19: import lombok.extern.slf4j.Slf4j;",
      "22: import org.junit.jupiter.api.DisplayName;",
      "25: import org.xbill.DNS.DClass;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "31: import org.xbill.DNS.Section;",
      "32: import org.xbill.DNS.Type;",
      "34: class UnboundTests extends TestBase {",
      "35:   void runUnboundTest() throws ParseException, IOException {",
      "43:       }",
      "88:           }",
      "98:             }",
      "104:           }",
      "105:         }",
      "106:       }",
      "126:         }",
      "127:       }",
      "140:       }",
      "147:       }",
      "154:       Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);",
      "161:     }",
      "162:   }",
      "",
      "[Removed Lines]",
      "36:     InputStream data = getClass().getResourceAsStream(\"/unbound/\" + testName + \".rpl\");",
      "37:     RplParser p = new RplParser(data);",
      "38:     Rpl rpl = p.parse();",
      "39:     Properties config = new Properties();",
      "40:     if (rpl.nsec3iterations != null) {",
      "41:       for (Entry<Integer, Integer> e : rpl.nsec3iterations.entrySet()) {",
      "42:         config.put(\"dnsjava.dnssec.nsec3.iterations.\" + e.getKey(), e.getValue());",
      "44:     }",
      "46:     if (rpl.digestPreference != null) {",
      "47:       config.put(ValUtils.DIGEST_PREFERENCE, rpl.digestPreference);",
      "48:     }",
      "50:     config.put(ValUtils.DIGEST_HARDEN_DOWNGRADE, Boolean.toString(rpl.hardenAlgoDowngrade));",
      "52:     if (rpl.enableSha1) {",
      "53:       config.put(ValUtils.DIGEST_ENABLED + \".\" + DNSSEC.Digest.SHA1, Boolean.TRUE.toString());",
      "54:     }",
      "56:     if (rpl.enableDsa || rpl.enableSha1) {",
      "57:       config.put(ValUtils.ALGORITHM_ENABLED + \".\" + DNSSEC.Algorithm.DSA, Boolean.TRUE.toString());",
      "58:       config.put(",
      "59:           ValUtils.ALGORITHM_ENABLED + \".\" + DNSSEC.Algorithm.DSA_NSEC3_SHA1,",
      "60:           Boolean.TRUE.toString());",
      "61:     }",
      "63:     if (rpl.loadBouncyCastle) {",
      "64:       Security.addProvider(new BouncyCastleProvider());",
      "65:     }",
      "67:     for (Message m : rpl.replays) {",
      "68:       add(m);",
      "69:     }",
      "72:     List<Message> copy = new ArrayList<>(rpl.replays.size());",
      "73:     copy.addAll(rpl.replays);",
      "74:     List<Name> copiedTargets = new ArrayList<>(5);",
      "75:     for (Message m : copy) {",
      "76:       Name target = null;",
      "77:       for (RRset s : m.getSectionRRsets(Section.ANSWER)) {",
      "78:         if (s.getType() == Type.CNAME) {",
      "79:           target = ((CNAMERecord) s.first()).getTarget();",
      "80:         } else if (s.getType() == Type.DNAME) {",
      "81:           target = ((DNAMERecord) s.first()).getTarget();",
      "82:         }",
      "84:         while (target != null) {",
      "85:           Message a = get(target, m.getQuestion().getType());",
      "86:           if (a == null) {",
      "87:             a = get(target, Type.CNAME);",
      "90:           if (a == null) {",
      "91:             a = get(target, Type.DNAME);",
      "92:           }",
      "94:           if (a != null) {",
      "95:             target = add(m, a);",
      "96:             if (copiedTargets.contains(target)) {",
      "97:               break;",
      "100:             copiedTargets.add(target);",
      "101:             rpl.replays.remove(a);",
      "102:           } else {",
      "103:             target = null;",
      "107:     }",
      "110:     copy = new ArrayList<>(rpl.replays.size());",
      "111:     copy.addAll(rpl.replays);",
      "112:     for (Message m : copy) {",
      "113:       for (RRset s : m.getSectionRRsets(Section.AUTHORITY)) {",
      "114:         if (s.getType() == Type.DS) {",
      "115:           Message ds = new Message();",
      "116:           ds.addRecord(Record.newRecord(s.getName(), s.getType(), s.getDClass()), Section.QUESTION);",
      "117:           for (Record rr : s.rrs()) {",
      "118:             ds.addRecord(rr, Section.ANSWER);",
      "119:           }",
      "121:           for (RRSIGRecord sig : s.sigs()) {",
      "122:             ds.addRecord(sig, Section.ANSWER);",
      "123:           }",
      "125:           rpl.replays.add(ds);",
      "128:     }",
      "130:     clear();",
      "131:     for (Message m : rpl.replays) {",
      "132:       add(m);",
      "133:     }",
      "135:     if (rpl.date != null) {",
      "136:       try {",
      "137:         when(resolverClock.instant()).thenReturn(rpl.date);",
      "138:       } catch (Exception e) {",
      "139:         throw new RuntimeException(e);",
      "141:     }",
      "143:     if (rpl.trustAnchors != null) {",
      "144:       resolver.getTrustAnchors().clear();",
      "145:       for (SRRset rrset : rpl.trustAnchors) {",
      "146:         resolver.getTrustAnchors().store(rrset);",
      "148:     }",
      "150:     resolver.init(config);",
      "152:     for (Check c : rpl.checks.values()) {",
      "153:       Message s = resolver.send(c.query);",
      "155:       assertEquals(",
      "156:           c.response.getHeader().getFlag(Flags.AD),",
      "157:           s.getHeader().getFlag(Flags.AD),",
      "158:           \"AD Flag must match\");",
      "159:       assertEquals(",
      "160:           Rcode.string(c.response.getRcode()), Rcode.string(s.getRcode()), \"RCode must match\");",
      "",
      "[Added Lines]",
      "38: @Slf4j",
      "41:     try {",
      "42:       InputStream data = getClass().getResourceAsStream(\"/unbound/\" + testName + \".rpl\");",
      "43:       RplParser p = new RplParser(data);",
      "44:       Rpl rpl = p.parse();",
      "45:       Properties config = new Properties();",
      "46:       if (rpl.nsec3iterations != null) {",
      "47:         for (Entry<Integer, Integer> e : rpl.nsec3iterations.entrySet()) {",
      "48:           config.put(\"dnsjava.dnssec.nsec3.iterations.\" + e.getKey(), e.getValue());",
      "49:         }",
      "52:       if (rpl.digestPreference != null) {",
      "53:         config.put(ValUtils.DIGEST_PREFERENCE, rpl.digestPreference);",
      "54:       }",
      "56:       config.put(ValUtils.DIGEST_HARDEN_DOWNGRADE, Boolean.toString(rpl.hardenAlgoDowngrade));",
      "58:       if (rpl.enableSha1) {",
      "59:         config.put(ValUtils.DIGEST_ENABLED + \".\" + DNSSEC.Digest.SHA1, Boolean.TRUE.toString());",
      "60:       }",
      "62:       if (rpl.enableDsa || rpl.enableSha1) {",
      "63:         config.put(",
      "64:             ValUtils.ALGORITHM_ENABLED + \".\" + DNSSEC.Algorithm.DSA, Boolean.TRUE.toString());",
      "65:         config.put(",
      "66:             ValUtils.ALGORITHM_ENABLED + \".\" + DNSSEC.Algorithm.DSA_NSEC3_SHA1,",
      "67:             Boolean.TRUE.toString());",
      "68:       }",
      "70:       if (!rpl.hardenUnknownAdditional) {",
      "71:         System.setProperty(\"dnsjava.harden_unknown_additional\", Boolean.TRUE.toString());",
      "72:       }",
      "74:       if (rpl.loadBouncyCastle) {",
      "75:         Security.addProvider(new BouncyCastleProvider());",
      "76:       }",
      "78:       for (Message m : rpl.replays) {",
      "79:         add(m);",
      "80:       }",
      "83:       List<Message> copy = new ArrayList<>(rpl.replays.size());",
      "84:       copy.addAll(rpl.replays);",
      "85:       List<Name> copiedTargets = new ArrayList<>(5);",
      "86:       for (Message m : copy) {",
      "87:         Name target = null;",
      "88:         for (RRset s : m.getSectionRRsets(Section.ANSWER)) {",
      "89:           if (s.getType() == Type.CNAME) {",
      "90:             target = ((CNAMERecord) s.first()).getTarget();",
      "91:           } else if (s.getType() == Type.DNAME) {",
      "92:             target = ((DNAMERecord) s.first()).getTarget();",
      "95:           while (target != null) {",
      "96:             Message a = get(target, m.getQuestion().getType());",
      "97:             if (a == null) {",
      "98:               a = get(target, Type.CNAME);",
      "99:             }",
      "101:             if (a == null) {",
      "102:               a = get(target, Type.DNAME);",
      "105:             if (a != null) {",
      "106:               target = add(m, a);",
      "107:               if (copiedTargets.contains(target)) {",
      "108:                 break;",
      "109:               }",
      "111:               copiedTargets.add(target);",
      "112:               rpl.replays.remove(a);",
      "113:             } else {",
      "114:               target = null;",
      "115:             }",
      "121:       copy = new ArrayList<>(rpl.replays.size());",
      "122:       copy.addAll(rpl.replays);",
      "123:       for (Message m : copy) {",
      "124:         for (RRset s : m.getSectionRRsets(Section.AUTHORITY)) {",
      "125:           if (s.getType() == Type.DS) {",
      "126:             Message ds = new Message();",
      "127:             ds.addRecord(",
      "128:                 Record.newRecord(s.getName(), s.getType(), s.getDClass()), Section.QUESTION);",
      "129:             for (Record rr : s.rrs()) {",
      "130:               ds.addRecord(rr, Section.ANSWER);",
      "131:             }",
      "133:             for (RRSIGRecord sig : s.sigs()) {",
      "134:               ds.addRecord(sig, Section.ANSWER);",
      "135:             }",
      "137:             rpl.replays.add(ds);",
      "138:           }",
      "142:       clear();",
      "143:       for (Message m : rpl.replays) {",
      "144:         add(m);",
      "147:       if (rpl.date != null) {",
      "148:         try {",
      "149:           when(resolverClock.instant()).thenReturn(rpl.date);",
      "150:         } catch (Exception e) {",
      "151:           throw new RuntimeException(e);",
      "152:         }",
      "155:       if (rpl.trustAnchors != null) {",
      "156:         resolver.getTrustAnchors().clear();",
      "157:         for (SRRset rrset : rpl.trustAnchors) {",
      "158:           resolver.getTrustAnchors().store(rrset);",
      "159:         }",
      "160:       }",
      "162:       resolver.init(config);",
      "164:       for (Check c : rpl.checks.values()) {",
      "165:         Message s = resolver.send(c.query).normalize(c.query, true);",
      "166:         log.trace(",
      "167:             \"{}/{}/{} ---> \\n{}\",",
      "168:             c.query.getQuestion().getName(),",
      "169:             Type.string(c.query.getQuestion().getType()),",
      "170:             DClass.string(c.query.getQuestion().getDClass()),",
      "171:             s);",
      "172:         assertEquals(",
      "173:             c.response.getHeader().getFlag(Flags.AD),",
      "174:             s.getHeader().getFlag(Flags.AD),",
      "175:             \"AD Flag must match\");",
      "176:         assertEquals(",
      "177:             Rcode.string(c.response.getRcode()), Rcode.string(s.getRcode()), \"RCode must match\");",
      "178:       }",
      "179:     } finally {",
      "181:       System.clearProperty(\"dnsjava.harden_unknown_additional\");",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "182:     return next;",
      "183:   }",
      "186:     Map<String, String> ignored =",
      "187:         new HashMap<String, String>() {",
      "188:           {",
      "",
      "[Removed Lines]",
      "185:   static void xmain(String[] xargs) {",
      "",
      "[Added Lines]",
      "206:   static void main(String[] xargs) throws IOException, ParseException {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "207:             put(\"val_cnametoinsecure.rpl\", \"incomplete CNAME answer\");",
      "208:             put(\"val_nsec3_optout_cache.rpl\", \"more cache stuff\");",
      "209:             put(\"val_unsecds_qtypeds.rpl\", \"tests the iterative resolver\");",
      "212:             put(\"val_negcache_nta.rpl\", \"tests unbound option domain-insecure, not available here\");",
      "213:           }",
      "214:         };",
      "",
      "[Removed Lines]",
      "210:             put(\"val_anchor_nx.rpl\", \"tests caching of NX from a parent resolver\");",
      "211:             put(\"val_anchor_nx_nosig.rpl\", \"tests caching of NX from a parent resolver\");",
      "",
      "[Added Lines]",
      "231:             put(",
      "232:                 \"val_anchor_nx.rpl\",",
      "233:                 \"tests resolving conflicting responses in a recursive resolver\");",
      "234:             put(",
      "235:                 \"val_anchor_nx_nosig.rpl\",",
      "236:                 \"tests resolving conflicting responses in a recursive resolver\");",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "219:         System.out.println(\"    @Disabled(\\\"\" + comment + \"\\\")\");",
      "220:       }",
      "222:       System.out.println(\"    @Test\");",
      "223:       System.out.println(",
      "224:           \"    void \" + f.split(\"\\\\.\")[0] + \"() throws ParseException, IOException {\");",
      "225:       System.out.println(\"        runUnboundTest();\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "247:       Rpl rpl = new RplParser(new FileInputStream(\"./src/test/resources/unbound/\" + f)).parse();",
      "249:       System.out.println(\"    @DisplayName(\\\"\" + f + \": \" + rpl.scenario + \"\\\")\");",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "229:   }",
      "231:   @Test",
      "232:   void val_adbit() throws ParseException, IOException {",
      "233:     runUnboundTest();",
      "234:   }",
      "236:   @Test",
      "237:   void val_adcopy() throws ParseException, IOException {",
      "238:     runUnboundTest();",
      "239:   }",
      "242:   @Test",
      "243:   void val_anchor_nx() throws ParseException, IOException {",
      "244:     runUnboundTest();",
      "245:   }",
      "248:   @Test",
      "249:   void val_anchor_nx_nosig() throws ParseException, IOException {",
      "250:     runUnboundTest();",
      "251:   }",
      "253:   @Test",
      "254:   void val_ans_dsent() throws ParseException, IOException {",
      "255:     runUnboundTest();",
      "256:   }",
      "258:   @Test",
      "259:   void val_ans_nx() throws ParseException, IOException {",
      "260:     runUnboundTest();",
      "261:   }",
      "263:   @Test",
      "264:   void val_any() throws ParseException, IOException {",
      "265:     runUnboundTest();",
      "266:   }",
      "268:   @Test",
      "269:   void val_any_cname() throws ParseException, IOException {",
      "270:     runUnboundTest();",
      "271:   }",
      "273:   @Test",
      "274:   void val_any_dname() throws ParseException, IOException {",
      "275:     runUnboundTest();",
      "276:   }",
      "278:   @Test",
      "279:   void val_cnameinsectopos() throws ParseException, IOException {",
      "280:     runUnboundTest();",
      "281:   }",
      "283:   @Test",
      "284:   void val_cnamenx_dblnsec() throws ParseException, IOException {",
      "285:     runUnboundTest();",
      "286:   }",
      "288:   @Test",
      "289:   void val_cnamenx_rcodenx() throws ParseException, IOException {",
      "290:     runUnboundTest();",
      "291:   }",
      "293:   @Test",
      "294:   void val_cnameqtype() throws ParseException, IOException {",
      "295:     runUnboundTest();",
      "296:   }",
      "298:   @Test",
      "299:   void val_cnametocloser() throws ParseException, IOException {",
      "300:     runUnboundTest();",
      "301:   }",
      "303:   @Test",
      "304:   void val_cnametocloser_nosig() throws ParseException, IOException {",
      "305:     runUnboundTest();",
      "306:   }",
      "308:   @Test",
      "309:   void val_cnametocnamewctoposwc() throws ParseException, IOException {",
      "310:     runUnboundTest();",
      "311:   }",
      "313:   @Test",
      "314:   void val_cnametodname() throws ParseException, IOException {",
      "315:     runUnboundTest();",
      "316:   }",
      "318:   @Test",
      "319:   void val_cnametodnametocnametopos() throws ParseException, IOException {",
      "320:     runUnboundTest();",
      "321:   }",
      "323:   @Disabled(\"incomplete CNAME answer\")",
      "324:   @Test",
      "325:   void val_cnametoinsecure() throws ParseException, IOException {",
      "326:     runUnboundTest();",
      "327:   }",
      "329:   @Test",
      "330:   void val_cnametonodata() throws ParseException, IOException {",
      "331:     runUnboundTest();",
      "332:   }",
      "334:   @Test",
      "335:   void val_cnametonodata_nonsec() throws ParseException, IOException {",
      "336:     runUnboundTest();",
      "337:   }",
      "339:   @Disabled(\"incomplete CNAME answer\")",
      "340:   @Test",
      "341:   void val_cnametonsec() throws ParseException, IOException {",
      "342:     runUnboundTest();",
      "343:   }",
      "345:   @Test",
      "346:   void val_cnametonx() throws ParseException, IOException {",
      "347:     runUnboundTest();",
      "348:   }",
      "350:   @Disabled(\"incomplete CNAME answer\")",
      "351:   @Test",
      "352:   void val_cnametooptin() throws ParseException, IOException {",
      "353:     runUnboundTest();",
      "354:   }",
      "356:   @Test",
      "357:   void val_cnametooptout() throws ParseException, IOException {",
      "358:     runUnboundTest();",
      "359:   }",
      "361:   @Test",
      "362:   void val_cnametopos() throws ParseException, IOException {",
      "363:     runUnboundTest();",
      "364:   }",
      "366:   @Test",
      "367:   void val_cnametoposnowc() throws ParseException, IOException {",
      "368:     runUnboundTest();",
      "369:   }",
      "371:   @Test",
      "372:   void val_cnametoposwc() throws ParseException, IOException {",
      "373:     runUnboundTest();",
      "374:   }",
      "376:   @Test",
      "377:   void val_cnamewctonodata() throws ParseException, IOException {",
      "378:     runUnboundTest();",
      "379:   }",
      "381:   @Test",
      "382:   void val_cnamewctonx() throws ParseException, IOException {",
      "383:     runUnboundTest();",
      "384:   }",
      "386:   @Test",
      "387:   void val_cnamewctoposwc() throws ParseException, IOException {",
      "388:     runUnboundTest();",
      "389:   }",
      "391:   @Test",
      "392:   void val_cname_loop1() throws ParseException, IOException {",
      "393:     runUnboundTest();",
      "394:   }",
      "396:   @Test",
      "397:   void val_cname_loop2() throws ParseException, IOException {",
      "398:     runUnboundTest();",
      "399:   }",
      "401:   @Test",
      "402:   void val_cname_loop3() throws ParseException, IOException {",
      "403:     runUnboundTest();",
      "404:   }",
      "406:   @Test",
      "407:   void val_dnametoolong() throws ParseException, IOException {",
      "408:     runUnboundTest();",
      "409:   }",
      "411:   @Test",
      "412:   void val_dnametopos() throws ParseException, IOException {",
      "413:     runUnboundTest();",
      "414:   }",
      "416:   @Test",
      "417:   void val_dnametoposwc() throws ParseException, IOException {",
      "418:     runUnboundTest();",
      "419:   }",
      "421:   @Test",
      "422:   void val_dnamewc() throws ParseException, IOException {",
      "423:     runUnboundTest();",
      "424:   }",
      "426:   @Disabled(\"we don't do negative caching\")",
      "427:   @Test",
      "428:   void val_dsnsec() throws ParseException, IOException {",
      "429:     runUnboundTest();",
      "430:   }",
      "432:   @Test",
      "433:   void val_ds_afterprime() throws ParseException, IOException {",
      "434:     runUnboundTest();",
      "435:   }",
      "437:   @Test",
      "438:   void val_ds_cname() throws ParseException, IOException {",
      "439:     runUnboundTest();",
      "440:   }",
      "442:   @Test",
      "443:   void val_ds_cnamesub() throws ParseException, IOException {",
      "444:     runUnboundTest();",
      "445:   }",
      "447:   @Test",
      "448:   void val_ds_cnamesubbogus() throws ParseException, IOException {",
      "449:     runUnboundTest();",
      "450:   }",
      "452:   @Test",
      "453:   void val_ds_gost() throws ParseException, IOException {",
      "454:     runUnboundTest();",
      "455:   }",
      "457:   @Test",
      "458:   void val_ds_gost_downgrade() throws ParseException, IOException {",
      "459:     runUnboundTest();",
      "460:   }",
      "462:   @Test",
      "463:   void val_ds_sha2() throws ParseException, IOException {",
      "464:     runUnboundTest();",
      "465:   }",
      "467:   @Test",
      "468:   void val_ds_sha2_downgrade() throws ParseException, IOException {",
      "469:     runUnboundTest();",
      "470:   }",
      "472:   @Test",
      "473:   void val_ds_sha2_downgrade_override() throws ParseException, IOException {",
      "474:     runUnboundTest();",
      "475:   }",
      "477:   @Test",
      "478:   void val_ds_sha2_lenient() throws ParseException, IOException {",
      "479:     runUnboundTest();",
      "480:   }",
      "482:   @Test",
      "483:   void val_entds() throws ParseException, IOException {",
      "484:     runUnboundTest();",
      "485:   }",
      "487:   @Test",
      "488:   void val_faildnskey() throws ParseException, IOException {",
      "489:     runUnboundTest();",
      "490:   }",
      "492:   @Disabled(\"tests an unbound specific config option\")",
      "493:   @Test",
      "494:   void val_faildnskey_ok() throws ParseException, IOException {",
      "495:     runUnboundTest();",
      "496:   }",
      "498:   @Disabled(\"irrelevant, we're not a recursive resolver\")",
      "499:   @Test",
      "500:   void val_fwdds() throws ParseException, IOException {",
      "501:     runUnboundTest();",
      "502:   }",
      "504:   @Test",
      "505:   void val_keyprefetch() throws ParseException, IOException {",
      "506:     runUnboundTest();",
      "507:   }",
      "509:   @Test",
      "510:   void val_keyprefetch_verify() throws ParseException, IOException {",
      "511:     runUnboundTest();",
      "512:   }",
      "514:   @Test",
      "515:   void val_mal_wc() throws ParseException, IOException {",
      "516:     runUnboundTest();",
      "517:   }",
      "519:   @Test",
      "520:   void val_negcache_ds() throws ParseException, IOException {",
      "521:     runUnboundTest();",
      "522:   }",
      "524:   @Disabled(\"we don't do negative caching\")",
      "525:   @Test",
      "526:   void val_negcache_dssoa() throws ParseException, IOException {",
      "527:     runUnboundTest();",
      "528:   }",
      "530:   @Disabled(\"aggressive NSEC is not supported\")",
      "531:   @Test",
      "532:   void val_negcache_nodata() throws ParseException, IOException {",
      "533:     runUnboundTest();",
      "534:   }",
      "536:   @Disabled(\"tests unbound option domain-insecure, not available here\")",
      "537:   @Test",
      "538:   void val_negcache_nta() throws ParseException, IOException {",
      "539:     runUnboundTest();",
      "540:   }",
      "542:   @Disabled(\"aggressive NSEC is not supported\")",
      "543:   @Test",
      "544:   void val_negcache_nxdomain() throws ParseException, IOException {",
      "545:     runUnboundTest();",
      "546:   }",
      "548:   @Disabled(\"irrelevant - if we wouldn't want AD, we wouldn't be using this stuff\")",
      "549:   @Test",
      "550:   void val_noadwhennodo() throws ParseException, IOException {",
      "551:     runUnboundTest();",
      "552:   }",
      "554:   @Test",
      "555:   void val_nodata() throws ParseException, IOException {",
      "556:     runUnboundTest();",
      "557:   }",
      "559:   @Test",
      "560:   void val_nodatawc() throws ParseException, IOException {",
      "561:     runUnboundTest();",
      "562:   }",
      "564:   @Test",
      "565:   void val_nodatawc_badce() throws ParseException, IOException {",
      "566:     runUnboundTest();",
      "567:   }",
      "569:   @Test",
      "570:   void val_nodatawc_nodeny() throws ParseException, IOException {",
      "571:     runUnboundTest();",
      "572:   }",
      "574:   @Test",
      "575:   void val_nodatawc_one() throws ParseException, IOException {",
      "576:     runUnboundTest();",
      "577:   }",
      "579:   @Test",
      "580:   void val_nodatawc_wcns() throws ParseException, IOException {",
      "581:     runUnboundTest();",
      "582:   }",
      "584:   @Test",
      "585:   void val_nodatawc_wrongdeleg() throws ParseException, IOException {",
      "586:     runUnboundTest();",
      "587:   }",
      "589:   @Test",
      "590:   void val_nodata_ent() throws ParseException, IOException {",
      "591:     runUnboundTest();",
      "592:   }",
      "594:   @Test",
      "595:   void val_nodata_entnx() throws ParseException, IOException {",
      "596:     runUnboundTest();",
      "597:   }",
      "599:   @Test",
      "600:   void val_nodata_entwc() throws ParseException, IOException {",
      "601:     runUnboundTest();",
      "602:   }",
      "604:   @Test",
      "605:   void val_nodata_failsig() throws ParseException, IOException {",
      "606:     runUnboundTest();",
      "607:   }",
      "609:   @Test",
      "610:   void val_nodata_failwc() throws ParseException, IOException {",
      "611:     runUnboundTest();",
      "612:   }",
      "614:   @Test",
      "615:   void val_nodata_hasdata() throws ParseException, IOException {",
      "616:     runUnboundTest();",
      "617:   }",
      "619:   @Test",
      "620:   void val_nodata_zonecut() throws ParseException, IOException {",
      "621:     runUnboundTest();",
      "622:   }",
      "624:   @Test",
      "625:   void val_nokeyprime() throws ParseException, IOException {",
      "626:     runUnboundTest();",
      "627:   }",
      "629:   @Test",
      "630:   void val_nsec3_b1_nameerror() throws ParseException, IOException {",
      "631:     runUnboundTest();",
      "632:   }",
      "634:   @Test",
      "635:   void val_nsec3_b1_nameerror_noce() throws ParseException, IOException {",
      "636:     runUnboundTest();",
      "637:   }",
      "639:   @Test",
      "640:   void val_nsec3_b1_nameerror_nonc() throws ParseException, IOException {",
      "641:     runUnboundTest();",
      "642:   }",
      "644:   @Test",
      "645:   void val_nsec3_b1_nameerror_nowc() throws ParseException, IOException {",
      "646:     runUnboundTest();",
      "647:   }",
      "649:   @Test",
      "650:   void val_nsec3_b21_nodataent() throws ParseException, IOException {",
      "651:     runUnboundTest();",
      "652:   }",
      "654:   @Test",
      "655:   void val_nsec3_b21_nodataent_wr() throws ParseException, IOException {",
      "656:     runUnboundTest();",
      "657:   }",
      "659:   @Test",
      "660:   void val_nsec3_b2_nodata() throws ParseException, IOException {",
      "661:     runUnboundTest();",
      "662:   }",
      "664:   @Test",
      "665:   void val_nsec3_b2_nodata_nons() throws ParseException, IOException {",
      "666:     runUnboundTest();",
      "667:   }",
      "669:   @Test",
      "670:   void val_nsec3_b3_optout() throws ParseException, IOException {",
      "671:     runUnboundTest();",
      "672:   }",
      "674:   @Disabled(\"we don't do negative caching\")",
      "675:   @Test",
      "676:   void val_nsec3_b3_optout_negcache() throws ParseException, IOException {",
      "677:     runUnboundTest();",
      "678:   }",
      "680:   @Test",
      "681:   void val_nsec3_b3_optout_noce() throws ParseException, IOException {",
      "682:     runUnboundTest();",
      "683:   }",
      "685:   @Test",
      "686:   void val_nsec3_b3_optout_nonc() throws ParseException, IOException {",
      "687:     runUnboundTest();",
      "688:   }",
      "690:   @Test",
      "691:   void val_nsec3_b4_wild() throws ParseException, IOException {",
      "692:     runUnboundTest();",
      "693:   }",
      "695:   @Test",
      "696:   void val_nsec3_b4_wild_wr() throws ParseException, IOException {",
      "697:     runUnboundTest();",
      "698:   }",
      "700:   @Test",
      "701:   void val_nsec3_b5_wcnodata() throws ParseException, IOException {",
      "702:     runUnboundTest();",
      "703:   }",
      "705:   @Test",
      "706:   void val_nsec3_b5_wcnodata_noce() throws ParseException, IOException {",
      "707:     runUnboundTest();",
      "708:   }",
      "710:   @Test",
      "711:   void val_nsec3_b5_wcnodata_nonc() throws ParseException, IOException {",
      "712:     runUnboundTest();",
      "713:   }",
      "715:   @Test",
      "716:   void val_nsec3_b5_wcnodata_nowc() throws ParseException, IOException {",
      "717:     runUnboundTest();",
      "718:   }",
      "720:   @Test",
      "721:   void val_nsec3_cnametocnamewctoposwc() throws ParseException, IOException {",
      "722:     runUnboundTest();",
      "723:   }",
      "725:   @Test",
      "726:   void val_nsec3_cname_ds() throws ParseException, IOException {",
      "727:     runUnboundTest();",
      "728:   }",
      "730:   @Test",
      "731:   void val_nsec3_cname_par() throws ParseException, IOException {",
      "732:     runUnboundTest();",
      "733:   }",
      "735:   @Test",
      "736:   void val_nsec3_cname_sub() throws ParseException, IOException {",
      "737:     runUnboundTest();",
      "738:   }",
      "740:   @Test",
      "741:   void val_nsec3_entnodata_optout() throws ParseException, IOException {",
      "742:     runUnboundTest();",
      "743:   }",
      "745:   @Test",
      "746:   void val_nsec3_entnodata_optout_badopt() throws ParseException, IOException {",
      "747:     runUnboundTest();",
      "748:   }",
      "750:   @Test",
      "751:   void val_nsec3_entnodata_optout_match() throws ParseException, IOException {",
      "752:     runUnboundTest();",
      "753:   }",
      "755:   @Test",
      "756:   void val_nsec3_iter_high() throws ParseException, IOException {",
      "757:     runUnboundTest();",
      "758:   }",
      "760:   @Test",
      "761:   void val_nsec3_nodatawccname() throws ParseException, IOException {",
      "762:     runUnboundTest();",
      "763:   }",
      "765:   @Test",
      "766:   void val_nsec3_nods() throws ParseException, IOException {",
      "767:     runUnboundTest();",
      "768:   }",
      "770:   @Test",
      "771:   void val_nsec3_nods_badopt() throws ParseException, IOException {",
      "772:     runUnboundTest();",
      "773:   }",
      "775:   @Test",
      "776:   void val_nsec3_nods_badsig() throws ParseException, IOException {",
      "777:     runUnboundTest();",
      "778:   }",
      "780:   @Disabled(\"we don't do negative caching\")",
      "781:   @Test",
      "782:   void val_nsec3_nods_negcache() throws ParseException, IOException {",
      "783:     runUnboundTest();",
      "784:   }",
      "786:   @Test",
      "787:   void val_nsec3_nods_soa() throws ParseException, IOException {",
      "788:     runUnboundTest();",
      "789:   }",
      "791:   @Test",
      "792:   void val_nsec3_optout_ad() throws ParseException, IOException {",
      "793:     runUnboundTest();",
      "794:   }",
      "796:   @Disabled(\"more cache stuff\")",
      "797:   @Test",
      "798:   void val_nsec3_optout_cache() throws ParseException, IOException {",
      "799:     runUnboundTest();",
      "800:   }",
      "802:   @Test",
      "803:   void val_nsec3_wcany() throws ParseException, IOException {",
      "804:     runUnboundTest();",
      "805:   }",
      "807:   @Test",
      "808:   void val_nsec3_wcany_nodeny() throws ParseException, IOException {",
      "809:     runUnboundTest();",
      "810:   }",
      "812:   @Test",
      "813:   void val_nx() throws ParseException, IOException {",
      "814:     runUnboundTest();",
      "815:   }",
      "817:   @Test",
      "818:   void val_nx_failwc() throws ParseException, IOException {",
      "819:     runUnboundTest();",
      "820:   }",
      "822:   @Test",
      "823:   void val_nx_nodeny() throws ParseException, IOException {",
      "824:     runUnboundTest();",
      "825:   }",
      "827:   @Test",
      "828:   void val_nx_nowc() throws ParseException, IOException {",
      "829:     runUnboundTest();",
      "830:   }",
      "832:   @Test",
      "833:   void val_nx_nsec3_collision() throws ParseException, IOException {",
      "834:     runUnboundTest();",
      "835:   }",
      "837:   @Test",
      "838:   void val_nx_nsec3_collision2() throws ParseException, IOException {",
      "839:     runUnboundTest();",
      "840:   }",
      "842:   @Test",
      "843:   void val_nx_nsec3_collision3() throws ParseException, IOException {",
      "844:     runUnboundTest();",
      "845:   }",
      "847:   @Test",
      "848:   void val_nx_nsec3_collision4() throws ParseException, IOException {",
      "849:     runUnboundTest();",
      "850:   }",
      "852:   @Test",
      "853:   void val_nx_nsec3_hashalg() throws ParseException, IOException {",
      "854:     runUnboundTest();",
      "855:   }",
      "857:   @Test",
      "858:   void val_nx_nsec3_nsecmix() throws ParseException, IOException {",
      "859:     runUnboundTest();",
      "860:   }",
      "862:   @Test",
      "863:   void val_nx_nsec3_params() throws ParseException, IOException {",
      "864:     runUnboundTest();",
      "865:   }",
      "867:   @Test",
      "868:   void val_nx_overreach() throws ParseException, IOException {",
      "869:     runUnboundTest();",
      "870:   }",
      "872:   @Test",
      "873:   void val_positive() throws ParseException, IOException {",
      "874:     runUnboundTest();",
      "875:   }",
      "877:   @Test",
      "878:   void val_positive_nosigs() throws ParseException, IOException {",
      "879:     runUnboundTest();",
      "880:   }",
      "882:   @Test",
      "883:   void val_positive_wc() throws ParseException, IOException {",
      "884:     runUnboundTest();",
      "885:   }",
      "887:   @Test",
      "888:   void val_positive_wc_nodeny() throws ParseException, IOException {",
      "889:     runUnboundTest();",
      "890:   }",
      "892:   @Test",
      "893:   void val_pos_truncns() throws ParseException, IOException {",
      "894:     runUnboundTest();",
      "895:   }",
      "897:   @Test",
      "898:   void val_qds_badanc() throws ParseException, IOException {",
      "899:     runUnboundTest();",
      "900:   }",
      "902:   @Test",
      "903:   void val_qds_oneanc() throws ParseException, IOException {",
      "904:     runUnboundTest();",
      "905:   }",
      "907:   @Test",
      "908:   void val_qds_twoanc() throws ParseException, IOException {",
      "909:     runUnboundTest();",
      "910:   }",
      "912:   @Disabled(\"NSEC records missing for validation, tests caching stuff\")",
      "913:   @Test",
      "914:   void val_referd() throws ParseException, IOException {",
      "915:     runUnboundTest();",
      "916:   }",
      "918:   @Disabled(\"we don't do negative caching\")",
      "919:   @Test",
      "920:   void val_referglue() throws ParseException, IOException {",
      "921:     runUnboundTest();",
      "922:   }",
      "924:   @Disabled(\"we don't do negative caching\")",
      "925:   @Test",
      "926:   void val_refer_unsignadd() throws ParseException, IOException {",
      "927:     runUnboundTest();",
      "928:   }",
      "930:   @Test",
      "931:   void val_rrsig() throws ParseException, IOException {",
      "932:     runUnboundTest();",
      "933:   }",
      "935:   @Test",
      "936:   void val_secds() throws ParseException, IOException {",
      "937:     runUnboundTest();",
      "938:   }",
      "940:   @Test",
      "941:   void val_secds_nosig() throws ParseException, IOException {",
      "942:     runUnboundTest();",
      "943:   }",
      "946:   @Test",
      "948:     runUnboundTest();",
      "949:   }",
      "951:   @Test",
      "953:     runUnboundTest();",
      "954:   }",
      "956:   @Test",
      "957:   void val_stub_noroot() throws ParseException, IOException {",
      "958:     runUnboundTest();",
      "959:   }",
      "961:   @Test",
      "962:   void val_ta_algo_dnskey() throws ParseException, IOException {",
      "963:     runUnboundTest();",
      "964:   }",
      "966:   @Test",
      "967:   void val_ta_algo_dnskey_dp() throws ParseException, IOException {",
      "968:     runUnboundTest();",
      "969:   }",
      "971:   @Test",
      "972:   void val_ta_algo_missing() throws ParseException, IOException {",
      "973:     runUnboundTest();",
      "974:   }",
      "976:   @Test",
      "977:   void val_ta_algo_missing_dp() throws ParseException, IOException {",
      "978:     runUnboundTest();",
      "979:   }",
      "981:   @Test",
      "982:   void val_twocname() throws ParseException, IOException {",
      "983:     runUnboundTest();",
      "984:   }",
      "986:   @Test",
      "987:   void val_unalgo_anchor() throws ParseException, IOException {",
      "988:     runUnboundTest();",
      "989:   }",
      "991:   @Test",
      "992:   void val_unalgo_dlv() throws ParseException, IOException {",
      "993:     runUnboundTest();",
      "994:   }",
      "996:   @Test",
      "997:   void val_unalgo_ds() throws ParseException, IOException {",
      "998:     runUnboundTest();",
      "999:   }",
      "1001:   @Test",
      "1002:   void val_unsecds() throws ParseException, IOException {",
      "1003:     runUnboundTest();",
      "1004:   }",
      "1006:   @Disabled(\"we don't do negative caching\")",
      "1007:   @Test",
      "1008:   void val_unsecds_negcache() throws ParseException, IOException {",
      "1009:     runUnboundTest();",
      "1010:   }",
      "1012:   @Disabled(\"tests the iterative resolver\")",
      "1013:   @Test",
      "1014:   void val_unsecds_qtypeds() throws ParseException, IOException {",
      "1015:     runUnboundTest();",
      "1016:   }",
      "1018:   @Test",
      "1019:   void val_unsec_cname() throws ParseException, IOException {",
      "1020:     runUnboundTest();",
      "1021:   }",
      "1023:   @Test",
      "1024:   void val_wild_pos() throws ParseException, IOException {",
      "1025:     runUnboundTest();",
      "1026:   }",
      "",
      "[Removed Lines]",
      "241:   @Disabled(\"tests caching of NX from a parent resolver\")",
      "247:   @Disabled(\"tests caching of NX from a parent resolver\")",
      "945:   @Disabled(\"tests unbound specific config (stub zones)\")",
      "947:   void val_stubds() throws ParseException, IOException {",
      "952:   void val_spurious_ns() throws ParseException, IOException {",
      "",
      "[Added Lines]",
      "259:   @DisplayName(\"val_adbit.rpl: Test validator AD bit signaling\")",
      "265:   @DisplayName(\"val_adcopy.rpl: Test validator AD bit sent by untrusted upstream\")",
      "270:   @Disabled(\"tests resolving conflicting responses in a recursive resolver\")",
      "272:   @DisplayName(\"val_anchor_nx.rpl: Test validator with secure proof of trust anchor nxdomain\")",
      "277:   @Disabled(\"tests resolving conflicting responses in a recursive resolver\")",
      "279:   @DisplayName(\"val_anchor_nx_nosig.rpl: Test validator with unsigned denial of trust anchor\")",
      "285:   @DisplayName(\"val_ans_dsent.rpl: Test validator with empty nonterminals on the trust chain.\")",
      "291:   @DisplayName(\"val_ans_nx.rpl: Test validator with DS nodata as nxdomain on trust chain\")",
      "297:   @DisplayName(\"val_any.rpl: Test validator with response to qtype ANY\")",
      "303:   @DisplayName(\"val_any_cname.rpl: Test validator with response to qtype ANY that includes CNAME\")",
      "309:   @DisplayName(\"val_any_dname.rpl: Test validator with response to qtype ANY that includes DNAME\")",
      "315:   @DisplayName(\"val_cnameinsectopos.rpl: Test validator with an insecure cname to positive cached\")",
      "321:   @DisplayName(",
      "322:       \"val_cnamenx_dblnsec.rpl: Test validator with cname-nxdomain for duplicate NSEC detection\")",
      "328:   @DisplayName(\"val_cnamenx_rcodenx.rpl: Test validator with cname-nxdomain with rcode nxdomain\")",
      "334:   @DisplayName(\"val_cnameqtype.rpl: Test validator with a query for type cname\")",
      "340:   @DisplayName(\"val_cnametocloser.rpl: Test validator with CNAME to closer anchor under optout.\")",
      "346:   @DisplayName(",
      "347:       \"val_cnametocloser_nosig.rpl: Test validator with CNAME to closer anchor optout missing sigs.\")",
      "353:   @DisplayName(",
      "354:       \"val_cnametocnamewctoposwc.rpl: Test validator with a regular cname to wildcard cname to wildcard response\")",
      "360:   @DisplayName(\"val_cnametodname.rpl: Test validator with a cname to a dname\")",
      "366:   @DisplayName(",
      "367:       \"val_cnametodnametocnametopos.rpl: Test validator with cname, dname, cname, positive answer\")",
      "374:   @DisplayName(\"val_cnametoinsecure.rpl: Test validator with CNAME to insecure NSEC or NSEC3.\")",
      "380:   @DisplayName(\"val_cnametonodata.rpl: Test validator with cname to nodata\")",
      "386:   @DisplayName(\"val_cnametonodata_nonsec.rpl: Test validator with cname to nodata\")",
      "393:   @DisplayName(\"val_cnametonsec.rpl: Test validator with CNAME to insecure NSEC delegation\")",
      "399:   @DisplayName(\"val_cnametonx.rpl: Test validator with cname to nxdomain\")",
      "406:   @DisplayName(\"val_cnametooptin.rpl: Test validator with CNAME to insecure optin NSEC3\")",
      "412:   @DisplayName(\"val_cnametooptout.rpl: Test validator with CNAME to optout NSEC3 span NODATA\")",
      "418:   @DisplayName(\"val_cnametopos.rpl: Test validator with a cname to positive\")",
      "424:   @DisplayName(",
      "425:       \"val_cnametoposnowc.rpl: Test validator with a cname to positive wildcard without proof\")",
      "431:   @DisplayName(\"val_cnametoposwc.rpl: Test validator with a cname to positive wildcard\")",
      "437:   @DisplayName(\"val_cnamewctonodata.rpl: Test validator with wildcard cname to nodata\")",
      "443:   @DisplayName(\"val_cnamewctonx.rpl: Test validator with wildcard cname to nxdomain\")",
      "449:   @DisplayName(\"val_cnamewctoposwc.rpl: Test validator with wildcard cname to positive wildcard\")",
      "455:   @DisplayName(\"val_cname_loop1.rpl: Test validator with cname loop\")",
      "461:   @DisplayName(\"val_cname_loop2.rpl: Test validator with cname 2 step loop\")",
      "467:   @DisplayName(\"val_cname_loop3.rpl: Test validator with cname 3 step loop\")",
      "473:   @DisplayName(\"val_deleg_nons.rpl: Test validator with unsigned delegation with no NS bit in NSEC\")",
      "474:   void val_deleg_nons() throws ParseException, IOException {",
      "475:     runUnboundTest();",
      "476:   }",
      "478:   @Test",
      "479:   @DisplayName(\"val_dnametoolong.rpl: Test validator with a dname too long response\")",
      "485:   @DisplayName(\"val_dnametopos.rpl: Test validator with a dname to positive\")",
      "491:   @DisplayName(\"val_dnametoposwc.rpl: Test validator with a dname to positive wildcard\")",
      "497:   @DisplayName(\"val_dnamewc.rpl: Test validator with a wildcarded dname\")",
      "504:   @DisplayName(\"val_dsnsec.rpl: Test pickup of DS NSEC from the cache.\")",
      "510:   @DisplayName(\"val_ds_afterprime.rpl: Test DS lookup after key prime is done.\")",
      "516:   @DisplayName(\"val_ds_cname.rpl: Test validator with CNAME response to DS\")",
      "522:   @DisplayName(\"val_ds_cnamesub.rpl: Test validator with CNAME response to DS in chain of trust\")",
      "528:   @DisplayName(",
      "529:       \"val_ds_cnamesubbogus.rpl: Test validator with bogus CNAME response to DS in chain of trust\")",
      "535:   @DisplayName(\"val_ds_gost.rpl: Test validator with GOST DS digest\")",
      "541:   @DisplayName(\"val_ds_gost_downgrade.rpl: Test validator with GOST DS digest downgrade attack\")",
      "547:   @DisplayName(\"val_ds_sha2.rpl: Test validator with SHA256 DS digest\")",
      "553:   @DisplayName(\"val_ds_sha2_downgrade.rpl: Test validator with SHA256 DS downgrade to SHA1\")",
      "559:   @DisplayName(",
      "560:       \"val_ds_sha2_downgrade_override.rpl: Test validator with SHA256 DS downgrade to SHA1\")",
      "566:   @DisplayName(\"val_ds_sha2_lenient.rpl: Test validator with SHA256 DS downgrade to SHA1 lenience\")",
      "572:   @DisplayName(\"val_entds.rpl: Test validator with lots of ENTs in the chain of trust\")",
      "578:   @DisplayName(\"val_faildnskey.rpl: Test validator with failed DNSKEY request\")",
      "585:   @DisplayName(",
      "586:       \"val_faildnskey_ok.rpl: Test validator with failed DNSKEY request, but not hardened.\")",
      "593:   @DisplayName(\"val_fwdds.rpl: Test forward-zone with DS query\")",
      "599:   @DisplayName(\"val_keyprefetch.rpl: Test validator with key prefetch\")",
      "605:   @DisplayName(",
      "606:       \"val_keyprefetch_verify.rpl: Test validator with key prefetch and verify with the anchor\")",
      "612:   @DisplayName(\"val_mal_wc.rpl: Test validator with nodata, wildcards and ENT\")",
      "618:   @DisplayName(\"val_negcache_ds.rpl: Test validator with negative cache DS response\")",
      "625:   @DisplayName(",
      "626:       \"val_negcache_dssoa.rpl: Test validator with negative cache DS response with cached SOA\")",
      "633:   @DisplayName(",
      "634:       \"val_negcache_nodata.rpl: Test validator with negative cache NXDOMAIN response (aggressive NSEC)\")",
      "641:   @DisplayName(\"val_negcache_nta.rpl: Test to not do aggressive NSEC for domains under NTA\")",
      "648:   @DisplayName(",
      "649:       \"val_negcache_nxdomain.rpl: Test validator with negative cache NXDOMAIN response (aggressive NSEC)\")",
      "656:   @DisplayName(\"val_noadwhennodo.rpl: Test if AD bit is returned on non-DO query.\")",
      "662:   @DisplayName(\"val_nodata.rpl: Test validator with nodata response\")",
      "668:   @DisplayName(\"val_nodatawc.rpl: Test validator with wildcard nodata response\")",
      "674:   @DisplayName(\"val_nodatawc_badce.rpl: Test validator with wildcard nodata, bad closest encloser\")",
      "680:   @DisplayName(",
      "681:       \"val_nodatawc_nodeny.rpl: Test validator with wildcard nodata response without qdenial\")",
      "687:   @DisplayName(\"val_nodatawc_one.rpl: Test validator with wildcard nodata response with one NSEC\")",
      "693:   @DisplayName(",
      "694:       \"val_nodatawc_wcns.rpl: Test validator with wildcard nodata response from parent zone with SOA\")",
      "700:   @DisplayName(",
      "701:       \"val_nodatawc_wrongdeleg.rpl: Test validator with wildcard nodata response from parent zone\")",
      "707:   @DisplayName(\"val_nodata_ent.rpl: Test validator with nodata on empty nonterminal response\")",
      "713:   @DisplayName(",
      "714:       \"val_nodata_entnx.rpl: Test validator with nodata on empty nonterminal response with rcode NXDOMAIN\")",
      "720:   @DisplayName(",
      "721:       \"val_nodata_entwc.rpl: Test validator with wildcard nodata on empty nonterminal response\")",
      "727:   @DisplayName(\"val_nodata_failsig.rpl: Test validator with nodata response with bogus RRSIG\")",
      "733:   @DisplayName(",
      "734:       \"val_nodata_failwc.rpl: Test validator with nodata response with wildcard expanded NSEC record, original NSEC owner does not provide proof for QNAME. CVE-2017-15105 test.\")",
      "740:   @DisplayName(\"val_nodata_hasdata.rpl: Test validator with nodata response, that proves the data.\")",
      "746:   @DisplayName(",
      "747:       \"val_nodata_zonecut.rpl: Test validator with nodata response from wrong side of zonecut\")",
      "753:   @DisplayName(\"val_nokeyprime.rpl: Test validator with failed key prime, no keys.\")",
      "759:   @DisplayName(\"val_nsec3_b1_nameerror.rpl: Test validator NSEC3 B.1 name error.\")",
      "765:   @DisplayName(",
      "766:       \"val_nsec3_b1_nameerror_noce.rpl: Test validator NSEC3 B.1 name error without ce NSEC3.\")",
      "772:   @DisplayName(",
      "773:       \"val_nsec3_b1_nameerror_nonc.rpl: Test validator NSEC3 B.1 name error without nc NSEC3.\")",
      "779:   @DisplayName(",
      "780:       \"val_nsec3_b1_nameerror_nowc.rpl: Test validator NSEC3 B.1 name error without wc NSEC3.\")",
      "786:   @DisplayName(\"val_nsec3_b21_nodataent.rpl: Test validator NSEC3 B.2.1 no data empty nonterminal.\")",
      "792:   @DisplayName(",
      "793:       \"val_nsec3_b21_nodataent_wr.rpl: Test validator NSEC3 B.2.1 no data empty nonterminal, wrong rr.\")",
      "799:   @DisplayName(\"val_nsec3_b2_nodata.rpl: Test validator NSEC3 B.2 no data.\")",
      "805:   @DisplayName(\"val_nsec3_b2_nodata_nons.rpl: Test validator NSEC3 B.2 no data, without NSEC3.\")",
      "811:   @DisplayName(",
      "812:       \"val_nsec3_b3_optout.rpl: Test validator NSEC3 B.3 referral to optout unsigned zone.\")",
      "819:   @DisplayName(",
      "820:       \"val_nsec3_b3_optout_negcache.rpl: Test validator NSEC3 B.3 referral optout with negative cache.\")",
      "826:   @DisplayName(",
      "827:       \"val_nsec3_b3_optout_noce.rpl: Test validator NSEC3 B.3 optout unsigned, without ce.\")",
      "833:   @DisplayName(",
      "834:       \"val_nsec3_b3_optout_nonc.rpl: Test validator NSEC3 B.3 optout unsigned, without nc.\")",
      "840:   @DisplayName(\"val_nsec3_b4_wild.rpl: Test validator NSEC3 B.4 wildcard expansion.\")",
      "846:   @DisplayName(",
      "847:       \"val_nsec3_b4_wild_wr.rpl: Test validator NSEC3 B.4 wildcard expansion, wrong NSEC3.\")",
      "853:   @DisplayName(\"val_nsec3_b5_wcnodata.rpl: Test validator NSEC3 B.5 wildcard nodata.\")",
      "859:   @DisplayName(",
      "860:       \"val_nsec3_b5_wcnodata_noce.rpl: Test validator NSEC3 B.5 wildcard nodata, without ce.\")",
      "866:   @DisplayName(",
      "867:       \"val_nsec3_b5_wcnodata_nonc.rpl: Test validator NSEC3 B.5 wildcard nodata, without nc.\")",
      "873:   @DisplayName(",
      "874:       \"val_nsec3_b5_wcnodata_nowc.rpl: Test validator NSEC3 B.5 wildcard nodata, without wc.\")",
      "880:   @DisplayName(",
      "881:       \"val_nsec3_cnametocnamewctoposwc.rpl: Test validator with a regular cname to wildcard cname to wildcard response\")",
      "887:   @DisplayName(\"val_nsec3_cname_ds.rpl: Test validator with NSEC3 CNAME for qtype DS.\")",
      "893:   @DisplayName(\"val_nsec3_cname_par.rpl: Test validator with NSEC3 wildcard CNAME to parent.\")",
      "899:   @DisplayName(\"val_nsec3_cname_sub.rpl: Test validator with NSEC3 wildcard CNAME to subzone.\")",
      "905:   @DisplayName(",
      "906:       \"val_nsec3_entnodata_optout.rpl: Test validator with NSEC3 response for NODATA ENT with optout.\")",
      "912:   @DisplayName(",
      "913:       \"val_nsec3_entnodata_optout_badopt.rpl: Test validator with NSEC3 response for NODATA ENT with optout.\")",
      "919:   @DisplayName(",
      "920:       \"val_nsec3_entnodata_optout_match.rpl: Test validator NODATA ENT with nsec3 optout matches the ent.\")",
      "926:   @DisplayName(",
      "927:       \"val_nsec3_iter_high.rpl: Test validator with nxdomain NSEC3 with too high iterations\")",
      "933:   @DisplayName(",
      "934:       \"val_nsec3_nodatawccname.rpl: Test validator with nodata NSEC3 abused wildcarded CNAME.\")",
      "940:   @DisplayName(\"val_nsec3_nods.rpl: Test validator with NSEC3 with no DS referral.\")",
      "946:   @DisplayName(",
      "947:       \"val_nsec3_nods_badopt.rpl: Test validator with NSEC3 with no DS with wrong optout bit.\")",
      "953:   @DisplayName(",
      "954:       \"val_nsec3_nods_badsig.rpl: Test validator with NSEC3 with no DS referral with bad signature.\")",
      "961:   @DisplayName(",
      "962:       \"val_nsec3_nods_negcache.rpl: Test validator with NSEC3 with no DS referral from neg cache.\")",
      "968:   @DisplayName(",
      "969:       \"val_nsec3_nods_soa.rpl: Test validator with NSEC3 with no DS referral abuse of apex.\")",
      "975:   @DisplayName(",
      "976:       \"val_nsec3_optout_ad.rpl: Test validator with optout NSEC3 response that gets no AD.\")",
      "983:   @DisplayName(",
      "984:       \"val_nsec3_optout_cache.rpl: Test validator with NSEC3 span change and cache effects.\")",
      "990:   @DisplayName(\"val_nsec3_wcany.rpl: Test validator with NSEC3 wildcard qtype ANY response.\")",
      "996:   @DisplayName(",
      "997:       \"val_nsec3_wcany_nodeny.rpl: Test validator with NSEC3 wildcard qtype ANY without denial.\")",
      "1003:   @DisplayName(\"val_nx.rpl: Test validator with nxdomain response\")",
      "1009:   @DisplayName(",
      "1010:       \"val_nx_failwc.rpl: Test validator with nxdomain response with wildcard expanded NSEC record, original NSEC owner does not provide proof for QNAME. CVE-2017-15105 test.\")",
      "1016:   @DisplayName(\"val_nx_nodeny.rpl: Test validator with nxdomain response missing qname denial\")",
      "1022:   @DisplayName(\"val_nx_nowc.rpl: Test validator with nxdomain response missing wildcard denial\")",
      "1028:   @DisplayName(\"val_nx_nsec3_collision.rpl: Test validator with nxdomain NSEC3 with a collision.\")",
      "1034:   @DisplayName(",
      "1035:       \"val_nx_nsec3_collision2.rpl: Test validator with nxdomain NSEC3 with a salt mismatch.\")",
      "1041:   @DisplayName(\"val_nx_nsec3_collision3.rpl: Test validator with nxdomain NSEC3 with a collision.\")",
      "1047:   @DisplayName(\"val_nx_nsec3_collision4.rpl: Test validator with nxdomain NSEC3 with a collision.\")",
      "1053:   @DisplayName(\"val_nx_nsec3_hashalg.rpl: Test validator with unknown NSEC3 hash algorithm.\")",
      "1059:   @DisplayName(",
      "1060:       \"val_nx_nsec3_nsecmix.rpl: Test validator with NSEC3 responses that has an NSEC mixed in.\")",
      "1066:   @DisplayName(\"val_nx_nsec3_params.rpl: Test validator with nxdomain NSEC3 several parameters.\")",
      "1072:   @DisplayName(\"val_nx_overreach.rpl: Test validator with overreaching NSEC record\")",
      "1078:   @DisplayName(\"val_positive.rpl: Test validator with positive response\")",
      "1084:   @DisplayName(",
      "1085:       \"val_positive_nosigs.rpl: Test validator with positive response, signatures removed.\")",
      "1091:   @DisplayName(\"val_positive_wc.rpl: Test validator with positive wildcard response\")",
      "1097:   @DisplayName(",
      "1098:       \"val_positive_wc_nodeny.rpl: Test validator with positive wildcard without qname denial\")",
      "1104:   @DisplayName(\"val_pos_truncns.rpl: Test validator with badly truncated positive response\")",
      "1110:   @DisplayName(\"val_qds_badanc.rpl: Test validator with DS query and a bad anchor\")",
      "1116:   @DisplayName(\"val_qds_oneanc.rpl: Test validator with DS query and one anchor\")",
      "1122:   @DisplayName(\"val_qds_twoanc.rpl: Test validator with DS query and two anchors\")",
      "1129:   @DisplayName(\"val_referd.rpl: Test validator with cache referral\")",
      "1136:   @DisplayName(\"val_referglue.rpl: Test validator with cache referral with unsigned glue\")",
      "1143:   @DisplayName(\"val_refer_unsignadd.rpl: Test validator with a referral with unsigned additional\")",
      "1149:   @DisplayName(\"val_rrsig.rpl: Test validator with qtype RRSIG response\")",
      "1155:   @DisplayName(\"val_secds.rpl: Test validator with secure delegation\")",
      "1161:   @DisplayName(\"val_secds_nosig.rpl: Test validator with no signatures after secure delegation\")",
      "1167:   @DisplayName(\"val_spurious_ns.rpl: Test validator with spurious unsigned NS in auth section\")",
      "1168:   void val_spurious_ns() throws ParseException, IOException {",
      "1172:   @Disabled(\"tests unbound specific config (stub zones)\")",
      "1174:   @DisplayName(\"val_stubds.rpl: Test stub with DS query\")",
      "1175:   void val_stubds() throws ParseException, IOException {",
      "1180:   @DisplayName(\"val_stub_noroot.rpl: Test validation of stub zone without root prime.\")",
      "1186:   @DisplayName(\"val_ta_algo_dnskey.rpl: Test validator with multiple algorithm trust anchor\")",
      "1192:   @DisplayName(",
      "1193:       \"val_ta_algo_dnskey_dp.rpl: Test validator with multiple algorithm trust anchor without harden\")",
      "1199:   @DisplayName(\"val_ta_algo_missing.rpl: Test validator with multiple algorithm missing one\")",
      "1205:   @DisplayName(\"val_ta_algo_missing_dp.rpl: Test validator with multiple algorithm missing one\")",
      "1211:   @DisplayName(\"val_twocname.rpl: Test validator with unsigned CNAME to signed CNAME to data\")",
      "1217:   @DisplayName(\"val_unalgo_anchor.rpl: Test validator with unsupported algorithm trust anchor\")",
      "1223:   @DisplayName(\"val_unalgo_dlv.rpl: Test validator with unknown algorithm DLV anchor\")",
      "1229:   @DisplayName(\"val_unalgo_ds.rpl: Test validator with unknown algorithm delegation\")",
      "1235:   @DisplayName(\"val_unsecds.rpl: Test validator with insecure delegation\")",
      "1242:   @DisplayName(",
      "1243:       \"val_unsecds_negcache.rpl: Test validator with insecure delegation and DS negative cache\")",
      "1250:   @DisplayName(\"val_unsecds_qtypeds.rpl: Test validator with insecure delegation and qtype DS.\")",
      "1256:   @DisplayName(\"val_unsec_cname.rpl: Test validator with DS, unsec, cname sequence.\")",
      "1262:   @DisplayName(\"val_wild_pos.rpl: Test validator with direct wildcard positive response\")",
      "",
      "---------------"
    ],
    "src/test/java/org/xbill/DNS/lookup/LookupResultTest.java||src/test/java/org/xbill/DNS/lookup/LookupResultTest.java": [
      "File: src/test/java/org/xbill/DNS/lookup/LookupResultTest.java -> src/test/java/org/xbill/DNS/lookup/LookupResultTest.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "4: import static java.util.Collections.singletonList;",
      "5: import static org.junit.jupiter.api.Assertions.assertEquals;",
      "6: import static org.junit.jupiter.api.Assertions.assertThrows;",
      "8: import java.net.InetAddress;",
      "9: import org.junit.jupiter.api.Test;",
      "10: import org.xbill.DNS.ARecord;",
      "11: import org.xbill.DNS.DClass;",
      "12: import org.xbill.DNS.Name;",
      "13: import org.xbill.DNS.Record;",
      "15: class LookupResultTest {",
      "16:   @Test",
      "17:   void ctor_nullRecords() {",
      "19:   }",
      "21:   @Test",
      "22:   void getResult() {",
      "27:   }",
      "29:   @Test",
      "30:   void getAliases() {",
      "31:     Name name = Name.fromConstantString(\"b.\");",
      "32:     Record record = new ARecord(name, DClass.IN, 0, InetAddress.getLoopbackAddress());",
      "34:     assertEquals(singletonList(name), lookupResult.getAliases());",
      "35:   }",
      "36: }",
      "",
      "[Removed Lines]",
      "18:     assertThrows(NullPointerException.class, () -> new LookupResult(null, null));",
      "23:     Record record =",
      "24:         new ARecord(Name.fromConstantString(\"a.\"), DClass.IN, 0, InetAddress.getLoopbackAddress());",
      "25:     LookupResult lookupResult = new LookupResult(singletonList(record), null);",
      "26:     assertEquals(singletonList(record), lookupResult.getRecords());",
      "33:     LookupResult lookupResult = new LookupResult(singletonList(record), singletonList(name));",
      "",
      "[Added Lines]",
      "6: import static org.junit.jupiter.api.Assertions.assertNull;",
      "10: import java.util.Collections;",
      "12: import org.junit.jupiter.params.ParameterizedTest;",
      "13: import org.junit.jupiter.params.provider.ValueSource;",
      "15: import org.xbill.DNS.CNAMERecord;",
      "21:   private static final LookupResult PREVIOUS = new LookupResult(false);",
      "22:   private static final ARecord A_RECORD =",
      "23:       new ARecord(Name.fromConstantString(\"a.\"), DClass.IN, 0, InetAddress.getLoopbackAddress());",
      "27:     assertThrows(",
      "28:         NullPointerException.class,",
      "29:         () -> new LookupResult(PREVIOUS, null, null, false, null, Collections.emptyList()));",
      "30:   }",
      "32:   @Test",
      "33:   void ctor_nullAliases() {",
      "34:     assertThrows(",
      "35:         NullPointerException.class,",
      "36:         () -> new LookupResult(PREVIOUS, null, null, false, Collections.emptyList(), null));",
      "37:   }",
      "39:   @ParameterizedTest",
      "40:   @ValueSource(booleans = {false, true})",
      "41:   void ctor_authOnly(boolean isAuthenticated) {",
      "42:     LookupResult lookupResult = new LookupResult(isAuthenticated);",
      "43:     assertEquals(isAuthenticated, lookupResult.isAuthenticated());",
      "44:     assertEquals(0, lookupResult.getAliases().size());",
      "45:     assertEquals(0, lookupResult.getRecords().size());",
      "46:     assertEquals(0, lookupResult.getQueryResponsePairs().size());",
      "47:   }",
      "49:   @ParameterizedTest",
      "50:   @ValueSource(booleans = {false, true})",
      "51:   void ctor_singleRecord(boolean isAuthenticated) {",
      "52:     LookupResult lookupResult = new LookupResult(A_RECORD, isAuthenticated, A_RECORD);",
      "53:     assertEquals(isAuthenticated, lookupResult.isAuthenticated());",
      "54:     assertEquals(0, lookupResult.getAliases().size());",
      "55:     assertEquals(1, lookupResult.getRecords().size());",
      "56:     assertEquals(1, lookupResult.getQueryResponsePairs().size());",
      "57:     assertNull(lookupResult.getQueryResponsePairs().get(A_RECORD));",
      "62:     LookupResult lookupResult =",
      "63:         new LookupResult(",
      "64:             PREVIOUS, null, null, false, singletonList(A_RECORD), Collections.emptyList());",
      "65:     assertEquals(singletonList(A_RECORD), lookupResult.getRecords());",
      "72:     LookupResult lookupResult =",
      "73:         new LookupResult(PREVIOUS, null, null, false, singletonList(record), singletonList(name));",
      "77:   @ParameterizedTest",
      "78:   @ValueSource(booleans = {false, true})",
      "79:   void isAuthenticated(boolean isAuthenticated) {",
      "80:     LookupResult lookupResult =",
      "81:         new LookupResult(",
      "82:             new LookupResult(isAuthenticated),",
      "83:             null,",
      "84:             null,",
      "85:             isAuthenticated,",
      "86:             singletonList(A_RECORD),",
      "87:             Collections.emptyList());",
      "88:     assertEquals(isAuthenticated, lookupResult.isAuthenticated());",
      "89:   }",
      "91:   @ParameterizedTest",
      "92:   @ValueSource(booleans = {false, true})",
      "93:   void isAuthenticatedRequiresAllForTrue(boolean isAuthenticated) {",
      "94:     Name nameA = Name.fromConstantString(\"a.\");",
      "95:     Name nameB = Name.fromConstantString(\"b.\");",
      "96:     Record cname = new CNAMERecord(nameA, DClass.IN, 0, nameB);",
      "97:     Record a = new ARecord(nameB, DClass.IN, 0, InetAddress.getLoopbackAddress());",
      "98:     LookupResult lookupResult1 = new LookupResult(isAuthenticated);",
      "99:     LookupResult lookupResult2 =",
      "100:         new LookupResult(lookupResult1, cname, null, true, singletonList(a), singletonList(nameA));",
      "101:     assertEquals(isAuthenticated, lookupResult2.isAuthenticated());",
      "102:   }",
      "",
      "---------------"
    ],
    "src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java||src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java": [
      "File: src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java -> src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java",
      "--- Hunk 1 ---",
      "[Context before]",
      "5: import static java.util.Arrays.asList;",
      "6: import static java.util.Collections.emptyList;",
      "7: import static java.util.Collections.singletonList;",
      "8: import static org.junit.jupiter.api.Assertions.assertEquals;",
      "10: import static org.mockito.ArgumentMatchers.any;",
      "11: import static org.mockito.ArgumentMatchers.anyInt;",
      "12: import static org.mockito.Mockito.inOrder;",
      "13: import static org.mockito.Mockito.mock;",
      "14: import static org.mockito.Mockito.times;",
      "15: import static org.mockito.Mockito.verify;",
      "16: import static org.mockito.Mockito.verifyNoMoreInteractions;",
      "",
      "[Removed Lines]",
      "9: import static org.junit.jupiter.api.Assertions.assertThrows;",
      "",
      "[Added Lines]",
      "8: import static org.assertj.core.api.Assertions.assertThat;",
      "9: import static org.assertj.core.api.Assertions.assertThatThrownBy;",
      "10: import static org.junit.jupiter.api.Assertions.assertAll;",
      "12: import static org.junit.jupiter.api.Assertions.assertTrue;",
      "13: import static org.junitpioneer.jupiter.cartesian.CartesianTest.Enum;",
      "14: import static org.junitpioneer.jupiter.cartesian.CartesianTest.Values;",
      "18: import static org.mockito.Mockito.lenient;",
      "20: import static org.mockito.Mockito.spy;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "20: import static org.xbill.DNS.LookupTest.LONG_LABEL;",
      "21: import static org.xbill.DNS.LookupTest.answer;",
      "22: import static org.xbill.DNS.LookupTest.fail;",
      "23: import static org.xbill.DNS.Type.A;",
      "24: import static org.xbill.DNS.Type.AAAA;",
      "25: import static org.xbill.DNS.Type.CNAME;",
      "26: import static org.xbill.DNS.Type.MX;",
      "28: import java.io.IOException;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "30: import static org.xbill.DNS.LookupTest.multiAnswer;",
      "34: import static org.xbill.DNS.Type.DNAME;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "44: import org.junit.jupiter.api.BeforeEach;",
      "45: import org.junit.jupiter.api.Test;",
      "46: import org.junit.jupiter.api.extension.ExtendWith;",
      "48: import org.junit.jupiter.api.io.TempDir;",
      "49: import org.junit.jupiter.params.ParameterizedTest;",
      "50: import org.junit.jupiter.params.provider.CsvSource;",
      "51: import org.junit.jupiter.params.provider.ValueSource;",
      "52: import org.mockito.ArgumentCaptor;",
      "53: import org.mockito.InOrder;",
      "54: import org.mockito.Mock;",
      "",
      "[Removed Lines]",
      "47: import org.junit.jupiter.api.function.Executable;",
      "",
      "[Added Lines]",
      "59: import org.junit.jupiter.params.provider.EnumSource;",
      "61: import org.junitpioneer.jupiter.cartesian.CartesianTest;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "70: import org.xbill.DNS.Section;",
      "71: import org.xbill.DNS.SetResponse;",
      "72: import org.xbill.DNS.Type;",
      "73: import org.xbill.DNS.hosts.HostsFileParser;",
      "75: @ExtendWith(MockitoExtension.class)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "83: import org.xbill.DNS.WireParseException;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "81:   private static final ARecord LOOPBACK_A =",
      "82:       new ARecord(DUMMY_NAME, IN, 3600, InetAddress.getLoopbackAddress());",
      "83:   private static final AAAARecord LOOPBACK_AAAA;",
      "84:   private HostsFileParser lookupSessionTestHostsFileParser;",
      "86:   static {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "94:   private static final ARecord EXAMPLE_A = (ARecord) LOOPBACK_A.withName(name(\"example.com.\"));",
      "96:   private static final String INVALID_SERVER_RESPONSE_MESSAGE = \"refusing to return it\";",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "124:     verify(mockResolver).sendAsync(any(), any(Executor.class));",
      "125:   }",
      "127:   @Test",
      "128:   void lookupAsync_absoluteQuery_defaultClass() throws InterruptedException, ExecutionException {",
      "129:     wireUpMockResolver(mockResolver, query -> answer(query, name -> LOOPBACK_A));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "140:   @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")",
      "141:   void lookupAsync_absoluteQueryNoExtra(",
      "142:       @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)",
      "143:       throws ExecutionException, InterruptedException {",
      "144:     wireUpMockResolver(",
      "145:         mockResolver, query -> multiAnswer(query, name -> new Record[] {LOOPBACK_A, EXAMPLE_A}));",
      "147:     LookupSession lookupSession = lookupSession(useCache).irrelevantRecordMode(mode).build();",
      "148:     CompletableFuture<LookupResult> future =",
      "149:         lookupSession.lookupAsync(name(\"a.b.\"), A, IN).toCompletableFuture();",
      "150:     if (mode == IrrelevantRecordMode.THROW) {",
      "151:       assertThatThrownBy(future::get)",
      "152:           .cause()",
      "153:           .isInstanceOf(LookupFailedException.class)",
      "154:           .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE);",
      "155:     } else {",
      "156:       LookupResult result = future.get();",
      "157:       assertThat(result.getAliases()).isEmpty();",
      "158:       assertThat(result.getRecords()).containsExactly(LOOPBACK_A.withName(name(\"a.b.\")));",
      "159:     }",
      "161:     assertCacheUnused(useCache, mode, lookupSession);",
      "162:     verify(mockResolver).sendAsync(any(), any(Executor.class));",
      "163:   }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "160:     when(mockHosts.getAddressForHost(any(), anyInt())).thenThrow(IOException.class);",
      "161:     LookupSession lookupSession =",
      "162:         LookupSession.builder().resolver(mockResolver).hostsFileParser(mockHosts).build();",
      "167:   }",
      "169:   @Test",
      "",
      "[Removed Lines]",
      "163:     CompletionStage<LookupResult> resultFuture =",
      "164:         lookupSession.lookupAsync(name(\"kubernetes.docker.internal.\"), A, IN);",
      "166:     assertThrowsCause(NoSuchDomainException.class, () -> resultFuture.toCompletableFuture().get());",
      "",
      "[Added Lines]",
      "202:     assertThatThrownBy(",
      "203:             lookupSession",
      "204:                     .lookupAsync(name(\"kubernetes.docker.internal.\"), A, IN)",
      "205:                     .toCompletableFuture()",
      "206:                 ::get)",
      "207:         .cause()",
      "208:         .isInstanceOf(NoSuchDomainException.class);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "174:             .resolver(mockResolver)",
      "175:             .hostsFileParser(lookupSessionTestHostsFileParser)",
      "176:             .build();",
      "181:     verify(mockResolver).sendAsync(any(), any(Executor.class));",
      "182:   }",
      "",
      "[Removed Lines]",
      "177:     CompletionStage<LookupResult> resultFuture =",
      "178:         lookupSession.lookupAsync(name(\"kubernetes.docker.internal.\"), MX, IN);",
      "180:     assertThrowsCause(NoSuchDomainException.class, () -> resultFuture.toCompletableFuture().get());",
      "",
      "[Added Lines]",
      "220:     assertThatThrownBy(",
      "221:             lookupSession",
      "222:                     .lookupAsync(name(\"kubernetes.docker.internal.\"), MX, IN)",
      "223:                     .toCompletableFuture()",
      "224:                 ::get)",
      "225:         .cause()",
      "226:         .isInstanceOf(NoSuchDomainException.class);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "355:     when(mockCache.lookupRecords(name(\"host.tld.\"), A, Credibility.NORMAL))",
      "356:         .thenReturn(mock(SetResponse.class));",
      "361:         .thenReturn(singletonList(new RRset(LOOPBACK_A.withName(name(\"another.tld.\")))));",
      "364:     LookupSession lookupSession =",
      "365:         LookupSession.builder()",
      "",
      "[Removed Lines]",
      "358:     SetResponse second = mock(SetResponse.class);",
      "359:     when(second.isSuccessful()).thenReturn(true);",
      "360:     when(second.answers())",
      "362:     when(mockCache.lookupRecords(name(\"another.tld.\"), A, Credibility.NORMAL)).thenReturn(second);",
      "",
      "[Added Lines]",
      "404:     SetResponse anotherTldResponse = mock(SetResponse.class);",
      "405:     when(anotherTldResponse.isSuccessful()).thenReturn(true);",
      "406:     when(anotherTldResponse.answers())",
      "408:     when(mockCache.lookupRecords(name(\"another.tld.\"), A, Credibility.NORMAL))",
      "409:         .thenReturn(anotherTldResponse);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "432:         };",
      "433:     wireUpMockResolver(mockResolver, q -> answer(q, nameToRecord));",
      "440:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"cname.a.\"), A, IN);",
      "442:     LookupResult result = resultFuture.toCompletableFuture().get();",
      "",
      "[Removed Lines]",
      "435:     LookupSession lookupSession =",
      "436:         useCache",
      "437:             ? LookupSession.builder().cache(new Cache()).resolver(mockResolver).build()",
      "438:             : LookupSession.builder().resolver(mockResolver).build();",
      "",
      "[Added Lines]",
      "482:     LookupSession lookupSession = lookupSession(useCache).build();",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "444:     assertEquals(",
      "445:         Stream.of(name(\"cname.a.\"), name(\"cname.b.\")).collect(Collectors.toList()),",
      "446:         result.getAliases());",
      "447:     verify(mockResolver, times(3)).sendAsync(any(), any(Executor.class));",
      "448:   }",
      "458:       throws Exception {",
      "459:     wireUpMockResolver(",
      "460:         mockResolver,",
      "",
      "[Removed Lines]",
      "450:   @ParameterizedTest",
      "451:   @CsvSource({",
      "452:     \"false,false\",",
      "453:     \"true,false\",",
      "454:     \"false,true\",",
      "455:     \"true,true\",",
      "456:   })",
      "457:   void lookupAsync_twoDnameRedirectOneQuery(boolean useCache, boolean includeSyntheticCnames)",
      "",
      "[Added Lines]",
      "490:     if (useCache) {",
      "491:       assertEquals(3, lookupSession.getCache(IN).getSize());",
      "492:     }",
      "496:   @CartesianTest(name = \"useCache={0}, includeSyntheticCnames={1}, irrelevantRecordMode={2}\")",
      "497:   void lookupAsync_twoDnameRedirectOneQuery(",
      "498:       @Values(booleans = {true, false}) boolean useCache,",
      "499:       @Values(booleans = {true, false}) boolean includeSyntheticCnames,",
      "500:       @Enum IrrelevantRecordMode mode)",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "474:           return answer;",
      "475:         });",
      "482:     CompletionStage<LookupResult> resultFuture =",
      "483:         lookupSession.lookupAsync(name(\"www.example.org.\"), A, IN);",
      "",
      "[Removed Lines]",
      "477:     LookupSession lookupSession =",
      "478:         useCache",
      "479:             ? LookupSession.builder().cache(new Cache()).resolver(mockResolver).build()",
      "480:             : LookupSession.builder().resolver(mockResolver).build();",
      "",
      "[Added Lines]",
      "520:     LookupSession lookupSession = lookupSession(useCache).irrelevantRecordMode(mode).build();",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "488:         Stream.of(name(\"www.example.org.\"), name(\"www.example.net.\"), name(\"www.example.com.\"))",
      "489:             .collect(Collectors.toList()),",
      "490:         result.getAliases());",
      "491:     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));",
      "492:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "530:     if (useCache) {",
      "531:       assertEquals(4 + (includeSyntheticCnames ? 2 : 0), lookupSession.getCache(IN).getSize());",
      "532:     }",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "505:           return answer;",
      "506:         });",
      "513:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"cname.a.\"), A, IN);",
      "515:     LookupResult result = resultFuture.toCompletableFuture().get();",
      "",
      "[Removed Lines]",
      "508:     LookupSession lookupSession =",
      "509:         useCache",
      "510:             ? LookupSession.builder().cache(new Cache()).resolver(mockResolver).build()",
      "511:             : LookupSession.builder().resolver(mockResolver).build();",
      "",
      "[Added Lines]",
      "550:     LookupSession lookupSession = lookupSession(useCache).build();",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "545:           return answer;",
      "546:         });",
      "553:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"cname.a.\"), A, IN);",
      "555:     LookupResult result = resultFuture.toCompletableFuture().get();",
      "",
      "[Removed Lines]",
      "548:     LookupSession lookupSession =",
      "549:         useCache",
      "550:             ? LookupSession.builder().cache(new Cache()).resolver(mockResolver).build()",
      "551:             : LookupSession.builder().resolver(mockResolver).build();",
      "",
      "[Added Lines]",
      "586:     LookupSession lookupSession = lookupSession(useCache).build();",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "557:     assertEquals(",
      "558:         Stream.of(name(\"cname.a.\"), name(\"cname.b.\")).collect(Collectors.toList()),",
      "559:         result.getAliases());",
      "560:     verify(mockResolver, times(2)).sendAsync(any(), any(Executor.class));",
      "561:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "594:     if (useCache) {",
      "595:       assertEquals(3, lookupSession.getCache(IN).getSize());",
      "596:     }",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "601:           }",
      "602:         });",
      "613:     if (rcode.equals(\"NXDOMAIN\")) {",
      "615:     } else {",
      "616:       LookupResult result = future.get();",
      "618:     }",
      "619:     verify(mockResolver, times(2)).sendAsync(any(), any(Executor.class));",
      "620:   }",
      "622:   @Test",
      "623:   void lookupAsync_simpleCnameRedirect() throws Exception {",
      "624:     Function<Name, Record> nameToRecord =",
      "626:     wireUpMockResolver(mockResolver, q -> answer(q, nameToRecord));",
      "628:     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();",
      "632:     LookupResult result = resultFuture.toCompletableFuture().get();",
      "633:     assertEquals(singletonList(LOOPBACK_A.withName(name(\"a.b.\"))), result.getRecords());",
      "635:     verify(mockResolver, times(2)).sendAsync(any(), any(Executor.class));",
      "636:   }",
      "",
      "[Removed Lines]",
      "604:     LookupSession lookupSession =",
      "605:         useCache",
      "606:             ? LookupSession.builder().cache(new Cache()).resolver(mockResolver).build()",
      "607:             : LookupSession.builder().resolver(mockResolver).build();",
      "609:     CompletionStage<LookupResult> resultFuture =",
      "610:         lookupSession.lookupAsync(name(\"cname.r.\"), Type.value(type), IN);",
      "612:     CompletableFuture<LookupResult> future = resultFuture.toCompletableFuture();",
      "614:       assertThrowsCause(NoSuchDomainException.class, future::get);",
      "617:       assertEquals(0, result.getRecords().size());",
      "625:         name -> name(\"cname.r.\").equals(name) ? cname(\"cname.r.\", \"a.b.\") : LOOPBACK_A;",
      "630:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"cname.r.\"), A, IN);",
      "634:     assertEquals(singletonList(name(\"cname.r.\")), result.getAliases());",
      "",
      "[Added Lines]",
      "641:     LookupSession lookupSession = lookupSession(useCache).build();",
      "642:     CompletableFuture<LookupResult> future =",
      "643:         lookupSession.lookupAsync(name(\"cname.r.\"), Type.value(type), IN).toCompletableFuture();",
      "646:       assertThatThrownBy(future::get).cause().isInstanceOf(NoSuchDomainException.class);",
      "649:       assertThat(result.getRecords()).isEmpty();",
      "656:     Name cname = name(\"cname.r.\");",
      "657:     Name target = name(\"a.b.\");",
      "659:         name -> cname.equals(name) ? cname(cname, target) : LOOPBACK_A;",
      "664:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(cname, A, IN);",
      "668:     assertEquals(singletonList(cname), result.getAliases());",
      "669:     verify(mockResolver, times(2)).sendAsync(any(), any(Executor.class));",
      "670:   }",
      "672:   @ParameterizedTest",
      "673:   @EnumSource(value = IrrelevantRecordMode.class)",
      "674:   void lookupAsync_simpleCnameRedirectNoExtra(IrrelevantRecordMode mode)",
      "675:       throws ExecutionException, InterruptedException {",
      "676:     Name query = name(\"cname.r.\");",
      "677:     Name target = name(\"a.b.\");",
      "678:     Function<Name, Record[]> nameToRecord =",
      "679:         name ->",
      "680:             query.equals(name)",
      "681:                 ? new Record[] {cname(query, target)}",
      "682:                 : new Record[] {",
      "683:                   LOOPBACK_A, EXAMPLE_A,",
      "684:                 };",
      "685:     wireUpMockResolver(mockResolver, q -> multiAnswer(q, nameToRecord));",
      "687:     LookupSession lookupSession =",
      "688:         LookupSession.builder().resolver(mockResolver).irrelevantRecordMode(mode).build();",
      "690:     CompletableFuture<LookupResult> f =",
      "691:         lookupSession.lookupAsync(query, A, IN).toCompletableFuture();",
      "692:     if (mode == IrrelevantRecordMode.REMOVE) {",
      "693:       LookupResult result = f.get();",
      "694:       assertThat(result.getRecords()).hasSize(1).containsExactly(LOOPBACK_A.withName(target));",
      "695:     } else {",
      "696:       assertThatThrownBy(f::get)",
      "697:           .cause()",
      "698:           .isInstanceOf(LookupFailedException.class)",
      "699:           .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE)",
      "700:           .rootCause()",
      "701:           .isInstanceOf(WireParseException.class);",
      "702:     }",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "652:     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));",
      "653:   }",
      "655:   @Test",
      "656:   void lookupAsync_simpleDnameRedirect() throws Exception {",
      "657:     Function<Name, Record> nameToRecord =",
      "659:     wireUpMockResolver(mockResolver, q -> answer(q, nameToRecord));",
      "661:     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();",
      "666:     LookupResult result = resultFuture.toCompletableFuture().get();",
      "667:     assertEquals(singletonList(LOOPBACK_A.withName(name(\"x.y.to.a.\"))), result.getRecords());",
      "",
      "[Removed Lines]",
      "658:         n -> name(\"x.y.to.dname.\").equals(n) ? dname(\"to.dname.\", \"to.a.\") : LOOPBACK_A;",
      "663:     CompletionStage<LookupResult> resultFuture =",
      "664:         lookupSession.lookupAsync(name(\"x.y.to.dname.\"), A, IN);",
      "",
      "[Added Lines]",
      "724:   @Test",
      "725:   void lookupAsync_dnameQuery() throws Exception {",
      "726:     Name query = name(\"dname.r.\");",
      "727:     DNAMERecord response = dname(query, \"a.b.\");",
      "728:     Function<Name, Record> nameToRecord = name -> name.equals(query) ? response : LOOPBACK_A;",
      "729:     wireUpMockResolver(mockResolver, q -> answer(q, nameToRecord));",
      "731:     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();",
      "733:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(query, DNAME, IN);",
      "735:     LookupResult result = resultFuture.toCompletableFuture().get();",
      "736:     assertEquals(singletonList(response), result.getRecords());",
      "737:     assertEquals(emptyList(), result.getAliases());",
      "738:     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));",
      "739:   }",
      "741:   @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")",
      "742:   void lookupAsync_cnameQueryExtra(",
      "743:       @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)",
      "744:       throws ExecutionException, InterruptedException {",
      "745:     Name query = name(\"cname.r.\");",
      "746:     Name target = name(\"a.b.\");",
      "747:     CNAMERecord response1 = cname(query, target);",
      "748:     CNAMERecord response2 = cname(name(\"additional.r.\"), target);",
      "749:     Function<Name, Record[]> nameToRecord =",
      "750:         name ->",
      "751:             query.equals(name) ? new Record[] {response1, response2} : new Record[] {LOOPBACK_A};",
      "752:     wireUpMockResolver(mockResolver, q -> multiAnswer(q, nameToRecord));",
      "754:     LookupSession lookupSession = lookupSession(useCache, mode).build();",
      "755:     CompletableFuture<LookupResult> future =",
      "756:         lookupSession.lookupAsync(query, CNAME, IN).toCompletableFuture();",
      "757:     if (mode == IrrelevantRecordMode.THROW) {",
      "758:       assertThatThrownBy(future::get)",
      "759:           .cause()",
      "760:           .isInstanceOf(LookupFailedException.class)",
      "761:           .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE);",
      "762:     } else {",
      "763:       LookupResult result = future.get();",
      "764:       assertThat(result.getAliases()).isEmpty();",
      "765:       assertThat(result.getRecords()).containsExactly(cname(query, target));",
      "766:     }",
      "768:     assertCacheUnused(useCache, mode, lookupSession);",
      "769:     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));",
      "770:   }",
      "772:   @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")",
      "773:   void lookupAsync_dnameQueryExtra(",
      "774:       @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)",
      "775:       throws ExecutionException, InterruptedException {",
      "776:     Name query = name(\"cname.r.\");",
      "777:     Name target = name(\"a.b.\");",
      "778:     DNAMERecord response1 = dname(query, target);",
      "779:     DNAMERecord response2 = dname(name(\"additional.r.\"), target);",
      "780:     Function<Name, Record[]> nameToRecord =",
      "781:         name ->",
      "782:             query.equals(name) ? new Record[] {response1, response2} : new Record[] {LOOPBACK_A};",
      "783:     wireUpMockResolver(mockResolver, q -> multiAnswer(q, nameToRecord));",
      "785:     LookupSession lookupSession = lookupSession(useCache, mode).build();",
      "786:     CompletableFuture<LookupResult> future =",
      "787:         lookupSession.lookupAsync(query, DNAME, IN).toCompletableFuture();",
      "788:     if (mode == IrrelevantRecordMode.THROW) {",
      "789:       assertThatThrownBy(future::get)",
      "790:           .cause()",
      "791:           .isInstanceOf(LookupFailedException.class)",
      "792:           .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE);",
      "793:     } else {",
      "794:       LookupResult result = future.get();",
      "795:       assertThat(result.getAliases()).isEmpty();",
      "796:       assertThat(result.getRecords()).containsExactly(response1);",
      "797:     }",
      "799:     assertCacheUnused(useCache, mode, lookupSession);",
      "800:     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));",
      "801:   }",
      "805:     Name query = name(\"x.y.to.dname.\");",
      "807:         name -> name.equals(query) ? dname(\"to.dname.\", \"to.a.\") : LOOPBACK_A;",
      "812:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(query, A, IN);",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "669:   }",
      "671:   @Test",
      "686:   }",
      "688:   @ParameterizedTest",
      "689:   @ValueSource(ints = {3, 4})",
      "690:   void lookupAsync_redirectLoopOneAnswer(int maxRedirects) {",
      "691:     wireUpMockResolver(",
      "",
      "[Removed Lines]",
      "672:   void lookupAsync_redirectLoop() {",
      "673:     Function<Name, Record> nameToRecord =",
      "674:         name -> name(\"a.b.\").equals(name) ? cname(\"a.\", \"b.\") : cname(\"b.\", \"a.\");",
      "675:     wireUpMockResolver(mockResolver, q -> answer(q, nameToRecord));",
      "677:     LookupSession lookupSession =",
      "678:         LookupSession.builder().resolver(mockResolver).maxRedirects(2).build();",
      "680:     CompletionStage<LookupResult> resultFuture =",
      "681:         lookupSession.lookupAsync(name(\"first.example.com.\"), A, IN);",
      "683:     assertThrowsCause(",
      "684:         RedirectOverflowException.class, () -> resultFuture.toCompletableFuture().get());",
      "685:     verify(mockResolver, times(3)).sendAsync(any(), any(Executor.class));",
      "",
      "[Added Lines]",
      "820:   void lookupAsync_simpleDnameRedirectSynthesizedCname() throws Exception {",
      "821:     Name query = name(\"x.y.example.org.\");",
      "822:     wireUpMockResolver(",
      "823:         mockResolver,",
      "824:         q ->",
      "825:             multiAnswer(",
      "826:                 q,",
      "827:                 name ->",
      "828:                     new Record[] {",
      "829:                       dname(\"example.org.\", \"example.net.\"),",
      "830:                       cname(\"x.y.example.org.\", \"x.y.example.net.\"),",
      "831:                       LOOPBACK_A.withName(name(\"x.y.example.net.\")),",
      "832:                     }));",
      "834:     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();",
      "836:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(query, A, IN);",
      "838:     LookupResult result = resultFuture.toCompletableFuture().get();",
      "839:     assertEquals(singletonList(LOOPBACK_A.withName(name(\"x.y.example.net.\"))), result.getRecords());",
      "840:     assertEquals(singletonList(name(\"x.y.example.org.\")), result.getAliases());",
      "841:     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));",
      "845:   @CsvSource(",
      "846:       value = {",
      "847:         \"x.y.example.com.,x.y.example.org.,REMOVE\",",
      "848:         \"x.y.example.com.,x.y.example.org.,THROW\",",
      "849:         \"x.y.example.org.,x.y.example.com.,REMOVE\",",
      "850:         \"x.y.example.org.,x.y.example.com.,THROW\",",
      "851:       })",
      "852:   void lookupAsync_simpleDnameRedirectWrongSynthesizedCname(",
      "853:       String from, String to, IrrelevantRecordMode mode)",
      "854:       throws ExecutionException, InterruptedException {",
      "855:     Name query = name(\"x.y.example.org.\");",
      "856:     wireUpMockResolver(",
      "857:         mockResolver,",
      "858:         q ->",
      "859:             multiAnswer(",
      "860:                 q,",
      "861:                 name ->",
      "862:                     new Record[] {",
      "864:                       dname(\"example.org.\", \"example.net.\"),",
      "866:                       cname(from, to),",
      "868:                       LOOPBACK_A.withName(name(\"x.y.example.net.\")),",
      "870:                       LOOPBACK_A.withName(name(to)),",
      "871:                     }));",
      "873:     LookupSession lookupSession =",
      "874:         LookupSession.builder().resolver(mockResolver).irrelevantRecordMode(mode).build();",
      "876:     CompletableFuture<LookupResult> future =",
      "877:         lookupSession.lookupAsync(query, A, IN).toCompletableFuture();",
      "878:     if (mode == IrrelevantRecordMode.THROW) {",
      "879:       assertThatThrownBy(future::get)",
      "880:           .cause()",
      "881:           .isInstanceOf(LookupFailedException.class)",
      "882:           .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE);",
      "883:     } else {",
      "884:       LookupResult result = future.get();",
      "885:       assertThat(result.getAliases()).containsExactly(name(\"x.y.example.org.\"));",
      "886:       assertThat(result.getRecords())",
      "887:           .containsExactly(LOOPBACK_A.withName(name(\"x.y.example.net.\")));",
      "888:     }",
      "889:     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));",
      "890:   }",
      "892:   @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")",
      "893:   void lookupAsync_simpleDnameRedirectNoExtra(",
      "894:       @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)",
      "895:       throws ExecutionException, InterruptedException {",
      "896:     Name queryName = name(\"x.y.to.dname.\");",
      "897:     wireUpMockResolver(",
      "898:         mockResolver,",
      "899:         question ->",
      "900:             multiAnswer(",
      "901:                 question,",
      "902:                 name ->",
      "903:                     name.equals(queryName)",
      "904:                         ? new Record[] {dname(\"to.dname.\", \"to.a.\")}",
      "905:                         : new Record[] {",
      "907:                           LOOPBACK_A, EXAMPLE_A,",
      "908:                         }));",
      "910:     LookupSession lookupSession = lookupSession(useCache, mode).build();",
      "911:     CompletableFuture<LookupResult> future =",
      "912:         lookupSession.lookupAsync(queryName, A, IN).toCompletableFuture();",
      "913:     if (mode == IrrelevantRecordMode.THROW) {",
      "914:       assertThatThrownBy(future::get)",
      "915:           .cause()",
      "916:           .isInstanceOf(LookupFailedException.class)",
      "917:           .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE);",
      "918:     } else {",
      "919:       LookupResult result = future.get();",
      "920:       assertAll(",
      "921:           () -> {",
      "922:             assertThat(result.getAliases()).containsExactly(name(\"x.y.to.dname.\"));",
      "923:             assertThat(result.getRecords()).containsExactly(LOOPBACK_A.withName(name(\"x.y.to.a.\")));",
      "924:           });",
      "925:     }",
      "927:     if (useCache && mode == IrrelevantRecordMode.THROW) {",
      "929:       Cache cache = lookupSession.getCache(IN);",
      "930:       verify(cache, times(1)).addMessage(any(Message.class));",
      "931:       assertEquals(1, cache.getSize());",
      "932:       assertTrue(cache.lookupRecords(name(\"example.com.\"), A, Credibility.NORMAL).isUnknown());",
      "933:     }",
      "935:     verify(mockResolver, times(2)).sendAsync(any(), any(Executor.class));",
      "936:   }",
      "938:   @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")",
      "939:   void lookupAsync_simpleCnameWrongInitial(",
      "940:       @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)",
      "941:       throws ExecutionException, InterruptedException {",
      "942:     Name query = name(\"first.example.com.\");",
      "943:     wireUpMockResolver(mockResolver, q -> answer(q, name -> cname(\"a.\", \"b.\")));",
      "945:     LookupSession lookupSession = lookupSession(useCache).irrelevantRecordMode(mode).build();",
      "946:     CompletableFuture<LookupResult> future =",
      "947:         lookupSession.lookupAsync(query, A, IN).toCompletableFuture();",
      "948:     if (mode == IrrelevantRecordMode.THROW) {",
      "949:       assertThatThrownBy(future::get)",
      "950:           .cause()",
      "951:           .isInstanceOf(LookupFailedException.class)",
      "952:           .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE);",
      "953:     } else {",
      "954:       LookupResult result = future.get();",
      "955:       assertThat(result.getAliases()).isEmpty();",
      "956:       assertThat(result.getRecords()).isEmpty();",
      "957:     }",
      "959:     assertCacheUnused(useCache, mode, lookupSession);",
      "961:     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));",
      "962:   }",
      "964:   @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")",
      "965:   void lookupAsync_simpleDnameWrongInitial(",
      "966:       @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)",
      "967:       throws ExecutionException, InterruptedException {",
      "968:     Name query = name(\"first.example.com.\");",
      "969:     wireUpMockResolver(mockResolver, q -> answer(q, name -> dname(\"a.\", \"b.\")));",
      "971:     LookupSession lookupSession =",
      "972:         lookupSession(useCache, mode == IrrelevantRecordMode.THROW)",
      "973:             .irrelevantRecordMode(mode)",
      "974:             .build();",
      "976:     CompletableFuture<LookupResult> future =",
      "977:         lookupSession.lookupAsync(query, A, IN).toCompletableFuture();",
      "978:     if (mode == IrrelevantRecordMode.THROW) {",
      "979:       assertThatThrownBy(future::get)",
      "980:           .cause()",
      "981:           .isInstanceOf(LookupFailedException.class)",
      "982:           .hasMessageContaining(INVALID_SERVER_RESPONSE_MESSAGE);",
      "983:     } else {",
      "984:       LookupResult result = future.get();",
      "985:       assertThat(result.getAliases()).isEmpty();",
      "986:       assertThat(result.getRecords()).isEmpty();",
      "987:     }",
      "989:     assertCacheUnused(useCache, mode, lookupSession);",
      "990:     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));",
      "991:   }",
      "993:   private static void assertCacheUnused(",
      "994:       boolean useCache, IrrelevantRecordMode mode, LookupSession lookupSession) {",
      "995:     if (useCache && mode == IrrelevantRecordMode.THROW) {",
      "997:       Cache cache = lookupSession.getCache(IN);",
      "998:       verify(cache, times(0)).addMessage(any(Message.class));",
      "999:       assertEquals(0, cache.getSize());",
      "1000:     }",
      "1001:   }",
      "1003:   @CartesianTest(name = \"maxRedirects={0}, irrelevantRecordMode={1}\")",
      "1004:   void lookupAsync_redirectLoop(",
      "1005:       @Values(ints = {3, 4}) int maxRedirects, @Enum IrrelevantRecordMode mode) {",
      "1006:     CNAMERecord cnameA = cname(\"a.\", \"b.\");",
      "1007:     CNAMERecord cnameB = cname(\"b.\", \"c.\");",
      "1008:     CNAMERecord cnameC = cname(\"c.\", \"d.\");",
      "1009:     CNAMERecord cnameD = cname(\"d.\", \"a.\");",
      "1010:     Function<Name, Record> nameToRecord =",
      "1011:         name -> {",
      "1012:           if (name.equals(cnameA.getName())) {",
      "1013:             return cnameA;",
      "1014:           } else if (name.equals(cnameB.getName())) {",
      "1015:             return cnameB;",
      "1016:           } else if (name.equals(cnameC.getName())) {",
      "1017:             return cnameC;",
      "1018:           } else if (name.equals(cnameD.getName())) {",
      "1019:             return cnameD;",
      "1020:           } else {",
      "1021:             throw new RuntimeException(\"Unexpected query\");",
      "1022:           }",
      "1023:         };",
      "1024:     wireUpMockResolver(mockResolver, q -> answer(q, nameToRecord));",
      "1025:     LookupSession lookupSession =",
      "1026:         LookupSession.builder()",
      "1027:             .maxRedirects(maxRedirects)",
      "1028:             .resolver(mockResolver)",
      "1029:             .irrelevantRecordMode(mode)",
      "1030:             .build();",
      "1032:     Class<? extends Throwable> expected =",
      "1033:         maxRedirects == 3 ? RedirectOverflowException.class : RedirectLoopException.class;",
      "1034:     assertThatThrownBy(",
      "1035:             lookupSession.lookupAsync(cnameA.getName(), A, IN).toCompletableFuture()::get)",
      "1036:         .cause()",
      "1037:         .isInstanceOf(expected);",
      "1038:     verify(mockResolver, times(maxRedirects)).sendAsync(any(), any(Executor.class));",
      "1039:   }",
      "1041:   @ParameterizedTest(name = \"maxRedirects={0}\")",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "703:     LookupSession lookupSession =",
      "704:         LookupSession.builder().resolver(mockResolver).maxRedirects(maxRedirects).build();",
      "710:     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));",
      "711:   }",
      "",
      "[Removed Lines]",
      "706:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"a.\"), A, IN);",
      "708:     assertThrowsCause(",
      "709:         RedirectOverflowException.class, () -> resultFuture.toCompletableFuture().get());",
      "",
      "[Added Lines]",
      "1059:     Class<? extends Throwable> expected =",
      "1060:         maxRedirects == 3 ? RedirectOverflowException.class : RedirectLoopException.class;",
      "1061:     assertThatThrownBy(lookupSession.lookupAsync(name(\"a.\"), A, IN).toCompletableFuture()::get)",
      "1062:         .cause()",
      "1063:         .isInstanceOf(expected);",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "718:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"a.b.\"), A, IN);",
      "720:     LookupResult result = resultFuture.toCompletableFuture().get();",
      "722:     verify(mockResolver).sendAsync(any(), any(Executor.class));",
      "723:   }",
      "",
      "[Removed Lines]",
      "721:     assertEquals(0, result.getRecords().size());",
      "",
      "[Added Lines]",
      "1075:     assertThat(result.getRecords()).isEmpty();",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "727:     wireUpMockResolver(mockResolver, q -> fail(q, Rcode.NXDOMAIN));",
      "729:     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();",
      "733:     verify(mockResolver).sendAsync(any(), any(Executor.class));",
      "734:   }",
      "",
      "[Removed Lines]",
      "730:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"a.b.\"), A, IN);",
      "732:     assertThrowsCause(NoSuchDomainException.class, () -> resultFuture.toCompletableFuture().get());",
      "",
      "[Added Lines]",
      "1084:     assertThatThrownBy(lookupSession.lookupAsync(name(\"a.b.\"), A, IN).toCompletableFuture()::get)",
      "1085:         .cause()",
      "1086:         .isInstanceOf(NoSuchDomainException.class);",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "738:     wireUpMockResolver(mockResolver, q -> fail(q, Rcode.SERVFAIL));",
      "740:     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();",
      "744:     verify(mockResolver).sendAsync(any(), any(Executor.class));",
      "745:   }",
      "",
      "[Removed Lines]",
      "741:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"a.b.\"), A, IN);",
      "743:     assertThrowsCause(ServerFailedException.class, () -> resultFuture.toCompletableFuture().get());",
      "",
      "[Added Lines]",
      "1095:     assertThatThrownBy(lookupSession.lookupAsync(name(\"a.b.\"), A, IN).toCompletableFuture()::get)",
      "1096:         .cause()",
      "1097:         .isInstanceOf(ServerFailedException.class);",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "749:     wireUpMockResolver(mockResolver, q -> fail(q, Rcode.NOTIMP));",
      "751:     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();",
      "755:     verify(mockResolver).sendAsync(any(), any(Executor.class));",
      "756:   }",
      "",
      "[Removed Lines]",
      "752:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"a.b.\"), A, IN);",
      "754:     assertThrowsCause(LookupFailedException.class, () -> resultFuture.toCompletableFuture().get());",
      "",
      "[Added Lines]",
      "1106:     assertThatThrownBy(lookupSession.lookupAsync(name(\"a.b.\"), A, IN).toCompletableFuture()::get)",
      "1107:         .cause()",
      "1108:         .isInstanceOf(LookupFailedException.class);",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "760:     wireUpMockResolver(mockResolver, q -> fail(q, Rcode.NXRRSET));",
      "762:     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();",
      "766:     verify(mockResolver).sendAsync(any(), any(Executor.class));",
      "767:   }",
      "",
      "[Removed Lines]",
      "763:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"a.b.\"), A, IN);",
      "765:     assertThrowsCause(NoSuchRRSetException.class, () -> resultFuture.toCompletableFuture().get());",
      "",
      "[Added Lines]",
      "1117:     assertThatThrownBy(lookupSession.lookupAsync(name(\"a.b.\"), A, IN).toCompletableFuture()::get)",
      "1118:         .cause()",
      "1119:         .isInstanceOf(NoSuchRRSetException.class);",
      "",
      "---------------",
      "--- Hunk 26 ---",
      "[Context before]",
      "774:     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();",
      "775:     Name toLookup = name(format(\"%s.%s.%s.to.dname.\", LONG_LABEL, LONG_LABEL, LONG_LABEL));",
      "780:     verify(mockResolver).sendAsync(any(), any(Executor.class));",
      "781:   }",
      "783:   @Test",
      "789:     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();",
      "806:   }",
      "808:   @Test",
      "",
      "[Removed Lines]",
      "776:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(toLookup, A, IN);",
      "778:     assertThrowsCause(",
      "779:         InvalidZoneDataException.class, () -> resultFuture.toCompletableFuture().get());",
      "784:   void lookupAsync_MultipleCNAMEs() {",
      "787:     wireUpMockResolver(mockResolver, LookupSessionTest::multipleCNAMEs);",
      "790:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(name(\"a.b.\"), A, IN);",
      "792:     assertThrowsCause(",
      "793:         InvalidZoneDataException.class, () -> resultFuture.toCompletableFuture().get());",
      "794:     verify(mockResolver).sendAsync(any(), any(Executor.class));",
      "795:   }",
      "797:   private static Message multipleCNAMEs(Message query) {",
      "798:     Message answer = new Message(query.getHeader().getID());",
      "799:     Record question = query.getQuestion();",
      "800:     answer.addRecord(question, Section.QUESTION);",
      "801:     answer.addRecord(",
      "802:         new CNAMERecord(question.getName(), CNAME, IN, name(\"target1.\")), Section.ANSWER);",
      "803:     answer.addRecord(",
      "804:         new CNAMERecord(question.getName(), CNAME, IN, name(\"target2.\")), Section.ANSWER);",
      "805:     return answer;",
      "",
      "[Added Lines]",
      "1130:     assertThatThrownBy(lookupSession.lookupAsync(toLookup, A, IN).toCompletableFuture()::get)",
      "1131:         .cause()",
      "1132:         .isInstanceOf(InvalidZoneDataException.class);",
      "1137:   void lookupAsync_MultipleCNAMEs() throws ExecutionException, InterruptedException {",
      "1138:     Record testQuestion = Record.newRecord(name(\"a.b.\"), A, IN);",
      "1141:     wireUpMockResolver(",
      "1142:         mockResolver,",
      "1143:         query -> {",
      "1144:           Message answer = new Message(query.getHeader().getID());",
      "1145:           answer.addRecord(testQuestion, Section.QUESTION);",
      "1146:           answer.addRecord(cname(testQuestion.getName(), \"target1.\"), Section.ANSWER);",
      "1147:           answer.addRecord(cname(testQuestion.getName(), \"target2.\"), Section.ANSWER);",
      "1148:           return answer;",
      "1149:         });",
      "1152:     LookupResult result = lookupSession.lookupAsync(testQuestion).toCompletableFuture().get();",
      "1154:     assertTrue(result.getRecords().isEmpty());",
      "1155:     assertThat(result.getAliases()).containsExactly(testQuestion.getName());",
      "1158:     verify(mockResolver, times(2)).sendAsync(any(), any(Executor.class));",
      "",
      "---------------",
      "--- Hunk 27 ---",
      "[Context before]",
      "821:     ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);",
      "822:     verify(mockResolver).sendAsync(messageCaptor.capture(), any(Executor.class));",
      "830:   }",
      "832:   @Test",
      "",
      "[Removed Lines]",
      "824:     assertEquals(",
      "825:         Record.newRecord(name(\"host.example.com.\"), Type.A, DClass.IN, 0L),",
      "826:         messageCaptor.getValue().getSection(Section.QUESTION).get(0));",
      "828:     assertEquals(",
      "829:         singletonList(LOOPBACK_A.withName(name(\"host.example.com.\"))), lookupResult.getRecords());",
      "",
      "[Added Lines]",
      "1177:     assertThat(messageCaptor.getValue().getSection(Section.QUESTION))",
      "1178:         .containsExactly(Record.newRecord(name(\"host.example.com.\"), Type.A, DClass.IN, 0L));",
      "1180:     assertThat(lookupResult.getRecords())",
      "1181:         .containsExactly(LOOPBACK_A.withName(name(\"host.example.com.\")));",
      "",
      "---------------",
      "--- Hunk 28 ---",
      "[Context before]",
      "999:   }",
      "1001:   private static CNAMERecord cname(String name, String target) {",
      "1003:   }",
      "1005:   private static CNAMERecord cname(Name name, String target) {",
      "1007:   }",
      "1010:   private static DNAMERecord dname(String name, String target) {",
      "1012:   }",
      "1014:   private static Name name(String name) {",
      "1015:     return Name.fromConstantString(name);",
      "1016:   }",
      "1022:   }",
      "1024:   private void wireUpMockResolver(Resolver mockResolver, Function<Message, Message> handler) {",
      "",
      "[Removed Lines]",
      "1002:     return cname(name(name), target);",
      "1006:     return new CNAMERecord(name, IN, 0, name(target));",
      "1009:   @SuppressWarnings(\"SameParameterValue\")",
      "1011:     return new DNAMERecord(name(name), IN, 0, name(target));",
      "1018:   @SuppressWarnings(\"SameParameterValue\")",
      "1019:   private <T extends Throwable> void assertThrowsCause(Class<T> ex, Executable executable) {",
      "1020:     Throwable outerException = assertThrows(Throwable.class, executable);",
      "1021:     assertEquals(ex, outerException.getCause().getClass());",
      "",
      "[Added Lines]",
      "1354:     return cname(name(name), name(target));",
      "1357:   @SuppressWarnings(\"SameParameterValue\")",
      "1359:     return cname(name, name(target));",
      "1360:   }",
      "1362:   private static CNAMERecord cname(Name name, Name target) {",
      "1363:     return new CNAMERecord(name, IN, 120, target);",
      "1367:     return dname(name(name), name(target));",
      "1368:   }",
      "1370:   @SuppressWarnings(\"SameParameterValue\")",
      "1371:   private static DNAMERecord dname(Name name, String target) {",
      "1372:     return dname(name, name(target));",
      "1373:   }",
      "1375:   private static DNAMERecord dname(Name name, Name target) {",
      "1376:     return new DNAMERecord(name, IN, 120, target);",
      "1383:   private LookupSession.LookupSessionBuilder lookupSession(boolean useCache) {",
      "1384:     return lookupSession(useCache, false);",
      "1385:   }",
      "1387:   private LookupSession.LookupSessionBuilder lookupSession(",
      "1388:       boolean useCache, IrrelevantRecordMode mode) {",
      "1389:     return lookupSession(useCache, mode, false);",
      "1390:   }",
      "1392:   private LookupSession.LookupSessionBuilder lookupSession(boolean useCache, boolean throwOnUse) {",
      "1393:     return lookupSession(useCache, IrrelevantRecordMode.REMOVE, throwOnUse);",
      "1394:   }",
      "1396:   private LookupSession.LookupSessionBuilder lookupSession(",
      "1397:       boolean useCache, IrrelevantRecordMode mode, boolean throwOnUse) {",
      "1398:     LookupSession.LookupSessionBuilder builder =",
      "1399:         LookupSession.builder().resolver(mockResolver).irrelevantRecordMode(mode);",
      "1400:     if (useCache) {",
      "1401:       Cache cache = spy(new Cache());",
      "1402:       builder.cache(cache);",
      "1403:       if (throwOnUse) {",
      "1404:         lenient()",
      "1405:             .doThrow(new RuntimeException(\"Unexpected addMessage\"))",
      "1406:             .when(cache)",
      "1407:             .addMessage(any(Message.class));",
      "1408:         lenient()",
      "1409:             .doThrow(new RuntimeException(\"Unexpected addRecord\"))",
      "1410:             .when(cache)",
      "1411:             .addRecord(any(Record.class), anyInt());",
      "1412:       }",
      "1413:     }",
      "1415:     return builder;",
      "",
      "---------------"
    ],
    "src/test/resources/unbound/val_adcopy.rpl||src/test/resources/unbound/val_adcopy.rpl": [
      "File: src/test/resources/unbound/val_adcopy.rpl -> src/test/resources/unbound/val_adcopy.rpl",
      "--- Hunk 1 ---",
      "[Context before]",
      "18: ; K.ROOT-SERVERS.NET.",
      "19: RANGE_BEGIN 0 100",
      "21: ENTRY_BEGIN",
      "22: MATCH opcode qtype qname",
      "23: ADJUST copy_id",
      "",
      "[Removed Lines]",
      "20:  ADDRESS 193.0.14.129",
      "",
      "[Added Lines]",
      "20:  ADDRESS 193.0.14.129",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "115: www.example.com. IN A",
      "116: SECTION ANSWER",
      "117: www.example.com. IN A 10.20.30.40",
      "119: SECTION AUTHORITY",
      "120: example.com. IN NS ns.example.com.",
      "121: example.com.    3600    IN      RRSIG   NS 3 2 3600 20070926134150 20070829134150 2854 example.com. MC0CFQCN+qHdJxoI/2tNKwsb08pra/G7aAIUAWA5sDdJTbrXA1/3OaesGBAO3sI= ;{id = 2854}",
      "122: SECTION ADDITIONAL",
      "123: ns.example.com.  IN  A 1.2.3.4",
      "125: ENTRY_END",
      "126: RANGE_END",
      "",
      "[Removed Lines]",
      "118: ns.example.com. 3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFQCQMyTjn7WWwpwAR1LlVeLpRgZGuQIUCcJDEkwAuzytTDRlYK7nIMwH1CM= ;{id = 2854}",
      "124: www.example.com.        3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFC99iE9K5y2WNgI0gFvBWaTi9wm6AhUAoUqOpDtG5Zct+Qr9F3mSdnbc6V4= ;{id = 2854}",
      "",
      "[Added Lines]",
      "118: www.example.com.        3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFC99iE9K5y2WNgI0gFvBWaTi9wm6AhUAoUqOpDtG5Zct+Qr9F3mSdnbc6V4= ;{id = 2854}",
      "124: ns.example.com. 3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFQCQMyTjn7WWwpwAR1LlVeLpRgZGuQIUCcJDEkwAuzytTDRlYK7nIMwH1CM= ;{id = 2854}",
      "",
      "---------------"
    ],
    "src/test/resources/unbound/val_unalgo_anchor.rpl||src/test/resources/unbound/val_unalgo_anchor.rpl": [
      "File: src/test/resources/unbound/val_unalgo_anchor.rpl -> src/test/resources/unbound/val_unalgo_anchor.rpl",
      "--- Hunk 1 ---",
      "[Context before]",
      "13:  stub-addr: 193.0.14.129  # K.ROOT-SERVERS.NET.",
      "14: CONFIG_END",
      "18: ; K.ROOT-SERVERS.NET.",
      "19: RANGE_BEGIN 0 100",
      "21: ENTRY_BEGIN",
      "22: MATCH opcode qtype qname",
      "23: ADJUST copy_id",
      "",
      "[Removed Lines]",
      "16: SCENARIO_BEGIN Test validator with unsupported algorithm trust anchor",
      "20:  ADDRESS 193.0.14.129",
      "",
      "[Added Lines]",
      "16: SCENARIO_BEGIN Test validator with unsupported algorithm trust anchor",
      "20:  ADDRESS 193.0.14.129",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "115: www.example.com. IN A",
      "116: SECTION ANSWER",
      "117: www.example.com. IN A 10.20.30.40",
      "119: SECTION AUTHORITY",
      "120: example.com. IN NS ns.example.com.",
      "121: example.com.    3600    IN      RRSIG   NS 3 2 3600 20070926134150 20070829134150 2854 example.com. MC0CFQCN+qHdJxoI/2tNKwsb08pra/G7aAIUAWA5sDdJTbrXA1/3OaesGBAO3sI= ;{id = 2854}",
      "122: SECTION ADDITIONAL",
      "123: ns.example.com.  IN  A 1.2.3.4",
      "125: ENTRY_END",
      "126: RANGE_END",
      "",
      "[Removed Lines]",
      "118: ns.example.com. 3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFQCQMyTjn7WWwpwAR1LlVeLpRgZGuQIUCcJDEkwAuzytTDRlYK7nIMwH1CM= ;{id = 2854}",
      "124: www.example.com.        3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFC99iE9K5y2WNgI0gFvBWaTi9wm6AhUAoUqOpDtG5Zct+Qr9F3mSdnbc6V4= ;{id = 2854}",
      "",
      "[Added Lines]",
      "118: www.example.com.        3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFC99iE9K5y2WNgI0gFvBWaTi9wm6AhUAoUqOpDtG5Zct+Qr9F3mSdnbc6V4= ;{id = 2854}",
      "124: ns.example.com. 3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFQCQMyTjn7WWwpwAR1LlVeLpRgZGuQIUCcJDEkwAuzytTDRlYK7nIMwH1CM= ;{id = 2854}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e6302ef9d580f99f1704e29dfece28aef04e0579",
      "candidate_info": {
        "commit_hash": "e6302ef9d580f99f1704e29dfece28aef04e0579",
        "repo": "dnsjava/dnsjava",
        "commit_url": "https://github.com/dnsjava/dnsjava/commit/e6302ef9d580f99f1704e29dfece28aef04e0579",
        "files": [
          "src/main/java/org/xbill/DNS/Cache.java",
          "src/main/java/org/xbill/DNS/SetResponse.java",
          "src/main/java/org/xbill/DNS/SetResponseType.java",
          "src/main/java/org/xbill/DNS/Zone.java",
          "src/test/java/org/xbill/DNS/SetResponseTest.java"
        ],
        "message": "Remove mix of how SetResponse is constructed",
        "before_after_code_files": [
          "src/main/java/org/xbill/DNS/Cache.java||src/main/java/org/xbill/DNS/Cache.java",
          "src/main/java/org/xbill/DNS/SetResponse.java||src/main/java/org/xbill/DNS/SetResponse.java",
          "src/main/java/org/xbill/DNS/SetResponseType.java||src/main/java/org/xbill/DNS/SetResponseType.java",
          "src/main/java/org/xbill/DNS/Zone.java||src/main/java/org/xbill/DNS/Zone.java",
          "src/test/java/org/xbill/DNS/SetResponseTest.java||src/test/java/org/xbill/DNS/SetResponseTest.java"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/main/java/org/xbill/DNS/Cache.java||src/main/java/org/xbill/DNS/Cache.java",
            "src/main/java/org/xbill/DNS/SetResponse.java||src/main/java/org/xbill/DNS/SetResponse.java",
            "src/main/java/org/xbill/DNS/SetResponseType.java||src/main/java/org/xbill/DNS/SetResponseType.java",
            "src/test/java/org/xbill/DNS/SetResponseTest.java||src/test/java/org/xbill/DNS/SetResponseTest.java"
          ],
          "candidate": [
            "src/main/java/org/xbill/DNS/Cache.java||src/main/java/org/xbill/DNS/Cache.java",
            "src/main/java/org/xbill/DNS/SetResponse.java||src/main/java/org/xbill/DNS/SetResponse.java",
            "src/main/java/org/xbill/DNS/SetResponseType.java||src/main/java/org/xbill/DNS/SetResponseType.java",
            "src/test/java/org/xbill/DNS/SetResponseTest.java||src/test/java/org/xbill/DNS/SetResponseTest.java"
          ]
        }
      },
      "candidate_diff": {
        "src/main/java/org/xbill/DNS/Cache.java||src/main/java/org/xbill/DNS/Cache.java": [
          "File: src/main/java/org/xbill/DNS/Cache.java -> src/main/java/org/xbill/DNS/Cache.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "423:     Element element;",
          "424:     Name tname;",
          "425:     Object types;",
          "428:     labels = name.labels();",
          "",
          "[Removed Lines]",
          "426:     SetResponse sr;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "452:       if (isExact && type == Type.ANY) {",
          "454:         Element[] elements = allElements(types);",
          "455:         int added = 0;",
          "456:         for (Element value : elements) {",
          "457:           element = value;",
          "",
          "[Removed Lines]",
          "453:         sr = new SetResponse(SetResponse.SUCCESSFUL);",
          "",
          "[Added Lines]",
          "453:         SetResponse sr = SetResponse.ofType(SetResponseType.SUCCESSFUL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "475:       } else if (isExact) {",
          "476:         element = oneElement(tname, types, type, minCred);",
          "477:         if (element instanceof CacheRRset) {",
          "481:         } else if (element != null) {",
          "484:         }",
          "486:         element = oneElement(tname, types, Type.CNAME, minCred);",
          "487:         if (element instanceof CacheRRset) {",
          "489:         }",
          "490:       } else {",
          "491:         element = oneElement(tname, types, Type.DNAME, minCred);",
          "492:         if (element instanceof CacheRRset) {",
          "494:         }",
          "495:       }",
          "498:       element = oneElement(tname, types, Type.NS, minCred);",
          "499:       if (element instanceof CacheRRset) {",
          "501:       }",
          "504:       if (isExact) {",
          "505:         element = oneElement(tname, types, 0, minCred);",
          "506:         if (element != null) {",
          "508:         }",
          "509:       }",
          "510:     }",
          "512:   }",
          "",
          "[Removed Lines]",
          "478:           sr = new SetResponse(SetResponse.SUCCESSFUL);",
          "479:           sr.addRRset((CacheRRset) element);",
          "480:           return sr;",
          "482:           sr = new SetResponse(SetResponse.NXRRSET);",
          "483:           return sr;",
          "488:           return new SetResponse(SetResponse.CNAME, (CacheRRset) element);",
          "493:           return new SetResponse(SetResponse.DNAME, (CacheRRset) element);",
          "500:         return new SetResponse(SetResponse.DELEGATION, (CacheRRset) element);",
          "507:           return SetResponse.ofType(SetResponse.NXDOMAIN);",
          "511:     return SetResponse.ofType(SetResponse.UNKNOWN);",
          "",
          "[Added Lines]",
          "477:           return SetResponse.ofType(SetResponseType.SUCCESSFUL, (CacheRRset) element);",
          "479:           return SetResponse.ofType(SetResponseType.NXRRSET);",
          "484:           return SetResponse.ofType(SetResponseType.CNAME, (CacheRRset) element);",
          "489:           return SetResponse.ofType(SetResponseType.DNAME, (CacheRRset) element);",
          "496:         return SetResponse.ofType(SetResponseType.DELEGATION, (CacheRRset) element);",
          "503:           return SetResponse.ofType(SetResponseType.NXDOMAIN);",
          "507:     return SetResponse.ofType(SetResponseType.UNKNOWN);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "642:         completed = true;",
          "643:         if (curname == qname) {",
          "644:           if (response == null) {",
          "646:           }",
          "647:           response.addRRset(answer);",
          "648:         }",
          "",
          "[Removed Lines]",
          "645:             response = new SetResponse(SetResponse.SUCCESSFUL);",
          "",
          "[Added Lines]",
          "641:             response = SetResponse.ofType(SetResponseType.SUCCESSFUL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "651:         CNAMERecord cname;",
          "652:         addRRset(answer, cred);",
          "653:         if (curname == qname) {",
          "655:         }",
          "656:         cname = (CNAMERecord) answer.first();",
          "657:         curname = cname.getTarget();",
          "",
          "[Removed Lines]",
          "654:           response = new SetResponse(SetResponse.CNAME, answer);",
          "",
          "[Added Lines]",
          "650:           response = SetResponse.ofType(SetResponseType.CNAME, answer);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "659:         DNAMERecord dname;",
          "660:         addRRset(answer, cred);",
          "661:         if (curname == qname) {",
          "663:         }",
          "664:         dname = (DNAMERecord) answer.first();",
          "665:         try {",
          "",
          "[Removed Lines]",
          "662:           response = new SetResponse(SetResponse.DNAME, answer);",
          "",
          "[Added Lines]",
          "658:           response = SetResponse.ofType(SetResponseType.DNAME, answer);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "692:         }",
          "693:         addNegative(curname, cachetype, soarec, cred);",
          "694:         if (response == null) {",
          "696:           if (rcode == Rcode.NXDOMAIN) {",
          "698:           } else {",
          "700:           }",
          "701:           response = SetResponse.ofType(responseType);",
          "702:         }",
          "",
          "[Removed Lines]",
          "695:           int responseType;",
          "697:             responseType = SetResponse.NXDOMAIN;",
          "699:             responseType = SetResponse.NXRRSET;",
          "",
          "[Added Lines]",
          "691:           SetResponseType responseType;",
          "693:             responseType = SetResponseType.NXDOMAIN;",
          "695:             responseType = SetResponseType.NXRRSET;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "707:         addRRset(ns, cred);",
          "708:         markAdditional(ns, additionalNames);",
          "709:         if (response == null) {",
          "711:         }",
          "712:       }",
          "713:     } else if (rcode == Rcode.NOERROR && ns != null) {",
          "",
          "[Removed Lines]",
          "710:           response = new SetResponse(SetResponse.DELEGATION, ns);",
          "",
          "[Added Lines]",
          "706:           response = SetResponse.ofType(SetResponseType.DELEGATION, ns);",
          "",
          "---------------"
        ],
        "src/main/java/org/xbill/DNS/SetResponse.java||src/main/java/org/xbill/DNS/SetResponse.java": [
          "File: src/main/java/org/xbill/DNS/SetResponse.java -> src/main/java/org/xbill/DNS/SetResponse.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: package org.xbill.DNS;",
          "6: import java.util.ArrayList;",
          "7: import java.util.List;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: import static org.xbill.DNS.SetResponseType.CNAME;",
          "7: import static org.xbill.DNS.SetResponseType.DELEGATION;",
          "8: import static org.xbill.DNS.SetResponseType.DNAME;",
          "9: import static org.xbill.DNS.SetResponseType.NXDOMAIN;",
          "10: import static org.xbill.DNS.SetResponseType.NXRRSET;",
          "11: import static org.xbill.DNS.SetResponseType.SUCCESSFUL;",
          "12: import static org.xbill.DNS.SetResponseType.UNKNOWN;",
          "16: import lombok.Getter;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "17: public class SetResponse {",
          "59:   private List<RRset> data;",
          "67:     this.type = type;",
          "70:   }",
          "78:   }",
          "81:     switch (type) {",
          "82:       case UNKNOWN:",
          "84:       case NXDOMAIN:",
          "86:       case NXRRSET:",
          "88:       case DELEGATION:",
          "89:       case CNAME:",
          "90:       case DNAME:",
          "91:       case SUCCESSFUL:",
          "96:       default:",
          "97:         throw new IllegalArgumentException(\"invalid type\");",
          "98:     }",
          "99:   }",
          "101:   void addRRset(RRset rrset) {",
          "102:     if (data == null) {",
          "103:       data = new ArrayList<>();",
          "104:     }",
          "105:     data.add(rrset);",
          "106:   }",
          "",
          "[Removed Lines]",
          "20:   static final int UNKNOWN = 0;",
          "26:   static final int NXDOMAIN = 1;",
          "32:   static final int NXRRSET = 2;",
          "35:   static final int DELEGATION = 3;",
          "42:   static final int CNAME = 4;",
          "49:   static final int DNAME = 5;",
          "52:   static final int SUCCESSFUL = 6;",
          "54:   private static final SetResponse unknown = new SetResponse(UNKNOWN);",
          "55:   private static final SetResponse nxdomain = new SetResponse(NXDOMAIN);",
          "56:   private static final SetResponse nxrrset = new SetResponse(NXRRSET);",
          "58:   private int type;",
          "61:   private SetResponse() {}",
          "63:   SetResponse(int type, RRset rrset) {",
          "64:     if (type < 0 || type > 6) {",
          "65:       throw new IllegalArgumentException(\"invalid type\");",
          "66:     }",
          "68:     this.data = new ArrayList<>();",
          "69:     this.data.add(rrset);",
          "72:   SetResponse(int type) {",
          "73:     if (type < 0 || type > 6) {",
          "74:       throw new IllegalArgumentException(\"invalid type\");",
          "75:     }",
          "76:     this.type = type;",
          "77:     this.data = null;",
          "80:   static SetResponse ofType(int type) {",
          "83:         return unknown;",
          "85:         return nxdomain;",
          "87:         return nxrrset;",
          "92:         SetResponse sr = new SetResponse();",
          "93:         sr.type = type;",
          "94:         sr.data = null;",
          "95:         return sr;",
          "",
          "[Added Lines]",
          "27:   private static final SetResponse SR_UNKNOWN = new SetResponse(UNKNOWN, null, false);",
          "28:   private static final SetResponse SR_UNKNOWN_AUTH = new SetResponse(UNKNOWN, null, true);",
          "29:   private static final SetResponse SR_NXDOMAIN = new SetResponse(NXDOMAIN, null, false);",
          "30:   private static final SetResponse SR_NXDOMAIN_AUTH = new SetResponse(NXDOMAIN, null, true);",
          "31:   private static final SetResponse SR_NXRRSET = new SetResponse(NXRRSET, null, false);",
          "32:   private static final SetResponse SR_NXRRSET_AUTH = new SetResponse(NXRRSET, null, true);",
          "34:   private final SetResponseType type;",
          "39:   @Getter private boolean isAuthenticated;",
          "43:   private SetResponse(SetResponseType type, RRset rrset, boolean isAuthenticated) {",
          "45:     this.isAuthenticated = isAuthenticated;",
          "46:     if (rrset != null) {",
          "47:       addRRset(rrset);",
          "48:     }",
          "51:   static SetResponse ofType(SetResponseType type) {",
          "52:     return ofType(type, null, false);",
          "53:   }",
          "55:   static SetResponse ofType(SetResponseType type, RRset rrset) {",
          "56:     return ofType(type, rrset, false);",
          "59:   static SetResponse ofType(SetResponseType type, RRset rrset, boolean isAuthenticated) {",
          "62:         return isAuthenticated ? SR_UNKNOWN_AUTH : SR_UNKNOWN;",
          "64:         return isAuthenticated ? SR_NXDOMAIN_AUTH : SR_NXDOMAIN;",
          "66:         return isAuthenticated ? SR_NXRRSET_AUTH : SR_NXRRSET;",
          "71:         return new SetResponse(type, rrset, isAuthenticated);",
          "78:     if (type.isSealed()) {",
          "79:       throw new IllegalStateException(\"Attempted to add RRset to sealed response of type \" + type);",
          "80:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "162:   public RRset getNS() {",
          "164:   }",
          "167:   @Override",
          "168:   public String toString() {",
          "187:   }",
          "188: }",
          "",
          "[Removed Lines]",
          "163:     return (data != null) ? data.get(0) : null;",
          "169:     switch (type) {",
          "170:       case UNKNOWN:",
          "171:         return \"unknown\";",
          "172:       case NXDOMAIN:",
          "173:         return \"NXDOMAIN\";",
          "174:       case NXRRSET:",
          "175:         return \"NXRRSET\";",
          "176:       case DELEGATION:",
          "177:         return \"delegation: \" + data.get(0);",
          "178:       case CNAME:",
          "179:         return \"CNAME: \" + data.get(0);",
          "180:       case DNAME:",
          "181:         return \"DNAME: \" + data.get(0);",
          "182:       case SUCCESSFUL:",
          "183:         return \"successful\";",
          "184:       default:",
          "185:         throw new IllegalStateException();",
          "186:     }",
          "",
          "[Added Lines]",
          "144:     return data != null ? data.get(0) : null;",
          "150:     return type + (type.isPrintRecords() ? \": \" + data.get(0) : \"\");",
          "",
          "---------------"
        ],
        "src/main/java/org/xbill/DNS/SetResponseType.java||src/main/java/org/xbill/DNS/SetResponseType.java": [
          "File: src/main/java/org/xbill/DNS/SetResponseType.java -> src/main/java/org/xbill/DNS/SetResponseType.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: package org.xbill.DNS;",
          "3: import lombok.Getter;",
          "4: import lombok.RequiredArgsConstructor;",
          "6: @Getter",
          "7: @RequiredArgsConstructor",
          "8: enum SetResponseType {",
          "10:   UNKNOWN(false, true),",
          "16:   NXDOMAIN(false, true),",
          "22:   NXRRSET(false, true),",
          "25:   DELEGATION(true, false),",
          "32:   CNAME(true, false),",
          "39:   DNAME(true, false),",
          "42:   SUCCESSFUL(false, false);",
          "44:   private final boolean printRecords;",
          "47:   private final boolean isSealed;",
          "48: }",
          "",
          "---------------"
        ],
        "src/main/java/org/xbill/DNS/Zone.java||src/main/java/org/xbill/DNS/Zone.java": [
          "File: src/main/java/org/xbill/DNS/Zone.java -> src/main/java/org/xbill/DNS/Zone.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "339:   private synchronized SetResponse lookup(Name name, int type) {",
          "340:     if (!name.subdomain(origin)) {",
          "342:     }",
          "344:     int labels = name.labels();",
          "",
          "[Removed Lines]",
          "341:       return SetResponse.ofType(SetResponse.NXDOMAIN);",
          "",
          "[Added Lines]",
          "341:       return SetResponse.ofType(SetResponseType.NXDOMAIN);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "366:       if (!isOrigin) {",
          "367:         RRset ns = oneRRset(types, Type.NS);",
          "368:         if (ns != null) {",
          "370:         }",
          "371:       }",
          "374:       if (isExact && type == Type.ANY) {",
          "376:         for (RRset set : allRRsets(types)) {",
          "377:           sr.addRRset(set);",
          "378:         }",
          "",
          "[Removed Lines]",
          "369:           return new SetResponse(SetResponse.DELEGATION, ns);",
          "375:         SetResponse sr = new SetResponse(SetResponse.SUCCESSFUL);",
          "",
          "[Added Lines]",
          "369:           return SetResponse.ofType(SetResponseType.DELEGATION, ns);",
          "375:         SetResponse sr = SetResponse.ofType(SetResponseType.SUCCESSFUL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "386:       if (isExact) {",
          "387:         RRset rrset = oneRRset(types, type);",
          "388:         if (rrset != null) {",
          "390:         }",
          "391:         rrset = oneRRset(types, Type.CNAME);",
          "392:         if (rrset != null) {",
          "394:         }",
          "395:       } else {",
          "396:         RRset rrset = oneRRset(types, Type.DNAME);",
          "397:         if (rrset != null) {",
          "399:         }",
          "400:       }",
          "403:       if (isExact) {",
          "405:       }",
          "406:     }",
          "",
          "[Removed Lines]",
          "389:           return new SetResponse(SetResponse.SUCCESSFUL, rrset);",
          "393:           return new SetResponse(SetResponse.CNAME, rrset);",
          "398:           return new SetResponse(SetResponse.DNAME, rrset);",
          "404:         return SetResponse.ofType(SetResponse.NXRRSET);",
          "",
          "[Added Lines]",
          "389:           return SetResponse.ofType(SetResponseType.SUCCESSFUL, rrset);",
          "393:           return SetResponse.ofType(SetResponseType.CNAME, rrset);",
          "398:           return SetResponse.ofType(SetResponseType.DNAME, rrset);",
          "404:         return SetResponse.ofType(SetResponseType.NXRRSET);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "414:         }",
          "416:         if (type == Type.ANY) {",
          "418:           for (RRset set : allRRsets(types)) {",
          "419:             sr.addRRset(expandSet(set, name));",
          "420:           }",
          "",
          "[Removed Lines]",
          "417:           SetResponse sr = new SetResponse(SetResponse.SUCCESSFUL);",
          "",
          "[Added Lines]",
          "417:           SetResponse sr = SetResponse.ofType(SetResponseType.SUCCESSFUL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "422:         } else {",
          "423:           RRset rrset = oneRRset(types, type);",
          "424:           if (rrset != null) {",
          "426:           }",
          "427:         }",
          "428:       }",
          "429:     }",
          "432:   }",
          "434:   private RRset expandSet(RRset set, Name tname) {",
          "",
          "[Removed Lines]",
          "425:             return new SetResponse(SetResponse.SUCCESSFUL, expandSet(rrset, name));",
          "431:     return SetResponse.ofType(SetResponse.NXDOMAIN);",
          "",
          "[Added Lines]",
          "425:             return SetResponse.ofType(SetResponseType.SUCCESSFUL, expandSet(rrset, name));",
          "431:     return SetResponse.ofType(SetResponseType.NXDOMAIN);",
          "",
          "---------------"
        ],
        "src/test/java/org/xbill/DNS/SetResponseTest.java||src/test/java/org/xbill/DNS/SetResponseTest.java": [
          "File: src/test/java/org/xbill/DNS/SetResponseTest.java -> src/test/java/org/xbill/DNS/SetResponseTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "45: import java.net.InetAddress;",
          "46: import java.net.UnknownHostException;",
          "47: import org.junit.jupiter.api.Test;",
          "49: class SetResponseTest {",
          "178:     RRset rrs = new RRset();",
          "188:     RRset[] exp = new RRset[] {rrs};",
          "189:     assertArrayEquals(exp, sr.answers().toArray());",
          "",
          "[Removed Lines]",
          "50:   @Test",
          "51:   void ctor_1arg() {",
          "52:     final int[] types =",
          "53:         new int[] {",
          "54:           SetResponse.UNKNOWN,",
          "55:           SetResponse.NXDOMAIN,",
          "56:           SetResponse.NXRRSET,",
          "57:           SetResponse.DELEGATION,",
          "58:           SetResponse.CNAME,",
          "59:           SetResponse.DNAME,",
          "60:           SetResponse.SUCCESSFUL",
          "61:         };",
          "63:     for (int type : types) {",
          "64:       SetResponse sr = new SetResponse(type);",
          "65:       assertNull(sr.getNS());",
          "66:       assertEquals(type == SetResponse.UNKNOWN, sr.isUnknown());",
          "67:       assertEquals(type == SetResponse.NXDOMAIN, sr.isNXDOMAIN());",
          "68:       assertEquals(type == SetResponse.NXRRSET, sr.isNXRRSET());",
          "69:       assertEquals(type == SetResponse.DELEGATION, sr.isDelegation());",
          "70:       assertEquals(type == SetResponse.CNAME, sr.isCNAME());",
          "71:       assertEquals(type == SetResponse.DNAME, sr.isDNAME());",
          "72:       assertEquals(type == SetResponse.SUCCESSFUL, sr.isSuccessful());",
          "73:     }",
          "74:   }",
          "76:   @Test",
          "77:   void ctor_1arg_toosmall() {",
          "78:     assertThrows(IllegalArgumentException.class, () -> new SetResponse(-1));",
          "79:   }",
          "81:   @Test",
          "82:   void ctor_1arg_toobig() {",
          "83:     assertThrows(IllegalArgumentException.class, () -> new SetResponse(7));",
          "84:   }",
          "86:   @Test",
          "87:   void ctor_2arg() {",
          "88:     final int[] types =",
          "89:         new int[] {",
          "90:           SetResponse.UNKNOWN,",
          "91:           SetResponse.NXDOMAIN,",
          "92:           SetResponse.NXRRSET,",
          "93:           SetResponse.DELEGATION,",
          "94:           SetResponse.CNAME,",
          "95:           SetResponse.DNAME,",
          "96:           SetResponse.SUCCESSFUL",
          "97:         };",
          "99:     for (int type : types) {",
          "100:       RRset rs = new RRset();",
          "101:       SetResponse sr = new SetResponse(type, rs);",
          "102:       assertSame(rs, sr.getNS());",
          "103:       assertEquals(type == SetResponse.UNKNOWN, sr.isUnknown());",
          "104:       assertEquals(type == SetResponse.NXDOMAIN, sr.isNXDOMAIN());",
          "105:       assertEquals(type == SetResponse.NXRRSET, sr.isNXRRSET());",
          "106:       assertEquals(type == SetResponse.DELEGATION, sr.isDelegation());",
          "107:       assertEquals(type == SetResponse.CNAME, sr.isCNAME());",
          "108:       assertEquals(type == SetResponse.DNAME, sr.isDNAME());",
          "109:       assertEquals(type == SetResponse.SUCCESSFUL, sr.isSuccessful());",
          "110:     }",
          "111:   }",
          "113:   @Test",
          "114:   void ctor_2arg_toosmall() {",
          "115:     assertThrows(IllegalArgumentException.class, () -> new SetResponse(-1, new RRset()));",
          "116:   }",
          "118:   @Test",
          "119:   void ctor_2arg_toobig() {",
          "120:     assertThrows(IllegalArgumentException.class, () -> new SetResponse(7, new RRset()));",
          "121:   }",
          "123:   @Test",
          "124:   void ofType_basic() {",
          "125:     final int[] types =",
          "126:         new int[] {",
          "127:           SetResponse.DELEGATION, SetResponse.CNAME, SetResponse.DNAME, SetResponse.SUCCESSFUL",
          "128:         };",
          "130:     for (int type : types) {",
          "131:       SetResponse sr = SetResponse.ofType(type);",
          "132:       assertNull(sr.getNS());",
          "133:       assertEquals(type == SetResponse.UNKNOWN, sr.isUnknown());",
          "134:       assertEquals(type == SetResponse.NXDOMAIN, sr.isNXDOMAIN());",
          "135:       assertEquals(type == SetResponse.NXRRSET, sr.isNXRRSET());",
          "136:       assertEquals(type == SetResponse.DELEGATION, sr.isDelegation());",
          "137:       assertEquals(type == SetResponse.CNAME, sr.isCNAME());",
          "138:       assertEquals(type == SetResponse.DNAME, sr.isDNAME());",
          "139:       assertEquals(type == SetResponse.SUCCESSFUL, sr.isSuccessful());",
          "141:       SetResponse sr2 = SetResponse.ofType(type);",
          "142:       assertNotSame(sr, sr2);",
          "143:     }",
          "144:   }",
          "146:   @Test",
          "147:   void ofType_singleton() {",
          "148:     final int[] types = new int[] {SetResponse.UNKNOWN, SetResponse.NXDOMAIN, SetResponse.NXRRSET};",
          "150:     for (int type : types) {",
          "151:       SetResponse sr = SetResponse.ofType(type);",
          "152:       assertNull(sr.getNS());",
          "153:       assertEquals(type == SetResponse.UNKNOWN, sr.isUnknown());",
          "154:       assertEquals(type == SetResponse.NXDOMAIN, sr.isNXDOMAIN());",
          "155:       assertEquals(type == SetResponse.NXRRSET, sr.isNXRRSET());",
          "156:       assertEquals(type == SetResponse.DELEGATION, sr.isDelegation());",
          "157:       assertEquals(type == SetResponse.CNAME, sr.isCNAME());",
          "158:       assertEquals(type == SetResponse.DNAME, sr.isDNAME());",
          "159:       assertEquals(type == SetResponse.SUCCESSFUL, sr.isSuccessful());",
          "161:       SetResponse sr2 = SetResponse.ofType(type);",
          "162:       assertSame(sr, sr2);",
          "163:     }",
          "164:   }",
          "166:   @Test",
          "167:   void ofType_toosmall() {",
          "168:     assertThrows(IllegalArgumentException.class, () -> SetResponse.ofType(-1));",
          "169:   }",
          "171:   @Test",
          "172:   void ofType_toobig() {",
          "173:     assertThrows(IllegalArgumentException.class, () -> SetResponse.ofType(7));",
          "174:   }",
          "176:   @Test",
          "177:   void addRRset() throws TextParseException, UnknownHostException {",
          "179:     rrs.addRR(",
          "180:         new ARecord(",
          "181:             Name.fromString(\"The.Name.\"), DClass.IN, 0xABCD, InetAddress.getByName(\"192.168.0.1\")));",
          "182:     rrs.addRR(",
          "183:         new ARecord(",
          "184:             Name.fromString(\"The.Name.\"), DClass.IN, 0xABCD, InetAddress.getByName(\"192.168.0.2\")));",
          "185:     SetResponse sr = new SetResponse(SetResponse.SUCCESSFUL);",
          "186:     sr.addRRset(rrs);",
          "",
          "[Added Lines]",
          "48: import org.junit.jupiter.params.ParameterizedTest;",
          "49: import org.junit.jupiter.params.provider.EnumSource;",
          "52:   private static final ARecord A_RECORD_1 =",
          "53:       new ARecord(",
          "54:           Name.fromConstantString(\"The.Name.\"),",
          "55:           DClass.IN,",
          "56:           0xABCD,",
          "57:           new byte[] {(byte) 192, (byte) 168, 0, 1});",
          "58:   private static final ARecord A_RECORD_2 =",
          "59:       new ARecord(",
          "60:           Name.fromConstantString(\"The.Name.\"),",
          "61:           DClass.IN,",
          "62:           0xABCD,",
          "63:           new byte[] {(byte) 192, (byte) 168, 0, 2});",
          "65:   @ParameterizedTest",
          "66:   @EnumSource(value = SetResponseType.class)",
          "67:   void ctor_1arg(SetResponseType type) {",
          "68:     SetResponse sr = SetResponse.ofType(type);",
          "69:     assertNull(sr.getNS());",
          "70:     assertEquals(type == SetResponseType.UNKNOWN, sr.isUnknown());",
          "71:     assertEquals(type == SetResponseType.NXDOMAIN, sr.isNXDOMAIN());",
          "72:     assertEquals(type == SetResponseType.NXRRSET, sr.isNXRRSET());",
          "73:     assertEquals(type == SetResponseType.DELEGATION, sr.isDelegation());",
          "74:     assertEquals(type == SetResponseType.CNAME, sr.isCNAME());",
          "75:     assertEquals(type == SetResponseType.DNAME, sr.isDNAME());",
          "76:     assertEquals(type == SetResponseType.SUCCESSFUL, sr.isSuccessful());",
          "77:   }",
          "79:   @ParameterizedTest",
          "80:   @EnumSource(",
          "81:       value = SetResponseType.class,",
          "82:       names = {",
          "83:         \"DELEGATION\",",
          "84:         \"CNAME\",",
          "85:         \"DNAME\",",
          "86:         \"SUCCESSFUL\",",
          "87:       })",
          "88:   void ofType_basic(SetResponseType type) {",
          "89:     RRset rs = new RRset();",
          "90:     SetResponse sr = SetResponse.ofType(type, rs);",
          "91:     assertSame(rs, sr.getNS());",
          "92:     assertEquals(type == SetResponseType.DELEGATION, sr.isDelegation());",
          "93:     assertEquals(type == SetResponseType.CNAME, sr.isCNAME());",
          "94:     assertEquals(type == SetResponseType.DNAME, sr.isDNAME());",
          "95:     assertEquals(type == SetResponseType.SUCCESSFUL, sr.isSuccessful());",
          "97:     SetResponse sr2 = SetResponse.ofType(type, rs);",
          "98:     assertNotSame(sr, sr2);",
          "99:   }",
          "101:   @ParameterizedTest",
          "102:   @EnumSource(",
          "103:       value = SetResponseType.class,",
          "104:       names = {",
          "105:         \"UNKNOWN\",",
          "106:         \"NXDOMAIN\",",
          "107:         \"NXRRSET\",",
          "108:       })",
          "109:   void ofType_singleton(SetResponseType type) {",
          "110:     SetResponse sr = SetResponse.ofType(type);",
          "111:     assertNull(sr.getNS());",
          "112:     assertEquals(type == SetResponseType.UNKNOWN, sr.isUnknown());",
          "113:     assertEquals(type == SetResponseType.NXDOMAIN, sr.isNXDOMAIN());",
          "114:     assertEquals(type == SetResponseType.NXRRSET, sr.isNXRRSET());",
          "115:     assertThrows(IllegalStateException.class, () -> sr.addRRset(new RRset()));",
          "117:     SetResponse sr2 = SetResponse.ofType(type);",
          "118:     assertSame(sr, sr2);",
          "119:   }",
          "121:   @Test",
          "122:   void addRRset() {",
          "124:     rrs.addRR(A_RECORD_1);",
          "125:     rrs.addRR(A_RECORD_2);",
          "126:     SetResponse sr = SetResponse.ofType(SetResponseType.SUCCESSFUL, rrs);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "192:   @Test",
          "193:   void addRRset_multiple() throws TextParseException, UnknownHostException {",
          "194:     RRset rrs = new RRset();",
          "202:     RRset rrs2 = new RRset();",
          "203:     rrs2.addRR(",
          "",
          "[Removed Lines]",
          "195:     rrs.addRR(",
          "196:         new ARecord(",
          "197:             Name.fromString(\"The.Name.\"), DClass.IN, 0xABCD, InetAddress.getByName(\"192.168.0.1\")));",
          "198:     rrs.addRR(",
          "199:         new ARecord(",
          "200:             Name.fromString(\"The.Name.\"), DClass.IN, 0xABCD, InetAddress.getByName(\"192.168.0.2\")));",
          "",
          "[Added Lines]",
          "135:     rrs.addRR(A_RECORD_1);",
          "136:     rrs.addRR(A_RECORD_2);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "213:             0xABCE,",
          "214:             InetAddress.getByName(\"192.168.1.2\")));",
          "217:     sr.addRRset(rrs);",
          "218:     sr.addRRset(rrs2);",
          "",
          "[Removed Lines]",
          "216:     SetResponse sr = new SetResponse(SetResponse.SUCCESSFUL);",
          "",
          "[Added Lines]",
          "152:     SetResponse sr = SetResponse.ofType(SetResponseType.SUCCESSFUL);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "224:   @Test",
          "225:   void answers_nonSUCCESSFUL() {",
          "227:     assertNull(sr.answers());",
          "228:   }",
          "230:   @Test",
          "231:   void getCNAME() throws TextParseException {",
          "233:     CNAMERecord cr =",
          "234:         new CNAMERecord(",
          "235:             Name.fromString(\"The.Name.\"), DClass.IN, 0xABCD, Name.fromString(\"The.Alias.\"));",
          "238:     assertEquals(cr, sr.getCNAME());",
          "239:   }",
          "241:   @Test",
          "242:   void getDNAME() throws TextParseException {",
          "244:     DNAMERecord dr =",
          "245:         new DNAMERecord(",
          "246:             Name.fromString(\"The.Name.\"), DClass.IN, 0xABCD, Name.fromString(\"The.Alias.\"));",
          "249:     assertEquals(dr, sr.getDNAME());",
          "250:   }",
          "283:     }",
          "284:   }",
          "285: }",
          "",
          "[Removed Lines]",
          "226:     SetResponse sr = new SetResponse(SetResponse.UNKNOWN, new RRset());",
          "232:     RRset rrs = new RRset();",
          "236:     rrs.addRR(cr);",
          "237:     SetResponse sr = new SetResponse(SetResponse.CNAME, rrs);",
          "243:     RRset rrs = new RRset();",
          "247:     rrs.addRR(dr);",
          "248:     SetResponse sr = new SetResponse(SetResponse.DNAME, rrs);",
          "252:   @Test",
          "253:   void test_toString() throws TextParseException, UnknownHostException {",
          "254:     final int[] types =",
          "255:         new int[] {",
          "256:           SetResponse.UNKNOWN,",
          "257:           SetResponse.NXDOMAIN,",
          "258:           SetResponse.NXRRSET,",
          "259:           SetResponse.DELEGATION,",
          "260:           SetResponse.CNAME,",
          "261:           SetResponse.DNAME,",
          "262:           SetResponse.SUCCESSFUL",
          "263:         };",
          "264:     RRset rrs = new RRset();",
          "265:     rrs.addRR(",
          "266:         new ARecord(",
          "267:             Name.fromString(\"The.Name.\"), DClass.IN, 0xABCD, InetAddress.getByName(\"192.168.0.1\")));",
          "269:     final String[] labels =",
          "270:         new String[] {",
          "271:           \"unknown\",",
          "272:           \"NXDOMAIN\",",
          "273:           \"NXRRSET\",",
          "274:           \"delegation: \" + rrs,",
          "275:           \"CNAME: \" + rrs,",
          "276:           \"DNAME: \" + rrs,",
          "277:           \"successful\"",
          "278:         };",
          "280:     for (int i = 0; i < types.length; ++i) {",
          "281:       SetResponse sr = new SetResponse(types[i], rrs);",
          "282:       assertEquals(labels[i], sr.toString());",
          "",
          "[Added Lines]",
          "162:     SetResponse sr = SetResponse.ofType(SetResponseType.UNKNOWN, new RRset());",
          "171:     RRset rrs = new RRset(cr);",
          "172:     SetResponse sr = SetResponse.ofType(SetResponseType.CNAME, rrs);",
          "181:     RRset rrs = new RRset(dr);",
          "182:     SetResponse sr = SetResponse.ofType(SetResponseType.DNAME, rrs);",
          "186:   @ParameterizedTest",
          "187:   @EnumSource(SetResponseType.class)",
          "188:   void test_toString(SetResponseType type) {",
          "189:     RRset rrs = new RRset(A_RECORD_1);",
          "191:     SetResponse sr = SetResponse.ofType(type, rrs);",
          "192:     if (type.isPrintRecords()) {",
          "193:       assertEquals(type + \": \" + rrs, sr.toString());",
          "194:     } else {",
          "195:       assertEquals(type.toString(), sr.toString());",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5ff4e4ca35ee2eba49bb4fcd9da479fab3010f1a",
      "candidate_info": {
        "commit_hash": "5ff4e4ca35ee2eba49bb4fcd9da479fab3010f1a",
        "repo": "dnsjava/dnsjava",
        "commit_url": "https://github.com/dnsjava/dnsjava/commit/5ff4e4ca35ee2eba49bb4fcd9da479fab3010f1a",
        "files": [
          "src/main/java/org/xbill/DNS/lookup/LookupSession.java",
          "src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java"
        ],
        "message": "Fix CNAME in LookupSession\n\nCloses #279",
        "before_after_code_files": [
          "src/main/java/org/xbill/DNS/lookup/LookupSession.java||src/main/java/org/xbill/DNS/lookup/LookupSession.java",
          "src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java||src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/main/java/org/xbill/DNS/lookup/LookupSession.java||src/main/java/org/xbill/DNS/lookup/LookupSession.java",
            "src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java||src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java"
          ],
          "candidate": [
            "src/main/java/org/xbill/DNS/lookup/LookupSession.java||src/main/java/org/xbill/DNS/lookup/LookupSession.java",
            "src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java||src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java"
          ]
        }
      },
      "candidate_diff": {
        "src/main/java/org/xbill/DNS/lookup/LookupSession.java||src/main/java/org/xbill/DNS/lookup/LookupSession.java": [
          "File: src/main/java/org/xbill/DNS/lookup/LookupSession.java -> src/main/java/org/xbill/DNS/lookup/LookupSession.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "529:     List<Record> records = response.getRecords();",
          "530:     if (!records.isEmpty()",
          "531:         && (records.get(0).getType() == Type.CNAME || records.get(0).getType() == Type.DNAME)) {",
          "532:       return maybeFollowRedirectsInAnswer(response, query, redirectCount);",
          "533:     } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "531:         && query.getType() != records.get(0).getType()",
          "",
          "---------------"
        ],
        "src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java||src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java": [
          "File: src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java -> src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: import static java.lang.String.format;",
          "5: import static java.util.Arrays.asList;",
          "6: import static java.util.Collections.singletonList;",
          "7: import static org.junit.jupiter.api.Assertions.assertEquals;",
          "8: import static org.junit.jupiter.api.Assertions.assertThrows;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: import static java.util.Collections.emptyList;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52: import org.mockito.InOrder;",
          "53: import org.mockito.Mock;",
          "54: import org.mockito.junit.jupiter.MockitoExtension;",
          "67: import org.xbill.DNS.Record;",
          "72: import org.xbill.DNS.hosts.HostsFileParser;",
          "74: @ExtendWith(MockitoExtension.class)",
          "",
          "[Removed Lines]",
          "55: import org.xbill.DNS.AAAARecord;",
          "56: import org.xbill.DNS.ARecord;",
          "57: import org.xbill.DNS.Address;",
          "58: import org.xbill.DNS.CNAMERecord;",
          "59: import org.xbill.DNS.Cache;",
          "60: import org.xbill.DNS.Credibility;",
          "61: import org.xbill.DNS.DClass;",
          "62: import org.xbill.DNS.DNAMERecord;",
          "63: import org.xbill.DNS.Message;",
          "64: import org.xbill.DNS.Name;",
          "65: import org.xbill.DNS.RRset;",
          "66: import org.xbill.DNS.Rcode;",
          "68: import org.xbill.DNS.Resolver;",
          "69: import org.xbill.DNS.Section;",
          "70: import org.xbill.DNS.SetResponse;",
          "71: import org.xbill.DNS.Type;",
          "",
          "[Added Lines]",
          "56: import org.xbill.DNS.*;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "634:     verify(mockResolver, times(2)).sendAsync(any(), any(Executor.class));",
          "635:   }",
          "637:   @Test",
          "638:   void lookupAsync_simpleDnameRedirect() throws Exception {",
          "639:     Function<Name, Record> nameToRecord =",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "623:   @Test",
          "624:   void lookupAsync_cnameQuery() throws Exception {",
          "625:     Name query = name(\"cname.r.\");",
          "626:     CNAMERecord response = cname(query, \"a.b.\");",
          "627:     Function<Name, Record> nameToRecord = name -> query.equals(name) ? response : LOOPBACK_A;",
          "628:     wireUpMockResolver(mockResolver, q -> answer(q, nameToRecord));",
          "630:     LookupSession lookupSession = LookupSession.builder().resolver(mockResolver).build();",
          "632:     CompletionStage<LookupResult> resultFuture = lookupSession.lookupAsync(query, CNAME, IN);",
          "634:     LookupResult result = resultFuture.toCompletableFuture().get();",
          "635:     assertEquals(singletonList(response), result.getRecords());",
          "636:     assertEquals(emptyList(), result.getAliases());",
          "637:     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));",
          "638:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "981:   }",
          "983:   private static CNAMERecord cname(String name, String target) {",
          "985:   }",
          "987:   @SuppressWarnings(\"SameParameterValue\")",
          "",
          "[Removed Lines]",
          "984:     return new CNAMERecord(name(name), IN, 0, name(target));",
          "",
          "[Added Lines]",
          "987:     return cname(name(name), target);",
          "988:   }",
          "990:   private static CNAMERecord cname(Name name, String target) {",
          "991:     return new CNAMERecord(name, IN, 0, name(target));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "711af79be3214f52daa5c846b95766dc0a075116",
      "candidate_info": {
        "commit_hash": "711af79be3214f52daa5c846b95766dc0a075116",
        "repo": "dnsjava/dnsjava",
        "commit_url": "https://github.com/dnsjava/dnsjava/commit/711af79be3214f52daa5c846b95766dc0a075116",
        "files": [
          "src/main/java/org/xbill/DNS/DNSSEC.java",
          "src/main/java/org/xbill/DNS/Resolver.java",
          "src/main/java/org/xbill/DNS/dnssec/AlgorithmRequirements.java",
          "src/main/java/org/xbill/DNS/dnssec/DnsSecVerifier.java",
          "src/main/java/org/xbill/DNS/dnssec/KeyEntry.java",
          "src/main/java/org/xbill/DNS/dnssec/NSEC3ValUtils.java",
          "src/main/java/org/xbill/DNS/dnssec/Nsec3ValidationState.java",
          "src/main/java/org/xbill/DNS/dnssec/ValUtils.java",
          "src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java",
          "src/main/resources/messages.properties",
          "src/test/java/org/xbill/DNS/dnssec/DnsSecVerifierTests.java",
          "src/test/java/org/xbill/DNS/dnssec/TestAlgorithmSupport.java",
          "src/test/java/org/xbill/DNS/dnssec/TestBase.java",
          "src/test/java/org/xbill/DNS/dnssec/TestCNames.java",
          "src/test/java/org/xbill/DNS/dnssec/TestNormallyUnreachableCode.java",
          "src/test/java/org/xbill/DNS/dnssec/TestNsec3ValUtilsPublicKeyLoading.java",
          "src/test/java/org/xbill/DNS/dnssec/TestPriming.java",
          "src/test/java/org/xbill/DNS/dnssec/TestTrustAnchorLoading.java",
          "src/test/java/org/xbill/DNS/dnssec/UnboundTests.java",
          "src/test/resources/unbound/val_secds_nosig.rpl",
          "src/test/resources/unbound/val_ta_algo_dnskey.rpl",
          "src/test/resources/unbound/val_ta_algo_dnskey_dp.rpl",
          "src/test/resources/unbound/val_ta_algo_missing.rpl",
          "src/test/resources/unbound/val_ta_algo_missing_dp.rpl"
        ],
        "message": "CVE-2023-50868 / KeyTrap: NSEC3 closest encloser proof can exhaust CPU",
        "before_after_code_files": [
          "src/main/java/org/xbill/DNS/DNSSEC.java||src/main/java/org/xbill/DNS/DNSSEC.java",
          "src/main/java/org/xbill/DNS/Resolver.java||src/main/java/org/xbill/DNS/Resolver.java",
          "src/main/java/org/xbill/DNS/dnssec/AlgorithmRequirements.java||src/main/java/org/xbill/DNS/dnssec/AlgorithmRequirements.java",
          "src/main/java/org/xbill/DNS/dnssec/DnsSecVerifier.java||src/main/java/org/xbill/DNS/dnssec/DnsSecVerifier.java",
          "src/main/java/org/xbill/DNS/dnssec/KeyEntry.java||src/main/java/org/xbill/DNS/dnssec/KeyEntry.java",
          "src/main/java/org/xbill/DNS/dnssec/NSEC3ValUtils.java||src/main/java/org/xbill/DNS/dnssec/NSEC3ValUtils.java",
          "src/main/java/org/xbill/DNS/dnssec/Nsec3ValidationState.java||src/main/java/org/xbill/DNS/dnssec/Nsec3ValidationState.java",
          "src/main/java/org/xbill/DNS/dnssec/ValUtils.java||src/main/java/org/xbill/DNS/dnssec/ValUtils.java",
          "src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java||src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java",
          "src/main/resources/messages.properties||src/main/resources/messages.properties",
          "src/test/java/org/xbill/DNS/dnssec/DnsSecVerifierTests.java||src/test/java/org/xbill/DNS/dnssec/DnsSecVerifierTests.java",
          "src/test/java/org/xbill/DNS/dnssec/TestAlgorithmSupport.java||src/test/java/org/xbill/DNS/dnssec/TestAlgorithmSupport.java",
          "src/test/java/org/xbill/DNS/dnssec/TestBase.java||src/test/java/org/xbill/DNS/dnssec/TestBase.java",
          "src/test/java/org/xbill/DNS/dnssec/TestCNames.java||src/test/java/org/xbill/DNS/dnssec/TestCNames.java",
          "src/test/java/org/xbill/DNS/dnssec/TestNormallyUnreachableCode.java||src/test/java/org/xbill/DNS/dnssec/TestNormallyUnreachableCode.java",
          "src/test/java/org/xbill/DNS/dnssec/TestNsec3ValUtilsPublicKeyLoading.java||src/test/java/org/xbill/DNS/dnssec/TestNsec3ValUtilsPublicKeyLoading.java",
          "src/test/java/org/xbill/DNS/dnssec/TestPriming.java||src/test/java/org/xbill/DNS/dnssec/TestPriming.java",
          "src/test/java/org/xbill/DNS/dnssec/TestTrustAnchorLoading.java||src/test/java/org/xbill/DNS/dnssec/TestTrustAnchorLoading.java",
          "src/test/java/org/xbill/DNS/dnssec/UnboundTests.java||src/test/java/org/xbill/DNS/dnssec/UnboundTests.java",
          "src/test/resources/unbound/val_secds_nosig.rpl||src/test/resources/unbound/val_secds_nosig.rpl",
          "src/test/resources/unbound/val_ta_algo_dnskey.rpl||src/test/resources/unbound/val_ta_algo_dnskey.rpl",
          "src/test/resources/unbound/val_ta_algo_dnskey_dp.rpl||src/test/resources/unbound/val_ta_algo_dnskey_dp.rpl",
          "src/test/resources/unbound/val_ta_algo_missing.rpl||src/test/resources/unbound/val_ta_algo_missing.rpl",
          "src/test/resources/unbound/val_ta_algo_missing_dp.rpl||src/test/resources/unbound/val_ta_algo_missing_dp.rpl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java||src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java",
            "src/test/java/org/xbill/DNS/dnssec/TestBase.java||src/test/java/org/xbill/DNS/dnssec/TestBase.java",
            "src/test/java/org/xbill/DNS/dnssec/UnboundTests.java||src/test/java/org/xbill/DNS/dnssec/UnboundTests.java"
          ],
          "candidate": [
            "src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java||src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java",
            "src/test/java/org/xbill/DNS/dnssec/TestBase.java||src/test/java/org/xbill/DNS/dnssec/TestBase.java",
            "src/test/java/org/xbill/DNS/dnssec/UnboundTests.java||src/test/java/org/xbill/DNS/dnssec/UnboundTests.java"
          ]
        }
      },
      "candidate_diff": {
        "src/main/java/org/xbill/DNS/DNSSEC.java||src/main/java/org/xbill/DNS/DNSSEC.java": [
          "File: src/main/java/org/xbill/DNS/DNSSEC.java -> src/main/java/org/xbill/DNS/DNSSEC.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "433:   public static class SignatureVerificationException extends DNSSECException {",
          "442:     SignatureVerificationException(Throwable inner) {",
          "443:       super(\"Signature verification failed\", inner);",
          "444:     }",
          "",
          "[Removed Lines]",
          "434:     SignatureVerificationException(String message) {",
          "435:       super(message);",
          "436:     }",
          "438:     SignatureVerificationException() {",
          "439:       this((Throwable) null);",
          "440:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "997:       s.update(data);",
          "998:       if (!s.verify(signature)) {",
          "999:         throw new SignatureVerificationException(",
          "1001:                 + keyRecord.getName()",
          "1002:                 + \" (alg=\"",
          "1003:                 + keyRecord.getAlgorithm()",
          "",
          "[Removed Lines]",
          "1000:             \"KEY \"",
          "",
          "[Added Lines]",
          "992:             \"Key \"",
          "",
          "---------------"
        ],
        "src/main/java/org/xbill/DNS/Resolver.java||src/main/java/org/xbill/DNS/Resolver.java": [
          "File: src/main/java/org/xbill/DNS/Resolver.java -> src/main/java/org/xbill/DNS/Resolver.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "157:     } catch (ExecutionException e) {",
          "158:       if (e.getCause() instanceof IOException) {",
          "159:         throw (IOException) e.getCause();",
          "161:         throw new IOException(e.getCause());",
          "162:       }",
          "163:     } catch (TimeoutException e) {",
          "164:       throw new IOException(",
          "",
          "[Removed Lines]",
          "160:       } else {",
          "",
          "[Added Lines]",
          "160:       } else if (e.getCause() != null) {",
          "162:       } else {",
          "163:         throw new IOException(e);",
          "",
          "---------------"
        ],
        "src/main/java/org/xbill/DNS/dnssec/AlgorithmRequirements.java||src/main/java/org/xbill/DNS/dnssec/AlgorithmRequirements.java": [
          "File: src/main/java/org/xbill/DNS/dnssec/AlgorithmRequirements.java -> src/main/java/org/xbill/DNS/dnssec/AlgorithmRequirements.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: package org.xbill.DNS.dnssec;",
          "6: import java.util.ArrayList;",
          "7: import java.util.List;",
          "8: import lombok.Getter;",
          "9: import org.xbill.DNS.DSRecord;",
          "10: import org.xbill.DNS.RRset;",
          "11: import org.xbill.DNS.Record;",
          "14: class AlgorithmRequirements {",
          "15:   private static final int MAX_ALGORITHMS = 0xFF;",
          "16:   private final ValUtils valUtils;",
          "18:   public AlgorithmRequirements(ValUtils valUtils) {",
          "19:     this.valUtils = valUtils;",
          "20:   }",
          "31:   private final short[] needs = new short[MAX_ALGORITHMS];",
          "34:   @Getter private int num;",
          "41:   void initList(List<Integer> sigalg) {",
          "42:     num = 0;",
          "43:     for (Integer algo : sigalg) {",
          "44:       needs[algo] = 1;",
          "45:       num++;",
          "46:     }",
          "47:   }",
          "56:   List<Integer> initDs(RRset dsRRset, int favoriteDsAlgorithm) {",
          "57:     List<Integer> sigalg = new ArrayList<>();",
          "58:     num = 0;",
          "59:     for (Record r : dsRRset.rrs(false)) {",
          "60:       DSRecord ds = (DSRecord) r;",
          "61:       if (ds.getDigestID() != favoriteDsAlgorithm) {",
          "62:         continue;",
          "63:       }",
          "65:       int algo = ds.getAlgorithm();",
          "66:       if (!valUtils.isAlgorithmSupported(algo)) {",
          "67:         continue;",
          "68:       }",
          "70:       if (needs[algo] == 0) {",
          "71:         needs[algo] = 1;",
          "72:         sigalg.add(algo);",
          "73:         num++;",
          "74:       }",
          "75:     }",
          "77:     return sigalg;",
          "78:   }",
          "86:   boolean setSecure(int algo) {",
          "87:     if (needs[algo] != 0) {",
          "88:       needs[algo] = 0;",
          "89:       num--;",
          "91:       return num == 0;",
          "92:     }",
          "94:     return false;",
          "95:   }",
          "103:   void setBogus(int algo) {",
          "104:     if (needs[algo] != 0) {",
          "106:       needs[algo] = 2;",
          "107:     }",
          "108:   }",
          "115:   int missing() {",
          "116:     int miss = -1;",
          "120:     for (int i = 0; i < needs.length; i++) {",
          "121:       if (needs[i] == 2) {",
          "122:         return 0;",
          "123:       }",
          "125:       if (needs[i] == 1 && miss == -1) {",
          "126:         miss = i;",
          "127:       }",
          "128:     }",
          "130:     if (miss != -1) {",
          "131:       return miss;",
          "132:     }",
          "134:     return 0;",
          "135:   }",
          "136: }",
          "",
          "---------------"
        ],
        "src/main/java/org/xbill/DNS/dnssec/DnsSecVerifier.java||src/main/java/org/xbill/DNS/dnssec/DnsSecVerifier.java": [
          "File: src/main/java/org/xbill/DNS/dnssec/DnsSecVerifier.java -> src/main/java/org/xbill/DNS/dnssec/DnsSecVerifier.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: @Slf4j",
          "33: final class DnsSecVerifier {",
          "34:   public static final String MAX_VALIDATE_RRSIGS_PROPERTY = \"dnsjava.dnssec.max_validate_rrsigs\";",
          "35:   private int maxValidateRRsigs;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36:   private final ValUtils valUtils;",
          "39:   public DnsSecVerifier(ValUtils valUtils) {",
          "40:     this.valUtils = valUtils;",
          "41:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:     int keyid = signature.getFootprint();",
          "70:     int alg = signature.getAlgorithm();",
          "71:     List<DNSKEYRecord> res = new ArrayList<>(dnskeyRrset.size());",
          "73:       DNSKEYRecord dnskey = (DNSKEYRecord) r;",
          "74:       if (dnskey.getAlgorithm() == alg && dnskey.getFootprint() == keyid) {",
          "75:         res.add(dnskey);",
          "",
          "[Removed Lines]",
          "72:     for (Record r : dnskeyRrset.rrs()) {",
          "",
          "[Added Lines]",
          "78:     for (Record r : dnskeyRrset.rrs(false)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "93:   private JustifiedSecStatus verifySignature(",
          "95:     if (!rrset.getName().subdomain(sigrec.getSigner())) {",
          "96:       log.debug(\"Signer name {} is off-tree for {}\", sigrec.getSigner(), rrset.getName());",
          "97:       return new JustifiedSecStatus(",
          "",
          "[Removed Lines]",
          "94:       SRRset rrset, RRSIGRecord sigrec, RRset keyRrset, Instant date) {",
          "",
          "[Added Lines]",
          "100:       SRRset rrset, RRSIGRecord sigrec, KeyEntry keyRrset, Instant date) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "156:     List<RRSIGRecord> sigs = rrset.sigs();",
          "157:     if (sigs.isEmpty()) {",
          "158:       log.info(",
          "",
          "[Removed Lines]",
          "155:   public JustifiedSecStatus verify(SRRset rrset, RRset keyRrset, Instant date) {",
          "",
          "[Added Lines]",
          "161:   public JustifiedSecStatus verify(SRRset rrset, KeyEntry keyRrset, Instant date) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "166:           R.get(\"validate.bogus.missingsig_named\", rrset.getName(), Type.string(rrset.getType())));",
          "167:     }",
          "169:     JustifiedSecStatus res = null;",
          "170:     int numVerified = 0;",
          "171:     for (RRSIGRecord sigrec : sigs) {",
          "172:       res = this.verifySignature(rrset, sigrec, keyRrset, date);",
          "173:       if (res.status == SecurityStatus.SECURE) {",
          "175:       }",
          "177:       numVerified++;",
          "",
          "[Removed Lines]",
          "174:         return res;",
          "",
          "[Added Lines]",
          "175:     AlgorithmRequirements needs = null;",
          "176:     if (keyRrset.getAlgo() != null) {",
          "177:       needs = new AlgorithmRequirements(valUtils);",
          "178:       needs.initList(keyRrset.getAlgo());",
          "179:       if (needs.getNum() == 0) {",
          "180:         log.debug(\"{} has no known algorithms\", rrset.getName());",
          "181:         return new JustifiedSecStatus(",
          "182:             SecurityStatus.INSECURE,",
          "183:             ExtendedErrorCodeOption.UNSUPPORTED_DNSKEY_ALGORITHM,",
          "184:             R.get(\"validate.insecure.noalg\", rrset.getName()));",
          "185:       }",
          "186:     }",
          "193:         if (needs == null || needs.setSecure(sigrec.getAlgorithm())) {",
          "194:           return res;",
          "195:         }",
          "196:       } else if (needs != null && res.status == SecurityStatus.BOGUS) {",
          "197:         needs.setBogus(sigrec.getAlgorithm());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "263:         Type.string(rrset.getType()));",
          "264:     int edeReason = ExtendedErrorCodeOption.DNSSEC_BOGUS;",
          "265:     String reason = \"dnskey.invalid\";",
          "267:       edeReason = ExtendedErrorCodeOption.SIGNATURE_EXPIRED;",
          "268:       reason = \"dnskey.expired\";",
          "269:     } else if (lastException instanceof SignatureNotYetValidException) {",
          "",
          "[Removed Lines]",
          "266:     if (lastException instanceof SignatureExpiredException) {",
          "",
          "[Added Lines]",
          "289:     if (numVerified == 0) {",
          "290:       edeReason = ExtendedErrorCodeOption.DNSKEY_MISSING;",
          "291:       reason = \"dnskey.no_ds_match\";",
          "292:     } else if (lastException instanceof SignatureExpiredException) {",
          "",
          "---------------"
        ],
        "src/main/java/org/xbill/DNS/dnssec/KeyEntry.java||src/main/java/org/xbill/DNS/dnssec/KeyEntry.java": [
          "File: src/main/java/org/xbill/DNS/dnssec/KeyEntry.java -> src/main/java/org/xbill/DNS/dnssec/KeyEntry.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: package org.xbill.DNS.dnssec;",
          "7: import lombok.EqualsAndHashCode;",
          "8: import lombok.extern.slf4j.Slf4j;",
          "9: import org.xbill.DNS.DClass;",
          "10: import org.xbill.DNS.ExtendedErrorCodeOption;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: import java.util.List;",
          "9: import lombok.Getter;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "22:     callSuper = true,",
          "23:     of = {\"edeReason\", \"badReason\", \"isEmpty\"})",
          "24: final class KeyEntry extends SRRset {",
          "25:   private int edeReason = -1;",
          "26:   private String badReason;",
          "27:   private boolean isEmpty;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28:   @Getter private final List<Integer> algo;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "34:   private KeyEntry(SRRset rrset) {",
          "35:     super(rrset);",
          "36:   }",
          "38:   private KeyEntry(Name name, int dclass, long ttl, boolean isBad) {",
          "39:     super(new SRRset(Record.newRecord(name, Type.DNSKEY, dclass, ttl)));",
          "40:     this.isEmpty = true;",
          "41:     if (isBad) {",
          "42:       setSecurityStatus(SecurityStatus.BOGUS);",
          "43:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40:     this(rrset, null);",
          "41:   }",
          "49:   private KeyEntry(SRRset rrset, List<Integer> sigalg) {",
          "51:     this.algo = sigalg;",
          "57:     this.algo = null;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "53:     return new KeyEntry(rrset);",
          "54:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "80:   public static KeyEntry newKeyEntry(SRRset rrset, List<Integer> sigalg) {",
          "81:     return new KeyEntry(rrset, sigalg);",
          "82:   }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "113:   public void setBadReason(int edeReason, String reason) {",
          "114:     this.edeReason = edeReason;",
          "115:     this.badReason = reason;",
          "117:   }",
          "",
          "[Removed Lines]",
          "116:     log.debug(this.badReason);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/main/java/org/xbill/DNS/dnssec/NSEC3ValUtils.java||src/main/java/org/xbill/DNS/dnssec/NSEC3ValUtils.java": [
          "File: src/main/java/org/xbill/DNS/dnssec/NSEC3ValUtils.java -> src/main/java/org/xbill/DNS/dnssec/NSEC3ValUtils.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:   private static final int MAX_ITERATION_COUNT = 65536;",
          "46:   private final TreeMap<Integer, Integer> maxIterations;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "51:   private static final int MAX_NSEC3_CALCULATIONS = 8;",
          "57:   private static final int MAX_NSEC3_ERRORS = -1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:       String key = s.getKey().toString();",
          "70:       if (key.startsWith(NSEC3_MAX_ITERATIONS_PROPERTY_PREFIX)) {",
          "71:         int keySize = Integer.parseInt(key.substring(key.lastIndexOf(\".\") + 1));",
          "75:         }",
          "77:         if (first) {",
          "",
          "[Removed Lines]",
          "72:         int iters = Integer.parseInt(s.getValue().toString());",
          "73:         if (iters > MAX_ITERATION_COUNT) {",
          "74:           throw new IllegalArgumentException(\"Iteration count too high.\");",
          "",
          "[Added Lines]",
          "85:         int iterations = Integer.parseInt(s.getValue().toString());",
          "86:         if (iterations > MAX_ITERATION_COUNT) {",
          "87:           throw new IllegalArgumentException(",
          "88:               iterations + \" iterations is too high, maximum is \" + MAX_ITERATION_COUNT);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "79:           this.maxIterations.clear();",
          "80:         }",
          "83:       }",
          "84:     }",
          "85:   }",
          "",
          "[Removed Lines]",
          "82:         this.maxIterations.put(keySize, iters);",
          "",
          "[Added Lines]",
          "96:         this.maxIterations.put(keySize, iterations);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "167:     for (SRRset set : nsec3s) {",
          "168:       try {",
          "169:         NSEC3Record nsec3 = (NSEC3Record) set.first();",
          "172:         if (complete.equals(nsec3.getName())) {",
          "173:           return nsec3;",
          "174:         }",
          "175:       } catch (NoSuchAlgorithmException | TextParseException e) {",
          "176:         log.debug(\"Unrecognized NSEC3 in set: {}\", set, e);",
          "177:       }",
          "178:     }",
          "",
          "[Removed Lines]",
          "165:   private NSEC3Record findMatchingNSEC3(Name name, Name zonename, List<SRRset> nsec3s) {",
          "166:     base32 b32 = new base32(base32.Alphabet.BASE32HEX, false, false);",
          "170:         byte[] hash = nsec3.hashName(name);",
          "171:         Name complete = new Name(b32.toString(hash), zonename);",
          "",
          "[Added Lines]",
          "180:   private NSEC3Record findMatchingNSEC3(",
          "181:       Name name, Name zonename, List<SRRset> nsec3s, Nsec3ValidationState state) {",
          "183:       if (state.numCalc >= MAX_NSEC3_CALCULATIONS) {",
          "184:         if (state.numCalc == state.numCalcErrors) {",
          "185:           log.debug(\"NSEC3 reached max. hash calculation errors\");",
          "186:           state.numCalc = MAX_NSEC3_ERRORS;",
          "187:         } else {",
          "188:           log.debug(\"NSEC3 reached max. hash calculations\");",
          "189:         }",
          "190:         break;",
          "191:       }",
          "195:         Nsec3ValidationState.Nsec3CacheEntry hash = state.computeIfAbsent(nsec3, name);",
          "196:         Name complete = new Name(hash.getHashAsBase32(), zonename);",
          "201:         state.numCalcErrors++;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "225:     for (SRRset set : nsec3s) {",
          "226:       try {",
          "227:         NSEC3Record nsec3 = (NSEC3Record) set.first();",
          "230:           return nsec3;",
          "231:         }",
          "232:       } catch (NoSuchAlgorithmException e) {",
          "233:         log.debug(\"Unrecognized NSEC3 in set: {}\", set, e);",
          "234:       }",
          "235:     }",
          "",
          "[Removed Lines]",
          "224:   private NSEC3Record findCoveringNSEC3(Name name, Name zonename, List<SRRset> nsec3s) {",
          "228:         byte[] hash = nsec3.hashName(name);",
          "229:         if (this.nsec3Covers(nsec3, zonename, hash)) {",
          "",
          "[Added Lines]",
          "251:   private NSEC3Record findCoveringNSEC3(",
          "252:       Name name, Name zonename, List<SRRset> nsec3s, Nsec3ValidationState state) {",
          "255:       if (state.numCalc >= MAX_NSEC3_CALCULATIONS) {",
          "256:         if (state.numCalcErrors == state.numCalc) {",
          "257:           state.numCalc = MAX_NSEC3_ERRORS;",
          "258:         }",
          "260:         return null;",
          "261:       }",
          "265:         Nsec3ValidationState.Nsec3CacheEntry hash = state.computeIfAbsent(nsec3, name);",
          "266:         if (this.nsec3Covers(nsec3, zonename, hash.getHash())) {",
          "271:         state.numCalcErrors++;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "254:     while (name.labels() >= zonename.labels()) {",
          "256:       if (nsec3 != null) {",
          "257:         return new CEResponse(name, nsec3);",
          "258:       }",
          "",
          "[Removed Lines]",
          "250:   private CEResponse findClosestEncloser(Name name, Name zonename, List<SRRset> nsec3s) {",
          "255:       NSEC3Record nsec3 = this.findMatchingNSEC3(name, zonename, nsec3s);",
          "",
          "[Added Lines]",
          "290:   private CEResponse findClosestEncloser(",
          "291:       Name name, Name zonename, List<SRRset> nsec3s, Nsec3ValidationState state) {",
          "296:       if (state.numCalc >= MAX_NSEC3_CALCULATIONS || state.numCalc == MAX_NSEC3_ERRORS) {",
          "297:         log.debug(\"NSEC3 reached max. hash calculations\");",
          "298:         break;",
          "299:       }",
          "301:       NSEC3Record nsec3 = this.findMatchingNSEC3(name, zonename, nsec3s, state);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "277:     if (candidate == null) {",
          "278:       log.debug(\"Could not find a candidate for the closest encloser\");",
          "279:       candidate = new CEResponse(Name.empty, null);",
          "",
          "[Removed Lines]",
          "275:   private CEResponse proveClosestEncloser(Name qname, Name zonename, List<SRRset> nsec3s) {",
          "276:     CEResponse candidate = this.findClosestEncloser(qname, zonename, nsec3s);",
          "",
          "[Added Lines]",
          "322:   private CEResponse proveClosestEncloser(",
          "323:       Name qname, Name zonename, List<SRRset> nsec3s, Nsec3ValidationState state) {",
          "324:     CEResponse candidate = this.findClosestEncloser(qname, zonename, nsec3s, state);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "311:     Name nextClosest = this.nextClosest(qname, candidate.closestEncloser);",
          "313:     if (candidate.ncNsec3 == null) {",
          "314:       log.debug(\"Could not find proof that the closest encloser was the closest encloser\");",
          "315:       candidate.status = SecurityStatus.BOGUS;",
          "",
          "[Removed Lines]",
          "312:     candidate.ncNsec3 = this.findCoveringNSEC3(nextClosest, zonename, nsec3s);",
          "",
          "[Added Lines]",
          "360:     candidate.ncNsec3 = this.findCoveringNSEC3(nextClosest, zonename, nsec3s, state);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "323:   private boolean validIterations(SRRset nsec, KeyCache keyCache) {",
          "324:     SRRset dnskeyRrset = keyCache.find(nsec.getSignerName(), nsec.getDClass());",
          "327:     try {",
          "329:         DNSKEYRecord dnskey = (DNSKEYRecord) r;",
          "330:         int keysize;",
          "331:         switch (dnskey.getAlgorithm()) {",
          "332:           case Algorithm.RSAMD5:",
          "",
          "[Removed Lines]",
          "328:       for (Record r : dnskeyRrset.rrs()) {",
          "",
          "[Added Lines]",
          "373:     if (dnskeyRrset == null) {",
          "374:       return false;",
          "375:     }",
          "381:       int smallestKeySize = Integer.MAX_VALUE;",
          "382:       for (Record r : dnskeyRrset.rrs(false)) {",
          "384:         if ((dnskey.getFlags() & DNSKEYRecord.Flags.ZONE_KEY) != DNSKEYRecord.Flags.ZONE_KEY) {",
          "385:           continue;",
          "386:         }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "363:             return false;",
          "364:         }",
          "369:         }",
          "375:       }",
          "378:     } catch (DNSSECException e) {",
          "379:       log.error(\"Could not get public key from NSEC3 record\", e);",
          "380:       return false;",
          "",
          "[Removed Lines]",
          "366:         Integer keyIters = this.maxIterations.floorKey(keysize);",
          "367:         if (keyIters == null) {",
          "368:           keyIters = this.maxIterations.firstKey();",
          "371:         keyIters = this.maxIterations.get(keyIters);",
          "372:         if (((NSEC3Record) nsec.first()).getIterations() > keyIters) {",
          "373:           return false;",
          "374:         }",
          "377:       return true;",
          "",
          "[Added Lines]",
          "424:         if (keysize < smallestKeySize) {",
          "425:           smallestKeySize = keysize;",
          "427:       }",
          "430:       Integer maxIterationsForKeySet = this.maxIterations.floorKey(smallestKeySize);",
          "431:       if (maxIterationsForKeySet == null) {",
          "432:         maxIterationsForKeySet = this.maxIterations.firstKey();",
          "435:       maxIterationsForKeySet = this.maxIterations.get(maxIterationsForKeySet);",
          "436:       return ((NSEC3Record) nsec.first()).getIterations() <= maxIterationsForKeySet;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "394:     Map<Name, NSEC3Record> foundNsecs = new HashMap<>();",
          "395:     for (SRRset set : nsec3s) {",
          "396:       for (Record r : set.rrs()) {",
          "",
          "[Removed Lines]",
          "393:   public boolean allNSEC3sIgnoreable(List<SRRset> nsec3s, KeyCache dnskeyRrset) {",
          "",
          "[Added Lines]",
          "452:   public boolean allNSEC3sIgnorable(List<SRRset> nsec3s, KeyCache dnskeyRrset) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "446:     if (nsec3s == null || nsec3s.isEmpty()) {",
          "447:       return SecurityStatus.BOGUS;",
          "448:     }",
          "454:     if (ce.status != SecurityStatus.SECURE) {",
          "455:       log.debug(\"Failed to prove a closest encloser\");",
          "",
          "[Removed Lines]",
          "445:   public SecurityStatus proveNameError(List<SRRset> nsec3s, Name qname, Name zonename) {",
          "452:     CEResponse ce = this.proveClosestEncloser(qname, zonename, nsec3s);",
          "",
          "[Added Lines]",
          "505:   public SecurityStatus proveNameError(",
          "506:       List<SRRset> nsec3s, Name qname, Name zonename, Nsec3ValidationState state) {",
          "513:     CEResponse ce = this.proveClosestEncloser(qname, zonename, nsec3s, state);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "457:     }",
          "462:     Name wc = this.ceWildcard(ce.closestEncloser);",
          "464:     if (nsec3 == null) {",
          "465:       log.debug(\"Could not prove that the applicable wildcard did not exist\");",
          "466:       return SecurityStatus.BOGUS;",
          "467:     }",
          "",
          "[Removed Lines]",
          "463:     NSEC3Record nsec3 = this.findCoveringNSEC3(wc, zonename, nsec3s);",
          "",
          "[Added Lines]",
          "523:     if (wc == null) {",
          "524:       return SecurityStatus.BOGUS;",
          "525:     }",
          "527:     NSEC3Record nsec3 = this.findCoveringNSEC3(wc, zonename, nsec3s, state);",
          "530:       if (state.numCalc == MAX_NSEC3_ERRORS) {",
          "531:         log.debug(\"NSEC3 reached max. hash calculation errors\");",
          "532:         return SecurityStatus.BOGUS;",
          "533:       } else if (state.numCalc == MAX_NSEC3_CALCULATIONS) {",
          "534:         log.debug(\"NSEC3 reached max. hash calculations\");",
          "535:         return SecurityStatus.UNCHECKED;",
          "536:       }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "502:     if (nsec3s == null || nsec3s.isEmpty()) {",
          "503:       return new JustifiedSecStatus(",
          "504:           SecurityStatus.BOGUS, ExtendedErrorCodeOption.NSEC_MISSING, R.get(\"failed.nsec3.none\"));",
          "505:     }",
          "509:     if (nsec3 != null) {",
          "510:       if (nsec3.hasType(qtype)) {",
          "",
          "[Removed Lines]",
          "501:   public JustifiedSecStatus proveNodata(List<SRRset> nsec3s, Name qname, int qtype, Name zonename) {",
          "507:     NSEC3Record nsec3 = this.findMatchingNSEC3(qname, zonename, nsec3s);",
          "",
          "[Added Lines]",
          "574:   public JustifiedSecStatus proveNodata(",
          "575:       List<SRRset> nsec3s, Name qname, int qtype, Name zonename, Nsec3ValidationState state) {",
          "581:     NSEC3Record nsec3 = this.findMatchingNSEC3(qname, zonename, nsec3s, state);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "537:       return new JustifiedSecStatus(SecurityStatus.SECURE, -1, null);",
          "538:     }",
          "",
          "[Removed Lines]",
          "543:     CEResponse ce = this.proveClosestEncloser(qname, zonename, nsec3s);",
          "",
          "[Added Lines]",
          "614:     if (state.numCalc == MAX_NSEC3_ERRORS) {",
          "615:       log.debug(\"NSEC3 reached max. hash calculation errors\");",
          "616:       return new JustifiedSecStatus(",
          "617:           SecurityStatus.BOGUS, DNSSEC_BOGUS, R.get(\"failed.nsec3.hash_errors\"));",
          "618:     } else if (state.numCalc == MAX_NSEC3_CALCULATIONS) {",
          "619:       log.debug(\"NSEC3 reached max. hash calculations\");",
          "620:       return new JustifiedSecStatus(SecurityStatus.UNCHECKED, -1, null);",
          "621:     }",
          "626:     CEResponse ce = this.proveClosestEncloser(qname, zonename, nsec3s, state);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "551:     } else if (ce.status == SecurityStatus.INSECURE && qtype != Type.DS) {",
          "552:       log.debug(\"Closest NSEC3 is insecure delegation\");",
          "553:       return new JustifiedSecStatus(SecurityStatus.INSECURE, -1, null);",
          "554:     }",
          "559:     Name wc = this.ceWildcard(ce.closestEncloser);",
          "561:     if (nsec3 != null) {",
          "562:       if (nsec3.hasType(qtype)) {",
          "563:         log.debug(\"Matching wildcard has qtype {}\", Type.string(qtype));",
          "",
          "[Removed Lines]",
          "560:     nsec3 = this.findMatchingNSEC3(wc, zonename, nsec3s);",
          "",
          "[Added Lines]",
          "637:     } else if (ce.status == SecurityStatus.UNCHECKED) {",
          "638:       return new JustifiedSecStatus(SecurityStatus.UNCHECKED, -1, null);",
          "645:     nsec3 = this.findMatchingNSEC3(wc, zonename, nsec3s, state);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "587:       return new JustifiedSecStatus(SecurityStatus.SECURE, -1, null);",
          "588:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "675:     if (state.numCalc == MAX_NSEC3_ERRORS) {",
          "676:       log.debug(\"NSEC3 reached max. hash calculation errors\");",
          "677:       return new JustifiedSecStatus(",
          "678:           SecurityStatus.BOGUS, DNSSEC_BOGUS, R.get(\"failed.nsec3.wc.hash_errors\"));",
          "679:     } else if (state.numCalc == MAX_NSEC3_CALCULATIONS) {",
          "680:       log.debug(\"NSEC3 reached max. hash calculations\");",
          "681:       return new JustifiedSecStatus(SecurityStatus.UNCHECKED, -1, null);",
          "682:     }",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "627:   public SecurityStatus proveWildcard(",
          "629:     if (nsec3s == null || nsec3s.isEmpty() || qname == null || wildcard == null) {",
          "630:       return SecurityStatus.BOGUS;",
          "631:     }",
          "",
          "[Removed Lines]",
          "628:       List<SRRset> nsec3s, Name qname, Name zonename, Name wildcard) {",
          "",
          "[Added Lines]",
          "723:       List<SRRset> nsec3s, Name qname, Name zonename, Name wildcard, Nsec3ValidationState state) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "639:     Name nextClosest = this.nextClosest(qname, candidate.closestEncloser);",
          "642:     if (candidate.ncNsec3 == null) {",
          "643:       log.debug(",
          "",
          "[Removed Lines]",
          "640:     candidate.ncNsec3 = this.findCoveringNSEC3(nextClosest, zonename, nsec3s);",
          "",
          "[Added Lines]",
          "735:     candidate.ncNsec3 = this.findCoveringNSEC3(nextClosest, zonename, nsec3s, state);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "672:     if (nsec3s == null || nsec3s.isEmpty()) {",
          "673:       return SecurityStatus.BOGUS;",
          "674:     }",
          "679:     if (nsec3 != null) {",
          "",
          "[Removed Lines]",
          "671:   public SecurityStatus proveNoDS(List<SRRset> nsec3s, Name qname, Name zonename) {",
          "677:     NSEC3Record nsec3 = this.findMatchingNSEC3(qname, zonename, nsec3s);",
          "",
          "[Added Lines]",
          "767:   public SecurityStatus proveNoDS(",
          "768:       List<SRRset> nsec3s, Name qname, Name zonename, Nsec3ValidationState state) {",
          "774:     NSEC3Record nsec3 = this.findMatchingNSEC3(qname, zonename, nsec3s, state);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "695:     }",
          "699:     if (ce.status != SecurityStatus.SECURE) {",
          "700:       return SecurityStatus.BOGUS;",
          "701:     }",
          "",
          "[Removed Lines]",
          "698:     CEResponse ce = this.proveClosestEncloser(qname, zonename, nsec3s);",
          "",
          "[Added Lines]",
          "795:     CEResponse ce = this.proveClosestEncloser(qname, zonename, nsec3s, state);",
          "",
          "---------------"
        ],
        "src/main/java/org/xbill/DNS/dnssec/Nsec3ValidationState.java||src/main/java/org/xbill/DNS/dnssec/Nsec3ValidationState.java": [
          "File: src/main/java/org/xbill/DNS/dnssec/Nsec3ValidationState.java -> src/main/java/org/xbill/DNS/dnssec/Nsec3ValidationState.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: package org.xbill.DNS.dnssec;",
          "4: import java.math.BigInteger;",
          "5: import java.security.NoSuchAlgorithmException;",
          "6: import java.util.HashMap;",
          "7: import java.util.Map;",
          "8: import lombok.Getter;",
          "9: import lombok.RequiredArgsConstructor;",
          "10: import org.xbill.DNS.NSEC3Record;",
          "11: import org.xbill.DNS.Name;",
          "12: import org.xbill.DNS.utils.base32;",
          "18: class Nsec3ValidationState {",
          "19:   private static final base32 b32 = new base32(base32.Alphabet.BASE32HEX, false, false);",
          "21:   private final Map<String, Nsec3CacheEntry> cache = new HashMap<>();",
          "23:   public int numCalc;",
          "24:   public int numCalcErrors;",
          "26:   public Nsec3CacheEntry computeIfAbsent(NSEC3Record nsec3, Name name)",
          "27:       throws NoSuchAlgorithmException {",
          "28:     String key = key(nsec3, name);",
          "29:     Nsec3CacheEntry entry = cache.get(key);",
          "30:     if (entry == null) {",
          "31:       byte[] hash = nsec3.hashName(name);",
          "32:       entry = new Nsec3CacheEntry(hash);",
          "33:       cache.put(key, entry);",
          "34:       numCalc++;",
          "35:     }",
          "37:     return entry;",
          "38:   }",
          "40:   @RequiredArgsConstructor",
          "41:   static class Nsec3CacheEntry {",
          "42:     @Getter private final byte[] hash;",
          "43:     private String asBase32;",
          "45:     String getHashAsBase32() {",
          "46:       if (asBase32 == null) {",
          "47:         asBase32 = b32.toString(hash);",
          "48:       }",
          "50:       return asBase32;",
          "51:     }",
          "52:   }",
          "54:   private String key(NSEC3Record nsec3, Name name) {",
          "55:     return name",
          "56:         + \"/\"",
          "57:         + nsec3.getHashAlgorithm()",
          "58:         + \"/\"",
          "59:         + nsec3.getIterations()",
          "60:         + \"/\"",
          "61:         + (nsec3.getSalt() == null ? \"-\" : new BigInteger(nsec3.getSalt()).toString());",
          "62:   }",
          "63: }",
          "",
          "---------------"
        ],
        "src/main/java/org/xbill/DNS/dnssec/ValUtils.java||src/main/java/org/xbill/DNS/dnssec/ValUtils.java": [
          "File: src/main/java/org/xbill/DNS/dnssec/ValUtils.java -> src/main/java/org/xbill/DNS/dnssec/ValUtils.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: package org.xbill.DNS.dnssec;",
          "6: import java.security.PublicKey;",
          "7: import java.security.Security;",
          "8: import java.security.interfaces.RSAPublicKey;",
          "9: import java.time.Instant;",
          "10: import java.util.List;",
          "11: import java.util.Properties;",
          "12: import lombok.extern.slf4j.Slf4j;",
          "13: import org.xbill.DNS.DClass;",
          "14: import org.xbill.DNS.DNSKEYRecord;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: import java.util.Arrays;",
          "14: import java.util.concurrent.atomic.AtomicInteger;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62:   public ValUtils() {",
          "64:     hasGost = Security.getProviders(\"MessageDigest.GOST3411\") != null;",
          "65:     hasEd25519 = Security.getProviders(\"KeyFactory.Ed25519\") != null;",
          "66:     hasEd448 = Security.getProviders(\"KeyFactory.Ed448\") != null;",
          "67:   }",
          "",
          "[Removed Lines]",
          "63:     this.verifier = new DnsSecVerifier();",
          "",
          "[Added Lines]",
          "69:     this.verifier = new DnsSecVerifier(this);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "252:   public KeyEntry verifyNewDNSKEYs(",
          "253:       SRRset dnskeyRrset, SRRset dsRrset, long badKeyTTL, Instant date) {",
          "257:       ke.setBadReason(",
          "258:           ExtendedErrorCodeOption.UNSUPPORTED_DS_DIGEST_TYPE,",
          "259:           R.get(\"failed.ds.nodigest\", dsRrset.getName()));",
          "260:       return ke;",
          "261:     }",
          "266:       ke.setBadReason(",
          "269:       return ke;",
          "270:     }",
          "275:     int numDsOk = 0;",
          "280:         continue;",
          "281:       }",
          "290:         }",
          "309:       }",
          "310:     }",
          "313:     if (numDsSizeUnsupported > 0) {",
          "315:     }",
          "321:     }",
          "324:   }",
          "328:     byte[] dsHash = ds.getDigest();",
          "",
          "[Removed Lines]",
          "254:     if (!atLeastOneSupportedDigest(dsRrset)) {",
          "255:       KeyEntry ke =",
          "256:           KeyEntry.newNullKeyEntry(dsRrset.getName(), dsRrset.getDClass(), dsRrset.getTTL());",
          "263:     if (!atLeastOneSupportedAlgorithm(dsRrset)) {",
          "264:       KeyEntry ke =",
          "265:           KeyEntry.newNullKeyEntry(dsRrset.getName(), dsRrset.getDClass(), dsRrset.getTTL());",
          "267:           ExtendedErrorCodeOption.UNSUPPORTED_DNSKEY_ALGORITHM,",
          "268:           R.get(\"failed.ds.noalg\", dsRrset.getName()));",
          "272:     int favoriteDigestID = this.favoriteDSDigestID(dsRrset);",
          "273:     int numDsChecked = 0;",
          "274:     int numDsSizeUnsupported = 0;",
          "276:     KeyEntry ke = null;",
          "277:     for (Record dsr : dsRrset.rrs()) {",
          "278:       DSRecord ds = (DSRecord) dsr;",
          "279:       if (this.digestHardenDowngrade && ds.getDigestID() != favoriteDigestID) {",
          "283:       for (Record dsnkeyr : dnskeyRrset.rrs()) {",
          "284:         DNSKEYRecord dnskey = (DNSKEYRecord) dsnkeyr;",
          "287:         if (ds.getFootprint() != dnskey.getFootprint()",
          "288:             || ds.getAlgorithm() != dnskey.getAlgorithm()) {",
          "289:           continue;",
          "292:         numDsChecked++;",
          "293:         ke = getKeyEntry(dnskeyRrset, date, ds, dnskey);",
          "294:         if (ke.isGood()) {",
          "295:           if (isKeySizeSupported(dnskey)) {",
          "296:             return ke;",
          "297:           }",
          "299:           log.trace(\"DNSKEY size not supported, skipping\");",
          "300:           ke = null;",
          "301:           numDsSizeUnsupported++;",
          "302:         } else if (numDsChecked > numDsOk + maxDsMatchFailures) {",
          "303:           ke = KeyEntry.newBadKeyEntry(dsRrset.getName(), dsRrset.getDClass(), badKeyTTL);",
          "304:           ke.setBadReason(ExtendedErrorCodeOption.DNSSEC_BOGUS, R.get(\"dnskey.no_ds_match\"));",
          "305:           return ke;",
          "306:         }",
          "314:       ke = KeyEntry.newNullKeyEntry(dsRrset.getName(), dsRrset.getDClass(), badKeyTTL);",
          "318:     if (ke == null) {",
          "319:       ke = KeyEntry.newBadKeyEntry(dsRrset.getName(), dsRrset.getDClass(), badKeyTTL);",
          "320:       ke.setBadReason(ExtendedErrorCodeOption.DNSKEY_MISSING, R.get(\"dnskey.no_ds_match\"));",
          "323:     return ke;",
          "326:   private KeyEntry getKeyEntry(SRRset dnskeyRrset, Instant date, DSRecord ds, DNSKEYRecord dnskey) {",
          "327:     KeyEntry ke;",
          "",
          "[Added Lines]",
          "257:     if (!dnskeyRrset.getName().equals(dsRrset.getName())) {",
          "258:       KeyEntry ke = KeyEntry.newBadKeyEntry(dsRrset.getName(), dsRrset.getDClass(), badKeyTTL);",
          "259:       ke.setBadReason(ExtendedErrorCodeOption.DNSSEC_BOGUS, R.get(\"dnskey.no_name_match\"));",
          "260:       return ke;",
          "261:     }",
          "263:     int favoriteDigestID;",
          "264:     AlgorithmRequirements needs = null;",
          "265:     List<Integer> sigalg = null;",
          "266:     if (digestHardenDowngrade) {",
          "267:       favoriteDigestID = this.favoriteDSDigestID(dsRrset);",
          "268:       needs = new AlgorithmRequirements(this);",
          "269:       sigalg = needs.initDs(dsRrset, favoriteDigestID);",
          "270:       log.trace(",
          "271:           \"Favorite DigestID for rrset {}/DNSKEY is {} ({})\",",
          "272:           dnskeyRrset.getName(),",
          "273:           favoriteDigestID,",
          "274:           DNSSEC.Digest.string(favoriteDigestID));",
          "275:     } else {",
          "276:       favoriteDigestID = -1;",
          "277:     }",
          "279:     boolean hasAlgoRefusal = false;",
          "280:     boolean hasCheckedDs = false;",
          "281:     boolean hasUsefulDs = false;",
          "282:     JustifiedSecStatus lastVerificationResult = null;",
          "283:     AtomicInteger numDsChecked = new AtomicInteger(0);",
          "284:     for (Record dsr : dsRrset.rrs(false)) {",
          "285:       DSRecord ds = (DSRecord) dsr;",
          "286:       if (!isDigestSupported(ds.getDigestID())) {",
          "287:         log.debug(",
          "288:             \"Digest ID {} ({}) is not supported\",",
          "289:             ds.getDigestID(),",
          "290:             DNSSEC.Digest.string(ds.getDigestID()));",
          "291:         continue;",
          "292:       }",
          "294:       if (!isAlgorithmSupported(ds.getAlgorithm())) {",
          "295:         log.debug(",
          "296:             \"Algorithm {} ({}) is not supported\",",
          "297:             ds.getAlgorithm(),",
          "298:             DNSSEC.Algorithm.string(ds.getAlgorithm()));",
          "299:         continue;",
          "300:       }",
          "302:       if ((needs != null && ds.getDigestID() != favoriteDigestID)) {",
          "303:         log.debug(",
          "304:             \"Downgrade protection prevents using digest ID {} ({})\",",
          "305:             ds.getDigestID(),",
          "306:             DNSSEC.Digest.string(ds.getDigestID()));",
          "307:         continue;",
          "308:       }",
          "310:       lastVerificationResult = verifyDnskeysWithDs(dnskeyRrset, ds, date, numDsChecked);",
          "311:       if (lastVerificationResult.status == SecurityStatus.INSECURE) {",
          "312:         log.debug(",
          "313:             \"Algorithm {} ({}) refused\",",
          "314:             ds.getAlgorithm(),",
          "315:             DNSSEC.Algorithm.string(ds.getAlgorithm()));",
          "316:         hasAlgoRefusal = true;",
          "317:         continue;",
          "318:       }",
          "320:       if (numDsChecked.get() > 0) {",
          "321:         log.debug(\"Checked #{} DS\", numDsChecked.get());",
          "322:         hasCheckedDs = true;",
          "323:       }",
          "327:       hasUsefulDs = true;",
          "329:       if (lastVerificationResult.status == SecurityStatus.SECURE) {",
          "330:         if (needs == null || needs.setSecure(ds.getAlgorithm())) {",
          "331:           if (!isKeySizeSupported(dnskeyRrset)) {",
          "332:             log.debug(",
          "333:                 \"DS {} (footprint={}, id={}, alg={}) works, but DNSKEY set contains keys that are unsupported, treat as insecure\",",
          "334:                 ds.getName(),",
          "335:                 ds.getFootprint(),",
          "336:                 ds.getDigestID(),",
          "337:                 ds.getAlgorithm());",
          "338:             return KeyEntry.newNullKeyEntry(dsRrset.getName(), dsRrset.getDClass(), badKeyTTL);",
          "339:           }",
          "341:           dnskeyRrset.setSecurityStatus(SecurityStatus.SECURE);",
          "342:           return KeyEntry.newKeyEntry(dnskeyRrset, sigalg);",
          "343:         }",
          "344:       } else if (needs != null && lastVerificationResult.status == SecurityStatus.BOGUS) {",
          "345:         needs.setBogus(ds.getAlgorithm());",
          "346:       }",
          "347:     }",
          "355:     if (hasAlgoRefusal && !hasCheckedDs) {",
          "356:       log.debug(\"No supported DS records were found -- treating as insecure\");",
          "357:       KeyEntry ke = KeyEntry.newNullKeyEntry(dsRrset.getName(), dsRrset.getDClass(), badKeyTTL);",
          "365:     if (!hasUsefulDs) {",
          "366:       log.debug(\"No usable DS records were found -- treating as insecure\");",
          "367:       KeyEntry ke = KeyEntry.newNullKeyEntry(dsRrset.getName(), dsRrset.getDClass(), badKeyTTL);",
          "369:           ExtendedErrorCodeOption.UNSUPPORTED_DS_DIGEST_TYPE,",
          "370:           R.get(\"failed.ds.no_usable_digest\", dsRrset.getName()));",
          "375:     log.debug(\"Failed to match any usable DS to a DNSKEY\");",
          "376:     if (needs != null) {",
          "377:       int alg = needs.missing();",
          "378:       if (alg != 0) {",
          "379:         log.debug(",
          "380:             \"Missing verification of DNSKEY signature with algorithm {} ({})\",",
          "381:             alg,",
          "382:             DNSSEC.Algorithm.string(alg));",
          "383:       }",
          "384:     }",
          "386:     KeyEntry ke = KeyEntry.newBadKeyEntry(dsRrset.getName(), dsRrset.getDClass(), badKeyTTL);",
          "387:     ke.setBadReason(lastVerificationResult.edeReason, lastVerificationResult.reason);",
          "388:     return ke;",
          "389:   }",
          "391:   private JustifiedSecStatus verifyDnskeysWithDs(",
          "392:       SRRset dnskeyRrset, DSRecord ds, Instant date, AtomicInteger numDsChecked) {",
          "394:     int numDsSizeUnsupported = 0;",
          "395:     for (Record dsnkeyr : dnskeyRrset.rrs(false)) {",
          "396:       DNSKEYRecord dnskey = (DNSKEYRecord) dsnkeyr;",
          "398:       log.trace(",
          "399:           \"Validating DNSKEY {} (footprint={}, alg={}) against DS {} (footprint={}, digest={}, alg={})\",",
          "400:           dnskey.getName(),",
          "401:           dnskey.getFootprint(),",
          "402:           dnskey.getAlgorithm(),",
          "403:           ds.getName(),",
          "404:           ds.getFootprint(),",
          "405:           ds.getDigestID(),",
          "406:           ds.getAlgorithm());",
          "409:       if (ds.getFootprint() != dnskey.getFootprint()",
          "410:           || ds.getAlgorithm() != dnskey.getAlgorithm()) {",
          "411:         log.trace(\"Footprint or algorithm mismatch, ignoring\");",
          "415:       numDsChecked.getAndIncrement();",
          "416:       if (!dsDigestMatchesDnskey(ds, dnskey)) {",
          "417:         log.debug(\"DS did not match DNSKEY, ignoring\");",
          "418:         if (numDsChecked.get() > numDsOk + maxDsMatchFailures) {",
          "419:           return new JustifiedSecStatus(",
          "420:               SecurityStatus.BOGUS,",
          "421:               ExtendedErrorCodeOption.DNSSEC_BOGUS,",
          "422:               R.get(\"dnskey.ds_max_match\"));",
          "425:         continue;",
          "426:       }",
          "428:       numDsOk++;",
          "429:       if (!isKeySizeSupported(dnskey)) {",
          "430:         log.debug(\"DS okay but that DNSKEY size is not supported\");",
          "431:         numDsSizeUnsupported++;",
          "432:         continue;",
          "433:       }",
          "437:       JustifiedSecStatus sec = this.verifier.verify(dnskeyRrset, dnskey, date);",
          "438:       if (sec.status == SecurityStatus.SECURE) {",
          "439:         return sec;",
          "446:       return new JustifiedSecStatus(SecurityStatus.INSECURE, -1, null);",
          "449:     if (numDsChecked.get() == 0) {",
          "450:       return new JustifiedSecStatus(",
          "451:           SecurityStatus.BOGUS,",
          "452:           ExtendedErrorCodeOption.DNSKEY_MISSING,",
          "453:           R.get(",
          "454:               \"dnskey.no_ds_alg_match\",",
          "455:               dnskeyRrset.getName(),",
          "456:               DNSSEC.Algorithm.string(ds.getAlgorithm())));",
          "457:     } else if (numDsOk == 0) {",
          "458:       return new JustifiedSecStatus(",
          "459:           SecurityStatus.BOGUS, ExtendedErrorCodeOption.DNSSEC_BOGUS, R.get(\"dnskey.no_ds_match\"));",
          "462:     return new JustifiedSecStatus(",
          "463:         SecurityStatus.BOGUS,",
          "464:         ExtendedErrorCodeOption.DNSSEC_BOGUS,",
          "465:         R.get(\"dnskey.ds_match_mismatch\"));",
          "468:   private boolean dsDigestMatchesDnskey(DSRecord ds, DNSKEYRecord dnskey) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "333:       DSRecord keyDigest = new DSRecord(Name.root, ds.getDClass(), 0, ds.getDigestID(), dnskey);",
          "334:       keyHash = keyDigest.getDigest();",
          "335:     } catch (IllegalArgumentException iae) {",
          "354:     }",
          "370:     }",
          "373:   }",
          "",
          "[Removed Lines]",
          "336:       ke = KeyEntry.newBadKeyEntry(ds.getName(), ds.getDClass(), ds.getTTL());",
          "337:       ke.setBadReason(ExtendedErrorCodeOption.DNSSEC_BOGUS, R.get(\"dnskey.invalid\"));",
          "338:       return ke;",
          "339:     }",
          "342:     if (keyHash.length != dsHash.length) {",
          "343:       ke = KeyEntry.newBadKeyEntry(ds.getName(), ds.getDClass(), ds.getTTL());",
          "344:       ke.setBadReason(ExtendedErrorCodeOption.DNSSEC_BOGUS, R.get(\"dnskey.invalid\"));",
          "345:       return ke;",
          "346:     }",
          "348:     for (int k = 0; k < keyHash.length; k++) {",
          "349:       if (keyHash[k] != dsHash[k]) {",
          "350:         ke = KeyEntry.newBadKeyEntry(ds.getName(), ds.getDClass(), ds.getTTL());",
          "351:         ke.setBadReason(ExtendedErrorCodeOption.DNSSEC_BOGUS, R.get(\"dnskey.invalid\"));",
          "352:         return ke;",
          "353:       }",
          "358:     JustifiedSecStatus res = this.verifier.verify(dnskeyRrset, dnskey, date);",
          "359:     switch (res.status) {",
          "360:       case SECURE:",
          "361:         dnskeyRrset.setSecurityStatus(SecurityStatus.SECURE);",
          "362:         ke = KeyEntry.newKeyEntry(dnskeyRrset);",
          "363:         break;",
          "364:       case BOGUS:",
          "365:         ke = KeyEntry.newBadKeyEntry(ds.getName(), ds.getDClass(), ds.getTTL());",
          "366:         ke.setBadReason(res.edeReason, res.reason);",
          "367:         break;",
          "368:       default:",
          "369:         throw new IllegalStateException(\"Unexpected security status\");",
          "372:     return ke;",
          "",
          "[Added Lines]",
          "477:       log.debug(\"Digest generation failed\", iae);",
          "478:       return false;",
          "481:     if (!Arrays.equals(keyHash, dsHash)) {",
          "482:       log.debug(\"Hash mismatch: key {} != ds {}\", keyHash, dsHash);",
          "483:       return false;",
          "486:     return true;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "384:   int favoriteDSDigestID(SRRset dsset) {",
          "385:     if (this.digestPreference == null) {",
          "386:       int max = 0;",
          "388:         DSRecord ds = (DSRecord) r;",
          "389:         if (ds.getDigestID() > max",
          "390:             && isDigestSupported(ds.getDigestID())",
          "",
          "[Removed Lines]",
          "387:       for (Record r : dsset.rrs()) {",
          "",
          "[Added Lines]",
          "501:       for (Record r : dsset.rrs(false)) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "396:       return max;",
          "397:     } else {",
          "398:       for (int preference : this.digestPreference) {",
          "400:           DSRecord ds = (DSRecord) r;",
          "401:           if (ds.getDigestID() == preference) {",
          "402:             return ds.getDigestID();",
          "",
          "[Removed Lines]",
          "399:         for (Record r : dsset.rrs()) {",
          "",
          "[Added Lines]",
          "513:         for (Record r : dsset.rrs(false)) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "421:     if (rrset.getSecurityStatus() == SecurityStatus.SECURE) {",
          "422:       log.trace(",
          "423:           \"RRset <{}/{}/{}> previously found to be SECURE\",",
          "",
          "[Removed Lines]",
          "420:   public JustifiedSecStatus verifySRRset(SRRset rrset, SRRset keyRrset, Instant date) {",
          "",
          "[Added Lines]",
          "534:   public JustifiedSecStatus verifySRRset(SRRset rrset, KeyEntry keyRrset, Instant date) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "738:   public JustifiedSecStatus nsecProvesNodataDsReply(",
          "740:     Name qname = request.getQuestion().getName();",
          "741:     int qclass = request.getQuestion().getDClass();",
          "",
          "[Removed Lines]",
          "739:       Message request, SMessage response, SRRset keyRrset, Instant date) {",
          "",
          "[Added Lines]",
          "853:       Message request, SMessage response, KeyEntry keyRrset, Instant date) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "779:         return new JustifiedSecStatus(res.status, res.edeReason, R.get(\"failed.ds.nsec.ent\"));",
          "780:       }",
          "783:       ndp = ValUtils.nsecProvesNodata(set, nsec, qname, Type.DS);",
          "784:       if (ndp.result) {",
          "785:         hasValidNSEC = true;",
          "",
          "[Removed Lines]",
          "782:       NSECRecord nsec = (NSECRecord) set.rrs().get(0);",
          "",
          "[Added Lines]",
          "896:       NSECRecord nsec = (NSECRecord) set.rrs(false).get(0);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "873:   boolean atLeastOneSupportedAlgorithm(RRset dsRRset) {",
          "875:       if (isAlgorithmSupported(((DSRecord) r).getAlgorithm())) {",
          "876:         return true;",
          "877:       }",
          "",
          "[Removed Lines]",
          "874:     for (Record r : dsRRset.rrs()) {",
          "",
          "[Added Lines]",
          "988:     for (Record r : dsRRset.rrs(false)) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "918:     }",
          "919:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1041:   private boolean isKeySizeSupported(RRset dnskeyRrset) {",
          "1042:     for (Record r : dnskeyRrset.rrs(false)) {",
          "1043:       if (!isKeySizeSupported((DNSKEYRecord) r)) {",
          "1044:         return false;",
          "1045:       }",
          "1046:     }",
          "1047:     return true;",
          "1048:   }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "963:   boolean atLeastOneSupportedDigest(RRset dsRRset) {",
          "965:       if (isDigestSupported(((DSRecord) r).getDigestID())) {",
          "966:         return true;",
          "967:       }",
          "",
          "[Removed Lines]",
          "964:     for (Record r : dsRRset.rrs()) {",
          "",
          "[Added Lines]",
          "1093:     for (Record r : dsRRset.rrs(false)) {",
          "",
          "---------------"
        ],
        "src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java||src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java": [
          "File: src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java -> src/main/java/org/xbill/DNS/dnssec/ValidatingResolver.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "289:   private CompletionStage<Void> validatePositiveResponse(",
          "291:     Map<Name, Name> wcs = new HashMap<>(1);",
          "292:     List<SRRset> nsec3s = new ArrayList<>(0);",
          "293:     List<SRRset> nsecs = new ArrayList<>(0);",
          "",
          "[Removed Lines]",
          "290:       Message request, SMessage response, Executor executor) {",
          "",
          "[Added Lines]",
          "292:       Message request, SMessage response, Nsec3ValidationState nsec3State, Executor executor) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "360:                   if (!wcNsecOk && !nsec3s.isEmpty()) {",
          "362:                       response.setStatus(",
          "363:                           SecurityStatus.INSECURE, -1, R.get(\"failed.nsec3_ignored\"));",
          "364:                       return;",
          "",
          "[Removed Lines]",
          "361:                     if (this.n3valUtils.allNSEC3sIgnoreable(nsec3s, this.keyCache)) {",
          "",
          "[Added Lines]",
          "363:                     if (this.n3valUtils.allNSEC3sIgnorable(nsec3s, this.keyCache)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "367:                     SecurityStatus status =",
          "368:                         this.n3valUtils.proveWildcard(",
          "370:                     if (status == SecurityStatus.INSECURE) {",
          "371:                       response.setStatus(status, -1);",
          "372:                       return;",
          "",
          "[Removed Lines]",
          "369:                             nsec3s, wc.getKey(), nsec3s.get(0).getSignerName(), wc.getValue());",
          "",
          "[Added Lines]",
          "371:                             nsec3s,",
          "372:                             wc.getKey(),",
          "373:                             nsec3s.get(0).getSignerName(),",
          "374:                             wc.getValue(),",
          "375:                             nsec3State);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "556:   private CompletionStage<Void> validateNodataResponse(",
          "558:     Name intermediateQname = request.getQuestion().getName();",
          "559:     int qtype = request.getQuestion().getType();",
          "",
          "[Removed Lines]",
          "557:       Message request, SMessage response, Executor executor) {",
          "",
          "[Added Lines]",
          "564:       Message request, SMessage response, Nsec3ValidationState nsec3State, Executor executor) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "578:     Name qname = intermediateQname;",
          "580:         .handleAsync(",
          "581:             (result, ex) -> {",
          "582:               if (ex != null) {",
          "",
          "[Removed Lines]",
          "579:     return this.validateNodataResponseRecursive(response, new AtomicInteger(0), executor)",
          "",
          "[Added Lines]",
          "586:     return this.validateNodataResponseRecursive(",
          "587:             response, new AtomicInteger(0), nsec3State, executor)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "638:                 log.debug(\"Using NSEC3 records\");",
          "642:                   response.setBogus(R.get(\"failed.nsec3_ignored\"));",
          "643:                   return null;",
          "644:                 }",
          "646:                 JustifiedSecStatus res =",
          "648:                 edeReason = res.edeReason;",
          "649:                 if (res.status == SecurityStatus.INSECURE) {",
          "650:                   response.setStatus(SecurityStatus.INSECURE, -1);",
          "",
          "[Removed Lines]",
          "641:                 if (this.n3valUtils.allNSEC3sIgnoreable(nsec3s, this.keyCache)) {",
          "647:                     this.n3valUtils.proveNodata(nsec3s, qname, qtype, nsec3Signer);",
          "",
          "[Added Lines]",
          "649:                 if (this.n3valUtils.allNSEC3sIgnorable(nsec3s, this.keyCache)) {",
          "655:                     this.n3valUtils.proveNodata(nsec3s, qname, qtype, nsec3Signer, nsec3State);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "667:   }",
          "669:   private CompletionStage<Void> validateNodataResponseRecursive(",
          "671:     if (setIndex.get() >= response.getSectionRRsets(Section.AUTHORITY).size()) {",
          "672:       return completedFuture(null);",
          "673:     }",
          "",
          "[Removed Lines]",
          "670:       SMessage response, AtomicInteger setIndex, Executor executor) {",
          "",
          "[Added Lines]",
          "678:       SMessage response,",
          "679:       AtomicInteger setIndex,",
          "680:       Nsec3ValidationState nsec3State,",
          "681:       Executor executor) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "688:                 return this.failedFuture(new Exception(\"failed.authority.nodata\"));",
          "689:               }",
          "692:             });",
          "693:   }",
          "",
          "[Removed Lines]",
          "691:               return this.validateNodataResponseRecursive(response, setIndex, executor);",
          "",
          "[Added Lines]",
          "702:               return this.validateNodataResponseRecursive(response, setIndex, nsec3State, executor);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "713:   private CompletionStage<Void> validateNameErrorResponse(",
          "715:     Name intermediateQname = request.getQuestion().getName();",
          "",
          "[Removed Lines]",
          "714:       Message request, SMessage response, Executor executor) {",
          "",
          "[Added Lines]",
          "726:       Message request, SMessage response, Nsec3ValidationState nsec3State, Executor executor) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "775:                 log.debug(\"Validating nxdomain: using NSEC3 records\");",
          "779:                   response.setStatus(SecurityStatus.INSECURE, -1, R.get(\"failed.nsec3_ignored\"));",
          "780:                   return completedFuture(null);",
          "781:                 }",
          "784:                 if (status != SecurityStatus.SECURE) {",
          "785:                   if (status == SecurityStatus.INSECURE) {",
          "786:                     response.setStatus(status, -1, R.get(\"failed.nxdomain.nsec3_insecure\"));",
          "",
          "[Removed Lines]",
          "778:                 if (this.n3valUtils.allNSEC3sIgnoreable(nsec3s, this.keyCache)) {",
          "783:                 SecurityStatus status = this.n3valUtils.proveNameError(nsec3s, qname, nsec3Signer);",
          "",
          "[Added Lines]",
          "790:                 if (this.n3valUtils.allNSEC3sIgnorable(nsec3s, this.keyCache)) {",
          "795:                 SecurityStatus status =",
          "796:                     this.n3valUtils.proveNameError(nsec3s, qname, nsec3Signer, nsec3State);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "804:                 boolean hasValidNSEC2 = hasValidNSEC;",
          "808:                     .thenRun(",
          "809:                         () -> {",
          "810:                           if (response.getStatus() == SecurityStatus.SECURE) {",
          "",
          "[Removed Lines]",
          "807:                 return this.validateNodataResponse(request, response, executor)",
          "",
          "[Added Lines]",
          "820:                 return this.validateNodataResponse(request, response, nsec3State, executor)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "896:     if (state.keyEntry == null",
          "897:         || (!state.keyEntry.getName().equals(state.signerName) && state.keyEntry.isGood())) {",
          "906:     }",
          "908:     return completedFuture(state.keyEntry);",
          "",
          "[Removed Lines]",
          "899:       state.dsRRset = trustAnchorSRRset;",
          "900:       state.keyEntry = null;",
          "901:       state.currentDSKeyName = new Name(trustAnchorRRset.getName(), 1);",
          "905:       return this.processFindKey(state, executor).thenApply(v -> state.keyEntry);",
          "",
          "[Added Lines]",
          "912:       if (trustAnchorSRRset.getType() == Type.DS) {",
          "913:         state.dsRRset = trustAnchorSRRset;",
          "914:         state.keyEntry = null;",
          "915:         state.currentDSKeyName = new Name(trustAnchorRRset.getName(), 1);",
          "918:         return this.processFindKey(state, executor).thenApply(v -> state.keyEntry);",
          "919:       } else {",
          "920:         state.keyEntry = KeyEntry.newKeyEntry(trustAnchorSRRset);",
          "921:         state.keyEntry.setSecurityStatus(SecurityStatus.SECURE);",
          "922:         this.keyCache.store(state.keyEntry);",
          "923:       }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "990:     Name qname = request.getQuestion().getName();",
          "991:     int qclass = request.getQuestion().getDClass();",
          "",
          "[Removed Lines]",
          "989:   private KeyEntry dsResponseToKE(SMessage response, Message request, SRRset keyRrset) {",
          "",
          "[Added Lines]",
          "1007:   private KeyEntry dsResponseToKE(SMessage response, Message request, KeyEntry keyRrset) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1057:     Name qname = request.getQuestion().getName();",
          "1058:     int qclass = request.getQuestion().getDClass();",
          "1059:     KeyEntry bogusKE = KeyEntry.newBadKeyEntry(qname, qclass, DEFAULT_TA_BAD_KEY_TTL);",
          "",
          "[Removed Lines]",
          "1056:   private KeyEntry dsResponseToKeForNodata(SMessage response, Message request, SRRset keyRrset) {",
          "",
          "[Added Lines]",
          "1074:   private KeyEntry dsResponseToKeForNodata(SMessage response, Message request, KeyEntry keyRrset) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1108:         nsec3s.add(nsec3set);",
          "1109:       }",
          "1112:         case INSECURE:",
          "",
          "[Removed Lines]",
          "1111:       switch (this.n3valUtils.proveNoDS(nsec3s, qname, nsec3Signer)) {",
          "",
          "[Added Lines]",
          "1129:       Nsec3ValidationState nsec3State = new Nsec3ValidationState();",
          "1130:       switch (this.n3valUtils.proveNoDS(nsec3s, qname, nsec3Signer, nsec3State)) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1208:       this.removeSpuriousAuthority(response);",
          "1209:     }",
          "1211:     CompletionStage<Void> completionStage;",
          "1212:     switch (subtype) {",
          "1213:       case POSITIVE:",
          "1214:       case CNAME:",
          "1215:       case ANY:",
          "1216:         log.trace(\"Validating a positive response\");",
          "1218:         break;",
          "1220:       case NODATA:",
          "1221:         log.trace(\"Validating a nodata response\");",
          "1223:         break;",
          "1225:       case CNAME_NODATA:",
          "1226:         log.trace(\"Validating a CNAME_NODATA response\");",
          "1227:         completionStage =",
          "1229:                 .thenCompose(",
          "1230:                     v -> {",
          "1231:                       if (response.getStatus() != SecurityStatus.INSECURE) {",
          "1232:                         response.setStatus(SecurityStatus.UNCHECKED, -1);",
          "1234:                       }",
          "1236:                       return completedFuture(null);",
          "",
          "[Removed Lines]",
          "1217:         completionStage = this.validatePositiveResponse(request, response, executor);",
          "1222:         completionStage = this.validateNodataResponse(request, response, executor);",
          "1228:             this.validatePositiveResponse(request, response, executor)",
          "1233:                         return this.validateNodataResponse(request, response, executor);",
          "",
          "[Added Lines]",
          "1230:     Nsec3ValidationState nsec3State = new Nsec3ValidationState();",
          "1237:         completionStage = this.validatePositiveResponse(request, response, nsec3State, executor);",
          "1242:         completionStage = this.validateNodataResponse(request, response, nsec3State, executor);",
          "1248:             this.validatePositiveResponse(request, response, nsec3State, executor)",
          "1253:                         return this.validateNodataResponse(request, response, nsec3State, executor);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1240:       case NAMEERROR:",
          "1241:         log.trace(\"Validating a nxdomain response\");",
          "1243:         break;",
          "1245:       case CNAME_NAMEERROR:",
          "1246:         log.trace(\"Validating a cname_nxdomain response\");",
          "1247:         completionStage =",
          "1249:                 .thenCompose(",
          "1250:                     v -> {",
          "1251:                       if (response.getStatus() != SecurityStatus.INSECURE) {",
          "1252:                         response.setStatus(SecurityStatus.UNCHECKED, -1);",
          "1254:                       }",
          "1256:                       return completedFuture(null);",
          "",
          "[Removed Lines]",
          "1242:         completionStage = this.validateNameErrorResponse(request, response, executor);",
          "1248:             this.validatePositiveResponse(request, response, executor)",
          "1253:                         return this.validateNameErrorResponse(request, response, executor);",
          "",
          "[Added Lines]",
          "1262:         completionStage = this.validateNameErrorResponse(request, response, nsec3State, executor);",
          "1268:             this.validatePositiveResponse(request, response, nsec3State, executor)",
          "1273:                         return this.validateNameErrorResponse(",
          "1274:                             request, response, nsec3State, executor);",
          "",
          "---------------"
        ],
        "src/main/resources/messages.properties||src/main/resources/messages.properties": [
          "File: src/main/resources/messages.properties -> src/main/resources/messages.properties",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: failed.nsec3.not_optout=NSEC3 was not opt-out",
          "26: failed.nsec3.qname_ce=NSEC3 did not match query name and closest encloser not found",
          "27: failed.nsec3_ignored=All NSEC3s were validated but ignored due to unknown algorithms or invalid iteration counts.",
          "28: failed.nxdomain.nsec3_bogus=NSEC3 failed to proof the name error.",
          "29: failed.nxdomain.nsec3_insecure=NSEC3 proofed that the target domain is under opt-out, response is insecure.",
          "30: failed.nxdomain.exists=NameError response has failed to prove that {0} does not exist.",
          "31: failed.nxdomain.haswildcard=NameError response has failed to prove that the covering wildcard does not exist.",
          "32: dnskey.no_rrset=Missing DNSKEY RRset in response to DNSKEY query for {0}.",
          "33: dnskey.no_ds_match=Did not match a DS to a DNSKEY.",
          "34: dnskey.no_key=No key for signature {0}",
          "36: dnskey.key_offtree=Signer name {0} is off-tree for {1}",
          "37: dnskey.no_match=Key does not match signature",
          "38: dnskey.expired=Key expired",
          "",
          "[Removed Lines]",
          "35: dnskey.no_sigs=No signatures for RRset {0}/{1}",
          "",
          "[Added Lines]",
          "28: failed.nsec3.hash_errors=All attempted hash calculations while finding a matching NSEC3 were erroneous.",
          "29: failed.nsec3.wc.hash_errors=All attempted hash calculations while matching wildcard were erroneous.",
          "36: dnskey.no_ds_alg_match=No keys for {0} have a DS for alg {1}",
          "37: dnskey.no_name_match=DS and DNSKEY names do not match.",
          "39: dnskey.ds_max_match=DS match max. attempt reached",
          "40: dnskey.ds_match_mismatch=Keyset not secured by DNSKEY that matches DS",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "56: failed.ds.unknown=Ran out of validation options, thus bogus.",
          "57: failed.ds.notype=Encountered an unhandled type ({0}) of DS response, thus bogus.",
          "58: failed.ds.nodigest=No supported digest ID for DS for {0}.",
          "60: validate.insecure_unsigned=Unsigned response was proved to be validly INSECURE",
          "61: validate.bogus=Could not establish validation of INSECURE status of unsigned response. Reason: {0}",
          "62: validate.bogus.badkey=Could not establish a chain of trust to keys for [{0}]. Reason: {1}",
          "63: validate.bogus.missingsig=Could not validate RRset due to missing signature.",
          "64: validate.bogus.missingsig_named=Could not validate RRset {0}/{1} due to missing signature.",
          "66: validate.bogus.rrsigtoomany=Could not validate RRset {0}/{1}, too many signatures.",
          "67: validate.insecure=Verified that response is INSECURE",
          "68: validate.response.unknown=Response subtype is {0} and thus cannot be validated.",
          "69: insecure.ds.noalgorithms=No supported algorithms in DS RRset for {0}, treating as insecure.",
          "70: failed.dname.wildcard=Illegal DNAME ({0} is from a wildcard expansion).",
          "",
          "[Removed Lines]",
          "59: failed.ds.noalg=No supported algorithm ID on DS for {0}.",
          "65: validate.bogus.allinvalid=Could not validate RRset {0}/{1}, signature(s) were invalid.",
          "",
          "[Added Lines]",
          "64: failed.ds.no_usable_digest=No usable digest ID for DS for {0}.",
          "72: validate.insecure.noalg={0} has no known algorithms",
          "",
          "---------------"
        ],
        "src/test/java/org/xbill/DNS/dnssec/DnsSecVerifierTests.java||src/test/java/org/xbill/DNS/dnssec/DnsSecVerifierTests.java": [
          "File: src/test/java/org/xbill/DNS/dnssec/DnsSecVerifierTests.java -> src/test/java/org/xbill/DNS/dnssec/DnsSecVerifierTests.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: import org.xbill.DNS.RRset;",
          "23: public class DnsSecVerifierTests {",
          "25:   private final DNSKEYRecord key;",
          "26:   private final RRset unsigned;",
          "27:   private final RRset signed;",
          "28:   private final RRset multiSigned;",
          "",
          "[Removed Lines]",
          "24:   private final DnsSecVerifier verifier = new DnsSecVerifier();",
          "",
          "[Added Lines]",
          "24:   private final DnsSecVerifier verifier = new DnsSecVerifier(new ValUtils());",
          "26:   private final KeyEntry keyEntry;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "41:             DNSKEYRecord.Protocol.DNSSEC,",
          "42:             DNSSEC.Algorithm.RSASHA256,",
          "43:             rsaKeyPair.getPublic());",
          "44:     unsigned = new RRset(new ARecord(Name.root, DClass.IN, 3600, new byte[4]));",
          "45:     signed = new RRset(new ARecord(Name.root, DClass.IN, 3600, new byte[4]));",
          "46:     Instant inception = Instant.ofEpochSecond(3600);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "45:     keyEntry = KeyEntry.newKeyEntry(new SRRset(key));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "69:   void validateUnsigned(boolean asSet) {",
          "70:     JustifiedSecStatus status;",
          "71:     if (asSet) {",
          "73:     } else {",
          "74:       status = verifier.verify(unsigned, key, Instant.ofEpochSecond(5400));",
          "75:     }",
          "",
          "[Removed Lines]",
          "72:       status = verifier.verify(new SRRset(unsigned), new RRset(key), Instant.ofEpochSecond(5400));",
          "",
          "[Added Lines]",
          "74:       status = verifier.verify(new SRRset(unsigned), keyEntry, Instant.ofEpochSecond(5400));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "84:   void validateValid(boolean asSet) {",
          "85:     JustifiedSecStatus status;",
          "86:     if (asSet) {",
          "88:     } else {",
          "89:       status = verifier.verify(signed, key, Instant.ofEpochSecond(5400));",
          "90:     }",
          "",
          "[Removed Lines]",
          "87:       status = verifier.verify(new SRRset(signed), new RRset(key), Instant.ofEpochSecond(5400));",
          "",
          "[Added Lines]",
          "89:       status = verifier.verify(new SRRset(signed), keyEntry, Instant.ofEpochSecond(5400));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "99:   void validateNotYetValid(boolean asSet) {",
          "100:     JustifiedSecStatus status;",
          "101:     if (asSet) {",
          "103:     } else {",
          "104:       status = verifier.verify(signed, key, Instant.ofEpochSecond(1800));",
          "105:     }",
          "",
          "[Removed Lines]",
          "102:       status = verifier.verify(new SRRset(signed), new RRset(key), Instant.ofEpochSecond(1800));",
          "",
          "[Added Lines]",
          "104:       status = verifier.verify(new SRRset(signed), keyEntry, Instant.ofEpochSecond(1800));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "114:   void validateExpired(boolean asSet) {",
          "115:     JustifiedSecStatus status;",
          "116:     if (asSet) {",
          "118:     } else {",
          "119:       status = verifier.verify(signed, key, Instant.ofEpochSecond(8000));",
          "120:     }",
          "",
          "[Removed Lines]",
          "117:       status = verifier.verify(new SRRset(signed), new RRset(key), Instant.ofEpochSecond(8000));",
          "",
          "[Added Lines]",
          "119:       status = verifier.verify(new SRRset(signed), keyEntry, Instant.ofEpochSecond(8000));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "135:     JustifiedSecStatus status;",
          "136:     if (asSet) {",
          "139:     } else {",
          "140:       status = verifier.verify(multiSigned, key, Instant.ofEpochSecond(7208));",
          "141:     }",
          "",
          "[Removed Lines]",
          "137:       status =",
          "138:           verifier.verify(new SRRset(multiSigned), new RRset(key), Instant.ofEpochSecond(7208));",
          "",
          "[Added Lines]",
          "139:       status = verifier.verify(new SRRset(multiSigned), keyEntry, Instant.ofEpochSecond(7208));",
          "",
          "---------------"
        ],
        "src/test/java/org/xbill/DNS/dnssec/TestAlgorithmSupport.java||src/test/java/org/xbill/DNS/dnssec/TestAlgorithmSupport.java": [
          "File: src/test/java/org/xbill/DNS/dnssec/TestAlgorithmSupport.java -> src/test/java/org/xbill/DNS/dnssec/TestAlgorithmSupport.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:   void testDigestIdIsUnknown() throws IOException {",
          "57:     Message response = resolver.send(createMessage(\"unknown-alg.ingotronic.ch./A\"));",
          "58:     assertFalse(response.getHeader().getFlag(Flags.AD), \"AD flag must not be set\");",
          "60:     assertRCode(Rcode.NOERROR, response.getRcode());",
          "61:     assertEde(ExtendedErrorCodeOption.UNSUPPORTED_DS_DIGEST_TYPE, response);",
          "62:   }",
          "",
          "[Removed Lines]",
          "59:     assertEquals(\"failed.ds.nodigest:unknown-alg.ingotronic.ch.\", getReason(response));",
          "",
          "[Added Lines]",
          "60:     assertEquals(\"failed.ds.no_usable_digest:unknown-alg.ingotronic.ch.\", getReason(response));",
          "",
          "---------------"
        ],
        "src/test/java/org/xbill/DNS/dnssec/TestBase.java||src/test/java/org/xbill/DNS/dnssec/TestBase.java": [
          "File: src/test/java/org/xbill/DNS/dnssec/TestBase.java -> src/test/java/org/xbill/DNS/dnssec/TestBase.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: import java.lang.reflect.Method;",
          "18: import java.nio.charset.StandardCharsets;",
          "19: import java.time.Clock;",
          "20: import java.time.ZonedDateTime;",
          "21: import java.time.format.DateTimeFormatter;",
          "22: import java.util.HashMap;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: import java.time.Duration;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "158:   }",
          "160:   private void setup() throws NumberFormatException, IOException, DNSSECException {",
          "161:     resolver =",
          "162:         new ValidatingResolver(",
          "163:             new SimpleResolver(\"8.8.4.4\") {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "163:     System.setProperty(\"dnsjava.dnssec.algorithm_rsa_min_key_size\", \"1023\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "194:             resolverClock);",
          "196:     resolver.loadTrustAnchors(getClass().getResourceAsStream(\"/trust_anchors\"));",
          "197:   }",
          "199:   protected void add(Message m) throws IOException {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "200:     resolver.setTimeout(Duration.ofHours(1));",
          "",
          "---------------"
        ],
        "src/test/java/org/xbill/DNS/dnssec/TestCNames.java||src/test/java/org/xbill/DNS/dnssec/TestCNames.java": [
          "File: src/test/java/org/xbill/DNS/dnssec/TestCNames.java -> src/test/java/org/xbill/DNS/dnssec/TestCNames.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "74:     assertFalse(response.getHeader().getFlag(Flags.AD), \"AD flag must not be set\");",
          "75:     assertRCode(Rcode.SERVFAIL, response.getRcode());",
          "76:     assertEquals(",
          "78:     assertEde(ExtendedErrorCodeOption.DNSKEY_MISSING, response);",
          "79:   }",
          "",
          "[Removed Lines]",
          "77:         \"validate.bogus.badkey:dnssec-failed.org.:dnskey.no_ds_match\", getReason(response));",
          "",
          "[Added Lines]",
          "77:         \"validate.bogus.badkey:dnssec-failed.org.:dnskey.no_ds_alg_match:dnssec-failed.org.:RSASHA1\",",
          "78:         getReason(response));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "102:     assertFalse(response.getHeader().getFlag(Flags.AD), \"AD flag must not be set\");",
          "103:     assertRCode(Rcode.SERVFAIL, response.getRcode());",
          "104:     assertEquals(",
          "106:     assertEde(ExtendedErrorCodeOption.DNSKEY_MISSING, response);",
          "107:   }",
          "",
          "[Removed Lines]",
          "105:         \"validate.bogus.badkey:dnssec-failed.org.:dnskey.no_ds_match\", getReason(response));",
          "",
          "[Added Lines]",
          "106:         \"validate.bogus.badkey:dnssec-failed.org.:dnskey.no_ds_alg_match:dnssec-failed.org.:RSASHA1\",",
          "107:         getReason(response));",
          "",
          "---------------"
        ],
        "src/test/java/org/xbill/DNS/dnssec/TestNormallyUnreachableCode.java||src/test/java/org/xbill/DNS/dnssec/TestNormallyUnreachableCode.java": [
          "File: src/test/java/org/xbill/DNS/dnssec/TestNormallyUnreachableCode.java -> src/test/java/org/xbill/DNS/dnssec/TestNormallyUnreachableCode.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: import org.xbill.DNS.Message;",
          "15: import org.xbill.DNS.Name;",
          "16: import org.xbill.DNS.OPTRecord;",
          "18: import org.xbill.DNS.Record;",
          "19: import org.xbill.DNS.Section;",
          "20: import org.xbill.DNS.Type;",
          "",
          "[Removed Lines]",
          "17: import org.xbill.DNS.RRset;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35:   @Test",
          "36:   void testVerifyWithoutSignaturesIsBogus() {",
          "38:     ARecord record = new ARecord(Name.root, DClass.IN, 120, localhost);",
          "39:     SRRset set = new SRRset();",
          "40:     set.addRR(record);",
          "42:     JustifiedSecStatus res = verifier.verify(set, keys, Instant.now());",
          "43:     assertEquals(SecurityStatus.BOGUS, res.status);",
          "44:     assertEquals(ExtendedErrorCodeOption.RRSIGS_MISSING, res.edeReason);",
          "",
          "[Removed Lines]",
          "37:     DnsSecVerifier verifier = new DnsSecVerifier();",
          "41:     RRset keys = new RRset();",
          "",
          "[Added Lines]",
          "36:     DnsSecVerifier verifier = new DnsSecVerifier(new ValUtils());",
          "40:     KeyEntry keys = KeyEntry.newKeyEntry(new SRRset());",
          "",
          "---------------"
        ],
        "src/test/java/org/xbill/DNS/dnssec/TestNsec3ValUtilsPublicKeyLoading.java||src/test/java/org/xbill/DNS/dnssec/TestNsec3ValUtilsPublicKeyLoading.java": [
          "File: src/test/java/org/xbill/DNS/dnssec/TestNsec3ValUtilsPublicKeyLoading.java -> src/test/java/org/xbill/DNS/dnssec/TestNsec3ValUtilsPublicKeyLoading.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: import java.lang.reflect.Constructor;",
          "10: import java.lang.reflect.InvocationTargetException;",
          "11: import java.security.PublicKey;",
          "13: import java.util.concurrent.atomic.AtomicInteger;",
          "14: import org.junit.jupiter.api.Test;",
          "15: import org.mockito.stubbing.Answer;",
          "",
          "[Removed Lines]",
          "12: import java.time.Duration;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "26:   @PrepareMocks(\"prepareTestPublicKeyLoadingException\")",
          "27:   void testPublicKeyLoadingException() throws Exception {",
          "28:     try {",
          "30:       Message response = resolver.send(createMessage(\"www.wc.nsec3.ingotronic.ch./A\"));",
          "31:       assertFalse(response.getHeader().getFlag(Flags.AD), \"AD flag must not be set\");",
          "32:       assertRCode(Rcode.NOERROR, response.getRcode());",
          "",
          "[Removed Lines]",
          "29:       resolver.setTimeout(Duration.ofDays(1));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "49:                     (Answer<PublicKey>)",
          "50:                         a -> {",
          "51:                           if (((DNSKEYRecord) a.getMock()).getName().equals(fakeName)) {",
          "53:                               throwDnssecException();",
          "54:                             }",
          "55:                             return (PublicKey) a.callRealMethod();",
          "",
          "[Removed Lines]",
          "52:                             if (invocationCount.getAndIncrement() == 3) {",
          "",
          "[Added Lines]",
          "50:                             if (invocationCount.getAndIncrement() == 4) {",
          "",
          "---------------"
        ],
        "src/test/java/org/xbill/DNS/dnssec/TestPriming.java||src/test/java/org/xbill/DNS/dnssec/TestPriming.java": [
          "File: src/test/java/org/xbill/DNS/dnssec/TestPriming.java -> src/test/java/org/xbill/DNS/dnssec/TestPriming.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:     Message response = resolver.send(createMessage(\"www.ingotronic.ch./A\"));",
          "65:     assertFalse(response.getHeader().getFlag(Flags.AD), \"AD flag must not be set\");",
          "67:     assertRCode(Rcode.SERVFAIL, response.getRcode());",
          "68:     assertEde(ExtendedErrorCodeOption.DNSSEC_BOGUS, response);",
          "69:   }",
          "",
          "[Removed Lines]",
          "66:     assertEquals(\"validate.bogus.badkey:.:dnskey.invalid\", getReason(response));",
          "",
          "[Added Lines]",
          "67:     assertEquals(\"validate.bogus.badkey:.:dnskey.no_ds_match\", getReason(response));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:     try {",
          "75:       Message response = resolver.send(createMessage(\"www.ingotronic.ch./A\"));",
          "76:       assertFalse(response.getHeader().getFlag(Flags.AD), \"AD flag must not be set\");",
          "78:       assertRCode(Rcode.SERVFAIL, response.getRcode());",
          "79:       assertEde(ExtendedErrorCodeOption.DNSKEY_MISSING, response);",
          "80:     } finally {",
          "81:       Type.register(Type.DNSKEY, Type.string(Type.DNSKEY), () -> spy(DNSKEYRecord.class));",
          "",
          "[Removed Lines]",
          "77:       assertEquals(\"validate.bogus.badkey:.:dnskey.no_ds_match\", getReason(response));",
          "",
          "[Added Lines]",
          "78:       assertEquals(",
          "79:           \"validate.bogus.badkey:.:dnskey.no_ds_alg_match:.:RSASHA256\", getReason(response));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "99:     try {",
          "100:       Message response = resolver.send(createMessage(\"www.ingotronic.ch./A\"));",
          "101:       assertFalse(response.getHeader().getFlag(Flags.AD), \"AD flag must not be set\");",
          "103:       assertRCode(Rcode.SERVFAIL, response.getRcode());",
          "104:       assertEde(ExtendedErrorCodeOption.DNSKEY_MISSING, response);",
          "105:     } finally {",
          "106:       Type.register(Type.DNSKEY, Type.string(Type.DNSKEY), () -> spy(DNSKEYRecord.class));",
          "",
          "[Removed Lines]",
          "102:       assertEquals(\"validate.bogus.badkey:.:dnskey.no_ds_match\", getReason(response));",
          "",
          "[Added Lines]",
          "104:       assertEquals(",
          "105:           \"validate.bogus.badkey:.:dnskey.no_ds_alg_match:.:RSASHA256\", getReason(response));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "149:       Security.insertProviderAt(p, 1);",
          "150:       Message response = resolver.send(createMessage(\"www.ingotronic.ch./A\"));",
          "151:       assertFalse(response.getHeader().getFlag(Flags.AD), \"AD flag must not be set\");",
          "153:       assertRCode(Rcode.SERVFAIL, response.getRcode());",
          "154:       assertEde(ExtendedErrorCodeOption.DNSSEC_BOGUS, response);",
          "155:     } finally {",
          "156:       Security.removeProvider(p.getName());",
          "",
          "[Removed Lines]",
          "152:       assertEquals(\"validate.bogus.badkey:.:dnskey.invalid\", getReason(response));",
          "",
          "[Added Lines]",
          "155:       assertEquals(\"validate.bogus.badkey:.:dnskey.no_ds_match\", getReason(response));",
          "",
          "---------------"
        ],
        "src/test/java/org/xbill/DNS/dnssec/TestTrustAnchorLoading.java||src/test/java/org/xbill/DNS/dnssec/TestTrustAnchorLoading.java": [
          "File: src/test/java/org/xbill/DNS/dnssec/TestTrustAnchorLoading.java -> src/test/java/org/xbill/DNS/dnssec/TestTrustAnchorLoading.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "93:     Message response = resolver.send(createMessage(\"www.ingotronic.ch./A\"));",
          "94:     assertFalse(response.getHeader().getFlag(Flags.AD), \"AD flag must not be set\");",
          "96:     assertRCode(Rcode.SERVFAIL, response.getRcode());",
          "97:     assertEde(ExtendedErrorCodeOption.DNSKEY_MISSING, response);",
          "98:   }",
          "",
          "[Removed Lines]",
          "95:     assertEquals(\"validate.bogus.badkey:.:dnskey.no_ds_match\", getReason(response));",
          "",
          "[Added Lines]",
          "96:     assertEquals(\"validate.bogus.badkey:.:dnskey.no_ds_alg_match:.:RSASHA256\", getReason(response));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "106:     Message response = resolver.send(createMessage(\"www.ingotronic.ch./A\"));",
          "107:     assertFalse(response.getHeader().getFlag(Flags.AD), \"AD flag must not be set\");",
          "109:     assertRCode(Rcode.SERVFAIL, response.getRcode());",
          "110:     assertEde(ExtendedErrorCodeOption.DNSSEC_BOGUS, response);",
          "111:   }",
          "",
          "[Removed Lines]",
          "108:     assertEquals(\"validate.bogus.badkey:.:dnskey.invalid\", getReason(response));",
          "",
          "[Added Lines]",
          "109:     assertEquals(\"validate.bogus.badkey:.:dnskey.no_ds_match\", getReason(response));",
          "",
          "---------------"
        ],
        "src/test/java/org/xbill/DNS/dnssec/UnboundTests.java||src/test/java/org/xbill/DNS/dnssec/UnboundTests.java": [
          "File: src/test/java/org/xbill/DNS/dnssec/UnboundTests.java -> src/test/java/org/xbill/DNS/dnssec/UnboundTests.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: import java.io.InputStream;",
          "11: import java.security.Security;",
          "12: import java.text.ParseException;",
          "13: import java.util.ArrayList;",
          "14: import java.util.HashMap;",
          "15: import java.util.List;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: import java.time.Duration;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76:       }",
          "78:       if (rpl.minRsaSize != null) {",
          "87:       List<Message> copy = new ArrayList<>(rpl.replays.size());",
          "",
          "[Removed Lines]",
          "79:       config.put(ValUtils.ALGORITHM_RSA_MIN_KEY_SIZE, Integer.toString(rpl.minRsaSize));",
          "80:     }",
          "82:     for (Message m : rpl.replays) {",
          "83:       add(m);",
          "84:     }",
          "",
          "[Added Lines]",
          "80:         config.put(ValUtils.ALGORITHM_RSA_MIN_KEY_SIZE, Integer.toString(rpl.minRsaSize));",
          "81:       }",
          "83:       for (Message m : rpl.replays) {",
          "84:         add(m);",
          "85:       }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "164:       }",
          "166:       resolver.init(config);",
          "168:       for (Check c : rpl.checks.values()) {",
          "169:         Message s = resolver.send(c.query).normalize(c.query, true);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "168:       resolver.setTimeout(Duration.ofMinutes(1));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1199:     runUnboundTest();",
          "1200:   }",
          "1203:   @Test",
          "1204:   @DisplayName(\"val_ta_algo_missing.rpl: Test validator with multiple algorithm missing one\")",
          "1205:   void val_ta_algo_missing() throws ParseException, IOException {",
          "",
          "[Removed Lines]",
          "1202:   @Disabled(\"TODO: passed before accidentally, message normalization now exposes this\")",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/test/resources/unbound/val_secds_nosig.rpl||src/test/resources/unbound/val_secds_nosig.rpl": [
          "File: src/test/resources/unbound/val_secds_nosig.rpl -> src/test/resources/unbound/val_secds_nosig.rpl",
          "--- Hunk 1 ---",
          "[Context before]",
          "5:  val-override-date: \"20070916134226\"",
          "6:  target-fetch-policy: \"0 0 0 0 0\"",
          "7:  fake-sha1: yes",
          "8:  trust-anchor-signaling: no",
          "10: stub-zone:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8:  val-min-rsa-size: 512",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "17: ; K.ROOT-SERVERS.NET.",
          "18: RANGE_BEGIN 0 100",
          "20: ENTRY_BEGIN",
          "21: MATCH opcode qtype qname",
          "22: ADJUST copy_id",
          "",
          "[Removed Lines]",
          "19:  ADDRESS 193.0.14.129",
          "",
          "[Added Lines]",
          "20:  ADDRESS 193.0.14.129",
          "",
          "---------------"
        ],
        "src/test/resources/unbound/val_ta_algo_dnskey.rpl||src/test/resources/unbound/val_ta_algo_dnskey.rpl": [
          "File: src/test/resources/unbound/val_ta_algo_dnskey.rpl -> src/test/resources/unbound/val_ta_algo_dnskey.rpl",
          "--- Hunk 1 ---",
          "[Context before]",
          "7:  target-fetch-policy: \"0 0 0 0 0\"",
          "8:  qname-minimisation: \"no\"",
          "9:  fake-sha1: yes",
          "10:  trust-anchor-signaling: no",
          "11:  minimal-responses: no",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10:  val-min-rsa-size: 512",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "20: ; K.ROOT-SERVERS.NET.",
          "21: RANGE_BEGIN 0 100",
          "23: ENTRY_BEGIN",
          "24: MATCH opcode qtype qname",
          "25: ADJUST copy_id",
          "",
          "[Removed Lines]",
          "22:  ADDRESS 193.0.14.129",
          "",
          "[Added Lines]",
          "23:  ADDRESS 193.0.14.129",
          "",
          "---------------"
        ],
        "src/test/resources/unbound/val_ta_algo_dnskey_dp.rpl||src/test/resources/unbound/val_ta_algo_dnskey_dp.rpl": [
          "File: src/test/resources/unbound/val_ta_algo_dnskey_dp.rpl -> src/test/resources/unbound/val_ta_algo_dnskey_dp.rpl",
          "--- Hunk 1 ---",
          "[Context before]",
          "8:  qname-minimisation: \"no\"",
          "9:  harden-algo-downgrade: no",
          "10:  fake-sha1: yes",
          "11:  trust-anchor-signaling: no",
          "12:  minimal-responses: no",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11:  val-min-rsa-size: 512",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "16:  stub-addr: 193.0.14.129  # K.ROOT-SERVERS.NET.",
          "17: CONFIG_END",
          "21: ; K.ROOT-SERVERS.NET.",
          "22: RANGE_BEGIN 0 100",
          "24: ENTRY_BEGIN",
          "25: MATCH opcode qtype qname",
          "26: ADJUST copy_id",
          "",
          "[Removed Lines]",
          "19: SCENARIO_BEGIN Test validator with multiple algorithm trust anchor without harden",
          "23:  ADDRESS 193.0.14.129",
          "",
          "[Added Lines]",
          "20: SCENARIO_BEGIN Test validator with multiple algorithm trust anchor without harden",
          "24:  ADDRESS 193.0.14.129",
          "",
          "---------------"
        ],
        "src/test/resources/unbound/val_ta_algo_missing.rpl||src/test/resources/unbound/val_ta_algo_missing.rpl": [
          "File: src/test/resources/unbound/val_ta_algo_missing.rpl -> src/test/resources/unbound/val_ta_algo_missing.rpl",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: ; config options",
          "2: ; The island of trust is at example.com",
          "3: server:",
          "5:  trust-anchor: \"example.com. 3600 IN DS 30899 5 1 d4bf9d2e10f6d76840d42ef5913022abcd0bf512\"",
          "6:  trust-anchor: \"example.com. 3600 IN DS 30899 7 1 d4bf9d2e10f6d76840d42ef5913022abcd0bf512\"",
          "7:  val-override-date: \"20070916134226\"",
          "8:  target-fetch-policy: \"0 0 0 0 0\"",
          "9:  qname-minimisation: \"no\"",
          "10:  harden-algo-downgrade: yes",
          "11:  fake-sha1: yes",
          "12:  trust-anchor-signaling: no",
          "14: stub-zone:",
          "",
          "[Removed Lines]",
          "4:  trust-anchor: \"example.com. 3600 IN DNSKEY 256 3 3 ALXLUsWqUrY3JYER3T4TBJIIs70j+sDS/UT2QRp61SE7S3EEXopNXoFE73JLRmvpi/UrOO/Vz4Se6wXv/CYCKjGw06U4WRgRYXcpEhJROyNapmdIKSxhOzfLVE1gqA0PweZR8dtY3aNQSRn3sPpwJr6Mi/PqQKAMMrZ9ckJpf1+bQMOOvxgzz2U1GS18b3yZKcgTMEaJzd/GZYzi/BN2DzQ0MsrSwYXfsNLFOBbs8PJMW4LYIxeeOe6rUgkWOF7CC9Dh/dduQ1QrsJhmZAEFfd6ByYV+ ;{id = 2854 (zsk), size = 1688b}\"",
          "",
          "[Added Lines]",
          "4: ; trust-anchor: \"example.com. 3600 IN DNSKEY 256 3 3 ALXLUsWqUrY3JYER3T4TBJIIs70j+sDS/UT2QRp61SE7S3EEXopNXoFE73JLRmvpi/UrOO/Vz4Se6wXv/CYCKjGw06U4WRgRYXcpEhJROyNapmdIKSxhOzfLVE1gqA0PweZR8dtY3aNQSRn3sPpwJr6Mi/PqQKAMMrZ9ckJpf1+bQMOOvxgzz2U1GS18b3yZKcgTMEaJzd/GZYzi/BN2DzQ0MsrSwYXfsNLFOBbs8PJMW4LYIxeeOe6rUgkWOF7CC9Dh/dduQ1QrsJhmZAEFfd6ByYV+ ;{id = 2854 (zsk), size = 1688b}\"",
          "5: ; dnssecjava behaves different than unbound by creating an in-memory DS record from a DNSKEY trust anchor",
          "6: ; thus add a real one here to prevent a forced digest upgrade",
          "7:  trust-anchor: \"example.com. 3600 IN DS 2854 3 1 46e4ffc6e9a4793b488954bd3f0cc6af0dfb201b\"",
          "9: ; this is the anchor that has no DNSKEY, thus causing the validation to fail with",
          "10: ; harden-algo-downgrade enabled",
          "17:  val-min-rsa-size: 512",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "21: ; K.ROOT-SERVERS.NET.",
          "22: RANGE_BEGIN 0 100",
          "24: ENTRY_BEGIN",
          "25: MATCH opcode qtype qname",
          "26: ADJUST copy_id",
          "",
          "[Removed Lines]",
          "23:  ADDRESS 193.0.14.129",
          "",
          "[Added Lines]",
          "29:  ADDRESS 193.0.14.129",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "142: www.example.com. IN A",
          "143: SECTION ANSWER",
          "144: www.example.com. IN A 10.20.30.40",
          "146: www.example.com. 3600 IN RRSIG A 5 3 3600 20070926134150 20070829134150 30899 example.com. JNWECShNE+nCLQwOXJJ3xpUkh2G+FCh5nk8uYAHIVQRse/BIvCMSlvRrtVyw9RnXvk5RR2bEgN0pRdLWW7ug5Q== ;{id = 30899}",
          "147: SECTION AUTHORITY",
          "148: example.com. IN NS ns.example.com.",
          "",
          "[Removed Lines]",
          "145: ns.example.com. 3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFQCQMyTjn7WWwpwAR1LlVeLpRgZGuQIUCcJDEkwAuzytTDRlYK7nIMwH1CM= ;{id = 2854}",
          "",
          "[Added Lines]",
          "151: www.example.com.        3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFC99iE9K5y2WNgI0gFvBWaTi9wm6AhUAoUqOpDtG5Zct+Qr9F3mSdnbc6V4= ;{id = 2854}",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "150: example.com. 3600 IN RRSIG NS 5 2 3600 20070926134150 20070829134150 30899 example.com. YTqtYba73HIOQuPr5oDyIX9pfmz1ybEBjwlD/jUgcPmFINUOZ9FeqG6ywgRKwn4AizkKTK00p1sxZYMKxl91wg== ;{id = 30899}",
          "151: SECTION ADDITIONAL",
          "152: ns.example.com.  IN  A 1.2.3.4",
          "154: ns.example.com. 3600 IN RRSIG A 5 3 3600 20070926134150 20070829134150 30899 example.com. Dn1ziMKrc3NdJkSv8g61Y9WNk3+BAuwCwnYzAZiHmkejkSCPViLJN7+f4Conp9l8LkTl50ZnLgoYrrUYNhMj6w== ;{id = 30899}",
          "155: ENTRY_END",
          "156: RANGE_END",
          "",
          "[Removed Lines]",
          "153: www.example.com.        3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFC99iE9K5y2WNgI0gFvBWaTi9wm6AhUAoUqOpDtG5Zct+Qr9F3mSdnbc6V4= ;{id = 2854}",
          "",
          "[Added Lines]",
          "159: ns.example.com. 3600    IN      RRSIG   A 3 3 3600 20070926134150 20070829134150 2854 example.com. MC0CFQCQMyTjn7WWwpwAR1LlVeLpRgZGuQIUCcJDEkwAuzytTDRlYK7nIMwH1CM= ;{id = 2854}",
          "",
          "---------------"
        ],
        "src/test/resources/unbound/val_ta_algo_missing_dp.rpl||src/test/resources/unbound/val_ta_algo_missing_dp.rpl": [
          "File: src/test/resources/unbound/val_ta_algo_missing_dp.rpl -> src/test/resources/unbound/val_ta_algo_missing_dp.rpl",
          "--- Hunk 1 ---",
          "[Context before]",
          "9:  qname-minimisation: \"no\"",
          "10:  harden-algo-downgrade: no",
          "11:  fake-sha1: yes",
          "12:  trust-anchor-signaling: no",
          "13:  minimal-responses: no",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12:  val-min-rsa-size: 512",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "22: ; K.ROOT-SERVERS.NET.",
          "23: RANGE_BEGIN 0 100",
          "25: ENTRY_BEGIN",
          "26: MATCH opcode qtype qname",
          "27: ADJUST copy_id",
          "",
          "[Removed Lines]",
          "24:  ADDRESS 193.0.14.129",
          "",
          "[Added Lines]",
          "25:  ADDRESS 193.0.14.129",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "77e049578334982794348885027261130e89b2d1",
      "candidate_info": {
        "commit_hash": "77e049578334982794348885027261130e89b2d1",
        "repo": "dnsjava/dnsjava",
        "commit_url": "https://github.com/dnsjava/dnsjava/commit/77e049578334982794348885027261130e89b2d1",
        "files": [
          "src/main/java/org/xbill/DNS/Message.java"
        ],
        "message": "Fix compiler warnings about unsigned conversions",
        "before_after_code_files": [
          "src/main/java/org/xbill/DNS/Message.java||src/main/java/org/xbill/DNS/Message.java"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/main/java/org/xbill/DNS/Message.java||src/main/java/org/xbill/DNS/Message.java"
          ],
          "candidate": [
            "src/main/java/org/xbill/DNS/Message.java||src/main/java/org/xbill/DNS/Message.java"
          ]
        }
      },
      "candidate_diff": {
        "src/main/java/org/xbill/DNS/Message.java||src/main/java/org/xbill/DNS/Message.java": [
          "File: src/main/java/org/xbill/DNS/Message.java -> src/main/java/org/xbill/DNS/Message.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:   private static final Record[] emptyRecordArray = new Record[0];",
          "63:   private Message(Header header) {",
          "65:     this.header = header;",
          "66:   }",
          "",
          "[Removed Lines]",
          "62:   @SuppressWarnings(\"unchecked\")",
          "64:     sections = new List[4];",
          "",
          "[Added Lines]",
          "62:   @SuppressWarnings({\"unchecked\"})",
          "64:     sections = (List<Record>[]) new List<?>[4];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "706:   @SuppressWarnings({\"unchecked\", \"java:S2975\"})",
          "707:   public Message clone() {",
          "708:     Message m = (Message) super.clone();",
          "710:     for (int i = 0; i < sections.length; i++) {",
          "711:       if (sections[i] != null) {",
          "712:         m.sections[i] = new LinkedList<>(sections[i]);",
          "",
          "[Removed Lines]",
          "709:     m.sections = new List[sections.length];",
          "",
          "[Added Lines]",
          "709:     m.sections = (List<Record>[]) new List<?>[sections.length];",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b842550e6c3046cdbd7969ac6ddf99af9ccdc637",
      "candidate_info": {
        "commit_hash": "b842550e6c3046cdbd7969ac6ddf99af9ccdc637",
        "repo": "dnsjava/dnsjava",
        "commit_url": "https://github.com/dnsjava/dnsjava/commit/b842550e6c3046cdbd7969ac6ddf99af9ccdc637",
        "files": [
          "pom.xml",
          "src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java"
        ],
        "message": "Remove junit-pioneer due to lack of Java 8 support",
        "before_after_code_files": [
          "src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java||src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java||src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java"
          ],
          "candidate": [
            "src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java||src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java"
          ]
        }
      },
      "candidate_diff": {
        "src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java||src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java": [
          "File: src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java -> src/test/java/org/xbill/DNS/lookup/LookupSessionTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: import static org.junit.jupiter.api.Assertions.assertAll;",
          "11: import static org.junit.jupiter.api.Assertions.assertEquals;",
          "12: import static org.junit.jupiter.api.Assertions.assertTrue;",
          "15: import static org.mockito.ArgumentMatchers.any;",
          "16: import static org.mockito.ArgumentMatchers.anyInt;",
          "17: import static org.mockito.Mockito.inOrder;",
          "",
          "[Removed Lines]",
          "13: import static org.junitpioneer.jupiter.cartesian.CartesianTest.Enum;",
          "14: import static org.junitpioneer.jupiter.cartesian.CartesianTest.Values;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58: import org.junit.jupiter.params.provider.CsvSource;",
          "59: import org.junit.jupiter.params.provider.EnumSource;",
          "60: import org.junit.jupiter.params.provider.ValueSource;",
          "62: import org.mockito.ArgumentCaptor;",
          "63: import org.mockito.InOrder;",
          "64: import org.mockito.Mock;",
          "",
          "[Removed Lines]",
          "61: import org.junitpioneer.jupiter.cartesian.CartesianTest;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "137:     verify(mockResolver).sendAsync(any(), any(Executor.class));",
          "138:   }",
          "143:       throws ExecutionException, InterruptedException {",
          "144:     wireUpMockResolver(",
          "145:         mockResolver, query -> multiAnswer(query, name -> new Record[] {LOOPBACK_A, EXAMPLE_A}));",
          "",
          "[Removed Lines]",
          "140:   @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")",
          "141:   void lookupAsync_absoluteQueryNoExtra(",
          "142:       @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)",
          "",
          "[Added Lines]",
          "137:   @ParameterizedTest",
          "138:   @CsvSource(",
          "139:       value = {",
          "140:         \"true,REMOVE\",",
          "141:         \"true,THROW\",",
          "142:         \"false,REMOVE\",",
          "143:         \"false,THROW\",",
          "144:       })",
          "145:   void lookupAsync_absoluteQueryNoExtra(boolean useCache, IrrelevantRecordMode mode)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "493:     verify(mockResolver, times(3)).sendAsync(any(), any(Executor.class));",
          "494:   }",
          "497:   void lookupAsync_twoDnameRedirectOneQuery(",
          "501:       throws Exception {",
          "502:     wireUpMockResolver(",
          "503:         mockResolver,",
          "",
          "[Removed Lines]",
          "496:   @CartesianTest(name = \"useCache={0}, includeSyntheticCnames={1}, irrelevantRecordMode={2}\")",
          "498:       @Values(booleans = {true, false}) boolean useCache,",
          "499:       @Values(booleans = {true, false}) boolean includeSyntheticCnames,",
          "500:       @Enum IrrelevantRecordMode mode)",
          "",
          "[Added Lines]",
          "499:   @ParameterizedTest",
          "500:   @CsvSource(",
          "501:       value = {",
          "502:         \"true,true,REMOVE\",",
          "503:         \"true,true,THROW\",",
          "504:         \"true,false,REMOVE\",",
          "505:         \"true,false,THROW\",",
          "506:         \"false,false,REMOVE\",",
          "507:         \"false,false,THROW\",",
          "508:         \"false,true,REMOVE\",",
          "509:         \"false,true,THROW\",",
          "510:       })",
          "512:       boolean useCache, boolean includeSyntheticCnames, IrrelevantRecordMode mode)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "738:     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));",
          "739:   }",
          "744:       throws ExecutionException, InterruptedException {",
          "745:     Name query = name(\"cname.r.\");",
          "746:     Name target = name(\"a.b.\");",
          "",
          "[Removed Lines]",
          "741:   @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")",
          "742:   void lookupAsync_cnameQueryExtra(",
          "743:       @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)",
          "",
          "[Added Lines]",
          "753:   @ParameterizedTest",
          "754:   @CsvSource(",
          "755:       value = {",
          "756:         \"true,REMOVE\",",
          "757:         \"true,THROW\",",
          "758:         \"false,REMOVE\",",
          "759:         \"false,THROW\",",
          "760:       })",
          "761:   void lookupAsync_cnameQueryExtra(boolean useCache, IrrelevantRecordMode mode)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "769:     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));",
          "770:   }",
          "775:       throws ExecutionException, InterruptedException {",
          "776:     Name query = name(\"cname.r.\");",
          "777:     Name target = name(\"a.b.\");",
          "",
          "[Removed Lines]",
          "772:   @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")",
          "773:   void lookupAsync_dnameQueryExtra(",
          "774:       @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)",
          "",
          "[Added Lines]",
          "790:   @ParameterizedTest",
          "791:   @CsvSource(",
          "792:       value = {",
          "793:         \"true,REMOVE\",",
          "794:         \"true,THROW\",",
          "795:         \"false,REMOVE\",",
          "796:         \"false,THROW\",",
          "797:       })",
          "798:   void lookupAsync_dnameQueryExtra(boolean useCache, IrrelevantRecordMode mode)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "889:     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));",
          "890:   }",
          "895:       throws ExecutionException, InterruptedException {",
          "896:     Name queryName = name(\"x.y.to.dname.\");",
          "897:     wireUpMockResolver(",
          "",
          "[Removed Lines]",
          "892:   @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")",
          "893:   void lookupAsync_simpleDnameRedirectNoExtra(",
          "894:       @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)",
          "",
          "[Added Lines]",
          "916:   @ParameterizedTest",
          "917:   @CsvSource(",
          "918:       value = {",
          "919:         \"true,REMOVE\",",
          "920:         \"true,THROW\",",
          "921:         \"false,REMOVE\",",
          "922:         \"false,THROW\",",
          "923:       })",
          "924:   void lookupAsync_simpleDnameRedirectNoExtra(boolean useCache, IrrelevantRecordMode mode)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "935:     verify(mockResolver, times(2)).sendAsync(any(), any(Executor.class));",
          "936:   }",
          "941:       throws ExecutionException, InterruptedException {",
          "942:     Name query = name(\"first.example.com.\");",
          "943:     wireUpMockResolver(mockResolver, q -> answer(q, name -> cname(\"a.\", \"b.\")));",
          "",
          "[Removed Lines]",
          "938:   @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")",
          "939:   void lookupAsync_simpleCnameWrongInitial(",
          "940:       @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)",
          "",
          "[Added Lines]",
          "968:   @ParameterizedTest",
          "969:   @CsvSource(",
          "970:       value = {",
          "971:         \"true,REMOVE\",",
          "972:         \"true,THROW\",",
          "973:         \"false,REMOVE\",",
          "974:         \"false,THROW\",",
          "975:       })",
          "976:   void lookupAsync_simpleCnameWrongInitial(boolean useCache, IrrelevantRecordMode mode)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "961:     verify(mockResolver, times(1)).sendAsync(any(), any(Executor.class));",
          "962:   }",
          "967:       throws ExecutionException, InterruptedException {",
          "968:     Name query = name(\"first.example.com.\");",
          "969:     wireUpMockResolver(mockResolver, q -> answer(q, name -> dname(\"a.\", \"b.\")));",
          "",
          "[Removed Lines]",
          "964:   @CartesianTest(name = \"useCache={0}, irrelevantRecordMode={1}\")",
          "965:   void lookupAsync_simpleDnameWrongInitial(",
          "966:       @Values(booleans = {true, false}) boolean useCache, @Enum IrrelevantRecordMode mode)",
          "",
          "[Added Lines]",
          "1000:   @ParameterizedTest",
          "1001:   @CsvSource(",
          "1002:       value = {",
          "1003:         \"true,REMOVE\",",
          "1004:         \"true,THROW\",",
          "1005:         \"false,REMOVE\",",
          "1006:         \"false,THROW\",",
          "1007:       })",
          "1008:   void lookupAsync_simpleDnameWrongInitial(boolean useCache, IrrelevantRecordMode mode)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1000:     }",
          "1001:   }",
          "1006:     CNAMERecord cnameA = cname(\"a.\", \"b.\");",
          "1007:     CNAMERecord cnameB = cname(\"b.\", \"c.\");",
          "1008:     CNAMERecord cnameC = cname(\"c.\", \"d.\");",
          "",
          "[Removed Lines]",
          "1003:   @CartesianTest(name = \"maxRedirects={0}, irrelevantRecordMode={1}\")",
          "1004:   void lookupAsync_redirectLoop(",
          "1005:       @Values(ints = {3, 4}) int maxRedirects, @Enum IrrelevantRecordMode mode) {",
          "",
          "[Added Lines]",
          "1045:   @ParameterizedTest",
          "1046:   @CsvSource(",
          "1047:       value = {",
          "1048:         \"3,REMOVE\",",
          "1049:         \"3,THROW\",",
          "1050:         \"4,REMOVE\",",
          "1051:         \"4,THROW\",",
          "1052:       })",
          "1053:   void lookupAsync_redirectLoop(int maxRedirects, IrrelevantRecordMode mode) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
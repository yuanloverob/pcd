{
  "cve_id": "CVE-2020-29457",
  "cve_desc": "A Privilege Elevation vulnerability in OPC UA .NET Standard Stack 1.4.363.107 could allow a rogue application to establish a secure connection.",
  "repo": "OPCFoundation/UA-.NETStandard",
  "patch_hash": "d815cfb972bd668c1b6e461f6ff97519d6b26f25",
  "patch_info": {
    "commit_hash": "d815cfb972bd668c1b6e461f6ff97519d6b26f25",
    "repo": "OPCFoundation/UA-.NETStandard",
    "commit_url": "https://github.com/OPCFoundation/UA-.NETStandard/pull/1229/commits/d815cfb972bd668c1b6e461f6ff97519d6b26f25",
    "files": [
      "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs",
      "Stack/Opc.Ua.Core/Types/Utils/ServiceResult.cs",
      "Tests/Opc.Ua.Core.Tests/Security/Certificates/CertificateValidatorTest.cs"
    ],
    "message": "Improve handling of certificate validation (#1217)\n\nThe change ensures that all certificate validation failures (except those related to the hostname of a server) are stacked in the right order into a service result, which -- if not empty -- in the end is raised in a service result exception.\nThe single point where knowledge about suppressible changes is needed is the place in Validate, where that exception is caught.",
    "before_after_code_files": [
      "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs",
      "Stack/Opc.Ua.Core/Types/Utils/ServiceResult.cs||Stack/Opc.Ua.Core/Types/Utils/ServiceResult.cs",
      "Tests/Opc.Ua.Core.Tests/Security/Certificates/CertificateValidatorTest.cs||Tests/Opc.Ua.Core.Tests/Security/Certificates/CertificateValidatorTest.cs"
    ]
  },
  "patch_diff": {
    "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs": [
      "File: Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs -> Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs",
      "--- Hunk 1 ---",
      "[Context before]",
      "251:             catch (ServiceResultException se)",
      "252:             {",
      "279:                 }",
      "",
      "[Removed Lines]",
      "254:                 switch (se.StatusCode)",
      "255:                 {",
      "256:                     case StatusCodes.BadCertificateHostNameInvalid:",
      "257:                     case StatusCodes.BadCertificateIssuerRevocationUnknown:",
      "258:                     case StatusCodes.BadCertificateChainIncomplete:",
      "259:                     case StatusCodes.BadCertificateIssuerTimeInvalid:",
      "260:                     case StatusCodes.BadCertificateIssuerUseNotAllowed:",
      "261:                     case StatusCodes.BadCertificateRevocationUnknown:",
      "262:                     case StatusCodes.BadCertificateTimeInvalid:",
      "263:                     case StatusCodes.BadCertificatePolicyCheckFailed:",
      "264:                     case StatusCodes.BadCertificateUseNotAllowed:",
      "265:                     case StatusCodes.BadCertificateUntrusted:",
      "266:                     {",
      "267:                         Utils.Trace(\"Certificate Vaildation failed for '{0}'. Reason={1}\", certificate.Subject, (StatusCode)se.StatusCode);",
      "268:                         break;",
      "269:                     }",
      "271:                     default:",
      "272:                     {",
      "274:                         Utils.Trace((int)Utils.TraceMasks.Error, \"Certificate '{0}' rejected. Reason={1}\", certificate.Subject, (StatusCode)se.StatusCode);",
      "275:                         SaveCertificate(certificate);",
      "277:                         throw new ServiceResultException(se, StatusCodes.BadCertificateInvalid);",
      "278:                     }",
      "",
      "[Added Lines]",
      "254:                 if (ContainsUnsuppressibleSC(se.Result))",
      "255:                 {",
      "256:                     Utils.Trace((int)Utils.TraceMasks.Error, \"Certificate '{0}' rejected. Reason={1}\", certificate.Subject, (StatusCode)se.StatusCode);",
      "257:                     SaveCertificate(certificate);",
      "259:                     throw new ServiceResultException(se, StatusCodes.BadCertificateInvalid);",
      "260:                 }",
      "261:                 else",
      "262:                 {",
      "263:                     Utils.Trace(\"Certificate Vaildation failed for '{0}'. Reason={1}\", certificate.Subject, se.ToLongString());",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "310:             }",
      "311:         }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "308:         static private bool ContainsUnsuppressibleSC(ServiceResult sr)",
      "309:         {",
      "310:             List<StatusCode> suppressibleStatusCodes = new List<StatusCode>()",
      "311:             {",
      "312:                 StatusCodes.BadCertificateHostNameInvalid,",
      "313:                 StatusCodes.BadCertificateIssuerRevocationUnknown,",
      "314:                 StatusCodes.BadCertificateChainIncomplete,",
      "315:                 StatusCodes.BadCertificateIssuerTimeInvalid,",
      "316:                 StatusCodes.BadCertificateIssuerUseNotAllowed,",
      "317:                 StatusCodes.BadCertificateRevocationUnknown,",
      "318:                 StatusCodes.BadCertificateTimeInvalid,",
      "319:                 StatusCodes.BadCertificatePolicyCheckFailed,",
      "320:                 StatusCodes.BadCertificateUseNotAllowed,",
      "321:                 StatusCodes.BadCertificateUntrusted",
      "322:             };",
      "323:             if (!suppressibleStatusCodes.Contains(sr.StatusCode))",
      "324:             {",
      "325:                 return true;",
      "326:             }",
      "327:             if(sr.InnerResult == null)",
      "328:             {",
      "329:                 return false;",
      "330:             }",
      "331:             return ContainsUnsuppressibleSC(sr.InnerResult);",
      "332:         }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "668:             }",
      "672:             X509Chain chain = new X509Chain();",
      "673:             chain.ChainPolicy = policy;",
      "674:             chain.Build(certificate);",
      "",
      "[Removed Lines]",
      "671:             bool chainStatusChecked = false;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "681:                 target = new CertificateIdentifier(certificate);",
      "682:             }",
      "684:             for (int ii = 0; ii < chain.ChainElements.Count; ii++)",
      "685:             {",
      "686:                 X509ChainElement element = chain.ChainElements[ii];",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "705:             ServiceResult sresult = null;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "697:                 {",
      "698:                     foreach (X509ChainStatus status in element.ChainElementStatus)",
      "699:                     {",
      "702:                         if (ServiceResult.IsBad(result))",
      "703:                         {",
      "719:                         }",
      "722:                     }",
      "723:                 }",
      "729:                 if (issuer != null)",
      "730:                 {",
      "",
      "[Removed Lines]",
      "700:                         ServiceResult result = CheckChainStatus(status, target, issuer, (ii != 0));",
      "705:                             if (trustedCertificate == null)",
      "706:                             {",
      "707:                                 ServiceResult errorResult = new ServiceResult(",
      "708:                                     result.StatusCode,",
      "709:                                     result.SymbolicId,",
      "710:                                     result.NamespaceUri,",
      "711:                                     result.LocalizedText,",
      "712:                                     result.AdditionalInfo,",
      "713:                                     StatusCodes.BadCertificateUntrusted);",
      "715:                                 throw new ServiceResultException(errorResult);",
      "716:                             }",
      "718:                             throw new ServiceResultException(result);",
      "721:                         chainStatusChecked = true;",
      "724:                 else",
      "725:                 {",
      "726:                     chainStatusChecked = true;",
      "727:                 }",
      "",
      "[Added Lines]",
      "723:                         ServiceResult result = CheckChainStatus(status, target, issuer, (ii != 0));",
      "726:                             sresult = new ServiceResult(result, sresult);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "751:                     chainIncomplete = true;",
      "752:                 }",
      "765:             if (issuedByCA && !isIssuerTrusted && trustedCertificate == null)",
      "766:             {",
      "771:                         \"Certificate issuer is not trusted.\\r\\nSubjectName: {0}\\r\\nIssuerName: {1}\",",
      "775:             }",
      "",
      "[Removed Lines]",
      "753:             }",
      "755:             if (issuedByCA && (!chainStatusChecked || chainIncomplete))",
      "756:             {",
      "757:                 throw ServiceResultException.Create(",
      "758:                     StatusCodes.BadCertificateChainIncomplete,",
      "759:                     \"Certificate chain validation incomplete.\\r\\nSubjectName: {0}\\r\\nIssuerName: {1}\",",
      "760:                     certificate.SubjectName.Name,",
      "761:                     certificate.IssuerName.Name);",
      "762:             }",
      "767:                 if (m_applicationCertificate == null || !Utils.IsEqual(m_applicationCertificate.RawData, certificate.RawData))",
      "768:                 {",
      "769:                     throw ServiceResultException.Create(",
      "770:                         StatusCodes.BadCertificateUntrusted,",
      "772:                         certificate.SubjectName.Name,",
      "773:                         certificate.IssuerName.Name);",
      "774:                 }",
      "",
      "[Added Lines]",
      "755:             }",
      "760:                 sresult = new ServiceResult(StatusCodes.BadCertificateUntrusted,",
      "761:                     null,",
      "762:                     null,",
      "763:                     String.Format(",
      "765:                     certificate.SubjectName.Name,",
      "766:                     certificate.IssuerName.Name),",
      "767:                     null,",
      "768:                     sresult",
      "769:                     );",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "779:             {",
      "780:                 if (m_applicationCertificate == null || !Utils.IsEqual(m_applicationCertificate.RawData, certificate.RawData))",
      "781:                 {",
      "785:                         certificate.SubjectName.Name,",
      "787:                 }",
      "788:             }",
      "",
      "[Removed Lines]",
      "782:                     throw ServiceResultException.Create(",
      "783:                         StatusCodes.BadCertificateUntrusted,",
      "784:                         \"Certificate is not trusted.\\r\\nSubjectName: {0}\\r\\nIssuerName: {1}\",",
      "786:                         certificate.IssuerName.Name);",
      "",
      "[Added Lines]",
      "777:                     sresult = new ServiceResult(StatusCodes.BadCertificateUntrusted,",
      "778:                         null,",
      "779:                         null,",
      "780:                         String.Format(",
      "781:                             \"Certificate is not trusted.\\r\\nSubjectName: {0}\\r\\nIssuerName: {1}\",",
      "783:                         certificate.IssuerName.Name),",
      "784:                         null,",
      "785:                         sresult",
      "786:                         );",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "793:             if ((certificateKeyUsage & X509KeyUsageFlags.DataEncipherment) == 0)",
      "794:             {",
      "796:             }",
      "799:             if (m_rejectSHA1SignedCertificates && IsSHA1SignatureAlgorithm(certificate.SignatureAlgorithm))",
      "800:             {",
      "802:             }",
      "804:             int keySize = X509Utils.GetRSAPublicKeySize(certificate);",
      "805:             if (keySize < m_minimumCertificateKeySize)",
      "806:             {",
      "808:             }",
      "809:         }",
      "",
      "[Removed Lines]",
      "795:                 throw new ServiceResultException(StatusCodes.BadCertificateUseNotAllowed, \"Usage of certificate is not allowed.\");",
      "801:                 throw new ServiceResultException(StatusCodes.BadCertificatePolicyCheckFailed, \"SHA1 signed certificates are not trusted\");",
      "807:                 throw new ServiceResultException(StatusCodes.BadCertificatePolicyCheckFailed, \"Certificate doesn't meet minimum key length requirement\");",
      "",
      "[Added Lines]",
      "795:                 sresult = new ServiceResult(StatusCodes.BadCertificateUseNotAllowed,",
      "796:                     null,",
      "797:                     null,",
      "798:                     \"Usage of certificate is not allowed.\",",
      "799:                     null,",
      "800:                     sresult",
      "801:                     );",
      "807:                 sresult = new ServiceResult(StatusCodes.BadCertificatePolicyCheckFailed,",
      "808:                     null,",
      "809:                     null,",
      "810:                     \"SHA1 signed certificates are not trusted\",",
      "811:                     null,",
      "812:                     sresult",
      "813:                     );",
      "819:                 sresult = new ServiceResult(StatusCodes.BadCertificatePolicyCheckFailed,",
      "820:                     null,",
      "821:                     null,",
      "822:                     \"Certificate doesn't meet minimum key length requirement\",",
      "823:                     null,",
      "824:                     sresult",
      "825:                     );",
      "826:             }",
      "828:             if (issuedByCA && chainIncomplete)",
      "829:             {",
      "830:                 sresult = new ServiceResult(StatusCodes.BadCertificateChainIncomplete,",
      "831:                     null,",
      "832:                     null,",
      "833:                     String.Format(",
      "834:                         \"Certificate chain validation incomplete.\\r\\nSubjectName: {0}\\r\\nIssuerName: {1}\",",
      "835:                     certificate.SubjectName.Name,",
      "836:                     certificate.IssuerName.Name),",
      "837:                     null,",
      "838:                     sresult",
      "839:                     );",
      "840:             }",
      "841:             if(sresult != null)",
      "842:             {",
      "843:                 throw new ServiceResultException(sresult);",
      "",
      "---------------"
    ],
    "Stack/Opc.Ua.Core/Types/Utils/ServiceResult.cs||Stack/Opc.Ua.Core/Types/Utils/ServiceResult.cs": [
      "File: Stack/Opc.Ua.Core/Types/Utils/ServiceResult.cs -> Stack/Opc.Ua.Core/Types/Utils/ServiceResult.cs",
      "--- Hunk 1 ---",
      "[Context before]",
      "53:             InnerResult = innerResult;",
      "54:         }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "61:         public ServiceResult(",
      "62:             ServiceResult outerResult,",
      "63:             ServiceResult innerResult = null)",
      "64:             :",
      "65:             this(outerResult.Code, outerResult.SymbolicId, outerResult.NamespaceUri, outerResult.LocalizedText, outerResult.AdditionalInfo, innerResult)",
      "66:         {",
      "67:         }",
      "",
      "---------------"
    ],
    "Tests/Opc.Ua.Core.Tests/Security/Certificates/CertificateValidatorTest.cs||Tests/Opc.Ua.Core.Tests/Security/Certificates/CertificateValidatorTest.cs": [
      "File: Tests/Opc.Ua.Core.Tests/Security/Certificates/CertificateValidatorTest.cs -> Tests/Opc.Ua.Core.Tests/Security/Certificates/CertificateValidatorTest.cs",
      "--- Hunk 1 ---",
      "[Context before]",
      "758:             Assert.NotNull(cert);",
      "759:             Assert.True(X509Utils.CompareDistinguishedName(\"CN=App Test Cert\", cert.Subject));",
      "760:             CleanupValidatorAndStores();",
      "762:             {",
      "763:                 await m_issuerStore.Add(cert);",
      "764:             }",
      "",
      "[Removed Lines]",
      "761:             if (trusted)",
      "",
      "[Added Lines]",
      "761:             if (!trusted)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "768:             }",
      "769:             var certValidator = InitValidatorWithStores();",
      "770:             var serviceResultException = Assert.Throws<ServiceResultException>(() => { certValidator.Validate(cert); });",
      "772:         }",
      "",
      "[Removed Lines]",
      "771:             Assert.AreEqual(StatusCodes.BadCertificateTimeInvalid, serviceResultException.StatusCode, serviceResultException.Message);",
      "",
      "[Added Lines]",
      "771:             if (!trusted)",
      "772:             {",
      "773:                 Assert.AreEqual(StatusCodes.BadCertificateUntrusted, serviceResultException.StatusCode, serviceResultException.Message);",
      "774:             }",
      "775:             else",
      "776:             {",
      "777:                 Assert.AreEqual(StatusCodes.BadCertificateTimeInvalid, serviceResultException.StatusCode, serviceResultException.Message);",
      "778:             }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "788:             Assert.NotNull(cert);",
      "789:             Assert.True(X509Utils.CompareDistinguishedName(\"CN=App Test Cert\", cert.Subject));",
      "790:             CleanupValidatorAndStores();",
      "792:             {",
      "793:                 await m_issuerStore.Add(cert);",
      "794:             }",
      "",
      "[Removed Lines]",
      "791:             if (trusted)",
      "",
      "[Added Lines]",
      "798:             if (!trusted)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "798:             }",
      "799:             var certValidator = InitValidatorWithStores();",
      "800:             var serviceResultException = Assert.Throws<ServiceResultException>(() => { certValidator.Validate(cert); });",
      "802:         }",
      "804:         [Test, Order(602)]",
      "",
      "[Removed Lines]",
      "801:             Assert.AreEqual(StatusCodes.BadCertificateTimeInvalid, serviceResultException.StatusCode, serviceResultException.Message);",
      "",
      "[Added Lines]",
      "808:             if (!trusted)",
      "809:             {",
      "810:                 Assert.AreEqual(StatusCodes.BadCertificateUntrusted, serviceResultException.StatusCode, serviceResultException.Message);",
      "811:             }",
      "812:             else",
      "813:             {",
      "814:                 Assert.AreEqual(StatusCodes.BadCertificateTimeInvalid, serviceResultException.StatusCode, serviceResultException.Message);",
      "815:             }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bfa117b7a73217b26d369c75a2b6cb70884469fc",
      "candidate_info": {
        "commit_hash": "bfa117b7a73217b26d369c75a2b6cb70884469fc",
        "repo": "OPCFoundation/UA-.NETStandard",
        "commit_url": "https://github.com/OPCFoundation/UA-.NETStandard/commit/bfa117b7a73217b26d369c75a2b6cb70884469fc",
        "files": [
          "Applications/ClientControls.Net4/Configuration/Common (OLD)/GuiUtils.cs",
          "Applications/ConsoleReferenceClient/UAClient.cs",
          "Applications/ServerControls.Net4/ServerForm.cs",
          "Libraries/Opc.Ua.Configuration/ApplicationInstance.cs",
          "Libraries/Opc.Ua.Security.Certificates/PEM/PEMWriter.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
        ],
        "message": "Implement an AcceptAll flag in the cert validator callback (#1230)\n\n- The AcceptAll flag can be used to accept all suppressible errors in one call back\n- Behaviour unchanged when only Accept is set, callback is invoked for all errors and all must be approved",
        "before_after_code_files": [
          "Applications/ConsoleReferenceClient/UAClient.cs||Applications/ConsoleReferenceClient/UAClient.cs",
          "Applications/ServerControls.Net4/ServerForm.cs||Applications/ServerControls.Net4/ServerForm.cs",
          "Libraries/Opc.Ua.Configuration/ApplicationInstance.cs||Libraries/Opc.Ua.Configuration/ApplicationInstance.cs",
          "Libraries/Opc.Ua.Security.Certificates/PEM/PEMWriter.cs||Libraries/Opc.Ua.Security.Certificates/PEM/PEMWriter.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
          ],
          "candidate": [
            "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
          ]
        }
      },
      "candidate_diff": {
        "Applications/ConsoleReferenceClient/UAClient.cs||Applications/ConsoleReferenceClient/UAClient.cs": [
          "File: Applications/ConsoleReferenceClient/UAClient.cs -> Applications/ConsoleReferenceClient/UAClient.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "480:             bool certificateAccepted = true;",
          "487:             if (certificateAccepted)",
          "488:             {",
          "489:                 Console.WriteLine(\"Untrusted Certificate accepted. SubjectName = {0}\", e.Certificate.SubjectName);",
          "490:             }",
          "493:         }",
          "494:         #endregion",
          "",
          "[Removed Lines]",
          "492:             e.Accept = certificateAccepted;",
          "",
          "[Added Lines]",
          "488:             ServiceResult error = e.Error;",
          "489:             while (error != null)",
          "490:             {",
          "491:                 Console.WriteLine(error);",
          "492:                 error = error.InnerResult;",
          "493:             }",
          "500:             e.AcceptAll = certificateAccepted;",
          "",
          "---------------"
        ],
        "Applications/ServerControls.Net4/ServerForm.cs||Applications/ServerControls.Net4/ServerForm.cs": [
          "File: Applications/ServerControls.Net4/ServerForm.cs -> Applications/ServerControls.Net4/ServerForm.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: using Opc.Ua;",
          "39: using Opc.Ua.Configuration;",
          "40: using System.IO;",
          "42: namespace Opc.Ua.Server.Controls",
          "43: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "41: using System.Linq;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "212:             StringBuilder buffer = new StringBuilder();",
          "213:             buffer.AppendLine(\"Certificate could not be validated!\");",
          "214:             buffer.AppendLine(\"Validation error(s):\");",
          "217:             {",
          "219:             }",
          "220:             buffer.AppendFormat(\"\\r\\nSubject: {0}\\r\\n\", e.Certificate.Subject);",
          "221:             buffer.AppendFormat(\"Issuer: {0}\\r\\n\", X509Utils.CompareDistinguishedName(e.Certificate.Subject, e.Certificate.Issuer)",
          "",
          "[Removed Lines]",
          "215:             buffer.AppendFormat(\"\\t{0}\\r\\n\", e.Error.StatusCode);",
          "216:             if (e.Error.InnerResult != null)",
          "218:                 buffer.AppendFormat(\"\\t{0}\\r\\n\", e.Error.InnerResult.StatusCode);",
          "",
          "[Added Lines]",
          "216:             ServiceResult error = e.Error;",
          "217:             while (error != null)",
          "219:                 buffer.AppendFormat(\"- {0}\\r\\n\", error.ToString().Split('\\r','\\n').FirstOrDefault());",
          "220:                 error = error.InnerResult;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "230:             if (MessageBox.Show(buffer.ToString(), caller.Text, MessageBoxButtons.YesNo) == DialogResult.Yes)",
          "231:             {",
          "233:             }",
          "234:         }",
          "235:     }",
          "",
          "[Removed Lines]",
          "232:                 e.Accept = true;",
          "",
          "[Added Lines]",
          "234:                 e.AcceptAll = true;",
          "",
          "---------------"
        ],
        "Libraries/Opc.Ua.Configuration/ApplicationInstance.cs||Libraries/Opc.Ua.Configuration/ApplicationInstance.cs": [
          "File: Libraries/Opc.Ua.Configuration/ApplicationInstance.cs -> Libraries/Opc.Ua.Configuration/ApplicationInstance.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "583:                 }",
          "585:                 string message = Utils.Format(",
          "587:                     serverDomainNames[ii]);",
          "589:                 valid = false;",
          "",
          "[Removed Lines]",
          "586:                     \"The server is configured to use domain '{0}' which does not appear in the certificate. Use certificate?\",",
          "",
          "[Added Lines]",
          "586:                     \"The server is configured to use domain '{0}' which does not appear in the certificate. Use certificate anyway?\",",
          "",
          "---------------"
        ],
        "Libraries/Opc.Ua.Security.Certificates/PEM/PEMWriter.cs||Libraries/Opc.Ua.Security.Certificates/PEM/PEMWriter.cs": [
          "File: Libraries/Opc.Ua.Security.Certificates/PEM/PEMWriter.cs -> Libraries/Opc.Ua.Security.Certificates/PEM/PEMWriter.cs"
        ],
        "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs": [
          "File: Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs -> Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "285:                     {",
          "286:                         do",
          "287:                         {",
          "289:                             m_CertificateValidation(this, args);",
          "290:                             accept = args.Accept;",
          "291:                             if (accept)",
          "292:                             {",
          "",
          "[Removed Lines]",
          "288:                             CertificateValidationEventArgs args = new CertificateValidationEventArgs(new ServiceResult(serviceResult), certificate);",
          "",
          "[Added Lines]",
          "288:                             CertificateValidationEventArgs args = new CertificateValidationEventArgs(serviceResult, certificate);",
          "290:                             if (args.AcceptAll)",
          "291:                             {",
          "292:                                 accept = true;",
          "293:                                 serviceResult = null;",
          "294:                                 break;",
          "295:                             }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "781:             if (issuedByCA && !isIssuerTrusted && trustedCertificate == null)",
          "782:             {",
          "784:                 sresult = new ServiceResult(StatusCodes.BadCertificateUntrusted,",
          "791:             }",
          "",
          "[Removed Lines]",
          "783:                 var message = CertificateMessage(\"Certificate issuer is not trusted.\", certificate);",
          "785:                     null,",
          "786:                     null,",
          "787:                     message,",
          "788:                     null,",
          "789:                     sresult",
          "790:                     );",
          "",
          "[Added Lines]",
          "788:                 var message = CertificateMessage(\"Certificate Issuer is not trusted.\", certificate);",
          "790:                     null, null, message, null, sresult);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "797:                 {",
          "798:                     var message = CertificateMessage(\"Certificate is not trusted.\", certificate);",
          "799:                     sresult = new ServiceResult(StatusCodes.BadCertificateUntrusted,",
          "806:                 }",
          "807:             }",
          "",
          "[Removed Lines]",
          "800:                         null,",
          "801:                         null,",
          "802:                         message,",
          "803:                         null,",
          "804:                         sresult",
          "805:                         );",
          "",
          "[Added Lines]",
          "800:                     null, null, message, null, sresult);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "822:             if ((certificateKeyUsage & X509KeyUsageFlags.DataEncipherment) == 0)",
          "823:             {",
          "824:                 sresult = new ServiceResult(StatusCodes.BadCertificateUseNotAllowed,",
          "831:             }",
          "834:             if (m_rejectSHA1SignedCertificates && IsSHA1SignatureAlgorithm(certificate.SignatureAlgorithm))",
          "835:             {",
          "836:                 sresult = new ServiceResult(StatusCodes.BadCertificatePolicyCheckFailed,",
          "843:             }",
          "845:             int keySize = X509Utils.GetRSAPublicKeySize(certificate);",
          "846:             if (keySize < m_minimumCertificateKeySize)",
          "847:             {",
          "848:                 sresult = new ServiceResult(StatusCodes.BadCertificatePolicyCheckFailed,",
          "855:             }",
          "857:             if (issuedByCA && chainIncomplete)",
          "",
          "[Removed Lines]",
          "825:                     null,",
          "826:                     null,",
          "827:                     \"Usage of certificate is not allowed.\",",
          "828:                     null,",
          "829:                     sresult",
          "830:                     );",
          "837:                     null,",
          "838:                     null,",
          "839:                     \"SHA1 signed certificates are not trusted.\",",
          "840:                     null,",
          "841:                     sresult",
          "842:                     );",
          "849:                     null,",
          "850:                     null,",
          "851:                     \"Certificate doesn't meet minimum key length requirement.\",",
          "852:                     null,",
          "853:                     sresult",
          "854:                     );",
          "",
          "[Added Lines]",
          "820:                     null, null, \"Usage of certificate is not allowed.\", null, sresult);",
          "827:                     null, null, \"SHA1 signed certificates are not trusted.\", null, sresult);",
          "834:                     null, null, \"Certificate doesn't meet minimum key length requirement.\", null, sresult);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "904:                 {",
          "905:                     var args = new CertificateValidationEventArgs(new ServiceResult(serviceResult), serverCertificate);",
          "906:                     m_CertificateValidation(this, args);",
          "908:                 }",
          "910:                 if (!accept)",
          "",
          "[Removed Lines]",
          "907:                     accept = args.Accept;",
          "",
          "[Added Lines]",
          "887:                     accept = args.Accept || args.AcceptAll;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1202:         public X509Certificate2 Certificate => m_certificate;",
          "1207:         public bool Accept",
          "1208:         {",
          "1209:             get { return m_accept; }",
          "1210:             set { m_accept = value; }",
          "1211:         }",
          "1212:         #endregion",
          "1214:         #region Private Fields",
          "1215:         private ServiceResult m_error;",
          "1216:         private X509Certificate2 m_certificate;",
          "1217:         private bool m_accept;",
          "1218:         #endregion",
          "1219:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1198:         public bool AcceptAll",
          "1199:         {",
          "1200:             get { return m_acceptAll; }",
          "1201:             set { m_acceptAll = value; }",
          "1202:         }",
          "1209:         private bool m_acceptAll;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f0c467410ea11658662026a70a65b4627992d493",
      "candidate_info": {
        "commit_hash": "f0c467410ea11658662026a70a65b4627992d493",
        "repo": "OPCFoundation/UA-.NETStandard",
        "commit_url": "https://github.com/OPCFoundation/UA-.NETStandard/commit/f0c467410ea11658662026a70a65b4627992d493",
        "files": [
          "Libraries/Opc.Ua.Configuration/ApplicationInstance.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
        ],
        "message": "Implement AutoAcceptUntrustedCertificates flag for Client side also. Fixes #1228 (#1380)",
        "before_after_code_files": [
          "Libraries/Opc.Ua.Configuration/ApplicationInstance.cs||Libraries/Opc.Ua.Configuration/ApplicationInstance.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
          ],
          "candidate": [
            "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
          ]
        }
      },
      "candidate_diff": {
        "Libraries/Opc.Ua.Configuration/ApplicationInstance.cs||Libraries/Opc.Ua.Configuration/ApplicationInstance.cs": [
          "File: Libraries/Opc.Ua.Configuration/ApplicationInstance.cs -> Libraries/Opc.Ua.Configuration/ApplicationInstance.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "185:                 await LoadApplicationConfiguration(false).ConfigureAwait(false);",
          "186:             }",
          "193:             server.Start(m_applicationConfiguration);",
          "194:         }",
          "",
          "[Removed Lines]",
          "188:             if (m_applicationConfiguration.CertificateValidator != null)",
          "189:             {",
          "190:                 m_applicationConfiguration.CertificateValidator.CertificateValidation += CertificateValidator_CertificateValidation;",
          "191:             }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "438:         #endregion",
          "440:         #region Private Methods",
          "",
          "[Removed Lines]",
          "444:         private void CertificateValidator_CertificateValidation(CertificateValidator validator, CertificateValidationEventArgs e)",
          "445:         {",
          "446:             try",
          "447:             {",
          "448:                 if (m_applicationConfiguration.SecurityConfiguration != null",
          "449:                     && m_applicationConfiguration.SecurityConfiguration.AutoAcceptUntrustedCertificates",
          "450:                     && e.Error != null && e.Error.Code == StatusCodes.BadCertificateUntrusted)",
          "451:                 {",
          "452:                     e.Accept = true;",
          "453:                     Utils.Trace(Utils.TraceMasks.Security, \"Automatically accepted certificate: {0}\", e.Certificate.Subject);",
          "454:                 }",
          "455:             }",
          "456:             catch (Exception exception)",
          "457:             {",
          "458:                 Utils.Trace(exception, \"Error accepting certificate.\");",
          "459:             }",
          "460:         }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs": [
          "File: Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs -> Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:         public CertificateValidator()",
          "34:         {",
          "35:             m_validatedCertificates = new Dictionary<string, X509Certificate2>();",
          "36:             m_rejectSHA1SignedCertificates = CertificateFactory.DefaultHashSize >= 256;",
          "37:             m_rejectUnknownRevocationStatus = false;",
          "38:             m_minimumCertificateKeySize = CertificateFactory.DefaultKeySize;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36:             m_autoAcceptUntrustedCertificates = false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "172:                     configuration.TrustedIssuerCertificates,",
          "173:                     configuration.TrustedPeerCertificates,",
          "174:                     configuration.RejectedCertificateStore);",
          "175:                 m_rejectSHA1SignedCertificates = configuration.RejectSHA1SignedCertificates;",
          "176:                 m_rejectUnknownRevocationStatus = configuration.RejectUnknownRevocationStatus;",
          "177:                 m_minimumCertificateKeySize = configuration.MinimumCertificateKeySize;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "176:                 m_autoAcceptUntrustedCertificates = configuration.AutoAcceptUntrustedCertificates;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "781:                 }",
          "782:             }",
          "786:             {",
          "796:                 {",
          "798:                     sresult = new ServiceResult(StatusCodes.BadCertificateUntrusted,",
          "800:                 }",
          "801:             }",
          "",
          "[Removed Lines]",
          "785:             if (issuedByCA && !isIssuerTrusted && trustedCertificate == null)",
          "787:                 var message = CertificateMessage(\"Certificate Issuer is not trusted.\", certificate);",
          "788:                 sresult = new ServiceResult(StatusCodes.BadCertificateUntrusted,",
          "789:                     null, null, message, null, sresult);",
          "790:             }",
          "793:             if (trustedCertificate == null && !isIssuerTrusted)",
          "794:             {",
          "795:                 if (m_applicationCertificate == null || !Utils.IsEqual(m_applicationCertificate.RawData, certificate.RawData))",
          "797:                     var message = CertificateMessage(\"Certificate is not trusted.\", certificate);",
          "799:                     null, null, message, null, sresult);",
          "",
          "[Added Lines]",
          "786:             if (!m_autoAcceptUntrustedCertificates)",
          "789:                 if (issuedByCA && !isIssuerTrusted && trustedCertificate == null)",
          "791:                     var message = CertificateMessage(\"Certificate Issuer is not trusted.\", certificate);",
          "793:                         null, null, message, null, sresult);",
          "794:                 }",
          "797:                 if (trustedCertificate == null && !isIssuerTrusted)",
          "798:                 {",
          "799:                     if (m_applicationCertificate == null || !Utils.IsEqual(m_applicationCertificate.RawData, certificate.RawData))",
          "800:                     {",
          "801:                         var message = CertificateMessage(\"Certificate is not trusted.\", certificate);",
          "802:                         sresult = new ServiceResult(StatusCodes.BadCertificateUntrusted,",
          "803:                         null, null, message, null, sresult);",
          "804:                     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1146:         private event CertificateValidationEventHandler m_CertificateValidation;",
          "1147:         private event CertificateUpdateEventHandler m_CertificateUpdate;",
          "1148:         private X509Certificate2 m_applicationCertificate;",
          "1149:         private bool m_rejectSHA1SignedCertificates;",
          "1150:         private bool m_rejectUnknownRevocationStatus;",
          "1151:         private ushort m_minimumCertificateKeySize;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1154:         private bool m_autoAcceptUntrustedCertificates;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e5c127513f34014bafa0585ecf53e23515a4bb79",
      "candidate_info": {
        "commit_hash": "e5c127513f34014bafa0585ecf53e23515a4bb79",
        "repo": "OPCFoundation/UA-.NETStandard",
        "commit_url": "https://github.com/OPCFoundation/UA-.NETStandard/commit/e5c127513f34014bafa0585ecf53e23515a4bb79",
        "files": [
          "Libraries/Opc.Ua.Client/Session.cs",
          "Libraries/Opc.Ua.Configuration/ApplicationConfigurationBuilder.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/CertificateIdentifier.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs",
          "Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestClient.cs",
          "Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestServer.cs",
          "Tests/Opc.Ua.Gds.Tests/PushTest.cs",
          "Tests/Opc.Ua.Gds.Tests/ServerConfigurationPushTestClient.cs"
        ],
        "message": "fix GDS tests",
        "before_after_code_files": [
          "Libraries/Opc.Ua.Client/Session.cs||Libraries/Opc.Ua.Client/Session.cs",
          "Libraries/Opc.Ua.Configuration/ApplicationConfigurationBuilder.cs||Libraries/Opc.Ua.Configuration/ApplicationConfigurationBuilder.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/CertificateIdentifier.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateIdentifier.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs",
          "Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestClient.cs||Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestClient.cs",
          "Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestServer.cs||Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestServer.cs",
          "Tests/Opc.Ua.Gds.Tests/PushTest.cs||Tests/Opc.Ua.Gds.Tests/PushTest.cs",
          "Tests/Opc.Ua.Gds.Tests/ServerConfigurationPushTestClient.cs||Tests/Opc.Ua.Gds.Tests/ServerConfigurationPushTestClient.cs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
          ],
          "candidate": [
            "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
          ]
        }
      },
      "candidate_diff": {
        "Libraries/Opc.Ua.Client/Session.cs||Libraries/Opc.Ua.Client/Session.cs": [
          "File: Libraries/Opc.Ua.Client/Session.cs -> Libraries/Opc.Ua.Client/Session.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "186:                 }",
          "197:             }",
          "",
          "[Removed Lines]",
          "189:                 m_instanceCertificateChain = new X509Certificate2Collection(m_instanceCertificate);",
          "190:                 List<CertificateIdentifier> issuers = new List<CertificateIdentifier>();",
          "191:                 configuration.CertificateValidator.GetIssuers(m_instanceCertificate, issuers).Wait();",
          "193:                 for (int i = 0; i < issuers.Count; i++)",
          "194:                 {",
          "195:                     m_instanceCertificateChain.Add(issuers[i].Certificate);",
          "196:                 }",
          "",
          "[Added Lines]",
          "189:                 m_instanceCertificateChain = LoadCertificateChain(configuration, m_instanceCertificate).GetAwaiter().GetResult();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "216:             m_preferredLocales = new string[] { CultureInfo.CurrentCulture.Name };",
          "229:         }",
          "",
          "[Removed Lines]",
          "219:             m_systemContext = new SystemContext();",
          "221:             m_systemContext.SystemHandle = this;",
          "222:             m_systemContext.EncodeableFactory = m_factory;",
          "223:             m_systemContext.NamespaceUris = m_namespaceUris;",
          "224:             m_systemContext.ServerUris = m_serverUris;",
          "225:             m_systemContext.TypeTable = TypeTree;",
          "226:             m_systemContext.PreferredLocales = null;",
          "227:             m_systemContext.SessionId = null;",
          "228:             m_systemContext.UserIdentity = null;",
          "",
          "[Added Lines]",
          "212:             m_systemContext = new SystemContext {",
          "213:                 SystemHandle = this,",
          "214:                 EncodeableFactory = m_factory,",
          "215:                 NamespaceUris = m_namespaceUris,",
          "216:                 ServerUris = m_serverUris,",
          "217:                 TypeTable = TypeTree,",
          "218:                 PreferredLocales = null,",
          "219:                 SessionId = null,",
          "220:                 UserIdentity = null",
          "221:             };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4563:             {",
          "4564:                 clientCertificateChain = new X509Certificate2Collection(clientCertificate);",
          "4565:                 List<CertificateIdentifier> issuers = new List<CertificateIdentifier>();",
          "4568:                 for (int i = 0; i < issuers.Count; i++)",
          "4569:                 {",
          "",
          "[Removed Lines]",
          "4566:                 await configuration.CertificateValidator.GetIssuers(clientCertificate, issuers).ConfigureAwait(false);",
          "",
          "[Added Lines]",
          "4559:                 await configuration.CertificateValidator.GetIssuers(clientCertificate, issuers, false).ConfigureAwait(false);",
          "",
          "---------------"
        ],
        "Libraries/Opc.Ua.Configuration/ApplicationConfigurationBuilder.cs||Libraries/Opc.Ua.Configuration/ApplicationConfigurationBuilder.cs": [
          "File: Libraries/Opc.Ua.Configuration/ApplicationConfigurationBuilder.cs -> Libraries/Opc.Ua.Configuration/ApplicationConfigurationBuilder.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "98:         {",
          "99:             pkiRoot = DefaultPKIRoot(pkiRoot);",
          "100:             appRoot = appRoot == null ? pkiRoot : DefaultPKIRoot(appRoot);",
          "102:             var appStoreType = CertificateStoreIdentifier.DetermineStoreType(appRoot);",
          "103:             var pkiRootType = CertificateStoreIdentifier.DetermineStoreType(pkiRoot);",
          "104:             var rejectedRootType = CertificateStoreIdentifier.DetermineStoreType(rejectedRoot);",
          "",
          "[Removed Lines]",
          "101:             rejectedRoot = DefaultPKIRoot(rejectedRoot);",
          "",
          "[Added Lines]",
          "101:             rejectedRoot = rejectedRoot == null ? pkiRoot : DefaultPKIRoot(rejectedRoot);",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Security/Certificates/CertificateIdentifier.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateIdentifier.cs": [
          "File: Stack/Opc.Ua.Core/Security/Certificates/CertificateIdentifier.cs -> Stack/Opc.Ua.Core/Security/Certificates/CertificateIdentifier.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1125:             var certificateChain = new X509Certificate2Collection(certificate);",
          "1126:             List<CertificateIdentifier> issuers = new List<CertificateIdentifier>();",
          "1128:             {",
          "1129:                 for (int i = 0; i < issuers.Count; i++)",
          "1130:                 {",
          "",
          "[Removed Lines]",
          "1127:             if (await m_certificateValidator.GetIssuers(certificate, issuers))",
          "",
          "[Added Lines]",
          "1127:             if (await m_certificateValidator.GetIssuers(certificate, issuers, false))",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs": [
          "File: Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs -> Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "591:             string serialNumber,",
          "592:             string authorityKeyId)",
          "593:         {",
          "595:             if (certificate == null)",
          "596:             {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "594:             bool check = false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "610:                 {",
          "611:                     return false;",
          "612:                 }",
          "613:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "615:                 check = true;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "623:                     {",
          "624:                         return false;",
          "625:                     }",
          "626:                 }",
          "627:             }",
          "631:         }",
          "637:         {",
          "638:             bool isTrusted = false;",
          "639:             CertificateIdentifier issuer = null;",
          "",
          "[Removed Lines]",
          "630:             return true;",
          "636:         public async Task<bool> GetIssuers(X509Certificate2Collection certificates, List<CertificateIdentifier> issuers)",
          "",
          "[Added Lines]",
          "629:                     check = true;",
          "634:             return check;",
          "635:         }",
          "640:         public Task<bool> GetIssuers(X509Certificate2Collection certificates, List<CertificateIdentifier> issuers)",
          "641:         {",
          "642:             return GetIssuers(certificates, issuers, true);",
          "648:         public async Task<bool> GetIssuers(X509Certificate2Collection certificates, List<CertificateIdentifier> issuers, bool checkRevocationStatus)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "648:             do",
          "649:             {",
          "652:                 if (issuer == null)",
          "653:                 {",
          "656:                     if (issuer == null)",
          "657:                     {",
          "659:                     }",
          "660:                 }",
          "661:                 else",
          "",
          "[Removed Lines]",
          "650:                 issuer = await GetIssuer(certificate, m_trustedCertificateList, m_trustedCertificateStore, true).ConfigureAwait(false);",
          "654:                     issuer = await GetIssuer(certificate, m_issuerCertificateList, m_issuerCertificateStore, true).ConfigureAwait(false);",
          "658:                         issuer = await GetIssuer(certificate, collection, null, true).ConfigureAwait(false);",
          "",
          "[Added Lines]",
          "662:                 issuer = await GetIssuer(certificate, m_trustedCertificateList, m_trustedCertificateStore, checkRevocationStatus).ConfigureAwait(false);",
          "666:                     issuer = await GetIssuer(certificate, m_issuerCertificateList, m_issuerCertificateStore, checkRevocationStatus).ConfigureAwait(false);",
          "670:                         issuer = await GetIssuer(certificate, collection, null, checkRevocationStatus).ConfigureAwait(false);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "680:             return isTrusted;",
          "681:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "701:         public Task<bool> GetIssuers(X509Certificate2 certificate, List<CertificateIdentifier> issuers, bool checkRevocationStatus)",
          "702:         {",
          "703:             return GetIssuers(new X509Certificate2Collection { certificate }, issuers, checkRevocationStatus);",
          "704:         }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "689:         public Task<bool> GetIssuers(X509Certificate2 certificate, List<CertificateIdentifier> issuers)",
          "690:         {",
          "692:         }",
          "",
          "[Removed Lines]",
          "691:             return GetIssuers(new X509Certificate2Collection { certificate }, issuers);",
          "",
          "[Added Lines]",
          "714:             return GetIssuers(new X509Certificate2Collection { certificate }, issuers, true);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "963:                 }",
          "964:             }",
          "965:             else",
          "967:                 if ((certificateKeyUsage & X509KeyUsageFlags.DataEncipherment) == 0)",
          "968:                 {",
          "969:                     sresult = new ServiceResult(StatusCodes.BadCertificateUseNotAllowed,",
          "",
          "[Removed Lines]",
          "966:             {",
          "",
          "[Added Lines]",
          "989:             {",
          "",
          "---------------"
        ],
        "Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestClient.cs||Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestClient.cs": [
          "File: Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestClient.cs -> Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestClient.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:             Configuration = await application.LoadApplicationConfiguration(false).ConfigureAwait(false);",
          "65: #else",
          "67:             var clientConfig = new GlobalDiscoveryTestClientConfiguration() {",
          "68:                 GlobalDiscoveryServerUrl = \"opc.tcp://localhost:58810/GlobalDiscoveryTestServer\",",
          "73:             };",
          "",
          "[Removed Lines]",
          "66:             string pkiRoot = \"%LocalApplicationData%/OPC/pki\";",
          "69:                 AppUserName=\"appuser\",",
          "70:                 AppPassword=\"demo\",",
          "71:                 AdminUserName=\"appadmin\",",
          "72:                 AdminPassword=\"demo\"",
          "",
          "[Added Lines]",
          "66:             string root = \"%LocalApplicationData%/OPC\";",
          "67:             string pkiRoot = Path.Combine(root, \"pki\");",
          "70:                 AppUserName = \"appuser\",",
          "71:                 AppPassword = \"demo\",",
          "72:                 AdminUserName = \"appadmin\",",
          "73:                 AdminPassword = \"demo\"",
          "74:             };",
          "76:             var transportQuotas = new TransportQuotas() {",
          "77:                 OperationTimeout = 120000,",
          "78:                 MaxStringLength = 1048576,",
          "79:                 MaxByteStringLength = 1048576,",
          "80:                 MaxArrayLength = 65535,",
          "81:                 MaxMessageSize = 4194304,",
          "82:                 MaxBufferSize = 65535,",
          "83:                 ChannelLifetime = 300000,",
          "84:                 SecurityTokenLifetime = 3600000,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77:                 .Build(",
          "78:                     \"urn:localhost:opcfoundation.org:GlobalDiscoveryTestClient\",",
          "79:                     \"http://opcfoundation.org/UA/GlobalDiscoveryTestClient\")",
          "80:                 .AsClient()",
          "81:                 .AddSecurityConfiguration(",
          "82:                     \"CN=Global Discovery Test Client, O=OPC Foundation, DC=localhost\",",
          "83:                     pkiRoot)",
          "84:                 .SetAutoAcceptUntrustedCertificates(true)",
          "85:                 .SetRejectSHA1SignedCertificates(false)",
          "86:                 .SetMinimumCertificateKeySize(1024)",
          "87:                 .AddExtension<GlobalDiscoveryTestClientConfiguration>(null, clientConfig)",
          "89:                 .SetTraceMasks(519)",
          "90:                 .Create().ConfigureAwait(false);",
          "91: #endif",
          "",
          "[Removed Lines]",
          "88:                 .SetOutputFilePath(pkiRoot + \"/Logs/Opc.Ua.Gds.Tests.log.txt\")",
          "",
          "[Added Lines]",
          "92:                 .SetTransportQuotas(transportQuotas)",
          "94:                 .SetDefaultSessionTimeout(600000)",
          "95:                 .SetMinSubscriptionLifetime(10000)",
          "101:                 .SetRejectUnknownRevocationStatus(true)",
          "104:                 .SetOutputFilePath(Path.Combine(root, \"Logs\", \"Opc.Ua.Gds.Tests.log.txt\"))",
          "",
          "---------------"
        ],
        "Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestServer.cs||Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestServer.cs": [
          "File: Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestServer.cs -> Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestServer.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "181:             }",
          "182:         }",
          "185:         {",
          "186: #if USE_FILE_CONFIG",
          "188:             ApplicationConfiguration config = await application.LoadApplicationConfiguration(true).ConfigureAwait(false);",
          "189: #else",
          "191:             var gdsConfig = new GlobalDiscoveryServerConfiguration() {",
          "192:                 AuthoritiesStorePath = Path.Combine(gdsRoot, \"authorities\"),",
          "193:                 ApplicationCertificatesStorePath = Path.Combine(gdsRoot, \"applications\"),",
          "194:                 DefaultSubjectNameContext = \"O=OPC Foundation\",",
          "195:                 CertificateGroups = new CertificateGroupConfigurationCollection()",
          "196:                 {",
          "199:                         Id = \"Default\",",
          "201:                         SubjectName = \"CN=GDS Test CA, O=OPC Foundation\",",
          "202:                         BaseStorePath = Path.Combine(gdsRoot, \"CA\", \"default\"),",
          "203:                         DefaultCertificateHashSize = 256,",
          "",
          "[Removed Lines]",
          "184:         private async Task<ApplicationConfiguration> Load(ApplicationInstance application, int basePort)",
          "190:             string gdsRoot = Path.Combine(\"%LocalApplicationData%\", \"OPC\", \"GDS\");",
          "197:                     new CertificateGroupConfiguration()",
          "198:                     {",
          "200:                         CertificateType =\"RsaSha256ApplicationCertificateType\",",
          "",
          "[Added Lines]",
          "184:         private static async Task<ApplicationConfiguration> Load(ApplicationInstance application, int basePort)",
          "190:             string root = Path.Combine(\"%LocalApplicationData%\", \"OPC\");",
          "191:             string gdsRoot = Path.Combine(root, \"GDS\");",
          "198:                     new CertificateGroupConfiguration() {",
          "200:                         CertificateType = \"RsaSha256ApplicationCertificateType\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "208:                         CACertificateLifetime = 60",
          "209:                     }",
          "210:                 },",
          "212:             };",
          "",
          "[Removed Lines]",
          "211:                 DatabaseStorePath = gdsRoot + \"/gdsdb.json\"",
          "",
          "[Added Lines]",
          "211:                 DatabaseStorePath = Path.Combine(gdsRoot, \"gdsdb.json\")",
          "212:             };",
          "214:             var transportQuotas = new TransportQuotas() {",
          "215:                 OperationTimeout = 120000,",
          "216:                 MaxStringLength = 1048576,",
          "217:                 MaxByteStringLength = 1048576,",
          "218:                 MaxArrayLength = 65535,",
          "219:                 MaxMessageSize = 4194304,",
          "220:                 MaxBufferSize = 65535,",
          "221:                 ChannelLifetime = 300000,",
          "222:                 SecurityTokenLifetime = 3600000,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "216:                 .Build(",
          "217:                     \"urn:localhost:opcfoundation.org:GlobalDiscoveryTestServer\",",
          "218:                     \"http://opcfoundation.org/UA/GlobalDiscoveryTestServer\")",
          "219:                 .AsServer(new string[] { \"opc.tcp://localhost:58810/GlobalDiscoveryTestServer\" })",
          "220:                 .AddUserTokenPolicy(UserTokenType.Anonymous)",
          "221:                 .AddUserTokenPolicy(UserTokenType.UserName)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "230:                 .SetTransportQuotas(transportQuotas)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "228:                     gdsRoot)",
          "229:                 .SetAutoAcceptUntrustedCertificates(true)",
          "230:                 .SetRejectSHA1SignedCertificates(false)",
          "231:                 .SetMinimumCertificateKeySize(1024)",
          "232:                 .AddExtension<GlobalDiscoveryServerConfiguration>(null, gdsConfig)",
          "233:                 .SetDeleteOnLoad(true)",
          "235:                 .SetTraceMasks(519)",
          "236:                 .Create().ConfigureAwait(false);",
          "237: #endif",
          "",
          "[Removed Lines]",
          "234:                 .SetOutputFilePath(gdsRoot + \"/Logs/Opc.Ua.Gds.Tests.log.txt\")",
          "",
          "[Added Lines]",
          "243:                 .SetRejectUnknownRevocationStatus(true)",
          "247:                 .SetOutputFilePath(Path.Combine(root, \"Logs\", \"Opc.Ua.Gds.Tests.log.txt\"))",
          "",
          "---------------"
        ],
        "Tests/Opc.Ua.Gds.Tests/PushTest.cs||Tests/Opc.Ua.Gds.Tests/PushTest.cs": [
          "File: Tests/Opc.Ua.Gds.Tests/PushTest.cs -> Tests/Opc.Ua.Gds.Tests/PushTest.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "624:             )",
          "625:         {",
          "626:             m_pushClient.PushClient.AdminCredentials = sysAdmin ? m_pushClient.SysAdminUser : m_pushClient.AppUser;",
          "628:             TestContext.Progress.WriteLine($\"GDS Push({sysAdmin}) Connected -- {memberName}\");",
          "629:         }",
          "",
          "[Removed Lines]",
          "627:             m_pushClient.PushClient.Connect(m_pushClient.PushClient.EndpointUrl).Wait();",
          "",
          "[Added Lines]",
          "627:             m_pushClient.PushClient.Connect(m_pushClient.PushClient.EndpointUrl).GetAwaiter().GetResult();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "695:         {",
          "696:             DisconnectPushClient();",
          "697:             Thread.Sleep(2000);",
          "700:             Assert.AreEqual(",
          "701:                 certificate,",
          "702:                 m_pushClient.PushClient.Session.ConfiguredEndpoint.Description.ServerCertificate",
          "",
          "[Removed Lines]",
          "698:             m_gdsClient.GDSClient.Connect(m_gdsClient.GDSClient.EndpointUrl).Wait();",
          "699:             m_pushClient.PushClient.Connect(m_pushClient.PushClient.EndpointUrl).Wait();",
          "",
          "[Added Lines]",
          "698:             m_gdsClient.GDSClient.Connect(m_gdsClient.GDSClient.EndpointUrl).GetAwaiter().GetResult();",
          "699:             m_pushClient.PushClient.Connect(m_pushClient.PushClient.EndpointUrl).GetAwaiter().GetResult();",
          "",
          "---------------"
        ],
        "Tests/Opc.Ua.Gds.Tests/ServerConfigurationPushTestClient.cs||Tests/Opc.Ua.Gds.Tests/ServerConfigurationPushTestClient.cs": [
          "File: Tests/Opc.Ua.Gds.Tests/ServerConfigurationPushTestClient.cs -> Tests/Opc.Ua.Gds.Tests/ServerConfigurationPushTestClient.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "65:             Config = await application.LoadApplicationConfiguration(false).ConfigureAwait(false);",
          "66: #else",
          "68:             var clientConfig = new ServerConfigurationPushTestClientConfiguration() {",
          "69:                 ServerUrl = \"opc.tcp://localhost:58810/GlobalDiscoveryTestServer\",",
          "70:                 AppUserName = \"\",",
          "71:                 AppPassword = \"\",",
          "72:                 SysAdminUserName = \"sysadmin\",",
          "73:                 SysAdminPassword = \"demo\",",
          "75:             };",
          "",
          "[Removed Lines]",
          "67:             string pkiRoot = \"%LocalApplicationData%/OPC/pki\";",
          "74:                 TempStorePath = pkiRoot + \"/temp\"",
          "",
          "[Added Lines]",
          "67:             string root = Path.Combine(\"%LocalApplicationData%\", \"OPC\");",
          "68:             string pkiRoot = Path.Combine(root, \"pki\");",
          "75:                 TempStorePath = Path.Combine(pkiRoot, \"temp\")",
          "76:             };",
          "78:             var transportQuotas = new TransportQuotas() {",
          "79:                 OperationTimeout = 120000,",
          "80:                 MaxStringLength = 1048576,",
          "81:                 MaxByteStringLength = 1048576,",
          "82:                 MaxArrayLength = 65535,",
          "83:                 MaxMessageSize = 4194304,",
          "84:                 MaxBufferSize = 65535,",
          "85:                 ChannelLifetime = 300000,",
          "86:                 SecurityTokenLifetime = 3600000,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:                 .Build(",
          "80:                     \"urn:localhost:opcfoundation.org:ServerConfigurationPushTestClient\",",
          "81:                     \"http://opcfoundation.org/UA/ServerConfigurationPushTestClient\")",
          "82:                 .AsClient()",
          "83:                 .AddSecurityConfiguration(",
          "84:                     \"CN=Server Configuration Push Test Client, O=OPC Foundation\",",
          "86:                 .SetAutoAcceptUntrustedCertificates(true)",
          "87:                 .SetRejectSHA1SignedCertificates(false)",
          "88:                 .SetMinimumCertificateKeySize(1024)",
          "89:                 .AddExtension<ServerConfigurationPushTestClientConfiguration>(null, clientConfig)",
          "91:                 .SetTraceMasks(Utils.TraceMasks.Error)",
          "92:                 .Create().ConfigureAwait(false);",
          "93: #endif",
          "",
          "[Removed Lines]",
          "85:                     pkiRoot)",
          "90:                 .SetOutputFilePath(pkiRoot + \"/Logs/Opc.Ua.Gds.Tests.log.txt\")",
          "",
          "[Added Lines]",
          "94:                 .SetTransportQuotas(transportQuotas)",
          "98:                     pkiRoot, pkiRoot, pkiRoot)",
          "101:                 .SetRejectUnknownRevocationStatus(true)",
          "104:                 .SetOutputFilePath(Path.Combine(root, \"Logs\", \"Opc.Ua.Gds.Tests.log.txt\"))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f51202ae75ac354900ba94f2bba1d726faa2c580",
      "candidate_info": {
        "commit_hash": "f51202ae75ac354900ba94f2bba1d726faa2c580",
        "repo": "OPCFoundation/UA-.NETStandard",
        "commit_url": "https://github.com/OPCFoundation/UA-.NETStandard/commit/f51202ae75ac354900ba94f2bba1d726faa2c580",
        "files": [
          "Libraries/Opc.Ua.Configuration/ApplicationInstance.cs",
          "Libraries/Opc.Ua.Security.Certificates/X509Certificate/X509PfxUtils.cs",
          "Stack/Opc.Ua.Core/Opc.Ua.Core.csproj",
          "Stack/Opc.Ua.Core/Schema/ApplicationConfiguration.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/CertificateFactory.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/DirectoryCertificateStore.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/EccUtils.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/X509Utils.cs",
          "Stack/Opc.Ua.Core/Security/Constants/SecurityConstants.cs",
          "Stack/Opc.Ua.Core/Security/Constants/SecurityPolicies.cs",
          "Stack/Opc.Ua.Core/Stack/Tcp/TcpServerChannel.cs",
          "Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.Asymmetric.cs",
          "Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.Symmetric.cs",
          "Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.cs",
          "Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryClientChannel.cs",
          "Stack/Opc.Ua.Core/Types/Utils/Utils.cs",
          "Tests/Opc.Ua.Client.Tests/ClientFixture.cs",
          "Tests/Opc.Ua.Client.Tests/ClientTest.cs",
          "Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestServer.cs",
          "Tests/Opc.Ua.Server.Tests/ServerFixture.cs"
        ],
        "message": "test case for nistP256",
        "before_after_code_files": [
          "Libraries/Opc.Ua.Configuration/ApplicationInstance.cs||Libraries/Opc.Ua.Configuration/ApplicationInstance.cs",
          "Libraries/Opc.Ua.Security.Certificates/X509Certificate/X509PfxUtils.cs||Libraries/Opc.Ua.Security.Certificates/X509Certificate/X509PfxUtils.cs",
          "Stack/Opc.Ua.Core/Opc.Ua.Core.csproj||Stack/Opc.Ua.Core/Opc.Ua.Core.csproj",
          "Stack/Opc.Ua.Core/Schema/ApplicationConfiguration.cs||Stack/Opc.Ua.Core/Schema/ApplicationConfiguration.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/CertificateFactory.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateFactory.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/DirectoryCertificateStore.cs||Stack/Opc.Ua.Core/Security/Certificates/DirectoryCertificateStore.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/EccUtils.cs||Stack/Opc.Ua.Core/Security/Certificates/EccUtils.cs",
          "Stack/Opc.Ua.Core/Security/Certificates/X509Utils.cs||Stack/Opc.Ua.Core/Security/Certificates/X509Utils.cs",
          "Stack/Opc.Ua.Core/Security/Constants/SecurityConstants.cs||Stack/Opc.Ua.Core/Security/Constants/SecurityConstants.cs",
          "Stack/Opc.Ua.Core/Security/Constants/SecurityPolicies.cs||Stack/Opc.Ua.Core/Security/Constants/SecurityPolicies.cs",
          "Stack/Opc.Ua.Core/Stack/Tcp/TcpServerChannel.cs||Stack/Opc.Ua.Core/Stack/Tcp/TcpServerChannel.cs",
          "Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.Asymmetric.cs||Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.Asymmetric.cs",
          "Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.Symmetric.cs||Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.Symmetric.cs",
          "Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.cs||Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.cs",
          "Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryClientChannel.cs||Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryClientChannel.cs",
          "Stack/Opc.Ua.Core/Types/Utils/Utils.cs||Stack/Opc.Ua.Core/Types/Utils/Utils.cs",
          "Tests/Opc.Ua.Client.Tests/ClientFixture.cs||Tests/Opc.Ua.Client.Tests/ClientFixture.cs",
          "Tests/Opc.Ua.Client.Tests/ClientTest.cs||Tests/Opc.Ua.Client.Tests/ClientTest.cs",
          "Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestServer.cs||Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestServer.cs",
          "Tests/Opc.Ua.Server.Tests/ServerFixture.cs||Tests/Opc.Ua.Server.Tests/ServerFixture.cs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
          ],
          "candidate": [
            "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
          ]
        }
      },
      "candidate_diff": {
        "Libraries/Opc.Ua.Configuration/ApplicationInstance.cs||Libraries/Opc.Ua.Configuration/ApplicationInstance.cs": [
          "File: Libraries/Opc.Ua.Configuration/ApplicationInstance.cs -> Libraries/Opc.Ua.Configuration/ApplicationInstance.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: using System.IO;",
          "33: using System.Linq;",
          "34: using System.Net;",
          "35: using System.Security.Cryptography.X509Certificates;",
          "36: using System.Text;",
          "37: using System.Threading.Tasks;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: using System.Security.Cryptography;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "595:                 configuration.CertificateValidator.CertificateValidation -= certValidator.OnCertificateValidation;",
          "596:             }",
          "601:             {",
          "608:                 {",
          "610:                 }",
          "611:             }",
          "",
          "[Removed Lines]",
          "599:             int keySize = X509Utils.GetRSAPublicKeySize(certificate);",
          "600:             if (minimumKeySize > keySize)",
          "602:                 string message = Utils.Format(",
          "603:                     \"The key size ({0}) in the certificate is less than the minimum provided ({1}). Use certificate anyway?\",",
          "604:                     keySize,",
          "605:                     minimumKeySize);",
          "607:                 if (!await ApproveMessage(message, silent).ConfigureAwait(false))",
          "609:                     return false;",
          "",
          "[Added Lines]",
          "599:             if (!X509Utils.IsECDsaSignature(certificate))",
          "602:                 int keySize = X509Utils.GetRSAPublicKeySize(certificate);",
          "603:                 if (minimumKeySize > keySize)",
          "605:                     string message = Utils.Format(",
          "606:                         \"The key size ({0}) in the certificate is less than the minimum provided ({1}). Use certificate anyway?\",",
          "607:                         keySize,",
          "608:                         minimumKeySize);",
          "610:                     if (!await ApproveMessage(message, silent).ConfigureAwait(false))",
          "611:                     {",
          "612:                         return false;",
          "613:                     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "758:                 id.SubjectName,",
          "759:                 serverDomainNames)",
          "760:                 .SetLifeTime(lifeTimeInMonths)",
          "764:             id.Certificate = certificate;",
          "765:             var passwordProvider = configuration.SecurityConfiguration.CertificatePasswordProvider;",
          "",
          "[Removed Lines]",
          "761:                 .SetRSAKeySize(keySize)",
          "762:                 .CreateForRSA();",
          "",
          "[Added Lines]",
          "766:                 .SetECCurve(ECCurve.NamedCurves.nistP256)",
          "767:                 .CreateForECDsa();",
          "",
          "---------------"
        ],
        "Libraries/Opc.Ua.Security.Certificates/X509Certificate/X509PfxUtils.cs||Libraries/Opc.Ua.Security.Certificates/X509Certificate/X509PfxUtils.cs": [
          "File: Libraries/Opc.Ua.Security.Certificates/X509Certificate/X509PfxUtils.cs -> Libraries/Opc.Ua.Security.Certificates/X509Certificate/X509PfxUtils.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:             X509Certificate2 certWithPublicKey,",
          "49:             X509Certificate2 certWithPrivateKey,",
          "50:             bool throwOnError = false)",
          "51:         {",
          "52:             bool result = false;",
          "53:             try",
          "",
          "[Removed Lines]",
          "47:         public static bool VerifyRSAKeyPair(",
          "",
          "[Added Lines]",
          "46:         public static bool VerifyKeyPair(",
          "50:         {",
          "51:             if (IsECDsaSignature(certWithPublicKey))",
          "52:             {",
          "53:                 return VerifyECDsaKeyPair(certWithPublicKey, certWithPrivateKey, throwOnError);",
          "54:             }",
          "55:             else",
          "56:             {",
          "57:                 return VerifyRSAKeyPair(certWithPublicKey, certWithPrivateKey, throwOnError);",
          "58:             }",
          "59:         }",
          "64:         public static bool VerifyRSAKeyPair(",
          "65:         X509Certificate2 certWithPublicKey,",
          "66:         X509Certificate2 certWithPrivateKey,",
          "67:         bool throwOnError = false)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "119:                         rawData,",
          "120:                         password ?? String.Empty,",
          "121:                         flag);",
          "124:                     {",
          "125:                         return certificate;",
          "126:                     }",
          "",
          "[Removed Lines]",
          "123:                     if (VerifyRSAKeyPair(certificate, certificate, true))",
          "",
          "[Added Lines]",
          "139:                     if (VerifyKeyPair(certificate, certificate, true))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "174:             return rsaPublicKey.VerifyData(testBlock, signature, HashAlgorithmName.SHA1, RSASignaturePadding.Pkcs1);",
          "175:         }",
          "177: #if ECC_SUPPORT",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "196:         public static bool IsECDsaSignature(X509Certificate2 cert)",
          "197:         {",
          "198:             return cert.SignatureAlgorithm.FriendlyName.Contains(\"ECDSA\", StringComparison.OrdinalIgnoreCase);",
          "199:         }",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Opc.Ua.Core.csproj||Stack/Opc.Ua.Core/Opc.Ua.Core.csproj": [
          "File: Stack/Opc.Ua.Core/Opc.Ua.Core.csproj -> Stack/Opc.Ua.Core/Opc.Ua.Core.csproj",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:     <GenerateDocumentationFile>true</GenerateDocumentationFile>",
          "12:   </PropertyGroup>",
          "14:   <PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\">",
          "15:     <PackageId>$(PackageId).Debug</PackageId>",
          "16:   </PropertyGroup>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14:   <PropertyGroup Condition=\"'$(TargetFramework)' == 'netstandard2.1'\">",
          "15:     <DefineConstants>$(DefineConstants);ECC_SUPPORT</DefineConstants>",
          "16:   </PropertyGroup>",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Schema/ApplicationConfiguration.cs||Stack/Opc.Ua.Core/Schema/ApplicationConfiguration.cs": [
          "File: Stack/Opc.Ua.Core/Schema/ApplicationConfiguration.cs -> Stack/Opc.Ua.Core/Schema/ApplicationConfiguration.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "644:                 case SecurityPolicies.Basic128Rsa15: result = 2; break;",
          "645:                 case SecurityPolicies.Basic256: result = 4; break;",
          "646:                 case SecurityPolicies.Basic256Sha256: result = 6; break;",
          "647:                 case SecurityPolicies.Aes128_Sha256_RsaOaep: result = 8; break;",
          "648:                 case SecurityPolicies.Aes256_Sha256_RsaPss: result = 10; break;",
          "649:                 case SecurityPolicies.None:",
          "650:                 default: return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "647:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "648:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "649:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "651:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "652:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "653:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Security/Certificates/CertificateFactory.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateFactory.cs": [
          "File: Stack/Opc.Ua.Core/Security/Certificates/CertificateFactory.cs -> Stack/Opc.Ua.Core/Security/Certificates/CertificateFactory.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "101:                 if (ensurePrivateKeyAccessible)",
          "102:                 {",
          "104:                     {",
          "105:                         Utils.Trace(Utils.TraceMasks.Error, \"WARNING - Trying to add certificate to cache with invalid private key.\");",
          "106:                         return null;",
          "",
          "[Removed Lines]",
          "103:                     if (!X509Utils.VerifyRSAKeyPair(certificate, certificate))",
          "",
          "[Added Lines]",
          "103:                     if (!X509Utils.VerifyKeyPair(certificate, certificate))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "346:                 throw new NotSupportedException(\"Need a certificate with a private key.\");",
          "347:             }",
          "350:             {",
          "352:             }",
          "355:         }",
          "",
          "[Removed Lines]",
          "349:             if (!X509Utils.VerifyRSAKeyPair(certificate, certificateWithPrivateKey))",
          "351:                 throw new NotSupportedException(\"The public and the private key pair doesn't match.\");",
          "354:             return certificate.CopyWithPrivateKey(certificateWithPrivateKey.GetRSAPrivateKey());",
          "",
          "[Added Lines]",
          "349:             if (X509Utils.IsECDsaSignature(certificate))",
          "351:                 if (!X509Utils.VerifyECDsaKeyPair(certificate, certificateWithPrivateKey))",
          "352:                 {",
          "353:                     throw new NotSupportedException(\"The public and the private key pair doesn't match.\");",
          "354:                 }",
          "355:                 using (ECDsa privateKey = certificateWithPrivateKey.GetECDsaPrivateKey())",
          "356:                 {",
          "357:                     return certificate.CopyWithPrivateKey(privateKey);",
          "358:                 }",
          "359:             }",
          "360:             else",
          "361:             {",
          "362:                 if (!X509Utils.VerifyRSAKeyPair(certificate, certificateWithPrivateKey))",
          "363:                 {",
          "364:                     throw new NotSupportedException(\"The public and the private key pair doesn't match.\");",
          "365:                 }",
          "366:                 using (RSA privateKey = certificateWithPrivateKey.GetRSAPrivateKey())",
          "367:                 {",
          "368:                     return certificate.CopyWithPrivateKey(privateKey);",
          "369:                 }",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs": [
          "File: Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs -> Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "496:                         try",
          "497:                         {",
          "498:                             store.Delete(certificate.Thumbprint);",
          "500:                         }",
          "501:                         finally",
          "502:                         {",
          "",
          "[Removed Lines]",
          "499:                             store.Add(certificate);",
          "",
          "[Added Lines]",
          "500:                             if (certificate.HasPrivateKey)",
          "501:                             {",
          "502:                                 using (var cert = new X509Certificate2(certificate.RawData))",
          "503:                                 {",
          "504:                                     store.Add(cert);",
          "505:                                 }",
          "506:                             }",
          "507:                             else",
          "508:                             {",
          "509:                                 store.Add(certificate);",
          "510:                             }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "927:                     );",
          "928:             }",
          "931:             X509KeyUsageFlags certificateKeyUsage = X509Utils.GetKeyUsage(certificate);",
          "934:             {",
          "937:             }",
          "",
          "[Removed Lines]",
          "933:             if ((certificateKeyUsage & X509KeyUsageFlags.DataEncipherment) == 0)",
          "935:                 sresult = new ServiceResult(StatusCodes.BadCertificateUseNotAllowed,",
          "936:                     null, null, \"Usage of certificate is not allowed.\", null, sresult);",
          "",
          "[Added Lines]",
          "941:             bool isECDsaSignature = X509PfxUtils.IsECDsaSignature(certificate);",
          "945:             if (isECDsaSignature)",
          "947:                 if ((certificateKeyUsage & X509KeyUsageFlags.DigitalSignature) == 0)",
          "948:                 {",
          "949:                     sresult = new ServiceResult(StatusCodes.BadCertificateUseNotAllowed,",
          "950:                         null, null, \"Usage of ECDSA certificate is not allowed.\", null, sresult);",
          "951:                 }",
          "952:             }",
          "953:             else",
          "954:             {",
          "955:                 if ((certificateKeyUsage & X509KeyUsageFlags.DataEncipherment) == 0)",
          "956:                 {",
          "957:                     sresult = new ServiceResult(StatusCodes.BadCertificateUseNotAllowed,",
          "958:                         null, null, \"Usage of RSA certificate is not allowed.\", null, sresult);",
          "959:                 }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "943:                     null, null, \"SHA1 signed certificates are not trusted.\", null, sresult);",
          "944:             }",
          "948:             {",
          "951:             }",
          "953:             if (issuedByCA && chainIncomplete)",
          "",
          "[Removed Lines]",
          "946:             int keySize = X509Utils.GetRSAPublicKeySize(certificate);",
          "947:             if (keySize < m_minimumCertificateKeySize)",
          "949:                 sresult = new ServiceResult(StatusCodes.BadCertificatePolicyCheckFailed,",
          "950:                     null, null, \"Certificate doesn't meet minimum key length requirement.\", null, sresult);",
          "",
          "[Added Lines]",
          "969:             if (!isECDsaSignature)",
          "971:                 int keySize = X509Utils.GetRSAPublicKeySize(certificate);",
          "972:                 if (keySize < m_minimumCertificateKeySize)",
          "973:                 {",
          "974:                     sresult = new ServiceResult(StatusCodes.BadCertificatePolicyCheckFailed,",
          "975:                         null, null, \"Certificate doesn't meet minimum key length requirement.\", null, sresult);",
          "976:                 }",
          "977:             }",
          "978:             else",
          "979:             {",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Security/Certificates/DirectoryCertificateStore.cs||Stack/Opc.Ua.Core/Security/Certificates/DirectoryCertificateStore.cs": [
          "File: Stack/Opc.Ua.Core/Security/Certificates/DirectoryCertificateStore.cs -> Stack/Opc.Ua.Core/Security/Certificates/DirectoryCertificateStore.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "339:                                 privateKeyFile.FullName,",
          "340:                                 password,",
          "341:                                 flag);",
          "343:                             {",
          "344:                                 return certificate;",
          "345:                             }",
          "",
          "[Removed Lines]",
          "342:                             if (X509Utils.VerifyRSAKeyPair(certificate, certificate, true))",
          "",
          "[Added Lines]",
          "342:                             if (X509Utils.VerifyKeyPair(certificate, certificate, true))",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Security/Certificates/EccUtils.cs||Stack/Opc.Ua.Core/Security/Certificates/EccUtils.cs": [
          "File: Stack/Opc.Ua.Core/Security/Certificates/EccUtils.cs -> Stack/Opc.Ua.Core/Security/Certificates/EccUtils.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2:    The source code in this file is covered under a dual-license scenario:",
          "3:      - RCL: for OPC Foundation members in good-standing",
          "4:      - GPL V2: everybody else",
          "5:    RCL license terms accompanied with this source code. See http://opcfoundation.org/License/RCL/1.00/",
          "6:    GNU General Public License as published by the Free Software Foundation;",
          "7:    version 2 of the License are accompanied with this source code. See http://opcfoundation.org/License/GPLv2",
          "8:    This source code is distributed in the hope that it will be useful,",
          "9:    but WITHOUT ANY WARRANTY; without even the implied warranty of",
          "10:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.",
          "13: #if ECC_SUPPORT",
          "15: using System;",
          "16: using System.Text;",
          "17: using System.IO;",
          "18: using System.Collections.Generic;",
          "19: using System.Security.Cryptography;",
          "20: using System.Security.Cryptography.X509Certificates;",
          "22: #if CURVE25519",
          "23: using Org.BouncyCastle.Pkcs;",
          "24: using Org.BouncyCastle.X509;",
          "25: using Org.BouncyCastle.Security;",
          "26: using Org.BouncyCastle.Crypto;",
          "27: using Org.BouncyCastle.Crypto.Parameters;",
          "28: using Org.BouncyCastle.Crypto.Signers;",
          "29: using Org.BouncyCastle.Crypto.Agreement;",
          "30: using Org.BouncyCastle.Crypto.Generators;",
          "31: using Org.BouncyCastle.Crypto.Modes;",
          "32: using Org.BouncyCastle.Crypto.Digests;",
          "33: #endif",
          "35: namespace Opc.Ua",
          "36: {",
          "40:     public class ICertificate : X509Certificate2",
          "41:     {",
          "42:     }",
          "46:     public class Nonce : IDisposable",
          "47:     {",
          "48:         private ECDiffieHellman m_ecdh;",
          "49: #if CURVE25519",
          "50:         private AsymmetricCipherKeyPair m_bcKeyPair;",
          "51: #endif",
          "53:         enum Algorithm",
          "54:         {",
          "55:             Unknown,",
          "56:             RSA,",
          "57:             nistP256,",
          "58:             nistP384,",
          "59:             brainpoolP256r1,",
          "60:             brainpoolP384r1,",
          "61:             Ed25519",
          "62:         }",
          "67:         enum CngAlgorithm",
          "68:         {",
          "69:             Sha256,",
          "70:             Sha1,",
          "71:             MD5,",
          "72:             ECDsaP521,",
          "73:             ECDsaP384,",
          "74:             ECDsaP256,",
          "75:             ECDsa,",
          "76:             ECDiffieHellmanP521,",
          "77:             ECDiffieHellmanP384,",
          "78:             ECDiffieHellmanP256,",
          "79:             ECDiffieHellman,",
          "80:             Rsa,",
          "81:             Sha384,",
          "82:             Sha512,",
          "83:         }",
          "85:         private Nonce()",
          "86:         {",
          "87:             m_ecdh = null;",
          "88: #if CURVE25519",
          "89:             m_bcKeyPair = null;",
          "90: #endif",
          "91:         }",
          "93:         #region IDisposable Members",
          "97:         public void Dispose()",
          "98:         {",
          "99:             Dispose(true);",
          "100:         }",
          "105:         protected virtual void Dispose(bool disposing)",
          "106:         {",
          "107:             if (disposing)",
          "108:             {",
          "109:                 if (m_ecdh != null)",
          "110:                 {",
          "111:                     m_ecdh.Dispose();",
          "112:                     m_ecdh = null;",
          "113:                 }",
          "114:             }",
          "115:         }",
          "116:         #endregion",
          "118:         public byte[] Data { get; private set; }",
          "120:         public byte[] DeriveKey(Nonce remoteNonce, byte[] salt, HashAlgorithmName algorithm, int length)",
          "121:         {",
          "122: #if CURVE25519",
          "123:             if (m_bcKeyPair != null)",
          "124:             {",
          "125:                 var localPublicKey = m_bcKeyPair.Public;",
          "127:                 if (localPublicKey is X25519PublicKeyParameters)",
          "128:                 {",
          "129:                     X25519Agreement agreement = new X25519Agreement();",
          "130:                     agreement.Init(m_bcKeyPair.Private);",
          "132:                     var key = new X25519PublicKeyParameters(remoteNonce.Data, 0);",
          "133:                     byte[] secret = new byte[agreement.AgreementSize];",
          "134:                     agreement.CalculateAgreement(key, secret, 0);",
          "136:                     HkdfBytesGenerator generator = new HkdfBytesGenerator(new Sha256Digest());",
          "137:                     generator.Init(new HkdfParameters(secret, salt, salt));",
          "139:                     byte[] output = new byte[length];",
          "140:                     generator.GenerateBytes(output, 0, output.Length);",
          "141:                     return output;",
          "142:                 }",
          "144:                 if (localPublicKey is X448PublicKeyParameters)",
          "145:                 {",
          "146:                     X448Agreement agreement = new X448Agreement();",
          "147:                     agreement.Init(m_bcKeyPair.Private);",
          "149:                     var key = new X448PublicKeyParameters(remoteNonce.Data, 0);",
          "150:                     byte[] secret = new byte[agreement.AgreementSize];",
          "151:                     agreement.CalculateAgreement(key, secret, 0);",
          "153:                     HkdfBytesGenerator generator = new HkdfBytesGenerator(new Sha256Digest());",
          "154:                     generator.Init(new HkdfParameters(secret, salt, salt));",
          "156:                     byte[] output = new byte[length];",
          "157:                     generator.GenerateBytes(output, 0, output.Length);",
          "158:                     return output;",
          "159:                 }",
          "161:                 throw new NotSupportedException();",
          "162:             }",
          "163: #endif",
          "164:             if (m_ecdh != null)",
          "165:             {",
          "166:                 var secret = m_ecdh.DeriveKeyFromHmac(remoteNonce.m_ecdh.PublicKey, algorithm, salt, null, null);",
          "168:                 byte[] output = new byte[length];",
          "170:                 HMACSHA256 hmac = new HMACSHA256(secret);",
          "172:                 byte counter = 1;",
          "174:                 byte[] info = new byte[hmac.HashSize / 8 + salt.Length + 1];",
          "175:                 Buffer.BlockCopy(salt, 0, info, 0, salt.Length);",
          "176:                 info[salt.Length] = counter++;",
          "178:                 byte[] hash = hmac.ComputeHash(info, 0, salt.Length + 1);",
          "180:                 int pos = 0;",
          "182:                 for (int ii = 0; ii < hash.Length && pos < length; ii++)",
          "183:                 {",
          "184:                     output[pos++] = hash[ii];",
          "185:                 }",
          "187:                 while (pos < length)",
          "188:                 {",
          "189:                     Buffer.BlockCopy(hash, 0, info, 0, hash.Length);",
          "190:                     Buffer.BlockCopy(salt, 0, info, hash.Length, salt.Length);",
          "191:                     info[info.Length - 1] = counter++;",
          "193:                     hash = hmac.ComputeHash(info, 0, info.Length);",
          "195:                     for (int ii = 0; ii < hash.Length && pos < length; ii++)",
          "196:                     {",
          "197:                         output[pos++] = hash[ii];",
          "198:                     }",
          "199:                 }",
          "201:                 return output;",
          "202:             }",
          "204:             return Data;",
          "205:         }",
          "207:         public static Nonce CreateNonce(string securityPolicyUri, uint nonceLength)",
          "208:         {",
          "209:             if (securityPolicyUri == null)",
          "210:             {",
          "211:                 throw new ArgumentNullException(\"securityPolicyUri\");",
          "212:             }",
          "214:             Nonce nonce = null;",
          "216:             ECCurve curve = ECCurve.NamedCurves.nistP256;",
          "218:             switch (securityPolicyUri)",
          "219:             {",
          "220:                 case SecurityPolicies.Aes128_Sha256_nistP256: { return CreateNonce(ECCurve.NamedCurves.nistP256, CngAlgorithm.Sha256); }",
          "221:                 case SecurityPolicies.Aes256_Sha384_nistP384: { return CreateNonce(ECCurve.NamedCurves.nistP384, CngAlgorithm.Sha384); }",
          "222:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1: { return CreateNonce(ECCurve.NamedCurves.brainpoolP256r1, CngAlgorithm.Sha256); }",
          "223:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1: { return CreateNonce(ECCurve.NamedCurves.brainpoolP384r1, CngAlgorithm.Sha384); }",
          "224: #if CURVE25519",
          "225:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "226:                 {",
          "227:                     return CreateNonceForCurve25519();",
          "228:                 }",
          "230:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "231:                 {",
          "232:                     return CreateNonceForCurve448();",
          "233:                 }",
          "234: #endif",
          "235:                 default:",
          "236:                 {",
          "237:                     nonce = new Nonce() {",
          "238:                         Data = Utils.Nonce.CreateNonce(nonceLength)",
          "239:                     };",
          "241:                     return nonce;",
          "242:                 }",
          "243:             }",
          "244:         }",
          "245: #if CURVE25519",
          "246:         private static Nonce CreateNonceForCurve25519()",
          "247:         {",
          "248:             SecureRandom random = new SecureRandom();",
          "249:             IAsymmetricCipherKeyPairGenerator generator = new X25519KeyPairGenerator();",
          "250:             generator.Init(new X25519KeyGenerationParameters(random));",
          "252:             var keyPair = generator.GenerateKeyPair();",
          "254:             byte[] senderNonce = new byte[X25519PublicKeyParameters.KeySize];",
          "255:             ((X25519PublicKeyParameters)(keyPair.Public)).Encode(senderNonce, 0);",
          "257:             var nonce = new Nonce() {",
          "258:                 Data = senderNonce,",
          "259:                 m_bcKeyPair = keyPair",
          "260:             };",
          "262:             return nonce;",
          "263:         }",
          "265:         private static Nonce CreateNonceForCurve448()",
          "266:         {",
          "267:             SecureRandom random = new SecureRandom();",
          "268:             IAsymmetricCipherKeyPairGenerator generator = new X448KeyPairGenerator();",
          "269:             generator.Init(new X448KeyGenerationParameters(random));",
          "271:             var keyPair = generator.GenerateKeyPair();",
          "273:             byte[] senderNonce = new byte[X448PublicKeyParameters.KeySize];",
          "274:             ((X448PublicKeyParameters)(keyPair.Public)).Encode(senderNonce, 0);",
          "276:             var nonce = new Nonce() {",
          "277:                 Data = senderNonce,",
          "278:                 m_bcKeyPair = keyPair",
          "279:             };",
          "281:             return nonce;",
          "282:         }",
          "283: #endif",
          "284:         private static Nonce CreateNonce(ECCurve curve, CngAlgorithm algorithm)",
          "285:         {",
          "286: #if NET472",
          "287:             var ecdh = (ECDiffieHellman)ECDiffieHellmanCng.Create(curve);",
          "288:             byte[] data = ecdh.Key.Export(CngKeyBlobFormat.EccPublicBlob);",
          "289:             var senderNonce = new byte[data.Length - 8];",
          "290:             Buffer.BlockCopy(data, 8, senderNonce, 0, senderNonce.Length);",
          "291: #else",
          "292:             var ecdh = (ECDiffieHellman)ECDiffieHellman.Create(curve);",
          "293:             var ecdhParameters = ecdh.ExportParameters(false);",
          "294:             int xLen = ecdhParameters.Q.X.Length;",
          "295:             int yLen = ecdhParameters.Q.Y.Length;",
          "296:             byte[] senderNonce = new byte[xLen + yLen];",
          "297:             Array.Copy(ecdhParameters.Q.X, senderNonce, xLen);",
          "298:             Array.Copy(ecdhParameters.Q.Y, 0, senderNonce, xLen, yLen);",
          "299: #endif",
          "301:             var nonce = new Nonce() {",
          "302:                 Data = senderNonce,",
          "303:                 m_ecdh = ecdh",
          "304:             };",
          "306:             return nonce;",
          "307:         }",
          "309:         public static Nonce CreateNonce(string securityPolicyUri, byte[] nonceData)",
          "310:         {",
          "311:             if (securityPolicyUri == null)",
          "312:             {",
          "313:                 throw new ArgumentNullException(\"securityPolicyUri\");",
          "314:             }",
          "316:             if (nonceData == null)",
          "317:             {",
          "318:                 throw new ArgumentNullException(\"nonceData\");",
          "319:             }",
          "321:             Nonce nonce = new Nonce() {",
          "322:                 Data = nonceData",
          "323:             };",
          "325:             switch (securityPolicyUri)",
          "326:             {",
          "327:                 case SecurityPolicies.Aes128_Sha256_nistP256: { return CreateNonce(ECCurve.NamedCurves.nistP256, CngAlgorithm.Sha256, nonceData); }",
          "328:                 case SecurityPolicies.Aes256_Sha384_nistP384: { return CreateNonce(ECCurve.NamedCurves.nistP384, CngAlgorithm.Sha384, nonceData); }",
          "329:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1: { return CreateNonce(ECCurve.NamedCurves.brainpoolP256r1, CngAlgorithm.Sha256, nonceData); }",
          "330:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1: { return CreateNonce(ECCurve.NamedCurves.brainpoolP384r1, CngAlgorithm.Sha384, nonceData); }",
          "332:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "333:                 {",
          "334:                     return CreateNonceForCurve25519(nonceData);",
          "335:                 }",
          "337:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "338:                 {",
          "339:                     return CreateNonceForCurve448(nonceData);",
          "340:                 }",
          "342:                 default:",
          "343:                 {",
          "344:                     break;",
          "345:                 }",
          "346:             }",
          "348:             return nonce;",
          "349:         }",
          "352:         private static Nonce CreateNonceForCurve25519(byte[] nonceData)",
          "353:         {",
          "354:             var nonce = new Nonce() {",
          "355:                 Data = nonceData,",
          "356:             };",
          "358:             return nonce;",
          "359:         }",
          "361:         private static Nonce CreateNonceForCurve448(byte[] nonceData)",
          "362:         {",
          "363:             var nonce = new Nonce() {",
          "364:                 Data = nonceData,",
          "365:             };",
          "367:             return nonce;",
          "368:         }",
          "370:         private static Nonce CreateNonce(ECCurve curve, CngAlgorithm algorithm, byte[] nonceData)",
          "371:         {",
          "372:             Nonce nonce = new Nonce() {",
          "373:                 Data = nonceData",
          "374:             };",
          "376:             int keyLength = nonceData.Length;",
          "378:             using (var ostrm = new System.IO.MemoryStream())",
          "379:             {",
          "380:                 byte[] qx = new byte[keyLength / 2];",
          "381:                 byte[] qy = new byte[keyLength / 2];",
          "382:                 Buffer.BlockCopy(nonceData, 0, qx, 0, keyLength / 2);",
          "383:                 Buffer.BlockCopy(nonceData, keyLength / 2, qy, 0, keyLength / 2);",
          "385:                 var ecdhParameters = new ECParameters {",
          "386:                     Curve = curve,",
          "387:                     Q = { X = qx, Y = qy }",
          "388:                 };",
          "390:                 nonce.m_ecdh = ECDiffieHellman.Create(ecdhParameters);",
          "391:             }",
          "393:             return nonce;",
          "394:         }",
          "395:     }",
          "400:     public static class EccUtils",
          "401:     {",
          "402:         public static bool IsEccPolicy(string securityPolicyUri)",
          "403:         {",
          "404:             if (securityPolicyUri != null)",
          "405:             {",
          "406:                 switch (securityPolicyUri)",
          "407:                 {",
          "408:                     case SecurityPolicies.Aes128_Sha256_nistP256:",
          "409:                     case SecurityPolicies.Aes256_Sha384_nistP384:",
          "410:                     case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "411:                     case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "412:                     case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "413:                     case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "414:                     {",
          "415:                         return true;",
          "416:                     }",
          "417:                 }",
          "418:             }",
          "420:             return false;",
          "421:         }",
          "423:         public static string[] GetSupportedSecurityPolicyUris(ICertificate certificate)",
          "424:         {",
          "425:             string[] securityPolicyUris;",
          "427:             if (GetPublicKey(certificate, out securityPolicyUris) == null)",
          "428:             {",
          "429:                 return null;",
          "430:             }",
          "432:             return securityPolicyUris;",
          "433:         }",
          "435:         public static ECDsa GetPublicKey(X509Certificate2 certificate)",
          "436:         {",
          "437:             string[] securityPolicyUris;",
          "438:             return GetPublicKey(certificate, out securityPolicyUris);",
          "439:         }",
          "441:         public static ECDsa GetPublicKey(X509Certificate2 certificate, out string[] securityPolicyUris)",
          "442:         {",
          "443:             securityPolicyUris = null;",
          "445:             var keyAlgorithm = certificate.GetKeyAlgorithm();",
          "447:             if (certificate == null || keyAlgorithm != \"1.2.840.10045.2.1\")",
          "448:             {",
          "449:                 return null;",
          "450:             }",
          "452:             const X509KeyUsageFlags SufficientFlags =",
          "453:                 X509KeyUsageFlags.KeyAgreement |",
          "454:                 X509KeyUsageFlags.DigitalSignature |",
          "455:                 X509KeyUsageFlags.NonRepudiation |",
          "456:                 X509KeyUsageFlags.CrlSign |",
          "457:                 X509KeyUsageFlags.KeyCertSign;",
          "459:             foreach (X509Extension extension in certificate.Extensions)",
          "460:             {",
          "461:                 if (extension.Oid.Value == \"2.5.29.15\")",
          "462:                 {",
          "463:                     X509KeyUsageExtension kuExt = (X509KeyUsageExtension)extension;",
          "465:                     if ((kuExt.KeyUsages & SufficientFlags) == 0)",
          "466:                     {",
          "467:                         return null;",
          "468:                     }",
          "469:                 }",
          "470:             }",
          "472:             PublicKey encodedPublicKey = certificate.PublicKey;",
          "473:             string keyParameters = BitConverter.ToString(encodedPublicKey.EncodedParameters.RawData);",
          "474:             byte[] keyValue = encodedPublicKey.EncodedKeyValue.RawData;",
          "476:             ECParameters ecParameters = default(ECParameters);",
          "478:             if (keyValue[0] != 0x04)",
          "479:             {",
          "480:                 throw new InvalidOperationException(\"Only uncompressed points are supported\");",
          "481:             }",
          "483:             byte[] x = new byte[(keyValue.Length - 1) / 2];",
          "484:             byte[] y = new byte[x.Length];",
          "486:             Buffer.BlockCopy(keyValue, 1, x, 0, x.Length);",
          "487:             Buffer.BlockCopy(keyValue, 1 + x.Length, y, 0, y.Length);",
          "489:             ecParameters.Q.X = x;",
          "490:             ecParameters.Q.Y = y;",
          "495:             switch (keyParameters)",
          "496:             {",
          "497:                 case \"06-08-2A-86-48-CE-3D-03-01-07\":",
          "498:                 {",
          "499:                     ecParameters.Curve = ECCurve.NamedCurves.nistP256;",
          "500:                     securityPolicyUris = new string[] { SecurityPolicies.Aes128_Sha256_nistP256 };",
          "501:                     break;",
          "502:                 }",
          "504:                 case \"06-05-2B-81-04-00-22\":",
          "505:                 {",
          "506:                     ecParameters.Curve = ECCurve.NamedCurves.nistP384;",
          "507:                     securityPolicyUris = new string[] { SecurityPolicies.Aes256_Sha384_nistP384, SecurityPolicies.Aes128_Sha256_nistP256 };",
          "508:                     break;",
          "509:                 }",
          "511:                 case \"06-09-2B-24-03-03-02-08-01-01-07\":",
          "512:                 {",
          "513:                     ecParameters.Curve = ECCurve.NamedCurves.brainpoolP256r1;",
          "514:                     securityPolicyUris = new string[] { SecurityPolicies.Aes128_Sha256_brainpoolP256r1 };",
          "515:                     break;",
          "516:                 }",
          "517:                 case \"06-09-2B-24-03-03-02-08-01-01-0B\":",
          "518:                 {",
          "519:                     ecParameters.Curve = ECCurve.NamedCurves.brainpoolP384r1;",
          "520:                     securityPolicyUris = new string[] { SecurityPolicies.Aes256_Sha384_brainpoolP384r1, SecurityPolicies.Aes128_Sha256_brainpoolP256r1 };",
          "521:                     break;",
          "522:                 }",
          "524:                 default:",
          "525:                 {",
          "526:                     throw new NotImplementedException(keyParameters);",
          "527:                 }",
          "528:             }",
          "530:             return ECDsa.Create(ecParameters);",
          "531:         }",
          "536:         public static int GetSignatureLength(X509Certificate2 signingCertificate)",
          "537:         {",
          "538:             if (signingCertificate == null)",
          "539:             {",
          "540:                 throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, \"No public key for certificate.\");",
          "541:             }",
          "542: #if CURVE25519",
          "543:             if (signingCertificate.BcCertificate.GetPublicKey() is Ed25519PublicKeyParameters)",
          "544:             {",
          "545:                 return 64;",
          "546:             }",
          "548:             if (signingCertificate.BcCertificate.GetPublicKey() is Ed448PublicKeyParameters)",
          "549:             {",
          "550:                 return 114;",
          "551:             }",
          "552: #endif",
          "553:             using (var publicKey = GetPublicKey(signingCertificate))",
          "554:             {",
          "555:                 if (publicKey == null)",
          "556:                 {",
          "557:                     throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, \"No public key for certificate.\");",
          "558:                 }",
          "560:                 return publicKey.KeySize / 4;",
          "561:             }",
          "563:             throw new NotImplementedException();",
          "564:         }",
          "566:         public static HashAlgorithmName GetSignatureAlgorithmName(string securityPolicyUri)",
          "567:         {",
          "568:             if (securityPolicyUri == null)",
          "569:             {",
          "570:                 throw new ArgumentNullException(\"securityPolicyUri\");",
          "571:             }",
          "573:             switch (securityPolicyUri)",
          "574:             {",
          "575:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "576:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "577:                 {",
          "578:                     return HashAlgorithmName.SHA256;",
          "579:                 }",
          "581:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "582:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "583:                 {",
          "584:                     return HashAlgorithmName.SHA384;",
          "585:                 }",
          "587:                 case SecurityPolicies.None:",
          "588:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "589:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "590:                 default:",
          "591:                 {",
          "592:                     return HashAlgorithmName.SHA256;",
          "593:                 }",
          "594:             }",
          "595:         }",
          "600:         public static byte[] Encrypt(",
          "601:             byte[] dataToEncrypt,",
          "602:             ICertificate encryptingCertificate)",
          "603:         {",
          "604:             return dataToEncrypt;",
          "605:         }",
          "610:         public static byte[] Decrypt(",
          "611:             ArraySegment<byte> dataToDecrypt,",
          "612:             ICertificate encryptingCertificate)",
          "613:         {",
          "614:             return dataToDecrypt.Array;",
          "615:         }",
          "620:         public static byte[] Sign(",
          "621:             ArraySegment<byte> dataToSign,",
          "622:             X509Certificate2 signingCertificate,",
          "623:             string securityPolicyUri)",
          "624:         {",
          "625:             var algorithm = GetSignatureAlgorithmName(securityPolicyUri);",
          "626:             return Sign(dataToSign, signingCertificate, algorithm);",
          "627:         }",
          "632:         public static byte[] Sign(",
          "633:             ArraySegment<byte> dataToSign,",
          "634:             X509Certificate2 signingCertificate,",
          "635:             HashAlgorithmName algorithm)",
          "636:         {",
          "637: #if CURVE25519",
          "638:             var publicKey = signingCertificate.BcCertificate.GetPublicKey();",
          "640:             if (publicKey is Ed25519PublicKeyParameters)",
          "641:             {",
          "642:                 var signer = new Ed25519Signer();",
          "644:                 signer.Init(true, signingCertificate.BcPrivateKey);",
          "645:                 signer.BlockUpdate(dataToSign.Array, dataToSign.Offset, dataToSign.Count);",
          "646:                 byte[] signature = signer.GenerateSignature();",
          "647: #if DEBUG",
          "648:                 var verifier = new Ed25519Signer();",
          "650:                 verifier.Init(false, signingCertificate.BcCertificate.GetPublicKey());",
          "651:                 verifier.BlockUpdate(dataToSign.Array, dataToSign.Offset, dataToSign.Count);",
          "653:                 if (!verifier.VerifySignature(signature))",
          "654:                 {",
          "655:                     throw new ServiceResultException(StatusCodes.BadSecurityChecksFailed, \"Could not verify signature.\");",
          "656:                 }",
          "657: #endif",
          "658:                 return signature;",
          "659:             }",
          "661:             if (publicKey is Ed448PublicKeyParameters)",
          "662:             {",
          "663:                 var signer = new Ed448Signer(new byte[32]);",
          "665:                 signer.Init(true, signingCertificate.BcPrivateKey);",
          "666:                 signer.BlockUpdate(dataToSign.Array, dataToSign.Offset, dataToSign.Count);",
          "667:                 byte[] signature = signer.GenerateSignature();",
          "668: #if DEBUG",
          "669:                 var verifier = new Ed448Signer(new byte[32]);",
          "671:                 verifier.Init(false, signingCertificate.BcCertificate.GetPublicKey());",
          "672:                 verifier.BlockUpdate(dataToSign.Array, dataToSign.Offset, dataToSign.Count);",
          "674:                 if (!verifier.VerifySignature(signature))",
          "675:                 {",
          "676:                     throw new ServiceResultException(StatusCodes.BadSecurityChecksFailed, \"Could not verify signature.\");",
          "677:                 }",
          "678: #endif",
          "679:                 return signature;",
          "680:             }",
          "681: #endif",
          "682:             var senderPrivateKey = signingCertificate.GetECDsaPrivateKey() as ECDsa;",
          "684:             if (senderPrivateKey == null)",
          "685:             {",
          "686:                 throw new ServiceResultException(StatusCodes.BadCertificateInvalid, \"Missing private key needed for create a signature.\");",
          "687:             }",
          "689:             using (senderPrivateKey)",
          "690:             {",
          "691:                 var signature = senderPrivateKey.SignData(dataToSign.Array, dataToSign.Offset, dataToSign.Count, algorithm);",
          "693: #if DEBUGxxx",
          "694:                 using (ECDsa ecdsa = EccUtils.GetPublicKey(new X509Certificate2(signingCertificate.RawData)))",
          "695:                 {",
          "696:                     if (!ecdsa.VerifyData(dataToSign.Array, dataToSign.Offset, dataToSign.Count, signature, algorithm))",
          "697:                     {",
          "698:                         throw new ServiceResultException(StatusCodes.BadSecurityChecksFailed, \"Could not verify signature.\");",
          "699:                     }",
          "700:                 }",
          "701: #endif",
          "703:                 return signature;",
          "704:             }",
          "705:         }",
          "710:         public static bool Verify(",
          "711:             ArraySegment<byte> dataToVerify,",
          "712:             byte[] signature,",
          "713:             X509Certificate2 signingCertificate,",
          "714:             string securityPolicyUri)",
          "715:         {",
          "716:             return Verify(dataToVerify, signature, signingCertificate, GetSignatureAlgorithmName(securityPolicyUri));",
          "717:         }",
          "722:         public static bool Verify(",
          "723:             ArraySegment<byte> dataToVerify,",
          "724:             byte[] signature,",
          "725:             X509Certificate2 signingCertificate,",
          "726:             HashAlgorithmName algorithm)",
          "727:         {",
          "728: #if CURVE25519",
          "729:             var publicKey = signingCertificate.BcCertificate.GetPublicKey();",
          "731:             if (publicKey is Ed25519PublicKeyParameters)",
          "732:             {",
          "733:                 var verifier = new Ed25519Signer();",
          "735:                 verifier.Init(false, signingCertificate.BcCertificate.GetPublicKey());",
          "736:                 verifier.BlockUpdate(dataToVerify.Array, dataToVerify.Offset, dataToVerify.Count);",
          "738:                 if (!verifier.VerifySignature(signature))",
          "739:                 {",
          "740:                     return false;",
          "741:                 }",
          "743:                 return true;",
          "744:             }",
          "746:             if (publicKey is Ed448PublicKeyParameters)",
          "747:             {",
          "748:                 var verifier = new Ed448Signer(new byte[32]);",
          "750:                 verifier.Init(false, signingCertificate.BcCertificate.GetPublicKey());",
          "751:                 verifier.BlockUpdate(dataToVerify.Array, dataToVerify.Offset, dataToVerify.Count);",
          "753:                 if (!verifier.VerifySignature(signature))",
          "754:                 {",
          "755:                     return false;",
          "756:                 }",
          "758:                 return true;",
          "759:             }",
          "760: #endif",
          "761:             using (ECDsa ecdsa = EccUtils.GetPublicKey(signingCertificate))",
          "762:             {",
          "763:                 if (!ecdsa.VerifyData(dataToVerify.Array, dataToVerify.Offset, dataToVerify.Count, signature, algorithm))",
          "764:                 {",
          "765:                     return false;",
          "766:                 }",
          "767:             }",
          "769:             return true;",
          "770:         }",
          "771:     }",
          "773:     public class EncryptedSecret",
          "774:     {",
          "775:         public X509Certificate2 SenderCertificate { get; set; }",
          "777:         public X509Certificate2Collection SenderIssuerCertificates { get; set; }",
          "779:         public bool DoNotEncodeSenderCertificate { get; set; }",
          "781:         public Nonce SenderNonce { get; set; }",
          "783:         public Nonce ReceiverNonce { get; set; }",
          "785:         public ICertificate ReceiverCertificate { get; set; }",
          "787:         public CertificateValidator Validator { get; set; }",
          "789:         public string SecurityPolicyUri { get; set; }",
          "791:         private static byte[] EncryptSecret(",
          "792:             byte[] secret,",
          "793:             byte[] nonce,",
          "794:             byte[] encryptingKey,",
          "795:             byte[] iv)",
          "796:         {",
          "797: #if CURVE25519",
          "798:             bool useAuthenticatedEncryption = false;",
          "799:             if (SenderCertificate.BcCertificate.GetPublicKey() is Ed25519PublicKeyParameters ||",
          "800:                 SenderCertificate.BcCertificate.GetPublicKey() is Ed448PublicKeyParameters)",
          "801:             {",
          "802:                 useAuthenticatedEncryption = true;",
          "803:             }",
          "804: #endif",
          "805:             byte[] dataToEncrypt = null;",
          "807:             using (var encoder = new BinaryEncoder(ServiceMessageContext.GlobalContext))",
          "808:             {",
          "809:                 encoder.WriteByteString(null, nonce);",
          "810:                 encoder.WriteByteString(null, secret);",
          "813:                 int paddingSize = (iv.Length - ((encoder.Position + 2) % iv.Length));",
          "814:                 paddingSize %= iv.Length;",
          "816:                 if (secret.Length + paddingSize < iv.Length)",
          "817:                 {",
          "818:                     paddingSize += iv.Length;",
          "819:                 }",
          "821:                 for (int ii = 0; ii < paddingSize; ii++)",
          "822:                 {",
          "823:                     encoder.WriteByte(null, (byte)(paddingSize & 0xFF));",
          "824:                 }",
          "826:                 encoder.WriteUInt16(null, (ushort)paddingSize);",
          "828:                 dataToEncrypt = encoder.CloseAndReturnBuffer();",
          "829:             }",
          "830: #if CURVE25519",
          "831:             if (useAuthenticatedEncryption)",
          "832:             {",
          "833:                 return EncryptWithChaCha20Poly1305(encryptingKey, iv, dataToEncrypt);",
          "834:             }",
          "835: #endif",
          "836:             using (Aes aes = Aes.Create())",
          "837:             {",
          "838:                 aes.Mode = CipherMode.CBC;",
          "839:                 aes.Padding = PaddingMode.None;",
          "840:                 aes.Key = encryptingKey;",
          "841:                 aes.IV = iv;",
          "843:                 using (ICryptoTransform encryptor = aes.CreateEncryptor())",
          "844:                 {",
          "845:                     if (dataToEncrypt.Length % encryptor.InputBlockSize != 0)",
          "846:                     {",
          "847:                         throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, \"Input data is not an even number of encryption blocks.\");",
          "848:                     }",
          "850:                     encryptor.TransformBlock(dataToEncrypt, 0, dataToEncrypt.Length, dataToEncrypt, 0);",
          "851:                 }",
          "852:             }",
          "854:             return dataToEncrypt;",
          "855:         }",
          "857: #if CURVE25519",
          "858:         private static byte[] EncryptWithChaCha20Poly1305(",
          "859:             byte[] encryptingKey,",
          "860:             byte[] iv,",
          "861:             byte[] dataToEncrypt)",
          "862:         {",
          "863:             Utils.Trace($\"EncryptKey={Utils.ToHexString(encryptingKey)}\");",
          "864:             Utils.Trace($\"EncryptIV={Utils.ToHexString(iv)}\");",
          "866:             int signatureLength = 16;",
          "868:             AeadParameters parameters = new AeadParameters(",
          "869:                 new KeyParameter(encryptingKey),",
          "870:                 signatureLength * 8,",
          "871:                 iv,",
          "872:                 null);",
          "874:             ChaCha20Poly1305 encryptor = new ChaCha20Poly1305();",
          "875:             encryptor.Init(true, parameters);",
          "877:             byte[] ciphertext = new byte[encryptor.GetOutputSize(dataToEncrypt.Length)];",
          "878:             int length = encryptor.ProcessBytes(dataToEncrypt, 0, dataToEncrypt.Length, ciphertext, 0);",
          "879:             length += encryptor.DoFinal(ciphertext, length);",
          "881:             if (ciphertext.Length != length)",
          "882:             {",
          "883:                 throw ServiceResultException.Create(",
          "884:                     StatusCodes.BadSecurityChecksFailed,",
          "885:                     $\"CipherText not the expected size. [{ciphertext.Length} != {length}]\");",
          "886:             }",
          "888:             return ciphertext;",
          "889:         }",
          "891:         private ArraySegment<byte> DecryptWithChaCha20Poly1305(",
          "892:             byte[] encryptingKey,",
          "893:             byte[] iv,",
          "894:             byte[] dataToDecrypt,",
          "895:             int offset,",
          "896:             int count)",
          "897:         {",
          "898:             Utils.Trace($\"EncryptKey={Utils.ToHexString(encryptingKey)}\");",
          "899:             Utils.Trace($\"EncryptIV={Utils.ToHexString(iv)}\");",
          "901:             int signatureLength = 16;",
          "903:             AeadParameters parameters = new AeadParameters(",
          "904:                 new KeyParameter(encryptingKey),",
          "905:                 signatureLength * 8,",
          "906:                 iv,",
          "907:                 null);",
          "909:             ChaCha20Poly1305 decryptor = new ChaCha20Poly1305();",
          "910:             decryptor.Init(false, parameters);",
          "912:             byte[] plaintext = new byte[decryptor.GetOutputSize(count)];",
          "913:             int length = decryptor.ProcessBytes(dataToDecrypt, offset, count, plaintext, 0);",
          "914:             length += decryptor.DoFinal(plaintext, length);",
          "916:             if (plaintext.Length != length || plaintext.Length < iv.Length)",
          "917:             {",
          "918:                 throw ServiceResultException.Create(",
          "919:                     StatusCodes.BadSecurityChecksFailed,",
          "920:                     $\"PlainText not the expected size or too short. [{count} != {length}]\");",
          "921:             }",
          "923:             ushort paddingSize = plaintext[length-1];",
          "924:             paddingSize <<= 8;",
          "925:             paddingSize += plaintext[length - 2];",
          "927:             int notvalid = (paddingSize < length) ? 0 : 1;",
          "928:             int start = length - paddingSize - 2;",
          "930:             for (int ii = 0; ii < length - 2 && ii < paddingSize; ii++)",
          "931:             {",
          "932:                 if (start < 0 || start + ii >= plaintext.Length)",
          "933:                 {",
          "934:                     notvalid |= 1;",
          "935:                     continue;",
          "936:                 }",
          "938:                 notvalid |= plaintext[start + ii] ^ (paddingSize & 0xFF);",
          "939:             }",
          "941:             if (notvalid != 0)",
          "942:             {",
          "943:                 throw new ServiceResultException(StatusCodes.BadNonceInvalid);",
          "944:             }",
          "946:             return new ArraySegment<byte>(plaintext, 0, start);",
          "947:         }",
          "948: #endif",
          "950:         private ArraySegment<byte> DecryptSecret(",
          "951:             byte[] dataToDecrypt,",
          "952:             int offset,",
          "953:             int count,",
          "954:             byte[] encryptingKey,",
          "955:             byte[] iv)",
          "956:         {",
          "957: #if CURVE25519",
          "958:             bool useAuthenticatedEncryption = false;",
          "959:             if (SenderCertificate.BcCertificate.GetPublicKey() is Ed25519PublicKeyParameters ||",
          "960:                 SenderCertificate.BcCertificate.GetPublicKey() is Ed448PublicKeyParameters)",
          "961:             {",
          "962:                 useAuthenticatedEncryption = true;",
          "963:             }",
          "964:             if (useAuthenticatedEncryption)",
          "965:             {",
          "966:                 return DecryptWithChaCha20Poly1305(encryptingKey, iv, dataToDecrypt, offset, count);",
          "967:             }",
          "968: #endif",
          "969:             using (Aes aes = Aes.Create())",
          "970:             {",
          "971:                 aes.Mode = CipherMode.CBC;",
          "972:                 aes.Padding = PaddingMode.None;",
          "973:                 aes.Key = encryptingKey;",
          "974:                 aes.IV = iv;",
          "976:                 using (ICryptoTransform decryptor = aes.CreateDecryptor())",
          "977:                 {",
          "978:                     if (count % decryptor.InputBlockSize != 0)",
          "979:                     {",
          "980:                         throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, \"Input data is not an even number of encryption blocks.\");",
          "981:                     }",
          "983:                     decryptor.TransformBlock(dataToDecrypt, offset, count, dataToDecrypt, offset);",
          "984:                 }",
          "985:             }",
          "987:             ushort paddingSize = dataToDecrypt[offset + count - 1];",
          "988:             paddingSize <<= 8;",
          "989:             paddingSize += dataToDecrypt[offset + count - 2];",
          "991:             int notvalid = (paddingSize < count) ? 0 : 1;",
          "992:             int start = offset + count - paddingSize - 2;",
          "994:             for (int ii = 0; ii < count - 2 && ii < paddingSize; ii++)",
          "995:             {",
          "996:                 if (start < 0 || start + ii >= dataToDecrypt.Length)",
          "997:                 {",
          "998:                     notvalid |= 1;",
          "999:                     continue;",
          "1000:                 }",
          "1002:                 notvalid |= dataToDecrypt[start + ii] ^ (paddingSize & 0xFF);",
          "1003:             }",
          "1005:             if (notvalid != 0)",
          "1006:             {",
          "1007:                 throw new ServiceResultException(StatusCodes.BadNonceInvalid);",
          "1008:             }",
          "1010:             return new ArraySegment<byte>(dataToDecrypt, offset, count - paddingSize);",
          "1011:         }",
          "1013:         static readonly byte[] s_Label = new UTF8Encoding().GetBytes(\"opcua-secret\");",
          "1015:         private static void CreateKeysForEcc(",
          "1016:             string securityPolicyUri,",
          "1017:             Nonce senderNonce,",
          "1018:             Nonce receiverNonce,",
          "1019:             bool forDecryption,",
          "1020:             out byte[] encryptingKey,",
          "1021:             out byte[] iv)",
          "1022:         {",
          "1023:             int encryptingKeySize = 32;",
          "1024:             int blockSize = 16;",
          "1025:             HashAlgorithmName algorithmName = HashAlgorithmName.SHA256;",
          "1027:             switch (securityPolicyUri)",
          "1028:             {",
          "1029:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "1030:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "1031:                 {",
          "1032:                     encryptingKeySize = 16;",
          "1033:                     break;",
          "1034:                 }",
          "1036:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "1037:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "1038:                 {",
          "1039:                     encryptingKeySize = 32;",
          "1040:                     algorithmName = HashAlgorithmName.SHA384;",
          "1041:                     break;",
          "1042:                 }",
          "1044:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "1045:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "1046:                 {",
          "1047:                     encryptingKeySize = 32;",
          "1048:                     blockSize = 12;",
          "1049:                     algorithmName = HashAlgorithmName.SHA256;",
          "1050:                     break;",
          "1051:                 }",
          "1052:             }",
          "1054:             encryptingKey = new byte[encryptingKeySize];",
          "1055:             iv = new byte[blockSize];",
          "1057:             var keyLength = BitConverter.GetBytes((ushort)(encryptingKeySize + blockSize));",
          "1058:             var salt = Utils.Append(keyLength, s_Label, senderNonce.Data, receiverNonce.Data);",
          "1060:             byte[] keyData = null;",
          "1062:             if (forDecryption)",
          "1063:             {",
          "1064:                 keyData = receiverNonce.DeriveKey(senderNonce, salt, algorithmName, encryptingKeySize + blockSize);",
          "1065:             }",
          "1066:             else",
          "1067:             {",
          "1068:                 keyData = senderNonce.DeriveKey(receiverNonce, salt, algorithmName, encryptingKeySize + blockSize);",
          "1069:             }",
          "1071:             Buffer.BlockCopy(keyData, 0, encryptingKey, 0, encryptingKey.Length);",
          "1072:             Buffer.BlockCopy(keyData, encryptingKeySize, iv, 0, iv.Length);",
          "1073:         }",
          "1075:         public byte[] Encrypt(byte[] secret, byte[] nonce)",
          "1076:         {",
          "1077:             byte[] encryptingKey = null;",
          "1078:             byte[] iv = null;",
          "1079:             byte[] message = null;",
          "1080:             int lengthPosition = 0;",
          "1082:             var signatureLength = EccUtils.GetSignatureLength(SenderCertificate);",
          "1084:             using (BinaryEncoder encoder = new BinaryEncoder(ServiceMessageContext.GlobalContext))",
          "1085:             {",
          "1087:                 encoder.WriteNodeId(null, DataTypeIds.EccEncryptedSecret);",
          "1088:                 encoder.WriteByte(null, (byte)ExtensionObjectEncoding.Binary);",
          "1090:                 lengthPosition = encoder.Position;",
          "1091:                 encoder.WriteUInt32(null, 0);",
          "1093:                 encoder.WriteString(null, SecurityPolicyUri);",
          "1095:                 byte[] senderCertificate = null;",
          "1097:                 if (!DoNotEncodeSenderCertificate)",
          "1098:                 {",
          "1099:                     senderCertificate = SenderCertificate.RawData;",
          "1101:                     if (SenderIssuerCertificates != null && SenderIssuerCertificates.Count > 0)",
          "1102:                     {",
          "1103:                         int blobSize = senderCertificate.Length;",
          "1105:                         foreach (var issuer in SenderIssuerCertificates)",
          "1106:                         {",
          "1107:                             blobSize += issuer.RawData.Length;",
          "1108:                         }",
          "1110:                         var blob = new byte[blobSize];",
          "1111:                         Buffer.BlockCopy(senderCertificate, 0, blob, 0, senderCertificate.Length);",
          "1113:                         int pos = senderCertificate.Length;",
          "1115:                         foreach (var issuer in SenderIssuerCertificates)",
          "1116:                         {",
          "1117:                             var data = issuer.RawData;",
          "1118:                             Buffer.BlockCopy(data, 0, blob, pos, data.Length);",
          "1119:                             pos += data.Length;",
          "1120:                         }",
          "1122:                         senderCertificate = blob;",
          "1123:                     }",
          "1124:                 }",
          "1126:                 encoder.WriteByteString(null, senderCertificate);",
          "1127:                 encoder.WriteDateTime(null, DateTime.UtcNow);",
          "1129:                 var senderNonce = SenderNonce.Data;",
          "1130:                 var receiverNonce = ReceiverNonce.Data;",
          "1132:                 encoder.WriteUInt16(null, (ushort)(senderNonce.Length + receiverNonce.Length + 8));",
          "1133:                 encoder.WriteByteString(null, senderNonce);",
          "1134:                 encoder.WriteByteString(null, receiverNonce);",
          "1137:                 if (EccUtils.IsEccPolicy(SecurityPolicyUri))",
          "1138:                 {",
          "1139:                     CreateKeysForEcc(SecurityPolicyUri, SenderNonce, ReceiverNonce, false, out encryptingKey, out iv);",
          "1140:                 }",
          "1143:                 var encryptedData = EncryptSecret(secret, nonce, encryptingKey, iv);",
          "1146:                 for (int ii = 0; ii < encryptedData.Length; ii++)",
          "1147:                 {",
          "1148:                     encoder.WriteByte(null, encryptedData[ii]);",
          "1149:                 }",
          "1152:                 for (int ii = 0; ii < signatureLength; ii++)",
          "1153:                 {",
          "1154:                     encoder.WriteByte(null, 0);",
          "1155:                 }",
          "1157:                 message = encoder.CloseAndReturnBuffer();",
          "1158:             }",
          "1160:             var length = message.Length - lengthPosition - 4;",
          "1162:             message[lengthPosition++] = (byte)((length & 0xFF));",
          "1163:             message[lengthPosition++] = (byte)((length & 0xFF00) >> 8);",
          "1164:             message[lengthPosition++] = (byte)((length & 0xFF0000) >> 16);",
          "1165:             message[lengthPosition++] = (byte)((length & 0xFF000000) >> 24);",
          "1168:             HashAlgorithmName signatureAlgorithm = HashAlgorithmName.SHA256;",
          "1170:             switch (SecurityPolicyUri)",
          "1171:             {",
          "1172:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "1173:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "1174:                 {",
          "1175:                     signatureAlgorithm = HashAlgorithmName.SHA384;",
          "1176:                     break;",
          "1177:                 }",
          "1178:             }",
          "1180:             ArraySegment<byte> dataToSign = new ArraySegment<byte>(message, 0, message.Length - signatureLength);",
          "1181:             var signature = EccUtils.Sign(dataToSign, SenderCertificate, signatureAlgorithm);",
          "1182:             Buffer.BlockCopy(signature, 0, message, message.Length - signatureLength, signatureLength);",
          "1183:             return message;",
          "1184:         }",
          "1186:         private ArraySegment<byte> VerifyHeaderForEcc(",
          "1187:             ArraySegment<byte> dataToDecrypt,",
          "1188:             DateTime earliestTime)",
          "1189:         {",
          "1190:             using (BinaryDecoder decoder = new BinaryDecoder(dataToDecrypt.Array, dataToDecrypt.Offset, dataToDecrypt.Count, ServiceMessageContext.GlobalContext))",
          "1191:             {",
          "1192:                 var typeId = decoder.ReadNodeId(null);",
          "1194:                 if (typeId != DataTypeIds.EccEncryptedSecret)",
          "1195:                 {",
          "1196:                     throw new ServiceResultException(StatusCodes.BadDataTypeIdUnknown);",
          "1197:                 }",
          "1199:                 var encoding = (ExtensionObjectEncoding)decoder.ReadByte(null);",
          "1201:                 if (encoding != ExtensionObjectEncoding.Binary)",
          "1202:                 {",
          "1203:                     throw new ServiceResultException(StatusCodes.BadDataEncodingUnsupported);",
          "1204:                 }",
          "1206:                 var length = decoder.ReadUInt32(null);",
          "1209:                 int startOfData = decoder.Position + dataToDecrypt.Offset;",
          "1211:                 SecurityPolicyUri = decoder.ReadString(null);",
          "1213:                 if (!EccUtils.IsEccPolicy(SecurityPolicyUri))",
          "1214:                 {",
          "1215:                     throw new ServiceResultException(StatusCodes.BadSecurityPolicyRejected);",
          "1216:                 }",
          "1219:                 HashAlgorithmName signatureAlgorithm = HashAlgorithmName.SHA256;",
          "1221:                 switch (SecurityPolicyUri)",
          "1222:                 {",
          "1223:                     case SecurityPolicies.Aes256_Sha384_nistP384:",
          "1224:                     case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "1225:                     {",
          "1226:                         signatureAlgorithm = HashAlgorithmName.SHA384;",
          "1227:                         break;",
          "1228:                     }",
          "1229:                 }",
          "1232:                 var senderCertificate = decoder.ReadByteString(null);",
          "1234:                 if (senderCertificate == null || senderCertificate.Length == 0)",
          "1235:                 {",
          "1236:                     if (SenderCertificate == null)",
          "1237:                     {",
          "1238:                         throw new ServiceResultException(StatusCodes.BadCertificateInvalid);",
          "1239:                     }",
          "1240:                 }",
          "1241:                 else",
          "1242:                 {",
          "1243:                     var senderCertificateChain = Utils.ParseCertificateChainBlob(senderCertificate);",
          "1245:                     SenderCertificate = senderCertificateChain[0];",
          "1246:                     SenderIssuerCertificates = new X509Certificate2Collection();",
          "1248:                     for (int ii = 1; ii < senderCertificateChain.Count; ii++)",
          "1249:                     {",
          "1250:                         SenderIssuerCertificates.Add(senderCertificateChain[ii]);",
          "1251:                     }",
          "1254:                     if (Validator != null)",
          "1255:                     {",
          "1256:                         Validator.Validate(senderCertificateChain);",
          "1257:                     }",
          "1258:                 }",
          "1261:                 var signingTime = decoder.ReadDateTime(null);",
          "1263:                 if (signingTime < earliestTime)",
          "1264:                 {",
          "1265:                     throw new ServiceResultException(StatusCodes.BadInvalidTimestamp);",
          "1266:                 }",
          "1269:                 var headerLength = decoder.ReadUInt16(null);",
          "1271:                 if (headerLength == 0 || headerLength > length)",
          "1272:                 {",
          "1273:                     throw new ServiceResultException(StatusCodes.BadDecodingError);",
          "1274:                 }",
          "1277:                 var senderPublicKey = decoder.ReadByteString(null);",
          "1278:                 var receiverPublicKey = decoder.ReadByteString(null);",
          "1280:                 if (headerLength != senderPublicKey.Length + receiverPublicKey.Length + 8)",
          "1281:                 {",
          "1282:                     throw new ServiceResultException(StatusCodes.BadDecodingError, \"Unexpected policy header length\");",
          "1283:                 }",
          "1285:                 var startOfEncryption = decoder.Position;",
          "1287:                 SenderNonce = Nonce.CreateNonce(SecurityPolicyUri, senderPublicKey);",
          "1289:                 if (!Utils.IsEqual(receiverPublicKey, ReceiverNonce.Data))",
          "1290:                 {",
          "1291:                     throw new ServiceResultException(StatusCodes.BadDecodingError, \"Unexpected receiver nonce.\");",
          "1292:                 }",
          "1295:                 int signatureLength = EccUtils.GetSignatureLength(SenderCertificate);",
          "1297:                 if (signatureLength >= length)",
          "1298:                 {",
          "1299:                     throw new ServiceResultException(StatusCodes.BadDecodingError);",
          "1300:                 }",
          "1302:                 byte[] signature = new byte[signatureLength];",
          "1303:                 Buffer.BlockCopy(dataToDecrypt.Array, startOfData + (int)length - signatureLength, signature, 0, signatureLength);",
          "1305:                 ArraySegment<byte> dataToSign = new ArraySegment<byte>(dataToDecrypt.Array, 0, startOfData + (int)length - signatureLength);",
          "1307:                 if (!EccUtils.Verify(dataToSign, signature, SenderCertificate, signatureAlgorithm))",
          "1308:                 {",
          "1309:                     throw new ServiceResultException(StatusCodes.BadSecurityChecksFailed, \"Could not verify signature.\");",
          "1310:                 }",
          "1313:                 return new ArraySegment<byte>(dataToDecrypt.Array, startOfEncryption, (int)length - (startOfEncryption - startOfData + signatureLength));",
          "1314:             }",
          "1315:         }",
          "1317:         public byte[] Decrypt(DateTime earliestTime, byte[] expectedNonce, byte[] data, int offset, int count)",
          "1318:         {",
          "1319:             byte[] encryptingKey = null;",
          "1320:             byte[] iv = null;",
          "1321:             byte[] secret = null;",
          "1323:             var dataToDecrypt = VerifyHeaderForEcc(new ArraySegment<byte>(data, offset, count), earliestTime);",
          "1325:             CreateKeysForEcc(SecurityPolicyUri, SenderNonce, ReceiverNonce, true, out encryptingKey, out iv);",
          "1327:             var plainText = DecryptSecret(dataToDecrypt.Array, dataToDecrypt.Offset, dataToDecrypt.Count, encryptingKey, iv);",
          "1329:             using (BinaryDecoder decoder = new BinaryDecoder(plainText.Array, plainText.Offset, plainText.Count, ServiceMessageContext.GlobalContext))",
          "1330:             {",
          "1331:                 var actualNonce = decoder.ReadByteString(null);",
          "1333:                 if (expectedNonce != null && expectedNonce.Length > 0)",
          "1334:                 {",
          "1335:                     int notvalid = (expectedNonce.Length == actualNonce.Length) ? 0 : 1;",
          "1337:                     for (int ii = 0; ii < expectedNonce.Length && ii < actualNonce.Length; ii++)",
          "1338:                     {",
          "1339:                         notvalid |= expectedNonce[ii] ^ actualNonce[ii];",
          "1340:                     }",
          "1342:                     if (notvalid != 0)",
          "1343:                     {",
          "1344:                         throw new ServiceResultException(StatusCodes.BadNonceInvalid);",
          "1345:                     }",
          "1346:                 }",
          "1348:                 secret = decoder.ReadByteString(null);",
          "1349:             }",
          "1351:             return secret;",
          "1352:         }",
          "1353:     }",
          "1354: }",
          "1357: #endif",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Security/Certificates/X509Utils.cs||Stack/Opc.Ua.Core/Security/Certificates/X509Utils.cs": [
          "File: Stack/Opc.Ua.Core/Security/Certificates/X509Utils.cs -> Stack/Opc.Ua.Core/Security/Certificates/X509Utils.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "436:             return fields;",
          "437:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "443:         public static bool IsECDsaSignature(X509Certificate2 cert)",
          "444:         {",
          "445:             return X509PfxUtils.IsECDsaSignature(cert);",
          "446:         }",
          "451:         public static bool VerifyKeyPair(",
          "452:             X509Certificate2 certWithPublicKey,",
          "453:             X509Certificate2 certWithPrivateKey,",
          "454:             bool throwOnError = false)",
          "455:         {",
          "456:             return X509PfxUtils.VerifyKeyPair(certWithPublicKey, certWithPrivateKey, throwOnError);",
          "457:         }",
          "462:         public static bool VerifyECDsaKeyPair(",
          "463:             X509Certificate2 certWithPublicKey,",
          "464:             X509Certificate2 certWithPrivateKey,",
          "465:             bool throwOnError = false)",
          "466:         {",
          "467: #if ECC_SUPPORT",
          "468:             return X509PfxUtils.VerifyECDsaKeyPair(certWithPublicKey, certWithPrivateKey, throwOnError);",
          "469: #else",
          "470:             throw new NotSupportedException();",
          "471: #endif",
          "472:         }",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Security/Constants/SecurityConstants.cs||Stack/Opc.Ua.Core/Security/Constants/SecurityConstants.cs": [
          "File: Stack/Opc.Ua.Core/Security/Constants/SecurityConstants.cs -> Stack/Opc.Ua.Core/Security/Constants/SecurityConstants.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: namespace Opc.Ua",
          "",
          "[Removed Lines]",
          "14: {",
          "",
          "[Added Lines]",
          "14: {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "93:         public const string PSha256 = \"http://opcfoundation.org/ua/security/p_sha2-256\";",
          "94:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "98:         public const string Ecdsa_Sha256_nistP256 =  SecurityPolicies.Aes128_Sha256_nistP256;",
          "103:         public const string Ecdsa_Sha384_nistP384 = SecurityPolicies.Aes256_Sha384_nistP384;",
          "108:         public const string Ecdsa_Sha256_brainpoolP256r1 = SecurityPolicies.Aes128_Sha256_brainpoolP256r1;",
          "113:         public const string Ecdsa_Sha384_brainpoolP384r1 = SecurityPolicies.Aes256_Sha384_brainpoolP384r1;",
          "114:     }",
          "120:     public static class EllipticCurves",
          "121:     {",
          "125:         public const string nistP256 = \"nistP256\";",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Security/Constants/SecurityPolicies.cs||Stack/Opc.Ua.Core/Security/Constants/SecurityPolicies.cs": [
          "File: Stack/Opc.Ua.Core/Security/Constants/SecurityPolicies.cs -> Stack/Opc.Ua.Core/Security/Constants/SecurityPolicies.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "65:         public const string Https = BaseUri + \"Https\";",
          "66:         #endregion",
          "68:         #region Static Methods",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70:         public const string Aes128_Sha256_nistP256 = BaseUri + \"Aes128_Sha256_nistP256\";",
          "75:         public const string Aes256_Sha384_nistP384 = BaseUri + \"Aes256_Sha384_nistP384\";",
          "80:         public const string Aes128_Sha256_brainpoolP256r1 = BaseUri + \"Aes128_Sha256_brainpoolP256r1\";",
          "85:         public const string Aes256_Sha384_brainpoolP384r1 = BaseUri + \"Aes256_Sha384_brainpoolP384r1\";",
          "90:         public const string ChaCha20Poly1305_curve25519 = BaseUri + \"ChaCha20Poly1305_curve25519\";",
          "95:         public const string ChaCha20Poly1305_curve448 = BaseUri + \"ChaCha20Poly1305_curve448\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "201:                     break;",
          "202:                 }",
          "204:                 case SecurityPolicies.None:",
          "205:                 {",
          "206:                     break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "235:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "236:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "237:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "238:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "239:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "240:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "241:                 {",
          "242:                     return encryptedData;",
          "243:                 }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "267:                     break;",
          "268:                 }",
          "270:                 case SecurityPolicies.None:",
          "271:                 {",
          "272:                     if (String.IsNullOrEmpty(dataToDecrypt.Algorithm))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "311:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "312:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "313:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "314:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "315:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "316:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "336:                     break;",
          "337:                 }",
          "339:                 case SecurityPolicies.None:",
          "340:                 {",
          "341:                     signatureData.Algorithm = null;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "386:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "387:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "388:                 {",
          "389:                     signatureData.Algorithm = null;",
          "390:                     signatureData.Signature = EccUtils.Sign(new ArraySegment<byte>(dataToSign), certificate, HashAlgorithmName.SHA256);",
          "391:                     break;",
          "392:                 }",
          "394:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "395:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "396:                 {",
          "397:                     signatureData.Algorithm = null;",
          "398:                     signatureData.Signature = EccUtils.Sign(new ArraySegment<byte>(dataToSign), certificate, HashAlgorithmName.SHA384);",
          "399:                     break;",
          "400:                 }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "343:                     break;",
          "344:                 }",
          "346:                 default:",
          "347:                 {",
          "348:                     throw ServiceResultException.Create(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "409:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "410:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "419:                         SecurityAlgorithms.RsaPssSha256);",
          "420:                 }",
          "423:                 case SecurityPolicies.None:",
          "424:                 {",
          "425:                     return true;",
          "426:                 }",
          "428:                 default:",
          "429:                 {",
          "430:                     throw ServiceResultException.Create(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "487:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "488:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "489:                 {",
          "490:                     return EccUtils.Verify(new ArraySegment<byte>(dataToVerify), signature.Signature, certificate, HashAlgorithmName.SHA256);",
          "491:                 }",
          "493:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "494:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "495:                 {",
          "496:                     return EccUtils.Verify(new ArraySegment<byte>(dataToVerify), signature.Signature, certificate, HashAlgorithmName.SHA384);",
          "497:                 }",
          "505:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "506:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Stack/Tcp/TcpServerChannel.cs||Stack/Opc.Ua.Core/Stack/Tcp/TcpServerChannel.cs": [
          "File: Stack/Opc.Ua.Core/Stack/Tcp/TcpServerChannel.cs -> Stack/Opc.Ua.Core/Stack/Tcp/TcpServerChannel.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "558:                 ChannelToken token = CreateToken();",
          "560:                 token.TokenId = GetNewTokenId();",
          "564:                 chunksToProcess = GetSavedChunks(requestId, messageBody);",
          "",
          "[Removed Lines]",
          "561:                 token.ServerNonce = CreateNonce();",
          "",
          "[Added Lines]",
          "561:                 token.ServerNonce = CreateNonce(ServerCertificate);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "583:                 token.ClientNonce = request.ClientNonce;",
          "586:                 {",
          "587:                     throw ServiceResultException.Create(StatusCodes.BadNonceInvalid, \"Client nonce is not the correct length or not random enough.\");",
          "588:                 }",
          "",
          "[Removed Lines]",
          "585:                 if (!ValidateNonce(token.ClientNonce))",
          "",
          "[Added Lines]",
          "585:                 if (!ValidateNonce(ClientCertificate, token.ClientNonce))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "957:         #endregion",
          "959:         #region Private Fields",
          "961:         private ReverseConnectAsyncResult m_pendingReverseHello;",
          "962:         #endregion",
          "963:     }",
          "",
          "[Removed Lines]",
          "960:         private string m_ImplementationString = \".NetStandard ServerChannel UA-TCP \" + Utils.GetAssemblyBuildNumber();",
          "",
          "[Added Lines]",
          "960:         private readonly string m_ImplementationString = \".NET Standard ServerChannel UA-TCP \" + Utils.GetAssemblyBuildNumber();",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.Asymmetric.cs||Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.Asymmetric.cs": [
          "File: Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.Asymmetric.cs -> Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.Asymmetric.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:             set { m_clientCertificateChain = value; }",
          "98:         }",
          "",
          "[Removed Lines]",
          "103:         protected byte[] CreateNonce()",
          "104:         {",
          "105:             uint length = GetNonceLength();",
          "106:             if (length > 0)",
          "107:             {",
          "108:                 return Utils.Nonce.CreateNonce(length);",
          "109:             }",
          "110:             return null;",
          "111:         }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "196:         protected uint GetNonceLength()",
          "197:         {",
          "199:         }",
          "205:         {",
          "207:         }",
          "",
          "[Removed Lines]",
          "198:             return Utils.Nonce.GetNonceLength(SecurityPolicyUri);",
          "204:         protected bool ValidateNonce(byte[] nonce)",
          "206:             return Utils.Nonce.ValidateNonce(nonce, SecurityMode, SecurityPolicyUri);",
          "",
          "[Added Lines]",
          "185:             switch (SecurityPolicyUri)",
          "186:             {",
          "187:                 case SecurityPolicies.Basic128Rsa15:",
          "188:                 {",
          "189:                     return 16;",
          "190:                 }",
          "192:                 case SecurityPolicies.Basic256:",
          "193:                 case SecurityPolicies.Basic256Sha256:",
          "194:                 {",
          "195:                     return 32;",
          "196:                 }",
          "198:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "199:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "200:                 {",
          "201:                     return 64;",
          "202:                 }",
          "204:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "205:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "206:                 {",
          "207:                     return 96;",
          "208:                 }",
          "210:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "211:                 {",
          "212:                     return 32;",
          "213:                 }",
          "215:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "216:                 {",
          "217:                     return 56;",
          "218:                 }",
          "220:                 default:",
          "221:                 case SecurityPolicies.None:",
          "222:                 {",
          "223:                     return 0;",
          "224:                 }",
          "225:             }",
          "231:         protected byte[] CreateNonce(X509Certificate2 certificate)",
          "233:             switch (SecurityPolicyUri)",
          "234:             {",
          "235:                 case SecurityPolicies.Basic128Rsa15:",
          "236:                 case SecurityPolicies.Basic256:",
          "237:                 case SecurityPolicies.Basic256Sha256:",
          "238:                 {",
          "239:                     uint length = GetNonceLength();",
          "241:                     if (length > 0)",
          "242:                     {",
          "243:                         return Utils.Nonce.CreateNonce(length);",
          "244:                     }",
          "246:                     break;",
          "247:                 }",
          "249:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "250:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "251:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "252:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "253:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "254:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "255:                 {",
          "256:                     m_localNonce = Nonce.CreateNonce(SecurityPolicyUri, GetNonceLength());",
          "257:                     return m_localNonce.Data;",
          "258:                 }",
          "260:                 default:",
          "261:                 case SecurityPolicies.None:",
          "262:                 {",
          "263:                     return null;",
          "264:                 }",
          "265:             }",
          "267:             return null;",
          "273:         protected bool ValidateNonce(X509Certificate2 certificate, byte[] nonce)",
          "274:         {",
          "276:             if (SecurityMode == MessageSecurityMode.None)",
          "277:             {",
          "278:                 return true;",
          "279:             }",
          "282:             if (nonce == null || nonce.Length < GetNonceLength())",
          "283:             {",
          "284:                 return false;",
          "285:             }",
          "287:             switch (SecurityPolicyUri)",
          "288:             {",
          "289:                 case SecurityPolicies.Basic128Rsa15:",
          "290:                 case SecurityPolicies.Basic256:",
          "291:                 case SecurityPolicies.Basic256Sha256:",
          "292:                 {",
          "294:                     for (int ii = 0; ii < nonce.Length; ii++)",
          "295:                     {",
          "296:                         if (nonce[ii] != 0)",
          "297:                         {",
          "298:                             return true;",
          "299:                         }",
          "300:                     }",
          "302:                     break;",
          "303:                 }",
          "305:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "306:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "307:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "308:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "309:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "310:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "311:                 {",
          "312:                     m_remoteNonce = Nonce.CreateNonce(SecurityPolicyUri, nonce);",
          "313:                     return true;",
          "314:                 }",
          "315:             }",
          "317:             return false;",
          "318:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "216:                 case SecurityPolicies.Basic256:",
          "217:                 case SecurityPolicies.Basic256Sha256:",
          "218:                 case SecurityPolicies.Aes128_Sha256_RsaOaep:",
          "223:                 case SecurityPolicies.Aes256_Sha256_RsaPss:",
          "228:                 case SecurityPolicies.Basic128Rsa15:",
          "233:                 default:",
          "234:                 case SecurityPolicies.None:",
          "238:             }",
          "239:         }",
          "",
          "[Removed Lines]",
          "219:                     {",
          "220:                         return RsaUtils.GetPlainTextBlockSize(receiverCertificate, RsaUtils.Padding.OaepSHA1);",
          "221:                     }",
          "224:                     {",
          "225:                         return RsaUtils.GetPlainTextBlockSize(receiverCertificate, RsaUtils.Padding.OaepSHA256);",
          "226:                     }",
          "229:                     {",
          "230:                         return RsaUtils.GetPlainTextBlockSize(receiverCertificate, RsaUtils.Padding.Pkcs1);",
          "231:                     }",
          "235:                     {",
          "236:                         return 1;",
          "237:                     }",
          "",
          "[Added Lines]",
          "331:                 {",
          "332:                     return RsaUtils.GetPlainTextBlockSize(receiverCertificate, RsaUtils.Padding.OaepSHA1);",
          "333:                 }",
          "336:                 {",
          "337:                     return RsaUtils.GetPlainTextBlockSize(receiverCertificate, RsaUtils.Padding.OaepSHA256);",
          "338:                 }",
          "341:                 {",
          "342:                     return RsaUtils.GetPlainTextBlockSize(receiverCertificate, RsaUtils.Padding.Pkcs1);",
          "343:                 }",
          "345:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "346:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "347:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "348:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "349:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "350:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "351:                 {",
          "352:                     return 1;",
          "353:                 }",
          "357:                 {",
          "358:                     return 1;",
          "359:                 }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "248:                 case SecurityPolicies.Basic256:",
          "249:                 case SecurityPolicies.Basic256Sha256:",
          "250:                 case SecurityPolicies.Aes128_Sha256_RsaOaep:",
          "255:                 case SecurityPolicies.Aes256_Sha256_RsaPss:",
          "260:                 case SecurityPolicies.Basic128Rsa15:",
          "265:                 default:",
          "266:                 case SecurityPolicies.None:",
          "270:             }",
          "271:         }",
          "",
          "[Removed Lines]",
          "251:                     {",
          "252:                         return RsaUtils.GetCipherTextBlockSize(receiverCertificate, RsaUtils.Padding.OaepSHA1);",
          "253:                     }",
          "256:                     {",
          "257:                         return RsaUtils.GetCipherTextBlockSize(receiverCertificate, RsaUtils.Padding.OaepSHA256);",
          "258:                     }",
          "261:                     {",
          "262:                         return RsaUtils.GetCipherTextBlockSize(receiverCertificate, RsaUtils.Padding.Pkcs1);",
          "263:                     }",
          "267:                     {",
          "268:                         return 1;",
          "269:                     }",
          "",
          "[Added Lines]",
          "373:                 {",
          "374:                     return RsaUtils.GetCipherTextBlockSize(receiverCertificate, RsaUtils.Padding.OaepSHA1);",
          "375:                 }",
          "378:                 {",
          "379:                     return RsaUtils.GetCipherTextBlockSize(receiverCertificate, RsaUtils.Padding.OaepSHA256);",
          "380:                 }",
          "383:                 {",
          "384:                     return RsaUtils.GetCipherTextBlockSize(receiverCertificate, RsaUtils.Padding.Pkcs1);",
          "385:                 }",
          "387:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "388:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "389:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "390:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "391:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "392:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "393:                 {",
          "394:                     return 1;",
          "395:                 }",
          "399:                 {",
          "400:                     return 1;",
          "401:                 }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "359:                 case SecurityPolicies.Basic256Sha256:",
          "360:                 case SecurityPolicies.Aes128_Sha256_RsaOaep:",
          "361:                 case SecurityPolicies.Aes256_Sha256_RsaPss:",
          "366:                 default:",
          "367:                 case SecurityPolicies.None:",
          "371:             }",
          "372:         }",
          "",
          "[Removed Lines]",
          "362:                     {",
          "363:                         return RsaUtils.GetSignatureLength(senderCertificate);",
          "364:                     }",
          "368:                     {",
          "369:                         return 0;",
          "370:                     }",
          "",
          "[Added Lines]",
          "494:                 {",
          "495:                     return RsaUtils.GetSignatureLength(senderCertificate);",
          "496:                 }",
          "498:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "499:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "500:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "501:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "502:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "503:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "504:                 {",
          "505:                     return EccUtils.GetSignatureLength(senderCertificate);",
          "506:                 }",
          "510:                 {",
          "511:                     return 0;",
          "512:                 }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "596:                     if (SecurityMode != MessageSecurityMode.None)",
          "597:                     {",
          "599:                         {",
          "604:                             {",
          "624:                             }",
          "631:                             {",
          "633:                             }",
          "635:                         }",
          "",
          "[Removed Lines]",
          "598:                         if (X509Utils.GetRSAPublicKeySize(receiverCertificate) <= TcpMessageLimits.KeySizeExtraPadding)",
          "601:                             plainTextSize++;",
          "603:                             if (plainTextSize % plainTextBlockSize != 0)",
          "605:                                 padding = plainTextBlockSize - (plainTextSize % plainTextBlockSize);",
          "606:                             }",
          "608:                             encoder.WriteByte(null, (byte)padding);",
          "609:                             for (int ii = 0; ii < padding; ii++)",
          "610:                             {",
          "611:                                 encoder.WriteByte(null, (byte)padding);",
          "612:                             }",
          "613:                         }",
          "614:                         else",
          "615:                         {",
          "617:                             plainTextSize++;",
          "619:                             plainTextSize++;",
          "621:                             if (plainTextSize % plainTextBlockSize != 0)",
          "622:                             {",
          "623:                                 padding = plainTextBlockSize - (plainTextSize % plainTextBlockSize);",
          "626:                             byte paddingSize = (byte)(padding & 0xff);",
          "627:                             byte extraPaddingByte = (byte)((padding >> 8) & 0xff);",
          "629:                             encoder.WriteByte(null, paddingSize);",
          "630:                             for (int ii = 0; ii < padding; ii++)",
          "632:                                 encoder.WriteByte(null, (byte)paddingSize);",
          "634:                             encoder.WriteByte(null, extraPaddingByte);",
          "",
          "[Added Lines]",
          "740:                         if (receiverCertificate.GetRSAPublicKey() != null)",
          "742:                             if (X509Utils.GetRSAPublicKeySize(receiverCertificate) <= TcpMessageLimits.KeySizeExtraPadding)",
          "745:                                 plainTextSize++;",
          "747:                                 if (plainTextSize % plainTextBlockSize != 0)",
          "748:                                 {",
          "749:                                     padding = plainTextBlockSize - (plainTextSize % plainTextBlockSize);",
          "750:                                 }",
          "752:                                 encoder.WriteByte(null, (byte)padding);",
          "753:                                 for (int ii = 0; ii < padding; ii++)",
          "754:                                 {",
          "755:                                     encoder.WriteByte(null, (byte)padding);",
          "756:                                 }",
          "758:                             else",
          "761:                                 plainTextSize++;",
          "763:                                 plainTextSize++;",
          "765:                                 if (plainTextSize % plainTextBlockSize != 0)",
          "766:                                 {",
          "767:                                     padding = plainTextBlockSize - (plainTextSize % plainTextBlockSize);",
          "768:                                 }",
          "770:                                 byte paddingSize = (byte)(padding & 0xff);",
          "771:                                 byte extraPaddingByte = (byte)((padding >> 8) & 0xff);",
          "773:                                 encoder.WriteByte(null, paddingSize);",
          "774:                                 for (int ii = 0; ii < padding; ii++)",
          "775:                                 {",
          "776:                                     encoder.WriteByte(null, (byte)paddingSize);",
          "777:                                 }",
          "778:                                 encoder.WriteByte(null, extraPaddingByte);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "977:             int paddingCount = 0;",
          "980:             {",
          "981:                 int paddingEnd = -1;",
          "982:                 if (X509Utils.GetRSAPublicKeySize(receiverCertificate) > TcpMessageLimits.KeySizeExtraPadding)",
          "",
          "[Removed Lines]",
          "979:             if (SecurityMode != MessageSecurityMode.None)",
          "",
          "[Added Lines]",
          "1124:             if (SecurityMode != MessageSecurityMode.None && receiverCertificate.GetRSAPublicKey() != null)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1048:             {",
          "1049:                 default:",
          "1050:                 case SecurityPolicies.None:",
          "1055:                 case SecurityPolicies.Basic256:",
          "1056:                 case SecurityPolicies.Basic128Rsa15:",
          "1061:                 case SecurityPolicies.Aes128_Sha256_RsaOaep:",
          "1062:                 case SecurityPolicies.Basic256Sha256:",
          "1067:                 case SecurityPolicies.Aes256_Sha256_RsaPss:",
          "1071:             }",
          "1072:         }",
          "",
          "[Removed Lines]",
          "1051:                     {",
          "1052:                         return null;",
          "1053:                     }",
          "1057:                     {",
          "1058:                         return Rsa_Sign(dataToSign, senderCertificate, HashAlgorithmName.SHA1, RSASignaturePadding.Pkcs1);",
          "1059:                     }",
          "1063:                     {",
          "1064:                         return Rsa_Sign(dataToSign, senderCertificate, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);",
          "1065:                     }",
          "1068:                     {",
          "1069:                         return Rsa_Sign(dataToSign, senderCertificate, HashAlgorithmName.SHA256, RSASignaturePadding.Pss);",
          "1070:                     }",
          "",
          "[Added Lines]",
          "1196:                 {",
          "1197:                     return null;",
          "1198:                 }",
          "1202:                 {",
          "1203:                     return Rsa_Sign(dataToSign, senderCertificate, HashAlgorithmName.SHA1, RSASignaturePadding.Pkcs1);",
          "1204:                 }",
          "1208:                 {",
          "1209:                     return Rsa_Sign(dataToSign, senderCertificate, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);",
          "1210:                 }",
          "1213:                 {",
          "1214:                     return Rsa_Sign(dataToSign, senderCertificate, HashAlgorithmName.SHA256, RSASignaturePadding.Pss);",
          "1215:                 }",
          "1217:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "1218:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "1219:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "1220:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "1221:                 {",
          "1222:                     return EccUtils.Sign(dataToSign, senderCertificate, HashAlgorithmName.SHA256);",
          "1223:                 }",
          "1225:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "1226:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "1227:                 {",
          "1228:                     return EccUtils.Sign(dataToSign, senderCertificate, HashAlgorithmName.SHA384);",
          "1229:                 }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1088:             switch (SecurityPolicyUri)",
          "1089:             {",
          "1090:                 case SecurityPolicies.None:",
          "1095:                 case SecurityPolicies.Basic128Rsa15:",
          "1096:                 case SecurityPolicies.Basic256:",
          "1101:                 case SecurityPolicies.Aes128_Sha256_RsaOaep:",
          "1102:                 case SecurityPolicies.Basic256Sha256:",
          "1107:                 case SecurityPolicies.Aes256_Sha256_RsaPss:",
          "1112:                 default:",
          "1116:             }",
          "1117:         }",
          "",
          "[Removed Lines]",
          "1091:                     {",
          "1092:                         return true;",
          "1093:                     }",
          "1097:                     {",
          "1098:                         return Rsa_Verify(dataToVerify, signature, senderCertificate, HashAlgorithmName.SHA1, RSASignaturePadding.Pkcs1);",
          "1099:                     }",
          "1103:                     {",
          "1104:                         return Rsa_Verify(dataToVerify, signature, senderCertificate, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);",
          "1105:                     }",
          "1108:                     {",
          "1109:                         return Rsa_Verify(dataToVerify, signature, senderCertificate, HashAlgorithmName.SHA256, RSASignaturePadding.Pss);",
          "1110:                     }",
          "1113:                     {",
          "1114:                         return false;",
          "1115:                     }",
          "",
          "[Added Lines]",
          "1251:                 {",
          "1252:                     return true;",
          "1253:                 }",
          "1257:                 {",
          "1258:                     return Rsa_Verify(dataToVerify, signature, senderCertificate, HashAlgorithmName.SHA1, RSASignaturePadding.Pkcs1);",
          "1259:                 }",
          "1263:                 {",
          "1264:                     return Rsa_Verify(dataToVerify, signature, senderCertificate, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);",
          "1265:                 }",
          "1268:                 {",
          "1269:                     return Rsa_Verify(dataToVerify, signature, senderCertificate, HashAlgorithmName.SHA256, RSASignaturePadding.Pss);",
          "1270:                 }",
          "1272:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "1273:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "1274:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "1275:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "1276:                 {",
          "1277:                     return EccUtils.Verify(dataToVerify, signature, senderCertificate, HashAlgorithmName.SHA256);",
          "1278:                 }",
          "1280:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "1281:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "1282:                 {",
          "1283:                     return EccUtils.Verify(dataToVerify, signature, senderCertificate, HashAlgorithmName.SHA384);",
          "1284:                 }",
          "1287:                 {",
          "1288:                     return false;",
          "1289:                 }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1132:             switch (SecurityPolicyUri)",
          "1133:             {",
          "1134:                 default:",
          "1135:                 case SecurityPolicies.None:",
          "1145:                 case SecurityPolicies.Basic256:",
          "1146:                 case SecurityPolicies.Aes128_Sha256_RsaOaep:",
          "1147:                 case SecurityPolicies.Basic256Sha256:",
          "1152:                 case SecurityPolicies.Aes256_Sha256_RsaPss:",
          "1157:                 case SecurityPolicies.Basic128Rsa15:",
          "1161:             }",
          "1162:         }",
          "",
          "[Removed Lines]",
          "1136:                     {",
          "1137:                         byte[] encryptedBuffer = BufferManager.TakeBuffer(SendBufferSize, \"Encrypt\");",
          "1139:                         Array.Copy(headerToCopy.Array, headerToCopy.Offset, encryptedBuffer, 0, headerToCopy.Count);",
          "1140:                         Array.Copy(dataToEncrypt.Array, dataToEncrypt.Offset, encryptedBuffer, headerToCopy.Count, dataToEncrypt.Count);",
          "1142:                         return new ArraySegment<byte>(encryptedBuffer, 0, dataToEncrypt.Count + headerToCopy.Count);",
          "1143:                     }",
          "1148:                     {",
          "1149:                         return Rsa_Encrypt(dataToEncrypt, headerToCopy, receiverCertificate, RsaUtils.Padding.OaepSHA1);",
          "1150:                     }",
          "1153:                     {",
          "1154:                         return Rsa_Encrypt(dataToEncrypt, headerToCopy, receiverCertificate, RsaUtils.Padding.OaepSHA256);",
          "1155:                     }",
          "1158:                     {",
          "1159:                         return Rsa_Encrypt(dataToEncrypt, headerToCopy, receiverCertificate, RsaUtils.Padding.Pkcs1);",
          "1160:                     }",
          "",
          "[Added Lines]",
          "1309:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "1310:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "1311:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "1312:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "1313:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "1314:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "1316:                 {",
          "1317:                     byte[] encryptedBuffer = BufferManager.TakeBuffer(SendBufferSize, \"Encrypt\");",
          "1319:                     Array.Copy(headerToCopy.Array, headerToCopy.Offset, encryptedBuffer, 0, headerToCopy.Count);",
          "1320:                     Array.Copy(dataToEncrypt.Array, dataToEncrypt.Offset, encryptedBuffer, headerToCopy.Count, dataToEncrypt.Count);",
          "1322:                     return new ArraySegment<byte>(encryptedBuffer, 0, dataToEncrypt.Count + headerToCopy.Count);",
          "1323:                 }",
          "1328:                 {",
          "1329:                     return Rsa_Encrypt(dataToEncrypt, headerToCopy, receiverCertificate, RsaUtils.Padding.OaepSHA1);",
          "1330:                 }",
          "1333:                 {",
          "1334:                     return Rsa_Encrypt(dataToEncrypt, headerToCopy, receiverCertificate, RsaUtils.Padding.OaepSHA256);",
          "1335:                 }",
          "1338:                 {",
          "1339:                     return Rsa_Encrypt(dataToEncrypt, headerToCopy, receiverCertificate, RsaUtils.Padding.Pkcs1);",
          "1340:                 }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1176:             switch (SecurityPolicyUri)",
          "1177:             {",
          "1178:                 default:",
          "1179:                 case SecurityPolicies.None:",
          "1189:                 case SecurityPolicies.Basic256:",
          "1190:                 case SecurityPolicies.Aes128_Sha256_RsaOaep:",
          "1191:                 case SecurityPolicies.Basic256Sha256:",
          "1196:                 case SecurityPolicies.Aes256_Sha256_RsaPss:",
          "1201:                 case SecurityPolicies.Basic128Rsa15:",
          "1205:             }",
          "1206:         }",
          "1207:         #endregion",
          "",
          "[Removed Lines]",
          "1180:                     {",
          "1181:                         byte[] decryptedBuffer = BufferManager.TakeBuffer(SendBufferSize, \"Decrypt\");",
          "1183:                         Array.Copy(headerToCopy.Array, headerToCopy.Offset, decryptedBuffer, 0, headerToCopy.Count);",
          "1184:                         Array.Copy(dataToDecrypt.Array, dataToDecrypt.Offset, decryptedBuffer, headerToCopy.Count, dataToDecrypt.Count);",
          "1186:                         return new ArraySegment<byte>(decryptedBuffer, 0, dataToDecrypt.Count + headerToCopy.Count);",
          "1187:                     }",
          "1192:                     {",
          "1193:                         return Rsa_Decrypt(dataToDecrypt, headerToCopy, receiverCertificate, RsaUtils.Padding.OaepSHA1);",
          "1194:                     }",
          "1197:                     {",
          "1198:                         return Rsa_Decrypt(dataToDecrypt, headerToCopy, receiverCertificate, RsaUtils.Padding.OaepSHA256);",
          "1199:                     }",
          "1202:                     {",
          "1203:                         return Rsa_Decrypt(dataToDecrypt, headerToCopy, receiverCertificate, RsaUtils.Padding.Pkcs1);",
          "1204:                     }",
          "",
          "[Added Lines]",
          "1359:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "1360:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "1361:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "1362:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "1363:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "1364:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "1366:                 {",
          "1367:                     byte[] decryptedBuffer = BufferManager.TakeBuffer(SendBufferSize, \"Decrypt\");",
          "1369:                     Array.Copy(headerToCopy.Array, headerToCopy.Offset, decryptedBuffer, 0, headerToCopy.Count);",
          "1370:                     Array.Copy(dataToDecrypt.Array, dataToDecrypt.Offset, decryptedBuffer, headerToCopy.Count, dataToDecrypt.Count);",
          "1372:                     return new ArraySegment<byte>(decryptedBuffer, 0, dataToDecrypt.Count + headerToCopy.Count);",
          "1373:                 }",
          "1378:                 {",
          "1379:                     return Rsa_Decrypt(dataToDecrypt, headerToCopy, receiverCertificate, RsaUtils.Padding.OaepSHA1);",
          "1380:                 }",
          "1383:                 {",
          "1384:                     return Rsa_Decrypt(dataToDecrypt, headerToCopy, receiverCertificate, RsaUtils.Padding.OaepSHA256);",
          "1385:                 }",
          "1388:                 {",
          "1389:                     return Rsa_Decrypt(dataToDecrypt, headerToCopy, receiverCertificate, RsaUtils.Padding.Pkcs1);",
          "1390:                 }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1217:         private X509Certificate2 m_clientCertificate;",
          "1218:         private X509Certificate2Collection m_clientCertificateChain;",
          "1219:         private bool m_uninitialized;",
          "1220:         #endregion",
          "1221:     }",
          "1222: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1406:         private Nonce m_localNonce;",
          "1407:         private Nonce m_remoteNonce;",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.Symmetric.cs||Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.Symmetric.cs": [
          "File: Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.Symmetric.cs -> Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.Symmetric.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "89:         #endregion",
          "91:         #region Symmetric Cryptography Functions",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "95:         private bool UseAuthenticatedEncryption",
          "96:         {",
          "97:             get; set;",
          "98:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "105:         protected void CalculateSymmetricKeySizes()",
          "106:         {",
          "107:             switch (SecurityPolicyUri)",
          "108:             {",
          "109:                 case SecurityPolicies.Basic128Rsa15:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "115:             UseAuthenticatedEncryption = false;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "151:                     break;",
          "152:                 }",
          "154:                 default:",
          "155:                 case SecurityPolicies.None:",
          "156:                 {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "164:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "165:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "166:                 {",
          "167:                     m_hmacHashSize = 32;",
          "168:                     m_signatureKeySize = 32;",
          "169:                     m_encryptionKeySize = 16;",
          "170:                     m_encryptionBlockSize = 16;",
          "171:                     break;",
          "172:                 }",
          "174:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "175:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "176:                 {",
          "177:                     UseAuthenticatedEncryption = true;",
          "178:                     m_hmacHashSize = 16;",
          "179:                     m_signatureKeySize = 32;",
          "180:                     m_encryptionKeySize = 32;",
          "181:                     m_encryptionBlockSize = 12;",
          "182:                     break;",
          "183:                 }",
          "185:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "186:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "187:                 {",
          "188:                     m_hmacHashSize = 48;",
          "189:                     m_signatureKeySize = 48;",
          "190:                     m_encryptionKeySize = 32;",
          "191:                     m_encryptionBlockSize = 16;",
          "192:                     break;",
          "193:                 }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "163:             }",
          "164:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "207:         private void DeriveKeysWithPSHA(HashAlgorithmName algorithmName, byte[] secret, byte[] seed, ChannelToken token, bool isServer)",
          "208:         {",
          "209:             int length = m_signatureKeySize + m_encryptionKeySize + m_encryptionBlockSize;",
          "211:             using (var hmac = Utils.CreateHMAC(algorithmName, secret))",
          "212:             {",
          "213:                 var output = Utils.PSHA(hmac, null, seed, 0, length);",
          "215:                 var signingKey = new byte[m_signatureKeySize];",
          "216:                 var encryptingKey = new byte[m_encryptionKeySize];",
          "217:                 var iv = new byte[m_encryptionBlockSize];",
          "219:                 Buffer.BlockCopy(output, 0, signingKey, 0, signingKey.Length);",
          "220:                 Buffer.BlockCopy(output, m_signatureKeySize, encryptingKey, 0, encryptingKey.Length);",
          "221:                 Buffer.BlockCopy(output, m_signatureKeySize + m_encryptionKeySize, iv, 0, iv.Length);",
          "223:                 if (isServer)",
          "224:                 {",
          "225:                     token.ServerSigningKey = signingKey;",
          "226:                     token.ServerEncryptingKey = encryptingKey;",
          "227:                     token.ServerInitializationVector = iv;",
          "228:                 }",
          "229:                 else",
          "230:                 {",
          "231:                     token.ClientSigningKey = signingKey;",
          "232:                     token.ClientEncryptingKey = encryptingKey;",
          "233:                     token.ClientInitializationVector = iv;",
          "234:                 }",
          "235:             }",
          "236:         }",
          "238:         private void DeriveKeysWithHKDF(HashAlgorithmName algorithmName, byte[] salt, ChannelToken token, bool isServer)",
          "239:         {",
          "240:             int length = m_signatureKeySize + m_encryptionKeySize + m_encryptionBlockSize;",
          "242:             var output = m_localNonce.DeriveKey(m_remoteNonce, salt, algorithmName, length);",
          "244:             var signingKey = new byte[m_signatureKeySize];",
          "245:             var encryptingKey = new byte[m_encryptionKeySize];",
          "246:             var iv = new byte[m_encryptionBlockSize];",
          "248:             Buffer.BlockCopy(output, 0, signingKey, 0, signingKey.Length);",
          "249:             Buffer.BlockCopy(output, m_signatureKeySize, encryptingKey, 0, encryptingKey.Length);",
          "250:             Buffer.BlockCopy(output, m_signatureKeySize + m_encryptionKeySize, iv, 0, iv.Length);",
          "252:             if (isServer)",
          "253:             {",
          "254:                 token.ServerSigningKey = signingKey;",
          "255:                 token.ServerEncryptingKey = encryptingKey;",
          "256:                 token.ServerInitializationVector = iv;",
          "257:             }",
          "258:             else",
          "259:             {",
          "260:                 token.ClientSigningKey = signingKey;",
          "261:                 token.ClientEncryptingKey = encryptingKey;",
          "262:                 token.ClientInitializationVector = iv;",
          "263:             }",
          "264:         }",
          "266:         static readonly byte[] s_HkdfClientLabel = new UTF8Encoding().GetBytes(\"opcua-client\");",
          "267:         static readonly byte[] s_HkdfServerLabel = new UTF8Encoding().GetBytes(\"opcua-server\");",
          "268:         static readonly byte[] s_HkdfAes128SignOnlyKeyLength = BitConverter.GetBytes((ushort)32);",
          "269:         static readonly byte[] s_HkdfAes256SignOnlyKeyLength = BitConverter.GetBytes((ushort)48);",
          "270:         static readonly byte[] s_HkdfAes128SignAndEncryptKeyLength = BitConverter.GetBytes((ushort)64);",
          "271:         static readonly byte[] s_HkdfAes256SignAndEncryptKeyLength = BitConverter.GetBytes((ushort)96);",
          "272:         static readonly byte[] s_HkdfChaCha20Poly1305KeyLength = BitConverter.GetBytes((ushort)76);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "176:                 return;",
          "177:             }",
          "179:             if (SecurityPolicyUri == SecurityPolicies.Basic256Sha256 ||",
          "180:                 SecurityPolicyUri == SecurityPolicies.Aes128_Sha256_RsaOaep ||",
          "181:                 SecurityPolicyUri == SecurityPolicies.Aes256_Sha256_RsaPss)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "287:             byte[] serverSecret = token.ServerNonce;",
          "288:             byte[] clientSecret = token.ClientNonce;",
          "289:             HashAlgorithmName algorithmName = HashAlgorithmName.SHA256;",
          "291: #if TODO // remove",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "196:                 token.ServerEncryptingKey = Utils.PSHA1(token.ClientNonce, null, token.ServerNonce, m_signatureKeySize, m_encryptionKeySize);",
          "197:                 token.ServerInitializationVector = Utils.PSHA1(token.ClientNonce, null, token.ServerNonce, m_signatureKeySize + m_encryptionKeySize, m_encryptionBlockSize);",
          "198:             }",
          "200:             switch (SecurityPolicyUri)",
          "201:             {",
          "202:                 case SecurityPolicies.Basic128Rsa15:",
          "203:                 case SecurityPolicies.Basic256:",
          "204:                 case SecurityPolicies.Basic256Sha256:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "312: #endif",
          "315: #if TODO //remove",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "236:                     }",
          "237:                     break;",
          "238:                 }",
          "240:                 default:",
          "241:                 case SecurityPolicies.None:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "353: #endif",
          "355:                 default:",
          "356:                 {",
          "357:                     DeriveKeysWithPSHA(algorithmName, serverSecret, clientSecret, token, false);",
          "358:                     DeriveKeysWithPSHA(algorithmName, clientSecret, serverSecret, token, true);",
          "359:                     break;",
          "360:                 }",
          "362:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "363:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "364:                 {",
          "365:                     algorithmName = HashAlgorithmName.SHA256;",
          "366:                     var length = (SecurityMode == MessageSecurityMode.Sign) ? s_HkdfAes128SignOnlyKeyLength : s_HkdfAes128SignAndEncryptKeyLength;",
          "367:                     var serverSalt = Utils.Append(length, s_HkdfServerLabel, serverSecret, clientSecret);",
          "368:                     var clientSalt = Utils.Append(length, s_HkdfClientLabel, clientSecret, serverSecret);",
          "370:                     Utils.Trace($\"Length={Utils.ToHexString(length)}\");",
          "371:                     Utils.Trace($\"ClientSecret={Utils.ToHexString(clientSecret)}\");",
          "372:                     Utils.Trace($\"ServerSecret={Utils.ToHexString(clientSecret)}\");",
          "373:                     Utils.Trace($\"ServerSalt={Utils.ToHexString(serverSalt)}\");",
          "374:                     Utils.Trace($\"ClientSalt={Utils.ToHexString(clientSalt)}\");",
          "376:                     DeriveKeysWithHKDF(algorithmName, serverSalt, token, true);",
          "377:                     DeriveKeysWithHKDF(algorithmName, clientSalt, token, false);",
          "378:                     break;",
          "379:                 }",
          "381:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "382:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "383:                 {",
          "384:                     algorithmName = HashAlgorithmName.SHA384;",
          "385:                     var length = (SecurityMode == MessageSecurityMode.Sign) ? s_HkdfAes256SignOnlyKeyLength : s_HkdfAes256SignAndEncryptKeyLength;",
          "386:                     var serverSalt = Utils.Append(length, s_HkdfServerLabel, serverSecret, clientSecret);",
          "387:                     var clientSalt = Utils.Append(length, s_HkdfClientLabel, clientSecret, serverSecret);",
          "389:                     Utils.Trace($\"Length={Utils.ToHexString(length)}\");",
          "390:                     Utils.Trace($\"ClientSecret={Utils.ToHexString(clientSecret)}\");",
          "391:                     Utils.Trace($\"ServerSecret={Utils.ToHexString(clientSecret)}\");",
          "392:                     Utils.Trace($\"ServerSalt={Utils.ToHexString(serverSalt)}\");",
          "393:                     Utils.Trace($\"ClientSalt={Utils.ToHexString(clientSalt)}\");",
          "395:                     DeriveKeysWithHKDF(algorithmName, serverSalt, token, true);",
          "396:                     DeriveKeysWithHKDF(algorithmName, clientSalt, token, false);",
          "397:                     break;",
          "398:                 }",
          "400:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "401:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "402:                 {",
          "403:                     algorithmName = HashAlgorithmName.SHA256;",
          "404:                     var length = s_HkdfChaCha20Poly1305KeyLength;",
          "405:                     var serverSalt = Utils.Append(length, s_HkdfServerLabel, serverSecret, clientSecret);",
          "406:                     var clientSalt = Utils.Append(length, s_HkdfClientLabel, clientSecret, serverSecret);",
          "408:                     Utils.Trace($\"Length={Utils.ToHexString(length)}\");",
          "409:                     Utils.Trace($\"ClientSecret={Utils.ToHexString(clientSecret)}\");",
          "410:                     Utils.Trace($\"ServerSecret={Utils.ToHexString(clientSecret)}\");",
          "411:                     Utils.Trace($\"ServerSalt={Utils.ToHexString(serverSalt)}\");",
          "412:                     Utils.Trace($\"ClientSalt={Utils.ToHexString(clientSalt)}\");",
          "414:                     DeriveKeysWithHKDF(algorithmName, serverSalt, token, true);",
          "415:                     DeriveKeysWithHKDF(algorithmName, clientSalt, token, false);",
          "416:                     break;",
          "417:                 }",
          "419:                 case SecurityPolicies.Basic128Rsa15:",
          "420:                 case SecurityPolicies.Basic256:",
          "421:                 {",
          "422:                     algorithmName = HashAlgorithmName.SHA1;",
          "423:                     DeriveKeysWithPSHA(algorithmName, serverSecret, clientSecret, token, false);",
          "424:                     DeriveKeysWithPSHA(algorithmName, clientSecret, serverSecret, token, true);",
          "425:                     break;",
          "426:                 }",
          "427:             }",
          "429:             switch (SecurityPolicyUri)",
          "430:             {",
          "431:                 case SecurityPolicies.Basic128Rsa15:",
          "432:                 case SecurityPolicies.Basic256:",
          "433:                 case SecurityPolicies.Basic256Sha256:",
          "434:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "435:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "436:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "437:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "438:                 {",
          "440:                     SymmetricAlgorithm AesCbcEncryptorProvider = Aes.Create();",
          "441:                     AesCbcEncryptorProvider.Mode = CipherMode.CBC;",
          "442:                     AesCbcEncryptorProvider.Padding = PaddingMode.None;",
          "443:                     AesCbcEncryptorProvider.Key = token.ClientEncryptingKey;",
          "444:                     AesCbcEncryptorProvider.IV = token.ClientInitializationVector;",
          "445:                     token.ClientEncryptor = AesCbcEncryptorProvider;",
          "447:                     SymmetricAlgorithm AesCbcDecryptorProvider = Aes.Create();",
          "448:                     AesCbcDecryptorProvider.Mode = CipherMode.CBC;",
          "449:                     AesCbcDecryptorProvider.Padding = PaddingMode.None;",
          "450:                     AesCbcDecryptorProvider.Key = token.ServerEncryptingKey;",
          "451:                     AesCbcDecryptorProvider.IV = token.ServerInitializationVector;",
          "452:                     token.ServerEncryptor = AesCbcDecryptorProvider;",
          "453:                     break;",
          "454:                 }",
          "456:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "457:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "458:                 {",
          "459:                     break;",
          "460:                 }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "243:                     break;",
          "244:                 }",
          "245:             }",
          "246:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "469:             switch (SecurityPolicyUri)",
          "470:             {",
          "471:                 case SecurityPolicies.Basic128Rsa15:",
          "472:                 case SecurityPolicies.Basic256:",
          "473:                 {",
          "474:                     token.ServerHmac = new HMACSHA1(token.ServerSigningKey);",
          "475:                     token.ClientHmac = new HMACSHA1(token.ClientSigningKey);",
          "476:                     break;",
          "477:                 }",
          "479:                 case SecurityPolicies.Basic256Sha256:",
          "480:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "481:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "482:                 {",
          "483:                     token.ServerHmac = new HMACSHA256(token.ServerSigningKey);",
          "484:                     token.ClientHmac = new HMACSHA256(token.ClientSigningKey);",
          "485:                     break;",
          "486:                 }",
          "488:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "489:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "490:                 {",
          "491:                     token.ServerHmac = new HMACSHA384(token.ServerSigningKey);",
          "492:                     token.ClientHmac = new HMACSHA384(token.ClientSigningKey);",
          "493:                     break;",
          "494:                 }",
          "496:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "497:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "498:                 {",
          "499:                     break;",
          "500:                 }",
          "502:                 default:",
          "503:                 case SecurityPolicies.None:",
          "504:                 {",
          "505:                     break;",
          "506:                 }",
          "507:             }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "269:                 int maxPayloadSize = maxPlainTextSize - SymmetricSignatureSize - 1 - TcpMessageLimits.SequenceHeaderSize;",
          "270:                 int headerSize = TcpMessageLimits.SymmetricHeaderSize + TcpMessageLimits.SequenceHeaderSize;",
          "273:                 ArraySegmentStream ostrm = new ArraySegmentStream(",
          "274:                     BufferManager,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "537:                 if (UseAuthenticatedEncryption)",
          "538:                 {",
          "539:                     maxPayloadSize++;",
          "540:                 }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "369:                     int padding = 0;",
          "372:                     {",
          "374:                         count++;",
          "",
          "[Removed Lines]",
          "371:                     if (SecurityMode == MessageSecurityMode.SignAndEncrypt)",
          "",
          "[Added Lines]",
          "641:                     if (SecurityMode == MessageSecurityMode.SignAndEncrypt && !UseAuthenticatedEncryption)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "399:                     messageSize += chunkToProcess.Count;",
          "403:                     {",
          "404:                         for (int jj = 0; jj <= padding; jj++)",
          "405:                         {",
          "",
          "[Removed Lines]",
          "402:                     if (SecurityMode == MessageSecurityMode.SignAndEncrypt)",
          "",
          "[Added Lines]",
          "672:                     if (SecurityMode == MessageSecurityMode.SignAndEncrypt && !UseAuthenticatedEncryption)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "407:                         }",
          "408:                     }",
          "410:                     if (SecurityMode != MessageSecurityMode.None)",
          "411:                     {",
          "416:                         {",
          "418:                         }",
          "419:                     }",
          "422:                     {",
          "424:                         ArraySegment<byte> dataToEncrypt = new ArraySegment<byte>(chunkToProcess.Array, TcpMessageLimits.SymmetricHeaderSize, encoder.Position - TcpMessageLimits.SymmetricHeaderSize);",
          "",
          "[Removed Lines]",
          "413:                         byte[] signature = Sign(token, new ArraySegment<byte>(chunkToProcess.Array, 0, encoder.Position), isRequest);",
          "415:                         if (signature != null)",
          "417:                             encoder.WriteRawBytes(signature, 0, signature.Length);",
          "421:                     if (SecurityMode == MessageSecurityMode.SignAndEncrypt)",
          "",
          "[Added Lines]",
          "683:                         if (UseAuthenticatedEncryption)",
          "685:                             strm.Seek(SymmetricSignatureSize, SeekOrigin.Current);",
          "686:                         }",
          "687:                         else",
          "688:                         {",
          "689:                             byte[] signature = Sign(token, new ArraySegment<byte>(chunkToProcess.Array, 0, encoder.Position), isRequest);",
          "691:                             if (signature != null)",
          "692:                             {",
          "693:                                 encoder.WriteRawBytes(signature, 0, signature.Length);",
          "694:                             }",
          "698:                     if ((SecurityMode == MessageSecurityMode.SignAndEncrypt && !UseAuthenticatedEncryption) ||",
          "699:                         (SecurityMode != MessageSecurityMode.None && UseAuthenticatedEncryption))",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "524:             int headerSize = decoder.Position;",
          "527:             {",
          "529:                 Decrypt(token, new ArraySegment<byte>(buffer.Array, buffer.Offset + headerSize, buffer.Count - headerSize), isRequest);",
          "530:             }",
          "533:             {",
          "535:                 byte[] signature = new byte[SymmetricSignatureSize];",
          "",
          "[Removed Lines]",
          "526:             if (SecurityMode == MessageSecurityMode.SignAndEncrypt)",
          "532:             if (SecurityMode != MessageSecurityMode.None)",
          "",
          "[Added Lines]",
          "804:             if ((SecurityMode == MessageSecurityMode.SignAndEncrypt && !UseAuthenticatedEncryption) ||",
          "805:                 (SecurityMode != MessageSecurityMode.None && UseAuthenticatedEncryption))",
          "811:             if (SecurityMode != MessageSecurityMode.None && !UseAuthenticatedEncryption)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "550:             int paddingCount = 0;",
          "553:             {",
          "555:                 int paddingStart = buffer.Offset + buffer.Count - SymmetricSignatureSize - 1;",
          "",
          "[Removed Lines]",
          "552:             if (SecurityMode == MessageSecurityMode.SignAndEncrypt)",
          "",
          "[Added Lines]",
          "831:             if (SecurityMode == MessageSecurityMode.SignAndEncrypt && !UseAuthenticatedEncryption)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "596:                 case SecurityPolicies.Basic256Sha256:",
          "597:                 case SecurityPolicies.Aes128_Sha256_RsaOaep:",
          "598:                 case SecurityPolicies.Aes256_Sha256_RsaPss:",
          "599:                 {",
          "600:                     return SymmetricSign(token, dataToSign, useClientKeys);",
          "601:                 }",
          "602:             }",
          "603:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "878:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "879:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "880:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "881:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "886: #if GCMMODE",
          "887:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "889:                 {",
          "890:                     return SymmetricSignWithAESGCM(token, dataToSign, useClientKeys);",
          "891:                 }",
          "892: #endif",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "622:                 case SecurityPolicies.Basic128Rsa15:",
          "623:                 case SecurityPolicies.Basic256:",
          "624:                 case SecurityPolicies.Basic256Sha256:",
          "625:                 case SecurityPolicies.Aes128_Sha256_RsaOaep:",
          "626:                 case SecurityPolicies.Aes256_Sha256_RsaPss:",
          "627:                 {",
          "628:                     return SymmetricVerify(token, signature, dataToVerify, useClientKeys);",
          "629:                 }",
          "631:                 default:",
          "632:                 {",
          "633:                     return false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "916:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "917:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "918:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "921:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "925: #if GCMMODE",
          "926:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "928:                 {",
          "929:                     return SymmetricVerifyWithAESGCM(token, signature, dataToVerify, useClientKeys);",
          "930:                 }",
          "931: #endif",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "651:                 case SecurityPolicies.Basic256:",
          "652:                 case SecurityPolicies.Basic256Sha256:",
          "653:                 case SecurityPolicies.Basic128Rsa15:",
          "654:                 case SecurityPolicies.Aes128_Sha256_RsaOaep:",
          "655:                 case SecurityPolicies.Aes256_Sha256_RsaPss:",
          "656:                 {",
          "657:                     SymmetricEncrypt(token, dataToEncrypt, useClientKeys);",
          "658:                     break;",
          "659:                 }",
          "660:             }",
          "661:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "955:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "956:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "957:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "964: #if CURVE25519",
          "965:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "966:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "967:                 {",
          "968:                     if (SecurityMode == MessageSecurityMode.SignAndEncrypt)",
          "969:                     {",
          "970:                         SymmetricEncryptWithChaCha20Poly1305(token, m_localSequenceNumber, dataToEncrypt, useClientKeys);",
          "971:                         break;",
          "972:                     }",
          "974:                     SymmetricSignWithPoly1305(token, m_localSequenceNumber, dataToEncrypt, useClientKeys);",
          "975:                     break;",
          "976:                 }",
          "977: #endif",
          "978:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "980:                 {",
          "981:                     break;",
          "982:                 }",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "676:                 case SecurityPolicies.Basic256:",
          "677:                 case SecurityPolicies.Basic256Sha256:",
          "678:                 case SecurityPolicies.Basic128Rsa15:",
          "679:                 case SecurityPolicies.Aes128_Sha256_RsaOaep:",
          "680:                 case SecurityPolicies.Aes256_Sha256_RsaPss:",
          "681:                 {",
          "682:                     SymmetricDecrypt(token, dataToDecrypt, useClientKeys);",
          "683:                     break;",
          "684:                 }",
          "685:             }",
          "686:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1002:                 case SecurityPolicies.Aes256_Sha384_nistP384:",
          "1003:                 case SecurityPolicies.Aes128_Sha256_brainpoolP256r1:",
          "1004:                 case SecurityPolicies.Aes256_Sha384_brainpoolP384r1:",
          "1011: #if CURVE25519",
          "1012:                 case SecurityPolicies.ChaCha20Poly1305_curve25519:",
          "1013:                 case SecurityPolicies.ChaCha20Poly1305_curve448:",
          "1014:                 {",
          "1015:                     if (SecurityMode == MessageSecurityMode.SignAndEncrypt)",
          "1016:                     {",
          "1017:                         SymmetricDecryptWithChaCha20Poly1305(token, m_remoteSequenceNumber, dataToDecrypt, useClientKeys);",
          "1018:                         break;",
          "1019:                     }",
          "1021:                     SymmetricVerifyWithPoly1305(token, m_remoteSequenceNumber, dataToDecrypt, useClientKeys);",
          "1022:                     break;",
          "1023:                 }",
          "1024: #endif",
          "1025:                 case SecurityPolicies.Aes128_Sha256_nistP256:",
          "1027:                 {",
          "1028:                     break;",
          "1029:                 }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "703:             return signature;",
          "704:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1050: #if GCMMODE",
          "1054:         private static byte[] SymmetricSignWithAESGCM(ChannelToken token, ArraySegment<byte> dataToSign, bool useClientKeys)",
          "1055:         {",
          "1056:             try",
          "1057:             {",
          "1058:                 var key = (useClientKeys) ? token.ClientEncryptingKey : token.ServerSigningKey;",
          "1059:                 var nonce = (useClientKeys) ? token.ClientInitializationVector : token.ServerInitializationVector;",
          "1060:                 var macSize = (useClientKeys) ? token.ClientSigningKey.Length : token.ServerSigningKey.Length;",
          "1062:                 var header = new byte[TcpMessageLimits.SymmetricHeaderSize];",
          "1063:                 Buffer.BlockCopy(dataToSign.Array, 0, header, 0, header.Length);",
          "1065:                 var cipher = new GcmBlockCipher(new AesEngine());",
          "1066:                 var parameters = new AeadParameters(new KeyParameter(key), macSize, nonce, header);",
          "1067:                 cipher.Init(true, parameters);",
          "1069:                 var plainTextLength = dataToSign.Count - TcpMessageLimits.SymmetricHeaderSize;",
          "1070:                 var cipherLength = cipher.GetOutputSize(plainTextLength);",
          "1071:                 var cipherText = new byte[cipherLength];",
          "1073:                 var length = cipher.ProcessBytes(",
          "1074:                     dataToSign.Array,",
          "1075:                     TcpMessageLimits.SymmetricHeaderSize,",
          "1076:                     plainTextLength,",
          "1077:                     cipherText,",
          "1078:                     0);",
          "1080:                 cipher.DoFinal(cipherText, length);",
          "1082:                 Buffer.BlockCopy(cipherText, 0, dataToSign.Array, TcpMessageLimits.SymmetricHeaderSize, cipherText.Length);",
          "1085:                 var signature = new byte[cipherLength + header.Length - dataToSign.Count];",
          "1086:                 Buffer.BlockCopy(dataToSign.Array, dataToSign.Count, signature, 0, signature.Length);",
          "1088:                 int eod = dataToSign.Count + signature.Length;",
          "1089:                 int siz = BitConverter.ToInt32(dataToSign.Array, 4);",
          "1096:                 return signature;",
          "1097:             }",
          "1098:             catch (Exception)",
          "1099:             {",
          "1100:                 throw;",
          "1101:             }",
          "1102:         }",
          "1103: #endif",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "745:             return true;",
          "746:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1145: #if GCMMODE",
          "1149:         private static bool SymmetricVerifyWithAESGCM(",
          "1150:             ChannelToken token,",
          "1151:             byte[] signature,",
          "1152:             ArraySegment<byte> dataToVerify,",
          "1153:             bool useClientKeys)",
          "1154:         {",
          "1155:             try",
          "1156:             {",
          "1157:                 var key = (useClientKeys) ? token.ClientEncryptingKey : token.ServerSigningKey;",
          "1158:                 var nonce = (useClientKeys) ? token.ClientInitializationVector : token.ServerInitializationVector;",
          "1159:                 var macSize = (useClientKeys) ? token.ClientSigningKey.Length : token.ServerSigningKey.Length;",
          "1161:                 using (var cipherStream = new MemoryStream(dataToVerify.Array, dataToVerify.Offset, dataToVerify.Count + signature.Length))",
          "1162:                 {",
          "1163:                     using (var cipherReader = new BinaryReader(cipherStream))",
          "1164:                     {",
          "1165:                         var header = cipherReader.ReadBytes(TcpMessageLimits.SymmetricHeaderSize);",
          "1167:                         var cipher = new GcmBlockCipher(new AesEngine());",
          "1168:                         var parameters = new AeadParameters(new KeyParameter(key), macSize, nonce, header);",
          "1169:                         cipher.Init(false, parameters);",
          "1171:                         var cipherText = cipherReader.ReadBytes(dataToVerify.Count - header.Length + signature.Length);",
          "1172:                         var plainTextLength = cipher.GetOutputSize(cipherText.Length);",
          "1173:                         var plainText = new byte[plainTextLength];",
          "1175:                         try",
          "1176:                         {",
          "1177:                             var length = cipher.ProcessBytes(cipherText, 0, cipherText.Length, plainText, 0);",
          "1178:                             cipher.DoFinal(plainText, length);",
          "1179:                         }",
          "1180:                         catch (InvalidCipherTextException e)",
          "1181:                         {",
          "1183:                             return false;",
          "1184:                         }",
          "1186:                         Buffer.BlockCopy(plainText, 0, dataToVerify.Array, dataToVerify.Offset + header.Length, plainText.Length);",
          "1187:                         return true;",
          "1188:                     }",
          "1189:                 }",
          "1190:             }",
          "1191:             catch (Exception e)",
          "1192:             {",
          "1193:                 throw;",
          "1194:             }",
          "1195:         }",
          "1196: #endif",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "807:                 decryptor.TransformBlock(blockToDecrypt, start, count, blockToDecrypt, start);",
          "808:             }",
          "809:         }",
          "810:         #endregion",
          "812:         #region Private Fields",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1260:         private static void ApplyChaCha20Poly1305Mask(ChannelToken token, uint lastSequenceNumber, byte[] iv)",
          "1261:         {",
          "1262:             iv[0] ^= (byte)((token.TokenId & 0x000000FF));",
          "1263:             iv[1] ^= (byte)((token.TokenId & 0x0000FF00) >> 8);",
          "1264:             iv[2] ^= (byte)((token.TokenId & 0x00FF0000) >> 16);",
          "1265:             iv[3] ^= (byte)((token.TokenId & 0xFF000000) >> 24);",
          "1266:             iv[4] ^= (byte)((lastSequenceNumber & 0x000000FF));",
          "1267:             iv[5] ^= (byte)((lastSequenceNumber & 0x0000FF00) >> 8);",
          "1268:             iv[6] ^= (byte)((lastSequenceNumber & 0x00FF0000) >> 16);",
          "1269:             iv[7] ^= (byte)((lastSequenceNumber & 0xFF000000) >> 24);",
          "1270:         }",
          "1272: #if CURVE25519",
          "1276:         private static void SymmetricEncryptWithChaCha20Poly1305(",
          "1277:             ChannelToken token,",
          "1278:             uint lastSequenceNumber,",
          "1279:             ArraySegment<byte> dataToEncrypt,",
          "1280:             bool useClientKeys)",
          "1281:         {",
          "1282:             var signingKey = (useClientKeys) ? token.ClientSigningKey : token.ServerSigningKey;",
          "1284:             if (signingKey == null)",
          "1285:             {",
          "1286:                 throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, \"Token missing symmetric key object.\");",
          "1287:             }",
          "1289:             var encryptingKey = (useClientKeys) ? token.ClientEncryptingKey : token.ServerEncryptingKey;",
          "1291:             if (encryptingKey == null)",
          "1292:             {",
          "1293:                 throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, \"Token missing symmetric key object.\");",
          "1294:             }",
          "1296:             var iv = (useClientKeys) ? token.ClientInitializationVector : token.ServerInitializationVector;",
          "1298:             if (iv == null)",
          "1299:             {",
          "1300:                 throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, \"Token missing symmetric key object.\");",
          "1301:             }",
          "1305:             ApplyChaCha20Poly1305Mask(token, lastSequenceNumber, iv);",
          "1308:             int signatureLength = 16;",
          "1310:             var plaintext = dataToEncrypt.Array;",
          "1311:             int headerSize = dataToEncrypt.Offset;",
          "1312:             int plainTextLength = dataToEncrypt.Offset + dataToEncrypt.Count - signatureLength;",
          "1316:             AeadParameters parameters = new AeadParameters(",
          "1317:                 new KeyParameter(encryptingKey),",
          "1318:                 signatureLength * 8,",
          "1319:                 iv,",
          "1320:                 null);",
          "1322:             ChaCha20Poly1305 encryptor = new ChaCha20Poly1305();",
          "1323:             encryptor.Init(true, parameters);",
          "1324:             encryptor.ProcessAadBytes(plaintext, 0, headerSize);",
          "1326:             byte[] ciphertext = new byte[encryptor.GetOutputSize(plainTextLength - headerSize) + headerSize];",
          "1327:             Buffer.BlockCopy(plaintext, 0, ciphertext, 0, headerSize);",
          "1328:             int length = encryptor.ProcessBytes(plaintext, headerSize, plainTextLength - headerSize, ciphertext, headerSize);",
          "1329:             length += encryptor.DoFinal(ciphertext, length + headerSize);",
          "1331:             if (ciphertext.Length - headerSize != length)",
          "1332:             {",
          "1333:                 throw ServiceResultException.Create(",
          "1334:                     StatusCodes.BadSecurityChecksFailed,",
          "1335:                     $\"Cipher text not the expected size. [{ciphertext.Length - headerSize} != {length}]\");",
          "1336:             }",
          "1338:             Buffer.BlockCopy(ciphertext, 0, plaintext, 0, plainTextLength + signatureLength);",
          "1344:         }",
          "1349:         private static void SymmetricSignWithPoly1305(",
          "1350:             ChannelToken token,",
          "1351:             uint lastSequenceNumber,",
          "1352:             ArraySegment<byte> dataToEncrypt,",
          "1353:             bool useClientKeys)",
          "1354:         {",
          "1355:             var signingKey = (useClientKeys) ? token.ClientSigningKey : token.ServerSigningKey;",
          "1357:             if (signingKey == null)",
          "1358:             {",
          "1359:                 throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, \"Token missing symmetric key object.\");",
          "1360:             }",
          "1362:             ApplyChaCha20Poly1305Mask(token, lastSequenceNumber, signingKey);",
          "1364:             using (var hash = SHA256.Create())",
          "1365:             {",
          "1366:                 signingKey = hash.ComputeHash(signingKey);",
          "1367:             }",
          "1371:             int signatureLength = 16;",
          "1373:             var plaintext = dataToEncrypt.Array;",
          "1374:             int headerSize = dataToEncrypt.Offset;",
          "1375:             int plainTextLength = dataToEncrypt.Offset + dataToEncrypt.Count - signatureLength;",
          "1379:             Poly1305 poly = new Poly1305();",
          "1381:             poly.Init(new KeyParameter(signingKey, 0, signingKey.Length));",
          "1382:             poly.BlockUpdate(plaintext, 0, plainTextLength);",
          "1383:             int length = poly.DoFinal(plaintext, plainTextLength);",
          "1385:             if (signatureLength != length)",
          "1386:             {",
          "1387:                 throw ServiceResultException.Create(",
          "1388:                     StatusCodes.BadSecurityChecksFailed,",
          "1389:                     $\"Signed data not the expected size. [{plainTextLength + signatureLength} != {length}]\");",
          "1390:             }",
          "1391:         }",
          "1396:         private static void SymmetricDecryptWithChaCha20Poly1305(",
          "1397:             ChannelToken token,",
          "1398:             uint lastSequenceNumber,",
          "1399:             ArraySegment<byte> dataToDecrypt,",
          "1400:             bool useClientKeys)",
          "1401:         {",
          "1402:             var encryptingKey = (useClientKeys) ? token.ClientEncryptingKey : token.ServerEncryptingKey;",
          "1404:             if (encryptingKey == null)",
          "1405:             {",
          "1406:                 throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, \"Token missing symmetric key object.\");",
          "1407:             }",
          "1409:             var iv = (useClientKeys) ? token.ClientInitializationVector : token.ServerInitializationVector;",
          "1411:             if (iv == null)",
          "1412:             {",
          "1413:                 throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, \"Token missing symmetric key object.\");",
          "1414:             }",
          "1418:             ApplyChaCha20Poly1305Mask(token, lastSequenceNumber, iv);",
          "1421:             int signatureLength = 16;",
          "1423:             var ciphertext = dataToDecrypt.Array;",
          "1424:             int headerSize = dataToDecrypt.Offset;",
          "1425:             int cipherTextLength = dataToDecrypt.Offset + dataToDecrypt.Count - signatureLength;",
          "1429:             byte[] mac = new byte[16];",
          "1430:             Buffer.BlockCopy(ciphertext, cipherTextLength, mac, 0, signatureLength);",
          "1433:             AeadParameters parameters = new AeadParameters(",
          "1434:                 new KeyParameter(encryptingKey),",
          "1435:                 signatureLength * 8,",
          "1436:                 iv,",
          "1437:                 null);",
          "1439:             ChaCha20Poly1305 decryptor = new ChaCha20Poly1305();",
          "1440:             decryptor.Init(false, parameters);",
          "1441:             decryptor.ProcessAadBytes(ciphertext, 0, headerSize);",
          "1443:             var plaintext = new byte[decryptor.GetOutputSize(cipherTextLength + signatureLength - headerSize) + headerSize];",
          "1444:             Buffer.BlockCopy(ciphertext, headerSize, plaintext, 0, headerSize);",
          "1446:             int length = decryptor.ProcessBytes(ciphertext, headerSize, cipherTextLength + signatureLength - headerSize, plaintext, headerSize);",
          "1447:             length += decryptor.DoFinal(plaintext, length + headerSize);",
          "1449:             if (plaintext.Length - headerSize != length)",
          "1450:             {",
          "1451:                 throw ServiceResultException.Create(",
          "1452:                     StatusCodes.BadSecurityChecksFailed,",
          "1453:                     $\"Plain text not the expected size. [{plaintext.Length - headerSize} != {length}]\");",
          "1454:             }",
          "1456:             Buffer.BlockCopy(plaintext, 0, ciphertext, 0, cipherTextLength);",
          "1457:         }",
          "1462:         private static void SymmetricVerifyWithPoly1305(",
          "1463:             ChannelToken token,",
          "1464:             uint lastSequenceNumber,",
          "1465:             ArraySegment<byte> dataToDecrypt,",
          "1466:             bool useClientKeys)",
          "1467:         {",
          "1468:             var signingKey = (useClientKeys) ? token.ClientSigningKey : token.ServerSigningKey;",
          "1470:             if (signingKey == null)",
          "1471:             {",
          "1472:                 throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, \"Token missing symmetric key object.\");",
          "1473:             }",
          "1475:             ApplyChaCha20Poly1305Mask(token, lastSequenceNumber, signingKey);",
          "1478:             using (var hash = SHA256.Create())",
          "1479:             {",
          "1480:                 signingKey = hash.ComputeHash(signingKey);",
          "1481:             }",
          "1483:             int signatureLength = 16;",
          "1485:             var plaintext = dataToDecrypt.Array;",
          "1486:             int headerSize = dataToDecrypt.Offset;",
          "1487:             int plainTextLength = dataToDecrypt.Offset + dataToDecrypt.Count - signatureLength;",
          "1491:             Poly1305 poly = new Poly1305();",
          "1493:             poly.Init(new KeyParameter(signingKey, 0, signingKey.Length));",
          "1494:             poly.BlockUpdate(plaintext, 0, plainTextLength);",
          "1496:             byte[] mac = new byte[poly.GetMacSize()];",
          "1497:             int length = poly.DoFinal(mac, 0);",
          "1499:             if (signatureLength != length)",
          "1500:             {",
          "1501:                 throw ServiceResultException.Create(",
          "1502:                     StatusCodes.BadSecurityChecksFailed,",
          "1503:                     $\"Signed data not the expected size. [{plainTextLength + signatureLength} != {length}]\");",
          "1504:             }",
          "1506:             for (int ii = 0; ii < mac.Length; ii++)",
          "1507:             {",
          "1508:                 if (mac[ii] != plaintext[plainTextLength + ii])",
          "1509:                 {",
          "1510:                     throw ServiceResultException.Create(",
          "1511:                         StatusCodes.BadSecurityChecksFailed,",
          "1512:                         $\"Invaid MAC on data.\");",
          "1513:                 }",
          "1514:             }",
          "1515:         }",
          "1516: #endif",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.cs||Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.cs": [
          "File: Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.cs -> Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryChannel.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "146:         {",
          "147:             if (disposing)",
          "148:             {",
          "150:             }",
          "151:         }",
          "152:         #endregion",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "149:                 if (m_localNonce != null)",
          "150:                 {",
          "151:                     m_localNonce.Dispose();",
          "152:                     m_localNonce = null;",
          "153:                 }",
          "155:                 if (m_remoteNonce != null)",
          "156:                 {",
          "157:                     m_remoteNonce.Dispose();",
          "158:                     m_remoteNonce = null;",
          "159:                 }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "199:         protected void ChannelStateChanged(TcpChannelState state, ServiceResult reason)",
          "200:         {",
          "204:         }",
          "",
          "[Removed Lines]",
          "201:             Task.Run(() => {",
          "202:                 m_StateChanged?.Invoke(this, state, reason);",
          "203:             });",
          "",
          "[Added Lines]",
          "211:             if (m_StateChanged != null)",
          "212:             {",
          "213:                 Task.Run(() => {",
          "214:                     m_StateChanged?.Invoke(this, state, reason);",
          "215:                 });",
          "216:             }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "209:         protected uint GetNewSequenceNumber()",
          "210:         {",
          "211:             return Utils.IncrementIdentifier(ref m_sequenceNumber);",
          "212:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "224:             m_localSequenceNumber = (uint)m_sequenceNumber;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "779:         private uint m_channelId;",
          "780:         private string m_globalChannelId;",
          "781:         private long m_sequenceNumber;",
          "782:         private uint m_remoteSequenceNumber;",
          "783:         private bool m_sequenceRollover;",
          "784:         private uint m_partialRequestId;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "796:         private uint m_localSequenceNumber;",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryClientChannel.cs||Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryClientChannel.cs": [
          "File: Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryClientChannel.cs -> Stack/Opc.Ua.Core/Stack/Tcp/UaSCBinaryClientChannel.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "494:         {",
          "496:             ChannelToken token = CreateToken();",
          "500:             OpenSecureChannelRequest request = new OpenSecureChannelRequest();",
          "",
          "[Removed Lines]",
          "497:             token.ClientNonce = CreateNonce();",
          "",
          "[Added Lines]",
          "497:             token.ClientNonce = CreateNonce(ClientCertificate);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "616:                 m_requestedToken.Lifetime = (int)response.SecurityToken.RevisedLifetime;",
          "617:                 m_requestedToken.ServerNonce = response.ServerNonce;",
          "619:                 string implementation = String.Format(g_ImplementationString, m_socketFactory.Implementation);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "619:                 if (!ValidateNonce(ServerCertificate, response.ServerNonce))",
          "620:                 {",
          "621:                     throw new ServiceResultException(StatusCodes.BadNonceInvalid);",
          "622:                 }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1452:         private TimerCallback m_StartHandshake;",
          "1453:         private AsyncCallback m_HandshakeComplete;",
          "1454:         private List<QueuedOperation> m_queuedOperations;",
          "1456:         #endregion",
          "1457:     }",
          "1458: }",
          "",
          "[Removed Lines]",
          "1455:         private string g_ImplementationString = \".NetStandard ClientChannel {0} \" + Utils.GetAssemblyBuildNumber();",
          "",
          "[Added Lines]",
          "1460:         private readonly string g_ImplementationString = \".NET Standard ClientChannel {0} \" + Utils.GetAssemblyBuildNumber();",
          "",
          "---------------"
        ],
        "Stack/Opc.Ua.Core/Types/Utils/Utils.cs||Stack/Opc.Ua.Core/Types/Utils/Utils.cs": [
          "File: Stack/Opc.Ua.Core/Types/Utils/Utils.cs -> Stack/Opc.Ua.Core/Types/Utils/Utils.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "2900:         {",
          "2901:             if (hmac == null) throw new ArgumentNullException(nameof(hmac));",
          "2902:             if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));",
          "",
          "[Removed Lines]",
          "2899:         private static byte[] PSHA(HMAC hmac, string label, byte[] data, int offset, int length)",
          "",
          "[Added Lines]",
          "2899:         public static byte[] PSHA(HMAC hmac, string label, byte[] data, int offset, int length)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2972:             return output;",
          "2973:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2979:         [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Security\",",
          "2980:             \"CA5350:Do Not Use Weak Cryptographic Algorithms\", Justification = \"<Pending>\")]",
          "2981:         public static HMAC CreateHMAC(HashAlgorithmName algorithmName, byte[] secret)",
          "2982:         {",
          "2983:             if (algorithmName == HashAlgorithmName.SHA256)",
          "2984:             {",
          "2985:                 return new HMACSHA256(secret);",
          "2986:             }",
          "2988:             if (algorithmName == HashAlgorithmName.SHA384)",
          "2989:             {",
          "2990:                 return new HMACSHA384(secret);",
          "2991:             }",
          "2993:             if (algorithmName == HashAlgorithmName.SHA1)",
          "2994:             {",
          "2995:                 return new HMACSHA1(secret);",
          "2996:             }",
          "2998:             throw new NotImplementedException();",
          "2999:         }",
          "",
          "---------------"
        ],
        "Tests/Opc.Ua.Client.Tests/ClientFixture.cs||Tests/Opc.Ua.Client.Tests/ClientFixture.cs": [
          "File: Tests/Opc.Ua.Client.Tests/ClientFixture.cs -> Tests/Opc.Ua.Client.Tests/ClientFixture.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:         {",
          "58:             ApplicationInstance application = new ApplicationInstance {",
          "59:                 ApplicationName = clientName",
          "60:             };",
          "65:             Config = await application",
          "66:                 .Build(",
          "",
          "[Removed Lines]",
          "56:         public async Task LoadClientConfiguration(string clientName = \"TestClient\")",
          "62:             string pkiRoot = \"%LocalApplicationData%/OPC/pki\";",
          "",
          "[Added Lines]",
          "56:         public async Task LoadClientConfiguration(string pkiRoot = \"%LocalApplicationData%/OPC/pki\", string clientName = \"TestClient\")",
          "",
          "---------------"
        ],
        "Tests/Opc.Ua.Client.Tests/ClientTest.cs||Tests/Opc.Ua.Client.Tests/ClientTest.cs": [
          "File: Tests/Opc.Ua.Client.Tests/ClientTest.cs -> Tests/Opc.Ua.Client.Tests/ClientTest.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "67:         Session m_session;",
          "68:         OperationLimits m_operationLimits;",
          "69:         string m_uriScheme;",
          "70:         Uri m_url;",
          "72:         public ClientTest(string uriScheme = Utils.UriSchemeOpcTcp)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70:         string m_pkiRoot;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "97:         public async Task OneTimeSetUpAsync(TextWriter writer = null)",
          "98:         {",
          "100:             m_serverFixture = new ServerFixture<ReferenceServer> {",
          "101:                 UriScheme = m_uriScheme,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "101:             m_pkiRoot = Path.GetTempPath() + Path.GetRandomFileName();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "107:             {",
          "108:                 m_serverFixture.TraceMasks = Utils.TraceMasks.Error;",
          "109:             }",
          "112:             m_clientFixture = new ClientFixture();",
          "114:             m_clientFixture.Config.TransportQuotas.MaxMessageSize =",
          "115:             m_clientFixture.Config.TransportQuotas.MaxBufferSize = 4 * 1024 * 1024;",
          "116:             m_url = new Uri(m_uriScheme + \"://localhost:\" + m_serverFixture.Port.ToString());",
          "117:             try",
          "118:             {",
          "120:             }",
          "121:             catch (Exception e)",
          "122:             {",
          "",
          "[Removed Lines]",
          "110:             m_server = await m_serverFixture.StartAsync(writer ?? TestContext.Out).ConfigureAwait(false);",
          "113:             await m_clientFixture.LoadClientConfiguration().ConfigureAwait(false);",
          "119:                 m_session = await m_clientFixture.ConnectAsync(m_url, SecurityPolicies.Basic256Sha256).ConfigureAwait(false);",
          "",
          "[Added Lines]",
          "114:             m_server = await m_serverFixture.StartAsync(writer ?? TestContext.Out, m_pkiRoot).ConfigureAwait(false);",
          "117:             await m_clientFixture.LoadClientConfiguration(m_pkiRoot).ConfigureAwait(false);",
          "123:                 m_session = await m_clientFixture.ConnectAsync(m_url, SecurityPolicies.Aes128_Sha256_nistP256).ConfigureAwait(false);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "201:                 .Create().ConfigureAwait(false);",
          "202:         }",
          "205:         public async Task Connect(string securityPolicy)",
          "206:         {",
          "207:             var session = await m_clientFixture.ConnectAsync(m_url, securityPolicy, m_endpoints).ConfigureAwait(false);",
          "",
          "[Removed Lines]",
          "204:         [Theory, Order(200)]",
          "",
          "[Added Lines]",
          "208:         [Test, Order(200)]",
          "209:         [TestCase(SecurityPolicies.Aes128_Sha256_nistP256)]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "319:             StructureDefinition structureDefinition = dataTypeDefinition.Body as StructureDefinition;",
          "320:             Assert.AreEqual(ObjectIds.ProgramDiagnosticDataType_Encoding_DefaultBinary, structureDefinition.DefaultEncodingId);",
          "321:         }",
          "323:         [Theory, Order(400)]",
          "324:         public async Task BrowseFullAddressSpace(string securityPolicy)",
          "325:         {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "327: #if mist",
          "328:         [Test]",
          "329:         public async Task ReadWriteDataTypeDefinition()",
          "330:         {",
          "332:             var typeId = DataTypeIds.PubSubGroupDataType;",
          "333:             var node = m_session.ReadNode(typeId);",
          "334:             Assert.NotNull(node);",
          "335:             var dataTypeNode = (DataTypeNode)node;",
          "336:             Assert.NotNull(dataTypeNode);",
          "337:             var dataTypeDefinition = dataTypeNode.DataTypeDefinition;",
          "338:             Assert.NotNull(dataTypeDefinition);",
          "339:             Assert.True(dataTypeDefinition is ExtensionObject);",
          "340:             Assert.NotNull(dataTypeDefinition.Body);",
          "341:             Assert.True(dataTypeDefinition.Body is StructureDefinition);",
          "342:             StructureDefinition structureDefinition = dataTypeDefinition.Body as StructureDefinition;",
          "343:             Assert.AreEqual(ObjectIds.PubSubGroupDataType_Encoding_DefaultBinary, structureDefinition.DefaultEncodingId);",
          "344:             structureDefinition.DefaultEncodingId = ObjectIds.PubSubGroupDataType_Encoding_DefaultJson;",
          "346:             var writeValueCollection = new WriteValueCollection();",
          "347:             writeValueCollection.Add(new WriteValue() {",
          "348:                 AttributeId = Attributes.DataTypeDefinition,",
          "349:                 NodeId = typeId,",
          "350:                 Value = new DataValue(new Variant(dataTypeDefinition))",
          "351:             });",
          "352:             var response = await m_session.WriteAsync(null, writeValueCollection, CancellationToken.None);",
          "353:             Assert.AreEqual(StatusCodes.BadNotWritable, response.Results[0].Code);",
          "354:             Assert.NotNull(response);",
          "355:         }",
          "356: #endif",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "529:             typeSystem = await m_session.LoadDataTypeSystem(ObjectIds.XmlSchema_TypeSystem).ConfigureAwait(false);",
          "530:             Assert.NotNull(typeSystem);",
          "531:         }",
          "",
          "[Removed Lines]",
          "532:         #endregion",
          "534:         #region Benchmarks",
          "",
          "[Added Lines]",
          "566: #endregion",
          "568: #region Benchmarks",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "551:         {",
          "552:             await BrowseFullAddressSpace(null).ConfigureAwait(false);",
          "553:         }",
          "558:         private uint GetOperationLimitValue(NodeId nodeId)",
          "559:         {",
          "",
          "[Removed Lines]",
          "554:         #endregion",
          "556:         #region Private Methods",
          "",
          "[Added Lines]",
          "588: #endregion",
          "590: #region Private Methods",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "570:                 throw;",
          "571:             }",
          "572:         }",
          "574:     }",
          "575: }",
          "",
          "[Removed Lines]",
          "573:         #endregion",
          "",
          "[Added Lines]",
          "607: #endregion",
          "",
          "---------------"
        ],
        "Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestServer.cs||Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestServer.cs": [
          "File: Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestServer.cs -> Tests/Opc.Ua.Gds.Tests/GlobalDiscoveryTestServer.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "54:         public async Task StartServer(bool clean, int basePort = -1)",
          "55:         {",
          "56:             ApplicationInstance.MessageDlg = new ApplicationMessageDlg();",
          "59:                 ApplicationName = \"Global Discovery Server\",",
          "60:                 ApplicationType = ApplicationType.Server,",
          "61:                 ConfigSectionName = \"Opc.Ua.GlobalDiscoveryTestServer\"",
          "",
          "[Removed Lines]",
          "57:             Application = new ApplicationInstance",
          "58:             {",
          "",
          "[Added Lines]",
          "54:             Application = new ApplicationInstance {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "194:             ApplicationConfiguration config = await application.LoadApplicationConfiguration(true).ConfigureAwait(false);",
          "195: #else",
          "201:                 DefaultSubjectNameContext = \"O=OPC Foundation\",",
          "202:                 CertificateGroups = new CertificateGroupConfigurationCollection()",
          "203:                 {",
          "",
          "[Removed Lines]",
          "196:             string gdsRoot = \"%LocalApplicationData%/OPC/GDS\";",
          "197:             var gdsConfig = new GlobalDiscoveryServerConfiguration()",
          "198:             {",
          "199:                 AuthoritiesStorePath = gdsRoot + \"/authorities\",",
          "200:                 ApplicationCertificatesStorePath = gdsRoot + \"/applications\",",
          "",
          "[Added Lines]",
          "190:             string gdsRoot = Path.Combine(\"%LocalApplicationData%\", \"OPC\", \"GDS\");",
          "191:             var gdsConfig = new GlobalDiscoveryServerConfiguration() {",
          "192:                 AuthoritiesStorePath = Path.Combine(gdsRoot, \"authorities\"),",
          "193:                 ApplicationCertificatesStorePath = Path.Combine(gdsRoot, \"applications\"),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "206:                         Id = \"Default\",",
          "207:                         CertificateType =\"RsaSha256ApplicationCertificateType\",",
          "208:                         SubjectName = \"CN=GDS Test CA, O=OPC Foundation\",",
          "210:                         DefaultCertificateHashSize = 256,",
          "211:                         DefaultCertificateKeySize = 2048,",
          "212:                         DefaultCertificateLifetime = 12,",
          "",
          "[Removed Lines]",
          "209:                         BaseStorePath = gdsRoot + \"/CA/default\",",
          "",
          "[Added Lines]",
          "202:                         BaseStorePath = Path.Combine(gdsRoot, \"CA\", \"default\"),",
          "",
          "---------------"
        ],
        "Tests/Opc.Ua.Server.Tests/ServerFixture.cs||Tests/Opc.Ua.Server.Tests/ServerFixture.cs": [
          "File: Tests/Opc.Ua.Server.Tests/ServerFixture.cs -> Tests/Opc.Ua.Server.Tests/ServerFixture.cs",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:         {",
          "59:             Random m_random = new Random();",
          "60:             bool retryStartServer = false;",
          "",
          "[Removed Lines]",
          "57:         public async Task<T> StartAsync(TextWriter writer, int port = 0)",
          "",
          "[Added Lines]",
          "57:         public async Task<T> StartAsync(TextWriter writer, string pkiRoot = null, int port = 0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "71:             {",
          "72:                 try",
          "73:                 {",
          "75:                 }",
          "76:                 catch (ServiceResultException sre)",
          "77:                 {",
          "",
          "[Removed Lines]",
          "74:                     await InternalStartServerAsync(writer, testPort).ConfigureAwait(false);",
          "",
          "[Added Lines]",
          "74:                     await InternalStartServerAsync(writer, testPort, pkiRoot).ConfigureAwait(false);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "97:         {",
          "98:             ApplicationInstance application = new ApplicationInstance {",
          "99:                 ApplicationName = typeof(T).Name,",
          "",
          "[Removed Lines]",
          "96:         private async Task InternalStartServerAsync(TextWriter writer, int port)",
          "",
          "[Added Lines]",
          "96:         private async Task InternalStartServerAsync(TextWriter writer, int port, string pkiRoot = null)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "101:             };",
          "105:             var endpointUrl = $\"{UriScheme}://localhost:{port}/\" + typeof(T).Name;",
          "106:             var serverConfig = application.Build(",
          "107:                 \"urn:localhost:UA:\" + typeof(T).Name,",
          "",
          "[Removed Lines]",
          "104:             var pkiRoot = Path.GetTempPath() + Path.GetRandomFileName();",
          "",
          "[Added Lines]",
          "104:             pkiRoot = pkiRoot ?? Path.GetTempPath() + Path.GetRandomFileName();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "119:             {",
          "120:                 serverConfig.AddPolicy(MessageSecurityMode.SignAndEncrypt, SecurityPolicies.Basic256Sha256);",
          "121:             }",
          "123:             {",
          "125:                 serverConfig.AddPolicy(MessageSecurityMode.Sign, SecurityPolicies.Basic128Rsa15)",
          "126:                     .AddPolicy(MessageSecurityMode.Sign, SecurityPolicies.Basic256)",
          "127:                     .AddPolicy(MessageSecurityMode.SignAndEncrypt, SecurityPolicies.Basic128Rsa15)",
          "128:                     .AddPolicy(MessageSecurityMode.SignAndEncrypt, SecurityPolicies.Basic256)",
          "129:                     .AddSignPolicies()",
          "130:                     .AddSignAndEncryptPolicies();",
          "131:             }",
          "133:             if (OperationLimits)",
          "",
          "[Removed Lines]",
          "122:             else if(endpointUrl.StartsWith(Utils.UriSchemeOpcTcp, StringComparison.InvariantCultureIgnoreCase))",
          "",
          "[Added Lines]",
          "122:             else if (endpointUrl.StartsWith(Utils.UriSchemeOpcTcp, StringComparison.InvariantCultureIgnoreCase))",
          "124:                 serverConfig.AddPolicy(MessageSecurityMode.Sign, SecurityPolicies.Aes128_Sha256_nistP256);",
          "126: #if TODO",
          "133: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "44c26c42f22e900e9fb816d5f4afed96abc0ffbb",
      "candidate_info": {
        "commit_hash": "44c26c42f22e900e9fb816d5f4afed96abc0ffbb",
        "repo": "OPCFoundation/UA-.NETStandard",
        "commit_url": "https://github.com/OPCFoundation/UA-.NETStandard/commit/44c26c42f22e900e9fb816d5f4afed96abc0ffbb",
        "files": [
          "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
        ],
        "message": "remove empty lines",
        "before_after_code_files": [
          "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
          ],
          "candidate": [
            "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
          ]
        }
      },
      "candidate_diff": {
        "Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs||Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs": [
          "File: Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs -> Stack/Opc.Ua.Core/Security/Certificates/CertificateValidator.cs"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-25659",
  "cve_desc": "python-cryptography 3.2 is vulnerable to Bleichenbacher timing attacks in the RSA decryption API, via timed processing of valid PKCS#1 v1.5 ciphertext.",
  "repo": "pyca/cryptography",
  "patch_hash": "58494b41d6ecb0f56b7c5f05d5f5e3ca0320d494",
  "patch_info": {
    "commit_hash": "58494b41d6ecb0f56b7c5f05d5f5e3ca0320d494",
    "repo": "pyca/cryptography",
    "commit_url": "https://github.com/pyca/cryptography/commit/58494b41d6ecb0f56b7c5f05d5f5e3ca0320d494",
    "files": [
      "CHANGELOG.rst",
      "docs/spelling_wordlist.txt",
      "src/cryptography/hazmat/backends/openssl/rsa.py"
    ],
    "message": "Attempt to mitigate Bleichenbacher attacks on RSA decryption (#5507)",
    "before_after_code_files": [
      "src/cryptography/hazmat/backends/openssl/rsa.py||src/cryptography/hazmat/backends/openssl/rsa.py"
    ]
  },
  "patch_diff": {
    "src/cryptography/hazmat/backends/openssl/rsa.py||src/cryptography/hazmat/backends/openssl/rsa.py": [
      "File: src/cryptography/hazmat/backends/openssl/rsa.py -> src/cryptography/hazmat/backends/openssl/rsa.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "120:     outlen = backend._ffi.new(\"size_t *\", buf_size)",
      "121:     buf = backend._ffi.new(\"unsigned char[]\", buf_size)",
      "122:     res = crypt(pkey_ctx, buf, outlen, data, len(data))",
      "123:     if res <= 0:",
      "141: def _rsa_sig_determine_padding(backend, key, padding, algorithm):",
      "",
      "[Removed Lines]",
      "124:         _handle_rsa_enc_dec_error(backend, key)",
      "126:     return backend._ffi.buffer(buf)[: outlen[0]]",
      "129: def _handle_rsa_enc_dec_error(backend, key):",
      "130:     errors = backend._consume_errors_with_text()",
      "131:     if isinstance(key, _RSAPublicKey):",
      "132:         raise ValueError(",
      "133:             \"Data too long for key size. Encrypt less data or use a \"",
      "134:             \"larger key size.\",",
      "135:             errors,",
      "136:         )",
      "137:     else:",
      "138:         raise ValueError(\"Decryption failed.\", errors)",
      "",
      "[Added Lines]",
      "122:     # Everything from this line onwards is written with the goal of being as",
      "123:     # constant-time as is practical given the constraints of Python and our",
      "124:     # API. See Bleichenbacher's '98 attack on RSA, and its many many variants.",
      "125:     # As such, you should not attempt to change this (particularly to \"clean it",
      "126:     # up\") without understanding why it was written this way (see",
      "127:     # Chesterton's Fence), and without measuring to verify you have not",
      "128:     # introduced observable time differences.",
      "130:     resbuf = backend._ffi.buffer(buf)[: outlen[0]]",
      "131:     backend._lib.ERR_clear_error()",
      "133:         raise ValueError(\"Encryption/decryption failed.\")",
      "134:     return resbuf",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bc609feef8bfd472bbf3cefad2a18a1761af9751",
      "candidate_info": {
        "commit_hash": "bc609feef8bfd472bbf3cefad2a18a1761af9751",
        "repo": "pyca/cryptography",
        "commit_url": "https://github.com/pyca/cryptography/commit/bc609feef8bfd472bbf3cefad2a18a1761af9751",
        "files": [
          "src/_cffi_src/openssl/err.py",
          "src/cryptography/hazmat/backends/openssl/rsa.py",
          "src/cryptography/hazmat/bindings/openssl/_conditional.py",
          "tests/hazmat/primitives/test_rsa.py"
        ],
        "message": "simplify more errors (#5353)\n\nthe quest to stop using unstable openssl error codes continues",
        "before_after_code_files": [
          "src/_cffi_src/openssl/err.py||src/_cffi_src/openssl/err.py",
          "src/cryptography/hazmat/backends/openssl/rsa.py||src/cryptography/hazmat/backends/openssl/rsa.py",
          "src/cryptography/hazmat/bindings/openssl/_conditional.py||src/cryptography/hazmat/bindings/openssl/_conditional.py",
          "tests/hazmat/primitives/test_rsa.py||tests/hazmat/primitives/test_rsa.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/cryptography/hazmat/backends/openssl/rsa.py||src/cryptography/hazmat/backends/openssl/rsa.py"
          ],
          "candidate": [
            "src/cryptography/hazmat/backends/openssl/rsa.py||src/cryptography/hazmat/backends/openssl/rsa.py"
          ]
        }
      },
      "candidate_diff": {
        "src/_cffi_src/openssl/err.py||src/_cffi_src/openssl/err.py": [
          "File: src/_cffi_src/openssl/err.py -> src/_cffi_src/openssl/err.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: TYPES = \"\"\"",
          "12: static const int Cryptography_HAS_EC_CODES;",
          "15: static const int ERR_LIB_DH;",
          "16: static const int ERR_LIB_EVP;",
          "",
          "[Removed Lines]",
          "13: static const int Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "93: static const int PKCS12_R_PKCS12_CIPHERFINAL_ERROR;",
          "98: static const int RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY;",
          "104: static const int SSL_TLSEXT_ERR_OK;",
          "105: static const int SSL_TLSEXT_ERR_ALERT_WARNING;",
          "",
          "[Removed Lines]",
          "95: static const int RSA_R_BAD_PAD_BYTE_COUNT;",
          "96: static const int RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE;",
          "97: static const int RSA_R_DATA_TOO_LARGE_FOR_MODULUS;",
          "99: static const int RSA_R_BLOCK_TYPE_IS_NOT_01;",
          "100: static const int RSA_R_BLOCK_TYPE_IS_NOT_02;",
          "101: static const int RSA_R_PKCS_DECODING_ERROR;",
          "102: static const int RSA_R_OAEP_DECODING_ERROR;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "159: CUSTOMIZATIONS = \"\"\"",
          "160: static const long Cryptography_HAS_EC_CODES = 1;",
          "168: \"\"\"",
          "",
          "[Removed Lines]",
          "162: #ifdef RSA_R_PKCS_DECODING_ERROR",
          "163: static const long Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR = 1;",
          "164: #else",
          "165: static const long Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR = 0;",
          "166: static const long RSA_R_PKCS_DECODING_ERROR = 0;",
          "167: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/cryptography/hazmat/backends/openssl/rsa.py||src/cryptography/hazmat/backends/openssl/rsa.py": [
          "File: src/cryptography/hazmat/backends/openssl/rsa.py -> src/cryptography/hazmat/backends/openssl/rsa.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "129: def _handle_rsa_enc_dec_error(backend, key):",
          "133:     if isinstance(key, _RSAPublicKey):",
          "137:         raise ValueError(",
          "138:             \"Data too long for key size. Encrypt less data or use a \"",
          "140:         )",
          "141:     else:",
          "159: def _rsa_sig_determine_padding(backend, key, padding, algorithm):",
          "",
          "[Removed Lines]",
          "130:     errors = backend._consume_errors()",
          "131:     backend.openssl_assert(errors)",
          "132:     backend.openssl_assert(errors[0].lib == backend._lib.ERR_LIB_RSA)",
          "134:         backend.openssl_assert(",
          "135:             errors[0].reason == backend._lib.RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE",
          "136:         )",
          "139:             \"larger key size.\"",
          "142:         decoding_errors = [",
          "143:             backend._lib.RSA_R_BAD_PAD_BYTE_COUNT,",
          "144:             backend._lib.RSA_R_BLOCK_TYPE_IS_NOT_01,",
          "145:             backend._lib.RSA_R_BLOCK_TYPE_IS_NOT_02,",
          "146:             backend._lib.RSA_R_OAEP_DECODING_ERROR,",
          "147:             # Though this error looks similar to the",
          "148:             # RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE, this occurs on decrypts,",
          "149:             # rather than on encrypts",
          "150:             backend._lib.RSA_R_DATA_TOO_LARGE_FOR_MODULUS,",
          "151:         ]",
          "152:         if backend._lib.Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR:",
          "153:             decoding_errors.append(backend._lib.RSA_R_PKCS_DECODING_ERROR)",
          "155:         backend.openssl_assert(errors[0].reason in decoding_errors)",
          "156:         raise ValueError(\"Decryption failed.\")",
          "",
          "[Added Lines]",
          "130:     errors = backend._consume_errors_with_text()",
          "134:             \"larger key size.\",",
          "135:             errors,",
          "138:         raise ValueError(\"Decryption failed.\", errors)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "241:     buf = backend._ffi.new(\"unsigned char[]\", buflen[0])",
          "242:     res = backend._lib.EVP_PKEY_sign(pkey_ctx, buf, buflen, data, len(data))",
          "243:     if res != 1:",
          "259:     return backend._ffi.buffer(buf)[:]",
          "",
          "[Removed Lines]",
          "244:         errors = backend._consume_errors()",
          "245:         backend.openssl_assert(errors[0].lib == backend._lib.ERR_LIB_RSA)",
          "246:         if errors[0].reason == backend._lib.RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE:",
          "247:             reason = (",
          "248:                 \"Salt length too long for key size. Try using \"",
          "249:                 \"MAX_LENGTH instead.\"",
          "250:             )",
          "251:         else:",
          "252:             backend.openssl_assert(",
          "253:                 errors[0].reason",
          "254:                 == backend._lib.RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY",
          "255:             )",
          "256:             reason = \"Digest too large for key size. Use a larger key.\"",
          "257:         raise ValueError(reason)",
          "",
          "[Added Lines]",
          "226:         errors = backend._consume_errors_with_text()",
          "227:         raise ValueError(",
          "228:             \"Digest or salt length too long for key size. Use a larger key \"",
          "229:             \"or shorter salt length if you are specifying a PSS salt\",",
          "230:             errors,",
          "231:         )",
          "",
          "---------------"
        ],
        "src/cryptography/hazmat/bindings/openssl/_conditional.py||src/cryptography/hazmat/bindings/openssl/_conditional.py": [
          "File: src/cryptography/hazmat/bindings/openssl/_conditional.py -> src/cryptography/hazmat/bindings/openssl/_conditional.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "13:     ]",
          "20: def cryptography_has_rsa_oaep_md():",
          "21:     return [",
          "22:         \"EVP_PKEY_CTX_set_rsa_oaep_md\",",
          "",
          "[Removed Lines]",
          "16: def cryptography_has_rsa_r_pkcs_decoding_error():",
          "17:     return [\"RSA_R_PKCS_DECODING_ERROR\"]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "306: # lists so we can use coverage to measure which are used.",
          "307: CONDITIONAL_NAMES = {",
          "308:     \"Cryptography_HAS_EC2M\": cryptography_has_ec2m,",
          "312:     \"Cryptography_HAS_RSA_OAEP_MD\": cryptography_has_rsa_oaep_md,",
          "313:     \"Cryptography_HAS_RSA_OAEP_LABEL\": cryptography_has_rsa_oaep_label,",
          "314:     \"Cryptography_HAS_SSL3_METHOD\": cryptography_has_ssl3_method,",
          "",
          "[Removed Lines]",
          "309:     \"Cryptography_HAS_RSA_R_PKCS_DECODING_ERROR\": (",
          "310:         cryptography_has_rsa_r_pkcs_decoding_error",
          "311:     ),",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tests/hazmat/primitives/test_rsa.py||tests/hazmat/primitives/test_rsa.py": [
          "File: tests/hazmat/primitives/test_rsa.py -> tests/hazmat/primitives/test_rsa.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1583:         skip_message=\"Does not support OAEP.\",",
          "1584:     )",
          "1585:     def test_invalid_oaep_decryption(self, backend):",
          "1589:         private_key = RSA_KEY_512.private_key(backend)",
          "1591:         ciphertext = private_key.public_key().encrypt(",
          "",
          "[Removed Lines]",
          "1586:         # More recent versions of OpenSSL may raise RSA_R_OAEP_DECODING_ERROR",
          "1587:         # This test triggers it and confirms that we properly handle it. Other",
          "1588:         # backends should also return the proper ValueError.",
          "",
          "[Added Lines]",
          "1586:         # More recent versions of OpenSSL may raise different errors.",
          "1587:         # This test triggers a failure and confirms that we properly handle",
          "1588:         # it.",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "069691a27b98bbca13faa843a1408d631b691bea",
      "candidate_info": {
        "commit_hash": "069691a27b98bbca13faa843a1408d631b691bea",
        "repo": "pyca/cryptography",
        "commit_url": "https://github.com/pyca/cryptography/commit/069691a27b98bbca13faa843a1408d631b691bea",
        "files": [
          "src/_cffi_src/openssl/err.py",
          "src/cryptography/hazmat/backends/openssl/rsa.py",
          "tests/wycheproof/test_rsa.py"
        ],
        "message": "Added wycheproof RSA PKCSv1 encryption tests (#5234)",
        "before_after_code_files": [
          "src/_cffi_src/openssl/err.py||src/_cffi_src/openssl/err.py",
          "src/cryptography/hazmat/backends/openssl/rsa.py||src/cryptography/hazmat/backends/openssl/rsa.py",
          "tests/wycheproof/test_rsa.py||tests/wycheproof/test_rsa.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/cryptography/hazmat/backends/openssl/rsa.py||src/cryptography/hazmat/backends/openssl/rsa.py"
          ],
          "candidate": [
            "src/cryptography/hazmat/backends/openssl/rsa.py||src/cryptography/hazmat/backends/openssl/rsa.py"
          ]
        }
      },
      "candidate_diff": {
        "src/_cffi_src/openssl/err.py||src/_cffi_src/openssl/err.py": [
          "File: src/_cffi_src/openssl/err.py -> src/_cffi_src/openssl/err.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "101: static const int PKCS12_R_PKCS12_CIPHERFINAL_ERROR;",
          "103: static const int RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE;",
          "104: static const int RSA_R_DATA_TOO_LARGE_FOR_MODULUS;",
          "105: static const int RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "103: static const int RSA_R_BAD_PAD_BYTE_COUNT;",
          "",
          "---------------"
        ],
        "src/cryptography/hazmat/backends/openssl/rsa.py||src/cryptography/hazmat/backends/openssl/rsa.py": [
          "File: src/cryptography/hazmat/backends/openssl/rsa.py -> src/cryptography/hazmat/backends/openssl/rsa.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "136:         )",
          "137:     else:",
          "138:         decoding_errors = [",
          "139:             backend._lib.RSA_R_BLOCK_TYPE_IS_NOT_01,",
          "140:             backend._lib.RSA_R_BLOCK_TYPE_IS_NOT_02,",
          "141:             backend._lib.RSA_R_OAEP_DECODING_ERROR,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "139:             backend._lib.RSA_R_BAD_PAD_BYTE_COUNT,",
          "",
          "---------------"
        ],
        "tests/wycheproof/test_rsa.py||tests/wycheproof/test_rsa.py": [
          "File: tests/wycheproof/test_rsa.py -> tests/wycheproof/test_rsa.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "78:     digest = _DIGESTS[wycheproof.testgroup[\"sha\"]]",
          "80:     if digest is None or not backend.hash_supported(digest):",
          "83:     if should_verify(backend, wycheproof):",
          "84:         key.verify(",
          "",
          "[Removed Lines]",
          "81:         pytest.skip(\"Hash {} not supported\".format(digest))",
          "",
          "[Added Lines]",
          "81:         pytest.skip(",
          "82:             \"Hash {} not supported\".format(wycheproof.testgroup[\"sha\"])",
          "83:         )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "184:     )",
          "186:     if not backend.rsa_padding_supported(padding_algo):",
          "189:     if wycheproof.valid or wycheproof.acceptable:",
          "190:         pt = key.decrypt(",
          "",
          "[Removed Lines]",
          "187:         pytest.skip(\"Padding {} not supported\".format(padding_algo))",
          "",
          "[Added Lines]",
          "189:         pytest.skip(",
          "190:             \"OAEP with digest={} and MGF digest={} not supported\".format(",
          "191:                 wycheproof.testgroup[\"sha\"], wycheproof.testgroup[\"mgfSha\"],",
          "192:             )",
          "193:         )",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "198:                 binascii.unhexlify(wycheproof.testcase[\"ct\"]),",
          "199:                 padding_algo",
          "200:             )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "209: @pytest.mark.wycheproof_tests(",
          "210:     \"rsa_pkcs1_2048_test.json\",",
          "211:     \"rsa_pkcs1_3072_test.json\",",
          "212:     \"rsa_pkcs1_4096_test.json\",",
          "213: )",
          "214: def test_rsa_pkcs1_encryption(backend, wycheproof):",
          "215:     key = serialization.load_pem_private_key(",
          "216:         wycheproof.testgroup[\"privateKeyPem\"].encode(\"ascii\"),",
          "217:         password=None,",
          "218:         backend=backend,",
          "219:     )",
          "221:     if wycheproof.valid:",
          "222:         pt = key.decrypt(",
          "223:             binascii.unhexlify(wycheproof.testcase[\"ct\"]),",
          "224:             padding.PKCS1v15()",
          "225:         )",
          "226:         assert pt == binascii.unhexlify(wycheproof.testcase[\"msg\"])",
          "227:     else:",
          "228:         with pytest.raises(ValueError):",
          "229:             key.decrypt(",
          "230:                 binascii.unhexlify(wycheproof.testcase[\"ct\"]),",
          "231:                 padding.PKCS1v15()",
          "232:             )",
          "",
          "---------------"
        ]
      }
    }
  ]
}
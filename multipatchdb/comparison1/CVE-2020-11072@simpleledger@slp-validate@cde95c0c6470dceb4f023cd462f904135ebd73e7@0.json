{
  "cve_id": "CVE-2020-11072",
  "cve_desc": "In SLP Validate (npm package slp-validate) before version 1.2.1, users could experience false-negative validation outcomes for MINT transaction operations. A poorly implemented SLP wallet could allow spending of the affected tokens which would result in the destruction of a user's minting baton. This has been fixed in slp-validate in version 1.2.1. Additonally, slpjs version 0.27.2 has a related fix under related CVE-2020-11071.",
  "repo": "simpleledger/slp-validate",
  "patch_hash": "cde95c0c6470dceb4f023cd462f904135ebd73e7",
  "patch_info": {
    "commit_hash": "cde95c0c6470dceb4f023cd462f904135ebd73e7",
    "repo": "simpleledger/slp-validate",
    "commit_url": "https://github.com/simpleledger/slp-validate/commit/cde95c0c6470dceb4f023cd462f904135ebd73e7",
    "files": [
      "lib/validation.ts"
    ],
    "message": "fix false negative case for MINT transactions\n\nSee the newly added unit test case for this issue.\nCurrently there are 151 unit tests.",
    "before_after_code_files": [
      "lib/validation.ts||lib/validation.ts"
    ]
  },
  "patch_diff": {
    "lib/validation.ts||lib/validation.ts": [
      "File: lib/validation.ts -> lib/validation.ts",
      "--- Hunk 1 ---",
      "[Context before]",
      "408:                     }",
      "409:                 } catch (_) { }",
      "410:             }",
      "412:                 validation.validity = false;",
      "413:                 validation.waiting = false;",
      "415:                 return validation.validity!;",
      "416:             }",
      "417:         } else if (slpmsg.transactionType === SlpTransactionType.SEND) {",
      "",
      "[Removed Lines]",
      "411:             if (validation.parents.length !== 1) {",
      "414:                 validation.invalidReason = \"MINT transaction must have 1 valid baton parent.\";",
      "",
      "[Added Lines]",
      "411:             if (validation.parents.length < 1) {",
      "414:                 validation.invalidReason = \"MINT transaction must have at least 1 candidate baton parent input.\";",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "470:         const parentTxids = [...new Set(validation.parents.map(p => p.txid))];",
      "475:                 validation.validity = false;",
      "476:                 validation.waiting = false;",
      "477:                 validation.invalidReason = \"MINT transaction with invalid baton parent.\";",
      "",
      "[Removed Lines]",
      "471:         for (let i = 0; i < parentTxids.length; i++) {",
      "472:             const valid = await this.isValidSlpTxid({ txid: parentTxids[i] });",
      "473:             validation.parents.filter(p => p.txid === parentTxids[i]).map(p => p.valid = valid);",
      "474:             if (validation.details!.transactionType === SlpTransactionType.MINT && !valid) {",
      "",
      "[Added Lines]",
      "471:         for (const id of parentTxids) {",
      "472:             const valid = await this.isValidSlpTxid({ txid: id });",
      "473:             validation.parents.filter(p => p.txid === id).map(p => p.valid = valid);",
      "474:         }",
      "477:         if (validation.details!.transactionType === SlpTransactionType.MINT) {",
      "478:             if (validation.parents.filter(p => p.valid && p.inputQty === null).length !== 1) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "cd9251971a0b4461f40dc0d8642e27e1bd2a062c",
      "candidate_info": {
        "commit_hash": "cd9251971a0b4461f40dc0d8642e27e1bd2a062c",
        "repo": "simpleledger/slp-validate",
        "commit_url": "https://github.com/simpleledger/slp-validate/commit/cd9251971a0b4461f40dc0d8642e27e1bd2a062c",
        "files": [
          ".gitignore",
          ".vscode/launch.json",
          "README.md",
          "examples/1-validate-tx-rpc-burn-valid-stop.ts",
          "examples/2-validate-tx-rpc-burn-valid-allow.ts",
          "examples/3-validate-txid-rpc.ts",
          "examples/4-validate-txid-bchd.ts",
          "index.ts",
          "lib/crypto.ts",
          "lib/script.ts",
          "lib/slp.ts",
          "lib/transaction.ts",
          "lib/validation.ts",
          "package-lock.json",
          "package.json",
          "test/slp.ts",
          "test/validation.ts",
          "tsconfig.json"
        ],
        "message": "1.0.0",
        "before_after_code_files": [
          "examples/1-validate-tx-rpc-burn-valid-stop.ts||examples/1-validate-tx-rpc-burn-valid-stop.ts",
          "examples/2-validate-tx-rpc-burn-valid-allow.ts||examples/2-validate-tx-rpc-burn-valid-allow.ts",
          "examples/3-validate-txid-rpc.ts||examples/3-validate-txid-rpc.ts",
          "examples/4-validate-txid-bchd.ts||examples/4-validate-txid-bchd.ts",
          "index.ts||index.ts",
          "lib/crypto.ts||lib/crypto.ts",
          "lib/script.ts||lib/script.ts",
          "lib/slp.ts||lib/slp.ts",
          "lib/transaction.ts||lib/transaction.ts",
          "lib/validation.ts||lib/validation.ts",
          "test/slp.ts||test/slp.ts",
          "test/validation.ts||test/validation.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/validation.ts||lib/validation.ts"
          ],
          "candidate": [
            "lib/validation.ts||lib/validation.ts"
          ]
        }
      },
      "candidate_diff": {
        "examples/1-validate-tx-rpc-burn-valid-stop.ts||examples/1-validate-tx-rpc-burn-valid-stop.ts": [
          "File: examples/1-validate-tx-rpc-burn-valid-stop.ts -> examples/1-validate-tx-rpc-burn-valid-stop.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: import { ValidatorType1 } from '../index';",
          "18: import { Big } from 'big.js';",
          "19: const RpcClient = require('bitcoin-rpc-promise-retry');",
          "21: const RPC_USER_NAME = 'bitcoin';",
          "22: const RPC_PASSWORD = 'password';",
          "23: const RPC_URL = 'localhost:8332';",
          "29: const txn = \"01000000067fb42e8fdf232ae50f8dc5e558252fba30336ae83b6e45e138f5b922205143d9020000006441bcf1bd79e139931c9132b72f184223573169367e12bedf407a83b02ab743449f5f7bab144f1ac6514e7cdcab644a4d84e93aeccb26328ce29a860b565a781732412102f706e233e38f92c854093350cca74f03989ade992cad5e9c2f37fd3591e2a745feffffff09e43bbe31136a69856a1d82b18e43be2f6654bb5ed34e762142c003da70ad3a020000006441b8f2c9216c68831c87f59706180f6370c7058e55dc7e566879cbc72b539b44a686a3f0a86f84e190d56498ff303135a1167e1bafbbe218a670ca3ae822d3063f4121023d538f5640dbcb1bca0cab14d9eacf19fb6558ab884aaaf5fa18268eccda8e1afeffffff79fd9c6d020ff90625ede1eca3d63836f11e6a774e022f306cf260b5a20fe077010000006441a4d16b13aa4a8ce8648872359cdcd56c6652280d4514f12be1362fa2a49c619a948c96f18b8d0f15d8b042e65315cf0f84dca2912430357f53cc6bb198d944324121027f76d0cef47d1ca5480fb61475b8a8dda3c150db24e7878e5054a2677f68ed09feffffff3f916feaac6fd543f2b4c1a0bd0cf8cdd67a051d9148b983ff89651cae6448a8010000006441e9e66ad5228bf7cea1be41a0b9cc0abc14fb533751cadd56d925be167f6dd130e608c94d6554059c8651d5814067390f705a7d4febb4e5d43ce2992ec048da45412102c4abc5997c7e1dad05fd8bacd51e5124e6f45c4956dc5cf81cd05af2b30a2a71feffffffb04c1d306f823540686c02899bfcc343e10537be36006b372885bf176b37e68a01000000644105934999a2b5b08469d91a44657353e43a3537a26ecfb85302d9109833b709f7cf6772273357cbbdfa94e1c98f010307ea42e31e6f66f5d01ebe387298ed30774121028cdd539d1c2ebe21e712121928a0e9f1244038cffaf88dd3f646a93f6e1babaffeffffff7fb42e8fdf232ae50f8dc5e558252fba30336ae83b6e45e138f5b922205143d9030000006441bbff4b3a6cb5b616a28210f4c6a07b92ca3c2d483f7f85439e8761a037ba725ea6ac164b36c1ab6f172635d4fbb8792a52f2b4bed5c40b8f5aa1305180f42866412103a08f93fed637daf62c1663c634d9034a2bfb6631c9f6ceba0c2ea7099c17fae2feffffff030000000000000000376a04534c500001010453454e4420c4b0d62156b3fa5c8f3436079b5394f7edc1bef5dc1cd2f9d0c4d46f82cca47908000000000000019022020000000000001976a91446e33d57e44125f02fc71a754fff13317ee8fc5088acb10f0000000000001976a9149c22bf7f6bb779237b2318dcbb1272f39a02d52e88accd2d0900\";",
          "31: (async function() {",
          "32:     console.time(\"SLP-VALIDATE-RPC\");",
          "33:     const connectionString = `http://${RPC_USER_NAME}:${RPC_PASSWORD}@${RPC_URL}`;",
          "34:     const rpc = new RpcClient(connectionString);",
          "35:     const slpValidator = new ValidatorType1({ getRawTransaction: async (txid) => await rpc.getRawTransaction(txid) });",
          "36:     console.log(\"This may take a several seconds...\");",
          "37:     let isValid;",
          "38:     try {",
          "39:         isValid = await slpValidator.isValidSlpTxn({ txn, burnQuantity: Big(0) });",
          "40:     } catch(error) {",
          "41:         console.log(error);",
          "42:         isValid = false;",
          "43:     }",
          "44:     console.log(\"Final Result:\", isValid);",
          "45:     console.log(\"NOTE: THIS IS A VALID SLP TRANSACTION, BUT WE CALL IT INVALID SINCE IT WAS BURNING INPUTS.\")",
          "46:     console.timeEnd(\"SLP-VALIDATE-RPC\");",
          "47: })();",
          "",
          "---------------"
        ],
        "examples/2-validate-tx-rpc-burn-valid-allow.ts||examples/2-validate-tx-rpc-burn-valid-allow.ts": [
          "File: examples/2-validate-tx-rpc-burn-valid-allow.ts -> examples/2-validate-tx-rpc-burn-valid-allow.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: import { ValidatorType1 } from '../index';",
          "13: import { Big } from 'big.js';",
          "14: const RpcClient = require('bitcoin-rpc-promise-retry');",
          "16: const RPC_USER_NAME = 'bitcoin';",
          "17: const RPC_PASSWORD = 'password';",
          "18: const RPC_URL = 'localhost:8332';",
          "20: const txn = \"01000000067fb42e8fdf232ae50f8dc5e558252fba30336ae83b6e45e138f5b922205143d9020000006441bcf1bd79e139931c9132b72f184223573169367e12bedf407a83b02ab743449f5f7bab144f1ac6514e7cdcab644a4d84e93aeccb26328ce29a860b565a781732412102f706e233e38f92c854093350cca74f03989ade992cad5e9c2f37fd3591e2a745feffffff09e43bbe31136a69856a1d82b18e43be2f6654bb5ed34e762142c003da70ad3a020000006441b8f2c9216c68831c87f59706180f6370c7058e55dc7e566879cbc72b539b44a686a3f0a86f84e190d56498ff303135a1167e1bafbbe218a670ca3ae822d3063f4121023d538f5640dbcb1bca0cab14d9eacf19fb6558ab884aaaf5fa18268eccda8e1afeffffff79fd9c6d020ff90625ede1eca3d63836f11e6a774e022f306cf260b5a20fe077010000006441a4d16b13aa4a8ce8648872359cdcd56c6652280d4514f12be1362fa2a49c619a948c96f18b8d0f15d8b042e65315cf0f84dca2912430357f53cc6bb198d944324121027f76d0cef47d1ca5480fb61475b8a8dda3c150db24e7878e5054a2677f68ed09feffffff3f916feaac6fd543f2b4c1a0bd0cf8cdd67a051d9148b983ff89651cae6448a8010000006441e9e66ad5228bf7cea1be41a0b9cc0abc14fb533751cadd56d925be167f6dd130e608c94d6554059c8651d5814067390f705a7d4febb4e5d43ce2992ec048da45412102c4abc5997c7e1dad05fd8bacd51e5124e6f45c4956dc5cf81cd05af2b30a2a71feffffffb04c1d306f823540686c02899bfcc343e10537be36006b372885bf176b37e68a01000000644105934999a2b5b08469d91a44657353e43a3537a26ecfb85302d9109833b709f7cf6772273357cbbdfa94e1c98f010307ea42e31e6f66f5d01ebe387298ed30774121028cdd539d1c2ebe21e712121928a0e9f1244038cffaf88dd3f646a93f6e1babaffeffffff7fb42e8fdf232ae50f8dc5e558252fba30336ae83b6e45e138f5b922205143d9030000006441bbff4b3a6cb5b616a28210f4c6a07b92ca3c2d483f7f85439e8761a037ba725ea6ac164b36c1ab6f172635d4fbb8792a52f2b4bed5c40b8f5aa1305180f42866412103a08f93fed637daf62c1663c634d9034a2bfb6631c9f6ceba0c2ea7099c17fae2feffffff030000000000000000376a04534c500001010453454e4420c4b0d62156b3fa5c8f3436079b5394f7edc1bef5dc1cd2f9d0c4d46f82cca47908000000000000019022020000000000001976a91446e33d57e44125f02fc71a754fff13317ee8fc5088acb10f0000000000001976a9149c22bf7f6bb779237b2318dcbb1272f39a02d52e88accd2d0900\";",
          "22: (async function() {",
          "23:     console.time(\"SLP-VALIDATE-RPC\");",
          "24:     const connectionString = `http://${RPC_USER_NAME}:${RPC_PASSWORD}@${RPC_URL}`;",
          "25:     const rpc = new RpcClient(connectionString);",
          "26:     const slpValidator = new ValidatorType1({ getRawTransaction: async (txid) => await rpc.getRawTransaction(txid) });",
          "27:     console.log(\"This may take a several seconds...\");",
          "28:     let isValid;",
          "29:     try {",
          "30:         isValid = await slpValidator.isValidSlpTxn({ txn, burnQuantity: Big(5) });  // <--- Use \"burnQuantity\" to allow an exact burn amount",
          "31:     } catch(error) {",
          "32:         console.log(error);",
          "33:         isValid = false;",
          "34:     }",
          "35:     console.log(\"Final Result:\", isValid);",
          "36:     console.log(\"NOTE: IN CONTRAST TO EXAMPLE 1, WE SPECIFICALLY ALLOWED BURNING IN THIS EXAMPLE\");",
          "37:     console.timeEnd(\"SLP-VALIDATE-RPC\");",
          "38: })();",
          "",
          "---------------"
        ],
        "examples/3-validate-txid-rpc.ts||examples/3-validate-txid-rpc.ts": [
          "File: examples/3-validate-txid-rpc.ts -> examples/3-validate-txid-rpc.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: import { ValidatorType1 } from '../index';",
          "12: const RpcClient = require('bitcoin-rpc-promise-retry');",
          "14: const RPC_USER_NAME = 'bitcoin';",
          "15: const RPC_PASSWORD = 'password';",
          "16: const RPC_URL = 'localhost:8332';",
          "18: const txid = \"9cd705998fcc233ccf0a840f4ee7fcbc1eb678eba79e708560ecc95fedecfec9\";",
          "20: (async function() {",
          "21:     console.time(\"SLP-VALIDATE-RPC\");",
          "22:     const connectionString = `http://${RPC_USER_NAME}:${RPC_PASSWORD}@${RPC_URL}`;",
          "23:     const rpc = new RpcClient(connectionString);",
          "24:     const slpValidator = new ValidatorType1({ getRawTransaction: async (txid) => await rpc.getRawTransaction(txid) });",
          "25:     console.log(\"Validating:\", txid);",
          "26:     console.log(\"This may take a several seconds...\");",
          "27:     let isValid = await slpValidator.isValidSlpTxid({ txid });",
          "28:     console.log(\"Final Result:\", isValid);",
          "29:     console.log(\"WARNING: THIS VALIDATION METHOD COMES WITH NO BURN PROTECTION.\")",
          "30:     console.timeEnd(\"SLP-VALIDATE-RPC\");",
          "31: })();",
          "",
          "---------------"
        ],
        "examples/4-validate-txid-bchd.ts||examples/4-validate-txid-bchd.ts": [
          "File: examples/4-validate-txid-bchd.ts -> examples/4-validate-txid-bchd.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: import { ValidatorType1 } from '../index';",
          "12: import { GrpcClient } from 'grpc-bchrpc-node';",
          "14: const GRPC_URL = 'localhost:8335';",
          "16: const GRPC_CERT = '<path to your BCHD cert>';",
          "18: const txid = \"9cd705998fcc233ccf0a840f4ee7fcbc1eb678eba79e708560ecc95fedecfec9\";",
          "20: (async function() {",
          "21:     console.time(\"SLP-VALIDATE-GRPC\");",
          "22:     const rpc = new GrpcClient({ url: GRPC_URL, rootCertPath: GRPC_CERT });",
          "23:     const slpValidator = new ValidatorType1({ getRawTransaction: async (txid: string) => {",
          "24:         let res = await rpc.getRawTransaction({ hash: txid, reverseOrder: true});",
          "25:         return Buffer.from(res.getTransaction_asU8());",
          "26:     } });",
          "27:     console.log(\"Validating:\", txid);",
          "28:     console.log(\"This may take a several seconds...\");",
          "29:     let isValid = await slpValidator.isValidSlpTxid({ txid });",
          "30:     console.log(\"Final Result:\", isValid);",
          "31:     console.log(\"WARNING: THIS VALIDATION METHOD COMES WITH NO BURN PROTECTION.\")",
          "32:     console.timeEnd(\"SLP-VALIDATE-GRPC\");",
          "33: })();",
          "",
          "---------------"
        ],
        "index.ts||index.ts": [
          "File: index.ts -> index.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: export * from './lib/validation';",
          "2: export * from './lib/transaction';",
          "3: export * from './lib/slp';",
          "4: export * from './lib/crypto';",
          "",
          "---------------"
        ],
        "lib/crypto.ts||lib/crypto.ts": [
          "File: lib/crypto.ts -> lib/crypto.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import * as crypto from 'crypto';",
          "3: export class Crypto {",
          "4:     static hash256(message: Buffer): Buffer {",
          "5:         let hash1 = crypto.createHash('sha256');",
          "6:         let hash2 = crypto.createHash('sha256');",
          "7:         hash1.update(message);",
          "8:         hash2.update(hash1.digest());",
          "9:         return Buffer.from(hash2.digest().toJSON().data.reverse());",
          "10:     }",
          "11: }",
          "",
          "---------------"
        ],
        "lib/script.ts||lib/script.ts": [
          "File: lib/script.ts -> lib/script.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: export class Script {",
          "2:     static opcodes = {",
          "3:         OP_0: 0,",
          "4:         OP_16: 96,",
          "5:         OP_PUSHDATA1: 76,",
          "6:         OP_PUSHDATA2: 77,",
          "7:         OP_PUSHDATA4: 78,",
          "8:         OP_1NEGATE : 79,",
          "9:         OP_RETURN: 106,",
          "10:     }",
          "11: }",
          "",
          "---------------"
        ],
        "lib/slp.ts||lib/slp.ts": [
          "File: lib/slp.ts -> lib/slp.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import { Script } from './script';",
          "3: import Big from 'big.js';",
          "5: export enum SlpTransactionType {",
          "6:     \"GENESIS\" = \"GENESIS\",",
          "7:     \"MINT\" = \"MINT\",",
          "8:     \"SEND\" = \"SEND\"",
          "9: }",
          "11: export enum SlpVersionType {",
          "12:     \"TokenVersionType1\" = 1,",
          "13:     \"TokenVersionType1_NFT_Child\" = 65,",
          "14:     \"TokenVersionType1_NFT_Parent\" = 129",
          "15: }",
          "17: export interface SlpTransactionDetails {",
          "18:     transactionType: SlpTransactionType;",
          "19:     tokenIdHex: string;",
          "20:     versionType: SlpVersionType;",
          "21:     timestamp?: string;",
          "22:     symbol: string;",
          "23:     name: string;",
          "24:     documentUri: string|Buffer;",
          "25:     documentSha256: Buffer|null;",
          "26:     decimals: number;",
          "27:     containsBaton: boolean;",
          "28:     batonVout: number|null;",
          "29:     genesisOrMintQuantity: Big|null;",
          "30:     sendOutputs?: Big[]|null;",
          "31: }",
          "33: export interface PushDataOperation {",
          "34:     opcode: number,",
          "35:     data: Buffer|null",
          "36: }",
          "38: export class Slp {",
          "40:     static get lokadIdHex() { return \"534c5000\" }",
          "43:     static parseOpReturnToChunks(script: Buffer, allow_op_0=false, allow_op_number=false) {",
          "46:         let ops: PushDataOperation[];",
          "49:         try {",
          "50:             ops = this.getScriptOperations(script);",
          "51:         } catch(e) {",
          "53:             throw Error('Script error');",
          "54:         }",
          "56:         if(ops[0].opcode !== Script.opcodes.OP_RETURN)",
          "57:             throw Error('No OP_RETURN');",
          "58:         let chunks: (Buffer|null)[] = [];",
          "59:         ops.slice(1).forEach(opitem => {",
          "60:             if(opitem.opcode > Script.opcodes.OP_16)",
          "61:                 throw Error(\"Non-push opcode\");",
          "62:             if(opitem.opcode > Script.opcodes.OP_PUSHDATA4) {",
          "63:                 if(opitem.opcode === 80)",
          "64:                     throw Error('Non-push opcode');",
          "65:                 if(!allow_op_number)",
          "66:                     throw Error('OP_1NEGATE to OP_16 not allowed');",
          "67:                 if(opitem.opcode === Script.opcodes.OP_1NEGATE)",
          "68:                     opitem.data = Buffer.from([0x81]);",
          "69:                 else // OP_1 - OP_16",
          "70:                     opitem.data = Buffer.from([opitem.opcode - 80]);",
          "71:             }",
          "72:             if(opitem.opcode === Script.opcodes.OP_0 && !allow_op_0){",
          "73:                 throw Error('OP_0 not allowed');",
          "74:             }",
          "75:             chunks.push(opitem.data)",
          "76:         });",
          "78:         return chunks",
          "79:     }",
          "81:     static parseChunkToInt(intBytes: Buffer, minByteLen: number, maxByteLen: number, raise_on_Null = false) {",
          "87:         if(intBytes.length >= minByteLen && intBytes.length <= maxByteLen)",
          "88:             return intBytes.readUIntBE(0, intBytes.length)",
          "89:         if(intBytes.length === 0 && !raise_on_Null)",
          "90:             return null;",
          "91:         throw Error('Field has wrong length');",
          "92:     }",
          "94:     static parseSlpOutputScript(outputScript: Buffer): SlpTransactionDetails {",
          "95:         let slpMsg = <SlpTransactionDetails>{};",
          "96:         let chunks: (Buffer|null)[];",
          "97:         try {",
          "98:             chunks = this.parseOpReturnToChunks(outputScript);",
          "99:         } catch(e) {",
          "100:             throw Error('Bad OP_RETURN');",
          "101:         }",
          "102:         if(chunks.length === 0)",
          "103:             throw Error('Empty OP_RETURN');",
          "104:         if(!chunks[0])",
          "105:             throw Error(\"Not SLP\")",
          "106:         if(!chunks[0]!.equals(Buffer.from(this.lokadIdHex, 'hex')))",
          "107:             throw Error('Not SLP');",
          "108:         if(chunks.length === 1)",
          "109:             throw Error(\"Missing token versionType\");",
          "111:         if(!chunks[1])",
          "112:             throw Error(\"Bad versionType buffer\")",
          "113:         slpMsg.versionType = <SlpVersionType>Slp.parseChunkToInt(chunks[1]!, 1, 2, true);",
          "114:         let supportedTypes = [",
          "115:                 SlpVersionType.TokenVersionType1,",
          "116:                 SlpVersionType.TokenVersionType1_NFT_Parent,",
          "117:                 SlpVersionType.TokenVersionType1_NFT_Child ];",
          "118:         if(!supportedTypes.includes(slpMsg.versionType))",
          "119:             throw Error('Unsupported token type: ' + slpMsg.versionType);",
          "120:         if(chunks.length === 2)",
          "121:             throw Error('Missing SLP transaction type');",
          "122:         try {",
          "123:             let msgType: string = chunks[2]!.toString('ascii')",
          "124:             slpMsg.transactionType = SlpTransactionType[msgType as keyof typeof SlpTransactionType]",
          "125:         } catch(_){",
          "126:             throw Error('Bad transaction type');",
          "127:         }",
          "128:         if(slpMsg.transactionType === SlpTransactionType.GENESIS) {",
          "129:             if(chunks.length !== 10)",
          "130:                 throw Error('GENESIS with incorrect number of parameters');",
          "131:             slpMsg.symbol = chunks[3] ? chunks[3]!.toString('utf8') : '';",
          "132:             slpMsg.name = chunks[4] ? chunks[4]!.toString('utf8') : '';",
          "133:             slpMsg.documentUri = chunks[5] ? chunks[5]!.toString('utf8') : '';",
          "134:             slpMsg.documentSha256 = chunks[6] ? chunks[6] : null;",
          "135:             if(slpMsg.documentSha256) {",
          "136:                 if(slpMsg.documentSha256.length !== 0 && slpMsg.documentSha256.length !== 32)",
          "137:                     throw Error('Token document hash is incorrect length');",
          "138:             }",
          "139:             if(!chunks[7])",
          "140:                 throw Error(\"Bad decimals buffer\")",
          "141:             slpMsg.decimals = <number>Slp.parseChunkToInt(chunks[7]!, 1, 1, true);",
          "142:             if(slpMsg.versionType === 0x41 && slpMsg.decimals !== 0)",
          "143:                 throw Error('NFT1 child token must have divisibility set to 0 decimal places.')",
          "144:             if(slpMsg.decimals > 9)",
          "145:                 throw Error('Too many decimals')",
          "146:             slpMsg.batonVout = chunks[8] ? Slp.parseChunkToInt(chunks[8]!, 1, 1) : null;",
          "147:             if(slpMsg.batonVout !== null) {",
          "148:                 if (slpMsg.batonVout < 2)",
          "149:                     throw Error('Mint baton cannot be on vout=0 or 1');",
          "150:                 slpMsg.containsBaton = true;",
          "151:             }",
          "152:             if(slpMsg.versionType === 0x41 && slpMsg.batonVout !== null)",
          "153:                 throw Error(\"NFT1 child token must not have a minting baton!\")",
          "154:             if(!chunks[9])",
          "155:                 throw Error(\"Bad Genesis quantity buffer\")",
          "156:             if(chunks[9]!.length !== 8)",
          "157:                 throw Error(\"Genesis quantity must be provided as an 8-byte buffer\")",
          "158:             slpMsg.genesisOrMintQuantity = this.buffer2BigNumber(chunks[9]!);",
          "159:             if(slpMsg.versionType === 0x41 && !slpMsg.genesisOrMintQuantity.eq(1))",
          "160:                 throw Error(\"NFT1 child token must have GENESIS quantity of 1.\")",
          "161:         }",
          "162:         else if(slpMsg.transactionType === SlpTransactionType.SEND) {",
          "163:             if(chunks.length < 4)",
          "164:                 throw Error('SEND with too few parameters');",
          "165:             if(!chunks[3])",
          "166:                 throw Error(\"Bad tokenId buffer\")",
          "167:             if(chunks[3]!.length !== 32)",
          "168:                 throw Error('token_id is wrong length');",
          "169:             slpMsg.tokenIdHex = chunks[3]!.toString('hex');",
          "175:             slpMsg.sendOutputs = [];",
          "176:             slpMsg.sendOutputs.push(new Big(0));",
          "177:             chunks.slice(4).forEach(chunk => {",
          "178:                 if(!chunk)",
          "179:                     throw Error(\"Bad send quantity buffer.\")",
          "180:                 if(chunk.length !== 8)",
          "181:                     throw Error('SEND quantities must be 8-bytes each.');",
          "182:                 slpMsg.sendOutputs!.push(this.buffer2BigNumber(chunk));",
          "183:             });",
          "185:             if(slpMsg.sendOutputs.length < 2)",
          "186:                 throw Error('Missing output amounts');",
          "187:             if(slpMsg.sendOutputs.length > 20)",
          "188:                 throw Error('More than 19 output amounts');",
          "189:         }",
          "190:         else if(slpMsg.transactionType === SlpTransactionType.MINT) {",
          "191:             if(slpMsg.versionType === 0x41)",
          "192:                 throw Error(\"NFT1 Child cannot have MINT transaction type.\")",
          "193:             if(chunks.length != 6)",
          "194:                 throw Error('MINT with incorrect number of parameters');",
          "195:             if(!chunks[3])",
          "196:                 throw Error(\"Bad token_id buffer\");",
          "197:             if(chunks[3]!.length != 32)",
          "198:                 throw Error('token_id is wrong length');",
          "199:             slpMsg.tokenIdHex = chunks[3]!.toString('hex');",
          "200:             slpMsg.batonVout = chunks[4] ? Slp.parseChunkToInt(chunks[4]!,1,1) : null;",
          "201:             if(slpMsg.batonVout !== null && slpMsg.batonVout !== undefined) {",
          "202:                 if(slpMsg.batonVout < 2)",
          "203:                     throw Error('Mint baton cannot be on vout=0 or 1');",
          "204:                 slpMsg.containsBaton = true;",
          "205:             }",
          "206:             if(!chunks[5])",
          "207:                 throw Error(\"Bad Mint quantity buffer\")",
          "208:             if(chunks[5]!.length !== 8)",
          "209:                 throw Error(\"Mint quantity must be provided as an 8-byte buffer\")",
          "210:             slpMsg.genesisOrMintQuantity = this.buffer2BigNumber(chunks[5]!);",
          "211:         }",
          "212:         else",
          "213:             throw Error(\"Bad transaction type\");",
          "215:         if(!slpMsg.genesisOrMintQuantity && (!slpMsg.sendOutputs || slpMsg.sendOutputs.length === 0))",
          "216:             throw Error(\"SLP message must have either Genesis/Mint outputs or Send outputs, both are missing\");",
          "218:         return slpMsg;",
          "219:     }",
          "221:     static buffer2BigNumber(amount: Buffer): Big {",
          "222:         if(amount.length < 5 || amount.length > 8)",
          "223:             throw Error(\"Buffer must be between 4-8 bytes in length\");",
          "224:         return (new Big(amount.readUInt32BE(0).toString())).times(2**32).plus(amount.readUInt32BE(4).toString());",
          "225:     }",
          "228:     static getScriptOperations(script: Buffer) {",
          "229:         let ops: PushDataOperation[] = [];",
          "230:         try {",
          "231:             let n = 0;",
          "232:             let dlen: number;",
          "233:             while (n < script.length) {",
          "234:                 let op: PushDataOperation = { opcode: script[n], data: null }",
          "235:                 n += 1;",
          "236:                 if(op.opcode <= Script.opcodes.OP_PUSHDATA4) {",
          "237:                     if(op.opcode < Script.opcodes.OP_PUSHDATA1)",
          "238:                         dlen = op.opcode;",
          "239:                     else if(op.opcode === Script.opcodes.OP_PUSHDATA1) {",
          "240:                         dlen = script[n];",
          "241:                         n += 1;",
          "242:                     }",
          "243:                     else if(op.opcode === Script.opcodes.OP_PUSHDATA2) {",
          "244:                         dlen = script.slice(n, n + 2).readUIntLE(0,2);",
          "245:                         n += 2;",
          "246:                     }",
          "247:                     else {",
          "248:                         dlen = script.slice(n, n + 4).readUIntLE(0,4);",
          "249:                         n += 4;",
          "250:                     }",
          "251:                     if((n + dlen) > script.length) {",
          "252:                         throw Error('IndexError');",
          "253:                     }",
          "254:                     if(dlen > 0)",
          "255:                         op.data = script.slice(n, n + dlen);",
          "256:                     n += dlen",
          "257:                 }",
          "258:                 ops.push(op);",
          "259:             }",
          "260:         } catch(e) {",
          "262:             throw Error('truncated script')",
          "263:         }",
          "264:         return ops;",
          "265:     }",
          "267: }",
          "",
          "---------------"
        ],
        "lib/transaction.ts||lib/transaction.ts": [
          "File: lib/transaction.ts -> lib/transaction.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: export class Transaction {",
          "2:     version: number;",
          "3:     inputs: TransactionInput[];",
          "4:     outputs: TransactionOutput[];",
          "5:     lockTime: number;",
          "6:     constructor(version?: number, inputs?: TransactionInput[], outputs?: any[], lockTime?: number) {",
          "7:         this.version = version || 1;",
          "8:         this.inputs = inputs || [];",
          "9:         this.outputs = outputs || [];",
          "10:         this.lockTime = lockTime || 0;",
          "11:     }",
          "13:     static parseFromBuffer(buffer: Buffer) {",
          "14:         let source = new Primatives.ArraySource(buffer.toJSON().data)",
          "15:         let stream = new Primatives.ByteStream(source);",
          "16:         return Transaction.parse(stream);",
          "17:     }",
          "19:     static parse(stream: Primatives.ByteStream) {",
          "20:         var transaction = new Transaction();",
          "21:         transaction.version = stream.readInt(4);",
          "23:         var txInNum = stream.readVarInt();",
          "24:         for (var i = 0; i < txInNum; i++) {",
          "25:             let input: TransactionInput = {",
          "26:                 previousTxHash: stream.readHexBytes(32),",
          "27:                 previousTxOutIndex: stream.readInt(4),",
          "28:                 scriptSig: Buffer.from(stream.readString()),",
          "29:                 sequenceNo: stream.readHexBytes(4),",
          "30:             }",
          "32:             transaction.inputs.push(input);",
          "33:         }",
          "35:         var txOutNum = stream.readVarInt();",
          "36:         for (var i = 0; i < txOutNum; i++) {",
          "37:             transaction.outputs.push({",
          "38:                 value: stream.readInt(8),",
          "39:                 scriptPubKey: Buffer.from(stream.readString())",
          "40:             });",
          "41:         }",
          "43:         transaction.lockTime = stream.readInt(4);",
          "45:         return transaction;",
          "46:     }",
          "47: }",
          "49: export interface TransactionInput {",
          "50:     previousTxHash: string,",
          "51:     previousTxOutIndex: number,",
          "52:     scriptSig: Buffer,",
          "53:     sequenceNo: string,",
          "54:     satoshis?: number",
          "55: }",
          "57: export interface TransactionOutput {",
          "58:     value: number;",
          "59:     scriptPubKey: Buffer;",
          "60: }",
          "62: export namespace Primatives {",
          "63:     class Hex {",
          "64:         static decode(text: string) {",
          "65:             return text.match(/.{2}/g)!.map(function(byte) {",
          "66:                 return parseInt(byte, 16);",
          "67:             });",
          "68:         }",
          "69:         static encode(bytes: number[]) {",
          "70:             var result = [];",
          "71:             for (var i = 0, hex; i < bytes.length; i++) {",
          "72:                 hex = bytes[i].toString(16);",
          "73:                 if (hex.length < 2) {",
          "74:                     hex = '0' + hex;",
          "75:                 }",
          "76:                 result.push(hex);",
          "77:             }",
          "78:             return result.join('');",
          "79:         }",
          "80:     };",
          "82:     class LittleEndian {",
          "83:         static decode(bytes: number[]) {",
          "84:             return bytes.reduce(function(previous, current, index) {",
          "85:                 return previous + current * Math.pow(256, index);",
          "86:             }, 0);",
          "87:         }",
          "88:         static encode(number: number, count: number) {",
          "89:             var rawBytes = [];",
          "90:             for (var i = 0; i < count; i++) {",
          "91:                 rawBytes[i] = number & 0xff;",
          "92:                 number = Math.floor(number / 256);",
          "93:             }",
          "94:             return rawBytes;",
          "95:         }",
          "96:     };",
          "98:     export class ArraySource {",
          "99:         rawBytes: number[];",
          "100:         index: number;",
          "101:         constructor(rawBytes: number[], index?: number) {",
          "102:             this.rawBytes = rawBytes;",
          "103:             this.index = index || 0;",
          "104:         }",
          "105:         readByte() {",
          "106:             if (!this.hasMoreBytes()) {",
          "107:                 throw new Error('Cannot read past the end of the array.');",
          "108:             }",
          "109:             return this.rawBytes[this.index++];",
          "110:         }",
          "111:         hasMoreBytes() {",
          "112:             return this.index < this.rawBytes.length;",
          "113:         }",
          "114:         getPosition() {",
          "115:             return this.index;",
          "116:         }",
          "117:     }",
          "119:     export class ByteStream {",
          "120:         source: ArraySource;",
          "121:         constructor(source: ArraySource){",
          "122:             this.source = source;",
          "123:         }",
          "124:         readByte() {",
          "125:             return this.source.readByte();",
          "126:         }",
          "127:         readBytes(num: number) {",
          "128:             var bytes = [];",
          "129:             for (var i = 0; i < num; i++) {",
          "130:                 bytes.push(this.readByte());",
          "131:             }",
          "132:             return bytes;",
          "133:         }",
          "134:         readInt(num: number) {",
          "135:             var bytes = this.readBytes(num);",
          "136:             return LittleEndian.decode(bytes);",
          "137:         }",
          "138:         readVarInt() {",
          "139:             var num = this.readByte();",
          "140:             if (num < 0xfd) {",
          "141:                 return num;",
          "142:             } else if (num === 0xfd) {",
          "143:                 return this.readInt(2);",
          "144:             } else if (num === 0xfe) {",
          "145:                 return this.readInt(4);",
          "146:             } else {",
          "147:                 return this.readInt(8);",
          "148:             }",
          "149:         }",
          "150:         readString() {",
          "151:             var length = this.readVarInt();",
          "152:             return this.readBytes(length);",
          "153:         }",
          "154:         readHexBytes(num: number) {",
          "155:             var bytes = this.readBytes(num);",
          "156:             return Hex.encode(bytes.reverse());",
          "157:         }",
          "158:         hasMoreBytes() {",
          "159:             return this.source.hasMoreBytes();",
          "160:         }",
          "161:         getPosition() {",
          "162:             return this.source.getPosition();",
          "163:         }",
          "164:     }",
          "165: }",
          "",
          "---------------"
        ],
        "lib/validation.ts||lib/validation.ts": [
          "File: lib/validation.ts -> lib/validation.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import { Crypto } from './crypto';",
          "2: import { Transaction } from './transaction';",
          "3: import { SlpTransactionType, SlpTransactionDetails, Slp } from './slp';",
          "5: import Big from 'big.js';",
          "7: export interface Validation { validity: boolean|null; parents: Parent[], details: SlpTransactionDetails|null, invalidReason: string|null, waiting: boolean }",
          "8: export type GetRawTransactionAsync = (txid: string) => Promise<string|Buffer>;",
          "10: const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))",
          "12: interface Parent {",
          "13:     txid: string;",
          "14:     vout: number;",
          "15:     versionType: number;",
          "16:     valid: boolean|null;",
          "17:     inputQty: Big|null;",
          "18: }",
          "20: export class ValidatorType1 {",
          "21:     cachedRawTransactions: MapCache<string, Buffer>; //{ [txid: string]: Buffer }",
          "22:     cachedValidations: MapCache<string, Validation>; //{ [txid: string]: Validation }",
          "23:     getRawTransaction: GetRawTransactionAsync;",
          "24:     logger: { log: (s: string)=> any };",
          "26:     constructor({ getRawTransaction, logger=console, maxTransactionCacheSize=100000, maxValidationCacheSize=100000 }: { getRawTransaction: GetRawTransactionAsync, logger?: { log: (s: string)=> any }, maxTransactionCacheSize?: number, maxValidationCacheSize?: number }) {",
          "27:         if(!getRawTransaction)",
          "28:             throw Error(\"Must provide method getRawTransaction to class constructor.\")",
          "29:         this.logger = logger;",
          "30:         this.getRawTransaction = getRawTransaction;",
          "31:         this.cachedValidations = new MapCache<string, Validation>(maxValidationCacheSize);",
          "32:         this.cachedRawTransactions = new MapCache<string, Buffer>(maxTransactionCacheSize);",
          "33:     }",
          "35:     addValidationFromStore(hex: string, isValid: boolean) {",
          "36:         let id = Crypto.hash256(Buffer.from(hex, 'hex')).toString('hex');",
          "37:         if(!this.cachedValidations.has(id))",
          "38:             this.cachedValidations.set(id, { validity: isValid, parents: [], details: null, invalidReason: null, waiting: false })",
          "39:         if(!this.cachedRawTransactions.has(id))",
          "40:             this.cachedRawTransactions.set(id, Buffer.from(hex, 'hex'));",
          "41:     }",
          "43:     async waitForCurrentValidationProcessing(txid: string) {",
          "44:         let cached: Validation = this.cachedValidations.get(txid)!;",
          "46:         if(!cached)",
          "47:             throw Error(\"txid is missing from cachedValidations.\")",
          "49:         while(true) {",
          "50:             if(typeof cached.validity === 'boolean') {",
          "51:                 cached.waiting = false;",
          "52:                 break;",
          "53:             }",
          "54:             await sleep(10);",
          "55:         }",
          "56:     }",
          "58:     async waitForTransactionDownloadToComplete(txid: string){",
          "59:         while(true) {",
          "61:             if(this.cachedRawTransactions.get(txid)! && this.cachedRawTransactions.get(txid)! !== \"waiting\") {",
          "62:                 break;",
          "63:             }",
          "64:             await sleep(10);",
          "65:         }",
          "66:     }",
          "68:     async retrieveRawTransaction(txid: string) {",
          "69:         if(this.cachedRawTransactions.has(txid))",
          "70:             return this.cachedRawTransactions.get(txid)!;",
          "72:         this.cachedRawTransactions.set(txid, \"waiting\");",
          "73:         let res = await this.getRawTransaction(txid);",
          "74:         if(typeof res === \"string\")",
          "75:             this.cachedRawTransactions.set(txid, Buffer.from(res, 'hex'));",
          "76:         else",
          "77:             this.cachedRawTransactions.set(txid, res);",
          "78:         if(this.cachedRawTransactions.has(txid)) {",
          "79:             if(this.cachedRawTransactions.get(txid)!.length < 60)",
          "80:                 throw Error(\"Valid transaction data not provided.\")",
          "81:             return this.cachedRawTransactions.get(txid)!;",
          "82:         }",
          "83:         throw Error(\"Transaction data not provided (null or undefined).\")",
          "84:     }",
          "86:     async isValidSlpTxn({ txn, tokenIdFilter, tokenTypeFilter, burnQuantity=Big(0) }: { txn: string|Buffer, tokenIdFilter?: string, tokenTypeFilter?: number, burnQuantity?: Big }): Promise<boolean> {",
          "87:         let txid;",
          "88:         if(typeof txn === 'string') {",
          "89:             let txnBuf = Buffer.from(txn,'hex');",
          "90:             txid = Crypto.hash256(txnBuf).toString('hex');",
          "91:             this.cachedRawTransactions.set(txid, txnBuf);",
          "92:         }",
          "93:         else {",
          "94:             txid = Crypto.hash256(txn).toString('hex');",
          "95:             this.cachedRawTransactions.set(txid, txn);",
          "96:         }",
          "98:         let validity = await this.isValidSlpTxid({ txid, tokenIdFilter, tokenTypeFilter });",
          "99:         if(!validity)",
          "100:             return validity;",
          "101:         let validation = this.cachedValidations.get(txid)!;",
          "102:         if(burnQuantity.eq(0)) {",
          "103:             let validInputs: Big;",
          "104:             let outputs: Big;",
          "105:             outputs = validation.details!.sendOutputs!.reduce((p, c) => p.plus(c), Big(0));",
          "106:             validInputs = validation.parents.map(p => p.inputQty ? p.inputQty : Big(0)).reduce((p, c) => p.plus(c), Big(0));",
          "107:             if(!validInputs.eq(outputs) && validation.details!.transactionType === SlpTransactionType.SEND)",
          "108:                 throw Error('SLPJS: Outputs do not match valid inputs');",
          "109:         } else if (burnQuantity.gt(0)) {",
          "110:             let validInputs: Big;",
          "111:             let outputs: Big;",
          "112:             outputs = validation.details!.sendOutputs!.reduce((p, c) => p.plus(c), Big(0));",
          "113:             validInputs = validation.parents.map(p => p.inputQty ? p.inputQty : Big(0)).reduce((p, c) => p.plus(c), Big(0));",
          "114:             if(!validInputs.minus(burnQuantity).eq(outputs) && validation.details!.transactionType === SlpTransactionType.SEND)",
          "115:                 throw Error('SLPJS: Burn amount specified is not properly being burned in the provided transaction.');",
          "116:         }",
          "117:         return validity;",
          "118:     }",
          "120:     async isValidSlpTxid({ txid, tokenIdFilter, tokenTypeFilter }:{ txid: string, tokenIdFilter?: string, tokenTypeFilter?: number }): Promise<boolean> {",
          "121:         this.logger.log(\"SLPJS Validating: \" + txid);",
          "122:         let valid = await this._isValidSlpTxid(txid, tokenIdFilter, tokenTypeFilter);",
          "123:         this.logger.log(\"SLPJS Result: \" + valid + \" (\" + txid + \")\");",
          "124:         if(!valid && this.cachedValidations.get(txid)!.invalidReason)",
          "125:             this.logger.log(\"SLPJS Invalid Reason: \" + this.cachedValidations.get(txid)!.invalidReason);",
          "126:         else if(!valid)",
          "127:             this.logger.log(\"SLPJS Invalid Reason: unknown (result is user supplied)\")",
          "128:         return valid;",
          "129:     }",
          "144:     async _isValidSlpTxid(txid: string, tokenIdFilter?: string, tokenTypeFilter?: number): Promise<boolean> {",
          "146:         if(!this.cachedValidations.has(txid)) {",
          "147:             this.cachedValidations.set(txid, {",
          "148:                 validity: null,",
          "149:                 parents: [],",
          "150:                 details: null,",
          "151:                 invalidReason: null,",
          "152:                 waiting: false",
          "153:             });",
          "154:             await this.retrieveRawTransaction(txid);",
          "155:         }",
          "157:         else if(typeof this.cachedValidations.get(txid)!.validity === 'boolean' && !tokenIdFilter && !tokenTypeFilter) {",
          "158:             return this.cachedValidations.get(txid)!.validity!;",
          "159:         }",
          "169:         if(!this.cachedRawTransactions.get(txid)! || this.cachedRawTransactions.get(txid)! === \"waiting\") {",
          "171:             if(this.cachedRawTransactions.get(txid)! !== \"waiting\")",
          "172:                 this.retrieveRawTransaction(txid);",
          "175:             await this.waitForTransactionDownloadToComplete(txid);",
          "176:         }",
          "178:         let validation = this.cachedValidations.get(txid)!;",
          "179:         let transaction = this.cachedRawTransactions.get(txid)!;",
          "182:         if(validation.waiting) {",
          "183:             await this.waitForCurrentValidationProcessing(txid);",
          "184:             if(typeof validation.validity === 'boolean' && !tokenIdFilter && !tokenTypeFilter) {",
          "185:                 return validation.validity!;",
          "186:             }",
          "187:         }",
          "189:         validation.waiting = true;",
          "192:         let txn: Transaction = Transaction.parseFromBuffer(transaction);",
          "193:         let slpmsg: SlpTransactionDetails;",
          "194:         try {",
          "195:             slpmsg = validation.details = Slp.parseSlpOutputScript(txn.outputs[0].scriptPubKey);",
          "196:             if(slpmsg.transactionType === SlpTransactionType.GENESIS)",
          "197:                 slpmsg.tokenIdHex = txid;",
          "198:         } catch(e) {",
          "199:             validation.validity = false;",
          "200:             validation.waiting = false;",
          "201:             validation.invalidReason = \"SLP OP_RETURN parsing error (\" + e.message + \").\";",
          "202:             return validation.validity!;",
          "203:         }",
          "206:         if(tokenIdFilter && slpmsg.tokenIdHex !== tokenIdFilter) {",
          "207:             validation.waiting = false;",
          "208:             validation.invalidReason = \"Validator was run with filter only considering tokenId \" + tokenIdFilter + \" as valid.\";",
          "209:             return false; // Don't save boolean result to cache incase cache is ever used without tokenIdFilter.",
          "210:         } else {",
          "211:             if(validation.validity !== false)",
          "212:                 validation.invalidReason = null;",
          "213:         }",
          "216:         if(tokenTypeFilter && slpmsg.versionType !== tokenTypeFilter) {",
          "217:             validation.validity = null;",
          "218:             validation.waiting = false;",
          "219:             validation.invalidReason = \"Validator was run with filter only considering token type: \" + tokenTypeFilter + \" as valid.\";",
          "220:             return false; // Don't save boolean result to cache incase cache is ever used with different token type.",
          "221:         } else {",
          "222:             if(validation.validity !== false)",
          "223:                 validation.invalidReason = null;",
          "224:         }",
          "227:         if(slpmsg.transactionType === SlpTransactionType.GENESIS) {",
          "229:             if(slpmsg.versionType === 0x41) {",
          "232:                 let input_txid = txn.inputs[0].previousTxHash;",
          "233:                 let input_txhex = await this.retrieveRawTransaction(input_txid);",
          "234:                 let input_tx: Transaction = Transaction.parseFromBuffer(input_txhex);",
          "235:                 let input_slpmsg;",
          "236:                 try {",
          "237:                     input_slpmsg = Slp.parseSlpOutputScript(input_tx.outputs[0].scriptPubKey);",
          "238:                 } catch(_) { }",
          "239:                 if(!input_slpmsg || input_slpmsg.versionType !== 0x81) {",
          "240:                     validation.validity = false;",
          "241:                     validation.waiting = false;",
          "242:                     validation.invalidReason = \"NFT1 child GENESIS does not have a valid NFT1 parent input.\";",
          "243:                     return validation.validity!;",
          "244:                 }",
          "246:                 if(input_slpmsg.transactionType === SlpTransactionType.SEND &&",
          "247:                     (!input_slpmsg.sendOutputs![1].gt(0)))",
          "248:                 {",
          "249:                     validation.validity = false;",
          "250:                     validation.waiting = false;",
          "251:                     validation.invalidReason = \"NFT1 child's parent has SLP output that is not greater than zero.\";",
          "252:                     return validation.validity!;",
          "253:                 } else if((input_slpmsg.transactionType === SlpTransactionType.GENESIS ||",
          "254:                             input_slpmsg.transactionType === SlpTransactionType.MINT) &&",
          "255:                             !input_slpmsg.genesisOrMintQuantity!.gt(0))",
          "256:                 {",
          "257:                     validation.validity = false;",
          "258:                     validation.waiting = false;",
          "259:                     validation.invalidReason = \"NFT1 child's parent has SLP output that is not greater than zero.\";",
          "260:                     return validation.validity!;",
          "261:                 }",
          "263:                 let nft_parent_dag_validity = await this.isValidSlpTxid({txid: input_txid, tokenIdFilter: undefined, tokenTypeFilter: 0x81 });",
          "264:                 validation.validity = nft_parent_dag_validity;",
          "265:                 validation.waiting = false;",
          "266:                 if(!nft_parent_dag_validity) {",
          "267:                     validation.invalidReason = \"NFT1 child GENESIS does not have valid parent DAG.\"",
          "268:                 }",
          "269:                 return validation.validity!;",
          "270:             }",
          "273:             else {",
          "274:                 validation.validity = true;",
          "275:                 validation.waiting = false;",
          "276:                 return validation.validity!;",
          "277:             }",
          "278:         }",
          "279:         else if (slpmsg.transactionType === SlpTransactionType.MINT) {",
          "280:             for(let i = 0; i < txn.inputs.length; i++) {",
          "281:                 let input_txid = txn.inputs[i].previousTxHash;",
          "282:                 let input_txhex = await this.retrieveRawTransaction(input_txid);",
          "283:                 let input_tx: Transaction = Transaction.parseFromBuffer(input_txhex);",
          "284:                 try {",
          "285:                     let input_slpmsg = Slp.parseSlpOutputScript(input_tx.outputs[0].scriptPubKey);",
          "286:                     if(input_slpmsg.transactionType === SlpTransactionType.GENESIS)",
          "287:                         input_slpmsg.tokenIdHex = input_txid;",
          "288:                     if(input_slpmsg.tokenIdHex === slpmsg.tokenIdHex) {",
          "289:                         if(input_slpmsg.transactionType === SlpTransactionType.GENESIS || input_slpmsg.transactionType === SlpTransactionType.MINT) {",
          "290:                             if(txn.inputs[i].previousTxOutIndex === input_slpmsg.batonVout) {",
          "291:                                 validation.parents.push({",
          "292:                                     txid: txn.inputs[i].previousTxHash,",
          "293:                                     vout: txn.inputs[i].previousTxOutIndex,",
          "294:                                     versionType: input_slpmsg.versionType,",
          "295:                                     valid: null,",
          "296:                                     inputQty: null",
          "297:                                 })",
          "298:                             }",
          "299:                         }",
          "300:                     }",
          "301:                 } catch(_) {}",
          "302:             }",
          "303:             if(validation.parents.length !== 1) {",
          "304:                 validation.validity = false;",
          "305:                 validation.waiting = false;",
          "306:                 validation.invalidReason = \"MINT transaction must have 1 valid baton parent.\"",
          "307:                 return validation.validity!;",
          "308:             }",
          "309:         }",
          "310:         else if(slpmsg.transactionType === SlpTransactionType.SEND) {",
          "311:             let tokenOutQty = slpmsg.sendOutputs!.reduce((t,v)=>{ return t.plus(v) }, new Big(0))",
          "312:             let tokenInQty = new Big(0);",
          "313:             for(let i = 0; i < txn.inputs.length; i++) {",
          "314:                 let input_txid = txn.inputs[i].previousTxHash;",
          "315:                 let input_txhex = await this.retrieveRawTransaction(input_txid);",
          "316:                 let input_tx: Transaction = Transaction.parseFromBuffer(input_txhex);",
          "317:                 try {",
          "318:                     let input_slpmsg = Slp.parseSlpOutputScript(input_tx.outputs[0].scriptPubKey)",
          "319:                     if(input_slpmsg.transactionType === SlpTransactionType.GENESIS)",
          "320:                         input_slpmsg.tokenIdHex = input_txid;",
          "321:                     if(input_slpmsg.tokenIdHex === slpmsg.tokenIdHex) {",
          "322:                         if(input_slpmsg.transactionType === SlpTransactionType.SEND) {",
          "323:                             if(txn.inputs[i].previousTxOutIndex <= input_slpmsg.sendOutputs!.length-1) {",
          "324:                                 tokenInQty = tokenInQty.plus(input_slpmsg.sendOutputs![txn.inputs[i].previousTxOutIndex])",
          "325:                                 validation.parents.push({",
          "326:                                     txid: txn.inputs[i].previousTxHash,",
          "327:                                     vout: txn.inputs[i].previousTxOutIndex,",
          "328:                                     versionType: input_slpmsg.versionType,",
          "329:                                     valid: null,",
          "330:                                     inputQty: input_slpmsg.sendOutputs![txn.inputs[i].previousTxOutIndex]",
          "331:                                 })",
          "332:                             }",
          "333:                         }",
          "334:                         else if(input_slpmsg.transactionType === SlpTransactionType.GENESIS || input_slpmsg.transactionType === SlpTransactionType.MINT) {",
          "335:                             if(txn.inputs[i].previousTxOutIndex === 1) {",
          "336:                                 tokenInQty = tokenInQty.plus(input_slpmsg.genesisOrMintQuantity!)",
          "337:                                 validation.parents.push({",
          "338:                                     txid: txn.inputs[i].previousTxHash,",
          "339:                                     vout: txn.inputs[i].previousTxOutIndex,",
          "340:                                     versionType: input_slpmsg.versionType,",
          "341:                                     valid: null,",
          "342:                                     inputQty: input_slpmsg.genesisOrMintQuantity",
          "343:                                 })",
          "344:                             }",
          "345:                         }",
          "346:                     }",
          "347:                 } catch(_) {}",
          "348:             }",
          "351:             if(tokenOutQty.gt(tokenInQty)) {",
          "352:                 validation.validity = false;",
          "353:                 validation.waiting = false;",
          "354:                 validation.invalidReason = \"Token outputs are greater than possible token inputs.\"",
          "355:                 return validation.validity!;",
          "356:             }",
          "357:         }",
          "361:         let parentTxids = [...new Set(validation.parents.map(p => p.txid))];",
          "362:         for(let i = 0; i < parentTxids.length; i++) {",
          "363:             let valid = await this.isValidSlpTxid({ txid: parentTxids[i] })",
          "364:             validation.parents.filter(p => p.txid === parentTxids[i]).map(p => p.valid = valid);",
          "365:             if(validation.details!.transactionType === SlpTransactionType.MINT && !valid) {",
          "366:                 validation.validity = false;",
          "367:                 validation.waiting = false;",
          "368:                 validation.invalidReason = \"MINT transaction with invalid baton parent.\"",
          "369:                 return validation.validity!;",
          "370:             }",
          "371:         }",
          "374:         if(validation.details!.transactionType === SlpTransactionType.SEND) {",
          "375:             let validInputQty = validation.parents.reduce((t, v) => { return v.valid ? t.plus(v.inputQty!) : t }, new Big(0));",
          "376:             let tokenOutQty = slpmsg.sendOutputs!.reduce((t,v)=>{ return t.plus(v) }, new Big(0))",
          "377:             if(tokenOutQty.gt(validInputQty)) {",
          "378:                 validation.validity = false;",
          "379:                 validation.waiting = false;",
          "380:                 validation.invalidReason = \"Token outputs are greater than valid token inputs.\"",
          "381:                 return validation.validity!;",
          "382:             }",
          "383:         }",
          "386:         if(validation.parents.filter(p => p.valid).length > 0) {",
          "387:             let validVersionType = validation.parents.find(p => p.valid!)!.versionType;",
          "388:             if(validation.details!.versionType !== validVersionType) {",
          "389:                 validation.validity = false;",
          "390:                 validation.waiting = false;",
          "391:                 validation.invalidReason = \"SLP version/type mismatch from valid parent.\"",
          "392:                 return validation.validity!;",
          "393:             }",
          "394:         }",
          "395:         validation.validity = true;",
          "396:         validation.waiting = false;",
          "397:         return validation.validity!;",
          "398:     }",
          "400:     async validateSlpTransactions(txids: string[]): Promise<string[]> {",
          "401:         let res = [];",
          "402:         for (let i = 0; i < txids.length; i++) {",
          "403:             res.push((await this.isValidSlpTxid({ txid: txids[i] })) ? txids[i] : '')",
          "404:         }",
          "405:         return res.filter((id: string) => id.length > 0);",
          "406:     }",
          "407: }",
          "409: class MapCache<T, M> {",
          "410:     private map = new Map<T, M>()",
          "411:     private list: T[] = [];",
          "412:     private maxSize: number;",
          "414:     constructor(maxSize: number) {",
          "415:         this.maxSize = maxSize;",
          "416:     }",
          "418:     get length(): number {",
          "419:         return this.list.length;",
          "420:     }",
          "422:     set(key: T, item: M) {",
          "423:         this.list.push(key);",
          "424:         this.map.set(key, item);",
          "425:         if(this.map.size > this.maxSize) {",
          "426:             this.shift();",
          "427:         }",
          "428:     }",
          "430:     get(key: T) {",
          "431:         return this.map.get(key);",
          "432:     }",
          "434:     has(key: T) {",
          "435:         return this.map.has(key);",
          "436:     }",
          "438:     private shift(): T | undefined {",
          "439:         let key = this.list.shift();",
          "440:         if(key)",
          "441:             this.map.delete(key);",
          "442:         return key;",
          "443:     }",
          "445:     clear() {",
          "446:         this.list = [];",
          "447:         this.map.clear();",
          "448:     }",
          "449: }",
          "",
          "---------------"
        ],
        "test/slp.ts||test/slp.ts": [
          "File: test/slp.ts -> test/slp.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import { Slp } from '../lib/slp';",
          "2: import assert from 'assert';",
          "4: const scriptUnitTestData = require('slp-unit-test-data/script_tests.json');",
          "6: describe('Slp', function() {",
          "8:     describe('parseSlpOutputScript() -- SLP OP_RETURN Unit Tests', function() {",
          "9:         scriptUnitTestData.forEach((test: any)=> {",
          "10:             it(test.msg, () => {",
          "11:                 let script = Buffer.from(test.script, 'hex');",
          "12:                 let eCode = test.code;",
          "13:                 if(eCode) {",
          "14:                     assert.throws(function() { Slp.parseSlpOutputScript(script) });",
          "15:                 } else {",
          "16:                     let parsedOutput = Slp.parseSlpOutputScript(script);",
          "17:                     assert(typeof parsedOutput, 'object');",
          "18:                 }",
          "19:             });",
          "20:         });",
          "21:     });",
          "22: });",
          "",
          "---------------"
        ],
        "test/validation.ts||test/validation.ts": [
          "File: test/validation.ts -> test/validation.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import { ValidatorType1, GetRawTransactionAsync } from '../lib/validation';",
          "2: import {Crypto } from '../lib/crypto';",
          "4: import * as assert from 'assert';",
          "5: import \"mocha\";",
          "7: const txUnitTestData: SlpValidityUnitTest[] = require('slp-unit-test-data/tx_input_tests.json');",
          "9: describe('Slp', function() {",
          "10:     describe('isValidSlpTxid() -- SLP Transaction Validation Unit Tests', function() {",
          "11:         txUnitTestData.forEach(test => {",
          "12:             it(test.description, async () => {",
          "15:                 let getRawUnitTestTransaction: GetRawTransactionAsync = async (txid: string) => {",
          "16:                     let allTxns: SlpTestTxn[] = test.when.concat(test.should);",
          "17:                     let txn = allTxns.find(i => {",
          "18:                         let hash = Crypto.hash256(Buffer.from(i.tx, 'hex')).toString('hex');",
          "19:                         return hash === txid",
          "20:                     });",
          "21:                     if(txn)",
          "22:                         return txn.tx;",
          "23:                     throw Error(\"Transaction data for the provided txid not found (txid: \" + txid + \")\")",
          "24:                 }",
          "27:                 var slpValidator = new ValidatorType1({ getRawTransaction: getRawUnitTestTransaction });",
          "30:                 test.when.forEach(w => {",
          "31:                     slpValidator.addValidationFromStore(w.tx, w.valid)",
          "32:                 });",
          "34:                 let txid = Crypto.hash256(Buffer.from(test.should[0].tx, 'hex')).toString('hex');",
          "35:                 let shouldBeValid = test.should[0].valid;",
          "36:                 let isValid = await slpValidator.isValidSlpTxid({ txid });",
          "37:                 if(isValid === false)",
          "38:                     console.log('invalid reason:', slpValidator.cachedValidations.get(txid)!.invalidReason);",
          "39:                 assert.equal(isValid, shouldBeValid);",
          "40:             });",
          "41:         })",
          "42:     });",
          "43: });",
          "45: interface SlpValidityUnitTest {",
          "46:     description: string;",
          "47:     when: SlpTestTxn[]",
          "48:     should: SlpTestTxn[]",
          "49: }",
          "51: interface SlpTestTxn {",
          "52:     tx: string, valid: boolean",
          "53: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8af9e2d5ad1a9c9f57ee3a3a30bce7d7222a4fcc",
      "candidate_info": {
        "commit_hash": "8af9e2d5ad1a9c9f57ee3a3a30bce7d7222a4fcc",
        "repo": "simpleledger/slp-validate",
        "commit_url": "https://github.com/simpleledger/slp-validate/commit/8af9e2d5ad1a9c9f57ee3a3a30bce7d7222a4fcc",
        "files": [
          "lib/cachemap.ts",
          "lib/interfaces.ts",
          "lib/script.ts",
          "lib/transaction.ts",
          "lib/validation.ts",
          "test/validation.ts"
        ],
        "message": "more linting",
        "before_after_code_files": [
          "lib/cachemap.ts||lib/cachemap.ts",
          "lib/interfaces.ts||lib/interfaces.ts",
          "lib/script.ts||lib/script.ts",
          "lib/transaction.ts||lib/transaction.ts",
          "lib/validation.ts||lib/validation.ts",
          "test/validation.ts||test/validation.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/validation.ts||lib/validation.ts"
          ],
          "candidate": [
            "lib/validation.ts||lib/validation.ts"
          ]
        }
      },
      "candidate_diff": {
        "lib/cachemap.ts||lib/cachemap.ts": [
          "File: lib/cachemap.ts -> lib/cachemap.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: export class CacheMap<T, M> {",
          "2:     private map = new Map<T, M>();",
          "3:     private list: T[] = [];",
          "4:     private maxSize: number;",
          "5:     constructor(maxSize: number) {",
          "6:         this.maxSize = maxSize;",
          "7:     }",
          "8:     get length(): number {",
          "9:         return this.list.length;",
          "10:     }",
          "11:     public set(key: T, item: M) {",
          "12:         this.list.push(key);",
          "13:         this.map.set(key, item);",
          "14:         if (this.map.size > this.maxSize) {",
          "15:             this.shift();",
          "16:         }",
          "17:     }",
          "18:     public get(key: T) {",
          "19:         return this.map.get(key);",
          "20:     }",
          "21:     public has(key: T) {",
          "22:         return this.map.has(key);",
          "23:     }",
          "24:     private shift(): T | undefined {",
          "25:         const key = this.list.shift();",
          "26:         if (key) {",
          "27:             this.map.delete(key);",
          "28:         }",
          "29:         return key;",
          "30:     }",
          "31:     public clear() {",
          "32:         this.list = [];",
          "33:         this.map.clear();",
          "34:     }",
          "35: }",
          "",
          "---------------"
        ],
        "lib/interfaces.ts||lib/interfaces.ts": [
          "File: lib/interfaces.ts -> lib/interfaces.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import Big from \"big.js\";",
          "2: export interface IValidSlpTxnParams {",
          "3:     txn: string | Buffer;",
          "4:     tokenIdFilter?: string;",
          "5:     tokenTypeFilter?: number;",
          "6:     burnQuantity?: Big;",
          "7: }",
          "8: export interface IValidSlpTxidParams {",
          "9:     txid: string;",
          "10:     tokenIdFilter?: string;",
          "11:     tokenTypeFilter?: number;",
          "12: }",
          "",
          "---------------"
        ],
        "lib/script.ts||lib/script.ts": [
          "File: lib/script.ts -> lib/script.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: export class Script {",
          "3:         OP_0: 0,",
          "4:         OP_16: 96,",
          "5:         OP_PUSHDATA1: 76,",
          "",
          "[Removed Lines]",
          "2:     static opcodes = {",
          "",
          "[Added Lines]",
          "2:     public static opcodes = {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7:         OP_PUSHDATA4: 78,",
          "8:         OP_1NEGATE: 79,",
          "9:         OP_RETURN: 106,",
          "",
          "[Removed Lines]",
          "10:     }",
          "11: }",
          "",
          "[Added Lines]",
          "11: }",
          "",
          "---------------"
        ],
        "lib/transaction.ts||lib/transaction.ts": [
          "File: lib/transaction.ts -> lib/transaction.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: export class Transaction {",
          "16:         return Transaction.parse(stream);",
          "17:     }",
          "21:         transaction.version = stream.readInt(4);",
          "23:         var txInNum = stream.readVarInt();",
          "26:                 previousTxHash: stream.readHexBytes(32),",
          "27:                 previousTxOutIndex: stream.readInt(4),",
          "28:                 scriptSig: Buffer.from(stream.readString()),",
          "29:                 sequenceNo: stream.readHexBytes(4),",
          "32:             transaction.inputs.push(input);",
          "33:         }",
          "37:             transaction.outputs.push({",
          "38:                 value: stream.readInt(8),",
          "40:             });",
          "41:         }",
          "43:         transaction.lockTime = stream.readInt(4);",
          "45:         return transaction;",
          "46:     }",
          "47: }",
          "49: export interface TransactionInput {",
          "55: }",
          "57: export interface TransactionOutput {",
          "",
          "[Removed Lines]",
          "2:     version: number;",
          "3:     inputs: TransactionInput[];",
          "4:     outputs: TransactionOutput[];",
          "5:     lockTime: number;",
          "6:     constructor(version?: number, inputs?: TransactionInput[], outputs?: any[], lockTime?: number) {",
          "7:         this.version = version || 1;",
          "8:         this.inputs = inputs || [];",
          "9:         this.outputs = outputs || [];",
          "10:         this.lockTime = lockTime || 0;",
          "11:     }",
          "13:     static parseFromBuffer(buffer: Buffer) {",
          "14:         let source = new Primatives.ArraySource(buffer.toJSON().data)",
          "15:         let stream = new Primatives.ByteStream(source);",
          "19:     static parse(stream: Primatives.ByteStream) {",
          "20:         var transaction = new Transaction();",
          "24:         for (var i = 0; i < txInNum; i++) {",
          "25:             let input: TransactionInput = {",
          "30:             }",
          "35:         var txOutNum = stream.readVarInt();",
          "36:         for (var i = 0; i < txOutNum; i++) {",
          "39:                 scriptPubKey: Buffer.from(stream.readString())",
          "50:     previousTxHash: string,",
          "51:     previousTxOutIndex: number,",
          "52:     scriptSig: Buffer,",
          "53:     sequenceNo: string,",
          "54:     satoshis?: number",
          "",
          "[Added Lines]",
          "2:     public static parseFromBuffer(buffer: Buffer) {",
          "3:         const source = new Primatives.ArraySource(buffer.toJSON().data);",
          "4:         const stream = new Primatives.ByteStream(source);",
          "8:     public static parse(stream: Primatives.ByteStream) {",
          "9:         const transaction = new Transaction();",
          "13:         for (let i = 0; i < txInNum; i++) {",
          "14:             const input: TransactionInput = {",
          "19:             };",
          "24:         const txOutNum = stream.readVarInt();",
          "25:         for (let i = 0; i < txOutNum; i++) {",
          "29:                 scriptPubKey: Buffer.from(stream.readString()),",
          "36:     public version: number;",
          "37:     public inputs: TransactionInput[];",
          "38:     public outputs: TransactionOutput[];",
          "39:     public lockTime: number;",
          "40:     constructor(version?: number, inputs?: TransactionInput[], outputs?: any[], lockTime?: number) {",
          "41:         this.version = version || 1;",
          "42:         this.inputs = inputs || [];",
          "43:         this.outputs = outputs || [];",
          "44:         this.lockTime = lockTime || 0;",
          "45:     }",
          "49:     previousTxHash: string;",
          "50:     previousTxOutIndex: number;",
          "51:     scriptSig: Buffer;",
          "52:     sequenceNo: string;",
          "53:     satoshis?: number;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62: export namespace Primatives {",
          "63:     class Hex {",
          "65:             return text.match(/.{2}/g)!.map(function(byte) {",
          "66:                 return parseInt(byte, 16);",
          "67:             });",
          "68:         }",
          "72:                 hex = bytes[i].toString(16);",
          "73:                 if (hex.length < 2) {",
          "74:                     hex = '0' + hex;",
          "",
          "[Removed Lines]",
          "64:         static decode(text: string) {",
          "69:         static encode(bytes: number[]) {",
          "70:             var result = [];",
          "71:             for (var i = 0, hex; i < bytes.length; i++) {",
          "",
          "[Added Lines]",
          "63:         public static decode(text: string) {",
          "68:         public static encode(bytes: number[]) {",
          "69:             const result = [];",
          "70:             for (let i = 0, hex; i < bytes.length; i++) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "78:             return result.join('');",
          "79:         }",
          "80:     };",
          "82:     class LittleEndian {",
          "84:             return bytes.reduce(function(previous, current, index) {",
          "85:                 return previous + current * Math.pow(256, index);",
          "86:             }, 0);",
          "87:         }",
          "91:                 rawBytes[i] = number & 0xff;",
          "92:                 number = Math.floor(number / 256);",
          "93:             }",
          "94:             return rawBytes;",
          "95:         }",
          "96:     };",
          "98:     export class ArraySource {",
          "101:         constructor(rawBytes: number[], index?: number) {",
          "102:             this.rawBytes = rawBytes;",
          "103:             this.index = index || 0;",
          "104:         }",
          "106:             if (!this.hasMoreBytes()) {",
          "107:                 throw new Error('Cannot read past the end of the array.');",
          "108:             }",
          "109:             return this.rawBytes[this.index++];",
          "110:         }",
          "112:             return this.index < this.rawBytes.length;",
          "113:         }",
          "115:             return this.index;",
          "116:         }",
          "117:     }",
          "119:     export class ByteStream {",
          "121:         constructor(source: ArraySource){",
          "122:             this.source = source;",
          "123:         }",
          "125:             return this.source.readByte();",
          "126:         }",
          "130:                 bytes.push(this.readByte());",
          "131:             }",
          "132:             return bytes;",
          "133:         }",
          "136:             return LittleEndian.decode(bytes);",
          "137:         }",
          "140:             if (num < 0xfd) {",
          "141:                 return num;",
          "142:             } else if (num === 0xfd) {",
          "",
          "[Removed Lines]",
          "83:         static decode(bytes: number[]) {",
          "88:         static encode(number: number, count: number) {",
          "89:             var rawBytes = [];",
          "90:             for (var i = 0; i < count; i++) {",
          "99:         rawBytes: number[];",
          "100:         index: number;",
          "105:         readByte() {",
          "111:         hasMoreBytes() {",
          "114:         getPosition() {",
          "120:         source: ArraySource;",
          "124:         readByte() {",
          "127:         readBytes(num: number) {",
          "128:             var bytes = [];",
          "129:             for (var i = 0; i < num; i++) {",
          "134:         readInt(num: number) {",
          "135:             var bytes = this.readBytes(num);",
          "138:         readVarInt() {",
          "139:             var num = this.readByte();",
          "",
          "[Added Lines]",
          "82:         public static decode(bytes: number[]) {",
          "87:         public static encode(number: number, count: number) {",
          "88:             const rawBytes = [];",
          "89:             for (let i = 0; i < count; i++) {",
          "98:         public rawBytes: number[];",
          "99:         public index: number;",
          "104:         public readByte() {",
          "110:         public hasMoreBytes() {",
          "113:         public getPosition() {",
          "119:         public source: ArraySource;",
          "123:         public readByte() {",
          "126:         public readBytes(num: number) {",
          "127:             const bytes = [];",
          "128:             for (let i = 0; i < num; i++) {",
          "133:         public readInt(num: number) {",
          "134:             const bytes = this.readBytes(num);",
          "137:         public readVarInt() {",
          "138:             const num = this.readByte();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "147:                 return this.readInt(8);",
          "148:             }",
          "149:         }",
          "152:             return this.readBytes(length);",
          "153:         }",
          "156:             return Hex.encode(bytes.reverse());",
          "157:         }",
          "159:             return this.source.hasMoreBytes();",
          "160:         }",
          "162:             return this.source.getPosition();",
          "163:         }",
          "164:     }",
          "",
          "[Removed Lines]",
          "150:         readString() {",
          "151:             var length = this.readVarInt();",
          "154:         readHexBytes(num: number) {",
          "155:             var bytes = this.readBytes(num);",
          "158:         hasMoreBytes() {",
          "161:         getPosition() {",
          "",
          "[Added Lines]",
          "149:         public readString() {",
          "150:             const length = this.readVarInt();",
          "153:         public readHexBytes(num: number) {",
          "154:             const bytes = this.readBytes(num);",
          "157:         public hasMoreBytes() {",
          "160:         public getPosition() {",
          "",
          "---------------"
        ],
        "lib/validation.ts||lib/validation.ts": [
          "File: lib/validation.ts -> lib/validation.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: export type GetRawTransactionAsync = (txid: string) => Promise<string|Buffer>;",
          "12: interface Parent {",
          "13:     txid: string;",
          "",
          "[Removed Lines]",
          "1: import { Crypto } from './crypto';",
          "2: import { Transaction } from './transaction';",
          "3: import { SlpTransactionType, SlpTransactionDetails, Slp } from './slp';",
          "5: import Big from 'big.js';",
          "7: export interface Validation { validity: boolean|null; parents: Parent[], details: SlpTransactionDetails|null, invalidReason: string|null, waiting: boolean }",
          "10: const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))",
          "",
          "[Added Lines]",
          "1: import Big from \"big.js\";",
          "2: import { CacheMap } from \"./cachemap\";",
          "3: import { Crypto } from \"./crypto\";",
          "4: import { IValidSlpTxidParams, IValidSlpTxnParams } from \"./interfaces\";",
          "5: import { Slp, SlpTransactionDetails, SlpTransactionType } from \"./slp\";",
          "6: import { Transaction } from \"./transaction\";",
          "8: export interface Validation {",
          "9:     validity: boolean|null;",
          "10:     parents: Parent[];",
          "11:     details: SlpTransactionDetails|null;",
          "12:     invalidReason: string|null;",
          "13:     waiting: boolean;",
          "14: }",
          "18: const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "18: }",
          "20: export class ValidatorType1 {",
          "29:         this.logger = logger;",
          "30:         this.getRawTransaction = getRawTransaction;",
          "33:     }",
          "41:     }",
          "47:             throw Error(\"txid is missing from cachedValidations.\")",
          "51:                 cached.waiting = false;",
          "52:                 break;",
          "53:             }",
          "",
          "[Removed Lines]",
          "21:     cachedRawTransactions: MapCache<string, Buffer>; //{ [txid: string]: Buffer }",
          "22:     cachedValidations: MapCache<string, Validation>; //{ [txid: string]: Validation }",
          "23:     getRawTransaction: GetRawTransactionAsync;",
          "24:     logger: { log: (s: string)=> any };",
          "26:     constructor({ getRawTransaction, logger=console, maxTransactionCacheSize=100000, maxValidationCacheSize=100000 }: { getRawTransaction: GetRawTransactionAsync, logger?: { log: (s: string)=> any }, maxTransactionCacheSize?: number, maxValidationCacheSize?: number }) {",
          "27:         if(!getRawTransaction)",
          "28:             throw Error(\"Must provide method getRawTransaction to class constructor.\")",
          "31:         this.cachedValidations = new MapCache<string, Validation>(maxValidationCacheSize);",
          "32:         this.cachedRawTransactions = new MapCache<string, Buffer>(maxTransactionCacheSize);",
          "35:     addValidationFromStore(hex: string, isValid: boolean) {",
          "36:         let id = Crypto.hash256(Buffer.from(hex, 'hex')).toString('hex');",
          "37:         if(!this.cachedValidations.has(id))",
          "38:             this.cachedValidations.set(id, { validity: isValid, parents: [], details: null, invalidReason: null, waiting: false })",
          "39:         if(!this.cachedRawTransactions.has(id))",
          "40:             this.cachedRawTransactions.set(id, Buffer.from(hex, 'hex'));",
          "43:     async waitForCurrentValidationProcessing(txid: string) {",
          "44:         let cached: Validation = this.cachedValidations.get(txid)!;",
          "46:         if(!cached)",
          "49:         while(true) {",
          "50:             if(typeof cached.validity === 'boolean') {",
          "",
          "[Added Lines]",
          "29:     public cachedRawTransactions: CacheMap<string, Buffer>; // { [txid: string]: Buffer }",
          "30:     public cachedValidations: CacheMap<string, Validation>; // { [txid: string]: Validation }",
          "31:     public getRawTransaction: GetRawTransactionAsync;",
          "32:     public logger: { log: (s: string) => any };",
          "34:     constructor({ getRawTransaction, logger= console, maxTransactionCacheSize= 100000,",
          "35:                 maxValidationCacheSize= 100000 }: { getRawTransaction: GetRawTransactionAsync, logger?:",
          "36:                     { log: (s: string) => any }, maxTransactionCacheSize?: number, maxValidationCacheSize?: number }) {",
          "37:         if (!getRawTransaction) {",
          "38:             throw Error(\"Must provide method getRawTransaction to class constructor.\");",
          "39:         }",
          "42:         this.cachedValidations = new CacheMap<string, Validation>(maxValidationCacheSize);",
          "43:         this.cachedRawTransactions = new CacheMap<string, Buffer>(maxTransactionCacheSize);",
          "46:     public addValidationFromStore(hex: string, isValid: boolean) {",
          "47:         const id = Crypto.hash256(Buffer.from(hex, \"hex\")).toString(\"hex\");",
          "48:         if (!this.cachedValidations.has(id)) {",
          "49:             this.cachedValidations.set(id,",
          "50:                 { validity: isValid, parents: [], details: null, invalidReason: null, waiting: false });",
          "51:         }",
          "52:         if (!this.cachedRawTransactions.has(id)) {",
          "53:             this.cachedRawTransactions.set(id, Buffer.from(hex, \"hex\"));",
          "54:         }",
          "57:     public async waitForCurrentValidationProcessing(txid: string) {",
          "58:         const cached: Validation = this.cachedValidations.get(txid)!;",
          "60:         if (!cached) {",
          "62:         }",
          "64:         while (true) {",
          "65:             if (typeof cached.validity === \"boolean\") {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "55:         }",
          "56:     }",
          "62:                 break;",
          "63:             }",
          "64:             await sleep(10);",
          "65:         }",
          "66:     }",
          "70:             return this.cachedRawTransactions.get(txid)!;",
          "72:         this.cachedRawTransactions.set(txid, \"waiting\");",
          "77:             this.cachedRawTransactions.set(txid, res);",
          "80:                 throw Error(\"Valid transaction data not provided.\")",
          "81:             return this.cachedRawTransactions.get(txid)!;",
          "82:         }",
          "83:         throw Error(\"Transaction data not provided (null or undefined).\")",
          "84:     }",
          "87:         let txid;",
          "91:             this.cachedRawTransactions.set(txid, txnBuf);",
          "95:             this.cachedRawTransactions.set(txid, txn);",
          "96:         }",
          "100:             return validity;",
          "103:             let validInputs: Big;",
          "104:             let outputs: Big;",
          "105:             outputs = validation.details!.sendOutputs!.reduce((p, c) => p.plus(c), Big(0));",
          "109:         } else if (burnQuantity.gt(0)) {",
          "110:             let validInputs: Big;",
          "111:             let outputs: Big;",
          "112:             outputs = validation.details!.sendOutputs!.reduce((p, c) => p.plus(c), Big(0));",
          "116:         }",
          "117:         return validity;",
          "118:     }",
          "128:         return valid;",
          "129:     }",
          "144:     async _isValidSlpTxid(txid: string, tokenIdFilter?: string, tokenTypeFilter?: number): Promise<boolean> {",
          "153:             });",
          "154:             await this.retrieveRawTransaction(txid);",
          "158:             return this.cachedValidations.get(txid)!.validity!;",
          "159:         }",
          "",
          "[Removed Lines]",
          "58:     async waitForTransactionDownloadToComplete(txid: string){",
          "59:         while(true) {",
          "61:             if(this.cachedRawTransactions.get(txid)! && this.cachedRawTransactions.get(txid)! !== \"waiting\") {",
          "68:     async retrieveRawTransaction(txid: string) {",
          "69:         if(this.cachedRawTransactions.has(txid))",
          "73:         let res = await this.getRawTransaction(txid);",
          "74:         if(typeof res === \"string\")",
          "75:             this.cachedRawTransactions.set(txid, Buffer.from(res, 'hex'));",
          "76:         else",
          "78:         if(this.cachedRawTransactions.has(txid)) {",
          "79:             if(this.cachedRawTransactions.get(txid)!.length < 60)",
          "86:     async isValidSlpTxn({ txn, tokenIdFilter, tokenTypeFilter, burnQuantity=Big(0) }: { txn: string|Buffer, tokenIdFilter?: string, tokenTypeFilter?: number, burnQuantity?: Big }): Promise<boolean> {",
          "88:         if(typeof txn === 'string') {",
          "89:             let txnBuf = Buffer.from(txn,'hex');",
          "90:             txid = Crypto.hash256(txnBuf).toString('hex');",
          "92:         }",
          "93:         else {",
          "94:             txid = Crypto.hash256(txn).toString('hex');",
          "98:         let validity = await this.isValidSlpTxid({ txid, tokenIdFilter, tokenTypeFilter });",
          "99:         if(!validity)",
          "101:         let validation = this.cachedValidations.get(txid)!;",
          "102:         if(burnQuantity.eq(0)) {",
          "106:             validInputs = validation.parents.map(p => p.inputQty ? p.inputQty : Big(0)).reduce((p, c) => p.plus(c), Big(0));",
          "107:             if(!validInputs.eq(outputs) && validation.details!.transactionType === SlpTransactionType.SEND)",
          "108:                 throw Error('SLPJS: Outputs do not match valid inputs');",
          "113:             validInputs = validation.parents.map(p => p.inputQty ? p.inputQty : Big(0)).reduce((p, c) => p.plus(c), Big(0));",
          "114:             if(!validInputs.minus(burnQuantity).eq(outputs) && validation.details!.transactionType === SlpTransactionType.SEND)",
          "115:                 throw Error('SLPJS: Burn amount specified is not properly being burned in the provided transaction.');",
          "120:     async isValidSlpTxid({ txid, tokenIdFilter, tokenTypeFilter }:{ txid: string, tokenIdFilter?: string, tokenTypeFilter?: number }): Promise<boolean> {",
          "121:         this.logger.log(\"SLPJS Validating: \" + txid);",
          "122:         let valid = await this._isValidSlpTxid(txid, tokenIdFilter, tokenTypeFilter);",
          "123:         this.logger.log(\"SLPJS Result: \" + valid + \" (\" + txid + \")\");",
          "124:         if(!valid && this.cachedValidations.get(txid)!.invalidReason)",
          "125:             this.logger.log(\"SLPJS Invalid Reason: \" + this.cachedValidations.get(txid)!.invalidReason);",
          "126:         else if(!valid)",
          "127:             this.logger.log(\"SLPJS Invalid Reason: unknown (result is user supplied)\")",
          "146:         if(!this.cachedValidations.has(txid)) {",
          "147:             this.cachedValidations.set(txid, {",
          "148:                 validity: null,",
          "149:                 parents: [],",
          "150:                 details: null,",
          "151:                 invalidReason: null,",
          "152:                 waiting: false",
          "155:         }",
          "157:         else if(typeof this.cachedValidations.get(txid)!.validity === 'boolean' && !tokenIdFilter && !tokenTypeFilter) {",
          "",
          "[Added Lines]",
          "73:     public async waitForTransactionDownloadToComplete(txid: string) {",
          "74:         while (true) {",
          "76:             if (this.cachedRawTransactions.get(txid)! && this.cachedRawTransactions.get(txid)! !== \"waiting\") {",
          "83:     public async retrieveRawTransaction(txid: string) {",
          "84:         if (this.cachedRawTransactions.has(txid)) {",
          "86:         }",
          "89:         const res = await this.getRawTransaction(txid);",
          "90:         if (typeof res === \"string\") {",
          "91:             this.cachedRawTransactions.set(txid, Buffer.from(res, \"hex\"));",
          "92:         } else {",
          "94:         }",
          "95:         if (this.cachedRawTransactions.has(txid)) {",
          "96:             if (this.cachedRawTransactions.get(txid)!.length < 60) {",
          "98:             }",
          "104:     public async isValidSlpTxn(",
          "105:         { txn, tokenIdFilter, tokenTypeFilter, burnQuantity= Big(0) }: IValidSlpTxnParams): Promise<boolean> {",
          "107:         if (typeof txn === \"string\") {",
          "108:             const txnBuf = Buffer.from(txn, \"hex\");",
          "109:             txid = Crypto.hash256(txnBuf).toString(\"hex\");",
          "111:         } else {",
          "112:             txid = Crypto.hash256(txn).toString(\"hex\");",
          "116:         const validity = await this.isValidSlpTxid({ txid, tokenIdFilter, tokenTypeFilter });",
          "117:         if (!validity) {",
          "119:         }",
          "120:         const validation = this.cachedValidations.get(txid)!;",
          "121:         if (burnQuantity.eq(0)) {",
          "125:             validInputs = validation.parents.map(p =>",
          "126:                 p.inputQty ? p.inputQty : Big(0)).reduce((p, c) => p.plus(c), Big(0));",
          "127:             if (!validInputs.eq(outputs) && validation.details!.transactionType === SlpTransactionType.SEND) {",
          "128:                 throw Error(\"[slp-validate] Outputs do not match valid inputs\");",
          "129:             }",
          "134:             validInputs = validation.parents.map(p =>",
          "135:                 p.inputQty ? p.inputQty : Big(0)).reduce((p, c) => p.plus(c), Big(0));",
          "136:             if (!validInputs.minus(burnQuantity).eq(outputs) &&",
          "137:             validation.details!.transactionType === SlpTransactionType.SEND) {",
          "138:                 throw Error(\"[slp-validate] Burn amount specified is not properly being burned in the provided transaction.\");",
          "139:             }",
          "144:     public async isValidSlpTxid(",
          "145:         { txid, tokenIdFilter, tokenTypeFilter }: IValidSlpTxidParams): Promise<boolean> {",
          "146:         this.logger.log(\"[slp-validate] Validating: \" + txid);",
          "147:         const valid = await this._isValidSlpTxid(txid, tokenIdFilter, tokenTypeFilter);",
          "148:         this.logger.log(\"[slp-validate] Result: \" + valid + \" (\" + txid + \")\");",
          "149:         if (!valid && this.cachedValidations.get(txid)!.invalidReason) {",
          "150:             this.logger.log(\"[slp-validate] Invalid Reason: \" + this.cachedValidations.get(txid)!.invalidReason);",
          "151:         } else if (!valid) {",
          "152:             this.logger.log(\"[slp-validate] Invalid Reason: unknown (result is user supplied)\")",
          "153:  }",
          "172:         if (!this.cachedValidations.has(txid)) {",
          "173:             this.cachedValidations.set(txid, {",
          "174:                 validity: null,",
          "175:                 parents: [],",
          "176:                 details: null,",
          "177:                 invalidReason: null,",
          "178:                 waiting: false,",
          "181:         } else if (typeof this.cachedValidations.get(txid)!.validity === \"boolean\" &&",
          "182:                   !tokenIdFilter && !tokenTypeFilter) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "172:                 this.retrieveRawTransaction(txid);",
          "175:             await this.waitForTransactionDownloadToComplete(txid);",
          "176:         }",
          "183:             await this.waitForCurrentValidationProcessing(txid);",
          "185:                 return validation.validity!;",
          "186:             }",
          "187:         }",
          "",
          "[Removed Lines]",
          "169:         if(!this.cachedRawTransactions.get(txid)! || this.cachedRawTransactions.get(txid)! === \"waiting\") {",
          "171:             if(this.cachedRawTransactions.get(txid)! !== \"waiting\")",
          "178:         let validation = this.cachedValidations.get(txid)!;",
          "179:         let transaction = this.cachedRawTransactions.get(txid)!;",
          "182:         if(validation.waiting) {",
          "184:             if(typeof validation.validity === 'boolean' && !tokenIdFilter && !tokenTypeFilter) {",
          "",
          "[Added Lines]",
          "194:         if (!this.cachedRawTransactions.get(txid)! || this.cachedRawTransactions.get(txid)! === \"waiting\") {",
          "196:             if (this.cachedRawTransactions.get(txid)! !== \"waiting\") {",
          "198:             }",
          "204:         const validation = this.cachedValidations.get(txid)!;",
          "205:         const transaction = this.cachedRawTransactions.get(txid)!;",
          "208:         if (validation.waiting) {",
          "210:             if (typeof validation.validity === \"boolean\" && !tokenIdFilter && !tokenTypeFilter) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "189:         validation.waiting = true;",
          "193:         let slpmsg: SlpTransactionDetails;",
          "194:         try {",
          "195:             slpmsg = validation.details = Slp.parseSlpOutputScript(txn.outputs[0].scriptPubKey);",
          "197:                 slpmsg.tokenIdHex = txid;",
          "199:             validation.validity = false;",
          "200:             validation.waiting = false;",
          "201:             validation.invalidReason = \"SLP OP_RETURN parsing error (\" + e.message + \").\";",
          "",
          "[Removed Lines]",
          "192:         let txn: Transaction = Transaction.parseFromBuffer(transaction);",
          "196:             if(slpmsg.transactionType === SlpTransactionType.GENESIS)",
          "198:         } catch(e) {",
          "",
          "[Added Lines]",
          "218:         const txn: Transaction = Transaction.parseFromBuffer(transaction);",
          "222:             if (slpmsg.transactionType === SlpTransactionType.GENESIS) {",
          "224:             }",
          "225:         } catch (e) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "203:         }",
          "207:             validation.waiting = false;",
          "208:             validation.invalidReason = \"Validator was run with filter only considering tokenId \" + tokenIdFilter + \" as valid.\";",
          "209:             return false; // Don't save boolean result to cache incase cache is ever used without tokenIdFilter.",
          "210:         } else {",
          "212:                 validation.invalidReason = null;",
          "213:         }",
          "217:             validation.validity = null;",
          "218:             validation.waiting = false;",
          "219:             validation.invalidReason = \"Validator was run with filter only considering token type: \" + tokenTypeFilter + \" as valid.\";",
          "220:             return false; // Don't save boolean result to cache incase cache is ever used with different token type.",
          "221:         } else {",
          "223:                 validation.invalidReason = null;",
          "224:         }",
          "236:                 try {",
          "240:                     validation.validity = false;",
          "241:                     validation.waiting = false;",
          "242:                     validation.invalidReason = \"NFT1 child GENESIS does not have a valid NFT1 parent input.\";",
          "243:                     return validation.validity!;",
          "244:                 }",
          "249:                     validation.validity = false;",
          "250:                     validation.waiting = false;",
          "251:                     validation.invalidReason = \"NFT1 child's parent has SLP output that is not greater than zero.\";",
          "252:                     return validation.validity!;",
          "257:                     validation.validity = false;",
          "258:                     validation.waiting = false;",
          "259:                     validation.invalidReason = \"NFT1 child's parent has SLP output that is not greater than zero.\";",
          "260:                     return validation.validity!;",
          "261:                 }",
          "264:                 validation.validity = nft_parent_dag_validity;",
          "265:                 validation.waiting = false;",
          "267:                     validation.invalidReason = \"NFT1 child GENESIS does not have valid parent DAG.\"",
          "268:                 }",
          "269:                 return validation.validity!;",
          "274:                 validation.validity = true;",
          "275:                 validation.waiting = false;",
          "276:                 return validation.validity!;",
          "277:             }",
          "284:                 try {",
          "295:                                     valid: null,",
          "298:                             }",
          "299:                         }",
          "300:                     }",
          "302:             }",
          "304:                 validation.validity = false;",
          "305:                 validation.waiting = false;",
          "306:                 validation.invalidReason = \"MINT transaction must have 1 valid baton parent.\"",
          "307:                 return validation.validity!;",
          "308:             }",
          "312:             let tokenInQty = new Big(0);",
          "317:                 try {",
          "332:                             }",
          "344:                             }",
          "345:                         }",
          "346:                     }",
          "348:             }",
          "352:                 validation.validity = false;",
          "353:                 validation.waiting = false;",
          "354:                 validation.invalidReason = \"Token outputs are greater than possible token inputs.\"",
          "",
          "[Removed Lines]",
          "206:         if(tokenIdFilter && slpmsg.tokenIdHex !== tokenIdFilter) {",
          "211:             if(validation.validity !== false)",
          "216:         if(tokenTypeFilter && slpmsg.versionType !== tokenTypeFilter) {",
          "222:             if(validation.validity !== false)",
          "227:         if(slpmsg.transactionType === SlpTransactionType.GENESIS) {",
          "229:             if(slpmsg.versionType === 0x41) {",
          "232:                 let input_txid = txn.inputs[0].previousTxHash;",
          "233:                 let input_txhex = await this.retrieveRawTransaction(input_txid);",
          "234:                 let input_tx: Transaction = Transaction.parseFromBuffer(input_txhex);",
          "235:                 let input_slpmsg;",
          "237:                     input_slpmsg = Slp.parseSlpOutputScript(input_tx.outputs[0].scriptPubKey);",
          "238:                 } catch(_) { }",
          "239:                 if(!input_slpmsg || input_slpmsg.versionType !== 0x81) {",
          "246:                 if(input_slpmsg.transactionType === SlpTransactionType.SEND &&",
          "247:                     (!input_slpmsg.sendOutputs![1].gt(0)))",
          "248:                 {",
          "253:                 } else if((input_slpmsg.transactionType === SlpTransactionType.GENESIS ||",
          "254:                             input_slpmsg.transactionType === SlpTransactionType.MINT) &&",
          "255:                             !input_slpmsg.genesisOrMintQuantity!.gt(0))",
          "256:                 {",
          "263:                 let nft_parent_dag_validity = await this.isValidSlpTxid({txid: input_txid, tokenIdFilter: undefined, tokenTypeFilter: 0x81 });",
          "266:                 if(!nft_parent_dag_validity) {",
          "270:             }",
          "273:             else {",
          "278:         }",
          "279:         else if (slpmsg.transactionType === SlpTransactionType.MINT) {",
          "280:             for(let i = 0; i < txn.inputs.length; i++) {",
          "281:                 let input_txid = txn.inputs[i].previousTxHash;",
          "282:                 let input_txhex = await this.retrieveRawTransaction(input_txid);",
          "283:                 let input_tx: Transaction = Transaction.parseFromBuffer(input_txhex);",
          "285:                     let input_slpmsg = Slp.parseSlpOutputScript(input_tx.outputs[0].scriptPubKey);",
          "286:                     if(input_slpmsg.transactionType === SlpTransactionType.GENESIS)",
          "287:                         input_slpmsg.tokenIdHex = input_txid;",
          "288:                     if(input_slpmsg.tokenIdHex === slpmsg.tokenIdHex) {",
          "289:                         if(input_slpmsg.transactionType === SlpTransactionType.GENESIS || input_slpmsg.transactionType === SlpTransactionType.MINT) {",
          "290:                             if(txn.inputs[i].previousTxOutIndex === input_slpmsg.batonVout) {",
          "291:                                 validation.parents.push({",
          "292:                                     txid: txn.inputs[i].previousTxHash,",
          "293:                                     vout: txn.inputs[i].previousTxOutIndex,",
          "294:                                     versionType: input_slpmsg.versionType,",
          "296:                                     inputQty: null",
          "297:                                 })",
          "301:                 } catch(_) {}",
          "303:             if(validation.parents.length !== 1) {",
          "309:         }",
          "310:         else if(slpmsg.transactionType === SlpTransactionType.SEND) {",
          "311:             let tokenOutQty = slpmsg.sendOutputs!.reduce((t,v)=>{ return t.plus(v) }, new Big(0))",
          "313:             for(let i = 0; i < txn.inputs.length; i++) {",
          "314:                 let input_txid = txn.inputs[i].previousTxHash;",
          "315:                 let input_txhex = await this.retrieveRawTransaction(input_txid);",
          "316:                 let input_tx: Transaction = Transaction.parseFromBuffer(input_txhex);",
          "318:                     let input_slpmsg = Slp.parseSlpOutputScript(input_tx.outputs[0].scriptPubKey)",
          "319:                     if(input_slpmsg.transactionType === SlpTransactionType.GENESIS)",
          "320:                         input_slpmsg.tokenIdHex = input_txid;",
          "321:                     if(input_slpmsg.tokenIdHex === slpmsg.tokenIdHex) {",
          "322:                         if(input_slpmsg.transactionType === SlpTransactionType.SEND) {",
          "323:                             if(txn.inputs[i].previousTxOutIndex <= input_slpmsg.sendOutputs!.length-1) {",
          "324:                                 tokenInQty = tokenInQty.plus(input_slpmsg.sendOutputs![txn.inputs[i].previousTxOutIndex])",
          "325:                                 validation.parents.push({",
          "326:                                     txid: txn.inputs[i].previousTxHash,",
          "327:                                     vout: txn.inputs[i].previousTxOutIndex,",
          "328:                                     versionType: input_slpmsg.versionType,",
          "329:                                     valid: null,",
          "330:                                     inputQty: input_slpmsg.sendOutputs![txn.inputs[i].previousTxOutIndex]",
          "331:                                 })",
          "333:                         }",
          "334:                         else if(input_slpmsg.transactionType === SlpTransactionType.GENESIS || input_slpmsg.transactionType === SlpTransactionType.MINT) {",
          "335:                             if(txn.inputs[i].previousTxOutIndex === 1) {",
          "336:                                 tokenInQty = tokenInQty.plus(input_slpmsg.genesisOrMintQuantity!)",
          "337:                                 validation.parents.push({",
          "338:                                     txid: txn.inputs[i].previousTxHash,",
          "339:                                     vout: txn.inputs[i].previousTxOutIndex,",
          "340:                                     versionType: input_slpmsg.versionType,",
          "341:                                     valid: null,",
          "342:                                     inputQty: input_slpmsg.genesisOrMintQuantity",
          "343:                                 })",
          "347:                 } catch(_) {}",
          "351:             if(tokenOutQty.gt(tokenInQty)) {",
          "",
          "[Added Lines]",
          "233:         if (tokenIdFilter && slpmsg.tokenIdHex !== tokenIdFilter) {",
          "238:             if (validation.validity !== false) {",
          "240:             }",
          "244:         if (tokenTypeFilter && slpmsg.versionType !== tokenTypeFilter) {",
          "250:             if (validation.validity !== false) {",
          "252:             }",
          "256:         if (slpmsg.transactionType === SlpTransactionType.GENESIS) {",
          "258:             if (slpmsg.versionType === 0x41) {",
          "261:                 const inputTxid = txn.inputs[0].previousTxHash;",
          "262:                 const inputTxHex = await this.retrieveRawTransaction(inputTxid);",
          "263:                 const inputTx: Transaction = Transaction.parseFromBuffer(inputTxHex);",
          "264:                 let inputSlpMsg;",
          "266:                     inputSlpMsg = Slp.parseSlpOutputScript(inputTx.outputs[0].scriptPubKey);",
          "267:                 } catch (_) {}",
          "268:                 if (!inputSlpMsg || inputSlpMsg.versionType !== 0x81) {",
          "275:                 if (inputSlpMsg.transactionType === SlpTransactionType.SEND &&",
          "276:                     !inputSlpMsg.sendOutputs![1].gt(0)) {",
          "281:                 } else if ((inputSlpMsg.transactionType === SlpTransactionType.GENESIS ||",
          "282:                             inputSlpMsg.transactionType === SlpTransactionType.MINT) &&",
          "283:                             !inputSlpMsg.genesisOrMintQuantity!.gt(0)) {",
          "290:                 let nft_parent_dag_validity = await this.isValidSlpTxid({ txid: inputTxid, tokenIdFilter: undefined, tokenTypeFilter: 0x81 });",
          "293:                 if (!nft_parent_dag_validity) {",
          "297:             } else {",
          "302:         } else if (slpmsg.transactionType === SlpTransactionType.MINT) {",
          "303:             for (let i = 0; i < txn.inputs.length; i++) {",
          "304:                 const inputTxid = txn.inputs[i].previousTxHash;",
          "305:                 const inputTxHex = await this.retrieveRawTransaction(inputTxid);",
          "306:                 const inputTx: Transaction = Transaction.parseFromBuffer(inputTxHex);",
          "308:                     const inputSlpMsg = Slp.parseSlpOutputScript(inputTx.outputs[0].scriptPubKey);",
          "309:                     if (inputSlpMsg.transactionType === SlpTransactionType.GENESIS) {",
          "310:                         inputSlpMsg.tokenIdHex = inputTxid;",
          "311:                     }",
          "312:                     if (inputSlpMsg.tokenIdHex === slpmsg.tokenIdHex) {",
          "313:                         if (inputSlpMsg.transactionType === SlpTransactionType.GENESIS ||",
          "314:                             inputSlpMsg.transactionType === SlpTransactionType.MINT) {",
          "315:                             if (txn.inputs[i].previousTxOutIndex === inputSlpMsg.batonVout) {",
          "316:                                 validation.parents.push({",
          "317:                                     txid: txn.inputs[i].previousTxHash,",
          "318:                                     vout: txn.inputs[i].previousTxOutIndex,",
          "319:                                     versionType: inputSlpMsg.versionType,",
          "321:                                     inputQty: null,",
          "322:                                 });",
          "326:                 } catch (_) { }",
          "328:             if (validation.parents.length !== 1) {",
          "334:         } else if (slpmsg.transactionType === SlpTransactionType.SEND) {",
          "335:             const tokenOutQty = slpmsg.sendOutputs!.reduce((t, v) => t.plus(v), new Big(0));",
          "337:             for (let i = 0; i < txn.inputs.length; i++) {",
          "338:                 const inputTxid = txn.inputs[i].previousTxHash;",
          "339:                 const inputTxHex = await this.retrieveRawTransaction(inputTxid);",
          "340:                 const inputTx: Transaction = Transaction.parseFromBuffer(inputTxHex);",
          "342:                     const inputSlpMsg = Slp.parseSlpOutputScript(inputTx.outputs[0].scriptPubKey);",
          "343:                     if (inputSlpMsg.transactionType === SlpTransactionType.GENESIS) {",
          "344:                         inputSlpMsg.tokenIdHex = inputTxid;",
          "345:                     }",
          "346:                     if (inputSlpMsg.tokenIdHex === slpmsg.tokenIdHex) {",
          "347:                         if (inputSlpMsg.transactionType === SlpTransactionType.SEND) {",
          "348:                             if (txn.inputs[i].previousTxOutIndex <= inputSlpMsg.sendOutputs!.length - 1) {",
          "349:                                 tokenInQty = tokenInQty.plus(",
          "350:                                     inputSlpMsg.sendOutputs![txn.inputs[i].previousTxOutIndex]);",
          "351:                                 validation.parents.push({",
          "352:                                     txid: txn.inputs[i].previousTxHash,",
          "353:                                     vout: txn.inputs[i].previousTxOutIndex,",
          "354:                                     versionType: inputSlpMsg.versionType,",
          "355:                                     valid: null,",
          "356:                                     inputQty: inputSlpMsg.sendOutputs![txn.inputs[i].previousTxOutIndex],",
          "357:                                 });",
          "359:                         } else if (inputSlpMsg.transactionType === SlpTransactionType.GENESIS ||",
          "360:                                    inputSlpMsg.transactionType === SlpTransactionType.MINT) {",
          "361:                             if (txn.inputs[i].previousTxOutIndex === 1) {",
          "362:                                 tokenInQty = tokenInQty.plus(inputSlpMsg.genesisOrMintQuantity!);",
          "363:                                 validation.parents.push({",
          "364:                                     txid: txn.inputs[i].previousTxHash,",
          "365:                                     vout: txn.inputs[i].previousTxOutIndex,",
          "366:                                     versionType: inputSlpMsg.versionType,",
          "367:                                     valid: null,",
          "368:                                     inputQty: inputSlpMsg.genesisOrMintQuantity,",
          "369:                                 });",
          "373:                 } catch (_) { }",
          "377:             if (tokenOutQty.gt(tokenInQty)) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "364:             validation.parents.filter(p => p.txid === parentTxids[i]).map(p => p.valid = valid);",
          "366:                 validation.validity = false;",
          "367:                 validation.waiting = false;",
          "369:                 return validation.validity!;",
          "370:             }",
          "371:         }",
          "378:                 validation.validity = false;",
          "379:                 validation.waiting = false;",
          "380:                 validation.invalidReason = \"Token outputs are greater than valid token inputs.\"",
          "",
          "[Removed Lines]",
          "361:         let parentTxids = [...new Set(validation.parents.map(p => p.txid))];",
          "362:         for(let i = 0; i < parentTxids.length; i++) {",
          "363:             let valid = await this.isValidSlpTxid({ txid: parentTxids[i] })",
          "365:             if(validation.details!.transactionType === SlpTransactionType.MINT && !valid) {",
          "368:                 validation.invalidReason = \"MINT transaction with invalid baton parent.\"",
          "374:         if(validation.details!.transactionType === SlpTransactionType.SEND) {",
          "375:             let validInputQty = validation.parents.reduce((t, v) => { return v.valid ? t.plus(v.inputQty!) : t }, new Big(0));",
          "376:             let tokenOutQty = slpmsg.sendOutputs!.reduce((t,v)=>{ return t.plus(v) }, new Big(0))",
          "377:             if(tokenOutQty.gt(validInputQty)) {",
          "",
          "[Added Lines]",
          "387:         const parentTxids = [...new Set(validation.parents.map(p => p.txid))];",
          "388:         for (let i = 0; i < parentTxids.length; i++) {",
          "389:             const valid = await this.isValidSlpTxid({ txid: parentTxids[i] });",
          "391:             if (validation.details!.transactionType === SlpTransactionType.MINT && !valid) {",
          "394:                 validation.invalidReason = \"MINT transaction with invalid baton parent.\";",
          "400:         if (validation.details!.transactionType === SlpTransactionType.SEND) {",
          "401:             const validInputQty = validation.parents.reduce((t, v) => v.valid ? t.plus(v.inputQty!) : t, new Big(0));",
          "402:             const tokenOutQty = slpmsg.sendOutputs!.reduce((t, v) => t.plus(v), new Big(0));",
          "403:             if (tokenOutQty.gt(validInputQty)) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "383:         }",
          "389:                 validation.validity = false;",
          "390:                 validation.waiting = false;",
          "391:                 validation.invalidReason = \"SLP version/type mismatch from valid parent.\"",
          "",
          "[Removed Lines]",
          "386:         if(validation.parents.filter(p => p.valid).length > 0) {",
          "387:             let validVersionType = validation.parents.find(p => p.valid!)!.versionType;",
          "388:             if(validation.details!.versionType !== validVersionType) {",
          "",
          "[Added Lines]",
          "412:         if (validation.parents.filter(p => p.valid).length > 0) {",
          "413:             const validVersionType = validation.parents.find(p => p.valid!)!.versionType;",
          "414:             if (validation.details!.versionType !== validVersionType) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "397:         return validation.validity!;",
          "398:     }",
          "402:         for (let i = 0; i < txids.length; i++) {",
          "404:         }",
          "405:         return res.filter((id: string) => id.length > 0);",
          "406:     }",
          "407: }",
          "",
          "[Removed Lines]",
          "400:     async validateSlpTransactions(txids: string[]): Promise<string[]> {",
          "401:         let res = [];",
          "403:             res.push((await this.isValidSlpTxid({ txid: txids[i] })) ? txids[i] : '')",
          "409: class MapCache<T, M> {",
          "410:     private map = new Map<T, M>()",
          "411:     private list: T[] = [];",
          "412:     private maxSize: number;",
          "414:     constructor(maxSize: number) {",
          "415:         this.maxSize = maxSize;",
          "416:     }",
          "418:     get length(): number {",
          "419:         return this.list.length;",
          "420:     }",
          "422:     set(key: T, item: M) {",
          "423:         this.list.push(key);",
          "424:         this.map.set(key, item);",
          "425:         if(this.map.size > this.maxSize) {",
          "426:             this.shift();",
          "427:         }",
          "428:     }",
          "430:     get(key: T) {",
          "431:         return this.map.get(key);",
          "432:     }",
          "434:     has(key: T) {",
          "435:         return this.map.has(key);",
          "436:     }",
          "438:     private shift(): T | undefined {",
          "439:         let key = this.list.shift();",
          "440:         if(key)",
          "441:             this.map.delete(key);",
          "442:         return key;",
          "443:     }",
          "445:     clear() {",
          "446:         this.list = [];",
          "447:         this.map.clear();",
          "448:     }",
          "449: }",
          "",
          "[Added Lines]",
          "426:     public async validateSlpTransactions(txids: string[]): Promise<string[]> {",
          "427:         const res = [];",
          "429:             res.push((await this.isValidSlpTxid({ txid: txids[i] })) ? txids[i] : \"\");",
          "",
          "---------------"
        ],
        "test/validation.ts||test/validation.ts": [
          "File: test/validation.ts -> test/validation.ts"
        ]
      }
    },
    {
      "candidate_hash": "bacdf9deab90de26ffe1035254827b8e01b4c49a",
      "candidate_info": {
        "commit_hash": "bacdf9deab90de26ffe1035254827b8e01b4c49a",
        "repo": "simpleledger/slp-validate",
        "commit_url": "https://github.com/simpleledger/slp-validate/commit/bacdf9deab90de26ffe1035254827b8e01b4c49a",
        "files": [
          "examples/1-validate-tx-rpc-burn-valid-stop.ts",
          "examples/2-validate-tx-rpc-burn-valid-allow.ts",
          "examples/3-validate-txid-rpc.ts",
          "examples/4-validate-txid-bchd.ts",
          "examples/5-validate-txid-gs++.ts",
          "index.ts",
          "lib/index.ts",
          "lib/validation.ts",
          "tsconfig.json"
        ],
        "message": "linting and tsconfig",
        "before_after_code_files": [
          "examples/1-validate-tx-rpc-burn-valid-stop.ts||examples/1-validate-tx-rpc-burn-valid-stop.ts",
          "examples/2-validate-tx-rpc-burn-valid-allow.ts||examples/2-validate-tx-rpc-burn-valid-allow.ts",
          "examples/3-validate-txid-rpc.ts||examples/3-validate-txid-rpc.ts",
          "examples/4-validate-txid-bchd.ts||examples/4-validate-txid-bchd.ts",
          "examples/5-validate-txid-gs++.ts||examples/5-validate-txid-gs++.ts",
          "index.ts||index.ts",
          "lib/index.ts||lib/index.ts",
          "lib/validation.ts||lib/validation.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/validation.ts||lib/validation.ts"
          ],
          "candidate": [
            "lib/validation.ts||lib/validation.ts"
          ]
        }
      },
      "candidate_diff": {
        "examples/1-validate-tx-rpc-burn-valid-stop.ts||examples/1-validate-tx-rpc-burn-valid-stop.ts": [
          "File: examples/1-validate-tx-rpc-burn-valid-stop.ts -> examples/1-validate-tx-rpc-burn-valid-stop.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: const txn = \"01000000067fb42e8fdf232ae50f8dc5e558252fba30336ae83b6e45e138f5b922205143d9020000006441bcf1bd79e139931c9132b72f184223573169367e12bedf407a83b02ab743449f5f7bab144f1ac6514e7cdcab644a4d84e93aeccb26328ce29a860b565a781732412102f706e233e38f92c854093350cca74f03989ade992cad5e9c2f37fd3591e2a745feffffff09e43bbe31136a69856a1d82b18e43be2f6654bb5ed34e762142c003da70ad3a020000006441b8f2c9216c68831c87f59706180f6370c7058e55dc7e566879cbc72b539b44a686a3f0a86f84e190d56498ff303135a1167e1bafbbe218a670ca3ae822d3063f4121023d538f5640dbcb1bca0cab14d9eacf19fb6558ab884aaaf5fa18268eccda8e1afeffffff79fd9c6d020ff90625ede1eca3d63836f11e6a774e022f306cf260b5a20fe077010000006441a4d16b13aa4a8ce8648872359cdcd56c6652280d4514f12be1362fa2a49c619a948c96f18b8d0f15d8b042e65315cf0f84dca2912430357f53cc6bb198d944324121027f76d0cef47d1ca5480fb61475b8a8dda3c150db24e7878e5054a2677f68ed09feffffff3f916feaac6fd543f2b4c1a0bd0cf8cdd67a051d9148b983ff89651cae6448a8010000006441e9e66ad5228bf7cea1be41a0b9cc0abc14fb533751cadd56d925be167f6dd130e608c94d6554059c8651d5814067390f705a7d4febb4e5d43ce2992ec048da45412102c4abc5997c7e1dad05fd8bacd51e5124e6f45c4956dc5cf81cd05af2b30a2a71feffffffb04c1d306f823540686c02899bfcc343e10537be36006b372885bf176b37e68a01000000644105934999a2b5b08469d91a44657353e43a3537a26ecfb85302d9109833b709f7cf6772273357cbbdfa94e1c98f010307ea42e31e6f66f5d01ebe387298ed30774121028cdd539d1c2ebe21e712121928a0e9f1244038cffaf88dd3f646a93f6e1babaffeffffff7fb42e8fdf232ae50f8dc5e558252fba30336ae83b6e45e138f5b922205143d9030000006441bbff4b3a6cb5b616a28210f4c6a07b92ca3c2d483f7f85439e8761a037ba725ea6ac164b36c1ab6f172635d4fbb8792a52f2b4bed5c40b8f5aa1305180f42866412103a08f93fed637daf62c1663c634d9034a2bfb6631c9f6ceba0c2ea7099c17fae2feffffff030000000000000000376a04534c500001010453454e4420c4b0d62156b3fa5c8f3436079b5394f7edc1bef5dc1cd2f9d0c4d46f82cca47908000000000000019022020000000000001976a91446e33d57e44125f02fc71a754fff13317ee8fc5088acb10f0000000000001976a9149c22bf7f6bb779237b2318dcbb1272f39a02d52e88accd2d0900\";",
          "32:     console.time(\"SLP-VALIDATE-RPC\");",
          "33:     const connectionString = `http://${RPC_USER_NAME}:${RPC_PASSWORD}@${RPC_URL}`;",
          "34:     const rpc = new RpcClient(connectionString);",
          "",
          "[Removed Lines]",
          "17: import { ValidatorType1 } from '../index';",
          "18: import { Big } from 'big.js';",
          "19: const RpcClient = require('bitcoin-rpc-promise-retry');",
          "21: const RPC_USER_NAME = 'bitcoin';",
          "22: const RPC_PASSWORD = 'password';",
          "23: const RPC_URL = 'localhost:8332';",
          "31: (async function() {",
          "",
          "[Added Lines]",
          "17: import { Big } from \"big.js\";",
          "18: import { ValidatorType1 } from \"../lib/index\";",
          "19: const RpcClient = require(\"bitcoin-rpc-promise-retry\");",
          "21: const RPC_USER_NAME = \"bitcoin\";",
          "22: const RPC_PASSWORD = \"password\";",
          "23: const RPC_URL = \"localhost:8332\";",
          "31: (async () => {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37:     let isValid;",
          "38:     try {",
          "39:         isValid = await slpValidator.isValidSlpTxn({ txn, burnQuantity: Big(0) });",
          "41:         console.log(error);",
          "42:         isValid = false;",
          "43:     }",
          "44:     console.log(\"Final Result:\", isValid);",
          "46:     console.timeEnd(\"SLP-VALIDATE-RPC\");",
          "47: })();",
          "",
          "[Removed Lines]",
          "40:     } catch(error) {",
          "45:     console.log(\"NOTE: THIS IS A VALID SLP TRANSACTION, BUT WE CALL IT INVALID SINCE IT WAS BURNING INPUTS.\")",
          "",
          "[Added Lines]",
          "40:     } catch (error) {",
          "45:     console.log(\"NOTE: THIS IS A VALID SLP TRANSACTION, BUT WE CALL IT INVALID SINCE IT WAS BURNING INPUTS.\");",
          "",
          "---------------"
        ],
        "examples/2-validate-tx-rpc-burn-valid-allow.ts||examples/2-validate-tx-rpc-burn-valid-allow.ts": [
          "File: examples/2-validate-tx-rpc-burn-valid-allow.ts -> examples/2-validate-tx-rpc-burn-valid-allow.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: const txn = \"01000000067fb42e8fdf232ae50f8dc5e558252fba30336ae83b6e45e138f5b922205143d9020000006441bcf1bd79e139931c9132b72f184223573169367e12bedf407a83b02ab743449f5f7bab144f1ac6514e7cdcab644a4d84e93aeccb26328ce29a860b565a781732412102f706e233e38f92c854093350cca74f03989ade992cad5e9c2f37fd3591e2a745feffffff09e43bbe31136a69856a1d82b18e43be2f6654bb5ed34e762142c003da70ad3a020000006441b8f2c9216c68831c87f59706180f6370c7058e55dc7e566879cbc72b539b44a686a3f0a86f84e190d56498ff303135a1167e1bafbbe218a670ca3ae822d3063f4121023d538f5640dbcb1bca0cab14d9eacf19fb6558ab884aaaf5fa18268eccda8e1afeffffff79fd9c6d020ff90625ede1eca3d63836f11e6a774e022f306cf260b5a20fe077010000006441a4d16b13aa4a8ce8648872359cdcd56c6652280d4514f12be1362fa2a49c619a948c96f18b8d0f15d8b042e65315cf0f84dca2912430357f53cc6bb198d944324121027f76d0cef47d1ca5480fb61475b8a8dda3c150db24e7878e5054a2677f68ed09feffffff3f916feaac6fd543f2b4c1a0bd0cf8cdd67a051d9148b983ff89651cae6448a8010000006441e9e66ad5228bf7cea1be41a0b9cc0abc14fb533751cadd56d925be167f6dd130e608c94d6554059c8651d5814067390f705a7d4febb4e5d43ce2992ec048da45412102c4abc5997c7e1dad05fd8bacd51e5124e6f45c4956dc5cf81cd05af2b30a2a71feffffffb04c1d306f823540686c02899bfcc343e10537be36006b372885bf176b37e68a01000000644105934999a2b5b08469d91a44657353e43a3537a26ecfb85302d9109833b709f7cf6772273357cbbdfa94e1c98f010307ea42e31e6f66f5d01ebe387298ed30774121028cdd539d1c2ebe21e712121928a0e9f1244038cffaf88dd3f646a93f6e1babaffeffffff7fb42e8fdf232ae50f8dc5e558252fba30336ae83b6e45e138f5b922205143d9030000006441bbff4b3a6cb5b616a28210f4c6a07b92ca3c2d483f7f85439e8761a037ba725ea6ac164b36c1ab6f172635d4fbb8792a52f2b4bed5c40b8f5aa1305180f42866412103a08f93fed637daf62c1663c634d9034a2bfb6631c9f6ceba0c2ea7099c17fae2feffffff030000000000000000376a04534c500001010453454e4420c4b0d62156b3fa5c8f3436079b5394f7edc1bef5dc1cd2f9d0c4d46f82cca47908000000000000019022020000000000001976a91446e33d57e44125f02fc71a754fff13317ee8fc5088acb10f0000000000001976a9149c22bf7f6bb779237b2318dcbb1272f39a02d52e88accd2d0900\";",
          "23:     console.time(\"SLP-VALIDATE-RPC\");",
          "24:     const connectionString = `http://${RPC_USER_NAME}:${RPC_PASSWORD}@${RPC_URL}`;",
          "25:     const rpc = new RpcClient(connectionString);",
          "",
          "[Removed Lines]",
          "12: import { ValidatorType1 } from '../index';",
          "13: import { Big } from 'big.js';",
          "14: const RpcClient = require('bitcoin-rpc-promise-retry');",
          "16: const RPC_USER_NAME = 'bitcoin';",
          "17: const RPC_PASSWORD = 'password';",
          "18: const RPC_URL = 'localhost:8332';",
          "22: (async function() {",
          "",
          "[Added Lines]",
          "12: import { Big } from \"big.js\";",
          "13: import { ValidatorType1 } from \"../lib/index\";",
          "14: const RpcClient = require(\"bitcoin-rpc-promise-retry\");",
          "16: const RPC_USER_NAME = \"bitcoin\";",
          "17: const RPC_PASSWORD = \"password\";",
          "18: const RPC_URL = \"localhost:8332\";",
          "22: (async () => {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "28:     let isValid;",
          "29:     try {",
          "30:         isValid = await slpValidator.isValidSlpTxn({ txn, burnQuantity: Big(5) });  // <--- Use \"burnQuantity\" to allow an exact burn amount",
          "32:         console.log(error);",
          "33:         isValid = false;",
          "34:     }",
          "",
          "[Removed Lines]",
          "31:     } catch(error) {",
          "",
          "[Added Lines]",
          "31:     } catch (error) {",
          "",
          "---------------"
        ],
        "examples/3-validate-txid-rpc.ts||examples/3-validate-txid-rpc.ts": [
          "File: examples/3-validate-txid-rpc.ts -> examples/3-validate-txid-rpc.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:     console.time(\"SLP-VALIDATE-RPC\");",
          "22:     const connectionString = `http://${RPC_USER_NAME}:${RPC_PASSWORD}@${RPC_URL}`;",
          "23:     const rpc = new RpcClient(connectionString);",
          "",
          "[Removed Lines]",
          "11: import { ValidatorType1 } from '../index';",
          "12: const RpcClient = require('bitcoin-rpc-promise-retry');",
          "14: const RPC_USER_NAME = 'bitcoin';",
          "15: const RPC_PASSWORD = 'password';",
          "16: const RPC_URL = 'localhost:8332';",
          "18: const txid = \"9cd705998fcc233ccf0a840f4ee7fcbc1eb678eba79e708560ecc95fedecfec9\";",
          "20: (async function() {",
          "",
          "[Added Lines]",
          "11: import { ValidatorType1 } from \"../lib/index\";",
          "12: const RpcClient = require(\"bitcoin-rpc-promise-retry\");",
          "14: const RPC_USER_NAME = \"bitcoin\";",
          "15: const RPC_PASSWORD = \"password\";",
          "16: const RPC_URL = \"localhost:8332\";",
          "18: const txid = \"3ff425384539519e815507f7f6739d9c12a44af84ff895601606b85157e0fb19\";",
          "20: (async () => {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "26:     console.log(\"This may take a several seconds...\");",
          "27:     let isValid = await slpValidator.isValidSlpTxid({ txid });",
          "28:     console.log(\"Final Result:\", isValid);",
          "30:     console.timeEnd(\"SLP-VALIDATE-RPC\");",
          "31: })();",
          "",
          "[Removed Lines]",
          "29:     console.log(\"WARNING: THIS VALIDATION METHOD COMES WITH NO BURN PROTECTION.\")",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "examples/4-validate-txid-bchd.ts||examples/4-validate-txid-bchd.ts": [
          "File: examples/4-validate-txid-bchd.ts -> examples/4-validate-txid-bchd.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: (async function() {",
          "21:     console.time(\"SLP-VALIDATE-GRPC\");",
          "22:     const rpc = new GrpcClient({ url: GRPC_URL, rootCertPath: GRPC_CERT });",
          "23:     const slpValidator = new ValidatorType1({ getRawTransaction: async (txid: string) => {",
          "25:         return Buffer.from(res.getTransaction_asU8());",
          "26:     } });",
          "27:     console.log(\"Validating:\", txid);",
          "28:     console.log(\"This may take a several seconds...\");",
          "30:     console.log(\"Final Result:\", isValid);",
          "32:     console.timeEnd(\"SLP-VALIDATE-GRPC\");",
          "33: })();",
          "",
          "[Removed Lines]",
          "11: import { ValidatorType1 } from '../index';",
          "12: import { GrpcClient } from 'grpc-bchrpc-node';",
          "14: const GRPC_URL = 'localhost:8335';",
          "16: const GRPC_CERT = '<path to your BCHD cert>';",
          "18: const txid = \"9cd705998fcc233ccf0a840f4ee7fcbc1eb678eba79e708560ecc95fedecfec9\";",
          "24:         let res = await rpc.getRawTransaction({ hash: txid, reverseOrder: true});",
          "29:     let isValid = await slpValidator.isValidSlpTxid({ txid });",
          "31:     console.log(\"WARNING: THIS VALIDATION METHOD COMES WITH NO BURN PROTECTION.\")",
          "",
          "[Added Lines]",
          "11: import { GrpcClient } from \"grpc-bchrpc-node\";",
          "12: import { ValidatorType1 } from \"../lib/index\";",
          "14: const GRPC_URL = \"localhost:8335\";",
          "16: const GRPC_CERT = \"<path to your BCHD cert>\";",
          "18: const txid = \"cecf484fa8b65b938131392e8e0e0a83a939c83d2e3f6673e28349ad5cc74244\";",
          "24:         const res = await rpc.getRawTransaction({ hash: txid, reversedHashOrder: true});",
          "29:     const isValid = await slpValidator.isValidSlpTxid({ txid });",
          "31:     console.log(\"WARNING: THIS VALIDATION METHOD COMES WITH NO BURN PROTECTION.\");",
          "",
          "---------------"
        ],
        "examples/5-validate-txid-gs++.ts||examples/5-validate-txid-gs++.ts": [
          "File: examples/5-validate-txid-gs++.ts -> examples/5-validate-txid-gs++.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "17:     console.time(\"SLP-VALIDATE-W-GRAPH-SEARCH\");",
          "25:         dag.set(id, txnBuf);",
          "26:     });",
          "33:     const slpValidator = new ValidatorType1({ getRawTransaction });",
          "35:     console.log(\"Validating:\", txid);",
          "36:     console.log(\"This may take a several seconds...\");",
          "38:     console.log(\"Final Result:\", isValid);",
          "40:     console.timeEnd(\"SLP-VALIDATE-W-GRAPH-SEARCH\");",
          "41: })();",
          "",
          "[Removed Lines]",
          "11: import { ValidatorType1, Crypto } from '../index';",
          "12: import { GraphSearchClient } from 'grpc-slp-graphsearch-node';",
          "14: const txid = \"ecaaf0a4de119a59a440089c99a2c103791dbd06086472ff8ff4229c5cd7cc4f\";",
          "16: (async function() {",
          "20:     let gs = new GraphSearchClient(); // optional set server url",
          "21:     let dag = new Map<string, Buffer>();",
          "22:     (await gs.graphSearchFor(txid)).getTxdataList_asU8().forEach(txn => {",
          "23:         let txnBuf = Buffer.from(txn);",
          "24:         let id = Crypto.hash256(txnBuf).toString('hex');",
          "29:     let getRawTransaction =  async (id: string) => {",
          "30:         if(dag.has(id)) return dag.get(id)!;",
          "31:         else return Buffer.alloc(60);",
          "32:     }",
          "37:     let isValid = await slpValidator.isValidSlpTxid({ txid });",
          "39:     console.log(\"WARNING: THIS VALIDATION METHOD COMES WITH NO BURN PROTECTION.\")",
          "",
          "[Added Lines]",
          "11: import { GraphSearchClient } from \"grpc-slp-graphsearch-node\";",
          "12: import { Crypto, ValidatorType1 } from \"../lib/index\";",
          "14: const txid = \"3ff425384539519e815507f7f6739d9c12a44af84ff895601606b85157e0fb19\";",
          "16: (async () => {",
          "20:     const gs = new GraphSearchClient(); // optional set server url",
          "21:     const dag = new Map<string, Buffer>();",
          "22:     (await gs.graphSearchFor(txid)).getTxdataList_asU8().forEach((txn) => {",
          "23:         const txnBuf = Buffer.from(txn);",
          "24:         const id = Crypto.hash256(txnBuf).toString(\"hex\");",
          "29:     const getRawTransaction =  async (id: string) => {",
          "30:         if (dag.has(id)) { return dag.get(id)!; }",
          "31:         else { return Buffer.alloc(60); }",
          "32:     };",
          "37:     const isValid = await slpValidator.isValidSlpTxid({ txid });",
          "39:     console.log(\"WARNING: THIS VALIDATION METHOD COMES WITH NO BURN PROTECTION.\");",
          "",
          "---------------"
        ],
        "index.ts||index.ts": [
          "File: index.ts -> index.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/index.ts||lib/index.ts": [
          "File: lib/index.ts -> lib/index.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: export * from \"./validation\";",
          "2: export * from \"./transaction\";",
          "3: export * from \"./slp\";",
          "4: export * from \"./crypto\";",
          "",
          "---------------"
        ],
        "lib/validation.ts||lib/validation.ts": [
          "File: lib/validation.ts -> lib/validation.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:         const cached: Validation = this.cachedValidations.get(txid)!;",
          "60:         if (!cached) {",
          "62:         }",
          "64:         while (true) {",
          "",
          "[Removed Lines]",
          "61:             throw Error(\"txid is missing from cachedValidations.\")",
          "",
          "[Added Lines]",
          "61:             throw Error(\"txid is missing from cachedValidations.\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "94:         }",
          "95:         if (this.cachedRawTransactions.has(txid)) {",
          "96:             if (this.cachedRawTransactions.get(txid)!.length < 60) {",
          "98:             }",
          "99:             return this.cachedRawTransactions.get(txid)!;",
          "100:         }",
          "102:     }",
          "",
          "[Removed Lines]",
          "97:                 throw Error(\"Valid transaction data not provided.\")",
          "101:         throw Error(\"Transaction data not provided (null or undefined).\")",
          "",
          "[Added Lines]",
          "97:                 throw Error(\"Valid transaction data not provided.\");",
          "101:         throw Error(\"Transaction data not provided (null or undefined).\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "193:         if (!valid && this.cachedValidations.get(txid)!.invalidReason) {",
          "194:             this.logger.log(\"[slp-validate] Invalid Reason: \" + this.cachedValidations.get(txid)!.invalidReason);",
          "195:         } else if (!valid) {",
          "197:  }",
          "198:         return valid;",
          "199:     }",
          "",
          "[Removed Lines]",
          "196:             this.logger.log(\"[slp-validate] Invalid Reason: unknown (result is user supplied)\")",
          "",
          "[Added Lines]",
          "196:             this.logger.log(\"[slp-validate] Invalid Reason: unknown (result is user supplied)\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "343:                 validation.validity = nft_parent_dag_validity;",
          "344:                 validation.waiting = false;",
          "345:                 if (!nft_parent_dag_validity) {",
          "347:                 }",
          "348:                 return validation.validity!;",
          "349:             } else {",
          "",
          "[Removed Lines]",
          "346:                     validation.invalidReason = \"NFT1 child GENESIS does not have valid parent DAG.\"",
          "",
          "[Added Lines]",
          "346:                     validation.invalidReason = \"NFT1 child GENESIS does not have valid parent DAG.\";",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "380:             if (validation.parents.length !== 1) {",
          "381:                 validation.validity = false;",
          "382:                 validation.waiting = false;",
          "384:                 return validation.validity!;",
          "385:             }",
          "386:         } else if (slpmsg.transactionType === SlpTransactionType.SEND) {",
          "",
          "[Removed Lines]",
          "383:                 validation.invalidReason = \"MINT transaction must have 1 valid baton parent.\"",
          "",
          "[Added Lines]",
          "383:                 validation.invalidReason = \"MINT transaction must have 1 valid baton parent.\";",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "429:             if (tokenOutQty.gt(tokenInQty)) {",
          "430:                 validation.validity = false;",
          "431:                 validation.waiting = false;",
          "433:                 return validation.validity!;",
          "434:             }",
          "435:         }",
          "",
          "[Removed Lines]",
          "432:                 validation.invalidReason = \"Token outputs are greater than possible token inputs.\"",
          "",
          "[Added Lines]",
          "432:                 validation.invalidReason = \"Token outputs are greater than possible token inputs.\";",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "455:             if (tokenOutQty.gt(validInputQty)) {",
          "456:                 validation.validity = false;",
          "457:                 validation.waiting = false;",
          "459:                 return validation.validity!;",
          "460:             }",
          "461:         }",
          "",
          "[Removed Lines]",
          "458:                 validation.invalidReason = \"Token outputs are greater than valid token inputs.\"",
          "",
          "[Added Lines]",
          "458:                 validation.invalidReason = \"Token outputs are greater than valid token inputs.\";",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "466:             if (validation.details!.versionType !== validVersionType) {",
          "467:                 validation.validity = false;",
          "468:                 validation.waiting = false;",
          "470:                 return validation.validity!;",
          "471:             }",
          "472:         }",
          "",
          "[Removed Lines]",
          "469:                 validation.invalidReason = \"SLP version/type mismatch from valid parent.\"",
          "",
          "[Added Lines]",
          "469:                 validation.invalidReason = \"SLP version/type mismatch from valid parent.\";",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "478:     public async validateSlpTransactions(txids: string[]): Promise<string[]> {",
          "479:         const res = [];",
          "482:         }",
          "483:         return res.filter((id: string) => id.length > 0);",
          "484:     }",
          "",
          "[Removed Lines]",
          "480:         for (let i = 0; i < txids.length; i++) {",
          "481:             res.push((await this.isValidSlpTxid({ txid: txids[i] })) ? txids[i] : \"\");",
          "",
          "[Added Lines]",
          "480:         for (const txid of txids) {",
          "481:             res.push((await this.isValidSlpTxid({ txid })) ? txid : \"\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
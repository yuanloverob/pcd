{
  "cve_id": "CVE-2021-43784",
  "cve_desc": "runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. In runc, netlink is used internally as a serialization system for specifying the relevant container configuration to the `C` portion of the code (responsible for the based namespace setup of containers). In all versions of runc prior to 1.0.3, the encoder did not handle the possibility of an integer overflow in the 16-bit length field for the byte array attribute type, meaning that a large enough malicious byte array attribute could result in the length overflowing and the attribute contents being parsed as netlink messages for container configuration. This vulnerability requires the attacker to have some control over the configuration of the container and would allow the attacker to bypass the namespace restrictions of the container by simply adding their own netlink payload which disables all namespaces. The main users impacted are those who allow untrusted images with untrusted configurations to run on their machines (such as with shared cloud infrastructure). runc version 1.0.3 contains a fix for this bug. As a workaround, one may try disallowing untrusted namespace paths from your container. It should be noted that untrusted namespace paths would allow the attacker to disable namespace protections entirely even in the absence of this bug.",
  "repo": "opencontainers/runc",
  "patch_hash": "9c444070ec7bb83995dbc0185da68284da71c554",
  "patch_info": {
    "commit_hash": "9c444070ec7bb83995dbc0185da68284da71c554",
    "repo": "opencontainers/runc",
    "commit_url": "https://github.com/opencontainers/runc/commit/9c444070ec7bb83995dbc0185da68284da71c554",
    "files": [
      "libcontainer/configs/mount.go",
      "libcontainer/container_linux.go",
      "libcontainer/factory_linux.go",
      "libcontainer/init_linux.go",
      "libcontainer/message_linux.go",
      "libcontainer/nsenter/nsexec.c",
      "libcontainer/rootfs_linux.go",
      "libcontainer/standard_init_linux.go"
    ],
    "message": "Open bind mount sources from the host userns\n\nThe source of the bind mount might not be accessible in a different user\nnamespace because a component of the source path might not be traversed\nunder the users and groups mapped inside the user namespace. This caused\nerrors such as the following:\n\n  # time=\"2020-06-22T13:48:26Z\" level=error msg=\"container_linux.go:367:\n  starting container process caused: process_linux.go:459:\n  container init caused: rootfs_linux.go:58:\n  mounting \\\"/tmp/busyboxtest/source-inaccessible/dir\\\"\n  to rootfs at \\\"/tmp/inaccessible\\\" caused:\n  stat /tmp/busyboxtest/source-inaccessible/dir: permission denied\"\n\nTo solve this problem, this patch performs the following:\n\n1. in nsexec.c, it opens the source path in the host userns (so we have\n   the right permissions to open it) but in the container mntns (so the\n   kernel cross mntns mount check let us mount it later:\n   https://github.com/torvalds/linux/blob/v5.8/fs/namespace.c#L2312).\n\n2. in nsexec.c, it passes the file descriptors of the source to the\n   child process with SCM_RIGHTS.\n\n3. In runc-init in Golang, it finishes the mounts while inside the\n   userns even without access to the some components of the source\n   paths.\n\nPassing the fds with SCM_RIGHTS is necessary because once the child\nprocess is in the container mntns, it is already in the container userns\nso it cannot temporarily join the host mntns.\n\nThis patch uses the existing mechanism with _LIBCONTAINER_* environment\nvariables to pass the file descriptors from runc to runc init.\n\nThis patch uses the existing mechanism with the Netlink-style bootstrap\nto pass information about the list of source mounts to nsexec.c.\n\nRootless containers don't use this bind mount sources fdpassing\nmechanism because we can't setns() to the target mntns in a rootless\ncontainer (we don't have the privileges when we are in the host userns).\n\nThis patch takes care of using O_CLOEXEC on mount fds, and close them\nearly.\n\nFixes: #2484.\n\nSigned-off-by: Alban Crequy <alban@kinvolk.io>\nSigned-off-by: Rodrigo Campos <rodrigo@kinvolk.io>\nCo-authored-by: Rodrigo Campos <rodrigo@kinvolk.io>",
    "before_after_code_files": [
      "libcontainer/configs/mount.go||libcontainer/configs/mount.go",
      "libcontainer/container_linux.go||libcontainer/container_linux.go",
      "libcontainer/factory_linux.go||libcontainer/factory_linux.go",
      "libcontainer/init_linux.go||libcontainer/init_linux.go",
      "libcontainer/message_linux.go||libcontainer/message_linux.go",
      "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c",
      "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go",
      "libcontainer/standard_init_linux.go||libcontainer/standard_init_linux.go"
    ]
  },
  "patch_diff": {
    "libcontainer/configs/mount.go||libcontainer/configs/mount.go": [
      "File: libcontainer/configs/mount.go -> libcontainer/configs/mount.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: package configs",
      "3: const (",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3: import \"golang.org/x/sys/unix\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "38:  PostmountCmds []Command `json:\"postmount_cmds\"`",
      "39: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "43: func (m *Mount) IsBind() bool {",
      "44:  return m.Flags&unix.MS_BIND != 0",
      "45: }",
      "",
      "---------------"
    ],
    "libcontainer/container_linux.go||libcontainer/container_linux.go": [
      "File: libcontainer/container_linux.go -> libcontainer/container_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "521:  return cmd",
      "522: }",
      "524: func (c *linuxContainer) newInitProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*initProcess, error) {",
      "525:  cmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initStandard))",
      "526:  nsMaps := make(map[configs.NamespaceType]string)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "527: func (c *linuxContainer) shouldSendMountSources() bool {",
      "530:  if !c.config.Namespaces.Contains(configs.NEWUSER) ||",
      "531:   !c.config.Namespaces.Contains(configs.NEWNS) {",
      "532:   return false",
      "533:  }",
      "537:  if c.config.RootlessEUID {",
      "538:   return false",
      "539:  }",
      "542:  for _, m := range c.config.Mounts {",
      "543:   if m.IsBind() {",
      "544:    return true",
      "545:   }",
      "546:  }",
      "548:  return false",
      "549: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "530:   }",
      "531:  }",
      "532:  _, sharePidns := nsMaps[configs.NEWPID]",
      "534:  if err != nil {",
      "535:   return nil, err",
      "536:  }",
      "537:  init := &initProcess{",
      "538:   cmd:             cmd,",
      "539:   messageSockPair: messageSockPair,",
      "",
      "[Removed Lines]",
      "533:  data, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps)",
      "",
      "[Added Lines]",
      "560:  data, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps, initStandard)",
      "565:  if c.shouldSendMountSources() {",
      "568:   mountFds := make([]int, len(c.config.Mounts))",
      "569:   for i, m := range c.config.Mounts {",
      "570:    if !m.IsBind() {",
      "572:     mountFds[i] = -1",
      "573:     continue",
      "574:    }",
      "580:    cmd.ExtraFiles = append(cmd.ExtraFiles, messageSockPair.child)",
      "581:    mountFds[i] = stdioFdCount + len(cmd.ExtraFiles) - 1",
      "582:   }",
      "584:   mountFdsJson, err := json.Marshal(mountFds)",
      "585:   if err != nil {",
      "586:    return nil, fmt.Errorf(\"Error creating _LIBCONTAINER_MOUNT_FDS: %w\", err)",
      "587:   }",
      "589:   cmd.Env = append(cmd.Env,",
      "590:    \"_LIBCONTAINER_MOUNT_FDS=\"+string(mountFdsJson),",
      "591:   )",
      "592:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "558:  }",
      "562:  if err != nil {",
      "563:   return nil, err",
      "564:  }",
      "",
      "[Removed Lines]",
      "561:  data, err := c.bootstrapData(0, state.NamespacePaths)",
      "",
      "[Added Lines]",
      "618:  data, err := c.bootstrapData(0, state.NamespacePaths, initSetns)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1213:  case \"bind\":",
      "1217:    return err",
      "1218:   }",
      "1219:  default:",
      "",
      "[Removed Lines]",
      "1216:   if err := prepareBindMount(m, c.config.Rootfs); err != nil {",
      "",
      "[Added Lines]",
      "1275:   if err := prepareBindMount(m, c.config.Rootfs, nil); err != nil {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2055:  r := nl.NewNetlinkRequest(int(InitMsg), 0)",
      "",
      "[Removed Lines]",
      "2053: func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string) (io.Reader, error) {",
      "",
      "[Added Lines]",
      "2112: func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string, it initType) (io.Reader, error) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2132:   Value: c.config.RootlessEUID,",
      "2133:  })",
      "2135:  return bytes.NewReader(r.Serialize()), nil",
      "2136: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2195:  if it == initStandard && c.shouldSendMountSources() {",
      "2196:   var mounts []byte",
      "2197:   for _, m := range c.config.Mounts {",
      "2198:    if m.IsBind() {",
      "2199:     mounts = append(mounts, []byte(m.Source)...)",
      "2200:    }",
      "2201:    mounts = append(mounts, byte(0))",
      "2202:   }",
      "2204:   r.AddData(&Bytemsg{",
      "2205:    Type:  MountSourcesAttr,",
      "2206:    Value: mounts,",
      "2207:   })",
      "2208:  }",
      "",
      "---------------"
    ],
    "libcontainer/factory_linux.go||libcontainer/factory_linux.go": [
      "File: libcontainer/factory_linux.go -> libcontainer/factory_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "295:   return fmt.Errorf(\"unable to convert _LIBCONTAINER_LOGPIPE: %w\", err)",
      "296:  }",
      "300:  os.Clearenv()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "299:  mountFds, err := parseMountFds()",
      "300:  if err != nil {",
      "301:   return err",
      "302:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "305:   }",
      "306:  }()",
      "309:  if err != nil {",
      "310:   return err",
      "311:  }",
      "",
      "[Removed Lines]",
      "308:  i, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd)",
      "",
      "[Added Lines]",
      "314:  i, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd, mountFds)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "359:   return nil",
      "360:  }",
      "361: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "369: func parseMountFds() ([]int, error) {",
      "370:  fdsJson := os.Getenv(\"_LIBCONTAINER_MOUNT_FDS\")",
      "371:  if fdsJson == \"\" {",
      "373:   return nil, nil",
      "374:  }",
      "376:  var mountFds []int",
      "377:  if err := json.Unmarshal([]byte(fdsJson), &mountFds); err != nil {",
      "378:   return nil, fmt.Errorf(\"Error unmarshalling _LIBCONTAINER_MOUNT_FDS: %w\", err)",
      "379:  }",
      "381:  return mountFds, nil",
      "382: }",
      "",
      "---------------"
    ],
    "libcontainer/init_linux.go||libcontainer/init_linux.go": [
      "File: libcontainer/init_linux.go -> libcontainer/init_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "76:  Init() error",
      "77: }",
      "80:  var config *initConfig",
      "81:  if err := json.NewDecoder(pipe).Decode(&config); err != nil {",
      "82:   return nil, err",
      "",
      "[Removed Lines]",
      "79: func newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd, logFd int) (initer, error) {",
      "",
      "[Added Lines]",
      "79: func newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd, logFd int, mountFds []int) (initer, error) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "86:  }",
      "87:  switch t {",
      "88:  case initSetns:",
      "89:   return &linuxSetnsInit{",
      "90:    pipe:          pipe,",
      "91:    consoleSocket: consoleSocket,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "90:   if mountFds != nil {",
      "91:    return nil, errors.New(\"mountFds must be nil. Can't mount while doing runc exec.\")",
      "92:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "100:    config:        config,",
      "101:    fifoFd:        fifoFd,",
      "102:    logFd:         logFd,",
      "103:   }, nil",
      "104:  }",
      "105:  return nil, fmt.Errorf(\"unknown init type %q\", t)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "108:    mountFds:      mountFds,",
      "",
      "---------------"
    ],
    "libcontainer/message_linux.go||libcontainer/message_linux.go": [
      "File: libcontainer/message_linux.go -> libcontainer/message_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "18:  RootlessEUIDAttr uint16 = 27287",
      "19:  UidmapPathAttr   uint16 = 27288",
      "20:  GidmapPathAttr   uint16 = 27289",
      "21: )",
      "23: type Int32msg struct {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "21:  MountSourcesAttr uint16 = 27290",
      "",
      "---------------"
    ],
    "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c": [
      "File: libcontainer/nsenter/nsexec.c -> libcontainer/nsenter/nsexec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4: #include <errno.h>",
      "5: #include <fcntl.h>",
      "6: #include <grp.h>",
      "7: #include <sched.h>",
      "8: #include <setjmp.h>",
      "9: #include <signal.h>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7: #include <limits.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "87:  size_t uidmappath_len;",
      "88:  char *gidmappath;",
      "89:  size_t gidmappath_len;",
      "90: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "95:  char *mountsources;",
      "96:  size_t mountsources_len;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "119: #define ROOTLESS_EUID_ATTR 27287",
      "120: #define UIDMAPPATH_ATTR  27288",
      "121: #define GIDMAPPATH_ATTR  27289",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "129: #define MOUNT_SOURCES_ATTR 27290",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "542:   case SETGROUP_ATTR:",
      "543:    config->is_setgroup = readint8(current);",
      "544:    break;",
      "545:   default:",
      "546:    bail(\"unknown netlink message type %d\", nlattr->nla_type);",
      "547:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "553:   case MOUNT_SOURCES_ATTR:",
      "554:    config->mountsources = current;",
      "555:    config->mountsources_len = payload_len;",
      "556:    break;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "633:   return 0;",
      "634: }",
      "636: void nsexec(void)",
      "637: {",
      "638:  int pipenum;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "648: void receive_fd(int sockfd, int new_fd)",
      "649: {",
      "650:  int bytes_read;",
      "651:  struct msghdr msg = { };",
      "652:  struct cmsghdr *cmsg;",
      "653:  struct iovec iov = { };",
      "654:  char null_byte = '\\0';",
      "655:  int ret;",
      "656:  int fd_count;",
      "657:  int *fd_payload;",
      "659:  iov.iov_base = &null_byte;",
      "660:  iov.iov_len = 1;",
      "662:  msg.msg_iov = &iov;",
      "663:  msg.msg_iovlen = 1;",
      "665:  msg.msg_controllen = CMSG_SPACE(sizeof(int));",
      "666:  msg.msg_control = malloc(msg.msg_controllen);",
      "667:  if (msg.msg_control == NULL) {",
      "668:   bail(\"Can't allocate memory to receive fd.\");",
      "669:  }",
      "671:  memset(msg.msg_control, 0, msg.msg_controllen);",
      "673:  bytes_read = recvmsg(sockfd, &msg, 0);",
      "674:  if (bytes_read != 1)",
      "675:   bail(\"failed to receive fd from unix socket %d\", sockfd);",
      "676:  if (msg.msg_flags & MSG_CTRUNC)",
      "677:   bail(\"received truncated control message from unix socket %d\", sockfd);",
      "679:  cmsg = CMSG_FIRSTHDR(&msg);",
      "680:  if (!cmsg)",
      "681:   bail(\"received message from unix socket %d without control message\", sockfd);",
      "683:  if (cmsg->cmsg_level != SOL_SOCKET)",
      "684:   bail(\"received unknown control message from unix socket %d: cmsg_level=%d\", sockfd, cmsg->cmsg_level);",
      "686:  if (cmsg->cmsg_type != SCM_RIGHTS)",
      "687:   bail(\"received unknown control message from unix socket %d: cmsg_type=%d\", sockfd, cmsg->cmsg_type);",
      "689:  fd_count = (cmsg->cmsg_len - CMSG_LEN(0)) / sizeof(int);",
      "690:  if (fd_count != 1)",
      "691:   bail(\"received control message from unix socket %d with too many fds: %d\", sockfd, fd_count);",
      "693:  fd_payload = (int *)CMSG_DATA(cmsg);",
      "694:  ret = dup3(*fd_payload, new_fd, O_CLOEXEC);",
      "695:  if (ret < 0)",
      "696:   bail(\"cannot dup3 fd %d to %d\", *fd_payload, new_fd);",
      "698:  free(msg.msg_control);",
      "700:  ret = close(*fd_payload);",
      "701:  if (ret < 0)",
      "702:   bail(\"cannot close fd %d\", *fd_payload);",
      "703: }",
      "705: void send_fd(int sockfd, int fd)",
      "706: {",
      "707:  int bytes_written;",
      "708:  struct msghdr msg = { };",
      "709:  struct cmsghdr *cmsg;",
      "710:  struct iovec iov[1] = { };",
      "711:  char null_byte = '\\0';",
      "713:  iov[0].iov_base = &null_byte;",
      "714:  iov[0].iov_len = 1;",
      "716:  msg.msg_iov = iov;",
      "717:  msg.msg_iovlen = 1;",
      "721:  msg.msg_controllen = CMSG_SPACE(sizeof(int));",
      "722:  msg.msg_control = malloc(msg.msg_controllen);",
      "723:  if (msg.msg_control == NULL) {",
      "724:   bail(\"Can't allocate memory to send fd.\");",
      "725:  }",
      "727:  memset(msg.msg_control, 0, msg.msg_controllen);",
      "729:  cmsg = CMSG_FIRSTHDR(&msg);",
      "730:  cmsg->cmsg_level = SOL_SOCKET;",
      "731:  cmsg->cmsg_type = SCM_RIGHTS;",
      "732:  cmsg->cmsg_len = CMSG_LEN(sizeof(int));",
      "733:  memcpy(CMSG_DATA(cmsg), &fd, sizeof(int));",
      "735:  bytes_written = sendmsg(sockfd, &msg, 0);",
      "737:  free(msg.msg_control);",
      "739:  if (bytes_written != 1)",
      "740:   bail(\"failed to send fd %d via unix socket %d\", fd, sockfd);",
      "741: }",
      "743: void receive_mountsources(int sockfd)",
      "744: {",
      "745:  char *mount_fds, *endp;",
      "746:  long new_fd;",
      "749:  mount_fds = getenv(\"_LIBCONTAINER_MOUNT_FDS\");",
      "751:  if (mount_fds[0] != '[') {",
      "752:   bail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: missing '['\");",
      "753:  }",
      "754:  mount_fds++;",
      "756:  for (endp = mount_fds; *endp != ']'; mount_fds = endp + 1) {",
      "757:   new_fd = strtol(mount_fds, &endp, 10);",
      "758:   if (endp == mount_fds) {",
      "759:    bail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: not a number\");",
      "760:   }",
      "761:   if (*endp == '\\0') {",
      "762:    bail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: missing ]\");",
      "763:   }",
      "765:   if (new_fd == -1) {",
      "766:    continue;",
      "767:   }",
      "769:   if (new_fd == LONG_MAX || new_fd < 0 || new_fd > INT_MAX) {",
      "770:    bail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: fds out of range\");",
      "771:   }",
      "773:   receive_fd(sockfd, new_fd);",
      "774:  }",
      "775: }",
      "777: void send_mountsources(int sockfd, pid_t child, char *mountsources, size_t mountsources_len)",
      "778: {",
      "779:  char proc_path[PATH_MAX];",
      "780:  int host_mntns_fd;",
      "781:  int container_mntns_fd;",
      "782:  int fd;",
      "783:  int ret;",
      "787:  if (mountsources == NULL)",
      "788:   return;",
      "790:  host_mntns_fd = open(\"/proc/self/ns/mnt\", O_RDONLY | O_CLOEXEC);",
      "791:  if (host_mntns_fd == -1)",
      "792:   bail(\"failed to get current mount namespace\");",
      "794:  if (snprintf(proc_path, PATH_MAX, \"/proc/%d/ns/mnt\", child) < 0)",
      "795:   bail(\"failed to get mount namespace path\");",
      "797:  container_mntns_fd = open(proc_path, O_RDONLY | O_CLOEXEC);",
      "798:  if (container_mntns_fd == -1)",
      "799:   bail(\"failed to get container mount namespace\");",
      "801:  if (setns(container_mntns_fd, CLONE_NEWNS) < 0)",
      "802:   bail(\"failed to setns to container mntns\");",
      "804:  char *mountsources_end = mountsources + mountsources_len;",
      "805:  while (mountsources < mountsources_end) {",
      "806:   if (mountsources[0] == '\\0') {",
      "807:    mountsources++;",
      "808:    continue;",
      "809:   }",
      "811:   fd = open(mountsources, O_PATH | O_CLOEXEC);",
      "812:   if (fd < 0)",
      "813:    bail(\"failed to open mount source %s\", mountsources);",
      "815:   send_fd(sockfd, fd);",
      "817:   ret = close(fd);",
      "818:   if (ret != 0)",
      "819:    bail(\"failed to close mount source fd %d\", fd);",
      "821:   mountsources += strlen(mountsources) + 1;",
      "822:  }",
      "824:  if (setns(host_mntns_fd, CLONE_NEWNS) < 0)",
      "825:   bail(\"failed to setns to host mntns\");",
      "827:  ret = close(host_mntns_fd);",
      "828:  if (ret != 0)",
      "829:   bail(\"failed to close host mount namespace fd %d\", host_mntns_fd);",
      "830:  ret = close(container_mntns_fd);",
      "831:  if (ret != 0)",
      "832:   bail(\"failed to close container mount namespace fd %d\", container_mntns_fd);",
      "833: }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "865:       bail(\"failed to sync with runc: write(pid-JSON)\");",
      "866:      }",
      "867:      break;",
      "868:     case SYNC_CHILD_FINISH:",
      "869:      write_log(DEBUG, \"stage-1 complete\");",
      "870:      stage1_complete = true;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1067:     case SYNC_MOUNTSOURCES_PLS:",
      "1068:      send_mountsources(syncfd, stage1_pid, config.mountsources,",
      "1069:          config.mountsources_len);",
      "1071:      s = SYNC_MOUNTSOURCES_ACK;",
      "1072:      if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {",
      "1073:       kill(stage1_pid, SIGKILL);",
      "1074:       bail(\"failed to sync with child: write(SYNC_MOUNTSOURCES_ACK)\");",
      "1075:      }",
      "1076:      break;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1019:    if (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)",
      "1020:     bail(\"failed to unshare remaining namespaces (except cgroupns)\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1232:    if (config.mountsources) {",
      "1233:     s = SYNC_MOUNTSOURCES_PLS;",
      "1234:     if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {",
      "1235:      kill(stage2_pid, SIGKILL);",
      "1236:      bail(\"failed to sync with parent: write(SYNC_MOUNTSOURCES_PLS)\");",
      "1237:     }",
      "1240:     receive_mountsources(syncfd);",
      "1243:     if (read(syncfd, &s, sizeof(s)) != sizeof(s)) {",
      "1244:      kill(stage2_pid, SIGKILL);",
      "1245:      bail(\"failed to sync with parent: read(SYNC_MOUNTSOURCES_ACK)\");",
      "1246:     }",
      "1247:     if (s != SYNC_MOUNTSOURCES_ACK) {",
      "1248:      kill(stage2_pid, SIGKILL);",
      "1249:      bail(\"failed to sync with parent: SYNC_MOUNTSOURCES_ACK: got %u\", s);",
      "1250:     }",
      "1251:    }",
      "",
      "---------------"
    ],
    "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go": [
      "File: libcontainer/rootfs_linux.go -> libcontainer/rootfs_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "36:  cgroup2Path     string",
      "37:  rootlessCgroups bool",
      "38:  cgroupns        bool",
      "39: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "39:  fd              *int",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "55:  config := iConfig.Config",
      "56:  if err := prepareRoot(config); err != nil {",
      "57:   return fmt.Errorf(\"error preparing rootfs: %w\", err)",
      "58:  }",
      "60:  mountConfig := &mountConfig{",
      "61:   root:            config.Rootfs,",
      "62:   label:           config.MountLabel,",
      "",
      "[Removed Lines]",
      "54: func prepareRootfs(pipe io.ReadWriter, iConfig *initConfig) (err error) {",
      "",
      "[Added Lines]",
      "55: func prepareRootfs(pipe io.ReadWriter, iConfig *initConfig, mountFds []int) (err error) {",
      "61:  if mountFds != nil && len(mountFds) != len(config.Mounts) {",
      "62:   return fmt.Errorf(\"malformed mountFds slice. Expected size: %v, got: %v. Slice: %v\", len(config.Mounts), len(mountFds), mountFds)",
      "63:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "65:   cgroupns:        config.Namespaces.Contains(configs.NEWCGROUP),",
      "66:  }",
      "67:  setupDev := needsSetupDev(config)",
      "69:   for _, precmd := range m.PremountCmds {",
      "70:    if err := mountCmd(precmd); err != nil {",
      "71:     return fmt.Errorf(\"error running premount command: %w\", err)",
      "72:    }",
      "73:   }",
      "74:   if err := mountToRootfs(m, mountConfig); err != nil {",
      "75:    return fmt.Errorf(\"error mounting %q to rootfs at %q: %w\", m.Source, m.Destination, err)",
      "76:   }",
      "",
      "[Removed Lines]",
      "68:  for _, m := range config.Mounts {",
      "",
      "[Added Lines]",
      "73:  for i, m := range config.Mounts {",
      "82:   if mountFds != nil && mountFds[i] != -1 {",
      "83:    mountConfig.fd = &mountFds[i]",
      "84:   }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "210:  return nil",
      "211: }",
      "215:  if err != nil {",
      "",
      "[Removed Lines]",
      "213: func prepareBindMount(m *configs.Mount, rootfs string) error {",
      "214:  stat, err := os.Stat(m.Source)",
      "",
      "[Added Lines]",
      "225: func prepareBindMount(m *configs.Mount, rootfs string, mountFd *int) error {",
      "226:  source := m.Source",
      "227:  if mountFd != nil {",
      "228:   source = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)",
      "229:  }",
      "231:  stat, err := os.Stat(source)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "225:  if dest, err = securejoin.SecureJoin(rootfs, m.Destination); err != nil {",
      "226:   return err",
      "227:  }",
      "229:   return err",
      "230:  }",
      "231:  if err := createIfNotExists(dest, stat.IsDir()); err != nil {",
      "",
      "[Removed Lines]",
      "228:  if err := checkProcMount(rootfs, dest, m.Source); err != nil {",
      "",
      "[Added Lines]",
      "245:  if err := checkProcMount(rootfs, dest, source); err != nil {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "348:  oldDest := m.Destination",
      "349:  m.Destination = tmpDir",
      "351:  m.Destination = oldDest",
      "352:  if err != nil {",
      "353:   return err",
      "",
      "[Removed Lines]",
      "350:  err = mountPropagate(m, \"/\", mountLabel)",
      "",
      "[Added Lines]",
      "369:  err = mountPropagate(m, \"/\", mountLabel, nil)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "378: func mountToRootfs(m *configs.Mount, c *mountConfig) error {",
      "379:  rootfs := c.root",
      "380:  mountLabel := c.label",
      "381:  dest, err := securejoin.SecureJoin(rootfs, m.Destination)",
      "382:  if err != nil {",
      "383:   return err",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "400:  mountFd := c.fd",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "401:    return err",
      "402:   }",
      "405:  case \"mqueue\":",
      "406:   if err := os.MkdirAll(dest, 0o755); err != nil {",
      "407:    return err",
      "408:   }",
      "410:    return err",
      "411:   }",
      "412:   return label.SetFileLabel(dest, mountLabel)",
      "",
      "[Removed Lines]",
      "404:   return mountPropagate(m, rootfs, \"\")",
      "409:   if err := mountPropagate(m, rootfs, \"\"); err != nil {",
      "",
      "[Added Lines]",
      "424:   return mountPropagate(m, rootfs, \"\", nil)",
      "429:   if err := mountPropagate(m, rootfs, \"\", nil); err != nil {",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "421:   if m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP {",
      "422:    err = doTmpfsCopyUp(m, rootfs, mountLabel)",
      "423:   } else {",
      "425:   }",
      "426:   if err != nil {",
      "427:    return err",
      "428:   }",
      "429:   if stat != nil {",
      "430:    if err = os.Chmod(dest, stat.Mode()); err != nil {",
      "431:     return err",
      "",
      "[Removed Lines]",
      "424:    err = mountPropagate(m, rootfs, mountLabel)",
      "",
      "[Added Lines]",
      "444:    err = mountPropagate(m, rootfs, mountLabel, nil)",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "433:   }",
      "435:   if m.Flags&unix.MS_RDONLY != 0 {",
      "437:     return err",
      "438:    }",
      "439:   }",
      "440:   return nil",
      "441:  case \"bind\":",
      "443:    return err",
      "444:   }",
      "446:    return err",
      "447:   }",
      "450:   if m.Flags&^(unix.MS_REC|unix.MS_REMOUNT|unix.MS_BIND) != 0 {",
      "453:     return err",
      "454:    }",
      "455:   }",
      "",
      "[Removed Lines]",
      "436:    if err := remount(m, rootfs); err != nil {",
      "442:   if err := prepareBindMount(m, rootfs); err != nil {",
      "445:   if err := mountPropagate(m, rootfs, mountLabel); err != nil {",
      "452:    if err := remount(m, rootfs); err != nil {",
      "",
      "[Added Lines]",
      "458:    if err := remount(m, rootfs, mountFd); err != nil {",
      "464:   if err := prepareBindMount(m, rootfs, mountFd); err != nil {",
      "467:   if err := mountPropagate(m, rootfs, mountLabel, mountFd); err != nil {",
      "474:    if err := remount(m, rootfs, mountFd); err != nil {",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "475:   if err := os.MkdirAll(dest, 0o755); err != nil {",
      "476:    return err",
      "477:   }",
      "479:  }",
      "480:  return nil",
      "481: }",
      "",
      "[Removed Lines]",
      "478:   return mountPropagate(m, rootfs, mountLabel)",
      "",
      "[Added Lines]",
      "500:   return mountPropagate(m, rootfs, mountLabel, mountFd)",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "1037:  return ioutil.WriteFile(path.Join(\"/proc/sys\", keyPath), []byte(value), 0o644)",
      "1038: }",
      "1041:  return utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {",
      "1043:  })",
      "1044: }",
      "1049:  var (",
      "1050:   data  = label.FormatMountLabel(m.Data, mountLabel)",
      "1051:   flags = m.Flags",
      "",
      "[Removed Lines]",
      "1040: func remount(m *configs.Mount, rootfs string) error {",
      "1042:   return mount(m.Source, m.Destination, procfd, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")",
      "1048: func mountPropagate(m *configs.Mount, rootfs string, mountLabel string) error {",
      "",
      "[Added Lines]",
      "1062: func remount(m *configs.Mount, rootfs string, mountFd *int) error {",
      "1063:  source := m.Source",
      "1064:  if mountFd != nil {",
      "1065:   source = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)",
      "1066:  }",
      "1069:   return mount(source, m.Destination, procfd, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")",
      "1075: func mountPropagate(m *configs.Mount, rootfs string, mountLabel string, mountFd *int) error {",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "1065:  if err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {",
      "1067:  }); err != nil {",
      "1068:   return err",
      "1069:  }",
      "",
      "[Removed Lines]",
      "1066:   return mount(m.Source, m.Destination, procfd, m.Device, uintptr(flags), data)",
      "",
      "[Added Lines]",
      "1092:  source := m.Source",
      "1093:  if mountFd != nil {",
      "1094:   source = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)",
      "1095:  }",
      "1098:   return mount(source, m.Destination, procfd, m.Device, uintptr(flags), data)",
      "",
      "---------------"
    ],
    "libcontainer/standard_init_linux.go||libcontainer/standard_init_linux.go": [
      "File: libcontainer/standard_init_linux.go -> libcontainer/standard_init_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "26:  parentPid     int",
      "27:  fifoFd        int",
      "28:  logFd         int",
      "29:  config        *initConfig",
      "30: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "29:  mountFds      []int",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "89:  selinux.GetEnabled()",
      "91:   return err",
      "92:  }",
      "",
      "[Removed Lines]",
      "90:  if err := prepareRootfs(l.pipe, l.config); err != nil {",
      "",
      "[Added Lines]",
      "93:  err := prepareRootfs(l.pipe, l.config, l.mountFds)",
      "94:  for _, m := range l.mountFds {",
      "95:   if m == -1 {",
      "96:    continue",
      "97:   }",
      "99:   if err := unix.Close(m); err != nil {",
      "100:    return fmt.Errorf(\"Unable to close mountFds fds: %w\", err)",
      "101:   }",
      "102:  }",
      "104:  if err != nil {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "81fdc8ce1c83ada66a1076a52d72f228ee1f7b0e",
      "candidate_info": {
        "commit_hash": "81fdc8ce1c83ada66a1076a52d72f228ee1f7b0e",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/81fdc8ce1c83ada66a1076a52d72f228ee1f7b0e",
        "files": [
          "tests/integration/userns.bats"
        ],
        "message": "New integration tests for user namespaces bind sources\n\nThe previous commit fixed an issue opening bind mount sources. This\ncommit just adds integration tests to make sure we don't regress on this\nin the future.\n\nSigned-off-by: Alban Crequy <alban@kinvolk.io>\nSigned-off-by: Rodrigo Campos <rodrigo@kinvolk.io>\nCo-authored-by: Rodrigo Campos <rodrigo@kinvolk.io>",
        "before_after_code_files": [
          "tests/integration/userns.bats||tests/integration/userns.bats"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/opencontainers/runc/pull/2576"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/integration/userns.bats||tests/integration/userns.bats": [
          "File: tests/integration/userns.bats -> tests/integration/userns.bats",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env bats",
          "3: load helpers",
          "5: function setup() {",
          "6:  setup_busybox",
          "8:  # Prepare source folders for bind mount",
          "9:  mkdir -p source-{accessible,inaccessible-1,inaccessible-2}/dir",
          "10:  touch source-{accessible,inaccessible-1,inaccessible-2}/dir/foo.txt",
          "12:  # Permissions only to the owner, it is inaccessible to group/others",
          "13:  chmod 700 source-inaccessible-{1,2}",
          "15:  mkdir -p rootfs/{proc,sys,tmp}",
          "16:  mkdir -p rootfs/tmp/mount-{1,2}",
          "18:  # We need to give permissions for others so the uid inside the userns",
          "19:  # can mount the rootfs on itself. Otherwise the rootfs mount will fail.",
          "20:  chmod 755 \"$ROOT\"",
          "22:  if [ \"$ROOTLESS\" -eq 0 ]; then",
          "23:   update_config ' .linux.namespaces += [{\"type\": \"user\"}]",
          "24:    | .linux.uidMappings += [{\"hostID\": 100000, \"containerID\": 0, \"size\": 65534}]",
          "25:    | .linux.gidMappings += [{\"hostID\": 100000, \"containerID\": 0, \"size\": 65534}] '",
          "26:  fi",
          "27: }",
          "29: function teardown() {",
          "30:  teardown_bundle",
          "31: }",
          "33: @test \"userns with simple mount\" {",
          "34:  update_config ' .process.args += [\"-c\", \"stat /tmp/mount-1/foo.txt\"]",
          "35:   | .mounts += [{\"source\": \"source-accessible/dir\", \"destination\": \"/tmp/mount-1\", \"options\": [\"bind\"]}] '",
          "37:  runc run test_busybox",
          "38:  [ \"$status\" -eq 0 ]",
          "39: }",
          "41: # We had bugs where 1 mount worked but not 2+, test with 2 as it is a more",
          "42: # general case.",
          "43: @test \"userns with 2 inaccessible mounts\" {",
          "44:  update_config '   .process.args += [\"-c\", \"stat /tmp/mount-1/foo.txt /tmp/mount-2/foo.txt\"]",
          "45:    | .mounts += [ { \"source\": \"source-inaccessible-1/dir\", \"destination\": \"/tmp/mount-1\", \"options\": [\"bind\"] },",
          "46:                    { \"source\": \"source-inaccessible-2/dir\", \"destination\": \"/tmp/mount-2\", \"options\": [\"bind\"] }",
          "47:               ]'",
          "49:  # When not running rootless, this should work: while",
          "50:  # \"source-inaccessible-1\" can't be read by the uid in the userns, the fd",
          "51:  # is opened before changing to the userns and sent over via SCM_RIGHTs",
          "52:  # (with env var _LIBCONTAINER_MOUNT_FDS). Idem for",
          "53:  # source-inaccessible-2.",
          "54:  # On rootless, the owner is the same so it is accessible.",
          "55:  runc run test_busybox",
          "56:  [ \"$status\" -eq 0 ]",
          "57: }",
          "59: # exec + bindmounts + user ns is a special case in the code. Test that it works.",
          "60: @test \"userns with inaccessible mount + exec\" {",
          "61:  update_config ' .mounts += [  { \"source\": \"source-inaccessible-1/dir\", \"destination\": \"/tmp/mount-1\", \"options\": [\"bind\"] },",
          "62:      { \"source\": \"source-inaccessible-2/dir\", \"destination\": \"/tmp/mount-2\", \"options\": [\"bind\"] }",
          "63:             ]'",
          "65:  runc run -d --console-socket \"$CONSOLE_SOCKET\" test_busybox",
          "66:  [ \"$status\" -eq 0 ]",
          "68:  runc exec test_busybox stat /tmp/mount-1/foo.txt /tmp/mount-2/foo.txt",
          "69:  [ \"$status\" -eq 0 ]",
          "70: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8542322dfe80b92c94291fd7427a9ca307017403",
      "candidate_info": {
        "commit_hash": "8542322dfe80b92c94291fd7427a9ca307017403",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/8542322dfe80b92c94291fd7427a9ca307017403",
        "files": [
          "libcontainer/integration/exec_test.go",
          "libcontainer/integration/utils_test.go"
        ],
        "message": "libcontainer: Add unit tests with userns and mounts\n\nAdd a unit test to check that bind mounts that have a part of its\npath non accessible by others still work when using user namespaces.\n\nTo do this, we also modify newRoot() to return rootfs directories that\ncan be traverse by others, so the rootfs created works for all test\n(either running in a userns or not).\n\nSigned-off-by: Mauricio V\u00e1squez <mauricio@kinvolk.io>\nSigned-off-by: Rodrigo Campos <rodrigo@kinvolk.io>\nCo-authored-by: Rodrigo Campos <rodrigo@kinvolk.io>",
        "before_after_code_files": [
          "libcontainer/integration/exec_test.go||libcontainer/integration/exec_test.go",
          "libcontainer/integration/utils_test.go||libcontainer/integration/utils_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/opencontainers/runc/pull/2576"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libcontainer/integration/exec_test.go||libcontainer/integration/exec_test.go": [
          "File: libcontainer/integration/exec_test.go -> libcontainer/integration/exec_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import (",
          "4:  \"bytes\"",
          "5:  \"encoding/json\"",
          "6:  \"fmt\"",
          "7:  \"io/ioutil\"",
          "8:  \"os\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6:  \"errors\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1838:   t.Fatalf(\"found %d extra fds after container.Run\", count)",
          "1839:  }",
          "1840: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1845: func TestBindMountAndUser(t *testing.T) {",
          "1846:  if _, err := os.Stat(\"/proc/self/ns/user\"); errors.Is(err, os.ErrNotExist) {",
          "1847:   t.Skip(\"userns is unsupported\")",
          "1848:  }",
          "1850:  if testing.Short() {",
          "1851:   return",
          "1852:  }",
          "1854:  temphost := t.TempDir()",
          "1855:  dirhost := filepath.Join(temphost, \"inaccessible\", \"dir\")",
          "1857:  err := os.MkdirAll(dirhost, 0o755)",
          "1858:  ok(t, err)",
          "1860:  err = ioutil.WriteFile(filepath.Join(dirhost, \"foo.txt\"), []byte(\"Hello\"), 0o755)",
          "1861:  ok(t, err)",
          "1864:  err = os.Chmod(filepath.Join(temphost, \"inaccessible\"), 0o700)",
          "1865:  ok(t, err)",
          "1867:  config := newTemplateConfig(t, &tParam{",
          "1868:   userns: true,",
          "1869:  })",
          "1872:  config.UidMappings[0].HostID = 1000",
          "1873:  config.GidMappings[0].HostID = 1000",
          "1877:  err = os.Chown(config.Rootfs, 1000, 1000)",
          "1878:  ok(t, err)",
          "1880:  config.Mounts = append(config.Mounts, &configs.Mount{",
          "1881:   Source:      dirhost,",
          "1882:   Destination: \"/tmp/mnt1cont\",",
          "1883:   Device:      \"bind\",",
          "1884:   Flags:       unix.MS_BIND | unix.MS_REC,",
          "1885:  })",
          "1887:  container, err := newContainer(t, config)",
          "1888:  ok(t, err)",
          "1889:  defer container.Destroy() //nolint: errcheck",
          "1891:  var stdout bytes.Buffer",
          "1893:  pconfig := libcontainer.Process{",
          "1894:   Cwd:    \"/\",",
          "1895:   Args:   []string{\"sh\", \"-c\", \"stat /tmp/mnt1cont/foo.txt\"},",
          "1896:   Env:    standardEnvironment,",
          "1897:   Stdout: &stdout,",
          "1898:   Init:   true,",
          "1899:  }",
          "1900:  err = container.Run(&pconfig)",
          "1901:  ok(t, err)",
          "1903:  waitProcess(&pconfig, t)",
          "1904: }",
          "",
          "---------------"
        ],
        "libcontainer/integration/utils_test.go||libcontainer/integration/utils_test.go": [
          "File: libcontainer/integration/utils_test.go -> libcontainer/integration/utils_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "105:  if err := copyBusybox(dir); err != nil {",
          "106:   t.Fatal(err)",
          "107:  }",
          "108:  return dir",
          "109: }",
          "111: func remove(dir string) {",
          "112:  _ = os.RemoveAll(dir)",
          "113: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111:  if err := traversePath(dir); err != nil {",
          "112:   t.Fatalf(\"Error making newRootfs path traversable by others: %v\", err)",
          "113:  }",
          "121: func traversePath(tPath string) error {",
          "123:  tempBase := os.TempDir()",
          "124:  if !strings.HasPrefix(tPath, tempBase) {",
          "125:   return fmt.Errorf(\"traversePath: %q is not a descendant of %q\", tPath, tempBase)",
          "126:  }",
          "128:  var path string",
          "129:  for _, p := range strings.SplitAfter(tPath, \"/\") {",
          "130:   path = path + p",
          "131:   stats, err := os.Stat(path)",
          "132:   if err != nil {",
          "133:    return err",
          "134:   }",
          "136:   perm := stats.Mode().Perm()",
          "138:   if perm&0o5 == 0o5 {",
          "139:    continue",
          "140:   }",
          "142:   if strings.HasPrefix(tempBase, path) {",
          "143:    return fmt.Errorf(\"traversePath: directory %q MUST have read+exec permissions for others\", path)",
          "144:   }",
          "146:   if err := os.Chmod(path, perm|0o5); err != nil {",
          "147:    return err",
          "148:   }",
          "149:  }",
          "151:  return nil",
          "152: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "485e6c84e7ef783c126c392af072a974c9fb88ce",
      "candidate_info": {
        "commit_hash": "485e6c84e7ef783c126c392af072a974c9fb88ce",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/485e6c84e7ef783c126c392af072a974c9fb88ce",
        "files": [
          "libcontainer/factory_linux.go",
          "libcontainer/init_linux.go",
          "notify_socket.go"
        ],
        "message": "Fix some revive warnings\n\nThis is needed since the future commits will touch this code, and then\nthe lint-extra CI job complains.\n\n> libcontainer/factory.go#L245\n> var-naming: var fdsJson should be fdsJSON (revive)\n\nand\n\n> libcontainer/init_linux.go#L181\n> error-strings: error strings should not be capitalized or end with punctuation or a newline (revive)\n\nand\n\n> notify_socket.go#L94\n> receiver-naming: receiver name n should be consistent with previous receiver name s for notifySocket (revive)\n\nSigned-off-by: Kir Kolyshkin <kolyshkin@gmail.com>",
        "before_after_code_files": [
          "libcontainer/factory_linux.go||libcontainer/factory_linux.go",
          "libcontainer/init_linux.go||libcontainer/init_linux.go",
          "notify_socket.go||notify_socket.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libcontainer/factory_linux.go||libcontainer/factory_linux.go",
            "libcontainer/init_linux.go||libcontainer/init_linux.go"
          ],
          "candidate": [
            "libcontainer/factory_linux.go||libcontainer/factory_linux.go",
            "libcontainer/init_linux.go||libcontainer/init_linux.go"
          ]
        }
      },
      "candidate_diff": {
        "libcontainer/factory_linux.go||libcontainer/factory_linux.go": [
          "File: libcontainer/factory_linux.go -> libcontainer/factory_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "400: }",
          "402: func parseMountFds() ([]int, error) {",
          "406:   return nil, nil",
          "407:  }",
          "409:  var mountFds []int",
          "411:   return nil, fmt.Errorf(\"Error unmarshalling _LIBCONTAINER_MOUNT_FDS: %w\", err)",
          "412:  }",
          "",
          "[Removed Lines]",
          "403:  fdsJson := os.Getenv(\"_LIBCONTAINER_MOUNT_FDS\")",
          "404:  if fdsJson == \"\" {",
          "410:  if err := json.Unmarshal([]byte(fdsJson), &mountFds); err != nil {",
          "",
          "[Added Lines]",
          "403:  fdsJSON := os.Getenv(\"_LIBCONTAINER_MOUNT_FDS\")",
          "404:  if fdsJSON == \"\" {",
          "410:  if err := json.Unmarshal([]byte(fdsJSON), &mountFds); err != nil {",
          "",
          "---------------"
        ],
        "libcontainer/init_linux.go||libcontainer/init_linux.go": [
          "File: libcontainer/init_linux.go -> libcontainer/init_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:  case initSetns:",
          "89:   if mountFds != nil {",
          "91:   }",
          "93:   return &linuxSetnsInit{",
          "",
          "[Removed Lines]",
          "90:    return nil, errors.New(\"mountFds must be nil. Can't mount while doing runc exec.\")",
          "",
          "[Added Lines]",
          "90:    return nil, errors.New(\"mountFds must be nil; can't mount from exec\")",
          "",
          "---------------"
        ],
        "notify_socket.go||notify_socket.go": [
          "File: notify_socket.go -> notify_socket.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "91:  return notifySocket, nil",
          "92: }",
          "96:  if err != nil {",
          "97:   return err",
          "98:  }",
          "100: }",
          "102: func (n *notifySocket) run(pid1 int) error {",
          "",
          "[Removed Lines]",
          "94: func (n *notifySocket) waitForContainer(container libcontainer.Container) error {",
          "95:  s, err := container.State()",
          "99:  return n.run(s.InitProcessPid)",
          "",
          "[Added Lines]",
          "94: func (s *notifySocket) waitForContainer(container libcontainer.Container) error {",
          "95:  state, err := container.State()",
          "99:  return s.run(state.InitProcessPid)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d614445dd8f03d3b0fcf12ef9fbf11f1884a2aed",
      "candidate_info": {
        "commit_hash": "d614445dd8f03d3b0fcf12ef9fbf11f1884a2aed",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/d614445dd8f03d3b0fcf12ef9fbf11f1884a2aed",
        "files": [
          "libcontainer/nsenter/nsexec.c"
        ],
        "message": "[1.1] libct/nsenter: switch to sane_kill()\n\nSigned-off-by: guodong <guodong9211@gmail.com>",
        "before_after_code_files": [
          "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c"
          ],
          "candidate": [
            "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c"
          ]
        }
      },
      "candidate_diff": {
        "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c": [
          "File: libcontainer/nsenter/nsexec.c -> libcontainer/nsenter/nsexec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1069:      s = SYNC_MOUNTSOURCES_ACK;",
          "1070:      if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {",
          "1072:       bail(\"failed to sync with child: write(SYNC_MOUNTSOURCES_ACK)\");",
          "1073:      }",
          "1074:      break;",
          "",
          "[Removed Lines]",
          "1071:       kill(stage1_pid, SIGKILL);",
          "",
          "[Added Lines]",
          "1071:       sane_kill(stage1_pid, SIGKILL);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1230:    if (config.mountsources) {",
          "1231:     s = SYNC_MOUNTSOURCES_PLS;",
          "1232:     if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {",
          "1234:      bail(\"failed to sync with parent: write(SYNC_MOUNTSOURCES_PLS)\");",
          "1235:     }",
          "",
          "[Removed Lines]",
          "1233:      kill(stage2_pid, SIGKILL);",
          "",
          "[Added Lines]",
          "1233:      sane_kill(stage2_pid, SIGKILL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1241:     if (read(syncfd, &s, sizeof(s)) != sizeof(s)) {",
          "1243:      bail(\"failed to sync with parent: read(SYNC_MOUNTSOURCES_ACK)\");",
          "1244:     }",
          "1245:     if (s != SYNC_MOUNTSOURCES_ACK) {",
          "1247:      bail(\"failed to sync with parent: SYNC_MOUNTSOURCES_ACK: got %u\", s);",
          "1248:     }",
          "1249:    }",
          "",
          "[Removed Lines]",
          "1242:      kill(stage2_pid, SIGKILL);",
          "1246:      kill(stage2_pid, SIGKILL);",
          "",
          "[Added Lines]",
          "1242:      sane_kill(stage2_pid, SIGKILL);",
          "1246:      sane_kill(stage2_pid, SIGKILL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "201d60c51d0b78afb780841443200a25d63493a6",
      "candidate_info": {
        "commit_hash": "201d60c51d0b78afb780841443200a25d63493a6",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/201d60c51d0b78afb780841443200a25d63493a6",
        "files": [
          "libcontainer/container_linux.go",
          "libcontainer/container_linux_test.go",
          "libcontainer/factory_linux.go",
          "libcontainer/init_linux.go",
          "libcontainer/logs/logs.go",
          "libcontainer/logs/logs_linux_test.go",
          "libcontainer/process_linux.go",
          "libcontainer/restored_process.go",
          "libcontainer/setns_init_linux.go",
          "libcontainer/standard_init_linux.go"
        ],
        "message": "runc run/start/exec: fix init log forwarding race\n\nSometimes debug.bats test cases are failing like this:\n\n> not ok 27 global --debug to --log --log-format 'json'\n> # (in test file tests/integration/debug.bats, line 77)\n> #   `[[ \"${output}\" == *\"child process in init()\"* ]]' failed\n\nIt happens more when writing to disk.\n\nThis issue is caused by the fact that runc spawns log forwarding goroutine\n(ForwardLogs) but does not wait for it to finish, resulting in missing\ndebug lines from nsexec.\n\nForwardLogs itself, though, never finishes, because it reads from a\nreading side of a pipe which writing side is not closed. This is\nespecially true in case of runc create, which spawns runc init and\nexits; meanwhile runc init waits on exec fifo for arbitrarily long\ntime before doing execve.\n\nSo, to fix the failure described above, we need to:\n\n 1. Make runc create/run/exec wait for ForwardLogs to finish;\n\n 2. Make runc init close its log pipe file descriptor (i.e.\n    the one which value is passed in _LIBCONTAINER_LOGPIPE\n    environment variable).\n\nThis is exactly what this commit does:\n\n 1. Amend ForwardLogs to return a channel, and wait for it in start().\n\n 2. In runc init, save the log fd and close it as late as possible.\n\nPS I have to admit I still do not understand why an explicit close of\nlog pipe fd is required in e.g. (*linuxSetnsInit).Init, right before\nthe execve which (thanks to CLOEXEC) closes the fd anyway.\n\nSigned-off-by: Kir Kolyshkin <kolyshkin@gmail.com>",
        "before_after_code_files": [
          "libcontainer/container_linux.go||libcontainer/container_linux.go",
          "libcontainer/container_linux_test.go||libcontainer/container_linux_test.go",
          "libcontainer/factory_linux.go||libcontainer/factory_linux.go",
          "libcontainer/init_linux.go||libcontainer/init_linux.go",
          "libcontainer/logs/logs.go||libcontainer/logs/logs.go",
          "libcontainer/logs/logs_linux_test.go||libcontainer/logs/logs_linux_test.go",
          "libcontainer/process_linux.go||libcontainer/process_linux.go",
          "libcontainer/restored_process.go||libcontainer/restored_process.go",
          "libcontainer/setns_init_linux.go||libcontainer/setns_init_linux.go",
          "libcontainer/standard_init_linux.go||libcontainer/standard_init_linux.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libcontainer/container_linux.go||libcontainer/container_linux.go",
            "libcontainer/factory_linux.go||libcontainer/factory_linux.go",
            "libcontainer/init_linux.go||libcontainer/init_linux.go",
            "libcontainer/standard_init_linux.go||libcontainer/standard_init_linux.go"
          ],
          "candidate": [
            "libcontainer/container_linux.go||libcontainer/container_linux.go",
            "libcontainer/factory_linux.go||libcontainer/factory_linux.go",
            "libcontainer/init_linux.go||libcontainer/init_linux.go",
            "libcontainer/standard_init_linux.go||libcontainer/standard_init_linux.go"
          ]
        }
      },
      "candidate_diff": {
        "libcontainer/container_linux.go||libcontainer/container_linux.go": [
          "File: libcontainer/container_linux.go -> libcontainer/container_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "357:  err  error",
          "358: }",
          "361:  parent, err := c.newParentProcess(process)",
          "362:  if err != nil {",
          "363:   return newSystemErrorWithCause(err, \"creating new parent process\")",
          "364:  }",
          "366:  if err := parent.start(); err != nil {",
          "367:   return newSystemErrorWithCause(err, \"starting container process\")",
          "368:  }",
          "",
          "[Removed Lines]",
          "360: func (c *linuxContainer) start(process *Process) error {",
          "365:  parent.forwardChildLogs()",
          "",
          "[Added Lines]",
          "360: func (c *linuxContainer) start(process *Process) (retErr error) {",
          "366:  logsDone := parent.forwardChildLogs()",
          "367:  if logsDone != nil {",
          "368:   defer func() {",
          "371:    err := <-logsDone",
          "372:    if err != nil && retErr == nil {",
          "373:     retErr = newSystemErrorWithCause(err, \"forwarding init logs\")",
          "374:    }",
          "375:   }()",
          "376:  }",
          "",
          "---------------"
        ],
        "libcontainer/container_linux_test.go||libcontainer/container_linux_test.go": [
          "File: libcontainer/container_linux_test.go -> libcontainer/container_linux_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "139: func (m *mockProcess) setExternalDescriptors(newFds []string) {",
          "140: }",
          "143: }",
          "145: func TestGetContainerPids(t *testing.T) {",
          "",
          "[Removed Lines]",
          "142: func (m *mockProcess) forwardChildLogs() {",
          "",
          "[Added Lines]",
          "142: func (m *mockProcess) forwardChildLogs() chan error {",
          "143:  return nil",
          "",
          "---------------"
        ],
        "libcontainer/factory_linux.go||libcontainer/factory_linux.go": [
          "File: libcontainer/factory_linux.go -> libcontainer/factory_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "365:   defer consoleSocket.Close()",
          "366:  }",
          "370:  os.Clearenv()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "368:  logPipeFdStr := os.Getenv(\"_LIBCONTAINER_LOGPIPE\")",
          "369:  logPipeFd, err := strconv.Atoi(logPipeFdStr)",
          "370:  if err != nil {",
          "371:   return fmt.Errorf(\"unable to convert _LIBCONTAINER_LOGPIPE=%s to int: %s\", logPipeFdStr, err)",
          "372:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "387:   }",
          "388:  }()",
          "391:  if err != nil {",
          "392:   return err",
          "393:  }",
          "",
          "[Removed Lines]",
          "390:  i, err := newContainerInit(it, pipe, consoleSocket, fifofd)",
          "",
          "[Added Lines]",
          "396:  i, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd)",
          "",
          "---------------"
        ],
        "libcontainer/init_linux.go||libcontainer/init_linux.go": [
          "File: libcontainer/init_linux.go -> libcontainer/init_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "76:  Init() error",
          "77: }",
          "80:  var config *initConfig",
          "81:  if err := json.NewDecoder(pipe).Decode(&config); err != nil {",
          "82:   return nil, err",
          "",
          "[Removed Lines]",
          "79: func newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd int) (initer, error) {",
          "",
          "[Added Lines]",
          "79: func newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd, logFd int) (initer, error) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "90:    pipe:          pipe,",
          "91:    consoleSocket: consoleSocket,",
          "92:    config:        config,",
          "93:   }, nil",
          "94:  case initStandard:",
          "95:   return &linuxStandardInit{",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "93:    logFd:         logFd,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "98:    parentPid:     unix.Getppid(),",
          "99:    config:        config,",
          "100:    fifoFd:        fifoFd,",
          "101:   }, nil",
          "102:  }",
          "103:  return nil, fmt.Errorf(\"unknown init type %q\", t)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102:    logFd:         logFd,",
          "",
          "---------------"
        ],
        "libcontainer/logs/logs.go||libcontainer/logs/logs.go": [
          "File: libcontainer/logs/logs.go -> libcontainer/logs/logs.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: )",
          "15: var (",
          "19:  loggingConfigured = false",
          "",
          "[Removed Lines]",
          "16:  configureMutex = sync.Mutex{}",
          "",
          "[Added Lines]",
          "16:  configureMutex sync.Mutex",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "26:  LogPipeFd   int",
          "27: }",
          "30:  s := bufio.NewScanner(logPipe)",
          "39: }",
          "41: func processEntry(text []byte) {",
          "",
          "[Removed Lines]",
          "29: func ForwardLogs(logPipe io.Reader) {",
          "31:  for s.Scan() {",
          "32:   processEntry(s.Bytes())",
          "33:  }",
          "34:  if err := s.Err(); err != nil {",
          "35:   logrus.Errorf(\"log pipe read error: %+v\", err)",
          "36:  } else {",
          "37:   logrus.Debugf(\"log pipe closed\")",
          "38:  }",
          "",
          "[Added Lines]",
          "29: func ForwardLogs(logPipe io.ReadCloser) chan error {",
          "30:  done := make(chan error, 1)",
          "33:  go func() {",
          "34:   for s.Scan() {",
          "35:    processEntry(s.Bytes())",
          "36:   }",
          "37:   if err := logPipe.Close(); err != nil {",
          "38:    logrus.Errorf(\"error closing log source: %v\", err)",
          "39:   }",
          "42:   done <- s.Err()",
          "43:   close(done)",
          "44:  }()",
          "46:  return done",
          "",
          "---------------"
        ],
        "libcontainer/logs/logs_linux_test.go||libcontainer/logs/logs_linux_test.go": [
          "File: libcontainer/logs/logs_linux_test.go -> libcontainer/logs/logs_linux_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: type log struct {",
          "73:  w    io.WriteCloser",
          "74:  file string",
          "76: }",
          "78: func runLogForwarding(t *testing.T) *log {",
          "",
          "[Removed Lines]",
          "75:  done chan struct{}",
          "",
          "[Added Lines]",
          "75:  done chan error",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "99:  if err := ConfigureLogging(logConfig); err != nil {",
          "100:   t.Fatal(err)",
          "101:  }",
          "108:  return &log{w: logW, done: doneForwarding, file: logFile}",
          "109: }",
          "",
          "[Removed Lines]",
          "102:  doneForwarding := make(chan struct{})",
          "103:  go func() {",
          "104:   ForwardLogs(logR)",
          "105:   close(doneForwarding)",
          "106:  }()",
          "",
          "[Added Lines]",
          "103:  doneForwarding := ForwardLogs(logR)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "111: func finish(t *testing.T, l *log) {",
          "112:  t.Helper()",
          "113:  l.w.Close()",
          "115: }",
          "117: func truncateLogFile(t *testing.T, logFile string) {",
          "",
          "[Removed Lines]",
          "114:  <-l.done",
          "",
          "[Added Lines]",
          "111:  if err := <-l.done; err != nil {",
          "112:   t.Fatalf(\"ForwardLogs: %v\", err)",
          "113:  }",
          "",
          "---------------"
        ],
        "libcontainer/process_linux.go||libcontainer/process_linux.go": [
          "File: libcontainer/process_linux.go -> libcontainer/process_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:  setExternalDescriptors(fds []string)",
          "55: }",
          "57: type filePair struct {",
          "",
          "[Removed Lines]",
          "54:  forwardChildLogs()",
          "",
          "[Added Lines]",
          "54:  forwardChildLogs() chan error",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "251:  p.fds = newFds",
          "252: }",
          "256: }",
          "258: type initProcess struct {",
          "",
          "[Removed Lines]",
          "254: func (p *setnsProcess) forwardChildLogs() {",
          "255:  go logs.ForwardLogs(p.logFilePair.parent)",
          "",
          "[Added Lines]",
          "254: func (p *setnsProcess) forwardChildLogs() chan error {",
          "255:  return logs.ForwardLogs(p.logFilePair.parent)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "605:  p.fds = newFds",
          "606: }",
          "610: }",
          "612: func getPipeFds(pid int) ([]string, error) {",
          "",
          "[Removed Lines]",
          "608: func (p *initProcess) forwardChildLogs() {",
          "609:  go logs.ForwardLogs(p.logFilePair.parent)",
          "",
          "[Added Lines]",
          "608: func (p *initProcess) forwardChildLogs() chan error {",
          "609:  return logs.ForwardLogs(p.logFilePair.parent)",
          "",
          "---------------"
        ],
        "libcontainer/restored_process.go||libcontainer/restored_process.go": [
          "File: libcontainer/restored_process.go -> libcontainer/restored_process.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "77:  p.fds = newFds",
          "78: }",
          "81: }",
          "",
          "[Removed Lines]",
          "80: func (p *restoredProcess) forwardChildLogs() {",
          "",
          "[Added Lines]",
          "80: func (p *restoredProcess) forwardChildLogs() chan error {",
          "81:  return nil",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:  p.fds = newFds",
          "126: }",
          "129: }",
          "",
          "[Removed Lines]",
          "128: func (p *nonChildProcess) forwardChildLogs() {",
          "",
          "[Added Lines]",
          "129: func (p *nonChildProcess) forwardChildLogs() chan error {",
          "130:  return nil",
          "",
          "---------------"
        ],
        "libcontainer/setns_init_linux.go||libcontainer/setns_init_linux.go": [
          "File: libcontainer/setns_init_linux.go -> libcontainer/setns_init_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:  pipe          *os.File",
          "22:  consoleSocket *os.File",
          "23:  config        *initConfig",
          "24: }",
          "26: func (l *linuxSetnsInit) getSessionRingName() string {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24:  logFd         int",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "86:    return newSystemErrorWithCause(err, \"init seccomp\")",
          "87:   }",
          "88:  }",
          "89:  return system.Execv(l.config.Args[0], l.config.Args[0:], os.Environ())",
          "90: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "91:  if err := unix.Close(l.logFd); err != nil {",
          "92:   return newSystemErrorWithCause(err, \"closing log pipe fd\")",
          "93:  }",
          "",
          "---------------"
        ],
        "libcontainer/standard_init_linux.go||libcontainer/standard_init_linux.go": [
          "File: libcontainer/standard_init_linux.go -> libcontainer/standard_init_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:  consoleSocket *os.File",
          "25:  parentPid     int",
          "26:  fifoFd        int",
          "27:  config        *initConfig",
          "28: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27:  logFd         int",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "181:  }",
          "183:  l.pipe.Close()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "187:  if err := unix.Close(l.logFd); err != nil {",
          "188:   return newSystemErrorWithCause(err, \"closing log pipe fd\")",
          "189:  }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
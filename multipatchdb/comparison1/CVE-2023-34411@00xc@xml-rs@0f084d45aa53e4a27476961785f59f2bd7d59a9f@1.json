{
  "cve_id": "CVE-2023-34411",
  "cve_desc": "The xml-rs crate before 0.8.14 for Rust and Crab allows a denial of service (panic) via an invalid <! token (such as <!DOCTYPEs/%<!A nesting) in an XML document. The earliest affected version is 0.8.9.",
  "repo": "00xc/xml-rs",
  "patch_hash": "0f084d45aa53e4a27476961785f59f2bd7d59a9f",
  "patch_info": {
    "commit_hash": "0f084d45aa53e4a27476961785f59f2bd7d59a9f",
    "repo": "00xc/xml-rs",
    "commit_url": "https://github.com/00xc/xml-rs/commit/0f084d45aa53e4a27476961785f59f2bd7d59a9f",
    "files": [
      "README.md",
      "src/reader/lexer.rs",
      "src/reader/parser/inside_cdata.rs",
      "src/reader/parser/inside_doctype.rs",
      "src/reader/parser/inside_processing_instruction.rs",
      "src/reader/parser/mod.rs",
      "src/reader/parser/outside_tag.rs",
      "tests/xmlconf.rs"
    ],
    "message": "Parse DOCTYPE markup declarations",
    "before_after_code_files": [
      "src/reader/lexer.rs||src/reader/lexer.rs",
      "src/reader/parser/inside_cdata.rs||src/reader/parser/inside_cdata.rs",
      "src/reader/parser/inside_doctype.rs||src/reader/parser/inside_doctype.rs",
      "src/reader/parser/inside_processing_instruction.rs||src/reader/parser/inside_processing_instruction.rs",
      "src/reader/parser/mod.rs||src/reader/parser/mod.rs",
      "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs",
      "tests/xmlconf.rs||tests/xmlconf.rs"
    ]
  },
  "patch_diff": {
    "src/reader/lexer.rs||src/reader/lexer.rs": [
      "File: src/reader/lexer.rs -> src/reader/lexer.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "54:     ReferenceStart,",
      "56:     ReferenceEnd,",
      "57: }",
      "59: impl fmt::Display for Token {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "58:     MarkupDeclarationStart,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "143:     }",
      "144: }",
      "146: enum State {",
      "148:     Normal,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "148: #[derive(Copy, Clone)]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "154:     CommentStarted,",
      "156:     DoctypeStarted(DoctypeStartedSubstate),",
      "160:     CDataStarted(CDataStartedSubstate),",
      "",
      "[Removed Lines]",
      "158:     DoctypeFinishing(u8),",
      "",
      "[Added Lines]",
      "161:     InsideMarkupDeclaration,",
      "163:     InsideDoctype,",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "174:     InsideCdata,",
      "176:     InsideProcessingInstruction,",
      "177: }",
      "179: #[derive(Copy, Clone)]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "183:     InsideMarkupDeclarationQuotedString(QuoteStyle),",
      "184: }",
      "186: #[derive(Copy, Clone, Eq, PartialEq)]",
      "187: enum QuoteStyle {",
      "188:     Single, Double",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "229:     head_pos: TextPosition,",
      "230:     char_queue: VecDeque<char>,",
      "231:     st: State,",
      "232:     skip_errors: bool,",
      "233:     inside_token: bool,",
      "234:     eof_handled: bool",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "245:     normal_state: State,",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "248:             head_pos: TextPosition::new(),",
      "249:             char_queue: VecDeque::with_capacity(4),  // TODO: check size",
      "250:             st: State::Normal,",
      "251:             skip_errors: false,",
      "252:             inside_token: false,",
      "253:             eof_handled: false",
      "254:         }",
      "255:     }",
      "268:     #[inline]",
      "",
      "[Removed Lines]",
      "259:     #[inline]",
      "260:     pub fn enable_errors(&mut self) { self.skip_errors = false; }",
      "264:     #[inline]",
      "265:     pub fn disable_errors(&mut self) { self.skip_errors = true; }",
      "",
      "[Added Lines]",
      "265:             normal_state: State::Normal,",
      "274:     pub(crate) fn disable_errors(&mut self) { self.skip_errors = true; }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "326:             State::TagStarted | State::CommentOrCDataOrDoctypeStarted |",
      "327:             State::CommentStarted | State::CDataStarted(_)| State::DoctypeStarted(_) |",
      "328:             State::CommentClosing(ClosingSubstate::Second) |",
      "330:             State::InsideProcessingInstruction | State::ProcessingInstructionClosing |",
      "332:                 Err(self.error(\"Unexpected end of stream\")),",
      "333:             State::EmptyTagClosing =>",
      "334:                 Ok(Some(Token::Character('/'))),",
      "",
      "[Removed Lines]",
      "329:             State::InsideComment |",
      "331:             State::DoctypeFinishing(_) =>",
      "",
      "[Added Lines]",
      "338:             State::InsideComment | State::InsideMarkupDeclaration |",
      "340:             State::InsideDoctype | State::InsideMarkupDeclarationQuotedString(_) =>",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "369:             State::CommentStarted                 => self.comment_started(c),",
      "370:             State::CDataStarted(s)                => self.cdata_started(c, s),",
      "371:             State::DoctypeStarted(s)              => self.doctype_started(c, s),",
      "373:             State::EmptyTagClosing                => self.empty_element_closing(c),",
      "374:             State::CommentClosing(s)              => self.comment_closing(c, s),",
      "375:             State::CDataClosing(s)                => self.cdata_closing(c, s),",
      "",
      "[Removed Lines]",
      "372:             State::DoctypeFinishing(d)            => self.doctype_finishing(c, d),",
      "",
      "[Added Lines]",
      "381:             State::InsideDoctype                  => self.inside_doctype(c),",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "378:             State::InsideCdata                    => self.inside_cdata(c),",
      "379:             State::InsideProcessingInstruction    => self.inside_processing_instruction(c),",
      "380:             State::ProcessingInstructionClosing   => self.processing_instruction_closing(c),",
      "381:         }",
      "382:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "390:             State::InsideMarkupDeclaration       => self.markup_declaration(c),",
      "391:             State::InsideMarkupDeclarationQuotedString(q) => self.markup_declaration_string(c, q),",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "393:         Ok(Some(token))",
      "394:     }",
      "396:     #[inline]",
      "397:     fn move_to_with_unread(&mut self, st: State, cs: &[char], token: Token) -> Result {",
      "398:         self.char_queue.extend(cs.iter().copied());",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "407:     #[inline]",
      "408:     fn move_to_and_reset_normal(&mut self, st: State, token: Token) -> Result {",
      "409:         self.normal_state = st;",
      "410:         self.st = st;",
      "411:         Ok(Some(token))",
      "412:     }",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "461:     fn tag_opened(&mut self, c: char) -> Result {",
      "462:         match c {",
      "463:             '?'                        => self.move_to_with(State::InsideProcessingInstruction, Token::ProcessingInstructionStart),",
      "465:             '!'                        => self.move_to(State::CommentOrCDataOrDoctypeStarted),",
      "468:             _                          => self.handle_error(\"<\", c)",
      "469:         }",
      "470:     }",
      "",
      "[Removed Lines]",
      "464:             '/'                        => self.move_to_with(State::Normal, Token::ClosingTagStart),",
      "466:             _ if is_whitespace_char(c) => self.move_to_with_unread(State::Normal, &[c], Token::OpeningTagStart),",
      "467:             _ if is_name_char(c)       => self.move_to_with_unread(State::Normal, &[c], Token::OpeningTagStart),",
      "",
      "[Added Lines]",
      "483:             '/'                        => self.move_to_with(self.normal_state, Token::ClosingTagStart),",
      "485:             _ if is_whitespace_char(c) => self.move_to_with_unread(self.normal_state, &[c], Token::OpeningTagStart),",
      "486:             _ if is_name_char(c)       => self.move_to_with_unread(self.normal_state, &[c], Token::OpeningTagStart),",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "475:             '-' => self.move_to(State::CommentStarted),",
      "476:             '[' => self.move_to(State::CDataStarted(CDataStartedSubstate::E)),",
      "477:             'D' => self.move_to(State::DoctypeStarted(DoctypeStartedSubstate::D)),",
      "478:             _ => self.handle_error(\"<!\", c),",
      "479:         }",
      "480:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "497:             'E' | 'A' | 'N' if matches!(self.normal_state, State::InsideDoctype) => self.move_to_with(State::InsideMarkupDeclaration, Token::MarkupDeclarationStart),",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "500:         )",
      "501:     }",
      "504:     fn doctype_started(&mut self, c: char, s: DoctypeStartedSubstate) -> Result {",
      "505:         use self::DoctypeStartedSubstate::{D, DO, DOC, DOCT, DOCTY, DOCTYP};",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "524:     fn markup_declaration(&mut self, c: char) -> Result {",
      "525:         match c {",
      "526:             '<'                        => self.handle_error(\"<!\", c),",
      "527:             '>'                        => self.move_to_with(self.normal_state, Token::TagEnd),",
      "528:             '&'                        => Ok(Some(Token::ReferenceStart)),",
      "529:             ';'                        => Ok(Some(Token::ReferenceEnd)),",
      "530:             '\"'                        => self.move_to_with(State::InsideMarkupDeclarationQuotedString(QuoteStyle::Double), Token::DoubleQuote),",
      "531:             '\\''                       => self.move_to_with(State::InsideMarkupDeclarationQuotedString(QuoteStyle::Single), Token::SingleQuote),",
      "532:             _ => Ok(None),",
      "533:         }",
      "534:     }",
      "536:     fn markup_declaration_string(&mut self, c: char, q: QuoteStyle) -> Result {",
      "537:         match c {",
      "538:             '\"' if q == QuoteStyle::Double  => self.move_to_with(State::InsideMarkupDeclaration, Token::DoubleQuote),",
      "539:             '\\'' if q == QuoteStyle::Single => self.move_to_with(State::InsideMarkupDeclaration, Token::SingleQuote),",
      "540:             _ => Ok(None),",
      "541:         }",
      "542:     }",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "509:             DOC    ; 'T' ; DOCT   ; \"<!DOC\",",
      "510:             DOCT   ; 'Y' ; DOCTY  ; \"<!DOCT\",",
      "511:             DOCTY  ; 'P' ; DOCTYP ; \"<!DOCTY\";",
      "513:         )",
      "514:     }",
      "518:         match c {",
      "522:             _ => Ok(None),",
      "523:         }",
      "524:     }",
      "",
      "[Removed Lines]",
      "512:             DOCTYP ; 'E' ; \"<!DOCTYP\" ; self.move_to_with(State::DoctypeFinishing(1), Token::DoctypeStart)",
      "517:     fn doctype_finishing(&mut self, c: char, d: u8) -> Result {",
      "519:             '<' => self.move_to(State::DoctypeFinishing(d + 1)),",
      "520:             '>' if d == 1 => self.move_to_with(State::Normal, Token::TagEnd),",
      "521:             '>' => self.move_to(State::DoctypeFinishing(d - 1)),",
      "",
      "[Added Lines]",
      "553:             DOCTYP ; 'E' ; \"<!DOCTYP\" ; self.move_to_and_reset_normal(State::InsideDoctype, Token::DoctypeStart)",
      "558:     fn inside_doctype(&mut self, c: char) -> Result {",
      "560:             '>' => self.move_to_and_reset_normal(State::Normal, Token::TagEnd),",
      "561:             '<'                        => self.move_to(State::TagStarted),",
      "562:             '&'                        => Ok(Some(Token::ReferenceStart)),",
      "563:             ';'                        => Ok(Some(Token::ReferenceEnd)),",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "527:     fn processing_instruction_closing(&mut self, c: char) -> Result {",
      "528:         match c {",
      "530:             _ => self.move_to_with_unread(State::InsideProcessingInstruction, &[c], Token::Character('?')),",
      "531:         }",
      "532:     }",
      "",
      "[Removed Lines]",
      "529:             '>' => self.move_to_with(State::Normal, Token::ProcessingInstructionEnd),",
      "",
      "[Added Lines]",
      "571:             '>' => self.move_to_with(self.normal_state, Token::ProcessingInstructionEnd),",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "535:     fn empty_element_closing(&mut self, c: char) -> Result {",
      "536:         match c {",
      "539:         }",
      "540:     }",
      "",
      "[Removed Lines]",
      "537:             '>' => self.move_to_with(State::Normal, Token::EmptyTagEnd),",
      "538:             _ => self.move_to_with_unread(State::Normal, &[c], Token::Character('/')),",
      "",
      "[Added Lines]",
      "579:             '>' => self.move_to_with(self.normal_state, Token::EmptyTagEnd),",
      "580:             _ => self.move_to_with_unread(self.normal_state, &[c], Token::Character('/')),",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "547:                 _ => self.move_to_with_unread(State::InsideComment, &[c], Token::Character('-')),",
      "548:             },",
      "549:             ClosingSubstate::Second => match c {",
      "552:                 _ => self.handle_error(\"--\", c),",
      "553:             },",
      "",
      "[Removed Lines]",
      "550:                 '>' => self.move_to_with(State::Normal, Token::CommentEnd),",
      "",
      "[Added Lines]",
      "592:                 '>' => self.move_to_with(self.normal_state, Token::CommentEnd),",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "576:                 _ => self.move_to_with_unread(State::Normal, &[c], Token::Character(']')),",
      "577:             },",
      "578:             ClosingSubstate::Second => match c {",
      "580:                 _ => self.move_to_with_unread(State::Normal, &[']', c], Token::Character(']')),",
      "581:             },",
      "582:         }",
      "",
      "[Removed Lines]",
      "579:                 '>' => self.move_to_with(State::Normal, Token::CDataEnd),",
      "",
      "[Added Lines]",
      "621:                 '>' => self.move_to_with(self.normal_state, Token::CDataEnd),",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "825:     #[test]",
      "826:     fn doctype_with_internal_subset_test() {",
      "827:         let (mut lex, mut buf) = make_lex_and_buf(",
      "829:         );",
      "830:         assert_oks!(for lex and buf ;",
      "831:             Token::OpeningTagStart",
      "832:             Token::Character('a')",
      "833:             Token::TagEnd",
      "834:             Token::DoctypeStart",
      "835:             Token::TagEnd",
      "836:             Token::Whitespace(' ')",
      "837:         );",
      "838:         assert_none!(for lex and buf);",
      "839:     }",
      "841:     #[test]",
      "842:     fn end_of_stream_handling_ok() {",
      "843:         macro_rules! eof_check(",
      "",
      "[Removed Lines]",
      "828:             r#\"<a><!DOCTYPE ab[<!ELEMENT ba> ]> \"#",
      "",
      "[Added Lines]",
      "870:             r#\"<a><!DOCTYPE ab[<!ELEMENT ba \">>>>>\"> ]> \"#",
      "877:             Token::MarkupDeclarationStart",
      "878:             Token::DoubleQuote",
      "879:             Token::DoubleQuote",
      "880:             Token::TagEnd",
      "881:             Token::TagEnd",
      "882:             Token::Whitespace(' ')",
      "883:         );",
      "884:         assert_none!(for lex and buf);",
      "885:     }",
      "887:     #[test]",
      "888:     fn doctype_internal_pi_comment() {",
      "889:         let (mut lex, mut buf) = make_lex_and_buf(",
      "890:             \"<!DOCTYPE a [\\n<!ELEMENT leopard ANY> <!-- <?non?>--> <?pi > ?> \\n]>\"",
      "891:         );",
      "892:         assert_oks!(for lex and buf ;",
      "893:             Token::DoctypeStart",
      "894:             Token::MarkupDeclarationStart",
      "896:             Token::CommentStart",
      "898:             Token::Character('<')",
      "899:             Token::Character('?')",
      "900:             Token::Character('n')",
      "901:             Token::Character('o')",
      "902:             Token::Character('n')",
      "903:             Token::Character('?')",
      "904:             Token::Character('>')",
      "905:             Token::CommentEnd",
      "906:             Token::ProcessingInstructionStart",
      "907:             Token::Character('p')",
      "908:             Token::Character('i')",
      "909:             Token::Whitespace(' ')",
      "910:             Token::TagEnd // not really",
      "911:             Token::Whitespace(' ')",
      "912:             Token::ProcessingInstructionEnd",
      "913:             Token::TagEnd // DTD",
      "",
      "---------------"
    ],
    "src/reader/parser/inside_cdata.rs||src/reader/parser/inside_cdata.rs": [
      "File: src/reader/parser/inside_cdata.rs -> src/reader/parser/inside_cdata.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "7:     pub fn inside_cdata(&mut self, t: Token) -> Option<Result> {",
      "8:         match t {",
      "9:             Token::CDataEnd => {",
      "11:                 let event = if self.config.cdata_to_characters {",
      "12:                     None",
      "13:                 } else {",
      "",
      "[Removed Lines]",
      "10:                 self.lexer.enable_errors();",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/reader/parser/inside_doctype.rs||src/reader/parser/inside_doctype.rs": [
      "File: src/reader/parser/inside_doctype.rs -> src/reader/parser/inside_doctype.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "6:     pub fn inside_doctype(&mut self, t: Token) -> Option<Result> {",
      "7:         match t {",
      "8:             Token::TagEnd => {",
      "10:                 self.into_state_continue(State::OutsideTag)",
      "11:             }",
      "13:             _ => None,",
      "14:         }",
      "15:     }",
      "",
      "[Removed Lines]",
      "9:                 self.lexer.enable_errors();",
      "",
      "[Added Lines]",
      "12:             Token::MarkupDeclarationStart => {",
      "13:                 self.into_state_continue(State::InsideDoctypeMarkupDeclaration)",
      "14:             },",
      "16:             _ => None,",
      "17:         }",
      "18:     }",
      "20:     pub fn inside_doctype_markup_declaration(&mut self, t: Token) -> Option<Result> {",
      "21:         match t {",
      "22:             Token::TagEnd => {",
      "23:                 self.into_state_continue(State::InsideDoctype)",
      "24:             }",
      "",
      "---------------"
    ],
    "src/reader/parser/inside_processing_instruction.rs||src/reader/parser/inside_processing_instruction.rs": [
      "File: src/reader/parser/inside_processing_instruction.rs -> src/reader/parser/inside_processing_instruction.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "69:             ProcessingInstructionSubstate::PIInsideData => match t {",
      "70:                 Token::ProcessingInstructionEnd => {",
      "72:                     let name = self.data.take_name();",
      "73:                     let data = self.take_buf();",
      "74:                     self.into_state_emit(",
      "",
      "[Removed Lines]",
      "71:                     self.lexer.enable_errors();",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/reader/parser/mod.rs||src/reader/parser/mod.rs": [
      "File: src/reader/parser/mod.rs -> src/reader/parser/mod.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "139:     InsideCData,",
      "140:     InsideDeclaration(DeclarationSubstate),",
      "141:     InsideDoctype,",
      "142:     InsideReference(Box<State>),",
      "143: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "142:     InsideDoctypeMarkupDeclaration,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "337:             State::InsideProcessingInstruction(s) => self.inside_processing_instruction(t, s),",
      "338:             State::InsideDeclaration(s)           => self.inside_declaration(t, s),",
      "339:             State::InsideDoctype                  => self.inside_doctype(t),",
      "340:             State::InsideOpeningTag(s)            => self.inside_opening_tag(t, s),",
      "341:             State::InsideClosingTag(s)            => self.inside_closing_tag_name(t, s),",
      "342:             State::InsideComment                  => self.inside_comment(t),",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "341:             State::InsideDoctypeMarkupDeclaration => self.inside_doctype_markup_declaration(t),",
      "",
      "---------------"
    ],
    "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs": [
      "File: src/reader/parser/outside_tag.rs -> src/reader/parser/outside_tag.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "83:                         self.next_pos();",
      "85:                         self.into_state(State::InsideDoctype, next_event)",
      "86:                     }",
      "",
      "[Removed Lines]",
      "84:                         self.lexer.disable_errors();",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "tests/xmlconf.rs||tests/xmlconf.rs": [
      "File: tests/xmlconf.rs -> tests/xmlconf.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "116:         \"rmt-e2e-18\", // External entity containing start of entity declaration is base URI for system identifier",
      "117:         \"rmt-e2e-19\", // Parameter entities and character references are included-in-literal, but general entities are bypassed.",
      "118:         \"rmt-e2e-22\", // UTF-8 entities may start with a BOM",
      "120:         \"rmt-e2e-34\", // A non-deterministic content model is an error even if the element type is not used.",
      "121:         \"rmt-e2e-50\", // All line-ends are normalized, even those not passed to the application. NB this can only be tested effectively in XML 1.1, since CR is in the S production; in 1.1 we can use NEL which isn't.",
      "122:         \"rmt-e2e-55\", // A reference to an unparsed entity in an entity value is an error rather than forbidden (unless the entity is referenced, of course)",
      "",
      "[Removed Lines]",
      "119:         \"rmt-e2e-24\", // Either the built-in entity or a character reference can be used to represent greater-than after two close-square-brackets",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "279: #[test] fn oasis() {",
      "280:     run_suite(\"oasis/oasis.xml\", &[",
      "285:         \"o-p01fail1\", // S cannot occur before the prolog",
      "286:         \"o-p01fail2\", // comments cannot occur before the prolog",
      "287:         \"o-p01fail3\", // only one document element",
      "288:         \"o-p09fail1\", // EntityValue excludes '%'",
      "289:         \"o-p09fail2\", // EntityValue excludes '&'",
      "290:         \"o-p09fail3\", // incomplete character reference",
      "296:         \"o-p12fail2\", // '\\' excluded",
      "297:         \"o-p12fail3\", // entity references excluded",
      "298:         \"o-p12fail6\", // built-in entity refs excluded",
      "299:         \"o-p12fail7\", // The public ID has a tab character, which is disallowed",
      "300:         \"o-p14fail3\", // \"]]>\" excluded",
      "",
      "[Removed Lines]",
      "281:         \"o-p43pass1\", // Valid use of character data, comments, processing instructions and CDATA sections within the start and end tag.",
      "282:         \"o-p68pass1\", // Valid entity references.  Also ensures that a charref to           '&' isn't interpreted as an entity reference open delimiter",
      "283:         \"o-p04pass1\", // names with all valid ASCII characters, and one from each               other class in NameChar",
      "284:         \"o-p05pass1\", // various valid Name constructions",
      "291:         \"o-p09fail4\", // quote types must match",
      "292:         \"o-p09fail5\", // quote types must match",
      "293:         \"o-p11fail1\", // quote types must match",
      "294:         \"o-p11fail2\", // cannot contain delimiting quotes",
      "295:         \"o-p12fail1\", // '\"' excluded",
      "",
      "[Added Lines]",
      "283:         \"o-p04pass1\", // names with all valid ASCII characters, and one from each               other class in NameChar",
      "284:         \"o-p05pass1\", // various valid Name constructions",
      "288:         \"o-p11pass1\", // p11pass1.xml       system literals may not contain     URI fragments",
      "289:         \"o-p12fail1\", // p12fail1.xml       '\"' excluded",
      "292:         \"o-p12fail4\", // p12fail4.xml       '>' excluded",
      "293:         \"o-p12fail5\", // p12fail5.xml       '<' excluded",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "303:         \"o-p22fail2\", // prolog must start with XML decl",
      "304:         \"o-p23fail1\", // \"xml\" must be lower-case",
      "305:         \"o-p27fail1\", // References aren't allowed in Misc,     even if they would resolve to valid Misc.",
      "307:         \"o-p30fail1\", // An XML declaration is not the same as a TextDecl",
      "308:         \"o-p31fail1\", // external subset excludes doctypedecl",
      "309:         \"o-p32fail3\", // initial S is required",
      "310:         \"o-p40fail1\", // S is required between attributes",
      "311:         \"o-p44fail4\", // Whitespace required between attributes.",
      "313:         \"o-p45fail2\", // S before contentspec is required.",
      "314:         \"o-p45fail3\", // only one content spec",
      "315:         \"o-p45fail4\", // no comments in declarations (contrast with SGML)",
      "",
      "[Removed Lines]",
      "306:         \"o-p29fail1\", // A processor must not pass unknown declaration types.",
      "312:         \"o-p45fail1\", // ELEMENT must be upper case.",
      "",
      "[Added Lines]",
      "306:         \"o-p43pass1\", // Valid use of character data, comments, processing instructions and CDATA sections within the start and end tag.",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "371:         \"o-p64fail1\", // section delimiters must balance",
      "372:         \"o-p64fail2\", // section delimiters must balance",
      "373:         \"o-p66fail5\", // no references to non-characters",
      "374:         \"o-p69fail1\", // terminating ';' is required",
      "375:         \"o-p69fail2\", // no S after '%'",
      "376:         \"o-p69fail3\", // no S before ';'",
      "377:         \"o-p70fail1\", // This is neither",
      "378:         \"o-p71fail1\", // S is required before EntityDef",
      "379:         \"o-p71fail2\", // Entity name is a Name, not an NMToken",
      "381:         \"o-p71fail4\", // S is required after \"<!ENTITY\"",
      "382:         \"o-p72fail1\", // S is required after \"<!ENTITY\"",
      "383:         \"o-p72fail2\", // S is required after '%'",
      "384:         \"o-p72fail3\", // S is required after name",
      "385:         \"o-p72fail4\", // Entity name is a name, not an NMToken",
      "386:         \"o-p73fail1\", // No typed replacement text",
      "387:         \"o-p73fail2\", // Only one replacement value",
      "",
      "[Removed Lines]",
      "380:         \"o-p71fail3\", // no S after \"<!\"",
      "",
      "[Added Lines]",
      "369:         \"o-p68pass1\", // Valid entity references.  Also ensures that a charref to           '&' isn't interpreted as an entity reference open delimiter",
      "380:         \"o-p76fail4\", // p76fail4.xml       notation names are Names",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "438:         \"content02\", // No whitespace before \"*\" in content model",
      "439:         \"content03\", // No whitespace before \"+\" in content model",
      "440:         \"decl01\", // External entities may not have standalone decls.",
      "443:         \"dtd02\", // PE name immediately after \"%\"",
      "444:         \"dtd03\", // PE name immediately followed by \";\"",
      "445:         \"dtd04\", // PUBLIC literal must be quoted",
      "",
      "[Removed Lines]",
      "441:         \"nwf-dtd00\", // Comma mandatory in content model",
      "442:         \"nwf-dtd01\", // Can't mix comma and vertical bar in content models",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "451:         \"encoding04\", // Illegal character \":\" in encoding name",
      "452:         \"encoding05\", // Illegal character \"@\" in encoding name",
      "453:         \"encoding06\", // Illegal character \"+\" in encoding name",
      "454:         \"pubid01\", // Illegal entity ref in public ID",
      "455:         \"pubid02\", // Illegal characters in public ID",
      "456:         \"pubid03\", // Illegal characters in public ID",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "448:         \"nwf-dtd00\", // Comma mandatory in content model",
      "449:         \"nwf-dtd01\", // Can't mix comma and vertical bar in content models",
      "450:         \"pi\", // pi.xml      No space between PI target name and data",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "502:         \"not-wf-sa-060\", // Invalid type NAME defined in ATTLIST.",
      "503:         \"not-wf-sa-061\", // External entity declarations require whitespace between public     and system IDs.",
      "504:         \"not-wf-sa-062\", // Entity declarations need space after the entity name.",
      "506:         \"not-wf-sa-064\", // Space is required between attribute type and default values     in <!ATTLIST...> declarations.",
      "507:         \"not-wf-sa-065\", // Space is required between attribute name and type     in <!ATTLIST...> declarations.",
      "508:         \"not-wf-sa-066\", // Required whitespace is missing.",
      "",
      "[Removed Lines]",
      "505:         \"not-wf-sa-063\", // Conditional sections may only appear in the external     DTD subset.",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "523:         \"not-wf-sa-101\", // Space is not permitted in an encoding name.",
      "524:         \"not-wf-sa-105\", // Invalid placement of CDATA section.",
      "525:         \"not-wf-sa-106\", // Invalid placement of entity declaration.",
      "527:         \"not-wf-sa-113\", // Parameter entity values must use valid reference syntax;     this reference is malformed.",
      "528:         \"not-wf-sa-114\", // General entity values must use valid reference syntax;     this reference is malformed.",
      "529:         \"not-wf-sa-121\", // A name of an ENTITY was started with an invalid character.",
      "",
      "[Removed Lines]",
      "526:         \"not-wf-sa-107\", // Invalid document type declaration.  CDATA alone is invalid.",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "566:         \"not-wf-sa-174\", // Character FFFF is not legal anywhere in an XML document.",
      "567:         \"not-wf-sa-175\", // Character FFFF is not legal anywhere in an XML document.",
      "568:         \"not-wf-sa-177\", // Character FFFF is not legal anywhere in an XML document.",
      "570:         \"not-wf-sa-180\", // The Entity Declared WFC requires entities to be declared     before they are used in an attribute list declaration.",
      "571:         \"not-wf-sa-183\", // Mixed content declarations may not include content particles.",
      "572:         \"not-wf-sa-184\", // In mixed content models, element names must not be     parenthesized.",
      "",
      "[Removed Lines]",
      "569:         \"not-wf-sa-179\", // Invalid syntax matching double quote is missing.",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3e6362c9d34252823d5bc1d3ee9e34cfd09facc8",
      "candidate_info": {
        "commit_hash": "3e6362c9d34252823d5bc1d3ee9e34cfd09facc8",
        "repo": "00xc/xml-rs",
        "commit_url": "https://github.com/00xc/xml-rs/commit/3e6362c9d34252823d5bc1d3ee9e34cfd09facc8",
        "files": [
          ".gitignore",
          "tests/xmlconf.rs",
          "tests/xmlts20130923.zip"
        ],
        "message": "XML conformance suite",
        "before_after_code_files": [
          "tests/xmlconf.rs||tests/xmlconf.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tests/xmlconf.rs||tests/xmlconf.rs"
          ],
          "candidate": [
            "tests/xmlconf.rs||tests/xmlconf.rs"
          ]
        }
      },
      "candidate_diff": {
        "tests/xmlconf.rs||tests/xmlconf.rs": [
          "File: tests/xmlconf.rs -> tests/xmlconf.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: use std::collections::HashSet;",
          "4: use std::ffi::OsStr;",
          "5: use std::path::Path;",
          "6: use std::collections::HashMap;",
          "7: use std::fs::File;",
          "8: use std::io::BufReader;",
          "9: use std::process::Command;",
          "10: use std::sync::Mutex;",
          "12: use xml::EventReader;",
          "13: use xml::reader::XmlEvent;",
          "15: static UNZIP: Mutex<()> = Mutex::new(());",
          "17: fn ensure_unzipped() {",
          "18:     let _g = UNZIP.lock().expect(\"unzip already failed\");",
          "21:     if !Path::new(\"tests/xmlconf\").exists() {",
          "22:         assert!(Command::new(\"unzip\")",
          "23:             .current_dir(\"tests\")",
          "24:             .arg(\"xmlts20130923.zip\")",
          "25:             .status().unwrap().success(), \"must unzip\");",
          "26:     }",
          "27: }",
          "29: #[track_caller]",
          "30: fn run_suite(suite_rel_path: &str, known_broken_tests: &[&str]) {",
          "31:     ensure_unzipped();",
          "33:     let known_broken_tests = known_broken_tests.iter().map(|name| name.as_ref()).collect::<HashSet<&OsStr>>();",
          "35:     let suite_path = Path::new(\"tests/xmlconf\").join(suite_rel_path);",
          "36:     let root = suite_path.parent().unwrap();",
          "37:     let mut parsed = 0;",
          "39:     let f = BufReader::new(File::open(&suite_path)",
          "40:         .map_err(|e| format!(\"{}: {e}\", suite_path.display())).unwrap());",
          "41:     let r = EventReader::new(f);",
          "42:     let mut desc = String::new();",
          "43:     let mut attr = HashMap::<String, String>::new();",
          "44:     for e in r {",
          "45:         let e = e.expect(\"testsuite validity\");",
          "46:         match e {",
          "47:             XmlEvent::Characters(chr) => {",
          "48:                 desc.push_str(&chr.replace('\\n', \" \"));",
          "49:             },",
          "50:             XmlEvent::EndElement { name } if name.local_name == \"TEST\" => {",
          "51:                 let path = root.join(&attr[\"URI\"]);",
          "52:                 let test_type = attr[\"TYPE\"].as_str();",
          "54:                 let res = match test_type {",
          "55:                     \"valid\" => expect_well_formed(&path, &desc),",
          "56:                     \"invalid\" => expect_well_formed(&path, &desc), // invalid is still well-formed",
          "57:                     \"not-wf\" | \"error\" => expect_ill_formed(&path, &desc),",
          "58:                     other => unimplemented!(\"{other}?? type\"),",
          "59:                 };",
          "61:                 let id = attr[\"ID\"].as_str();",
          "62:                 let known_bad = known_broken_tests.contains::<OsStr>(id.as_ref());",
          "64:                 match res {",
          "65:                     Err(_) if known_bad => {},",
          "66:                     Err(e) => panic!(\"{suite_rel_path} failed on {} ({id})\\n{e}\", path.display()),",
          "67:                     Ok(()) if known_bad => panic!(\"expected {} ({id}) to fail, but it passes {test_type} of {suite_rel_path} now\", path.display()),",
          "68:                     Ok(()) => {},",
          "69:                 };",
          "70:                 parsed += 1;",
          "71:             },",
          "72:             XmlEvent::StartElement { name, attributes, namespace: _ } if name.local_name == \"TEST\" => {",
          "73:                 desc.clear();",
          "74:                 attr = attributes.into_iter().map(|a| (a.name.local_name, a.value)).collect();",
          "75:             },",
          "76:             _ => {},",
          "78:         }",
          "79:     }",
          "80:     assert!(parsed > 0);",
          "81: }",
          "83: #[track_caller]",
          "84: fn expect_well_formed(xml_path: &Path, msg: &str) -> Result<(), Box<dyn std::error::Error>> {",
          "85:     let f = BufReader::new(File::open(xml_path)?);",
          "86:     let r = EventReader::new(f);",
          "87:     let mut seen_any = false;",
          "88:     for e in r {",
          "89:         let e = e.map_err(|e| format!(\"\\\"{}\\\", // {msg}; {e}\", xml_path.display()))?;",
          "90:         if let XmlEvent::EndElement { .. } = e {",
          "91:             seen_any = true;",
          "92:         }",
          "93:     }",
          "94:     if !seen_any { Err(\"no elements found\")? }",
          "95:     Ok(())",
          "96: }",
          "98: #[track_caller]",
          "99: fn expect_ill_formed(xml_path: &Path, msg: &str) -> Result<(), Box<dyn std::error::Error>> {",
          "100:     let f = BufReader::new(File::open(xml_path)?);",
          "101:     let r = EventReader::new(f);",
          "102:     for e in r {",
          "103:         if let Err(_) = e {",
          "104:             return Ok(());",
          "105:         }",
          "106:     }",
          "107:     Err(format!(\"\\\"{}\\\", // {msg}\", xml_path.display()))?",
          "108: }",
          "110: #[test] fn eduni_errata_2e() {",
          "111:     run_suite(\"eduni/errata-2e/errata2e.xml\", &[",
          "112:         \"rmt-e2e-15a\", // Empty content can't contain an entity reference",
          "113:         \"rmt-e2e-15e\", // Element content can contain entity reference if replacement text is whitespace",
          "114:         \"rmt-e2e-15f\", // Element content can contain entity reference if replacement text is whitespace, even if it came from a character reference in the literal entity value",
          "115:         \"rmt-e2e-15h\", // Element content can't contain entity reference if replacement text is character reference to whitespace",
          "116:         \"rmt-e2e-18\", // External entity containing start of entity declaration is base URI for system identifier",
          "117:         \"rmt-e2e-19\", // Parameter entities and character references are included-in-literal, but general entities are bypassed.",
          "118:         \"rmt-e2e-22\", // UTF-8 entities may start with a BOM",
          "119:         \"rmt-e2e-24\", // Either the built-in entity or a character reference can be used to represent greater-than after two close-square-brackets",
          "120:         \"rmt-e2e-34\", // A non-deterministic content model is an error even if the element type is not used.",
          "121:         \"rmt-e2e-50\", // All line-ends are normalized, even those not passed to the application. NB this can only be tested effectively in XML 1.1, since CR is in the S production; in 1.1 we can use NEL which isn't.",
          "122:         \"rmt-e2e-55\", // A reference to an unparsed entity in an entity value is an error rather than forbidden (unless the entity is referenced, of course)",
          "123:         \"rmt-e2e-57\", // A value other than preserve or default for xml:space is an error",
          "124:         \"rmt-e2e-61\", // (From John Cowan) An encoding declaration in ASCII specifying an encoding that is not compatible with ASCII (so the document is not in its declared encoding).  It should generate a fatal error.",
          "125:     ]);",
          "126: }",
          "128: #[test] fn eduni_errata_3e() {",
          "129:     run_suite(\"eduni/errata-3e/errata3e.xml\", &[",
          "130:         \"rmt-e3e-12\", // E12.xml Default values for attributes may not contain references to external entities.",
          "131:         \"rmt-e3e-13\", // E13.xml Even internal parameter entity references are enough to make undeclared entities into mere validity errors rather than well-formedness errors.",
          "132:     ]);",
          "133: }",
          "135: #[test] fn eduni_errata_4e() {",
          "136:     run_suite(\"eduni/errata-4e/errata4e.xml\", &[",
          "137:         \"invalid-bo-1\", // inclbom_be.xml Byte order mark in general entity should go away (big-endian)",
          "138:         \"invalid-bo-2\", // inclbom_le.xml Byte order mark in general entity should go away (little-endian)",
          "139:         \"invalid-bo-3\", // incl8bom.xml Byte order mark in general entity should go away (utf-8)",
          "140:         \"invalid-bo-4\", // inclbombom_be.xml Two byte order marks in general entity produce only one (big-endian)",
          "141:         \"invalid-bo-5\", // inclbombom_le.xml Two byte order marks in general entity produce only one (little-endian)",
          "142:         \"invalid-bo-6\", // incl8bombom.xml Two byte order marks in general entity produce only one (utf-8)",
          "143:         \"invalid-sa-140\", // 140.xml Character '&#x309a;' is a CombiningChar, not a Letter, but as of 5th edition, may begin a name (c.f. xmltest/not-wf/sa/140.xml).",
          "144:         \"invalid-sa-141\", // 141.xml As of 5th edition, character #x0E5C is legal in XML names (c.f. xmltest/not-wf/sa/141.xml).",
          "145:         \"x-rmt-008b\", // 008.xml a document with version=1.7, legal in XML 1.0 from 5th edition",
          "146:         \"x-ibm-1-0.5-valid-P04-ibm04v01.xml\", // ibm04v01.xml This test case covers legal NameStartChars character ranges plus discrete legal characters for production 04.",
          "147:         \"x-ibm-1-0.5-valid-P05-ibm05v01.xml\", // ibm05v01.xml This test case covers legal Element Names as per production 5.",
          "148:         \"x-ibm-1-0.5-valid-P05-ibm05v03.xml\", // ibm05v03.xml This test case covers legal Attribute (Names) as per production 5.",
          "149:     ]);",
          "150: }",
          "152: #[test] fn eduni_misc_ht() {",
          "153:     run_suite(\"eduni/misc/ht-bh.xml\", &[]);",
          "154: }",
          "156: #[test] fn eduni_namespaces_10() {",
          "157:     run_suite(\"eduni/namespaces/1.0/rmt-ns10.xml\", &[",
          "158:         \"rmt-ns10-004\", // Namespace name test: a relative URI (deprecated)",
          "159:         \"rmt-ns10-005\", // Namespace name test: a same-document relative URI (deprecated)",
          "160:         \"rmt-ns10-009\", // Namespace equality test: plain repetition",
          "161:         \"rmt-ns10-010\", // Namespace equality test: use of character reference",
          "162:         \"rmt-ns10-012\", // Namespace inequality test: equal after attribute value normalization",
          "163:         \"rmt-ns10-030\", // Reserved prefixes and namespaces: binding another prefix to the xml namespace",
          "164:         \"rmt-ns10-033\", // Reserved prefixes and namespaces: binding another prefix to the xmlns namespace",
          "165:         \"rmt-ns10-036\", // Attribute uniqueness: repeated attribute with different prefixes",
          "166:         \"rmt-ns10-042\", // Colon in PI name",
          "167:         \"rmt-ns10-043\", // Colon in entity name",
          "168:         \"rmt-ns10-044\", // Colon in entity name",
          "169:         \"ht-ns10-047\", // Reserved name: _not_ an error",
          "170:     ]);",
          "171: }",
          "173: #[test] fn eduni_namespaces_11() {",
          "174:     run_suite(\"eduni/namespaces/1.1/rmt-ns11.xml\", &[",
          "175:         \"rmt-ns11-001\", // 001.xml Namespace name test: a perfectly good http IRI that is not a URI",
          "176:         \"rmt-ns11-002\", // 002.xml Namespace inequality test: different escaping of non-ascii letter",
          "177:         \"rmt-ns11-003\", // 003.xml 1.1 style prefix unbinding",
          "178:         \"rmt-ns11-004\", // 004.xml 1.1 style prefix unbinding and rebinding",
          "179:     ]);",
          "180: }",
          "182: #[test] fn eduni_namespaces_errata() {",
          "183:     run_suite(\"eduni/namespaces/errata-1e/errata1e.xml\", &[",
          "184:         \"rmt-ns-e1.0-13a\", // NE13a.xml The xml namespace must not be declared as the default namespace.",
          "185:         \"rmt-ns-e1.0-13b\", // NE13b.xml The xmlns namespace must not be declared as the default namespace.",
          "186:     ]);",
          "187: }",
          "189: #[test] fn eduni_xml_11() {",
          "190:     run_suite(\"eduni/xml-1.1/xml11.xml\", &[",
          "191:         \"rmt-001\", // 001.xml External subset has later version number",
          "192:         \"rmt-002\", // 002.xml External PE has later version number",
          "193:         \"rmt-006\", // 006.xml Second-level external general entity has later version number than first-level, but not later than document, so not an error.",
          "194:         \"rmt-010\", // 010.xml Contains a C1 control, legal in XML 1.0, illegal in XML 1.1",
          "195:         \"rmt-013\", // 013.xml Contains a DEL, legal in XML 1.0, illegal in XML 1.1",
          "196:         \"rmt-014\", // 014.xml Has a \"long s\" in a name, legal in XML 1.1, illegal in XML 1.0 thru 4th edition",
          "197:         \"rmt-016\", // 016.xml Has a Byzantine Musical Symbol Kratimata in a name, legal in XML 1.1, illegal in XML 1.0 thru 4th edition",
          "198:         \"rmt-019\", // 019.xml Has the last legal namechar in XML 1.1, illegal in XML 1.0 thru 4th edition",
          "199:         \"rmt-022\", // 022.xml Has a NEL character; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "200:         \"rmt-023\", // 023.xml Has a NEL character; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "201:         \"rmt-026\", // 026.xml Has CR-NEL; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "202:         \"rmt-027\", // 027.xml Has CR-NEL; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "203:         \"rmt-030\", // 030.xml Has a NEL character in an NMTOKENS attribute; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "204:         \"rmt-031\", // 031.xml Has a NEL character in an NMTOKENS attribute; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "205:         \"rmt-034\", // 034.xml Has an NMTOKENS attribute containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "206:         \"rmt-035\", // 035.xml Has an NMTOKENS attribute containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "207:         \"rmt-036\", // 036.xml Has an NMTOKENS attribute containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "208:         \"rmt-037\", // 037.xml Has an NMTOKENS attribute containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "209:         \"rmt-038\", // 038.xml Contains a C0 control character (form-feed), illegal in both XML 1.0 and 1.1",
          "210:         \"rmt-039\", // 039.xml Contains a C0 control character (form-feed), illegal in both XML 1.0 and 1.1",
          "211:         \"rmt-040\", // 040.xml Contains a C1 control character (partial line up), legal in XML 1.0 but not 1.1",
          "212:         \"rmt-042\", // 042.xml Contains a character reference to a C0 control character (form-feed), legal in XML 1.1 but not 1.0",
          "213:         \"rmt-046\", // 046.xml Has a NEL character in element content whitespace; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "214:         \"rmt-047\", // 047.xml Has a NEL character in element content whitespace; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "215:         \"rmt-050\", // 050.xml Has element content whitespace containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "216:         \"rmt-051\", // 051.xml Has element content whitespace containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "217:         \"rmt-052\", // 052.xml Has element content whitespace containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "218:         \"rmt-053\", // 053.xml Has element content whitespace containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "219:         \"rmt-054\", // 054.xml Contains a character reference to a C0 control character (form-feed) in an entity value.  This will be legal (in XML 1.1) when the entity declaration is parsed, but what about when it is used?",
          "220:     ]);",
          "221: }",
          "223: #[test] fn ibm_oasis_valid() {",
          "224:     run_suite(\"ibm/ibm_oasis_valid.xml\", &[",
          "225:         \"ibm-valid-P09-ibm09v01.xml\", // ibm09v01.xml Empty EntityValue is legal",
          "226:         \"ibm-valid-P09-ibm09v02.xml\", // ibm09v02.xml Tests a normal EnitityValue",
          "227:         \"ibm-valid-P09-ibm09v03.xml\", // ibm09v03.xml Tests EnitityValue referencing a Parameter Entity",
          "228:         \"ibm-valid-P09-ibm09v04.xml\", // ibm09v04.xml Tests EnitityValue referencing a General Entity",
          "229:         \"ibm-valid-P09-ibm09v05.xml\", // ibm09v05.xml Tests EnitityValue with combination of GE, PE and text, the GE used is      declared in the student.dtd",
          "230:         \"ibm-valid-P10-ibm10v01.xml\", // ibm10v01.xml Tests empty AttValue with double quotes as the delimiters",
          "231:         \"ibm-valid-P10-ibm10v02.xml\", // ibm10v02.xml Tests empty AttValue with single quotes as the delimiters",
          "232:         \"ibm-valid-P10-ibm10v03.xml\", // ibm10v03.xml Test AttValue with double quotes as the delimiters and single quote inside",
          "233:         \"ibm-valid-P10-ibm10v04.xml\", // ibm10v04.xml Test AttValue with single quotes as the delimiters and double quote inside",
          "234:         \"ibm-valid-P10-ibm10v05.xml\", // ibm10v05.xml Test AttValue with a GE reference and double quotes as the delimiters",
          "235:         \"ibm-valid-P10-ibm10v06.xml\", // ibm10v06.xml Test AttValue with a GE reference and single quotes as the delimiters",
          "236:         \"ibm-valid-P10-ibm10v07.xml\", // ibm10v07.xml testing AttValue with mixed references and text content in double quotes",
          "237:         \"ibm-valid-P10-ibm10v08.xml\", // ibm10v08.xml testing AttValue with mixed references and text content in single quotes",
          "238:         \"ibm-valid-P28-ibm28v02.xml\", // ibm28v02.xml Tests doctypedecl with external subset and combinations of different markup     declarations and PEReferences",
          "239:         \"ibm-valid-P29-ibm29v01.xml\", // ibm29v01.xml Tests markupdecl with combinations of elementdecl, AttlistDecl,EntityDecl,      NotationDecl, PI and comment",
          "240:         \"ibm-valid-P29-ibm29v02.xml\", // ibm29v02.xml Tests WFC: PE in internal subset as a positive test",
          "241:         \"ibm-valid-P32-ibm32v02.xml\", // ibm32v02.xml Tests VC: Standalone Document Declaration with external entity reference     and standalone is no",
          "242:         \"ibm-valid-P43-ibm43v01.xml\", // ibm43v01.xml Tests content with all possible constructs: element, CharData, Reference,      CDSect, Comment",
          "243:         \"ibm-valid-P67-ibm67v01.xml\", // ibm67v01.xml Tests Reference could be EntityRef or CharRef.",
          "244:         \"ibm-valid-P78-ibm78v01.xml\", // ibm78v01.xml Tests ExtParsedEnt, also TextDecl in P77 and EncodingDecl in P80",
          "245:     ]);",
          "246: }",
          "248: #[test] fn ibm_xml_11() {",
          "249:     run_suite(\"ibm/xml-1.1/ibm_valid.xml\", &[",
          "250:         \"ibm-1-1-valid-P02-ibm02v04.xml\", // ibm02v04.xml This test case contains embeded whitespace characters                   some form the range 1 - 1F.",
          "251:         \"ibm-1-1-valid-P03-ibm03v01.xml\", // ibm03v01.xml The two character sequence #x0D #x85 in an external entity must be normalized to a          single newline.",
          "252:         \"ibm-1-1-valid-P03-ibm03v02.xml\", // ibm03v02.xml The single character sequence #x85 in an external entity must be normalized to a          single newline.",
          "253:         \"ibm-1-1-valid-P03-ibm03v03.xml\", // ibm03v03.xml The two character sequence #x0D #x85 in an external entity must be normalized to a          single newline.",
          "254:         \"ibm-1-1-valid-P03-ibm03v04.xml\", // ibm03v04.xml The single character sequence #x85 in an external entity must be normalized to a          single newline.",
          "255:         \"ibm-1-1-valid-P03-ibm03v05.xml\", // ibm03v05.xml The two character sequence #x0D #x85 in a document entity must be normalized to a          single newline.",
          "256:         \"ibm-1-1-valid-P03-ibm03v06.xml\", // ibm03v06.xml The single character sequence #x85 in a document entity must be normalized to a          single newline.",
          "257:         \"ibm-1-1-valid-P03-ibm03v07.xml\", // ibm03v07.xml The single character sequence #x2028 in a document entity must be normalized to a          single newline.",
          "258:         \"ibm-1-1-valid-P04-ibm04v01.xml\", // ibm04v01.xml This test case covers legal NameStartChars character ranges plus discrete legal          characters for production 04.",
          "259:         \"ibm-1-1-valid-P05-ibm05v01.xml\", // ibm05v01.xml This test case covers legal Element Names as per production 5.",
          "260:         \"ibm-1-1-valid-P05-ibm05v03.xml\", // ibm05v03.xml This test case covers legal Attribute (Names) as per production 5.",
          "261:         \"ibm-1-1-valid-P77-ibm77v04.xml\", // ibm77v04.xml The VersionNum of the document entity is 1.1 whereas the VersionNum of the external          entity is 1.0.  The character #xD6 which is a valid XML 1.1 but an invalid XML 1.0          character is present in both documents.",
          "262:         \"ibm-1-1-valid-P77-ibm77v05.xml\", // ibm77v05.xml The VersionNum of the document entity is 1.1 whereas the VersionNum of the external          entity is 1.0.  The character #x1FFF which is a valid XML 1.1 but an invalid XML 1.0          character is present in both documents.",
          "263:         \"ibm-1-1-valid-P77-ibm77v06.xml\", // ibm77v06.xml The VersionNum of the document entity is 1.1 whereas the VersionNum of the external          entity is 1.0.  The character #xF901 which is a valid XML 1.1 but an invalid XML 1.0          character is present in both documents.",
          "264:         \"ibm-1-1-valid-P77-ibm77v10.xml\", // ibm77v10.xml The VersionNum of the document and external entity is 1.1 and both contain the          valid XML1.1 but invalid XML1.0 character #xF6.",
          "265:         \"ibm-1-1-valid-P77-ibm77v11.xml\", // ibm77v11.xml The VersionNum of the document and external entity is 1.1 and both contain the          valid XML1.1 but invalid XML1.0 character #x1FFF.",
          "266:         \"ibm-1-1-valid-P77-ibm77v12.xml\", // ibm77v12.xml The VersionNum of the document and external entity is 1.1 and both contain the          valid XML1.1 but invalid XML1.0 character #xF901.",
          "267:         \"ibm-1-1-valid-P77-ibm77v16.xml\", // ibm77v16.xml The VersionNum of the document entity is 1.1 but the external entity does not          contain a textDecl and both contain the valid XML1.1 but invalid XML1.0 character          #x2FF.",
          "268:         \"ibm-1-1-valid-P77-ibm77v17.xml\", // ibm77v17.xml The VersionNum of the document entity is 1.1 but the external entity does not          contain a textDecl and both contain the valid XML1.1 but invalid XML1.0 character          #x1FFF.",
          "269:         \"ibm-1-1-valid-P77-ibm77v18.xml\", // ibm77v18.xml The VersionNum of the document entity is 1.1 but the external entity does not          contain a textDecl and both contain the valid XML1.1 but invalid XML1.0 character          #xF901.",
          "270:         \"ibm-1-1-valid-P77-ibm77v22.xml\", // ibm77v22.xml The VersionNum of the document and the external entity is 1.1.  The entity contains          a reference to the character #x7F.",
          "271:         \"ibm-1-1-valid-P77-ibm77v23.xml\", // ibm77v23.xml The VersionNum of the document and the external entity is 1.1.  The entity contains          a reference to the character #x80.",
          "272:         \"ibm-1-1-valid-P77-ibm77v24.xml\", // ibm77v24.xml The VersionNum of the document and the external entity is 1.1.  The entity contains          a reference to the character #x9F.",
          "273:         \"ibm-1-1-valid-P77-ibm77v28.xml\", // ibm77v28.xml The VersionNum of the document is 1.1 and the textDecl is missing in the external          entity.  The replacement text of an entity declared in the external DTD contains a          reference to the character #x7F, #x80, #x9F.",
          "274:         \"ibm-1-1-valid-P77-ibm77v29.xml\", // ibm77v29.xml The VersionNum of the document is 1.1 and the textDecl is missing in the external          entity.  The replacement text of an entity declared in the external DTD contains a          reference to the character #x85, #x8F.",
          "275:         \"ibm-1-1-valid-P77-ibm77v30.xml\", // ibm77v30.xml The VersionNum of the document is 1.1 and the textDecl is missing in the external          entity.",
          "276:     ]);",
          "277: }",
          "279: #[test] fn oasis() {",
          "280:     run_suite(\"oasis/oasis.xml\", &[",
          "281:         \"o-p43pass1\", // Valid use of character data, comments, processing instructions and CDATA sections within the start and end tag.",
          "282:         \"o-p68pass1\", // Valid entity references.  Also ensures that a charref to           '&' isn't interpreted as an entity reference open delimiter",
          "283:         \"o-p04pass1\", // names with all valid ASCII characters, and one from each               other class in NameChar",
          "284:         \"o-p05pass1\", // various valid Name constructions",
          "285:         \"o-p15pass1\", // valid comments",
          "286:         \"o-p16pass1\", // Valid form of Processing Instruction. Shows that whitespace character data is valid before end of processing instruction.",
          "287:         \"o-p01fail1\", // S cannot occur before the prolog",
          "288:         \"o-p01fail2\", // comments cannot occur before the prolog",
          "289:         \"o-p01fail3\", // only one document element",
          "290:         \"o-p09fail1\", // EntityValue excludes '%'",
          "291:         \"o-p09fail2\", // EntityValue excludes '&'",
          "292:         \"o-p09fail3\", // incomplete character reference",
          "293:         \"o-p09fail4\", // quote types must match",
          "294:         \"o-p09fail5\", // quote types must match",
          "295:         \"o-p11fail1\", // quote types must match",
          "296:         \"o-p11fail2\", // cannot contain delimiting quotes",
          "297:         \"o-p12fail1\", // '\"' excluded",
          "298:         \"o-p12fail2\", // '\\' excluded",
          "299:         \"o-p12fail3\", // entity references excluded",
          "300:         \"o-p12fail6\", // built-in entity refs excluded",
          "301:         \"o-p12fail7\", // The public ID has a tab character, which is disallowed",
          "302:         \"o-p14fail3\", // \"]]>\" excluded",
          "303:         \"o-p18fail3\", // CDSect's can't nest",
          "304:         \"o-p22fail1\", // prolog must start with XML decl",
          "305:         \"o-p22fail2\", // prolog must start with XML decl",
          "306:         \"o-p23fail1\", // \"xml\" must be lower-case",
          "307:         \"o-p27fail1\", // References aren't allowed in Misc,     even if they would resolve to valid Misc.",
          "308:         \"o-p29fail1\", // A processor must not pass unknown declaration types.",
          "309:         \"o-p30fail1\", // An XML declaration is not the same as a TextDecl",
          "310:         \"o-p31fail1\", // external subset excludes doctypedecl",
          "311:         \"o-p32fail3\", // initial S is required",
          "312:         \"o-p40fail1\", // S is required between attributes",
          "313:         \"o-p44fail4\", // Whitespace required between attributes.",
          "314:         \"o-p45fail1\", // ELEMENT must be upper case.",
          "315:         \"o-p45fail2\", // S before contentspec is required.",
          "316:         \"o-p45fail3\", // only one content spec",
          "317:         \"o-p45fail4\", // no comments in declarations (contrast with SGML)",
          "318:         \"o-p46fail1\", // no parens on declared content",
          "319:         \"o-p46fail2\", // no inclusions (contrast with SGML)",
          "320:         \"o-p46fail3\", // no exclusions (contrast with SGML)",
          "321:         \"o-p46fail4\", // no space before occurrence",
          "322:         \"o-p46fail5\", // single group",
          "323:         \"o-p46fail6\", // can't be both declared and modeled",
          "324:         \"o-p47fail1\", // Invalid operator '|' must match previous operator ','",
          "325:         \"o-p47fail2\", // Illegal character '-' in Element-content model",
          "326:         \"o-p47fail3\", // Optional character must follow a name or list",
          "327:         \"o-p47fail4\", // Illegal space before optional character",
          "328:         \"o-p48fail1\", // Illegal space before optional character",
          "329:         \"o-p48fail2\", // Illegal space before optional character",
          "330:         \"o-p51fail1\", // occurrence on #PCDATA group must be *",
          "331:         \"o-p51fail2\", // occurrence on #PCDATA group must be *",
          "332:         \"o-p51fail3\", // #PCDATA must come first",
          "333:         \"o-p51fail4\", // occurrence on #PCDATA group must be *",
          "334:         \"o-p51fail5\", // only '|' connectors",
          "335:         \"o-p51fail6\", // Only '|' connectors and occurrence on #PCDATA group must be *",
          "336:         \"o-p51fail7\", // no nested groups",
          "337:         \"o-p52fail1\", // A name is required",
          "338:         \"o-p52fail2\", // A name is required",
          "339:         \"o-p53fail1\", // S is required before default",
          "340:         \"o-p53fail2\", // S is required before type",
          "341:         \"o-p53fail3\", // type is required",
          "342:         \"o-p53fail4\", // default is required",
          "343:         \"o-p53fail5\", // name is requried",
          "344:         \"o-p54fail1\", // don't pass unknown attribute types",
          "345:         \"o-p55fail1\", // must be upper case",
          "346:         \"o-p56fail1\", // no IDS type",
          "347:         \"o-p56fail2\", // no NUMBER type",
          "348:         \"o-p56fail3\", // no NAME type",
          "349:         \"o-p56fail4\", // no ENTITYS type - types must be upper case",
          "350:         \"o-p56fail5\", // types must be upper case",
          "351:         \"o-p57fail1\", // no keyword for NMTOKEN enumeration",
          "352:         \"o-p58fail1\", // at least one value required",
          "353:         \"o-p58fail2\", // separator must be '|'",
          "354:         \"o-p58fail3\", // notations are NAMEs, not NMTOKENs -- note:     Leaving the invalid           notation undeclared would cause a validating parser to fail without           checking the name syntax, so the notation is declared with an           invalid name.  A parser that reports error positions should report           an error at the AttlistDecl on line 6, before reaching the notation           declaration.",
          "355:         \"o-p58fail4\", // NOTATION must be upper case",
          "356:         \"o-p58fail5\", // S after keyword is required",
          "357:         \"o-p58fail6\", // parentheses are require",
          "358:         \"o-p58fail7\", // values are unquoted",
          "359:         \"o-p58fail8\", // values are unquoted",
          "360:         \"o-p59fail1\", // at least one required",
          "361:         \"o-p59fail2\", // separator must be \",\"",
          "362:         \"o-p59fail3\", // values are unquoted",
          "363:         \"o-p60fail1\", // keywords must be upper case",
          "364:         \"o-p60fail2\", // S is required after #FIXED",
          "365:         \"o-p60fail3\", // only #FIXED has both keyword and value",
          "366:         \"o-p60fail4\", // #FIXED required value",
          "367:         \"o-p60fail5\", // only one default type",
          "368:         \"o-p61fail1\", // no other types, including TEMP, which is valid in SGML",
          "369:         \"o-p62fail1\", // INCLUDE must be upper case",
          "370:         \"o-p62fail2\", // no spaces in terminating delimiter",
          "371:         \"o-p63fail1\", // IGNORE must be upper case",
          "372:         \"o-p63fail2\", // delimiters must be balanced",
          "373:         \"o-p64fail1\", // section delimiters must balance",
          "374:         \"o-p64fail2\", // section delimiters must balance",
          "375:         \"o-p66fail5\", // no references to non-characters",
          "376:         \"o-p69fail1\", // terminating ';' is required",
          "377:         \"o-p69fail2\", // no S after '%'",
          "378:         \"o-p69fail3\", // no S before ';'",
          "379:         \"o-p70fail1\", // This is neither",
          "380:         \"o-p71fail1\", // S is required before EntityDef",
          "381:         \"o-p71fail2\", // Entity name is a Name, not an NMToken",
          "382:         \"o-p71fail3\", // no S after \"<!\"",
          "383:         \"o-p71fail4\", // S is required after \"<!ENTITY\"",
          "384:         \"o-p72fail1\", // S is required after \"<!ENTITY\"",
          "385:         \"o-p72fail2\", // S is required after '%'",
          "386:         \"o-p72fail3\", // S is required after name",
          "387:         \"o-p72fail4\", // Entity name is a name, not an NMToken",
          "388:         \"o-p73fail1\", // No typed replacement text",
          "389:         \"o-p73fail2\", // Only one replacement value",
          "390:         \"o-p73fail3\", // No NDataDecl on replacement text",
          "391:         \"o-p73fail4\", // Value is required",
          "392:         \"o-p73fail5\", // No NDataDecl without value",
          "393:         \"o-p74fail1\", // no NDataDecls on parameter entities",
          "394:         \"o-p74fail2\", // value is required",
          "395:         \"o-p74fail3\", // only one value",
          "396:         \"o-p75fail1\", // S required after \"PUBLIC\"",
          "397:         \"o-p75fail2\", // S required after \"SYSTEM\"",
          "398:         \"o-p75fail3\", // S required between literals",
          "399:         \"o-p75fail4\", // \"SYSTEM\" implies only one literal",
          "400:         \"o-p75fail5\", // only one keyword",
          "401:         \"o-p75fail6\", // \"PUBLIC\" requires two literals (contrast with SGML)",
          "402:         \"o-p76fail1\", // S is required before \"NDATA\"",
          "403:         \"o-p76fail2\", // \"NDATA\" is upper-case",
          "404:         \"o-p76fail3\", // notation name is required",
          "405:     ]);",
          "406: }",
          "408: #[test] fn sun_valid() {",
          "409:     run_suite(\"sun/sun-valid.xml\", &[",
          "410:         \"ext01\", // Tests use of external parsed entities with and without content.",
          "411:         \"ext02\", // Tests use of external parsed entities with different    encodings than the base document.",
          "412:         \"not-sa02\", // A non-standalone document is valid if declared as such.",
          "413:         \"not-sa03\", // A non-standalone document is valid if declared as such.",
          "414:         \"not-sa04\", // A non-standalone document is valid if declared as such.",
          "415:         \"sa02\", // A document may be marked 'standalone' if any     attributes that need normalization are  defined within the internal DTD subset.",
          "416:         \"sa03\", // A document may be marked 'standalone' if any     the defined entities need expanding are internal,     and no attributes need defaulting or normalization.     On output, requires notations to be correctly reported.",
          "417:         \"sa04\", // Like sa03 but relies on attribute     defaulting defined in the internal subset.     On output, requires notations to be correctly reported.",
          "418:         \"v-pe00\", // Tests construction of internal entity replacement text, using     an example in the XML specification.",
          "419:         \"v-pe03\", // Tests construction of internal entity replacement text, using     an example in the XML specification.",
          "420:         \"v-pe02\", // Tests construction of internal entity replacement text, using     a complex example in the XML specification.",
          "421:     ]);",
          "422: }",
          "424: #[test] fn sun_ill_formed() {",
          "425:     run_suite(\"sun/sun-not-wf.xml\", &[",
          "426:         \"attlist01\", // SGML's NUTOKEN is not allowed.",
          "427:         \"attlist02\", // SGML's NUTOKENS attribute type is not allowed.",
          "428:         \"attlist03\", // Comma doesn't separate enumerations, unlike in SGML.",
          "429:         \"attlist04\", // SGML's NUMBER attribute type is not allowed.",
          "430:         \"attlist05\", // SGML's NUMBERS attribute type is not allowed.",
          "431:         \"attlist06\", // SGML's NAME attribute type is not allowed.",
          "432:         \"attlist07\", // SGML's NAMES attribute type is not allowed.",
          "433:         \"attlist08\", // SGML's #CURRENT is not allowed.",
          "434:         \"attlist09\", // SGML's #CONREF is not allowed.",
          "435:         \"attlist10\", // Whitespace required between attributes",
          "436:         \"attlist11\", // Whitespace required between attributes",
          "437:         \"cond01\", // Only INCLUDE and IGNORE are conditional section keywords",
          "438:         \"cond02\", // Must have keyword in conditional sections",
          "439:         \"content01\", // No whitespace before \"?\" in content model",
          "440:         \"content02\", // No whitespace before \"*\" in content model",
          "441:         \"content03\", // No whitespace before \"+\" in content model",
          "442:         \"decl01\", // External entities may not have standalone decls.",
          "443:         \"nwf-dtd00\", // Comma mandatory in content model",
          "444:         \"nwf-dtd01\", // Can't mix comma and vertical bar in content models",
          "445:         \"dtd02\", // PE name immediately after \"%\"",
          "446:         \"dtd03\", // PE name immediately followed by \";\"",
          "447:         \"dtd04\", // PUBLIC literal must be quoted",
          "448:         \"dtd05\", // SYSTEM identifier must be quoted",
          "449:         \"dtd07\", // Text declarations (which optionally begin any external entity)     are required to have \"encoding=...\".",
          "450:         \"encoding01\", // Illegal character \" \" in encoding name",
          "451:         \"encoding02\", // Illegal character \"/\" in encoding name",
          "452:         \"encoding03\", // Illegal character reference in encoding name",
          "453:         \"encoding04\", // Illegal character \":\" in encoding name",
          "454:         \"encoding05\", // Illegal character \"@\" in encoding name",
          "455:         \"encoding06\", // Illegal character \"+\" in encoding name",
          "456:         \"pubid01\", // Illegal entity ref in public ID",
          "457:         \"pubid02\", // Illegal characters in public ID",
          "458:         \"pubid03\", // Illegal characters in public ID",
          "459:         \"pubid04\", // Illegal characters in public ID",
          "460:         \"pubid05\", // SGML-ism:  public ID without system ID",
          "461:         \"sgml02\", // XML declaration must be at the very beginning of a document;   it\"s not a processing instruction",
          "462:         \"sgml04\", // ATTLIST declarations apply to only one element, unlike SGML",
          "463:         \"sgml05\", // ELEMENT declarations apply to only one element, unlike SGML",
          "464:         \"sgml06\", // ATTLIST declarations are never global, unlike in SGML",
          "465:         \"sgml07\", // SGML Tag minimization specifications are not allowed",
          "466:         \"sgml08\", // SGML Tag minimization specifications are not allowed",
          "467:         \"sgml09\", // SGML Content model exception specifications are not allowed",
          "468:         \"sgml10\", // SGML Content model exception specifications are not allowed",
          "469:         \"sgml11\", // CDATA is not a valid content model spec",
          "470:         \"sgml12\", // RCDATA is not a valid content model spec",
          "471:         \"sgml13\", // SGML Unordered content models not allowed",
          "472:     ]);",
          "473: }",
          "475: #[ignore]",
          "476: #[test] fn japanese() {",
          "477:     run_suite(\"japanese/japanese.xml\", &[",
          "478:         \"pr-xml-little-endian.xml\"  // needs DTD",
          "479:     ]);",
          "480: }",
          "482: #[test] fn xmltest() {",
          "483:     run_suite(\"xmltest/xmltest.xml\", &[",
          "484:         \"not-wf-sa-003\", // Processing Instruction target name is required.",
          "485:         \"not-wf-sa-025\", // Text may not contain a literal ']]>' sequence.",
          "486:         \"not-wf-sa-026\", // Text may not contain a literal ']]>' sequence.",
          "487:         \"not-wf-sa-029\", // Text may not contain a literal ']]>' sequence.",
          "488:         \"not-wf-sa-030\", // A form feed is not a legal XML character.",
          "489:         \"not-wf-sa-031\", // A form feed is not a legal XML character.",
          "490:         \"not-wf-sa-032\", // A form feed is not a legal XML character.",
          "491:         \"not-wf-sa-033\", // An ESC (octal 033) is not a legal XML character.",
          "492:         \"not-wf-sa-037\", // Character references may not appear after the root element.",
          "493:         \"not-wf-sa-040\", // Provides two document elements.",
          "494:         \"not-wf-sa-041\", // Provides two document elements.",
          "495:         \"not-wf-sa-044\", // Provides two document elements.",
          "496:         \"not-wf-sa-048\", // Provides a CDATA section after the root element.",
          "497:         \"not-wf-sa-051\", // CDATA is invalid at top level of document.",
          "498:         \"not-wf-sa-052\", // Invalid character reference.",
          "499:         \"not-wf-sa-054\", // PUBLIC requires two literals.",
          "500:         \"not-wf-sa-056\", // Invalid Document Type Definition format - misplaced comment.",
          "501:         \"not-wf-sa-057\", // This isn't SGML; comments can't exist in declarations.",
          "502:         \"not-wf-sa-058\", // Invalid character , in ATTLIST enumeration",
          "503:         \"not-wf-sa-059\", // String literal must be in quotes.",
          "504:         \"not-wf-sa-060\", // Invalid type NAME defined in ATTLIST.",
          "505:         \"not-wf-sa-061\", // External entity declarations require whitespace between public     and system IDs.",
          "506:         \"not-wf-sa-062\", // Entity declarations need space after the entity name.",
          "507:         \"not-wf-sa-063\", // Conditional sections may only appear in the external     DTD subset.",
          "508:         \"not-wf-sa-064\", // Space is required between attribute type and default values     in <!ATTLIST...> declarations.",
          "509:         \"not-wf-sa-065\", // Space is required between attribute name and type     in <!ATTLIST...> declarations.",
          "510:         \"not-wf-sa-066\", // Required whitespace is missing.",
          "511:         \"not-wf-sa-067\", // Space is required between attribute type and default values     in <!ATTLIST...> declarations.",
          "512:         \"not-wf-sa-068\", // Space is required between NOTATION keyword and list of     enumerated choices in <!ATTLIST...> declarations.",
          "513:         \"not-wf-sa-069\", // Space is required before an NDATA entity annotation.",
          "514:         \"not-wf-sa-078\", // Undefined ENTITY foo.",
          "515:         \"not-wf-sa-079\", // ENTITY can't reference itself directly or indirectly.",
          "516:         \"not-wf-sa-080\", // ENTITY can't reference itself directly or indirectly.",
          "517:         \"not-wf-sa-082\", // This tests the No External Entity References WFC,     since the entity is referred to within an attribute.",
          "518:         \"not-wf-sa-084\", // Tests the Parsed Entity WFC by referring to an     unparsed entity.  (This precedes the error of not declaring     that entity's notation, which may be detected any time before     the DTD parsing is completed.)",
          "519:         \"not-wf-sa-085\", // Public IDs may not contain \"[\".",
          "520:         \"not-wf-sa-086\", // Public IDs may not contain \"[\".",
          "521:         \"not-wf-sa-087\", // Public IDs may not contain \"[\".",
          "522:         \"not-wf-sa-089\", // Parameter entities \"are\" always parsed; NDATA annotations     are not permitted.",
          "523:         \"not-wf-sa-091\", // Parameter entities \"are\" always parsed; NDATA annotations     are not permitted.",
          "524:         \"not-wf-sa-096\", // Space is required before the standalone declaration.",
          "525:         \"not-wf-sa-101\", // Space is not permitted in an encoding name.",
          "526:         \"not-wf-sa-105\", // Invalid placement of CDATA section.",
          "527:         \"not-wf-sa-106\", // Invalid placement of entity declaration.",
          "528:         \"not-wf-sa-107\", // Invalid document type declaration.  CDATA alone is invalid.",
          "529:         \"not-wf-sa-113\", // Parameter entity values must use valid reference syntax;     this reference is malformed.",
          "530:         \"not-wf-sa-114\", // General entity values must use valid reference syntax;     this reference is malformed.",
          "531:         \"not-wf-sa-121\", // A name of an ENTITY was started with an invalid character.",
          "532:         \"not-wf-sa-122\", // Invalid syntax mixed connectors are used.",
          "533:         \"not-wf-sa-123\", // Invalid syntax mismatched parenthesis.",
          "534:         \"not-wf-sa-124\", // Invalid format of Mixed-content declaration.",
          "535:         \"not-wf-sa-125\", // Invalid syntax extra set of parenthesis not necessary.",
          "536:         \"not-wf-sa-126\", // Invalid syntax Mixed-content must be defined as zero or more.",
          "537:         \"not-wf-sa-127\", // Invalid syntax Mixed-content must be defined as zero or more.",
          "538:         \"not-wf-sa-128\", // Invalid CDATA syntax.",
          "539:         \"not-wf-sa-129\", // Invalid syntax for Element Type Declaration.",
          "540:         \"not-wf-sa-130\", // Invalid syntax for Element Type Declaration.",
          "541:         \"not-wf-sa-131\", // Invalid syntax for Element Type Declaration.",
          "542:         \"not-wf-sa-132\", // Invalid syntax mixed connectors used.",
          "543:         \"not-wf-sa-133\", // Illegal whitespace before optional character causes syntax error.",
          "544:         \"not-wf-sa-134\", // Illegal whitespace before optional character causes syntax error.",
          "545:         \"not-wf-sa-135\", // Invalid character used as connector.",
          "546:         \"not-wf-sa-136\", // Tag omission is invalid in XML.",
          "547:         \"not-wf-sa-137\", // Space is required before a content model.",
          "548:         \"not-wf-sa-138\", // Invalid syntax for content particle.",
          "549:         \"not-wf-sa-139\", // The element-content model should not be empty.",
          "550:         \"not-wf-sa-143\", // Character #x001F is not legal anywhere in an XML document.",
          "551:         \"not-wf-sa-144\", // Character #xFFFF is not legal anywhere in an XML document.",
          "552:         \"not-wf-sa-147\", // XML Declaration may not be preceded by whitespace.",
          "553:         \"not-wf-sa-148\", // XML Declaration may not be preceded by comments or whitespace.",
          "554:         \"not-wf-sa-149\", // XML Declaration may not be within a DTD.",
          "555:         \"not-wf-sa-154\", // '<?XML ...?>' is neither an XML declaration     nor a legal processing instruction target name.",
          "556:         \"not-wf-sa-155\", // '<?xmL ...?>' is neither an XML declaration     nor a legal processing instruction target name.",
          "557:         \"not-wf-sa-158\", // SGML-ism:  \"#NOTATION gif\" can't have attributes.",
          "558:         \"not-wf-sa-160\", // Violates the PEs in Internal Subset WFC     by using a PE reference within a declaration.",
          "559:         \"not-wf-sa-161\", // Violates the PEs in Internal Subset WFC     by using a PE reference within a declaration.",
          "560:         \"not-wf-sa-162\", // Violates the PEs in Internal Subset WFC     by using a PE reference within a declaration.",
          "561:         \"not-wf-sa-164\", // Invalid placement of Parameter entity reference.",
          "562:         \"not-wf-sa-165\", // Parameter entity declarations must have a space before     the '%'.",
          "563:         \"not-wf-sa-166\", // Character FFFF is not legal anywhere in an XML document.",
          "564:         \"not-wf-sa-167\", // Character FFFE is not legal anywhere in an XML document.",
          "565:         \"not-wf-sa-171\", // Character FFFF is not legal anywhere in an XML document.",
          "566:         \"not-wf-sa-172\", // Character FFFF is not legal anywhere in an XML document.",
          "567:         \"not-wf-sa-173\", // Character FFFF is not legal anywhere in an XML document.",
          "568:         \"not-wf-sa-174\", // Character FFFF is not legal anywhere in an XML document.",
          "569:         \"not-wf-sa-175\", // Character FFFF is not legal anywhere in an XML document.",
          "570:         \"not-wf-sa-177\", // Character FFFF is not legal anywhere in an XML document.",
          "571:         \"not-wf-sa-179\", // Invalid syntax matching double quote is missing.",
          "572:         \"not-wf-sa-180\", // The Entity Declared WFC requires entities to be declared     before they are used in an attribute list declaration.",
          "573:         \"not-wf-sa-183\", // Mixed content declarations may not include content particles.",
          "574:         \"not-wf-sa-184\", // In mixed content models, element names must not be     parenthesized.",
          "575:         \"not-wf-sa-186\", // Whitespace is required between attribute/value pairs.",
          "576:         \"not-wf-not-sa-001\", // Conditional sections must be properly terminated (\"]>\" used     instead of \"]]>\").",
          "577:         \"not-wf-not-sa-002\", // Processing instruction target names may not be \"XML\"      in any combination of cases.",
          "578:         \"not-wf-not-sa-003\", // Conditional sections must be properly terminated (\"]]>\" omitted).",
          "579:         \"not-wf-not-sa-004\", // Conditional sections must be properly terminated (\"]]>\" omitted).",
          "580:         \"not-wf-not-sa-005\", // Tests the Entity Declared VC by referring to an     undefined parameter entity within an external entity.",
          "581:         \"not-wf-not-sa-006\", // Conditional sections need a '[' after the INCLUDE or IGNORE.",
          "582:         \"not-wf-not-sa-007\", // A <!DOCTYPE ...> declaration may not begin any external     entity; it's only found once, in the document entity.",
          "583:         \"not-wf-not-sa-008\", // In DTDs, the '%' character must be part of a parameter     entity reference.",
          "584:         \"not-wf-not-sa-009\", // This test violates WFC:PE Between Declarations in Production 28a.       The last character of a markup declaration is not contained in the same      parameter-entity text replacement.",
          "585:         \"valid-sa-012\", // Uses a legal XML 1.0 name consisting of a single colon     character (disallowed by the latest XML Namespaces draft).",
          "586:         \"valid-sa-023\", // Test demonstrates that Entity References are valid element content.",
          "587:         \"valid-sa-024\", // Test demonstrates that Entity References are valid element content and also demonstrates a valid Entity Declaration.",
          "588:         \"valid-sa-049\", // Test demonstrates that characters outside of normal ascii range can be used as element content.",
          "589:         \"valid-sa-050\", // Test demonstrates that characters outside of normal ascii range can be used as element content.",
          "590:         \"valid-sa-051\", // The document is encoded in UTF-16 and uses some name     characters well outside of the normal ASCII range.",
          "591:         \"valid-sa-053\", // Tests inclusion of a well-formed internal entity, which     holds an element required by the content model.",
          "592:         \"valid-sa-066\", // Expands a CDATA attribute with a character reference.",
          "593:         \"valid-sa-068\", // Tests definition of an internal entity holding a carriage return character     reference, which must not be normalized before reporting to the application.  Line      break normalization only occurs when parsing external parsed entities.",
          "594:         \"valid-sa-085\", // Parameter and General entities use different namespaces,     so there can be an entity of each type with a given name.",
          "595:         \"valid-sa-086\", // Tests whether entities may be declared more than once,     with the first declaration being the binding one.",
          "596:         \"valid-sa-087\", // Tests whether character references in internal entities are     expanded early enough, by relying on correct handling to     make the entity be well formed.",
          "597:         \"valid-sa-088\", // Tests whether entity references in internal entities are     expanded late enough, by relying on correct handling to     make the expanded text be valid.  (If it's expanded too     early, the entity will parse as an element that's not     valid in that context.)",
          "598:         \"valid-sa-089\", // Tests entity expansion of three legal character references,     which each expand to a Unicode surrogate pair.",
          "599:         \"valid-sa-108\", // This tests normalization of end-of-line characters (CRLF)     within entities to LF, primarily as an output test.",
          "600:         \"valid-sa-110\", // Basically an output test, this requires that a CDATA     attribute with a CRLF be normalized to one space.",
          "601:         \"valid-sa-114\", // Test demonstrates that all text within a valid CDATA section is considered text and not recognized as markup.",
          "602:         \"valid-sa-115\", // Test demonstrates that an entity reference is processed by recursively processing the replacement text of the entity.",
          "603:         \"valid-sa-117\", // Test demonstrates that entity expansion is done while processing entity declarations.",
          "604:         \"valid-sa-118\", // Test demonstrates that entity expansion is done while processing entity declarations.",
          "605:         \"valid-not-sa-031\", // Expands a general entity which contains a CDATA section with     what looks like a markup declaration (but is just text since     it's in a CDATA section).",
          "606:         \"valid-ext-sa-001\", // A combination of carriage return line feed in an external entity must     be normalized to a single newline.",
          "607:         \"valid-ext-sa-002\", // A carriage return (also CRLF) in an external entity must     be normalized to a single newline.",
          "608:         \"valid-ext-sa-003\", // Test demonstrates that the content of an element can be empty. In this case the external entity is an empty file.",
          "609:         \"valid-ext-sa-004\", // A carriage return (also CRLF) in an external entity must     be normalized to a single newline.",
          "610:         \"valid-ext-sa-005\", // Test demonstrates the use of optional character and content particles within an element content.  The test also show the use of external entity.",
          "611:         \"valid-ext-sa-006\", // Test demonstrates the use of optional character and content particles within mixed element content.  The test also shows the use of an external entity and that a carriage control line feed in an external entity must be normalized to a single newline.",
          "612:         \"valid-ext-sa-007\", // Test demonstrates the use of external entity and how replacement  text is retrieved and processed.",
          "613:         \"valid-ext-sa-008\", // Test demonstrates the use of external  entity and how replacement text is retrieved and processed.  Also tests the use of an  EncodingDecl of UTF-16.",
          "614:         \"valid-ext-sa-009\", // A carriage return (also CRLF) in an external entity must     be normalized to a single newline.",
          "615:         \"valid-ext-sa-011\", // Test demonstrates the use of a public identifier with and external entity.   The test also show that a carriage control line feed combination in an external  entity must be normalized to a single newline.",
          "616:         \"valid-ext-sa-012\", // Test demonstrates both internal and external entities and that processing of entity references may be required to produce the correct replacement text.",
          "617:         \"valid-ext-sa-013\", // Test demonstrates that whitespace is handled by adding a single whitespace to the normalized value in the attribute list.",
          "618:         \"valid-ext-sa-014\", // Test demonstrates use of characters outside of normal ASCII range.",
          "619:     ]);",
          "620: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "00d53d5b4de6278eef047f2f68fe9125ede36e24",
      "candidate_info": {
        "commit_hash": "00d53d5b4de6278eef047f2f68fe9125ede36e24",
        "repo": "00xc/xml-rs",
        "commit_url": "https://github.com/00xc/xml-rs/commit/00d53d5b4de6278eef047f2f68fe9125ede36e24",
        "files": [
          "tests/cases/quote.xml",
          "tests/cases/xmlnsquote.xml",
          "tests/ht-bh.fail.txt",
          "tests/tests.xml",
          "tests/xmlconf.rs"
        ],
        "message": "Custom tests",
        "before_after_code_files": [
          "tests/xmlconf.rs||tests/xmlconf.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tests/xmlconf.rs||tests/xmlconf.rs"
          ],
          "candidate": [
            "tests/xmlconf.rs||tests/xmlconf.rs"
          ]
        }
      },
      "candidate_diff": {
        "tests/xmlconf.rs||tests/xmlconf.rs": [
          "File: tests/xmlconf.rs -> tests/xmlconf.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: fn run_suite(suite_rel_path: &str) {",
          "31:     ensure_unzipped();",
          "34:     let known_failures_file_path = Path::new(\"tests\").join(suite_path.with_extension(\"fail.txt\").file_name().unwrap());",
          "35:     let mut new_known_failures_file = if std::env::var(\"PRINT_SPEC\").map_or(false, |val| val == \"1\") { Some(String::new()) } else { None };",
          "",
          "[Removed Lines]",
          "33:     let suite_path = Path::new(\"tests/xmlconf\").join(suite_rel_path);",
          "",
          "[Added Lines]",
          "33:     let suite_path = Path::new(\"tests\").join(suite_rel_path);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54:             XmlEvent::EndElement { name } if name.local_name == \"TEST\" => {",
          "55:                 let path = root.join(&attr[\"URI\"]);",
          "56:                 let test_type = attr[\"TYPE\"].as_str();",
          "59:                 let res = match test_type {",
          "60:                     \"valid\" => expect_well_formed(&path, &desc),",
          "",
          "[Removed Lines]",
          "57:                 let id = attr[\"ID\"].as_str();",
          "",
          "[Added Lines]",
          "57:                 let id = attr.get(\"ID\").map(|a| a.as_str()).unwrap_or_else(|| path.file_stem().unwrap().to_str().unwrap());",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89:         }",
          "90:     }",
          "91:     if let Some(out) = new_known_failures_file {",
          "93:     }",
          "94:     assert!(parsed > 0);",
          "95: }",
          "97: #[track_caller]",
          "98: fn expect_well_formed(xml_path: &Path, msg: &str) -> Result<(), Box<dyn std::error::Error>> {",
          "100:     let r = EventReader::new(f);",
          "101:     let mut seen_any = false;",
          "102:     for e in r {",
          "",
          "[Removed Lines]",
          "92:         std::fs::write(known_failures_file_path, out).unwrap();",
          "99:     let f = BufReader::new(File::open(xml_path)?);",
          "",
          "[Added Lines]",
          "92:         if out.is_empty() {",
          "93:             let _ = std::fs::remove_file(known_failures_file_path);",
          "94:         } else {",
          "95:             std::fs::write(known_failures_file_path, out).unwrap();",
          "96:         }",
          "103:     let f = BufReader::new(File::open(xml_path).expect(\"testcase\"));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "122: }",
          "124: #[test] fn eduni_errata_2e() {",
          "126: }",
          "128: #[test] fn eduni_errata_3e() {",
          "130: }",
          "132: #[test] fn eduni_errata_4e() {",
          "134: }",
          "136: #[test] fn eduni_misc_ht() {",
          "138: }",
          "140: #[test] fn eduni_namespaces_10() {",
          "142: }",
          "144: #[test] fn eduni_namespaces_11() {",
          "146: }",
          "148: #[test] fn eduni_namespaces_errata() {",
          "150: }",
          "152: #[test] fn eduni_xml_11() {",
          "154: }",
          "156: #[test] fn ibm_oasis_valid() {",
          "158: }",
          "160: #[test] fn ibm_xml_11() {",
          "162: }",
          "164: #[test] fn oasis() {",
          "166: }",
          "168: #[test] fn sun_valid() {",
          "170: }",
          "172: #[test] fn sun_ill_formed() {",
          "174: }",
          "176: #[ignore]",
          "177: #[test] fn japanese() {",
          "179: }",
          "181: #[test] fn xmltest() {",
          "183: }",
          "",
          "[Removed Lines]",
          "125:     run_suite(\"eduni/errata-2e/errata2e.xml\");",
          "129:     run_suite(\"eduni/errata-3e/errata3e.xml\");",
          "133:     run_suite(\"eduni/errata-4e/errata4e.xml\");",
          "137:     run_suite(\"eduni/misc/ht-bh.xml\");",
          "141:     run_suite(\"eduni/namespaces/1.0/rmt-ns10.xml\");",
          "145:     run_suite(\"eduni/namespaces/1.1/rmt-ns11.xml\");",
          "149:     run_suite(\"eduni/namespaces/errata-1e/errata1e.xml\");",
          "153:     run_suite(\"eduni/xml-1.1/xml11.xml\");",
          "157:     run_suite(\"ibm/ibm_oasis_valid.xml\");",
          "161:     run_suite(\"ibm/xml-1.1/ibm_valid.xml\");",
          "165:     run_suite(\"oasis/oasis.xml\");",
          "169:     run_suite(\"sun/sun-valid.xml\");",
          "173:     run_suite(\"sun/sun-not-wf.xml\");",
          "178:     run_suite(\"japanese/japanese.xml\");",
          "182:     run_suite(\"xmltest/xmltest.xml\");",
          "",
          "[Added Lines]",
          "129:     run_suite(\"xmlconf/eduni/errata-2e/errata2e.xml\");",
          "133:     run_suite(\"xmlconf/eduni/errata-3e/errata3e.xml\");",
          "137:     run_suite(\"xmlconf/eduni/errata-4e/errata4e.xml\");",
          "141:     run_suite(\"xmlconf/eduni/misc/ht-bh.xml\");",
          "145:     run_suite(\"xmlconf/eduni/namespaces/1.0/rmt-ns10.xml\");",
          "149:     run_suite(\"xmlconf/eduni/namespaces/1.1/rmt-ns11.xml\");",
          "153:     run_suite(\"xmlconf/eduni/namespaces/errata-1e/errata1e.xml\");",
          "157:     run_suite(\"xmlconf/eduni/xml-1.1/xml11.xml\");",
          "161:     run_suite(\"xmlconf/ibm/ibm_oasis_valid.xml\");",
          "165:     run_suite(\"xmlconf/ibm/xml-1.1/ibm_valid.xml\");",
          "169:     run_suite(\"xmlconf/oasis/oasis.xml\");",
          "173:     run_suite(\"xmlconf/sun/sun-valid.xml\");",
          "177:     run_suite(\"xmlconf/sun/sun-not-wf.xml\");",
          "182:     run_suite(\"xmlconf/japanese/japanese.xml\");",
          "186:     run_suite(\"xmlconf/xmltest/xmltest.xml\");",
          "187: }",
          "189: #[test] fn own_tests() {",
          "190:     run_suite(\"tests.xml\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c4c04af5cdc2a9de9d4165c1d4a5d3a5b9f863fd",
      "candidate_info": {
        "commit_hash": "c4c04af5cdc2a9de9d4165c1d4a5d3a5b9f863fd",
        "repo": "00xc/xml-rs",
        "commit_url": "https://github.com/00xc/xml-rs/commit/c4c04af5cdc2a9de9d4165c1d4a5d3a5b9f863fd",
        "files": [
          "src/reader/parser.rs",
          "src/reader/parser/inside_doctype.rs",
          "src/reader/parser/inside_reference.rs",
          "src/reader/parser/outside_tag.rs",
          "tests/errata2e.fail.txt",
          "tests/errata4e.fail.txt",
          "tests/event_reader.rs",
          "tests/ibm_oasis_valid.fail.txt",
          "tests/ibm_valid.fail.txt",
          "tests/oasis.fail.txt",
          "tests/rmt-ns10.fail.txt",
          "tests/sun-valid.fail.txt",
          "tests/xml11.fail.txt",
          "tests/xmltest.fail.txt"
        ],
        "message": "Parse some <!ENTITY> declarations",
        "before_after_code_files": [
          "src/reader/parser.rs||src/reader/parser.rs",
          "src/reader/parser/inside_doctype.rs||src/reader/parser/inside_doctype.rs",
          "src/reader/parser/inside_reference.rs||src/reader/parser/inside_reference.rs",
          "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs",
          "tests/event_reader.rs||tests/event_reader.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/reader/parser/inside_doctype.rs||src/reader/parser/inside_doctype.rs",
            "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs"
          ],
          "candidate": [
            "src/reader/parser/inside_doctype.rs||src/reader/parser/inside_doctype.rs",
            "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/reader/parser.rs||src/reader/parser.rs": [
          "File: src/reader/parser.rs -> src/reader/parser.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: use std::borrow::Cow;",
          "4: use std::io::prelude::*;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: use std::collections::HashMap;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:     st: State,",
          "70:     state_after_reference: State,",
          "71:     buf: String,",
          "72:     nst: NamespaceStack,",
          "74:     data: MarkupData,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "75:     entities: HashMap<String, String>,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "93:             st: State::OutsideTag,",
          "94:             state_after_reference: State::OutsideTag,",
          "95:             buf: String::new(),",
          "96:             nst: NamespaceStack::default(),",
          "98:             data: MarkupData {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "101:             entities: HashMap::new(),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "140:     InsideComment,",
          "141:     InsideCData,",
          "142:     InsideDeclaration(DeclarationSubstate),",
          "147:     InsideReference,",
          "148: }",
          "150: #[derive(Copy, Clone, PartialEq)]",
          "151: pub enum OpeningTagSubstate {",
          "152:     InsideName,",
          "",
          "[Removed Lines]",
          "143:     InsideDoctype,",
          "144:     DoctypeMarkupDeclarationStart,",
          "145:     DoctypeMarkupDeclarationArgs,",
          "146:     InsideDoctypeMarkupDeclaration,",
          "",
          "[Added Lines]",
          "149:     InsideDoctype(DoctypeSubstate),",
          "153: #[derive(Copy, Clone, PartialEq)]",
          "154: pub enum DoctypeSubstate {",
          "155:     Outside,",
          "156:     InsideName,",
          "157:     BeforeEntityName,",
          "158:     EntityName,",
          "159:     BeforeEntityValue,",
          "160:     EntityValue,",
          "161:     NumericReferenceStart,",
          "162:     NumericReference,",
          "163:     SkipDeclaration,",
          "164: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "341:             State::OutsideTag                     => self.outside_tag(t),",
          "342:             State::InsideProcessingInstruction(s) => self.inside_processing_instruction(t, s),",
          "343:             State::InsideDeclaration(s)           => self.inside_declaration(t, s),",
          "348:             State::InsideOpeningTag(s)            => self.inside_opening_tag(t, s),",
          "349:             State::InsideClosingTag(s)            => self.inside_closing_tag_name(t, s),",
          "350:             State::InsideComment                  => self.inside_comment(t),",
          "",
          "[Removed Lines]",
          "344:             State::InsideDoctype                  => self.inside_doctype(t),",
          "345:             State::DoctypeMarkupDeclarationStart  => self.doctype_markup_declaration_start(t),",
          "346:             State::DoctypeMarkupDeclarationArgs   => self.doctype_markup_declaration_args(t),",
          "347:             State::InsideDoctypeMarkupDeclaration => self.inside_doctype_markup_declaration(t),",
          "",
          "[Added Lines]",
          "360:             State::InsideDoctype(s)               => self.inside_doctype(t, s),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "658:     #[test]",
          "659:     fn state_size() {",
          "660:         assert_eq!(2, std::mem::size_of::<super::State>());",
          "661:     }",
          "662: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "674:         assert_eq!(1, std::mem::size_of::<super::DoctypeSubstate>());",
          "",
          "---------------"
        ],
        "src/reader/parser/inside_doctype.rs||src/reader/parser/inside_doctype.rs": [
          "File: src/reader/parser/inside_doctype.rs -> src/reader/parser/inside_doctype.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: impl PullParser {",
          "15:             },",
          "53:                 }",
          "55:             },",
          "57:         }",
          "58:     }",
          "59: }",
          "",
          "[Removed Lines]",
          "1: use crate::{reader::lexer::Token, common::is_whitespace_char};",
          "3: use super::{PullParser, Result, State};",
          "6:     pub fn inside_doctype(&mut self, t: Token) -> Option<Result> {",
          "7:         match t {",
          "8:             Token::TagEnd => {",
          "9:                 self.into_state_continue(State::OutsideTag)",
          "10:             }",
          "12:             Token::MarkupDeclarationStart => {",
          "13:                 self.buf.clear();",
          "14:                 self.into_state_continue(State::DoctypeMarkupDeclarationStart)",
          "17:             _ => None,",
          "18:         }",
          "19:     }",
          "21:     pub fn inside_doctype_markup_declaration(&mut self, t: Token) -> Option<Result> {",
          "22:         match t {",
          "23:             Token::TagEnd => {",
          "24:                 self.into_state_continue(State::InsideDoctype)",
          "25:             }",
          "27:             _ => None,",
          "28:         }",
          "29:     }",
          "31:     pub fn doctype_markup_declaration_args(&mut self, t: Token) -> Option<Result> {",
          "32:         match t {",
          "33:             Token::TagEnd => {",
          "34:                 self.into_state_continue(State::InsideDoctype)",
          "35:             }",
          "36:             _ => None,",
          "37:         }",
          "38:     }",
          "40:     pub fn doctype_markup_declaration_start(&mut self, t: Token) -> Option<Result> {",
          "41:         match t {",
          "42:             Token::TagEnd => {",
          "43:                 self.into_state_continue(State::InsideDoctype)",
          "44:             }",
          "45:             Token::Character(c @ 'A'..='Z') => {",
          "46:                 self.buf.push(c);",
          "47:                 None",
          "48:             },",
          "49:             Token::Character(c) if is_whitespace_char(c) => {",
          "50:                 match self.buf.as_str() {",
          "51:                     \"ENTITY\" | \"NOTATION\" | \"ELEMENT\" | \"ATTLIST\" => self.into_state_continue(State::DoctypeMarkupDeclarationArgs),",
          "52:                     s => Some(self_error!(self; \"Unknown markup declaration: {}\", s)),",
          "56:             _ => Some(self_error!(self; \"Incomplete markup declaration: {}\", t)),",
          "",
          "[Added Lines]",
          "1: use crate::{reader::lexer::Token, common::{is_whitespace_char, is_name_start_char, is_name_char}};",
          "3: use super::{PullParser, Result, State, DoctypeSubstate, QuoteToken};",
          "6:     pub fn inside_doctype(&mut self, t: Token, substate: DoctypeSubstate) -> Option<Result> {",
          "7:         match substate {",
          "8:             DoctypeSubstate::Outside => match t {",
          "9:                 Token::TagEnd => {",
          "10:                     self.into_state_continue(State::OutsideTag)",
          "11:                 }",
          "13:                 Token::MarkupDeclarationStart => {",
          "14:                     self.buf.clear();",
          "15:                     self.into_state_continue(State::InsideDoctype(DoctypeSubstate::InsideName))",
          "16:                 },",
          "18:                 _ => None,",
          "20:             DoctypeSubstate::InsideName => match t {",
          "21:                 Token::Character(c @ 'A'..='Z') => {",
          "22:                     self.buf.push(c);",
          "23:                     None",
          "24:                 },",
          "25:                 Token::Character(c) if is_whitespace_char(c) => {",
          "26:                     match self.buf.as_str() {",
          "27:                         \"ENTITY\" => self.into_state_continue(State::InsideDoctype(DoctypeSubstate::BeforeEntityName)),",
          "28:                         \"NOTATION\" | \"ELEMENT\" | \"ATTLIST\" => self.into_state_continue(State::InsideDoctype(DoctypeSubstate::SkipDeclaration)),",
          "29:                         s => Some(self_error!(self; \"Unknown markup declaration: {}\", s)),",
          "30:                     }",
          "32:                 },",
          "33:                 _ => Some(self_error!(self; \"Incomplete markup declaration: {}\", t)),",
          "34:             },",
          "35:             DoctypeSubstate::BeforeEntityName => {",
          "36:                 self.data.name.clear();",
          "37:                 match t {",
          "38:                     Token::Character(c) if is_whitespace_char(c) => None,",
          "40:                     Token::Character('%') => self.into_state_continue(State::InsideDoctype(DoctypeSubstate::SkipDeclaration)),",
          "41:                     Token::Character(c) if is_name_start_char(c) => {",
          "42:                         self.data.name.push(c);",
          "43:                         self.into_state_continue(State::InsideDoctype(DoctypeSubstate::EntityName))",
          "44:                     },",
          "45:                     _ => Some(self_error!(self; \"Expected entity name, found {}\", t)),",
          "48:             DoctypeSubstate::EntityName => match t {",
          "49:                 Token::Character(c) if is_whitespace_char(c) => {",
          "50:                     self.into_state_continue(State::InsideDoctype(DoctypeSubstate::BeforeEntityValue))",
          "51:                 },",
          "52:                 Token::Character(c) if is_name_char(c) => {",
          "53:                     self.data.name.push(c);",
          "54:                     None",
          "55:                 },",
          "56:                 _ => Some(self_error!(self; \"Expected entity name, found {}\", t)),",
          "57:             },",
          "58:             DoctypeSubstate::BeforeEntityValue => {",
          "59:                 self.buf.clear();",
          "60:                 match t {",
          "61:                     Token::Character(c) if is_whitespace_char(c) => None,",
          "63:                     Token::Character('S') | Token::Character('P') => self.into_state_continue(State::InsideDoctype(DoctypeSubstate::SkipDeclaration)),",
          "64:                     Token::SingleQuote | Token::DoubleQuote => {",
          "65:                         self.data.quote = Some(super::QuoteToken::from_token(&t));",
          "66:                         self.into_state_continue(State::InsideDoctype(DoctypeSubstate::EntityValue))",
          "67:                     },",
          "68:                     _ => Some(self_error!(self; \"Expected entity name, found {}\", t)),",
          "69:                 }",
          "70:             },",
          "71:             DoctypeSubstate::EntityValue => match t {",
          "72:                 Token::SingleQuote if self.data.quote != Some(QuoteToken::SingleQuoteToken) => { self.buf.push('\\''); None },",
          "73:                 Token::DoubleQuote if self.data.quote != Some(QuoteToken::DoubleQuoteToken) => { self.buf.push('\"'); None },",
          "74:                 Token::SingleQuote | Token::DoubleQuote => {",
          "75:                     let name = self.data.take_name();",
          "76:                     let val = self.take_buf();",
          "77:                     self.data.quote = None;",
          "78:                     self.entities.insert(name, val);",
          "79:                     self.into_state_continue(State::InsideDoctype(DoctypeSubstate::SkipDeclaration)) // FIXME",
          "80:                 },",
          "81:                 Token::Character('&') => {",
          "82:                     self.data.ref_data.clear();",
          "83:                     self.into_state_continue(State::InsideDoctype(DoctypeSubstate::NumericReferenceStart))",
          "84:                 },",
          "85:                 Token::Character(c) => {",
          "86:                     self.buf.push(c);",
          "87:                     None",
          "88:                 },",
          "89:                 _ => Some(self_error!(self; \"Expected entity value, found {}\", t)),",
          "90:             },",
          "91:             DoctypeSubstate::NumericReferenceStart => match t {",
          "92:                 Token::Character('#') => {",
          "93:                     self.into_state_continue(State::InsideDoctype(DoctypeSubstate::NumericReference))",
          "94:                 },",
          "95:                 Token::Character(c) => {",
          "96:                     self.buf.push('&');",
          "97:                     self.buf.push(c);",
          "98:                     self.into_state_continue(State::InsideDoctype(DoctypeSubstate::EntityValue))",
          "99:                 },",
          "100:                 _ => Some(self_error!(self; \"Unexpected {} in entity\", t)),",
          "101:             },",
          "102:             DoctypeSubstate::NumericReference => match t {",
          "103:                 Token::Character(';') => {",
          "104:                     let r = self.data.take_ref_data();",
          "106:                     match self.numeric_reference_from_str(&r) {",
          "107:                         Ok(c) => {",
          "108:                             self.buf.push(c);",
          "109:                             self.into_state_continue(State::InsideDoctype(DoctypeSubstate::EntityValue))",
          "110:                         }",
          "111:                         Err(e) => Some(self_error!(self; e)),",
          "112:                     }",
          "113:                 },",
          "114:                 Token::Character(c) => {",
          "115:                     self.data.ref_data.push(c);",
          "116:                     None",
          "117:                 },",
          "118:                 _ => Some(self_error!(self; \"Unexpected {} in entity\", t)),",
          "119:             },",
          "120:             DoctypeSubstate::SkipDeclaration => match t {",
          "121:                 Token::TagEnd => {",
          "122:                     self.into_state_continue(State::InsideDoctype(DoctypeSubstate::Outside))",
          "123:                 },",
          "124:                 _ => None,",
          "125:             },",
          "",
          "---------------"
        ],
        "src/reader/parser/inside_reference.rs||src/reader/parser/inside_reference.rs": [
          "File: src/reader/parser/inside_reference.rs -> src/reader/parser/inside_reference.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use std::char;",
          "5: use crate::reader::lexer::Token;",
          "",
          "[Removed Lines]",
          "3: use crate::common::{is_name_char, is_name_start_char, is_whitespace_str};",
          "",
          "[Added Lines]",
          "3: use crate::common::{is_name_char, is_name_start_char, is_whitespace_char};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "16:             }",
          "18:             Token::ReferenceEnd => {",
          "20:                 let name = self.data.take_ref_data();",
          "22:                 let c = match &name[..] {",
          "61:                     },",
          "69:                 };",
          "80:                 }",
          "81:             }",
          "83:             _ => Some(self_error!(self; \"Unexpected token inside an entity: {}\", t)),",
          "84:         }",
          "85:     }",
          "86: }",
          "",
          "[Removed Lines]",
          "21:                 let name_len = name.len();  // compute once",
          "23:                     \"lt\"   => Ok('<'.to_string()),",
          "24:                     \"gt\"   => Ok('>'.to_string()),",
          "25:                     \"amp\"  => Ok('&'.to_string()),",
          "26:                     \"apos\" => Ok('\\''.to_string()),",
          "27:                     \"quot\" => Ok('\"'.to_string()),",
          "28:                     \"\"     => Err(self_error!(self; \"Encountered empty entity\")),",
          "29:                     _ if name_len > 2 && name.starts_with(\"#x\") => {",
          "30:                         let num_str = &name[2..name_len];",
          "31:                         if num_str == \"0\" {",
          "32:                             Err(self_error!(self; \"Null character entity is not allowed\"))",
          "33:                         } else if self.config.replace_unknown_entity_references {",
          "34:                             match u32::from_str_radix(num_str, 16).ok().map(|i| char::from_u32(i).unwrap_or('\\u{fffd}')) {",
          "35:                                 Some(c) => Ok(c.to_string()),",
          "36:                                 None    => Err(self_error!(self; \"Invalid hexadecimal character number in an entity: {}\", name))",
          "37:                             }",
          "38:                         } else {",
          "39:                             match u32::from_str_radix(num_str, 16).ok().and_then(char::from_u32) {",
          "40:                                 Some(c) => Ok(c.to_string()),",
          "41:                                 None    => Err(self_error!(self; \"Invalid hexadecimal character number in an entity: {}\", name))",
          "42:                             }",
          "43:                         }",
          "44:                     }",
          "45:                     _ if name_len > 1 && name.starts_with('#') => {",
          "46:                         let num_str = &name[1..name_len];",
          "47:                         if num_str == \"0\" {",
          "48:                             Err(self_error!(self; \"Null character entity is not allowed\"))",
          "49:                         } else if self.config.replace_unknown_entity_references {",
          "50:                             match u32::from_str_radix(num_str, 10).ok().map(|i| char::from_u32(i).unwrap_or('\\u{fffd}')) {",
          "51:                                 Some(c) => Ok(c.to_string()),",
          "52:                                 None    => Err(self_error!(self; \"Invalid decimal character number in an entity: {}\", name))",
          "53:                             }",
          "54:                         }",
          "55:                         else {",
          "56:                             match u32::from_str_radix(num_str, 10).ok().and_then(char::from_u32) {",
          "57:                                 Some(c) => Ok(c.to_string()),",
          "58:                                 None    => Err(self_error!(self; \"Invalid decimal character number in an entity: {}\", name))",
          "59:                             }",
          "60:                         }",
          "62:                     _ => {",
          "63:                         if let Some(v) = self.config.extra_entities.get(&name) {",
          "64:                             Ok(v.clone())",
          "65:                         } else {",
          "66:                             Err(self_error!(self; \"Unexpected entity: {}\", name))",
          "67:                         }",
          "68:                     }",
          "70:                 match c {",
          "71:                     Ok(c) => {",
          "72:                         self.buf.push_str(&c);",
          "73:                         let prev_st = self.state_after_reference.clone();",
          "74:                         if prev_st == State::OutsideTag && !is_whitespace_str(&c) {",
          "75:                             self.inside_whitespace = false;",
          "76:                         }",
          "77:                         self.into_state_continue(prev_st)",
          "78:                     }",
          "79:                     Err(e) => Some(e),",
          "",
          "[Added Lines]",
          "20:                 if name == \"\" {",
          "21:                     return Some(self_error!(self; \"Encountered empty entity\"));",
          "22:                 }",
          "25:                     \"lt\"   => Some('<'),",
          "26:                     \"gt\"   => Some('>'),",
          "27:                     \"amp\"  => Some('&'),",
          "28:                     \"apos\" => Some('\\''),",
          "29:                     \"quot\" => Some('\"'),",
          "30:                     _ if name.starts_with('#') => match self.numeric_reference_from_str(&name[1..]) {",
          "31:                         Ok(c) => Some(c),",
          "32:                         Err(e) => return Some(self_error!(self; e))",
          "34:                     _ => None,",
          "36:                 if let Some(c) = c {",
          "37:                     self.buf.push(c);",
          "38:                 } else if let Some(v) = self.config.extra_entities.get(&name).or_else(|| self.entities.get(&name)) {",
          "39:                     self.buf.push_str(v);",
          "40:                 } else {",
          "41:                     return Some(self_error!(self; \"Unexpected entity: {}\", name));",
          "42:                 }",
          "43:                 let prev_st = self.state_after_reference.clone();",
          "44:                 if prev_st == State::OutsideTag && !is_whitespace_char(self.buf.chars().last().unwrap_or('\\0')) {",
          "45:                     self.inside_whitespace = false;",
          "47:                 self.into_state_continue(prev_st)",
          "54:     pub(crate) fn numeric_reference_from_str(&self, num_str: &str) -> std::result::Result<char, String> {",
          "55:         let val = if let Some(hex) = num_str.strip_prefix('x') {",
          "56:             u32::from_str_radix(hex, 16).map_err(|_| format!(\"Invalid hexadecimal character number in an entity: {num_str}\"))?",
          "57:         } else {",
          "58:             u32::from_str_radix(num_str, 10).map_err(|_| format!(\"Invalid character number in an entity: {num_str}\"))?",
          "59:         };",
          "60:         match char::from_u32(val) {",
          "61:             Some('\\0') => Err(\"NUL character entity is not allowed\".into()),",
          "62:             Some(c) => Ok(c),",
          "63:             None if self.config.replace_unknown_entity_references => {",
          "64:                 Ok('\\u{fffd}')",
          "65:             },",
          "66:             None => Err(format!(\"Invalid character U+{val:X}\")),",
          "67:         }",
          "68:     }",
          "",
          "---------------"
        ],
        "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs": [
          "File: src/reader/parser/outside_tag.rs -> src/reader/parser/outside_tag.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: use super::{",
          "7:     ClosingTagSubstate, OpeningTagSubstate, ProcessingInstructionSubstate, PullParser, Result,",
          "9: };",
          "11: impl PullParser {",
          "",
          "[Removed Lines]",
          "8:     State, DEFAULT_ENCODING, DEFAULT_STANDALONE, DEFAULT_VERSION,",
          "",
          "[Added Lines]",
          "8:     State, DEFAULT_ENCODING, DEFAULT_STANDALONE, DEFAULT_VERSION, DoctypeSubstate,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "86:                         self.next_pos();",
          "88:                     }",
          "90:                     Token::OpeningTagStart => {",
          "",
          "[Removed Lines]",
          "87:                         self.into_state(State::InsideDoctype, next_event)",
          "",
          "[Added Lines]",
          "87:                         self.into_state(State::InsideDoctype(DoctypeSubstate::Outside), next_event)",
          "",
          "---------------"
        ],
        "tests/event_reader.rs||tests/event_reader.rs": [
          "File: tests/event_reader.rs -> tests/event_reader.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "404:         br#\"",
          "405:             |StartDocument(1.0, UTF-8)",
          "406:             |StartElement(doc)",
          "408:         \"#,",
          "409:         ParserConfig::new(),",
          "410:         false,",
          "",
          "[Removed Lines]",
          "407:             |1:13 Invalid decimal character number in an entity: #55357",
          "",
          "[Added Lines]",
          "407:             |1:13 Invalid character U+D83D",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "415:         br#\"",
          "416:             |StartDocument(1.0, UTF-8)",
          "417:             |StartElement(doc)",
          "419:         \"#,",
          "420:         ParserConfig::new(),",
          "421:         false,",
          "",
          "[Removed Lines]",
          "418:             |1:13 Invalid hexadecimal character number in an entity: #xd83d",
          "",
          "[Added Lines]",
          "418:             |1:13 Invalid character U+D83D",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "64d877d1b4604bd297c97a62aba1a1d61e359925",
      "candidate_info": {
        "commit_hash": "64d877d1b4604bd297c97a62aba1a1d61e359925",
        "repo": "00xc/xml-rs",
        "commit_url": "https://github.com/00xc/xml-rs/commit/64d877d1b4604bd297c97a62aba1a1d61e359925",
        "files": [
          "tests/errata1e.fail.txt",
          "tests/errata2e.fail.txt",
          "tests/errata3e.fail.txt",
          "tests/errata4e.fail.txt",
          "tests/ht-bh.fail.txt",
          "tests/ibm_oasis_valid.fail.txt",
          "tests/ibm_valid.fail.txt",
          "tests/oasis.fail.txt",
          "tests/rmt-ns10.fail.txt",
          "tests/rmt-ns11.fail.txt",
          "tests/sun-not-wf.fail.txt",
          "tests/sun-valid.fail.txt",
          "tests/xml11.fail.txt",
          "tests/xmlconf.rs",
          "tests/xmltest.fail.txt"
        ],
        "message": "Store test results in external files",
        "before_after_code_files": [
          "tests/xmlconf.rs||tests/xmlconf.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tests/xmlconf.rs||tests/xmlconf.rs"
          ],
          "candidate": [
            "tests/xmlconf.rs||tests/xmlconf.rs"
          ]
        }
      },
      "candidate_diff": {
        "tests/xmlconf.rs||tests/xmlconf.rs": [
          "File: tests/xmlconf.rs -> tests/xmlconf.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: use std::collections::HashSet;",
          "5: use std::path::Path;",
          "6: use std::collections::HashMap;",
          "7: use std::fs::File;",
          "",
          "[Removed Lines]",
          "4: use std::ffi::OsStr;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "27: }",
          "29: #[track_caller]",
          "31:     ensure_unzipped();",
          "35:     let suite_path = Path::new(\"tests/xmlconf\").join(suite_rel_path);",
          "36:     let root = suite_path.parent().unwrap();",
          "37:     let mut parsed = 0;",
          "",
          "[Removed Lines]",
          "30: fn run_suite(suite_rel_path: &str, known_broken_tests: &[&str]) {",
          "33:     let known_broken_tests = known_broken_tests.iter().map(|name| name.as_ref()).collect::<HashSet<&OsStr>>();",
          "",
          "[Added Lines]",
          "29: fn run_suite(suite_rel_path: &str) {",
          "33:     let known_failures_file_path = Path::new(\"tests\").join(suite_path.with_extension(\"fail.txt\").file_name().unwrap());",
          "34:     let mut new_known_failures_file = if std::env::var(\"PRINT_SPEC\").map_or(false, |val| val == \"1\") { Some(String::new()) } else { None };",
          "36:     let known_broken_test_ids: HashSet<_> = std::fs::read_to_string(&known_failures_file_path).unwrap_or_default().lines()",
          "37:         .map(|l| l.trim().split(' ').next().unwrap().to_string()).collect();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "45:         let e = e.expect(\"testsuite validity\");",
          "46:         match e {",
          "47:             XmlEvent::Characters(chr) => {",
          "49:             },",
          "50:             XmlEvent::EndElement { name } if name.local_name == \"TEST\" => {",
          "51:                 let path = root.join(&attr[\"URI\"]);",
          "",
          "[Removed Lines]",
          "48:                 desc.push_str(&chr.replace('\\n', \" \"));",
          "",
          "[Added Lines]",
          "51:                 desc.push_str(&chr.replace('\\n', \" \").replace(\"  \", \" \").replace(\"  \", \" \"));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "53:                 let id = attr[\"ID\"].as_str();",
          "55:                 let res = match test_type {",
          "59:                     other => unimplemented!(\"{other}?? type\"),",
          "60:                 };",
          "70:                 parsed += 1;",
          "71:             },",
          "72:             XmlEvent::StartElement { name, attributes, namespace: _ } if name.local_name == \"TEST\" => {",
          "",
          "[Removed Lines]",
          "56:                     \"valid\" => expect_well_formed(&path, &desc, id),",
          "57:                     \"invalid\" => expect_well_formed(&path, &desc, id), // invalid is still well-formed",
          "58:                     \"not-wf\" | \"error\" => expect_ill_formed(&path, &desc, id),",
          "62:                 let known_bad = known_broken_tests.contains::<OsStr>(id.as_ref());",
          "64:                 match res {",
          "65:                     Err(_) if known_bad => {},",
          "66:                     Err(e) => panic!(\"{suite_rel_path} failed on {} ({id})\\n{e}\", path.display()),",
          "67:                     Ok(()) if known_bad => panic!(\"expected {} ({id}) to fail, but it passes {test_type} of {suite_rel_path} now\\n{desc}\", path.display()),",
          "68:                     Ok(()) => {},",
          "69:                 };",
          "",
          "[Added Lines]",
          "59:                     \"valid\" => expect_well_formed(&path, &desc),",
          "60:                     \"invalid\" => expect_well_formed(&path, &desc), // invalid is still well-formed",
          "61:                     \"not-wf\" | \"error\" => expect_ill_formed(&path, &desc),",
          "65:                 if let Some(out) = new_known_failures_file.as_mut() {",
          "66:                     if let Err(e) = res {",
          "67:                         use std::fmt::Write;",
          "68:                         write!(out, \"{id} {e}\").unwrap();",
          "69:                     }",
          "70:                 } else {",
          "71:                     let known_bad = known_broken_test_ids.contains(id);",
          "72:                     match res {",
          "73:                         Err(_) if known_bad => {},",
          "74:                         Err(e) => panic!(\"{suite_rel_path} failed on {} ({id})\\n{e}\", path.display()),",
          "75:                         Ok(()) if known_bad => panic!(\"expected {} ({id}) to fail, but it passes {test_type} of {suite_rel_path} now\\n{desc}\", path.display()),",
          "76:                         Ok(()) => {},",
          "77:                     };",
          "78:                 }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "78:         }",
          "79:     }",
          "80:     assert!(parsed > 0);",
          "81: }",
          "83: #[track_caller]",
          "85:     let f = BufReader::new(File::open(xml_path)?);",
          "86:     let r = EventReader::new(f);",
          "87:     let mut seen_any = false;",
          "88:     for e in r {",
          "90:         if let XmlEvent::EndElement { .. } = e {",
          "91:             seen_any = true;",
          "92:         }",
          "",
          "[Removed Lines]",
          "84: fn expect_well_formed(xml_path: &Path, msg: &str, id: &str) -> Result<(), Box<dyn std::error::Error>> {",
          "89:         let e = e.map_err(|e| format!(\"\\\"{id}\\\", // {} {msg}; {e}\", xml_path.file_name().and_then(|f| f.to_str()).unwrap()))?;",
          "",
          "[Added Lines]",
          "90:     if let Some(out) = new_known_failures_file {",
          "91:         std::fs::write(known_failures_file_path, out).unwrap();",
          "92:     }",
          "97: fn expect_well_formed(xml_path: &Path, msg: &str) -> Result<(), Box<dyn std::error::Error>> {",
          "102:         let e = e.map_err(|e| format!(\"{} {msg}; {e}\\n\", xml_path.file_name().and_then(|f| f.to_str()).unwrap()))?;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "96: }",
          "98: #[track_caller]",
          "100:     let f = BufReader::new(File::open(xml_path)?);",
          "101:     let r = EventReader::new(f);",
          "102:     for e in r {",
          "",
          "[Removed Lines]",
          "99: fn expect_ill_formed(xml_path: &Path, msg: &str, id: &str) -> Result<(), Box<dyn std::error::Error>> {",
          "",
          "[Added Lines]",
          "112: fn expect_ill_formed(xml_path: &Path, msg: &str) -> Result<(), Box<dyn std::error::Error>> {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "104:             return Ok(());",
          "105:         }",
          "106:     }",
          "108: }",
          "110: #[test] fn eduni_errata_2e() {",
          "125: }",
          "127: #[test] fn eduni_errata_3e() {",
          "132: }",
          "134: #[test] fn eduni_errata_4e() {",
          "149: }",
          "151: #[test] fn eduni_misc_ht() {",
          "153: }",
          "155: #[test] fn eduni_namespaces_10() {",
          "170: }",
          "172: #[test] fn eduni_namespaces_11() {",
          "179: }",
          "181: #[test] fn eduni_namespaces_errata() {",
          "186: }",
          "188: #[test] fn eduni_xml_11() {",
          "220: }",
          "222: #[test] fn ibm_oasis_valid() {",
          "245: }",
          "247: #[test] fn ibm_xml_11() {",
          "276: }",
          "278: #[test] fn oasis() {",
          "400: }",
          "402: #[test] fn sun_valid() {",
          "416: }",
          "418: #[test] fn sun_ill_formed() {",
          "468: }",
          "470: #[ignore]",
          "471: #[test] fn japanese() {",
          "475: }",
          "477: #[test] fn xmltest() {",
          "612: }",
          "",
          "[Removed Lines]",
          "107:     Err(format!(\"\\\"{id}\\\", // {} {msg}\", xml_path.file_name().and_then(|f| f.to_str()).unwrap()))?",
          "111:     run_suite(\"eduni/errata-2e/errata2e.xml\", &[",
          "112:         \"rmt-e2e-15a\", // Empty content can't contain an entity reference",
          "113:         \"rmt-e2e-15e\", // Element content can contain entity reference if replacement text is whitespace",
          "114:         \"rmt-e2e-15f\", // Element content can contain entity reference if replacement text is whitespace, even if it came from a character reference in the literal entity value",
          "115:         \"rmt-e2e-15h\", // Element content can't contain entity reference if replacement text is character reference to whitespace",
          "116:         \"rmt-e2e-18\", // External entity containing start of entity declaration is base URI for system identifier",
          "117:         \"rmt-e2e-19\", // Parameter entities and character references are included-in-literal, but general entities are bypassed.",
          "118:         \"rmt-e2e-22\", // UTF-8 entities may start with a BOM",
          "119:         \"rmt-e2e-34\", // A non-deterministic content model is an error even if the element type is not used.",
          "120:         \"rmt-e2e-50\", // All line-ends are normalized, even those not passed to the application. NB this can only be tested effectively in XML 1.1, since CR is in the S production; in 1.1 we can use NEL which isn't.",
          "121:         \"rmt-e2e-55\", // A reference to an unparsed entity in an entity value is an error rather than forbidden (unless the entity is referenced, of course)",
          "122:         \"rmt-e2e-57\", // A value other than preserve or default for xml:space is an error",
          "123:         \"rmt-e2e-61\", // (From John Cowan) An encoding declaration in ASCII specifying an encoding that is not compatible with ASCII (so the document is not in its declared encoding).  It should generate a fatal error.",
          "124:     ]);",
          "128:     run_suite(\"eduni/errata-3e/errata3e.xml\", &[",
          "129:         \"rmt-e3e-12\", // E12.xml Default values for attributes may not contain references to external entities.",
          "130:         \"rmt-e3e-13\", // E13.xml Even internal parameter entity references are enough to make undeclared entities into mere validity errors rather than well-formedness errors.",
          "131:     ]);",
          "135:     run_suite(\"eduni/errata-4e/errata4e.xml\", &[",
          "136:         \"invalid-bo-1\", // inclbom_be.xml Byte order mark in general entity should go away (big-endian)",
          "137:         \"invalid-bo-2\", // inclbom_le.xml Byte order mark in general entity should go away (little-endian)",
          "138:         \"invalid-bo-3\", // incl8bom.xml Byte order mark in general entity should go away (utf-8)",
          "139:         \"invalid-bo-4\", // inclbombom_be.xml Two byte order marks in general entity produce only one (big-endian)",
          "140:         \"invalid-bo-5\", // inclbombom_le.xml Two byte order marks in general entity produce only one (little-endian)",
          "141:         \"invalid-bo-6\", // incl8bombom.xml Two byte order marks in general entity produce only one (utf-8)",
          "142:         \"invalid-sa-140\", // 140.xml Character '&#x309a;' is a CombiningChar, not a Letter, but as of 5th edition, may begin a name (c.f. xmltest/not-wf/sa/140.xml).",
          "143:         \"invalid-sa-141\", // 141.xml As of 5th edition, character #x0E5C is legal in XML names (c.f. xmltest/not-wf/sa/141.xml).",
          "144:         \"x-rmt-008b\", // 008.xml a document with version=1.7, legal in XML 1.0 from 5th edition",
          "145:         \"x-ibm-1-0.5-valid-P04-ibm04v01.xml\", // ibm04v01.xml This test case covers legal NameStartChars character ranges plus discrete legal characters for production 04.",
          "146:         \"x-ibm-1-0.5-valid-P05-ibm05v01.xml\", // ibm05v01.xml This test case covers legal Element Names as per production 5.",
          "147:         \"x-ibm-1-0.5-valid-P05-ibm05v03.xml\", // ibm05v03.xml This test case covers legal Attribute (Names) as per production 5.",
          "148:     ]);",
          "152:     run_suite(\"eduni/misc/ht-bh.xml\", &[]);",
          "156:     run_suite(\"eduni/namespaces/1.0/rmt-ns10.xml\", &[",
          "157:         \"rmt-ns10-004\", // Namespace name test: a relative URI (deprecated)",
          "158:         \"rmt-ns10-005\", // Namespace name test: a same-document relative URI (deprecated)",
          "159:         \"rmt-ns10-009\", // Namespace equality test: plain repetition",
          "160:         \"rmt-ns10-010\", // Namespace equality test: use of character reference",
          "161:         \"rmt-ns10-012\", // Namespace inequality test: equal after attribute value normalization",
          "162:         \"rmt-ns10-030\", // Reserved prefixes and namespaces: binding another prefix to the xml namespace",
          "163:         \"rmt-ns10-033\", // Reserved prefixes and namespaces: binding another prefix to the xmlns namespace",
          "164:         \"rmt-ns10-036\", // Attribute uniqueness: repeated attribute with different prefixes",
          "165:         \"rmt-ns10-042\", // Colon in PI name",
          "166:         \"rmt-ns10-043\", // Colon in entity name",
          "167:         \"rmt-ns10-044\", // Colon in entity name",
          "168:         \"ht-ns10-047\", // Reserved name: _not_ an error",
          "169:     ]);",
          "173:     run_suite(\"eduni/namespaces/1.1/rmt-ns11.xml\", &[",
          "174:         \"rmt-ns11-001\", // 001.xml Namespace name test: a perfectly good http IRI that is not a URI",
          "175:         \"rmt-ns11-002\", // 002.xml Namespace inequality test: different escaping of non-ascii letter",
          "176:         \"rmt-ns11-003\", // 003.xml 1.1 style prefix unbinding",
          "177:         \"rmt-ns11-004\", // 004.xml 1.1 style prefix unbinding and rebinding",
          "178:     ]);",
          "182:     run_suite(\"eduni/namespaces/errata-1e/errata1e.xml\", &[",
          "183:         \"rmt-ns-e1.0-13a\", // NE13a.xml The xml namespace must not be declared as the default namespace.",
          "184:         \"rmt-ns-e1.0-13b\", // NE13b.xml The xmlns namespace must not be declared as the default namespace.",
          "185:     ]);",
          "189:     run_suite(\"eduni/xml-1.1/xml11.xml\", &[",
          "190:         \"rmt-001\", // 001.xml External subset has later version number",
          "191:         \"rmt-002\", // 002.xml External PE has later version number",
          "192:         \"rmt-006\", // 006.xml Second-level external general entity has later version number than first-level, but not later than document, so not an error.",
          "193:         \"rmt-010\", // 010.xml Contains a C1 control, legal in XML 1.0, illegal in XML 1.1",
          "194:         \"rmt-013\", // 013.xml Contains a DEL, legal in XML 1.0, illegal in XML 1.1",
          "195:         \"rmt-014\", // 014.xml Has a \"long s\" in a name, legal in XML 1.1, illegal in XML 1.0 thru 4th edition",
          "196:         \"rmt-016\", // 016.xml Has a Byzantine Musical Symbol Kratimata in a name, legal in XML 1.1, illegal in XML 1.0 thru 4th edition",
          "197:         \"rmt-019\", // 019.xml Has the last legal namechar in XML 1.1, illegal in XML 1.0 thru 4th edition",
          "198:         \"rmt-022\", // 022.xml Has a NEL character; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "199:         \"rmt-023\", // 023.xml Has a NEL character; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "200:         \"rmt-026\", // 026.xml Has CR-NEL; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "201:         \"rmt-027\", // 027.xml Has CR-NEL; legal in both XML 1.0 and 1.1, but different canonical output because of normalization in 1.1",
          "202:         \"rmt-030\", // 030.xml Has a NEL character in an NMTOKENS attribute; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "203:         \"rmt-031\", // 031.xml Has a NEL character in an NMTOKENS attribute; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "204:         \"rmt-034\", // 034.xml Has an NMTOKENS attribute containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "205:         \"rmt-035\", // 035.xml Has an NMTOKENS attribute containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "206:         \"rmt-036\", // 036.xml Has an NMTOKENS attribute containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "207:         \"rmt-037\", // 037.xml Has an NMTOKENS attribute containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "208:         \"rmt-038\", // 038.xml Contains a C0 control character (form-feed), illegal in both XML 1.0 and 1.1",
          "209:         \"rmt-039\", // 039.xml Contains a C0 control character (form-feed), illegal in both XML 1.0 and 1.1",
          "210:         \"rmt-040\", // 040.xml Contains a C1 control character (partial line up), legal in XML 1.0 but not 1.1",
          "211:         \"rmt-042\", // 042.xml Contains a character reference to a C0 control character (form-feed), legal in XML 1.1 but not 1.0",
          "212:         \"rmt-046\", // 046.xml Has a NEL character in element content whitespace; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "213:         \"rmt-047\", // 047.xml Has a NEL character in element content whitespace; well-formed in both XML 1.0 and 1.1, but valid only in 1.1",
          "214:         \"rmt-050\", // 050.xml Has element content whitespace containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "215:         \"rmt-051\", // 051.xml Has element content whitespace containing a CR character that comes from a character reference in an internal entity.  Because CR is in the S production, this is valid in both XML 1.0 and 1.1.",
          "216:         \"rmt-052\", // 052.xml Has element content whitespace containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "217:         \"rmt-053\", // 053.xml Has element content whitespace containing a NEL character that comes from a character reference in an internal entity.  Because NEL is not in the S production (even though real NELs are converted to LF on input), this is invalid in both XML 1.0 and 1.1.",
          "218:         \"rmt-054\", // 054.xml Contains a character reference to a C0 control character (form-feed) in an entity value.  This will be legal (in XML 1.1) when the entity declaration is parsed, but what about when it is used?",
          "219:     ]);",
          "223:     run_suite(\"ibm/ibm_oasis_valid.xml\", &[",
          "224:         \"ibm-valid-P09-ibm09v01.xml\", // ibm09v01.xml Empty EntityValue is legal",
          "225:         \"ibm-valid-P09-ibm09v02.xml\", // ibm09v02.xml Tests a normal EnitityValue",
          "226:         \"ibm-valid-P09-ibm09v03.xml\", // ibm09v03.xml Tests EnitityValue referencing a Parameter Entity",
          "227:         \"ibm-valid-P09-ibm09v04.xml\", // ibm09v04.xml Tests EnitityValue referencing a General Entity",
          "228:         \"ibm-valid-P09-ibm09v05.xml\", // ibm09v05.xml Tests EnitityValue with combination of GE, PE and text, the GE used is      declared in the student.dtd",
          "229:         \"ibm-valid-P10-ibm10v01.xml\", // ibm10v01.xml Tests empty AttValue with double quotes as the delimiters",
          "230:         \"ibm-valid-P10-ibm10v02.xml\", // ibm10v02.xml Tests empty AttValue with single quotes as the delimiters",
          "231:         \"ibm-valid-P10-ibm10v03.xml\", // ibm10v03.xml Test AttValue with double quotes as the delimiters and single quote inside",
          "232:         \"ibm-valid-P10-ibm10v04.xml\", // ibm10v04.xml Test AttValue with single quotes as the delimiters and double quote inside",
          "233:         \"ibm-valid-P10-ibm10v05.xml\", // ibm10v05.xml Test AttValue with a GE reference and double quotes as the delimiters",
          "234:         \"ibm-valid-P10-ibm10v06.xml\", // ibm10v06.xml Test AttValue with a GE reference and single quotes as the delimiters",
          "235:         \"ibm-valid-P10-ibm10v07.xml\", // ibm10v07.xml testing AttValue with mixed references and text content in double quotes",
          "236:         \"ibm-valid-P10-ibm10v08.xml\", // ibm10v08.xml testing AttValue with mixed references and text content in single quotes",
          "237:         \"ibm-valid-P28-ibm28v02.xml\", // ibm28v02.xml Tests doctypedecl with external subset and combinations of different markup     declarations and PEReferences",
          "238:         \"ibm-valid-P29-ibm29v01.xml\", // ibm29v01.xml Tests markupdecl with combinations of elementdecl, AttlistDecl,EntityDecl,      NotationDecl, PI and comment",
          "239:         \"ibm-valid-P29-ibm29v02.xml\", // ibm29v02.xml Tests WFC: PE in internal subset as a positive test",
          "240:         \"ibm-valid-P32-ibm32v02.xml\", // ibm32v02.xml Tests VC: Standalone Document Declaration with external entity reference     and standalone is no",
          "241:         \"ibm-valid-P43-ibm43v01.xml\", // ibm43v01.xml Tests content with all possible constructs: element, CharData, Reference,      CDSect, Comment",
          "242:         \"ibm-valid-P67-ibm67v01.xml\", // ibm67v01.xml Tests Reference could be EntityRef or CharRef.",
          "243:         \"ibm-valid-P78-ibm78v01.xml\", // ibm78v01.xml Tests ExtParsedEnt, also TextDecl in P77 and EncodingDecl in P80",
          "244:     ]);",
          "248:     run_suite(\"ibm/xml-1.1/ibm_valid.xml\", &[",
          "249:         \"ibm-1-1-valid-P02-ibm02v04.xml\", // ibm02v04.xml This test case contains embeded whitespace characters                   some form the range 1 - 1F.",
          "250:         \"ibm-1-1-valid-P03-ibm03v01.xml\", // ibm03v01.xml The two character sequence #x0D #x85 in an external entity must be normalized to a          single newline.",
          "251:         \"ibm-1-1-valid-P03-ibm03v02.xml\", // ibm03v02.xml The single character sequence #x85 in an external entity must be normalized to a          single newline.",
          "252:         \"ibm-1-1-valid-P03-ibm03v03.xml\", // ibm03v03.xml The two character sequence #x0D #x85 in an external entity must be normalized to a          single newline.",
          "253:         \"ibm-1-1-valid-P03-ibm03v04.xml\", // ibm03v04.xml The single character sequence #x85 in an external entity must be normalized to a          single newline.",
          "254:         \"ibm-1-1-valid-P03-ibm03v05.xml\", // ibm03v05.xml The two character sequence #x0D #x85 in a document entity must be normalized to a          single newline.",
          "255:         \"ibm-1-1-valid-P03-ibm03v06.xml\", // ibm03v06.xml The single character sequence #x85 in a document entity must be normalized to a          single newline.",
          "256:         \"ibm-1-1-valid-P03-ibm03v07.xml\", // ibm03v07.xml The single character sequence #x2028 in a document entity must be normalized to a          single newline.",
          "257:         \"ibm-1-1-valid-P04-ibm04v01.xml\", // ibm04v01.xml This test case covers legal NameStartChars character ranges plus discrete legal          characters for production 04.",
          "258:         \"ibm-1-1-valid-P05-ibm05v01.xml\", // ibm05v01.xml This test case covers legal Element Names as per production 5.",
          "259:         \"ibm-1-1-valid-P05-ibm05v03.xml\", // ibm05v03.xml This test case covers legal Attribute (Names) as per production 5.",
          "260:         \"ibm-1-1-valid-P77-ibm77v04.xml\", // ibm77v04.xml The VersionNum of the document entity is 1.1 whereas the VersionNum of the external          entity is 1.0.  The character #xD6 which is a valid XML 1.1 but an invalid XML 1.0          character is present in both documents.",
          "261:         \"ibm-1-1-valid-P77-ibm77v05.xml\", // ibm77v05.xml The VersionNum of the document entity is 1.1 whereas the VersionNum of the external          entity is 1.0.  The character #x1FFF which is a valid XML 1.1 but an invalid XML 1.0          character is present in both documents.",
          "262:         \"ibm-1-1-valid-P77-ibm77v06.xml\", // ibm77v06.xml The VersionNum of the document entity is 1.1 whereas the VersionNum of the external          entity is 1.0.  The character #xF901 which is a valid XML 1.1 but an invalid XML 1.0          character is present in both documents.",
          "263:         \"ibm-1-1-valid-P77-ibm77v10.xml\", // ibm77v10.xml The VersionNum of the document and external entity is 1.1 and both contain the          valid XML1.1 but invalid XML1.0 character #xF6.",
          "264:         \"ibm-1-1-valid-P77-ibm77v11.xml\", // ibm77v11.xml The VersionNum of the document and external entity is 1.1 and both contain the          valid XML1.1 but invalid XML1.0 character #x1FFF.",
          "265:         \"ibm-1-1-valid-P77-ibm77v12.xml\", // ibm77v12.xml The VersionNum of the document and external entity is 1.1 and both contain the          valid XML1.1 but invalid XML1.0 character #xF901.",
          "266:         \"ibm-1-1-valid-P77-ibm77v16.xml\", // ibm77v16.xml The VersionNum of the document entity is 1.1 but the external entity does not          contain a textDecl and both contain the valid XML1.1 but invalid XML1.0 character          #x2FF.",
          "267:         \"ibm-1-1-valid-P77-ibm77v17.xml\", // ibm77v17.xml The VersionNum of the document entity is 1.1 but the external entity does not          contain a textDecl and both contain the valid XML1.1 but invalid XML1.0 character          #x1FFF.",
          "268:         \"ibm-1-1-valid-P77-ibm77v18.xml\", // ibm77v18.xml The VersionNum of the document entity is 1.1 but the external entity does not          contain a textDecl and both contain the valid XML1.1 but invalid XML1.0 character          #xF901.",
          "269:         \"ibm-1-1-valid-P77-ibm77v22.xml\", // ibm77v22.xml The VersionNum of the document and the external entity is 1.1.  The entity contains          a reference to the character #x7F.",
          "270:         \"ibm-1-1-valid-P77-ibm77v23.xml\", // ibm77v23.xml The VersionNum of the document and the external entity is 1.1.  The entity contains          a reference to the character #x80.",
          "271:         \"ibm-1-1-valid-P77-ibm77v24.xml\", // ibm77v24.xml The VersionNum of the document and the external entity is 1.1.  The entity contains          a reference to the character #x9F.",
          "272:         \"ibm-1-1-valid-P77-ibm77v28.xml\", // ibm77v28.xml The VersionNum of the document is 1.1 and the textDecl is missing in the external          entity.  The replacement text of an entity declared in the external DTD contains a          reference to the character #x7F, #x80, #x9F.",
          "273:         \"ibm-1-1-valid-P77-ibm77v29.xml\", // ibm77v29.xml The VersionNum of the document is 1.1 and the textDecl is missing in the external          entity.  The replacement text of an entity declared in the external DTD contains a          reference to the character #x85, #x8F.",
          "274:         \"ibm-1-1-valid-P77-ibm77v30.xml\", // ibm77v30.xml The VersionNum of the document is 1.1 and the textDecl is missing in the external          entity.",
          "275:     ]);",
          "279:     run_suite(\"oasis/oasis.xml\", &[",
          "280:         \"o-p01fail1\", // S cannot occur before the prolog",
          "281:         \"o-p01fail2\", // comments cannot occur before the prolog",
          "282:         \"o-p01fail3\", // only one document element",
          "283:         \"o-p04pass1\", // names with all valid ASCII characters, and one from each               other class in NameChar",
          "284:         \"o-p05pass1\", // various valid Name constructions",
          "285:         \"o-p09fail1\", // EntityValue excludes '%'",
          "286:         \"o-p09fail2\", // EntityValue excludes '&'",
          "287:         \"o-p09fail3\", // incomplete character reference",
          "288:         \"o-p11pass1\", // p11pass1.xml       system literals may not contain     URI fragments",
          "289:         \"o-p12fail1\", // p12fail1.xml       '\"' excluded",
          "290:         \"o-p12fail2\", // '\\' excluded",
          "291:         \"o-p12fail3\", // entity references excluded",
          "292:         \"o-p12fail4\", // p12fail4.xml       '>' excluded",
          "293:         \"o-p12fail5\", // p12fail5.xml       '<' excluded",
          "294:         \"o-p12fail6\", // built-in entity refs excluded",
          "295:         \"o-p12fail7\", // The public ID has a tab character, which is disallowed",
          "296:         \"o-p14fail3\", // \"]]>\" excluded",
          "297:         \"o-p18fail3\", // CDSect's can't nest",
          "298:         \"o-p22fail1\", // prolog must start with XML decl",
          "299:         \"o-p22fail2\", // prolog must start with XML decl",
          "300:         \"o-p23fail1\", // \"xml\" must be lower-case",
          "301:         \"o-p27fail1\", // References aren't allowed in Misc,     even if they would resolve to valid Misc.",
          "302:         \"o-p30fail1\", // An XML declaration is not the same as a TextDecl",
          "303:         \"o-p31fail1\", // external subset excludes doctypedecl",
          "304:         \"o-p32fail3\", // initial S is required",
          "305:         \"o-p40fail1\", // S is required between attributes",
          "306:         \"o-p43pass1\", // Valid use of character data, comments, processing instructions and CDATA sections within the start and end tag.",
          "307:         \"o-p44fail4\", // Whitespace required between attributes.",
          "308:         \"o-p45fail2\", // S before contentspec is required.",
          "309:         \"o-p45fail3\", // only one content spec",
          "310:         \"o-p45fail4\", // no comments in declarations (contrast with SGML)",
          "311:         \"o-p46fail1\", // no parens on declared content",
          "312:         \"o-p46fail2\", // no inclusions (contrast with SGML)",
          "313:         \"o-p46fail3\", // no exclusions (contrast with SGML)",
          "314:         \"o-p46fail4\", // no space before occurrence",
          "315:         \"o-p46fail5\", // single group",
          "316:         \"o-p46fail6\", // can't be both declared and modeled",
          "317:         \"o-p47fail1\", // Invalid operator '|' must match previous operator ','",
          "318:         \"o-p47fail2\", // Illegal character '-' in Element-content model",
          "319:         \"o-p47fail3\", // Optional character must follow a name or list",
          "320:         \"o-p47fail4\", // Illegal space before optional character",
          "321:         \"o-p48fail1\", // Illegal space before optional character",
          "322:         \"o-p48fail2\", // Illegal space before optional character",
          "323:         \"o-p51fail1\", // occurrence on #PCDATA group must be *",
          "324:         \"o-p51fail2\", // occurrence on #PCDATA group must be *",
          "325:         \"o-p51fail3\", // #PCDATA must come first",
          "326:         \"o-p51fail4\", // occurrence on #PCDATA group must be *",
          "327:         \"o-p51fail5\", // only '|' connectors",
          "328:         \"o-p51fail6\", // Only '|' connectors and occurrence on #PCDATA group must be *",
          "329:         \"o-p51fail7\", // no nested groups",
          "330:         \"o-p52fail1\", // A name is required",
          "331:         \"o-p52fail2\", // A name is required",
          "332:         \"o-p53fail1\", // S is required before default",
          "333:         \"o-p53fail2\", // S is required before type",
          "334:         \"o-p53fail3\", // type is required",
          "335:         \"o-p53fail4\", // default is required",
          "336:         \"o-p53fail5\", // name is requried",
          "337:         \"o-p54fail1\", // don't pass unknown attribute types",
          "338:         \"o-p55fail1\", // must be upper case",
          "339:         \"o-p56fail1\", // no IDS type",
          "340:         \"o-p56fail2\", // no NUMBER type",
          "341:         \"o-p56fail3\", // no NAME type",
          "342:         \"o-p56fail4\", // no ENTITYS type - types must be upper case",
          "343:         \"o-p56fail5\", // types must be upper case",
          "344:         \"o-p57fail1\", // no keyword for NMTOKEN enumeration",
          "345:         \"o-p58fail1\", // at least one value required",
          "346:         \"o-p58fail2\", // separator must be '|'",
          "347:         \"o-p58fail3\", // notations are NAMEs, not NMTOKENs -- note:     Leaving the invalid           notation undeclared would cause a validating parser to fail without           checking the name syntax, so the notation is declared with an           invalid name.  A parser that reports error positions should report           an error at the AttlistDecl on line 6, before reaching the notation           declaration.",
          "348:         \"o-p58fail4\", // NOTATION must be upper case",
          "349:         \"o-p58fail5\", // S after keyword is required",
          "350:         \"o-p58fail6\", // parentheses are require",
          "351:         \"o-p58fail7\", // values are unquoted",
          "352:         \"o-p58fail8\", // values are unquoted",
          "353:         \"o-p59fail1\", // at least one required",
          "354:         \"o-p59fail2\", // separator must be \",\"",
          "355:         \"o-p59fail3\", // values are unquoted",
          "356:         \"o-p60fail1\", // keywords must be upper case",
          "357:         \"o-p60fail2\", // S is required after #FIXED",
          "358:         \"o-p60fail3\", // only #FIXED has both keyword and value",
          "359:         \"o-p60fail4\", // #FIXED required value",
          "360:         \"o-p60fail5\", // only one default type",
          "361:         \"o-p61fail1\", // no other types, including TEMP, which is valid in SGML",
          "362:         \"o-p62fail1\", // INCLUDE must be upper case",
          "363:         \"o-p62fail2\", // no spaces in terminating delimiter",
          "364:         \"o-p63fail1\", // IGNORE must be upper case",
          "365:         \"o-p63fail2\", // delimiters must be balanced",
          "366:         \"o-p64fail1\", // section delimiters must balance",
          "367:         \"o-p64fail2\", // section delimiters must balance",
          "368:         \"o-p66fail5\", // no references to non-characters",
          "369:         \"o-p68pass1\", // Valid entity references.  Also ensures that a charref to           '&' isn't interpreted as an entity reference open delimiter",
          "370:         \"o-p69fail1\", // terminating ';' is required",
          "371:         \"o-p69fail2\", // no S after '%'",
          "372:         \"o-p69fail3\", // no S before ';'",
          "373:         \"o-p70fail1\", // This is neither",
          "374:         \"o-p71fail1\", // S is required before EntityDef",
          "375:         \"o-p71fail2\", // Entity name is a Name, not an NMToken",
          "376:         \"o-p71fail4\", // S is required after \"<!ENTITY\"",
          "377:         \"o-p72fail1\", // S is required after \"<!ENTITY\"",
          "378:         \"o-p72fail2\", // S is required after '%'",
          "379:         \"o-p72fail3\", // S is required after name",
          "380:         \"o-p76fail4\", // p76fail4.xml       notation names are Names",
          "381:         \"o-p72fail4\", // Entity name is a name, not an NMToken",
          "382:         \"o-p73fail1\", // No typed replacement text",
          "383:         \"o-p73fail2\", // Only one replacement value",
          "384:         \"o-p73fail3\", // No NDataDecl on replacement text",
          "385:         \"o-p73fail4\", // Value is required",
          "386:         \"o-p73fail5\", // No NDataDecl without value",
          "387:         \"o-p74fail1\", // no NDataDecls on parameter entities",
          "388:         \"o-p74fail2\", // value is required",
          "389:         \"o-p74fail3\", // only one value",
          "390:         \"o-p75fail1\", // S required after \"PUBLIC\"",
          "391:         \"o-p75fail2\", // S required after \"SYSTEM\"",
          "392:         \"o-p75fail3\", // S required between literals",
          "393:         \"o-p75fail4\", // \"SYSTEM\" implies only one literal",
          "394:         \"o-p75fail5\", // only one keyword",
          "395:         \"o-p75fail6\", // \"PUBLIC\" requires two literals (contrast with SGML)",
          "396:         \"o-p76fail1\", // S is required before \"NDATA\"",
          "397:         \"o-p76fail2\", // \"NDATA\" is upper-case",
          "398:         \"o-p76fail3\", // notation name is required",
          "399:     ]);",
          "403:     run_suite(\"sun/sun-valid.xml\", &[",
          "404:         \"ext01\", // Tests use of external parsed entities with and without content.",
          "405:         \"ext02\", // Tests use of external parsed entities with different    encodings than the base document.",
          "406:         \"not-sa02\", // A non-standalone document is valid if declared as such.",
          "407:         \"not-sa03\", // A non-standalone document is valid if declared as such.",
          "408:         \"not-sa04\", // A non-standalone document is valid if declared as such.",
          "409:         \"sa02\", // A document may be marked 'standalone' if any     attributes that need normalization are  defined within the internal DTD subset.",
          "410:         \"sa03\", // A document may be marked 'standalone' if any     the defined entities need expanding are internal,     and no attributes need defaulting or normalization.     On output, requires notations to be correctly reported.",
          "411:         \"sa04\", // Like sa03 but relies on attribute     defaulting defined in the internal subset.     On output, requires notations to be correctly reported.",
          "412:         \"v-pe00\", // Tests construction of internal entity replacement text, using     an example in the XML specification.",
          "413:         \"v-pe03\", // Tests construction of internal entity replacement text, using     an example in the XML specification.",
          "414:         \"v-pe02\", // Tests construction of internal entity replacement text, using     a complex example in the XML specification.",
          "415:     ]);",
          "419:     run_suite(\"sun/sun-not-wf.xml\", &[",
          "420:         \"attlist01\", // SGML's NUTOKEN is not allowed.",
          "421:         \"attlist02\", // SGML's NUTOKENS attribute type is not allowed.",
          "422:         \"attlist03\", // Comma doesn't separate enumerations, unlike in SGML.",
          "423:         \"attlist04\", // SGML's NUMBER attribute type is not allowed.",
          "424:         \"attlist05\", // SGML's NUMBERS attribute type is not allowed.",
          "425:         \"attlist06\", // SGML's NAME attribute type is not allowed.",
          "426:         \"attlist07\", // SGML's NAMES attribute type is not allowed.",
          "427:         \"attlist08\", // SGML's #CURRENT is not allowed.",
          "428:         \"attlist09\", // SGML's #CONREF is not allowed.",
          "429:         \"attlist10\", // Whitespace required between attributes",
          "430:         \"attlist11\", // Whitespace required between attributes",
          "431:         \"cond01\", // Only INCLUDE and IGNORE are conditional section keywords",
          "432:         \"cond02\", // Must have keyword in conditional sections",
          "433:         \"content01\", // No whitespace before \"?\" in content model",
          "434:         \"content02\", // No whitespace before \"*\" in content model",
          "435:         \"content03\", // No whitespace before \"+\" in content model",
          "436:         \"decl01\", // External entities may not have standalone decls.",
          "437:         \"dtd02\", // PE name immediately after \"%\"",
          "438:         \"dtd03\", // PE name immediately followed by \";\"",
          "439:         \"dtd04\", // PUBLIC literal must be quoted",
          "440:         \"dtd05\", // SYSTEM identifier must be quoted",
          "441:         \"dtd07\", // Text declarations (which optionally begin any external entity)     are required to have \"encoding=...\".",
          "442:         \"encoding01\", // Illegal character \" \" in encoding name",
          "443:         \"encoding02\", // Illegal character \"/\" in encoding name",
          "444:         \"encoding03\", // Illegal character reference in encoding name",
          "445:         \"encoding04\", // Illegal character \":\" in encoding name",
          "446:         \"encoding05\", // Illegal character \"@\" in encoding name",
          "447:         \"encoding06\", // Illegal character \"+\" in encoding name",
          "448:         \"nwf-dtd00\", // Comma mandatory in content model",
          "449:         \"nwf-dtd01\", // Can't mix comma and vertical bar in content models",
          "450:         \"pi\", // pi.xml      No space between PI target name and data",
          "451:         \"pubid01\", // Illegal entity ref in public ID",
          "452:         \"pubid02\", // Illegal characters in public ID",
          "453:         \"pubid03\", // Illegal characters in public ID",
          "454:         \"pubid04\", // Illegal characters in public ID",
          "455:         \"pubid05\", // SGML-ism:  public ID without system ID",
          "456:         \"sgml02\", // XML declaration must be at the very beginning of a document;   it\"s not a processing instruction",
          "457:         \"sgml04\", // ATTLIST declarations apply to only one element, unlike SGML",
          "458:         \"sgml05\", // ELEMENT declarations apply to only one element, unlike SGML",
          "459:         \"sgml06\", // ATTLIST declarations are never global, unlike in SGML",
          "460:         \"sgml07\", // SGML Tag minimization specifications are not allowed",
          "461:         \"sgml08\", // SGML Tag minimization specifications are not allowed",
          "462:         \"sgml09\", // SGML Content model exception specifications are not allowed",
          "463:         \"sgml10\", // SGML Content model exception specifications are not allowed",
          "464:         \"sgml11\", // CDATA is not a valid content model spec",
          "465:         \"sgml12\", // RCDATA is not a valid content model spec",
          "466:         \"sgml13\", // SGML Unordered content models not allowed",
          "467:     ]);",
          "472:     run_suite(\"japanese/japanese.xml\", &[",
          "473:         \"pr-xml-little-endian.xml\"  // needs DTD",
          "474:     ]);",
          "478:     run_suite(\"xmltest/xmltest.xml\", &[",
          "479:         \"not-wf-sa-003\", // Processing Instruction target name is required.",
          "480:         \"not-wf-sa-025\", // Text may not contain a literal ']]>' sequence.",
          "481:         \"not-wf-sa-026\", // Text may not contain a literal ']]>' sequence.",
          "482:         \"not-wf-sa-029\", // Text may not contain a literal ']]>' sequence.",
          "483:         \"not-wf-sa-030\", // A form feed is not a legal XML character.",
          "484:         \"not-wf-sa-031\", // A form feed is not a legal XML character.",
          "485:         \"not-wf-sa-032\", // A form feed is not a legal XML character.",
          "486:         \"not-wf-sa-033\", // An ESC (octal 033) is not a legal XML character.",
          "487:         \"not-wf-sa-037\", // Character references may not appear after the root element.",
          "488:         \"not-wf-sa-040\", // Provides two document elements.",
          "489:         \"not-wf-sa-041\", // Provides two document elements.",
          "490:         \"not-wf-sa-044\", // Provides two document elements.",
          "491:         \"not-wf-sa-048\", // Provides a CDATA section after the root element.",
          "492:         \"not-wf-sa-051\", // CDATA is invalid at top level of document.",
          "493:         \"not-wf-sa-052\", // Invalid character reference.",
          "494:         \"not-wf-sa-054\", // PUBLIC requires two literals.",
          "495:         \"not-wf-sa-056\", // Invalid Document Type Definition format - misplaced comment.",
          "496:         \"not-wf-sa-057\", // This isn't SGML; comments can't exist in declarations.",
          "497:         \"not-wf-sa-058\", // Invalid character , in ATTLIST enumeration",
          "498:         \"not-wf-sa-059\", // String literal must be in quotes.",
          "499:         \"not-wf-sa-060\", // Invalid type NAME defined in ATTLIST.",
          "500:         \"not-wf-sa-061\", // External entity declarations require whitespace between public     and system IDs.",
          "501:         \"not-wf-sa-062\", // Entity declarations need space after the entity name.",
          "502:         \"not-wf-sa-064\", // Space is required between attribute type and default values     in <!ATTLIST...> declarations.",
          "503:         \"not-wf-sa-065\", // Space is required between attribute name and type     in <!ATTLIST...> declarations.",
          "504:         \"not-wf-sa-066\", // Required whitespace is missing.",
          "505:         \"not-wf-sa-067\", // Space is required between attribute type and default values     in <!ATTLIST...> declarations.",
          "506:         \"not-wf-sa-068\", // Space is required between NOTATION keyword and list of     enumerated choices in <!ATTLIST...> declarations.",
          "507:         \"not-wf-sa-069\", // Space is required before an NDATA entity annotation.",
          "508:         \"not-wf-sa-078\", // Undefined ENTITY foo.",
          "509:         \"not-wf-sa-079\", // ENTITY can't reference itself directly or indirectly.",
          "510:         \"not-wf-sa-080\", // ENTITY can't reference itself directly or indirectly.",
          "511:         \"not-wf-sa-082\", // This tests the No External Entity References WFC,     since the entity is referred to within an attribute.",
          "512:         \"not-wf-sa-084\", // Tests the Parsed Entity WFC by referring to an     unparsed entity.  (This precedes the error of not declaring     that entity's notation, which may be detected any time before     the DTD parsing is completed.)",
          "513:         \"not-wf-sa-085\", // Public IDs may not contain \"[\".",
          "514:         \"not-wf-sa-086\", // Public IDs may not contain \"[\".",
          "515:         \"not-wf-sa-087\", // Public IDs may not contain \"[\".",
          "516:         \"not-wf-sa-089\", // Parameter entities \"are\" always parsed; NDATA annotations     are not permitted.",
          "517:         \"not-wf-sa-091\", // Parameter entities \"are\" always parsed; NDATA annotations     are not permitted.",
          "518:         \"not-wf-sa-096\", // Space is required before the standalone declaration.",
          "519:         \"not-wf-sa-101\", // Space is not permitted in an encoding name.",
          "520:         \"not-wf-sa-105\", // Invalid placement of CDATA section.",
          "521:         \"not-wf-sa-106\", // Invalid placement of entity declaration.",
          "522:         \"not-wf-sa-113\", // Parameter entity values must use valid reference syntax;     this reference is malformed.",
          "523:         \"not-wf-sa-114\", // General entity values must use valid reference syntax;     this reference is malformed.",
          "524:         \"not-wf-sa-121\", // A name of an ENTITY was started with an invalid character.",
          "525:         \"not-wf-sa-122\", // Invalid syntax mixed connectors are used.",
          "526:         \"not-wf-sa-123\", // Invalid syntax mismatched parenthesis.",
          "527:         \"not-wf-sa-124\", // Invalid format of Mixed-content declaration.",
          "528:         \"not-wf-sa-125\", // Invalid syntax extra set of parenthesis not necessary.",
          "529:         \"not-wf-sa-126\", // Invalid syntax Mixed-content must be defined as zero or more.",
          "530:         \"not-wf-sa-127\", // Invalid syntax Mixed-content must be defined as zero or more.",
          "531:         \"not-wf-sa-128\", // Invalid CDATA syntax.",
          "532:         \"not-wf-sa-129\", // Invalid syntax for Element Type Declaration.",
          "533:         \"not-wf-sa-130\", // Invalid syntax for Element Type Declaration.",
          "534:         \"not-wf-sa-131\", // Invalid syntax for Element Type Declaration.",
          "535:         \"not-wf-sa-132\", // Invalid syntax mixed connectors used.",
          "536:         \"not-wf-sa-133\", // Illegal whitespace before optional character causes syntax error.",
          "537:         \"not-wf-sa-134\", // Illegal whitespace before optional character causes syntax error.",
          "538:         \"not-wf-sa-135\", // Invalid character used as connector.",
          "539:         \"not-wf-sa-136\", // Tag omission is invalid in XML.",
          "540:         \"not-wf-sa-137\", // Space is required before a content model.",
          "541:         \"not-wf-sa-138\", // Invalid syntax for content particle.",
          "542:         \"not-wf-sa-139\", // The element-content model should not be empty.",
          "543:         \"not-wf-sa-143\", // Character #x001F is not legal anywhere in an XML document.",
          "544:         \"not-wf-sa-144\", // Character #xFFFF is not legal anywhere in an XML document.",
          "545:         \"not-wf-sa-147\", // XML Declaration may not be preceded by whitespace.",
          "546:         \"not-wf-sa-148\", // XML Declaration may not be preceded by comments or whitespace.",
          "547:         \"not-wf-sa-149\", // XML Declaration may not be within a DTD.",
          "548:         \"not-wf-sa-154\", // '<?XML ...?>' is neither an XML declaration     nor a legal processing instruction target name.",
          "549:         \"not-wf-sa-155\", // '<?xmL ...?>' is neither an XML declaration     nor a legal processing instruction target name.",
          "550:         \"not-wf-sa-158\", // SGML-ism:  \"#NOTATION gif\" can't have attributes.",
          "551:         \"not-wf-sa-160\", // Violates the PEs in Internal Subset WFC     by using a PE reference within a declaration.",
          "552:         \"not-wf-sa-161\", // Violates the PEs in Internal Subset WFC     by using a PE reference within a declaration.",
          "553:         \"not-wf-sa-162\", // Violates the PEs in Internal Subset WFC     by using a PE reference within a declaration.",
          "554:         \"not-wf-sa-164\", // Invalid placement of Parameter entity reference.",
          "555:         \"not-wf-sa-165\", // Parameter entity declarations must have a space before     the '%'.",
          "556:         \"not-wf-sa-166\", // Character FFFF is not legal anywhere in an XML document.",
          "557:         \"not-wf-sa-167\", // Character FFFE is not legal anywhere in an XML document.",
          "558:         \"not-wf-sa-171\", // Character FFFF is not legal anywhere in an XML document.",
          "559:         \"not-wf-sa-172\", // Character FFFF is not legal anywhere in an XML document.",
          "560:         \"not-wf-sa-173\", // Character FFFF is not legal anywhere in an XML document.",
          "561:         \"not-wf-sa-174\", // Character FFFF is not legal anywhere in an XML document.",
          "562:         \"not-wf-sa-175\", // Character FFFF is not legal anywhere in an XML document.",
          "563:         \"not-wf-sa-177\", // Character FFFF is not legal anywhere in an XML document.",
          "564:         \"not-wf-sa-180\", // The Entity Declared WFC requires entities to be declared     before they are used in an attribute list declaration.",
          "565:         \"not-wf-sa-183\", // Mixed content declarations may not include content particles.",
          "566:         \"not-wf-sa-184\", // In mixed content models, element names must not be     parenthesized.",
          "567:         \"not-wf-sa-186\", // Whitespace is required between attribute/value pairs.",
          "568:         \"not-wf-not-sa-001\", // Conditional sections must be properly terminated (\"]>\" used     instead of \"]]>\").",
          "569:         \"not-wf-not-sa-002\", // Processing instruction target names may not be \"XML\"      in any combination of cases.",
          "570:         \"not-wf-not-sa-003\", // Conditional sections must be properly terminated (\"]]>\" omitted).",
          "571:         \"not-wf-not-sa-004\", // Conditional sections must be properly terminated (\"]]>\" omitted).",
          "572:         \"not-wf-not-sa-005\", // Tests the Entity Declared VC by referring to an     undefined parameter entity within an external entity.",
          "573:         \"not-wf-not-sa-006\", // Conditional sections need a '[' after the INCLUDE or IGNORE.",
          "574:         \"not-wf-not-sa-007\", // A <!DOCTYPE ...> declaration may not begin any external     entity; it's only found once, in the document entity.",
          "575:         \"not-wf-not-sa-008\", // In DTDs, the '%' character must be part of a parameter     entity reference.",
          "576:         \"not-wf-not-sa-009\", // This test violates WFC:PE Between Declarations in Production 28a.       The last character of a markup declaration is not contained in the same      parameter-entity text replacement.",
          "577:         \"valid-sa-012\", // Uses a legal XML 1.0 name consisting of a single colon     character (disallowed by the latest XML Namespaces draft).",
          "578:         \"valid-sa-023\", // Test demonstrates that Entity References are valid element content.",
          "579:         \"valid-sa-024\", // Test demonstrates that Entity References are valid element content and also demonstrates a valid Entity Declaration.",
          "580:         \"valid-sa-049\", // Test demonstrates that characters outside of normal ascii range can be used as element content.",
          "581:         \"valid-sa-050\", // Test demonstrates that characters outside of normal ascii range can be used as element content.",
          "582:         \"valid-sa-051\", // The document is encoded in UTF-16 and uses some name     characters well outside of the normal ASCII range.",
          "583:         \"valid-sa-053\", // Tests inclusion of a well-formed internal entity, which     holds an element required by the content model.",
          "584:         \"valid-sa-066\", // Expands a CDATA attribute with a character reference.",
          "585:         \"valid-sa-068\", // Tests definition of an internal entity holding a carriage return character     reference, which must not be normalized before reporting to the application.  Line      break normalization only occurs when parsing external parsed entities.",
          "586:         \"valid-sa-085\", // Parameter and General entities use different namespaces,     so there can be an entity of each type with a given name.",
          "587:         \"valid-sa-086\", // Tests whether entities may be declared more than once,     with the first declaration being the binding one.",
          "588:         \"valid-sa-087\", // Tests whether character references in internal entities are     expanded early enough, by relying on correct handling to     make the entity be well formed.",
          "589:         \"valid-sa-088\", // Tests whether entity references in internal entities are     expanded late enough, by relying on correct handling to     make the expanded text be valid.  (If it's expanded too     early, the entity will parse as an element that's not     valid in that context.)",
          "590:         \"valid-sa-089\", // Tests entity expansion of three legal character references,     which each expand to a Unicode surrogate pair.",
          "591:         \"valid-sa-108\", // This tests normalization of end-of-line characters (CRLF)     within entities to LF, primarily as an output test.",
          "592:         \"valid-sa-110\", // Basically an output test, this requires that a CDATA     attribute with a CRLF be normalized to one space.",
          "593:         \"valid-sa-114\", // Test demonstrates that all text within a valid CDATA section is considered text and not recognized as markup.",
          "594:         \"valid-sa-115\", // Test demonstrates that an entity reference is processed by recursively processing the replacement text of the entity.",
          "595:         \"valid-sa-117\", // Test demonstrates that entity expansion is done while processing entity declarations.",
          "596:         \"valid-sa-118\", // Test demonstrates that entity expansion is done while processing entity declarations.",
          "597:         \"valid-not-sa-031\", // Expands a general entity which contains a CDATA section with     what looks like a markup declaration (but is just text since     it's in a CDATA section).",
          "598:         \"valid-ext-sa-001\", // A combination of carriage return line feed in an external entity must     be normalized to a single newline.",
          "599:         \"valid-ext-sa-002\", // A carriage return (also CRLF) in an external entity must     be normalized to a single newline.",
          "600:         \"valid-ext-sa-003\", // Test demonstrates that the content of an element can be empty. In this case the external entity is an empty file.",
          "601:         \"valid-ext-sa-004\", // A carriage return (also CRLF) in an external entity must     be normalized to a single newline.",
          "602:         \"valid-ext-sa-005\", // Test demonstrates the use of optional character and content particles within an element content.  The test also show the use of external entity.",
          "603:         \"valid-ext-sa-006\", // Test demonstrates the use of optional character and content particles within mixed element content.  The test also shows the use of an external entity and that a carriage control line feed in an external entity must be normalized to a single newline.",
          "604:         \"valid-ext-sa-007\", // Test demonstrates the use of external entity and how replacement  text is retrieved and processed.",
          "605:         \"valid-ext-sa-008\", // Test demonstrates the use of external  entity and how replacement text is retrieved and processed.  Also tests the use of an  EncodingDecl of UTF-16.",
          "606:         \"valid-ext-sa-009\", // A carriage return (also CRLF) in an external entity must     be normalized to a single newline.",
          "607:         \"valid-ext-sa-011\", // Test demonstrates the use of a public identifier with and external entity.   The test also show that a carriage control line feed combination in an external  entity must be normalized to a single newline.",
          "608:         \"valid-ext-sa-012\", // Test demonstrates both internal and external entities and that processing of entity references may be required to produce the correct replacement text.",
          "609:         \"valid-ext-sa-013\", // Test demonstrates that whitespace is handled by adding a single whitespace to the normalized value in the attribute list.",
          "610:         \"valid-ext-sa-014\", // Test demonstrates use of characters outside of normal ASCII range.",
          "611:     ]);",
          "",
          "[Added Lines]",
          "120:     Err(format!(\"{} {msg}\\n\", xml_path.file_name().and_then(|f| f.to_str()).unwrap()))?",
          "124:     run_suite(\"eduni/errata-2e/errata2e.xml\");",
          "128:     run_suite(\"eduni/errata-3e/errata3e.xml\");",
          "132:     run_suite(\"eduni/errata-4e/errata4e.xml\");",
          "136:     run_suite(\"eduni/misc/ht-bh.xml\");",
          "140:     run_suite(\"eduni/namespaces/1.0/rmt-ns10.xml\");",
          "144:     run_suite(\"eduni/namespaces/1.1/rmt-ns11.xml\");",
          "148:     run_suite(\"eduni/namespaces/errata-1e/errata1e.xml\");",
          "152:     run_suite(\"eduni/xml-1.1/xml11.xml\");",
          "156:     run_suite(\"ibm/ibm_oasis_valid.xml\");",
          "160:     run_suite(\"ibm/xml-1.1/ibm_valid.xml\");",
          "164:     run_suite(\"oasis/oasis.xml\");",
          "168:     run_suite(\"sun/sun-valid.xml\");",
          "172:     run_suite(\"sun/sun-not-wf.xml\");",
          "177:     run_suite(\"japanese/japanese.xml\");",
          "181:     run_suite(\"xmltest/xmltest.xml\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bea0c88d9765a07b746e48284465e33cea9de20c",
      "candidate_info": {
        "commit_hash": "bea0c88d9765a07b746e48284465e33cea9de20c",
        "repo": "00xc/xml-rs",
        "commit_url": "https://github.com/00xc/xml-rs/commit/bea0c88d9765a07b746e48284465e33cea9de20c",
        "files": [
          "src/escape.rs",
          "src/name.rs",
          "src/reader/error.rs",
          "src/reader/lexer.rs",
          "src/reader/mod.rs",
          "src/reader/parser.rs",
          "src/reader/parser/inside_closing_tag_name.rs",
          "src/reader/parser/inside_declaration.rs",
          "src/reader/parser/inside_doctype.rs",
          "src/reader/parser/inside_opening_tag.rs",
          "src/reader/parser/inside_processing_instruction.rs",
          "src/reader/parser/inside_reference.rs",
          "src/reader/parser/outside_tag.rs",
          "tests/event_reader.rs"
        ],
        "message": "Refactored internal error type",
        "before_after_code_files": [
          "src/escape.rs||src/escape.rs",
          "src/name.rs||src/name.rs",
          "src/reader/error.rs||src/reader/error.rs",
          "src/reader/lexer.rs||src/reader/lexer.rs",
          "src/reader/mod.rs||src/reader/mod.rs",
          "src/reader/parser.rs||src/reader/parser.rs",
          "src/reader/parser/inside_closing_tag_name.rs||src/reader/parser/inside_closing_tag_name.rs",
          "src/reader/parser/inside_declaration.rs||src/reader/parser/inside_declaration.rs",
          "src/reader/parser/inside_doctype.rs||src/reader/parser/inside_doctype.rs",
          "src/reader/parser/inside_opening_tag.rs||src/reader/parser/inside_opening_tag.rs",
          "src/reader/parser/inside_processing_instruction.rs||src/reader/parser/inside_processing_instruction.rs",
          "src/reader/parser/inside_reference.rs||src/reader/parser/inside_reference.rs",
          "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs",
          "tests/event_reader.rs||tests/event_reader.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/reader/lexer.rs||src/reader/lexer.rs",
            "src/reader/parser/inside_doctype.rs||src/reader/parser/inside_doctype.rs",
            "src/reader/parser/inside_processing_instruction.rs||src/reader/parser/inside_processing_instruction.rs",
            "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs"
          ],
          "candidate": [
            "src/reader/lexer.rs||src/reader/lexer.rs",
            "src/reader/parser/inside_doctype.rs||src/reader/parser/inside_doctype.rs",
            "src/reader/parser/inside_processing_instruction.rs||src/reader/parser/inside_processing_instruction.rs",
            "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/escape.rs||src/escape.rs": [
          "File: src/escape.rs -> src/escape.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "119: #[inline]",
          "121:     escape_str::<AttributeEscapes>(s)",
          "122: }",
          "",
          "[Removed Lines]",
          "120: pub fn escape_str_attribute(s: &str) -> Cow<'_, str> {",
          "",
          "[Added Lines]",
          "120: #[must_use] pub fn escape_str_attribute(s: &str) -> Cow<'_, str> {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "135: #[inline]",
          "137:     escape_str::<PcDataEscapes>(s)",
          "138: }",
          "",
          "[Removed Lines]",
          "136: pub fn escape_str_pcdata(s: &str) -> Cow<'_, str> {",
          "",
          "[Added Lines]",
          "136: #[must_use] pub fn escape_str_pcdata(s: &str) -> Cow<'_, str> {",
          "",
          "---------------"
        ],
        "src/name.rs||src/name.rs": [
          "File: src/name.rs -> src/name.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "180: pub struct OwnedName {",
          "182:     pub local_name: String,",
          "",
          "[Removed Lines]",
          "179: #[derive(Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]",
          "",
          "[Added Lines]",
          "179: #[derive(Clone, PartialEq, Eq, Hash, Debug)]",
          "",
          "---------------"
        ],
        "src/reader/error.rs||src/reader/error.rs": [
          "File: src/reader/error.rs -> src/reader/error.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use std::borrow::Cow;",
          "2: use std::error;",
          "3: use std::error::Error as _;",
          "4: use std::fmt;",
          "5: use std::io;",
          "6: use std::str;",
          "9: use crate::common::{Position, TextPosition};",
          "10: use crate::util;",
          "12: #[derive(Debug)]",
          "13: pub enum ErrorKind {",
          "15:     Io(io::Error),",
          "16:     Utf8(str::Utf8Error),",
          "17:     UnexpectedEof,",
          "18: }",
          "35:     NoRootElement,",
          "36:     UnbalancedRootElement,",
          "39:     UnexpectedOpeningTag,",
          "45:     UnexpectedTokenOutsideRoot(Token),",
          "46:     UnexpectedToken(Token),",
          "47:     UnexpectedTokenInEntity(Token),",
          "48:     UnexpectedTokenInClosingTag(Token),",
          "49:     UnexpectedTokenInOpeningTag(Token),",
          "74: }",
          "76: impl fmt::Display for SyntaxError {",
          "77:     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
          "121:         }",
          "122:     }",
          "123: }",
          "",
          "[Removed Lines]",
          "7: use std::error;",
          "14:     Syntax(SyntaxError),",
          "20: impl fmt::Display for ErrorKind {",
          "21:     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
          "22:         use self::ErrorKind::*;",
          "23:         match self {",
          "24:             Syntax(err) => write!(f, \"Syntax error: {}\", err),",
          "25:             Io(err) => write!(f, \"IO error: {}\", err),",
          "26:             Utf8(err) => write!(f, \"Utf8 encoding error: {}\", err),",
          "27:             UnexpectedEof => write!(f, \"Unexpected EOF\"),",
          "28:         }",
          "29:     }",
          "30: }",
          "32: #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]",
          "33: pub enum SyntaxError {",
          "34:     UnexpectedEof,",
          "37:     InvalidQualifiedName(String),",
          "38:     UnexpectedQualifiedName(Token),",
          "40:     MissingNamespace(OwnedName),",
          "41:     UnboundAttribute(OwnedName),",
          "42:     UnboundPrefix(OwnedName),",
          "43:     UnexpectedClosingTag(OwnedName, OwnedName),",
          "44:     UnexpectedTokenBefore(&'static str, char),",
          "50:     UnexpectedName(OwnedName),",
          "51:     ProcessingInstructionWithoutName,",
          "54:     InvalidXmlProcessingInstruction(String),",
          "55:     InvalidProcessingInstruction(String),",
          "56:     UnexpectedProcessingInstruction(String, Token),",
          "57:     InvalidNamePrefix(Option<String>),",
          "58:     RedefinedAttribute(OwnedName),",
          "59:     CannotUndefinePrefix(String),",
          "60:     CannotRedefineXmlnsPrefix,",
          "61:     CannotRedefineXmlPrefix,",
          "62:     UnexpectedTokenInsideXml(Token),",
          "63:     UnexpectedNameInsideXml(OwnedName),",
          "64:     UnexpectedXmlVersion(Option<XmlVersion>),",
          "65:     InvalidStandaloneDeclaration(String),",
          "66:     EmptyEntity,",
          "67:     NullCharacterEntity,",
          "68:     InvalidHexCharacterEntity(String),",
          "69:     InvalidDecCharacterEntity(String),",
          "70:     UnexpectedEntity(String),",
          "71:     InvalidDefaultNamespace(String),",
          "73:     DoubleDashInComment,",
          "78:         use self::SyntaxError::*;",
          "79:         match self {",
          "80:             UnexpectedEof => write!(f, \"Unexpected end of stream\"),",
          "81:             NoRootElement => write!(f, \"Unexpected end of stream: no root element found\"),",
          "82:             UnbalancedRootElement => write!(f, \"Unexpected end of stream: still inside the root element\"),",
          "83:             InvalidQualifiedName(e) => write!(f, \"Qualified name is invalid: {}\", e),",
          "84:             UnexpectedQualifiedName(e) => write!(f, \"Unexpected token inside qualified name: {}\", e),",
          "85:             UnexpectedOpeningTag => write!(f, \"Unexpected token inside attribute value: <\"),",
          "86:             MissingNamespace(name) => write!(f, \"Element {} prefix is unbound\", name),",
          "87:             UnboundAttribute(name) => write!(f, \"Attribute {} prefix is unbound\", name),",
          "88:             UnboundPrefix(name) => write!(f, \"Element {} prefix is unbound\", name),",
          "89:             UnexpectedClosingTag(expected_name, got_name) => write!(f, \"Unexpected closing tag: {}, expected {}\", expected_name, got_name),",
          "90:             UnexpectedToken(token) => write!(f, \"Unexpected token: {}\", token),",
          "91:             UnexpectedTokenBefore(before, c) => write!(f, \"Unexpected token '{}' before '{}'\", before, c),",
          "92:             UnexpectedTokenOutsideRoot(token) => write!(f, \"Unexpected characters outside the root element: {}\", token),",
          "93:             UnexpectedTokenInOpeningTag(token) => write!(f, \"Unexpected token inside opening tag: {}\", token),",
          "94:             UnexpectedTokenInClosingTag(token) => write!(f, \"Unexpected token inside closing tag: {}\", token),",
          "95:             UnexpectedTokenInEntity(token) => write!(f, \"Unexpected token inside entity: {}\", token),",
          "96:             UnexpectedName(name) => write!(f, \"Unexpected name: {}\", name),",
          "97:             ProcessingInstructionWithoutName => write!(f, \"Encountered processing instruction without name\"),",
          "98:             InvalidXmlProcessingInstruction(name) => write!(f,",
          "99:                 \"Invalid processing instruction: <?{} - \\\"<?xml\\\"-like PI is \\",
          "100:                  only valid at the beginning of the document\", name),",
          "101:             InvalidProcessingInstruction(name) => write!(f, \"Invalid processing instruction: <?{}\", name),",
          "102:             UnexpectedProcessingInstruction(buf, token) => write!(f, \"Unexpected token inside processing instruction: <?{}{}\", buf, token),",
          "103:             InvalidNamePrefix(Some(prefix)) => write!(f, \"'{}' cannot be an element name prefix\", prefix),",
          "104:             InvalidNamePrefix(None) => write!(f, \"Empty element name prefix\"),",
          "105:             RedefinedAttribute(name) => write!(f, \"Attribute '{}' is redefined\", name),",
          "106:             CannotUndefinePrefix(ln) => write!(f, \"Cannot undefine prefix '{}'\", ln),",
          "107:             CannotRedefineXmlnsPrefix => write!(f, \"Cannot redefine XMLNS prefix '{}'\", NS_XMLNS_PREFIX),",
          "108:             CannotRedefineXmlPrefix => write!(f, \"Prefix '{}' cannot be rebound to another value\", NS_XML_PREFIX),",
          "109:             UnexpectedTokenInsideXml(token) => write!(f, \"Unexpected token inside XML declaration: {}\", token),",
          "110:             UnexpectedNameInsideXml(name) => write!(f, \"Unexpected name inside XML declaration: {}\", name),",
          "111:             UnexpectedXmlVersion(Some(version)) => write!(f, \"Invalid XML version: {}\", version),",
          "112:             UnexpectedXmlVersion(None) => write!(f, \"No XML version specified\"),",
          "113:             InvalidStandaloneDeclaration(value) => write!(f, \"Invalid standalone declaration value: {}\", value),",
          "114:             EmptyEntity => write!(f, \"Encountered empty entity\"),",
          "115:             NullCharacterEntity => write!(f, \"Null character entity is not allowed\"),",
          "116:             InvalidHexCharacterEntity(name) => write!(f, \"Invalid hexadecimal character number in an entity: {}\", name),",
          "117:             InvalidDecCharacterEntity(name) => write!(f, \"Invalid decimal character number in an entity: {}\", name),",
          "118:             UnexpectedEntity(name) => write!(f, \"Unexpected entity: {}\", name),",
          "119:             InvalidDefaultNamespace(name) => write!(f,  \"Namespace '{}' cannot be default\", name),",
          "120:             DoubleDashInComment => write!(f, \"Unexpected double dash inside a comment: \\\"--\\\"\"),",
          "",
          "[Added Lines]",
          "1: use crate::Encoding;",
          "2: use crate::reader::lexer::Token;",
          "16:     Syntax(Cow<'static, str>),",
          "22: #[derive(Debug, Clone, PartialEq)]",
          "23: pub(crate) enum SyntaxError {",
          "24:     CannotRedefineXmlnsPrefix,",
          "25:     CannotRedefineXmlPrefix,",
          "27:     DoubleDashInComment,",
          "29:     EntityTooBig,",
          "31:     EmptyEntity,",
          "33:     ProcessingInstructionWithoutName,",
          "35:     UnexpectedEof,",
          "38:     UnclosedCdata,",
          "39:     UnexpectedCdataEnd,",
          "40:     UnexpectedQualifiedName(Token),",
          "46:     UnexpectedTokenInsideXml(Token),",
          "47:     InvalidQualifiedName(Box<str>),",
          "48:     MissingNamespace(Box<str>),",
          "49:     UnboundAttribute(Box<str>),",
          "50:     UnboundPrefix(Box<str>),",
          "51:     UnexpectedClosingTag(Box<str>),",
          "52:     UnexpectedName(Box<str>),",
          "53:     UnexpectedProcessingInstruction(Box<str>, Token),",
          "56:     CannotUndefinePrefix(Box<str>),",
          "57:     InvalidCharacterEntity(u32),",
          "58:     InvalidDefaultNamespace(Box<str>),",
          "59:     InvalidNamePrefix(Box<str>),",
          "60:     InvalidNumericEntity(Box<str>),",
          "61:     InvalidProcessingInstruction(Box<str>),",
          "62:     InvalidStandaloneDeclaration(Box<str>),",
          "63:     InvalidXmlProcessingInstruction(Box<str>),",
          "64:     RedefinedAttribute(Box<str>),",
          "65:     UndefinedEntity(Box<str>),",
          "66:     UndefinedPEntity(Box<str>),",
          "67:     UnexpectedEntity(Box<str>),",
          "68:     UnexpectedNameInsideXml(Box<str>),",
          "69:     UnsupportedEncoding(Box<str>),",
          "71:     UnknownMarkupDeclaration(Box<str>),",
          "72:     UnexpectedXmlVersion(Box<str>),",
          "73:     ConflictingEncoding(Encoding, Encoding),",
          "74:     UnexpectedTokenBefore(&'static str, char),",
          "79:         self.to_cow().fmt(f)",
          "80:     }",
          "81: }",
          "83: impl SyntaxError {",
          "84:     #[inline(never)]",
          "85:     #[cold]",
          "86:     pub(crate) fn to_cow(&self) -> Cow<'static, str> {",
          "87:         match *self {",
          "88:             Self::CannotRedefineXmlnsPrefix => \"Cannot redefine XMLNS prefix\".into(),",
          "89:             Self::CannotRedefineXmlPrefix => \"Default XMLNS prefix cannot be rebound to another value\".into(),",
          "90:             Self::DoubleDashInComment => \"Unexpected double dash inside a comment: \\\"--\\\"\".into(),",
          "91:             Self::EmptyEntity => \"Encountered empty entity\".into(),",
          "92:             Self::EntityTooBig => \"Entity too big\".into(),",
          "93:             Self::NoRootElement => \"Unexpected end of stream: no root element found\".into(),",
          "94:             Self::ProcessingInstructionWithoutName => \"Encountered processing instruction without name\".into(),",
          "95:             Self::UnbalancedRootElement => \"Unexpected end of stream: still inside the root element\".into(),",
          "96:             Self::UnclosedCdata => \"Unclosed <![CDATA[\".into(),",
          "97:             Self::UnexpectedCdataEnd => \"]]> in text\".into(),",
          "98:             Self::UnexpectedEof => \"Unexpected end of stream\".into(),",
          "99:             Self::UnexpectedOpeningTag => \"'<' is not allowed in attributes\".into(),",
          "100:             Self::CannotUndefinePrefix(ref ln) => format!(\"Cannot undefine prefix '{ln}'\").into(),",
          "101:             Self::ConflictingEncoding(a, b) => format!(\"Declared encoding {a}, but uses {b}\").into(),",
          "102:             Self::InvalidCharacterEntity(num) => format!(\"Invalid character U+{num:04X}\").into(),",
          "103:             Self::InvalidDefaultNamespace(ref name) => format!( \"Namespace '{name}' cannot be default\").into(),",
          "104:             Self::InvalidNamePrefix(ref prefix) => format!(\"'{prefix}' cannot be an element name prefix\").into(),",
          "105:             Self::InvalidNumericEntity(ref v) => format!(\"Invalid numeric entity: {v}\").into(),",
          "106:             Self::InvalidProcessingInstruction(ref name) => format!(\"Invalid processing instruction: <?{name}\").into(),",
          "107:             Self::InvalidQualifiedName(ref e) => format!(\"Qualified name is invalid: {e}\").into(),",
          "108:             Self::InvalidStandaloneDeclaration(ref value) => format!(\"Invalid standalone declaration value: {value}\").into(),",
          "109:             Self::InvalidXmlProcessingInstruction(ref name) => format!(\"Invalid processing instruction: <?{name} - \\\"<?xml\\\"-like PI is only valid at the beginning of the document\").into(),",
          "110:             Self::MissingNamespace(ref name) => format!(\"Element {name} prefix is unbound\").into(),",
          "111:             Self::RedefinedAttribute(ref name) => format!(\"Attribute '{name}' is redefined\").into(),",
          "112:             Self::UnboundAttribute(ref name) => format!(\"Attribute {name} prefix is unbound\").into(),",
          "113:             Self::UnboundPrefix(ref name) => format!(\"Element {name} prefix is unbound\").into(),",
          "114:             Self::UndefinedEntity(ref v) => format!(\"Undefined entity: {v}\").into(),",
          "115:             Self::UndefinedPEntity(ref v) => format!(\"Undefined p entity: {v}\").into(),",
          "116:             Self::UnexpectedClosingTag(ref expected_got) => format!(\"Unexpected closing tag: {expected_got}\").into(),",
          "117:             Self::UnexpectedEntity(ref name) => format!(\"Unexpected entity: {name}\").into(),",
          "118:             Self::UnexpectedName(ref name) => format!(\"Unexpected name: {name}\").into(),",
          "119:             Self::UnexpectedNameInsideXml(ref name) => format!(\"Unexpected name inside XML declaration: {name}\").into(),",
          "120:             Self::UnexpectedProcessingInstruction(ref buf, token) => format!(\"Unexpected token inside processing instruction: <?{buf}{token}\").into(),",
          "121:             Self::UnexpectedQualifiedName(e) => format!(\"Unexpected token inside qualified name: {e}\").into(),",
          "122:             Self::UnexpectedToken(token) => format!(\"Unexpected token: {token}\").into(),",
          "123:             Self::UnexpectedTokenBefore(before, c) => format!(\"Unexpected token '{before}' before '{c}'\").into(),",
          "124:             Self::UnexpectedTokenInClosingTag(token) => format!(\"Unexpected token inside closing tag: {token}\").into(),",
          "125:             Self::UnexpectedTokenInEntity(token) => format!(\"Unexpected token inside entity: {token}\").into(),",
          "126:             Self::UnexpectedTokenInOpeningTag(token) => format!(\"Unexpected token inside opening tag: {token}\").into(),",
          "127:             Self::UnexpectedTokenInsideXml(token) => format!(\"Unexpected token inside XML declaration: {token}\").into(),",
          "128:             Self::UnexpectedTokenOutsideRoot(token) => format!(\"Unexpected characters outside the root element: {token}\").into(),",
          "129:             Self::UnexpectedXmlVersion(ref version) => format!(\"Invalid XML version: {version}\").into(),",
          "130:             Self::UnknownMarkupDeclaration(ref v) => format!(\"Unknown markup declaration: {v}\").into(),",
          "131:             Self::UnsupportedEncoding(ref v) => format!(\"Unsupported encoding: {v}\").into(),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "128: #[derive(Clone, PartialEq, Eq, Debug)]",
          "129: pub struct Error {",
          "132: }",
          "134: impl fmt::Display for Error {",
          "",
          "[Removed Lines]",
          "130:     pub pos: TextPosition,",
          "131:     pub kind: ErrorKind,",
          "",
          "[Added Lines]",
          "141:     pub(crate) pos: TextPosition,",
          "142:     pub(crate) kind: ErrorKind,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "155:     #[cold]",
          "156:     #[doc(hidden)]",
          "157:     #[allow(deprecated)]",
          "159:         use self::ErrorKind::{Io, Syntax, UnexpectedEof, Utf8};",
          "160:         match &self.kind {",
          "161:             Io(io_error) => io_error.description(),",
          "",
          "[Removed Lines]",
          "158:     pub fn msg(&self) -> &str {",
          "",
          "[Added Lines]",
          "169:     #[must_use] pub fn msg(&self) -> &str {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "203:     }",
          "204: }",
          "213: impl From<io::Error> for Error {",
          "214:     #[cold]",
          "215:     fn from(e: io::Error) -> Self {",
          "216:         Error {",
          "217:             pos: TextPosition::new(),",
          "219:         }",
          "220:     }",
          "221: }",
          "",
          "[Removed Lines]",
          "206: impl error::Error for Error { }",
          "208: impl Error {",
          "209:     #[inline]",
          "210:     fn kind(&self) -> &ErrorKind { &self.kind }",
          "211: }",
          "218:             kind: ErrorKind::Io(e)",
          "",
          "[Added Lines]",
          "222:             kind: ErrorKind::Io(e),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "251:     }",
          "252: }",
          "253: impl Eq for ErrorKind {}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "258: #[test]",
          "259: fn err_size() {",
          "260:     assert_eq!(24, std::mem::size_of::<SyntaxError>());",
          "261: }",
          "",
          "---------------"
        ],
        "src/reader/lexer.rs||src/reader/lexer.rs": [
          "File: src/reader/lexer.rs -> src/reader/lexer.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: use std::collections::VecDeque;",
          "7: use std::fmt;",
          "8: use std::io::Read;",
          "9: use std::result;",
          "11: use crate::common::{is_name_char, is_whitespace_char, Position, TextPosition};",
          "12: use crate::reader::Error;",
          "13: use crate::util::{CharReader, Encoding};",
          "",
          "[Removed Lines]",
          "5: use std::borrow::Cow;",
          "",
          "[Added Lines]",
          "6: use crate::reader::ErrorKind;",
          "7: use crate::reader::error::SyntaxError;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "313:         self.reparse_depth = 0;",
          "314:         loop {",
          "315:             let c = match self.reader.next_char_from(b)? {",
          "318:                 },",
          "319:                 Some(c) => c,  // got next char",
          "320:                 None => break, // nothing to read left",
          "",
          "[Removed Lines]",
          "316:                 Some('\\0' ..= '\\x08' | '\\x0B'..= '\\x0C' | '\\x0E'..= '\\x1F'| '\\u{7F}'..='\\u{84}' | '\\u{86}'..='\\u{9F}' | '\\u{fffe}'..='\\u{ffff}') => {",
          "317:                     return Err(self.error(\"Invalid char\"))",
          "",
          "[Added Lines]",
          "317:                 Some(c @ ('\\0' ..= '\\x08' | '\\x0B'..= '\\x0C' | '\\x0E'..= '\\x1F'| '\\u{7F}'..='\\u{84}' | '\\u{86}'..='\\u{9F}' | '\\u{fffe}'..='\\u{ffff}')) => {",
          "318:                     return Err(self.error(SyntaxError::InvalidCharacterEntity(c as u32)))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "346:         self.eof_handled = true;",
          "347:         self.pos = self.head_pos;",
          "348:         match self.st {",
          "351:             State::TagStarted | State::CommentOrCDataOrDoctypeStarted |",
          "352:             State::CommentStarted | State::CDataStarted(_)| State::DoctypeStarted(_) |",
          "353:             State::CommentClosing(ClosingSubstate::Second) |",
          "354:             State::InsideComment | State::InsideMarkupDeclaration |",
          "355:             State::InsideProcessingInstruction | State::ProcessingInstructionClosing |",
          "356:             State::InsideDoctype | State::InsideMarkupDeclarationQuotedString(_) =>",
          "358:             State::EmptyTagClosing =>",
          "359:                 Ok(Some(Token::Character('/'))),",
          "360:             State::CommentClosing(ClosingSubstate::First) =>",
          "",
          "[Removed Lines]",
          "349:             State::InsideCdata | State::CDataClosing(_) => Err(self.error(\"Unclosed CDATA\")),",
          "357:                 Err(self.error(\"Unexpected end of stream\")),",
          "",
          "[Added Lines]",
          "350:             State::InsideCdata | State::CDataClosing(_) => Err(self.error(SyntaxError::UnclosedCdata)),",
          "357:                 Err(self.error(SyntaxError::UnexpectedEof)),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "370:         }",
          "371:     }",
          "376:     }",
          "",
          "[Removed Lines]",
          "373:     #[inline]",
          "374:     fn error<M: Into<SyntaxError>>(&self, msg: M) -> Error {",
          "375:         (self, msg).into()",
          "",
          "[Added Lines]",
          "373:     #[cold]",
          "374:     fn error(&self, e: SyntaxError) -> Error {",
          "375:         Error {",
          "376:             pos: self.position(),",
          "377:             kind: ErrorKind::Syntax(e.to_cow()),",
          "378:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "433:         self.reparse_depth += 1;",
          "434:         if self.reparse_depth > MAX_ENTITY_EXPANSION_DEPTH || self.char_queue.len() > MAX_ENTITY_EXPANSION_LENGTH {",
          "436:         }",
          "438:         self.eof_handled = false;",
          "",
          "[Removed Lines]",
          "435:             return Err(self.error(\"Entity too big\".to_string()))",
          "",
          "[Added Lines]",
          "438:             return Err(self.error(SyntaxError::EntityTooBig))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "444:         Ok(())",
          "445:     }",
          "448:         debug_assert!(!chunk.is_empty());",
          "450:         if self.skip_errors {",
          "",
          "[Removed Lines]",
          "447:     fn handle_error(&mut self, chunk: &str, c: char) -> Result {",
          "",
          "[Added Lines]",
          "450:     fn handle_error(&mut self, chunk: &'static str, c: char) -> Result {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "454:             self.char_queue.push_back(c);",
          "455:             return self.move_to_with(State::Normal, Token::Character(first));",
          "456:         }",
          "458:     }",
          "",
          "[Removed Lines]",
          "457:         Err(self.error(format!(\"Unexpected token '{chunk}' before '{c}'\")))",
          "",
          "[Added Lines]",
          "460:         Err(self.error(SyntaxError::UnexpectedTokenBefore(chunk, c)))",
          "",
          "---------------"
        ],
        "src/reader/mod.rs||src/reader/mod.rs": [
          "File: src/reader/mod.rs -> src/reader/mod.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: mod parser;",
          "23: mod error;",
          "27: pub type Result<T, E = Error> = result::Result<T, E>;",
          "",
          "[Removed Lines]",
          "24: pub use self::error::{Error, SyntaxError, ErrorKind};",
          "",
          "[Added Lines]",
          "24: pub use self::error::{Error, ErrorKind};",
          "",
          "---------------"
        ],
        "src/reader/parser.rs||src/reader/parser.rs": [
          "File: src/reader/parser.rs -> src/reader/parser.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: use std::collections::HashMap;",
          "5: use std::io::prelude::*;",
          "",
          "[Removed Lines]",
          "3: use std::borrow::Cow;",
          "",
          "[Added Lines]",
          "4: use crate::reader::error::SyntaxError;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "13: use crate::reader::events::XmlEvent;",
          "14: use crate::reader::lexer::{Lexer, Token};",
          "16: macro_rules! gen_takes(",
          "17:     ($($field:ident -> $method:ident, $t:ty, $def:expr);+) => (",
          "18:         $(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: use super::{Error, ErrorKind};",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "41:     attributes   -> take_attributes, Vec<OwnedAttribute>, vec!()",
          "42: );",
          "49: mod inside_cdata;",
          "50: mod inside_closing_tag_name;",
          "51: mod inside_comment;",
          "",
          "[Removed Lines]",
          "44: macro_rules! self_error(",
          "45:     ($this:ident; $msg:expr) => ($this.error($msg));",
          "46:     ($this:ident; $fmt:expr, $($arg:expr),+) => ($this.error(format!($fmt, $($arg),+)))",
          "47: );",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "356:             if self.encountered == Encountered::Element && self.st == State::OutsideTag {  // all is ok",
          "357:                 Ok(XmlEvent::EndDocument)",
          "358:             } else if self.encountered < Encountered::Element {",
          "360:             } else {  // self.st != State::OutsideTag",
          "362:             }",
          "363:         } else if self.config.c.ignore_end_of_stream {",
          "364:             self.final_result = None;",
          "365:             self.lexer.reset_eof_handled();",
          "367:         } else {",
          "369:         };",
          "370:         self.set_final_result(ev)",
          "371:     }",
          "",
          "[Removed Lines]",
          "359:                 self_error!(self; \"Unexpected end of stream: no root element found\")",
          "361:                 self_error!(self; SyntaxError::UnexpectedEof)  // TODO: add expected hint?",
          "366:             return self_error!(self; \"Unexpected end of stream: still inside the root element\");",
          "368:             self_error!(self; \"Unexpected end of stream: still inside the root element\")",
          "",
          "[Added Lines]",
          "357:                 self.error(SyntaxError::NoRootElement)",
          "359:                 self.error(SyntaxError::UnexpectedEof)  // TODO: add expected hint?",
          "364:             return self.error(SyntaxError::UnbalancedRootElement);",
          "366:             self.error(SyntaxError::UnbalancedRootElement)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "379:     }",
          "381:     #[cold]",
          "384:     }",
          "386:     #[inline]",
          "",
          "[Removed Lines]",
          "382:     fn error<M: Into<Cow<'static, str>>>(&self, msg: M) -> Result {",
          "383:         Err((&self.lexer, msg).into())",
          "",
          "[Added Lines]",
          "380:     fn error(&self, e: SyntaxError) -> Result {",
          "381:         Err(Error {",
          "382:             pos: self.lexer.position(),",
          "383:             kind: ErrorKind::Syntax(e.to_cow()),",
          "384:         })",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "467:             let name = this.take_buf();",
          "468:             match name.parse() {",
          "469:                 Ok(name) => on_name(this, t, name),",
          "471:             }",
          "472:         };",
          "",
          "[Removed Lines]",
          "470:                 Err(_) => Some(self_error!(this; \"Qualified name is invalid: {}\", name)),",
          "",
          "[Added Lines]",
          "471:                 Err(_) => Some(this.error(SyntaxError::InvalidQualifiedName(name.into())))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "493:             Token::Character(c) if is_whitespace_char(c) => invoke_callback(self, t),",
          "496:         }",
          "497:     }",
          "",
          "[Removed Lines]",
          "495:             _ => Some(self_error!(self; SyntaxError::UnexpectedQualifiedName(t)))",
          "",
          "[Added Lines]",
          "496:             _ => Some(self.error(SyntaxError::UnexpectedQualifiedName(t)))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "528:             },",
          "530:             Token::OpeningTagStart =>",
          "534:             _ if self.data.quote.is_some() => {",
          "",
          "[Removed Lines]",
          "531:                 Some(self_error!(self; \"Unexpected token inside attribute value: {}\", t)),",
          "",
          "[Added Lines]",
          "532:                 Some(self.error(SyntaxError::UnexpectedOpeningTag)),",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "536:                 None",
          "537:             }",
          "540:         }",
          "541:     }",
          "",
          "[Removed Lines]",
          "539:             _ => Some(self_error!(self; \"Unexpected token inside attribute value: {}\", t)),",
          "",
          "[Added Lines]",
          "540:             _ => Some(self.error(SyntaxError::UnexpectedToken(t))),",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "548:         match self.nst.get(name.borrow().prefix_repr()) {",
          "549:             Some(\"\") => name.namespace = None,  // default namespace",
          "550:             Some(ns) => name.namespace = Some(ns.into()),",
          "552:         }",
          "",
          "[Removed Lines]",
          "551:             None => return Some(self_error!(self; SyntaxError::MissingNamespace(name)))",
          "",
          "[Added Lines]",
          "552:             None => return Some(self.error(SyntaxError::MissingNamespace(name.to_string().into())))",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "557:                 let new_ns = match self.nst.get(pfx) {",
          "558:                     Some(\"\") => None, // default namespace",
          "559:                     Some(ns) => Some(ns.into()),",
          "561:                 };",
          "562:                 attr.name.namespace = new_ns;",
          "563:             }",
          "",
          "[Removed Lines]",
          "560:                     None => return Some(self_error!(self; SyntaxError::UnboundAttribute(attr.name.clone())))",
          "",
          "[Added Lines]",
          "561:                     None => return Some(self.error(SyntaxError::UnboundAttribute(attr.name.to_string().into())))",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "586:         match self.nst.get(name.borrow().prefix_repr()) {",
          "587:             Some(\"\") => name.namespace = None, // default namespace",
          "588:             Some(ns) => name.namespace = Some(ns.into()),",
          "590:         }",
          "592:         let op_name = self.est.pop()?;",
          "",
          "[Removed Lines]",
          "589:             None => return Some(self_error!(self; \"Element {} prefix is unbound\", name)),",
          "",
          "[Added Lines]",
          "590:             None => return Some(self.error(SyntaxError::UnboundPrefix(name.to_string().into())))",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "595:             self.pop_namespace = true;",
          "596:             self.into_state_emit(State::OutsideTag, Ok(XmlEvent::EndElement { name }))",
          "597:         } else {",
          "599:         }",
          "600:     }",
          "601: }",
          "",
          "[Removed Lines]",
          "598:             Some(self_error!(self; SyntaxError::UnexpectedClosingTag(name, op_name)))",
          "",
          "[Added Lines]",
          "599:             Some(self.error(SyntaxError::UnexpectedClosingTag(format!(\"{name} != {op_name}\").into())))",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "603: #[cfg(test)]",
          "604: mod tests {",
          "605:     use std::io::BufReader;",
          "607:     use crate::attribute::OwnedAttribute;",
          "609:     use crate::name::OwnedName;",
          "610:     use crate::reader::events::XmlEvent;",
          "611:     use crate::reader::parser::PullParser;",
          "",
          "[Removed Lines]",
          "608:     use crate::common::{Position, TextPosition};",
          "",
          "[Added Lines]",
          "608:     use crate::common::TextPosition;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "619:         ($r:expr, $p:expr, $t:pat) => (",
          "620:             match $p.next(&mut $r) {",
          "621:                 $t => {}",
          "623:             }",
          "624:         );",
          "625:         ($r:expr, $p:expr, $t:pat => $c:expr ) => (",
          "626:             match $p.next(&mut $r) {",
          "627:                 $t if $c => {}",
          "629:             }",
          "630:         )",
          "631:     );",
          "",
          "[Removed Lines]",
          "622:                 e => panic!(\"Unexpected event: {:?}\", e)",
          "628:                 e => panic!(\"Unexpected event: {:?}\", e)",
          "",
          "[Added Lines]",
          "622:                 e => panic!(\"Unexpected event: {e:?}\\nExpected: {}\", stringify!($t))",
          "628:                 e => panic!(\"Unexpected event: {e:?}\\nExpected: {} if {}\", stringify!($t), stringify!($c))",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "694:     #[test]",
          "695:     fn opening_tag_in_attribute_value() {",
          "698:         let (mut r, mut p) = test_data!(r#\"",
          "699:             <a attr=\"zzz<zzz\" />",
          "",
          "[Removed Lines]",
          "696:         use reader::error::{SyntaxError, Error, ErrorKind};",
          "",
          "[Added Lines]",
          "696:         use crate::reader::error::{SyntaxError, Error, ErrorKind};",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "702:         expect_event!(r, p, Ok(XmlEvent::StartDocument { .. }));",
          "703:         expect_event!(r, p, Err(ref e) =>",
          "706:                 pos: TextPosition { row: 1, column: 24 }",
          "707:             }",
          "708:         );",
          "",
          "[Removed Lines]",
          "705:                 kind: ErrorKind::Syntax(SyntaxError::UnexpectedOpeningTag),",
          "",
          "[Added Lines]",
          "705:                 kind: ErrorKind::Syntax(SyntaxError::UnexpectedOpeningTag.to_cow()),",
          "",
          "---------------"
        ],
        "src/reader/parser/inside_closing_tag_name.rs||src/reader/parser/inside_closing_tag_name.rs": [
          "File: src/reader/parser/inside_closing_tag_name.rs -> src/reader/parser/inside_closing_tag_name.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use crate::{common::is_whitespace_char, namespace};",
          "3: use crate::reader::lexer::Token;",
          "5: use super::{ClosingTagSubstate, PullParser, QualifiedNameTarget, Result, State};",
          "7: impl PullParser {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: use crate::reader::error::SyntaxError;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "11:                 match name.prefix_ref() {",
          "12:                     Some(prefix) if prefix == namespace::NS_XML_PREFIX ||",
          "13:                                     prefix == namespace::NS_XMLNS_PREFIX =>",
          "15:                     _ => {",
          "16:                         this.data.element_name = Some(name.clone());",
          "17:                         match token {",
          "18:                             Token::TagEnd => this.emit_end_element(),",
          "19:                             Token::Character(c) if is_whitespace_char(c) => this.into_state_continue(State::InsideClosingTag(ClosingTagSubstate::CTAfterName)),",
          "21:                         }",
          "22:                     }",
          "23:                 }",
          "",
          "[Removed Lines]",
          "14:                         Some(self_error!(this; SyntaxError::InvalidNamePrefix(name.prefix.clone()))),",
          "20:                             _ => Some(self_error!(this; \"Unexpected token inside closing tag: {}\", token))",
          "",
          "[Added Lines]",
          "13:                         Some(this.error(SyntaxError::InvalidNamePrefix(prefix.into()))),",
          "19:                             _ => Some(this.error(SyntaxError::UnexpectedTokenInClosingTag(token)))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "25:             ClosingTagSubstate::CTAfterName => match t {",
          "26:                 Token::TagEnd => self.emit_end_element(),",
          "27:                 Token::Character(c) if is_whitespace_char(c) => None,  //  Skip whitespace",
          "29:             }",
          "30:         }",
          "31:     }",
          "",
          "[Removed Lines]",
          "28:                 _ => Some(self_error!(self; \"Unexpected token inside closing tag: {}\", t))",
          "",
          "[Added Lines]",
          "27:                 _ => Some(self.error(SyntaxError::UnexpectedTokenInClosingTag(t)))",
          "",
          "---------------"
        ],
        "src/reader/parser/inside_declaration.rs||src/reader/parser/inside_declaration.rs": [
          "File: src/reader/parser/inside_declaration.rs -> src/reader/parser/inside_declaration.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use crate::common::{is_whitespace_char, XmlVersion};",
          "3: use crate::reader::events::XmlEvent;",
          "4: use crate::reader::lexer::Token;",
          "5: use crate::util::Encoding;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: use crate::reader::error::SyntaxError;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "23:             let new_encoding = match new_encoding.parse() {",
          "24:                 Ok(e) => e,",
          "25:                 Err(_) if self.config.ignore_invalid_encoding_declarations => Encoding::Latin1,",
          "27:             };",
          "28:             let current_encoding = self.lexer.encoding();",
          "29:             if current_encoding != new_encoding {",
          "",
          "[Removed Lines]",
          "26:                 Err(_) => return Some(self_error!(self; \"Unknown encoding: {}\", new_encoding)),",
          "",
          "[Added Lines]",
          "26:                 Err(_) => return Some(self.error(SyntaxError::UnsupportedEncoding(new_encoding.into()))),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "31:                     (Encoding::Unknown | Encoding::Default, new) if new != Encoding::Utf16 => new,",
          "32:                     (Encoding::Utf16Be | Encoding::Utf16Le, Encoding::Utf16) => current_encoding,",
          "33:                     _ if self.config.ignore_invalid_encoding_declarations => current_encoding,",
          "35:                 };",
          "36:                 self.lexer.set_encoding(set);",
          "37:             }",
          "",
          "[Removed Lines]",
          "34:                     _ => return Some(self_error!(self; \"Conflicting encoding declared {}, used {}\", new_encoding, current_encoding)),",
          "",
          "[Added Lines]",
          "34:                     _ => return Some(self.error(SyntaxError::ConflictingEncoding(new_encoding, current_encoding))),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "52:             DeclarationSubstate::BeforeVersion => match t {",
          "53:                 Token::Character('v') => self.into_state_continue(State::InsideDeclaration(DeclarationSubstate::InsideVersion)),",
          "54:                 Token::Character(c) if is_whitespace_char(c) => None,  // continue",
          "56:             },",
          "58:             DeclarationSubstate::InsideVersion => self.read_qualified_name(t, QualifiedNameTarget::AttributeNameTarget, |this, token, name| {",
          "",
          "[Removed Lines]",
          "55:                 _ => unexpected_token!(t)",
          "",
          "[Added Lines]",
          "55:                 _ => Some(self.error(SyntaxError::UnexpectedToken(t))),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "65:                                 DeclarationSubstate::AfterVersion",
          "66:                             }",
          "67:                         )),",
          "69:                 }",
          "70:             }),",
          "72:             DeclarationSubstate::AfterVersion => match t {",
          "73:                 Token::EqualsSign => self.into_state_continue(State::InsideDeclaration(DeclarationSubstate::InsideVersionValue)),",
          "74:                 Token::Character(c) if is_whitespace_char(c) => None,",
          "76:             },",
          "78:             DeclarationSubstate::InsideVersionValue => self.read_attribute_value(t, |this, value| {",
          "",
          "[Removed Lines]",
          "68:                     _ => Some(this.error(SyntaxError::UnexpectedNameInsideXml(name))),",
          "75:                 _ => unexpected_token!(t)",
          "",
          "[Added Lines]",
          "68:                     _ => Some(this.error(SyntaxError::UnexpectedNameInsideXml(name.to_string().into()))),",
          "75:                 _ => Some(self.error(SyntaxError::UnexpectedToken(t))),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "84:                 if this.data.version.is_some() {",
          "85:                     this.into_state_continue(State::InsideDeclaration(DeclarationSubstate::AfterVersionValue))",
          "86:                 } else {",
          "88:                 }",
          "89:             }),",
          "",
          "[Removed Lines]",
          "87:                     Some(this.error(SyntaxError::UnexpectedXmlVersion(this.data.version)))",
          "",
          "[Added Lines]",
          "87:                     Some(this.error(SyntaxError::UnexpectedXmlVersion(value.into())))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "93:                 Token::Character('s') => self.into_state_continue(State::InsideDeclaration(DeclarationSubstate::InsideStandaloneDecl)),",
          "94:                 Token::ProcessingInstructionEnd => self.emit_start_document(),",
          "95:                 Token::Character(c) if is_whitespace_char(c) => None,  // skip whitespace",
          "97:             },",
          "99:             DeclarationSubstate::InsideEncoding => self.read_qualified_name(t, QualifiedNameTarget::AttributeNameTarget, |this, token, name| {",
          "",
          "[Removed Lines]",
          "96:                 _ => unexpected_token!(t)",
          "",
          "[Added Lines]",
          "96:                 _ => Some(self.error(SyntaxError::UnexpectedToken(t))),",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "102:                         this.into_state_continue(State::InsideDeclaration(",
          "103:                             if token == Token::EqualsSign { DeclarationSubstate::InsideEncodingValue } else { DeclarationSubstate::AfterEncoding }",
          "104:                         )),",
          "106:                 }",
          "107:             }),",
          "109:             DeclarationSubstate::AfterEncoding => match t {",
          "110:                 Token::EqualsSign => self.into_state_continue(State::InsideDeclaration(DeclarationSubstate::InsideEncodingValue)),",
          "111:                 Token::Character(c) if is_whitespace_char(c) => None,",
          "113:             },",
          "115:             DeclarationSubstate::InsideEncodingValue => self.read_attribute_value(t, |this, value| {",
          "",
          "[Removed Lines]",
          "105:                     _ => Some(this.error(SyntaxError::UnexpectedName(name)))",
          "112:                 _ => unexpected_token!(t),",
          "",
          "[Added Lines]",
          "105:                     _ => Some(this.error(SyntaxError::UnexpectedName(name.to_string().into())))",
          "112:                 _ => Some(self.error(SyntaxError::UnexpectedToken(t))),",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "121:                 Token::Character('s') => self.into_state_continue(State::InsideDeclaration(DeclarationSubstate::InsideStandaloneDecl)),",
          "122:                 Token::ProcessingInstructionEnd => self.emit_start_document(),",
          "123:                 Token::Character(c) if is_whitespace_char(c) => None, // skip whitespace",
          "125:             },",
          "127:             DeclarationSubstate::InsideStandaloneDecl => self.read_qualified_name(t, QualifiedNameTarget::AttributeNameTarget, |this, token, name| {",
          "",
          "[Removed Lines]",
          "124:                 _ => unexpected_token!(t),",
          "",
          "[Added Lines]",
          "124:                 _ => Some(self.error(SyntaxError::UnexpectedToken(t))),",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "134:                                 DeclarationSubstate::AfterStandaloneDecl",
          "135:                             }",
          "136:                         )),",
          "138:                 }",
          "139:             }),",
          "141:             DeclarationSubstate::AfterStandaloneDecl => match t {",
          "142:                 Token::EqualsSign => self.into_state_continue(State::InsideDeclaration(DeclarationSubstate::InsideStandaloneDeclValue)),",
          "143:                 Token::Character(c) if is_whitespace_char(c) => None,",
          "145:             },",
          "147:             DeclarationSubstate::InsideStandaloneDeclValue => self.read_attribute_value(t, |this, value| {",
          "",
          "[Removed Lines]",
          "137:                     _ => Some(this.error(SyntaxError::UnexpectedName(name))),",
          "144:                 _ => unexpected_token!(t)",
          "",
          "[Added Lines]",
          "137:                     _ => Some(this.error(SyntaxError::UnexpectedName(name.to_string().into()))),",
          "144:                 _ => Some(self.error(SyntaxError::UnexpectedToken(t))),",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "154:                     this.data.standalone = standalone;",
          "155:                     this.into_state_continue(State::InsideDeclaration(DeclarationSubstate::AfterStandaloneDeclValue))",
          "156:                 } else {",
          "158:                 }",
          "159:             }),",
          "161:             DeclarationSubstate::AfterStandaloneDeclValue => match t {",
          "162:                 Token::ProcessingInstructionEnd => self.emit_start_document(),",
          "163:                 Token::Character(c) if is_whitespace_char(c) => None, // skip whitespace",
          "165:             },",
          "166:         }",
          "167:     }",
          "",
          "[Removed Lines]",
          "157:                     Some(self_error!(this; SyntaxError::InvalidStandaloneDeclaration(value)))",
          "164:                 _ => unexpected_token!(t),",
          "",
          "[Added Lines]",
          "157:                     Some(this.error(SyntaxError::InvalidStandaloneDeclaration(value.into())))",
          "164:                 _ => Some(self.error(SyntaxError::UnexpectedToken(t))),",
          "",
          "---------------"
        ],
        "src/reader/parser/inside_doctype.rs||src/reader/parser/inside_doctype.rs": [
          "File: src/reader/parser/inside_doctype.rs -> src/reader/parser/inside_doctype.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: use super::{DoctypeSubstate, PullParser, QuoteToken, Result, State};",
          "",
          "[Removed Lines]",
          "1: use crate::{",
          "2:     common::{is_name_char, is_name_start_char, is_whitespace_char},",
          "3:     reader::lexer::Token,",
          "4: };",
          "",
          "[Added Lines]",
          "1: use crate::reader::error::SyntaxError;",
          "2: use crate::common::{is_name_char, is_name_start_char, is_whitespace_char};",
          "3: use crate::reader::lexer::Token;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "27:                     self.data.quote = Some(super::QuoteToken::from_token(&t));",
          "28:                     self.into_state_continue(State::InsideDoctype(DoctypeSubstate::String))",
          "29:                 },",
          "32:                 _ => None,",
          "33:             },",
          "",
          "[Removed Lines]",
          "30:                 Token::CDataEnd | Token::CDataStart => Some(self_error!(self; \"Unexpected token {}\", t)),",
          "",
          "[Added Lines]",
          "29:                 Token::CDataEnd | Token::CDataStart => Some(self.error(SyntaxError::UnexpectedToken(t))),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "55:                     match self.buf.as_str() {",
          "56:                         \"ENTITY\" => self.into_state_continue(State::InsideDoctype(DoctypeSubstate::BeforeEntityName)),",
          "57:                         \"NOTATION\" | \"ELEMENT\" | \"ATTLIST\" => self.into_state_continue(State::InsideDoctype(DoctypeSubstate::SkipDeclaration)),",
          "59:                     }",
          "61:                 },",
          "63:             },",
          "64:             DoctypeSubstate::BeforeEntityName => {",
          "65:                 self.data.name.clear();",
          "",
          "[Removed Lines]",
          "58:                         s => Some(self_error!(self; \"Unknown markup declaration: {}\", s)),",
          "62:                 _ => Some(self_error!(self; \"Incomplete markup declaration: {}\", t)),",
          "",
          "[Added Lines]",
          "57:                         s => Some(self.error(SyntaxError::UnknownMarkupDeclaration(s.into()))),",
          "61:                 _ => Some(self.error(SyntaxError::UnexpectedToken(t))),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "73:                         self.data.name.push(c);",
          "74:                         self.into_state_continue(State::InsideDoctype(DoctypeSubstate::EntityName))",
          "75:                     },",
          "77:                 }",
          "78:             },",
          "79:             DoctypeSubstate::EntityName => match t {",
          "",
          "[Removed Lines]",
          "76:                     _ => Some(self_error!(self; \"Expected entity name, found {}\", t)),",
          "",
          "[Added Lines]",
          "75:                     _ => Some(self.error(SyntaxError::UnexpectedTokenInEntity(t))),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "84:                     self.data.name.push(c);",
          "85:                     None",
          "86:                 },",
          "88:             },",
          "89:             DoctypeSubstate::BeforeEntityValue => {",
          "90:                 self.buf.clear();",
          "",
          "[Removed Lines]",
          "87:                 _ => Some(self_error!(self; \"Expected entity name, found {}\", t)),",
          "",
          "[Added Lines]",
          "86:                 _ => Some(self.error(SyntaxError::UnexpectedTokenInEntity(t))),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "101:                         self.data.quote = Some(super::QuoteToken::from_token(&t));",
          "102:                         self.into_state_continue(State::InsideDoctype(DoctypeSubstate::EntityValue))",
          "103:                     },",
          "105:                 }",
          "106:             },",
          "107:             DoctypeSubstate::EntityValue => match t {",
          "",
          "[Removed Lines]",
          "104:                     _ => Some(self_error!(self; \"Expected entity name, found {}\", t)),",
          "",
          "[Added Lines]",
          "103:                     _ => Some(self.error(SyntaxError::UnexpectedTokenInEntity(t))),",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "127:                     self.buf.push(c);",
          "128:                     None",
          "129:                 },",
          "131:             },",
          "132:             DoctypeSubstate::PEReferenceDefinitionStart => match t {",
          "133:                 Token::Character(c) if is_whitespace_char(c) => {",
          "",
          "[Removed Lines]",
          "130:                 _ => Some(self_error!(self; \"Expected entity value, found {}\", t)),",
          "",
          "[Added Lines]",
          "129:                 _ => Some(self.error(SyntaxError::UnexpectedTokenInEntity(t))),",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "138:                     self.data.name.push(c);",
          "139:                     self.into_state_continue(State::InsideDoctype(DoctypeSubstate::PEReferenceDefinition))",
          "140:                 },",
          "142:             },",
          "143:             DoctypeSubstate::PEReferenceDefinition => match t {",
          "144:                 Token::Character(c) if is_name_char(c) => {",
          "",
          "[Removed Lines]",
          "141:                 _ => Some(self_error!(self; \"Unexpected {} in entity\", t)),",
          "",
          "[Added Lines]",
          "140:                 _ => Some(self.error(SyntaxError::UnexpectedTokenInEntity(t))),",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "148:                 Token::Character(c) if is_whitespace_char(c) => {",
          "149:                     self.into_state_continue(State::InsideDoctype(DoctypeSubstate::BeforeEntityValue))",
          "150:                 },",
          "152:             },",
          "153:             DoctypeSubstate::PEReferenceInDtd => match t {",
          "154:                 Token::Character(c) if is_name_char(c) => {",
          "",
          "[Removed Lines]",
          "151:                 _ => Some(self_error!(self; \"Unexpected {} in entity\", t)),",
          "",
          "[Added Lines]",
          "150:                 _ => Some(self.error(SyntaxError::UnexpectedTokenInEntity(t))),",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "164:                             }",
          "165:                             self.into_state_continue(State::InsideDoctype(DoctypeSubstate::Outside))",
          "166:                         },",
          "168:                     }",
          "169:                 },",
          "171:             },",
          "172:             DoctypeSubstate::PEReferenceInValue => match t {",
          "173:                 Token::Character(c) if is_name_char(c) => {",
          "",
          "[Removed Lines]",
          "167:                         None => Some(self_error!(self; \"Undefined PE entity {}\", name)),",
          "170:                 _ => Some(self_error!(self; \"Unexpected {} in entity\", t)),",
          "",
          "[Added Lines]",
          "166:                         None => Some(self.error(SyntaxError::UndefinedPEntity(name.into()))),",
          "169:                 _ => Some(self.error(SyntaxError::UnexpectedTokenInEntity(t))),",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "181:                             self.buf.push_str(ent);",
          "182:                             self.into_state_continue(State::InsideDoctype(DoctypeSubstate::EntityValue))",
          "183:                         },",
          "185:                     }",
          "186:                 },",
          "188:             },",
          "189:             DoctypeSubstate::NumericReferenceStart => match t {",
          "190:                 Token::Character('#') => {",
          "",
          "[Removed Lines]",
          "184:                         None => Some(self_error!(self; \"Undefined PE entity {}\", name)),",
          "187:                 _ => Some(self_error!(self; \"Unexpected {} in entity\", t)),",
          "",
          "[Added Lines]",
          "183:                         None => Some(self.error(SyntaxError::UndefinedPEntity(name.into()))),",
          "186:                 _ => Some(self.error(SyntaxError::UnexpectedTokenInEntity(t))),",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "197:                     self.into_state_continue(State::InsideDoctype(DoctypeSubstate::EntityValue))",
          "198:                 },",
          "200:             },",
          "201:             DoctypeSubstate::NumericReference => match t {",
          "202:                 Token::ReferenceEnd | Token::Character(';') => {",
          "",
          "[Removed Lines]",
          "199:                 _ => Some(self_error!(self; \"Unexpected {} in entity\", t)),",
          "",
          "[Added Lines]",
          "198:                 _ => Some(self.error(SyntaxError::UnexpectedTokenInEntity(t))),",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "207:                             self.buf.push(c);",
          "208:                             self.into_state_continue(State::InsideDoctype(DoctypeSubstate::EntityValue))",
          "209:                         }",
          "211:                     }",
          "212:                 },",
          "213:                 Token::Character(c) => {",
          "214:                     self.data.ref_data.push(c);",
          "215:                     None",
          "216:                 },",
          "218:             },",
          "219:             DoctypeSubstate::SkipDeclaration => match t {",
          "220:                 Token::TagEnd => {",
          "",
          "[Removed Lines]",
          "210:                         Err(e) => Some(self_error!(self; e)),",
          "217:                 _ => Some(self_error!(self; \"Unexpected {} in entity\", t)),",
          "",
          "[Added Lines]",
          "209:                         Err(e) => Some(self.error(e)),",
          "216:                 _ => Some(self.error(SyntaxError::UnexpectedTokenInEntity(t))),",
          "",
          "---------------"
        ],
        "src/reader/parser/inside_opening_tag.rs||src/reader/parser/inside_opening_tag.rs": [
          "File: src/reader/parser/inside_opening_tag.rs -> src/reader/parser/inside_opening_tag.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use crate::common::is_name_start_char;",
          "2: use crate::namespace;",
          "3: use crate::{attribute::OwnedAttribute, common::is_whitespace_char};",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: use crate::reader::error::SyntaxError;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "13:                 match name.prefix_ref() {",
          "14:                     Some(prefix) if prefix == namespace::NS_XML_PREFIX ||",
          "15:                                     prefix == namespace::NS_XMLNS_PREFIX =>",
          "17:                     _ => {",
          "18:                         this.data.element_name = Some(name.clone());",
          "19:                         match token {",
          "",
          "[Removed Lines]",
          "16:                         Some(self_error!(this; SyntaxError::InvalidNamePrefix(name.prefix.clone()))),",
          "",
          "[Added Lines]",
          "17:                         Some(this.error(SyntaxError::InvalidNamePrefix(prefix.into()))),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "34:                     self.buf.push(c);",
          "35:                     self.into_state_continue(State::InsideOpeningTag(OpeningTagSubstate::InsideAttributeName))",
          "36:                 }",
          "38:             },",
          "40:             OpeningTagSubstate::InsideAttributeName => self.read_qualified_name(t, QualifiedNameTarget::AttributeNameTarget, |this, token, name| {",
          "",
          "[Removed Lines]",
          "37:                 _ => unexpected_token!(t)",
          "",
          "[Added Lines]",
          "38:                 _ => Some(self.error(SyntaxError::UnexpectedTokenInOpeningTag(t)))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "49:             OpeningTagSubstate::AfterAttributeName => match t {",
          "50:                 Token::EqualsSign => self.into_state_continue(State::InsideOpeningTag(OpeningTagSubstate::InsideAttributeValue)),",
          "51:                 Token::Character(c) if is_whitespace_char(c) => None,",
          "53:             },",
          "55:             OpeningTagSubstate::InsideAttributeValue => self.read_attribute_value(t, |this, value| {",
          "",
          "[Removed Lines]",
          "52:                 _ => unexpected_token!(t)",
          "",
          "[Added Lines]",
          "53:                 _ => Some(self.error(SyntaxError::UnexpectedTokenInOpeningTag(t)))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "59:                 if this.data.attributes.iter().any(|a| a.name == name) {  // TODO: looks bad",
          "63:                 } else {",
          "64:                     match name.prefix_ref() {",
          "",
          "[Removed Lines]",
          "62:                     Some(self_error!(this; SyntaxError::RedefinedAttribute(name)))",
          "",
          "[Added Lines]",
          "63:                     Some(this.error(SyntaxError::RedefinedAttribute(name.to_string().into())))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "67:                         Some(namespace::NS_XMLNS_PREFIX) => {",
          "68:                             let ln = &*name.local_name;",
          "69:                             if ln == namespace::NS_XMLNS_PREFIX {",
          "71:                             } else if ln == namespace::NS_XML_PREFIX && &*value != namespace::NS_XML_URI {",
          "73:                             } else if value.is_empty() {",
          "75:                             } else {",
          "76:                                 this.nst.put(name.local_name.clone(), value);",
          "77:                                 this.into_state_continue(State::InsideOpeningTag(OpeningTagSubstate::InsideTag))",
          "",
          "[Removed Lines]",
          "70:                                 Some(self_error!(this; \"Cannot redefine prefix '{}'\", namespace::NS_XMLNS_PREFIX))",
          "72:                                 Some(self_error!(this; \"Prefix '{}' cannot be rebound to another value\", namespace::NS_XML_PREFIX))",
          "74:                                 Some(self_error!(this; SyntaxError::CannotUndefinePrefix(ln.to_string())))",
          "",
          "[Added Lines]",
          "71:                                 Some(this.error(SyntaxError::CannotRedefineXmlnsPrefix))",
          "73:                                 Some(this.error(SyntaxError::CannotRedefineXmlPrefix))",
          "75:                                 Some(this.error(SyntaxError::CannotUndefinePrefix(ln.into())))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "82:                         None if &*name.local_name == namespace::NS_XMLNS_PREFIX =>",
          "83:                             match &*value {",
          "84:                                 namespace::NS_XMLNS_PREFIX | namespace::NS_XML_PREFIX | namespace::NS_XML_URI | namespace::NS_XMLNS_URI =>",
          "86:                                 _ => {",
          "87:                                     this.nst.put(namespace::NS_NO_PREFIX, value.clone());",
          "88:                                     this.into_state_continue(State::InsideOpeningTag(OpeningTagSubstate::InsideTag))",
          "",
          "[Removed Lines]",
          "85:                                     Some(self_error!(this; \"Namespace '{}' cannot be default\", value)),",
          "",
          "[Added Lines]",
          "86:                                     Some(this.error(SyntaxError::InvalidDefaultNamespace(value.into()))),",
          "",
          "---------------"
        ],
        "src/reader/parser/inside_processing_instruction.rs||src/reader/parser/inside_processing_instruction.rs": [
          "File: src/reader/parser/inside_processing_instruction.rs -> src/reader/parser/inside_processing_instruction.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use crate::common::{is_name_char, is_name_start_char, is_whitespace_char};",
          "3: use crate::reader::events::XmlEvent;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: use crate::reader::error::SyntaxError;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "21:                     match &*name {",
          "27:                         \"xml\"|\"xmL\"|\"xMl\"|\"xML\"|\"Xml\"|\"XmL\"|\"XMl\"|\"XML\" =>",
          "31:                         _ => {",
          "",
          "[Removed Lines]",
          "23:                         \"\" => Some(self_error!(self; SyntaxError::ProcessingInstructionWithoutName)),",
          "28:                             Some(self_error!(self; SyntaxError::InvalidXmlProcessingInstruction(name))),",
          "",
          "[Added Lines]",
          "24:                         \"\" => Some(self.error(SyntaxError::ProcessingInstructionWithoutName)),",
          "29:                             Some(self.error(SyntaxError::InvalidXmlProcessingInstruction(name.into()))),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54:                         \"xml\"|\"xmL\"|\"xMl\"|\"xML\"|\"Xml\"|\"XmL\"|\"XMl\"|\"XML\" =>",
          "58:                         _ => {",
          "",
          "[Removed Lines]",
          "55:                             Some(self_error!(self; \"Invalid processing instruction: <?{}\", name)),",
          "",
          "[Added Lines]",
          "56:                             Some(self.error(SyntaxError::InvalidProcessingInstruction(name.into()))),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "62:                     }",
          "63:                 }",
          "66:             },",
          "68:             ProcessingInstructionSubstate::PIInsideData => match t {",
          "",
          "[Removed Lines]",
          "65:                 _ => Some(self_error!(self; \"Unexpected token: <?{}{}\", self.buf, t)),",
          "",
          "[Added Lines]",
          "66:                 _ => {",
          "67:                     let buf = self.take_buf();",
          "68:                     Some(self.error(SyntaxError::UnexpectedProcessingInstruction(buf.into(), t)))",
          "69:                 }",
          "",
          "---------------"
        ],
        "src/reader/parser/inside_reference.rs||src/reader/parser/inside_reference.rs": [
          "File: src/reader/parser/inside_reference.rs -> src/reader/parser/inside_reference.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use std::char;",
          "3: use crate::common::{is_name_char, is_name_start_char, is_whitespace_char};",
          "5: use crate::reader::lexer::Token;",
          "7: use super::{PullParser, Result, State};",
          "9: impl PullParser {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: use crate::reader::error::SyntaxError;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "18:             Token::ReferenceEnd => {",
          "19:                 let name = self.data.take_ref_data();",
          "20:                 if name.is_empty() {",
          "22:                 }",
          "24:                 let c = match &*name {",
          "",
          "[Removed Lines]",
          "21:                     return Some(self_error!(self; \"Encountered empty entity\"));",
          "",
          "[Added Lines]",
          "19:                     return Some(self.error(SyntaxError::EmptyEntity));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "29:                     \"quot\" => Some('\"'),",
          "30:                     _ if name.starts_with('#') => match self.numeric_reference_from_str(&name[1..]) {",
          "31:                         Ok(c) => Some(c),",
          "33:                     },",
          "34:                     _ => None,",
          "35:                 };",
          "",
          "[Removed Lines]",
          "32:                         Err(e) => return Some(self_error!(self; e))",
          "",
          "[Added Lines]",
          "30:                         Err(e) => return Some(self.error(e))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "49:                         self.buf.push_str(v);",
          "50:                     }",
          "51:                 } else {",
          "53:                 }",
          "54:                 let prev_st = self.state_after_reference;",
          "55:                 if prev_st == State::OutsideTag && !is_whitespace_char(self.buf.chars().last().unwrap_or('\\0')) {",
          "",
          "[Removed Lines]",
          "52:                     return Some(self_error!(self; \"Unexpected entity: {}\", name));",
          "",
          "[Added Lines]",
          "50:                     return Some(self.error(SyntaxError::UnexpectedEntity(name.into())));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "58:                 self.into_state_continue(prev_st)",
          "59:             }",
          "62:         }",
          "63:     }",
          "66:         let val = if let Some(hex) = num_str.strip_prefix('x') {",
          "68:         } else {",
          "70:         };",
          "71:         match char::from_u32(val) {",
          "73:             Some(c) => Ok(c),",
          "74:             None if self.config.c.replace_unknown_entity_references => {",
          "75:                 Ok('\\u{fffd}')",
          "76:             },",
          "78:         }",
          "79:     }",
          "80: }",
          "",
          "[Removed Lines]",
          "61:             _ => Some(self_error!(self; \"Unexpected token inside an entity: {}\", t)),",
          "65:     pub(crate) fn numeric_reference_from_str(&self, num_str: &str) -> std::result::Result<char, String> {",
          "67:             u32::from_str_radix(hex, 16).map_err(move |_| format!(\"Invalid hexadecimal character number in an entity: {num_str}\"))?",
          "69:             u32::from_str_radix(num_str, 10).map_err(move |_| format!(\"Invalid character number in an entity: {num_str}\"))?",
          "72:             Some('\\0' | '\\u{fffe}' | '\\u{ffff}') => Err(\"character is not allowed\".into()),",
          "77:             None => Err(format!(\"Invalid character U+{val:X}\")),",
          "",
          "[Added Lines]",
          "59:             _ => Some(self.error(SyntaxError::UnexpectedTokenInEntity(t))),",
          "63:     pub(crate) fn numeric_reference_from_str(&self, num_str: &str) -> std::result::Result<char, SyntaxError> {",
          "65:             u32::from_str_radix(hex, 16).map_err(move |_| SyntaxError::InvalidNumericEntity(num_str.into()))?",
          "67:             u32::from_str_radix(num_str, 10).map_err(move |_| SyntaxError::InvalidNumericEntity(num_str.into()))?",
          "70:             Some('\\0' | '\\u{fffe}' | '\\u{ffff}') => Err(SyntaxError::InvalidCharacterEntity(val)),",
          "75:             None => Err(SyntaxError::InvalidCharacterEntity(val)),",
          "",
          "---------------"
        ],
        "src/reader/parser/outside_tag.rs||src/reader/parser/outside_tag.rs": [
          "File: src/reader/parser/outside_tag.rs -> src/reader/parser/outside_tag.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use crate::common::is_whitespace_char;",
          "3: use crate::reader::events::XmlEvent;",
          "4: use crate::reader::lexer::Token;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: use crate::reader::error::SyntaxError;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29:             }",
          "31:             _ if t.contains_char_data() && self.depth() == 0 => {",
          "33:             }",
          "37:             Token::ReferenceEnd if self.depth() > 0 => { // Semi-colon in a text outside an entity",
          "38:                 self.inside_whitespace = false;",
          "",
          "[Removed Lines]",
          "32:                 Some(self_error!(self; \"Unexpected characters outside the root element: {}\", t))",
          "35:             Token::CDataEnd => Some(self_error!(self; \"]]> in text\")),",
          "",
          "[Added Lines]",
          "32:                 Some(self.error(SyntaxError::UnexpectedTokenOutsideRoot(t)))",
          "35:             Token::CDataEnd => Some(self.error(SyntaxError::UnexpectedCdataEnd)),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "118:                         self.into_state(State::InsideCData, next_event)",
          "119:                     }",
          "122:                 }",
          "123:             }",
          "124:         }",
          "",
          "[Removed Lines]",
          "121:                     _ => Some(self_error!(self; \"Unexpected token: {}\", t)),",
          "",
          "[Added Lines]",
          "121:                     _ => Some(self.error(SyntaxError::UnexpectedToken(t)))",
          "",
          "---------------"
        ],
        "tests/event_reader.rs||tests/event_reader.rs": [
          "File: tests/event_reader.rs -> tests/event_reader.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "251: fn bad_1() {",
          "252:     test(",
          "253:         br#\"<?xml&.,\"#,",
          "255:         ParserConfig::new(),",
          "256:         false,",
          "257:     );",
          "",
          "[Removed Lines]",
          "254:         br#\"1:6 Unexpected token: <?xml&\"#,",
          "",
          "[Added Lines]",
          "254:         br#\"1:6 Unexpected token inside processing instruction: <?xml&\"#,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
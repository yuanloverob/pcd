{
  "cve_id": "CVE-2023-27483",
  "cve_desc": "crossplane-runtime is a set of go libraries used to build Kubernetes controllers in Crossplane and its related stacks. An out of memory panic vulnerability has been discovered in affected versions. Applications that use the `Paved` type's `SetValue` method with user provided input without proper validation might use excessive amounts of memory and cause an out of memory panic. In the fieldpath package, the Paved.SetValue method sets a value on the Paved object according to the provided path, without any validation. This allows setting values in slices at any provided index, which grows the target array up to the requested index, the index is currently capped at max uint32 (4294967295) given how indexes are parsed,  but that is still an unnecessarily large value. If callers are not validating paths' indexes on their own, which most probably are not going to do, given that the input is parsed directly in the SetValue method, this could allow users to consume arbitrary amounts of memory. Applications that do not use the `Paved` type's `SetValue` method are not affected. This issue has been addressed in versions 0.16.1 and 0.19.2. Users are advised to upgrade. Users unable to upgrade can parse and validate the path before passing it to the `SetValue` method of the `Paved` type, constraining the index size as deemed appropriate.",
  "repo": "crossplane/crossplane-runtime",
  "patch_hash": "f67177024d906aaf5e13ee7cd470b4e87a9fef40",
  "patch_info": {
    "commit_hash": "f67177024d906aaf5e13ee7cd470b4e87a9fef40",
    "repo": "crossplane/crossplane-runtime",
    "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/f67177024d906aaf5e13ee7cd470b4e87a9fef40",
    "files": [
      "pkg/fieldpath/fieldpath.go",
      "pkg/fieldpath/fieldpath_test.go",
      "pkg/fieldpath/paved.go",
      "pkg/fieldpath/paved_test.go"
    ],
    "message": "Add a package for getting and setting unstructured fields by path\n\nhttps://github.com/kubernetes-sigs/kustomize/blob/d190e1/api/k8sdeps/kunstruct/helper.go\nhttps://github.com/kubernetes/apimachinery/blob/2373d0/pkg/apis/meta/v1/unstructured/helpers.go\n\nThis package is similar to the above two, with some key differences:\n\n* Our fieldpath lexer is a little stricter; it won't allow dangling open braces,\n  unexpected periods, or empty brackets. It also supplies the position of any\n  syntax error if lexing fails.\n* We support setting and getting fields within a pkg/json unmarshalled object by\n  fieldpath. Other packages support only getting fields, or only setting fields\n  in paths that do not contain any array indexes.\n\nSigned-off-by: Nic Cope <negz@rk0n.org>",
    "before_after_code_files": [
      "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go",
      "pkg/fieldpath/fieldpath_test.go||pkg/fieldpath/fieldpath_test.go",
      "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
      "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
    ]
  },
  "patch_diff": {
    "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go": [
      "File: pkg/fieldpath/fieldpath.go -> pkg/fieldpath/fieldpath.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: Copyright 2019 The Crossplane Authors.",
      "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
      "5: you may not use this file except in compliance with the License.",
      "6: You may obtain a copy of the License at",
      "8:     http://www.apache.org/licenses/LICENSE-2.0",
      "10: Unless required by applicable law or agreed to in writing, software",
      "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
      "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
      "13: See the License for the specific language governing permissions and",
      "14: limitations under the License.",
      "43: package fieldpath",
      "45: import (",
      "46:  \"fmt\"",
      "47:  \"strconv\"",
      "48:  \"strings\"",
      "49:  \"unicode/utf8\"",
      "51:  \"github.com/pkg/errors\"",
      "52: )",
      "56: type SegmentType int",
      "59: const (",
      "60:  _ SegmentType = iota",
      "61:  SegmentField",
      "62:  SegmentIndex",
      "63: )",
      "66: type Segment struct {",
      "67:  Type  SegmentType",
      "68:  Field string",
      "69:  Index uint",
      "70: }",
      "73: type Segments []Segment",
      "75: func (sg Segments) String() string {",
      "76:  var b strings.Builder",
      "78:  for _, s := range sg {",
      "79:   switch s.Type {",
      "80:   case SegmentField:",
      "81:    if strings.ContainsRune(s.Field, period) {",
      "82:     b.WriteString(fmt.Sprintf(\"[%s]\", s.Field))",
      "83:     continue",
      "84:    }",
      "85:    b.WriteString(fmt.Sprintf(\".%s\", s.Field))",
      "86:   case SegmentIndex:",
      "87:    b.WriteString(fmt.Sprintf(\"[%d]\", s.Index))",
      "88:   }",
      "89:  }",
      "91:  return strings.TrimPrefix(b.String(), \".\")",
      "92: }",
      "98: func FieldOrIndex(s string) Segment {",
      "102:  if i, err := strconv.ParseUint(s, 10, 32); err == nil {",
      "103:   return Segment{Type: SegmentIndex, Index: uint(i)}",
      "104:  }",
      "108:  return Field(s)",
      "109: }",
      "113: func Field(s string) Segment {",
      "114:  return Segment{Type: SegmentField, Field: strings.Trim(s, \"'\\\"\")}",
      "115: }",
      "118: func Parse(path string) (Segments, error) {",
      "119:  l := &lexer{input: path, items: make(chan item)}",
      "120:  go l.run()",
      "122:  segments := make(Segments, 0, 1)",
      "123:  for i := range l.items {",
      "124:   switch i.typ {",
      "125:   case itemField:",
      "126:    segments = append(segments, Field(i.val))",
      "127:   case itemFieldOrIndex:",
      "128:    segments = append(segments, FieldOrIndex(i.val))",
      "129:   case itemError:",
      "130:    return nil, errors.Errorf(\"%s at position %d\", i.val, i.pos)",
      "131:   }",
      "132:  }",
      "133:  return segments, nil",
      "134: }",
      "136: const (",
      "137:  period       = '.'",
      "138:  leftBracket  = '['",
      "139:  rightBracket = ']'",
      "140: )",
      "142: type itemType int",
      "144: const (",
      "145:  itemError itemType = iota",
      "146:  itemPeriod",
      "147:  itemLeftBracket",
      "148:  itemRightBracket",
      "149:  itemField",
      "150:  itemFieldOrIndex",
      "151:  itemEOL",
      "152: )",
      "154: type item struct {",
      "155:  typ itemType",
      "156:  pos int",
      "157:  val string",
      "158: }",
      "160: type stateFn func(*lexer) stateFn",
      "164: type lexer struct {",
      "165:  input string",
      "166:  pos   int",
      "167:  start int",
      "168:  items chan item",
      "169: }",
      "171: func (l *lexer) run() {",
      "172:  for state := lexField; state != nil; {",
      "173:   state = state(l)",
      "174:  }",
      "175:  close(l.items)",
      "176: }",
      "178: func (l *lexer) emit(t itemType) {",
      "180:  if l.pos <= l.start {",
      "181:   return",
      "182:  }",
      "183:  l.items <- item{typ: t, pos: l.start, val: l.input[l.start:l.pos]}",
      "184:  l.start = l.pos",
      "185: }",
      "187: func (l *lexer) errorf(pos int, format string, args ...interface{}) stateFn {",
      "188:  l.items <- item{typ: itemError, pos: pos, val: fmt.Sprintf(format, args...)}",
      "189:  return nil",
      "190: }",
      "192: func lexField(l *lexer) stateFn {",
      "193:  for i, r := range l.input[l.pos:] {",
      "194:   switch r {",
      "196:   case rightBracket:",
      "197:    return l.errorf(l.pos+i, \"unexpected %q\", rightBracket)",
      "200:   case leftBracket:",
      "201:    l.pos += i",
      "202:    l.emit(itemField)",
      "203:    return lexLeftBracket",
      "206:   case period:",
      "207:    l.pos += i",
      "208:    l.emit(itemField)",
      "209:    return lexPeriod",
      "210:   }",
      "211:  }",
      "214:  l.pos = len(l.input)",
      "215:  l.emit(itemField)",
      "216:  l.emit(itemEOL)",
      "217:  return nil",
      "218: }",
      "220: func lexPeriod(l *lexer) stateFn {",
      "222:  if l.pos == 0 || l.pos == len(l.input)-1 {",
      "223:   return l.errorf(l.pos, \"unexpected %q\", period)",
      "224:  }",
      "226:  l.pos += utf8.RuneLen(period)",
      "227:  l.emit(itemPeriod)",
      "231:  r, _ := utf8.DecodeRuneInString(l.input[l.pos:])",
      "232:  if r == period {",
      "233:   return l.errorf(l.pos, \"unexpected %q\", period)",
      "234:  }",
      "235:  if r == leftBracket {",
      "236:   return l.errorf(l.pos, \"unexpected %q\", leftBracket)",
      "237:  }",
      "239:  return lexField",
      "240: }",
      "242: func lexLeftBracket(l *lexer) stateFn {",
      "244:  if !strings.ContainsRune(l.input[l.pos:], rightBracket) {",
      "245:   return l.errorf(l.pos, \"unterminated %q\", leftBracket)",
      "246:  }",
      "248:  l.pos += utf8.RuneLen(leftBracket)",
      "249:  l.emit(itemLeftBracket)",
      "250:  return lexFieldOrIndex",
      "251: }",
      "255: func lexFieldOrIndex(l *lexer) stateFn {",
      "258:  rbi := strings.IndexRune(l.input[l.pos:], rightBracket)",
      "261:  if rbi == 0 {",
      "262:   return l.errorf(l.pos, \"unexpected %q\", rightBracket)",
      "263:  }",
      "266:  if lbi := strings.IndexRune(l.input[l.pos:l.pos+rbi], leftBracket); lbi > -1 {",
      "267:   return l.errorf(l.pos+lbi, \"unexpected %q\", leftBracket)",
      "268:  }",
      "271:  l.pos += rbi",
      "272:  l.emit(itemFieldOrIndex)",
      "273:  return lexRightBracket",
      "274: }",
      "276: func lexRightBracket(l *lexer) stateFn {",
      "277:  l.pos += utf8.RuneLen(rightBracket)",
      "278:  l.emit(itemRightBracket)",
      "279:  return lexField",
      "280: }",
      "",
      "---------------"
    ],
    "pkg/fieldpath/fieldpath_test.go||pkg/fieldpath/fieldpath_test.go": [
      "File: pkg/fieldpath/fieldpath_test.go -> pkg/fieldpath/fieldpath_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: Copyright 2019 The Crossplane Authors.",
      "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
      "5: you may not use this file except in compliance with the License.",
      "6: You may obtain a copy of the License at",
      "8:     http://www.apache.org/licenses/LICENSE-2.0",
      "10: Unless required by applicable law or agreed to in writing, software",
      "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
      "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
      "13: See the License for the specific language governing permissions and",
      "14: limitations under the License.",
      "17: package fieldpath",
      "19: import (",
      "20:  \"math\"",
      "21:  \"strconv\"",
      "22:  \"testing\"",
      "24:  \"github.com/google/go-cmp/cmp\"",
      "25:  \"github.com/pkg/errors\"",
      "27:  \"github.com/crossplane/crossplane-runtime/pkg/test\"",
      "28: )",
      "30: func TestSegments(t *testing.T) {",
      "31:  cases := map[string]struct {",
      "32:   s    Segments",
      "33:   want string",
      "34:  }{",
      "35:   \"SingleField\": {",
      "36:    s:    Segments{Field(\"spec\")},",
      "37:    want: \"spec\",",
      "38:   },",
      "39:   \"SingleIndex\": {",
      "40:    s:    Segments{FieldOrIndex(\"0\")},",
      "41:    want: \"[0]\",",
      "42:   },",
      "43:   \"FieldsAndIndex\": {",
      "44:    s: Segments{",
      "45:     Field(\"spec\"),",
      "46:     Field(\"containers\"),",
      "47:     FieldOrIndex(\"0\"),",
      "48:     Field(\"name\"),",
      "49:    },",
      "50:    want: \"spec.containers[0].name\",",
      "51:   },",
      "52:   \"PeriodsInField\": {",
      "53:    s: Segments{",
      "54:     Field(\"data\"),",
      "55:     Field(\".config.yml\"),",
      "56:    },",
      "57:    want: \"data[.config.yml]\",",
      "58:   },",
      "59:  }",
      "61:  for name, tc := range cases {",
      "62:   t.Run(name, func(t *testing.T) {",
      "63:    if diff := cmp.Diff(tc.want, tc.s.String()); diff != \"\" {",
      "64:     t.Errorf(\"s.String(): -want, +got:\\n %s\", diff)",
      "65:    }",
      "67:   })",
      "68:  }",
      "69: }",
      "71: func TestFieldOrIndex(t *testing.T) {",
      "72:  cases := map[string]struct {",
      "73:   reason string",
      "74:   s      string",
      "75:   want   Segment",
      "76:  }{",
      "77:   \"Field\": {",
      "78:    reason: \"An unambiguous string should be interpreted as a field segment\",",
      "79:    s:      \"coolField\",",
      "80:    want:   Segment{Type: SegmentField, Field: \"coolField\"},",
      "81:   },",
      "82:   \"QuotedField\": {",
      "83:    reason: \"A quoted string should be interpreted as a field segment with the quotes removed\",",
      "84:    s:      \"'coolField'\",",
      "85:    want:   Segment{Type: SegmentField, Field: \"coolField\"},",
      "86:   },",
      "87:   \"Index\": {",
      "88:    reason: \"An unambiguous integer should be interpreted as an index segment\",",
      "89:    s:      \"3\",",
      "90:    want:   Segment{Type: SegmentIndex, Index: 3},",
      "91:   },",
      "92:   \"Negative\": {",
      "93:    reason: \"A negative integer should be interpreted as an field segment\",",
      "94:    s:      \"-3\",",
      "95:    want:   Segment{Type: SegmentField, Field: \"-3\"},",
      "96:   },",
      "97:   \"Float\": {",
      "98:    reason: \"A float should be interpreted as an field segment\",",
      "99:    s:      \"3.0\",",
      "100:    want:   Segment{Type: SegmentField, Field: \"3.0\"},",
      "101:   },",
      "102:   \"Overflow\": {",
      "103:    reason: \"A very big integer will be interpreted as a field segment\",",
      "104:    s:      strconv.Itoa(math.MaxUint32 + 1),",
      "105:    want:   Segment{Type: SegmentField, Field: strconv.Itoa(math.MaxUint32 + 1)},",
      "106:   },",
      "107:  }",
      "108:  for name, tc := range cases {",
      "109:   t.Run(name, func(t *testing.T) {",
      "110:    got := FieldOrIndex(tc.s)",
      "111:    if diff := cmp.Diff(tc.want, got); diff != \"\" {",
      "112:     t.Errorf(\"\\nFieldOrIndex(...): %s: -want, +got:\\n%s\", tc.reason, diff)",
      "113:    }",
      "114:   })",
      "115:  }",
      "116: }",
      "118: func TestParse(t *testing.T) {",
      "119:  type want struct {",
      "120:   s   Segments",
      "121:   err error",
      "122:  }",
      "124:  cases := map[string]struct {",
      "125:   reason string",
      "126:   path   string",
      "127:   want   want",
      "128:  }{",
      "129:   \"SingleField\": {",
      "130:    reason: \"A path with no brackets or periods should be interpreted as a single field segment\",",
      "131:    path:   \"spec\",",
      "132:    want: want{",
      "133:     s: Segments{Field(\"spec\")},",
      "134:    },",
      "135:   },",
      "136:   \"SingleIndex\": {",
      "137:    reason: \"An integer surrounded by brackets should be interpreted as an index\",",
      "138:    path:   \"[0]\",",
      "139:    want: want{",
      "140:     s: Segments{FieldOrIndex(\"0\")},",
      "141:    },",
      "142:   },",
      "143:   \"TwoFields\": {",
      "144:    reason: \"A path with one period should be interpreted as two field segments\",",
      "145:    path:   \"metadata.name\",",
      "146:    want: want{",
      "147:     s: Segments{Field(\"metadata\"), Field(\"name\")},",
      "148:    },",
      "149:   },",
      "150:   \"APIConventionsExample\": {",
      "151:    reason: \"The example given by the Kubernetes API convention should be parse correctly\",",
      "152:    path:   \"fields[1].state.current\",",
      "153:    want: want{",
      "154:     s: Segments{",
      "155:      Field(\"fields\"),",
      "156:      FieldOrIndex(\"1\"),",
      "157:      Field(\"state\"),",
      "158:      Field(\"current\"),",
      "159:     },",
      "160:    },",
      "161:   },",
      "162:   \"SimpleIndex\": {",
      "163:    reason: \"Indexing an object field that is an array should result in a field and an index\",",
      "164:    path:   \"items[0]\",",
      "165:    want: want{",
      "166:     s: Segments{Field(\"items\"), FieldOrIndex(\"0\")},",
      "167:    },",
      "168:   },",
      "169:   \"FieldsAndIndex\": {",
      "170:    reason: \"A path with periods and braces should be interpreted as fields and indices\",",
      "171:    path:   \"spec.containers[0].name\",",
      "172:    want: want{",
      "173:     s: Segments{",
      "174:      Field(\"spec\"),",
      "175:      Field(\"containers\"),",
      "176:      FieldOrIndex(\"0\"),",
      "177:      Field(\"name\"),",
      "178:     },",
      "179:    },",
      "180:   },",
      "181:   \"NestedArray\": {",
      "182:    reason: \"A nested array should result in two consecutive index fields\",",
      "183:    path:   \"nested[0][1].name\",",
      "184:    want: want{",
      "185:     s: Segments{",
      "186:      Field(\"nested\"),",
      "187:      FieldOrIndex(\"0\"),",
      "188:      FieldOrIndex(\"1\"),",
      "189:      Field(\"name\"),",
      "190:     },",
      "191:    },",
      "192:   },",
      "193:   \"BracketStyleField\": {",
      "194:    reason: \"A field name can be specified using brackets rather than a period\",",
      "195:    path:   \"spec[containers][0].name\",",
      "196:    want: want{",
      "197:     s: Segments{",
      "198:      Field(\"spec\"),",
      "199:      Field(\"containers\"),",
      "200:      FieldOrIndex(\"0\"),",
      "201:      Field(\"name\"),",
      "202:     },",
      "203:    },",
      "204:   },",
      "205:   \"BracketFieldWithPeriod\": {",
      "206:    reason: \"A field name specified using brackets can include a period\",",
      "207:    path:   \"data[.config.yml]\",",
      "208:    want: want{",
      "209:     s: Segments{",
      "210:      Field(\"data\"),",
      "211:      FieldOrIndex(\".config.yml\"),",
      "212:     },",
      "213:    },",
      "214:   },",
      "215:   \"LeadingPeriod\": {",
      "216:    reason: \"A path may not start with a period (unlike a JSON path)\",",
      "217:    path:   \".metadata.name\",",
      "218:    want: want{",
      "219:     err: errors.New(\"unexpected '.' at position 0\"),",
      "220:    },",
      "221:   },",
      "222:   \"TrailingPeriod\": {",
      "223:    reason: \"A path may not end with a period\",",
      "224:    path:   \"metadata.name.\",",
      "225:    want: want{",
      "226:     err: errors.New(\"unexpected '.' at position 13\"),",
      "227:    },",
      "228:   },",
      "229:   \"BracketsFollowingPeriod\": {",
      "230:    reason: \"Brackets may not follow a period\",",
      "231:    path:   \"spec.containers.[0].name\",",
      "232:    want: want{",
      "233:     err: errors.New(\"unexpected '[' at position 16\"),",
      "234:    },",
      "235:   },",
      "236:   \"DoublePeriod\": {",
      "237:    reason: \"A path may not include two consecutive periods\",",
      "238:    path:   \"metadata..name\",",
      "239:    want: want{",
      "240:     err: errors.New(\"unexpected '.' at position 9\"),",
      "241:    },",
      "242:   },",
      "243:   \"DanglingRightBracket\": {",
      "244:    reason: \"A right bracket may not appear in a field name\",",
      "245:    path:   \"metadata.]name\",",
      "246:    want: want{",
      "247:     err: errors.New(\"unexpected ']' at position 9\"),",
      "248:    },",
      "249:   },",
      "250:   \"DoubleOpenBracket\": {",
      "251:    reason: \"Brackets may not be nested\",",
      "252:    path:   \"spec[bracketed[name]]\",",
      "253:    want: want{",
      "254:     err: errors.New(\"unexpected '[' at position 14\"),",
      "255:    },",
      "256:   },",
      "257:   \"DanglingLeftBracket\": {",
      "258:    reason: \"A left bracket must be closed\",",
      "259:    path:   \"spec[name\",",
      "260:    want: want{",
      "261:     err: errors.New(\"unterminated '[' at position 4\"),",
      "262:    },",
      "263:   },",
      "264:   \"EmptyBracket\": {",
      "265:    reason: \"Brackets may not be empty\",",
      "266:    path:   \"spec[]\",",
      "267:    want: want{",
      "268:     err: errors.New(\"unexpected ']' at position 5\"),",
      "269:    },",
      "270:   },",
      "271:  }",
      "272:  for name, tc := range cases {",
      "273:   t.Run(name, func(t *testing.T) {",
      "274:    got, err := Parse(tc.path)",
      "275:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "276:     t.Fatalf(\"\\nParse(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "277:    }",
      "278:    if diff := cmp.Diff(tc.want.s, got); diff != \"\" {",
      "279:     t.Errorf(\"\\nParse(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "280:    }",
      "281:   })",
      "282:  }",
      "283: }",
      "",
      "---------------"
    ],
    "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
      "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: Copyright 2019 The Crossplane Authors.",
      "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
      "5: you may not use this file except in compliance with the License.",
      "6: You may obtain a copy of the License at",
      "8:     http://www.apache.org/licenses/LICENSE-2.0",
      "10: Unless required by applicable law or agreed to in writing, software",
      "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
      "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
      "13: See the License for the specific language governing permissions and",
      "14: limitations under the License.",
      "17: package fieldpath",
      "19: import (",
      "20:  \"encoding/json\"",
      "22:  \"github.com/pkg/errors\"",
      "23: )",
      "26: type Paved struct {",
      "27:  object map[string]interface{}",
      "28: }",
      "31: func Pave(object map[string]interface{}) *Paved {",
      "32:  return &Paved{object: object}",
      "33: }",
      "36: func (p Paved) MarshalJSON() ([]byte, error) {",
      "37:  return json.Marshal(p.object)",
      "38: }",
      "41: func (p *Paved) UnmarshalJSON(data []byte) error {",
      "42:  return json.Unmarshal(data, &p.object)",
      "43: }",
      "45: func (p *Paved) getValue(s Segments) (interface{}, error) {",
      "46:  var it interface{} = p.object",
      "47:  for i, current := range s {",
      "48:   final := i == len(s)-1",
      "49:   switch current.Type {",
      "50:   case SegmentIndex:",
      "51:    array, ok := it.([]interface{})",
      "52:    if !ok {",
      "53:     return nil, errors.Errorf(\"%s: not an array\", s[:i])",
      "54:    }",
      "55:    if int(current.Index) >= len(array) {",
      "56:     return nil, errors.Errorf(\"%s: no such element\", s[:i+1])",
      "57:    }",
      "58:    if final {",
      "59:     return array[current.Index], nil",
      "60:    }",
      "61:    it = array[current.Index]",
      "63:   case SegmentField:",
      "64:    object, ok := it.(map[string]interface{})",
      "65:    if !ok {",
      "66:     return nil, errors.Errorf(\"%s: not an object\", s[:i])",
      "67:    }",
      "68:    v, ok := object[current.Field]",
      "69:    if !ok {",
      "70:     return nil, errors.Errorf(\"%s: no such field\", s[:i+1])",
      "71:    }",
      "72:    if final {",
      "73:     return v, nil",
      "74:    }",
      "75:    it = object[current.Field]",
      "76:   }",
      "77:  }",
      "80:  return nil, nil",
      "81: }",
      "84: func (p *Paved) GetValue(path string) (interface{}, error) {",
      "85:  segments, err := Parse(path)",
      "86:  if err != nil {",
      "87:   return nil, errors.Wrapf(err, \"cannot parse path %q\", path)",
      "88:  }",
      "90:  return p.getValue(segments)",
      "91: }",
      "94: func (p *Paved) GetString(path string) (string, error) {",
      "95:  v, err := p.GetValue(path)",
      "96:  if err != nil {",
      "97:   return \"\", err",
      "98:  }",
      "100:  s, ok := v.(string)",
      "101:  if !ok {",
      "102:   return \"\", errors.Errorf(\"%s: not a string\", path)",
      "103:  }",
      "104:  return s, nil",
      "105: }",
      "108: func (p *Paved) GetStringArray(path string) ([]string, error) {",
      "109:  v, err := p.GetValue(path)",
      "110:  if err != nil {",
      "111:   return nil, err",
      "112:  }",
      "114:  a, ok := v.([]interface{})",
      "115:  if !ok {",
      "116:   return nil, errors.Errorf(\"%s: not an array\", path)",
      "117:  }",
      "119:  sa := make([]string, len(a))",
      "120:  for i := range a {",
      "121:   s, ok := a[i].(string)",
      "122:   if !ok {",
      "123:    return nil, errors.Errorf(\"%s: not an array of strings\", path)",
      "124:   }",
      "125:   sa[i] = s",
      "126:  }",
      "128:  return sa, nil",
      "129: }",
      "132: func (p *Paved) GetStringObject(path string) (map[string]string, error) {",
      "133:  v, err := p.GetValue(path)",
      "134:  if err != nil {",
      "135:   return nil, err",
      "136:  }",
      "138:  o, ok := v.(map[string]interface{})",
      "139:  if !ok {",
      "140:   return nil, errors.Errorf(\"%s: not an object\", path)",
      "141:  }",
      "143:  so := make(map[string]string)",
      "144:  for k, in := range o {",
      "145:   s, ok := in.(string)",
      "146:   if !ok {",
      "147:    return nil, errors.Errorf(\"%s: not an object with string field values\", path)",
      "148:   }",
      "149:   so[k] = s",
      "151:  }",
      "153:  return so, nil",
      "154: }",
      "157: func (p *Paved) GetBool(path string) (bool, error) {",
      "158:  v, err := p.GetValue(path)",
      "159:  if err != nil {",
      "160:   return false, err",
      "161:  }",
      "163:  b, ok := v.(bool)",
      "164:  if !ok {",
      "165:   return false, errors.Errorf(\"%s: not a bool\", path)",
      "166:  }",
      "167:  return b, nil",
      "168: }",
      "171: func (p *Paved) GetNumber(path string) (float64, error) {",
      "172:  v, err := p.GetValue(path)",
      "173:  if err != nil {",
      "174:   return 0, err",
      "175:  }",
      "177:  f, ok := v.(float64)",
      "178:  if !ok {",
      "179:   return 0, errors.Errorf(\"%s: not a (float64) number\", path)",
      "180:  }",
      "181:  return f, nil",
      "182: }",
      "184: func (p *Paved) setValue(s Segments, value interface{}) error {",
      "185:  var in interface{} = p.object",
      "186:  for i, current := range s {",
      "187:   final := i == len(s)-1",
      "189:   switch current.Type {",
      "190:   case SegmentIndex:",
      "191:    array, ok := in.([]interface{})",
      "192:    if !ok {",
      "193:     return errors.Errorf(\"%s is not an array\", s[:i])",
      "194:    }",
      "196:    if final {",
      "197:     array[current.Index] = value",
      "198:     return nil",
      "199:    }",
      "201:    prepareElement(array, current, s[i+1])",
      "202:    in = array[current.Index]",
      "204:   case SegmentField:",
      "205:    object, ok := in.(map[string]interface{})",
      "206:    if !ok {",
      "207:     return errors.Errorf(\"%s is not an object\", s[:i])",
      "208:    }",
      "210:    if final {",
      "211:     object[current.Field] = value",
      "212:     return nil",
      "213:    }",
      "215:    prepareField(object, current, s[i+1])",
      "216:    in = object[current.Field]",
      "217:   }",
      "218:  }",
      "220:  return nil",
      "221: }",
      "223: func prepareElement(array []interface{}, current, next Segment) {",
      "226:  if array[current.Index] == nil {",
      "227:   switch next.Type {",
      "228:   case SegmentIndex:",
      "229:    array[current.Index] = make([]interface{}, next.Index+1)",
      "230:   case SegmentField:",
      "231:    array[current.Index] = make(map[string]interface{})",
      "232:   }",
      "233:   return",
      "234:  }",
      "238:  if next.Type != SegmentIndex {",
      "239:   return",
      "240:  }",
      "242:  na, ok := array[current.Index].([]interface{})",
      "243:  if !ok {",
      "244:   return",
      "245:  }",
      "247:  if int(next.Index) < len(na) {",
      "248:   return",
      "249:  }",
      "251:  array[current.Index] = append(na, make([]interface{}, int(next.Index)-len(na)+1)...)",
      "252: }",
      "254: func prepareField(object map[string]interface{}, current, next Segment) {",
      "257:  if _, ok := object[current.Field]; !ok {",
      "258:   switch next.Type {",
      "259:   case SegmentIndex:",
      "260:    object[current.Field] = make([]interface{}, next.Index+1)",
      "261:   case SegmentField:",
      "262:    object[current.Field] = make(map[string]interface{})",
      "263:   }",
      "264:   return",
      "265:  }",
      "269:  if next.Type != SegmentIndex {",
      "270:   return",
      "271:  }",
      "273:  na, ok := object[current.Field].([]interface{})",
      "274:  if !ok {",
      "275:   return",
      "276:  }",
      "278:  if int(next.Index) < len(na) {",
      "279:   return",
      "280:  }",
      "282:  object[current.Field] = append(na, make([]interface{}, int(next.Index)-len(na)+1)...)",
      "283: }",
      "286: func (p *Paved) SetValue(path string, value interface{}) error {",
      "287:  segments, err := Parse(path)",
      "288:  if err != nil {",
      "289:   return errors.Wrapf(err, \"cannot parse path %q\", path)",
      "290:  }",
      "291:  return p.setValue(segments, value)",
      "292: }",
      "295: func (p *Paved) SetString(path, value string) error {",
      "296:  return p.SetValue(path, value)",
      "297: }",
      "300: func (p *Paved) SetBool(path string, value bool) error {",
      "301:  return p.SetValue(path, value)",
      "302: }",
      "305: func (p *Paved) SetNumber(path string, value float64) error {",
      "306:  return p.SetValue(path, value)",
      "307: }",
      "",
      "---------------"
    ],
    "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go": [
      "File: pkg/fieldpath/paved_test.go -> pkg/fieldpath/paved_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: Copyright 2019 The Crossplane Authors.",
      "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
      "5: you may not use this file except in compliance with the License.",
      "6: You may obtain a copy of the License at",
      "8:     http://www.apache.org/licenses/LICENSE-2.0",
      "10: Unless required by applicable law or agreed to in writing, software",
      "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
      "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
      "13: See the License for the specific language governing permissions and",
      "14: limitations under the License.",
      "17: package fieldpath",
      "19: import (",
      "20:  \"encoding/json\"",
      "21:  \"testing\"",
      "23:  \"github.com/google/go-cmp/cmp\"",
      "24:  \"github.com/pkg/errors\"",
      "26:  \"github.com/crossplane/crossplane-runtime/pkg/test\"",
      "27: )",
      "29: func TestGetValue(t *testing.T) {",
      "30:  type want struct {",
      "31:   value interface{}",
      "32:   err   error",
      "33:  }",
      "34:  cases := map[string]struct {",
      "35:   reason string",
      "36:   path   string",
      "37:   data   []byte",
      "38:   want   want",
      "39:  }{",
      "40:   \"MetadataName\": {",
      "41:    reason: \"It should be possible to get a field from a nested object\",",
      "42:    path:   \"metadata.name\",",
      "43:    data:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),",
      "44:    want: want{",
      "45:     value: \"cool\",",
      "46:    },",
      "47:   },",
      "48:   \"ContainerName\": {",
      "49:    reason: \"It should be possible to get a field from an object array element\",",
      "50:    path:   \"spec.containers[0].name\",",
      "51:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),",
      "52:    want: want{",
      "53:     value: \"cool\",",
      "54:    },",
      "55:   },",
      "56:   \"NestedArray\": {",
      "57:    reason: \"It should be possible to get a field from a nested array\",",
      "58:    path:   \"items[0][1]\",",
      "59:    data:   []byte(`{\"items\":[[\"a\", \"b\"]]}`),",
      "60:    want: want{",
      "61:     value: \"b\",",
      "62:    },",
      "63:   },",
      "64:   \"OwnerRefController\": {",
      "65:    reason: \"Requesting a boolean field path should work.\",",
      "66:    path:   \"metadata.ownerRefs[0].controller\",",
      "67:    data:   []byte(`{\"metadata\":{\"ownerRefs\":[{\"controller\": true}]}}`),",
      "68:    want: want{",
      "69:     value: true,",
      "70:    },",
      "71:   },",
      "72:   \"MetadataVersion\": {",
      "73:    reason: \"Requesting a number field should work\",",
      "74:    path:   \"metadata.version\",",
      "75:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
      "76:    want: want{",
      "77:     value: float64(2),",
      "78:    },",
      "79:   },",
      "80:   \"MetadataNope\": {",
      "81:    reason: \"Requesting a non-existent object field should fail\",",
      "82:    path:   \"metadata.name\",",
      "83:    data:   []byte(`{\"metadata\":{\"nope\":\"cool\"}}`),",
      "84:    want: want{",
      "85:     err: errors.New(\"metadata.name: no such field\"),",
      "86:    },",
      "87:   },",
      "88:   \"InsufficientContainers\": {",
      "89:    reason: \"Requesting a non-existent array element should fail\",",
      "90:    path:   \"spec.containers[1].name\",",
      "91:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),",
      "92:    want: want{",
      "93:     err: errors.New(\"spec.containers[1]: no such element\"),",
      "94:    },",
      "95:   },",
      "96:   \"NotAnArray\": {",
      "97:    reason: \"Indexing an object should fail\",",
      "98:    path:   \"metadata[1]\",",
      "99:    data:   []byte(`{\"metadata\":{\"nope\":\"cool\"}}`),",
      "100:    want: want{",
      "101:     err: errors.New(\"metadata: not an array\"),",
      "102:    },",
      "103:   },",
      "104:   \"NotAnObject\": {",
      "105:    reason: \"Requesting a field in an array should fail\",",
      "106:    path:   \"spec.containers[nope].name\",",
      "107:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),",
      "108:    want: want{",
      "109:     err: errors.New(\"spec.containers: not an object\"),",
      "110:    },",
      "111:   },",
      "112:   \"MalformedPath\": {",
      "113:    reason: \"Requesting an invalid field path should fail\",",
      "114:    path:   \"spec[]\",",
      "115:    want: want{",
      "116:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "117:    },",
      "118:   },",
      "119:  }",
      "121:  for name, tc := range cases {",
      "122:   t.Run(name, func(t *testing.T) {",
      "123:    in := make(map[string]interface{})",
      "124:    _ = json.Unmarshal(tc.data, &in)",
      "125:    p := Pave(in)",
      "127:    got, err := p.GetValue(tc.path)",
      "128:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "129:     t.Fatalf(\"\\np.GetValue(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "130:    }",
      "131:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "132:     t.Errorf(\"\\np.GetValue(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "133:    }",
      "134:   })",
      "135:  }",
      "136: }",
      "138: func TestGetString(t *testing.T) {",
      "139:  type want struct {",
      "140:   value string",
      "141:   err   error",
      "142:  }",
      "143:  cases := map[string]struct {",
      "144:   reason string",
      "145:   path   string",
      "146:   data   []byte",
      "147:   want   want",
      "148:  }{",
      "149:   \"MetadataName\": {",
      "150:    reason: \"It should be possible to get a field from a nested object\",",
      "151:    path:   \"metadata.name\",",
      "152:    data:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),",
      "153:    want: want{",
      "154:     value: \"cool\",",
      "155:    },",
      "156:   },",
      "157:   \"MalformedPath\": {",
      "158:    reason: \"Requesting an invalid field path should fail\",",
      "159:    path:   \"spec[]\",",
      "160:    want: want{",
      "161:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "162:    },",
      "163:   },",
      "164:   \"NotAString\": {",
      "165:    reason: \"Requesting an non-string field path should fail\",",
      "166:    path:   \"metadata.version\",",
      "167:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
      "168:    want: want{",
      "169:     err: errors.New(\"metadata.version: not a string\"),",
      "170:    },",
      "171:   },",
      "172:  }",
      "174:  for name, tc := range cases {",
      "175:   t.Run(name, func(t *testing.T) {",
      "176:    in := make(map[string]interface{})",
      "177:    _ = json.Unmarshal(tc.data, &in)",
      "178:    p := Pave(in)",
      "180:    got, err := p.GetString(tc.path)",
      "181:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "182:     t.Fatalf(\"\\np.GetString(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "183:    }",
      "184:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "185:     t.Errorf(\"\\np.GetString(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "186:    }",
      "187:   })",
      "188:  }",
      "189: }",
      "191: func TestGetStringArray(t *testing.T) {",
      "192:  type want struct {",
      "193:   value []string",
      "194:   err   error",
      "195:  }",
      "196:  cases := map[string]struct {",
      "197:   reason string",
      "198:   path   string",
      "199:   data   []byte",
      "200:   want   want",
      "201:  }{",
      "202:   \"MetadataLabels\": {",
      "203:    reason: \"It should be possible to get a field from a nested object\",",
      "204:    path:   \"spec.containers[0].command\",",
      "205:    data:   []byte(`{\"spec\": {\"containers\": [{\"command\": [\"/bin/bash\"]}]}}`),",
      "206:    want: want{",
      "207:     value: []string{\"/bin/bash\"},",
      "208:    },",
      "209:   },",
      "210:   \"MalformedPath\": {",
      "211:    reason: \"Requesting an invalid field path should fail\",",
      "212:    path:   \"spec[]\",",
      "213:    want: want{",
      "214:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "215:    },",
      "216:   },",
      "217:   \"NotAnArray\": {",
      "218:    reason: \"Requesting an non-object field path should fail\",",
      "219:    path:   \"metadata.version\",",
      "220:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
      "221:    want: want{",
      "222:     err: errors.New(\"metadata.version: not an array\"),",
      "223:    },",
      "224:   },",
      "225:   \"NotAStringArray\": {",
      "226:    reason: \"Requesting an non-string-object field path should fail\",",
      "227:    path:   \"metadata.versions\",",
      "228:    data:   []byte(`{\"metadata\":{\"versions\":[1,2]}}`),",
      "229:    want: want{",
      "230:     err: errors.New(\"metadata.versions: not an array of strings\"),",
      "231:    },",
      "232:   },",
      "233:  }",
      "235:  for name, tc := range cases {",
      "236:   t.Run(name, func(t *testing.T) {",
      "237:    in := make(map[string]interface{})",
      "238:    _ = json.Unmarshal(tc.data, &in)",
      "239:    p := Pave(in)",
      "241:    got, err := p.GetStringArray(tc.path)",
      "242:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "243:     t.Fatalf(\"\\np.GetStringArray(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "244:    }",
      "245:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "246:     t.Errorf(\"\\np.GetStringArray(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "247:    }",
      "248:   })",
      "249:  }",
      "250: }",
      "252: func TestGetStringObject(t *testing.T) {",
      "253:  type want struct {",
      "254:   value map[string]string",
      "255:   err   error",
      "256:  }",
      "257:  cases := map[string]struct {",
      "258:   reason string",
      "259:   path   string",
      "260:   data   []byte",
      "261:   want   want",
      "262:  }{",
      "263:   \"MetadataLabels\": {",
      "264:    reason: \"It should be possible to get a field from a nested object\",",
      "265:    path:   \"metadata.labels\",",
      "266:    data:   []byte(`{\"metadata\":{\"labels\":{\"cool\":\"true\"}}}`),",
      "267:    want: want{",
      "268:     value: map[string]string{\"cool\": \"true\"},",
      "269:    },",
      "270:   },",
      "271:   \"MalformedPath\": {",
      "272:    reason: \"Requesting an invalid field path should fail\",",
      "273:    path:   \"spec[]\",",
      "274:    want: want{",
      "275:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "276:    },",
      "277:   },",
      "278:   \"NotAnObject\": {",
      "279:    reason: \"Requesting an non-object field path should fail\",",
      "280:    path:   \"metadata.version\",",
      "281:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
      "282:    want: want{",
      "283:     err: errors.New(\"metadata.version: not an object\"),",
      "284:    },",
      "285:   },",
      "286:   \"NotAStringObject\": {",
      "287:    reason: \"Requesting an non-string-object field path should fail\",",
      "288:    path:   \"metadata.versions\",",
      "289:    data:   []byte(`{\"metadata\":{\"versions\":{\"a\": 2}}}`),",
      "290:    want: want{",
      "291:     err: errors.New(\"metadata.versions: not an object with string field values\"),",
      "292:    },",
      "293:   },",
      "294:  }",
      "296:  for name, tc := range cases {",
      "297:   t.Run(name, func(t *testing.T) {",
      "298:    in := make(map[string]interface{})",
      "299:    _ = json.Unmarshal(tc.data, &in)",
      "300:    p := Pave(in)",
      "302:    got, err := p.GetStringObject(tc.path)",
      "303:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "304:     t.Fatalf(\"\\np.GetStringObject(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "305:    }",
      "306:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "307:     t.Errorf(\"\\np.GetStringObject(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "308:    }",
      "309:   })",
      "310:  }",
      "311: }",
      "313: func TestGetBool(t *testing.T) {",
      "314:  type want struct {",
      "315:   value bool",
      "316:   err   error",
      "317:  }",
      "318:  cases := map[string]struct {",
      "319:   reason string",
      "320:   path   string",
      "321:   data   []byte",
      "322:   want   want",
      "323:  }{",
      "324:   \"OwnerRefController\": {",
      "325:    reason: \"Requesting a boolean field path should work.\",",
      "326:    path:   \"metadata.ownerRefs[0].controller\",",
      "327:    data:   []byte(`{\"metadata\":{\"ownerRefs\":[{\"controller\": true}]}}`),",
      "328:    want: want{",
      "329:     value: true,",
      "330:    },",
      "331:   },",
      "332:   \"MalformedPath\": {",
      "333:    reason: \"Requesting an invalid field path should fail\",",
      "334:    path:   \"spec[]\",",
      "335:    want: want{",
      "336:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "337:    },",
      "338:   },",
      "339:   \"NotABool\": {",
      "340:    reason: \"Requesting an non-boolean field path should fail\",",
      "341:    path:   \"metadata.name\",",
      "342:    data:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),",
      "343:    want: want{",
      "344:     err: errors.New(\"metadata.name: not a bool\"),",
      "345:    },",
      "346:   },",
      "347:  }",
      "349:  for name, tc := range cases {",
      "350:   t.Run(name, func(t *testing.T) {",
      "351:    in := make(map[string]interface{})",
      "352:    _ = json.Unmarshal(tc.data, &in)",
      "353:    p := Pave(in)",
      "355:    got, err := p.GetBool(tc.path)",
      "356:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "357:     t.Fatalf(\"\\np.GetBool(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "358:    }",
      "359:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "360:     t.Errorf(\"\\np.GetBool(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "361:    }",
      "362:   })",
      "363:  }",
      "364: }",
      "366: func TestGetNumber(t *testing.T) {",
      "367:  type want struct {",
      "368:   value float64",
      "369:   err   error",
      "370:  }",
      "371:  cases := map[string]struct {",
      "372:   reason string",
      "373:   path   string",
      "374:   data   []byte",
      "375:   want   want",
      "376:  }{",
      "377:   \"MetadataVersion\": {",
      "378:    reason: \"Requesting a number field should work\",",
      "379:    path:   \"metadata.version\",",
      "380:    data:   []byte(`{\"metadata\":{\"version\":2}}`),",
      "381:    want: want{",
      "382:     value: 2,",
      "383:    },",
      "384:   },",
      "385:   \"MalformedPath\": {",
      "386:    reason: \"Requesting an invalid field path should fail\",",
      "387:    path:   \"spec[]\",",
      "388:    want: want{",
      "389:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "390:    },",
      "391:   },",
      "392:   \"NotANumber\": {",
      "393:    reason: \"Requesting an non-number field path should fail\",",
      "394:    path:   \"metadata.name\",",
      "395:    data:   []byte(`{\"metadata\":{\"name\":\"cool\"}}`),",
      "396:    want: want{",
      "397:     err: errors.New(\"metadata.name: not a (float64) number\"),",
      "398:    },",
      "399:   },",
      "400:  }",
      "402:  for name, tc := range cases {",
      "403:   t.Run(name, func(t *testing.T) {",
      "404:    in := make(map[string]interface{})",
      "405:    _ = json.Unmarshal(tc.data, &in)",
      "406:    p := Pave(in)",
      "408:    got, err := p.GetNumber(tc.path)",
      "409:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "410:     t.Fatalf(\"\\np.GetNumber(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)",
      "411:    }",
      "412:    if diff := cmp.Diff(tc.want.value, got); diff != \"\" {",
      "413:     t.Errorf(\"\\np.GetNumber(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)",
      "414:    }",
      "415:   })",
      "416:  }",
      "417: }",
      "419: func TestSetValue(t *testing.T) {",
      "420:  type args struct {",
      "421:   path  string",
      "422:   value interface{}",
      "423:  }",
      "424:  type want struct {",
      "425:   object map[string]interface{}",
      "426:   err    error",
      "427:  }",
      "428:  cases := map[string]struct {",
      "429:   reason string",
      "430:   data   []byte",
      "431:   args   args",
      "432:   want   want",
      "433:  }{",
      "434:   \"MetadataName\": {",
      "435:    reason: \"Setting an object field should work\",",
      "436:    data:   []byte(`{\"metadata\":{\"name\":\"lame\"}}`),",
      "437:    args: args{",
      "438:     path:  \"metadata.name\",",
      "439:     value: \"cool\",",
      "440:    },",
      "441:    want: want{",
      "442:     object: map[string]interface{}{",
      "443:      \"metadata\": map[string]interface{}{",
      "444:       \"name\": \"cool\",",
      "445:      },",
      "446:     },",
      "447:    },",
      "448:   },",
      "449:   \"NonExistentMetadataName\": {",
      "450:    reason: \"Setting a non-existent object field should work\",",
      "451:    data:   []byte(`{}`),",
      "452:    args: args{",
      "453:     path:  \"metadata.name\",",
      "454:     value: \"cool\",",
      "455:    },",
      "456:    want: want{",
      "457:     object: map[string]interface{}{",
      "458:      \"metadata\": map[string]interface{}{",
      "459:       \"name\": \"cool\",",
      "460:      },",
      "461:     },",
      "462:    },",
      "463:   },",
      "464:   \"ContainerName\": {",
      "465:    reason: \"Setting a field of an object that is an array element should work\",",
      "466:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"lame\"}]}}`),",
      "467:    args: args{",
      "468:     path:  \"spec.containers[0].name\",",
      "469:     value: \"cool\",",
      "470:    },",
      "471:    want: want{",
      "472:     object: map[string]interface{}{",
      "473:      \"spec\": map[string]interface{}{",
      "474:       \"containers\": []interface{}{",
      "475:        map[string]interface{}{",
      "476:         \"name\": \"cool\",",
      "477:        },",
      "478:       },",
      "479:      },",
      "480:     },",
      "481:    },",
      "482:   },",
      "483:   \"NonExistentContainerName\": {",
      "484:    reason: \"Setting a field of a non-existent object that is an array element should work\",",
      "485:    data:   []byte(`{}`),",
      "486:    args: args{",
      "487:     path:  \"spec.containers[0].name\",",
      "488:     value: \"cool\",",
      "489:    },",
      "490:    want: want{",
      "491:     object: map[string]interface{}{",
      "492:      \"spec\": map[string]interface{}{",
      "493:       \"containers\": []interface{}{",
      "494:        map[string]interface{}{",
      "495:         \"name\": \"cool\",",
      "496:        },",
      "497:       },",
      "498:      },",
      "499:     },",
      "500:    },",
      "501:   },",
      "502:   \"NewContainer\": {",
      "503:    reason: \"Growing an array object field should work\",",
      "504:    data:   []byte(`{\"spec\":{\"containers\":[{\"name\":\"cool\"}]}}`),",
      "505:    args: args{",
      "506:     path:  \"spec.containers[1].name\",",
      "507:     value: \"cooler\",",
      "508:    },",
      "509:    want: want{",
      "510:     object: map[string]interface{}{",
      "511:      \"spec\": map[string]interface{}{",
      "512:       \"containers\": []interface{}{",
      "513:        map[string]interface{}{",
      "514:         \"name\": \"cool\",",
      "515:        },",
      "516:        map[string]interface{}{",
      "517:         \"name\": \"cooler\",",
      "518:        },",
      "519:       },",
      "520:      },",
      "521:     },",
      "522:    },",
      "523:   },",
      "524:   \"NestedArray\": {",
      "525:    reason: \"Setting a value in a nested array should work\",",
      "526:    data:   []byte(`{}`),",
      "527:    args: args{",
      "528:     path:  \"data[0][0]\",",
      "529:     value: \"a\",",
      "530:    },",
      "531:    want: want{",
      "532:     object: map[string]interface{}{",
      "533:      \"data\": []interface{}{",
      "534:       []interface{}{\"a\"},",
      "535:      },",
      "536:     },",
      "537:    },",
      "538:   },",
      "539:   \"GrowNestedArray\": {",
      "540:    reason: \"Growing then setting a value in a nested array should work\",",
      "541:    data:   []byte(`{\"data\":[[\"a\"]]}`),",
      "542:    args: args{",
      "543:     path:  \"data[0][1]\",",
      "544:     value: \"b\",",
      "545:    },",
      "546:    want: want{",
      "547:     object: map[string]interface{}{",
      "548:      \"data\": []interface{}{",
      "549:       []interface{}{\"a\", \"b\"},",
      "550:      },",
      "551:     },",
      "552:    },",
      "553:   },",
      "554:   \"GrowArrayField\": {",
      "555:    reason: \"Growing then setting a value in an array field should work\",",
      "556:    data:   []byte(`{\"data\":[\"a\"]}`),",
      "557:    args: args{",
      "558:     path:  \"data[2]\",",
      "559:     value: \"c\",",
      "560:    },",
      "561:    want: want{",
      "562:     object: map[string]interface{}{",
      "563:      \"data\": []interface{}{\"a\", nil, \"c\"},",
      "564:     },",
      "565:    },",
      "566:   },",
      "567:   \"NotAnArray\": {",
      "568:    reason: \"Indexing an object field should fail\",",
      "569:    data:   []byte(`{\"data\":{}}`),",
      "570:    args: args{",
      "571:     path: \"data[0]\",",
      "572:    },",
      "573:    want: want{",
      "574:     object: map[string]interface{}{\"data\": map[string]interface{}{}},",
      "575:     err:    errors.New(\"data is not an array\"),",
      "576:    },",
      "577:   },",
      "578:   \"NotAnObject\": {",
      "579:    reason: \"Requesting a field in an array should fail\",",
      "580:    data:   []byte(`{\"data\":[]}`),",
      "581:    args: args{",
      "582:     path: \"data.name\",",
      "583:    },",
      "584:    want: want{",
      "585:     object: map[string]interface{}{\"data\": []interface{}{}},",
      "586:     err:    errors.New(\"data is not an object\"),",
      "587:    },",
      "588:   },",
      "589:   \"MalformedPath\": {",
      "590:    reason: \"Requesting an invalid field path should fail\",",
      "591:    args: args{",
      "592:     path: \"spec[]\",",
      "593:    },",
      "594:    want: want{",
      "595:     object: map[string]interface{}{},",
      "596:     err:    errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
      "597:    },",
      "598:   },",
      "599:  }",
      "601:  for name, tc := range cases {",
      "602:   t.Run(name, func(t *testing.T) {",
      "603:    in := make(map[string]interface{})",
      "604:    _ = json.Unmarshal(tc.data, &in)",
      "605:    p := Pave(in)",
      "607:    err := p.SetValue(tc.args.path, tc.args.value)",
      "608:    if diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {",
      "609:     t.Fatalf(\"\\np.SetValue(%s, %v): %s: -want error, +got error:\\n%s\", tc.args.path, tc.args.value, tc.reason, diff)",
      "610:    }",
      "611:    if diff := cmp.Diff(tc.want.object, p.object); diff != \"\" {",
      "612:     t.Fatalf(\"\\np.SetValue(%s, %v): %s: -want, +got:\\n%s\", tc.args.path, tc.args.value, tc.reason, diff)",
      "613:    }",
      "614:   })",
      "615:  }",
      "616: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f0fcbc0af5cb3e9270ddf07e124fca7f0fb9ab1f",
      "candidate_info": {
        "commit_hash": "f0fcbc0af5cb3e9270ddf07e124fca7f0fb9ab1f",
        "repo": "crossplane/crossplane-runtime",
        "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/f0fcbc0af5cb3e9270ddf07e124fca7f0fb9ab1f",
        "files": [
          ".golangci.yml",
          "Makefile",
          "pkg/connection/fake/mocks.go",
          "pkg/connection/manager.go",
          "pkg/connection/store/kubernetes/store.go",
          "pkg/connection/store/store.go",
          "pkg/connection/store/vault/fake/mocks.go",
          "pkg/connection/store/vault/kv/fake/mocks.go",
          "pkg/connection/store/vault/kv/secret.go",
          "pkg/connection/store/vault/store.go",
          "pkg/errors/errors.go",
          "pkg/fieldpath/fieldpath.go",
          "pkg/fieldpath/paved.go",
          "pkg/logging/logging.go",
          "pkg/meta/meta.go",
          "pkg/parser/parser.go",
          "pkg/reconciler/managed/reconciler.go",
          "pkg/reconciler/providerconfig/reconciler.go",
          "pkg/reference/reference.go",
          "pkg/resource/fake/mocks.go",
          "pkg/resource/providerconfig.go",
          "pkg/resource/resource.go",
          "pkg/test/integration/crd.go",
          "pkg/test/integration/remote.go",
          "pkg/test/integration/server.go",
          "pkg/webhook/mutator.go"
        ],
        "message": "Update linter config to match c/c\n\nThis repo is a little out of date relative to our latest linting\npractices.\n\nSigned-off-by: Nic Cope <nicc@rk0n.org>",
        "before_after_code_files": [
          "pkg/connection/fake/mocks.go||pkg/connection/fake/mocks.go",
          "pkg/connection/manager.go||pkg/connection/manager.go",
          "pkg/connection/store/kubernetes/store.go||pkg/connection/store/kubernetes/store.go",
          "pkg/connection/store/store.go||pkg/connection/store/store.go",
          "pkg/connection/store/vault/fake/mocks.go||pkg/connection/store/vault/fake/mocks.go",
          "pkg/connection/store/vault/kv/fake/mocks.go||pkg/connection/store/vault/kv/fake/mocks.go",
          "pkg/connection/store/vault/kv/secret.go||pkg/connection/store/vault/kv/secret.go",
          "pkg/connection/store/vault/store.go||pkg/connection/store/vault/store.go",
          "pkg/errors/errors.go||pkg/errors/errors.go",
          "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go",
          "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
          "pkg/logging/logging.go||pkg/logging/logging.go",
          "pkg/meta/meta.go||pkg/meta/meta.go",
          "pkg/parser/parser.go||pkg/parser/parser.go",
          "pkg/reconciler/managed/reconciler.go||pkg/reconciler/managed/reconciler.go",
          "pkg/reconciler/providerconfig/reconciler.go||pkg/reconciler/providerconfig/reconciler.go",
          "pkg/reference/reference.go||pkg/reference/reference.go",
          "pkg/resource/fake/mocks.go||pkg/resource/fake/mocks.go",
          "pkg/resource/providerconfig.go||pkg/resource/providerconfig.go",
          "pkg/resource/resource.go||pkg/resource/resource.go",
          "pkg/test/integration/crd.go||pkg/test/integration/crd.go",
          "pkg/test/integration/remote.go||pkg/test/integration/remote.go",
          "pkg/test/integration/server.go||pkg/test/integration/server.go",
          "pkg/webhook/mutator.go||pkg/webhook/mutator.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go",
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go"
          ],
          "candidate": [
            "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go",
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go"
          ]
        }
      },
      "candidate_diff": {
        "pkg/connection/fake/mocks.go||pkg/connection/fake/mocks.go": [
          "File: pkg/connection/fake/mocks.go -> pkg/connection/fake/mocks.go"
        ],
        "pkg/connection/manager.go||pkg/connection/manager.go": [
          "File: pkg/connection/manager.go -> pkg/connection/manager.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "142: }",
          "",
          "[Removed Lines]",
          "145: func (m *DetailsManager) PropagateConnection(ctx context.Context, to resource.LocalConnectionSecretOwner, from resource.ConnectionSecretOwner) (propagated bool, err error) { // nolint:interfacer",
          "",
          "[Added Lines]",
          "146: func (m *DetailsManager) PropagateConnection(ctx context.Context, to resource.LocalConnectionSecretOwner, from resource.ConnectionSecretOwner) (propagated bool, err error) { //nolint:interfacer // See note below.",
          "",
          "---------------"
        ],
        "pkg/connection/store/kubernetes/store.go||pkg/connection/store/kubernetes/store.go": [
          "File: pkg/connection/store/kubernetes/store.go -> pkg/connection/store/kubernetes/store.go"
        ],
        "pkg/connection/store/store.go||pkg/connection/store/store.go": [
          "File: pkg/connection/store/store.go -> pkg/connection/store/store.go"
        ],
        "pkg/connection/store/vault/fake/mocks.go||pkg/connection/store/vault/fake/mocks.go": [
          "File: pkg/connection/store/vault/fake/mocks.go -> pkg/connection/store/vault/fake/mocks.go"
        ],
        "pkg/connection/store/vault/kv/fake/mocks.go||pkg/connection/store/vault/kv/fake/mocks.go": [
          "File: pkg/connection/store/vault/kv/fake/mocks.go -> pkg/connection/store/vault/kv/fake/mocks.go"
        ],
        "pkg/connection/store/vault/kv/secret.go||pkg/connection/store/vault/kv/secret.go": [
          "File: pkg/connection/store/vault/kv/secret.go -> pkg/connection/store/vault/kv/secret.go"
        ],
        "pkg/connection/store/vault/store.go||pkg/connection/store/vault/store.go": [
          "File: pkg/connection/store/vault/store.go -> pkg/connection/store/vault/store.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "63: }",
          "",
          "[Removed Lines]",
          "66: func NewSecretStore(ctx context.Context, kube client.Client, cfg v1.SecretStoreConfig) (*SecretStore, error) { // nolint: gocyclo",
          "",
          "[Added Lines]",
          "67: func NewSecretStore(ctx context.Context, kube client.Client, cfg v1.SecretStoreConfig) (*SecretStore, error) { //nolint: gocyclo // See note below.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "136: }",
          "141:  ao = append(ao, kv.AllowUpdateIf(func(current, desired *kv.Secret) bool {",
          "142:   return !cmp.Equal(current, desired, cmpopts.EquateEmpty(), cmpopts.IgnoreUnexported(kv.Secret{}))",
          "143:  }))",
          "",
          "[Removed Lines]",
          "139: func (ss *SecretStore) WriteKeyValues(_ context.Context, s *store.Secret, wo ...store.WriteOption) (changed bool, err error) {",
          "140:  ao := applyOptions(wo...)",
          "",
          "[Added Lines]",
          "140: func (ss *SecretStore) WriteKeyValues(ctx context.Context, s *store.Secret, wo ...store.WriteOption) (changed bool, err error) {",
          "141:  ao := applyOptions(ctx, wo...)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "161:  Secret := &kv.Secret{}",
          "162:  err := ss.client.Get(ss.path(s.ScopedName), Secret)",
          "163:  if kv.IsNotFound(err) {",
          "",
          "[Removed Lines]",
          "160: func (ss *SecretStore) DeleteKeyValues(_ context.Context, s *store.Secret, do ...store.DeleteOption) error {",
          "",
          "[Added Lines]",
          "161: func (ss *SecretStore) DeleteKeyValues(ctx context.Context, s *store.Secret, do ...store.DeleteOption) error {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "169:  }",
          "171:  for _, o := range do {",
          "173:    return err",
          "174:   }",
          "175:  }",
          "",
          "[Removed Lines]",
          "172:   if err = o(context.Background(), s); err != nil {",
          "",
          "[Added Lines]",
          "173:   if err = o(ctx, s); err != nil {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "194:  return filepath.Join(ss.defaultParentPath, s.Name)",
          "195: }",
          "198:  ao := make([]kv.ApplyOption, len(wo))",
          "199:  for i := range wo {",
          "200:   o := wo[i]",
          "",
          "[Removed Lines]",
          "197: func applyOptions(wo ...store.WriteOption) []kv.ApplyOption {",
          "",
          "[Added Lines]",
          "198: func applyOptions(ctx context.Context, wo ...store.WriteOption) []kv.ApplyOption {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "211:     },",
          "212:     Data: keyValuesFromData(desired.Data),",
          "213:    }",
          "215:     return err",
          "216:    }",
          "217:    desired.CustomMeta = ds.GetLabels()",
          "",
          "[Removed Lines]",
          "214:    if err := o(context.Background(), cs, ds); err != nil {",
          "",
          "[Added Lines]",
          "215:    if err := o(ctx, cs, ds); err != nil {",
          "",
          "---------------"
        ],
        "pkg/errors/errors.go||pkg/errors/errors.go": [
          "File: pkg/errors/errors.go -> pkg/errors/errors.go"
        ],
        "pkg/fieldpath/fieldpath.go||pkg/fieldpath/fieldpath.go": [
          "File: pkg/fieldpath/fieldpath.go -> pkg/fieldpath/fieldpath.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "122:  segments := make(Segments, 0, 1)",
          "123:  for i := range l.items {",
          "126:   case itemField:",
          "127:    segments = append(segments, Field(i.val))",
          "128:   case itemFieldOrIndex:",
          "",
          "[Removed Lines]",
          "125:   switch i.typ { // nolint:exhaustive",
          "",
          "[Added Lines]",
          "124:   switch i.typ { //nolint:exhaustive // We're only worried about names, not separators.",
          "",
          "---------------"
        ],
        "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
          "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "149:  return paths, nil",
          "150: }",
          "156:  var res []Segments",
          "157:  it := data",
          "158:  for i, current := range segments {",
          "",
          "[Removed Lines]",
          "155: func expandWildcards(data any, segments Segments) ([]Segments, error) { //nolint:gocyclo",
          "",
          "[Added Lines]",
          "152: func expandWildcards(data any, segments Segments) ([]Segments, error) { //nolint:gocyclo // See note below.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "485:  return p.delete(segments)",
          "486: }",
          "491:  if len(segments) == 1 {",
          "",
          "[Removed Lines]",
          "488: func (p *Paved) delete(segments Segments) error { // nolint:gocyclo",
          "",
          "[Added Lines]",
          "487: func (p *Paved) delete(segments Segments) error { //nolint:gocyclo // See note below.",
          "",
          "---------------"
        ],
        "pkg/logging/logging.go||pkg/logging/logging.go": [
          "File: pkg/logging/logging.go -> pkg/logging/logging.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "82: }",
          "84: func (l logrLogger) Info(msg string, keysAndValues ...any) {",
          "86: }",
          "88: func (l logrLogger) Debug(msg string, keysAndValues ...any) {",
          "90: }",
          "92: func (l logrLogger) WithValues(keysAndValues ...any) Logger {",
          "94: }",
          "",
          "[Removed Lines]",
          "85:  l.log.Info(msg, keysAndValues...)",
          "89:  l.log.V(1).Info(msg, keysAndValues...)",
          "93:  return logrLogger{log: l.log.WithValues(keysAndValues...)}",
          "",
          "[Added Lines]",
          "85:  l.log.Info(msg, keysAndValues...) //nolint:logrlint // False positive - logrlint thinks there's an odd number of args.",
          "89:  l.log.V(1).Info(msg, keysAndValues...) //nolint:logrlint // False positive - logrlint thinks there's an odd number of args.",
          "93:  return logrLogger{log: l.log.WithValues(keysAndValues...)} //nolint:logrlint // False positive - logrlint thinks there's an odd number of args.",
          "",
          "---------------"
        ],
        "pkg/meta/meta.go||pkg/meta/meta.go": [
          "File: pkg/meta/meta.go -> pkg/meta/meta.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "384: func AnnotationKeyPropagateTo(o metav1.Object) string {",
          "386:  h := fnv.New32a()",
          "389:  return fmt.Sprintf(\"%s%x\", AnnotationKeyPropagateToPrefix, h.Sum32())",
          "390: }",
          "",
          "[Removed Lines]",
          "387:  h.Write([]byte(o.GetNamespace())) // nolint:errcheck",
          "388:  h.Write([]byte(o.GetName()))      // nolint:errcheck",
          "",
          "[Added Lines]",
          "387:  h.Write([]byte(o.GetNamespace()))",
          "388:  h.Write([]byte(o.GetName()))",
          "",
          "---------------"
        ],
        "pkg/parser/parser.go||pkg/parser/parser.go": [
          "File: pkg/parser/parser.go -> pkg/parser/parser.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: limitations under the License.",
          "17: package parser",
          "19: import (",
          "20:  \"bufio\"",
          "21:  \"context\"",
          "22:  \"io\"",
          "24:  \"strings\"",
          "25:  \"unicode\"",
          "",
          "[Removed Lines]",
          "23:  \"io/ioutil\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "95:  pkg := NewPackage()",
          "96:  if reader == nil {",
          "97:   return pkg, nil",
          "",
          "[Removed Lines]",
          "94: func (p *PackageParser) Parse(ctx context.Context, reader io.ReadCloser) (*Package, error) { //nolint:gocyclo",
          "",
          "[Added Lines]",
          "94: func (p *PackageParser) Parse(ctx context.Context, reader io.ReadCloser) (*Package, error) { //nolint:gocyclo // Only at 11.",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "303:  for _, o := range bo {",
          "304:   o(p)",
          "305:  }",
          "307: }",
          "",
          "[Removed Lines]",
          "306:  return ioutil.NopCloser(strings.NewReader(p.echo)), nil",
          "",
          "[Added Lines]",
          "306:  return io.NopCloser(strings.NewReader(p.echo)), nil",
          "",
          "---------------"
        ],
        "pkg/reconciler/managed/reconciler.go||pkg/reconciler/managed/reconciler.go": [
          "File: pkg/reconciler/managed/reconciler.go -> pkg/reconciler/managed/reconciler.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "634: }",
          "",
          "[Removed Lines]",
          "637: func (r *Reconciler) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) { // nolint:gocyclo",
          "",
          "[Added Lines]",
          "637: func (r *Reconciler) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) { //nolint:gocyclo // See note below.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "652:  managed := r.newManaged()",
          "653:  if err := r.client.Get(ctx, req.NamespacedName, managed); err != nil {",
          "",
          "[Removed Lines]",
          "650:  externalCtx, _ := context.WithTimeout(ctx, r.timeout) // nolint:govet",
          "",
          "[Added Lines]",
          "650:  externalCtx, _ := context.WithTimeout(ctx, r.timeout) //nolint:govet // See note above.",
          "",
          "---------------"
        ],
        "pkg/reconciler/providerconfig/reconciler.go||pkg/reconciler/providerconfig/reconciler.go": [
          "File: pkg/reconciler/providerconfig/reconciler.go -> pkg/reconciler/providerconfig/reconciler.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "177:    if err := r.client.Delete(ctx, pcu); resource.IgnoreNotFound(err) != nil {",
          "178:     log.Debug(errDeletePCU, \"error\", err)",
          "179:     r.record.Event(pc, event.Warning(reasonAccount, errors.Wrap(err, errDeletePCU)))",
          "181:    }",
          "182:    users--",
          "183:   }",
          "",
          "[Removed Lines]",
          "180:     return reconcile.Result{RequeueAfter: shortWait}, nil",
          "",
          "[Added Lines]",
          "182:     return reconcile.Result{RequeueAfter: shortWait}, nil //nolint:nilerr // Returning err would make us requeue instantly.",
          "",
          "---------------"
        ],
        "pkg/reference/reference.go||pkg/reference/reference.go": [
          "File: pkg/reference/reference.go -> pkg/reference/reference.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "283:  if meta.WasDeleted(r.from) || req.IsNoOp() {",
          "284:   return MultiResolutionResponse{ResolvedValues: req.CurrentValues, ResolvedReferences: req.References}, nil",
          "",
          "[Removed Lines]",
          "281: func (r *APIResolver) ResolveMultiple(ctx context.Context, req MultiResolutionRequest) (MultiResolutionResponse, error) { // nolint: gocyclo",
          "",
          "[Added Lines]",
          "283: func (r *APIResolver) ResolveMultiple(ctx context.Context, req MultiResolutionRequest) (MultiResolutionResponse, error) { //nolint: gocyclo // Only at 11.",
          "",
          "---------------"
        ],
        "pkg/resource/fake/mocks.go||pkg/resource/fake/mocks.go": [
          "File: pkg/resource/fake/mocks.go -> pkg/resource/fake/mocks.go"
        ],
        "pkg/resource/providerconfig.go||pkg/resource/providerconfig.go": [
          "File: pkg/resource/providerconfig.go -> pkg/resource/providerconfig.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "90: func CommonCredentialExtractor(ctx context.Context, source xpv1.CredentialsSource, client client.Client, selector xpv1.CommonCredentialSelectors) ([]byte, error) {",
          "92:  case xpv1.CredentialsSourceEnvironment:",
          "93:   return ExtractEnv(ctx, os.Getenv, selector)",
          "94:  case xpv1.CredentialsSourceFilesystem:",
          "",
          "[Removed Lines]",
          "91:  switch source { // nolint:exhaustive",
          "",
          "[Added Lines]",
          "91:  switch source {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "97:   return ExtractSecret(ctx, client, selector)",
          "98:  case xpv1.CredentialsSourceNone:",
          "99:   return nil, nil",
          "100:  }",
          "102: }",
          "",
          "[Removed Lines]",
          "101:  return nil, errors.Errorf(errNoHandlerForSourceFmt, source)",
          "",
          "[Added Lines]",
          "100:  case xpv1.CredentialsSourceInjectedIdentity:",
          "103:   fallthrough",
          "104:  default:",
          "105:   return nil, errors.Errorf(errNoHandlerForSourceFmt, source)",
          "",
          "---------------"
        ],
        "pkg/resource/resource.go||pkg/resource/resource.go": [
          "File: pkg/resource/resource.go -> pkg/resource/resource.go"
        ],
        "pkg/test/integration/crd.go||pkg/test/integration/crd.go": [
          "File: pkg/test/integration/crd.go -> pkg/test/integration/crd.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:  \"bytes\"",
          "22:  \"errors\"",
          "23:  \"io\"",
          "25:  \"os\"",
          "26:  \"path/filepath\"",
          "",
          "[Removed Lines]",
          "24:  \"io/ioutil\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "39: func readCRDs(path string) ([]*apiextensionsv1beta1.CustomResourceDefinition, error) {",
          "44:   return nil, err",
          "45:  }",
          "",
          "[Removed Lines]",
          "41:  var files []os.FileInfo",
          "42:  var err error",
          "43:  if files, err = ioutil.ReadDir(path); err != nil {",
          "",
          "[Added Lines]",
          "40:  files, err := os.ReadDir(path)",
          "41:  if err != nil {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "77: }",
          "79: func readDocuments(fp string) ([][]byte, error) {",
          "81:  if err != nil {",
          "82:   return nil, err",
          "83:  }",
          "",
          "[Removed Lines]",
          "80:  b, err := ioutil.ReadFile(filepath.Clean(fp))",
          "",
          "[Added Lines]",
          "78:  b, err := os.ReadFile(filepath.Clean(fp))",
          "",
          "---------------"
        ],
        "pkg/test/integration/remote.go||pkg/test/integration/remote.go": [
          "File: pkg/test/integration/remote.go -> pkg/test/integration/remote.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "37:  hasher := fnv.New32a()",
          "39:  dst := filepath.Join(path, fmt.Sprintf(\"%x\", hasher.Sum32()))",
          "41:  c := getter.Client{",
          "",
          "[Removed Lines]",
          "38:  hasher.Write([]byte(url)) // nolint:errcheck",
          "",
          "[Added Lines]",
          "38:  hasher.Write([]byte(url))",
          "",
          "---------------"
        ],
        "pkg/test/integration/server.go||pkg/test/integration/server.go": [
          "File: pkg/test/integration/server.go -> pkg/test/integration/server.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: import (",
          "20:  \"context\"",
          "22:  \"os\"",
          "23:  \"time\"",
          "",
          "[Removed Lines]",
          "21:  \"io/ioutil\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "164:   op(c)",
          "165:  }",
          "168:  if err != nil {",
          "169:   return nil, errors.Wrap(err, errCreateTmpDir)",
          "170:  }",
          "",
          "[Removed Lines]",
          "167:  dir, err := ioutil.TempDir(\"\", \"\")",
          "",
          "[Added Lines]",
          "166:  dir, err := os.MkdirTemp(\"\", \"\")",
          "",
          "---------------"
        ],
        "pkg/webhook/mutator.go||pkg/webhook/mutator.go": [
          "File: pkg/webhook/mutator.go -> pkg/webhook/mutator.go"
        ]
      }
    },
    {
      "candidate_hash": "c3042fb18c6a5c06fd3a0f08415091fb595552c3",
      "candidate_info": {
        "commit_hash": "c3042fb18c6a5c06fd3a0f08415091fb595552c3",
        "repo": "crossplane/crossplane-runtime",
        "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/c3042fb18c6a5c06fd3a0f08415091fb595552c3",
        "files": [
          "pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go"
        ],
        "message": "Change the error message\n\nSigned-off-by: Sergen Yal\u00e7\u0131n <yalcinsergen97@gmail.com>\n(cherry picked from commit b1cd25a73b12cedda47fdc895d049b1f923cb8a4)",
        "before_after_code_files": [
          "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ],
          "candidate": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ]
        }
      },
      "candidate_diff": {
        "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
          "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "142:     }",
          "143:     it = object[current.Field]",
          "144:    case nil:",
          "146:    default:",
          "147:     return nil, errors.Errorf(\"%s: not an object\", s[:i])",
          "148:    }",
          "",
          "[Removed Lines]",
          "145:     return nil, errNotFound{errors.Errorf(\"field %q is not found in the path\", s[:i])}",
          "",
          "[Added Lines]",
          "145:     return nil, errNotFound{errors.Errorf(\"path %q is not found in the paved object\", s[:i])}",
          "",
          "---------------"
        ],
        "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go": [
          "File: pkg/fieldpath/paved_test.go -> pkg/fieldpath/paved_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "161:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
          "162:    },",
          "163:   },",
          "166:    path:   \"spec.containers[*].name\",",
          "167:    data:   []byte(`{\"spec\":{\"containers\": null}}`),",
          "168:    want: want{",
          "170:    },",
          "171:   },",
          "172:  }",
          "",
          "[Removed Lines]",
          "164:   \"NilValue\": {",
          "165:    reason: \"Requesting for an object that has nil value\",",
          "169:     err: errNotFound{errors.Errorf(\"field %q is not found in the path\", \"spec.containers\")},",
          "",
          "[Added Lines]",
          "164:   \"NilParent\": {",
          "165:    reason: \"Request for a path with a nil parent value\",",
          "169:     err: errNotFound{errors.Errorf(\"path %q is not found in the paved object\", \"spec.containers\")},",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c0dbcda6f106b9c60c0b3e3a48f06e77cc66524e",
      "candidate_info": {
        "commit_hash": "c0dbcda6f106b9c60c0b3e3a48f06e77cc66524e",
        "repo": "crossplane/crossplane-runtime",
        "commit_url": "https://github.com/crossplane/crossplane-runtime/commit/c0dbcda6f106b9c60c0b3e3a48f06e77cc66524e",
        "files": [
          "pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go"
        ],
        "message": "Add a nil case to the getValueFromInterface function\n\nSigned-off-by: Sergen Yal\u00e7\u0131n <yalcinsergen97@gmail.com>\n(cherry picked from commit 5cd11c97cb15ff3500747c838c99cd17d93d306b)",
        "before_after_code_files": [
          "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
          "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ],
          "candidate": [
            "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go",
            "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go"
          ]
        }
      },
      "candidate_diff": {
        "pkg/fieldpath/paved.go||pkg/fieldpath/paved.go": [
          "File: pkg/fieldpath/paved.go -> pkg/fieldpath/paved.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "112:  return getValueFromInterface(p.object, s)",
          "113: }",
          "116:  for i, current := range s {",
          "117:   final := i == len(s)-1",
          "118:   switch current.Type {",
          "",
          "[Removed Lines]",
          "115: func getValueFromInterface(it any, s Segments) (any, error) {",
          "",
          "[Added Lines]",
          "115: func getValueFromInterface(it any, s Segments) (any, error) { //nolint:gocyclo // See note below.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "129:    }",
          "130:    it = array[current.Index]",
          "131:   case SegmentField:",
          "134:     return nil, errors.Errorf(\"%s: not an object\", s[:i])",
          "135:    }",
          "144:   }",
          "145:  }",
          "",
          "[Removed Lines]",
          "132:    object, ok := it.(map[string]any)",
          "133:    if !ok {",
          "136:    v, ok := object[current.Field]",
          "137:    if !ok {",
          "138:     return nil, errNotFound{errors.Errorf(\"%s: no such field\", s[:i+1])}",
          "139:    }",
          "140:    if final {",
          "141:     return v, nil",
          "142:    }",
          "143:    it = object[current.Field]",
          "",
          "[Added Lines]",
          "134:    switch object := it.(type) {",
          "135:    case map[string]any:",
          "136:     v, ok := object[current.Field]",
          "137:     if !ok {",
          "138:      return nil, errNotFound{errors.Errorf(\"%s: no such field\", s[:i+1])}",
          "139:     }",
          "140:     if final {",
          "141:      return v, nil",
          "142:     }",
          "143:     it = object[current.Field]",
          "144:    case nil:",
          "145:     return nil, errNotFound{errors.Errorf(\"field %q is not found in the path\", s[:i])}",
          "146:    default:",
          "",
          "---------------"
        ],
        "pkg/fieldpath/paved_test.go||pkg/fieldpath/paved_test.go": [
          "File: pkg/fieldpath/paved_test.go -> pkg/fieldpath/paved_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "161:     err: errors.Wrap(errors.New(\"unexpected ']' at position 5\"), \"cannot parse path \\\"spec[]\\\"\"),",
          "162:    },",
          "163:   },",
          "164:  }",
          "166:  for name, tc := range cases {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "164:   \"NilValue\": {",
          "165:    reason: \"Requesting for an object that has nil value\",",
          "166:    path:   \"spec.containers[*].name\",",
          "167:    data:   []byte(`{\"spec\":{\"containers\": null}}`),",
          "168:    want: want{",
          "169:     err: errNotFound{errors.Errorf(\"field %q is not found in the path\", \"spec.containers\")},",
          "170:    },",
          "171:   },",
          "",
          "---------------"
        ]
      }
    }
  ]
}
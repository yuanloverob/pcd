{
  "cve_id": "CVE-2021-43784",
  "cve_desc": "runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. In runc, netlink is used internally as a serialization system for specifying the relevant container configuration to the `C` portion of the code (responsible for the based namespace setup of containers). In all versions of runc prior to 1.0.3, the encoder did not handle the possibility of an integer overflow in the 16-bit length field for the byte array attribute type, meaning that a large enough malicious byte array attribute could result in the length overflowing and the attribute contents being parsed as netlink messages for container configuration. This vulnerability requires the attacker to have some control over the configuration of the container and would allow the attacker to bypass the namespace restrictions of the container by simply adding their own netlink payload which disables all namespaces. The main users impacted are those who allow untrusted images with untrusted configurations to run on their machines (such as with shared cloud infrastructure). runc version 1.0.3 contains a fix for this bug. As a workaround, one may try disallowing untrusted namespace paths from your container. It should be noted that untrusted namespace paths would allow the attacker to disable namespace protections entirely even in the absence of this bug.",
  "repo": "opencontainers/runc",
  "patch_hash": "9c444070ec7bb83995dbc0185da68284da71c554",
  "patch_info": {
    "commit_hash": "9c444070ec7bb83995dbc0185da68284da71c554",
    "repo": "opencontainers/runc",
    "commit_url": "https://github.com/opencontainers/runc/commit/9c444070ec7bb83995dbc0185da68284da71c554",
    "files": [
      "libcontainer/configs/mount.go",
      "libcontainer/container_linux.go",
      "libcontainer/factory_linux.go",
      "libcontainer/init_linux.go",
      "libcontainer/message_linux.go",
      "libcontainer/nsenter/nsexec.c",
      "libcontainer/rootfs_linux.go",
      "libcontainer/standard_init_linux.go"
    ],
    "message": "Open bind mount sources from the host userns\n\nThe source of the bind mount might not be accessible in a different user\nnamespace because a component of the source path might not be traversed\nunder the users and groups mapped inside the user namespace. This caused\nerrors such as the following:\n\n  # time=\"2020-06-22T13:48:26Z\" level=error msg=\"container_linux.go:367:\n  starting container process caused: process_linux.go:459:\n  container init caused: rootfs_linux.go:58:\n  mounting \\\"/tmp/busyboxtest/source-inaccessible/dir\\\"\n  to rootfs at \\\"/tmp/inaccessible\\\" caused:\n  stat /tmp/busyboxtest/source-inaccessible/dir: permission denied\"\n\nTo solve this problem, this patch performs the following:\n\n1. in nsexec.c, it opens the source path in the host userns (so we have\n   the right permissions to open it) but in the container mntns (so the\n   kernel cross mntns mount check let us mount it later:\n   https://github.com/torvalds/linux/blob/v5.8/fs/namespace.c#L2312).\n\n2. in nsexec.c, it passes the file descriptors of the source to the\n   child process with SCM_RIGHTS.\n\n3. In runc-init in Golang, it finishes the mounts while inside the\n   userns even without access to the some components of the source\n   paths.\n\nPassing the fds with SCM_RIGHTS is necessary because once the child\nprocess is in the container mntns, it is already in the container userns\nso it cannot temporarily join the host mntns.\n\nThis patch uses the existing mechanism with _LIBCONTAINER_* environment\nvariables to pass the file descriptors from runc to runc init.\n\nThis patch uses the existing mechanism with the Netlink-style bootstrap\nto pass information about the list of source mounts to nsexec.c.\n\nRootless containers don't use this bind mount sources fdpassing\nmechanism because we can't setns() to the target mntns in a rootless\ncontainer (we don't have the privileges when we are in the host userns).\n\nThis patch takes care of using O_CLOEXEC on mount fds, and close them\nearly.\n\nFixes: #2484.\n\nSigned-off-by: Alban Crequy <alban@kinvolk.io>\nSigned-off-by: Rodrigo Campos <rodrigo@kinvolk.io>\nCo-authored-by: Rodrigo Campos <rodrigo@kinvolk.io>",
    "before_after_code_files": [
      "libcontainer/configs/mount.go||libcontainer/configs/mount.go",
      "libcontainer/container_linux.go||libcontainer/container_linux.go",
      "libcontainer/factory_linux.go||libcontainer/factory_linux.go",
      "libcontainer/init_linux.go||libcontainer/init_linux.go",
      "libcontainer/message_linux.go||libcontainer/message_linux.go",
      "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c",
      "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go",
      "libcontainer/standard_init_linux.go||libcontainer/standard_init_linux.go"
    ]
  },
  "patch_diff": {
    "libcontainer/configs/mount.go||libcontainer/configs/mount.go": [
      "File: libcontainer/configs/mount.go -> libcontainer/configs/mount.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: package configs",
      "3: const (",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3: import \"golang.org/x/sys/unix\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "38:  PostmountCmds []Command `json:\"postmount_cmds\"`",
      "39: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "43: func (m *Mount) IsBind() bool {",
      "44:  return m.Flags&unix.MS_BIND != 0",
      "45: }",
      "",
      "---------------"
    ],
    "libcontainer/container_linux.go||libcontainer/container_linux.go": [
      "File: libcontainer/container_linux.go -> libcontainer/container_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "521:  return cmd",
      "522: }",
      "524: func (c *linuxContainer) newInitProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*initProcess, error) {",
      "525:  cmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initStandard))",
      "526:  nsMaps := make(map[configs.NamespaceType]string)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "527: func (c *linuxContainer) shouldSendMountSources() bool {",
      "530:  if !c.config.Namespaces.Contains(configs.NEWUSER) ||",
      "531:   !c.config.Namespaces.Contains(configs.NEWNS) {",
      "532:   return false",
      "533:  }",
      "537:  if c.config.RootlessEUID {",
      "538:   return false",
      "539:  }",
      "542:  for _, m := range c.config.Mounts {",
      "543:   if m.IsBind() {",
      "544:    return true",
      "545:   }",
      "546:  }",
      "548:  return false",
      "549: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "530:   }",
      "531:  }",
      "532:  _, sharePidns := nsMaps[configs.NEWPID]",
      "534:  if err != nil {",
      "535:   return nil, err",
      "536:  }",
      "537:  init := &initProcess{",
      "538:   cmd:             cmd,",
      "539:   messageSockPair: messageSockPair,",
      "",
      "[Removed Lines]",
      "533:  data, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps)",
      "",
      "[Added Lines]",
      "560:  data, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps, initStandard)",
      "565:  if c.shouldSendMountSources() {",
      "568:   mountFds := make([]int, len(c.config.Mounts))",
      "569:   for i, m := range c.config.Mounts {",
      "570:    if !m.IsBind() {",
      "572:     mountFds[i] = -1",
      "573:     continue",
      "574:    }",
      "580:    cmd.ExtraFiles = append(cmd.ExtraFiles, messageSockPair.child)",
      "581:    mountFds[i] = stdioFdCount + len(cmd.ExtraFiles) - 1",
      "582:   }",
      "584:   mountFdsJson, err := json.Marshal(mountFds)",
      "585:   if err != nil {",
      "586:    return nil, fmt.Errorf(\"Error creating _LIBCONTAINER_MOUNT_FDS: %w\", err)",
      "587:   }",
      "589:   cmd.Env = append(cmd.Env,",
      "590:    \"_LIBCONTAINER_MOUNT_FDS=\"+string(mountFdsJson),",
      "591:   )",
      "592:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "558:  }",
      "562:  if err != nil {",
      "563:   return nil, err",
      "564:  }",
      "",
      "[Removed Lines]",
      "561:  data, err := c.bootstrapData(0, state.NamespacePaths)",
      "",
      "[Added Lines]",
      "618:  data, err := c.bootstrapData(0, state.NamespacePaths, initSetns)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1213:  case \"bind\":",
      "1217:    return err",
      "1218:   }",
      "1219:  default:",
      "",
      "[Removed Lines]",
      "1216:   if err := prepareBindMount(m, c.config.Rootfs); err != nil {",
      "",
      "[Added Lines]",
      "1275:   if err := prepareBindMount(m, c.config.Rootfs, nil); err != nil {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2055:  r := nl.NewNetlinkRequest(int(InitMsg), 0)",
      "",
      "[Removed Lines]",
      "2053: func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string) (io.Reader, error) {",
      "",
      "[Added Lines]",
      "2112: func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string, it initType) (io.Reader, error) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2132:   Value: c.config.RootlessEUID,",
      "2133:  })",
      "2135:  return bytes.NewReader(r.Serialize()), nil",
      "2136: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2195:  if it == initStandard && c.shouldSendMountSources() {",
      "2196:   var mounts []byte",
      "2197:   for _, m := range c.config.Mounts {",
      "2198:    if m.IsBind() {",
      "2199:     mounts = append(mounts, []byte(m.Source)...)",
      "2200:    }",
      "2201:    mounts = append(mounts, byte(0))",
      "2202:   }",
      "2204:   r.AddData(&Bytemsg{",
      "2205:    Type:  MountSourcesAttr,",
      "2206:    Value: mounts,",
      "2207:   })",
      "2208:  }",
      "",
      "---------------"
    ],
    "libcontainer/factory_linux.go||libcontainer/factory_linux.go": [
      "File: libcontainer/factory_linux.go -> libcontainer/factory_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "295:   return fmt.Errorf(\"unable to convert _LIBCONTAINER_LOGPIPE: %w\", err)",
      "296:  }",
      "300:  os.Clearenv()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "299:  mountFds, err := parseMountFds()",
      "300:  if err != nil {",
      "301:   return err",
      "302:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "305:   }",
      "306:  }()",
      "309:  if err != nil {",
      "310:   return err",
      "311:  }",
      "",
      "[Removed Lines]",
      "308:  i, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd)",
      "",
      "[Added Lines]",
      "314:  i, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd, mountFds)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "359:   return nil",
      "360:  }",
      "361: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "369: func parseMountFds() ([]int, error) {",
      "370:  fdsJson := os.Getenv(\"_LIBCONTAINER_MOUNT_FDS\")",
      "371:  if fdsJson == \"\" {",
      "373:   return nil, nil",
      "374:  }",
      "376:  var mountFds []int",
      "377:  if err := json.Unmarshal([]byte(fdsJson), &mountFds); err != nil {",
      "378:   return nil, fmt.Errorf(\"Error unmarshalling _LIBCONTAINER_MOUNT_FDS: %w\", err)",
      "379:  }",
      "381:  return mountFds, nil",
      "382: }",
      "",
      "---------------"
    ],
    "libcontainer/init_linux.go||libcontainer/init_linux.go": [
      "File: libcontainer/init_linux.go -> libcontainer/init_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "76:  Init() error",
      "77: }",
      "80:  var config *initConfig",
      "81:  if err := json.NewDecoder(pipe).Decode(&config); err != nil {",
      "82:   return nil, err",
      "",
      "[Removed Lines]",
      "79: func newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd, logFd int) (initer, error) {",
      "",
      "[Added Lines]",
      "79: func newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd, logFd int, mountFds []int) (initer, error) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "86:  }",
      "87:  switch t {",
      "88:  case initSetns:",
      "89:   return &linuxSetnsInit{",
      "90:    pipe:          pipe,",
      "91:    consoleSocket: consoleSocket,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "90:   if mountFds != nil {",
      "91:    return nil, errors.New(\"mountFds must be nil. Can't mount while doing runc exec.\")",
      "92:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "100:    config:        config,",
      "101:    fifoFd:        fifoFd,",
      "102:    logFd:         logFd,",
      "103:   }, nil",
      "104:  }",
      "105:  return nil, fmt.Errorf(\"unknown init type %q\", t)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "108:    mountFds:      mountFds,",
      "",
      "---------------"
    ],
    "libcontainer/message_linux.go||libcontainer/message_linux.go": [
      "File: libcontainer/message_linux.go -> libcontainer/message_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "18:  RootlessEUIDAttr uint16 = 27287",
      "19:  UidmapPathAttr   uint16 = 27288",
      "20:  GidmapPathAttr   uint16 = 27289",
      "21: )",
      "23: type Int32msg struct {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "21:  MountSourcesAttr uint16 = 27290",
      "",
      "---------------"
    ],
    "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c": [
      "File: libcontainer/nsenter/nsexec.c -> libcontainer/nsenter/nsexec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4: #include <errno.h>",
      "5: #include <fcntl.h>",
      "6: #include <grp.h>",
      "7: #include <sched.h>",
      "8: #include <setjmp.h>",
      "9: #include <signal.h>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7: #include <limits.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "87:  size_t uidmappath_len;",
      "88:  char *gidmappath;",
      "89:  size_t gidmappath_len;",
      "90: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "95:  char *mountsources;",
      "96:  size_t mountsources_len;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "119: #define ROOTLESS_EUID_ATTR 27287",
      "120: #define UIDMAPPATH_ATTR  27288",
      "121: #define GIDMAPPATH_ATTR  27289",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "129: #define MOUNT_SOURCES_ATTR 27290",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "542:   case SETGROUP_ATTR:",
      "543:    config->is_setgroup = readint8(current);",
      "544:    break;",
      "545:   default:",
      "546:    bail(\"unknown netlink message type %d\", nlattr->nla_type);",
      "547:   }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "553:   case MOUNT_SOURCES_ATTR:",
      "554:    config->mountsources = current;",
      "555:    config->mountsources_len = payload_len;",
      "556:    break;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "633:   return 0;",
      "634: }",
      "636: void nsexec(void)",
      "637: {",
      "638:  int pipenum;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "648: void receive_fd(int sockfd, int new_fd)",
      "649: {",
      "650:  int bytes_read;",
      "651:  struct msghdr msg = { };",
      "652:  struct cmsghdr *cmsg;",
      "653:  struct iovec iov = { };",
      "654:  char null_byte = '\\0';",
      "655:  int ret;",
      "656:  int fd_count;",
      "657:  int *fd_payload;",
      "659:  iov.iov_base = &null_byte;",
      "660:  iov.iov_len = 1;",
      "662:  msg.msg_iov = &iov;",
      "663:  msg.msg_iovlen = 1;",
      "665:  msg.msg_controllen = CMSG_SPACE(sizeof(int));",
      "666:  msg.msg_control = malloc(msg.msg_controllen);",
      "667:  if (msg.msg_control == NULL) {",
      "668:   bail(\"Can't allocate memory to receive fd.\");",
      "669:  }",
      "671:  memset(msg.msg_control, 0, msg.msg_controllen);",
      "673:  bytes_read = recvmsg(sockfd, &msg, 0);",
      "674:  if (bytes_read != 1)",
      "675:   bail(\"failed to receive fd from unix socket %d\", sockfd);",
      "676:  if (msg.msg_flags & MSG_CTRUNC)",
      "677:   bail(\"received truncated control message from unix socket %d\", sockfd);",
      "679:  cmsg = CMSG_FIRSTHDR(&msg);",
      "680:  if (!cmsg)",
      "681:   bail(\"received message from unix socket %d without control message\", sockfd);",
      "683:  if (cmsg->cmsg_level != SOL_SOCKET)",
      "684:   bail(\"received unknown control message from unix socket %d: cmsg_level=%d\", sockfd, cmsg->cmsg_level);",
      "686:  if (cmsg->cmsg_type != SCM_RIGHTS)",
      "687:   bail(\"received unknown control message from unix socket %d: cmsg_type=%d\", sockfd, cmsg->cmsg_type);",
      "689:  fd_count = (cmsg->cmsg_len - CMSG_LEN(0)) / sizeof(int);",
      "690:  if (fd_count != 1)",
      "691:   bail(\"received control message from unix socket %d with too many fds: %d\", sockfd, fd_count);",
      "693:  fd_payload = (int *)CMSG_DATA(cmsg);",
      "694:  ret = dup3(*fd_payload, new_fd, O_CLOEXEC);",
      "695:  if (ret < 0)",
      "696:   bail(\"cannot dup3 fd %d to %d\", *fd_payload, new_fd);",
      "698:  free(msg.msg_control);",
      "700:  ret = close(*fd_payload);",
      "701:  if (ret < 0)",
      "702:   bail(\"cannot close fd %d\", *fd_payload);",
      "703: }",
      "705: void send_fd(int sockfd, int fd)",
      "706: {",
      "707:  int bytes_written;",
      "708:  struct msghdr msg = { };",
      "709:  struct cmsghdr *cmsg;",
      "710:  struct iovec iov[1] = { };",
      "711:  char null_byte = '\\0';",
      "713:  iov[0].iov_base = &null_byte;",
      "714:  iov[0].iov_len = 1;",
      "716:  msg.msg_iov = iov;",
      "717:  msg.msg_iovlen = 1;",
      "721:  msg.msg_controllen = CMSG_SPACE(sizeof(int));",
      "722:  msg.msg_control = malloc(msg.msg_controllen);",
      "723:  if (msg.msg_control == NULL) {",
      "724:   bail(\"Can't allocate memory to send fd.\");",
      "725:  }",
      "727:  memset(msg.msg_control, 0, msg.msg_controllen);",
      "729:  cmsg = CMSG_FIRSTHDR(&msg);",
      "730:  cmsg->cmsg_level = SOL_SOCKET;",
      "731:  cmsg->cmsg_type = SCM_RIGHTS;",
      "732:  cmsg->cmsg_len = CMSG_LEN(sizeof(int));",
      "733:  memcpy(CMSG_DATA(cmsg), &fd, sizeof(int));",
      "735:  bytes_written = sendmsg(sockfd, &msg, 0);",
      "737:  free(msg.msg_control);",
      "739:  if (bytes_written != 1)",
      "740:   bail(\"failed to send fd %d via unix socket %d\", fd, sockfd);",
      "741: }",
      "743: void receive_mountsources(int sockfd)",
      "744: {",
      "745:  char *mount_fds, *endp;",
      "746:  long new_fd;",
      "749:  mount_fds = getenv(\"_LIBCONTAINER_MOUNT_FDS\");",
      "751:  if (mount_fds[0] != '[') {",
      "752:   bail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: missing '['\");",
      "753:  }",
      "754:  mount_fds++;",
      "756:  for (endp = mount_fds; *endp != ']'; mount_fds = endp + 1) {",
      "757:   new_fd = strtol(mount_fds, &endp, 10);",
      "758:   if (endp == mount_fds) {",
      "759:    bail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: not a number\");",
      "760:   }",
      "761:   if (*endp == '\\0') {",
      "762:    bail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: missing ]\");",
      "763:   }",
      "765:   if (new_fd == -1) {",
      "766:    continue;",
      "767:   }",
      "769:   if (new_fd == LONG_MAX || new_fd < 0 || new_fd > INT_MAX) {",
      "770:    bail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: fds out of range\");",
      "771:   }",
      "773:   receive_fd(sockfd, new_fd);",
      "774:  }",
      "775: }",
      "777: void send_mountsources(int sockfd, pid_t child, char *mountsources, size_t mountsources_len)",
      "778: {",
      "779:  char proc_path[PATH_MAX];",
      "780:  int host_mntns_fd;",
      "781:  int container_mntns_fd;",
      "782:  int fd;",
      "783:  int ret;",
      "787:  if (mountsources == NULL)",
      "788:   return;",
      "790:  host_mntns_fd = open(\"/proc/self/ns/mnt\", O_RDONLY | O_CLOEXEC);",
      "791:  if (host_mntns_fd == -1)",
      "792:   bail(\"failed to get current mount namespace\");",
      "794:  if (snprintf(proc_path, PATH_MAX, \"/proc/%d/ns/mnt\", child) < 0)",
      "795:   bail(\"failed to get mount namespace path\");",
      "797:  container_mntns_fd = open(proc_path, O_RDONLY | O_CLOEXEC);",
      "798:  if (container_mntns_fd == -1)",
      "799:   bail(\"failed to get container mount namespace\");",
      "801:  if (setns(container_mntns_fd, CLONE_NEWNS) < 0)",
      "802:   bail(\"failed to setns to container mntns\");",
      "804:  char *mountsources_end = mountsources + mountsources_len;",
      "805:  while (mountsources < mountsources_end) {",
      "806:   if (mountsources[0] == '\\0') {",
      "807:    mountsources++;",
      "808:    continue;",
      "809:   }",
      "811:   fd = open(mountsources, O_PATH | O_CLOEXEC);",
      "812:   if (fd < 0)",
      "813:    bail(\"failed to open mount source %s\", mountsources);",
      "815:   send_fd(sockfd, fd);",
      "817:   ret = close(fd);",
      "818:   if (ret != 0)",
      "819:    bail(\"failed to close mount source fd %d\", fd);",
      "821:   mountsources += strlen(mountsources) + 1;",
      "822:  }",
      "824:  if (setns(host_mntns_fd, CLONE_NEWNS) < 0)",
      "825:   bail(\"failed to setns to host mntns\");",
      "827:  ret = close(host_mntns_fd);",
      "828:  if (ret != 0)",
      "829:   bail(\"failed to close host mount namespace fd %d\", host_mntns_fd);",
      "830:  ret = close(container_mntns_fd);",
      "831:  if (ret != 0)",
      "832:   bail(\"failed to close container mount namespace fd %d\", container_mntns_fd);",
      "833: }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "865:       bail(\"failed to sync with runc: write(pid-JSON)\");",
      "866:      }",
      "867:      break;",
      "868:     case SYNC_CHILD_FINISH:",
      "869:      write_log(DEBUG, \"stage-1 complete\");",
      "870:      stage1_complete = true;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1067:     case SYNC_MOUNTSOURCES_PLS:",
      "1068:      send_mountsources(syncfd, stage1_pid, config.mountsources,",
      "1069:          config.mountsources_len);",
      "1071:      s = SYNC_MOUNTSOURCES_ACK;",
      "1072:      if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {",
      "1073:       kill(stage1_pid, SIGKILL);",
      "1074:       bail(\"failed to sync with child: write(SYNC_MOUNTSOURCES_ACK)\");",
      "1075:      }",
      "1076:      break;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1019:    if (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)",
      "1020:     bail(\"failed to unshare remaining namespaces (except cgroupns)\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1232:    if (config.mountsources) {",
      "1233:     s = SYNC_MOUNTSOURCES_PLS;",
      "1234:     if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {",
      "1235:      kill(stage2_pid, SIGKILL);",
      "1236:      bail(\"failed to sync with parent: write(SYNC_MOUNTSOURCES_PLS)\");",
      "1237:     }",
      "1240:     receive_mountsources(syncfd);",
      "1243:     if (read(syncfd, &s, sizeof(s)) != sizeof(s)) {",
      "1244:      kill(stage2_pid, SIGKILL);",
      "1245:      bail(\"failed to sync with parent: read(SYNC_MOUNTSOURCES_ACK)\");",
      "1246:     }",
      "1247:     if (s != SYNC_MOUNTSOURCES_ACK) {",
      "1248:      kill(stage2_pid, SIGKILL);",
      "1249:      bail(\"failed to sync with parent: SYNC_MOUNTSOURCES_ACK: got %u\", s);",
      "1250:     }",
      "1251:    }",
      "",
      "---------------"
    ],
    "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go": [
      "File: libcontainer/rootfs_linux.go -> libcontainer/rootfs_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "36:  cgroup2Path     string",
      "37:  rootlessCgroups bool",
      "38:  cgroupns        bool",
      "39: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "39:  fd              *int",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "55:  config := iConfig.Config",
      "56:  if err := prepareRoot(config); err != nil {",
      "57:   return fmt.Errorf(\"error preparing rootfs: %w\", err)",
      "58:  }",
      "60:  mountConfig := &mountConfig{",
      "61:   root:            config.Rootfs,",
      "62:   label:           config.MountLabel,",
      "",
      "[Removed Lines]",
      "54: func prepareRootfs(pipe io.ReadWriter, iConfig *initConfig) (err error) {",
      "",
      "[Added Lines]",
      "55: func prepareRootfs(pipe io.ReadWriter, iConfig *initConfig, mountFds []int) (err error) {",
      "61:  if mountFds != nil && len(mountFds) != len(config.Mounts) {",
      "62:   return fmt.Errorf(\"malformed mountFds slice. Expected size: %v, got: %v. Slice: %v\", len(config.Mounts), len(mountFds), mountFds)",
      "63:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "65:   cgroupns:        config.Namespaces.Contains(configs.NEWCGROUP),",
      "66:  }",
      "67:  setupDev := needsSetupDev(config)",
      "69:   for _, precmd := range m.PremountCmds {",
      "70:    if err := mountCmd(precmd); err != nil {",
      "71:     return fmt.Errorf(\"error running premount command: %w\", err)",
      "72:    }",
      "73:   }",
      "74:   if err := mountToRootfs(m, mountConfig); err != nil {",
      "75:    return fmt.Errorf(\"error mounting %q to rootfs at %q: %w\", m.Source, m.Destination, err)",
      "76:   }",
      "",
      "[Removed Lines]",
      "68:  for _, m := range config.Mounts {",
      "",
      "[Added Lines]",
      "73:  for i, m := range config.Mounts {",
      "82:   if mountFds != nil && mountFds[i] != -1 {",
      "83:    mountConfig.fd = &mountFds[i]",
      "84:   }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "210:  return nil",
      "211: }",
      "215:  if err != nil {",
      "",
      "[Removed Lines]",
      "213: func prepareBindMount(m *configs.Mount, rootfs string) error {",
      "214:  stat, err := os.Stat(m.Source)",
      "",
      "[Added Lines]",
      "225: func prepareBindMount(m *configs.Mount, rootfs string, mountFd *int) error {",
      "226:  source := m.Source",
      "227:  if mountFd != nil {",
      "228:   source = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)",
      "229:  }",
      "231:  stat, err := os.Stat(source)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "225:  if dest, err = securejoin.SecureJoin(rootfs, m.Destination); err != nil {",
      "226:   return err",
      "227:  }",
      "229:   return err",
      "230:  }",
      "231:  if err := createIfNotExists(dest, stat.IsDir()); err != nil {",
      "",
      "[Removed Lines]",
      "228:  if err := checkProcMount(rootfs, dest, m.Source); err != nil {",
      "",
      "[Added Lines]",
      "245:  if err := checkProcMount(rootfs, dest, source); err != nil {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "348:  oldDest := m.Destination",
      "349:  m.Destination = tmpDir",
      "351:  m.Destination = oldDest",
      "352:  if err != nil {",
      "353:   return err",
      "",
      "[Removed Lines]",
      "350:  err = mountPropagate(m, \"/\", mountLabel)",
      "",
      "[Added Lines]",
      "369:  err = mountPropagate(m, \"/\", mountLabel, nil)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "378: func mountToRootfs(m *configs.Mount, c *mountConfig) error {",
      "379:  rootfs := c.root",
      "380:  mountLabel := c.label",
      "381:  dest, err := securejoin.SecureJoin(rootfs, m.Destination)",
      "382:  if err != nil {",
      "383:   return err",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "400:  mountFd := c.fd",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "401:    return err",
      "402:   }",
      "405:  case \"mqueue\":",
      "406:   if err := os.MkdirAll(dest, 0o755); err != nil {",
      "407:    return err",
      "408:   }",
      "410:    return err",
      "411:   }",
      "412:   return label.SetFileLabel(dest, mountLabel)",
      "",
      "[Removed Lines]",
      "404:   return mountPropagate(m, rootfs, \"\")",
      "409:   if err := mountPropagate(m, rootfs, \"\"); err != nil {",
      "",
      "[Added Lines]",
      "424:   return mountPropagate(m, rootfs, \"\", nil)",
      "429:   if err := mountPropagate(m, rootfs, \"\", nil); err != nil {",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "421:   if m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP {",
      "422:    err = doTmpfsCopyUp(m, rootfs, mountLabel)",
      "423:   } else {",
      "425:   }",
      "426:   if err != nil {",
      "427:    return err",
      "428:   }",
      "429:   if stat != nil {",
      "430:    if err = os.Chmod(dest, stat.Mode()); err != nil {",
      "431:     return err",
      "",
      "[Removed Lines]",
      "424:    err = mountPropagate(m, rootfs, mountLabel)",
      "",
      "[Added Lines]",
      "444:    err = mountPropagate(m, rootfs, mountLabel, nil)",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "433:   }",
      "435:   if m.Flags&unix.MS_RDONLY != 0 {",
      "437:     return err",
      "438:    }",
      "439:   }",
      "440:   return nil",
      "441:  case \"bind\":",
      "443:    return err",
      "444:   }",
      "446:    return err",
      "447:   }",
      "450:   if m.Flags&^(unix.MS_REC|unix.MS_REMOUNT|unix.MS_BIND) != 0 {",
      "453:     return err",
      "454:    }",
      "455:   }",
      "",
      "[Removed Lines]",
      "436:    if err := remount(m, rootfs); err != nil {",
      "442:   if err := prepareBindMount(m, rootfs); err != nil {",
      "445:   if err := mountPropagate(m, rootfs, mountLabel); err != nil {",
      "452:    if err := remount(m, rootfs); err != nil {",
      "",
      "[Added Lines]",
      "458:    if err := remount(m, rootfs, mountFd); err != nil {",
      "464:   if err := prepareBindMount(m, rootfs, mountFd); err != nil {",
      "467:   if err := mountPropagate(m, rootfs, mountLabel, mountFd); err != nil {",
      "474:    if err := remount(m, rootfs, mountFd); err != nil {",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "475:   if err := os.MkdirAll(dest, 0o755); err != nil {",
      "476:    return err",
      "477:   }",
      "479:  }",
      "480:  return nil",
      "481: }",
      "",
      "[Removed Lines]",
      "478:   return mountPropagate(m, rootfs, mountLabel)",
      "",
      "[Added Lines]",
      "500:   return mountPropagate(m, rootfs, mountLabel, mountFd)",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "1037:  return ioutil.WriteFile(path.Join(\"/proc/sys\", keyPath), []byte(value), 0o644)",
      "1038: }",
      "1041:  return utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {",
      "1043:  })",
      "1044: }",
      "1049:  var (",
      "1050:   data  = label.FormatMountLabel(m.Data, mountLabel)",
      "1051:   flags = m.Flags",
      "",
      "[Removed Lines]",
      "1040: func remount(m *configs.Mount, rootfs string) error {",
      "1042:   return mount(m.Source, m.Destination, procfd, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")",
      "1048: func mountPropagate(m *configs.Mount, rootfs string, mountLabel string) error {",
      "",
      "[Added Lines]",
      "1062: func remount(m *configs.Mount, rootfs string, mountFd *int) error {",
      "1063:  source := m.Source",
      "1064:  if mountFd != nil {",
      "1065:   source = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)",
      "1066:  }",
      "1069:   return mount(source, m.Destination, procfd, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")",
      "1075: func mountPropagate(m *configs.Mount, rootfs string, mountLabel string, mountFd *int) error {",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "1065:  if err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {",
      "1067:  }); err != nil {",
      "1068:   return err",
      "1069:  }",
      "",
      "[Removed Lines]",
      "1066:   return mount(m.Source, m.Destination, procfd, m.Device, uintptr(flags), data)",
      "",
      "[Added Lines]",
      "1092:  source := m.Source",
      "1093:  if mountFd != nil {",
      "1094:   source = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)",
      "1095:  }",
      "1098:   return mount(source, m.Destination, procfd, m.Device, uintptr(flags), data)",
      "",
      "---------------"
    ],
    "libcontainer/standard_init_linux.go||libcontainer/standard_init_linux.go": [
      "File: libcontainer/standard_init_linux.go -> libcontainer/standard_init_linux.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "26:  parentPid     int",
      "27:  fifoFd        int",
      "28:  logFd         int",
      "29:  config        *initConfig",
      "30: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "29:  mountFds      []int",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "89:  selinux.GetEnabled()",
      "91:   return err",
      "92:  }",
      "",
      "[Removed Lines]",
      "90:  if err := prepareRootfs(l.pipe, l.config); err != nil {",
      "",
      "[Added Lines]",
      "93:  err := prepareRootfs(l.pipe, l.config, l.mountFds)",
      "94:  for _, m := range l.mountFds {",
      "95:   if m == -1 {",
      "96:    continue",
      "97:   }",
      "99:   if err := unix.Close(m); err != nil {",
      "100:    return fmt.Errorf(\"Unable to close mountFds fds: %w\", err)",
      "101:   }",
      "102:  }",
      "104:  if err != nil {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ff692f289b60e19b3079cbbbaa14c426225dc20f",
      "candidate_info": {
        "commit_hash": "ff692f289b60e19b3079cbbbaa14c426225dc20f",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/ff692f289b60e19b3079cbbbaa14c426225dc20f",
        "files": [
          "libcontainer/container_linux.go",
          "libcontainer/init_linux.go",
          "libcontainer/rootfs_linux.go",
          "libcontainer/specconv/example.go"
        ],
        "message": "Fix cgroup2 mount for rootless case\n\nIn case of rootless, cgroup2 mount is not possible (see [1] for more\ndetails), so since commit 9c81440fb5a7 runc bind-mounts the whole\n/sys/fs/cgroup into container.\n\nProblem is, if cgroupns is enabled, /sys/fs/cgroup inside the container\nis supposed to show the cgroup files for this cgroup, not the root one.\n\nThe fix is to pass through and use the cgroup path in case cgroup2\nmount failed, cgroupns is enabled, and the path is non-empty.\n\nSurely this requires the /sys/fs/cgroup mount in the spec, so modify\nrunc spec --rootless to keep it.\n\nBefore:\n\n\t$ ./runc run aaa\n\t# find /sys/fs/cgroup/ -type d\n\t/sys/fs/cgroup\n\t/sys/fs/cgroup/user.slice\n\t/sys/fs/cgroup/user.slice/user-1000.slice\n\t/sys/fs/cgroup/user.slice/user-1000.slice/user@1000.service\n\t...\n\t# ls -l /sys/fs/cgroup/cgroup.controllers\n\t-r--r--r--    1 nobody   nogroup          0 Feb 24 02:22 /sys/fs/cgroup/cgroup.controllers\n\t# wc -w /sys/fs/cgroup/cgroup.procs\n\t142 /sys/fs/cgroup/cgroup.procs\n\t# cat /sys/fs/cgroup/memory.current\n\tcat: can't open '/sys/fs/cgroup/memory.current': No such file or directory\n\nAfter:\n\n\t# find /sys/fs/cgroup/ -type d\n\t/sys/fs/cgroup/\n\t# ls -l /sys/fs/cgroup/cgroup.controllers\n\t-r--r--r--    1 root     root             0 Feb 24 02:43 /sys/fs/cgroup/cgroup.controllers\n\t# wc -w /sys/fs/cgroup/cgroup.procs\n\t2 /sys/fs/cgroup/cgroup.procs\n\t# cat /sys/fs/cgroup/memory.current\n\t577536\n\n[1] https://github.com/opencontainers/runc/issues/2158\n\nSigned-off-by: Kir Kolyshkin <kolyshkin@gmail.com>",
        "before_after_code_files": [
          "libcontainer/container_linux.go||libcontainer/container_linux.go",
          "libcontainer/init_linux.go||libcontainer/init_linux.go",
          "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go",
          "libcontainer/specconv/example.go||libcontainer/specconv/example.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libcontainer/container_linux.go||libcontainer/container_linux.go",
            "libcontainer/init_linux.go||libcontainer/init_linux.go",
            "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go"
          ],
          "candidate": [
            "libcontainer/container_linux.go||libcontainer/container_linux.go",
            "libcontainer/init_linux.go||libcontainer/init_linux.go",
            "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go"
          ]
        }
      },
      "candidate_diff": {
        "libcontainer/container_linux.go||libcontainer/container_linux.go": [
          "File: libcontainer/container_linux.go -> libcontainer/container_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "626:  if len(process.Rlimits) > 0 {",
          "627:   cfg.Rlimits = process.Rlimits",
          "628:  }",
          "630:  return cfg",
          "631: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "629:  if cgroups.IsCgroup2UnifiedMode() {",
          "630:   cfg.Cgroup2Path = c.cgroupManager.Path(\"\")",
          "631:  }",
          "",
          "---------------"
        ],
        "libcontainer/init_linux.go||libcontainer/init_linux.go": [
          "File: libcontainer/init_linux.go -> libcontainer/init_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:  RootlessEUID     bool                  `json:\"rootless_euid,omitempty\"`",
          "71:  RootlessCgroups  bool                  `json:\"rootless_cgroups,omitempty\"`",
          "72:  SpecState        *specs.State          `json:\"spec_state,omitempty\"`",
          "73: }",
          "75: type initer interface {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73:  Cgroup2Path      string                `json:\"cgroup2_path,omitempty\"`",
          "",
          "---------------"
        ],
        "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go": [
          "File: libcontainer/rootfs_linux.go -> libcontainer/rootfs_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: const defaultMountFlags = unix.MS_NOEXEC | unix.MS_NOSUID | unix.MS_NODEV",
          "33: type mountConfig struct {",
          "37: }",
          "",
          "[Removed Lines]",
          "34:  root     string",
          "35:  label    string",
          "36:  cgroupns bool",
          "",
          "[Added Lines]",
          "34:  root            string",
          "35:  label           string",
          "36:  cgroup2Path     string",
          "37:  rootlessCgroups bool",
          "38:  cgroupns        bool",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "56:  }",
          "58:  mountConfig := &mountConfig{",
          "62:  }",
          "63:  setupDev := needsSetupDev(config)",
          "64:  for _, m := range config.Mounts {",
          "",
          "[Removed Lines]",
          "59:   root:     config.Rootfs,",
          "60:   label:    config.MountLabel,",
          "61:   cgroupns: config.Namespaces.Contains(configs.NEWCGROUP),",
          "",
          "[Added Lines]",
          "61:   root:            config.Rootfs,",
          "62:   label:           config.MountLabel,",
          "63:   cgroup2Path:     iConfig.Cgroup2Path,",
          "64:   rootlessCgroups: iConfig.RootlessCgroups,",
          "65:   cgroupns:        config.Namespaces.Contains(configs.NEWCGROUP),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "308:   if err == unix.EPERM || err == unix.EBUSY {",
          "309:    src := fs2.UnifiedMountpoint",
          "311:   }",
          "312:   return err",
          "313:  }",
          "",
          "[Removed Lines]",
          "310:    return unix.Mount(src, dest, \"\", uintptr(m.Flags)|unix.MS_BIND, \"\")",
          "",
          "[Added Lines]",
          "314:    if c.cgroupns && c.cgroup2Path != \"\" {",
          "318:     src = c.cgroup2Path",
          "319:    }",
          "320:    err = unix.Mount(src, dest, \"\", uintptr(m.Flags)|unix.MS_BIND, \"\")",
          "321:    if err == unix.ENOENT && c.rootlessCgroups {",
          "322:     err = nil",
          "323:    }",
          "324:    return err",
          "",
          "---------------"
        ],
        "libcontainer/specconv/example.go||libcontainer/specconv/example.go": [
          "File: libcontainer/specconv/example.go -> libcontainer/specconv/example.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import (",
          "4:  \"os\"",
          "5:  \"strings\"",
          "7:  \"github.com/opencontainers/runc/libcontainer/cgroups\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5:  \"path/filepath\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "201:  var mounts []specs.Mount",
          "202:  for _, mount := range spec.Mounts {",
          "205:    continue",
          "206:   }",
          "",
          "[Removed Lines]",
          "204:   if strings.HasPrefix(mount.Destination, \"/sys\") {",
          "",
          "[Added Lines]",
          "205:   if filepath.Clean(mount.Destination) == \"/sys\" {",
          "206:    mounts = append(mounts, specs.Mount{",
          "207:     Source:      \"/sys\",",
          "208:     Destination: \"/sys\",",
          "209:     Type:        \"none\",",
          "210:     Options:     []string{\"rbind\", \"nosuid\", \"noexec\", \"nodev\", \"ro\"},",
          "211:    })",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "216:   mount.Options = options",
          "217:   mounts = append(mounts, mount)",
          "218:  }",
          "226:  spec.Mounts = mounts",
          "",
          "[Removed Lines]",
          "220:  mounts = append(mounts, specs.Mount{",
          "221:   Source:      \"/sys\",",
          "222:   Destination: \"/sys\",",
          "223:   Type:        \"none\",",
          "224:   Options:     []string{\"rbind\", \"nosuid\", \"noexec\", \"nodev\", \"ro\"},",
          "225:  })",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "35e6c3bf794326ad7844aa2e25efd4946a7addbe",
      "candidate_info": {
        "commit_hash": "35e6c3bf794326ad7844aa2e25efd4946a7addbe",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/35e6c3bf794326ad7844aa2e25efd4946a7addbe",
        "files": [
          "libcontainer/nsenter/nsexec.c"
        ],
        "message": "libct/nsenter: switch to sane_kill()\n\nSigned-off-by: guodong <guodong9211@gmail.com>",
        "before_after_code_files": [
          "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c"
          ],
          "candidate": [
            "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c"
          ]
        }
      },
      "candidate_diff": {
        "libcontainer/nsenter/nsexec.c||libcontainer/nsenter/nsexec.c": [
          "File: libcontainer/nsenter/nsexec.c -> libcontainer/nsenter/nsexec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1069:      s = SYNC_MOUNTSOURCES_ACK;",
          "1070:      if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {",
          "1072:       bail(\"failed to sync with child: write(SYNC_MOUNTSOURCES_ACK)\");",
          "1073:      }",
          "1074:      break;",
          "",
          "[Removed Lines]",
          "1071:       kill(stage1_pid, SIGKILL);",
          "",
          "[Added Lines]",
          "1071:       sane_kill(stage1_pid, SIGKILL);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1230:    if (config.mountsources) {",
          "1231:     s = SYNC_MOUNTSOURCES_PLS;",
          "1232:     if (write(syncfd, &s, sizeof(s)) != sizeof(s)) {",
          "1234:      bail(\"failed to sync with parent: write(SYNC_MOUNTSOURCES_PLS)\");",
          "1235:     }",
          "",
          "[Removed Lines]",
          "1233:      kill(stage2_pid, SIGKILL);",
          "",
          "[Added Lines]",
          "1233:      sane_kill(stage2_pid, SIGKILL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1241:     if (read(syncfd, &s, sizeof(s)) != sizeof(s)) {",
          "1243:      bail(\"failed to sync with parent: read(SYNC_MOUNTSOURCES_ACK)\");",
          "1244:     }",
          "1245:     if (s != SYNC_MOUNTSOURCES_ACK) {",
          "1247:      bail(\"failed to sync with parent: SYNC_MOUNTSOURCES_ACK: got %u\", s);",
          "1248:     }",
          "1249:    }",
          "",
          "[Removed Lines]",
          "1242:      kill(stage2_pid, SIGKILL);",
          "1246:      kill(stage2_pid, SIGKILL);",
          "",
          "[Added Lines]",
          "1242:      sane_kill(stage2_pid, SIGKILL);",
          "1246:      sane_kill(stage2_pid, SIGKILL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0ca91f44f1664da834bc61115a849b56d22f595f",
      "candidate_info": {
        "commit_hash": "0ca91f44f1664da834bc61115a849b56d22f595f",
        "repo": "opencontainers/runc",
        "commit_url": "https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f",
        "files": [
          "libcontainer/container_linux.go",
          "libcontainer/rootfs_linux.go",
          "libcontainer/utils/utils.go",
          "libcontainer/utils/utils_test.go"
        ],
        "message": "rootfs: add mount destination validation\n\nBecause the target of a mount is inside a container (which may be a\nvolume that is shared with another container), there exists a race\ncondition where the target of the mount may change to a path containing\na symlink after we have sanitised the path -- resulting in us\ninadvertently mounting the path outside of the container.\n\nThis is not immediately useful because we are in a mount namespace with\nMS_SLAVE mount propagation applied to \"/\", so we cannot mount on top of\nhost paths in the host namespace. However, if any subsequent mountpoints\nin the configuration use a subdirectory of that host path as a source,\nthose subsequent mounts will use an attacker-controlled source path\n(resolved within the host rootfs) -- allowing the bind-mounting of \"/\"\ninto the container.\n\nWhile arguably configuration issues like this are not entirely within\nrunc's threat model, within the context of Kubernetes (and possibly\nother container managers that provide semi-arbitrary container creation\nprivileges to untrusted users) this is a legitimate issue. Since we\ncannot block mounting from the host into the container, we need to block\nthe first stage of this attack (mounting onto a path outside the\ncontainer).\n\nThe long-term plan to solve this would be to migrate to libpathrs, but\nas a stop-gap we implement libpathrs-like path verification through\nreadlink(/proc/self/fd/$n) and then do mount operations through the\nprocfd once it's been verified to be inside the container. The target\ncould move after we've checked it, but if it is inside the container\nthen we can assume that it is safe for the same reason that libpathrs\noperations would be safe.\n\nA slight wrinkle is the \"copyup\" functionality we provide for tmpfs,\nwhich is the only case where we want to do a mount on the host\nfilesystem. To facilitate this, I split out the copy-up functionality\nentirely so that the logic isn't interspersed with the regular tmpfs\nlogic. In addition, all dependencies on m.Destination being overwritten\nhave been removed since that pattern was just begging to be a source of\nmore mount-target bugs (we do still have to modify m.Destination for\ntmpfs-copyup but we only do it temporarily).\n\nFixes: CVE-2021-30465\nReported-by: Etienne Champetier <champetier.etienne@gmail.com>\nCo-authored-by: Noah Meyerhans <nmeyerha@amazon.com>\nReviewed-by: Samuel Karp <skarp@amazon.com>\nReviewed-by: Kir Kolyshkin <kolyshkin@gmail.com> (@kolyshkin)\nReviewed-by: Akihiro Suda <akihiro.suda.cz@hco.ntt.co.jp>\nSigned-off-by: Aleksa Sarai <cyphar@cyphar.com>",
        "before_after_code_files": [
          "libcontainer/container_linux.go||libcontainer/container_linux.go",
          "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go",
          "libcontainer/utils/utils.go||libcontainer/utils/utils.go",
          "libcontainer/utils/utils_test.go||libcontainer/utils/utils_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libcontainer/container_linux.go||libcontainer/container_linux.go",
            "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go"
          ],
          "candidate": [
            "libcontainer/container_linux.go||libcontainer/container_linux.go",
            "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go"
          ]
        }
      },
      "candidate_diff": {
        "libcontainer/container_linux.go||libcontainer/container_linux.go": [
          "File: libcontainer/container_linux.go -> libcontainer/container_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "1217:   if err := checkProcMount(c.config.Rootfs, dest, \"\"); err != nil {",
          "1218:    return err",
          "1219:   }",
          "1221:   if err := os.MkdirAll(dest, 0755); err != nil {",
          "1222:    return err",
          "1223:   }",
          "",
          "[Removed Lines]",
          "1220:   m.Destination = dest",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1257:  umounts := []string{}",
          "1258:  defer func() {",
          "1259:   for _, u := range umounts {",
          "1265:     }",
          "1267:   }",
          "1268:  }()",
          "1269:  for _, m := range mounts {",
          "",
          "[Removed Lines]",
          "1260:    if e := unix.Unmount(u, unix.MNT_DETACH); e != nil {",
          "1261:     if e != unix.EINVAL {",
          "1264:      logrus.Warnf(\"Error during cleanup unmounting of %q (%v)\", u, e)",
          "1266:    }",
          "",
          "[Added Lines]",
          "1259:    _ = utils.WithProcfd(c.config.Rootfs, u, func(procfd string) error {",
          "1260:     if e := unix.Unmount(procfd, unix.MNT_DETACH); e != nil {",
          "1261:      if e != unix.EINVAL {",
          "1264:       logrus.Warnf(\"Error during cleanup unmounting of %s (%s): %v\", procfd, u, e)",
          "1265:      }",
          "1267:     return nil",
          "1268:    })",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1283:    if m.Device == \"bind\" {",
          "1286:     }",
          "1287:     umounts = append(umounts, m.Destination)",
          "1288:    }",
          "",
          "[Removed Lines]",
          "1284:     if err := unix.Mount(m.Source, m.Destination, \"\", unix.MS_BIND|unix.MS_REC, \"\"); err != nil {",
          "1285:      return errorsf.Wrapf(err, \"unable to bind mount %q to %q\", m.Source, m.Destination)",
          "",
          "[Added Lines]",
          "1286:     if err := utils.WithProcfd(c.config.Rootfs, m.Destination, func(procfd string) error {",
          "1287:      if err := unix.Mount(m.Source, procfd, \"\", unix.MS_BIND|unix.MS_REC, \"\"); err != nil {",
          "1288:       return errorsf.Wrapf(err, \"unable to bind mount %q to %q (through %q)\", m.Source, m.Destination, procfd)",
          "1289:      }",
          "1290:      return nil",
          "1291:     }); err != nil {",
          "1292:      return err",
          "",
          "---------------"
        ],
        "libcontainer/rootfs_linux.go||libcontainer/rootfs_linux.go": [
          "File: libcontainer/rootfs_linux.go -> libcontainer/rootfs_linux.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:  libcontainerUtils \"github.com/opencontainers/runc/libcontainer/utils\"",
          "26:  \"github.com/opencontainers/runtime-spec/specs-go\"",
          "27:  \"github.com/opencontainers/selinux/go-selinux/label\"",
          "28:  \"golang.org/x/sys/unix\"",
          "29: )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28:  \"github.com/sirupsen/logrus\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "228:  if err := checkProcMount(rootfs, dest, m.Source); err != nil {",
          "229:   return err",
          "230:  }",
          "233:  if err := createIfNotExists(dest, stat.IsDir()); err != nil {",
          "234:   return err",
          "235:  }",
          "",
          "[Removed Lines]",
          "232:  m.Destination = dest",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "266:    if err := os.MkdirAll(subsystemPath, 0755); err != nil {",
          "267:     return err",
          "268:    }",
          "281:     return err",
          "282:    }",
          "283:   } else {",
          "",
          "[Removed Lines]",
          "269:    flags := defaultMountFlags",
          "270:    if m.Flags&unix.MS_RDONLY != 0 {",
          "271:     flags = flags | unix.MS_RDONLY",
          "272:    }",
          "273:    cgroupmount := &configs.Mount{",
          "274:     Source:      \"cgroup\",",
          "275:     Device:      \"cgroup\", // this is actually fstype",
          "276:     Destination: subsystemPath,",
          "277:     Flags:       flags,",
          "278:     Data:        filepath.Base(subsystemPath),",
          "279:    }",
          "280:    if err := mountNewCgroup(cgroupmount); err != nil {",
          "",
          "[Added Lines]",
          "268:    if err := utils.WithProcfd(c.root, b.Destination, func(procfd string) error {",
          "269:     flags := defaultMountFlags",
          "270:     if m.Flags&unix.MS_RDONLY != 0 {",
          "271:      flags = flags | unix.MS_RDONLY",
          "272:     }",
          "273:     var (",
          "274:      source = \"cgroup\"",
          "275:      data   = filepath.Base(subsystemPath)",
          "276:     )",
          "277:     if data == \"systemd\" {",
          "278:      data = cgroups.CgroupNamePrefix + data",
          "279:      source = \"systemd\"",
          "280:     }",
          "281:     return unix.Mount(source, procfd, \"cgroup\", uintptr(flags), data)",
          "282:    }); err != nil {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "307:  if err := os.MkdirAll(dest, 0755); err != nil {",
          "308:   return err",
          "309:  }",
          "323:    }",
          "324:    return err",
          "325:   }",
          "326:   return err",
          "327:  }",
          "329: }",
          "331: func mountToRootfs(m *configs.Mount, c *mountConfig) error {",
          "332:  rootfs := c.root",
          "333:  mountLabel := c.label",
          "337:  }",
          "339:  switch m.Device {",
          "",
          "[Removed Lines]",
          "310:  if err := unix.Mount(m.Source, dest, \"cgroup2\", uintptr(m.Flags), m.Data); err != nil {",
          "312:   if err == unix.EPERM || err == unix.EBUSY {",
          "313:    src := fs2.UnifiedMountpoint",
          "314:    if c.cgroupns && c.cgroup2Path != \"\" {",
          "318:     src = c.cgroup2Path",
          "319:    }",
          "320:    err = unix.Mount(src, dest, \"\", uintptr(m.Flags)|unix.MS_BIND, \"\")",
          "321:    if err == unix.ENOENT && c.rootlessCgroups {",
          "322:     err = nil",
          "328:  return nil",
          "334:  dest := m.Destination",
          "335:  if !strings.HasPrefix(dest, rootfs) {",
          "336:   dest = filepath.Join(rootfs, dest)",
          "",
          "[Added Lines]",
          "312:  return utils.WithProcfd(c.root, m.Destination, func(procfd string) error {",
          "313:   if err := unix.Mount(m.Source, procfd, \"cgroup2\", uintptr(m.Flags), m.Data); err != nil {",
          "315:    if err == unix.EPERM || err == unix.EBUSY {",
          "316:     src := fs2.UnifiedMountpoint",
          "317:     if c.cgroupns && c.cgroup2Path != \"\" {",
          "321:      src = c.cgroup2Path",
          "322:     }",
          "323:     err = unix.Mount(src, procfd, \"\", uintptr(m.Flags)|unix.MS_BIND, \"\")",
          "324:     if err == unix.ENOENT && c.rootlessCgroups {",
          "325:      err = nil",
          "326:     }",
          "330:   return nil",
          "331:  })",
          "332: }",
          "334: func doTmpfsCopyUp(m *configs.Mount, rootfs, mountLabel string) (Err error) {",
          "336:  tmpdir, err := prepareTmp(\"/tmp\")",
          "337:  if err != nil {",
          "338:   return newSystemErrorWithCause(err, \"tmpcopyup: failed to setup tmpdir\")",
          "339:  }",
          "340:  defer cleanupTmp(tmpdir)",
          "341:  tmpDir, err := ioutil.TempDir(tmpdir, \"runctmpdir\")",
          "342:  if err != nil {",
          "343:   return newSystemErrorWithCause(err, \"tmpcopyup: failed to create tmpdir\")",
          "344:  }",
          "345:  defer os.RemoveAll(tmpDir)",
          "349:  oldDest := m.Destination",
          "350:  m.Destination = tmpDir",
          "351:  err = mountPropagate(m, \"/\", mountLabel)",
          "352:  m.Destination = oldDest",
          "353:  if err != nil {",
          "356:  defer func() {",
          "357:   if Err != nil {",
          "358:    if err := unix.Unmount(tmpDir, unix.MNT_DETACH); err != nil {",
          "359:     logrus.Warnf(\"tmpcopyup: failed to unmount tmpdir on error: %v\", err)",
          "360:    }",
          "361:   }",
          "362:  }()",
          "364:  return utils.WithProcfd(rootfs, m.Destination, func(procfd string) (Err error) {",
          "368:   if err := fileutils.CopyDirectory(procfd+\"/\", tmpDir); err != nil {",
          "369:    return fmt.Errorf(\"tmpcopyup: failed to copy %s to %s (%s): %w\", m.Destination, procfd, tmpDir, err)",
          "370:   }",
          "372:   if err := unix.Mount(tmpDir, procfd, \"\", unix.MS_MOVE, \"\"); err != nil {",
          "373:    return fmt.Errorf(\"tmpcopyup: failed to move mount %s to %s (%s): %w\", tmpDir, procfd, m.Destination, err)",
          "374:   }",
          "375:   return nil",
          "376:  })",
          "382:  dest, err := securejoin.SecureJoin(rootfs, m.Destination)",
          "383:  if err != nil {",
          "384:   return err",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "364:   }",
          "365:   return label.SetFileLabel(dest, mountLabel)",
          "366:  case \"tmpfs\":",
          "376:   stat, err := os.Stat(dest)",
          "377:   if err != nil {",
          "378:    if err := os.MkdirAll(dest, 0755); err != nil {",
          "379:     return err",
          "380:    }",
          "381:   }",
          "394:   }",
          "396:    return err",
          "397:   }",
          "414:   if stat != nil {",
          "415:    if err = os.Chmod(dest, stat.Mode()); err != nil {",
          "416:     return err",
          "",
          "[Removed Lines]",
          "367:   copyUp := m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP",
          "368:   tmpDir := \"\"",
          "371:   dest, err := securejoin.SecureJoin(rootfs, m.Destination)",
          "372:   if err != nil {",
          "373:    return err",
          "374:   }",
          "375:   m.Destination = dest",
          "382:   if copyUp {",
          "383:    tmpdir, err := prepareTmp(\"/tmp\")",
          "384:    if err != nil {",
          "385:     return newSystemErrorWithCause(err, \"tmpcopyup: failed to setup tmpdir\")",
          "386:    }",
          "387:    defer cleanupTmp(tmpdir)",
          "388:    tmpDir, err = ioutil.TempDir(tmpdir, \"runctmpdir\")",
          "389:    if err != nil {",
          "390:     return newSystemErrorWithCause(err, \"tmpcopyup: failed to create tmpdir\")",
          "391:    }",
          "392:    defer os.RemoveAll(tmpDir)",
          "393:    m.Destination = tmpDir",
          "395:   if err := mountPropagate(m, rootfs, mountLabel); err != nil {",
          "398:   if copyUp {",
          "399:    if err := fileutils.CopyDirectory(dest, tmpDir); err != nil {",
          "400:     errMsg := fmt.Errorf(\"tmpcopyup: failed to copy %s to %s: %v\", dest, tmpDir, err)",
          "401:     if err1 := unix.Unmount(tmpDir, unix.MNT_DETACH); err1 != nil {",
          "402:      return newSystemErrorWithCausef(err1, \"tmpcopyup: %v: failed to unmount\", errMsg)",
          "403:     }",
          "404:     return errMsg",
          "405:    }",
          "406:    if err := unix.Mount(tmpDir, dest, \"\", unix.MS_MOVE, \"\"); err != nil {",
          "407:     errMsg := fmt.Errorf(\"tmpcopyup: failed to move mount %s to %s: %v\", tmpDir, dest, err)",
          "408:     if err1 := unix.Unmount(tmpDir, unix.MNT_DETACH); err1 != nil {",
          "409:      return newSystemErrorWithCausef(err1, \"tmpcopyup: %v: failed to unmount\", errMsg)",
          "410:     }",
          "411:     return errMsg",
          "412:    }",
          "413:   }",
          "",
          "[Added Lines]",
          "422:   if m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP {",
          "423:    err = doTmpfsCopyUp(m, rootfs, mountLabel)",
          "424:   } else {",
          "425:    err = mountPropagate(m, rootfs, mountLabel)",
          "427:   if err != nil {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "454:   }",
          "455:   return mountCgroupV1(m, c)",
          "456:  default:",
          "465:   if err := checkProcMount(rootfs, dest, m.Source); err != nil {",
          "466:    return err",
          "467:   }",
          "470:   if err := os.MkdirAll(dest, 0755); err != nil {",
          "471:    return err",
          "472:   }",
          "",
          "[Removed Lines]",
          "461:   var err error",
          "462:   if dest, err = securejoin.SecureJoin(rootfs, m.Destination); err != nil {",
          "463:    return err",
          "464:   }",
          "469:   m.Destination = dest",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "649:  return nil",
          "650: }",
          "653:  f, err := os.Create(dest)",
          "654:  if err != nil && !os.IsExist(err) {",
          "655:   return err",
          "",
          "[Removed Lines]",
          "652: func bindMountDeviceNode(dest string, node *devices.Device) error {",
          "",
          "[Added Lines]",
          "658: func bindMountDeviceNode(rootfs, dest string, node *devices.Device) error {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "657:  if f != nil {",
          "658:   f.Close()",
          "659:  }",
          "661: }",
          "",
          "[Removed Lines]",
          "660:  return unix.Mount(node.Path, dest, \"bind\", unix.MS_BIND, \"\")",
          "",
          "[Added Lines]",
          "666:  return utils.WithProcfd(rootfs, dest, func(procfd string) error {",
          "667:   return unix.Mount(node.Path, procfd, \"bind\", unix.MS_BIND, \"\")",
          "668:  })",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "667:   return nil",
          "668:  }",
          "670:  if err := os.MkdirAll(filepath.Dir(dest), 0755); err != nil {",
          "671:   return err",
          "672:  }",
          "673:  if bind {",
          "675:  }",
          "676:  if err := mknodDevice(dest, node); err != nil {",
          "677:   if os.IsExist(err) {",
          "678:    return nil",
          "679:   } else if os.IsPermission(err) {",
          "681:   }",
          "682:   return err",
          "683:  }",
          "",
          "[Removed Lines]",
          "669:  dest := filepath.Join(rootfs, node.Path)",
          "674:   return bindMountDeviceNode(dest, node)",
          "680:    return bindMountDeviceNode(dest, node)",
          "",
          "[Added Lines]",
          "677:  dest, err := securejoin.SecureJoin(rootfs, node.Path)",
          "678:  if err != nil {",
          "679:   return err",
          "680:  }",
          "685:   return bindMountDeviceNode(rootfs, dest, node)",
          "691:    return bindMountDeviceNode(rootfs, dest, node)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1024: }",
          "1026: func remount(m *configs.Mount, rootfs string) error {",
          "1034: }",
          "1038: func mountPropagate(m *configs.Mount, rootfs string, mountLabel string) error {",
          "1039:  var (",
          "1041:   data  = label.FormatMountLabel(m.Data, mountLabel)",
          "1042:   flags = m.Flags",
          "1043:  )",
          "1051:   flags &= ^unix.MS_RDONLY",
          "1052:  }",
          "1066:   }",
          "1082:  }",
          "1083:  return nil",
          "1084: }",
          "",
          "[Removed Lines]",
          "1027:  var (",
          "1028:   dest = m.Destination",
          "1029:  )",
          "1030:  if !strings.HasPrefix(dest, rootfs) {",
          "1031:   dest = filepath.Join(rootfs, dest)",
          "1032:  }",
          "1033:  return unix.Mount(m.Source, dest, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")",
          "1040:   dest  = m.Destination",
          "1044:  if libcontainerUtils.CleanPath(dest) == \"/dev\" {",
          "1045:   flags &= ^unix.MS_RDONLY",
          "1046:  }",
          "1050:  if m.Device == \"tmpfs\" {",
          "1054:  copyUp := m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP",
          "1055:  if !(copyUp || strings.HasPrefix(dest, rootfs)) {",
          "1056:   dest = filepath.Join(rootfs, dest)",
          "1057:  }",
          "1059:  if err := unix.Mount(m.Source, dest, m.Device, uintptr(flags), data); err != nil {",
          "1060:   return err",
          "1061:  }",
          "1063:  for _, pflag := range m.PropagationFlags {",
          "1064:   if err := unix.Mount(\"\", dest, \"\", uintptr(pflag), \"\"); err != nil {",
          "1065:    return err",
          "1067:  }",
          "1068:  return nil",
          "1069: }",
          "1071: func mountNewCgroup(m *configs.Mount) error {",
          "1072:  var (",
          "1073:   data   = m.Data",
          "1074:   source = m.Source",
          "1075:  )",
          "1076:  if data == \"systemd\" {",
          "1077:   data = cgroups.CgroupNamePrefix + data",
          "1078:   source = \"systemd\"",
          "1079:  }",
          "1080:  if err := unix.Mount(source, m.Destination, m.Device, uintptr(m.Flags), data); err != nil {",
          "1081:   return err",
          "",
          "[Added Lines]",
          "1038:  return utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {",
          "1039:   return unix.Mount(m.Source, procfd, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")",
          "1040:  })",
          "1054:  if libcontainerUtils.CleanPath(m.Destination) == \"/dev\" || m.Device == \"tmpfs\" {",
          "1062:  if err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {",
          "1063:   return unix.Mount(m.Source, procfd, m.Device, uintptr(flags), data)",
          "1064:  }); err != nil {",
          "1065:   return fmt.Errorf(\"mount through procfd: %w\", err)",
          "1066:  }",
          "1070:  if err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {",
          "1071:   for _, pflag := range m.PropagationFlags {",
          "1072:    if err := unix.Mount(\"\", procfd, \"\", uintptr(pflag), \"\"); err != nil {",
          "1073:     return err",
          "1074:    }",
          "1076:   return nil",
          "1077:  }); err != nil {",
          "1078:   return fmt.Errorf(\"change mount propagation through procfd: %w\", err)",
          "",
          "---------------"
        ],
        "libcontainer/utils/utils.go||libcontainer/utils/utils.go": [
          "File: libcontainer/utils/utils.go -> libcontainer/utils/utils.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import (",
          "4:  \"encoding/binary\"",
          "5:  \"encoding/json\"",
          "6:  \"io\"",
          "7:  \"os\"",
          "8:  \"path/filepath\"",
          "9:  \"strings\"",
          "10:  \"unsafe\"",
          "12:  \"golang.org/x/sys/unix\"",
          "13: )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6:  \"fmt\"",
          "10:  \"strconv\"",
          "14:  \"github.com/cyphar/filepath-securejoin\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "88:  return filepath.Clean(path)",
          "89: }",
          "93: func SearchLabels(labels []string, query string) string {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "98: func stripRoot(root, path string) string {",
          "100:  root, path = CleanPath(\"/\"+root), CleanPath(\"/\"+path)",
          "101:  switch {",
          "102:  case path == root:",
          "103:   path = \"/\"",
          "104:  case root == \"/\":",
          "106:  case strings.HasPrefix(path, root+\"/\"):",
          "107:   path = strings.TrimPrefix(path, root+\"/\")",
          "108:  }",
          "109:  return CleanPath(\"/\" + path)",
          "110: }",
          "118: func WithProcfd(root, unsafePath string, fn func(procfd string) error) error {",
          "120:  unsafePath = stripRoot(root, unsafePath)",
          "121:  path, err := securejoin.SecureJoin(root, unsafePath)",
          "122:  if err != nil {",
          "123:   return fmt.Errorf(\"resolving path inside rootfs failed: %v\", err)",
          "124:  }",
          "127:  fh, err := os.OpenFile(path, unix.O_PATH|unix.O_CLOEXEC, 0)",
          "128:  if err != nil {",
          "129:   return fmt.Errorf(\"open o_path procfd: %w\", err)",
          "130:  }",
          "131:  defer fh.Close()",
          "134:  procfd := \"/proc/self/fd/\" + strconv.Itoa(int(fh.Fd()))",
          "135:  if realpath, err := os.Readlink(procfd); err != nil {",
          "136:   return fmt.Errorf(\"procfd verification failed: %w\", err)",
          "137:  } else if realpath != path {",
          "138:   return fmt.Errorf(\"possibly malicious path detected -- refusing to operate on %s\", realpath)",
          "139:  }",
          "142:  return fn(procfd)",
          "143: }",
          "",
          "---------------"
        ],
        "libcontainer/utils/utils_test.go||libcontainer/utils/utils_test.go": [
          "File: libcontainer/utils/utils_test.go -> libcontainer/utils/utils_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "143:   t.Errorf(\"expected to receive '/foo' and received %s\", path)",
          "144:  }",
          "145: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "147: func TestStripRoot(t *testing.T) {",
          "148:  for _, test := range []struct {",
          "149:   root, path, out string",
          "150:  }{",
          "152:   {\"/a/b\", \"/a/b/c\", \"/c\"},",
          "153:   {\"/hello/world\", \"/hello/world/the/quick-brown/fox\", \"/the/quick-brown/fox\"},",
          "155:   {\"/\", \"/a/b/c\", \"/a/b/c\"},",
          "157:   {\"/a/b\", \"/a/c/b\", \"/a/c/b\"},",
          "159:   {\"/abc/def\", \"/foo/abc/def/bar\", \"/foo/abc/def/bar\"},",
          "161:   {\"/foo/bar\", \"/foo/barSAMECOMPONENT\", \"/foo/barSAMECOMPONENT\"},",
          "163:   {\"/foo/bar\", \"/foo/bar/foo/bar/baz\", \"/foo/bar/baz\"},",
          "165:   {\"/foo/bar\", \"/foo/bar/../baz\", \"/foo/baz\"},",
          "166:   {\"/foo/bar\", \"../../../../../../foo/bar/baz\", \"/baz\"},",
          "167:   {\"/foo/bar\", \"/../../../../../../foo/bar/baz\", \"/baz\"},",
          "168:   {\"/foo/bar/../baz\", \"/foo/baz/bar\", \"/bar\"},",
          "169:   {\"/foo/bar/../baz\", \"/foo/baz/../bar/../baz/./foo\", \"/foo\"},",
          "171:   {\"foo/bar\", \"/foo/bar/baz/bee\", \"/baz/bee\"},",
          "172:   {\"/foo/bar\", \"foo/bar/baz/beef\", \"/baz/beef\"},",
          "173:   {\"foo/bar\", \"foo/bar/baz/beets\", \"/baz/beets\"},",
          "174:  } {",
          "175:   got := stripRoot(test.root, test.path)",
          "176:   if got != test.out {",
          "177:    t.Errorf(\"stripRoot(%q, %q) -- got %q, expected %q\", test.root, test.path, got, test.out)",
          "178:   }",
          "179:  }",
          "180: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
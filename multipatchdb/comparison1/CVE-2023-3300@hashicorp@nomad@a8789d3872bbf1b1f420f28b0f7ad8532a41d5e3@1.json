{
  "cve_id": "CVE-2023-3300",
  "cve_desc": "HashiCorp Nomad and Nomad Enterprise 0.11.0 up to 1.5.6 and 1.4.1 HTTP search API can reveal names of available CSI plugins to unauthenticated users or users without the plugin:read policy. Fixed in 1.6.0, 1.5.7, and 1.4.1.",
  "repo": "hashicorp/nomad",
  "patch_hash": "a8789d3872bbf1b1f420f28b0f7ad8532a41d5e3",
  "patch_info": {
    "commit_hash": "a8789d3872bbf1b1f420f28b0f7ad8532a41d5e3",
    "repo": "hashicorp/nomad",
    "commit_url": "https://github.com/hashicorp/nomad/commit/a8789d3872bbf1b1f420f28b0f7ad8532a41d5e3",
    "files": [
      ".changelog/17906.txt",
      "acl/acl.go",
      "nomad/search_endpoint.go",
      "nomad/search_endpoint_oss.go",
      "nomad/search_endpoint_test.go"
    ],
    "message": "search: fix ACL filtering for plugins and variables\n\nACL permissions for the search endpoints are done in three passes. The\nfirst (the `sufficientSearchPerms` method) is for performance and coarsely\nrejects requests based on the passed-in context parameter if the user has no\npermissions to any object in that context. The second (the\n`filteredSearchContexts` method) filters out contexts based on whether the user\nhas permissions either to the requested namespace or again by context (to catch\nthe \"all\" context). Finally, when iterating over the objects available, we do\nthe usual filtering in the iterator.\n\nInternal testing found several bugs in this filtering:\n* CSI plugins can be searched by any authenticated user.\n* Variables can be searched if the user has `job:read` permissions to the\n  variable's namespace instead of `variable:list`.\n* Variables cannot be searched by wildcard namespace.\n\nThis is an information leak of the plugin names and variable paths, which we\ndon't consider to be privileged information but intended to protect anyways.\n\nThis changeset fixes these bugs by ensuring CSI plugins are filtered in the 1st\nand 2nd pass ACL filters, and changes variables to check `variable:list` in the\n2nd pass filter unless the wildcard namespace is passed (at which point we'll\nfallback to filtering in the iterator).\n\nFixes: CVE-2023-3300\nFixes: #17906",
    "before_after_code_files": [
      "acl/acl.go||acl/acl.go",
      "nomad/search_endpoint.go||nomad/search_endpoint.go",
      "nomad/search_endpoint_oss.go||nomad/search_endpoint_oss.go",
      "nomad/search_endpoint_test.go||nomad/search_endpoint_test.go"
    ]
  },
  "patch_diff": {
    "acl/acl.go||acl/acl.go": [
      "File: acl/acl.go -> acl/acl.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "505:  if a.management {",
      "506:   return true",
      "507:  }",
      "508:  iter := a.variables.Root().Iterator()",
      "509:  iter.SeekPrefix([]byte(ns))",
      "510:  _, _, ok := iter.Next()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "508:  if ns == \"*\" {",
      "509:   return a.variables.Len() > 0 || a.wildcardVariables.Len() > 0",
      "510:  }",
      "",
      "---------------"
    ],
    "nomad/search_endpoint.go||nomad/search_endpoint.go": [
      "File: nomad/search_endpoint.go -> nomad/search_endpoint.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "668:   return true",
      "669:  }",
      "684:  switch context {",
      "685:  case structs.Nodes:",
      "687:  case structs.NodePools:",
      "693:  case structs.Namespaces:",
      "697:  case structs.Volumes:",
      "698:   return acl.NamespaceValidator(acl.NamespaceCapabilityCSIListVolume,",
      "699:    acl.NamespaceCapabilityCSIReadVolume,",
      "",
      "[Removed Lines]",
      "671:  nodeRead := aclObj.AllowNodeRead()",
      "672:  allowNodePool := aclObj.AllowNodePoolSearch()",
      "673:  allowNS := aclObj.AllowNamespace(namespace)",
      "674:  jobRead := aclObj.AllowNsOp(namespace, acl.NamespaceCapabilityReadJob)",
      "675:  allowEnt := sufficientSearchPermsEnt(aclObj)",
      "677:  if !nodeRead && !allowNodePool && !allowNS && !allowEnt && !jobRead {",
      "678:   return false",
      "679:  }",
      "686:   return nodeRead",
      "692:   return allowNodePool",
      "694:   return allowNS",
      "695:  case structs.Allocs, structs.Deployments, structs.Evals, structs.Jobs:",
      "696:   return jobRead",
      "",
      "[Added Lines]",
      "679:   return aclObj.AllowNodeRead()",
      "685:   return aclObj.AllowNodePoolSearch()",
      "687:   return aclObj.AllowNamespace(namespace)",
      "688:  case structs.Allocs, structs.Deployments, structs.Evals, structs.Jobs,",
      "689:   structs.ScalingPolicies, structs.Recommendations:",
      "690:   return aclObj.AllowNsOp(namespace, acl.NamespaceCapabilityReadJob)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "701:    acl.NamespaceCapabilityReadJob)(aclObj, namespace)",
      "702:  case structs.Variables:",
      "703:   return aclObj.AllowVariableSearch(namespace)",
      "704:  }",
      "706:  return true",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "698:  case structs.Plugins:",
      "699:   return aclObj.AllowPluginList()",
      "700:  case structs.Quotas:",
      "701:   return aclObj.AllowQuotaRead()",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "927:     available = append(available, c)",
      "928:    }",
      "929:   case structs.Variables:",
      "931:     available = append(available, c)",
      "932:    }",
      "933:   case structs.Nodes:",
      "",
      "[Removed Lines]",
      "930:    if jobRead {",
      "",
      "[Added Lines]",
      "928:    if aclObj.AllowVariableSearch(namespace) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "942:    if volRead {",
      "943:     available = append(available, c)",
      "944:    }",
      "945:   default:",
      "946:    if ok := filteredSearchContextsEnt(aclObj, namespace, c); ok {",
      "947:     available = append(available, c)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "943:   case structs.Plugins:",
      "944:    if aclObj.AllowPluginList() {",
      "945:     available = append(available, c)",
      "946:    }",
      "",
      "---------------"
    ],
    "nomad/search_endpoint_oss.go||nomad/search_endpoint_oss.go": [
      "File: nomad/search_endpoint_oss.go -> nomad/search_endpoint_oss.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "51:  return nil, fmt.Errorf(\"context must be one of %v or 'all' for all contexts; got %q\", allContexts, context)",
      "52: }",
      "58: func filteredSearchContextsEnt(aclObj *acl.ACL, namespace string, context structs.Context) bool {",
      "59:  return true",
      "60: }",
      "",
      "[Removed Lines]",
      "54: func sufficientSearchPermsEnt(aclObj *acl.ACL) bool {",
      "55:  return true",
      "56: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "nomad/search_endpoint_test.go||nomad/search_endpoint_test.go": [
      "File: nomad/search_endpoint_test.go -> nomad/search_endpoint_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "19:  \"github.com/hashicorp/nomad/testutil\"",
      "20:  \"github.com/shoenig/test/must\"",
      "21:  \"github.com/stretchr/testify/require\"",
      "22: )",
      "24: const jobIndex = 1000",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "22:  \"golang.org/x/exp/slices\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "85:  defer cleanupS()",
      "86:  codec := rpcClient(t, s)",
      "87:  testutil.WaitForLeader(t, s.RPC)",
      "90:  job := registerMockJob(s, t, jobID, 0)",
      "93:  req := &structs.SearchRequest{",
      "94:   Prefix:  \"\",",
      "",
      "[Removed Lines]",
      "88:  fsmState := s.fsm.State()",
      "91:  require.NoError(t, fsmState.UpsertNode(structs.MsgTypeTestSetup, 1001, mock.Node()))",
      "",
      "[Added Lines]",
      "89:  store := s.fsm.State()",
      "91:  ns := mock.Namespace()",
      "92:  ns.Name = \"not-allowed\"",
      "93:  must.NoError(t, store.UpsertNamespaces(10, []*structs.Namespace{ns}))",
      "97:  variable := mock.VariableEncrypted()",
      "98:  resp := store.VarSet(1001, &structs.VarApplyStateRequest{",
      "99:   Op:  structs.VarOpSet,",
      "100:   Var: variable,",
      "101:  })",
      "102:  must.NoError(t, resp.Error)",
      "104:  plugin := mock.CSIPlugin()",
      "105:  must.NoError(t, store.UpsertCSIPlugin(1002, plugin))",
      "107:  node := mock.Node()",
      "108:  must.NoError(t, store.UpsertNode(structs.MsgTypeTestSetup, 1003, node))",
      "110:  disallowedVariable := mock.VariableEncrypted()",
      "111:  disallowedVariable.Namespace = \"not-allowed\"",
      "112:  resp = store.VarSet(2001, &structs.VarApplyStateRequest{",
      "113:   Op:  structs.VarOpSet,",
      "114:   Var: disallowedVariable,",
      "115:  })",
      "116:  must.NoError(t, resp.Error)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "103:  {",
      "104:   var resp structs.SearchResponse",
      "105:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
      "107:  }",
      "110:  {",
      "112:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityListJobs}))",
      "113:   req.AuthToken = invalidToken.SecretID",
      "114:   var resp structs.SearchResponse",
      "115:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
      "117:  }",
      "120:  {",
      "122:   req.AuthToken = validToken.SecretID",
      "123:   var resp structs.SearchResponse",
      "124:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
      "126:  }",
      "129:  {",
      "131:   req.Context = structs.All",
      "132:   req.AuthToken = validToken.SecretID",
      "133:   var resp structs.SearchResponse",
      "140:  }",
      "143:  {",
      "145:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}))",
      "146:   req.AuthToken = validToken.SecretID",
      "147:   var resp structs.SearchResponse",
      "157:  }",
      "160:  {",
      "162:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
      "163:    mock.NodePolicy(acl.PolicyRead),",
      "164:   }, \"\\n\"))",
      "165:   req.AuthToken = validToken.SecretID",
      "166:   var resp structs.SearchResponse",
      "172:  }",
      "175:  {",
      "176:   req.AuthToken = root.SecretID",
      "177:   var resp structs.SearchResponse",
      "183:  }",
      "184: }",
      "",
      "[Removed Lines]",
      "106:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
      "111:   invalidToken := mock.CreatePolicyAndToken(t, fsmState, 1003, \"test-invalid\",",
      "116:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
      "121:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
      "125:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
      "130:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
      "134:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "135:   require.Equal(t, uint64(1001), resp.Index)",
      "136:   require.Len(t, resp.Matches[structs.Nodes], 1)",
      "139:   require.Len(t, resp.Matches[structs.Jobs], 0)",
      "144:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1009, \"test-valid2\",",
      "148:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "149:   require.Len(t, resp.Matches[structs.Jobs], 1)",
      "150:   require.Equal(t, job.ID, resp.Matches[structs.Jobs][0])",
      "153:   require.Equal(t, uint64(1000), resp.Index)",
      "156:   require.Len(t, resp.Matches[structs.Nodes], 0)",
      "161:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1011, \"test-valid3\", strings.Join([]string{",
      "167:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "168:   require.Len(t, resp.Matches[structs.Jobs], 1)",
      "169:   require.Equal(t, job.ID, resp.Matches[structs.Jobs][0])",
      "170:   require.Len(t, resp.Matches[structs.Nodes], 1)",
      "171:   require.Equal(t, uint64(1001), resp.Index)",
      "178:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "179:   require.Equal(t, uint64(1001), resp.Index)",
      "180:   require.Len(t, resp.Matches[structs.Jobs], 1)",
      "181:   require.Equal(t, job.ID, resp.Matches[structs.Jobs][0])",
      "182:   require.Len(t, resp.Matches[structs.Nodes], 1)",
      "",
      "[Added Lines]",
      "131:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
      "136:   invalidToken := mock.CreatePolicyAndToken(t, store, 1003, \"test-invalid\",",
      "141:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
      "146:   validToken := mock.CreatePolicyAndToken(t, store, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
      "150:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
      "155:   validToken := mock.CreatePolicyAndToken(t, store, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
      "159:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "161:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
      "165:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
      "166:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
      "167:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
      "169:   must.Eq(t, uint64(1003), resp.Index) // index of node",
      "174:   validToken := mock.CreatePolicyAndToken(t, store, 1009, \"test-valid2\",",
      "178:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "180:   must.Eq(t, []string{job.ID}, resp.Matches[structs.Jobs])",
      "184:   must.SliceEmpty(t, resp.Matches[structs.Nodes])",
      "185:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
      "186:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
      "189:   must.Eq(t, uint64(1000), resp.Index)",
      "194:   validToken := mock.CreatePolicyAndToken(t, store, 1011, \"test-valid3\", strings.Join([]string{",
      "200:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "202:   must.Eq(t, []string{job.ID}, resp.Matches[structs.Jobs])",
      "203:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
      "204:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
      "205:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
      "206:   must.Eq(t, uint64(1003), resp.Index) // index of node",
      "207:  }",
      "210:  {",
      "211:   validToken := mock.CreatePolicyAndToken(t, store, 1012, \"test-valid4\", strings.Join([]string{",
      "212:    mock.NamespacePolicyWithVariables(structs.DefaultNamespace, \"\", []string{},",
      "213:     map[string][]string{\"*\": []string{\"list\"}}),",
      "214:    mock.NodePolicy(acl.PolicyRead),",
      "215:   }, \"\\n\"))",
      "216:   req.AuthToken = validToken.SecretID",
      "217:   var resp structs.SearchResponse",
      "218:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "220:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
      "221:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
      "222:   must.Eq(t, []string{variable.Path}, resp.Matches[structs.Variables])",
      "223:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
      "224:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
      "225:  }",
      "228:  {",
      "229:   validToken := mock.CreatePolicyAndToken(t, store, 1012, \"test-valid4\", strings.Join([]string{",
      "230:    mock.NamespacePolicyWithVariables(structs.DefaultNamespace, \"\", []string{},",
      "231:     map[string][]string{\"*\": []string{\"list\"}}),",
      "232:    mock.NodePolicy(acl.PolicyRead),",
      "233:   }, \"\\n\"))",
      "234:   req.AuthToken = validToken.SecretID",
      "235:   req.Namespace = structs.AllNamespacesSentinel",
      "236:   var resp structs.SearchResponse",
      "237:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "239:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
      "240:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
      "241:   must.Eq(t, []string{variable.Path}, resp.Matches[structs.Variables])",
      "242:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
      "243:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
      "249:   req.Namespace = structs.DefaultNamespace",
      "251:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "253:   must.Eq(t, []string{job.ID}, resp.Matches[structs.Jobs])",
      "254:   must.Eq(t, []string{plugin.ID}, resp.Matches[structs.Plugins])",
      "256:   expectVars := []string{variable.Path, disallowedVariable.Path}",
      "257:   slices.Sort(expectVars)",
      "258:   slices.Sort(resp.Matches[structs.Variables])",
      "259:   must.Eq(t, expectVars, resp.Matches[structs.Variables])",
      "260:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
      "261:   must.Eq(t, uint64(2001), resp.Index) // highest index",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1003:  codec := rpcClient(t, s)",
      "1004:  testutil.WaitForLeader(t, s.RPC)",
      "1007:  ns := mock.Namespace()",
      "1010:  job1 := mock.Job()",
      "1013:  job2 := mock.Job()",
      "1014:  job2.Namespace = ns.Name",
      "1019:  req := &structs.SearchRequest{",
      "1020:   Prefix:  \"\",",
      "",
      "[Removed Lines]",
      "1005:  fsmState := s.fsm.State()",
      "1008:  require.NoError(t, fsmState.UpsertNamespaces(500, []*structs.Namespace{ns}))",
      "1011:  require.NoError(t, fsmState.UpsertJob(structs.MsgTypeTestSetup, 502, nil, job1))",
      "1015:  require.NoError(t, fsmState.UpsertJob(structs.MsgTypeTestSetup, 504, nil, job2))",
      "1017:  require.NoError(t, fsmState.UpsertNode(structs.MsgTypeTestSetup, 1001, mock.Node()))",
      "",
      "[Added Lines]",
      "1084:  store := s.fsm.State()",
      "1087:  must.NoError(t, store.UpsertNamespaces(500, []*structs.Namespace{ns}))",
      "1090:  must.NoError(t, store.UpsertJob(structs.MsgTypeTestSetup, 502, nil, job1))",
      "1094:  must.NoError(t, store.UpsertJob(structs.MsgTypeTestSetup, 504, nil, job2))",
      "1096:  node := mock.Node()",
      "1097:  must.NoError(t, store.UpsertNode(structs.MsgTypeTestSetup, 1001, node))",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1029:  {",
      "1030:   var resp structs.SearchResponse",
      "1031:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
      "1033:  }",
      "1036:  {",
      "1038:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityListJobs}))",
      "1039:   req.AuthToken = invalidToken.SecretID",
      "1040:   var resp structs.SearchResponse",
      "1041:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
      "1043:  }",
      "1046:  {",
      "1048:   req.Context = structs.Namespaces",
      "1049:   req.AuthToken = validToken.SecretID",
      "1050:   var resp structs.SearchResponse",
      "1051:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
      "1053:  }",
      "1056:  {",
      "1058:   req.Context = structs.All",
      "1059:   req.AuthToken = validToken.SecretID",
      "1060:   var resp structs.SearchResponse",
      "1067:  }",
      "1070:  {",
      "1072:    mock.NamespacePolicy(job2.Namespace, \"\", []string{acl.NamespaceCapabilityReadJob}))",
      "1073:   req.Context = structs.All",
      "1074:   req.AuthToken = validToken.SecretID",
      "1075:   req.Namespace = job2.Namespace",
      "1076:   var resp structs.SearchResponse",
      "1087:  }",
      "1090:  {",
      "1092:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
      "1093:    mock.NodePolicy(acl.PolicyRead),",
      "1094:   }, \"\\n\"))",
      "",
      "[Removed Lines]",
      "1032:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
      "1037:   invalidToken := mock.CreatePolicyAndToken(t, fsmState, 1003, \"test-invalid\",",
      "1042:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
      "1047:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
      "1052:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
      "1057:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
      "1061:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "1062:   require.Equal(t, uint64(1001), resp.Index)",
      "1063:   require.Len(t, resp.Matches[structs.Nodes], 1)",
      "1066:   require.Len(t, resp.Matches[structs.Jobs], 0)",
      "1071:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1009, \"test-valid2\",",
      "1077:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "1078:   require.Len(t, resp.Matches[structs.Jobs], 1)",
      "1079:   require.Equal(t, job2.ID, resp.Matches[structs.Jobs][0])",
      "1080:   require.Len(t, resp.Matches[structs.Namespaces], 1)",
      "1083:   require.Equal(t, uint64(504), resp.Index)",
      "1086:   require.Len(t, resp.Matches[structs.Nodes], 0)",
      "1091:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1011, \"test-valid3\", strings.Join([]string{",
      "",
      "[Added Lines]",
      "1112:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
      "1117:   invalidToken := mock.CreatePolicyAndToken(t, store, 1003, \"test-invalid\",",
      "1122:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
      "1127:   validToken := mock.CreatePolicyAndToken(t, store, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
      "1132:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
      "1137:   validToken := mock.CreatePolicyAndToken(t, store, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
      "1141:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "1142:   must.Eq(t, uint64(1001), resp.Index)",
      "1143:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
      "1146:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
      "1151:   validToken := mock.CreatePolicyAndToken(t, store, 1009, \"test-valid2\",",
      "1157:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "1159:   must.Eq(t, []string{job2.ID}, resp.Matches[structs.Jobs])",
      "1160:   must.Eq(t, []string{ns.Name}, resp.Matches[structs.Namespaces])",
      "1163:   must.Eq(t, uint64(504), resp.Index)",
      "1166:   must.SliceEmpty(t, resp.Matches[structs.Nodes])",
      "1171:   validToken := mock.CreatePolicyAndToken(t, store, 1011, \"test-valid3\", strings.Join([]string{",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1096:   req.AuthToken = validToken.SecretID",
      "1097:   req.Namespace = structs.DefaultNamespace",
      "1098:   var resp structs.SearchResponse",
      "1105:  }",
      "",
      "[Removed Lines]",
      "1099:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "1100:   require.Len(t, resp.Matches[structs.Jobs], 1)",
      "1101:   require.Equal(t, job1.ID, resp.Matches[structs.Jobs][0])",
      "1102:   require.Len(t, resp.Matches[structs.Nodes], 1)",
      "1103:   require.Equal(t, uint64(1001), resp.Index)",
      "1104:   require.Len(t, resp.Matches[structs.Namespaces], 1)",
      "",
      "[Added Lines]",
      "1179:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "1181:   must.Eq(t, []string{job1.ID}, resp.Matches[structs.Jobs])",
      "1182:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
      "1183:   must.Eq(t, []string{\"default\"}, resp.Matches[structs.Namespaces])",
      "1185:   must.Eq(t, uint64(1001), resp.Index)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1110:   req.AuthToken = root.SecretID",
      "1111:   req.Namespace = structs.DefaultNamespace",
      "1112:   var resp structs.SearchResponse",
      "1119:  }",
      "1120: }",
      "",
      "[Removed Lines]",
      "1113:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "1114:   require.Equal(t, uint64(1001), resp.Index)",
      "1115:   require.Len(t, resp.Matches[structs.Jobs], 1)",
      "1116:   require.Equal(t, job1.ID, resp.Matches[structs.Jobs][0])",
      "1117:   require.Len(t, resp.Matches[structs.Nodes], 1)",
      "1118:   require.Len(t, resp.Matches[structs.Namespaces], 2)",
      "",
      "[Added Lines]",
      "1195:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
      "1197:   must.Eq(t, []string{job1.ID}, resp.Matches[structs.Jobs])",
      "1198:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
      "1199:   must.Eq(t, []string{\"default\", ns.Name}, resp.Matches[structs.Namespaces])",
      "1201:   must.Eq(t, uint64(1001), resp.Index)",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1167:  defer cleanupS()",
      "1168:  codec := rpcClient(t, s)",
      "1169:  testutil.WaitForLeader(t, s.RPC)",
      "1172:  job := mock.Job()",
      "1173:  registerJob(s, t, job)",
      "1175:  node := mock.Node()",
      "1178:  req := &structs.FuzzySearchRequest{",
      "1179:   Text:         \"set-this-in-test\",",
      "",
      "[Removed Lines]",
      "1170:  fsmState := s.fsm.State()",
      "1176:  require.NoError(t, fsmState.UpsertNode(structs.MsgTypeTestSetup, 1001, node))",
      "",
      "[Added Lines]",
      "1253:  store := s.fsm.State()",
      "1255:  ns := mock.Namespace()",
      "1256:  ns.Name = \"not-allowed\"",
      "1257:  must.NoError(t, store.UpsertNamespaces(10, []*structs.Namespace{ns}))",
      "1262:  variable := mock.VariableEncrypted()",
      "1263:  variable.Path = \"test-path/o\"",
      "1264:  resp := store.VarSet(1001, &structs.VarApplyStateRequest{",
      "1265:   Op:  structs.VarOpSet,",
      "1266:   Var: variable,",
      "1267:  })",
      "1268:  must.NoError(t, resp.Error)",
      "1270:  plugin := mock.CSIPlugin()",
      "1271:  plugin.ID = \"mock.hashicorp.com\"",
      "1272:  must.NoError(t, store.UpsertCSIPlugin(1002, plugin))",
      "1275:  must.NoError(t, store.UpsertNode(structs.MsgTypeTestSetup, 1003, node))",
      "1277:  disallowedVariable := mock.VariableEncrypted()",
      "1278:  disallowedVariable.Namespace = \"not-allowed\"",
      "1279:  resp = store.VarSet(2001, &structs.VarApplyStateRequest{",
      "1280:   Op:  structs.VarOpSet,",
      "1281:   Var: disallowedVariable,",
      "1282:  })",
      "1283:  must.NoError(t, resp.Error)",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1185:  {",
      "1186:   var resp structs.FuzzySearchResponse",
      "1187:   err := msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp)",
      "1189:  }",
      "1192:  {",
      "1194:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityListJobs}))",
      "1195:   req.AuthToken = invalidToken.SecretID",
      "1196:   var resp structs.FuzzySearchResponse",
      "1197:   err := msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp)",
      "1199:  }",
      "1202:  {",
      "1204:   req.AuthToken = validToken.SecretID",
      "1205:   var resp structs.FuzzySearchResponse",
      "1206:   err := msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp)",
      "1208:  }",
      "1211:  {",
      "1213:   req.Context = structs.All",
      "1214:   req.AuthToken = validToken.SecretID",
      "1215:   req.Text = \"oo\" // mock node ID is foobar",
      "1216:   var resp structs.FuzzySearchResponse",
      "1223:  }",
      "1226:  {",
      "1228:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}))",
      "1229:   req.AuthToken = validToken.SecretID",
      "1230:   req.Text = \"jo\" // mock job Name is my-job",
      "1231:   var resp structs.FuzzySearchResponse",
      "1233:   require.Len(t, resp.Matches[structs.Jobs], 1)",
      "1235:    ID:    \"my-job\",",
      "1236:    Scope: []string{\"default\", job.ID},",
      "1237:   }, resp.Matches[structs.Jobs][0])",
      "1244:  }",
      "1247:  {",
      "1248:   req.AuthToken = root.SecretID",
      "1249:   var resp structs.FuzzySearchResponse",
      "1262:  }",
      "1263: }",
      "",
      "[Removed Lines]",
      "1188:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
      "1193:   invalidToken := mock.CreatePolicyAndToken(t, fsmState, 1003, \"test-invalid\",",
      "1198:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
      "1203:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
      "1207:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
      "1212:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
      "1217:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
      "1218:   require.Equal(t, uint64(1001), resp.Index)",
      "1219:   require.Len(t, resp.Matches[structs.Nodes], 1)",
      "1222:   require.Len(t, resp.Matches[structs.Jobs], 0)",
      "1227:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1009, \"test-valid2\",",
      "1232:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
      "1234:   require.Equal(t, structs.FuzzyMatch{",
      "1240:   require.Equal(t, uint64(1000), resp.Index)",
      "1243:   require.Len(t, resp.Matches[structs.Nodes], 0)",
      "1250:   req.Text = \"o\" // matches Job:my-job and Node:foobar",
      "1251:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
      "1252:   require.Equal(t, uint64(1001), resp.Index)",
      "1253:   require.Len(t, resp.Matches[structs.Jobs], 1)",
      "1254:   require.Equal(t, structs.FuzzyMatch{",
      "1255:    ID: job.Name, Scope: []string{\"default\", job.ID},",
      "1256:   }, resp.Matches[structs.Jobs][0])",
      "1257:   require.Len(t, resp.Matches[structs.Nodes], 1)",
      "1258:   require.Equal(t, structs.FuzzyMatch{",
      "1259:    ID:    \"foobar\",",
      "1260:    Scope: []string{node.ID},",
      "1261:   }, resp.Matches[structs.Nodes][0])",
      "",
      "[Added Lines]",
      "1295:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
      "1300:   invalidToken := mock.CreatePolicyAndToken(t, store, 1003, \"test-invalid\",",
      "1305:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
      "1310:   validToken := mock.CreatePolicyAndToken(t, store, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
      "1314:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
      "1319:   validToken := mock.CreatePolicyAndToken(t, store, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
      "1324:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
      "1326:   must.Eq(t, []structs.FuzzyMatch{{ID: node.Name, Scope: []string{node.ID}}},",
      "1327:    resp.Matches[structs.Nodes])",
      "1331:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
      "1332:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
      "1333:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
      "1335:   must.Eq(t, uint64(1003), resp.Index) // index of node",
      "1340:   validToken := mock.CreatePolicyAndToken(t, store, 1009, \"test-valid2\",",
      "1345:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
      "1347:   must.Eq(t, structs.FuzzyMatch{",
      "1353:   must.Eq(t, uint64(1000), resp.Index)",
      "1356:   must.SliceEmpty(t, resp.Matches[structs.Nodes])",
      "1357:  }",
      "1360:  {",
      "1361:   validToken := mock.CreatePolicyAndToken(t, store, 1012, \"test-valid4\", strings.Join([]string{",
      "1362:    mock.NamespacePolicyWithVariables(structs.DefaultNamespace, \"\", []string{},",
      "1363:     map[string][]string{\"*\": []string{\"list\"}}),",
      "1364:    mock.NodePolicy(acl.PolicyRead),",
      "1365:   }, \"\\n\"))",
      "1366:   req.Text = \"o\" // matches Job:my-job, Node:foobar, Plugin, and Variables",
      "1367:   req.AuthToken = validToken.SecretID",
      "1368:   var resp structs.FuzzySearchResponse",
      "1369:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
      "1371:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
      "1372:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
      "1374:   must.Eq(t, []structs.FuzzyMatch{",
      "1375:    {ID: node.Name, Scope: []string{node.ID}}},",
      "1376:    resp.Matches[structs.Nodes])",
      "1378:   must.Eq(t, []structs.FuzzyMatch{{",
      "1379:    ID:    variable.Path,",
      "1380:    Scope: []string{structs.DefaultNamespace, variable.Path}}},",
      "1381:    resp.Matches[structs.Variables])",
      "1383:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
      "1390:   req.Text = \"o\" // matches Job:my-job, Node:foobar, Plugin, and Variables",
      "1391:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
      "1393:   must.Eq(t, []structs.FuzzyMatch{",
      "1394:    {ID: job.Name, Scope: []string{\"default\", job.ID}}},",
      "1395:    resp.Matches[structs.Jobs])",
      "1397:   must.Eq(t, []structs.FuzzyMatch{",
      "1398:    {ID: node.Name, Scope: []string{node.ID}}},",
      "1399:    resp.Matches[structs.Nodes])",
      "1401:   must.Eq(t, []structs.FuzzyMatch{{ID: plugin.ID}},",
      "1402:    resp.Matches[structs.Plugins])",
      "1404:   must.Eq(t, []structs.FuzzyMatch{{",
      "1405:    ID:    variable.Path,",
      "1406:    Scope: []string{structs.DefaultNamespace, variable.Path}}},",
      "1407:    resp.Matches[structs.Variables])",
      "1409:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7eba8cfb2df4d636627c5f6e543aa9894e6ffa5b",
      "candidate_info": {
        "commit_hash": "7eba8cfb2df4d636627c5f6e543aa9894e6ffa5b",
        "repo": "hashicorp/nomad",
        "commit_url": "https://github.com/hashicorp/nomad/commit/7eba8cfb2df4d636627c5f6e543aa9894e6ffa5b",
        "files": [
          ".changelog/17906.txt",
          "acl/acl.go",
          "nomad/search_endpoint.go",
          "nomad/search_endpoint_oss.go",
          "nomad/search_endpoint_test.go"
        ],
        "message": "search: fix ACL filtering for plugins and variables\n\nACL permissions for the search endpoints are done in three passes. The\nfirst (the `sufficientSearchPerms` method) is for performance and coarsely\nrejects requests based on the passed-in context parameter if the user has no\npermissions to any object in that context. The second (the\n`filteredSearchContexts` method) filters out contexts based on whether the user\nhas permissions either to the requested namespace or again by context (to catch\nthe \"all\" context). Finally, when iterating over the objects available, we do\nthe usual filtering in the iterator.\n\nInternal testing found several bugs in this filtering:\n* CSI plugins can be searched by any authenticated user.\n* Variables can be searched if the user has `job:read` permissions to the\n  variable's namespace instead of `variable:list`.\n* Variables cannot be searched by wildcard namespace.\n\nThis is an information leak of the plugin names and variable paths, which we\ndon't consider to be privileged information but intended to protect anyways.\n\nThis changeset fixes these bugs by ensuring CSI plugins are filtered in the 1st\nand 2nd pass ACL filters, and changes variables to check `variable:list` in the\n2nd pass filter unless the wildcard namespace is passed (at which point we'll\nfallback to filtering in the iterator).\n\nFixes: CVE-2023-3300\nFixes: #17906",
        "before_after_code_files": [
          "acl/acl.go||acl/acl.go",
          "nomad/search_endpoint.go||nomad/search_endpoint.go",
          "nomad/search_endpoint_oss.go||nomad/search_endpoint_oss.go",
          "nomad/search_endpoint_test.go||nomad/search_endpoint_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "acl/acl.go||acl/acl.go",
            "nomad/search_endpoint.go||nomad/search_endpoint.go",
            "nomad/search_endpoint_oss.go||nomad/search_endpoint_oss.go",
            "nomad/search_endpoint_test.go||nomad/search_endpoint_test.go"
          ],
          "candidate": [
            "acl/acl.go||acl/acl.go",
            "nomad/search_endpoint.go||nomad/search_endpoint.go",
            "nomad/search_endpoint_oss.go||nomad/search_endpoint_oss.go",
            "nomad/search_endpoint_test.go||nomad/search_endpoint_test.go"
          ]
        }
      },
      "candidate_diff": {
        "acl/acl.go||acl/acl.go": [
          "File: acl/acl.go -> acl/acl.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "386:  if a.management {",
          "387:   return true",
          "388:  }",
          "389:  iter := a.variables.Root().Iterator()",
          "390:  iter.SeekPrefix([]byte(ns))",
          "391:  _, _, ok := iter.Next()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "389:  if ns == \"*\" {",
          "390:   return a.variables.Len() > 0 || a.wildcardVariables.Len() > 0",
          "391:  }",
          "",
          "---------------"
        ],
        "nomad/search_endpoint.go||nomad/search_endpoint.go": [
          "File: nomad/search_endpoint.go -> nomad/search_endpoint.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "618:   return true",
          "619:  }",
          "633:  switch context {",
          "634:  case structs.Nodes:",
          "636:  case structs.Namespaces:",
          "640:  case structs.Volumes:",
          "641:   return acl.NamespaceValidator(acl.NamespaceCapabilityCSIListVolume,",
          "642:    acl.NamespaceCapabilityCSIReadVolume,",
          "",
          "[Removed Lines]",
          "621:  nodeRead := aclObj.AllowNodeRead()",
          "622:  allowNS := aclObj.AllowNamespace(namespace)",
          "623:  jobRead := aclObj.AllowNsOp(namespace, acl.NamespaceCapabilityReadJob)",
          "624:  allowEnt := sufficientSearchPermsEnt(aclObj)",
          "626:  if !nodeRead && !allowNS && !allowEnt && !jobRead {",
          "627:   return false",
          "628:  }",
          "635:   return nodeRead",
          "637:   return allowNS",
          "638:  case structs.Allocs, structs.Deployments, structs.Evals, structs.Jobs:",
          "639:   return jobRead",
          "",
          "[Added Lines]",
          "629:   return aclObj.AllowNodeRead()",
          "631:   return aclObj.AllowNamespace(namespace)",
          "632:  case structs.Allocs, structs.Deployments, structs.Evals, structs.Jobs,",
          "633:   structs.ScalingPolicies, structs.Recommendations:",
          "634:   return aclObj.AllowNsOp(namespace, acl.NamespaceCapabilityReadJob)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "644:    acl.NamespaceCapabilityReadJob)(aclObj, namespace)",
          "645:  case structs.Variables:",
          "646:   return aclObj.AllowVariableSearch(namespace)",
          "647:  }",
          "649:  return true",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "642:  case structs.Plugins:",
          "643:   return aclObj.AllowPluginList()",
          "644:  case structs.Quotas:",
          "645:   return aclObj.AllowQuotaRead()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "864:     available = append(available, c)",
          "865:    }",
          "866:   case structs.Variables:",
          "868:     available = append(available, c)",
          "869:    }",
          "870:   case structs.Nodes:",
          "",
          "[Removed Lines]",
          "867:    if jobRead {",
          "",
          "[Added Lines]",
          "866:    if aclObj.AllowVariableSearch(namespace) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "875:    if volRead {",
          "876:     available = append(available, c)",
          "877:    }",
          "878:   default:",
          "879:    if ok := filteredSearchContextsEnt(aclObj, namespace, c); ok {",
          "880:     available = append(available, c)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "877:   case structs.Plugins:",
          "878:    if aclObj.AllowPluginList() {",
          "879:     available = append(available, c)",
          "880:    }",
          "",
          "---------------"
        ],
        "nomad/search_endpoint_oss.go||nomad/search_endpoint_oss.go": [
          "File: nomad/search_endpoint_oss.go -> nomad/search_endpoint_oss.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:  return nil, fmt.Errorf(\"context must be one of %v or 'all' for all contexts; got %q\", allContexts, context)",
          "49: }",
          "55: func filteredSearchContextsEnt(aclObj *acl.ACL, namespace string, context structs.Context) bool {",
          "56:  return true",
          "57: }",
          "",
          "[Removed Lines]",
          "51: func sufficientSearchPermsEnt(aclObj *acl.ACL) bool {",
          "52:  return true",
          "53: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "nomad/search_endpoint_test.go||nomad/search_endpoint_test.go": [
          "File: nomad/search_endpoint_test.go -> nomad/search_endpoint_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "14:  \"github.com/hashicorp/nomad/nomad/state\"",
          "15:  \"github.com/hashicorp/nomad/nomad/structs\"",
          "16:  \"github.com/hashicorp/nomad/testutil\"",
          "17:  \"github.com/stretchr/testify/require\"",
          "18: )",
          "20: const jobIndex = 1000",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17:  \"github.com/shoenig/test/must\"",
          "19:  \"golang.org/x/exp/slices\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "81:  defer cleanupS()",
          "82:  codec := rpcClient(t, s)",
          "83:  testutil.WaitForLeader(t, s.RPC)",
          "86:  job := registerMockJob(s, t, jobID, 0)",
          "89:  req := &structs.SearchRequest{",
          "90:   Prefix:  \"\",",
          "",
          "[Removed Lines]",
          "84:  fsmState := s.fsm.State()",
          "87:  require.NoError(t, fsmState.UpsertNode(structs.MsgTypeTestSetup, 1001, mock.Node()))",
          "",
          "[Added Lines]",
          "86:  store := s.fsm.State()",
          "88:  ns := mock.Namespace()",
          "89:  ns.Name = \"not-allowed\"",
          "90:  must.NoError(t, store.UpsertNamespaces(10, []*structs.Namespace{ns}))",
          "94:  variable := mock.VariableEncrypted()",
          "95:  resp := store.VarSet(1001, &structs.VarApplyStateRequest{",
          "96:   Op:  structs.VarOpSet,",
          "97:   Var: variable,",
          "98:  })",
          "99:  must.NoError(t, resp.Error)",
          "101:  plugin := mock.CSIPlugin()",
          "102:  must.NoError(t, store.UpsertCSIPlugin(1002, plugin))",
          "104:  node := mock.Node()",
          "105:  must.NoError(t, store.UpsertNode(structs.MsgTypeTestSetup, 1003, node))",
          "107:  disallowedVariable := mock.VariableEncrypted()",
          "108:  disallowedVariable.Namespace = \"not-allowed\"",
          "109:  resp = store.VarSet(2001, &structs.VarApplyStateRequest{",
          "110:   Op:  structs.VarOpSet,",
          "111:   Var: disallowedVariable,",
          "112:  })",
          "113:  must.NoError(t, resp.Error)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "99:  {",
          "100:   var resp structs.SearchResponse",
          "101:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "103:  }",
          "106:  {",
          "108:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityListJobs}))",
          "109:   req.AuthToken = invalidToken.SecretID",
          "110:   var resp structs.SearchResponse",
          "111:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "113:  }",
          "116:  {",
          "118:   req.AuthToken = validToken.SecretID",
          "119:   var resp structs.SearchResponse",
          "120:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "122:  }",
          "125:  {",
          "127:   req.Context = structs.All",
          "128:   req.AuthToken = validToken.SecretID",
          "129:   var resp structs.SearchResponse",
          "136:  }",
          "139:  {",
          "141:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}))",
          "142:   req.AuthToken = validToken.SecretID",
          "143:   var resp structs.SearchResponse",
          "153:  }",
          "156:  {",
          "158:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "159:    mock.NodePolicy(acl.PolicyRead),",
          "160:   }, \"\\n\"))",
          "161:   req.AuthToken = validToken.SecretID",
          "162:   var resp structs.SearchResponse",
          "168:  }",
          "171:  {",
          "172:   req.AuthToken = root.SecretID",
          "173:   var resp structs.SearchResponse",
          "179:  }",
          "180: }",
          "",
          "[Removed Lines]",
          "102:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "107:   invalidToken := mock.CreatePolicyAndToken(t, fsmState, 1003, \"test-invalid\",",
          "112:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "117:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "121:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "126:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "130:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "131:   require.Equal(t, uint64(1001), resp.Index)",
          "132:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "135:   require.Len(t, resp.Matches[structs.Jobs], 0)",
          "140:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1009, \"test-valid2\",",
          "144:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "145:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "146:   require.Equal(t, job.ID, resp.Matches[structs.Jobs][0])",
          "149:   require.Equal(t, uint64(1000), resp.Index)",
          "152:   require.Len(t, resp.Matches[structs.Nodes], 0)",
          "157:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1011, \"test-valid3\", strings.Join([]string{",
          "163:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "164:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "165:   require.Equal(t, job.ID, resp.Matches[structs.Jobs][0])",
          "166:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "167:   require.Equal(t, uint64(1001), resp.Index)",
          "174:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "175:   require.Equal(t, uint64(1001), resp.Index)",
          "176:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "177:   require.Equal(t, job.ID, resp.Matches[structs.Jobs][0])",
          "178:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "",
          "[Added Lines]",
          "128:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "133:   invalidToken := mock.CreatePolicyAndToken(t, store, 1003, \"test-invalid\",",
          "138:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "143:   validToken := mock.CreatePolicyAndToken(t, store, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "147:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "152:   validToken := mock.CreatePolicyAndToken(t, store, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "156:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "158:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "162:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "163:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "164:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
          "166:   must.Eq(t, uint64(1003), resp.Index) // index of node",
          "171:   validToken := mock.CreatePolicyAndToken(t, store, 1009, \"test-valid2\",",
          "175:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "177:   must.Eq(t, []string{job.ID}, resp.Matches[structs.Jobs])",
          "181:   must.SliceEmpty(t, resp.Matches[structs.Nodes])",
          "182:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "183:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
          "186:   must.Eq(t, uint64(1000), resp.Index)",
          "191:   validToken := mock.CreatePolicyAndToken(t, store, 1011, \"test-valid3\", strings.Join([]string{",
          "197:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "199:   must.Eq(t, []string{job.ID}, resp.Matches[structs.Jobs])",
          "200:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "201:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
          "202:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "203:   must.Eq(t, uint64(1003), resp.Index) // index of node",
          "204:  }",
          "207:  {",
          "208:   validToken := mock.CreatePolicyAndToken(t, store, 1012, \"test-valid4\", strings.Join([]string{",
          "209:    mock.NamespacePolicyWithVariables(structs.DefaultNamespace, \"\", []string{},",
          "210:     map[string][]string{\"*\": []string{\"list\"}}),",
          "211:    mock.NodePolicy(acl.PolicyRead),",
          "212:   }, \"\\n\"))",
          "213:   req.AuthToken = validToken.SecretID",
          "214:   var resp structs.SearchResponse",
          "215:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "217:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "218:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "219:   must.Eq(t, []string{variable.Path}, resp.Matches[structs.Variables])",
          "220:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "221:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
          "222:  }",
          "225:  {",
          "226:   validToken := mock.CreatePolicyAndToken(t, store, 1012, \"test-valid4\", strings.Join([]string{",
          "227:    mock.NamespacePolicyWithVariables(structs.DefaultNamespace, \"\", []string{},",
          "228:     map[string][]string{\"*\": []string{\"list\"}}),",
          "229:    mock.NodePolicy(acl.PolicyRead),",
          "230:   }, \"\\n\"))",
          "231:   req.AuthToken = validToken.SecretID",
          "232:   req.Namespace = structs.AllNamespacesSentinel",
          "233:   var resp structs.SearchResponse",
          "234:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "236:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "237:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "238:   must.Eq(t, []string{variable.Path}, resp.Matches[structs.Variables])",
          "239:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "240:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
          "246:   req.Namespace = structs.DefaultNamespace",
          "248:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "250:   must.Eq(t, []string{job.ID}, resp.Matches[structs.Jobs])",
          "251:   must.Eq(t, []string{plugin.ID}, resp.Matches[structs.Plugins])",
          "253:   expectVars := []string{variable.Path, disallowedVariable.Path}",
          "254:   slices.Sort(expectVars)",
          "255:   slices.Sort(resp.Matches[structs.Variables])",
          "256:   must.Eq(t, expectVars, resp.Matches[structs.Variables])",
          "257:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "258:   must.Eq(t, uint64(2001), resp.Index) // highest index",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "798:  codec := rpcClient(t, s)",
          "799:  testutil.WaitForLeader(t, s.RPC)",
          "802:  ns := mock.Namespace()",
          "805:  job1 := mock.Job()",
          "808:  job2 := mock.Job()",
          "809:  job2.Namespace = ns.Name",
          "814:  req := &structs.SearchRequest{",
          "815:   Prefix:  \"\",",
          "",
          "[Removed Lines]",
          "800:  fsmState := s.fsm.State()",
          "803:  require.NoError(t, fsmState.UpsertNamespaces(500, []*structs.Namespace{ns}))",
          "806:  require.NoError(t, fsmState.UpsertJob(structs.MsgTypeTestSetup, 502, job1))",
          "810:  require.NoError(t, fsmState.UpsertJob(structs.MsgTypeTestSetup, 504, job2))",
          "812:  require.NoError(t, fsmState.UpsertNode(structs.MsgTypeTestSetup, 1001, mock.Node()))",
          "",
          "[Added Lines]",
          "880:  store := s.fsm.State()",
          "883:  must.NoError(t, store.UpsertNamespaces(500, []*structs.Namespace{ns}))",
          "886:  must.NoError(t, store.UpsertJob(structs.MsgTypeTestSetup, 502, job1))",
          "890:  must.NoError(t, store.UpsertJob(structs.MsgTypeTestSetup, 504, job2))",
          "892:  node := mock.Node()",
          "893:  must.NoError(t, store.UpsertNode(structs.MsgTypeTestSetup, 1001, node))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "824:  {",
          "825:   var resp structs.SearchResponse",
          "826:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "828:  }",
          "831:  {",
          "833:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityListJobs}))",
          "834:   req.AuthToken = invalidToken.SecretID",
          "835:   var resp structs.SearchResponse",
          "836:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "838:  }",
          "841:  {",
          "843:   req.Context = structs.Namespaces",
          "844:   req.AuthToken = validToken.SecretID",
          "845:   var resp structs.SearchResponse",
          "846:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "848:  }",
          "851:  {",
          "853:   req.Context = structs.All",
          "854:   req.AuthToken = validToken.SecretID",
          "855:   var resp structs.SearchResponse",
          "862:  }",
          "865:  {",
          "867:    mock.NamespacePolicy(job2.Namespace, \"\", []string{acl.NamespaceCapabilityReadJob}))",
          "868:   req.Context = structs.All",
          "869:   req.AuthToken = validToken.SecretID",
          "870:   req.Namespace = job2.Namespace",
          "871:   var resp structs.SearchResponse",
          "882:  }",
          "885:  {",
          "887:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "888:    mock.NodePolicy(acl.PolicyRead),",
          "889:   }, \"\\n\"))",
          "",
          "[Removed Lines]",
          "827:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "832:   invalidToken := mock.CreatePolicyAndToken(t, fsmState, 1003, \"test-invalid\",",
          "837:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "842:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "847:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "852:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "856:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "857:   require.Equal(t, uint64(1001), resp.Index)",
          "858:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "861:   require.Len(t, resp.Matches[structs.Jobs], 0)",
          "866:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1009, \"test-valid2\",",
          "872:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "873:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "874:   require.Equal(t, job2.ID, resp.Matches[structs.Jobs][0])",
          "875:   require.Len(t, resp.Matches[structs.Namespaces], 1)",
          "878:   require.Equal(t, uint64(504), resp.Index)",
          "881:   require.Len(t, resp.Matches[structs.Nodes], 0)",
          "886:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1011, \"test-valid3\", strings.Join([]string{",
          "",
          "[Added Lines]",
          "908:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "913:   invalidToken := mock.CreatePolicyAndToken(t, store, 1003, \"test-invalid\",",
          "918:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "923:   validToken := mock.CreatePolicyAndToken(t, store, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "928:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "933:   validToken := mock.CreatePolicyAndToken(t, store, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "937:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "938:   must.Eq(t, uint64(1001), resp.Index)",
          "939:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "942:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "947:   validToken := mock.CreatePolicyAndToken(t, store, 1009, \"test-valid2\",",
          "953:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "955:   must.Eq(t, []string{job2.ID}, resp.Matches[structs.Jobs])",
          "956:   must.Eq(t, []string{ns.Name}, resp.Matches[structs.Namespaces])",
          "959:   must.Eq(t, uint64(504), resp.Index)",
          "962:   must.SliceEmpty(t, resp.Matches[structs.Nodes])",
          "967:   validToken := mock.CreatePolicyAndToken(t, store, 1011, \"test-valid3\", strings.Join([]string{",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "891:   req.AuthToken = validToken.SecretID",
          "892:   req.Namespace = structs.DefaultNamespace",
          "893:   var resp structs.SearchResponse",
          "900:  }",
          "",
          "[Removed Lines]",
          "894:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "895:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "896:   require.Equal(t, job1.ID, resp.Matches[structs.Jobs][0])",
          "897:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "898:   require.Equal(t, uint64(1001), resp.Index)",
          "899:   require.Len(t, resp.Matches[structs.Namespaces], 1)",
          "",
          "[Added Lines]",
          "975:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "977:   must.Eq(t, []string{job1.ID}, resp.Matches[structs.Jobs])",
          "978:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "979:   must.Eq(t, []string{\"default\"}, resp.Matches[structs.Namespaces])",
          "981:   must.Eq(t, uint64(1001), resp.Index)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "905:   req.AuthToken = root.SecretID",
          "906:   req.Namespace = structs.DefaultNamespace",
          "907:   var resp structs.SearchResponse",
          "914:  }",
          "915: }",
          "",
          "[Removed Lines]",
          "908:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "909:   require.Equal(t, uint64(1001), resp.Index)",
          "910:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "911:   require.Equal(t, job1.ID, resp.Matches[structs.Jobs][0])",
          "912:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "913:   require.Len(t, resp.Matches[structs.Namespaces], 2)",
          "",
          "[Added Lines]",
          "991:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "993:   must.Eq(t, []string{job1.ID}, resp.Matches[structs.Jobs])",
          "994:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "995:   must.Eq(t, []string{\"default\", ns.Name}, resp.Matches[structs.Namespaces])",
          "997:   must.Eq(t, uint64(1001), resp.Index)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "962:  defer cleanupS()",
          "963:  codec := rpcClient(t, s)",
          "964:  testutil.WaitForLeader(t, s.RPC)",
          "967:  job := mock.Job()",
          "968:  registerJob(s, t, job)",
          "970:  node := mock.Node()",
          "973:  req := &structs.FuzzySearchRequest{",
          "974:   Text:         \"set-this-in-test\",",
          "",
          "[Removed Lines]",
          "965:  fsmState := s.fsm.State()",
          "971:  require.NoError(t, fsmState.UpsertNode(structs.MsgTypeTestSetup, 1001, node))",
          "",
          "[Added Lines]",
          "1049:  store := s.fsm.State()",
          "1051:  ns := mock.Namespace()",
          "1052:  ns.Name = \"not-allowed\"",
          "1053:  must.NoError(t, store.UpsertNamespaces(10, []*structs.Namespace{ns}))",
          "1058:  variable := mock.VariableEncrypted()",
          "1059:  variable.Path = \"test-path/o\"",
          "1060:  resp := store.VarSet(1001, &structs.VarApplyStateRequest{",
          "1061:   Op:  structs.VarOpSet,",
          "1062:   Var: variable,",
          "1063:  })",
          "1064:  must.NoError(t, resp.Error)",
          "1066:  plugin := mock.CSIPlugin()",
          "1067:  plugin.ID = \"mock.hashicorp.com\"",
          "1068:  must.NoError(t, store.UpsertCSIPlugin(1002, plugin))",
          "1071:  must.NoError(t, store.UpsertNode(structs.MsgTypeTestSetup, 1003, node))",
          "1073:  disallowedVariable := mock.VariableEncrypted()",
          "1074:  disallowedVariable.Namespace = \"not-allowed\"",
          "1075:  resp = store.VarSet(2001, &structs.VarApplyStateRequest{",
          "1076:   Op:  structs.VarOpSet,",
          "1077:   Var: disallowedVariable,",
          "1078:  })",
          "1079:  must.NoError(t, resp.Error)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "980:  {",
          "981:   var resp structs.FuzzySearchResponse",
          "982:   err := msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp)",
          "984:  }",
          "987:  {",
          "989:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityListJobs}))",
          "990:   req.AuthToken = invalidToken.SecretID",
          "991:   var resp structs.FuzzySearchResponse",
          "992:   err := msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp)",
          "994:  }",
          "997:  {",
          "999:   req.AuthToken = validToken.SecretID",
          "1000:   var resp structs.FuzzySearchResponse",
          "1001:   err := msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp)",
          "1003:  }",
          "1006:  {",
          "1008:   req.Context = structs.All",
          "1009:   req.AuthToken = validToken.SecretID",
          "1010:   req.Text = \"oo\" // mock node ID is foobar",
          "1011:   var resp structs.FuzzySearchResponse",
          "1018:  }",
          "1021:  {",
          "1023:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}))",
          "1024:   req.AuthToken = validToken.SecretID",
          "1025:   req.Text = \"jo\" // mock job Name is my-job",
          "1026:   var resp structs.FuzzySearchResponse",
          "1028:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "1030:    ID:    \"my-job\",",
          "1031:    Scope: []string{\"default\", job.ID},",
          "1032:   }, resp.Matches[structs.Jobs][0])",
          "1039:  }",
          "1042:  {",
          "1043:   req.AuthToken = root.SecretID",
          "1044:   var resp structs.FuzzySearchResponse",
          "1057:  }",
          "1058: }",
          "",
          "[Removed Lines]",
          "983:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "988:   invalidToken := mock.CreatePolicyAndToken(t, fsmState, 1003, \"test-invalid\",",
          "993:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "998:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "1002:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "1007:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "1012:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1013:   require.Equal(t, uint64(1001), resp.Index)",
          "1014:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "1017:   require.Len(t, resp.Matches[structs.Jobs], 0)",
          "1022:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1009, \"test-valid2\",",
          "1027:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1029:   require.Equal(t, structs.FuzzyMatch{",
          "1035:   require.Equal(t, uint64(1000), resp.Index)",
          "1038:   require.Len(t, resp.Matches[structs.Nodes], 0)",
          "1045:   req.Text = \"o\" // matches Job:my-job and Node:foobar",
          "1046:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1047:   require.Equal(t, uint64(1001), resp.Index)",
          "1048:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "1049:   require.Equal(t, structs.FuzzyMatch{",
          "1050:    ID: job.Name, Scope: []string{\"default\", job.ID},",
          "1051:   }, resp.Matches[structs.Jobs][0])",
          "1052:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "1053:   require.Equal(t, structs.FuzzyMatch{",
          "1054:    ID:    \"foobar\",",
          "1055:    Scope: []string{node.ID},",
          "1056:   }, resp.Matches[structs.Nodes][0])",
          "",
          "[Added Lines]",
          "1091:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "1096:   invalidToken := mock.CreatePolicyAndToken(t, store, 1003, \"test-invalid\",",
          "1101:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "1106:   validToken := mock.CreatePolicyAndToken(t, store, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "1110:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "1115:   validToken := mock.CreatePolicyAndToken(t, store, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "1120:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1122:   must.Eq(t, []structs.FuzzyMatch{{ID: node.Name, Scope: []string{node.ID}}},",
          "1123:    resp.Matches[structs.Nodes])",
          "1127:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "1128:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "1129:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
          "1131:   must.Eq(t, uint64(1003), resp.Index) // index of node",
          "1136:   validToken := mock.CreatePolicyAndToken(t, store, 1009, \"test-valid2\",",
          "1141:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1143:   must.Eq(t, structs.FuzzyMatch{",
          "1149:   must.Eq(t, uint64(1000), resp.Index)",
          "1152:   must.SliceEmpty(t, resp.Matches[structs.Nodes])",
          "1153:  }",
          "1156:  {",
          "1157:   validToken := mock.CreatePolicyAndToken(t, store, 1012, \"test-valid4\", strings.Join([]string{",
          "1158:    mock.NamespacePolicyWithVariables(structs.DefaultNamespace, \"\", []string{},",
          "1159:     map[string][]string{\"*\": []string{\"list\"}}),",
          "1160:    mock.NodePolicy(acl.PolicyRead),",
          "1161:   }, \"\\n\"))",
          "1162:   req.Text = \"o\" // matches Job:my-job, Node:foobar, Plugin, and Variables",
          "1163:   req.AuthToken = validToken.SecretID",
          "1164:   var resp structs.FuzzySearchResponse",
          "1165:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1167:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "1168:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "1170:   must.Eq(t, []structs.FuzzyMatch{",
          "1171:    {ID: node.Name, Scope: []string{node.ID}}},",
          "1172:    resp.Matches[structs.Nodes])",
          "1174:   must.Eq(t, []structs.FuzzyMatch{{",
          "1175:    ID:    variable.Path,",
          "1176:    Scope: []string{structs.DefaultNamespace, variable.Path}}},",
          "1177:    resp.Matches[structs.Variables])",
          "1179:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
          "1186:   req.Text = \"o\" // matches Job:my-job, Node:foobar, Plugin, and Variables",
          "1187:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1189:   must.Eq(t, []structs.FuzzyMatch{",
          "1190:    {ID: job.Name, Scope: []string{\"default\", job.ID}}},",
          "1191:    resp.Matches[structs.Jobs])",
          "1193:   must.Eq(t, []structs.FuzzyMatch{",
          "1194:    {ID: node.Name, Scope: []string{node.ID}}},",
          "1195:    resp.Matches[structs.Nodes])",
          "1197:   must.Eq(t, []structs.FuzzyMatch{{ID: plugin.ID}},",
          "1198:    resp.Matches[structs.Plugins])",
          "1200:   must.Eq(t, []structs.FuzzyMatch{{",
          "1201:    ID:    variable.Path,",
          "1202:    Scope: []string{structs.DefaultNamespace, variable.Path}}},",
          "1203:    resp.Matches[structs.Variables])",
          "1205:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4d34954bf55248f463c5490c8d337db1a65d62f3",
      "candidate_info": {
        "commit_hash": "4d34954bf55248f463c5490c8d337db1a65d62f3",
        "repo": "hashicorp/nomad",
        "commit_url": "https://github.com/hashicorp/nomad/commit/4d34954bf55248f463c5490c8d337db1a65d62f3",
        "files": [
          ".changelog/17906.txt",
          "acl/acl.go",
          "nomad/search_endpoint.go",
          "nomad/search_endpoint_oss.go",
          "nomad/search_endpoint_test.go"
        ],
        "message": "search: fix ACL filtering for plugins and variables\n\nACL permissions for the search endpoints are done in three passes. The\nfirst (the `sufficientSearchPerms` method) is for performance and coarsely\nrejects requests based on the passed-in context parameter if the user has no\npermissions to any object in that context. The second (the\n`filteredSearchContexts` method) filters out contexts based on whether the user\nhas permissions either to the requested namespace or again by context (to catch\nthe \"all\" context). Finally, when iterating over the objects available, we do\nthe usual filtering in the iterator.\n\nInternal testing found several bugs in this filtering:\n* CSI plugins can be searched by any authenticated user.\n* Variables can be searched if the user has `job:read` permissions to the\n  variable's namespace instead of `variable:list`.\n* Variables cannot be searched by wildcard namespace.\n\nThis is an information leak of the plugin names and variable paths, which we\ndon't consider to be privileged information but intended to protect anyways.\n\nThis changeset fixes these bugs by ensuring CSI plugins are filtered in the 1st\nand 2nd pass ACL filters, and changes variables to check `variable:list` in the\n2nd pass filter unless the wildcard namespace is passed (at which point we'll\nfallback to filtering in the iterator).\n\nFixes: CVE-2023-3300\nFixes: #17906",
        "before_after_code_files": [
          "acl/acl.go||acl/acl.go",
          "nomad/search_endpoint.go||nomad/search_endpoint.go",
          "nomad/search_endpoint_oss.go||nomad/search_endpoint_oss.go",
          "nomad/search_endpoint_test.go||nomad/search_endpoint_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "acl/acl.go||acl/acl.go",
            "nomad/search_endpoint.go||nomad/search_endpoint.go",
            "nomad/search_endpoint_oss.go||nomad/search_endpoint_oss.go",
            "nomad/search_endpoint_test.go||nomad/search_endpoint_test.go"
          ],
          "candidate": [
            "acl/acl.go||acl/acl.go",
            "nomad/search_endpoint.go||nomad/search_endpoint.go",
            "nomad/search_endpoint_oss.go||nomad/search_endpoint_oss.go",
            "nomad/search_endpoint_test.go||nomad/search_endpoint_test.go"
          ]
        }
      },
      "candidate_diff": {
        "acl/acl.go||acl/acl.go": [
          "File: acl/acl.go -> acl/acl.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "386:  if a.management {",
          "387:   return true",
          "388:  }",
          "389:  iter := a.variables.Root().Iterator()",
          "390:  iter.SeekPrefix([]byte(ns))",
          "391:  _, _, ok := iter.Next()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "389:  if ns == \"*\" {",
          "390:   return a.variables.Len() > 0 || a.wildcardVariables.Len() > 0",
          "391:  }",
          "",
          "---------------"
        ],
        "nomad/search_endpoint.go||nomad/search_endpoint.go": [
          "File: nomad/search_endpoint.go -> nomad/search_endpoint.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "629:   return true",
          "630:  }",
          "644:  switch context {",
          "645:  case structs.Nodes:",
          "647:  case structs.Namespaces:",
          "651:  case structs.Volumes:",
          "652:   return acl.NamespaceValidator(acl.NamespaceCapabilityCSIListVolume,",
          "653:    acl.NamespaceCapabilityCSIReadVolume,",
          "",
          "[Removed Lines]",
          "632:  nodeRead := aclObj.AllowNodeRead()",
          "633:  allowNS := aclObj.AllowNamespace(namespace)",
          "634:  jobRead := aclObj.AllowNsOp(namespace, acl.NamespaceCapabilityReadJob)",
          "635:  allowEnt := sufficientSearchPermsEnt(aclObj)",
          "637:  if !nodeRead && !allowNS && !allowEnt && !jobRead {",
          "638:   return false",
          "639:  }",
          "646:   return nodeRead",
          "648:   return allowNS",
          "649:  case structs.Allocs, structs.Deployments, structs.Evals, structs.Jobs:",
          "650:   return jobRead",
          "",
          "[Added Lines]",
          "640:   return aclObj.AllowNodeRead()",
          "642:   return aclObj.AllowNamespace(namespace)",
          "643:  case structs.Allocs, structs.Deployments, structs.Evals, structs.Jobs,",
          "644:   structs.ScalingPolicies, structs.Recommendations:",
          "645:   return aclObj.AllowNsOp(namespace, acl.NamespaceCapabilityReadJob)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "655:    acl.NamespaceCapabilityReadJob)(aclObj, namespace)",
          "656:  case structs.Variables:",
          "657:   return aclObj.AllowVariableSearch(namespace)",
          "658:  }",
          "660:  return true",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "653:  case structs.Plugins:",
          "654:   return aclObj.AllowPluginList()",
          "655:  case structs.Quotas:",
          "656:   return aclObj.AllowQuotaRead()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "881:     available = append(available, c)",
          "882:    }",
          "883:   case structs.Variables:",
          "885:     available = append(available, c)",
          "886:    }",
          "887:   case structs.Nodes:",
          "",
          "[Removed Lines]",
          "884:    if jobRead {",
          "",
          "[Added Lines]",
          "883:    if aclObj.AllowVariableSearch(namespace) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "892:    if volRead {",
          "893:     available = append(available, c)",
          "894:    }",
          "895:   default:",
          "896:    if ok := filteredSearchContextsEnt(aclObj, namespace, c); ok {",
          "897:     available = append(available, c)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "894:   case structs.Plugins:",
          "895:    if aclObj.AllowPluginList() {",
          "896:     available = append(available, c)",
          "897:    }",
          "",
          "---------------"
        ],
        "nomad/search_endpoint_oss.go||nomad/search_endpoint_oss.go": [
          "File: nomad/search_endpoint_oss.go -> nomad/search_endpoint_oss.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:  return nil, fmt.Errorf(\"context must be one of %v or 'all' for all contexts; got %q\", allContexts, context)",
          "49: }",
          "55: func filteredSearchContextsEnt(aclObj *acl.ACL, namespace string, context structs.Context) bool {",
          "56:  return true",
          "57: }",
          "",
          "[Removed Lines]",
          "51: func sufficientSearchPermsEnt(aclObj *acl.ACL) bool {",
          "52:  return true",
          "53: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "nomad/search_endpoint_test.go||nomad/search_endpoint_test.go": [
          "File: nomad/search_endpoint_test.go -> nomad/search_endpoint_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "14:  \"github.com/hashicorp/nomad/nomad/state\"",
          "15:  \"github.com/hashicorp/nomad/nomad/structs\"",
          "16:  \"github.com/hashicorp/nomad/testutil\"",
          "17:  \"github.com/stretchr/testify/require\"",
          "18: )",
          "20: const jobIndex = 1000",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17:  \"github.com/shoenig/test/must\"",
          "19:  \"golang.org/x/exp/slices\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "81:  defer cleanupS()",
          "82:  codec := rpcClient(t, s)",
          "83:  testutil.WaitForLeader(t, s.RPC)",
          "86:  job := registerMockJob(s, t, jobID, 0)",
          "89:  req := &structs.SearchRequest{",
          "90:   Prefix:  \"\",",
          "",
          "[Removed Lines]",
          "84:  fsmState := s.fsm.State()",
          "87:  require.NoError(t, fsmState.UpsertNode(structs.MsgTypeTestSetup, 1001, mock.Node()))",
          "",
          "[Added Lines]",
          "86:  store := s.fsm.State()",
          "88:  ns := mock.Namespace()",
          "89:  ns.Name = \"not-allowed\"",
          "90:  must.NoError(t, store.UpsertNamespaces(10, []*structs.Namespace{ns}))",
          "94:  variable := mock.VariableEncrypted()",
          "95:  resp := store.VarSet(1001, &structs.VarApplyStateRequest{",
          "96:   Op:  structs.VarOpSet,",
          "97:   Var: variable,",
          "98:  })",
          "99:  must.NoError(t, resp.Error)",
          "101:  plugin := mock.CSIPlugin()",
          "102:  must.NoError(t, store.UpsertCSIPlugin(1002, plugin))",
          "104:  node := mock.Node()",
          "105:  must.NoError(t, store.UpsertNode(structs.MsgTypeTestSetup, 1003, node))",
          "107:  disallowedVariable := mock.VariableEncrypted()",
          "108:  disallowedVariable.Namespace = \"not-allowed\"",
          "109:  resp = store.VarSet(2001, &structs.VarApplyStateRequest{",
          "110:   Op:  structs.VarOpSet,",
          "111:   Var: disallowedVariable,",
          "112:  })",
          "113:  must.NoError(t, resp.Error)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "99:  {",
          "100:   var resp structs.SearchResponse",
          "101:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "103:  }",
          "106:  {",
          "108:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityListJobs}))",
          "109:   req.AuthToken = invalidToken.SecretID",
          "110:   var resp structs.SearchResponse",
          "111:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "113:  }",
          "116:  {",
          "118:   req.AuthToken = validToken.SecretID",
          "119:   var resp structs.SearchResponse",
          "120:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "122:  }",
          "125:  {",
          "127:   req.Context = structs.All",
          "128:   req.AuthToken = validToken.SecretID",
          "129:   var resp structs.SearchResponse",
          "136:  }",
          "139:  {",
          "141:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}))",
          "142:   req.AuthToken = validToken.SecretID",
          "143:   var resp structs.SearchResponse",
          "153:  }",
          "156:  {",
          "158:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "159:    mock.NodePolicy(acl.PolicyRead),",
          "160:   }, \"\\n\"))",
          "161:   req.AuthToken = validToken.SecretID",
          "162:   var resp structs.SearchResponse",
          "168:  }",
          "171:  {",
          "172:   req.AuthToken = root.SecretID",
          "173:   var resp structs.SearchResponse",
          "179:  }",
          "180: }",
          "",
          "[Removed Lines]",
          "102:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "107:   invalidToken := mock.CreatePolicyAndToken(t, fsmState, 1003, \"test-invalid\",",
          "112:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "117:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "121:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "126:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "130:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "131:   require.Equal(t, uint64(1001), resp.Index)",
          "132:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "135:   require.Len(t, resp.Matches[structs.Jobs], 0)",
          "140:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1009, \"test-valid2\",",
          "144:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "145:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "146:   require.Equal(t, job.ID, resp.Matches[structs.Jobs][0])",
          "149:   require.Equal(t, uint64(1000), resp.Index)",
          "152:   require.Len(t, resp.Matches[structs.Nodes], 0)",
          "157:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1011, \"test-valid3\", strings.Join([]string{",
          "163:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "164:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "165:   require.Equal(t, job.ID, resp.Matches[structs.Jobs][0])",
          "166:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "167:   require.Equal(t, uint64(1001), resp.Index)",
          "174:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "175:   require.Equal(t, uint64(1001), resp.Index)",
          "176:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "177:   require.Equal(t, job.ID, resp.Matches[structs.Jobs][0])",
          "178:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "",
          "[Added Lines]",
          "128:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "133:   invalidToken := mock.CreatePolicyAndToken(t, store, 1003, \"test-invalid\",",
          "138:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "143:   validToken := mock.CreatePolicyAndToken(t, store, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "147:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "152:   validToken := mock.CreatePolicyAndToken(t, store, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "156:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "158:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "162:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "163:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "164:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
          "166:   must.Eq(t, uint64(1003), resp.Index) // index of node",
          "171:   validToken := mock.CreatePolicyAndToken(t, store, 1009, \"test-valid2\",",
          "175:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "177:   must.Eq(t, []string{job.ID}, resp.Matches[structs.Jobs])",
          "181:   must.SliceEmpty(t, resp.Matches[structs.Nodes])",
          "182:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "183:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
          "186:   must.Eq(t, uint64(1000), resp.Index)",
          "191:   validToken := mock.CreatePolicyAndToken(t, store, 1011, \"test-valid3\", strings.Join([]string{",
          "197:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "199:   must.Eq(t, []string{job.ID}, resp.Matches[structs.Jobs])",
          "200:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "201:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
          "202:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "203:   must.Eq(t, uint64(1003), resp.Index) // index of node",
          "204:  }",
          "207:  {",
          "208:   validToken := mock.CreatePolicyAndToken(t, store, 1012, \"test-valid4\", strings.Join([]string{",
          "209:    mock.NamespacePolicyWithVariables(structs.DefaultNamespace, \"\", []string{},",
          "210:     map[string][]string{\"*\": []string{\"list\"}}),",
          "211:    mock.NodePolicy(acl.PolicyRead),",
          "212:   }, \"\\n\"))",
          "213:   req.AuthToken = validToken.SecretID",
          "214:   var resp structs.SearchResponse",
          "215:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "217:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "218:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "219:   must.Eq(t, []string{variable.Path}, resp.Matches[structs.Variables])",
          "220:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "221:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
          "222:  }",
          "225:  {",
          "226:   validToken := mock.CreatePolicyAndToken(t, store, 1012, \"test-valid4\", strings.Join([]string{",
          "227:    mock.NamespacePolicyWithVariables(structs.DefaultNamespace, \"\", []string{},",
          "228:     map[string][]string{\"*\": []string{\"list\"}}),",
          "229:    mock.NodePolicy(acl.PolicyRead),",
          "230:   }, \"\\n\"))",
          "231:   req.AuthToken = validToken.SecretID",
          "232:   req.Namespace = structs.AllNamespacesSentinel",
          "233:   var resp structs.SearchResponse",
          "234:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "236:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "237:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "238:   must.Eq(t, []string{variable.Path}, resp.Matches[structs.Variables])",
          "239:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "240:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
          "246:   req.Namespace = structs.DefaultNamespace",
          "248:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "250:   must.Eq(t, []string{job.ID}, resp.Matches[structs.Jobs])",
          "251:   must.Eq(t, []string{plugin.ID}, resp.Matches[structs.Plugins])",
          "253:   expectVars := []string{variable.Path, disallowedVariable.Path}",
          "254:   slices.Sort(expectVars)",
          "255:   slices.Sort(resp.Matches[structs.Variables])",
          "256:   must.Eq(t, expectVars, resp.Matches[structs.Variables])",
          "257:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "258:   must.Eq(t, uint64(2001), resp.Index) // highest index",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "798:  codec := rpcClient(t, s)",
          "799:  testutil.WaitForLeader(t, s.RPC)",
          "802:  ns := mock.Namespace()",
          "805:  job1 := mock.Job()",
          "808:  job2 := mock.Job()",
          "809:  job2.Namespace = ns.Name",
          "814:  req := &structs.SearchRequest{",
          "815:   Prefix:  \"\",",
          "",
          "[Removed Lines]",
          "800:  fsmState := s.fsm.State()",
          "803:  require.NoError(t, fsmState.UpsertNamespaces(500, []*structs.Namespace{ns}))",
          "806:  require.NoError(t, fsmState.UpsertJob(structs.MsgTypeTestSetup, 502, job1))",
          "810:  require.NoError(t, fsmState.UpsertJob(structs.MsgTypeTestSetup, 504, job2))",
          "812:  require.NoError(t, fsmState.UpsertNode(structs.MsgTypeTestSetup, 1001, mock.Node()))",
          "",
          "[Added Lines]",
          "880:  store := s.fsm.State()",
          "883:  must.NoError(t, store.UpsertNamespaces(500, []*structs.Namespace{ns}))",
          "886:  must.NoError(t, store.UpsertJob(structs.MsgTypeTestSetup, 502, job1))",
          "890:  must.NoError(t, store.UpsertJob(structs.MsgTypeTestSetup, 504, job2))",
          "892:  node := mock.Node()",
          "893:  must.NoError(t, store.UpsertNode(structs.MsgTypeTestSetup, 1001, node))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "824:  {",
          "825:   var resp structs.SearchResponse",
          "826:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "828:  }",
          "831:  {",
          "833:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityListJobs}))",
          "834:   req.AuthToken = invalidToken.SecretID",
          "835:   var resp structs.SearchResponse",
          "836:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "838:  }",
          "841:  {",
          "843:   req.Context = structs.Namespaces",
          "844:   req.AuthToken = validToken.SecretID",
          "845:   var resp structs.SearchResponse",
          "846:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "848:  }",
          "851:  {",
          "853:   req.Context = structs.All",
          "854:   req.AuthToken = validToken.SecretID",
          "855:   var resp structs.SearchResponse",
          "862:  }",
          "865:  {",
          "867:    mock.NamespacePolicy(job2.Namespace, \"\", []string{acl.NamespaceCapabilityReadJob}))",
          "868:   req.Context = structs.All",
          "869:   req.AuthToken = validToken.SecretID",
          "870:   req.Namespace = job2.Namespace",
          "871:   var resp structs.SearchResponse",
          "882:  }",
          "885:  {",
          "887:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "888:    mock.NodePolicy(acl.PolicyRead),",
          "889:   }, \"\\n\"))",
          "",
          "[Removed Lines]",
          "827:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "832:   invalidToken := mock.CreatePolicyAndToken(t, fsmState, 1003, \"test-invalid\",",
          "837:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "842:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "847:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "852:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "856:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "857:   require.Equal(t, uint64(1001), resp.Index)",
          "858:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "861:   require.Len(t, resp.Matches[structs.Jobs], 0)",
          "866:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1009, \"test-valid2\",",
          "872:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "873:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "874:   require.Equal(t, job2.ID, resp.Matches[structs.Jobs][0])",
          "875:   require.Len(t, resp.Matches[structs.Namespaces], 1)",
          "878:   require.Equal(t, uint64(504), resp.Index)",
          "881:   require.Len(t, resp.Matches[structs.Nodes], 0)",
          "886:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1011, \"test-valid3\", strings.Join([]string{",
          "",
          "[Added Lines]",
          "908:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "913:   invalidToken := mock.CreatePolicyAndToken(t, store, 1003, \"test-invalid\",",
          "918:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "923:   validToken := mock.CreatePolicyAndToken(t, store, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "928:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "933:   validToken := mock.CreatePolicyAndToken(t, store, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "937:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "938:   must.Eq(t, uint64(1001), resp.Index)",
          "939:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "942:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "947:   validToken := mock.CreatePolicyAndToken(t, store, 1009, \"test-valid2\",",
          "953:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "955:   must.Eq(t, []string{job2.ID}, resp.Matches[structs.Jobs])",
          "956:   must.Eq(t, []string{ns.Name}, resp.Matches[structs.Namespaces])",
          "959:   must.Eq(t, uint64(504), resp.Index)",
          "962:   must.SliceEmpty(t, resp.Matches[structs.Nodes])",
          "967:   validToken := mock.CreatePolicyAndToken(t, store, 1011, \"test-valid3\", strings.Join([]string{",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "891:   req.AuthToken = validToken.SecretID",
          "892:   req.Namespace = structs.DefaultNamespace",
          "893:   var resp structs.SearchResponse",
          "900:  }",
          "",
          "[Removed Lines]",
          "894:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "895:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "896:   require.Equal(t, job1.ID, resp.Matches[structs.Jobs][0])",
          "897:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "898:   require.Equal(t, uint64(1001), resp.Index)",
          "899:   require.Len(t, resp.Matches[structs.Namespaces], 1)",
          "",
          "[Added Lines]",
          "975:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "977:   must.Eq(t, []string{job1.ID}, resp.Matches[structs.Jobs])",
          "978:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "979:   must.Eq(t, []string{\"default\"}, resp.Matches[structs.Namespaces])",
          "981:   must.Eq(t, uint64(1001), resp.Index)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "905:   req.AuthToken = root.SecretID",
          "906:   req.Namespace = structs.DefaultNamespace",
          "907:   var resp structs.SearchResponse",
          "914:  }",
          "915: }",
          "",
          "[Removed Lines]",
          "908:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "909:   require.Equal(t, uint64(1001), resp.Index)",
          "910:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "911:   require.Equal(t, job1.ID, resp.Matches[structs.Jobs][0])",
          "912:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "913:   require.Len(t, resp.Matches[structs.Namespaces], 2)",
          "",
          "[Added Lines]",
          "991:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "993:   must.Eq(t, []string{job1.ID}, resp.Matches[structs.Jobs])",
          "994:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "995:   must.Eq(t, []string{\"default\", ns.Name}, resp.Matches[structs.Namespaces])",
          "997:   must.Eq(t, uint64(1001), resp.Index)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "962:  defer cleanupS()",
          "963:  codec := rpcClient(t, s)",
          "964:  testutil.WaitForLeader(t, s.RPC)",
          "967:  job := mock.Job()",
          "968:  registerJob(s, t, job)",
          "970:  node := mock.Node()",
          "973:  req := &structs.FuzzySearchRequest{",
          "974:   Text:         \"set-this-in-test\",",
          "",
          "[Removed Lines]",
          "965:  fsmState := s.fsm.State()",
          "971:  require.NoError(t, fsmState.UpsertNode(structs.MsgTypeTestSetup, 1001, node))",
          "",
          "[Added Lines]",
          "1049:  store := s.fsm.State()",
          "1051:  ns := mock.Namespace()",
          "1052:  ns.Name = \"not-allowed\"",
          "1053:  must.NoError(t, store.UpsertNamespaces(10, []*structs.Namespace{ns}))",
          "1058:  variable := mock.VariableEncrypted()",
          "1059:  variable.Path = \"test-path/o\"",
          "1060:  resp := store.VarSet(1001, &structs.VarApplyStateRequest{",
          "1061:   Op:  structs.VarOpSet,",
          "1062:   Var: variable,",
          "1063:  })",
          "1064:  must.NoError(t, resp.Error)",
          "1066:  plugin := mock.CSIPlugin()",
          "1067:  plugin.ID = \"mock.hashicorp.com\"",
          "1068:  must.NoError(t, store.UpsertCSIPlugin(1002, plugin))",
          "1071:  must.NoError(t, store.UpsertNode(structs.MsgTypeTestSetup, 1003, node))",
          "1073:  disallowedVariable := mock.VariableEncrypted()",
          "1074:  disallowedVariable.Namespace = \"not-allowed\"",
          "1075:  resp = store.VarSet(2001, &structs.VarApplyStateRequest{",
          "1076:   Op:  structs.VarOpSet,",
          "1077:   Var: disallowedVariable,",
          "1078:  })",
          "1079:  must.NoError(t, resp.Error)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "980:  {",
          "981:   var resp structs.FuzzySearchResponse",
          "982:   err := msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp)",
          "984:  }",
          "987:  {",
          "989:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityListJobs}))",
          "990:   req.AuthToken = invalidToken.SecretID",
          "991:   var resp structs.FuzzySearchResponse",
          "992:   err := msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp)",
          "994:  }",
          "997:  {",
          "999:   req.AuthToken = validToken.SecretID",
          "1000:   var resp structs.FuzzySearchResponse",
          "1001:   err := msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp)",
          "1003:  }",
          "1006:  {",
          "1008:   req.Context = structs.All",
          "1009:   req.AuthToken = validToken.SecretID",
          "1010:   req.Text = \"oo\" // mock node ID is foobar",
          "1011:   var resp structs.FuzzySearchResponse",
          "1018:  }",
          "1021:  {",
          "1023:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}))",
          "1024:   req.AuthToken = validToken.SecretID",
          "1025:   req.Text = \"jo\" // mock job Name is my-job",
          "1026:   var resp structs.FuzzySearchResponse",
          "1028:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "1030:    ID:    \"my-job\",",
          "1031:    Scope: []string{\"default\", job.ID},",
          "1032:   }, resp.Matches[structs.Jobs][0])",
          "1039:  }",
          "1042:  {",
          "1043:   req.AuthToken = root.SecretID",
          "1044:   var resp structs.FuzzySearchResponse",
          "1057:  }",
          "1058: }",
          "",
          "[Removed Lines]",
          "983:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "988:   invalidToken := mock.CreatePolicyAndToken(t, fsmState, 1003, \"test-invalid\",",
          "993:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "998:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "1002:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "1007:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "1012:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1013:   require.Equal(t, uint64(1001), resp.Index)",
          "1014:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "1017:   require.Len(t, resp.Matches[structs.Jobs], 0)",
          "1022:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1009, \"test-valid2\",",
          "1027:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1029:   require.Equal(t, structs.FuzzyMatch{",
          "1035:   require.Equal(t, uint64(1000), resp.Index)",
          "1038:   require.Len(t, resp.Matches[structs.Nodes], 0)",
          "1045:   req.Text = \"o\" // matches Job:my-job and Node:foobar",
          "1046:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1047:   require.Equal(t, uint64(1001), resp.Index)",
          "1048:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "1049:   require.Equal(t, structs.FuzzyMatch{",
          "1050:    ID: job.Name, Scope: []string{\"default\", job.ID},",
          "1051:   }, resp.Matches[structs.Jobs][0])",
          "1052:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "1053:   require.Equal(t, structs.FuzzyMatch{",
          "1054:    ID:    \"foobar\",",
          "1055:    Scope: []string{node.ID},",
          "1056:   }, resp.Matches[structs.Nodes][0])",
          "",
          "[Added Lines]",
          "1091:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "1096:   invalidToken := mock.CreatePolicyAndToken(t, store, 1003, \"test-invalid\",",
          "1101:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "1106:   validToken := mock.CreatePolicyAndToken(t, store, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "1110:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "1115:   validToken := mock.CreatePolicyAndToken(t, store, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "1120:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1122:   must.Eq(t, []structs.FuzzyMatch{{ID: node.Name, Scope: []string{node.ID}}},",
          "1123:    resp.Matches[structs.Nodes])",
          "1127:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "1128:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "1129:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
          "1131:   must.Eq(t, uint64(1003), resp.Index) // index of node",
          "1136:   validToken := mock.CreatePolicyAndToken(t, store, 1009, \"test-valid2\",",
          "1141:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1143:   must.Eq(t, structs.FuzzyMatch{",
          "1149:   must.Eq(t, uint64(1000), resp.Index)",
          "1152:   must.SliceEmpty(t, resp.Matches[structs.Nodes])",
          "1153:  }",
          "1156:  {",
          "1157:   validToken := mock.CreatePolicyAndToken(t, store, 1012, \"test-valid4\", strings.Join([]string{",
          "1158:    mock.NamespacePolicyWithVariables(structs.DefaultNamespace, \"\", []string{},",
          "1159:     map[string][]string{\"*\": []string{\"list\"}}),",
          "1160:    mock.NodePolicy(acl.PolicyRead),",
          "1161:   }, \"\\n\"))",
          "1162:   req.Text = \"o\" // matches Job:my-job, Node:foobar, Plugin, and Variables",
          "1163:   req.AuthToken = validToken.SecretID",
          "1164:   var resp structs.FuzzySearchResponse",
          "1165:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1167:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "1168:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "1170:   must.Eq(t, []structs.FuzzyMatch{",
          "1171:    {ID: node.Name, Scope: []string{node.ID}}},",
          "1172:    resp.Matches[structs.Nodes])",
          "1174:   must.Eq(t, []structs.FuzzyMatch{{",
          "1175:    ID:    variable.Path,",
          "1176:    Scope: []string{structs.DefaultNamespace, variable.Path}}},",
          "1177:    resp.Matches[structs.Variables])",
          "1179:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
          "1186:   req.Text = \"o\" // matches Job:my-job, Node:foobar, Plugin, and Variables",
          "1187:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1189:   must.Eq(t, []structs.FuzzyMatch{",
          "1190:    {ID: job.Name, Scope: []string{\"default\", job.ID}}},",
          "1191:    resp.Matches[structs.Jobs])",
          "1193:   must.Eq(t, []structs.FuzzyMatch{",
          "1194:    {ID: node.Name, Scope: []string{node.ID}}},",
          "1195:    resp.Matches[structs.Nodes])",
          "1197:   must.Eq(t, []structs.FuzzyMatch{{ID: plugin.ID}},",
          "1198:    resp.Matches[structs.Plugins])",
          "1200:   must.Eq(t, []structs.FuzzyMatch{{",
          "1201:    ID:    variable.Path,",
          "1202:    Scope: []string{structs.DefaultNamespace, variable.Path}}},",
          "1203:    resp.Matches[structs.Variables])",
          "1205:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e2300f1205af249eae76fba45b5b9f76f8d125b2",
      "candidate_info": {
        "commit_hash": "e2300f1205af249eae76fba45b5b9f76f8d125b2",
        "repo": "hashicorp/nomad",
        "commit_url": "https://github.com/hashicorp/nomad/commit/e2300f1205af249eae76fba45b5b9f76f8d125b2",
        "files": [
          ".changelog/17906.txt",
          "acl/acl.go",
          "nomad/search_endpoint.go",
          "nomad/search_endpoint_oss.go",
          "nomad/search_endpoint_test.go"
        ],
        "message": "search: fix ACL filtering for plugins and variables\n\nACL permissions for the search endpoints are done in three passes. The\nfirst (the `sufficientSearchPerms` method) is for performance and coarsely\nrejects requests based on the passed-in context parameter if the user has no\npermissions to any object in that context. The second (the\n`filteredSearchContexts` method) filters out contexts based on whether the user\nhas permissions either to the requested namespace or again by context (to catch\nthe \"all\" context). Finally, when iterating over the objects available, we do\nthe usual filtering in the iterator.\n\nInternal testing found several bugs in this filtering:\n* CSI plugins can be searched by any authenticated user.\n* Variables can be searched if the user has `job:read` permissions to the\n  variable's namespace instead of `variable:list`.\n* Variables cannot be searched by wildcard namespace.\n\nThis is an information leak of the plugin names and variable paths, which we\ndon't consider to be privileged information but intended to protect anyways.\n\nThis changeset fixes these bugs by ensuring CSI plugins are filtered in the 1st\nand 2nd pass ACL filters, and changes variables to check `variable:list` in the\n2nd pass filter unless the wildcard namespace is passed (at which point we'll\nfallback to filtering in the iterator).\n\nFixes: CVE-2023-3300\nFixes: #17906",
        "before_after_code_files": [
          "acl/acl.go||acl/acl.go",
          "nomad/search_endpoint.go||nomad/search_endpoint.go",
          "nomad/search_endpoint_oss.go||nomad/search_endpoint_oss.go",
          "nomad/search_endpoint_test.go||nomad/search_endpoint_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "acl/acl.go||acl/acl.go",
            "nomad/search_endpoint.go||nomad/search_endpoint.go",
            "nomad/search_endpoint_oss.go||nomad/search_endpoint_oss.go",
            "nomad/search_endpoint_test.go||nomad/search_endpoint_test.go"
          ],
          "candidate": [
            "acl/acl.go||acl/acl.go",
            "nomad/search_endpoint.go||nomad/search_endpoint.go",
            "nomad/search_endpoint_oss.go||nomad/search_endpoint_oss.go",
            "nomad/search_endpoint_test.go||nomad/search_endpoint_test.go"
          ]
        }
      },
      "candidate_diff": {
        "acl/acl.go||acl/acl.go": [
          "File: acl/acl.go -> acl/acl.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "505:  if a.management {",
          "506:   return true",
          "507:  }",
          "508:  iter := a.variables.Root().Iterator()",
          "509:  iter.SeekPrefix([]byte(ns))",
          "510:  _, _, ok := iter.Next()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "508:  if ns == \"*\" {",
          "509:   return a.variables.Len() > 0 || a.wildcardVariables.Len() > 0",
          "510:  }",
          "",
          "---------------"
        ],
        "nomad/search_endpoint.go||nomad/search_endpoint.go": [
          "File: nomad/search_endpoint.go -> nomad/search_endpoint.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "668:   return true",
          "669:  }",
          "684:  switch context {",
          "685:  case structs.Nodes:",
          "687:  case structs.NodePools:",
          "693:  case structs.Namespaces:",
          "697:  case structs.Volumes:",
          "698:   return acl.NamespaceValidator(acl.NamespaceCapabilityCSIListVolume,",
          "699:    acl.NamespaceCapabilityCSIReadVolume,",
          "",
          "[Removed Lines]",
          "671:  nodeRead := aclObj.AllowNodeRead()",
          "672:  allowNodePool := aclObj.AllowNodePoolSearch()",
          "673:  allowNS := aclObj.AllowNamespace(namespace)",
          "674:  jobRead := aclObj.AllowNsOp(namespace, acl.NamespaceCapabilityReadJob)",
          "675:  allowEnt := sufficientSearchPermsEnt(aclObj)",
          "677:  if !nodeRead && !allowNodePool && !allowNS && !allowEnt && !jobRead {",
          "678:   return false",
          "679:  }",
          "686:   return nodeRead",
          "692:   return allowNodePool",
          "694:   return allowNS",
          "695:  case structs.Allocs, structs.Deployments, structs.Evals, structs.Jobs:",
          "696:   return jobRead",
          "",
          "[Added Lines]",
          "679:   return aclObj.AllowNodeRead()",
          "685:   return aclObj.AllowNodePoolSearch()",
          "687:   return aclObj.AllowNamespace(namespace)",
          "688:  case structs.Allocs, structs.Deployments, structs.Evals, structs.Jobs,",
          "689:   structs.ScalingPolicies, structs.Recommendations:",
          "690:   return aclObj.AllowNsOp(namespace, acl.NamespaceCapabilityReadJob)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "701:    acl.NamespaceCapabilityReadJob)(aclObj, namespace)",
          "702:  case structs.Variables:",
          "703:   return aclObj.AllowVariableSearch(namespace)",
          "704:  }",
          "706:  return true",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "698:  case structs.Plugins:",
          "699:   return aclObj.AllowPluginList()",
          "700:  case structs.Quotas:",
          "701:   return aclObj.AllowQuotaRead()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "927:     available = append(available, c)",
          "928:    }",
          "929:   case structs.Variables:",
          "931:     available = append(available, c)",
          "932:    }",
          "933:   case structs.Nodes:",
          "",
          "[Removed Lines]",
          "930:    if jobRead {",
          "",
          "[Added Lines]",
          "928:    if aclObj.AllowVariableSearch(namespace) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "942:    if volRead {",
          "943:     available = append(available, c)",
          "944:    }",
          "945:   default:",
          "946:    if ok := filteredSearchContextsEnt(aclObj, namespace, c); ok {",
          "947:     available = append(available, c)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "943:   case structs.Plugins:",
          "944:    if aclObj.AllowPluginList() {",
          "945:     available = append(available, c)",
          "946:    }",
          "",
          "---------------"
        ],
        "nomad/search_endpoint_oss.go||nomad/search_endpoint_oss.go": [
          "File: nomad/search_endpoint_oss.go -> nomad/search_endpoint_oss.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "51:  return nil, fmt.Errorf(\"context must be one of %v or 'all' for all contexts; got %q\", allContexts, context)",
          "52: }",
          "58: func filteredSearchContextsEnt(aclObj *acl.ACL, namespace string, context structs.Context) bool {",
          "59:  return true",
          "60: }",
          "",
          "[Removed Lines]",
          "54: func sufficientSearchPermsEnt(aclObj *acl.ACL) bool {",
          "55:  return true",
          "56: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "nomad/search_endpoint_test.go||nomad/search_endpoint_test.go": [
          "File: nomad/search_endpoint_test.go -> nomad/search_endpoint_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "19:  \"github.com/hashicorp/nomad/testutil\"",
          "20:  \"github.com/shoenig/test/must\"",
          "21:  \"github.com/stretchr/testify/require\"",
          "22: )",
          "24: const jobIndex = 1000",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22:  \"golang.org/x/exp/slices\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "85:  defer cleanupS()",
          "86:  codec := rpcClient(t, s)",
          "87:  testutil.WaitForLeader(t, s.RPC)",
          "90:  job := registerMockJob(s, t, jobID, 0)",
          "93:  req := &structs.SearchRequest{",
          "94:   Prefix:  \"\",",
          "",
          "[Removed Lines]",
          "88:  fsmState := s.fsm.State()",
          "91:  require.NoError(t, fsmState.UpsertNode(structs.MsgTypeTestSetup, 1001, mock.Node()))",
          "",
          "[Added Lines]",
          "89:  store := s.fsm.State()",
          "91:  ns := mock.Namespace()",
          "92:  ns.Name = \"not-allowed\"",
          "93:  must.NoError(t, store.UpsertNamespaces(10, []*structs.Namespace{ns}))",
          "97:  variable := mock.VariableEncrypted()",
          "98:  resp := store.VarSet(1001, &structs.VarApplyStateRequest{",
          "99:   Op:  structs.VarOpSet,",
          "100:   Var: variable,",
          "101:  })",
          "102:  must.NoError(t, resp.Error)",
          "104:  plugin := mock.CSIPlugin()",
          "105:  must.NoError(t, store.UpsertCSIPlugin(1002, plugin))",
          "107:  node := mock.Node()",
          "108:  must.NoError(t, store.UpsertNode(structs.MsgTypeTestSetup, 1003, node))",
          "110:  disallowedVariable := mock.VariableEncrypted()",
          "111:  disallowedVariable.Namespace = \"not-allowed\"",
          "112:  resp = store.VarSet(2001, &structs.VarApplyStateRequest{",
          "113:   Op:  structs.VarOpSet,",
          "114:   Var: disallowedVariable,",
          "115:  })",
          "116:  must.NoError(t, resp.Error)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "103:  {",
          "104:   var resp structs.SearchResponse",
          "105:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "107:  }",
          "110:  {",
          "112:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityListJobs}))",
          "113:   req.AuthToken = invalidToken.SecretID",
          "114:   var resp structs.SearchResponse",
          "115:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "117:  }",
          "120:  {",
          "122:   req.AuthToken = validToken.SecretID",
          "123:   var resp structs.SearchResponse",
          "124:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "126:  }",
          "129:  {",
          "131:   req.Context = structs.All",
          "132:   req.AuthToken = validToken.SecretID",
          "133:   var resp structs.SearchResponse",
          "140:  }",
          "143:  {",
          "145:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}))",
          "146:   req.AuthToken = validToken.SecretID",
          "147:   var resp structs.SearchResponse",
          "157:  }",
          "160:  {",
          "162:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "163:    mock.NodePolicy(acl.PolicyRead),",
          "164:   }, \"\\n\"))",
          "165:   req.AuthToken = validToken.SecretID",
          "166:   var resp structs.SearchResponse",
          "172:  }",
          "175:  {",
          "176:   req.AuthToken = root.SecretID",
          "177:   var resp structs.SearchResponse",
          "183:  }",
          "184: }",
          "",
          "[Removed Lines]",
          "106:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "111:   invalidToken := mock.CreatePolicyAndToken(t, fsmState, 1003, \"test-invalid\",",
          "116:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "121:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "125:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "130:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "134:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "135:   require.Equal(t, uint64(1001), resp.Index)",
          "136:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "139:   require.Len(t, resp.Matches[structs.Jobs], 0)",
          "144:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1009, \"test-valid2\",",
          "148:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "149:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "150:   require.Equal(t, job.ID, resp.Matches[structs.Jobs][0])",
          "153:   require.Equal(t, uint64(1000), resp.Index)",
          "156:   require.Len(t, resp.Matches[structs.Nodes], 0)",
          "161:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1011, \"test-valid3\", strings.Join([]string{",
          "167:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "168:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "169:   require.Equal(t, job.ID, resp.Matches[structs.Jobs][0])",
          "170:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "171:   require.Equal(t, uint64(1001), resp.Index)",
          "178:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "179:   require.Equal(t, uint64(1001), resp.Index)",
          "180:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "181:   require.Equal(t, job.ID, resp.Matches[structs.Jobs][0])",
          "182:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "",
          "[Added Lines]",
          "131:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "136:   invalidToken := mock.CreatePolicyAndToken(t, store, 1003, \"test-invalid\",",
          "141:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "146:   validToken := mock.CreatePolicyAndToken(t, store, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "150:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "155:   validToken := mock.CreatePolicyAndToken(t, store, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "159:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "161:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "165:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "166:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "167:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
          "169:   must.Eq(t, uint64(1003), resp.Index) // index of node",
          "174:   validToken := mock.CreatePolicyAndToken(t, store, 1009, \"test-valid2\",",
          "178:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "180:   must.Eq(t, []string{job.ID}, resp.Matches[structs.Jobs])",
          "184:   must.SliceEmpty(t, resp.Matches[structs.Nodes])",
          "185:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "186:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
          "189:   must.Eq(t, uint64(1000), resp.Index)",
          "194:   validToken := mock.CreatePolicyAndToken(t, store, 1011, \"test-valid3\", strings.Join([]string{",
          "200:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "202:   must.Eq(t, []string{job.ID}, resp.Matches[structs.Jobs])",
          "203:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "204:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
          "205:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "206:   must.Eq(t, uint64(1003), resp.Index) // index of node",
          "207:  }",
          "210:  {",
          "211:   validToken := mock.CreatePolicyAndToken(t, store, 1012, \"test-valid4\", strings.Join([]string{",
          "212:    mock.NamespacePolicyWithVariables(structs.DefaultNamespace, \"\", []string{},",
          "213:     map[string][]string{\"*\": []string{\"list\"}}),",
          "214:    mock.NodePolicy(acl.PolicyRead),",
          "215:   }, \"\\n\"))",
          "216:   req.AuthToken = validToken.SecretID",
          "217:   var resp structs.SearchResponse",
          "218:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "220:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "221:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "222:   must.Eq(t, []string{variable.Path}, resp.Matches[structs.Variables])",
          "223:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "224:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
          "225:  }",
          "228:  {",
          "229:   validToken := mock.CreatePolicyAndToken(t, store, 1012, \"test-valid4\", strings.Join([]string{",
          "230:    mock.NamespacePolicyWithVariables(structs.DefaultNamespace, \"\", []string{},",
          "231:     map[string][]string{\"*\": []string{\"list\"}}),",
          "232:    mock.NodePolicy(acl.PolicyRead),",
          "233:   }, \"\\n\"))",
          "234:   req.AuthToken = validToken.SecretID",
          "235:   req.Namespace = structs.AllNamespacesSentinel",
          "236:   var resp structs.SearchResponse",
          "237:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "239:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "240:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "241:   must.Eq(t, []string{variable.Path}, resp.Matches[structs.Variables])",
          "242:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "243:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
          "249:   req.Namespace = structs.DefaultNamespace",
          "251:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "253:   must.Eq(t, []string{job.ID}, resp.Matches[structs.Jobs])",
          "254:   must.Eq(t, []string{plugin.ID}, resp.Matches[structs.Plugins])",
          "256:   expectVars := []string{variable.Path, disallowedVariable.Path}",
          "257:   slices.Sort(expectVars)",
          "258:   slices.Sort(resp.Matches[structs.Variables])",
          "259:   must.Eq(t, expectVars, resp.Matches[structs.Variables])",
          "260:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "261:   must.Eq(t, uint64(2001), resp.Index) // highest index",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1003:  codec := rpcClient(t, s)",
          "1004:  testutil.WaitForLeader(t, s.RPC)",
          "1007:  ns := mock.Namespace()",
          "1010:  job1 := mock.Job()",
          "1013:  job2 := mock.Job()",
          "1014:  job2.Namespace = ns.Name",
          "1019:  req := &structs.SearchRequest{",
          "1020:   Prefix:  \"\",",
          "",
          "[Removed Lines]",
          "1005:  fsmState := s.fsm.State()",
          "1008:  require.NoError(t, fsmState.UpsertNamespaces(500, []*structs.Namespace{ns}))",
          "1011:  require.NoError(t, fsmState.UpsertJob(structs.MsgTypeTestSetup, 502, nil, job1))",
          "1015:  require.NoError(t, fsmState.UpsertJob(structs.MsgTypeTestSetup, 504, nil, job2))",
          "1017:  require.NoError(t, fsmState.UpsertNode(structs.MsgTypeTestSetup, 1001, mock.Node()))",
          "",
          "[Added Lines]",
          "1084:  store := s.fsm.State()",
          "1087:  must.NoError(t, store.UpsertNamespaces(500, []*structs.Namespace{ns}))",
          "1090:  must.NoError(t, store.UpsertJob(structs.MsgTypeTestSetup, 502, nil, job1))",
          "1094:  must.NoError(t, store.UpsertJob(structs.MsgTypeTestSetup, 504, nil, job2))",
          "1096:  node := mock.Node()",
          "1097:  must.NoError(t, store.UpsertNode(structs.MsgTypeTestSetup, 1001, node))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1029:  {",
          "1030:   var resp structs.SearchResponse",
          "1031:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "1033:  }",
          "1036:  {",
          "1038:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityListJobs}))",
          "1039:   req.AuthToken = invalidToken.SecretID",
          "1040:   var resp structs.SearchResponse",
          "1041:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "1043:  }",
          "1046:  {",
          "1048:   req.Context = structs.Namespaces",
          "1049:   req.AuthToken = validToken.SecretID",
          "1050:   var resp structs.SearchResponse",
          "1051:   err := msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp)",
          "1053:  }",
          "1056:  {",
          "1058:   req.Context = structs.All",
          "1059:   req.AuthToken = validToken.SecretID",
          "1060:   var resp structs.SearchResponse",
          "1067:  }",
          "1070:  {",
          "1072:    mock.NamespacePolicy(job2.Namespace, \"\", []string{acl.NamespaceCapabilityReadJob}))",
          "1073:   req.Context = structs.All",
          "1074:   req.AuthToken = validToken.SecretID",
          "1075:   req.Namespace = job2.Namespace",
          "1076:   var resp structs.SearchResponse",
          "1087:  }",
          "1090:  {",
          "1092:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}),",
          "1093:    mock.NodePolicy(acl.PolicyRead),",
          "1094:   }, \"\\n\"))",
          "",
          "[Removed Lines]",
          "1032:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "1037:   invalidToken := mock.CreatePolicyAndToken(t, fsmState, 1003, \"test-invalid\",",
          "1042:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "1047:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "1052:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "1057:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "1061:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "1062:   require.Equal(t, uint64(1001), resp.Index)",
          "1063:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "1066:   require.Len(t, resp.Matches[structs.Jobs], 0)",
          "1071:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1009, \"test-valid2\",",
          "1077:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "1078:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "1079:   require.Equal(t, job2.ID, resp.Matches[structs.Jobs][0])",
          "1080:   require.Len(t, resp.Matches[structs.Namespaces], 1)",
          "1083:   require.Equal(t, uint64(504), resp.Index)",
          "1086:   require.Len(t, resp.Matches[structs.Nodes], 0)",
          "1091:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1011, \"test-valid3\", strings.Join([]string{",
          "",
          "[Added Lines]",
          "1112:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "1117:   invalidToken := mock.CreatePolicyAndToken(t, store, 1003, \"test-invalid\",",
          "1122:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "1127:   validToken := mock.CreatePolicyAndToken(t, store, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "1132:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "1137:   validToken := mock.CreatePolicyAndToken(t, store, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "1141:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "1142:   must.Eq(t, uint64(1001), resp.Index)",
          "1143:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "1146:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "1151:   validToken := mock.CreatePolicyAndToken(t, store, 1009, \"test-valid2\",",
          "1157:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "1159:   must.Eq(t, []string{job2.ID}, resp.Matches[structs.Jobs])",
          "1160:   must.Eq(t, []string{ns.Name}, resp.Matches[structs.Namespaces])",
          "1163:   must.Eq(t, uint64(504), resp.Index)",
          "1166:   must.SliceEmpty(t, resp.Matches[structs.Nodes])",
          "1171:   validToken := mock.CreatePolicyAndToken(t, store, 1011, \"test-valid3\", strings.Join([]string{",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1096:   req.AuthToken = validToken.SecretID",
          "1097:   req.Namespace = structs.DefaultNamespace",
          "1098:   var resp structs.SearchResponse",
          "1105:  }",
          "",
          "[Removed Lines]",
          "1099:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "1100:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "1101:   require.Equal(t, job1.ID, resp.Matches[structs.Jobs][0])",
          "1102:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "1103:   require.Equal(t, uint64(1001), resp.Index)",
          "1104:   require.Len(t, resp.Matches[structs.Namespaces], 1)",
          "",
          "[Added Lines]",
          "1179:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "1181:   must.Eq(t, []string{job1.ID}, resp.Matches[structs.Jobs])",
          "1182:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "1183:   must.Eq(t, []string{\"default\"}, resp.Matches[structs.Namespaces])",
          "1185:   must.Eq(t, uint64(1001), resp.Index)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1110:   req.AuthToken = root.SecretID",
          "1111:   req.Namespace = structs.DefaultNamespace",
          "1112:   var resp structs.SearchResponse",
          "1119:  }",
          "1120: }",
          "",
          "[Removed Lines]",
          "1113:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "1114:   require.Equal(t, uint64(1001), resp.Index)",
          "1115:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "1116:   require.Equal(t, job1.ID, resp.Matches[structs.Jobs][0])",
          "1117:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "1118:   require.Len(t, resp.Matches[structs.Namespaces], 2)",
          "",
          "[Added Lines]",
          "1195:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.PrefixSearch\", req, &resp))",
          "1197:   must.Eq(t, []string{job1.ID}, resp.Matches[structs.Jobs])",
          "1198:   must.Eq(t, []string{node.ID}, resp.Matches[structs.Nodes])",
          "1199:   must.Eq(t, []string{\"default\", ns.Name}, resp.Matches[structs.Namespaces])",
          "1201:   must.Eq(t, uint64(1001), resp.Index)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1167:  defer cleanupS()",
          "1168:  codec := rpcClient(t, s)",
          "1169:  testutil.WaitForLeader(t, s.RPC)",
          "1172:  job := mock.Job()",
          "1173:  registerJob(s, t, job)",
          "1175:  node := mock.Node()",
          "1178:  req := &structs.FuzzySearchRequest{",
          "1179:   Text:         \"set-this-in-test\",",
          "",
          "[Removed Lines]",
          "1170:  fsmState := s.fsm.State()",
          "1176:  require.NoError(t, fsmState.UpsertNode(structs.MsgTypeTestSetup, 1001, node))",
          "",
          "[Added Lines]",
          "1253:  store := s.fsm.State()",
          "1255:  ns := mock.Namespace()",
          "1256:  ns.Name = \"not-allowed\"",
          "1257:  must.NoError(t, store.UpsertNamespaces(10, []*structs.Namespace{ns}))",
          "1262:  variable := mock.VariableEncrypted()",
          "1263:  variable.Path = \"test-path/o\"",
          "1264:  resp := store.VarSet(1001, &structs.VarApplyStateRequest{",
          "1265:   Op:  structs.VarOpSet,",
          "1266:   Var: variable,",
          "1267:  })",
          "1268:  must.NoError(t, resp.Error)",
          "1270:  plugin := mock.CSIPlugin()",
          "1271:  plugin.ID = \"mock.hashicorp.com\"",
          "1272:  must.NoError(t, store.UpsertCSIPlugin(1002, plugin))",
          "1275:  must.NoError(t, store.UpsertNode(structs.MsgTypeTestSetup, 1003, node))",
          "1277:  disallowedVariable := mock.VariableEncrypted()",
          "1278:  disallowedVariable.Namespace = \"not-allowed\"",
          "1279:  resp = store.VarSet(2001, &structs.VarApplyStateRequest{",
          "1280:   Op:  structs.VarOpSet,",
          "1281:   Var: disallowedVariable,",
          "1282:  })",
          "1283:  must.NoError(t, resp.Error)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1185:  {",
          "1186:   var resp structs.FuzzySearchResponse",
          "1187:   err := msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp)",
          "1189:  }",
          "1192:  {",
          "1194:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityListJobs}))",
          "1195:   req.AuthToken = invalidToken.SecretID",
          "1196:   var resp structs.FuzzySearchResponse",
          "1197:   err := msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp)",
          "1199:  }",
          "1202:  {",
          "1204:   req.AuthToken = validToken.SecretID",
          "1205:   var resp structs.FuzzySearchResponse",
          "1206:   err := msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp)",
          "1208:  }",
          "1211:  {",
          "1213:   req.Context = structs.All",
          "1214:   req.AuthToken = validToken.SecretID",
          "1215:   req.Text = \"oo\" // mock node ID is foobar",
          "1216:   var resp structs.FuzzySearchResponse",
          "1223:  }",
          "1226:  {",
          "1228:    mock.NamespacePolicy(structs.DefaultNamespace, \"\", []string{acl.NamespaceCapabilityReadJob}))",
          "1229:   req.AuthToken = validToken.SecretID",
          "1230:   req.Text = \"jo\" // mock job Name is my-job",
          "1231:   var resp structs.FuzzySearchResponse",
          "1233:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "1235:    ID:    \"my-job\",",
          "1236:    Scope: []string{\"default\", job.ID},",
          "1237:   }, resp.Matches[structs.Jobs][0])",
          "1244:  }",
          "1247:  {",
          "1248:   req.AuthToken = root.SecretID",
          "1249:   var resp structs.FuzzySearchResponse",
          "1262:  }",
          "1263: }",
          "",
          "[Removed Lines]",
          "1188:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "1193:   invalidToken := mock.CreatePolicyAndToken(t, fsmState, 1003, \"test-invalid\",",
          "1198:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "1203:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "1207:   require.EqualError(t, err, structs.ErrPermissionDenied.Error())",
          "1212:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "1217:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1218:   require.Equal(t, uint64(1001), resp.Index)",
          "1219:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "1222:   require.Len(t, resp.Matches[structs.Jobs], 0)",
          "1227:   validToken := mock.CreatePolicyAndToken(t, fsmState, 1009, \"test-valid2\",",
          "1232:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1234:   require.Equal(t, structs.FuzzyMatch{",
          "1240:   require.Equal(t, uint64(1000), resp.Index)",
          "1243:   require.Len(t, resp.Matches[structs.Nodes], 0)",
          "1250:   req.Text = \"o\" // matches Job:my-job and Node:foobar",
          "1251:   require.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1252:   require.Equal(t, uint64(1001), resp.Index)",
          "1253:   require.Len(t, resp.Matches[structs.Jobs], 1)",
          "1254:   require.Equal(t, structs.FuzzyMatch{",
          "1255:    ID: job.Name, Scope: []string{\"default\", job.ID},",
          "1256:   }, resp.Matches[structs.Jobs][0])",
          "1257:   require.Len(t, resp.Matches[structs.Nodes], 1)",
          "1258:   require.Equal(t, structs.FuzzyMatch{",
          "1259:    ID:    \"foobar\",",
          "1260:    Scope: []string{node.ID},",
          "1261:   }, resp.Matches[structs.Nodes][0])",
          "",
          "[Added Lines]",
          "1295:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "1300:   invalidToken := mock.CreatePolicyAndToken(t, store, 1003, \"test-invalid\",",
          "1305:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "1310:   validToken := mock.CreatePolicyAndToken(t, store, 1005, \"test-invalid2\", mock.NodePolicy(acl.PolicyRead))",
          "1314:   must.EqError(t, err, structs.ErrPermissionDenied.Error())",
          "1319:   validToken := mock.CreatePolicyAndToken(t, store, 1007, \"test-valid\", mock.NodePolicy(acl.PolicyRead))",
          "1324:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1326:   must.Eq(t, []structs.FuzzyMatch{{ID: node.Name, Scope: []string{node.ID}}},",
          "1327:    resp.Matches[structs.Nodes])",
          "1331:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "1332:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "1333:   must.SliceEmpty(t, resp.Matches[structs.Variables])",
          "1335:   must.Eq(t, uint64(1003), resp.Index) // index of node",
          "1340:   validToken := mock.CreatePolicyAndToken(t, store, 1009, \"test-valid2\",",
          "1345:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1347:   must.Eq(t, structs.FuzzyMatch{",
          "1353:   must.Eq(t, uint64(1000), resp.Index)",
          "1356:   must.SliceEmpty(t, resp.Matches[structs.Nodes])",
          "1357:  }",
          "1360:  {",
          "1361:   validToken := mock.CreatePolicyAndToken(t, store, 1012, \"test-valid4\", strings.Join([]string{",
          "1362:    mock.NamespacePolicyWithVariables(structs.DefaultNamespace, \"\", []string{},",
          "1363:     map[string][]string{\"*\": []string{\"list\"}}),",
          "1364:    mock.NodePolicy(acl.PolicyRead),",
          "1365:   }, \"\\n\"))",
          "1366:   req.Text = \"o\" // matches Job:my-job, Node:foobar, Plugin, and Variables",
          "1367:   req.AuthToken = validToken.SecretID",
          "1368:   var resp structs.FuzzySearchResponse",
          "1369:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1371:   must.SliceEmpty(t, resp.Matches[structs.Jobs])",
          "1372:   must.SliceEmpty(t, resp.Matches[structs.Plugins])",
          "1374:   must.Eq(t, []structs.FuzzyMatch{",
          "1375:    {ID: node.Name, Scope: []string{node.ID}}},",
          "1376:    resp.Matches[structs.Nodes])",
          "1378:   must.Eq(t, []structs.FuzzyMatch{{",
          "1379:    ID:    variable.Path,",
          "1380:    Scope: []string{structs.DefaultNamespace, variable.Path}}},",
          "1381:    resp.Matches[structs.Variables])",
          "1383:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
          "1390:   req.Text = \"o\" // matches Job:my-job, Node:foobar, Plugin, and Variables",
          "1391:   must.NoError(t, msgpackrpc.CallWithCodec(codec, \"Search.FuzzySearch\", req, &resp))",
          "1393:   must.Eq(t, []structs.FuzzyMatch{",
          "1394:    {ID: job.Name, Scope: []string{\"default\", job.ID}}},",
          "1395:    resp.Matches[structs.Jobs])",
          "1397:   must.Eq(t, []structs.FuzzyMatch{",
          "1398:    {ID: node.Name, Scope: []string{node.ID}}},",
          "1399:    resp.Matches[structs.Nodes])",
          "1401:   must.Eq(t, []structs.FuzzyMatch{{ID: plugin.ID}},",
          "1402:    resp.Matches[structs.Plugins])",
          "1404:   must.Eq(t, []structs.FuzzyMatch{{",
          "1405:    ID:    variable.Path,",
          "1406:    Scope: []string{structs.DefaultNamespace, variable.Path}}},",
          "1407:    resp.Matches[structs.Variables])",
          "1409:   must.Eq(t, uint64(2001), resp.Index) // index of variables",
          "",
          "---------------"
        ]
      }
    }
  ]
}
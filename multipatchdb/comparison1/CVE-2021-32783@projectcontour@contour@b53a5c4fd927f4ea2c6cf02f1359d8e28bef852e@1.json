{
  "cve_id": "CVE-2021-32783",
  "cve_desc": "Contour is a Kubernetes ingress controller using Envoy proxy. In Contour before version 1.17.1 a specially crafted ExternalName type Service may be used to access Envoy's admin interface, which Contour normally prevents from access outside the Envoy container. This can be used to shut down Envoy remotely (a denial of service), or to expose the existence of any Secret that Envoy is using for its configuration, including most notably TLS Keypairs. However, it *cannot* be used to get the *content* of those secrets. Since this attack allows access to the administration interface, a variety of administration options are available, such as shutting down the Envoy or draining traffic. In general, the Envoy admin interface cannot easily be used for making changes to the cluster, in-flight requests, or backend services, but it could be used to shut down or drain Envoy, change traffic routing, or to retrieve secret metadata, as mentioned above. The issue will be addressed in Contour v1.18.0 and a cherry-picked patch release, v1.17.1, has been released to cover users who cannot upgrade at this time. For more details refer to the linked GitHub Security Advisory.",
  "repo": "projectcontour/contour",
  "patch_hash": "b53a5c4fd927f4ea2c6cf02f1359d8e28bef852e",
  "patch_info": {
    "commit_hash": "b53a5c4fd927f4ea2c6cf02f1359d8e28bef852e",
    "repo": "projectcontour/contour",
    "commit_url": "https://github.com/projectcontour/contour/commit/b53a5c4fd927f4ea2c6cf02f1359d8e28bef852e",
    "files": [
      "cmd/contour/serve.go",
      "examples/contour/01-contour-config.yaml",
      "examples/render/contour-gateway.yaml",
      "examples/render/contour.yaml",
      "go.mod",
      "internal/dag/accessors.go",
      "internal/dag/accessors_test.go",
      "internal/dag/builder_test.go",
      "internal/dag/extension_processor.go",
      "internal/dag/gatewayapi_processor.go",
      "internal/dag/httpproxy_processor.go",
      "internal/dag/ingress_processor.go",
      "internal/dag/status_test.go",
      "internal/featuretests/v3/externalname_test.go",
      "internal/featuretests/v3/headerpolicy_test.go",
      "pkg/config/parameters.go",
      "site/content/docs/main/configuration.md",
      "test/e2e/httpproxy/018_external_name_test.go",
      "test/e2e/httpproxy/httpproxy_test.go"
    ],
    "message": "cherrypicks for v1.17.1 (#3909)\n\n* Merge pull request from GHSA-5ph6-qq5x-7jwc\n\nSigned-off-by: Nick Young <ynick@vmware.com>\n\n* Fix spelling and lint errors that slipped into the ExternalName PR (#3908)\n\nSigned-off-by: Nick Young <ynick@vmware.com>\n\nCo-authored-by: Nick Young <ynick@vmware.com>",
    "before_after_code_files": [
      "cmd/contour/serve.go||cmd/contour/serve.go",
      "go.mod||go.mod",
      "internal/dag/accessors.go||internal/dag/accessors.go",
      "internal/dag/accessors_test.go||internal/dag/accessors_test.go",
      "internal/dag/builder_test.go||internal/dag/builder_test.go",
      "internal/dag/extension_processor.go||internal/dag/extension_processor.go",
      "internal/dag/gatewayapi_processor.go||internal/dag/gatewayapi_processor.go",
      "internal/dag/httpproxy_processor.go||internal/dag/httpproxy_processor.go",
      "internal/dag/ingress_processor.go||internal/dag/ingress_processor.go",
      "internal/dag/status_test.go||internal/dag/status_test.go",
      "internal/featuretests/v3/externalname_test.go||internal/featuretests/v3/externalname_test.go",
      "internal/featuretests/v3/headerpolicy_test.go||internal/featuretests/v3/headerpolicy_test.go",
      "pkg/config/parameters.go||pkg/config/parameters.go",
      "test/e2e/httpproxy/018_external_name_test.go||test/e2e/httpproxy/018_external_name_test.go",
      "test/e2e/httpproxy/httpproxy_test.go||test/e2e/httpproxy/httpproxy_test.go"
    ]
  },
  "patch_diff": {
    "cmd/contour/serve.go||cmd/contour/serve.go": [
      "File: cmd/contour/serve.go -> cmd/contour/serve.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "714:   responseHeadersPolicy.Remove = append(responseHeadersPolicy.Remove, ctx.Config.Policy.ResponseHeadersPolicy.Remove...)",
      "715:  }",
      "718:  dagProcessors := []dag.Processor{",
      "719:   &dag.IngressProcessor{",
      "722:   },",
      "723:   &dag.ExtensionServiceProcessor{",
      "724:    FieldLogger:       log.WithField(\"context\", \"ExtensionServiceProcessor\"),",
      "725:    ClientCertificate: clientCert,",
      "726:   },",
      "727:   &dag.HTTPProxyProcessor{",
      "734:   },",
      "735:  }",
      "737:  if ctx.Config.GatewayConfig != nil && clients.ResourcesExist(k8s.GatewayAPIResources()...) {",
      "738:   dagProcessors = append(dagProcessors, &dag.GatewayAPIProcessor{",
      "740:   })",
      "741:  }",
      "",
      "[Removed Lines]",
      "720:    FieldLogger:       log.WithField(\"context\", \"IngressProcessor\"),",
      "721:    ClientCertificate: clientCert,",
      "728:    DisablePermitInsecure: ctx.Config.DisablePermitInsecure,",
      "729:    FallbackCertificate:   fallbackCert,",
      "730:    DNSLookupFamily:       ctx.Config.Cluster.DNSLookupFamily,",
      "731:    ClientCertificate:     clientCert,",
      "732:    RequestHeadersPolicy:  &requestHeadersPolicy,",
      "733:    ResponseHeadersPolicy: &responseHeadersPolicy,",
      "739:    FieldLogger: log.WithField(\"context\", \"GatewayAPIProcessor\"),",
      "",
      "[Added Lines]",
      "717:  log.Debugf(\"EnableExternalNameService is set to %t\", ctx.Config.EnableExternalNameService)",
      "721:    EnableExternalNameService: ctx.Config.EnableExternalNameService,",
      "722:    FieldLogger:               log.WithField(\"context\", \"IngressProcessor\"),",
      "723:    ClientCertificate:         clientCert,",
      "732:    EnableExternalNameService: ctx.Config.EnableExternalNameService,",
      "733:    DisablePermitInsecure:     ctx.Config.DisablePermitInsecure,",
      "734:    FallbackCertificate:       fallbackCert,",
      "735:    DNSLookupFamily:           ctx.Config.Cluster.DNSLookupFamily,",
      "736:    ClientCertificate:         clientCert,",
      "737:    RequestHeadersPolicy:      &requestHeadersPolicy,",
      "738:    ResponseHeadersPolicy:     &responseHeadersPolicy,",
      "744:    EnableExternalNameService: ctx.Config.EnableExternalNameService,",
      "745:    FieldLogger:               log.WithField(\"context\", \"GatewayAPIProcessor\"),",
      "",
      "---------------"
    ],
    "go.mod||go.mod": [
      "File: go.mod -> go.mod",
      "--- Hunk 1 ---",
      "[Context before]",
      "5: require (",
      "6:  github.com/ahmetb/gen-crd-api-reference-docs v0.3.0",
      "7:  github.com/bombsimon/logrusr v1.0.0",
      "8:  github.com/envoyproxy/go-control-plane v0.9.9-0.20210111201334-f1f47757da33",
      "9:  github.com/go-logr/logr v0.4.0",
      "10:  github.com/golang/protobuf v1.5.2",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "8:  github.com/davecgh/go-spew v1.1.1 // indirect",
      "",
      "---------------"
    ],
    "internal/dag/accessors.go||internal/dag/accessors.go": [
      "File: internal/dag/accessors.go -> internal/dag/accessors.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "55:  svc, svcPort, err := cache.LookupService(meta, port)",
      "56:  if err != nil {",
      "57:   return nil, err",
      "58:  }",
      "60:  if dagSvc := dag.GetService(k8s.NamespacedNameOf(svc), svcPort.Port); dagSvc != nil {",
      "61:   return dagSvc, nil",
      "62:  }",
      "",
      "[Removed Lines]",
      "54: func (dag *DAG) EnsureService(meta types.NamespacedName, port intstr.IntOrString, cache *KubernetesCache) (*Service, error) {",
      "",
      "[Added Lines]",
      "54: func (dag *DAG) EnsureService(meta types.NamespacedName, port intstr.IntOrString, cache *KubernetesCache, enableExternalNameSvc bool) (*Service, error) {",
      "60:  err = validateExternalName(svc, enableExternalNameSvc)",
      "61:  if err != nil {",
      "62:   return nil, err",
      "63:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "78:  return dagSvc, nil",
      "79: }",
      "81: func upstreamProtocol(svc *v1.Service, port v1.ServicePort) string {",
      "82:  up := annotation.ParseUpstreamProtocols(svc.Annotations)",
      "83:  protocol := up[port.Name]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "86: func validateExternalName(svc *v1.Service, enableExternalNameSvc bool) error {",
      "89:  en := externalName(svc)",
      "90:  if en == \"\" {",
      "91:   return nil",
      "92:  }",
      "95:  if !enableExternalNameSvc {",
      "96:   return fmt.Errorf(\"%s/%s is an ExternalName service, these are not currently enabled. See the config.enableExternalNameService config file setting\", svc.Namespace, svc.Name)",
      "97:  }",
      "104:  localhostNames := map[string]struct{}{",
      "105:   \"localhost\":               {},",
      "106:   \"localhost.localdomain\":   {},",
      "107:   \"local.projectcontour.io\": {},",
      "108:  }",
      "110:  _, localhost := localhostNames[en]",
      "111:  if localhost {",
      "112:   return fmt.Errorf(\"%s/%s is an ExternalName service that points to localhost, this is not allowed\", svc.Namespace, svc.Name)",
      "113:  }",
      "115:  return nil",
      "116: }",
      "",
      "---------------"
    ],
    "internal/dag/accessors_test.go||internal/dag/accessors_test.go": [
      "File: internal/dag/accessors_test.go -> internal/dag/accessors_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "40:    }},",
      "41:   },",
      "42:  }",
      "43:  services := map[types.NamespacedName]*v1.Service{",
      "45:  }",
      "47:  tests := map[string]struct {",
      "48:   types.NamespacedName",
      "52:  }{",
      "53:   \"lookup service by port number\": {",
      "54:    NamespacedName: types.NamespacedName{Name: \"service1\", Namespace: \"default\"},",
      "",
      "[Removed Lines]",
      "44:   {Name: \"service1\", Namespace: \"default\"}: s1,",
      "49:   port    intstr.IntOrString",
      "50:   want    *Service",
      "51:   wantErr error",
      "",
      "[Added Lines]",
      "44:  externalNameValid := &v1.Service{",
      "45:   ObjectMeta: metav1.ObjectMeta{",
      "46:    Name:      \"externalnamevalid\",",
      "47:    Namespace: \"default\",",
      "48:   },",
      "49:   Spec: v1.ServiceSpec{",
      "50:    Type:         v1.ServiceTypeExternalName,",
      "51:    ExternalName: \"external.projectcontour.io\",",
      "52:    Ports: []v1.ServicePort{{",
      "53:     Name:       \"http\",",
      "54:     Protocol:   \"TCP\",",
      "55:     Port:       80,",
      "56:     TargetPort: intstr.FromInt(80),",
      "57:    }},",
      "58:   },",
      "59:  }",
      "61:  externalNameLocalhost := &v1.Service{",
      "62:   ObjectMeta: metav1.ObjectMeta{",
      "63:    Name:      \"externalnamelocalhost\",",
      "64:    Namespace: \"default\",",
      "65:   },",
      "66:   Spec: v1.ServiceSpec{",
      "67:    Type:         v1.ServiceTypeExternalName,",
      "68:    ExternalName: \"localhost\",",
      "69:    Ports: []v1.ServicePort{{",
      "70:     Name:       \"http\",",
      "71:     Protocol:   \"TCP\",",
      "72:     Port:       80,",
      "73:     TargetPort: intstr.FromInt(80),",
      "74:    }},",
      "75:   },",
      "76:  }",
      "79:   {Name: \"service1\", Namespace: \"default\"}:              s1,",
      "80:   {Name: \"externalnamevalid\", Namespace: \"default\"}:     externalNameValid,",
      "81:   {Name: \"externalnamelocalhost\", Namespace: \"default\"}: externalNameLocalhost,",
      "86:   port                  intstr.IntOrString",
      "87:   enableExternalNameSvc bool",
      "88:   want                  *Service",
      "89:   wantErr               error",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "80:    port:           intstr.FromString(\"9999\"),",
      "81:    wantErr:        errors.New(`port \"9999\" on service \"default/service1\" not matched`),",
      "82:   },",
      "83:  }",
      "85:  for name, tc := range tests {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "121:   \"When ExternalName Services are not disabled no error is returned\": {",
      "122:    NamespacedName: types.NamespacedName{Name: \"externalnamevalid\", Namespace: \"default\"},",
      "123:    port:           intstr.FromString(\"80\"),",
      "124:    want: &Service{",
      "125:     Weighted: WeightedService{",
      "126:      Weight:           1,",
      "127:      ServiceName:      \"externalnamevalid\",",
      "128:      ServiceNamespace: \"default\",",
      "129:      ServicePort: v1.ServicePort{",
      "130:       Name:       \"http\",",
      "131:       Protocol:   \"TCP\",",
      "132:       Port:       80,",
      "133:       TargetPort: intstr.FromInt(80),",
      "134:      },",
      "135:     },",
      "136:     ExternalName: \"external.projectcontour.io\",",
      "137:    },",
      "138:    enableExternalNameSvc: true,",
      "139:   },",
      "140:   \"When ExternalName Services are disabled an error is returned\": {",
      "141:    NamespacedName: types.NamespacedName{Name: \"externalnamevalid\", Namespace: \"default\"},",
      "142:    port:           intstr.FromString(\"80\"),",
      "143:    wantErr:        errors.New(`default/externalnamevalid is an ExternalName service, these are not currently enabled. See the config.enableExternalNameService config file setting`),",
      "144:   },",
      "145:   \"When ExternalName Services are enabled but a localhost ExternalName is used an error is returned\": {",
      "146:    NamespacedName:        types.NamespacedName{Name: \"externalnamelocalhost\", Namespace: \"default\"},",
      "147:    port:                  intstr.FromString(\"80\"),",
      "148:    wantErr:               errors.New(`default/externalnamelocalhost is an ExternalName service that points to localhost, this is not allowed`),",
      "149:    enableExternalNameSvc: true,",
      "150:   },",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "94:    var dag DAG",
      "97:    assert.Equal(t, tc.want, got)",
      "98:    assert.Equal(t, tc.wantErr, gotErr)",
      "99:   })",
      "",
      "[Removed Lines]",
      "96:    got, gotErr := dag.EnsureService(tc.NamespacedName, tc.port, &b.Source)",
      "",
      "[Added Lines]",
      "164:    got, gotErr := dag.EnsureService(tc.NamespacedName, tc.port, &b.Source, tc.enableExternalNameSvc)",
      "",
      "---------------"
    ],
    "internal/dag/builder_test.go||internal/dag/builder_test.go": [
      "File: internal/dag/builder_test.go -> internal/dag/builder_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "6536:   },",
      "6537:  }",
      "6539:  proxyExternalNameService := &contour_api_v1.HTTPProxy{",
      "6540:   ObjectMeta: metav1.ObjectMeta{",
      "6541:    Name:      \"example-com\",",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6539:  ingressExternalNameService := &networking_v1.Ingress{",
      "6540:   ObjectMeta: metav1.ObjectMeta{",
      "6541:    Name:      \"externalname\",",
      "6542:    Namespace: \"default\",",
      "6543:   },",
      "6544:   Spec: networking_v1.IngressSpec{",
      "6545:    Rules: []networking_v1.IngressRule{{",
      "6546:     Host: \"example.com\",",
      "6547:     IngressRuleValue: networking_v1.IngressRuleValue{",
      "6548:      HTTP: &networking_v1.HTTPIngressRuleValue{",
      "6549:       Paths: []networking_v1.HTTPIngressPath{{",
      "6550:        Backend: *backendv1(s14.GetName(), intstr.FromInt(80)),",
      "6551:       }},",
      "6552:      },",
      "6553:     },",
      "6554:    }},",
      "6555:   },",
      "6556:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "6582:  tests := map[string]struct {",
      "6583:   objs                         []interface{}",
      "6584:   disablePermitInsecure        bool",
      "6585:   fallbackCertificateName      string",
      "6586:   fallbackCertificateNamespace string",
      "6587:   want                         []Vertex",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "6604:   enableExternalNameSvc        bool",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "8980:     },",
      "8981:    ),",
      "8982:   },",
      "8983:   \"insert proxy with externalName service\": {",
      "8984:    objs: []interface{}{",
      "8985:     proxyExternalNameService,",
      "8986:     s14,",
      "8987:    },",
      "8988:    want: listeners(",
      "8989:     &Listener{",
      "8990:      Port: 80,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "9003:   \"insert ingress with externalName service\": {",
      "9004:    objs: []interface{}{",
      "9005:     ingressExternalNameService,",
      "9006:     s14,",
      "9007:    },",
      "9008:    enableExternalNameSvc: true,",
      "9009:    want: listeners(",
      "9010:     &Listener{",
      "9011:      Port: 80,",
      "9012:      VirtualHosts: virtualhosts(",
      "9013:       virtualhost(\"example.com\", &Route{",
      "9014:        PathMatchCondition: prefixString(\"/\"),",
      "9015:        Clusters: []*Cluster{{",
      "9016:         Upstream: &Service{",
      "9017:          ExternalName: \"externalservice.io\",",
      "9018:          Weighted: WeightedService{",
      "9019:           Weight:           1,",
      "9020:           ServiceName:      s14.Name,",
      "9021:           ServiceNamespace: s14.Namespace,",
      "9022:           ServicePort:      s14.Spec.Ports[0],",
      "9023:          },",
      "9024:         },",
      "9025:        }},",
      "9026:       }),",
      "9027:      ),",
      "9028:     },",
      "9029:    ),",
      "9030:   },",
      "9031:   \"insert ingress with externalName service, but externalName services disabled\": {",
      "9032:    objs: []interface{}{",
      "9033:     ingressExternalNameService,",
      "9034:     s14,",
      "9035:    },",
      "9036:    enableExternalNameSvc: false,",
      "9037:    want:                  listeners(),",
      "9038:   },",
      "9044:    enableExternalNameSvc: true,",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "9014:     s14,",
      "9015:     sec1,",
      "9016:    },",
      "9017:    want: listeners(",
      "9018:     &Listener{",
      "9019:      Port: 443,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "9074:    enableExternalNameSvc: true,",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "9073:     proxyReplaceHostHeaderRoute,",
      "9074:     s14,",
      "9075:    },",
      "9076:    want: listeners(",
      "9077:     &Listener{",
      "9078:      Port: 80,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "9134:    enableExternalNameSvc: true,",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "9111:     proxyReplaceHostHeaderService,",
      "9112:     s14,",
      "9113:    },",
      "9115:   },",
      "9116:   \"insert proxy with response header policy - route - host header\": {",
      "9117:    objs: []interface{}{",
      "",
      "[Removed Lines]",
      "9114:    want: listeners(),",
      "",
      "[Added Lines]",
      "9173:    enableExternalNameSvc: true,",
      "9174:    want:                  listeners(),",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "9754:     },",
      "9755:     Processors: []Processor{",
      "9756:      &IngressProcessor{",
      "9758:      },",
      "9759:      &HTTPProxyProcessor{",
      "9761:       FallbackCertificate: &types.NamespacedName{",
      "9762:        Name:      tc.fallbackCertificateName,",
      "9763:        Namespace: tc.fallbackCertificateNamespace,",
      "",
      "[Removed Lines]",
      "9757:       FieldLogger: fixture.NewTestLogger(t),",
      "9760:       DisablePermitInsecure: tc.disablePermitInsecure,",
      "",
      "[Added Lines]",
      "9817:       FieldLogger:               fixture.NewTestLogger(t),",
      "9818:       EnableExternalNameService: tc.enableExternalNameSvc,",
      "9821:       EnableExternalNameService: tc.enableExternalNameSvc,",
      "9822:       DisablePermitInsecure:     tc.disablePermitInsecure,",
      "",
      "---------------"
    ],
    "internal/dag/extension_processor.go||internal/dag/extension_processor.go": [
      "File: internal/dag/extension_processor.go -> internal/dag/extension_processor.go"
    ],
    "internal/dag/gatewayapi_processor.go||internal/dag/gatewayapi_processor.go": [
      "File: internal/dag/gatewayapi_processor.go -> internal/dag/gatewayapi_processor.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "48:  dag    *DAG",
      "49:  source *KubernetesCache",
      "50: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "54:  EnableExternalNameService bool",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "744:  meta := types.NamespacedName{Name: *serviceName, Namespace: namespace}",
      "748:  if err != nil {",
      "750:  }",
      "752:  return service, nil",
      "",
      "[Removed Lines]",
      "747:  service, err := p.dag.EnsureService(meta, intstr.FromInt(int(*port)), p.source)",
      "749:   return nil, fmt.Errorf(\"service %q does not exist\", meta.Name)",
      "",
      "[Added Lines]",
      "752:  service, err := p.dag.EnsureService(meta, intstr.FromInt(int(*port)), p.source, p.EnableExternalNameService)",
      "754:   return nil, fmt.Errorf(\"service %q is invalid: %s\", meta.Name, err)",
      "",
      "---------------"
    ],
    "internal/dag/httpproxy_processor.go||internal/dag/httpproxy_processor.go": [
      "File: internal/dag/httpproxy_processor.go -> internal/dag/httpproxy_processor.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "58:  FallbackCertificate *types.NamespacedName",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "63:  EnableExternalNameService bool",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "563:     return nil",
      "564:    }",
      "565:    m := types.NamespacedName{Name: service.Name, Namespace: proxy.Namespace}",
      "567:    if err != nil {",
      "568:     validCond.AddErrorf(contour_api_v1.ConditionTypeServiceError, \"ServiceUnresolvedReference\",",
      "569:      \"Spec.Routes unresolved service reference: %s\", err)",
      "",
      "[Removed Lines]",
      "566:    s, err := p.dag.EnsureService(m, intstr.FromInt(service.Port), p.source)",
      "",
      "[Added Lines]",
      "571:    s, err := p.dag.EnsureService(m, intstr.FromInt(service.Port), p.source, p.EnableExternalNameService)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "688:   var proxy TCPProxy",
      "689:   for _, service := range httpproxy.Spec.TCPProxy.Services {",
      "690:    m := types.NamespacedName{Name: service.Name, Namespace: httpproxy.Namespace}",
      "692:    if err != nil {",
      "694:      \"Spec.TCPProxy unresolved service reference: %s\", err)",
      "695:     return false",
      "696:    }",
      "",
      "[Removed Lines]",
      "691:    s, err := p.dag.EnsureService(m, intstr.FromInt(service.Port), p.source)",
      "693:     validCond.AddErrorf(contour_api_v1.ConditionTypeTCPProxyError, \"UnresolvedServiceRef\",",
      "",
      "[Added Lines]",
      "696:    s, err := p.dag.EnsureService(m, intstr.FromInt(service.Port), p.source, p.EnableExternalNameService)",
      "698:     validCond.AddErrorf(contour_api_v1.ConditionTypeTCPProxyError, \"ServiceUnresolvedReference\",",
      "",
      "---------------"
    ],
    "internal/dag/ingress_processor.go||internal/dag/ingress_processor.go": [
      "File: internal/dag/ingress_processor.go -> internal/dag/ingress_processor.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "39:  ClientCertificate *types.NamespacedName",
      "40: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44:  EnableExternalNameService bool",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "144:    port = intstr.FromInt(int(be.Service.Port.Number))",
      "145:   }",
      "148:   if err != nil {",
      "149:    p.WithError(err).",
      "150:     WithField(\"name\", ing.GetName()).",
      "",
      "[Removed Lines]",
      "147:   s, err := p.dag.EnsureService(m, port, p.source)",
      "",
      "[Added Lines]",
      "152:   s, err := p.dag.EnsureService(m, port, p.source, p.EnableExternalNameService)",
      "",
      "---------------"
    ],
    "internal/dag/status_test.go||internal/dag/status_test.go": [
      "File: internal/dag/status_test.go -> internal/dag/status_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "1758:   objs: []interface{}{proxyTCPInvalidMissingService},",
      "1759:   want: map[types.NamespacedName]contour_api_v1.DetailedCondition{",
      "1760:    {Name: proxyTCPInvalidMissingService.Name, Namespace: proxyTCPInvalidMissingService.Namespace}: fixture.NewValidCondition().",
      "1762:   },",
      "1763:  })",
      "",
      "[Removed Lines]",
      "1761:     WithError(contour_api_v1.ConditionTypeTCPProxyError, \"UnresolvedServiceRef\", `Spec.TCPProxy unresolved service reference: service \"roots/not-found\" not found`),",
      "",
      "[Added Lines]",
      "1761:     WithError(contour_api_v1.ConditionTypeTCPProxyError, \"ServiceUnresolvedReference\", `Spec.TCPProxy unresolved service reference: service \"roots/not-found\" not found`),",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1787:   objs: []interface{}{proxyTCPInvalidPortNotMatched, fixture.ServiceRootsKuard},",
      "1788:   want: map[types.NamespacedName]contour_api_v1.DetailedCondition{",
      "1789:    {Name: proxyTCPInvalidPortNotMatched.Name, Namespace: proxyTCPInvalidPortNotMatched.Namespace}: fixture.NewValidCondition().",
      "1791:   },",
      "1792:  })",
      "",
      "[Removed Lines]",
      "1790:     WithError(contour_api_v1.ConditionTypeTCPProxyError, \"UnresolvedServiceRef\", `Spec.TCPProxy unresolved service reference: port \"9999\" on service \"roots/kuard\" not matched`),",
      "",
      "[Added Lines]",
      "1790:     WithError(contour_api_v1.ConditionTypeTCPProxyError, \"ServiceUnresolvedReference\", `Spec.TCPProxy unresolved service reference: port \"9999\" on service \"roots/kuard\" not matched`),",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2931:      Type:    string(status.ConditionResolvedRefs),",
      "2932:      Status:  contour_api_v1.ConditionFalse,",
      "2933:      Reason:  string(status.ReasonDegraded),",
      "2935:     },",
      "2936:     gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
      "2937:      Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
      "",
      "[Removed Lines]",
      "2934:      Message: \"service \\\"invalid-one\\\" does not exist, service \\\"invalid-two\\\" does not exist\",",
      "",
      "[Added Lines]",
      "2934:      Message: \"service \\\"invalid-one\\\" is invalid: service \\\"default/invalid-one\\\" not found, service \\\"invalid-two\\\" is invalid: service \\\"default/invalid-two\\\" not found\",",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3661:       Type:    string(status.ConditionResolvedRefs),",
      "3662:       Status:  contour_api_v1.ConditionFalse,",
      "3663:       Reason:  string(status.ReasonDegraded),",
      "3665:      },",
      "3666:      gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
      "3667:       Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
      "",
      "[Removed Lines]",
      "3664:       Message: \"service \\\"invalid-one\\\" does not exist, service \\\"invalid-two\\\" does not exist\",",
      "",
      "[Added Lines]",
      "3664:       Message: \"service \\\"invalid-one\\\" is invalid: service \\\"default/invalid-one\\\" not found, service \\\"invalid-two\\\" is invalid: service \\\"default/invalid-two\\\" not found\",",
      "",
      "---------------"
    ],
    "internal/featuretests/v3/externalname_test.go||internal/featuretests/v3/externalname_test.go": [
      "File: internal/featuretests/v3/externalname_test.go -> internal/featuretests/v3/externalname_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "16: import (",
      "17:  \"testing\"",
      "19:  \"github.com/projectcontour/contour/internal/featuretests\"",
      "21:  envoy_cluster_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/cluster/v3\"",
      "22:  envoy_route_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/route/v3\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "19:  \"github.com/projectcontour/contour/internal/contour\"",
      "20:  \"github.com/projectcontour/contour/internal/dag\"",
      "22:  \"github.com/sirupsen/logrus\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "39: func TestExternalNameService(t *testing.T) {",
      "41:  defer done()",
      "43:  s1 := fixture.NewService(\"kuard\").",
      "",
      "[Removed Lines]",
      "40:  rh, c, done := setup(t)",
      "",
      "[Added Lines]",
      "43:  rh, c, done := setup(t, enableExternalNameService(t))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "317:   ),",
      "318:  })",
      "319: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "324: func enableExternalNameService(t *testing.T) func(eh *contour.EventHandler) {",
      "325:  return func(eh *contour.EventHandler) {",
      "327:   log := fixture.NewTestLogger(t)",
      "328:   log.SetLevel(logrus.DebugLevel)",
      "330:   eh.Builder.Processors = []dag.Processor{",
      "331:    &dag.IngressProcessor{",
      "332:     EnableExternalNameService: true,",
      "333:     FieldLogger:               log.WithField(\"context\", \"IngressProcessor\"),",
      "334:    },",
      "335:    &dag.HTTPProxyProcessor{",
      "336:     EnableExternalNameService: true,",
      "337:    },",
      "338:    &dag.ExtensionServiceProcessor{",
      "339:     FieldLogger: log.WithField(\"context\", \"ExtensionServiceProcessor\"),",
      "340:    },",
      "341:    &dag.ListenerProcessor{},",
      "342:   }",
      "343:  }",
      "344: }",
      "",
      "---------------"
    ],
    "internal/featuretests/v3/headerpolicy_test.go||internal/featuretests/v3/headerpolicy_test.go": [
      "File: internal/featuretests/v3/headerpolicy_test.go -> internal/featuretests/v3/headerpolicy_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "30: )",
      "32: func TestHeaderPolicy_ReplaceHeader_HTTProxy(t *testing.T) {",
      "34:  defer done()",
      "36:  rh.OnAdd(fixture.NewService(\"svc1\").",
      "",
      "[Removed Lines]",
      "33:  rh, c, done := setup(t)",
      "",
      "[Added Lines]",
      "36:  rh, c, done := setup(t, enableExternalNameService(t))",
      "",
      "---------------"
    ],
    "pkg/config/parameters.go||pkg/config/parameters.go": [
      "File: pkg/config/parameters.go -> pkg/config/parameters.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "537:  DisableAllowChunkedLength bool `yaml:\"disableAllowChunkedLength,omitempty\"`",
      "540:  LeaderElection LeaderElectionParameters `yaml:\"leaderelection,omitempty\"`",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "542:  EnableExternalNameService bool `yaml:\"enableExternalNameService,omitempty\"`",
      "",
      "---------------"
    ],
    "test/e2e/httpproxy/018_external_name_test.go||test/e2e/httpproxy/018_external_name_test.go": [
      "File: test/e2e/httpproxy/018_external_name_test.go -> test/e2e/httpproxy/018_external_name_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "79:     },",
      "80:    },",
      "81:   }",
      "84:   res, ok := f.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
      "85:    Host:      p.Spec.VirtualHost.Fqdn,",
      "",
      "[Removed Lines]",
      "82:   f.CreateHTTPProxyAndWaitFor(p, httpProxyValid)",
      "",
      "[Added Lines]",
      "82:   proxy, ok := f.CreateHTTPProxyAndWaitFor(p, httpProxyValid)",
      "83:   if !ok {",
      "84:    t.Fatalf(\"The HTTPProxy did not become valid, here are the Valid condition's Errors: %s\", httpProxyErrors(proxy))",
      "85:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "146:     },",
      "147:    },",
      "148:   }",
      "151:   res, ok := f.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
      "152:    Host:      p.Spec.VirtualHost.Fqdn,",
      "",
      "[Removed Lines]",
      "149:   f.CreateHTTPProxyAndWaitFor(p, httpProxyValid)",
      "",
      "[Added Lines]",
      "152:   proxy, ok := f.CreateHTTPProxyAndWaitFor(p, httpProxyValid)",
      "153:   if !ok {",
      "154:    t.Fatalf(\"The HTTPProxy did not become valid, here are the Valid condition's Errors: %s\", httpProxyErrors(proxy))",
      "155:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "159: func stringPtr(s string) *string {",
      "160:  return &s",
      "161: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "169: func testExternalNameServiceLocalhostInvalid(namespace string) {",
      "170:  Specify(\"external name services with localhost are rejected\", func() {",
      "171:   t := f.T()",
      "173:   f.Fixtures.Echo.Deploy(namespace, \"ingress-conformance-echo\")",
      "175:   externalNameService := &corev1.Service{",
      "176:    ObjectMeta: metav1.ObjectMeta{",
      "177:     Namespace: namespace,",
      "178:     Name:      \"external-name-service-localhost\",",
      "179:    },",
      "180:    Spec: corev1.ServiceSpec{",
      "181:     Type: corev1.ServiceTypeExternalName,",
      "184:     ExternalName: \"localhost.localdomain\",",
      "185:     Ports: []corev1.ServicePort{",
      "186:      {",
      "187:       Name: \"http\",",
      "188:       Port: 80,",
      "189:      },",
      "190:     },",
      "191:    },",
      "192:   }",
      "193:   require.NoError(t, f.Client.Create(context.TODO(), externalNameService))",
      "195:   p := &contourv1.HTTPProxy{",
      "196:    ObjectMeta: metav1.ObjectMeta{",
      "197:     Namespace: namespace,",
      "198:     Name:      \"external-name-proxy\",",
      "199:    },",
      "200:    Spec: contourv1.HTTPProxySpec{",
      "201:     VirtualHost: &contourv1.VirtualHost{",
      "202:      Fqdn: \"externalnameservice.projectcontour.io\",",
      "203:     },",
      "204:     Routes: []contourv1.Route{",
      "205:      {",
      "206:       Services: []contourv1.Service{",
      "207:        {",
      "208:         Name: externalNameService.Name,",
      "209:         Port: 80,",
      "210:        },",
      "211:       },",
      "212:       RequestHeadersPolicy: &contourv1.HeadersPolicy{",
      "213:        Set: []contourv1.HeaderValue{",
      "214:         {",
      "215:          Name:  \"Host\",",
      "216:          Value: externalNameService.Spec.ExternalName,",
      "217:         },",
      "218:        },",
      "219:       },",
      "220:      },",
      "221:     },",
      "222:    },",
      "223:   }",
      "224:   _, ok := f.CreateHTTPProxyAndWaitFor(p, httpProxyValid)",
      "225:   require.Falsef(t, ok, \"ExternalName with hostname %s was accepted by Contour.\", externalNameService.Spec.ExternalName)",
      "226:  })",
      "227: }",
      "",
      "---------------"
    ],
    "test/e2e/httpproxy/httpproxy_test.go||test/e2e/httpproxy/httpproxy_test.go": [
      "File: test/e2e/httpproxy/httpproxy_test.go -> test/e2e/httpproxy/httpproxy_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "20:  \"fmt\"",
      "21:  \"testing\"",
      "23:  certmanagerv1 \"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1\"",
      "24:  certmanagermetav1 \"github.com/jetstack/cert-manager/pkg/apis/meta/v1\"",
      "25:  . \"github.com/onsi/ginkgo\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "23:  \"github.com/davecgh/go-spew/spew\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "215:  f.NamespacedTest(\"017-host-header-rewrite\", testHostHeaderRewrite)",
      "221:  f.NamespacedTest(\"019-local-rate-limiting-vhost\", testLocalRateLimitingVirtualHost)",
      "223:  f.NamespacedTest(\"019-local-rate-limiting-route\", testLocalRateLimitingRoute)",
      "",
      "[Removed Lines]",
      "217:  f.NamespacedTest(\"018-external-name-service-insecure\", testExternalNameServiceInsecure)",
      "219:  f.NamespacedTest(\"018-external-name-service-tls\", testExternalNameServiceTLS)",
      "",
      "[Added Lines]",
      "218:  f.NamespacedTest(\"018-external-name-service-insecure\", func(namespace string) {",
      "219:   Context(\"with ExternalName Services enabled\", func() {",
      "220:    BeforeEach(func() {",
      "221:     contourConfig.EnableExternalNameService = true",
      "222:    })",
      "223:    testExternalNameServiceInsecure(namespace)",
      "224:   })",
      "225:  })",
      "227:  f.NamespacedTest(\"018-external-name-service-tls\", func(namespace string) {",
      "228:   Context(\"with ExternalName Services enabled\", func() {",
      "229:    BeforeEach(func() {",
      "230:     contourConfig.EnableExternalNameService = true",
      "231:    })",
      "232:    testExternalNameServiceTLS(namespace)",
      "233:   })",
      "234:  })",
      "236:  f.NamespacedTest(\"018-external-name-service-localhost\", func(namespace string) {",
      "237:   Context(\"with ExternalName Services enabled\", func() {",
      "238:    BeforeEach(func() {",
      "239:     contourConfig.EnableExternalNameService = true",
      "240:    })",
      "241:    testExternalNameServiceLocalhostInvalid(namespace)",
      "242:   })",
      "243:  })",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "280: func httpProxyValid(proxy *contourv1.HTTPProxy) bool {",
      "282: }",
      "",
      "[Removed Lines]",
      "281:  return proxy != nil && proxy.Status.CurrentStatus == \"valid\"",
      "",
      "[Added Lines]",
      "305:  if proxy == nil {",
      "306:   return false",
      "307:  }",
      "309:  if len(proxy.Status.Conditions) == 0 {",
      "310:   return false",
      "311:  }",
      "313:  cond := proxy.Status.GetConditionFor(\"Valid\")",
      "314:  return cond.Status == \"True\"",
      "316: }",
      "320: func httpProxyErrors(proxy *contourv1.HTTPProxy) string {",
      "321:  cond := proxy.Status.GetConditionFor(\"Valid\")",
      "322:  errors := cond.Errors",
      "323:  if len(errors) > 0 {",
      "324:   return spew.Sdump(errors)",
      "325:  }",
      "327:  return \"\"",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "03fa0faf2dc4dd541370dc15ab8973ee5379c9d7",
      "candidate_info": {
        "commit_hash": "03fa0faf2dc4dd541370dc15ab8973ee5379c9d7",
        "repo": "projectcontour/contour",
        "commit_url": "https://github.com/projectcontour/contour/commit/03fa0faf2dc4dd541370dc15ab8973ee5379c9d7",
        "files": [
          "test/e2e/framework.go",
          "test/e2e/gateway/005_request_header_modifier_test.go",
          "test/e2e/httpproxy/016_dynamic_headers_test.go",
          "test/e2e/httpproxy/017_host_header_rewrite_test.go",
          "test/e2e/httpproxy/019_local_rate_limiting_test.go",
          "test/e2e/httpproxy/020_global_rate_limiting_test.go",
          "test/e2e/httpproxy/httpproxy_test.go"
        ],
        "message": "test/e2e: add HTTPProxy tests 016,017,019,020 (#3648)\n\nUpdates #3621.\n\nSigned-off-by: Steve Kriss <krisss@vmware.com>",
        "before_after_code_files": [
          "test/e2e/framework.go||test/e2e/framework.go",
          "test/e2e/gateway/005_request_header_modifier_test.go||test/e2e/gateway/005_request_header_modifier_test.go",
          "test/e2e/httpproxy/016_dynamic_headers_test.go||test/e2e/httpproxy/016_dynamic_headers_test.go",
          "test/e2e/httpproxy/017_host_header_rewrite_test.go||test/e2e/httpproxy/017_host_header_rewrite_test.go",
          "test/e2e/httpproxy/019_local_rate_limiting_test.go||test/e2e/httpproxy/019_local_rate_limiting_test.go",
          "test/e2e/httpproxy/020_global_rate_limiting_test.go||test/e2e/httpproxy/020_global_rate_limiting_test.go",
          "test/e2e/httpproxy/httpproxy_test.go||test/e2e/httpproxy/httpproxy_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/e2e/httpproxy/httpproxy_test.go||test/e2e/httpproxy/httpproxy_test.go"
          ],
          "candidate": [
            "test/e2e/httpproxy/httpproxy_test.go||test/e2e/httpproxy/httpproxy_test.go"
          ]
        }
      },
      "candidate_diff": {
        "test/e2e/framework.go||test/e2e/framework.go": [
          "File: test/e2e/framework.go -> test/e2e/framework.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:  \"net/http\"",
          "22:  \"os\"",
          "23:  \"strconv\"",
          "25:  \"time\"",
          "27:  certmanagerv1 \"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1\"",
          "",
          "[Removed Lines]",
          "24:  \"strings\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "257: }",
          "259: type EchoResponseBody struct {",
          "271: }",
          "",
          "[Removed Lines]",
          "260:  Path      string      `json:\"path\"`",
          "261:  Host      string      `json:\"host\"`",
          "262:  Headers   http.Header `json:\"headers\"`",
          "263:  Namespace string      `json:\"namespace\"`",
          "264:  Ingress   string      `json:\"ingress\"`",
          "265:  Service   string      `json:\"service\"`",
          "266:  Pod       string      `json:\"pod\"`",
          "267: }",
          "269: func (erb *EchoResponseBody) GetHeader(name string) string {",
          "270:  return strings.Join(erb.Headers[name], \",\")",
          "",
          "[Added Lines]",
          "259:  Path           string      `json:\"path\"`",
          "260:  Host           string      `json:\"host\"`",
          "261:  RequestHeaders http.Header `json:\"headers\"`",
          "262:  Namespace      string      `json:\"namespace\"`",
          "263:  Ingress        string      `json:\"ingress\"`",
          "264:  Service        string      `json:\"service\"`",
          "265:  Pod            string      `json:\"pod\"`",
          "",
          "---------------"
        ],
        "test/e2e/gateway/005_request_header_modifier_test.go||test/e2e/gateway/005_request_header_modifier_test.go": [
          "File: test/e2e/gateway/005_request_header_modifier_test.go -> test/e2e/gateway/005_request_header_modifier_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "114:  body := fx.GetEchoResponseBody(res.Body)",
          "115:  assert.Equal(t, \"echo-header-filter\", body.Service)",
          "121:  assert.False(t, found, \"Other-Header was found on the response\")",
          "",
          "[Removed Lines]",
          "117:  assert.Equal(t, \"Foo\", body.Headers.Get(\"My-Header\"))",
          "118:  assert.Equal(t, \"Bar\", body.Headers.Get(\"Replace-Header\"))",
          "120:  _, found := body.Headers[\"Other-Header\"]",
          "",
          "[Added Lines]",
          "117:  assert.Equal(t, \"Foo\", body.RequestHeaders.Get(\"My-Header\"))",
          "118:  assert.Equal(t, \"Bar\", body.RequestHeaders.Get(\"Replace-Header\"))",
          "120:  _, found := body.RequestHeaders[\"Other-Header\"]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "135:  body = fx.GetEchoResponseBody(res.Body)",
          "136:  assert.Equal(t, \"echo-header-nofilter\", body.Service)",
          "141:  assert.False(t, found, \"My-Header was found on the response\")",
          "142: }",
          "",
          "[Removed Lines]",
          "138:  assert.Equal(t, \"Exist\", body.Headers.Get(\"Other-Header\"))",
          "140:  _, found = body.Headers[\"My-Header\"]",
          "",
          "[Added Lines]",
          "138:  assert.Equal(t, \"Exist\", body.RequestHeaders.Get(\"Other-Header\"))",
          "140:  _, found = body.RequestHeaders[\"My-Header\"]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "230:  body := fx.GetEchoResponseBody(res.Body)",
          "231:  assert.Equal(t, \"echo-header-filter\", body.Service)",
          "237:  assert.False(t, found, \"Other-Header was found on the response\")",
          "",
          "[Removed Lines]",
          "233:  assert.Equal(t, \"Foo\", body.Headers.Get(\"My-Header\"))",
          "234:  assert.Equal(t, \"Bar\", body.Headers.Get(\"Replace-Header\"))",
          "236:  _, found := body.Headers[\"Other-Header\"]",
          "",
          "[Added Lines]",
          "233:  assert.Equal(t, \"Foo\", body.RequestHeaders.Get(\"My-Header\"))",
          "234:  assert.Equal(t, \"Bar\", body.RequestHeaders.Get(\"Replace-Header\"))",
          "236:  _, found := body.RequestHeaders[\"Other-Header\"]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "251:  body = fx.GetEchoResponseBody(res.Body)",
          "252:  assert.Equal(t, \"echo-header-nofilter\", body.Service)",
          "257:  assert.False(t, found, \"My-Header was found on the response\")",
          "258: }",
          "",
          "[Removed Lines]",
          "254:  assert.Equal(t, \"Exist\", body.Headers.Get(\"Other-Header\"))",
          "256:  _, found = body.Headers[\"My-Header\"]",
          "",
          "[Added Lines]",
          "254:  assert.Equal(t, \"Exist\", body.RequestHeaders.Get(\"Other-Header\"))",
          "256:  _, found = body.RequestHeaders[\"My-Header\"]",
          "",
          "---------------"
        ],
        "test/e2e/httpproxy/016_dynamic_headers_test.go||test/e2e/httpproxy/016_dynamic_headers_test.go": [
          "File: test/e2e/httpproxy/016_dynamic_headers_test.go -> test/e2e/httpproxy/016_dynamic_headers_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: package httpproxy",
          "18: import (",
          "19:  \"net/http\"",
          "20:  \"strings\"",
          "22:  contourv1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"",
          "23:  \"github.com/projectcontour/contour/test/e2e\"",
          "24:  \"github.com/stretchr/testify/assert\"",
          "25:  \"github.com/stretchr/testify/require\"",
          "26:  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
          "27: )",
          "29: func testDynamicHeaders(fx *e2e.Framework) {",
          "30:  t := fx.T()",
          "31:  namespace := \"016-dynamic-headers\"",
          "33:  fx.CreateNamespace(namespace)",
          "34:  defer fx.DeleteNamespace(namespace)",
          "36:  fx.Fixtures.Echo.Deploy(namespace, \"ingress-conformance-echo\")",
          "38:  p := &contourv1.HTTPProxy{",
          "39:   ObjectMeta: metav1.ObjectMeta{",
          "40:    Namespace: namespace,",
          "41:    Name:      \"dynamic-headers\",",
          "42:   },",
          "43:   Spec: contourv1.HTTPProxySpec{",
          "44:    VirtualHost: &contourv1.VirtualHost{",
          "45:     Fqdn: \"dynamicheaders.projectcontour.io\",",
          "46:    },",
          "47:    Routes: []contourv1.Route{",
          "48:     {",
          "49:      Services: []contourv1.Service{",
          "50:       {",
          "51:        Name:                  \"ingress-conformance-echo\",",
          "52:        Port:                  80,",
          "53:        RequestHeadersPolicy:  &contourv1.HeadersPolicy{},",
          "54:        ResponseHeadersPolicy: &contourv1.HeadersPolicy{},",
          "55:       },",
          "56:      },",
          "57:     },",
          "58:    },",
          "59:   },",
          "60:  }",
          "62:  requestHeaders := map[string]string{",
          "63:   \"Request-Header\":                  \"foo\",",
          "64:   \"X-App-Weight\":                    \"100%\",",
          "65:   \"X-Envoy-Hostname\":                \"%HOSTNAME%\",",
          "66:   \"X-Envoy-Unknown\":                 \"%UNKNOWN%\",",
          "67:   \"X-Envoy-Upstream-Remote-Address\": \"%UPSTREAM_REMOTE_ADDRESS%\",",
          "68:   \"X-Request-Host\":                  \"%REQ(Host)%\",",
          "69:   \"X-Request-Missing-Header\":        \"%REQ(Missing-Header)%ook\",",
          "70:   \"X-Host-Protocol\":                 \"%REQ(Host)% - %PROTOCOL%\",",
          "71:   \"X-Dynamic-Header-1\":              \"%DOWNSTREAM_REMOTE_ADDRESS%\",",
          "72:   \"X-Dynamic-Header-2\":              \"%DOWNSTREAM_REMOTE_ADDRESS_WITHOUT_PORT%\",",
          "73:   \"X-Dynamic-Header-3\":              \"%DOWNSTREAM_LOCAL_ADDRESS%\",",
          "74:   \"X-Dynamic-Header-4\":              \"%DOWNSTREAM_LOCAL_ADDRESS_WITHOUT_PORT%\",",
          "75:   \"X-Dynamic-Header-5\":              \"%DOWNSTREAM_LOCAL_PORT%\",",
          "76:   \"X-Dynamic-Header-6\":              \"%DOWNSTREAM_LOCAL_URI_SAN%\",",
          "77:   \"X-Dynamic-Header-7\":              \"%DOWNSTREAM_PEER_URI_SAN%\",",
          "78:   \"X-Dynamic-Header-8\":              \"%DOWNSTREAM_LOCAL_SUBJECT%\",",
          "79:   \"X-Dynamic-Header-9\":              \"%DOWNSTREAM_PEER_SUBJECT%\",",
          "80:   \"X-Dynamic-Header-10\":             \"%DOWNSTREAM_PEER_ISSUER%\",",
          "81:   \"X-Dynamic-Header-11\":             \"%DOWNSTREAM_TLS_SESSION_ID%\",",
          "82:   \"X-Dynamic-Header-12\":             \"%DOWNSTREAM_TLS_CIPHER%\",",
          "83:   \"X-Dynamic-Header-13\":             \"%DOWNSTREAM_TLS_VERSION%\",",
          "84:   \"X-Dynamic-Header-14\":             \"%DOWNSTREAM_PEER_FINGERPRINT_256%\",",
          "85:   \"X-Dynamic-Header-15\":             \"%DOWNSTREAM_PEER_FINGERPRINT_1%\",",
          "86:   \"X-Dynamic-Header-16\":             \"%DOWNSTREAM_PEER_SERIAL%\",",
          "87:   \"X-Dynamic-Header-17\":             \"%DOWNSTREAM_PEER_CERT%\",",
          "88:   \"X-Dynamic-Header-18\":             \"%DOWNSTREAM_PEER_CERT_V_START%\",",
          "89:   \"X-Dynamic-Header-19\":             \"%DOWNSTREAM_PEER_CERT_V_END%\",",
          "90:   \"X-Dynamic-Header-20\":             \"%HOSTNAME%\",",
          "91:   \"X-Dynamic-Header-21\":             \"%PROTOCOL%\",",
          "92:   \"X-Dynamic-Header-22\":             \"%UPSTREAM_REMOTE_ADDRESS%\",",
          "93:   \"X-Dynamic-Header-23\":             \"%RESPONSE_FLAGS%\",",
          "94:   \"X-Dynamic-Header-24\":             \"%RESPONSE_CODE_DETAILS%\",",
          "95:   \"X-Contour-Namespace\":             \"%CONTOUR_NAMESPACE%\",",
          "96:   \"X-Contour-Service\":               \"%CONTOUR_SERVICE_NAME%:%CONTOUR_SERVICE_PORT%\",",
          "97:  }",
          "98:  for k, v := range requestHeaders {",
          "99:   hv := contourv1.HeaderValue{",
          "100:    Name:  k,",
          "101:    Value: v,",
          "102:   }",
          "103:   p.Spec.Routes[0].Services[0].RequestHeadersPolicy.Set = append(p.Spec.Routes[0].Services[0].RequestHeadersPolicy.Set, hv)",
          "104:  }",
          "106:  responseHeaders := map[string]string{",
          "107:   \"Response-Header\":                 \"bar\",",
          "108:   \"X-App-Weight\":                    \"100%\",",
          "109:   \"X-Envoy-Hostname\":                \"%HOSTNAME%\",",
          "110:   \"X-Envoy-Unknown\":                 \"%UNKNOWN%\",",
          "111:   \"X-Envoy-Upstream-Remote-Address\": \"%UPSTREAM_REMOTE_ADDRESS%\",",
          "112:   \"X-Request-Host\":                  \"%REQ(Host)%\",",
          "113:   \"X-Request-Missing-Header\":        \"%REQ(Missing-Header)%ook\",",
          "114:   \"X-Host-Protocol\":                 \"%REQ(Host)% - %PROTOCOL%\",",
          "115:   \"X-Dynamic-Header-1\":              \"%DOWNSTREAM_REMOTE_ADDRESS%\",",
          "116:   \"X-Dynamic-Header-2\":              \"%DOWNSTREAM_REMOTE_ADDRESS_WITHOUT_PORT%\",",
          "117:   \"X-Dynamic-Header-3\":              \"%DOWNSTREAM_LOCAL_ADDRESS%\",",
          "118:   \"X-Dynamic-Header-4\":              \"%DOWNSTREAM_LOCAL_ADDRESS_WITHOUT_PORT%\",",
          "119:   \"X-Dynamic-Header-5\":              \"%DOWNSTREAM_LOCAL_PORT%\",",
          "120:   \"X-Dynamic-Header-6\":              \"%DOWNSTREAM_LOCAL_URI_SAN%\",",
          "121:   \"X-Dynamic-Header-7\":              \"%DOWNSTREAM_PEER_URI_SAN%\",",
          "122:   \"X-Dynamic-Header-8\":              \"%DOWNSTREAM_LOCAL_SUBJECT%\",",
          "123:   \"X-Dynamic-Header-9\":              \"%DOWNSTREAM_PEER_SUBJECT%\",",
          "124:   \"X-Dynamic-Header-10\":             \"%DOWNSTREAM_PEER_ISSUER%\",",
          "125:   \"X-Dynamic-Header-11\":             \"%DOWNSTREAM_TLS_SESSION_ID%\",",
          "126:   \"X-Dynamic-Header-12\":             \"%DOWNSTREAM_TLS_CIPHER%\",",
          "127:   \"X-Dynamic-Header-13\":             \"%DOWNSTREAM_TLS_VERSION%\",",
          "128:   \"X-Dynamic-Header-14\":             \"%DOWNSTREAM_PEER_FINGERPRINT_256%\",",
          "129:   \"X-Dynamic-Header-15\":             \"%DOWNSTREAM_PEER_FINGERPRINT_1%\",",
          "130:   \"X-Dynamic-Header-16\":             \"%DOWNSTREAM_PEER_SERIAL%\",",
          "131:   \"X-Dynamic-Header-17\":             \"%DOWNSTREAM_PEER_CERT%\",",
          "132:   \"X-Dynamic-Header-18\":             \"%DOWNSTREAM_PEER_CERT_V_START%\",",
          "133:   \"X-Dynamic-Header-19\":             \"%DOWNSTREAM_PEER_CERT_V_END%\",",
          "134:   \"X-Dynamic-Header-20\":             \"%HOSTNAME%\",",
          "135:   \"X-Dynamic-Header-21\":             \"%PROTOCOL%\",",
          "136:   \"X-Dynamic-Header-22\":             \"%UPSTREAM_REMOTE_ADDRESS%\",",
          "137:   \"X-Dynamic-Header-23\":             \"%RESPONSE_FLAGS%\",",
          "138:   \"X-Dynamic-Header-24\":             \"%RESPONSE_CODE_DETAILS%\",",
          "139:  }",
          "140:  for k, v := range responseHeaders {",
          "141:   hv := contourv1.HeaderValue{",
          "142:    Name:  k,",
          "143:    Value: v,",
          "144:   }",
          "145:   p.Spec.Routes[0].Services[0].ResponseHeadersPolicy.Set = append(p.Spec.Routes[0].Services[0].ResponseHeadersPolicy.Set, hv)",
          "146:  }",
          "148:  fx.CreateHTTPProxyAndWaitFor(p, httpProxyValid)",
          "150:  res, ok := fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "151:   Host:      p.Spec.VirtualHost.Fqdn,",
          "152:   Condition: e2e.HasStatusCode(200),",
          "153:  })",
          "154:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "156:  body := fx.GetEchoResponseBody(res.Body)",
          "160:  headerSets := map[string]http.Header{",
          "161:   \"request\":  body.RequestHeaders,",
          "162:   \"response\": res.Headers,",
          "163:  }",
          "164:  for name, headers := range headerSets {",
          "165:   t.Logf(\"Checking %s headers\", name)",
          "168:   assert.Equal(t, \"100%\", headers.Get(\"X-App-Weight\"))",
          "171:   assert.True(t, strings.HasPrefix(headers.Get(\"X-Envoy-Hostname\"), \"envoy-\"), \"X-Envoy-Hostname does not start with 'envoy-'\")",
          "174:   assert.Equal(t, \"%UNKNOWN%\", headers.Get(\"X-Envoy-Unknown\"))",
          "177:   assert.Equal(t, body.Host, headers.Get(\"X-Request-Host\"))",
          "180:   assert.Equal(t, \"ook\", headers.Get(\"X-Request-Missing-Header\"))",
          "183:   assert.Equal(t, body.Host+\" - HTTP/1.1\", headers.Get(\"X-Host-Protocol\"))",
          "184:  }",
          "187:  assert.Equal(t, \"ingress-conformance-echo:80\", body.RequestHeaders.Get(\"X-Contour-Service\"))",
          "188: }",
          "",
          "---------------"
        ],
        "test/e2e/httpproxy/017_host_header_rewrite_test.go||test/e2e/httpproxy/017_host_header_rewrite_test.go": [
          "File: test/e2e/httpproxy/017_host_header_rewrite_test.go -> test/e2e/httpproxy/017_host_header_rewrite_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: package httpproxy",
          "18: import (",
          "19:  contourv1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"",
          "20:  \"github.com/projectcontour/contour/test/e2e\"",
          "21:  \"github.com/stretchr/testify/assert\"",
          "22:  \"github.com/stretchr/testify/require\"",
          "23:  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
          "24: )",
          "26: func testHostHeaderRewrite(fx *e2e.Framework) {",
          "27:  t := fx.T()",
          "28:  namespace := \"017-host-header-rewrite\"",
          "30:  fx.CreateNamespace(namespace)",
          "31:  defer fx.DeleteNamespace(namespace)",
          "33:  fx.Fixtures.Echo.Deploy(namespace, \"ingress-conformance-echo\")",
          "35:  p := &contourv1.HTTPProxy{",
          "36:   ObjectMeta: metav1.ObjectMeta{",
          "37:    Namespace: namespace,",
          "38:    Name:      \"host-header-rewrite\",",
          "39:   },",
          "40:   Spec: contourv1.HTTPProxySpec{",
          "41:    VirtualHost: &contourv1.VirtualHost{",
          "42:     Fqdn: \"hostheaderrewrite.projectcontour.io\",",
          "43:    },",
          "44:    Routes: []contourv1.Route{",
          "45:     {",
          "46:      Services: []contourv1.Service{",
          "47:       {",
          "48:        Name: \"ingress-conformance-echo\",",
          "49:        Port: 80,",
          "50:       },",
          "51:      },",
          "52:      RequestHeadersPolicy: &contourv1.HeadersPolicy{",
          "53:       Set: []contourv1.HeaderValue{",
          "54:        {",
          "55:         Name:  \"Host\",",
          "56:         Value: \"rewritten.com\",",
          "57:        },",
          "58:       },",
          "59:      },",
          "60:     },",
          "61:    },",
          "62:   },",
          "63:  }",
          "64:  fx.CreateHTTPProxyAndWaitFor(p, httpProxyValid)",
          "66:  res, ok := fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "67:   Host:      p.Spec.VirtualHost.Fqdn,",
          "68:   Condition: e2e.HasStatusCode(200),",
          "69:  })",
          "70:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "72:  assert.Equal(t, \"rewritten.com\", fx.GetEchoResponseBody(res.Body).Host)",
          "73: }",
          "",
          "---------------"
        ],
        "test/e2e/httpproxy/019_local_rate_limiting_test.go||test/e2e/httpproxy/019_local_rate_limiting_test.go": [
          "File: test/e2e/httpproxy/019_local_rate_limiting_test.go -> test/e2e/httpproxy/019_local_rate_limiting_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: package httpproxy",
          "18: import (",
          "19:  \"context\"",
          "21:  contourv1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"",
          "22:  \"github.com/projectcontour/contour/test/e2e\"",
          "23:  \"github.com/stretchr/testify/require\"",
          "24:  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
          "25: )",
          "27: func testLocalRateLimitingVirtualHost(fx *e2e.Framework) {",
          "28:  t := fx.T()",
          "29:  namespace := \"019-local-rate-limiting-vhost\"",
          "31:  fx.CreateNamespace(namespace)",
          "32:  defer fx.DeleteNamespace(namespace)",
          "34:  fx.Fixtures.Echo.Deploy(namespace, \"echo\")",
          "36:  p := &contourv1.HTTPProxy{",
          "37:   ObjectMeta: metav1.ObjectMeta{",
          "38:    Namespace: namespace,",
          "39:    Name:      \"vhostlocalratelimit\",",
          "40:   },",
          "41:   Spec: contourv1.HTTPProxySpec{",
          "42:    VirtualHost: &contourv1.VirtualHost{",
          "43:     Fqdn: \"vhostlocalratelimit.projectcontour.io\",",
          "44:    },",
          "45:    Routes: []contourv1.Route{",
          "46:     {",
          "47:      Services: []contourv1.Service{",
          "48:       {",
          "49:        Name: \"echo\",",
          "50:        Port: 80,",
          "51:       },",
          "52:      },",
          "53:     },",
          "54:    },",
          "55:   },",
          "56:  }",
          "57:  p, _ = fx.CreateHTTPProxyAndWaitFor(p, httpProxyValid)",
          "61:  res, ok := fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "62:   Host:      p.Spec.VirtualHost.Fqdn,",
          "63:   Condition: e2e.HasStatusCode(200),",
          "64:  })",
          "65:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "68:  p.Spec.VirtualHost.RateLimitPolicy = &contourv1.RateLimitPolicy{",
          "69:   Local: &contourv1.LocalRateLimitPolicy{",
          "70:    Requests: 1,",
          "71:    Unit:     \"hour\",",
          "72:   },",
          "73:  }",
          "74:  require.NoError(t, fx.Client.Update(context.TODO(), p))",
          "78:  res, ok = fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "79:   Host:      p.Spec.VirtualHost.Fqdn,",
          "80:   Condition: e2e.HasStatusCode(200),",
          "81:  })",
          "82:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "86:  res, ok = fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "87:   Host:      p.Spec.VirtualHost.Fqdn,",
          "88:   Condition: e2e.HasStatusCode(429),",
          "89:  })",
          "90:  require.Truef(t, ok, \"expected 429 response code, got %d\", res.StatusCode)",
          "91: }",
          "93: func testLocalRateLimitingRoute(fx *e2e.Framework) {",
          "94:  t := fx.T()",
          "95:  namespace := \"019-local-rate-limiting-route\"",
          "97:  fx.CreateNamespace(namespace)",
          "98:  defer fx.DeleteNamespace(namespace)",
          "100:  fx.Fixtures.Echo.Deploy(namespace, \"echo\")",
          "102:  p := &contourv1.HTTPProxy{",
          "103:   ObjectMeta: metav1.ObjectMeta{",
          "104:    Namespace: namespace,",
          "105:    Name:      \"routelocalratelimit\",",
          "106:   },",
          "107:   Spec: contourv1.HTTPProxySpec{",
          "108:    VirtualHost: &contourv1.VirtualHost{",
          "109:     Fqdn: \"routelocalratelimit.projectcontour.io\",",
          "110:    },",
          "111:    Routes: []contourv1.Route{",
          "112:     {",
          "113:      Services: []contourv1.Service{",
          "114:       {",
          "115:        Name: \"echo\",",
          "116:        Port: 80,",
          "117:       },",
          "118:      },",
          "119:     },",
          "120:     {",
          "121:      Services: []contourv1.Service{",
          "122:       {",
          "123:        Name: \"echo\",",
          "124:        Port: 80,",
          "125:       },",
          "126:      },",
          "127:      Conditions: []contourv1.MatchCondition{",
          "128:       {",
          "129:        Prefix: \"/unlimited\",",
          "130:       },",
          "131:      },",
          "132:     },",
          "133:    },",
          "134:   },",
          "135:  }",
          "136:  p, _ = fx.CreateHTTPProxyAndWaitFor(p, httpProxyValid)",
          "140:  res, ok := fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "141:   Host:      p.Spec.VirtualHost.Fqdn,",
          "142:   Condition: e2e.HasStatusCode(200),",
          "143:  })",
          "144:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "147:  p.Spec.Routes[0].RateLimitPolicy = &contourv1.RateLimitPolicy{",
          "148:   Local: &contourv1.LocalRateLimitPolicy{",
          "149:    Requests: 1,",
          "150:    Unit:     \"hour\",",
          "151:   },",
          "152:  }",
          "153:  require.NoError(t, fx.Client.Update(context.TODO(), p))",
          "157:  res, ok = fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "158:   Host:      p.Spec.VirtualHost.Fqdn,",
          "159:   Condition: e2e.HasStatusCode(200),",
          "160:  })",
          "161:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "165:  res, ok = fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "166:   Host:      p.Spec.VirtualHost.Fqdn,",
          "167:   Condition: e2e.HasStatusCode(429),",
          "168:  })",
          "169:  require.Truef(t, ok, \"expected 429 response code, got %d\", res.StatusCode)",
          "173:  res, ok = fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "174:   Host:      p.Spec.VirtualHost.Fqdn,",
          "175:   Path:      \"/unlimited\",",
          "176:   Condition: e2e.HasStatusCode(200),",
          "177:  })",
          "178:  require.Truef(t, ok, \"expected 200 response code for non-rate-limited route, got %d\", res.StatusCode)",
          "179: }",
          "",
          "---------------"
        ],
        "test/e2e/httpproxy/020_global_rate_limiting_test.go||test/e2e/httpproxy/020_global_rate_limiting_test.go": [
          "File: test/e2e/httpproxy/020_global_rate_limiting_test.go -> test/e2e/httpproxy/020_global_rate_limiting_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: package httpproxy",
          "18: import (",
          "19:  \"context\"",
          "21:  contourv1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"",
          "22:  \"github.com/projectcontour/contour/test/e2e\"",
          "23:  \"github.com/stretchr/testify/require\"",
          "24:  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
          "25: )",
          "27: func testGlobalRateLimitingVirtualHostNonTLS(fx *e2e.Framework) {",
          "28:  t := fx.T()",
          "29:  namespace := \"020-global-rate-limiting-vhost-non-tls\"",
          "31:  fx.CreateNamespace(namespace)",
          "32:  defer fx.DeleteNamespace(namespace)",
          "34:  fx.Fixtures.Echo.Deploy(namespace, \"echo\")",
          "36:  p := &contourv1.HTTPProxy{",
          "37:   ObjectMeta: metav1.ObjectMeta{",
          "38:    Namespace: namespace,",
          "39:    Name:      \"globalratelimitvhostnontls\",",
          "40:   },",
          "41:   Spec: contourv1.HTTPProxySpec{",
          "42:    VirtualHost: &contourv1.VirtualHost{",
          "43:     Fqdn: \"globalratelimitvhostnontls.projectcontour.io\",",
          "44:    },",
          "45:    Routes: []contourv1.Route{",
          "46:     {",
          "47:      Services: []contourv1.Service{",
          "48:       {",
          "49:        Name: \"echo\",",
          "50:        Port: 80,",
          "51:       },",
          "52:      },",
          "53:     },",
          "54:    },",
          "55:   },",
          "56:  }",
          "57:  p, _ = fx.CreateHTTPProxyAndWaitFor(p, httpProxyValid)",
          "61:  res, ok := fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "62:   Host:      p.Spec.VirtualHost.Fqdn,",
          "63:   Condition: e2e.HasStatusCode(200),",
          "64:  })",
          "65:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "68:  p.Spec.VirtualHost.RateLimitPolicy = &contourv1.RateLimitPolicy{",
          "69:   Global: &contourv1.GlobalRateLimitPolicy{",
          "70:    Descriptors: []contourv1.RateLimitDescriptor{",
          "71:     {",
          "72:      Entries: []contourv1.RateLimitDescriptorEntry{",
          "73:       {",
          "74:        GenericKey: &contourv1.GenericKeyDescriptor{",
          "75:         Value: \"vhostlimit\",",
          "76:        },",
          "77:       },",
          "78:      },",
          "79:     },",
          "80:    },",
          "81:   },",
          "82:  }",
          "83:  require.NoError(t, fx.Client.Update(context.TODO(), p))",
          "87:  res, ok = fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "88:   Host:      p.Spec.VirtualHost.Fqdn,",
          "89:   Condition: e2e.HasStatusCode(200),",
          "90:  })",
          "91:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "95:  res, ok = fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "96:   Host:      p.Spec.VirtualHost.Fqdn,",
          "97:   Condition: e2e.HasStatusCode(429),",
          "98:  })",
          "99:  require.Truef(t, ok, \"expected 429 response code, got %d\", res.StatusCode)",
          "100: }",
          "102: func testGlobalRateLimitingRouteNonTLS(fx *e2e.Framework) {",
          "103:  t := fx.T()",
          "104:  namespace := \"020-global-rate-limiting-route-non-tls\"",
          "106:  fx.CreateNamespace(namespace)",
          "107:  defer fx.DeleteNamespace(namespace)",
          "109:  fx.Fixtures.Echo.Deploy(namespace, \"echo\")",
          "111:  p := &contourv1.HTTPProxy{",
          "112:   ObjectMeta: metav1.ObjectMeta{",
          "113:    Namespace: namespace,",
          "114:    Name:      \"globalratelimitroutenontls\",",
          "115:   },",
          "116:   Spec: contourv1.HTTPProxySpec{",
          "117:    VirtualHost: &contourv1.VirtualHost{",
          "118:     Fqdn: \"globalratelimitroutenontls.projectcontour.io\",",
          "119:    },",
          "120:    Routes: []contourv1.Route{",
          "121:     {",
          "122:      Services: []contourv1.Service{",
          "123:       {",
          "124:        Name: \"echo\",",
          "125:        Port: 80,",
          "126:       },",
          "127:      },",
          "128:     },",
          "129:     {",
          "130:      Services: []contourv1.Service{",
          "131:       {",
          "132:        Name: \"echo\",",
          "133:        Port: 80,",
          "134:       },",
          "135:      },",
          "136:      Conditions: []contourv1.MatchCondition{",
          "137:       {",
          "138:        Prefix: \"/unlimited\",",
          "139:       },",
          "140:      },",
          "141:     },",
          "142:    },",
          "143:   },",
          "144:  }",
          "145:  p, _ = fx.CreateHTTPProxyAndWaitFor(p, httpProxyValid)",
          "149:  res, ok := fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "150:   Host:      p.Spec.VirtualHost.Fqdn,",
          "151:   Condition: e2e.HasStatusCode(200),",
          "152:  })",
          "153:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "156:  p.Spec.Routes[0].RateLimitPolicy = &contourv1.RateLimitPolicy{",
          "157:   Global: &contourv1.GlobalRateLimitPolicy{",
          "158:    Descriptors: []contourv1.RateLimitDescriptor{",
          "159:     {",
          "160:      Entries: []contourv1.RateLimitDescriptorEntry{",
          "161:       {",
          "162:        GenericKey: &contourv1.GenericKeyDescriptor{",
          "163:         Key:   \"route_limit_key\",",
          "164:         Value: \"routelimit\",",
          "165:        },",
          "166:       },",
          "167:      },",
          "168:     },",
          "169:    },",
          "170:   },",
          "171:  }",
          "172:  require.NoError(t, fx.Client.Update(context.TODO(), p))",
          "176:  res, ok = fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "177:   Host:      p.Spec.VirtualHost.Fqdn,",
          "178:   Condition: e2e.HasStatusCode(200),",
          "179:  })",
          "180:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "184:  res, ok = fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "185:   Host:      p.Spec.VirtualHost.Fqdn,",
          "186:   Condition: e2e.HasStatusCode(429),",
          "187:  })",
          "188:  require.Truef(t, ok, \"expected 429 response code, got %d\", res.StatusCode)",
          "192:  res, ok = fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "193:   Host:      p.Spec.VirtualHost.Fqdn,",
          "194:   Path:      \"/unlimited\",",
          "195:   Condition: e2e.HasStatusCode(200),",
          "196:  })",
          "197:  require.Truef(t, ok, \"expected 200 response code for non-rate-limited route, got %d\", res.StatusCode)",
          "198: }",
          "200: func testGlobalRateLimitingVirtualHostTLS(fx *e2e.Framework) {",
          "201:  t := fx.T()",
          "202:  namespace := \"020-global-rate-limiting-vhost-tls\"",
          "204:  fx.CreateNamespace(namespace)",
          "205:  defer fx.DeleteNamespace(namespace)",
          "207:  fx.Fixtures.Echo.Deploy(namespace, \"echo\")",
          "208:  fx.CreateSelfSignedCert(namespace, \"echo-cert\", \"echo\", \"globalratelimitvhosttls.projectcontour.io\")",
          "210:  p := &contourv1.HTTPProxy{",
          "211:   ObjectMeta: metav1.ObjectMeta{",
          "212:    Namespace: namespace,",
          "213:    Name:      \"globalratelimitvhosttls\",",
          "214:   },",
          "215:   Spec: contourv1.HTTPProxySpec{",
          "216:    VirtualHost: &contourv1.VirtualHost{",
          "217:     Fqdn: \"globalratelimitvhosttls.projectcontour.io\",",
          "218:     TLS: &contourv1.TLS{",
          "219:      SecretName: \"echo\",",
          "220:     },",
          "221:    },",
          "222:    Routes: []contourv1.Route{",
          "223:     {",
          "224:      Services: []contourv1.Service{",
          "225:       {",
          "226:        Name: \"echo\",",
          "227:        Port: 80,",
          "228:       },",
          "229:      },",
          "230:     },",
          "231:    },",
          "232:   },",
          "233:  }",
          "234:  p, _ = fx.CreateHTTPProxyAndWaitFor(p, httpProxyValid)",
          "238:  res, ok := fx.HTTP.SecureRequestUntil(&e2e.HTTPSRequestOpts{",
          "239:   Host:      p.Spec.VirtualHost.Fqdn,",
          "240:   Condition: e2e.HasStatusCode(200),",
          "241:  })",
          "242:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "245:  p.Spec.VirtualHost.RateLimitPolicy = &contourv1.RateLimitPolicy{",
          "246:   Global: &contourv1.GlobalRateLimitPolicy{",
          "247:    Descriptors: []contourv1.RateLimitDescriptor{",
          "248:     {",
          "249:      Entries: []contourv1.RateLimitDescriptorEntry{",
          "250:       {",
          "251:        GenericKey: &contourv1.GenericKeyDescriptor{",
          "252:         Value: \"tlsvhostlimit\",",
          "253:        },",
          "254:       },",
          "255:      },",
          "256:     },",
          "257:    },",
          "258:   },",
          "259:  }",
          "260:  require.NoError(t, fx.Client.Update(context.TODO(), p))",
          "264:  res, ok = fx.HTTP.SecureRequestUntil(&e2e.HTTPSRequestOpts{",
          "265:   Host:      p.Spec.VirtualHost.Fqdn,",
          "266:   Condition: e2e.HasStatusCode(200),",
          "267:  })",
          "268:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "272:  res, ok = fx.HTTP.SecureRequestUntil(&e2e.HTTPSRequestOpts{",
          "273:   Host:      p.Spec.VirtualHost.Fqdn,",
          "274:   Condition: e2e.HasStatusCode(429),",
          "275:  })",
          "276:  require.Truef(t, ok, \"expected 429 response code, got %d\", res.StatusCode)",
          "277: }",
          "279: func testGlobalRateLimitingRouteTLS(fx *e2e.Framework) {",
          "280:  t := fx.T()",
          "281:  namespace := \"020-global-rate-limiting-route-tls\"",
          "283:  fx.CreateNamespace(namespace)",
          "284:  defer fx.DeleteNamespace(namespace)",
          "286:  fx.Fixtures.Echo.Deploy(namespace, \"echo\")",
          "287:  fx.CreateSelfSignedCert(namespace, \"echo-cert\", \"echo\", \"globalratelimitroutetls.projectcontour.io\")",
          "289:  p := &contourv1.HTTPProxy{",
          "290:   ObjectMeta: metav1.ObjectMeta{",
          "291:    Namespace: namespace,",
          "292:    Name:      \"globalratelimitroutetls\",",
          "293:   },",
          "294:   Spec: contourv1.HTTPProxySpec{",
          "295:    VirtualHost: &contourv1.VirtualHost{",
          "296:     Fqdn: \"globalratelimitroutetls.projectcontour.io\",",
          "297:     TLS: &contourv1.TLS{",
          "298:      SecretName: \"echo\",",
          "299:     },",
          "300:    },",
          "301:    Routes: []contourv1.Route{",
          "302:     {",
          "303:      Services: []contourv1.Service{",
          "304:       {",
          "305:        Name: \"echo\",",
          "306:        Port: 80,",
          "307:       },",
          "308:      },",
          "309:     },",
          "310:     {",
          "311:      Services: []contourv1.Service{",
          "312:       {",
          "313:        Name: \"echo\",",
          "314:        Port: 80,",
          "315:       },",
          "316:      },",
          "317:      Conditions: []contourv1.MatchCondition{",
          "318:       {",
          "319:        Prefix: \"/unlimited\",",
          "320:       },",
          "321:      },",
          "322:     },",
          "323:    },",
          "324:   },",
          "325:  }",
          "326:  p, _ = fx.CreateHTTPProxyAndWaitFor(p, httpProxyValid)",
          "330:  res, ok := fx.HTTP.SecureRequestUntil(&e2e.HTTPSRequestOpts{",
          "331:   Host:      p.Spec.VirtualHost.Fqdn,",
          "332:   Condition: e2e.HasStatusCode(200),",
          "333:  })",
          "334:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "337:  p.Spec.Routes[0].RateLimitPolicy = &contourv1.RateLimitPolicy{",
          "338:   Global: &contourv1.GlobalRateLimitPolicy{",
          "339:    Descriptors: []contourv1.RateLimitDescriptor{",
          "340:     {",
          "341:      Entries: []contourv1.RateLimitDescriptorEntry{",
          "342:       {",
          "343:        GenericKey: &contourv1.GenericKeyDescriptor{",
          "344:         Value: \"tlsroutelimit\",",
          "345:        },",
          "346:       },",
          "347:      },",
          "348:     },",
          "349:    },",
          "350:   },",
          "351:  }",
          "352:  require.NoError(t, fx.Client.Update(context.TODO(), p))",
          "356:  res, ok = fx.HTTP.SecureRequestUntil(&e2e.HTTPSRequestOpts{",
          "357:   Host:      p.Spec.VirtualHost.Fqdn,",
          "358:   Condition: e2e.HasStatusCode(200),",
          "359:  })",
          "360:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "364:  res, ok = fx.HTTP.SecureRequestUntil(&e2e.HTTPSRequestOpts{",
          "365:   Host:      p.Spec.VirtualHost.Fqdn,",
          "366:   Condition: e2e.HasStatusCode(429),",
          "367:  })",
          "368:  require.Truef(t, ok, \"expected 429 response code, got %d\", res.StatusCode)",
          "372:  res, ok = fx.HTTP.SecureRequestUntil(&e2e.HTTPSRequestOpts{",
          "373:   Host:      p.Spec.VirtualHost.Fqdn,",
          "374:   Path:      \"/unlimited\",",
          "375:   Condition: e2e.HasStatusCode(200),",
          "376:  })",
          "377:  require.Truef(t, ok, \"expected 200 response code for non-rate-limited route, got %d\", res.StatusCode)",
          "378: }",
          "",
          "---------------"
        ],
        "test/e2e/httpproxy/httpproxy_test.go||test/e2e/httpproxy/httpproxy_test.go": [
          "File: test/e2e/httpproxy/httpproxy_test.go -> test/e2e/httpproxy/httpproxy_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:  It(\"012-https-fallback-certificate\", func() {",
          "62:   testHTTPSFallbackCertificate(f)",
          "63:  })",
          "64: })",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64:  It(\"016-dynamic-headers\", func() {",
          "65:   testDynamicHeaders(f)",
          "66:  })",
          "67:  It(\"017-host-header-rewrite\", func() {",
          "68:   testHostHeaderRewrite(f)",
          "69:  })",
          "70:  It(\"019-local-rate-limiting-vhost\", func() {",
          "71:   testLocalRateLimitingVirtualHost(f)",
          "72:  })",
          "73:  It(\"019-local-rate-limiting-route\", func() {",
          "74:   testLocalRateLimitingRoute(f)",
          "75:  })",
          "76:  It(\"020-global-rate-limiting-vhost-non-tls\", func() {",
          "77:   testGlobalRateLimitingVirtualHostNonTLS(f)",
          "78:  })",
          "79:  It(\"020-global-rate-limiting-route-non-tls\", func() {",
          "80:   testGlobalRateLimitingRouteNonTLS(f)",
          "81:  })",
          "82:  It(\"020-global-rate-limiting-vhost-tls\", func() {",
          "83:   testGlobalRateLimitingVirtualHostTLS(f)",
          "84:  })",
          "85:  It(\"020-global-rate-limiting-route-tls\", func() {",
          "86:   testGlobalRateLimitingRouteTLS(f)",
          "87:  })",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "93d8f101c53f8fb42b751c5d0939fa14234ab122",
      "candidate_info": {
        "commit_hash": "93d8f101c53f8fb42b751c5d0939fa14234ab122",
        "repo": "projectcontour/contour",
        "commit_url": "https://github.com/projectcontour/contour/commit/93d8f101c53f8fb42b751c5d0939fa14234ab122",
        "files": [
          "test/e2e/certs.go",
          "test/e2e/fixtures.go",
          "test/e2e/framework.go",
          "test/e2e/gateway/gateway_test.go",
          "test/e2e/http.go",
          "test/e2e/httpproxy/004_https_sni_enforcement_test.go",
          "test/e2e/httpproxy/007_client_cert_auth_test.go",
          "test/e2e/httpproxy/008_tcproute_https_termination_test.go",
          "test/e2e/httpproxy/009_https_misdirected_request_test.go",
          "test/e2e/httpproxy/012_https_fallback_certificate_test.go",
          "test/e2e/httpproxy/014_external_auth_test.go",
          "test/e2e/httpproxy/018_external_name_test.go",
          "test/e2e/httpproxy/020_global_rate_limiting_test.go",
          "test/e2e/httpproxy/httpproxy_test.go",
          "test/e2e/ingress/001_tls_wildcard_host_test.go",
          "test/e2e/ingress/ingress_test.go"
        ],
        "message": "test/e2e: add HTTPProxy 007,018 and Ingress 001 tests (#3665)\n\n* test/e2e: extract Certs helper type\n\nSigned-off-by: Steve Kriss <krisss@vmware.com>\n\n* test/e2e: add HTTPProxy 007,018 and Ingress 001 tests\n\nUpdates #3621.\n\nSigned-off-by: Steve Kriss <krisss@vmware.com>",
        "before_after_code_files": [
          "test/e2e/certs.go||test/e2e/certs.go",
          "test/e2e/fixtures.go||test/e2e/fixtures.go",
          "test/e2e/framework.go||test/e2e/framework.go",
          "test/e2e/gateway/gateway_test.go||test/e2e/gateway/gateway_test.go",
          "test/e2e/http.go||test/e2e/http.go",
          "test/e2e/httpproxy/004_https_sni_enforcement_test.go||test/e2e/httpproxy/004_https_sni_enforcement_test.go",
          "test/e2e/httpproxy/007_client_cert_auth_test.go||test/e2e/httpproxy/007_client_cert_auth_test.go",
          "test/e2e/httpproxy/008_tcproute_https_termination_test.go||test/e2e/httpproxy/008_tcproute_https_termination_test.go",
          "test/e2e/httpproxy/009_https_misdirected_request_test.go||test/e2e/httpproxy/009_https_misdirected_request_test.go",
          "test/e2e/httpproxy/012_https_fallback_certificate_test.go||test/e2e/httpproxy/012_https_fallback_certificate_test.go",
          "test/e2e/httpproxy/014_external_auth_test.go||test/e2e/httpproxy/014_external_auth_test.go",
          "test/e2e/httpproxy/018_external_name_test.go||test/e2e/httpproxy/018_external_name_test.go",
          "test/e2e/httpproxy/020_global_rate_limiting_test.go||test/e2e/httpproxy/020_global_rate_limiting_test.go",
          "test/e2e/httpproxy/httpproxy_test.go||test/e2e/httpproxy/httpproxy_test.go",
          "test/e2e/ingress/001_tls_wildcard_host_test.go||test/e2e/ingress/001_tls_wildcard_host_test.go",
          "test/e2e/ingress/ingress_test.go||test/e2e/ingress/ingress_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "test/e2e/httpproxy/018_external_name_test.go||test/e2e/httpproxy/018_external_name_test.go",
            "test/e2e/httpproxy/httpproxy_test.go||test/e2e/httpproxy/httpproxy_test.go"
          ],
          "candidate": [
            "test/e2e/httpproxy/018_external_name_test.go||test/e2e/httpproxy/018_external_name_test.go",
            "test/e2e/httpproxy/httpproxy_test.go||test/e2e/httpproxy/httpproxy_test.go"
          ]
        }
      },
      "candidate_diff": {
        "test/e2e/certs.go||test/e2e/certs.go": [
          "File: test/e2e/certs.go -> test/e2e/certs.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: package e2e",
          "18: import (",
          "19:  \"context\"",
          "20:  \"crypto/tls\"",
          "22:  certmanagerv1 \"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1\"",
          "23:  certmanagermetav1 \"github.com/jetstack/cert-manager/pkg/apis/meta/v1\"",
          "24:  \"github.com/onsi/ginkgo\"",
          "25:  \"github.com/stretchr/testify/require\"",
          "26:  corev1 \"k8s.io/api/core/v1\"",
          "27:  \"k8s.io/apimachinery/pkg/api/errors\"",
          "28:  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
          "29:  \"sigs.k8s.io/controller-runtime/pkg/client\"",
          "30: )",
          "34: type Certs struct {",
          "35:  client client.Client",
          "36:  t      ginkgo.GinkgoTInterface",
          "37: }",
          "41: func (c *Certs) CreateSelfSignedCert(ns, name, secretName, dnsName string) func() {",
          "42:  issuer := &certmanagerv1.Issuer{",
          "43:   ObjectMeta: metav1.ObjectMeta{",
          "44:    Namespace: ns,",
          "45:    Name:      \"selfsigned\",",
          "46:   },",
          "47:   Spec: certmanagerv1.IssuerSpec{",
          "48:    IssuerConfig: certmanagerv1.IssuerConfig{",
          "49:     SelfSigned: &certmanagerv1.SelfSignedIssuer{},",
          "50:    },",
          "51:   },",
          "52:  }",
          "54:  if err := c.client.Create(context.TODO(), issuer); err != nil && !errors.IsAlreadyExists(err) {",
          "55:   require.FailNow(c.t, \"error creating Issuer: %v\", err)",
          "56:  }",
          "58:  cert := &certmanagerv1.Certificate{",
          "59:   ObjectMeta: metav1.ObjectMeta{",
          "60:    Namespace: ns,",
          "61:    Name:      name,",
          "62:   },",
          "63:   Spec: certmanagerv1.CertificateSpec{",
          "64:    DNSNames:   []string{dnsName},",
          "65:    SecretName: secretName,",
          "66:    IssuerRef: certmanagermetav1.ObjectReference{",
          "67:     Name: \"selfsigned\",",
          "68:    },",
          "69:   },",
          "70:  }",
          "71:  require.NoError(c.t, c.client.Create(context.TODO(), cert))",
          "73:  return func() {",
          "74:   require.NoError(c.t, c.client.Delete(context.TODO(), cert))",
          "75:   require.NoError(c.t, c.client.Delete(context.TODO(), issuer))",
          "76:  }",
          "77: }",
          "81: func (c *Certs) GetTLSCertificate(secretNamespace, secretName string) tls.Certificate {",
          "82:  secret := &corev1.Secret{}",
          "83:  require.NoError(c.t, c.client.Get(context.TODO(), client.ObjectKey{Namespace: secretNamespace, Name: secretName}, secret))",
          "85:  cert, err := tls.X509KeyPair(secret.Data[\"tls.crt\"], secret.Data[\"tls.key\"])",
          "86:  require.NoError(c.t, err)",
          "88:  return cert",
          "89: }",
          "",
          "---------------"
        ],
        "test/e2e/fixtures.go||test/e2e/fixtures.go": [
          "File: test/e2e/fixtures.go -> test/e2e/fixtures.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:  Echo *Echo",
          "38:  HTTPBin *HTTPBin",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "38:  EchoSecure *EchoSecure",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "150:  }",
          "151: }",
          "154: type HTTPBin struct {",
          "155:  client client.Client",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "154:  }",
          "155: }",
          "158: type EchoSecure struct {",
          "159:  client client.Client",
          "160:  t      ginkgo.GinkgoTInterface",
          "161: }",
          "168: func (e *EchoSecure) Deploy(ns, name string) func() {",
          "169:  valOrDefault := func(val, defaultVal string) string {",
          "170:   if val != \"\" {",
          "171:    return val",
          "172:   }",
          "173:   return defaultVal",
          "174:  }",
          "176:  ns = valOrDefault(ns, \"default\")",
          "177:  name = valOrDefault(name, \"ingress-conformance-echo-tls\")",
          "179:  deployment := &appsv1.Deployment{",
          "180:   ObjectMeta: metav1.ObjectMeta{",
          "181:    Namespace: ns,",
          "182:    Name:      name,",
          "183:   },",
          "184:   Spec: appsv1.DeploymentSpec{",
          "185:    Selector: &metav1.LabelSelector{",
          "186:     MatchLabels: map[string]string{\"app.kubernetes.io/name\": name},",
          "187:    },",
          "188:    Template: corev1.PodTemplateSpec{",
          "189:     ObjectMeta: metav1.ObjectMeta{",
          "190:      Labels: map[string]string{\"app.kubernetes.io/name\": name},",
          "191:     },",
          "192:     Spec: corev1.PodSpec{",
          "193:      Containers: []corev1.Container{",
          "194:       {",
          "195:        Name:  \"conformance-echo\",",
          "196:        Image: \"tsaarni/echoserver:latest\",",
          "197:        Env: []corev1.EnvVar{",
          "198:         {",
          "199:          Name:  \"INGRESS_NAME\",",
          "200:          Value: name,",
          "201:         },",
          "202:         {",
          "203:          Name:  \"SERVICE_NAME\",",
          "204:          Value: name,",
          "205:         },",
          "206:         {",
          "207:          Name: \"POD_NAME\",",
          "208:          ValueFrom: &corev1.EnvVarSource{",
          "209:           FieldRef: &corev1.ObjectFieldSelector{",
          "210:            FieldPath: \"metadata.name\",",
          "211:           },",
          "212:          },",
          "213:         },",
          "214:         {",
          "215:          Name: \"NAMESPACE\",",
          "216:          ValueFrom: &corev1.EnvVarSource{",
          "217:           FieldRef: &corev1.ObjectFieldSelector{",
          "218:            FieldPath: \"metadata.namespace\",",
          "219:           },",
          "220:          },",
          "221:         },",
          "222:         {",
          "223:          Name:  \"TLS_SERVER_CERT\",",
          "224:          Value: \"/run/secrets/certs/tls.crt\",",
          "225:         },",
          "226:         {",
          "227:          Name:  \"TLS_SERVER_PRIVKEY\",",
          "228:          Value: \"/run/secrets/certs/tls.key\",",
          "229:         },",
          "230:         {",
          "231:          Name:  \"TLS_CLIENT_CACERTS\",",
          "232:          Value: \"/run/secrets/certs/ca.crt\",",
          "233:         },",
          "234:        },",
          "235:        Ports: []corev1.ContainerPort{",
          "236:         {",
          "237:          Name:          \"http-api\",",
          "238:          ContainerPort: 3000,",
          "239:         },",
          "240:         {",
          "241:          Name:          \"https-api\",",
          "242:          ContainerPort: 8443,",
          "243:         },",
          "244:        },",
          "245:        ReadinessProbe: &corev1.Probe{",
          "246:         Handler: corev1.Handler{",
          "247:          HTTPGet: &corev1.HTTPGetAction{",
          "248:           Path: \"/health\",",
          "249:           Port: intstr.FromInt(3000),",
          "250:          },",
          "251:         },",
          "252:        },",
          "253:        VolumeMounts: []corev1.VolumeMount{",
          "254:         {",
          "255:          MountPath: \"/run/secrets/certs\",",
          "256:          Name:      \"backend-server-cert\",",
          "257:          ReadOnly:  true,",
          "258:         },",
          "259:        },",
          "260:       },",
          "261:      },",
          "262:      Volumes: []corev1.Volume{",
          "263:       {",
          "264:        Name: \"backend-server-cert\",",
          "265:        VolumeSource: corev1.VolumeSource{",
          "266:         Secret: &corev1.SecretVolumeSource{",
          "267:          SecretName: \"backend-server-cert\",",
          "268:         },",
          "269:        },",
          "270:       },",
          "271:      },",
          "272:     },",
          "273:    },",
          "274:   },",
          "275:  }",
          "276:  require.NoError(e.t, e.client.Create(context.TODO(), deployment))",
          "278:  service := &corev1.Service{",
          "279:   ObjectMeta: metav1.ObjectMeta{",
          "280:    Namespace: ns,",
          "281:    Name:      name,",
          "282:    Annotations: map[string]string{",
          "283:     \"projectcontour.io/upstream-protocol.tls\": \"443\",",
          "284:    },",
          "285:   },",
          "286:   Spec: corev1.ServiceSpec{",
          "287:    Ports: []corev1.ServicePort{",
          "288:     {",
          "289:      Name:       \"http\",",
          "290:      Port:       80,",
          "291:      TargetPort: intstr.FromString(\"http-api\"),",
          "292:     },",
          "293:     {",
          "294:      Name:       \"https\",",
          "295:      Port:       443,",
          "296:      TargetPort: intstr.FromString(\"https-api\"),",
          "297:     },",
          "298:    },",
          "299:    Selector: map[string]string{\"app.kubernetes.io/name\": name},",
          "300:   },",
          "301:  }",
          "302:  require.NoError(e.t, e.client.Create(context.TODO(), service))",
          "",
          "---------------"
        ],
        "test/e2e/framework.go||test/e2e/framework.go": [
          "File: test/e2e/framework.go -> test/e2e/framework.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:  \"time\"",
          "26:  certmanagerv1 \"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1\"",
          "28:  \"github.com/onsi/ginkgo\"",
          "29:  contourv1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"",
          "30:  contourv1alpha1 \"github.com/projectcontour/contour/apis/projectcontour/v1alpha1\"",
          "31:  \"github.com/stretchr/testify/require\"",
          "32:  corev1 \"k8s.io/api/core/v1\"",
          "34:  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
          "35:  \"k8s.io/apimachinery/pkg/runtime\"",
          "36:  \"k8s.io/apimachinery/pkg/util/wait\"",
          "",
          "[Removed Lines]",
          "27:  certmanagermetav1 \"github.com/jetstack/cert-manager/pkg/apis/meta/v1\"",
          "33:  \"k8s.io/apimachinery/pkg/api/errors\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:  HTTP *HTTP",
          "66:  t ginkgo.GinkgoTInterface",
          "67: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66:  Certs *Certs",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "117:     client: crClient,",
          "118:     t:      t,",
          "119:    },",
          "120:    HTTPBin: &HTTPBin{",
          "121:     client: crClient,",
          "122:     t:      t,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "122:    EchoSecure: &EchoSecure{",
          "123:     client: crClient,",
          "124:     t:      t,",
          "125:    },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "129:    RetryTimeout:  60 * time.Second,",
          "130:    t:             t,",
          "131:   },",
          "132:   t: t,",
          "133:  }",
          "134: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "138:   Certs: &Certs{",
          "139:    client: crClient,",
          "140:    t:      t,",
          "141:   },",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "210:  require.NoError(f.t, f.Client.Delete(context.TODO(), ns))",
          "211: }",
          "",
          "[Removed Lines]",
          "215: func (f *Framework) CreateSelfSignedCert(ns, name, secretName, dnsName string) func() {",
          "216:  issuer := &certmanagerv1.Issuer{",
          "217:   ObjectMeta: metav1.ObjectMeta{",
          "218:    Namespace: ns,",
          "219:    Name:      \"selfsigned\",",
          "220:   },",
          "221:   Spec: certmanagerv1.IssuerSpec{",
          "222:    IssuerConfig: certmanagerv1.IssuerConfig{",
          "223:     SelfSigned: &certmanagerv1.SelfSignedIssuer{},",
          "224:    },",
          "225:   },",
          "226:  }",
          "228:  if err := f.Client.Create(context.TODO(), issuer); err != nil && !errors.IsAlreadyExists(err) {",
          "229:   require.FailNow(f.t, \"error creating Issuer: %v\", err)",
          "230:  }",
          "232:  cert := &certmanagerv1.Certificate{",
          "233:   ObjectMeta: metav1.ObjectMeta{",
          "234:    Namespace: ns,",
          "235:    Name:      name,",
          "236:   },",
          "237:   Spec: certmanagerv1.CertificateSpec{",
          "238:    DNSNames:   []string{dnsName},",
          "239:    SecretName: secretName,",
          "240:    IssuerRef: certmanagermetav1.ObjectReference{",
          "241:     Name: \"selfsigned\",",
          "242:    },",
          "243:   },",
          "244:  }",
          "245:  require.NoError(f.t, f.Client.Create(context.TODO(), cert))",
          "247:  return func() {",
          "248:   require.NoError(f.t, f.Client.Delete(context.TODO(), cert))",
          "249:   require.NoError(f.t, f.Client.Delete(context.TODO(), issuer))",
          "250:  }",
          "251: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/e2e/gateway/gateway_test.go||test/e2e/gateway/gateway_test.go": [
          "File: test/e2e/gateway/gateway_test.go -> test/e2e/gateway/gateway_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "163:    }",
          "165:    require.NoError(f.T(), f.Client.Create(context.TODO(), gateway))",
          "167:   })",
          "169:   AfterEach(func() {",
          "",
          "[Removed Lines]",
          "166:    cleanupCert = f.CreateSelfSignedCert(\"projectcontour\", \"tlscert\", \"tlscert\", \"tls-gateway.projectcontour.io\")",
          "",
          "[Added Lines]",
          "166:    cleanupCert = f.Certs.CreateSelfSignedCert(\"projectcontour\", \"tlscert\", \"tlscert\", \"tls-gateway.projectcontour.io\")",
          "",
          "---------------"
        ],
        "test/e2e/http.go||test/e2e/http.go": [
          "File: test/e2e/http.go -> test/e2e/http.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "127:  return h.requestUntil(makeRequest, opts.Condition)",
          "128: }",
          "130: func (h *HTTP) requestUntil(makeRequest func() (*http.Response, error), condition func(*http.Response) bool) (*HTTPResponse, bool) {",
          "131:  var res *HTTPResponse",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137: func (h *HTTP) SecureRequest(opts *HTTPSRequestOpts) (*HTTPResponse, error) {",
          "138:  req, err := http.NewRequest(\"GET\", h.HTTPSURLBase+opts.Path, nil)",
          "139:  require.NoError(h.t, err, \"error creating HTTP request\")",
          "141:  req.Host = opts.Host",
          "142:  for _, opt := range opts.RequestOpts {",
          "143:   opt(req)",
          "144:  }",
          "146:  transport := http.DefaultTransport.(*http.Transport).Clone()",
          "147:  transport.TLSClientConfig = &tls.Config{",
          "148:   ServerName: opts.Host,",
          "150:   InsecureSkipVerify: true,",
          "151:  }",
          "152:  for _, opt := range opts.TLSConfigOpts {",
          "153:   opt(transport.TLSClientConfig)",
          "154:  }",
          "156:  client := &http.Client{",
          "157:   Transport: transport,",
          "158:  }",
          "160:  r, err := client.Do(req)",
          "161:  if err != nil {",
          "162:   return nil, err",
          "163:  }",
          "164:  defer r.Body.Close()",
          "166:  bodyBytes, err := ioutil.ReadAll(r.Body)",
          "167:  require.NoError(h.t, err)",
          "169:  return &HTTPResponse{",
          "170:   StatusCode: r.StatusCode,",
          "171:   Headers:    r.Header,",
          "172:   Body:       bodyBytes,",
          "173:  }, nil",
          "174: }",
          "",
          "---------------"
        ],
        "test/e2e/httpproxy/004_https_sni_enforcement_test.go||test/e2e/httpproxy/004_https_sni_enforcement_test.go": [
          "File: test/e2e/httpproxy/004_https_sni_enforcement_test.go -> test/e2e/httpproxy/004_https_sni_enforcement_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:  defer fx.DeleteNamespace(namespace)",
          "35:  fx.Fixtures.Echo.Deploy(namespace, \"echo-one\")",
          "38:  echoOneProxy := &contourv1.HTTPProxy{",
          "39:   ObjectMeta: metav1.ObjectMeta{",
          "",
          "[Removed Lines]",
          "36:  fx.CreateSelfSignedCert(namespace, \"echo-one-cert\", \"echo-one\", \"sni-enforcement-echo-one.projectcontour.io\")",
          "",
          "[Added Lines]",
          "36:  fx.Certs.CreateSelfSignedCert(namespace, \"echo-one-cert\", \"echo-one\", \"sni-enforcement-echo-one.projectcontour.io\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:  fx.Fixtures.Echo.Deploy(namespace, \"echo-two\")",
          "77:  echoTwoProxy := &contourv1.HTTPProxy{",
          "78:   ObjectMeta: metav1.ObjectMeta{",
          "",
          "[Removed Lines]",
          "75:  fx.CreateSelfSignedCert(namespace, \"echo-two-cert\", \"echo-two\", \"sni-enforcement-echo-two.projectcontour.io\")",
          "",
          "[Added Lines]",
          "75:  fx.Certs.CreateSelfSignedCert(namespace, \"echo-two-cert\", \"echo-two\", \"sni-enforcement-echo-two.projectcontour.io\")",
          "",
          "---------------"
        ],
        "test/e2e/httpproxy/007_client_cert_auth_test.go||test/e2e/httpproxy/007_client_cert_auth_test.go": [
          "File: test/e2e/httpproxy/007_client_cert_auth_test.go -> test/e2e/httpproxy/007_client_cert_auth_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: package httpproxy",
          "18: import (",
          "19:  \"context\"",
          "20:  \"crypto/tls\"",
          "22:  certmanagerv1 \"github.com/jetstack/cert-manager/pkg/apis/certmanager/v1\"",
          "23:  certmanagermetav1 \"github.com/jetstack/cert-manager/pkg/apis/meta/v1\"",
          "24:  contourv1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"",
          "25:  \"github.com/projectcontour/contour/test/e2e\"",
          "26:  \"github.com/stretchr/testify/assert\"",
          "27:  \"github.com/stretchr/testify/require\"",
          "28:  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
          "29: )",
          "31: func testClientCertAuth(fx *e2e.Framework) {",
          "32:  t := fx.T()",
          "33:  namespace := \"007-client-cert-auth\"",
          "35:  fx.CreateNamespace(namespace)",
          "36:  defer fx.DeleteNamespace(namespace)",
          "39:  selfSignedIssuer := &certmanagerv1.Issuer{",
          "40:   ObjectMeta: metav1.ObjectMeta{",
          "41:    Namespace: namespace,",
          "42:    Name:      \"selfsigned\",",
          "43:   },",
          "44:   Spec: certmanagerv1.IssuerSpec{",
          "45:    IssuerConfig: certmanagerv1.IssuerConfig{",
          "46:     SelfSigned: &certmanagerv1.SelfSignedIssuer{},",
          "47:    },",
          "48:   },",
          "49:  }",
          "50:  require.NoError(t, fx.Client.Create(context.TODO(), selfSignedIssuer))",
          "54:  caSigningCert := &certmanagerv1.Certificate{",
          "55:   ObjectMeta: metav1.ObjectMeta{",
          "56:    Namespace: namespace,",
          "57:    Name:      \"ca-projectcontour-io\",",
          "58:   },",
          "59:   Spec: certmanagerv1.CertificateSpec{",
          "60:    IsCA: true,",
          "61:    Usages: []certmanagerv1.KeyUsage{",
          "62:     certmanagerv1.UsageSigning,",
          "63:     certmanagerv1.UsageCertSign,",
          "64:    },",
          "65:    Subject: &certmanagerv1.X509Subject{",
          "66:     OrganizationalUnits: []string{",
          "67:      \"io\",",
          "68:      \"projectcontour\",",
          "69:      \"testsuite\",",
          "70:     },",
          "71:    },",
          "72:    CommonName: \"issuer\",",
          "73:    SecretName: \"ca-projectcontour-io\",",
          "74:    IssuerRef: certmanagermetav1.ObjectReference{",
          "75:     Name: \"selfsigned\",",
          "76:    },",
          "77:   },",
          "78:  }",
          "79:  require.NoError(t, fx.Client.Create(context.TODO(), caSigningCert))",
          "83:  localCAIssuer := &certmanagerv1.Issuer{",
          "84:   ObjectMeta: metav1.ObjectMeta{",
          "85:    Namespace: namespace,",
          "86:    Name:      \"ca-projectcontour-io\",",
          "87:   },",
          "88:   Spec: certmanagerv1.IssuerSpec{",
          "89:    IssuerConfig: certmanagerv1.IssuerConfig{",
          "90:     CA: &certmanagerv1.CAIssuer{",
          "91:      SecretName: \"ca-projectcontour-io\",",
          "92:     },",
          "93:    },",
          "94:   },",
          "95:  }",
          "96:  require.NoError(t, fx.Client.Create(context.TODO(), localCAIssuer))",
          "100:  caSigningCert2 := &certmanagerv1.Certificate{",
          "101:   ObjectMeta: metav1.ObjectMeta{",
          "102:    Namespace: namespace,",
          "103:    Name:      \"ca-notprojectcontour-io\",",
          "104:   },",
          "105:   Spec: certmanagerv1.CertificateSpec{",
          "106:    IsCA: true,",
          "107:    Usages: []certmanagerv1.KeyUsage{",
          "108:     certmanagerv1.UsageSigning,",
          "109:     certmanagerv1.UsageCertSign,",
          "110:    },",
          "111:    Subject: &certmanagerv1.X509Subject{",
          "112:     OrganizationalUnits: []string{",
          "113:      \"io\",",
          "114:      \"notprojectcontour\",",
          "115:      \"testsuite\",",
          "116:     },",
          "117:    },",
          "118:    CommonName: \"issuer\",",
          "119:    SecretName: \"ca-notprojectcontour-io\",",
          "120:    IssuerRef: certmanagermetav1.ObjectReference{",
          "121:     Name: \"selfsigned\",",
          "122:    },",
          "123:   },",
          "124:  }",
          "125:  require.NoError(t, fx.Client.Create(context.TODO(), caSigningCert2))",
          "129:  localCAIssuer2 := &certmanagerv1.Issuer{",
          "130:   ObjectMeta: metav1.ObjectMeta{",
          "131:    Namespace: namespace,",
          "132:    Name:      \"ca-notprojectcontour-io\",",
          "133:   },",
          "134:   Spec: certmanagerv1.IssuerSpec{",
          "135:    IssuerConfig: certmanagerv1.IssuerConfig{",
          "136:     CA: &certmanagerv1.CAIssuer{",
          "137:      SecretName: \"ca-notprojectcontour-io\",",
          "138:     },",
          "139:    },",
          "140:   },",
          "141:  }",
          "142:  require.NoError(t, fx.Client.Create(context.TODO(), localCAIssuer2))",
          "144:  fx.Fixtures.Echo.Deploy(namespace, \"echo-no-auth\")",
          "147:  echoNoAuthCert := &certmanagerv1.Certificate{",
          "148:   ObjectMeta: metav1.ObjectMeta{",
          "149:    Namespace: namespace,",
          "150:    Name:      \"echo-no-auth-cert\",",
          "151:   },",
          "152:   Spec: certmanagerv1.CertificateSpec{",
          "154:    Usages: []certmanagerv1.KeyUsage{",
          "155:     certmanagerv1.UsageServerAuth,",
          "156:    },",
          "157:    DNSNames:   []string{\"echo-no-auth.projectcontour.io\"},",
          "158:    SecretName: \"echo-no-auth\",",
          "159:    IssuerRef: certmanagermetav1.ObjectReference{",
          "160:     Name: \"ca-projectcontour-io\",",
          "161:    },",
          "162:   },",
          "163:  }",
          "164:  require.NoError(t, fx.Client.Create(context.TODO(), echoNoAuthCert))",
          "166:  fx.Fixtures.Echo.Deploy(namespace, \"echo-with-auth\")",
          "169:  echoWithAuthCert := &certmanagerv1.Certificate{",
          "170:   ObjectMeta: metav1.ObjectMeta{",
          "171:    Namespace: namespace,",
          "172:    Name:      \"echo-with-auth-cert\",",
          "173:   },",
          "174:   Spec: certmanagerv1.CertificateSpec{",
          "175:    Usages: []certmanagerv1.KeyUsage{",
          "176:     certmanagerv1.UsageServerAuth,",
          "177:    },",
          "178:    DNSNames:   []string{\"echo-with-auth.projectcontour.io\"},",
          "179:    SecretName: \"echo-with-auth\",",
          "180:    IssuerRef: certmanagermetav1.ObjectReference{",
          "181:     Name: \"ca-projectcontour-io\",",
          "182:    },",
          "183:   },",
          "184:  }",
          "185:  require.NoError(t, fx.Client.Create(context.TODO(), echoWithAuthCert))",
          "187:  fx.Fixtures.Echo.Deploy(namespace, \"echo-with-auth-skip-verify\")",
          "190:  echoWithAuthSkipVerifyCert := &certmanagerv1.Certificate{",
          "191:   ObjectMeta: metav1.ObjectMeta{",
          "192:    Namespace: namespace,",
          "193:    Name:      \"echo-with-auth-skip-verify-cert\",",
          "194:   },",
          "195:   Spec: certmanagerv1.CertificateSpec{",
          "197:    Usages: []certmanagerv1.KeyUsage{",
          "198:     certmanagerv1.UsageServerAuth,",
          "199:    },",
          "200:    DNSNames:   []string{\"echo-with-auth-skip-verify.projectcontour.io\"},",
          "201:    SecretName: \"echo-with-auth-skip-verify\",",
          "202:    IssuerRef: certmanagermetav1.ObjectReference{",
          "203:     Name: \"ca-projectcontour-io\",",
          "204:    },",
          "205:   },",
          "206:  }",
          "207:  require.NoError(t, fx.Client.Create(context.TODO(), echoWithAuthSkipVerifyCert))",
          "210:  clientCert := &certmanagerv1.Certificate{",
          "211:   ObjectMeta: metav1.ObjectMeta{",
          "212:    Namespace: namespace,",
          "213:    Name:      \"echo-client-cert\",",
          "214:   },",
          "215:   Spec: certmanagerv1.CertificateSpec{",
          "216:    Usages: []certmanagerv1.KeyUsage{",
          "217:     certmanagerv1.UsageClientAuth,",
          "218:    },",
          "219:    EmailAddresses: []string{",
          "220:     \"client@projectcontour.io\",",
          "221:    },",
          "222:    CommonName: \"client\",",
          "223:    SecretName: \"echo-client\",",
          "224:    IssuerRef: certmanagermetav1.ObjectReference{",
          "225:     Name: \"ca-projectcontour-io\",",
          "226:    },",
          "227:   },",
          "228:  }",
          "229:  require.NoError(t, fx.Client.Create(context.TODO(), clientCert))",
          "232:  clientCertInvalid := &certmanagerv1.Certificate{",
          "233:   ObjectMeta: metav1.ObjectMeta{",
          "234:    Namespace: namespace,",
          "235:    Name:      \"echo-client-cert-invalid\",",
          "236:   },",
          "237:   Spec: certmanagerv1.CertificateSpec{",
          "238:    Usages: []certmanagerv1.KeyUsage{",
          "239:     certmanagerv1.UsageClientAuth,",
          "240:    },",
          "241:    EmailAddresses: []string{",
          "242:     \"badclient@projectcontour.io\",",
          "243:    },",
          "244:    CommonName: \"badclient\",",
          "245:    SecretName: \"echo-client-invalid\",",
          "246:    IssuerRef: certmanagermetav1.ObjectReference{",
          "247:     Name: \"ca-notprojectcontour-io\",",
          "248:    },",
          "249:   },",
          "250:  }",
          "251:  require.NoError(t, fx.Client.Create(context.TODO(), clientCertInvalid))",
          "254:  noAuthProxy := &contourv1.HTTPProxy{",
          "255:   ObjectMeta: metav1.ObjectMeta{",
          "256:    Namespace: namespace,",
          "257:    Name:      \"echo-no-auth\",",
          "258:   },",
          "259:   Spec: contourv1.HTTPProxySpec{",
          "260:    VirtualHost: &contourv1.VirtualHost{",
          "261:     Fqdn: \"echo-no-auth.projectcontour.io\",",
          "262:     TLS: &contourv1.TLS{",
          "263:      SecretName: \"echo-no-auth\",",
          "264:     },",
          "265:    },",
          "266:    Routes: []contourv1.Route{",
          "267:     {",
          "268:      Services: []contourv1.Service{",
          "269:       {",
          "270:        Name: \"echo-no-auth\",",
          "271:        Port: 80,",
          "272:       },",
          "273:      },",
          "274:     },",
          "275:    },",
          "276:   },",
          "277:  }",
          "278:  fx.CreateHTTPProxyAndWaitFor(noAuthProxy, httpProxyValid)",
          "281:  authProxy := &contourv1.HTTPProxy{",
          "282:   ObjectMeta: metav1.ObjectMeta{",
          "283:    Namespace: namespace,",
          "284:    Name:      \"echo-with-auth\",",
          "285:   },",
          "286:   Spec: contourv1.HTTPProxySpec{",
          "287:    VirtualHost: &contourv1.VirtualHost{",
          "288:     Fqdn: \"echo-with-auth.projectcontour.io\",",
          "289:     TLS: &contourv1.TLS{",
          "290:      SecretName: \"echo-with-auth\",",
          "291:      ClientValidation: &contourv1.DownstreamValidation{",
          "292:       CACertificate: \"echo-with-auth\",",
          "293:      },",
          "294:     },",
          "295:    },",
          "296:    Routes: []contourv1.Route{",
          "297:     {",
          "298:      Services: []contourv1.Service{",
          "299:       {",
          "300:        Name: \"echo-with-auth\",",
          "301:        Port: 80,",
          "302:       },",
          "303:      },",
          "304:     },",
          "305:    },",
          "306:   },",
          "307:  }",
          "308:  fx.CreateHTTPProxyAndWaitFor(authProxy, httpProxyValid)",
          "311:  authSkipVerifyProxy := &contourv1.HTTPProxy{",
          "312:   ObjectMeta: metav1.ObjectMeta{",
          "313:    Namespace: namespace,",
          "314:    Name:      \"echo-with-auth-skip-verify\",",
          "315:   },",
          "316:   Spec: contourv1.HTTPProxySpec{",
          "317:    VirtualHost: &contourv1.VirtualHost{",
          "318:     Fqdn: \"echo-with-auth-skip-verify.projectcontour.io\",",
          "319:     TLS: &contourv1.TLS{",
          "320:      SecretName: \"echo-with-auth-skip-verify\",",
          "321:      ClientValidation: &contourv1.DownstreamValidation{",
          "322:       SkipClientCertValidation: true,",
          "323:      },",
          "324:     },",
          "325:    },",
          "326:    Routes: []contourv1.Route{",
          "327:     {",
          "328:      Services: []contourv1.Service{",
          "329:       {",
          "330:        Name: \"echo-with-auth-skip-verify\",",
          "331:        Port: 80,",
          "332:       },",
          "333:      },",
          "334:     },",
          "335:    },",
          "336:   },",
          "337:  }",
          "338:  fx.CreateHTTPProxyAndWaitFor(authSkipVerifyProxy, httpProxyValid)",
          "341:  validClientCert := fx.Certs.GetTLSCertificate(namespace, \"echo-client\")",
          "342:  invalidClientCert := fx.Certs.GetTLSCertificate(namespace, \"echo-client-invalid\")",
          "344:  cases := map[string]struct {",
          "345:   host       string",
          "346:   clientCert *tls.Certificate",
          "347:   wantErr    string",
          "348:  }{",
          "349:   \"echo-no-auth without a client cert should succeed\": {",
          "350:    host:       noAuthProxy.Spec.VirtualHost.Fqdn,",
          "351:    clientCert: nil,",
          "352:    wantErr:    \"\",",
          "353:   },",
          "354:   \"echo-no-auth with echo-client-cert should succeed\": {",
          "355:    host:       noAuthProxy.Spec.VirtualHost.Fqdn,",
          "356:    clientCert: &validClientCert,",
          "357:    wantErr:    \"\",",
          "358:   },",
          "359:   \"echo-no-auth with echo-client-cert-invalid should succeed\": {",
          "360:    host:       noAuthProxy.Spec.VirtualHost.Fqdn,",
          "361:    clientCert: &invalidClientCert,",
          "362:    wantErr:    \"\",",
          "363:   },",
          "365:   \"echo-with-auth without a client cert should error\": {",
          "366:    host:       authProxy.Spec.VirtualHost.Fqdn,",
          "367:    clientCert: nil,",
          "368:    wantErr:    \"tls: certificate required\",",
          "369:   },",
          "370:   \"echo-with-auth with echo-client-cert should succeed\": {",
          "371:    host:       authProxy.Spec.VirtualHost.Fqdn,",
          "372:    clientCert: &validClientCert,",
          "373:    wantErr:    \"\",",
          "374:   },",
          "375:   \"echo-with-auth with echo-client-cert-invalid should error\": {",
          "376:    host:       authProxy.Spec.VirtualHost.Fqdn,",
          "377:    clientCert: &invalidClientCert,",
          "378:    wantErr:    \"tls: certificate required\",",
          "379:   },",
          "381:   \"echo-with-auth-skip-verify without a client cert should succeed\": {",
          "382:    host:       authSkipVerifyProxy.Spec.VirtualHost.Fqdn,",
          "383:    clientCert: nil,",
          "384:    wantErr:    \"\",",
          "385:   },",
          "386:   \"echo-with-auth-skip-verify with echo-client-cert should succeed\": {",
          "387:    host:       authSkipVerifyProxy.Spec.VirtualHost.Fqdn,",
          "388:    clientCert: &validClientCert,",
          "389:    wantErr:    \"\",",
          "390:   },",
          "391:   \"echo-with-auth-skip-verify with echo-client-cert-invalid should succeed\": {",
          "392:    host:       authSkipVerifyProxy.Spec.VirtualHost.Fqdn,",
          "393:    clientCert: &invalidClientCert,",
          "394:    wantErr:    \"\",",
          "395:   },",
          "396:  }",
          "398:  for name, tc := range cases {",
          "399:   t.Logf(\"Running test case %s\", name)",
          "400:   opts := &e2e.HTTPSRequestOpts{",
          "401:    Host: tc.host,",
          "402:   }",
          "403:   if tc.clientCert != nil {",
          "404:    opts.TLSConfigOpts = append(opts.TLSConfigOpts, optUseCert(*tc.clientCert))",
          "405:   }",
          "407:   switch {",
          "408:   case len(tc.wantErr) == 0:",
          "409:    opts.Condition = e2e.HasStatusCode(200)",
          "410:    res, ok := fx.HTTP.SecureRequestUntil(opts)",
          "411:    assert.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "412:   default:",
          "413:    _, err := fx.HTTP.SecureRequest(opts)",
          "414:    assert.Contains(t, err.Error(), tc.wantErr)",
          "415:   }",
          "416:  }",
          "417: }",
          "419: func optUseCert(cert tls.Certificate) func(*tls.Config) {",
          "420:  return func(c *tls.Config) {",
          "421:   c.Certificates = append(c.Certificates, cert)",
          "422:  }",
          "423: }",
          "",
          "---------------"
        ],
        "test/e2e/httpproxy/008_tcproute_https_termination_test.go||test/e2e/httpproxy/008_tcproute_https_termination_test.go": [
          "File: test/e2e/httpproxy/008_tcproute_https_termination_test.go -> test/e2e/httpproxy/008_tcproute_https_termination_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "36:  defer fx.DeleteNamespace(namespace)",
          "38:  fx.Fixtures.Echo.Deploy(namespace, \"ingress-conformance-echo\")",
          "41:  p := &contourv1.HTTPProxy{",
          "42:   ObjectMeta: metav1.ObjectMeta{",
          "",
          "[Removed Lines]",
          "39:  fx.CreateSelfSignedCert(namespace, \"echo-cert\", \"echo-cert\", \"tcp-route-https-termination.projectcontour.io\")",
          "",
          "[Added Lines]",
          "39:  fx.Certs.CreateSelfSignedCert(namespace, \"echo-cert\", \"echo-cert\", \"tcp-route-https-termination.projectcontour.io\")",
          "",
          "---------------"
        ],
        "test/e2e/httpproxy/009_https_misdirected_request_test.go||test/e2e/httpproxy/009_https_misdirected_request_test.go": [
          "File: test/e2e/httpproxy/009_https_misdirected_request_test.go -> test/e2e/httpproxy/009_https_misdirected_request_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:  defer fx.DeleteNamespace(namespace)",
          "35:  fx.Fixtures.Echo.Deploy(namespace, \"echo\")",
          "38:  p := &contourv1.HTTPProxy{",
          "39:   ObjectMeta: metav1.ObjectMeta{",
          "",
          "[Removed Lines]",
          "36:  fx.CreateSelfSignedCert(namespace, \"echo-cert\", \"echo\", \"https-misdirected-request.projectcontour.io\")",
          "",
          "[Added Lines]",
          "36:  fx.Certs.CreateSelfSignedCert(namespace, \"echo-cert\", \"echo\", \"https-misdirected-request.projectcontour.io\")",
          "",
          "---------------"
        ],
        "test/e2e/httpproxy/012_https_fallback_certificate_test.go||test/e2e/httpproxy/012_https_fallback_certificate_test.go": [
          "File: test/e2e/httpproxy/012_https_fallback_certificate_test.go -> test/e2e/httpproxy/012_https_fallback_certificate_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:  defer fx.DeleteNamespace(namespace)",
          "35:  fx.Fixtures.Echo.Deploy(namespace, \"echo\")",
          "38:  p := &contourv1.HTTPProxy{",
          "39:   ObjectMeta: metav1.ObjectMeta{",
          "",
          "[Removed Lines]",
          "36:  fx.CreateSelfSignedCert(namespace, \"echo-cert\", \"echo\", \"fallback-cert-echo.projectcontour.io\")",
          "",
          "[Added Lines]",
          "36:  fx.Certs.CreateSelfSignedCert(namespace, \"echo-cert\", \"echo\", \"fallback-cert-echo.projectcontour.io\")",
          "",
          "---------------"
        ],
        "test/e2e/httpproxy/014_external_auth_test.go||test/e2e/httpproxy/014_external_auth_test.go": [
          "File: test/e2e/httpproxy/014_external_auth_test.go -> test/e2e/httpproxy/014_external_auth_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "41:  defer fx.DeleteNamespace(authServerNamespace)",
          "43:  fx.Fixtures.Echo.Deploy(namespace, \"echo\")",
          "49:  deployment := &appsv1.Deployment{",
          "",
          "[Removed Lines]",
          "44:  fx.CreateSelfSignedCert(namespace, \"echo\", \"echo\", \"externalauth.projectcontour.io\")",
          "46:  fx.CreateSelfSignedCert(authServerNamespace, \"testserver-cert\", \"testserver-cert\", \"testserver\")",
          "",
          "[Added Lines]",
          "44:  fx.Certs.CreateSelfSignedCert(namespace, \"echo\", \"echo\", \"externalauth.projectcontour.io\")",
          "46:  fx.Certs.CreateSelfSignedCert(authServerNamespace, \"testserver-cert\", \"testserver-cert\", \"testserver\")",
          "",
          "---------------"
        ],
        "test/e2e/httpproxy/018_external_name_test.go||test/e2e/httpproxy/018_external_name_test.go": [
          "File: test/e2e/httpproxy/018_external_name_test.go -> test/e2e/httpproxy/018_external_name_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: package httpproxy",
          "18: import (",
          "19:  \"context\"",
          "21:  contourv1 \"github.com/projectcontour/contour/apis/projectcontour/v1\"",
          "22:  \"github.com/projectcontour/contour/test/e2e\"",
          "23:  \"github.com/stretchr/testify/require\"",
          "24:  corev1 \"k8s.io/api/core/v1\"",
          "25:  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
          "26: )",
          "28: func testExternalNameServiceInsecure(fx *e2e.Framework) {",
          "29:  t := fx.T()",
          "30:  namespace := \"018-external-name-service-insecure\"",
          "32:  fx.CreateNamespace(namespace)",
          "33:  defer fx.DeleteNamespace(namespace)",
          "35:  fx.Fixtures.Echo.Deploy(namespace, \"ingress-conformance-echo\")",
          "37:  externalNameService := &corev1.Service{",
          "38:   ObjectMeta: metav1.ObjectMeta{",
          "39:    Namespace: namespace,",
          "40:    Name:      \"external-name-service\",",
          "41:   },",
          "42:   Spec: corev1.ServiceSpec{",
          "43:    Type:         corev1.ServiceTypeExternalName,",
          "44:    ExternalName: \"ingress-conformance-echo.\" + namespace,",
          "45:    Ports: []corev1.ServicePort{",
          "46:     {",
          "47:      Name: \"http\",",
          "48:      Port: 80,",
          "49:     },",
          "50:    },",
          "51:   },",
          "52:  }",
          "53:  require.NoError(t, fx.Client.Create(context.TODO(), externalNameService))",
          "55:  p := &contourv1.HTTPProxy{",
          "56:   ObjectMeta: metav1.ObjectMeta{",
          "57:    Namespace: namespace,",
          "58:    Name:      \"external-name-proxy\",",
          "59:   },",
          "60:   Spec: contourv1.HTTPProxySpec{",
          "61:    VirtualHost: &contourv1.VirtualHost{",
          "62:     Fqdn: \"externalnameservice.projectcontour.io\",",
          "63:    },",
          "64:    Routes: []contourv1.Route{",
          "65:     {",
          "66:      Services: []contourv1.Service{",
          "67:       {",
          "68:        Name: externalNameService.Name,",
          "69:        Port: 80,",
          "70:       },",
          "71:      },",
          "72:      RequestHeadersPolicy: &contourv1.HeadersPolicy{",
          "73:       Set: []contourv1.HeaderValue{",
          "74:        {",
          "75:         Name:  \"Host\",",
          "76:         Value: externalNameService.Spec.ExternalName,",
          "77:        },",
          "78:       },",
          "79:      },",
          "80:     },",
          "81:    },",
          "82:   },",
          "83:  }",
          "84:  fx.CreateHTTPProxyAndWaitFor(p, httpProxyValid)",
          "86:  res, ok := fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "87:   Host:      p.Spec.VirtualHost.Fqdn,",
          "88:   Condition: e2e.HasStatusCode(200),",
          "89:  })",
          "90:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "91: }",
          "93: func testExternalNameServiceTLS(fx *e2e.Framework) {",
          "94:  t := fx.T()",
          "95:  namespace := \"018-external-name-service-tls\"",
          "97:  fx.CreateNamespace(namespace)",
          "98:  defer fx.DeleteNamespace(namespace)",
          "100:  fx.Certs.CreateSelfSignedCert(namespace, \"backend-server-cert\", \"backend-server-cert\", \"echo\")",
          "102:  fx.Fixtures.EchoSecure.Deploy(namespace, \"echo-tls\")",
          "104:  externalNameService := &corev1.Service{",
          "105:   ObjectMeta: metav1.ObjectMeta{",
          "106:    Namespace: namespace,",
          "107:    Name:      \"external-name-service-tls\",",
          "108:   },",
          "109:   Spec: corev1.ServiceSpec{",
          "110:    Type:         corev1.ServiceTypeExternalName,",
          "111:    ExternalName: \"echo-tls.\" + namespace,",
          "112:    Ports: []corev1.ServicePort{",
          "113:     {",
          "114:      Name:     \"https\",",
          "115:      Port:     443,",
          "116:      Protocol: corev1.ProtocolTCP,",
          "117:     },",
          "118:    },",
          "119:   },",
          "120:  }",
          "121:  require.NoError(t, fx.Client.Create(context.TODO(), externalNameService))",
          "123:  p := &contourv1.HTTPProxy{",
          "124:   ObjectMeta: metav1.ObjectMeta{",
          "125:    Namespace: namespace,",
          "126:    Name:      \"external-name-proxy-tls\",",
          "127:   },",
          "128:   Spec: contourv1.HTTPProxySpec{",
          "129:    VirtualHost: &contourv1.VirtualHost{",
          "130:     Fqdn: \"tls.externalnameservice.projectcontour.io\",",
          "131:    },",
          "132:    Routes: []contourv1.Route{",
          "133:     {",
          "134:      Services: []contourv1.Service{",
          "135:       {",
          "136:        Name:     externalNameService.Name,",
          "137:        Port:     443,",
          "138:        Protocol: stringPtr(\"tls\"),",
          "139:       },",
          "140:      },",
          "141:      RequestHeadersPolicy: &contourv1.HeadersPolicy{",
          "142:       Set: []contourv1.HeaderValue{",
          "143:        {",
          "144:         Name:  \"Host\",",
          "145:         Value: externalNameService.Spec.ExternalName,",
          "146:        },",
          "147:       },",
          "148:      },",
          "149:     },",
          "150:    },",
          "151:   },",
          "152:  }",
          "153:  fx.CreateHTTPProxyAndWaitFor(p, httpProxyValid)",
          "155:  res, ok := fx.HTTP.RequestUntil(&e2e.HTTPRequestOpts{",
          "156:   Host:      p.Spec.VirtualHost.Fqdn,",
          "157:   Condition: e2e.HasStatusCode(200),",
          "158:  })",
          "159:  require.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "160: }",
          "162: func stringPtr(s string) *string {",
          "163:  return &s",
          "164: }",
          "",
          "---------------"
        ],
        "test/e2e/httpproxy/020_global_rate_limiting_test.go||test/e2e/httpproxy/020_global_rate_limiting_test.go": [
          "File: test/e2e/httpproxy/020_global_rate_limiting_test.go -> test/e2e/httpproxy/020_global_rate_limiting_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "221:  defer fx.DeleteNamespace(namespace)",
          "223:  fx.Fixtures.Echo.Deploy(namespace, \"echo\")",
          "226:  p := &contourv1.HTTPProxy{",
          "227:   ObjectMeta: metav1.ObjectMeta{",
          "",
          "[Removed Lines]",
          "224:  fx.CreateSelfSignedCert(namespace, \"echo-cert\", \"echo\", \"globalratelimitvhosttls.projectcontour.io\")",
          "",
          "[Added Lines]",
          "224:  fx.Certs.CreateSelfSignedCert(namespace, \"echo-cert\", \"echo\", \"globalratelimitvhosttls.projectcontour.io\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "307:  defer fx.DeleteNamespace(namespace)",
          "309:  fx.Fixtures.Echo.Deploy(namespace, \"echo\")",
          "312:  p := &contourv1.HTTPProxy{",
          "313:   ObjectMeta: metav1.ObjectMeta{",
          "",
          "[Removed Lines]",
          "310:  fx.CreateSelfSignedCert(namespace, \"echo-cert\", \"echo\", \"globalratelimitroutetls.projectcontour.io\")",
          "",
          "[Added Lines]",
          "310:  fx.Certs.CreateSelfSignedCert(namespace, \"echo-cert\", \"echo\", \"globalratelimitroutetls.projectcontour.io\")",
          "",
          "---------------"
        ],
        "test/e2e/httpproxy/httpproxy_test.go||test/e2e/httpproxy/httpproxy_test.go": [
          "File: test/e2e/httpproxy/httpproxy_test.go -> test/e2e/httpproxy/httpproxy_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:  It(\"006-merge-slash\", func() {",
          "53:   testMergeSlash(f)",
          "54:  })",
          "55:  It(\"008-tcproute-https-termination\", func() {",
          "56:   testTCPRouteHTTPSTermination(f)",
          "57:  })",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "55:  It(\"007-client-cert-auth\", func() {",
          "56:   testClientCertAuth(f)",
          "57:  })",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:  It(\"017-host-header-rewrite\", func() {",
          "80:   testHostHeaderRewrite(f)",
          "81:  })",
          "82:  It(\"019-local-rate-limiting-vhost\", func() {",
          "83:   testLocalRateLimitingVirtualHost(f)",
          "84:  })",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "85:  It(\"018-external-name-service-insecure\", func() {",
          "86:   testExternalNameServiceInsecure(f)",
          "87:  })",
          "88:  It(\"018-external-name-service-tls\", func() {",
          "89:   testExternalNameServiceTLS(f)",
          "90:  })",
          "",
          "---------------"
        ],
        "test/e2e/ingress/001_tls_wildcard_host_test.go||test/e2e/ingress/001_tls_wildcard_host_test.go": [
          "File: test/e2e/ingress/001_tls_wildcard_host_test.go -> test/e2e/ingress/001_tls_wildcard_host_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: package ingress",
          "18: import (",
          "19:  \"context\"",
          "20:  \"crypto/tls\"",
          "22:  \"github.com/projectcontour/contour/test/e2e\"",
          "23:  \"github.com/stretchr/testify/require\"",
          "24:  networkingv1 \"k8s.io/api/networking/v1\"",
          "25:  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
          "26: )",
          "28: func testTLSWildcardHost(fx *e2e.Framework) {",
          "29:  t := fx.T()",
          "30:  namespace := \"001-ingress-tls-wildcard-host\"",
          "31:  hostSuffix := \"wildcardhost.ingress.projectcontour.io\"",
          "33:  fx.CreateNamespace(namespace)",
          "34:  defer fx.DeleteNamespace(namespace)",
          "36:  fx.Fixtures.Echo.Deploy(namespace, \"echo\")",
          "37:  fx.Certs.CreateSelfSignedCert(namespace, \"echo-one-cert\", \"echo-one-cert\", \"*.\"+hostSuffix)",
          "39:  i := &networkingv1.Ingress{",
          "40:   ObjectMeta: metav1.ObjectMeta{",
          "41:    Namespace: namespace,",
          "42:    Name:      \"wildcard-ingress\",",
          "43:   },",
          "44:   Spec: networkingv1.IngressSpec{",
          "45:    TLS: []networkingv1.IngressTLS{",
          "46:     {",
          "47:      Hosts:      []string{\"*.wildcardhost.ingress.projectcontour.io\"},",
          "48:      SecretName: \"echo-one-cert\",",
          "49:     },",
          "50:    },",
          "51:    Rules: []networkingv1.IngressRule{",
          "52:     {",
          "53:      Host: \"*.wildcardhost.ingress.projectcontour.io\",",
          "54:      IngressRuleValue: networkingv1.IngressRuleValue{",
          "55:       HTTP: &networkingv1.HTTPIngressRuleValue{",
          "56:        Paths: []networkingv1.HTTPIngressPath{",
          "57:         {",
          "58:          PathType: pathTypePtr(networkingv1.PathTypePrefix),",
          "59:          Path:     \"/\",",
          "60:          Backend: networkingv1.IngressBackend{",
          "61:           Service: &networkingv1.IngressServiceBackend{",
          "62:            Name: \"echo\",",
          "63:            Port: networkingv1.ServiceBackendPort{",
          "64:             Number: 80,",
          "65:            },",
          "66:           },",
          "67:          },",
          "68:         },",
          "69:        },",
          "70:       },",
          "71:      },",
          "72:     },",
          "73:    },",
          "74:   },",
          "75:  }",
          "76:  require.NoError(t, fx.Client.Create(context.TODO(), i))",
          "78:  cases := []struct {",
          "79:   hostname   string",
          "80:   sni        string",
          "81:   wantStatus int",
          "82:  }{",
          "83:   {",
          "84:    hostname:   \"random1.\" + hostSuffix,",
          "85:    sni:        \"random1.\" + hostSuffix,",
          "86:    wantStatus: 200,",
          "87:   },",
          "88:   {",
          "89:    hostname:   \"random2.\" + hostSuffix,",
          "90:    sni:        \"random2.\" + hostSuffix,",
          "91:    wantStatus: 200,",
          "92:   },",
          "93:   {",
          "94:    hostname:   \"a.random3.\" + hostSuffix,",
          "95:    sni:        \"a.random3.\" + hostSuffix,",
          "96:    wantStatus: 404,",
          "97:   },",
          "98:   {",
          "99:    hostname:   \"random4.\" + hostSuffix,",
          "100:    sni:        \"other-random4.\" + hostSuffix,",
          "101:    wantStatus: 421,",
          "102:   },",
          "103:   {",
          "104:    hostname:   \"random5.\" + hostSuffix,",
          "105:    sni:        \"a.random5.\" + hostSuffix,",
          "106:    wantStatus: 421,",
          "107:   },",
          "108:   {",
          "109:    hostname:   \"random6.\" + hostSuffix + \":9999\",",
          "110:    sni:        \"random6.\" + hostSuffix,",
          "111:    wantStatus: 200,",
          "112:   },",
          "113:  }",
          "115:  for _, tc := range cases {",
          "116:   t.Logf(\"Making request with hostname=%s, sni=%s\", tc.hostname, tc.sni)",
          "118:   res, ok := fx.HTTP.SecureRequestUntil(&e2e.HTTPSRequestOpts{",
          "119:    Host: tc.hostname,",
          "120:    TLSConfigOpts: []func(*tls.Config){",
          "121:     e2e.OptSetSNI(tc.sni),",
          "122:    },",
          "123:    Condition: e2e.HasStatusCode(tc.wantStatus),",
          "124:   })",
          "125:   require.Truef(t, ok, \"expected %d response code, got %d\", tc.wantStatus, res.StatusCode)",
          "126:  }",
          "127: }",
          "",
          "---------------"
        ],
        "test/e2e/ingress/ingress_test.go||test/e2e/ingress/ingress_test.go": [
          "File: test/e2e/ingress/ingress_test.go -> test/e2e/ingress/ingress_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:  . \"github.com/onsi/ginkgo\"",
          "22:  \"github.com/projectcontour/contour/test/e2e\"",
          "23: )",
          "25: func TestIngress(t *testing.T) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23:  networkingv1 \"k8s.io/api/networking/v1\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "33:   f = e2e.NewFramework(GinkgoT())",
          "34:  })",
          "36:  It(\"002-ingress-ensure-v1beta1\", func() {",
          "37:   testEnsureV1Beta1(f)",
          "38:  })",
          "39: })",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37:  It(\"001-tls-wildcard-host\", func() {",
          "38:   testTLSWildcardHost(f)",
          "39:  })",
          "46: func pathTypePtr(val networkingv1.PathType) *networkingv1.PathType {",
          "47:  return &val",
          "48: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c6484b7044eea02c28cb99ef7d34d6b956db375f",
      "candidate_info": {
        "commit_hash": "c6484b7044eea02c28cb99ef7d34d6b956db375f",
        "repo": "projectcontour/contour",
        "commit_url": "https://github.com/projectcontour/contour/commit/c6484b7044eea02c28cb99ef7d34d6b956db375f",
        "files": [
          "cmd/contour/serve.go",
          "internal/contour/metrics_test.go",
          "internal/contour/secret_test.go",
          "internal/dag/builder.go",
          "internal/dag/builder_test.go",
          "internal/dag/httpproxy_processor.go",
          "internal/dag/ingress_processor.go",
          "internal/dag/listener_processor.go",
          "internal/dag/policy.go",
          "internal/dag/status_test.go",
          "internal/featuretests/fallbackcert_test.go",
          "internal/featuretests/featuretests.go",
          "internal/featuretests/route_test.go"
        ],
        "message": "internal/dag: extract DAG processors from the main builder (#2847)\n\nExtracts the logic specific to processing HTTPProxy, Ingress\nAPIs into their own processors that are invoked by the DAG\nbuilder. Also extracts a listener processor to add HTTP/HTTPS\nlisteners after the other processors have run.\n\nSigned-off-by: Steve Kriss <krisss@vmware.com>",
        "before_after_code_files": [
          "cmd/contour/serve.go||cmd/contour/serve.go",
          "internal/contour/metrics_test.go||internal/contour/metrics_test.go",
          "internal/contour/secret_test.go||internal/contour/secret_test.go",
          "internal/dag/builder.go||internal/dag/builder.go",
          "internal/dag/builder_test.go||internal/dag/builder_test.go",
          "internal/dag/httpproxy_processor.go||internal/dag/httpproxy_processor.go",
          "internal/dag/ingress_processor.go||internal/dag/ingress_processor.go",
          "internal/dag/listener_processor.go||internal/dag/listener_processor.go",
          "internal/dag/policy.go||internal/dag/policy.go",
          "internal/dag/status_test.go||internal/dag/status_test.go",
          "internal/featuretests/fallbackcert_test.go||internal/featuretests/fallbackcert_test.go",
          "internal/featuretests/featuretests.go||internal/featuretests/featuretests.go",
          "internal/featuretests/route_test.go||internal/featuretests/route_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "cmd/contour/serve.go||cmd/contour/serve.go",
            "internal/dag/builder_test.go||internal/dag/builder_test.go",
            "internal/dag/httpproxy_processor.go||internal/dag/httpproxy_processor.go",
            "internal/dag/ingress_processor.go||internal/dag/ingress_processor.go",
            "internal/dag/status_test.go||internal/dag/status_test.go"
          ],
          "candidate": [
            "cmd/contour/serve.go||cmd/contour/serve.go",
            "internal/dag/builder_test.go||internal/dag/builder_test.go",
            "internal/dag/httpproxy_processor.go||internal/dag/httpproxy_processor.go",
            "internal/dag/ingress_processor.go||internal/dag/ingress_processor.go",
            "internal/dag/status_test.go||internal/dag/status_test.go"
          ]
        }
      },
      "candidate_diff": {
        "cmd/contour/serve.go||cmd/contour/serve.go": [
          "File: cmd/contour/serve.go -> cmd/contour/serve.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "222:   HoldoffMaxDelay: 500 * time.Millisecond,",
          "223:   Observer:        dag.ComposeObservers(contour.ObserversOf(resources)...),",
          "224:   Builder: dag.Builder{",
          "227:    Source: dag.KubernetesCache{",
          "228:     RootNamespaces: ctx.proxyRootNamespaces(),",
          "229:     IngressClass:   ctx.ingressClass,",
          "230:     FieldLogger:    log.WithField(\"context\", \"KubernetesCache\"),",
          "231:    },",
          "232:   },",
          "233:   FieldLogger: log.WithField(\"context\", \"contourEventHandler\"),",
          "234:  }",
          "237:  if fallbackCert != nil {",
          "238:   log.WithField(\"context\", \"fallback-certificate\").Infof(\"enabled fallback certificate with secret: %q\", fallbackCert)",
          "240:  }",
          "",
          "[Removed Lines]",
          "225:    FieldLogger:           log.WithField(\"context\", \"builder\"),",
          "226:    DisablePermitInsecure: ctx.DisablePermitInsecure,",
          "239:   eventHandler.Builder.FallbackCertificate = fallbackCert",
          "",
          "[Added Lines]",
          "225:    FieldLogger: log.WithField(\"context\", \"builder\"),",
          "231:    Processors: []dag.Processor{",
          "232:     &dag.IngressProcessor{},",
          "233:     &dag.HTTPProxyProcessor{",
          "234:      DisablePermitInsecure: ctx.DisablePermitInsecure,",
          "235:      FallbackCertificate:   fallbackCert,",
          "236:     },",
          "237:     &dag.ListenerProcessor{},",
          "238:    },",
          "",
          "---------------"
        ],
        "internal/contour/metrics_test.go||internal/contour/metrics_test.go": [
          "File: internal/contour/metrics_test.go -> internal/contour/metrics_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:      RootNamespaces: tc.rootNamespaces,",
          "46:      FieldLogger:    fixture.NewTestLogger(t),",
          "47:     },",
          "48:    }",
          "50:    for _, o := range tc.objs {",
          "51:     builder.Source.Insert(o)",
          "52:    }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "48:     Processors: []dag.Processor{",
          "49:      &dag.IngressProcessor{},",
          "50:      &dag.HTTPProxyProcessor{},",
          "51:      &dag.ListenerProcessor{},",
          "52:     },",
          "",
          "---------------"
        ],
        "internal/contour/secret_test.go||internal/contour/secret_test.go": [
          "File: internal/contour/secret_test.go -> internal/contour/secret_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "483:   Source: dag.KubernetesCache{",
          "484:    FieldLogger: fixture.NewTestLogger(t),",
          "485:   },",
          "486:  }",
          "488:  for _, o := range objs {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "486:   Processors: []dag.Processor{",
          "487:    &dag.IngressProcessor{},",
          "488:    &dag.HTTPProxyProcessor{},",
          "489:    &dag.ListenerProcessor{},",
          "490:   },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "498:   Source: dag.KubernetesCache{",
          "499:    FieldLogger: fixture.NewTestLogger(t),",
          "500:   },",
          "502:  }",
          "504:  for _, o := range objs {",
          "505:   builder.Source.Insert(o)",
          "506:  }",
          "",
          "[Removed Lines]",
          "501:   FallbackCertificate: fallbackCertificate,",
          "",
          "[Added Lines]",
          "506:   Processors: []dag.Processor{",
          "507:    &dag.IngressProcessor{},",
          "508:    &dag.HTTPProxyProcessor{",
          "509:     FallbackCertificate: fallbackCertificate,",
          "510:    },",
          "511:    &dag.ListenerProcessor{},",
          "512:   },",
          "",
          "---------------"
        ],
        "internal/dag/builder.go||internal/dag/builder.go": [
          "File: internal/dag/builder.go -> internal/dag/builder.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: package dag",
          "16: import (",
          "18:  \"fmt\"",
          "20:  \"strconv\"",
          "23:  v1 \"k8s.io/api/core/v1\"",
          "26:  \"k8s.io/apimachinery/pkg/types\"",
          "27:  \"k8s.io/apimachinery/pkg/util/intstr\"",
          "30:  \"github.com/projectcontour/contour/internal/annotation\"",
          "31:  \"github.com/projectcontour/contour/internal/k8s\"",
          "32:  \"github.com/sirupsen/logrus\"",
          "",
          "[Removed Lines]",
          "17:  \"errors\"",
          "19:  \"sort\"",
          "21:  \"strings\"",
          "24:  \"k8s.io/api/networking/v1beta1\"",
          "25:  \"k8s.io/apimachinery/pkg/api/equality\"",
          "29:  projcontour \"github.com/projectcontour/contour/apis/projectcontour/v1\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38:  Port      int32",
          "39: }",
          "42: type Builder struct {",
          "46:  Source KubernetesCache",
          "54:  virtualhosts       map[string]*VirtualHost",
          "55:  securevirtualhosts map[string]*SecureVirtualHost",
          "61:  StatusWriter",
          "62:  logrus.FieldLogger",
          "63: }",
          "66: func (b *Builder) Build() *DAG {",
          "67:  b.reset()",
          "79: }",
          "",
          "[Removed Lines]",
          "50:  DisablePermitInsecure bool",
          "52:  services map[RouteServiceName]*Service",
          "57:  orphaned map[types.NamespacedName]bool",
          "59:  FallbackCertificate *types.NamespacedName",
          "72:  b.computeSecureVirtualhosts()",
          "74:  b.computeIngresses()",
          "76:  b.computeHTTPProxies()",
          "78:  return b.buildDAG()",
          "",
          "[Added Lines]",
          "37: type Processor interface {",
          "39:  Run(builder *Builder)",
          "40: }",
          "50:  Processors []Processor",
          "52:  services           map[RouteServiceName]*Service",
          "55:  listeners          []*Listener",
          "66:  for _, p := range b.Processors {",
          "67:   p.Run(b)",
          "68:  }",
          "70:  var dag DAG",
          "72:  for i := range b.listeners {",
          "73:   dag.roots = append(dag.roots, b.listeners[i])",
          "74:  }",
          "76:  dag.statuses = b.statuses",
          "77:  return &dag",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "83:  b.services = make(map[RouteServiceName]*Service, len(b.services))",
          "84:  b.virtualhosts = make(map[string]*VirtualHost)",
          "85:  b.securevirtualhosts = make(map[string]*SecureVirtualHost)",
          "88:  b.statuses = make(map[types.NamespacedName]Status, len(b.statuses))",
          "89: }",
          "",
          "[Removed Lines]",
          "87:  b.orphaned = make(map[types.NamespacedName]bool, len(b.orphaned))",
          "",
          "[Added Lines]",
          "85:  b.listeners = []*Listener{}",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "189:  return svh",
          "190: }",
          "1031: func externalName(svc *v1.Service) string {",
          "1032:  if svc.Spec.Type != v1.ServiceTypeExternalName {",
          "1033:   return \"\"",
          "",
          "[Removed Lines]",
          "195: func (b *Builder) validHTTPProxies() []*projcontour.HTTPProxy {",
          "197:  var valid []*projcontour.HTTPProxy",
          "198:  fqdnHTTPProxies := make(map[string][]*projcontour.HTTPProxy)",
          "199:  for _, proxy := range b.Source.httpproxies {",
          "200:   if proxy.Spec.VirtualHost == nil {",
          "201:    valid = append(valid, proxy)",
          "202:    continue",
          "203:   }",
          "204:   fqdnHTTPProxies[proxy.Spec.VirtualHost.Fqdn] = append(fqdnHTTPProxies[proxy.Spec.VirtualHost.Fqdn], proxy)",
          "205:  }",
          "207:  for fqdn, proxies := range fqdnHTTPProxies {",
          "208:   switch len(proxies) {",
          "209:   case 1:",
          "210:    valid = append(valid, proxies[0])",
          "211:   default:",
          "213:    var conflicting []string",
          "214:    for _, proxy := range proxies {",
          "215:     conflicting = append(conflicting, proxy.Namespace+\"/\"+proxy.Name)",
          "216:    }",
          "217:    sort.Strings(conflicting) // sort for test stability",
          "218:    msg := fmt.Sprintf(\"fqdn %q is used in multiple HTTPProxies: %s\", fqdn, strings.Join(conflicting, \", \"))",
          "219:    for _, proxy := range proxies {",
          "220:     sw, commit := b.WithObject(proxy)",
          "221:     sw.WithValue(\"vhost\", fqdn).SetInvalid(msg)",
          "222:     commit()",
          "223:    }",
          "224:   }",
          "225:  }",
          "226:  return valid",
          "227: }",
          "231: func (b *Builder) computeSecureVirtualhosts() {",
          "232:  for _, ing := range b.Source.ingresses {",
          "233:   for _, tls := range ing.Spec.TLS {",
          "234:    secretName := k8s.NamespacedNameFrom(tls.SecretName, k8s.DefaultNamespace(ing.GetNamespace()))",
          "235:    sec, err := b.Source.LookupSecret(secretName, validSecret)",
          "236:    if err != nil {",
          "237:     b.WithError(err).",
          "238:      WithField(\"name\", ing.GetName()).",
          "239:      WithField(\"namespace\", ing.GetNamespace()).",
          "240:      WithField(\"secret\", secretName).",
          "241:      Error(\"unresolved secret reference\")",
          "242:     continue",
          "243:    }",
          "245:    if !b.Source.DelegationPermitted(secretName, ing.GetNamespace()) {",
          "246:     b.WithError(err).",
          "247:      WithField(\"name\", ing.GetName()).",
          "248:      WithField(\"namespace\", ing.GetNamespace()).",
          "249:      WithField(\"secret\", secretName).",
          "250:      Error(\"certificate delegation not permitted\")",
          "251:     continue",
          "252:    }",
          "257:    for _, host := range tls.Hosts {",
          "258:     svhost := b.lookupSecureVirtualHost(host)",
          "259:     svhost.Secret = sec",
          "260:     svhost.MinTLSVersion = annotation.MinTLSVersion(",
          "261:      annotation.CompatAnnotation(ing, \"tls-minimum-protocol-version\"))",
          "262:    }",
          "263:   }",
          "264:  }",
          "265: }",
          "267: func (b *Builder) computeIngresses() {",
          "269:  for _, ing := range b.Source.ingresses {",
          "272:   rules := rulesFromSpec(ing.Spec)",
          "273:   for _, rule := range rules {",
          "274:    b.computeIngressRule(ing, rule)",
          "275:   }",
          "276:  }",
          "277: }",
          "279: func (b *Builder) computeIngressRule(ing *v1beta1.Ingress, rule v1beta1.IngressRule) {",
          "280:  host := rule.Host",
          "281:  if strings.Contains(host, \"*\") {",
          "283:   return",
          "284:  }",
          "285:  if host == \"\" {",
          "287:   host = \"*\"",
          "288:  }",
          "289:  for _, httppath := range httppaths(rule) {",
          "290:   path := stringOrDefault(httppath.Path, \"/\")",
          "291:   be := httppath.Backend",
          "292:   m := types.NamespacedName{Name: be.ServiceName, Namespace: ing.Namespace}",
          "293:   s, err := b.lookupService(m, be.ServicePort)",
          "294:   if err != nil {",
          "295:    continue",
          "296:   }",
          "298:   r := route(ing, path, s)",
          "301:   if annotation.TLSRequired(ing) || annotation.HTTPAllowed(ing) {",
          "302:    b.lookupVirtualHost(host).addRoute(r)",
          "303:   }",
          "308:   svh, ok := b.securevirtualhosts[host]",
          "309:   if ok && host != \"*\" {",
          "310:    svh.addRoute(r)",
          "311:   }",
          "312:  }",
          "313: }",
          "315: func (b *Builder) computeHTTPProxies() {",
          "316:  for _, proxy := range b.validHTTPProxies() {",
          "317:   b.computeHTTPProxy(proxy)",
          "318:  }",
          "319: }",
          "321: func (b *Builder) computeHTTPProxy(proxy *projcontour.HTTPProxy) {",
          "322:  sw, commit := b.WithObject(proxy)",
          "323:  defer commit()",
          "325:  if proxy.Spec.VirtualHost == nil {",
          "327:   b.setOrphaned(proxy)",
          "328:   return",
          "329:  }",
          "332:  if !b.rootAllowed(proxy.Namespace) {",
          "333:   sw.SetInvalid(\"root HTTPProxy cannot be defined in this namespace\")",
          "334:   return",
          "335:  }",
          "337:  host := proxy.Spec.VirtualHost.Fqdn",
          "338:  if isBlank(host) {",
          "339:   sw.SetInvalid(\"Spec.VirtualHost.Fqdn must be specified\")",
          "340:   return",
          "341:  }",
          "342:  sw = sw.WithValue(\"vhost\", host)",
          "343:  if strings.Contains(host, \"*\") {",
          "344:   sw.SetInvalid(\"Spec.VirtualHost.Fqdn %q cannot use wildcards\", host)",
          "345:   return",
          "346:  }",
          "348:  var tlsEnabled bool",
          "349:  if tls := proxy.Spec.VirtualHost.TLS; tls != nil {",
          "350:   if !isBlank(tls.SecretName) && tls.Passthrough {",
          "351:    sw.SetInvalid(\"Spec.VirtualHost.TLS: both Passthrough and SecretName were specified\")",
          "352:    return",
          "353:   }",
          "354:   if isBlank(tls.SecretName) && !tls.Passthrough {",
          "355:    sw.SetInvalid(\"Spec.VirtualHost.TLS: neither Passthrough nor SecretName were specified\")",
          "356:    return",
          "357:   }",
          "358:   tlsEnabled = true",
          "361:   if !tls.Passthrough {",
          "362:    secretName := k8s.NamespacedNameFrom(tls.SecretName, k8s.DefaultNamespace(proxy.Namespace))",
          "363:    sec, err := b.Source.LookupSecret(secretName, validSecret)",
          "364:    if err != nil {",
          "365:     sw.SetInvalid(\"Spec.VirtualHost.TLS Secret %q is invalid: %s\", tls.SecretName, err)",
          "366:     return",
          "367:    }",
          "369:    if !b.Source.DelegationPermitted(secretName, proxy.Namespace) {",
          "370:     sw.SetInvalid(\"Spec.VirtualHost.TLS Secret %q certificate delegation not permitted\", tls.SecretName)",
          "371:     return",
          "372:    }",
          "374:    svhost := b.lookupSecureVirtualHost(host)",
          "375:    svhost.Secret = sec",
          "376:    svhost.MinTLSVersion = annotation.MinTLSVersion(tls.MinimumProtocolVersion)",
          "379:    if tls.EnableFallbackCertificate && tls.ClientValidation != nil {",
          "380:     sw.SetInvalid(\"Spec.Virtualhost.TLS fallback & client validation are incompatible together\")",
          "381:     return",
          "382:    }",
          "385:    if tls.EnableFallbackCertificate {",
          "386:     if b.FallbackCertificate == nil {",
          "387:      sw.SetInvalid(\"Spec.Virtualhost.TLS enabled fallback but the fallback Certificate Secret is not configured in Contour configuration file\")",
          "388:      return",
          "389:     }",
          "391:     sec, err = b.Source.LookupSecret(*b.FallbackCertificate, validSecret)",
          "392:     if err != nil {",
          "393:      sw.SetInvalid(\"Spec.Virtualhost.TLS Secret %q fallback certificate is invalid: %s\", b.FallbackCertificate, err)",
          "394:      return",
          "395:     }",
          "397:     if !b.Source.DelegationPermitted(*b.FallbackCertificate, proxy.Namespace) {",
          "398:      sw.SetInvalid(\"Spec.VirtualHost.TLS fallback Secret %q is not configured for certificate delegation\", b.FallbackCertificate)",
          "399:      return",
          "400:     }",
          "402:     svhost.FallbackCertificate = sec",
          "403:    }",
          "406:    if tls.ClientValidation != nil {",
          "407:     dv, err := b.lookupDownstreamValidation(tls.ClientValidation, proxy.Namespace)",
          "408:     if err != nil {",
          "409:      sw.SetInvalid(\"Spec.VirtualHost.TLS client validation is invalid: %s\", err)",
          "410:      return",
          "411:     }",
          "412:     svhost.DownstreamValidation = dv",
          "413:    }",
          "414:   } else if tls.ClientValidation != nil {",
          "415:    sw.SetInvalid(\"Spec.VirtualHost.TLS passthrough cannot be combined with tls.clientValidation\")",
          "416:    return",
          "417:   }",
          "418:  }",
          "420:  if proxy.Spec.TCPProxy != nil {",
          "421:   if !tlsEnabled {",
          "422:    sw.SetInvalid(\"Spec.TCPProxy requires that either Spec.TLS.Passthrough or Spec.TLS.SecretName be set\")",
          "423:    return",
          "424:   }",
          "425:   if !b.processHTTPProxyTCPProxy(sw, proxy, nil, host) {",
          "426:    return",
          "427:   }",
          "428:  }",
          "430:  routes := b.computeRoutes(sw, proxy, nil, nil, tlsEnabled)",
          "431:  insecure := b.lookupVirtualHost(host)",
          "432:  addRoutes(insecure, routes)",
          "436:  if tlsEnabled && proxy.Spec.TCPProxy == nil {",
          "437:   secure := b.lookupSecureVirtualHost(host)",
          "438:   addRoutes(secure, routes)",
          "439:  }",
          "440: }",
          "442: type vhost interface {",
          "443:  addRoute(*Route)",
          "444: }",
          "447: func addRoutes(vhost vhost, routes []*Route) {",
          "448:  for _, route := range routes {",
          "449:   vhost.addRoute(route)",
          "450:  }",
          "451: }",
          "468: func expandPrefixMatches(routes []*Route) []*Route {",
          "469:  prefixedRoutes := map[string][]*Route{}",
          "471:  expandedRoutes := []*Route{}",
          "474:  for _, r := range routes {",
          "476:   if !r.HasPathPrefix() {",
          "477:    expandedRoutes = append(expandedRoutes, r)",
          "478:   }",
          "480:   routingPrefix := r.PathMatchCondition.(*PrefixMatchCondition).Prefix",
          "482:   if routingPrefix != \"/\" {",
          "483:    routingPrefix = strings.TrimRight(routingPrefix, \"/\")",
          "484:   }",
          "486:   prefixedRoutes[routingPrefix] = append(prefixedRoutes[routingPrefix], r)",
          "487:  }",
          "489:  for prefix, routes := range prefixedRoutes {",
          "493:   expandedRoutes = append(expandedRoutes, routes...)",
          "495:   switch len(routes) {",
          "496:   case 1:",
          "498:    if len(routes[0].PrefixRewrite) == 0 {",
          "499:     continue",
          "500:    }",
          "502:    routingPrefix := routes[0].PathMatchCondition.(*PrefixMatchCondition).Prefix",
          "505:    if routingPrefix == \"/\" {",
          "506:     continue",
          "507:    }",
          "510:    newRoute := *routes[0]",
          "513:    routes[0].PrefixRewrite = strings.TrimRight(routes[0].PrefixRewrite, \"/\")",
          "514:    routes[0].PathMatchCondition = &PrefixMatchCondition{Prefix: prefix}",
          "516:    newRoute.PrefixRewrite = routes[0].PrefixRewrite + \"/\"",
          "517:    newRoute.PathMatchCondition = &PrefixMatchCondition{Prefix: prefix + \"/\"}",
          "523:    if len(routes[0].PrefixRewrite) == 0 {",
          "524:     routes[0].PrefixRewrite = \"/\"",
          "525:    }",
          "527:    expandedRoutes = append(expandedRoutes, &newRoute)",
          "528:   case 2:",
          "533:    continue",
          "534:   default:",
          "537:   }",
          "539:  }",
          "541:  return expandedRoutes",
          "542: }",
          "544: func getProtocol(service projcontour.Service, s *Service) (string, error) {",
          "546:  var protocol string",
          "547:  if service.Protocol != nil {",
          "548:   protocol = *service.Protocol",
          "549:   switch protocol {",
          "550:   case \"h2c\", \"h2\", \"tls\":",
          "551:   default:",
          "552:    return \"\", fmt.Errorf(\"unsupported protocol: %v\", protocol)",
          "553:   }",
          "554:  } else {",
          "555:   protocol = s.Protocol",
          "556:  }",
          "558:  return protocol, nil",
          "559: }",
          "561: func (b *Builder) computeRoutes(sw *ObjectStatusWriter, proxy *projcontour.HTTPProxy, conditions []projcontour.MatchCondition, visited []*projcontour.HTTPProxy, enforceTLS bool) []*Route {",
          "562:  for _, v := range visited {",
          "564:   var path []string",
          "565:   for _, vir := range visited {",
          "566:    path = append(path, fmt.Sprintf(\"%s/%s\", vir.Namespace, vir.Name))",
          "567:   }",
          "568:   if v.Name == proxy.Name && v.Namespace == proxy.Namespace {",
          "569:    path = append(path, fmt.Sprintf(\"%s/%s\", proxy.Namespace, proxy.Name))",
          "570:    sw.SetInvalid(\"include creates a delegation cycle: %s\", strings.Join(path, \" -> \"))",
          "571:    return nil",
          "572:   }",
          "573:  }",
          "575:  visited = append(visited, proxy)",
          "576:  var routes []*Route",
          "579:  if includeMatchConditionsIdentical(proxy.Spec.Includes) {",
          "580:   sw.SetInvalid(\"duplicate conditions defined on an include\")",
          "581:   return nil",
          "582:  }",
          "585:  for _, include := range proxy.Spec.Includes {",
          "586:   namespace := include.Namespace",
          "587:   if namespace == \"\" {",
          "588:    namespace = proxy.Namespace",
          "589:   }",
          "591:   delegate, ok := b.Source.httpproxies[types.NamespacedName{Name: include.Name, Namespace: namespace}]",
          "592:   if !ok {",
          "593:    sw.SetInvalid(\"include %s/%s not found\", namespace, include.Name)",
          "594:    return nil",
          "595:   }",
          "596:   if delegate.Spec.VirtualHost != nil {",
          "597:    sw.SetInvalid(\"root httpproxy cannot delegate to another root httpproxy\")",
          "598:    return nil",
          "599:   }",
          "601:   if err := pathMatchConditionsValid(include.Conditions); err != nil {",
          "602:    sw.SetInvalid(\"include: %s\", err)",
          "603:    return nil",
          "604:   }",
          "606:   sw, commit := b.WithObject(delegate)",
          "607:   routes = append(routes, b.computeRoutes(sw, delegate, append(conditions, include.Conditions...), visited, enforceTLS)...)",
          "608:   commit()",
          "611:   delete(b.orphaned, types.NamespacedName{Name: delegate.Name, Namespace: delegate.Namespace})",
          "612:  }",
          "614:  for _, route := range proxy.Spec.Routes {",
          "615:   if err := pathMatchConditionsValid(route.Conditions); err != nil {",
          "616:    sw.SetInvalid(\"route: %s\", err)",
          "617:    return nil",
          "618:   }",
          "620:   conds := append(conditions, route.Conditions...)",
          "623:   if err := headerMatchConditionsValid(conds); err != nil {",
          "624:    sw.SetInvalid(err.Error())",
          "625:    return nil",
          "626:   }",
          "628:   reqHP, err := headersPolicy(route.RequestHeadersPolicy, true /* allow Host */)",
          "629:   if err != nil {",
          "630:    sw.SetInvalid(err.Error())",
          "631:    return nil",
          "632:   }",
          "634:   respHP, err := headersPolicy(route.ResponseHeadersPolicy, false /* disallow Host */)",
          "635:   if err != nil {",
          "636:    sw.SetInvalid(err.Error())",
          "637:    return nil",
          "638:   }",
          "640:   if len(route.Services) < 1 {",
          "641:    sw.SetInvalid(\"route.services must have at least one entry\")",
          "642:    return nil",
          "643:   }",
          "645:   r := &Route{",
          "646:    PathMatchCondition:    mergePathMatchConditions(conds),",
          "647:    HeaderMatchConditions: mergeHeaderMatchConditions(conds),",
          "648:    Websocket:             route.EnableWebsockets,",
          "649:    HTTPSUpgrade:          routeEnforceTLS(enforceTLS, route.PermitInsecure && !b.DisablePermitInsecure),",
          "650:    TimeoutPolicy:         timeoutPolicy(route.TimeoutPolicy),",
          "651:    RetryPolicy:           retryPolicy(route.RetryPolicy),",
          "652:    RequestHeadersPolicy:  reqHP,",
          "653:    ResponseHeadersPolicy: respHP,",
          "654:   }",
          "656:   if len(route.GetPrefixReplacements()) > 0 {",
          "657:    if !r.HasPathPrefix() {",
          "658:     sw.SetInvalid(\"cannot specify prefix replacements without a prefix condition\")",
          "659:     return nil",
          "660:    }",
          "662:    if err := prefixReplacementsAreValid(route.GetPrefixReplacements()); err != nil {",
          "663:     sw.SetInvalid(err.Error())",
          "664:     return nil",
          "665:    }",
          "671:    routingPrefix := r.PathMatchCondition.(*PrefixMatchCondition).Prefix",
          "674:    for _, prefix := range route.GetPrefixReplacements() {",
          "675:     if len(prefix.Prefix) > 0 && routingPrefix == prefix.Prefix {",
          "676:      r.PrefixRewrite = prefix.Replacement",
          "677:      break",
          "678:     }",
          "679:    }",
          "682:    if len(r.PrefixRewrite) == 0 {",
          "683:     for _, prefix := range route.GetPrefixReplacements() {",
          "684:      if len(prefix.Prefix) == 0 {",
          "685:       r.PrefixRewrite = prefix.Replacement",
          "686:       break",
          "687:      }",
          "688:     }",
          "689:    }",
          "691:   }",
          "693:   for _, service := range route.Services {",
          "694:    if service.Port < 1 || service.Port > 65535 {",
          "695:     sw.SetInvalid(\"service %q: port must be in the range 1-65535\", service.Name)",
          "696:     return nil",
          "697:    }",
          "698:    m := types.NamespacedName{Name: service.Name, Namespace: proxy.Namespace}",
          "699:    s, err := b.lookupService(m, intstr.FromInt(service.Port))",
          "700:    if err != nil {",
          "701:     sw.SetInvalid(\"Spec.Routes unresolved service reference: %s\", err)",
          "702:     return nil",
          "703:    }",
          "706:    protocol, err := getProtocol(service, s)",
          "707:    if err != nil {",
          "708:     sw.SetInvalid(err.Error())",
          "709:     return nil",
          "710:    }",
          "712:    var uv *PeerValidationContext",
          "713:    if protocol == \"tls\" || protocol == \"h2\" {",
          "715:     uv, err = b.lookupUpstreamValidation(service.UpstreamValidation, proxy.Namespace)",
          "716:     if err != nil {",
          "717:      sw.SetInvalid(\"Service [%s:%d] TLS upstream validation policy error: %s\",",
          "718:       service.Name, service.Port, err)",
          "719:      return nil",
          "720:     }",
          "721:    }",
          "723:    reqHP, err := headersPolicy(service.RequestHeadersPolicy, true /* allow Host */)",
          "724:    if err != nil {",
          "725:     sw.SetInvalid(err.Error())",
          "726:     return nil",
          "727:    }",
          "729:    respHP, err := headersPolicy(service.ResponseHeadersPolicy, false /* disallow Host */)",
          "730:    if err != nil {",
          "731:     sw.SetInvalid(err.Error())",
          "732:     return nil",
          "733:    }",
          "735:    c := &Cluster{",
          "736:     Upstream:              s,",
          "737:     LoadBalancerPolicy:    loadBalancerPolicy(route.LoadBalancerPolicy),",
          "738:     Weight:                uint32(service.Weight),",
          "739:     HTTPHealthCheckPolicy: httpHealthCheckPolicy(route.HealthCheckPolicy),",
          "740:     UpstreamValidation:    uv,",
          "741:     RequestHeadersPolicy:  reqHP,",
          "742:     ResponseHeadersPolicy: respHP,",
          "743:     Protocol:              protocol,",
          "744:     SNI:                   determineSNI(r.RequestHeadersPolicy, reqHP, s),",
          "745:    }",
          "746:    if service.Mirror && r.MirrorPolicy != nil {",
          "747:     sw.SetInvalid(\"only one service per route may be nominated as mirror\")",
          "748:     return nil",
          "749:    }",
          "750:    if service.Mirror {",
          "751:     r.MirrorPolicy = &MirrorPolicy{",
          "752:      Cluster: c,",
          "753:     }",
          "754:    } else {",
          "755:     r.Clusters = append(r.Clusters, c)",
          "756:    }",
          "757:   }",
          "758:   routes = append(routes, r)",
          "759:  }",
          "761:  routes = expandPrefixMatches(routes)",
          "763:  sw.SetValid()",
          "764:  return routes",
          "765: }",
          "770: func determineSNI(routeRequestHeaders *HeadersPolicy, clusterRequestHeaders *HeadersPolicy, service *Service) string {",
          "773:  if clusterRequestHeaders != nil {",
          "774:   if clusterRequestHeaders.HostRewrite != \"\" {",
          "775:    return clusterRequestHeaders.HostRewrite",
          "776:   }",
          "777:  }",
          "780:  if routeRequestHeaders != nil {",
          "781:   if routeRequestHeaders.HostRewrite != \"\" {",
          "782:    return routeRequestHeaders.HostRewrite",
          "783:   }",
          "784:  }",
          "786:  return service.ExternalName",
          "787: }",
          "789: func escapeHeaderValue(value string) string {",
          "792:  return strings.Replace(value, \"%\", \"%%\", -1)",
          "793: }",
          "795: func includeMatchConditionsIdentical(includes []projcontour.Include) bool {",
          "796:  j := 0",
          "797:  for i := 1; i < len(includes); i++ {",
          "799:   for _, cA := range includes[i].Conditions {",
          "800:    for _, cB := range includes[j].Conditions {",
          "801:     if (cA.Prefix == cB.Prefix) && equality.Semantic.DeepEqual(cA.Header, cB.Header) {",
          "802:      return true",
          "803:     }",
          "804:    }",
          "805:   }",
          "806:   j++",
          "807:  }",
          "808:  return false",
          "809: }",
          "812: func (b *Builder) buildDAG() *DAG {",
          "813:  var dag DAG",
          "815:  http := b.buildHTTPListener()",
          "816:  if len(http.VirtualHosts) > 0 {",
          "817:   dag.roots = append(dag.roots, http)",
          "818:  }",
          "820:  https := b.buildHTTPSListener()",
          "821:  if len(https.VirtualHosts) > 0 {",
          "822:   dag.roots = append(dag.roots, https)",
          "823:  }",
          "825:  for meta := range b.orphaned {",
          "826:   proxy, ok := b.Source.httpproxies[meta]",
          "827:   if ok {",
          "828:    sw, commit := b.WithObject(proxy)",
          "829:    sw.WithValue(\"status\", k8s.StatusOrphaned).",
          "830:     WithValue(\"description\", \"this HTTPProxy is not part of a delegation chain from a root HTTPProxy\")",
          "831:    commit()",
          "832:   }",
          "833:  }",
          "834:  dag.statuses = b.statuses",
          "835:  return &dag",
          "836: }",
          "841: func (b *Builder) buildHTTPListener() *Listener {",
          "842:  var virtualhosts = make([]Vertex, 0, len(b.virtualhosts))",
          "844:  for _, vh := range b.virtualhosts {",
          "845:   if vh.Valid() {",
          "846:    virtualhosts = append(virtualhosts, vh)",
          "847:   }",
          "848:  }",
          "849:  sort.SliceStable(virtualhosts, func(i, j int) bool {",
          "850:   return virtualhosts[i].(*VirtualHost).Name < virtualhosts[j].(*VirtualHost).Name",
          "851:  })",
          "852:  return &Listener{",
          "853:   Port:         80,",
          "854:   VirtualHosts: virtualhosts,",
          "855:  }",
          "856: }",
          "861: func (b *Builder) buildHTTPSListener() *Listener {",
          "862:  var virtualhosts = make([]Vertex, 0, len(b.securevirtualhosts))",
          "863:  for _, svh := range b.securevirtualhosts {",
          "864:   if svh.Valid() {",
          "865:    virtualhosts = append(virtualhosts, svh)",
          "866:   }",
          "867:  }",
          "868:  sort.SliceStable(virtualhosts, func(i, j int) bool {",
          "869:   return virtualhosts[i].(*SecureVirtualHost).Name < virtualhosts[j].(*SecureVirtualHost).Name",
          "870:  })",
          "871:  return &Listener{",
          "872:   Port:         443,",
          "873:   VirtualHosts: virtualhosts,",
          "874:  }",
          "875: }",
          "878: func (b *Builder) setOrphaned(obj k8s.Object) {",
          "879:  m := types.NamespacedName{",
          "880:   Name:      obj.GetObjectMeta().GetName(),",
          "881:   Namespace: obj.GetObjectMeta().GetNamespace(),",
          "882:  }",
          "883:  b.orphaned[m] = true",
          "884: }",
          "887: func (b *Builder) rootAllowed(namespace string) bool {",
          "888:  if len(b.Source.RootNamespaces) == 0 {",
          "889:   return true",
          "890:  }",
          "891:  for _, ns := range b.Source.RootNamespaces {",
          "892:   if ns == namespace {",
          "893:    return true",
          "894:   }",
          "895:  }",
          "896:  return false",
          "897: }",
          "899: func (b *Builder) lookupUpstreamValidation(uv *projcontour.UpstreamValidation, namespace string) (*PeerValidationContext, error) {",
          "900:  if uv == nil {",
          "902:   return nil, nil",
          "903:  }",
          "905:  secretName := types.NamespacedName{Name: uv.CACertificate, Namespace: namespace}",
          "906:  cacert, err := b.Source.LookupSecret(secretName, validCA)",
          "907:  if err != nil {",
          "909:   return nil, fmt.Errorf(\"invalid CA Secret %q: %s\", secretName, err)",
          "910:  }",
          "912:  if uv.SubjectName == \"\" {",
          "914:   return nil, errors.New(\"missing subject alternative name\")",
          "915:  }",
          "917:  return &PeerValidationContext{",
          "918:   CACertificate: cacert,",
          "919:   SubjectName:   uv.SubjectName,",
          "920:  }, nil",
          "921: }",
          "923: func (b *Builder) lookupDownstreamValidation(vc *projcontour.DownstreamValidation, namespace string) (*PeerValidationContext, error) {",
          "924:  secretName := types.NamespacedName{Name: vc.CACertificate, Namespace: namespace}",
          "925:  cacert, err := b.Source.LookupSecret(secretName, validCA)",
          "926:  if err != nil {",
          "928:   return nil, fmt.Errorf(\"invalid CA Secret %q: %s\", secretName, err)",
          "929:  }",
          "931:  return &PeerValidationContext{",
          "932:   CACertificate: cacert,",
          "933:  }, nil",
          "934: }",
          "940: func (b *Builder) processHTTPProxyTCPProxy(sw *ObjectStatusWriter, httpproxy *projcontour.HTTPProxy, visited []*projcontour.HTTPProxy, host string) bool {",
          "941:  tcpproxy := httpproxy.Spec.TCPProxy",
          "942:  if tcpproxy == nil {",
          "944:   return true",
          "945:  }",
          "947:  visited = append(visited, httpproxy)",
          "951:  tcpProxyInclude := tcpproxy.Include",
          "952:  if tcpproxy.Include == nil {",
          "953:   tcpProxyInclude = tcpproxy.IncludesDeprecated",
          "954:  }",
          "956:  if len(tcpproxy.Services) > 0 && tcpProxyInclude != nil {",
          "957:   sw.SetInvalid(\"tcpproxy: cannot specify services and include in the same httpproxy\")",
          "958:   return false",
          "959:  }",
          "961:  if len(tcpproxy.Services) > 0 {",
          "962:   var proxy TCPProxy",
          "963:   for _, service := range httpproxy.Spec.TCPProxy.Services {",
          "964:    m := types.NamespacedName{Name: service.Name, Namespace: httpproxy.Namespace}",
          "965:    s, err := b.lookupService(m, intstr.FromInt(service.Port))",
          "966:    if err != nil {",
          "967:     sw.SetInvalid(\"Spec.TCPProxy unresolved service reference: %s\", err)",
          "968:     return false",
          "969:    }",
          "970:    proxy.Clusters = append(proxy.Clusters, &Cluster{",
          "971:     Upstream:             s,",
          "972:     Protocol:             s.Protocol,",
          "973:     LoadBalancerPolicy:   loadBalancerPolicy(tcpproxy.LoadBalancerPolicy),",
          "974:     TCPHealthCheckPolicy: tcpHealthCheckPolicy(tcpproxy.HealthCheckPolicy),",
          "975:    })",
          "976:   }",
          "977:   b.lookupSecureVirtualHost(host).TCPProxy = &proxy",
          "978:   return true",
          "979:  }",
          "981:  if tcpProxyInclude == nil {",
          "983:   sw.SetInvalid(\"tcpproxy: either services or inclusion must be specified\")",
          "984:   return false",
          "985:  }",
          "987:  namespace := tcpProxyInclude.Namespace",
          "988:  if namespace == \"\" {",
          "990:   namespace = httpproxy.Namespace",
          "991:  }",
          "993:  m := types.NamespacedName{Name: tcpProxyInclude.Name, Namespace: namespace}",
          "994:  dest, ok := b.Source.httpproxies[m]",
          "995:  if !ok {",
          "996:   sw.SetInvalid(\"tcpproxy: include %s/%s not found\", m.Namespace, m.Name)",
          "997:   return false",
          "998:  }",
          "1000:  if dest.Spec.VirtualHost != nil {",
          "1001:   sw.SetInvalid(\"root httpproxy cannot delegate to another root httpproxy\")",
          "1002:   return false",
          "1003:  }",
          "1006:  delete(b.orphaned, k8s.NamespacedNameOf(dest))",
          "1009:  var path []string",
          "1010:  for _, hp := range visited {",
          "1011:   path = append(path, fmt.Sprintf(\"%s/%s\", hp.Namespace, hp.Name))",
          "1012:  }",
          "1013:  for _, hp := range visited {",
          "1014:   if dest.Name == hp.Name && dest.Namespace == hp.Namespace {",
          "1015:    path = append(path, fmt.Sprintf(\"%s/%s\", dest.Namespace, dest.Name))",
          "1016:    sw.SetInvalid(\"tcpproxy include creates a cycle: %s\", strings.Join(path, \" -> \"))",
          "1017:    return false",
          "1018:   }",
          "1019:  }",
          "1022:  sw, commit := sw.WithObject(dest)",
          "1023:  defer commit()",
          "1024:  ok = b.processHTTPProxyTCPProxy(sw, dest, visited, host)",
          "1025:  if ok {",
          "1026:   sw.SetValid()",
          "1027:  }",
          "1028:  return ok",
          "1029: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1035:  return svc.Spec.ExternalName",
          "1036: }",
          "1102: func validSecret(s *v1.Secret) error {",
          "1103:  if s.Type != v1.SecretTypeTLS {",
          "",
          "[Removed Lines]",
          "1039: func route(ingress *v1beta1.Ingress, path string, service *Service) *Route {",
          "1040:  wr := annotation.WebsocketRoutes(ingress)",
          "1041:  r := &Route{",
          "1042:   HTTPSUpgrade:  annotation.TLSRequired(ingress),",
          "1043:   Websocket:     wr[path],",
          "1044:   TimeoutPolicy: ingressTimeoutPolicy(ingress),",
          "1045:   RetryPolicy:   ingressRetryPolicy(ingress),",
          "1046:   Clusters: []*Cluster{{",
          "1047:    Upstream: service,",
          "1048:    Protocol: service.Protocol,",
          "1049:   }},",
          "1050:  }",
          "1052:  if strings.ContainsAny(path, \"^+*[]%\") {",
          "1054:   r.PathMatchCondition = &RegexMatchCondition{Regex: path}",
          "1055:   return r",
          "1056:  }",
          "1058:  r.PathMatchCondition = &PrefixMatchCondition{Prefix: path}",
          "1059:  return r",
          "1060: }",
          "1063: func isBlank(s string) bool {",
          "1064:  return len(strings.TrimSpace(s)) == 0",
          "1065: }",
          "1067: func stringOrDefault(s, def string) string {",
          "1068:  if s == \"\" {",
          "1069:   return def",
          "1070:  }",
          "1071:  return s",
          "1072: }",
          "1076: func rulesFromSpec(spec v1beta1.IngressSpec) []v1beta1.IngressRule {",
          "1077:  rules := spec.Rules",
          "1078:  if backend := spec.Backend; backend != nil {",
          "1079:   rule := defaultBackendRule(backend)",
          "1080:   rules = append(rules, rule)",
          "1081:  }",
          "1082:  return rules",
          "1083: }",
          "1086: func defaultBackendRule(be *v1beta1.IngressBackend) v1beta1.IngressRule {",
          "1087:  return v1beta1.IngressRule{",
          "1088:   IngressRuleValue: v1beta1.IngressRuleValue{",
          "1089:    HTTP: &v1beta1.HTTPIngressRuleValue{",
          "1090:     Paths: []v1beta1.HTTPIngressPath{{",
          "1091:      Backend: v1beta1.IngressBackend{",
          "1092:       ServiceName: be.ServiceName,",
          "1093:       ServicePort: be.ServicePort,",
          "1094:      },",
          "1095:     }},",
          "1096:    },",
          "1097:   },",
          "1098:  }",
          "1099: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1115:  return nil",
          "1116: }",
          "",
          "[Removed Lines]",
          "1118: func validCA(s *v1.Secret) error {",
          "1119:  if len(s.Data[CACertificateKey]) == 0 {",
          "1120:   return fmt.Errorf(\"empty %q key\", CACertificateKey)",
          "1121:  }",
          "1123:  return nil",
          "1124: }",
          "1127: func routeEnforceTLS(enforceTLS, permitInsecure bool) bool {",
          "1128:  return enforceTLS && !permitInsecure",
          "1129: }",
          "1134: func httppaths(rule v1beta1.IngressRule) []v1beta1.HTTPIngressPath {",
          "1135:  if rule.IngressRuleValue.HTTP == nil {",
          "1137:   return nil",
          "1138:  }",
          "1139:  return rule.IngressRuleValue.HTTP.Paths",
          "1140: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "internal/dag/builder_test.go||internal/dag/builder_test.go": [
          "File: internal/dag/builder_test.go -> internal/dag/builder_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "6162:  for name, tc := range tests {",
          "6163:   t.Run(name, func(t *testing.T) {",
          "6164:    builder := Builder{",
          "6171:     Source: KubernetesCache{",
          "6172:      FieldLogger: fixture.NewTestLogger(t),",
          "6173:     },",
          "6174:    }",
          "6175:    for _, o := range tc.objs {",
          "6176:     builder.Source.Insert(o)",
          "6177:    }",
          "",
          "[Removed Lines]",
          "6165:     FieldLogger:           fixture.NewTestLogger(t),",
          "6166:     DisablePermitInsecure: tc.disablePermitInsecure,",
          "6167:     FallbackCertificate: &types.NamespacedName{",
          "6168:      Name:      tc.fallbackCertificateName,",
          "6169:      Namespace: tc.fallbackCertificateNamespace,",
          "6170:     },",
          "",
          "[Added Lines]",
          "6165:     FieldLogger: fixture.NewTestLogger(t),",
          "6169:     Processors: []Processor{",
          "6170:      &IngressProcessor{},",
          "6171:      &HTTPProxyProcessor{",
          "6172:       DisablePermitInsecure: tc.disablePermitInsecure,",
          "6173:       FallbackCertificate: &types.NamespacedName{",
          "6174:        Name:      tc.fallbackCertificateName,",
          "6175:        Namespace: tc.fallbackCertificateNamespace,",
          "6176:       },",
          "6177:      },",
          "6178:      &ListenerProcessor{},",
          "6179:     },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6409:      RootNamespaces: tc.rootNamespaces,",
          "6410:      FieldLogger:    fixture.NewTestLogger(t),",
          "6411:     },",
          "6412:    }",
          "6414:    for _, o := range tc.objs {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6419:     Processors: []Processor{",
          "6420:      &IngressProcessor{},",
          "6421:      &HTTPProxyProcessor{},",
          "6422:      &ListenerProcessor{},",
          "6423:     },",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6704:  }",
          "6705: }",
          "6707: func routes(routes ...*Route) map[string]*Route {",
          "6708:  if len(routes) == 0 {",
          "6709:   return nil",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6719: func TestBuilderRunsProcessorsInOrder(t *testing.T) {",
          "6720:  var got []string",
          "6722:  b := Builder{",
          "6723:   Processors: []Processor{",
          "6724:    &pluggableProcessor{runFunc: func(_ *Builder) { got = append(got, \"foo\") }},",
          "6725:    &pluggableProcessor{runFunc: func(_ *Builder) { got = append(got, \"bar\") }},",
          "6726:    &pluggableProcessor{runFunc: func(_ *Builder) { got = append(got, \"baz\") }},",
          "6727:    &pluggableProcessor{runFunc: func(_ *Builder) { got = append(got, \"abc\") }},",
          "6728:    &pluggableProcessor{runFunc: func(_ *Builder) { got = append(got, \"def\") }},",
          "6729:   },",
          "6730:  }",
          "6732:  b.Build()",
          "6734:  assert.Equal(t, []string{\"foo\", \"bar\", \"baz\", \"abc\", \"def\"}, got)",
          "6735: }",
          "6737: type pluggableProcessor struct {",
          "6738:  runFunc func(builder *Builder)",
          "6739: }",
          "6741: func (p *pluggableProcessor) Run(builder *Builder) {",
          "6742:  p.runFunc(builder)",
          "6743: }",
          "",
          "---------------"
        ],
        "internal/dag/httpproxy_processor.go||internal/dag/httpproxy_processor.go": [
          "File: internal/dag/httpproxy_processor.go -> internal/dag/httpproxy_processor.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: package dag",
          "16: import (",
          "17:  \"errors\"",
          "18:  \"fmt\"",
          "19:  \"sort\"",
          "20:  \"strings\"",
          "22:  projcontour \"github.com/projectcontour/contour/apis/projectcontour/v1\"",
          "23:  \"github.com/projectcontour/contour/internal/annotation\"",
          "24:  \"github.com/projectcontour/contour/internal/k8s\"",
          "25:  v1 \"k8s.io/api/core/v1\"",
          "26:  \"k8s.io/apimachinery/pkg/api/equality\"",
          "27:  \"k8s.io/apimachinery/pkg/types\"",
          "28:  \"k8s.io/apimachinery/pkg/util/intstr\"",
          "29: )",
          "33: type HTTPProxyProcessor struct {",
          "34:  builder  *Builder",
          "35:  orphaned map[types.NamespacedName]bool",
          "39:  DisablePermitInsecure bool",
          "44:  FallbackCertificate *types.NamespacedName",
          "45: }",
          "49: func (p *HTTPProxyProcessor) Run(builder *Builder) {",
          "50:  p.builder = builder",
          "51:  p.orphaned = make(map[types.NamespacedName]bool, len(p.orphaned))",
          "54:  defer func() {",
          "55:   p.builder = nil",
          "56:   p.orphaned = nil",
          "57:  }()",
          "59:  p.computeHTTPProxies()",
          "61:  for meta := range p.orphaned {",
          "62:   proxy, ok := p.builder.Source.httpproxies[meta]",
          "63:   if ok {",
          "64:    sw, commit := p.builder.WithObject(proxy)",
          "65:    sw.WithValue(\"status\", k8s.StatusOrphaned).",
          "66:     WithValue(\"description\", \"this HTTPProxy is not part of a delegation chain from a root HTTPProxy\")",
          "67:    commit()",
          "68:   }",
          "69:  }",
          "70: }",
          "72: func (p *HTTPProxyProcessor) computeHTTPProxies() {",
          "73:  for _, proxy := range p.validHTTPProxies() {",
          "74:   p.computeHTTPProxy(proxy)",
          "75:  }",
          "76: }",
          "78: func (p *HTTPProxyProcessor) computeHTTPProxy(proxy *projcontour.HTTPProxy) {",
          "79:  sw, commit := p.builder.WithObject(proxy)",
          "80:  defer commit()",
          "82:  if proxy.Spec.VirtualHost == nil {",
          "84:   p.setOrphaned(proxy)",
          "85:   return",
          "86:  }",
          "89:  if !p.rootAllowed(proxy.Namespace) {",
          "90:   sw.SetInvalid(\"root HTTPProxy cannot be defined in this namespace\")",
          "91:   return",
          "92:  }",
          "94:  host := proxy.Spec.VirtualHost.Fqdn",
          "95:  if isBlank(host) {",
          "96:   sw.SetInvalid(\"Spec.VirtualHost.Fqdn must be specified\")",
          "97:   return",
          "98:  }",
          "99:  sw = sw.WithValue(\"vhost\", host)",
          "100:  if strings.Contains(host, \"*\") {",
          "101:   sw.SetInvalid(\"Spec.VirtualHost.Fqdn %q cannot use wildcards\", host)",
          "102:   return",
          "103:  }",
          "105:  var tlsEnabled bool",
          "106:  if tls := proxy.Spec.VirtualHost.TLS; tls != nil {",
          "107:   if !isBlank(tls.SecretName) && tls.Passthrough {",
          "108:    sw.SetInvalid(\"Spec.VirtualHost.TLS: both Passthrough and SecretName were specified\")",
          "109:    return",
          "110:   }",
          "111:   if isBlank(tls.SecretName) && !tls.Passthrough {",
          "112:    sw.SetInvalid(\"Spec.VirtualHost.TLS: neither Passthrough nor SecretName were specified\")",
          "113:    return",
          "114:   }",
          "115:   tlsEnabled = true",
          "118:   if !tls.Passthrough {",
          "119:    secretName := k8s.NamespacedNameFrom(tls.SecretName, k8s.DefaultNamespace(proxy.Namespace))",
          "120:    sec, err := p.builder.Source.LookupSecret(secretName, validSecret)",
          "121:    if err != nil {",
          "122:     sw.SetInvalid(\"Spec.VirtualHost.TLS Secret %q is invalid: %s\", tls.SecretName, err)",
          "123:     return",
          "124:    }",
          "126:    if !p.builder.Source.DelegationPermitted(secretName, proxy.Namespace) {",
          "127:     sw.SetInvalid(\"Spec.VirtualHost.TLS Secret %q certificate delegation not permitted\", tls.SecretName)",
          "128:     return",
          "129:    }",
          "131:    svhost := p.builder.lookupSecureVirtualHost(host)",
          "132:    svhost.Secret = sec",
          "133:    svhost.MinTLSVersion = annotation.MinTLSVersion(tls.MinimumProtocolVersion)",
          "136:    if tls.EnableFallbackCertificate && tls.ClientValidation != nil {",
          "137:     sw.SetInvalid(\"Spec.Virtualhost.TLS fallback & client validation are incompatible together\")",
          "138:     return",
          "139:    }",
          "142:    if tls.EnableFallbackCertificate {",
          "143:     if p.FallbackCertificate == nil {",
          "144:      sw.SetInvalid(\"Spec.Virtualhost.TLS enabled fallback but the fallback Certificate Secret is not configured in Contour configuration file\")",
          "145:      return",
          "146:     }",
          "148:     sec, err = p.builder.Source.LookupSecret(*p.FallbackCertificate, validSecret)",
          "149:     if err != nil {",
          "150:      sw.SetInvalid(\"Spec.Virtualhost.TLS Secret %q fallback certificate is invalid: %s\", p.FallbackCertificate, err)",
          "151:      return",
          "152:     }",
          "154:     if !p.builder.Source.DelegationPermitted(*p.FallbackCertificate, proxy.Namespace) {",
          "155:      sw.SetInvalid(\"Spec.VirtualHost.TLS fallback Secret %q is not configured for certificate delegation\", p.FallbackCertificate)",
          "156:      return",
          "157:     }",
          "159:     svhost.FallbackCertificate = sec",
          "160:    }",
          "163:    if tls.ClientValidation != nil {",
          "164:     dv, err := p.lookupDownstreamValidation(tls.ClientValidation, proxy.Namespace)",
          "165:     if err != nil {",
          "166:      sw.SetInvalid(\"Spec.VirtualHost.TLS client validation is invalid: %s\", err)",
          "167:      return",
          "168:     }",
          "169:     svhost.DownstreamValidation = dv",
          "170:    }",
          "171:   } else if tls.ClientValidation != nil {",
          "172:    sw.SetInvalid(\"Spec.VirtualHost.TLS passthrough cannot be combined with tls.clientValidation\")",
          "173:    return",
          "174:   }",
          "175:  }",
          "177:  if proxy.Spec.TCPProxy != nil {",
          "178:   if !tlsEnabled {",
          "179:    sw.SetInvalid(\"Spec.TCPProxy requires that either Spec.TLS.Passthrough or Spec.TLS.SecretName be set\")",
          "180:    return",
          "181:   }",
          "182:   if !p.processHTTPProxyTCPProxy(sw, proxy, nil, host) {",
          "183:    return",
          "184:   }",
          "185:  }",
          "187:  routes := p.computeRoutes(sw, proxy, nil, nil, tlsEnabled)",
          "188:  insecure := p.builder.lookupVirtualHost(host)",
          "189:  addRoutes(insecure, routes)",
          "193:  if tlsEnabled && proxy.Spec.TCPProxy == nil {",
          "194:   secure := p.builder.lookupSecureVirtualHost(host)",
          "195:   addRoutes(secure, routes)",
          "196:  }",
          "197: }",
          "199: type vhost interface {",
          "200:  addRoute(*Route)",
          "201: }",
          "204: func addRoutes(vhost vhost, routes []*Route) {",
          "205:  for _, route := range routes {",
          "206:   vhost.addRoute(route)",
          "207:  }",
          "208: }",
          "210: func (p *HTTPProxyProcessor) computeRoutes(sw *ObjectStatusWriter, proxy *projcontour.HTTPProxy, conditions []projcontour.MatchCondition, visited []*projcontour.HTTPProxy, enforceTLS bool) []*Route {",
          "211:  for _, v := range visited {",
          "213:   var path []string",
          "214:   for _, vir := range visited {",
          "215:    path = append(path, fmt.Sprintf(\"%s/%s\", vir.Namespace, vir.Name))",
          "216:   }",
          "217:   if v.Name == proxy.Name && v.Namespace == proxy.Namespace {",
          "218:    path = append(path, fmt.Sprintf(\"%s/%s\", proxy.Namespace, proxy.Name))",
          "219:    sw.SetInvalid(\"include creates a delegation cycle: %s\", strings.Join(path, \" -> \"))",
          "220:    return nil",
          "221:   }",
          "222:  }",
          "224:  visited = append(visited, proxy)",
          "225:  var routes []*Route",
          "228:  if includeMatchConditionsIdentical(proxy.Spec.Includes) {",
          "229:   sw.SetInvalid(\"duplicate conditions defined on an include\")",
          "230:   return nil",
          "231:  }",
          "234:  for _, include := range proxy.Spec.Includes {",
          "235:   namespace := include.Namespace",
          "236:   if namespace == \"\" {",
          "237:    namespace = proxy.Namespace",
          "238:   }",
          "240:   delegate, ok := p.builder.Source.httpproxies[types.NamespacedName{Name: include.Name, Namespace: namespace}]",
          "241:   if !ok {",
          "242:    sw.SetInvalid(\"include %s/%s not found\", namespace, include.Name)",
          "243:    return nil",
          "244:   }",
          "245:   if delegate.Spec.VirtualHost != nil {",
          "246:    sw.SetInvalid(\"root httpproxy cannot delegate to another root httpproxy\")",
          "247:    return nil",
          "248:   }",
          "250:   if err := pathMatchConditionsValid(include.Conditions); err != nil {",
          "251:    sw.SetInvalid(\"include: %s\", err)",
          "252:    return nil",
          "253:   }",
          "255:   sw, commit := p.builder.WithObject(delegate)",
          "256:   routes = append(routes, p.computeRoutes(sw, delegate, append(conditions, include.Conditions...), visited, enforceTLS)...)",
          "257:   commit()",
          "260:   delete(p.orphaned, types.NamespacedName{Name: delegate.Name, Namespace: delegate.Namespace})",
          "261:  }",
          "263:  for _, route := range proxy.Spec.Routes {",
          "264:   if err := pathMatchConditionsValid(route.Conditions); err != nil {",
          "265:    sw.SetInvalid(\"route: %s\", err)",
          "266:    return nil",
          "267:   }",
          "269:   conds := append(conditions, route.Conditions...)",
          "272:   if err := headerMatchConditionsValid(conds); err != nil {",
          "273:    sw.SetInvalid(err.Error())",
          "274:    return nil",
          "275:   }",
          "277:   reqHP, err := headersPolicy(route.RequestHeadersPolicy, true /* allow Host */)",
          "278:   if err != nil {",
          "279:    sw.SetInvalid(err.Error())",
          "280:    return nil",
          "281:   }",
          "283:   respHP, err := headersPolicy(route.ResponseHeadersPolicy, false /* disallow Host */)",
          "284:   if err != nil {",
          "285:    sw.SetInvalid(err.Error())",
          "286:    return nil",
          "287:   }",
          "289:   if len(route.Services) < 1 {",
          "290:    sw.SetInvalid(\"route.services must have at least one entry\")",
          "291:    return nil",
          "292:   }",
          "294:   r := &Route{",
          "295:    PathMatchCondition:    mergePathMatchConditions(conds),",
          "296:    HeaderMatchConditions: mergeHeaderMatchConditions(conds),",
          "297:    Websocket:             route.EnableWebsockets,",
          "298:    HTTPSUpgrade:          routeEnforceTLS(enforceTLS, route.PermitInsecure && !p.DisablePermitInsecure),",
          "299:    TimeoutPolicy:         timeoutPolicy(route.TimeoutPolicy),",
          "300:    RetryPolicy:           retryPolicy(route.RetryPolicy),",
          "301:    RequestHeadersPolicy:  reqHP,",
          "302:    ResponseHeadersPolicy: respHP,",
          "303:   }",
          "305:   if len(route.GetPrefixReplacements()) > 0 {",
          "306:    if !r.HasPathPrefix() {",
          "307:     sw.SetInvalid(\"cannot specify prefix replacements without a prefix condition\")",
          "308:     return nil",
          "309:    }",
          "311:    if err := prefixReplacementsAreValid(route.GetPrefixReplacements()); err != nil {",
          "312:     sw.SetInvalid(err.Error())",
          "313:     return nil",
          "314:    }",
          "320:    routingPrefix := r.PathMatchCondition.(*PrefixMatchCondition).Prefix",
          "323:    for _, prefix := range route.GetPrefixReplacements() {",
          "324:     if len(prefix.Prefix) > 0 && routingPrefix == prefix.Prefix {",
          "325:      r.PrefixRewrite = prefix.Replacement",
          "326:      break",
          "327:     }",
          "328:    }",
          "331:    if len(r.PrefixRewrite) == 0 {",
          "332:     for _, prefix := range route.GetPrefixReplacements() {",
          "333:      if len(prefix.Prefix) == 0 {",
          "334:       r.PrefixRewrite = prefix.Replacement",
          "335:       break",
          "336:      }",
          "337:     }",
          "338:    }",
          "340:   }",
          "342:   for _, service := range route.Services {",
          "343:    if service.Port < 1 || service.Port > 65535 {",
          "344:     sw.SetInvalid(\"service %q: port must be in the range 1-65535\", service.Name)",
          "345:     return nil",
          "346:    }",
          "347:    m := types.NamespacedName{Name: service.Name, Namespace: proxy.Namespace}",
          "348:    s, err := p.builder.lookupService(m, intstr.FromInt(service.Port))",
          "349:    if err != nil {",
          "350:     sw.SetInvalid(\"Spec.Routes unresolved service reference: %s\", err)",
          "351:     return nil",
          "352:    }",
          "355:    protocol, err := getProtocol(service, s)",
          "356:    if err != nil {",
          "357:     sw.SetInvalid(err.Error())",
          "358:     return nil",
          "359:    }",
          "361:    var uv *PeerValidationContext",
          "362:    if protocol == \"tls\" || protocol == \"h2\" {",
          "364:     uv, err = p.lookupUpstreamValidation(service.UpstreamValidation, proxy.Namespace)",
          "365:     if err != nil {",
          "366:      sw.SetInvalid(\"Service [%s:%d] TLS upstream validation policy error: %s\",",
          "367:       service.Name, service.Port, err)",
          "368:      return nil",
          "369:     }",
          "370:    }",
          "372:    reqHP, err := headersPolicy(service.RequestHeadersPolicy, true /* allow Host */)",
          "373:    if err != nil {",
          "374:     sw.SetInvalid(err.Error())",
          "375:     return nil",
          "376:    }",
          "378:    respHP, err := headersPolicy(service.ResponseHeadersPolicy, false /* disallow Host */)",
          "379:    if err != nil {",
          "380:     sw.SetInvalid(err.Error())",
          "381:     return nil",
          "382:    }",
          "384:    c := &Cluster{",
          "385:     Upstream:              s,",
          "386:     LoadBalancerPolicy:    loadBalancerPolicy(route.LoadBalancerPolicy),",
          "387:     Weight:                uint32(service.Weight),",
          "388:     HTTPHealthCheckPolicy: httpHealthCheckPolicy(route.HealthCheckPolicy),",
          "389:     UpstreamValidation:    uv,",
          "390:     RequestHeadersPolicy:  reqHP,",
          "391:     ResponseHeadersPolicy: respHP,",
          "392:     Protocol:              protocol,",
          "393:     SNI:                   determineSNI(r.RequestHeadersPolicy, reqHP, s),",
          "394:    }",
          "395:    if service.Mirror && r.MirrorPolicy != nil {",
          "396:     sw.SetInvalid(\"only one service per route may be nominated as mirror\")",
          "397:     return nil",
          "398:    }",
          "399:    if service.Mirror {",
          "400:     r.MirrorPolicy = &MirrorPolicy{",
          "401:      Cluster: c,",
          "402:     }",
          "403:    } else {",
          "404:     r.Clusters = append(r.Clusters, c)",
          "405:    }",
          "406:   }",
          "407:   routes = append(routes, r)",
          "408:  }",
          "410:  routes = expandPrefixMatches(routes)",
          "412:  sw.SetValid()",
          "413:  return routes",
          "414: }",
          "420: func (p *HTTPProxyProcessor) processHTTPProxyTCPProxy(sw *ObjectStatusWriter, httpproxy *projcontour.HTTPProxy, visited []*projcontour.HTTPProxy, host string) bool {",
          "421:  tcpproxy := httpproxy.Spec.TCPProxy",
          "422:  if tcpproxy == nil {",
          "424:   return true",
          "425:  }",
          "427:  visited = append(visited, httpproxy)",
          "431:  tcpProxyInclude := tcpproxy.Include",
          "432:  if tcpproxy.Include == nil {",
          "433:   tcpProxyInclude = tcpproxy.IncludesDeprecated",
          "434:  }",
          "436:  if len(tcpproxy.Services) > 0 && tcpProxyInclude != nil {",
          "437:   sw.SetInvalid(\"tcpproxy: cannot specify services and include in the same httpproxy\")",
          "438:   return false",
          "439:  }",
          "441:  if len(tcpproxy.Services) > 0 {",
          "442:   var proxy TCPProxy",
          "443:   for _, service := range httpproxy.Spec.TCPProxy.Services {",
          "444:    m := types.NamespacedName{Name: service.Name, Namespace: httpproxy.Namespace}",
          "445:    s, err := p.builder.lookupService(m, intstr.FromInt(service.Port))",
          "446:    if err != nil {",
          "447:     sw.SetInvalid(\"Spec.TCPProxy unresolved service reference: %s\", err)",
          "448:     return false",
          "449:    }",
          "450:    proxy.Clusters = append(proxy.Clusters, &Cluster{",
          "451:     Upstream:             s,",
          "452:     Protocol:             s.Protocol,",
          "453:     LoadBalancerPolicy:   loadBalancerPolicy(tcpproxy.LoadBalancerPolicy),",
          "454:     TCPHealthCheckPolicy: tcpHealthCheckPolicy(tcpproxy.HealthCheckPolicy),",
          "455:    })",
          "456:   }",
          "457:   p.builder.lookupSecureVirtualHost(host).TCPProxy = &proxy",
          "458:   return true",
          "459:  }",
          "461:  if tcpProxyInclude == nil {",
          "463:   sw.SetInvalid(\"tcpproxy: either services or inclusion must be specified\")",
          "464:   return false",
          "465:  }",
          "467:  namespace := tcpProxyInclude.Namespace",
          "468:  if namespace == \"\" {",
          "470:   namespace = httpproxy.Namespace",
          "471:  }",
          "473:  m := types.NamespacedName{Name: tcpProxyInclude.Name, Namespace: namespace}",
          "474:  dest, ok := p.builder.Source.httpproxies[m]",
          "475:  if !ok {",
          "476:   sw.SetInvalid(\"tcpproxy: include %s/%s not found\", m.Namespace, m.Name)",
          "477:   return false",
          "478:  }",
          "480:  if dest.Spec.VirtualHost != nil {",
          "481:   sw.SetInvalid(\"root httpproxy cannot delegate to another root httpproxy\")",
          "482:   return false",
          "483:  }",
          "486:  delete(p.orphaned, k8s.NamespacedNameOf(dest))",
          "489:  var path []string",
          "490:  for _, hp := range visited {",
          "491:   path = append(path, fmt.Sprintf(\"%s/%s\", hp.Namespace, hp.Name))",
          "492:  }",
          "493:  for _, hp := range visited {",
          "494:   if dest.Name == hp.Name && dest.Namespace == hp.Namespace {",
          "495:    path = append(path, fmt.Sprintf(\"%s/%s\", dest.Namespace, dest.Name))",
          "496:    sw.SetInvalid(\"tcpproxy include creates a cycle: %s\", strings.Join(path, \" -> \"))",
          "497:    return false",
          "498:   }",
          "499:  }",
          "502:  sw, commit := sw.WithObject(dest)",
          "503:  defer commit()",
          "504:  ok = p.processHTTPProxyTCPProxy(sw, dest, visited, host)",
          "505:  if ok {",
          "506:   sw.SetValid()",
          "507:  }",
          "508:  return ok",
          "509: }",
          "514: func (p *HTTPProxyProcessor) validHTTPProxies() []*projcontour.HTTPProxy {",
          "516:  var valid []*projcontour.HTTPProxy",
          "517:  fqdnHTTPProxies := make(map[string][]*projcontour.HTTPProxy)",
          "518:  for _, proxy := range p.builder.Source.httpproxies {",
          "519:   if proxy.Spec.VirtualHost == nil {",
          "520:    valid = append(valid, proxy)",
          "521:    continue",
          "522:   }",
          "523:   fqdnHTTPProxies[proxy.Spec.VirtualHost.Fqdn] = append(fqdnHTTPProxies[proxy.Spec.VirtualHost.Fqdn], proxy)",
          "524:  }",
          "526:  for fqdn, proxies := range fqdnHTTPProxies {",
          "527:   switch len(proxies) {",
          "528:   case 1:",
          "529:    valid = append(valid, proxies[0])",
          "530:   default:",
          "532:    var conflicting []string",
          "533:    for _, proxy := range proxies {",
          "534:     conflicting = append(conflicting, proxy.Namespace+\"/\"+proxy.Name)",
          "535:    }",
          "536:    sort.Strings(conflicting) // sort for test stability",
          "537:    msg := fmt.Sprintf(\"fqdn %q is used in multiple HTTPProxies: %s\", fqdn, strings.Join(conflicting, \", \"))",
          "538:    for _, proxy := range proxies {",
          "539:     sw, commit := p.builder.WithObject(proxy)",
          "540:     sw.WithValue(\"vhost\", fqdn).SetInvalid(msg)",
          "541:     commit()",
          "542:    }",
          "543:   }",
          "544:  }",
          "545:  return valid",
          "546: }",
          "549: func (p *HTTPProxyProcessor) rootAllowed(namespace string) bool {",
          "550:  if len(p.builder.Source.RootNamespaces) == 0 {",
          "551:   return true",
          "552:  }",
          "553:  for _, ns := range p.builder.Source.RootNamespaces {",
          "554:   if ns == namespace {",
          "555:    return true",
          "556:   }",
          "557:  }",
          "558:  return false",
          "559: }",
          "561: func (p *HTTPProxyProcessor) lookupUpstreamValidation(uv *projcontour.UpstreamValidation, namespace string) (*PeerValidationContext, error) {",
          "562:  if uv == nil {",
          "564:   return nil, nil",
          "565:  }",
          "567:  secretName := types.NamespacedName{Name: uv.CACertificate, Namespace: namespace}",
          "568:  cacert, err := p.builder.Source.LookupSecret(secretName, validCA)",
          "569:  if err != nil {",
          "571:   return nil, fmt.Errorf(\"invalid CA Secret %q: %s\", secretName, err)",
          "572:  }",
          "574:  if uv.SubjectName == \"\" {",
          "576:   return nil, errors.New(\"missing subject alternative name\")",
          "577:  }",
          "579:  return &PeerValidationContext{",
          "580:   CACertificate: cacert,",
          "581:   SubjectName:   uv.SubjectName,",
          "582:  }, nil",
          "583: }",
          "585: func (p *HTTPProxyProcessor) lookupDownstreamValidation(vc *projcontour.DownstreamValidation, namespace string) (*PeerValidationContext, error) {",
          "586:  secretName := types.NamespacedName{Name: vc.CACertificate, Namespace: namespace}",
          "587:  cacert, err := p.builder.Source.LookupSecret(secretName, validCA)",
          "588:  if err != nil {",
          "590:   return nil, fmt.Errorf(\"invalid CA Secret %q: %s\", secretName, err)",
          "591:  }",
          "593:  return &PeerValidationContext{",
          "594:   CACertificate: cacert,",
          "595:  }, nil",
          "596: }",
          "598: func validCA(s *v1.Secret) error {",
          "599:  if len(s.Data[CACertificateKey]) == 0 {",
          "600:   return fmt.Errorf(\"empty %q key\", CACertificateKey)",
          "601:  }",
          "603:  return nil",
          "604: }",
          "607: func (p *HTTPProxyProcessor) setOrphaned(obj k8s.Object) {",
          "608:  m := types.NamespacedName{",
          "609:   Name:      obj.GetObjectMeta().GetName(),",
          "610:   Namespace: obj.GetObjectMeta().GetNamespace(),",
          "611:  }",
          "612:  p.orphaned[m] = true",
          "613: }",
          "630: func expandPrefixMatches(routes []*Route) []*Route {",
          "631:  prefixedRoutes := map[string][]*Route{}",
          "633:  expandedRoutes := []*Route{}",
          "636:  for _, r := range routes {",
          "638:   if !r.HasPathPrefix() {",
          "639:    expandedRoutes = append(expandedRoutes, r)",
          "640:   }",
          "642:   routingPrefix := r.PathMatchCondition.(*PrefixMatchCondition).Prefix",
          "644:   if routingPrefix != \"/\" {",
          "645:    routingPrefix = strings.TrimRight(routingPrefix, \"/\")",
          "646:   }",
          "648:   prefixedRoutes[routingPrefix] = append(prefixedRoutes[routingPrefix], r)",
          "649:  }",
          "651:  for prefix, routes := range prefixedRoutes {",
          "655:   expandedRoutes = append(expandedRoutes, routes...)",
          "657:   switch len(routes) {",
          "658:   case 1:",
          "660:    if len(routes[0].PrefixRewrite) == 0 {",
          "661:     continue",
          "662:    }",
          "664:    routingPrefix := routes[0].PathMatchCondition.(*PrefixMatchCondition).Prefix",
          "667:    if routingPrefix == \"/\" {",
          "668:     continue",
          "669:    }",
          "672:    newRoute := *routes[0]",
          "675:    routes[0].PrefixRewrite = strings.TrimRight(routes[0].PrefixRewrite, \"/\")",
          "676:    routes[0].PathMatchCondition = &PrefixMatchCondition{Prefix: prefix}",
          "678:    newRoute.PrefixRewrite = routes[0].PrefixRewrite + \"/\"",
          "679:    newRoute.PathMatchCondition = &PrefixMatchCondition{Prefix: prefix + \"/\"}",
          "685:    if len(routes[0].PrefixRewrite) == 0 {",
          "686:     routes[0].PrefixRewrite = \"/\"",
          "687:    }",
          "689:    expandedRoutes = append(expandedRoutes, &newRoute)",
          "690:   case 2:",
          "695:    continue",
          "696:   default:",
          "699:   }",
          "701:  }",
          "703:  return expandedRoutes",
          "704: }",
          "706: func getProtocol(service projcontour.Service, s *Service) (string, error) {",
          "708:  var protocol string",
          "709:  if service.Protocol != nil {",
          "710:   protocol = *service.Protocol",
          "711:   switch protocol {",
          "712:   case \"h2c\", \"h2\", \"tls\":",
          "713:   default:",
          "714:    return \"\", fmt.Errorf(\"unsupported protocol: %v\", protocol)",
          "715:   }",
          "716:  } else {",
          "717:   protocol = s.Protocol",
          "718:  }",
          "720:  return protocol, nil",
          "721: }",
          "726: func determineSNI(routeRequestHeaders *HeadersPolicy, clusterRequestHeaders *HeadersPolicy, service *Service) string {",
          "729:  if clusterRequestHeaders != nil {",
          "730:   if clusterRequestHeaders.HostRewrite != \"\" {",
          "731:    return clusterRequestHeaders.HostRewrite",
          "732:   }",
          "733:  }",
          "736:  if routeRequestHeaders != nil {",
          "737:   if routeRequestHeaders.HostRewrite != \"\" {",
          "738:    return routeRequestHeaders.HostRewrite",
          "739:   }",
          "740:  }",
          "742:  return service.ExternalName",
          "743: }",
          "745: func includeMatchConditionsIdentical(includes []projcontour.Include) bool {",
          "746:  j := 0",
          "747:  for i := 1; i < len(includes); i++ {",
          "749:   for _, cA := range includes[i].Conditions {",
          "750:    for _, cB := range includes[j].Conditions {",
          "751:     if (cA.Prefix == cB.Prefix) && equality.Semantic.DeepEqual(cA.Header, cB.Header) {",
          "752:      return true",
          "753:     }",
          "754:    }",
          "755:   }",
          "756:   j++",
          "757:  }",
          "758:  return false",
          "759: }",
          "762: func isBlank(s string) bool {",
          "763:  return len(strings.TrimSpace(s)) == 0",
          "764: }",
          "767: func routeEnforceTLS(enforceTLS, permitInsecure bool) bool {",
          "768:  return enforceTLS && !permitInsecure",
          "769: }",
          "",
          "---------------"
        ],
        "internal/dag/ingress_processor.go||internal/dag/ingress_processor.go": [
          "File: internal/dag/ingress_processor.go -> internal/dag/ingress_processor.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: package dag",
          "16: import (",
          "17:  \"strings\"",
          "19:  \"github.com/projectcontour/contour/internal/annotation\"",
          "20:  \"github.com/projectcontour/contour/internal/k8s\"",
          "21:  \"k8s.io/api/networking/v1beta1\"",
          "22:  \"k8s.io/apimachinery/pkg/types\"",
          "23: )",
          "27: type IngressProcessor struct {",
          "28:  builder *Builder",
          "29: }",
          "33: func (p *IngressProcessor) Run(builder *Builder) {",
          "34:  p.builder = builder",
          "37:  defer func() {",
          "38:   p.builder = nil",
          "39:  }()",
          "44:  p.computeSecureVirtualhosts()",
          "45:  p.computeIngresses()",
          "46: }",
          "50: func (p *IngressProcessor) computeSecureVirtualhosts() {",
          "51:  for _, ing := range p.builder.Source.ingresses {",
          "52:   for _, tls := range ing.Spec.TLS {",
          "53:    secretName := k8s.NamespacedNameFrom(tls.SecretName, k8s.DefaultNamespace(ing.GetNamespace()))",
          "54:    sec, err := p.builder.Source.LookupSecret(secretName, validSecret)",
          "55:    if err != nil {",
          "56:     p.builder.WithError(err).",
          "57:      WithField(\"name\", ing.GetName()).",
          "58:      WithField(\"namespace\", ing.GetNamespace()).",
          "59:      WithField(\"secret\", secretName).",
          "60:      Error(\"unresolved secret reference\")",
          "61:     continue",
          "62:    }",
          "64:    if !p.builder.Source.DelegationPermitted(secretName, ing.GetNamespace()) {",
          "65:     p.builder.WithError(err).",
          "66:      WithField(\"name\", ing.GetName()).",
          "67:      WithField(\"namespace\", ing.GetNamespace()).",
          "68:      WithField(\"secret\", secretName).",
          "69:      Error(\"certificate delegation not permitted\")",
          "70:     continue",
          "71:    }",
          "76:    for _, host := range tls.Hosts {",
          "77:     svhost := p.builder.lookupSecureVirtualHost(host)",
          "78:     svhost.Secret = sec",
          "79:     svhost.MinTLSVersion = annotation.MinTLSVersion(",
          "80:      annotation.CompatAnnotation(ing, \"tls-minimum-protocol-version\"))",
          "81:    }",
          "82:   }",
          "83:  }",
          "84: }",
          "86: func (p *IngressProcessor) computeIngresses() {",
          "88:  for _, ing := range p.builder.Source.ingresses {",
          "91:   rules := rulesFromSpec(ing.Spec)",
          "92:   for _, rule := range rules {",
          "93:    p.computeIngressRule(ing, rule)",
          "94:   }",
          "95:  }",
          "96: }",
          "98: func (p *IngressProcessor) computeIngressRule(ing *v1beta1.Ingress, rule v1beta1.IngressRule) {",
          "99:  host := rule.Host",
          "100:  if strings.Contains(host, \"*\") {",
          "102:   return",
          "103:  }",
          "104:  if host == \"\" {",
          "106:   host = \"*\"",
          "107:  }",
          "108:  for _, httppath := range httppaths(rule) {",
          "109:   path := stringOrDefault(httppath.Path, \"/\")",
          "110:   be := httppath.Backend",
          "111:   m := types.NamespacedName{Name: be.ServiceName, Namespace: ing.Namespace}",
          "112:   s, err := p.builder.lookupService(m, be.ServicePort)",
          "113:   if err != nil {",
          "114:    continue",
          "115:   }",
          "117:   r := route(ing, path, s)",
          "120:   if annotation.TLSRequired(ing) || annotation.HTTPAllowed(ing) {",
          "121:    p.builder.lookupVirtualHost(host).addRoute(r)",
          "122:   }",
          "127:   svh, ok := p.builder.securevirtualhosts[host]",
          "128:   if ok && host != \"*\" {",
          "129:    svh.addRoute(r)",
          "130:   }",
          "131:  }",
          "132: }",
          "135: func route(ingress *v1beta1.Ingress, path string, service *Service) *Route {",
          "136:  wr := annotation.WebsocketRoutes(ingress)",
          "137:  r := &Route{",
          "138:   HTTPSUpgrade:  annotation.TLSRequired(ingress),",
          "139:   Websocket:     wr[path],",
          "140:   TimeoutPolicy: ingressTimeoutPolicy(ingress),",
          "141:   RetryPolicy:   ingressRetryPolicy(ingress),",
          "142:   Clusters: []*Cluster{{",
          "143:    Upstream: service,",
          "144:    Protocol: service.Protocol,",
          "145:   }},",
          "146:  }",
          "148:  if strings.ContainsAny(path, \"^+*[]%\") {",
          "150:   r.PathMatchCondition = &RegexMatchCondition{Regex: path}",
          "151:   return r",
          "152:  }",
          "154:  r.PathMatchCondition = &PrefixMatchCondition{Prefix: path}",
          "155:  return r",
          "156: }",
          "160: func rulesFromSpec(spec v1beta1.IngressSpec) []v1beta1.IngressRule {",
          "161:  rules := spec.Rules",
          "162:  if backend := spec.Backend; backend != nil {",
          "163:   rule := defaultBackendRule(backend)",
          "164:   rules = append(rules, rule)",
          "165:  }",
          "166:  return rules",
          "167: }",
          "170: func defaultBackendRule(be *v1beta1.IngressBackend) v1beta1.IngressRule {",
          "171:  return v1beta1.IngressRule{",
          "172:   IngressRuleValue: v1beta1.IngressRuleValue{",
          "173:    HTTP: &v1beta1.HTTPIngressRuleValue{",
          "174:     Paths: []v1beta1.HTTPIngressPath{{",
          "175:      Backend: v1beta1.IngressBackend{",
          "176:       ServiceName: be.ServiceName,",
          "177:       ServicePort: be.ServicePort,",
          "178:      },",
          "179:     }},",
          "180:    },",
          "181:   },",
          "182:  }",
          "183: }",
          "185: func stringOrDefault(s, def string) string {",
          "186:  if s == \"\" {",
          "187:   return def",
          "188:  }",
          "189:  return s",
          "190: }",
          "195: func httppaths(rule v1beta1.IngressRule) []v1beta1.HTTPIngressPath {",
          "196:  if rule.IngressRuleValue.HTTP == nil {",
          "198:   return nil",
          "199:  }",
          "200:  return rule.IngressRuleValue.HTTP.Paths",
          "201: }",
          "",
          "---------------"
        ],
        "internal/dag/listener_processor.go||internal/dag/listener_processor.go": [
          "File: internal/dag/listener_processor.go -> internal/dag/listener_processor.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: package dag",
          "16: import \"sort\"",
          "21: type ListenerProcessor struct {",
          "22:  builder *Builder",
          "23: }",
          "28: func (p *ListenerProcessor) Run(builder *Builder) {",
          "29:  p.builder = builder",
          "32:  defer func() {",
          "33:   p.builder = nil",
          "34:  }()",
          "36:  http := p.buildHTTPListener()",
          "37:  if len(http.VirtualHosts) > 0 {",
          "38:   p.builder.listeners = append(p.builder.listeners, http)",
          "39:  }",
          "41:  https := p.buildHTTPSListener()",
          "42:  if len(https.VirtualHosts) > 0 {",
          "43:   p.builder.listeners = append(p.builder.listeners, https)",
          "44:  }",
          "45: }",
          "50: func (p *ListenerProcessor) buildHTTPListener() *Listener {",
          "51:  var virtualhosts = make([]Vertex, 0, len(p.builder.virtualhosts))",
          "53:  for _, vh := range p.builder.virtualhosts {",
          "54:   if vh.Valid() {",
          "55:    virtualhosts = append(virtualhosts, vh)",
          "56:   }",
          "57:  }",
          "58:  sort.SliceStable(virtualhosts, func(i, j int) bool {",
          "59:   return virtualhosts[i].(*VirtualHost).Name < virtualhosts[j].(*VirtualHost).Name",
          "60:  })",
          "61:  return &Listener{",
          "62:   Port:         80,",
          "63:   VirtualHosts: virtualhosts,",
          "64:  }",
          "65: }",
          "70: func (p *ListenerProcessor) buildHTTPSListener() *Listener {",
          "71:  var virtualhosts = make([]Vertex, 0, len(p.builder.securevirtualhosts))",
          "72:  for _, svh := range p.builder.securevirtualhosts {",
          "73:   if svh.Valid() {",
          "74:    virtualhosts = append(virtualhosts, svh)",
          "75:   }",
          "76:  }",
          "77:  sort.SliceStable(virtualhosts, func(i, j int) bool {",
          "78:   return virtualhosts[i].(*SecureVirtualHost).Name < virtualhosts[j].(*SecureVirtualHost).Name",
          "79:  })",
          "80:  return &Listener{",
          "81:   Port:         443,",
          "82:   VirtualHosts: virtualhosts,",
          "83:  }",
          "84: }",
          "",
          "---------------"
        ],
        "internal/dag/policy.go||internal/dag/policy.go": [
          "File: internal/dag/policy.go -> internal/dag/policy.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "116:  }, nil",
          "117: }",
          "120: func ingressRetryPolicy(ingress *v1beta1.Ingress) *RetryPolicy {",
          "121:  retryOn := annotation.CompatAnnotation(ingress, \"retry-on\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "119: func escapeHeaderValue(value string) string {",
          "122:  return strings.Replace(value, \"%\", \"%%\", -1)",
          "123: }",
          "",
          "---------------"
        ],
        "internal/dag/status_test.go||internal/dag/status_test.go": [
          "File: internal/dag/status_test.go -> internal/dag/status_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "2284:  for name, tc := range tests {",
          "2285:   t.Run(name, func(t *testing.T) {",
          "2286:    builder := Builder{",
          "2289:     Source: KubernetesCache{",
          "2290:      RootNamespaces: []string{\"roots\", \"marketing\"},",
          "2291:      FieldLogger:    fixture.NewTestLogger(t),",
          "2292:     },",
          "2293:    }",
          "2294:    for _, o := range tc.objs {",
          "2295:     builder.Source.Insert(o)",
          "",
          "[Removed Lines]",
          "2287:     FieldLogger:         fixture.NewTestLogger(t),",
          "2288:     FallbackCertificate: tc.fallbackCertificate,",
          "",
          "[Added Lines]",
          "2287:     FieldLogger: fixture.NewTestLogger(t),",
          "2292:     Processors: []Processor{",
          "2293:      &IngressProcessor{},",
          "2294:      &HTTPProxyProcessor{",
          "2295:       FallbackCertificate: tc.fallbackCertificate,",
          "2296:      },",
          "2297:      &ListenerProcessor{},",
          "2298:     },",
          "",
          "---------------"
        ],
        "internal/featuretests/fallbackcert_test.go||internal/featuretests/fallbackcert_test.go": [
          "File: internal/featuretests/fallbackcert_test.go -> internal/featuretests/fallbackcert_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:  envoy_api_v2_core \"github.com/envoyproxy/go-control-plane/envoy/api/v2/core\"",
          "22:  projcontour \"github.com/projectcontour/contour/apis/projectcontour/v1\"",
          "23:  \"github.com/projectcontour/contour/internal/contour\"",
          "24:  \"github.com/projectcontour/contour/internal/envoy\"",
          "25:  \"github.com/projectcontour/contour/internal/fixture\"",
          "26:  v1 \"k8s.io/api/core/v1\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24:  \"github.com/projectcontour/contour/internal/dag\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "31: func TestFallbackCertificate(t *testing.T) {",
          "32:  rh, c, done := setup(t, func(eh *contour.EventHandler) {",
          "36:   }",
          "37:  })",
          "38:  defer done()",
          "",
          "[Removed Lines]",
          "33:   eh.Builder.FallbackCertificate = &types.NamespacedName{",
          "34:    Name:      \"fallbacksecret\",",
          "35:    Namespace: \"admin\",",
          "",
          "[Added Lines]",
          "34:   eh.Builder.Processors = []dag.Processor{",
          "35:    &dag.IngressProcessor{},",
          "36:    &dag.HTTPProxyProcessor{",
          "37:     FallbackCertificate: &types.NamespacedName{",
          "38:      Name:      \"fallbacksecret\",",
          "39:      Namespace: \"admin\",",
          "40:     },",
          "41:    },",
          "42:    &dag.ListenerProcessor{},",
          "",
          "---------------"
        ],
        "internal/featuretests/featuretests.go||internal/featuretests/featuretests.go": [
          "File: internal/featuretests/featuretests.go -> internal/featuretests/featuretests.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "103:    },",
          "104:   },",
          "105:  }",
          "106:  for _, opt := range opts {",
          "107:   if opt, ok := opt.(func(*contour.EventHandler)); ok {",
          "108:    opt(eh)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "107:  eh.Builder.Processors = []dag.Processor{",
          "108:   &dag.IngressProcessor{},",
          "109:   &dag.HTTPProxyProcessor{},",
          "110:   &dag.ListenerProcessor{},",
          "111:  }",
          "",
          "---------------"
        ],
        "internal/featuretests/route_test.go||internal/featuretests/route_test.go": [
          "File: internal/featuretests/route_test.go -> internal/featuretests/route_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "1357: func TestRouteWithTLS_InsecurePaths_DisablePermitInsecureTrue(t *testing.T) {",
          "1358:  rh, c, done := setup(t, func(reh *contour.EventHandler) {",
          "1360:  })",
          "1362:  defer done()",
          "",
          "[Removed Lines]",
          "1359:   reh.Builder.DisablePermitInsecure = true",
          "",
          "[Added Lines]",
          "1359:   reh.Builder.Processors = []dag.Processor{",
          "1360:    &dag.IngressProcessor{},",
          "1361:    &dag.HTTPProxyProcessor{",
          "1362:     DisablePermitInsecure: true,",
          "1363:    },",
          "1364:    &dag.ListenerProcessor{},",
          "1365:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1793: func TestHTTPProxyRouteWithTLS_InsecurePaths_DisablePermitInsecureTrue(t *testing.T) {",
          "1794:  rh, c, done := setup(t, func(reh *contour.EventHandler) {",
          "1796:  })",
          "1798:  defer done()",
          "",
          "[Removed Lines]",
          "1795:   reh.Builder.DisablePermitInsecure = true",
          "",
          "[Added Lines]",
          "1801:   reh.Builder.Processors = []dag.Processor{",
          "1802:    &dag.IngressProcessor{},",
          "1803:    &dag.HTTPProxyProcessor{",
          "1804:     DisablePermitInsecure: true,",
          "1805:    },",
          "1806:    &dag.ListenerProcessor{},",
          "1807:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3e59de851bd4c0d1952c248fd0f127cfd012dc58",
      "candidate_info": {
        "commit_hash": "3e59de851bd4c0d1952c248fd0f127cfd012dc58",
        "repo": "projectcontour/contour",
        "commit_url": "https://github.com/projectcontour/contour/commit/3e59de851bd4c0d1952c248fd0f127cfd012dc58",
        "files": [
          "internal/dag/gatewayapi_processor.go",
          "internal/dag/status_test.go",
          "internal/status/httproutestatus.go",
          "internal/status/httproutestatus_test.go"
        ],
        "message": "internal/status: Update HTTPRoute status to only allow a single Type (#3600)\n\ninternal/status: Update HTTPRoute status to only allow a single Type\n\nUpdates the HTTPRoute status processing to only allow a single \"Type\" to\nbe specified at any given time. If there are duplicate conditions for the same\ntype, then the messages are appended together.\n\nFixes #3534\n\nSigned-off-by: Steve Sloka <slokas@vmware.com>",
        "before_after_code_files": [
          "internal/dag/gatewayapi_processor.go||internal/dag/gatewayapi_processor.go",
          "internal/dag/status_test.go||internal/dag/status_test.go",
          "internal/status/httproutestatus.go||internal/status/httproutestatus.go",
          "internal/status/httproutestatus_test.go||internal/status/httproutestatus_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "internal/dag/gatewayapi_processor.go||internal/dag/gatewayapi_processor.go",
            "internal/dag/status_test.go||internal/dag/status_test.go"
          ],
          "candidate": [
            "internal/dag/gatewayapi_processor.go||internal/dag/gatewayapi_processor.go",
            "internal/dag/status_test.go||internal/dag/status_test.go"
          ]
        }
      },
      "candidate_diff": {
        "internal/dag/gatewayapi_processor.go||internal/dag/gatewayapi_processor.go": [
          "File: internal/dag/gatewayapi_processor.go -> internal/dag/gatewayapi_processor.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "329:    service, err := p.dag.EnsureService(meta, intstr.FromInt(int(*forward.Port)), p.source)",
          "330:    if err != nil {",
          "332:     continue",
          "333:    }",
          "",
          "[Removed Lines]",
          "331:     routeAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, fmt.Sprintf(\"Service %q does not exist in namespace %q\", meta.Name, meta.Namespace))",
          "",
          "[Added Lines]",
          "331:     routeAccessor.AddCondition(status.ConditionResolvedRefs, metav1.ConditionFalse, status.ReasonDegraded, fmt.Sprintf(\"Service %q does not exist\", meta.Name))",
          "",
          "---------------"
        ],
        "internal/dag/status_test.go||internal/dag/status_test.go": [
          "File: internal/dag/status_test.go -> internal/dag/status_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "2504:    var gotConditions []metav1.Condition",
          "2505:    for _, u := range updates {",
          "2507:    }",
          "2509:    ops := []cmp.Option{",
          "2510:     cmpopts.IgnoreFields(metav1.Condition{}, \"LastTransitionTime\"),",
          "2513:     }),",
          "2514:    }",
          "2516:    if diff := cmp.Diff(tc.want, gotConditions, ops...); diff != \"\" {",
          "2517:     t.Fatalf(\"expected: %v, got %v\", tc.want, diff)",
          "2518:    }",
          "2519:   })",
          "2520:  }",
          "",
          "[Removed Lines]",
          "2506:     gotConditions = append(gotConditions, u.Conditions...)",
          "2511:     cmpopts.SortSlices(func(i, j int) bool {",
          "2512:      return tc.want[i].Message < tc.want[j].Message",
          "",
          "[Added Lines]",
          "2506:     for _, cond := range u.Conditions {",
          "2507:      gotConditions = append(gotConditions, cond)",
          "2508:     }",
          "2513:     cmpopts.SortSlices(func(i, j metav1.Condition) bool {",
          "2514:      return i.Message < j.Message",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2666:     },",
          "2667:    }},",
          "2668:   want: []metav1.Condition{{",
          "2674:    Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "2675:    Status:  contour_api_v1.ConditionFalse,",
          "2676:    Reason:  string(status.ReasonErrorsExist),",
          "2677:    Message: \"Errors found, check other Conditions for details.\",",
          "2678:   }},",
          "2679:  })",
          "",
          "[Removed Lines]",
          "2669:    Type:    string(status.ConditionNotImplemented),",
          "2670:    Status:  contour_api_v1.ConditionTrue,",
          "2671:    Reason:  string(status.ReasonPathMatchType),",
          "2672:    Message: \"HTTPRoute.Spec.Rules.PathMatch: Only Prefix match type and Exact match type are supported.\",",
          "2673:   }, {",
          "",
          "[Added Lines]",
          "2676:   }, {",
          "2677:    Type:    string(status.ConditionNotImplemented),",
          "2678:    Status:  contour_api_v1.ConditionTrue,",
          "2679:    Reason:  string(status.ReasonPathMatchType),",
          "2680:    Message: \"HTTPRoute.Spec.Rules.PathMatch: Only Prefix match type and Exact match type are supported.\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2713:     },",
          "2714:    }},",
          "2715:   want: []metav1.Condition{{",
          "2721:    Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "2722:    Status:  contour_api_v1.ConditionFalse,",
          "2723:    Reason:  string(status.ReasonErrorsExist),",
          "2724:    Message: \"Errors found, check other Conditions for details.\",",
          "2725:   }},",
          "2726:  })",
          "",
          "[Removed Lines]",
          "2716:    Type:    string(status.ConditionNotImplemented),",
          "2717:    Status:  contour_api_v1.ConditionTrue,",
          "2718:    Reason:  string(status.ReasonHeaderMatchType),",
          "2719:    Message: \"HTTPRoute.Spec.Rules.HeaderMatch: Only Exact match type is supported.\",",
          "2720:   }, {",
          "",
          "[Added Lines]",
          "2723:   }, {",
          "2724:    Type:    string(status.ConditionNotImplemented),",
          "2725:    Status:  contour_api_v1.ConditionTrue,",
          "2726:    Reason:  string(status.ReasonHeaderMatchType),",
          "2727:    Message: \"HTTPRoute.Spec.Rules.HeaderMatch: Only Exact match type is supported.\",",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2818:   }},",
          "2819:  })",
          "2821:  run(t, \"spec.rules.forwardTo.servicePort not specified\", testcase{",
          "2822:   objs: []interface{}{",
          "2823:    gateway,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2824:  run(t, \"spec.rules.forwardTo.serviceName invalid on two matches\", testcase{",
          "2825:   objs: []interface{}{",
          "2826:    gateway,",
          "2827:    &gatewayapi_v1alpha1.HTTPRoute{",
          "2828:     ObjectMeta: metav1.ObjectMeta{",
          "2829:      Name:      \"basic\",",
          "2830:      Namespace: \"default\",",
          "2831:      Labels: map[string]string{",
          "2832:       \"app\": \"contour\",",
          "2833:      },",
          "2834:     },",
          "2835:     Spec: gatewayapi_v1alpha1.HTTPRouteSpec{",
          "2836:      Hostnames: []gatewayapi_v1alpha1.Hostname{",
          "2837:       \"test.projectcontour.io\",",
          "2838:      },",
          "2839:      Rules: []gatewayapi_v1alpha1.HTTPRouteRule{{",
          "2840:       Matches: []gatewayapi_v1alpha1.HTTPRouteMatch{{",
          "2841:        Path: gatewayapi_v1alpha1.HTTPPathMatch{",
          "2842:         Type:  \"Prefix\",",
          "2843:         Value: \"/\",",
          "2844:        },",
          "2845:       }},",
          "2846:       ForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{",
          "2847:        ServiceName: pointer.StringPtr(\"invalid-one\"),",
          "2848:        Port:        gatewayPort(8080),",
          "2849:       }},",
          "2850:      }, {",
          "2851:       Matches: []gatewayapi_v1alpha1.HTTPRouteMatch{{",
          "2852:        Path: gatewayapi_v1alpha1.HTTPPathMatch{",
          "2853:         Type:  \"Prefix\",",
          "2854:         Value: \"/blog\",",
          "2855:        },",
          "2856:       }},",
          "2857:       ForwardTo: []gatewayapi_v1alpha1.HTTPRouteForwardTo{{",
          "2858:        ServiceName: pointer.StringPtr(\"invalid-two\"),",
          "2859:        Port:        gatewayPort(8080),",
          "2860:       }},",
          "2861:      }},",
          "2862:     },",
          "2863:    }},",
          "2864:   want: []metav1.Condition{{",
          "2865:    Type:    string(status.ConditionResolvedRefs),",
          "2866:    Status:  contour_api_v1.ConditionFalse,",
          "2867:    Reason:  string(status.ReasonDegraded),",
          "2868:    Message: \"Service \\\"invalid-one\\\" does not exist, Service \\\"invalid-two\\\" does not exist\",",
          "2869:   }, {",
          "2870:    Type:    \"Admitted\",",
          "2871:    Status:  contour_api_v1.ConditionFalse,",
          "2872:    Reason:  \"ErrorsExist\",",
          "2873:    Message: \"Errors found, check other Conditions for details.\",",
          "2874:   }},",
          "2875:  })",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3051:     },",
          "3052:    }},",
          "3053:   want: []metav1.Condition{{",
          "3059:    Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "3060:    Status:  contour_api_v1.ConditionFalse,",
          "3061:    Reason:  string(status.ReasonErrorsExist),",
          "3062:    Message: \"Errors found, check other Conditions for details.\",",
          "3063:   }},",
          "3064:  })",
          "",
          "[Removed Lines]",
          "3054:    Type:    string(status.ConditionNotImplemented),",
          "3055:    Status:  contour_api_v1.ConditionTrue,",
          "3056:    Reason:  string(status.ReasonHTTPRouteFilterType),",
          "3057:    Message: \"HTTPRoute.Spec.Rules.Filters: Only RequestHeaderModifier type is supported.\",",
          "3058:   }, {",
          "",
          "[Added Lines]",
          "3114:   }, {",
          "3115:    Type:    string(status.ConditionNotImplemented),",
          "3116:    Status:  contour_api_v1.ConditionTrue,",
          "3117:    Reason:  string(status.ReasonHTTPRouteFilterType),",
          "3118:    Message: \"HTTPRoute.Spec.Rules.Filters: Only RequestHeaderModifier type is supported.\",",
          "",
          "---------------"
        ],
        "internal/status/httproutestatus.go||internal/status/httproutestatus.go": [
          "File: internal/status/httproutestatus.go -> internal/status/httproutestatus.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: type HTTPRouteUpdate struct {",
          "40:  FullName           types.NamespacedName",
          "43:  GatewayRef         types.NamespacedName",
          "44:  Generation         int64",
          "45:  TransitionTime     metav1.Time",
          "",
          "[Removed Lines]",
          "41:  Conditions         []metav1.Condition",
          "42:  ExistingConditions []metav1.Condition",
          "",
          "[Added Lines]",
          "41:  Conditions         map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition",
          "42:  ExistingConditions map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "49: func (routeUpdate *HTTPRouteUpdate) AddCondition(cond gatewayapi_v1alpha1.RouteConditionType, status metav1.ConditionStatus, reason RouteReasonType, message string) metav1.Condition {",
          "50:  newDc := metav1.Condition{",
          "51:   Reason:             string(reason),",
          "52:   Status:             status,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "51:  if c, ok := routeUpdate.Conditions[cond]; ok {",
          "52:   message = fmt.Sprintf(\"%s, %s\", c.Message, message)",
          "53:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "55:   LastTransitionTime: metav1.NewTime(time.Now()),",
          "56:   ObservedGeneration: routeUpdate.Generation,",
          "57:  }",
          "59:  return newDc",
          "60: }",
          "",
          "[Removed Lines]",
          "58:  routeUpdate.Conditions = append(routeUpdate.Conditions, newDc)",
          "",
          "[Added Lines]",
          "63:  routeUpdate.Conditions[cond] = newDc",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "66: func (c *Cache) HTTPRouteAccessor(route *gatewayapi_v1alpha1.HTTPRoute) (*HTTPRouteUpdate, func()) {",
          "67:  pu := &HTTPRouteUpdate{",
          "68:   FullName:           k8s.NamespacedNameOf(route),",
          "70:   ExistingConditions: c.getGatewayConditions(route.Status.Gateways),",
          "71:   GatewayRef:         c.gatewayRef,",
          "72:   Generation:         route.Generation,",
          "",
          "[Removed Lines]",
          "69:   Conditions:         []metav1.Condition{},",
          "",
          "[Added Lines]",
          "74:   Conditions:         make(map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "152:  return httpRoute",
          "153: }",
          "156:  for _, gs := range gatewayStatus {",
          "157:   if c.gatewayRef.Name == gs.GatewayRef.Name &&",
          "158:    c.gatewayRef.Namespace == gs.GatewayRef.Namespace {",
          "160:   }",
          "161:  }",
          "163: }",
          "",
          "[Removed Lines]",
          "155: func (c *Cache) getGatewayConditions(gatewayStatus []gatewayapi_v1alpha1.RouteGatewayStatus) []metav1.Condition {",
          "159:    return gs.Conditions",
          "162:  return []metav1.Condition{}",
          "",
          "[Added Lines]",
          "160: func (c *Cache) getGatewayConditions(gatewayStatus []gatewayapi_v1alpha1.RouteGatewayStatus) map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition {",
          "165:    conditions := make(map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition)",
          "166:    for _, gsCondition := range gs.Conditions {",
          "167:     if val, ok := conditions[gatewayapi_v1alpha1.RouteConditionType(gsCondition.Type)]; !ok {",
          "168:      conditions[gatewayapi_v1alpha1.RouteConditionType(gsCondition.Type)] = val",
          "169:     }",
          "170:    }",
          "171:    return conditions",
          "174:  return map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{}",
          "",
          "---------------"
        ],
        "internal/status/httproutestatus_test.go||internal/status/httproutestatus_test.go": [
          "File: internal/status/httproutestatus_test.go -> internal/status/httproutestatus_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "38:  httpRouteUpdate := HTTPRouteUpdate{",
          "39:   FullName:   k8s.NamespacedNameFrom(\"test/test\"),",
          "40:   Generation: testGeneration,",
          "47:  }",
          "49:  got := httpRouteUpdate.AddCondition(gatewayapi_v1alpha1.ConditionRouteAdmitted, metav1.ConditionTrue, \"Valid\", \"Valid HTTPRoute\")",
          "",
          "[Removed Lines]",
          "41:   Conditions: []metav1.Condition{{",
          "42:    Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "43:    Status:  projectcontour.ConditionTrue,",
          "44:    Reason:  \"Valid\",",
          "45:    Message: \"Valid HTTPRoute\",",
          "46:   }},",
          "",
          "[Added Lines]",
          "41:   Conditions: make(map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1d4526a8d8cd9e86f6425ff78a32e2ac64a2a51d",
      "candidate_info": {
        "commit_hash": "1d4526a8d8cd9e86f6425ff78a32e2ac64a2a51d",
        "repo": "projectcontour/contour",
        "commit_url": "https://github.com/projectcontour/contour/commit/1d4526a8d8cd9e86f6425ff78a32e2ac64a2a51d",
        "files": [
          "internal/dag/builder_test.go",
          "internal/dag/gatewayapi_processor.go",
          "internal/dag/status_test.go",
          "internal/featuretests/v3/httproute_test.go",
          "internal/featuretests/v3/tlsroute_test.go",
          "test/e2e/gateway/008_tlsroute_test.go",
          "test/e2e/gateway/gateway_test.go"
        ],
        "message": "internal/dag: Implement TLSRoute mode:terminate (#3801)\n\nImplements support for GatewayAPI TLSRoute mode: terminate which terminates TLS\nat the Gateway.\n\nUpdates #3440\n\nSigned-off-by: Steve Sloka <slokas@vmware.com>",
        "before_after_code_files": [
          "internal/dag/builder_test.go||internal/dag/builder_test.go",
          "internal/dag/gatewayapi_processor.go||internal/dag/gatewayapi_processor.go",
          "internal/dag/status_test.go||internal/dag/status_test.go",
          "internal/featuretests/v3/tlsroute_test.go||internal/featuretests/v3/tlsroute_test.go",
          "test/e2e/gateway/008_tlsroute_test.go||test/e2e/gateway/008_tlsroute_test.go",
          "test/e2e/gateway/gateway_test.go||test/e2e/gateway/gateway_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "internal/dag/builder_test.go||internal/dag/builder_test.go",
            "internal/dag/gatewayapi_processor.go||internal/dag/gatewayapi_processor.go",
            "internal/dag/status_test.go||internal/dag/status_test.go"
          ],
          "candidate": [
            "internal/dag/builder_test.go||internal/dag/builder_test.go",
            "internal/dag/gatewayapi_processor.go||internal/dag/gatewayapi_processor.go",
            "internal/dag/status_test.go||internal/dag/status_test.go"
          ]
        }
      },
      "candidate_diff": {
        "internal/dag/builder_test.go||internal/dag/builder_test.go": [
          "File: internal/dag/builder_test.go -> internal/dag/builder_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "32:  gatewayapi_v1alpha1 \"sigs.k8s.io/gateway-api/apis/v1alpha1\"",
          "33: )",
          "35: func gatewayPort(port int) *gatewayapi_v1alpha1.PortNumber {",
          "36:  p := gatewayapi_v1alpha1.PortNumber(port)",
          "37:  return &p",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: var sec1 = &v1.Secret{",
          "36:  ObjectMeta: metav1.ObjectMeta{",
          "37:   Name:      \"secret\",",
          "38:   Namespace: \"default\",",
          "39:  },",
          "40:  Type: v1.SecretTypeTLS,",
          "41:  Data: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),",
          "42: }",
          "45: var secInvalid = &v1.Secret{",
          "46:  ObjectMeta: metav1.ObjectMeta{",
          "47:   Name:      \"secret\",",
          "48:   Namespace: \"default\",",
          "49:  },",
          "50:  Type: v1.SecretTypeTLS,",
          "51:  Data: secretdata(\"wrong\", \"wronger\"),",
          "52: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "143:   },",
          "144:  }",
          "146:  hostname := gatewayapi_v1alpha1.Hostname(\"gateway.projectcontour.io\")",
          "147:  wildcardHostname := gatewayapi_v1alpha1.Hostname(\"*.projectcontour.io\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "165:  sec1 := &v1.Secret{",
          "166:   ObjectMeta: metav1.ObjectMeta{",
          "167:    Name:      \"tlscert\",",
          "168:    Namespace: \"projectcontour\",",
          "169:   },",
          "170:   Type: v1.SecretTypeTLS,",
          "171:   Data: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),",
          "172:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "215:    Listeners: []gatewayapi_v1alpha1.Listener{{",
          "216:     Port:     80,",
          "217:     Protocol: gatewayapi_v1alpha1.TLSProtocolType,",
          "218:     Routes: gatewayapi_v1alpha1.RouteBindingSelector{",
          "219:      Kind: KindTLSRoute,",
          "220:      Namespaces: &gatewayapi_v1alpha1.RouteNamespaces{",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "246:     TLS: &gatewayapi_v1alpha1.GatewayTLSConfig{",
          "247:      Mode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),",
          "248:     },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "254:   },",
          "255:   Spec: gatewayapi_v1alpha1.GatewaySpec{",
          "256:    Listeners: []gatewayapi_v1alpha1.Listener{{",
          "258:     Protocol: gatewayapi_v1alpha1.TLSProtocolType,",
          "259:     TLS: &gatewayapi_v1alpha1.GatewayTLSConfig{",
          "260:      Mode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModeTerminate),",
          "261:     },",
          "262:     Routes: gatewayapi_v1alpha1.RouteBindingSelector{",
          "263:      Kind: KindTLSRoute,",
          "",
          "[Removed Lines]",
          "257:     Port:     80,",
          "",
          "[Added Lines]",
          "288:     Port:     443,",
          "292:      CertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{",
          "293:       Group: \"core\",",
          "294:       Kind:  \"Secret\",",
          "295:       Name:  sec1.Name,",
          "296:      },",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "297:    Listeners: []gatewayapi_v1alpha1.Listener{{",
          "298:     Port:     80,",
          "299:     Protocol: gatewayapi_v1alpha1.TLSProtocolType,",
          "300:     Routes: gatewayapi_v1alpha1.RouteBindingSelector{",
          "301:      Kind: KindTLSRoute,",
          "302:      Namespaces: &gatewayapi_v1alpha1.RouteNamespaces{",
          "303:       From: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectSame),",
          "304:      },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "336:     TLS: &gatewayapi_v1alpha1.GatewayTLSConfig{",
          "337:      Mode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),",
          "338:     },",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "317:   },",
          "318:  }",
          "329:  gatewayWithOnlyTLS := &gatewayapi_v1alpha1.Gateway{",
          "330:   ObjectMeta: metav1.ObjectMeta{",
          "331:    Name:      \"contour\",",
          "",
          "[Removed Lines]",
          "320:  sec1 := &v1.Secret{",
          "321:   ObjectMeta: metav1.ObjectMeta{",
          "322:    Name:      \"tlscert\",",
          "323:    Namespace: \"projectcontour\",",
          "324:   },",
          "325:   Type: v1.SecretTypeTLS,",
          "326:   Data: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),",
          "327:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1071:    },",
          "1072:    want: listeners(),",
          "1073:   },",
          "1075:    gateway: gatewayTLSRouteModeTerminate,",
          "1076:    objs: []interface{}{",
          "1077:     &v1.Namespace{",
          "1078:      ObjectMeta: metav1.ObjectMeta{",
          "",
          "[Removed Lines]",
          "1074:   \"TLSRoute with TLS.Mode=Terminate is invalid when TLS is not defined\": {",
          "",
          "[Added Lines]",
          "1105:   \"TLSRoute with TLS.Mode=Terminate\": {",
          "1107:    objs: []interface{}{",
          "1108:     kuardService,",
          "1109:     sec1,",
          "1110:     &gatewayapi_v1alpha1.TLSRoute{",
          "1111:      ObjectMeta: metav1.ObjectMeta{",
          "1112:       Name:      \"basic\",",
          "1113:       Namespace: \"projectcontour\",",
          "1114:      },",
          "1115:      Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "1116:       Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "1117:        Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "1118:       },",
          "1119:       Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "1120:        Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "1121:         SNIs: []gatewayapi_v1alpha1.Hostname{",
          "1122:          \"test.projectcontour.io\",",
          "1123:         },",
          "1124:        }},",
          "1125:        ForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),",
          "1126:       }},",
          "1127:      },",
          "1128:     },",
          "1129:    },",
          "1130:    want: listeners(",
          "1131:     &Listener{",
          "1132:      Port: 443,",
          "1133:      VirtualHosts: virtualhosts(",
          "1134:       &SecureVirtualHost{",
          "1135:        VirtualHost: VirtualHost{",
          "1136:         Name:         \"test.projectcontour.io\",",
          "1137:         ListenerName: \"ingress_https\",",
          "1138:        },",
          "1139:        TCPProxy: &TCPProxy{",
          "1140:         Clusters: clusters(",
          "1141:          service(kuardService),",
          "1142:         ),",
          "1143:        },",
          "1144:        Secret: secret(sec1),",
          "1145:       },",
          "1146:      ),",
          "1147:     },",
          "1148:    ),",
          "1149:   },",
          "1150:   \"TLSRoute with TLS.Mode=Terminate, invalid cert\": {",
          "1151:    gateway: &gatewayapi_v1alpha1.Gateway{",
          "1152:     ObjectMeta: metav1.ObjectMeta{",
          "1153:      Name:      \"contour\",",
          "1154:      Namespace: \"projectcontour\",",
          "1155:     },",
          "1156:     Spec: gatewayapi_v1alpha1.GatewaySpec{",
          "1157:      Listeners: []gatewayapi_v1alpha1.Listener{{",
          "1158:       Port:     443,",
          "1159:       Protocol: gatewayapi_v1alpha1.TLSProtocolType,",
          "1160:       TLS: &gatewayapi_v1alpha1.GatewayTLSConfig{",
          "1161:        Mode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModeTerminate),",
          "1162:        CertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{",
          "1163:         Group: \"core\",",
          "1164:         Kind:  \"Secret\",",
          "1165:         Name:  secInvalid.Name,",
          "1166:        },",
          "1167:       },",
          "1168:       Routes: gatewayapi_v1alpha1.RouteBindingSelector{",
          "1169:        Kind: KindTLSRoute,",
          "1170:        Namespaces: &gatewayapi_v1alpha1.RouteNamespaces{",
          "1171:         From: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),",
          "1172:        },",
          "1173:       },",
          "1174:      }},",
          "1175:     },",
          "1176:    },",
          "1177:    objs: []interface{}{",
          "1178:     kuardService,",
          "1179:     secInvalid,",
          "1180:     &gatewayapi_v1alpha1.TLSRoute{",
          "1181:      ObjectMeta: metav1.ObjectMeta{",
          "1182:       Name:      \"basic\",",
          "1183:       Namespace: \"projectcontour\",",
          "1184:      },",
          "1185:      Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "1186:       Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "1187:        Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "1188:       },",
          "1189:       Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "1190:        Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "1191:         SNIs: []gatewayapi_v1alpha1.Hostname{",
          "1192:          \"test.projectcontour.io\",",
          "1193:         },",
          "1194:        }},",
          "1195:        ForwardTo: tcpRouteForwardTo(\"kuard\", 8080, 0),",
          "1196:       }},",
          "1197:      },",
          "1198:     },",
          "1199:    },",
          "1200:    want: listeners(),",
          "1201:   },",
          "1202:   \"TLSRoute with TLS.Mode=Terminate is invalid when TLS is not defined\": {",
          "1203:    gateway: &gatewayapi_v1alpha1.Gateway{",
          "1204:     ObjectMeta: metav1.ObjectMeta{",
          "1205:      Name:      \"contour\",",
          "1206:      Namespace: \"projectcontour\",",
          "1207:     },",
          "1208:     Spec: gatewayapi_v1alpha1.GatewaySpec{",
          "1209:      Listeners: []gatewayapi_v1alpha1.Listener{{",
          "1210:       Port:     80,",
          "1211:       Protocol: gatewayapi_v1alpha1.TLSProtocolType,",
          "1212:       TLS: &gatewayapi_v1alpha1.GatewayTLSConfig{",
          "1213:        Mode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModeTerminate),",
          "1214:       },",
          "1215:       Routes: gatewayapi_v1alpha1.RouteBindingSelector{",
          "1216:        Kind: KindTLSRoute,",
          "1217:        Namespaces: &gatewayapi_v1alpha1.RouteNamespaces{",
          "1218:         From: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),",
          "1219:        },",
          "1220:       },",
          "1221:      }},",
          "1222:     },",
          "1223:    },",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3277:  sec3 := &v1.Secret{",
          "",
          "[Removed Lines]",
          "3256:  sec1 := &v1.Secret{",
          "3257:   ObjectMeta: metav1.ObjectMeta{",
          "3258:    Name:      \"secret\",",
          "3259:    Namespace: \"default\",",
          "3260:   },",
          "3261:   Type: v1.SecretTypeTLS,",
          "3262:   Data: secretdata(fixture.CERTIFICATE, fixture.RSA_PRIVATE_KEY),",
          "3263:  }",
          "3266:  sec2 := &v1.Secret{",
          "3267:   ObjectMeta: metav1.ObjectMeta{",
          "3268:    Name:      \"secret\",",
          "3269:    Namespace: \"default\",",
          "3270:   },",
          "3271:   Type: v1.SecretTypeTLS,",
          "3272:   Data: secretdata(\"wrong\", \"wronger\"),",
          "3273:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6605:   },",
          "6606:   \"ingressv1: insert invalid secret then ingress w/o tls\": {",
          "6607:    objs: []interface{}{",
          "6609:     i1V1,",
          "6610:    },",
          "6611:    want: listeners(),",
          "",
          "[Removed Lines]",
          "6608:     sec2,",
          "",
          "[Added Lines]",
          "6737:     secInvalid,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "6613:   \"ingressv1: insert service, invalid secret then ingress w/o tls\": {",
          "6614:    objs: []interface{}{",
          "6615:     s1,",
          "6617:     i1V1,",
          "6618:    },",
          "6619:    want: listeners(",
          "",
          "[Removed Lines]",
          "6616:     sec2,",
          "",
          "[Added Lines]",
          "6745:     secInvalid,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "6627:   },",
          "6628:   \"ingressv1: insert invalid secret then ingress w/ tls\": {",
          "6629:    objs: []interface{}{",
          "6631:     i3V1,",
          "6632:    },",
          "6633:    want: listeners(),",
          "",
          "[Removed Lines]",
          "6630:     sec2,",
          "",
          "[Added Lines]",
          "6759:     secInvalid,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "6635:   \"ingressv1: insert service, invalid secret then ingress w/ tls\": {",
          "6636:    objs: []interface{}{",
          "6637:     s1,",
          "6639:     i3V1,",
          "6640:    },",
          "6641:    want: listeners(",
          "",
          "[Removed Lines]",
          "6638:     sec2,",
          "",
          "[Added Lines]",
          "6767:     secInvalid,",
          "",
          "---------------"
        ],
        "internal/dag/gatewayapi_processor.go||internal/dag/gatewayapi_processor.go": [
          "File: internal/dag/gatewayapi_processor.go -> internal/dag/gatewayapi_processor.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "95:    }",
          "96:   case gatewayapi_v1alpha1.TLSProtocolType:",
          "113:      }",
          "114:     }",
          "115:    }",
          "",
          "[Removed Lines]",
          "98:    if tlsConfig := listener.TLS; tlsConfig != nil {",
          "99:     if tlsConfig.Mode != nil {",
          "100:      switch *tlsConfig.Mode {",
          "101:      case gatewayapi_v1alpha1.TLSModeTerminate:",
          "103:       if listenerSecret = p.validGatewayTLS(listener); listenerSecret == nil {",
          "106:        continue",
          "107:       }",
          "108:      case gatewayapi_v1alpha1.TLSModePassthrough:",
          "109:       if listener.TLS.CertificateRef != nil {",
          "110:        p.Errorf(\"Listener.TLS cannot be defined when TLS Mode is %q.\", tlsConfig.Mode)",
          "111:        continue",
          "112:       }",
          "",
          "[Added Lines]",
          "99:    if listener.TLS == nil {",
          "100:     p.Errorf(\"Listener.TLS is required when protocol is %q.\", listener.Protocol)",
          "101:     continue",
          "102:    }",
          "104:    if listener.TLS.Mode != nil {",
          "105:     switch *listener.TLS.Mode {",
          "106:     case gatewayapi_v1alpha1.TLSModeTerminate:",
          "108:      if listenerSecret = p.validGatewayTLS(listener); listenerSecret == nil {",
          "111:       continue",
          "112:      }",
          "113:     case gatewayapi_v1alpha1.TLSModePassthrough:",
          "114:      if listener.TLS.CertificateRef != nil {",
          "115:       p.Errorf(\"Listener.TLS.CertificateRef cannot be defined when TLS Mode is %q.\", *listener.TLS.Mode)",
          "116:       continue",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "232:   for _, matchingRoute := range matchingTLSRoutes {",
          "234:   }",
          "235:  }",
          "236: }",
          "",
          "[Removed Lines]",
          "233:    p.computeTLSRoute(matchingRoute)",
          "",
          "[Added Lines]",
          "237:    p.computeTLSRoute(matchingRoute, listenerSecret)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "238: func (p *GatewayAPIProcessor) validGatewayTLS(listener gatewayapi_v1alpha1.Listener) *Secret {",
          "242:   p.Errorf(\"Spec.VirtualHost.TLS.CertificateRef is not configured.\")",
          "243:   return nil",
          "244:  }",
          "",
          "[Removed Lines]",
          "241:  if listener.TLS.CertificateRef == nil {",
          "",
          "[Added Lines]",
          "245:  if listener.TLS == nil || listener.TLS.CertificateRef == nil {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "445:  return true, nil",
          "446: }",
          "450:  routeAccessor, commit := p.dag.StatusCache.ConditionsAccessor(k8s.NamespacedNameOf(route), route.Generation, status.ResourceTLSRoute, route.Status.Gateways)",
          "451:  defer commit()",
          "",
          "[Removed Lines]",
          "448: func (p *GatewayAPIProcessor) computeTLSRoute(route *gatewayapi_v1alpha1.TLSRoute) {",
          "",
          "[Added Lines]",
          "452: func (p *GatewayAPIProcessor) computeTLSRoute(route *gatewayapi_v1alpha1.TLSRoute, listenerSecret *Secret) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "514:   for _, host := range hosts {",
          "515:    secure := p.dag.EnsureSecureVirtualHost(ListenerName{Name: host, ListenerName: \"ingress_https\"})",
          "516:    secure.TCPProxy = &proxy",
          "517:   }",
          "518:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "521:    if listenerSecret != nil {",
          "522:     secure.Secret = listenerSecret",
          "523:    }",
          "",
          "---------------"
        ],
        "internal/dag/status_test.go||internal/dag/status_test.go": [
          "File: internal/dag/status_test.go -> internal/dag/status_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "3383: func TestGatewayAPITLSRouteDAGStatus(t *testing.T) {",
          "3385:  type testcase struct {",
          "3388:  }",
          "3390:  run := func(t *testing.T, desc string, tc testcase) {",
          "",
          "[Removed Lines]",
          "3386:   objs []interface{}",
          "3387:   want []*status.ConditionsUpdate",
          "",
          "[Added Lines]",
          "3386:   objs    []interface{}",
          "3387:   gateway *gatewayapi_v1alpha1.Gateway",
          "3388:   want    []*status.ConditionsUpdate",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3399:       Namespace: \"contour\",",
          "3400:       Name:      \"projectcontour\",",
          "3401:      },",
          "3422:     },",
          "3423:     Processors: []Processor{",
          "3424:      &IngressProcessor{",
          "",
          "[Removed Lines]",
          "3402:      gateway: &gatewayapi_v1alpha1.Gateway{",
          "3403:       ObjectMeta: metav1.ObjectMeta{",
          "3404:        Name:      \"contour\",",
          "3405:        Namespace: \"projectcontour\",",
          "3406:       },",
          "3407:       Spec: gatewayapi_v1alpha1.GatewaySpec{",
          "3408:        Listeners: []gatewayapi_v1alpha1.Listener{{",
          "3409:         Port:     80,",
          "3410:         Protocol: gatewayapi_v1alpha1.TLSProtocolType,",
          "3411:         Routes: gatewayapi_v1alpha1.RouteBindingSelector{",
          "3412:          Selector: &metav1.LabelSelector{",
          "3413:           MatchLabels: map[string]string{",
          "3414:            \"app\": \"contour\",",
          "3415:           },",
          "3416:          },",
          "3417:          Kind: KindTLSRoute,",
          "3418:         },",
          "3419:        }},",
          "3420:       },",
          "3421:      },",
          "",
          "[Added Lines]",
          "3403:      gateway: tc.gateway,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3431:      &ListenerProcessor{},",
          "3432:     },",
          "3433:    }",
          "3434:    for _, o := range tc.objs {",
          "3435:     builder.Source.Insert(o)",
          "3436:    }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3418:    builder.Source.Insert(fixture.SecretProjectContourCert)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3456:   })",
          "3457:  }",
          "3459:  kuardService := &v1.Service{",
          "3460:   ObjectMeta: metav1.ObjectMeta{",
          "3461:    Name:      \"kuard\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3445:  gateways := []*gatewayapi_v1alpha1.Gateway{{",
          "3446:   ObjectMeta: metav1.ObjectMeta{",
          "3447:    Name:      \"contour\",",
          "3448:    Namespace: \"projectcontour\",",
          "3449:   },",
          "3450:   Spec: gatewayapi_v1alpha1.GatewaySpec{",
          "3451:    Listeners: []gatewayapi_v1alpha1.Listener{{",
          "3452:     Port:     443,",
          "3453:     Protocol: gatewayapi_v1alpha1.TLSProtocolType,",
          "3454:     TLS: &gatewayapi_v1alpha1.GatewayTLSConfig{",
          "3456:      CertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{",
          "3457:       Group: \"core\",",
          "3458:       Kind:  \"Secret\",",
          "3459:       Name:  fixture.SecretProjectContourCert.Name,",
          "3460:      },",
          "3461:     },",
          "3462:     Routes: gatewayapi_v1alpha1.RouteBindingSelector{",
          "3463:      Selector: &metav1.LabelSelector{",
          "3464:       MatchLabels: map[string]string{",
          "3465:        \"app\": \"contour\",",
          "3466:       },",
          "3467:      },",
          "3468:      Kind: KindTLSRoute,",
          "3469:     },",
          "3470:    }},",
          "3471:   },",
          "3472:  }, {",
          "3473:   ObjectMeta: metav1.ObjectMeta{",
          "3474:    Name:      \"contour\",",
          "3475:    Namespace: \"projectcontour\",",
          "3476:   },",
          "3477:   Spec: gatewayapi_v1alpha1.GatewaySpec{",
          "3478:    Listeners: []gatewayapi_v1alpha1.Listener{{",
          "3479:     Port:     443,",
          "3480:     Protocol: gatewayapi_v1alpha1.TLSProtocolType,",
          "3481:     TLS: &gatewayapi_v1alpha1.GatewayTLSConfig{",
          "3482:      Mode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModeTerminate),",
          "3483:      CertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{",
          "3484:       Group: \"core\",",
          "3485:       Kind:  \"Secret\",",
          "3486:       Name:  fixture.SecretProjectContourCert.Name,",
          "3487:      },",
          "3488:     },",
          "3489:     Routes: gatewayapi_v1alpha1.RouteBindingSelector{",
          "3490:      Selector: &metav1.LabelSelector{",
          "3491:       MatchLabels: map[string]string{",
          "3492:        \"app\": \"contour\",",
          "3493:       },",
          "3494:      },",
          "3495:      Kind: KindTLSRoute,",
          "3496:     },",
          "3497:    }},",
          "3498:   },",
          "3499:  }, {",
          "3500:   ObjectMeta: metav1.ObjectMeta{",
          "3501:    Name:      \"contour\",",
          "3502:    Namespace: \"projectcontour\",",
          "3503:   },",
          "3504:   Spec: gatewayapi_v1alpha1.GatewaySpec{",
          "3505:    Listeners: []gatewayapi_v1alpha1.Listener{{",
          "3506:     Port:     443,",
          "3507:     Protocol: gatewayapi_v1alpha1.TLSProtocolType,",
          "3508:     TLS: &gatewayapi_v1alpha1.GatewayTLSConfig{",
          "3509:      Mode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),",
          "3510:     },",
          "3511:     Routes: gatewayapi_v1alpha1.RouteBindingSelector{",
          "3512:      Selector: &metav1.LabelSelector{",
          "3513:       MatchLabels: map[string]string{",
          "3514:        \"app\": \"contour\",",
          "3515:       },",
          "3516:      },",
          "3517:      Kind: KindTLSRoute,",
          "3518:     },",
          "3519:    }},",
          "3520:   },",
          "3521:  }}",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3471:   },",
          "3472:  }",
          "3488:      },",
          "3496:       }},",
          "3498:     },",
          "3499:    }},",
          "3532:      },",
          "3548:       }},",
          "3550:     },",
          "3551:    }},",
          "3585:      },",
          "3593:       }},",
          "3595:     },",
          "3596:    }},",
          "3630:      },",
          "3634:       }},",
          "3636:     },",
          "3637:    }},",
          "3671:      },",
          "3679:       }},",
          "3681:     },",
          "3682:    }},",
          "3716:      },",
          "3724:       }},",
          "3726:     },",
          "3727:    }},",
          "3761:      },",
          "3769:       }},",
          "3771:     },",
          "3772:    }},",
          "3791: }",
          "",
          "[Removed Lines]",
          "3474:  run(t, \"TLSRoute: spec.rules.forwardTo.serviceName not specified\", testcase{",
          "3475:   objs: []interface{}{",
          "3476:    kuardService,",
          "3477:    &gatewayapi_v1alpha1.TLSRoute{",
          "3478:     ObjectMeta: metav1.ObjectMeta{",
          "3479:      Name:      \"basic\",",
          "3480:      Namespace: \"default\",",
          "3481:      Labels: map[string]string{",
          "3482:       \"app\": \"contour\",",
          "3483:      },",
          "3484:     },",
          "3485:     Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "3486:      Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "3487:       Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "3489:      Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "3490:       Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3491:        SNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},",
          "3492:       }},",
          "3493:       ForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{",
          "3494:        ServiceName: nil,",
          "3495:        Port:        gatewayPort(8080),",
          "3497:      }},",
          "3500:   want: []*status.ConditionsUpdate{{",
          "3501:    FullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},",
          "3502:    Conditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{",
          "3503:     status.ConditionResolvedRefs: {",
          "3504:      Type:    string(status.ConditionResolvedRefs),",
          "3505:      Status:  contour_api_v1.ConditionFalse,",
          "3506:      Reason:  string(status.ReasonDegraded),",
          "3507:      Message: \"Spec.Rules.ForwardTo.ServiceName must be specified\",",
          "3508:     },",
          "3509:     gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
          "3510:      Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "3511:      Status:  contour_api_v1.ConditionFalse,",
          "3512:      Reason:  \"ErrorsExist\",",
          "3513:      Message: \"Errors found, check other Conditions for details.\",",
          "3514:     },",
          "3515:    },",
          "3516:   }},",
          "3517:  })",
          "3519:  run(t, \"TLSRoute: spec.rules.forwardTo.serviceName invalid on two matches\", testcase{",
          "3520:   objs: []interface{}{",
          "3521:    &gatewayapi_v1alpha1.TLSRoute{",
          "3522:     ObjectMeta: metav1.ObjectMeta{",
          "3523:      Name:      \"basic\",",
          "3524:      Namespace: \"default\",",
          "3525:      Labels: map[string]string{",
          "3526:       \"app\": \"contour\",",
          "3527:      },",
          "3528:     },",
          "3529:     Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "3530:      Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "3531:       Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "3533:      Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "3534:       Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3535:        SNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},",
          "3536:       }},",
          "3537:       ForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{",
          "3538:        ServiceName: pointer.StringPtr(\"invalid-one\"),",
          "3539:        Port:        gatewayPort(8080),",
          "3540:       }},",
          "3541:      }, {",
          "3542:       Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3543:        SNIs: []gatewayapi_v1alpha1.Hostname{\"another.projectcontour.io\"},",
          "3544:       }},",
          "3545:       ForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{",
          "3546:        ServiceName: pointer.StringPtr(\"invalid-two\"),",
          "3547:        Port:        gatewayPort(8080),",
          "3549:      }},",
          "3552:   want: []*status.ConditionsUpdate{{",
          "3553:    FullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},",
          "3554:    Conditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{",
          "3555:     status.ConditionResolvedRefs: {",
          "3556:      Type:    string(status.ConditionResolvedRefs),",
          "3557:      Status:  contour_api_v1.ConditionFalse,",
          "3558:      Reason:  string(status.ReasonDegraded),",
          "3559:      Message: \"service \\\"invalid-one\\\" does not exist, service \\\"invalid-two\\\" does not exist\",",
          "3560:     },",
          "3561:     gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
          "3562:      Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "3563:      Status:  contour_api_v1.ConditionFalse,",
          "3564:      Reason:  \"ErrorsExist\",",
          "3565:      Message: \"Errors found, check other Conditions for details.\",",
          "3566:     },",
          "3567:    },",
          "3568:   }},",
          "3569:  })",
          "3571:  run(t, \"TLSRoute: spec.rules.forwardTo.servicePort not specified\", testcase{",
          "3572:   objs: []interface{}{",
          "3573:    kuardService,",
          "3574:    &gatewayapi_v1alpha1.TLSRoute{",
          "3575:     ObjectMeta: metav1.ObjectMeta{",
          "3576:      Name:      \"basic\",",
          "3577:      Namespace: \"default\",",
          "3578:      Labels: map[string]string{",
          "3579:       \"app\": \"contour\",",
          "3580:      },",
          "3581:     },",
          "3582:     Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "3583:      Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "3584:       Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "3586:      Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "3587:       Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3588:        SNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},",
          "3589:       }},",
          "3590:       ForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{",
          "3591:        ServiceName: pointer.StringPtr(\"kuard\"),",
          "3592:        Port:        nil,",
          "3594:      }},",
          "3597:   want: []*status.ConditionsUpdate{{",
          "3598:    FullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},",
          "3599:    Conditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{",
          "3600:     status.ConditionResolvedRefs: {",
          "3601:      Type:    string(status.ConditionResolvedRefs),",
          "3602:      Status:  contour_api_v1.ConditionFalse,",
          "3603:      Reason:  string(status.ReasonDegraded),",
          "3604:      Message: \"Spec.Rules.ForwardTo.ServicePort must be specified\",",
          "3605:     },",
          "3606:     gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
          "3607:      Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "3608:      Status:  contour_api_v1.ConditionFalse,",
          "3609:      Reason:  \"ErrorsExist\",",
          "3610:      Message: \"Errors found, check other Conditions for details.\",",
          "3611:     },",
          "3612:    },",
          "3613:   }},",
          "3614:  })",
          "3616:  run(t, \"TLSRoute: spec.rules.forwardTo not specified\", testcase{",
          "3617:   objs: []interface{}{",
          "3618:    kuardService,",
          "3619:    &gatewayapi_v1alpha1.TLSRoute{",
          "3620:     ObjectMeta: metav1.ObjectMeta{",
          "3621:      Name:      \"basic\",",
          "3622:      Namespace: \"default\",",
          "3623:      Labels: map[string]string{",
          "3624:       \"app\": \"contour\",",
          "3625:      },",
          "3626:     },",
          "3627:     Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "3628:      Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "3629:       Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "3631:      Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "3632:       Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3633:        SNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},",
          "3635:      }},",
          "3638:   want: []*status.ConditionsUpdate{{",
          "3639:    FullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},",
          "3640:    Conditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{",
          "3641:     status.ConditionResolvedRefs: {",
          "3642:      Type:    string(status.ConditionResolvedRefs),",
          "3643:      Status:  contour_api_v1.ConditionFalse,",
          "3644:      Reason:  string(status.ReasonDegraded),",
          "3645:      Message: \"At least one Spec.Rules.ForwardTo must be specified.\",",
          "3646:     },",
          "3647:     gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
          "3648:      Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "3649:      Status:  contour_api_v1.ConditionFalse,",
          "3650:      Reason:  \"ErrorsExist\",",
          "3651:      Message: \"Errors found, check other Conditions for details.\",",
          "3652:     },",
          "3653:    },",
          "3654:   }},",
          "3655:  })",
          "3657:  run(t, \"TLSRoute: spec.rules.hostname: invalid wildcard\", testcase{",
          "3658:   objs: []interface{}{",
          "3659:    kuardService,",
          "3660:    &gatewayapi_v1alpha1.TLSRoute{",
          "3661:     ObjectMeta: metav1.ObjectMeta{",
          "3662:      Name:      \"basic\",",
          "3663:      Namespace: \"default\",",
          "3664:      Labels: map[string]string{",
          "3665:       \"app\": \"contour\",",
          "3666:      },",
          "3667:     },",
          "3668:     Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "3669:      Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "3670:       Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "3672:      Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "3673:       Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3674:        SNIs: []gatewayapi_v1alpha1.Hostname{\"*.*.projectcontour.io\"},",
          "3675:       }},",
          "3676:       ForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{",
          "3677:        ServiceName: pointer.StringPtr(\"kuard\"),",
          "3678:        Port:        gatewayPort(8080),",
          "3680:      }},",
          "3683:   want: []*status.ConditionsUpdate{{",
          "3684:    FullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},",
          "3685:    Conditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{",
          "3686:     status.ConditionResolvedRefs: {",
          "3687:      Type:    string(status.ConditionResolvedRefs),",
          "3688:      Status:  contour_api_v1.ConditionFalse,",
          "3689:      Reason:  string(status.ReasonDegraded),",
          "3690:      Message: \"invalid hostname \\\"*.*.projectcontour.io\\\": [a wildcard DNS-1123 subdomain must start with '*.', followed by a valid DNS subdomain, which must consist of lower case alphanumeric characters, '-' or '.' and end with an alphanumeric character (e.g. '*.example.com', regex used for validation is '\\\\*\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*')]\",",
          "3691:     },",
          "3692:     gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
          "3693:      Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "3694:      Status:  contour_api_v1.ConditionFalse,",
          "3695:      Reason:  \"ErrorsExist\",",
          "3696:      Message: \"Errors found, check other Conditions for details.\",",
          "3697:     },",
          "3698:    },",
          "3699:   }},",
          "3700:  })",
          "3702:  run(t, \"TLSRoute: spec.rules.hostname: invalid hostname\", testcase{",
          "3703:   objs: []interface{}{",
          "3704:    kuardService,",
          "3705:    &gatewayapi_v1alpha1.TLSRoute{",
          "3706:     ObjectMeta: metav1.ObjectMeta{",
          "3707:      Name:      \"basic\",",
          "3708:      Namespace: \"default\",",
          "3709:      Labels: map[string]string{",
          "3710:       \"app\": \"contour\",",
          "3711:      },",
          "3712:     },",
          "3713:     Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "3714:      Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "3715:       Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "3717:      Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "3718:       Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3719:        SNIs: []gatewayapi_v1alpha1.Hostname{\"#projectcontour.io\"},",
          "3720:       }},",
          "3721:       ForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{",
          "3722:        ServiceName: pointer.StringPtr(\"kuard\"),",
          "3723:        Port:        gatewayPort(8080),",
          "3725:      }},",
          "3728:   want: []*status.ConditionsUpdate{{",
          "3729:    FullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},",
          "3730:    Conditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{",
          "3731:     status.ConditionResolvedRefs: {",
          "3732:      Type:    string(status.ConditionResolvedRefs),",
          "3733:      Status:  contour_api_v1.ConditionFalse,",
          "3734:      Reason:  string(status.ReasonDegraded),",
          "3735:      Message: \"invalid hostname \\\"#projectcontour.io\\\": [a lowercase RFC 1123 subdomain must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character (e.g. 'example.com', regex used for validation is '[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*')]\",",
          "3736:     },",
          "3737:     gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
          "3738:      Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "3739:      Status:  contour_api_v1.ConditionFalse,",
          "3740:      Reason:  \"ErrorsExist\",",
          "3741:      Message: \"Errors found, check other Conditions for details.\",",
          "3742:     },",
          "3743:    },",
          "3744:   }},",
          "3745:  })",
          "3747:  run(t, \"TLSRoute: spec.rules.hostname: invalid hostname, ip address\", testcase{",
          "3748:   objs: []interface{}{",
          "3749:    kuardService,",
          "3750:    &gatewayapi_v1alpha1.TLSRoute{",
          "3751:     ObjectMeta: metav1.ObjectMeta{",
          "3752:      Name:      \"basic\",",
          "3753:      Namespace: \"default\",",
          "3754:      Labels: map[string]string{",
          "3755:       \"app\": \"contour\",",
          "3756:      },",
          "3757:     },",
          "3758:     Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "3759:      Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "3760:       Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "3762:      Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "3763:       Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3764:        SNIs: []gatewayapi_v1alpha1.Hostname{\"1.2.3.4\"},",
          "3765:       }},",
          "3766:       ForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{",
          "3767:        ServiceName: pointer.StringPtr(\"kuard\"),",
          "3768:        Port:        gatewayPort(8080),",
          "3770:      }},",
          "3773:   want: []*status.ConditionsUpdate{{",
          "3774:    FullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},",
          "3775:    Conditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{",
          "3776:     status.ConditionResolvedRefs: {",
          "3777:      Type:    string(status.ConditionResolvedRefs),",
          "3778:      Status:  contour_api_v1.ConditionFalse,",
          "3779:      Reason:  string(status.ReasonDegraded),",
          "3780:      Message: \"hostname \\\"1.2.3.4\\\" must be a DNS name, not an IP address\",",
          "3781:     },",
          "3782:     gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
          "3783:      Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "3784:      Status:  contour_api_v1.ConditionFalse,",
          "3785:      Reason:  \"ErrorsExist\",",
          "3786:      Message: \"Errors found, check other Conditions for details.\",",
          "3787:     },",
          "3788:    },",
          "3789:   }},",
          "3790:  })",
          "",
          "[Added Lines]",
          "3541:  for _, gw := range gateways {",
          "3543:   run(t, \"TLSRoute: spec.rules.forwardTo.serviceName not specified\", testcase{",
          "3544:    gateway: gw,",
          "3545:    objs: []interface{}{",
          "3546:     kuardService,",
          "3547:     &gatewayapi_v1alpha1.TLSRoute{",
          "3548:      ObjectMeta: metav1.ObjectMeta{",
          "3549:       Name:      \"basic\",",
          "3550:       Namespace: \"default\",",
          "3551:       Labels: map[string]string{",
          "3552:        \"app\": \"contour\",",
          "3553:       },",
          "3555:      Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "3556:       Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "3557:        Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "3558:       },",
          "3559:       Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "3560:        Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3561:         SNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},",
          "3562:        }},",
          "3563:        ForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{",
          "3564:         ServiceName: nil,",
          "3565:         Port:        gatewayPort(8080),",
          "3566:        }},",
          "3568:      },",
          "3569:     }},",
          "3570:    want: []*status.ConditionsUpdate{{",
          "3571:     FullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},",
          "3572:     Conditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{",
          "3573:      status.ConditionResolvedRefs: {",
          "3574:       Type:    string(status.ConditionResolvedRefs),",
          "3575:       Status:  contour_api_v1.ConditionFalse,",
          "3576:       Reason:  string(status.ReasonDegraded),",
          "3577:       Message: \"Spec.Rules.ForwardTo.ServiceName must be specified\",",
          "3578:      },",
          "3579:      gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
          "3580:       Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "3581:       Status:  contour_api_v1.ConditionFalse,",
          "3582:       Reason:  \"ErrorsExist\",",
          "3583:       Message: \"Errors found, check other Conditions for details.\",",
          "3584:      },",
          "3587:   })",
          "3589:   run(t, \"TLSRoute: spec.rules.forwardTo.serviceName invalid on two matches\", testcase{",
          "3590:    gateway: gw,",
          "3591:    objs: []interface{}{",
          "3592:     &gatewayapi_v1alpha1.TLSRoute{",
          "3593:      ObjectMeta: metav1.ObjectMeta{",
          "3594:       Name:      \"basic\",",
          "3595:       Namespace: \"default\",",
          "3596:       Labels: map[string]string{",
          "3597:        \"app\": \"contour\",",
          "3598:       },",
          "3600:      Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "3601:       Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "3602:        Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "3603:       },",
          "3604:       Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "3605:        Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3606:         SNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},",
          "3607:        }},",
          "3608:        ForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{",
          "3609:         ServiceName: pointer.StringPtr(\"invalid-one\"),",
          "3610:         Port:        gatewayPort(8080),",
          "3611:        }},",
          "3612:       }, {",
          "3613:        Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3614:         SNIs: []gatewayapi_v1alpha1.Hostname{\"another.projectcontour.io\"},",
          "3615:        }},",
          "3616:        ForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{",
          "3617:         ServiceName: pointer.StringPtr(\"invalid-two\"),",
          "3618:         Port:        gatewayPort(8080),",
          "3619:        }},",
          "3621:      },",
          "3622:     }},",
          "3623:    want: []*status.ConditionsUpdate{{",
          "3624:     FullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},",
          "3625:     Conditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{",
          "3626:      status.ConditionResolvedRefs: {",
          "3627:       Type:    string(status.ConditionResolvedRefs),",
          "3628:       Status:  contour_api_v1.ConditionFalse,",
          "3629:       Reason:  string(status.ReasonDegraded),",
          "3630:       Message: \"service \\\"invalid-one\\\" does not exist, service \\\"invalid-two\\\" does not exist\",",
          "3631:      },",
          "3632:      gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
          "3633:       Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "3634:       Status:  contour_api_v1.ConditionFalse,",
          "3635:       Reason:  \"ErrorsExist\",",
          "3636:       Message: \"Errors found, check other Conditions for details.\",",
          "3637:      },",
          "3640:   })",
          "3642:   run(t, \"TLSRoute: spec.rules.forwardTo.servicePort not specified\", testcase{",
          "3643:    gateway: gw,",
          "3644:    objs: []interface{}{",
          "3645:     kuardService,",
          "3646:     &gatewayapi_v1alpha1.TLSRoute{",
          "3647:      ObjectMeta: metav1.ObjectMeta{",
          "3648:       Name:      \"basic\",",
          "3649:       Namespace: \"default\",",
          "3650:       Labels: map[string]string{",
          "3651:        \"app\": \"contour\",",
          "3652:       },",
          "3654:      Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "3655:       Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "3656:        Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "3657:       },",
          "3658:       Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "3659:        Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3660:         SNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},",
          "3661:        }},",
          "3662:        ForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{",
          "3663:         ServiceName: pointer.StringPtr(\"kuard\"),",
          "3664:         Port:        nil,",
          "3665:        }},",
          "3667:      },",
          "3668:     }},",
          "3669:    want: []*status.ConditionsUpdate{{",
          "3670:     FullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},",
          "3671:     Conditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{",
          "3672:      status.ConditionResolvedRefs: {",
          "3673:       Type:    string(status.ConditionResolvedRefs),",
          "3674:       Status:  contour_api_v1.ConditionFalse,",
          "3675:       Reason:  string(status.ReasonDegraded),",
          "3676:       Message: \"Spec.Rules.ForwardTo.ServicePort must be specified\",",
          "3677:      },",
          "3678:      gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
          "3679:       Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "3680:       Status:  contour_api_v1.ConditionFalse,",
          "3681:       Reason:  \"ErrorsExist\",",
          "3682:       Message: \"Errors found, check other Conditions for details.\",",
          "3683:      },",
          "3686:   })",
          "3688:   run(t, \"TLSRoute: spec.rules.forwardTo not specified\", testcase{",
          "3689:    gateway: gw,",
          "3690:    objs: []interface{}{",
          "3691:     kuardService,",
          "3692:     &gatewayapi_v1alpha1.TLSRoute{",
          "3693:      ObjectMeta: metav1.ObjectMeta{",
          "3694:       Name:      \"basic\",",
          "3695:       Namespace: \"default\",",
          "3696:       Labels: map[string]string{",
          "3697:        \"app\": \"contour\",",
          "3698:       },",
          "3700:      Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "3701:       Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "3702:        Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "3703:       },",
          "3704:       Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "3705:        Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3706:         SNIs: []gatewayapi_v1alpha1.Hostname{\"test.projectcontour.io\"},",
          "3707:        }},",
          "3709:      },",
          "3710:     }},",
          "3711:    want: []*status.ConditionsUpdate{{",
          "3712:     FullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},",
          "3713:     Conditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{",
          "3714:      status.ConditionResolvedRefs: {",
          "3715:       Type:    string(status.ConditionResolvedRefs),",
          "3716:       Status:  contour_api_v1.ConditionFalse,",
          "3717:       Reason:  string(status.ReasonDegraded),",
          "3718:       Message: \"At least one Spec.Rules.ForwardTo must be specified.\",",
          "3719:      },",
          "3720:      gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
          "3721:       Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "3722:       Status:  contour_api_v1.ConditionFalse,",
          "3723:       Reason:  \"ErrorsExist\",",
          "3724:       Message: \"Errors found, check other Conditions for details.\",",
          "3725:      },",
          "3728:   })",
          "3730:   run(t, \"TLSRoute: spec.rules.hostname: invalid wildcard\", testcase{",
          "3731:    gateway: gw,",
          "3732:    objs: []interface{}{",
          "3733:     kuardService,",
          "3734:     &gatewayapi_v1alpha1.TLSRoute{",
          "3735:      ObjectMeta: metav1.ObjectMeta{",
          "3736:       Name:      \"basic\",",
          "3737:       Namespace: \"default\",",
          "3738:       Labels: map[string]string{",
          "3739:        \"app\": \"contour\",",
          "3740:       },",
          "3742:      Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "3743:       Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "3744:        Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "3745:       },",
          "3746:       Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "3747:        Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3748:         SNIs: []gatewayapi_v1alpha1.Hostname{\"*.*.projectcontour.io\"},",
          "3749:        }},",
          "3750:        ForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{",
          "3751:         ServiceName: pointer.StringPtr(\"kuard\"),",
          "3752:         Port:        gatewayPort(8080),",
          "3753:        }},",
          "3755:      },",
          "3756:     }},",
          "3757:    want: []*status.ConditionsUpdate{{",
          "3758:     FullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},",
          "3759:     Conditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{",
          "3760:      status.ConditionResolvedRefs: {",
          "3761:       Type:    string(status.ConditionResolvedRefs),",
          "3762:       Status:  contour_api_v1.ConditionFalse,",
          "3763:       Reason:  string(status.ReasonDegraded),",
          "3764:       Message: \"invalid hostname \\\"*.*.projectcontour.io\\\": [a wildcard DNS-1123 subdomain must start with '*.', followed by a valid DNS subdomain, which must consist of lower case alphanumeric characters, '-' or '.' and end with an alphanumeric character (e.g. '*.example.com', regex used for validation is '\\\\*\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*')]\",",
          "3765:      },",
          "3766:      gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
          "3767:       Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "3768:       Status:  contour_api_v1.ConditionFalse,",
          "3769:       Reason:  \"ErrorsExist\",",
          "3770:       Message: \"Errors found, check other Conditions for details.\",",
          "3771:      },",
          "3774:   })",
          "3776:   run(t, \"TLSRoute: spec.rules.hostname: invalid hostname\", testcase{",
          "3777:    gateway: gw,",
          "3778:    objs: []interface{}{",
          "3779:     kuardService,",
          "3780:     &gatewayapi_v1alpha1.TLSRoute{",
          "3781:      ObjectMeta: metav1.ObjectMeta{",
          "3782:       Name:      \"basic\",",
          "3783:       Namespace: \"default\",",
          "3784:       Labels: map[string]string{",
          "3785:        \"app\": \"contour\",",
          "3786:       },",
          "3788:      Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "3789:       Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "3790:        Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "3791:       },",
          "3792:       Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "3793:        Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3794:         SNIs: []gatewayapi_v1alpha1.Hostname{\"#projectcontour.io\"},",
          "3795:        }},",
          "3796:        ForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{",
          "3797:         ServiceName: pointer.StringPtr(\"kuard\"),",
          "3798:         Port:        gatewayPort(8080),",
          "3799:        }},",
          "3801:      },",
          "3802:     }},",
          "3803:    want: []*status.ConditionsUpdate{{",
          "3804:     FullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},",
          "3805:     Conditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{",
          "3806:      status.ConditionResolvedRefs: {",
          "3807:       Type:    string(status.ConditionResolvedRefs),",
          "3808:       Status:  contour_api_v1.ConditionFalse,",
          "3809:       Reason:  string(status.ReasonDegraded),",
          "3810:       Message: \"invalid hostname \\\"#projectcontour.io\\\": [a lowercase RFC 1123 subdomain must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character (e.g. 'example.com', regex used for validation is '[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*')]\",",
          "3811:      },",
          "3812:      gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
          "3813:       Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "3814:       Status:  contour_api_v1.ConditionFalse,",
          "3815:       Reason:  \"ErrorsExist\",",
          "3816:       Message: \"Errors found, check other Conditions for details.\",",
          "3817:      },",
          "3820:   })",
          "3822:   run(t, \"TLSRoute: spec.rules.hostname: invalid hostname, ip address\", testcase{",
          "3823:    gateway: gw,",
          "3824:    objs: []interface{}{",
          "3825:     kuardService,",
          "3826:     &gatewayapi_v1alpha1.TLSRoute{",
          "3827:      ObjectMeta: metav1.ObjectMeta{",
          "3828:       Name:      \"basic\",",
          "3829:       Namespace: \"default\",",
          "3830:       Labels: map[string]string{",
          "3831:        \"app\": \"contour\",",
          "3832:       },",
          "3834:      Spec: gatewayapi_v1alpha1.TLSRouteSpec{",
          "3835:       Gateways: &gatewayapi_v1alpha1.RouteGateways{",
          "3836:        Allow: gatewayAllowTypePtr(gatewayapi_v1alpha1.GatewayAllowAll),",
          "3837:       },",
          "3838:       Rules: []gatewayapi_v1alpha1.TLSRouteRule{{",
          "3839:        Matches: []gatewayapi_v1alpha1.TLSRouteMatch{{",
          "3840:         SNIs: []gatewayapi_v1alpha1.Hostname{\"1.2.3.4\"},",
          "3841:        }},",
          "3842:        ForwardTo: []gatewayapi_v1alpha1.RouteForwardTo{{",
          "3843:         ServiceName: pointer.StringPtr(\"kuard\"),",
          "3844:         Port:        gatewayPort(8080),",
          "3845:        }},",
          "3847:      },",
          "3848:     }},",
          "3849:    want: []*status.ConditionsUpdate{{",
          "3850:     FullName: types.NamespacedName{Namespace: \"default\", Name: \"basic\"},",
          "3851:     Conditions: map[gatewayapi_v1alpha1.RouteConditionType]metav1.Condition{",
          "3852:      status.ConditionResolvedRefs: {",
          "3853:       Type:    string(status.ConditionResolvedRefs),",
          "3854:       Status:  contour_api_v1.ConditionFalse,",
          "3855:       Reason:  string(status.ReasonDegraded),",
          "3856:       Message: \"hostname \\\"1.2.3.4\\\" must be a DNS name, not an IP address\",",
          "3857:      },",
          "3858:      gatewayapi_v1alpha1.ConditionRouteAdmitted: {",
          "3859:       Type:    string(gatewayapi_v1alpha1.ConditionRouteAdmitted),",
          "3860:       Status:  contour_api_v1.ConditionFalse,",
          "3861:       Reason:  \"ErrorsExist\",",
          "3862:       Message: \"Errors found, check other Conditions for details.\",",
          "3863:      },",
          "3866:   })",
          "3867:  }",
          "",
          "---------------"
        ],
        "internal/featuretests/v3/tlsroute_test.go||internal/featuretests/v3/tlsroute_test.go": [
          "File: internal/featuretests/v3/tlsroute_test.go -> internal/featuretests/v3/tlsroute_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: import (",
          "17:  \"testing\"",
          "19:  envoy_listener_v3 \"github.com/envoyproxy/go-control-plane/envoy/config/listener/v3\"",
          "20:  envoy_discovery_v3 \"github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3\"",
          "21:  \"github.com/projectcontour/contour/internal/dag\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19:  \"github.com/projectcontour/contour/internal/featuretests\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "41:  rh.OnAdd(svc)",
          "42:  rh.OnAdd(svcAnother)",
          "45:   ObjectMeta: metav1.ObjectMeta{",
          "46:    Name:      \"contour\",",
          "47:    Namespace: \"projectcontour\",",
          "",
          "[Removed Lines]",
          "44:  rh.OnAdd(&gatewayapi_v1alpha1.Gateway{",
          "",
          "[Added Lines]",
          "46:  gatewayPassthrough := &gatewayapi_v1alpha1.Gateway{",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "50:    Listeners: []gatewayapi_v1alpha1.Listener{{",
          "51:     Port:     443,",
          "52:     Protocol: \"TLS\",",
          "53:     Routes: gatewayapi_v1alpha1.RouteBindingSelector{",
          "54:      Namespaces: &gatewayapi_v1alpha1.RouteNamespaces{",
          "55:       From: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "55:     TLS: &gatewayapi_v1alpha1.GatewayTLSConfig{",
          "56:      Mode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModePassthrough),",
          "57:     },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "58:     },",
          "59:    }},",
          "60:   },",
          "63:  route1 := &gatewayapi_v1alpha1.TLSRoute{",
          "64:   ObjectMeta: metav1.ObjectMeta{",
          "",
          "[Removed Lines]",
          "61:  })",
          "",
          "[Added Lines]",
          "66:  }",
          "68:  rh.OnAdd(gatewayPassthrough)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "239:   ),",
          "240:   TypeUrl: routeType,",
          "241:  })",
          "242: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "250:  rh.OnDelete(route1)",
          "251:  rh.OnDelete(route2)",
          "252:  rh.OnDelete(route3)",
          "253:  rh.OnDelete(route4)",
          "255:  sec1 := &v1.Secret{",
          "256:   ObjectMeta: metav1.ObjectMeta{",
          "257:    Name:      \"tlscert\",",
          "258:    Namespace: \"projectcontour\",",
          "259:   },",
          "260:   Type: \"kubernetes.io/tls\",",
          "261:   Data: featuretests.Secretdata(featuretests.CERTIFICATE, featuretests.RSA_PRIVATE_KEY),",
          "262:  }",
          "265:  gatewayTerminate := &gatewayapi_v1alpha1.Gateway{",
          "266:   ObjectMeta: metav1.ObjectMeta{",
          "267:    Name:      \"contour\",",
          "268:    Namespace: \"projectcontour\",",
          "269:   },",
          "270:   Spec: gatewayapi_v1alpha1.GatewaySpec{",
          "271:    Listeners: []gatewayapi_v1alpha1.Listener{{",
          "272:     Port:     443,",
          "273:     Protocol: \"TLS\",",
          "274:     TLS: &gatewayapi_v1alpha1.GatewayTLSConfig{",
          "275:      Mode: tlsModeTypePtr(gatewayapi_v1alpha1.TLSModeTerminate),",
          "276:      CertificateRef: &gatewayapi_v1alpha1.LocalObjectReference{",
          "277:       Group: \"core\",",
          "278:       Kind:  \"Secret\",",
          "279:       Name:  \"tlscert\",",
          "280:      },",
          "281:     },",
          "282:     Routes: gatewayapi_v1alpha1.RouteBindingSelector{",
          "283:      Namespaces: &gatewayapi_v1alpha1.RouteNamespaces{",
          "284:       From: routeSelectTypePtr(gatewayapi_v1alpha1.RouteSelectAll),",
          "285:      },",
          "286:      Kind: dag.KindTLSRoute,",
          "287:     },",
          "288:    }},",
          "289:   },",
          "290:  }",
          "292:  rh.OnAdd(sec1)",
          "293:  rh.OnAdd(gatewayTerminate)",
          "294:  rh.OnAdd(route1)",
          "296:  c.Request(listenerType).Equals(&envoy_discovery_v3.DiscoveryResponse{",
          "297:   Resources: resources(t,",
          "298:    &envoy_listener_v3.Listener{",
          "299:     Name:    \"ingress_https\",",
          "300:     Address: envoy_v3.SocketAddress(\"0.0.0.0\", 8443),",
          "301:     FilterChains: appendFilterChains(",
          "302:      filterchaintls(\"tcp.projectcontour.io\", sec1, tcpproxy(\"ingress_https\", \"default/correct-backend/80/da39a3ee5e\"), nil),",
          "303:     ),",
          "304:     ListenerFilters: envoy_v3.ListenerFilters(",
          "305:      envoy_v3.TLSInspector(),",
          "306:     ),",
          "307:     SocketOptions: envoy_v3.TCPKeepaliveSocketOptions(),",
          "308:    },",
          "309:    staticListener(),",
          "310:   ),",
          "311:   TypeUrl: listenerType,",
          "312:  })",
          "315:  c.Request(routeType).Equals(&envoy_discovery_v3.DiscoveryResponse{",
          "316:   Resources: resources(t,",
          "317:    envoy_v3.RouteConfiguration(\"ingress_http\"),",
          "318:   ),",
          "319:   TypeUrl: routeType,",
          "320:  })",
          "321: }",
          "323: func tlsModeTypePtr(mode gatewayapi_v1alpha1.TLSModeType) *gatewayapi_v1alpha1.TLSModeType {",
          "324:  return &mode",
          "",
          "---------------"
        ],
        "test/e2e/gateway/008_tlsroute_test.go||test/e2e/gateway/008_tlsroute_test.go": [
          "File: test/e2e/gateway/008_tlsroute_test.go -> test/e2e/gateway/008_tlsroute_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: import (",
          "19:  \"context\"",
          "21:  . \"github.com/onsi/ginkgo\"",
          "22:  \"github.com/projectcontour/contour/test/e2e\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20:  \"crypto/tls\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100:   assert.Equal(t, \"echo\", f.GetEchoResponseBody(res.Body).Service)",
          "101:  })",
          "102: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "105: func testTLSRouteTerminate(namespace string) {",
          "106:  Specify(\"TLS requests terminate via SNI at Envoy and then are routed to a service\", func() {",
          "107:   t := f.T()",
          "109:   f.Fixtures.Echo.Deploy(namespace, \"echo\")",
          "111:   route := &gatewayv1alpha1.TLSRoute{",
          "112:    ObjectMeta: metav1.ObjectMeta{",
          "113:     Namespace: namespace,",
          "114:     Name:      \"tls-route-1\",",
          "115:    },",
          "116:    Spec: gatewayv1alpha1.TLSRouteSpec{",
          "117:     Gateways: &gatewayv1alpha1.RouteGateways{",
          "118:      Allow: gatewayAllowTypePtr(gatewayv1alpha1.GatewayAllowAll),",
          "119:     },",
          "120:     Rules: []gatewayv1alpha1.TLSRouteRule{{",
          "121:      Matches: []gatewayv1alpha1.TLSRouteMatch{{",
          "122:       SNIs: []gatewayv1alpha1.Hostname{",
          "123:        gatewayv1alpha1.Hostname(\"tlsroute.gatewayapi.projectcontour.io\"),",
          "124:       },",
          "125:      }},",
          "126:      ForwardTo: []gatewayv1alpha1.RouteForwardTo{{",
          "127:       ServiceName: stringPtr(\"echo\"),",
          "128:       Port:        portNumPtr(80),",
          "129:      }},",
          "130:     }},",
          "131:    },",
          "132:   }",
          "133:   f.CreateTLSRouteAndWaitFor(route, tlsRouteAdmitted)",
          "136:   res, ok := f.HTTP.SecureRequestUntil(&e2e.HTTPSRequestOpts{",
          "137:    Host:      \"tlsroute.gatewayapi.projectcontour.io\",",
          "138:    Condition: e2e.HasStatusCode(200),",
          "139:    TLSConfigOpts: []func(*tls.Config){",
          "140:     e2e.OptSetSNI(\"tlsroute.gatewayapi.projectcontour.io\"),",
          "141:    },",
          "142:   })",
          "143:   assert.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "144:   assert.Equal(t, \"echo\", f.GetEchoResponseBody(res.Body).Service)",
          "147:   res, _ = f.HTTP.SecureRequestUntil(&e2e.HTTPSRequestOpts{",
          "148:    Host: \"something.else.not.matching\",",
          "149:    TLSConfigOpts: []func(*tls.Config){",
          "150:     e2e.OptSetSNI(\"something.else.not.matching\"),",
          "151:    },",
          "152:   })",
          "155:   assert.Nil(t, res, \"expected no response but got a response.\")",
          "158:   require.NoError(t, retry.RetryOnConflict(retry.DefaultBackoff, func() error {",
          "159:    if err := f.Client.Get(context.TODO(), client.ObjectKeyFromObject(route), route); err != nil {",
          "160:     return err",
          "161:    }",
          "163:    route.Spec.Rules = []gatewayv1alpha1.TLSRouteRule{",
          "164:     {",
          "165:      ForwardTo: []gatewayv1alpha1.RouteForwardTo{",
          "166:       {",
          "167:        ServiceName: stringPtr(\"echo\"),",
          "168:        Port:        portNumPtr(80),",
          "169:       },",
          "170:      },",
          "171:     },",
          "172:    }",
          "174:    return f.Client.Update(context.TODO(), route)",
          "175:   }))",
          "178:   res, ok = f.HTTP.SecureRequestUntil(&e2e.HTTPSRequestOpts{",
          "179:    Host:      \"anything.should.work.now\",",
          "180:    Condition: e2e.HasStatusCode(200),",
          "181:   })",
          "182:   assert.Truef(t, ok, \"expected 200 response code, got %d\", res.StatusCode)",
          "183:   assert.Equal(t, \"echo\", f.GetEchoResponseBody(res.Body).Service)",
          "184:  })",
          "185: }",
          "",
          "---------------"
        ],
        "test/e2e/gateway/gateway_test.go||test/e2e/gateway/gateway_test.go": [
          "File: test/e2e/gateway/gateway_test.go -> test/e2e/gateway/gateway_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "216:    },",
          "217:    Spec: gatewayv1alpha1.GatewaySpec{",
          "218:     GatewayClassName: \"contour-class\",",
          "228:       },",
          "229:      },",
          "231:    },",
          "232:   }",
          "234:   f.NamespacedTest(\"008-tlsroute\", testWithGateway(gw, testTLSRoutePassthrough))",
          "235:  })",
          "255:        },",
          "256:       },",
          "257:      },",
          "258:     },",
          "260:   }",
          "263:  })",
          "264: })",
          "",
          "[Removed Lines]",
          "219:     Listeners: []gatewayv1alpha1.Listener{",
          "220:      {",
          "221:       Protocol: gatewayv1alpha1.TLSProtocolType,",
          "222:       Port:     gatewayv1alpha1.PortNumber(443),",
          "223:       Routes: gatewayv1alpha1.RouteBindingSelector{",
          "224:        Kind: \"TLSRoute\",",
          "225:        Namespaces: &gatewayv1alpha1.RouteNamespaces{",
          "226:         From: routeSelectTypePtr(gatewayv1alpha1.RouteSelectAll),",
          "227:        },",
          "230:     },",
          "237:  Describe(\"TLSRoute Gateway: Mode: Passthrough\", func() {",
          "238:   gw := &gatewayv1alpha1.Gateway{",
          "239:    ObjectMeta: metav1.ObjectMeta{",
          "240:     Name: \"tls-passthrough\",",
          "241:    },",
          "242:    Spec: gatewayv1alpha1.GatewaySpec{",
          "243:     GatewayClassName: \"contour-class\",",
          "244:     Listeners: []gatewayv1alpha1.Listener{",
          "245:      {",
          "246:       Protocol: gatewayv1alpha1.TLSProtocolType,",
          "247:       Port:     gatewayv1alpha1.PortNumber(443),",
          "248:       TLS: &gatewayv1alpha1.GatewayTLSConfig{",
          "249:        Mode: tlsModeTypePtr(gatewayv1alpha1.TLSModePassthrough),",
          "250:       },",
          "251:       Routes: gatewayv1alpha1.RouteBindingSelector{",
          "252:        Kind: \"TLSRoute\",",
          "253:        Namespaces: &gatewayv1alpha1.RouteNamespaces{",
          "254:         From: routeSelectTypePtr(gatewayv1alpha1.RouteSelectAll),",
          "259:    },",
          "262:   f.NamespacedTest(\"008-tlsroute-mode-passthrough\", testWithGateway(gw, testTLSRoutePassthrough))",
          "",
          "[Added Lines]",
          "219:     Listeners: []gatewayv1alpha1.Listener{{",
          "220:      Protocol: gatewayv1alpha1.TLSProtocolType,",
          "221:      TLS: &gatewayv1alpha1.GatewayTLSConfig{",
          "222:       Mode: tlsModeTypePtr(gatewayv1alpha1.TLSModePassthrough),",
          "223:      },",
          "224:      Port: gatewayv1alpha1.PortNumber(443),",
          "225:      Routes: gatewayv1alpha1.RouteBindingSelector{",
          "226:       Kind: \"TLSRoute\",",
          "227:       Namespaces: &gatewayv1alpha1.RouteNamespaces{",
          "228:        From: routeSelectTypePtr(gatewayv1alpha1.RouteSelectAll),",
          "231:     }},",
          "238:  Describe(\"TLSRoute Gateway: Mode: Terminate\", func() {",
          "240:   testWithTLSGateway := func(hostname string, body e2e.NamespacedTestBody) e2e.NamespacedTestBody {",
          "241:    gw := &gatewayv1alpha1.Gateway{",
          "242:     ObjectMeta: metav1.ObjectMeta{",
          "243:      Name: \"tls-passthrough\",",
          "244:     },",
          "245:     Spec: gatewayv1alpha1.GatewaySpec{",
          "246:      GatewayClassName: \"contour-class\",",
          "247:      Listeners: []gatewayv1alpha1.Listener{",
          "248:       {",
          "249:        Protocol: gatewayv1alpha1.TLSProtocolType,",
          "250:        Port:     gatewayv1alpha1.PortNumber(443),",
          "251:        TLS: &gatewayv1alpha1.GatewayTLSConfig{",
          "252:         Mode: tlsModeTypePtr(gatewayv1alpha1.TLSModeTerminate),",
          "253:         CertificateRef: &gatewayv1alpha1.LocalObjectReference{",
          "254:          Group: \"core\",",
          "255:          Kind:  \"Secret\",",
          "256:          Name:  \"tlscert\",",
          "257:         },",
          "258:        },",
          "259:        Routes: gatewayv1alpha1.RouteBindingSelector{",
          "260:         Kind: \"TLSRoute\",",
          "261:         Namespaces: &gatewayv1alpha1.RouteNamespaces{",
          "262:          From: routeSelectTypePtr(gatewayv1alpha1.RouteSelectAll),",
          "263:         },",
          "268:    }",
          "269:    return testWithGateway(gw, func(namespace string) {",
          "270:     Context(fmt.Sprintf(\"with TLS secret %s/tlscert for hostname %s\", namespace, hostname), func() {",
          "271:      BeforeEach(func() {",
          "272:       f.Certs.CreateSelfSignedCert(namespace, \"tlscert\", \"tlscert\", hostname)",
          "273:      })",
          "275:      body(namespace)",
          "276:     })",
          "277:    })",
          "280:   f.NamespacedTest(\"008-tlsroute-mode-terminate\", testWithTLSGateway(\"tlsroute.gatewayapi.projectcontour.io\", testTLSRouteTerminate))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-8747",
  "cve_desc": "The multifilesystem storage backend in Radicale before 1.1 allows remote attackers to read or write to arbitrary files via a crafted component name.",
  "repo": "Unrud/Radicale",
  "patch_hash": "bcaf452e516c02c9bed584a73736431c5e8831f1",
  "patch_info": {
    "commit_hash": "bcaf452e516c02c9bed584a73736431c5e8831f1",
    "repo": "Unrud/Radicale",
    "commit_url": "https://github.com/Unrud/Radicale/commit/bcaf452e516c02c9bed584a73736431c5e8831f1",
    "files": [
      "radicale/storage/multifilesystem.py"
    ],
    "message": "Convert component names safely to filenames Component names are controlled by the user and without this checks access to arbitrary files is possible if the multifilesystem backend is used.",
    "before_after_code_files": [
      "radicale/storage/multifilesystem.py||radicale/storage/multifilesystem.py"
    ]
  },
  "patch_diff": {
    "radicale/storage/multifilesystem.py||radicale/storage/multifilesystem.py": [
      "File: radicale/storage/multifilesystem.py -> radicale/storage/multifilesystem.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "53:             name = (",
      "54:                 component.name if sys.version_info[0] >= 3 else",
      "55:                 component.name.encode(filesystem.FILESYSTEM_ENCODING))",
      "56:             filesystem_path = os.path.join(self._filesystem_path, name)",
      "57:             with filesystem.open(filesystem_path, \"w\") as fd:",
      "58:                 fd.write(text)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "56:             if not pathutils.is_safe_filesystem_path_component(name):",
      "57:                 log.LOGGER.debug(",
      "58:                     \"Can't tranlate name safely to filesystem, \"",
      "59:                     \"skipping component: %s\", name)",
      "60:                 continue",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "62:         os.remove(self._props_path)",
      "64:     def remove(self, name):",
      "65:         filesystem_path = os.path.join(self._filesystem_path, name)",
      "66:         if os.path.exists(filesystem_path):",
      "67:             os.remove(filesystem_path)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "70:         if not pathutils.is_safe_filesystem_path_component(name):",
      "71:             log.LOGGER.debug(",
      "72:                 \"Can't tranlate name safely to filesystem, \"",
      "73:                 \"skipping component: %s\", name)",
      "74:             return",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6b7e79a368be86d266c51cf50915324490a1b728",
      "candidate_info": {
        "commit_hash": "6b7e79a368be86d266c51cf50915324490a1b728",
        "repo": "Unrud/Radicale",
        "commit_url": "https://github.com/Unrud/Radicale/commit/6b7e79a368be86d266c51cf50915324490a1b728",
        "files": [
          "radicale/ical.py"
        ],
        "message": "Use sanitize_path instead of normpath See a7b47f075499a1e1b40539bc1fa872a3ab77a204 The check for \".\" is now needless because the sane path is always absolute. ```path.replace(os.sep, \"/\")``` is only relevant for the (multi)filesystem backend and should be there.",
        "before_after_code_files": [
          "radicale/ical.py||radicale/ical.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/Kozea/Radicale/pull/343"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "radicale/ical.py||radicale/ical.py": [
          "File: radicale/ical.py -> radicale/ical.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: \"\"\"",
          "28: import os",
          "30: import hashlib",
          "31: import re",
          "32: from uuid import uuid4",
          "33: from random import randint",
          "34: from contextlib import contextmanager",
          "37: def serialize(tag, headers=(), items=()):",
          "38:     \"\"\"Return a text corresponding to given collection ``tag``.",
          "",
          "[Removed Lines]",
          "29: import posixpath",
          "",
          "[Added Lines]",
          "35: from . import pathutils",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "184:         \"\"\"",
          "185:         self.encoding = \"utf-8\"",
          "188:         if principal and split_path and self.is_node(self.path):",
          "189:             # Already existing principal collection",
          "190:             self.owner = split_path[0]",
          "",
          "[Removed Lines]",
          "186:         split_path = path.split(\"/\")",
          "187:         self.path = path if path != \".\" else \"\"",
          "",
          "[Added Lines]",
          "187:         # path should already be sanitized",
          "188:         self.path = pathutils.sanitize_path(path).strip(\"/\")",
          "189:         split_path = self.path.split(\"/\")",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "215:         if path is None:",
          "216:             return []",
          "220:         attributes = sane_path.split(\"/\")",
          "221:         if not attributes:",
          "222:             return []",
          "",
          "[Removed Lines]",
          "218:         # First do normpath and then strip, to prevent access to FOLDER/../",
          "219:         sane_path = posixpath.normpath(path.replace(os.sep, \"/\")).strip(\"/\")",
          "",
          "[Added Lines]",
          "220:         # path should already be sanitized",
          "221:         sane_path = pathutils.sanitize_path(path).strip(\"/\")",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1ad994cadf8a339863c1a8f5e405b76a83fd7ba5",
      "candidate_info": {
        "commit_hash": "1ad994cadf8a339863c1a8f5e405b76a83fd7ba5",
        "repo": "Unrud/Radicale",
        "commit_url": "https://github.com/Unrud/Radicale/commit/1ad994cadf8a339863c1a8f5e405b76a83fd7ba5",
        "files": [
          "radicale/__init__.py",
          "radicale/pathutils.py"
        ],
        "message": "Move sanitize_path into pathutils.py",
        "before_after_code_files": [
          "radicale/__init__.py||radicale/__init__.py",
          "radicale/pathutils.py||radicale/pathutils.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/Kozea/Radicale/pull/343"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "radicale/__init__.py||radicale/__init__.py": [
          "File: radicale/__init__.py -> radicale/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: import sys",
          "33: import pprint",
          "34: import base64",
          "36: import socket",
          "37: import ssl",
          "38: import wsgiref.simple_server",
          "",
          "[Removed Lines]",
          "35: import posixpath",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:     from urlparse import urlparse",
          "49: # pylint: enable=F0401,E0611",
          "54: VERSION = \"1.0.1\"",
          "",
          "[Removed Lines]",
          "51: from . import auth, config, ical, log, rights, storage, xmlutils",
          "",
          "[Added Lines]",
          "50: from . import auth, config, ical, log, pathutils, rights, storage, xmlutils",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "179:     def sanitize_uri(uri):",
          "180:         \"\"\"Unquote and make absolute to prevent access to other data.\"\"\"",
          "181:         uri = unquote(uri)",
          "192:     def collect_allowed_items(self, items, user):",
          "193:         \"\"\"Get items from request that user is allowed to access.\"\"\"",
          "",
          "[Removed Lines]",
          "182:         trailing_slash = \"/\" if uri.endswith(\"/\") else \"\"",
          "183:         uri = posixpath.normpath(uri)",
          "184:         new_uri = \"/\"",
          "185:         for part in uri.split(\"/\"):",
          "186:             if not part or part in (\".\", \"..\"):",
          "187:                 continue",
          "188:             new_uri = posixpath.join(new_uri, part)",
          "189:         trailing_slash = \"\" if new_uri.endswith(\"/\") else trailing_slash",
          "190:         return new_uri + trailing_slash",
          "",
          "[Added Lines]",
          "181:         return pathutils.sanitize_path(uri)",
          "",
          "---------------"
        ],
        "radicale/pathutils.py||radicale/pathutils.py": [
          "File: radicale/pathutils.py -> radicale/pathutils.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # -*- coding: utf-8 -*-",
          "2: #",
          "3: # This file is part of Radicale Server - Calendar Server",
          "4: #",
          "5: # This library is free software: you can redistribute it and/or modify",
          "6: # it under the terms of the GNU General Public License as published by",
          "7: # the Free Software Foundation, either version 3 of the License, or",
          "8: # (at your option) any later version.",
          "9: #",
          "10: # This library is distributed in the hope that it will be useful,",
          "11: # but WITHOUT ANY WARRANTY; without even the implied warranty of",
          "12: # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
          "13: # GNU General Public License for more details.",
          "14: #",
          "15: # You should have received a copy of the GNU General Public License",
          "16: # along with Radicale.  If not, see <http://www.gnu.org/licenses/>.",
          "18: \"\"\"",
          "19: Helper functions for working with paths",
          "21: \"\"\"",
          "23: import posixpath",
          "26: def sanitize_path(path):",
          "27:     \"\"\"Make absolute (with leading slash) to prevent access to other data.",
          "28:        Preserves an potential trailing slash.\"\"\"",
          "29:     trailing_slash = \"/\" if path.endswith(\"/\") else \"\"",
          "30:     path = posixpath.normpath(path)",
          "31:     new_path = \"/\"",
          "32:     for part in path.split(\"/\"):",
          "33:         if not part or part in (\".\", \"..\"):",
          "34:             continue",
          "35:         new_path = posixpath.join(new_path, part)",
          "36:     trailing_slash = \"\" if new_path.endswith(\"/\") else trailing_slash",
          "37:     return new_path + trailing_slash",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "780cecc0f2f91116bc71852888061874fd5b1277",
      "candidate_info": {
        "commit_hash": "780cecc0f2f91116bc71852888061874fd5b1277",
        "repo": "Unrud/Radicale",
        "commit_url": "https://github.com/Unrud/Radicale/commit/780cecc0f2f91116bc71852888061874fd5b1277",
        "files": [
          "radicale/__init__.py"
        ],
        "message": "Always sanitize request URI Do no rely on the HTTP server",
        "before_after_code_files": [
          "radicale/__init__.py||radicale/__init__.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/Kozea/Radicale/pull/343"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "radicale/__init__.py||radicale/__init__.py": [
          "File: radicale/__init__.py -> radicale/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "254:         headers = pprint.pformat(self.headers_log(environ))",
          "255:         log.LOGGER.debug(\"Request headers:\\n%s\" % headers)",
          "257:         base_prefix = config.get(\"server\", \"base_prefix\")",
          "258:         if environ[\"PATH_INFO\"].startswith(base_prefix):",
          "263:         elif config.get(\"server\", \"can_skip_base_prefix\"):",
          "264:             log.LOGGER.debug(",
          "266:         else:",
          "267:             # Request path not starting with base_prefix, not allowed",
          "268:             log.LOGGER.debug(",
          "269:                 \"Path not starting with prefix: %s\", environ[\"PATH_INFO\"])",
          "270:             environ[\"PATH_INFO\"] = None",
          "272:         path = environ[\"PATH_INFO\"]",
          "274:         # Get function corresponding to method",
          "",
          "[Removed Lines]",
          "259:             # Sanitize request URI",
          "260:             environ[\"PATH_INFO\"] = self.sanitize_uri(",
          "261:                 \"/%s\" % environ[\"PATH_INFO\"][len(base_prefix):])",
          "262:             log.LOGGER.debug(\"Sanitized path: %s\", environ[\"PATH_INFO\"])",
          "265:                 \"Skipped already sanitized path: %s\", environ[\"PATH_INFO\"])",
          "",
          "[Added Lines]",
          "257:         # Strip base_prefix from request URI",
          "260:             environ[\"PATH_INFO\"] = environ[\"PATH_INFO\"][len(base_prefix):]",
          "263:                 \"Prefix already stripped from path: %s\", environ[\"PATH_INFO\"])",
          "270:         # Sanitize request URI",
          "271:         environ[\"PATH_INFO\"] = self.sanitize_uri(environ[\"PATH_INFO\"])",
          "272:         log.LOGGER.debug(\"Sanitized path: %s\", environ[\"PATH_INFO\"])",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b4b3d51f33c7623d312f289252dd7bbb8f58bbe6",
      "candidate_info": {
        "commit_hash": "b4b3d51f33c7623d312f289252dd7bbb8f58bbe6",
        "repo": "Unrud/Radicale",
        "commit_url": "https://github.com/Unrud/Radicale/commit/b4b3d51f33c7623d312f289252dd7bbb8f58bbe6",
        "files": [
          "radicale/pathutils.py",
          "radicale/storage/filesystem.py",
          "radicale/storage/multifilesystem.py"
        ],
        "message": "Convert paths safely to file system paths With the old implementation on Windows a path like \"/c:/file/ignore\" got converted to \"c:\\file\" and allowed access to files outside of FOLDER",
        "before_after_code_files": [
          "radicale/pathutils.py||radicale/pathutils.py",
          "radicale/storage/filesystem.py||radicale/storage/filesystem.py",
          "radicale/storage/multifilesystem.py||radicale/storage/multifilesystem.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/Kozea/Radicale/pull/343"
        ],
        "olp_code_files": {
          "patch": [
            "radicale/storage/multifilesystem.py||radicale/storage/multifilesystem.py"
          ],
          "candidate": [
            "radicale/storage/multifilesystem.py||radicale/storage/multifilesystem.py"
          ]
        }
      },
      "candidate_diff": {
        "radicale/pathutils.py||radicale/pathutils.py": [
          "File: radicale/pathutils.py -> radicale/pathutils.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: \"\"\"",
          "23: import posixpath",
          "26: def sanitize_path(path):",
          "27:     \"\"\"Make absolute (with leading slash) to prevent access to other data.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: import os",
          "26: from . import log",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34:             continue",
          "35:         new_path = posixpath.join(new_path, part)",
          "36:     trailing_slash = \"\" if new_path.endswith(\"/\") else trailing_slash",
          "",
          "[Removed Lines]",
          "37:     return new_path + trailing_slash",
          "",
          "[Added Lines]",
          "43: def is_safe_filesystem_path_component(path):",
          "44:     \"\"\"Checks if path is a single component of a local filesystem path",
          "45:        and is safe to join\"\"\"",
          "46:     if not path:",
          "47:         return False",
          "48:     drive, _ = os.path.splitdrive(path)",
          "49:     if drive:",
          "50:         return False",
          "51:     head, _ = os.path.split(path)",
          "52:     if head:",
          "53:         return False",
          "54:     if path in (os.curdir, os.pardir):",
          "55:         return False",
          "56:     return True",
          "59: def path_to_filesystem(path, base_folder):",
          "60:     \"\"\"Converts path to a local filesystem path relative to base_folder",
          "61:         in a secure manner or raises ValueError.\"\"\"",
          "62:     sane_path = sanitize_path(path).strip(\"/\")",
          "63:     safe_path = base_folder",
          "64:     if not sane_path:",
          "65:         return safe_path",
          "66:     for part in sane_path.split(\"/\"):",
          "67:         if not is_safe_filesystem_path_component(part):",
          "68:             log.LOGGER.debug(\"Can't translate path safely to filesystem: %s\",",
          "69:                              path)",
          "70:             raise ValueError(\"Unsafe path\")",
          "71:         safe_path = os.path.join(safe_path, part)",
          "72:     return safe_path",
          "",
          "---------------"
        ],
        "radicale/storage/filesystem.py||radicale/storage/filesystem.py": [
          "File: radicale/storage/filesystem.py -> radicale/storage/filesystem.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: import time",
          "29: import sys",
          "30: from contextlib import contextmanager",
          "34: FOLDER = os.path.expanduser(config.get(\"storage\", \"filesystem_folder\"))",
          "",
          "[Removed Lines]",
          "31: from .. import config, ical",
          "",
          "[Added Lines]",
          "32: from .. import config, ical, pathutils",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63: class Collection(ical.Collection):",
          "64:     \"\"\"Collection stored in a flat ical file.\"\"\"",
          "65:     @property",
          "67:         \"\"\"Absolute path of the file at local ``path``.\"\"\"",
          "70:     @property",
          "71:     def _props_path(self):",
          "72:         \"\"\"Absolute path of the file storing the collection properties.\"\"\"",
          "75:     def _create_dirs(self):",
          "76:         \"\"\"Create folder storing the collection if absent.\"\"\"",
          "80:     def save(self, text):",
          "81:         self._create_dirs()",
          "83:             fd.write(text)",
          "85:     def delete(self):",
          "87:         os.remove(self._props_path)",
          "89:     @property",
          "90:     def text(self):",
          "91:         try:",
          "93:                 return fd.read()",
          "94:         except IOError:",
          "95:             return \"\"",
          "97:     @classmethod",
          "98:     def children(cls, path):",
          "101:         for filename in directories + files:",
          "102:             rel_filename = posixpath.join(path, filename)",
          "103:             if cls.is_node(rel_filename) or cls.is_leaf(rel_filename):",
          "",
          "[Removed Lines]",
          "66:     def _path(self):",
          "68:         return os.path.join(FOLDER, self.path.replace(\"/\", os.sep))",
          "73:         return self._path + \".props\"",
          "77:         if not os.path.exists(os.path.dirname(self._path)):",
          "78:             os.makedirs(os.path.dirname(self._path))",
          "82:         with open(self._path, \"w\") as fd:",
          "86:         os.remove(self._path)",
          "92:             with open(self._path) as fd:",
          "99:         abs_path = os.path.join(FOLDER, path.replace(\"/\", os.sep))",
          "100:         _, directories, files = next(os.walk(abs_path))",
          "",
          "[Added Lines]",
          "67:     def _filesystem_path(self):",
          "69:         return pathutils.path_to_filesystem(self.path, FOLDER)",
          "74:         return self._filesystem_path + \".props\"",
          "78:         if not os.path.exists(os.path.dirname(self._filesystem_path)):",
          "79:             os.makedirs(os.path.dirname(self._filesystem_path))",
          "83:         with open(self._filesystem_path, \"w\") as fd:",
          "87:         os.remove(self._filesystem_path)",
          "93:             with open(self._filesystem_path) as fd:",
          "100:         filesystem_path = pathutils.path_to_filesystem(path, FOLDER)",
          "101:         _, directories, files = next(os.walk(filesystem_path))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "106:     @classmethod",
          "107:     def is_node(cls, path):",
          "111:     @classmethod",
          "112:     def is_leaf(cls, path):",
          "116:     @property",
          "117:     def last_modified(self):",
          "119:         return time.strftime(\"%a, %d %b %Y %H:%M:%S +0000\", modification_time)",
          "121:     @property",
          "",
          "[Removed Lines]",
          "108:         abs_path = os.path.join(FOLDER, path.replace(\"/\", os.sep))",
          "109:         return os.path.isdir(abs_path)",
          "113:         abs_path = os.path.join(FOLDER, path.replace(\"/\", os.sep))",
          "114:         return os.path.isfile(abs_path) and not abs_path.endswith(\".props\")",
          "118:         modification_time = time.gmtime(os.path.getmtime(self._path))",
          "",
          "[Added Lines]",
          "109:         filesystem_path = pathutils.path_to_filesystem(path, FOLDER)",
          "110:         return os.path.isdir(filesystem_path)",
          "114:         filesystem_path = pathutils.path_to_filesystem(path, FOLDER)",
          "115:         return (os.path.isfile(filesystem_path) and not",
          "116:                 filesystem_path.endswith(\".props\"))",
          "120:         modification_time = \\",
          "121:             time.gmtime(os.path.getmtime(self._filesystem_path))",
          "",
          "---------------"
        ],
        "radicale/storage/multifilesystem.py||radicale/storage/multifilesystem.py": [
          "File: radicale/storage/multifilesystem.py -> radicale/storage/multifilesystem.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: from . import filesystem",
          "31: from .. import ical",
          "32: from .. import log",
          "35: class Collection(filesystem.Collection):",
          "36:     \"\"\"Collection stored in several files per calendar.\"\"\"",
          "37:     def _create_dirs(self):",
          "41:     @property",
          "42:     def headers(self):",
          "",
          "[Removed Lines]",
          "38:         if not os.path.exists(self._path):",
          "39:             os.makedirs(self._path)",
          "",
          "[Added Lines]",
          "33: from .. import pathutils",
          "39:         if not os.path.exists(self._filesystem_path):",
          "40:             os.makedirs(self._filesystem_path)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:             name = (",
          "53:                 component.name if sys.version_info[0] >= 3 else",
          "54:                 component.name.encode(filesystem.FILESYSTEM_ENCODING))",
          "57:                 fd.write(text)",
          "59:     def delete(self):",
          "61:         os.remove(self._props_path)",
          "63:     def remove(self, name):",
          "67:     @property",
          "68:     def text(self):",
          "",
          "[Removed Lines]",
          "55:             path = os.path.join(self._path, name)",
          "56:             with filesystem.open(path, \"w\") as fd:",
          "60:         shutil.rmtree(self._path)",
          "64:         if os.path.exists(os.path.join(self._path, name)):",
          "65:             os.remove(os.path.join(self._path, name))",
          "",
          "[Added Lines]",
          "56:             filesystem_path = os.path.join(self._filesystem_path, name)",
          "57:             with filesystem.open(filesystem_path, \"w\") as fd:",
          "61:         shutil.rmtree(self._filesystem_path)",
          "65:         filesystem_path = os.path.join(self._filesystem_path, name)",
          "66:         if os.path.exists(filesystem_path):",
          "67:             os.remove(filesystem_path)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "70:             ical.Timezone, ical.Event, ical.Todo, ical.Journal, ical.Card)",
          "71:         items = set()",
          "72:         try:",
          "74:         except (OSError, IOError) as e:",
          "75:             log.LOGGER.info('Error while reading collection %r: %r'",
          "77:             return \"\"",
          "79:         for filename in filenames:",
          "81:             try:",
          "82:                 with filesystem.open(path) as fd:",
          "83:                     items.update(self._parse(fd.read(), components))",
          "",
          "[Removed Lines]",
          "73:             filenames = os.listdir(self._path)",
          "76:                             % (self._path, e))",
          "80:             path = os.path.join(self._path, filename)",
          "",
          "[Added Lines]",
          "75:             filenames = os.listdir(self._filesystem_path)",
          "78:                             % (self._filesystem_path, e))",
          "82:             path = os.path.join(self._filesystem_path, filename)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "91:     @classmethod",
          "92:     def is_node(cls, path):",
          "96:     @classmethod",
          "97:     def is_leaf(cls, path):",
          "101:     @property",
          "102:     def last_modified(self):",
          "103:         last = max([",
          "106:         return time.strftime(\"%a, %d %b %Y %H:%M:%S +0000\", time.gmtime(last))",
          "",
          "[Removed Lines]",
          "93:         path = os.path.join(filesystem.FOLDER, path.replace(\"/\", os.sep))",
          "94:         return os.path.isdir(path) and not os.path.exists(path + \".props\")",
          "98:         path = os.path.join(filesystem.FOLDER, path.replace(\"/\", os.sep))",
          "99:         return os.path.isdir(path) and os.path.exists(path + \".props\")",
          "104:             os.path.getmtime(os.path.join(self._path, filename))",
          "105:             for filename in os.listdir(self._path)] or [0])",
          "",
          "[Added Lines]",
          "95:         filesystem_path = pathutils.path_to_filesystem(path,",
          "96:                                                        filesystem.FOLDER)",
          "97:         return (os.path.isdir(filesystem_path) and",
          "98:                 not os.path.exists(filesystem_path + \".props\"))",
          "102:         filesystem_path = pathutils.path_to_filesystem(path,",
          "103:                                                        filesystem.FOLDER)",
          "104:         return (os.path.isdir(filesystem_path) and",
          "105:                 os.path.exists(path + \".props\"))",
          "110:             os.path.getmtime(os.path.join(self._filesystem_path, filename))",
          "111:             for filename in os.listdir(self._filesystem_path)] or [0])",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "eed37792aef835a18cf1413814adf37a3394b4d1",
      "candidate_info": {
        "commit_hash": "eed37792aef835a18cf1413814adf37a3394b4d1",
        "repo": "Unrud/Radicale",
        "commit_url": "https://github.com/Unrud/Radicale/commit/eed37792aef835a18cf1413814adf37a3394b4d1",
        "files": [
          "radicale/pathutils.py",
          "radicale/storage/filesystem.py"
        ],
        "message": "Convert filesystem paths safely to paths This only becomes a problem if the OS/filesystem allows / in filenames or . respectively .. as filenames.",
        "before_after_code_files": [
          "radicale/pathutils.py||radicale/pathutils.py",
          "radicale/storage/filesystem.py||radicale/storage/filesystem.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/Kozea/Radicale/pull/343"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "radicale/pathutils.py||radicale/pathutils.py": [
          "File: radicale/pathutils.py -> radicale/pathutils.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:     return new_path + trailing_slash",
          "43: def is_safe_filesystem_path_component(path):",
          "44:     \"\"\"Checks if path is a single component of a local filesystem path",
          "45:        and is safe to join\"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43: def is_safe_path_component(path):",
          "44:     \"\"\"Checks if path is a single component of a path and is safe to join\"\"\"",
          "45:     if not path:",
          "46:         return False",
          "47:     head, _ = posixpath.split(path)",
          "48:     if head:",
          "49:         return False",
          "50:     if path in (\".\", \"..\"):",
          "51:         return False",
          "52:     return True",
          "",
          "---------------"
        ],
        "radicale/storage/filesystem.py||radicale/storage/filesystem.py": [
          "File: radicale/storage/filesystem.py -> radicale/storage/filesystem.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: import sys",
          "30: from contextlib import contextmanager",
          "35: FOLDER = os.path.expanduser(config.get(\"storage\", \"filesystem_folder\"))",
          "",
          "[Removed Lines]",
          "32: from .. import config, ical, pathutils",
          "",
          "[Added Lines]",
          "32: from .. import config, ical, log, pathutils",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100:         filesystem_path = pathutils.path_to_filesystem(path, FOLDER)",
          "101:         _, directories, files = next(os.walk(filesystem_path))",
          "102:         for filename in directories + files:",
          "103:             rel_filename = posixpath.join(path, filename)",
          "104:             if cls.is_node(rel_filename) or cls.is_leaf(rel_filename):",
          "105:                 yield cls(rel_filename)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "103:             # make sure that the local filename can be translated",
          "104:             # into an internal path",
          "105:             if not pathutils.is_safe_path_component(filename):",
          "106:                 log.LOGGER.debug(\"Skipping unsupported filename: %s\",",
          "107:                                  filename)",
          "108:                 continue",
          "",
          "---------------"
        ]
      }
    }
  ]
}
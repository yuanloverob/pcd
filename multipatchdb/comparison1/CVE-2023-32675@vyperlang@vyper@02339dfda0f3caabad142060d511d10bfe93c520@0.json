{
  "cve_id": "CVE-2023-32675",
  "cve_desc": "Vyper is a pythonic Smart Contract Language for the ethereum virtual machine. In contracts with more than one regular nonpayable function, it is possible to send funds to the default function, even if the default function is marked `nonpayable`. This applies to contracts compiled with vyper versions prior to 0.3.8. This issue was fixed by the removal of the global `calldatasize` check in commit `02339dfda`. Users are advised to upgrade to version 0.3.8. Users unable to upgrade should avoid use of nonpayable default functions.",
  "repo": "vyperlang/vyper",
  "patch_hash": "02339dfda0f3caabad142060d511d10bfe93c520",
  "patch_info": {
    "commit_hash": "02339dfda0f3caabad142060d511d10bfe93c520",
    "repo": "vyperlang/vyper",
    "commit_url": "https://github.com/vyperlang/vyper/commit/02339dfda0f3caabad142060d511d10bfe93c520",
    "files": [
      "tests/parser/features/test_init.py",
      "vyper/codegen/function_definitions/external_function.py",
      "vyper/codegen/module.py"
    ],
    "message": "refactor: optimize calldatasize check (#3104)\n\nthis changes the calldatasize check from a global/contract-entry check\nto a function-local check - the calldatasize check only needs to be\npresent if a selector is 0. this maintains the invariant protecting\nagainst the bug in #1603 while being more efficient.\n\nCo-authored-by: Charles Cooper <cooper.charles.m@gmail.com>",
    "before_after_code_files": [
      "tests/parser/features/test_init.py||tests/parser/features/test_init.py",
      "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
      "vyper/codegen/module.py||vyper/codegen/module.py"
    ]
  },
  "patch_diff": {
    "tests/parser/features/test_init.py||tests/parser/features/test_init.py": [
      "File: tests/parser/features/test_init.py -> tests/parser/features/test_init.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "15:     assert c.val() == 123",
      "17:     # Make sure the init code does not access calldata",
      "26: def test_init_calls_internal(get_contract, assert_compile_failed, assert_tx_failed):",
      "",
      "[Removed Lines]",
      "18:     opcodes = vyper.compile_code(code, [\"opcodes\"])[\"opcodes\"].split(\" \")",
      "19:     ir_return_idx = opcodes.index(\"JUMP\")",
      "21:     assert \"CALLDATALOAD\" in opcodes",
      "22:     assert \"CALLDATACOPY\" not in opcodes[:ir_return_idx]",
      "23:     assert \"CALLDATALOAD\" not in opcodes[:ir_return_idx]",
      "",
      "[Added Lines]",
      "18:     assembly = vyper.compile_code(code, [\"asm\"])[\"asm\"].split(\" \")",
      "19:     ir_return_idx_start = assembly.index(\"{\")",
      "20:     ir_return_idx_end = assembly.index(\"}\")",
      "22:     assert \"CALLDATALOAD\" in assembly",
      "23:     assert \"CALLDATACOPY\" not in assembly[:ir_return_idx_start] + assembly[ir_return_idx_end:]",
      "24:     assert \"CALLDATALOAD\" not in assembly[:ir_return_idx_start] + assembly[ir_return_idx_end:]",
      "",
      "---------------"
    ],
    "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py": [
      "File: vyper/codegen/function_definitions/external_function.py -> vyper/codegen/function_definitions/external_function.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "124:         ret.append([\"goto\", sig.external_function_base_entry_label])",
      "127:         return ret",
      "129:     ret = [\"seq\"]",
      "",
      "[Removed Lines]",
      "126:         ret = [\"if\", [\"eq\", \"_calldata_method_id\", method_id], ret]",
      "",
      "[Added Lines]",
      "126:         method_id_check = [\"eq\", \"_calldata_method_id\", method_id]",
      "128:         # if there is a function whose selector is 0, it won't be distinguished",
      "129:         # from the case where nil calldata is supplied, b/c calldataload loads",
      "130:         # 0s past the end of physical calldata (cf. yellow paper).",
      "131:         # since supplying 0 calldata is expected to trigger the fallback fn,",
      "132:         # we check that calldatasize > 0, which distinguishes the 0 selector",
      "133:         # from the fallback function \"selector\"",
      "134:         # (equiv. to \"all selectors not in the selector table\").",
      "136:         # note: cases where not enough calldata is supplied (besides",
      "137:         # calldatasize==0) are not addressed here b/c a calldatasize",
      "138:         # well-formedness check is already present in the function body",
      "139:         # as part of abi validation",
      "140:         if method_id.value == 0:",
      "141:             method_id_check = [\"and\", [\"gt\", \"calldatasize\", 0], method_id_check]",
      "143:         ret = [\"if\", method_id_check, ret]",
      "",
      "---------------"
    ],
    "vyper/codegen/module.py||vyper/codegen/module.py": [
      "File: vyper/codegen/module.py -> vyper/codegen/module.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "121:     runtime = [",
      "122:         \"seq\",",
      "126:         [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section],",
      "127:         close_selector_section,",
      "128:         [\"label\", \"fallback\", [\"var_list\"], fallback_ir],",
      "",
      "[Removed Lines]",
      "123:         # check that calldatasize is at least 4, otherwise",
      "124:         # calldataload will load zeros (cf. yellow paper).",
      "125:         [\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]],",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3de52b3ed4bdddf688a86c684f625164409ecfcc",
      "candidate_info": {
        "commit_hash": "3de52b3ed4bdddf688a86c684f625164409ecfcc",
        "repo": "vyperlang/vyper",
        "commit_url": "https://github.com/vyperlang/vyper/commit/3de52b3ed4bdddf688a86c684f625164409ecfcc",
        "files": [
          "tests/parser/features/iteration/test_repeater.py",
          "vyper/codegen/function_definitions/external_function.py",
          "vyper/codegen/function_definitions/internal_function.py",
          "vyper/codegen/lll_node.py",
          "vyper/codegen/module.py",
          "vyper/codegen/return_.py",
          "vyper/codegen/self_call.py",
          "vyper/codegen/stmt.py",
          "vyper/compiler/output.py",
          "vyper/compiler/phases.py",
          "vyper/evm/opcodes.py",
          "vyper/exceptions.py",
          "vyper/lll/compile_lll.py",
          "vyper/utils.py"
        ],
        "message": "feat: add parametrized labels to LLL (#2598)\n\nChange labels in LLL to be parameterized. Previously, stack items were\nimplicitly consumed from jumpdests using `pass`, which made liveness\nanalysis for stack items impossible in general. Now, any parameters\npassed on the stack are expicitly named. Since labels now take\nparameters, they are very similar to subroutines so we could use that\nterminology interchangeably. Note that this changes the structure of\nlabels - instead of allowing labels to occur arbitrarily in code, they\nturn into blocks, enforcing scope of the named stack items.\n\nThis change also enables translation to other architectures such as LLVM\nbackends since implicit stack items cannot be handled in translation to\na register machine.\n\nThis commit also renames `get_comb_opcodes` to `get_lll_opcodes`.\nIt originally stood for \"get combined [pseudo- and evm-] opcodes\". What\nit really meant is \"get all LLL opcodes\".\n\nLastly, this commit also adds an `exit_to` instruction for LLL. This\ncompiles the same as `goto` -- to a JUMP instruction -- but has\ndifferent scoping semantics. `exit_to` terminates a subroutine while\n`goto` expects control flow to be returned. This is an important hint\nfor liveness analysis. If you hit an `exit_to`, all stack items in scope\nmust be consumed, whereas if you hit a `goto` the same requirement does\nnot hold.\n\nIn order to accomodate the semantic change, this commit changes the\ncodegen everywhere that stack items are consumed implicitly. In\npractice, this happens in private functions, and in function common\ncleanup blocks. Also, all blocks must now be terminated (either with an\nEVM stopping instruction like STOP, or with the new `exit_to` macro).\n\nNote: the assembly output for all contracts I looked at were\nbyte-for-byte the same with the exception of those which returned\nstraight out of a loop (using the LLL `cleanup_repeat` instruction), so\nthis commit adds a couple more tests to test returns out of loops (in\nthe void return and external cases)",
        "before_after_code_files": [
          "tests/parser/features/iteration/test_repeater.py||tests/parser/features/iteration/test_repeater.py",
          "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
          "vyper/codegen/function_definitions/internal_function.py||vyper/codegen/function_definitions/internal_function.py",
          "vyper/codegen/lll_node.py||vyper/codegen/lll_node.py",
          "vyper/codegen/module.py||vyper/codegen/module.py",
          "vyper/codegen/return_.py||vyper/codegen/return_.py",
          "vyper/codegen/self_call.py||vyper/codegen/self_call.py",
          "vyper/codegen/stmt.py||vyper/codegen/stmt.py",
          "vyper/compiler/output.py||vyper/compiler/output.py",
          "vyper/compiler/phases.py||vyper/compiler/phases.py",
          "vyper/evm/opcodes.py||vyper/evm/opcodes.py",
          "vyper/exceptions.py||vyper/exceptions.py",
          "vyper/lll/compile_lll.py||vyper/lll/compile_lll.py",
          "vyper/utils.py||vyper/utils.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ],
          "candidate": [
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ]
        }
      },
      "candidate_diff": {
        "tests/parser/features/iteration/test_repeater.py||tests/parser/features/iteration/test_repeater.py": [
          "File: tests/parser/features/iteration/test_repeater.py -> tests/parser/features/iteration/test_repeater.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "155:     assert c.foo(100) == 31337",
          "158: @pytest.mark.parametrize(\"typ\", [\"int128\", \"uint256\"])",
          "159: def test_breaks_and_returns_inside_nested_repeater(get_contract, typ):",
          "160:     code = f\"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "158: @pytest.mark.parametrize(\"typ\", [\"int128\", \"uint256\"])",
          "159: @pytest.mark.parametrize(\"val\", range(20))",
          "160: def test_return_void_nested_repeater(get_contract, typ, val):",
          "161:     code = f\"\"\"",
          "162: result: {typ}",
          "163: @internal",
          "164: def _final(a: {typ}):",
          "165:     for i in range(10):",
          "166:         for x in range(10):",
          "167:             if i + x > a:",
          "168:                 self.result = i + x",
          "169:                 return",
          "170:     self.result = 31337",
          "172: @internal",
          "173: def _middle(a: {typ}):",
          "174:     self._final(a)",
          "176: @external",
          "177: def foo(a: {typ}) -> {typ}:",
          "178:     self._middle(a)",
          "179:     return self.result",
          "180:     \"\"\"",
          "181:     c = get_contract(code)",
          "182:     if val + 1 >= 19:",
          "183:         assert c.foo(val) == 31337",
          "184:     else:",
          "185:         assert c.foo(val) == val + 1",
          "188: @pytest.mark.parametrize(\"typ\", [\"int128\", \"uint256\"])",
          "189: @pytest.mark.parametrize(\"val\", range(20))",
          "190: def test_external_nested_repeater(get_contract, typ, val):",
          "191:     code = f\"\"\"",
          "192: @external",
          "193: def foo(a: {typ}) -> {typ}:",
          "194:     for i in range(10):",
          "195:         for x in range(10):",
          "196:             if i + x > a:",
          "197:                 return i + x",
          "198:     return 31337",
          "199:     \"\"\"",
          "200:     c = get_contract(code)",
          "201:     if val + 1 >= 19:",
          "202:         assert c.foo(val) == 31337",
          "203:     else:",
          "204:         assert c.foo(val) == val + 1",
          "207: @pytest.mark.parametrize(\"typ\", [\"int128\", \"uint256\"])",
          "208: @pytest.mark.parametrize(\"val\", range(20))",
          "209: def test_external_void_nested_repeater(get_contract, typ, val):",
          "210:     # test return out of loop in void external function",
          "211:     code = f\"\"\"",
          "212: result: public({typ})",
          "213: @external",
          "214: def foo(a: {typ}):",
          "215:     for i in range(10):",
          "216:         for x in range(10):",
          "217:             if i + x > a:",
          "218:                 self.result = i + x",
          "219:                 return",
          "220:     self.result = 31337",
          "221:     \"\"\"",
          "222:     c = get_contract(code)",
          "223:     c.foo(val, transact={})",
          "224:     if val + 1 >= 19:",
          "225:         assert c.result() == 31337",
          "226:     else:",
          "227:         assert c.result() == val + 1",
          "",
          "---------------"
        ],
        "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py": [
          "File: vyper/codegen/function_definitions/external_function.py -> vyper/codegen/function_definitions/external_function.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "176:     # generate handlers for kwargs and register the variable records",
          "177:     kwarg_handlers = _generate_kwarg_handlers(context, sig, pos)",
          "179:     # once optional args have been handled,",
          "180:     # generate the main body of the function",
          "185:     if check_nonpayable and sig.mutability != \"payable\":",
          "186:         # if the contract contains payable functions, but this is not one of them",
          "187:         # add an assertion that the value of the call is zero",
          "195:     if sig.is_init_func:",
          "196:         pass  # init func has special exit sequence generated by module.py",
          "197:     elif context.return_type is None:",
          "199:     else:",
          "203:     # the lll which comprises the main body of the function,",
          "204:     # besides any kwarg handling",
          "207:     if sig.is_default_func or sig.is_init_func:",
          "210:     else:",
          "211:         ret = kwarg_handlers",
          "212:         # sneak the base code into the kwarg handler",
          "",
          "[Removed Lines]",
          "181:     entrance = [[\"label\", sig.external_function_base_entry_label]]",
          "183:     entrance += handle_base_args",
          "188:         entrance += [[\"assert\", [\"iszero\", \"callvalue\"]]]",
          "190:     entrance += nonreentrant_pre",
          "192:     body = [parse_body(c, context) for c in code.body]",
          "194:     exit = [[\"label\", sig.exit_sequence_label]] + nonreentrant_post",
          "198:         exit += [[\"stop\"]]",
          "200:         # ret_ofst and ret_len stack items passed by function body; consume using 'pass'",
          "201:         exit += [[\"return\", \"pass\", \"pass\"]]",
          "205:     func_common_lll = [\"seq\"] + entrance + body + exit",
          "208:         # default and init funcs have special entries generated by module.py",
          "209:         ret = func_common_lll",
          "",
          "[Added Lines]",
          "179:     body = [\"seq\"]",
          "182:     body += handle_base_args",
          "187:         body += [[\"assert\", [\"iszero\", \"callvalue\"]]]",
          "189:     body += nonreentrant_pre",
          "191:     body += [parse_body(code.body, context, ensure_terminated=True)]",
          "193:     # wrap the body in labeled block",
          "194:     body = [\"label\", sig.external_function_base_entry_label, [\"var_list\"], body]",
          "196:     exit_sequence = [\"seq\"] + nonreentrant_post",
          "200:         exit_sequence += [[\"stop\"]]",
          "202:         exit_sequence += [[\"return\", \"ret_ofst\", \"ret_len\"]]",
          "204:     exit_sequence_args = [\"var_list\"]",
          "205:     if context.return_type is not None:",
          "206:         exit_sequence_args += [\"ret_ofst\", \"ret_len\"]",
          "207:     # wrap the exit in a labeled block",
          "208:     exit = [\"label\", sig.exit_sequence_label, exit_sequence_args, exit_sequence]",
          "212:     func_common_lll = [\"seq\", body, exit]",
          "215:         ret = [\"seq\"]",
          "216:         # add a goto to make the function entry look like other functions",
          "217:         # (for zksync interpreter)",
          "218:         ret.append([\"goto\", sig.external_function_base_entry_label])",
          "219:         ret.append(func_common_lll)",
          "",
          "---------------"
        ],
        "vyper/codegen/function_definitions/internal_function.py||vyper/codegen/function_definitions/internal_function.py": [
          "File: vyper/codegen/function_definitions/internal_function.py -> vyper/codegen/function_definitions/internal_function.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:     function_entry_label = sig.internal_function_label",
          "53:     cleanup_label = sig.exit_sequence_label",
          "64:     return LLLnode.from_list(",
          "66:         typ=None,",
          "67:         pos=getpos(code),",
          "68:     )",
          "",
          "[Removed Lines]",
          "55:     # jump to the label which was passed in via stack",
          "56:     stop_func = LLLnode.from_list([\"jump\", \"pass\"], annotation=\"jump to return address\")",
          "58:     enter = [[\"label\", function_entry_label]] + nonreentrant_pre",
          "60:     body = [parse_body(c, context) for c in code.body]",
          "62:     exit = [[\"label\", cleanup_label]] + nonreentrant_post + [stop_func]",
          "65:         [\"seq\"] + enter + body + exit,",
          "",
          "[Added Lines]",
          "55:     stack_args = [\"var_list\"]",
          "56:     if func_type.return_type:",
          "57:         stack_args += [\"return_buffer\"]",
          "58:     stack_args += [\"return_pc\"]",
          "60:     body = [",
          "61:         \"label\",",
          "62:         function_entry_label,",
          "63:         stack_args,",
          "64:         [\"seq\"] + nonreentrant_pre + [parse_body(code.body, context, ensure_terminated=True)],",
          "65:     ]",
          "67:     cleanup_routine = [",
          "68:         \"label\",",
          "69:         cleanup_label,",
          "70:         [\"var_list\", \"return_pc\"],",
          "71:         [\"seq\"] + nonreentrant_post + [[\"exit_to\", \"return_pc\"]],",
          "72:     ]",
          "75:         [\"seq\", body, cleanup_routine],",
          "",
          "---------------"
        ],
        "vyper/codegen/lll_node.py||vyper/codegen/lll_node.py": [
          "File: vyper/codegen/lll_node.py -> vyper/codegen/lll_node.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: from vyper.codegen.types import BaseType, NodeType, ceil32",
          "6: from vyper.compiler.settings import VYPER_COLOR_OUTPUT",
          "9: from vyper.utils import VALID_LLL_MACROS, cached_property",
          "11: # Set default string representation for ints in LLL output.",
          "",
          "[Removed Lines]",
          "7: from vyper.evm.opcodes import get_comb_opcodes",
          "8: from vyper.exceptions import CompilerPanic",
          "",
          "[Added Lines]",
          "7: from vyper.evm.opcodes import get_lll_opcodes",
          "8: from vyper.exceptions import CodegenPanic, CompilerPanic",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "108:             self.gas = 5",
          "109:         elif isinstance(self.value, str):",
          "110:             # Opcodes and pseudo-opcodes (e.g. clamp)",
          "113:                 self.valency = outs",
          "114:                 _check(",
          "115:                     len(self.args) == ins,",
          "",
          "[Removed Lines]",
          "111:             if self.value.upper() in get_comb_opcodes():",
          "112:                 _, ins, outs, gas = get_comb_opcodes()[self.value.upper()]",
          "",
          "[Added Lines]",
          "111:             if self.value.upper() in get_lll_opcodes():",
          "112:                 _, ins, outs, gas = get_lll_opcodes()[self.value.upper()]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "212:             # GOTO is a jump with args",
          "213:             # e.g. (goto my_label x y z) will push x y and z onto the stack,",
          "214:             # then JUMP to my_label.",
          "216:                 for arg in self.args:",
          "217:                     _check(",
          "218:                         arg.valency == 1 or arg.value == \"pass\",",
          "",
          "[Removed Lines]",
          "215:             elif self.value == \"goto\":",
          "",
          "[Added Lines]",
          "215:             elif self.value in (\"goto\", \"exit_to\"):",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "222:                 self.valency = 0",
          "223:                 self.gas = sum([arg.gas for arg in self.args])",
          "224:             # Multi statements: multi <expr> <expr> ...",
          "225:             elif self.value == \"multi\":",
          "226:                 for arg in self.args:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "224:             elif self.value == \"label\":",
          "225:                 if not self.args[1].value == \"var_list\":",
          "226:                     raise CodegenPanic(f\"2nd argument to label must be var_list, {self}\")",
          "227:                 self.valency = 0",
          "228:                 self.gas = 1 + sum(t.gas for t in self.args)",
          "229:             # var_list names a variable number stack variables",
          "230:             elif self.value == \"var_list\":",
          "231:                 for arg in self.args:",
          "232:                     if not isinstance(arg.value, str) or len(arg.args) > 0:",
          "233:                         raise CodegenPanic(f\"var_list only takes strings: {self.args}\")",
          "234:                 self.valency = 0",
          "235:                 self.gas = 0",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "261:         do_not_cache = {\"~empty\"}",
          "262:         return (",
          "263:             isinstance(self.value, str)",
          "265:             and self.value.lower() not in do_not_cache",
          "266:         )",
          "",
          "[Removed Lines]",
          "264:             and (self.value.lower() in VALID_LLL_MACROS or self.value.upper() in get_comb_opcodes())",
          "",
          "[Added Lines]",
          "277:             and (self.value.lower() in VALID_LLL_MACROS or self.value.upper() in get_lll_opcodes())",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "371:     def _colorise_keywords(val):",
          "372:         if val.lower() in VALID_LLL_MACROS:  # highlight macro",
          "373:             return OKLIGHTMAGENTA + val + ENDC",
          "375:             return OKMAGENTA + val + ENDC",
          "376:         return val",
          "",
          "[Removed Lines]",
          "374:         elif val.upper() in get_comb_opcodes().keys():",
          "",
          "[Added Lines]",
          "387:         elif val.upper() in get_lll_opcodes().keys():",
          "",
          "---------------"
        ],
        "vyper/codegen/module.py||vyper/codegen/module.py": [
          "File: vyper/codegen/module.py -> vyper/codegen/module.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "175:         \"seq\",",
          "176:         func_init_lll(),",
          "177:         [\"with\", \"_calldata_method_id\", [\"mload\", 0], external_seq],",
          "179:     ]",
          "180:     runtime.extend(internal_funcs)",
          "",
          "[Removed Lines]",
          "178:         [\"seq\", [\"label\", \"fallback\"], fallback_lll],",
          "",
          "[Added Lines]",
          "178:         [\"label\", \"fallback\", [\"var_list\"], fallback_lll],",
          "",
          "---------------"
        ],
        "vyper/codegen/return_.py||vyper/codegen/return_.py": [
          "File: vyper/codegen/return_.py -> vyper/codegen/return_.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:     sig = context.sig",
          "26:     _pos = getpos(stmt)",
          "",
          "[Removed Lines]",
          "24:     jump_to_exit = [\"goto\", sig.exit_sequence_label]",
          "",
          "[Added Lines]",
          "24:     jump_to_exit = [\"exit_to\", f\"_sym_{sig.exit_sequence_label}\"]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "40:             fill_return_buffer, annotation=f\"fill return buffer {sig._lll_identifier}\"",
          "41:         )",
          "42:         cleanup_loops = \"cleanup_repeat\" if context.forvars else \"pass\"",
          "43:         return LLLnode.from_list(",
          "46:             pos=_pos,",
          "47:         )",
          "49:     if context.return_type is None:",
          "50:         return finalize([\"pass\"])",
          "52:     if context.is_internal:",
          "53:         dst = LLLnode.from_list([\"return_buffer\"], typ=context.return_type, location=\"memory\")",
          "61:         return finalize(fill_return_buffer)",
          "",
          "[Removed Lines]",
          "44:             [\"seq\", cleanup_loops, fill_return_buffer, jump_to_exit],",
          "45:             typ=None,",
          "54:         fill_return_buffer = [",
          "55:             \"with\",",
          "56:             dst,",
          "57:             \"pass\",  # return_buffer is passed on the stack by caller",
          "58:             make_setter(dst, lll_val, pos=_pos),",
          "59:         ]",
          "",
          "[Added Lines]",
          "43:         # NOTE: because stack analysis is incomplete, cleanup_repeat must",
          "44:         # come after fill_return_buffer otherwise the stack will break",
          "46:             [\"seq\", fill_return_buffer, cleanup_loops, jump_to_exit],",
          "51:         jump_to_exit += [\"return_pc\"]",
          "56:         fill_return_buffer = make_setter(dst, lll_val, pos=_pos)",
          "57:         jump_to_exit += [\"return_pc\"]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "80:         # CMC introduced `goto` with args so this enables us to replace `seq_unchecked` w/ `seq`",
          "81:         # and then just append the arguments for the cleanup to the `jump_to_exit` list",
          "82:         # check in vyper/codegen/self_call.py for an example",
          "85:         return finalize([\"pass\"])",
          "",
          "[Removed Lines]",
          "83:         jump_to_exit += [return_buffer_ofst, encode_out]",
          "",
          "[Added Lines]",
          "81:         jump_to_exit += [return_buffer_ofst, encode_out]  # type: ignore",
          "",
          "---------------"
        ],
        "vyper/codegen/self_call.py||vyper/codegen/self_call.py": [
          "File: vyper/codegen/self_call.py -> vyper/codegen/self_call.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:     # allocate space for the return buffer",
          "59:     # TODO allocate in stmt and/or expr.py",
          "65:     # note: dst_tuple_t != args_tuple_t",
          "66:     dst_tuple_t = TupleType([arg.typ for arg in sig.args])",
          "",
          "[Removed Lines]",
          "60:     return_buffer = (",
          "61:         context.new_internal_variable(sig.return_type) if sig.return_type is not None else \"pass\"",
          "62:     )",
          "63:     return_buffer = LLLnode.from_list([return_buffer], annotation=f\"{return_label}_return_buf\")",
          "",
          "[Added Lines]",
          "60:     if sig.return_type is not None:",
          "61:         return_buffer = LLLnode.from_list(",
          "62:             context.new_internal_variable(sig.return_type), annotation=f\"{return_label}_return_buf\"",
          "63:         )",
          "64:     else:",
          "65:         return_buffer = None",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "88:     else:",
          "89:         copy_args = make_setter(args_dst, args_as_tuple, pos)",
          "91:     call_sequence = [",
          "92:         \"seq\",",
          "93:         copy_args,",
          "102:     ]",
          "104:     o = LLLnode.from_list(",
          "105:         call_sequence,",
          "",
          "[Removed Lines]",
          "94:         [",
          "95:             \"goto\",",
          "96:             sig.internal_function_label,",
          "97:             return_buffer,  # pass return buffer to subroutine",
          "98:             push_label_to_stack(return_label),  # pass return label to subroutine",
          "99:         ],",
          "100:         [\"label\", return_label],",
          "101:         return_buffer,  # push return buffer location to stack",
          "",
          "[Added Lines]",
          "93:     goto_op = [\"goto\", sig.internal_function_label]",
          "94:     # pass return buffer to subroutine",
          "95:     if return_buffer is not None:",
          "96:         goto_op += [return_buffer]",
          "97:     # pass return label to subroutine",
          "98:     goto_op += [push_label_to_stack(return_label)]",
          "103:         goto_op,",
          "104:         [\"label\", return_label, [\"var_list\"], \"pass\"],",
          "106:     if return_buffer is not None:",
          "107:         # push return buffer location to stack",
          "108:         call_sequence += [return_buffer]",
          "",
          "---------------"
        ],
        "vyper/codegen/stmt.py||vyper/codegen/stmt.py": [
          "File: vyper/codegen/stmt.py -> vyper/codegen/stmt.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "10:     get_dyn_array_count,",
          "11:     get_element_ptr,",
          "12:     getpos,",
          "13:     make_byte_array_copier,",
          "14:     make_setter,",
          "15:     pop_dyn_array,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13:     is_return_from_function,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "448:     return Stmt(stmt, context).lll_node",
          "453:     if not isinstance(code, list):",
          "454:         return parse_stmt(code, context)",
          "",
          "[Removed Lines]",
          "451: # Parse a piece of code",
          "452: def parse_body(code, context):",
          "",
          "[Added Lines]",
          "452: # check if a function body is \"terminated\"",
          "453: # a function is terminated if it ends with a return stmt, OR,",
          "454: # it ends with an if/else and both branches are terminated.",
          "455: # (if not, we need to insert a terminator so that the IR is well-formed)",
          "456: def _is_terminated(code):",
          "457:     last_stmt = code[-1]",
          "459:     if is_return_from_function(last_stmt):",
          "460:         return True",
          "462:     if isinstance(last_stmt, vy_ast.If):",
          "463:         if last_stmt.orelse:",
          "464:             return _is_terminated(last_stmt.body) and _is_terminated(last_stmt.orelse)",
          "465:     return False",
          "468: # codegen a list of statements",
          "469: def parse_body(code, context, ensure_terminated=False):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "457:     for stmt in code:",
          "458:         lll = parse_stmt(stmt, context)",
          "459:         lll_node.append(lll)",
          "461:     return LLLnode.from_list(lll_node, pos=getpos(code[0]) if code else None)",
          "",
          "[Removed Lines]",
          "460:     lll_node.append(\"pass\")  # force zerovalent, even last statement",
          "",
          "[Added Lines]",
          "478:     # force using the return routine / exit_to cleanup for end of function",
          "479:     if ensure_terminated and context.return_type is None and not _is_terminated(code):",
          "480:         lll_node.append(parse_stmt(vy_ast.Return(value=None), context))",
          "482:     # force zerovalent, even last statement",
          "483:     lll_node.append(\"pass\")  # CMC 2022-01-16 is this necessary?",
          "",
          "---------------"
        ],
        "vyper/compiler/output.py||vyper/compiler/output.py": [
          "File: vyper/compiler/output.py -> vyper/compiler/output.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "161: def _build_asm(asm_list):",
          "162:     output_string = \"\"",
          "164:     for node in asm_list:",
          "165:         if isinstance(node, list):",
          "166:             output_string += \"[ \" + _build_asm(node) + \"] \"",
          "167:             continue",
          "176:         else:",
          "179:     return output_string",
          "",
          "[Removed Lines]",
          "163:     skip_newlines = 0",
          "169:         is_push = isinstance(node, str) and node.startswith(\"PUSH\")",
          "171:         output_string += str(node) + \" \"",
          "172:         if skip_newlines:",
          "173:             skip_newlines -= 1",
          "174:         elif is_push:",
          "175:             skip_newlines = int(node[4:]) - 1",
          "177:             output_string += \" \"",
          "",
          "[Added Lines]",
          "163:     in_push = 0",
          "170:         if in_push > 0:",
          "171:             assert isinstance(node, int), node",
          "172:             output_string += hex(node)[2:].rjust(2, \"0\")",
          "173:             if in_push == 1:",
          "174:                 output_string += \" \"",
          "175:             in_push -= 1",
          "177:             assert isinstance(node, str), node",
          "179:             output_string += node + \" \"",
          "181:             if node.startswith(\"PUSH\"):",
          "182:                 assert in_push == 0",
          "183:                 in_push = int(node[4:])",
          "184:                 output_string += \"0x\"",
          "",
          "---------------"
        ],
        "vyper/compiler/phases.py||vyper/compiler/phases.py": [
          "File: vyper/compiler/phases.py -> vyper/compiler/phases.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "141:     @property",
          "142:     def assembly(self) -> list:",
          "143:         if not hasattr(self, \"_assembly\"):",
          "145:         return self._assembly",
          "147:     @property",
          "148:     def assembly_runtime(self) -> list:",
          "149:         if not hasattr(self, \"_assembly_runtime\"):",
          "151:         return self._assembly_runtime",
          "153:     @property",
          "",
          "[Removed Lines]",
          "144:             self._assembly = generate_assembly(self.lll_nodes)",
          "150:             self._assembly_runtime = generate_assembly(self.lll_runtime)",
          "",
          "[Added Lines]",
          "144:             self._assembly = generate_assembly(self.lll_nodes, self.no_optimize)",
          "150:             self._assembly_runtime = generate_assembly(self.lll_runtime, self.no_optimize)",
          "",
          "---------------"
        ],
        "vyper/evm/opcodes.py||vyper/evm/opcodes.py": [
          "File: vyper/evm/opcodes.py -> vyper/evm/opcodes.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "206:     \"SET\": (None, 2, 0, 20),",
          "207:     \"NE\": (None, 2, 1, 6),",
          "208:     \"DEBUGGER\": (None, 0, 0, 0),",
          "210: }",
          "215: def evm_wrapper(fn, *args, **kwargs):",
          "",
          "[Removed Lines]",
          "209:     \"LABEL\": (None, 1, 0, 1),",
          "212: COMB_OPCODES: OpcodeMap = {**OPCODES, **PSEUDO_OPCODES}",
          "",
          "[Added Lines]",
          "211: LLL_OPCODES: OpcodeMap = {**OPCODES, **PSEUDO_OPCODES}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "245: _evm_opcodes: Dict[int, OpcodeRulesetMap] = {",
          "246:     v: _mk_version_opcodes(OPCODES, v) for v in EVM_VERSIONS.values()",
          "247: }",
          "251: }",
          "",
          "[Removed Lines]",
          "249: _evm_combined: Dict[int, OpcodeRulesetMap] = {",
          "250:     v: _mk_version_opcodes(COMB_OPCODES, v) for v in EVM_VERSIONS.values()",
          "",
          "[Added Lines]",
          "247: _lll_opcodes: Dict[int, OpcodeRulesetMap] = {",
          "248:     v: _mk_version_opcodes(LLL_OPCODES, v) for v in EVM_VERSIONS.values()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "255:     return _evm_opcodes[active_evm_version]",
          "262: def version_check(begin: Optional[str] = None, end: Optional[str] = None) -> bool:",
          "",
          "[Removed Lines]",
          "258: def get_comb_opcodes() -> OpcodeRulesetMap:",
          "259:     return _evm_combined[active_evm_version]",
          "",
          "[Added Lines]",
          "256: def get_lll_opcodes() -> OpcodeRulesetMap:",
          "257:     return _lll_opcodes[active_evm_version]",
          "",
          "---------------"
        ],
        "vyper/exceptions.py||vyper/exceptions.py": [
          "File: vyper/exceptions.py -> vyper/exceptions.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "299:     \"\"\"General unexpected error during compilation.\"\"\"",
          "302: class UnexpectedNodeType(VyperInternalException):",
          "303:     \"\"\"Unexpected AST node type.\"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "302: class CodegenPanic(VyperInternalException):",
          "303:     \"\"\"Invalid code generated during codegen phase\"\"\"",
          "",
          "---------------"
        ],
        "vyper/lll/compile_lll.py||vyper/lll/compile_lll.py": [
          "File: vyper/lll/compile_lll.py -> vyper/lll/compile_lll.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import functools",
          "3: from vyper.codegen.lll_node import LLLnode",
          "4: from vyper.evm.opcodes import get_opcodes",
          "6: from vyper.utils import MemoryPositions",
          "8: PUSH_OFFSET = 0x5F",
          "",
          "[Removed Lines]",
          "5: from vyper.exceptions import CompilerPanic",
          "",
          "[Added Lines]",
          "1: import copy",
          "6: from vyper.exceptions import CodegenPanic, CompilerPanic",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "50:     return isinstance(i, str) and i[:5] == \"_sym_\"",
          "53: def _assert_false():",
          "54:     # use a shared failure block for common case of assert(x).",
          "55:     # in the future we might want to change the code",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54: # temporary optimization to handle stack items for return sequences",
          "55: # like `return return_ofst return_len`. this is kind of brittle because",
          "56: # it assumes the arguments are already on the stack, to be replaced",
          "57: # by better liveness analysis.",
          "58: # NOTE: modifies input in-place",
          "59: def _rewrite_return_sequences(lll_node, label_params=None):",
          "60:     args = lll_node.args",
          "62:     if lll_node.value == \"return\":",
          "63:         if args[0].value == \"ret_ofst\" and args[1].value == \"ret_len\":",
          "64:             lll_node.args[0].value = \"pass\"",
          "65:             lll_node.args[1].value = \"pass\"",
          "66:     if lll_node.value == \"exit_to\":",
          "67:         # handle exit from private function",
          "68:         if args[0].value == \"return_pc\":",
          "69:             lll_node.value = \"jump\"",
          "70:             args[0].value = \"pass\"",
          "71:         else:",
          "72:             # handle jump to cleanup",
          "73:             assert is_symbol(args[0].value)",
          "74:             lll_node.value = \"seq\"",
          "76:             _t = [\"seq\"]",
          "77:             if \"return_buffer\" in label_params:",
          "78:                 _t.append([\"pop\", \"pass\"])",
          "80:             dest = args[0].value[5:]  # `_sym_foo` -> `foo`",
          "81:             more_args = [\"pass\" if t.value == \"return_pc\" else t for t in args[1:]]",
          "82:             _t.append([\"goto\", dest] + more_args)",
          "83:             lll_node.args = LLLnode.from_list(_t, pos=lll_node.pos).args",
          "85:     if lll_node.value == \"label\":",
          "86:         label_params = set(t.value for t in lll_node.args[1].args)",
          "88:     for t in args:",
          "89:         _rewrite_return_sequences(t, label_params)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "108: @apply_line_numbers",
          "109: def compile_to_assembly(code, no_optimize=False):",
          "110:     res = _compile_to_assembly(code)",
          "112:     _add_postambles(res)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "149:     # don't overwrite ir since the original might need to be output, e.g. `-f ir,asm`",
          "150:     code = copy.deepcopy(code)",
          "151:     _rewrite_return_sequences(code)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "123:     if not isinstance(withargs, dict):",
          "124:         raise CompilerPanic(f\"Incorrect type for withargs: {type(withargs)}\")",
          "126:     if existing_labels is None:",
          "127:         existing_labels = set()",
          "128:     if not isinstance(existing_labels, set):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "169:     def _height_of(witharg):",
          "170:         ret = height - withargs[witharg]",
          "171:         if ret > 16:",
          "172:             raise Exception(\"With statement too deep\")",
          "173:         return ret",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "145:         return [\"PUSH\" + str(len(bytez))] + bytez",
          "146:     # Variables connected to with statements",
          "147:     elif isinstance(code.value, str) and code.value in withargs:",
          "151:     # Setting variables connected to with statements",
          "152:     elif code.value == \"set\":",
          "153:         if len(code.args) != 2 or code.args[0].value not in withargs:",
          "",
          "[Removed Lines]",
          "148:         if height - withargs[code.value] > 16:",
          "149:             raise Exception(\"With statement too deep\")",
          "150:         return [\"DUP\" + str(height - withargs[code.value])]",
          "",
          "[Added Lines]",
          "197:         return [\"DUP\" + str(_height_of(code.value))]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "320:     elif code.value == \"cleanup_repeat\":",
          "321:         if not break_dest:",
          "322:             raise CompilerPanic(\"Invalid break\")",
          "324:         # clean up local vars and internal loop vars",
          "325:         return [\"POP\"] * break_height",
          "326:     # With statements",
          "327:     elif code.value == \"with\":",
          "",
          "[Removed Lines]",
          "323:         _, _, break_height = break_dest",
          "",
          "[Added Lines]",
          "371:         _, _, break_height = break_dest",
          "372:         # except don't pop label params",
          "373:         if \"return_buffer\" in withargs:",
          "374:             break_height -= 1",
          "375:         if \"return_pc\" in withargs:",
          "376:             break_height -= 1",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "583:             break_dest,",
          "584:             height,",
          "585:         )",
          "587:     elif code.value == \"goto\":",
          "588:         o = []",
          "589:         for i, c in enumerate(reversed(code.args[1:])):",
          "",
          "[Removed Lines]",
          "586:     # # jump to a symbol, and push variable arguments onto stack",
          "",
          "[Added Lines]",
          "638:     # jump to a symbol, and push variable # of arguments onto stack",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "594:         return [code.value]",
          "595:     # set a symbol as a location.",
          "596:     elif code.value == \"label\":",
          "599:         if label_name in existing_labels:",
          "600:             raise Exception(f\"Label with name {label_name} already exists!\")",
          "601:         else:",
          "602:             existing_labels.add(label_name)",
          "605:     # inject debug opcode.",
          "606:     elif code.value == \"debugger\":",
          "607:         return mkdebug(pc_debugger=False, pos=code.pos)",
          "",
          "[Removed Lines]",
          "597:         label_name = str(code.args[0])",
          "604:         return [\"_sym_\" + label_name, \"JUMPDEST\"]",
          "",
          "[Added Lines]",
          "649:         label_name = code.args[0].value",
          "650:         assert isinstance(label_name, str)",
          "657:         if code.args[1].value != \"var_list\":",
          "658:             raise CodegenPanic(\"2nd arg to label must be var_list\")",
          "659:         var_args = code.args[1].args",
          "661:         body = code.args[2]",
          "663:         # new scope",
          "664:         height = 0",
          "665:         withargs = {}",
          "667:         for arg in reversed(var_args):",
          "668:             assert isinstance(",
          "669:                 arg.value, str",
          "670:             )  # already checked for higher up but only the paranoid survive",
          "671:             withargs[arg.value] = height",
          "672:             height += 1",
          "674:         body_asm = _compile_to_assembly(",
          "675:             body, withargs=withargs, existing_labels=existing_labels, height=height",
          "676:         )",
          "677:         # pop_scoped_vars = [\"POP\"] * height",
          "678:         # for now, _rewrite_return_sequences forces",
          "679:         # label params to be consumed implicitly",
          "680:         pop_scoped_vars = []",
          "682:         return [\"_sym_\" + label_name, \"JUMPDEST\"] + body_asm + pop_scoped_vars",
          "684:     elif code.value == \"exit_to\":",
          "685:         raise CodegenPanic(\"exit_to not implemented yet!\")",
          "",
          "---------------"
        ],
        "vyper/utils.py||vyper/utils.py": [
          "File: vyper/utils.py -> vyper/utils.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "157: }",
          "159: # List of valid LLL macros.",
          "160: VALID_LLL_MACROS = {",
          "161:     \"assert\",",
          "162:     \"break\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "160: # TODO move this somewhere else, like lll_node.py",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "196:     \"~selfcode\",",
          "197:     \"~calldata\",",
          "198:     \"~empty\",",
          "199: }",
          "201: # Available base types",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "200:     \"var_list\",",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "33c247151cfed13999289c08f3c35d70fa83394d",
      "candidate_info": {
        "commit_hash": "33c247151cfed13999289c08f3c35d70fa83394d",
        "repo": "vyperlang/vyper",
        "commit_url": "https://github.com/vyperlang/vyper/commit/33c247151cfed13999289c08f3c35d70fa83394d",
        "files": [
          "vyper/codegen/function_definitions/external_function.py",
          "vyper/codegen/module.py"
        ],
        "message": "fix: add back global calldatasize check (#3463)\n\nprevent a performance regression for sending eth to contracts with a\npayable default function by (mostly) reverting the changes introduced in\n9ecb97b4b6f and 02339dfda0. the `skip_nonpayable_check=False` for the\ndefault function is introduced to address GHSA-vxmm-cwh2-q762 (which\n02339dfda0 inadvertently fixed, and a test for which was added in\n903727006c).",
        "before_after_code_files": [
          "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
          "vyper/codegen/module.py||vyper/codegen/module.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ],
          "candidate": [
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ]
        }
      },
      "candidate_diff": {
        "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py": [
          "File: vyper/codegen/function_definitions/external_function.py -> vyper/codegen/function_definitions/external_function.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "89:         calldata_min_size = args_abi_t.min_size() + 4",
          "91:         # note we don't need the check if calldata_min_size == 4,",
          "94:         if calldata_min_size > 4:",
          "95:             ret.append([\"assert\", [\"ge\", \"calldatasize\", calldata_min_size]])",
          "",
          "[Removed Lines]",
          "92:         # because the selector checks later in this routine ensure",
          "93:         # that calldatasize >= 4.",
          "",
          "[Added Lines]",
          "92:         # because the global calldatasize check ensures that already.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:         ret.append([\"goto\", func_t._ir_info.external_function_base_entry_label])",
          "127:         method_id_check = [\"eq\", \"_calldata_method_id\", method_id]",
          "150:         ret = [\"if\", method_id_check, ret]",
          "151:         return ret",
          "",
          "[Removed Lines]",
          "129:         # if there is a function whose selector is 0 or has trailing 0s, it",
          "130:         # might not be distinguished from the case where insufficient calldata",
          "131:         # is supplied, b/c calldataload loads 0s past the end of physical",
          "132:         # calldata (cf. yellow paper).",
          "133:         # since the expected behavior of supplying insufficient calldata",
          "134:         # is to trigger the fallback fn, we add to the selector check that",
          "135:         # calldatasize >= 4, which distinguishes any selector with trailing",
          "136:         # 0 bytes from the fallback function \"selector\" (equiv. to \"all",
          "137:         # selectors not in the selector table\").",
          "138:         #",
          "139:         # note that the inclusion of this check means that, we are always",
          "140:         # guaranteed that the calldata is at least 4 bytes - either we have",
          "141:         # the explicit `calldatasize >= 4` condition in the selector check,",
          "142:         # or there are no trailing zeroes in the selector, (so the selector",
          "143:         # is impossible to match without calldatasize being at least 4).",
          "144:         method_id_bytes = util.method_id(abi_sig)",
          "145:         assert len(method_id_bytes) == 4",
          "146:         has_trailing_zeroes = method_id_bytes.endswith(b\"\\x00\")",
          "147:         if has_trailing_zeroes:",
          "148:             method_id_check = [\"and\", [\"ge\", \"calldatasize\", 4], method_id_check]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "vyper/codegen/module.py||vyper/codegen/module.py": [
          "File: vyper/codegen/module.py -> vyper/codegen/module.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "107:         selector_section.append(func_ir)",
          "109:     if default_function:",
          "111:     else:",
          "112:         fallback_ir = IRnode.from_list(",
          "113:             [\"revert\", 0, 0], annotation=\"Default function\", error_msg=\"fallback function\"",
          "",
          "[Removed Lines]",
          "110:         fallback_ir = generate_ir_for_function(default_function, global_ctx, skip_nonpayable_check)",
          "",
          "[Added Lines]",
          "110:         fallback_ir = generate_ir_for_function(",
          "111:             default_function, global_ctx, skip_nonpayable_check=False",
          "112:         )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "119:     # fallback label is the immediate next instruction,",
          "120:     close_selector_section = [\"goto\", \"fallback\"]",
          "122:     runtime = [",
          "123:         \"seq\",",
          "124:         [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section],",
          "125:         close_selector_section,",
          "126:         [\"label\", \"fallback\", [\"var_list\"], fallback_ir],",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "124:     global_calldatasize_check = [\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]]",
          "128:         global_calldatasize_check,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9ecb97b4b6fcdc566361b3c4501888e3f19d9cac",
      "candidate_info": {
        "commit_hash": "9ecb97b4b6fcdc566361b3c4501888e3f19d9cac",
        "repo": "vyperlang/vyper",
        "commit_url": "https://github.com/vyperlang/vyper/commit/9ecb97b4b6fcdc566361b3c4501888e3f19d9cac",
        "files": [
          "tests/parser/functions/test_default_function.py",
          "vyper/codegen/function_definitions/external_function.py"
        ],
        "message": "fix: calldatasize < 4 reverting instead of going to fallback (#3408)\n\nin the case that a selector matches calldata with less than 4 bytes, it\ncurrently will revert instead of going to the fallback. this can happen\nif the selector has trailing zeroes. this commit fixes the behavior for\nselectors with trailing zeroes, and improves code size and gas for those\nwithout trailing zeroes.",
        "before_after_code_files": [
          "tests/parser/functions/test_default_function.py||tests/parser/functions/test_default_function.py",
          "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py"
          ],
          "candidate": [
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py"
          ]
        }
      },
      "candidate_diff": {
        "tests/parser/functions/test_default_function.py||tests/parser/functions/test_default_function.py": [
          "File: tests/parser/functions/test_default_function.py -> tests/parser/functions/test_default_function.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "100:     assert_compile_failed(lambda: get_contract_with_gas_estimation(code))",
          "104:     code = \"\"\"",
          "105: event Sent:",
          "106:     sig: uint256",
          "",
          "[Removed Lines]",
          "103: def test_zero_method_id(w3, get_logs, get_contract_with_gas_estimation):",
          "",
          "[Added Lines]",
          "103: def test_zero_method_id(w3, get_logs, get_contract, assert_tx_failed):",
          "104:     # test a method with 0x00000000 selector,",
          "105:     # expects at least 36 bytes of calldata.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "116: def __default__():",
          "117:     log Sent(1)",
          "118:     \"\"\"",
          "122:     assert c.blockHashAskewLimitary(0) == 7",
          "",
          "[Removed Lines]",
          "120:     c = get_contract_with_gas_estimation(code)",
          "124:     logs = get_logs(w3.eth.send_transaction({\"to\": c.address, \"value\": 0}), c, \"Sent\")",
          "125:     assert 1 == logs[0].args.sig",
          "127:     logs = get_logs(",
          "128:         # call blockHashAskewLimitary",
          "129:         w3.eth.send_transaction({\"to\": c.address, \"value\": 0, \"data\": \"0x\" + \"00\" * 36}),",
          "130:         c,",
          "131:         \"Sent\",",
          "132:     )",
          "133:     assert 2 == logs[0].args.sig",
          "",
          "[Added Lines]",
          "121:     c = get_contract(code)",
          "125:     def _call_with_bytes(hexstr):",
          "126:         # call our special contract and return the logged value",
          "127:         logs = get_logs(",
          "128:             w3.eth.send_transaction({\"to\": c.address, \"value\": 0, \"data\": hexstr}), c, \"Sent\"",
          "129:         )",
          "130:         return logs[0].args.sig",
          "132:     assert 1 == _call_with_bytes(\"0x\")",
          "134:     # call blockHashAskewLimitary with proper calldata",
          "135:     assert 2 == _call_with_bytes(\"0x\" + \"00\" * 36)",
          "137:     # call blockHashAskewLimitary with extra trailing bytes in calldata",
          "138:     assert 2 == _call_with_bytes(\"0x\" + \"00\" * 37)",
          "140:     for i in range(4):",
          "141:         # less than 4 bytes of calldata doesn't match the 0 selector and goes to default",
          "142:         assert 1 == _call_with_bytes(\"0x\" + \"00\" * i)",
          "144:     for i in range(4, 36):",
          "145:         # match the full 4 selector bytes, but revert due to malformed (short) calldata",
          "146:         assert_tx_failed(lambda: _call_with_bytes(\"0x\" + \"00\" * i))",
          "149: def test_another_zero_method_id(w3, get_logs, get_contract, assert_tx_failed):",
          "150:     # test another zero method id but which only expects 4 bytes of calldata",
          "151:     code = \"\"\"",
          "152: event Sent:",
          "153:     sig: uint256",
          "155: @external",
          "156: @payable",
          "157: # function selector: 0x00000000",
          "158: def wycpnbqcyf() -> uint256:",
          "159:     log Sent(2)",
          "160:     return 7",
          "162: @external",
          "163: def __default__():",
          "164:     log Sent(1)",
          "165:     \"\"\"",
          "166:     c = get_contract(code)",
          "168:     assert c.wycpnbqcyf() == 7",
          "170:     def _call_with_bytes(hexstr):",
          "171:         # call our special contract and return the logged value",
          "172:         logs = get_logs(",
          "173:             w3.eth.send_transaction({\"to\": c.address, \"value\": 0, \"data\": hexstr}), c, \"Sent\"",
          "174:         )",
          "175:         return logs[0].args.sig",
          "177:     assert 1 == _call_with_bytes(\"0x\")",
          "179:     # call wycpnbqcyf",
          "180:     assert 2 == _call_with_bytes(\"0x\" + \"00\" * 4)",
          "182:     # too many bytes ok",
          "183:     assert 2 == _call_with_bytes(\"0x\" + \"00\" * 5)",
          "185:     # \"right\" method id but by accident - not enough bytes.",
          "186:     for i in range(4):",
          "187:         assert 1 == _call_with_bytes(\"0x\" + \"00\" * i)",
          "190: def test_partial_selector_match_trailing_zeroes(w3, get_logs, get_contract):",
          "191:     code = \"\"\"",
          "192: event Sent:",
          "193:     sig: uint256",
          "195: @external",
          "196: @payable",
          "197: # function selector: 0xd88e0b00",
          "198: def fow() -> uint256:",
          "199:     log Sent(2)",
          "200:     return 7",
          "202: @external",
          "203: def __default__():",
          "204:     log Sent(1)",
          "205:     \"\"\"",
          "206:     c = get_contract(code)",
          "208:     # sanity check - we can call c.fow()",
          "209:     assert c.fow() == 7",
          "211:     def _call_with_bytes(hexstr):",
          "212:         # call our special contract and return the logged value",
          "213:         logs = get_logs(",
          "214:             w3.eth.send_transaction({\"to\": c.address, \"value\": 0, \"data\": hexstr}), c, \"Sent\"",
          "215:         )",
          "216:         return logs[0].args.sig",
          "218:     # check we can call default function",
          "219:     assert 1 == _call_with_bytes(\"0x\")",
          "221:     # check fow() selector is 0xd88e0b00",
          "222:     assert 2 == _call_with_bytes(\"0xd88e0b00\")",
          "224:     # check calling d88e0b with no trailing zero goes to fallback instead of reverting",
          "225:     assert 1 == _call_with_bytes(\"0xd88e0b\")",
          "",
          "---------------"
        ],
        "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py": [
          "File: vyper/codegen/function_definitions/external_function.py -> vyper/codegen/function_definitions/external_function.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "88:         # ensure calldata is at least of minimum length",
          "89:         args_abi_t = calldata_args_t.abi_type",
          "90:         calldata_min_size = args_abi_t.min_size() + 4",
          "93:         # TODO optimize make_setter by using",
          "94:         # TupleT(list(arg.typ for arg in calldata_kwargs + default_kwargs))",
          "",
          "[Removed Lines]",
          "91:         ret.append([\"assert\", [\"ge\", \"calldatasize\", calldata_min_size]])",
          "",
          "[Added Lines]",
          "92:         # note we don't need the check if calldata_min_size == 4,",
          "93:         # because the selector checks later in this routine ensure",
          "94:         # that calldatasize >= 4.",
          "95:         if calldata_min_size > 4:",
          "96:             ret.append([\"assert\", [\"ge\", \"calldatasize\", calldata_min_size]])",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:         method_id_check = [\"eq\", \"_calldata_method_id\", method_id]",
          "142:         ret = [\"if\", method_id_check, ret]",
          "143:         return ret",
          "",
          "[Removed Lines]",
          "127:         # if there is a function whose selector is 0, it won't be distinguished",
          "128:         # from the case where nil calldata is supplied, b/c calldataload loads",
          "129:         # 0s past the end of physical calldata (cf. yellow paper).",
          "130:         # since supplying 0 calldata is expected to trigger the fallback fn,",
          "131:         # we check that calldatasize > 0, which distinguishes the 0 selector",
          "132:         # from the fallback function \"selector\"",
          "133:         # (equiv. to \"all selectors not in the selector table\").",
          "135:         # note: cases where not enough calldata is supplied (besides",
          "136:         # calldatasize==0) are not addressed here b/c a calldatasize",
          "137:         # well-formedness check is already present in the function body",
          "138:         # as part of abi validation",
          "139:         if method_id.value == 0:",
          "140:             method_id_check = [\"and\", [\"gt\", \"calldatasize\", 0], method_id_check]",
          "",
          "[Added Lines]",
          "132:         # if there is a function whose selector is 0 or has trailing 0s, it",
          "133:         # might not be distinguished from the case where insufficient calldata",
          "134:         # is supplied, b/c calldataload loads 0s past the end of physical",
          "135:         # calldata (cf. yellow paper).",
          "136:         # since the expected behavior of supplying insufficient calldata",
          "137:         # is to trigger the fallback fn, we add to the selector check that",
          "138:         # calldatasize >= 4, which distinguishes any selector with trailing",
          "139:         # 0 bytes from the fallback function \"selector\" (equiv. to \"all",
          "140:         # selectors not in the selector table\").",
          "141:         #",
          "142:         # note that the inclusion of this check means that, we are always",
          "143:         # guaranteed that the calldata is at least 4 bytes - either we have",
          "144:         # the explicit `calldatasize >= 4` condition in the selector check,",
          "145:         # or there are no trailing zeroes in the selector, (so the selector",
          "146:         # is impossible to match without calldatasize being at least 4).",
          "147:         method_id_bytes = util.method_id(abi_sig)",
          "148:         assert len(method_id_bytes) == 4",
          "149:         has_trailing_zeroes = method_id_bytes.endswith(b\"\\x00\")",
          "150:         if has_trailing_zeroes:",
          "151:             method_id_check = [\"and\", [\"ge\", \"calldatasize\", 4], method_id_check]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "408929fa31ae01dde4f7566bb7babbc7da5b6620",
      "candidate_info": {
        "commit_hash": "408929fa31ae01dde4f7566bb7babbc7da5b6620",
        "repo": "vyperlang/vyper",
        "commit_url": "https://github.com/vyperlang/vyper/commit/408929fa31ae01dde4f7566bb7babbc7da5b6620",
        "files": [
          ".github/workflows/test.yml",
          "docs/compiling-a-contract.rst",
          "docs/structure-of-a-contract.rst",
          "tests/base_conftest.py",
          "tests/cli/vyper_json/test_parse_args_vyperjson.py",
          "tests/compiler/__init__.py",
          "tests/compiler/test_default_settings.py",
          "tests/conftest.py",
          "tests/parser/functions/test_slice.py",
          "tests/parser/test_selector_table.py",
          "tox.ini",
          "vyper/ast/grammar.lark",
          "vyper/cli/vyper_compile.py",
          "vyper/cli/vyper_ir.py",
          "vyper/codegen/core.py",
          "vyper/codegen/function_definitions/__init__.py",
          "vyper/codegen/function_definitions/common.py",
          "vyper/codegen/function_definitions/external_function.py",
          "vyper/codegen/ir_node.py",
          "vyper/codegen/jumptable_utils.py",
          "vyper/codegen/module.py",
          "vyper/compiler/output.py",
          "vyper/compiler/settings.py",
          "vyper/ir/compile_ir.py"
        ],
        "message": "feat: O(1) selector tables (#3496)\n\nthis commit replaces the existing linear entry point search with an O(1)\nimplementation. there are two methods depending on whether optimizing\nfor code size or gas, hash table with probing and perfect hashing using\na two-level technique.\n\nthe first method divides the selectors into buckets, uses\n`method_id % n_buckets` as a \"guess\" to where to enter the selector\ntable and then jumps there and performs the familiar linear search for\nthe selector (\"probing\"). to avoid too large buckets, the jumptable\ngenerator searches a range from ~`n_buckets * 0.85` to\n`n_buckets * 1.15` to minimize worst-case probe depth; the average worst\ncase for 80-100 methods is 3 items per bucket and the worst worst case\nis 4 items per bucket (presumably if you get really unlucky), see\n`_bench_sparse()` in `vyper/codegen/jumptable_utils.py`. the average\nbucket size is 1.6 methods.\n\nthe second method uses a perfect hashing technique. finding a single\nmagic which produces a perfect hash is infeasible for large `N`\n(exponential, and in practice seems to run off a cliff around 10\n methods). to \"get around\" this, the methods are divided into buckets of\nroughly size 10, and a magic is computed per bucket. several `n_buckets`\nare tried, trying to minimize `n_buckets`. the code size overhead of\neach bucket is roughly 5 bytes per bucket, which works out to ~20% per\nmethod, see `_bench_dense()` in `vyper/codegen/jumptable_utils.py`.\nthen, the function selector is looked up in two steps - it loads the\nmagic for the bucket given by `method_id % n_buckets`, and then uses the\nmagic to compute the location of the function selector (and associated\nmetadata) in the data section. from there it loads the function\nmetadata, performs the calldatasize, callvalue and method id checks and\njumps into the function.\n\nthere is a gas vs code size tradeoff between the two methods - roughly\nspeaking, the sparse method requires ~69 gas in the best case (~109 gas\nin the \"average\" case) and 12-22 bytes of code per method, while the\ndense method requires ~212 gas across the board, and ~8 bytes of code\nper method.\n\nto accomplish this implementation-wise, the jumptable info is generated\nin a new helper module, `vyper/codegen/jumptable_utils.py`. some\nrefactoring had to be additionally done to pull the calldatasize,\ncallvalue and method id checks from external function generation out\ninto a new selector section construction step in\n`vyper/codegen/module.py`.\n\nadditionally, a new IR \"data\" directive was added, and an associated\nassembly directive. the data segments in assembly are moved to the end\nof the bytecode to ensure that data bytes which happen to look like\n`PUSH` instructions do not mangle valid bytecode which comes after the\ndata section.",
        "before_after_code_files": [
          "tests/base_conftest.py||tests/base_conftest.py",
          "tests/cli/vyper_json/test_parse_args_vyperjson.py||tests/cli/vyper_json/test_parse_args_vyperjson.py",
          "tests/compiler/__init__.py||tests/compiler/__init__.py",
          "tests/compiler/test_default_settings.py||tests/compiler/test_default_settings.py",
          "tests/conftest.py||tests/conftest.py",
          "tests/parser/functions/test_slice.py||tests/parser/functions/test_slice.py",
          "tests/parser/test_selector_table.py||tests/parser/test_selector_table.py",
          "vyper/ast/grammar.lark||vyper/ast/grammar.lark",
          "vyper/cli/vyper_compile.py||vyper/cli/vyper_compile.py",
          "vyper/cli/vyper_ir.py||vyper/cli/vyper_ir.py",
          "vyper/codegen/core.py||vyper/codegen/core.py",
          "vyper/codegen/function_definitions/__init__.py||vyper/codegen/function_definitions/__init__.py",
          "vyper/codegen/function_definitions/common.py||vyper/codegen/function_definitions/common.py",
          "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
          "vyper/codegen/ir_node.py||vyper/codegen/ir_node.py",
          "vyper/codegen/jumptable_utils.py||vyper/codegen/jumptable_utils.py",
          "vyper/codegen/module.py||vyper/codegen/module.py",
          "vyper/compiler/output.py||vyper/compiler/output.py",
          "vyper/compiler/settings.py||vyper/compiler/settings.py",
          "vyper/ir/compile_ir.py||vyper/ir/compile_ir.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ],
          "candidate": [
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ]
        }
      },
      "candidate_diff": {
        "tests/base_conftest.py||tests/base_conftest.py": [
          "File: tests/base_conftest.py -> tests/base_conftest.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "112:     return w3",
          "116:     settings = Settings()",
          "117:     settings.evm_version = kwargs.pop(\"evm_version\", None)",
          "119:     out = compiler.compile_code(",
          "120:         source_code,",
          "121:         # test that metadata gets generated",
          "",
          "[Removed Lines]",
          "115: def _get_contract(w3, source_code, optimize, *args, **kwargs):",
          "118:     settings.optimize = optimize",
          "",
          "[Added Lines]",
          "115: def _get_contract(w3, source_code, optimize, *args, override_opt_level=None, **kwargs):",
          "118:     settings.optimize = override_opt_level or optimize",
          "",
          "---------------"
        ],
        "tests/cli/vyper_json/test_parse_args_vyperjson.py||tests/cli/vyper_json/test_parse_args_vyperjson.py": [
          "File: tests/cli/vyper_json/test_parse_args_vyperjson.py -> tests/cli/vyper_json/test_parse_args_vyperjson.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:     _parse_args([path.absolute().as_posix()])",
          "58:     out, _ = capfd.readouterr()",
          "59:     output_json = json.loads(out)",
          "61:     assert \"contracts/foo.vy\" in output_json[\"sources\"]",
          "62:     assert \"contracts/bar.vy\" in output_json[\"sources\"]",
          "",
          "[Removed Lines]",
          "60:     assert _no_errors(output_json)",
          "",
          "[Added Lines]",
          "60:     assert _no_errors(output_json), (INPUT_JSON, output_json)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "71:     assert output_path.exists()",
          "72:     with output_path.open() as fp:",
          "73:         output_json = json.load(fp)",
          "75:     assert \"contracts/foo.vy\" in output_json[\"sources\"]",
          "76:     assert \"contracts/bar.vy\" in output_json[\"sources\"]",
          "",
          "[Removed Lines]",
          "74:     assert _no_errors(output_json)",
          "",
          "[Added Lines]",
          "74:     assert _no_errors(output_json), (INPUT_JSON, output_json)",
          "",
          "---------------"
        ],
        "tests/compiler/__init__.py||tests/compiler/__init__.py": [
          "File: tests/compiler/__init__.py -> tests/compiler/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # prevent module name collision between tests/compiler/test_pre_parser.py",
          "2: # and tests/ast/test_pre_parser.py",
          "",
          "---------------"
        ],
        "tests/compiler/test_default_settings.py||tests/compiler/test_default_settings.py": [
          "File: tests/compiler/test_default_settings.py -> tests/compiler/test_default_settings.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: from vyper.codegen import core",
          "2: from vyper.compiler.phases import CompilerData",
          "3: from vyper.compiler.settings import OptimizationLevel, _is_debug_mode",
          "6: def test_default_settings():",
          "7:     source_code = \"\"",
          "8:     compiler_data = CompilerData(source_code)",
          "9:     _ = compiler_data.vyper_module  # force settings to be computed",
          "11:     assert compiler_data.settings.optimize == OptimizationLevel.GAS",
          "14: def test_default_opt_level():",
          "15:     assert OptimizationLevel.default() == OptimizationLevel.GAS",
          "18: def test_codegen_opt_level():",
          "19:     assert core._opt_level == OptimizationLevel.GAS",
          "20:     assert core._opt_gas() is True",
          "21:     assert core._opt_none() is False",
          "22:     assert core._opt_codesize() is False",
          "25: def test_debug_mode(pytestconfig):",
          "26:     debug_mode = pytestconfig.getoption(\"enable_compiler_debug_mode\")",
          "27:     assert _is_debug_mode() == debug_mode",
          "",
          "---------------"
        ],
        "tests/conftest.py||tests/conftest.py": [
          "File: tests/conftest.py -> tests/conftest.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: from vyper import compiler",
          "12: from vyper.codegen.ir_node import IRnode",
          "14: from vyper.ir import compile_ir, optimizer",
          "16: from .base_conftest import VyperContract, _get_contract, zero_gas_price_strategy",
          "",
          "[Removed Lines]",
          "13: from vyper.compiler.settings import OptimizationLevel",
          "",
          "[Added Lines]",
          "13: from vyper.compiler.settings import OptimizationLevel, _set_debug_mode",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43:         default=\"gas\",",
          "44:         help=\"change optimization mode\",",
          "45:     )",
          "48: @pytest.fixture(scope=\"module\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:     parser.addoption(\"--enable-compiler-debug-mode\", action=\"store_true\")",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "51:     return OptimizationLevel.from_string(flag)",
          "54: @pytest.fixture",
          "55: def keccak():",
          "56:     return Web3.keccak",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "55: @pytest.fixture(scope=\"session\", autouse=True)",
          "56: def debug(pytestconfig):",
          "57:     debug = pytestconfig.getoption(\"enable_compiler_debug_mode\")",
          "58:     assert isinstance(debug, bool)",
          "59:     _set_debug_mode(debug)",
          "",
          "---------------"
        ],
        "tests/parser/functions/test_slice.py||tests/parser/functions/test_slice.py": [
          "File: tests/parser/functions/test_slice.py -> tests/parser/functions/test_slice.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: import pytest",
          "3: from hypothesis import given, settings",
          "5: from vyper.exceptions import ArgumentException, TypeMismatch",
          "7: _fun_bytes32_bounds = [(0, 32), (3, 29), (27, 5), (0, 5), (5, 3), (30, 2)]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: from vyper.compiler.settings import OptimizationLevel",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34: @pytest.mark.parametrize(\"literal_start\", (True, False))",
          "35: @pytest.mark.parametrize(\"literal_length\", (True, False))",
          "36: @given(start=_draw_1024, length=_draw_1024, length_bound=_draw_1024_1, bytesdata=_bytes_1024)",
          "38: def test_slice_immutable(",
          "39:     get_contract,",
          "40:     assert_compile_failed,",
          "41:     assert_tx_failed,",
          "42:     bytesdata,",
          "43:     start,",
          "44:     literal_start,",
          "",
          "[Removed Lines]",
          "37: @settings(max_examples=25, deadline=None)",
          "",
          "[Added Lines]",
          "37: @pytest.mark.parametrize(\"opt_level\", list(OptimizationLevel))",
          "39: @settings(max_examples=100, deadline=None)",
          "40: @pytest.mark.fuzzing",
          "45:     opt_level,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "64:     \"\"\"",
          "66:     def _get_contract():",
          "69:     if (",
          "70:         (start + length > length_bound and literal_start and literal_length)",
          "",
          "[Removed Lines]",
          "67:         return get_contract(code, bytesdata, start, length)",
          "",
          "[Added Lines]",
          "71:         return get_contract(code, bytesdata, start, length, override_opt_level=opt_level)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "84: @pytest.mark.parametrize(\"location\", (\"storage\", \"calldata\", \"memory\", \"literal\", \"code\"))",
          "85: @pytest.mark.parametrize(\"literal_start\", (True, False))",
          "86: @pytest.mark.parametrize(\"literal_length\", (True, False))",
          "87: @given(start=_draw_1024, length=_draw_1024, length_bound=_draw_1024_1, bytesdata=_bytes_1024)",
          "89: def test_slice_bytes(",
          "90:     get_contract,",
          "91:     assert_compile_failed,",
          "92:     assert_tx_failed,",
          "93:     location,",
          "94:     bytesdata,",
          "95:     start,",
          "",
          "[Removed Lines]",
          "88: @settings(max_examples=25, deadline=None)",
          "",
          "[Added Lines]",
          "91: @pytest.mark.parametrize(\"opt_level\", list(OptimizationLevel))",
          "93: @settings(max_examples=100, deadline=None)",
          "94: @pytest.mark.fuzzing",
          "99:     opt_level,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "133:     \"\"\"",
          "135:     def _get_contract():",
          "138:     data_length = len(bytesdata) if location == \"literal\" else length_bound",
          "139:     if (",
          "",
          "[Removed Lines]",
          "136:         return get_contract(code, bytesdata)",
          "",
          "[Added Lines]",
          "143:         return get_contract(code, bytesdata, override_opt_level=opt_level)",
          "",
          "---------------"
        ],
        "tests/parser/test_selector_table.py||tests/parser/test_selector_table.py": [
          "File: tests/parser/test_selector_table.py -> tests/parser/test_selector_table.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: import hypothesis.strategies as st",
          "2: import pytest",
          "3: from hypothesis import given, settings",
          "5: import vyper.utils as utils",
          "6: from vyper.codegen.jumptable_utils import (",
          "7:     generate_dense_jumptable_info,",
          "8:     generate_sparse_jumptable_buckets,",
          "9: )",
          "10: from vyper.compiler.settings import OptimizationLevel",
          "13: @given(",
          "14:     n_methods=st.integers(min_value=1, max_value=100),",
          "15:     seed=st.integers(min_value=0, max_value=2**64 - 1),",
          "16: )",
          "17: @pytest.mark.fuzzing",
          "18: @settings(max_examples=10, deadline=None)",
          "19: def test_sparse_jumptable_probe_depth(n_methods, seed):",
          "20:     sigs = [f\"foo{i + seed}()\" for i in range(n_methods)]",
          "21:     _, buckets = generate_sparse_jumptable_buckets(sigs)",
          "22:     bucket_sizes = [len(bucket) for bucket in buckets.values()]",
          "24:     # generally bucket sizes should be bounded at around 4, but",
          "25:     # just test that they don't get really out of hand",
          "26:     assert max(bucket_sizes) <= 8",
          "28:     # generally mean bucket size should be around 1.6, here just",
          "29:     # test they don't get really out of hand",
          "30:     assert sum(bucket_sizes) / len(bucket_sizes) <= 4",
          "33: @given(",
          "34:     n_methods=st.integers(min_value=4, max_value=100),",
          "35:     seed=st.integers(min_value=0, max_value=2**64 - 1),",
          "36: )",
          "37: @pytest.mark.fuzzing",
          "38: @settings(max_examples=10, deadline=None)",
          "39: def test_dense_jumptable_bucket_size(n_methods, seed):",
          "40:     sigs = [f\"foo{i + seed}()\" for i in range(n_methods)]",
          "41:     n = len(sigs)",
          "42:     buckets = generate_dense_jumptable_info(sigs)",
          "43:     n_buckets = len(buckets)",
          "45:     # generally should be around 14 buckets per 100 methods, here",
          "46:     # we test they don't get really out of hand",
          "47:     assert n_buckets / n < 0.4 or n < 10",
          "50: @pytest.mark.parametrize(\"opt_level\", list(OptimizationLevel))",
          "51: # dense selector table packing boundaries at 256 and 65336",
          "52: @pytest.mark.parametrize(\"max_calldata_bytes\", [255, 256, 65336])",
          "53: @settings(max_examples=5, deadline=None)",
          "54: @given(",
          "55:     seed=st.integers(min_value=0, max_value=2**64 - 1),",
          "56:     max_default_args=st.integers(min_value=0, max_value=4),",
          "57:     default_fn_mutability=st.sampled_from([\"\", \"@pure\", \"@view\", \"@nonpayable\", \"@payable\"]),",
          "58: )",
          "59: @pytest.mark.fuzzing",
          "60: def test_selector_table_fuzz(",
          "61:     max_calldata_bytes,",
          "62:     seed,",
          "63:     max_default_args,",
          "64:     opt_level,",
          "65:     default_fn_mutability,",
          "66:     w3,",
          "67:     get_contract,",
          "68:     assert_tx_failed,",
          "69:     get_logs,",
          "70: ):",
          "71:     def abi_sig(calldata_words, i, n_default_args):",
          "72:         args = [] if not calldata_words else [f\"uint256[{calldata_words}]\"]",
          "73:         args.extend([\"uint256\"] * n_default_args)",
          "74:         argstr = \",\".join(args)",
          "75:         return f\"foo{seed + i}({argstr})\"",
          "77:     def generate_func_def(mutability, calldata_words, i, n_default_args):",
          "78:         arglist = [] if not calldata_words else [f\"x: uint256[{calldata_words}]\"]",
          "79:         for j in range(n_default_args):",
          "80:             arglist.append(f\"x{j}: uint256 = 0\")",
          "81:         args = \", \".join(arglist)",
          "82:         _log_return = f\"log _Return({i})\" if mutability == \"@payable\" else \"\"",
          "84:         return f\"\"\"",
          "85: @external",
          "86: {mutability}",
          "87: def foo{seed + i}({args}) -> uint256:",
          "88:     {_log_return}",
          "89:     return {i}",
          "90:     \"\"\"",
          "92:     @given(",
          "93:         methods=st.lists(",
          "94:             st.tuples(",
          "95:                 st.sampled_from([\"@pure\", \"@view\", \"@nonpayable\", \"@payable\"]),",
          "96:                 st.integers(min_value=0, max_value=max_calldata_bytes // 32),",
          "97:                 # n bytes to strip from calldata",
          "98:                 st.integers(min_value=1, max_value=4),",
          "99:                 # n default args",
          "100:                 st.integers(min_value=0, max_value=max_default_args),",
          "101:             ),",
          "102:             min_size=1,",
          "103:             max_size=100,",
          "104:         )",
          "105:     )",
          "106:     @settings(max_examples=25)",
          "107:     def _test(methods):",
          "108:         func_defs = \"\\n\".join(",
          "109:             generate_func_def(m, s, i, d) for i, (m, s, _, d) in enumerate(methods)",
          "110:         )",
          "112:         if default_fn_mutability == \"\":",
          "113:             default_fn_code = \"\"",
          "114:         elif default_fn_mutability in (\"@nonpayable\", \"@payable\"):",
          "115:             default_fn_code = f\"\"\"",
          "116: @external",
          "117: {default_fn_mutability}",
          "118: def __default__():",
          "119:     log CalledDefault()",
          "120:             \"\"\"",
          "121:         else:",
          "122:             # can't log from pure/view functions, just test that it returns",
          "123:             default_fn_code = \"\"\"",
          "124: @external",
          "125: def __default__():",
          "126:     pass",
          "127:             \"\"\"",
          "129:         code = f\"\"\"",
          "130: event CalledDefault:",
          "131:     pass",
          "133: event _Return:",
          "134:     val: uint256",
          "136: {func_defs}",
          "138: {default_fn_code}",
          "139:         \"\"\"",
          "141:         c = get_contract(code, override_opt_level=opt_level)",
          "143:         for i, (mutability, n_calldata_words, n_strip_bytes, n_default_args) in enumerate(methods):",
          "144:             funcname = f\"foo{seed + i}\"",
          "145:             func = getattr(c, funcname)",
          "147:             for j in range(n_default_args + 1):",
          "148:                 args = [[1] * n_calldata_words] if n_calldata_words else []",
          "149:                 args.extend([1] * j)",
          "151:                 # check the function returns as expected",
          "152:                 assert func(*args) == i",
          "154:                 method_id = utils.method_id(abi_sig(n_calldata_words, i, j))",
          "156:                 argsdata = b\"\\x00\" * (n_calldata_words * 32 + j * 32)",
          "158:                 # do payable check",
          "159:                 if mutability == \"@payable\":",
          "160:                     tx = func(*args, transact={\"value\": 1})",
          "161:                     (event,) = get_logs(tx, c, \"_Return\")",
          "162:                     assert event.args.val == i",
          "163:                 else:",
          "164:                     hexstr = (method_id + argsdata).hex()",
          "165:                     txdata = {\"to\": c.address, \"data\": hexstr, \"value\": 1}",
          "166:                     assert_tx_failed(lambda: w3.eth.send_transaction(txdata))",
          "168:                 # now do calldatasize check",
          "169:                 # strip some bytes",
          "170:                 calldata = (method_id + argsdata)[:-n_strip_bytes]",
          "171:                 hexstr = calldata.hex()",
          "172:                 tx_params = {\"to\": c.address, \"data\": hexstr}",
          "173:                 if n_calldata_words == 0 and j == 0:",
          "174:                     # no args, hit default function",
          "175:                     if default_fn_mutability == \"\":",
          "176:                         assert_tx_failed(lambda: w3.eth.send_transaction(tx_params))",
          "177:                     elif default_fn_mutability == \"@payable\":",
          "178:                         # we should be able to send eth to it",
          "179:                         tx_params[\"value\"] = 1",
          "180:                         tx = w3.eth.send_transaction(tx_params)",
          "181:                         logs = get_logs(tx, c, \"CalledDefault\")",
          "182:                         assert len(logs) == 1",
          "183:                     else:",
          "184:                         tx = w3.eth.send_transaction(tx_params)",
          "186:                         # note: can't emit logs from view/pure functions,",
          "187:                         # so the logging is not tested.",
          "188:                         if default_fn_mutability == \"@nonpayable\":",
          "189:                             logs = get_logs(tx, c, \"CalledDefault\")",
          "190:                             assert len(logs) == 1",
          "192:                         # check default function reverts",
          "193:                         tx_params[\"value\"] = 1",
          "194:                         assert_tx_failed(lambda: w3.eth.send_transaction(tx_params))",
          "195:                 else:",
          "196:                     assert_tx_failed(lambda: w3.eth.send_transaction(tx_params))",
          "198:     _test()",
          "",
          "---------------"
        ],
        "vyper/ast/grammar.lark||vyper/ast/grammar.lark": [
          "File: vyper/ast/grammar.lark -> vyper/ast/grammar.lark",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: _EVENT_DECL: \"event\"",
          "73: event_member: NAME \":\" type",
          "74: indexed_event_arg: NAME \":\" \"indexed\" \"(\" type \")\"",
          "77: event_def: _EVENT_DECL NAME \":\" ( event_body | _PASS )",
          "",
          "[Removed Lines]",
          "75: event_body: _NEWLINE _INDENT ((event_member | indexed_event_arg) _NEWLINE)+ _DEDENT",
          "",
          "[Added Lines]",
          "76: event_body: _NEWLINE _INDENT (((event_member | indexed_event_arg ) _NEWLINE)+ | _PASS _NEWLINE) _DEDENT",
          "",
          "---------------"
        ],
        "vyper/cli/vyper_compile.py||vyper/cli/vyper_compile.py": [
          "File: vyper/cli/vyper_compile.py -> vyper/cli/vyper_compile.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: import vyper.codegen.ir_node as ir_node",
          "12: from vyper.cli import vyper_json",
          "13: from vyper.cli.utils import extract_file_interface_imports, get_interface_file_path",
          "15: from vyper.evm.opcodes import DEFAULT_EVM_VERSION, EVM_VERSIONS",
          "16: from vyper.typing import ContractCodes, ContractPath, OutputFormats",
          "",
          "[Removed Lines]",
          "14: from vyper.compiler.settings import VYPER_TRACEBACK_LIMIT, OptimizationLevel, Settings",
          "",
          "[Added Lines]",
          "14: from vyper.compiler.settings import (",
          "15:     VYPER_TRACEBACK_LIMIT,",
          "16:     OptimizationLevel,",
          "17:     Settings,",
          "18:     _set_debug_mode,",
          "19: )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "105:         dest=\"evm_version\",",
          "106:     )",
          "107:     parser.add_argument(\"--no-optimize\", help=\"Do not optimize\", action=\"store_true\")",
          "109:     parser.add_argument(",
          "110:         \"--no-bytecode-metadata\", help=\"Do not add metadata to bytecode\", action=\"store_true\"",
          "111:     )",
          "",
          "[Removed Lines]",
          "108:     parser.add_argument(\"--optimize\", help=\"Optimization flag\", choices=[\"gas\", \"codesize\", \"none\"])",
          "",
          "[Added Lines]",
          "113:     parser.add_argument(",
          "114:         \"--optimize\",",
          "115:         help=\"Optimization flag (defaults to 'gas')\",",
          "116:         choices=[\"gas\", \"codesize\", \"none\"],",
          "117:     )",
          "118:     parser.add_argument(\"--debug\", help=\"Compile in debug mode\", action=\"store_true\")",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "152:     output_formats = tuple(uniq(args.format.split(\",\")))",
          "154:     if args.no_optimize and args.optimize:",
          "155:         raise ValueError(\"Cannot use `--no-optimize` and `--optimize` at the same time!\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "164:     if args.debug:",
          "165:         _set_debug_mode(True)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "165:         settings.evm_version = args.evm_version",
          "167:     if args.verbose:",
          "170:     compiled = compile_files(",
          "171:         args.input_files,",
          "",
          "[Removed Lines]",
          "168:         print(f\"using `{settings}`\", file=sys.stderr)",
          "",
          "[Added Lines]",
          "181:         print(f\"cli specified: `{settings}`\", file=sys.stderr)",
          "",
          "---------------"
        ],
        "vyper/cli/vyper_ir.py||vyper/cli/vyper_ir.py": [
          "File: vyper/cli/vyper_ir.py -> vyper/cli/vyper_ir.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:         compiler_data[\"asm\"] = asm",
          "57:     if \"bytecode\" in output_formats:",
          "59:         compiler_data[\"bytecode\"] = \"0x\" + bytecode.hex()",
          "61:     return compiler_data",
          "",
          "[Removed Lines]",
          "58:         (bytecode, _srcmap) = compile_ir.assembly_to_evm(asm)",
          "",
          "[Added Lines]",
          "58:         bytecode, _ = compile_ir.assembly_to_evm(asm)",
          "",
          "---------------"
        ],
        "vyper/codegen/core.py||vyper/codegen/core.py": [
          "File: vyper/codegen/core.py -> vyper/codegen/core.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1033:     return None",
          "1037: def is_return_from_function(node):",
          "1038:     if isinstance(node, vy_ast.Expr) and node.get(\"value.func.id\") in (",
          "1039:         \"raw_revert\",",
          "",
          "[Removed Lines]",
          "1036: # TODO move return checks to vyper/semantics/validation",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1045:     return False",
          "1048: def check_single_exit(fn_node):",
          "1049:     _check_return_body(fn_node, fn_node.body)",
          "1050:     for node in fn_node.get_descendants(vy_ast.If):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1047: # TODO this is almost certainly duplicated with check_terminus_node",
          "1048: # in vyper/semantics/analysis/local.py",
          "",
          "---------------"
        ],
        "vyper/codegen/function_definitions/__init__.py||vyper/codegen/function_definitions/__init__.py": [
          "File: vyper/codegen/function_definitions/__init__.py -> vyper/codegen/function_definitions/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: from .common import generate_ir_for_function  # noqa",
          "",
          "[Added Lines]",
          "1: from .common import FuncIR, generate_ir_for_function  # noqa",
          "",
          "---------------"
        ],
        "vyper/codegen/function_definitions/common.py||vyper/codegen/function_definitions/common.py": [
          "File: vyper/codegen/function_definitions/common.py -> vyper/codegen/function_definitions/common.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: import vyper.ast as vy_ast",
          "6: from vyper.codegen.context import Constancy, Context",
          "8: from vyper.codegen.function_definitions.external_function import generate_ir_for_external_function",
          "9: from vyper.codegen.function_definitions.internal_function import generate_ir_for_internal_function",
          "10: from vyper.codegen.global_context import GlobalContext",
          "",
          "[Removed Lines]",
          "7: from vyper.codegen.core import check_single_exit, getpos",
          "",
          "[Added Lines]",
          "7: from vyper.codegen.core import check_single_exit",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63:         return self.ir_identifier + suffix",
          "66: def generate_ir_for_function(",
          "72:     \"\"\"",
          "73:     Parse a function and produce IR code for the function, includes:",
          "74:         - Signature method if statement",
          "",
          "[Removed Lines]",
          "67:     code: vy_ast.FunctionDef,",
          "68:     global_ctx: GlobalContext,",
          "69:     skip_nonpayable_check: bool,",
          "70:     is_ctor_context: bool = False,",
          "71: ) -> IRnode:",
          "",
          "[Added Lines]",
          "66: class FuncIR:",
          "67:     pass",
          "70: @dataclass",
          "71: class EntryPointInfo:",
          "72:     func_t: ContractFunctionT",
          "73:     min_calldatasize: int  # the min calldata required for this entry point",
          "74:     ir_node: IRnode  # the ir for this entry point",
          "77: @dataclass",
          "78: class ExternalFuncIR(FuncIR):",
          "79:     entry_points: dict[str, EntryPointInfo]  # map from abi sigs to entry points",
          "80:     common_ir: IRnode  # the \"common\" code for the function",
          "83: @dataclass",
          "84: class InternalFuncIR(FuncIR):",
          "85:     func_ir: IRnode  # the code for the function",
          "88: # TODO: should split this into external and internal ir generation?",
          "90:     code: vy_ast.FunctionDef, global_ctx: GlobalContext, is_ctor_context: bool = False",
          "91: ) -> FuncIR:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "82:     func_t._ir_info = _FuncIRInfo(func_t)",
          "84:     # Validate return statements.",
          "85:     check_single_exit(code)",
          "87:     callees = func_t.called_functions",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "105:     # XXX: This should really be in semantics pass.",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "106:     )",
          "108:     if func_t.is_internal:",
          "111:     else:",
          "118:     frame_size = context.memory_allocator.size_of_mem - MemoryPositions.RESERVED_MEMORY",
          "120:     frame_info = FrameInfo(allocate_start, frame_size, context.vars)",
          "122:     if func_t._ir_info.frame_info is None:",
          "123:         func_t._ir_info.set_frame_info(frame_info)",
          "124:     else:",
          "",
          "[Removed Lines]",
          "109:         assert skip_nonpayable_check is False",
          "110:         o = generate_ir_for_internal_function(code, func_t, context)",
          "112:         if func_t.is_payable:",
          "113:             assert skip_nonpayable_check is False  # nonsense",
          "114:         o = generate_ir_for_external_function(code, func_t, context, skip_nonpayable_check)",
          "116:     o.source_pos = getpos(code)",
          "",
          "[Added Lines]",
          "130:         ret: FuncIR = InternalFuncIR(generate_ir_for_internal_function(code, func_t, context))",
          "131:         func_t._ir_info.gas_estimate = ret.func_ir.gas  # type: ignore",
          "133:         kwarg_handlers, common = generate_ir_for_external_function(code, func_t, context)",
          "134:         entry_points = {",
          "135:             k: EntryPointInfo(func_t, mincalldatasize, ir_node)",
          "136:             for k, (mincalldatasize, ir_node) in kwarg_handlers.items()",
          "137:         }",
          "138:         ret = ExternalFuncIR(entry_points, common)",
          "139:         # note: this ignores the cost of traversing selector table",
          "140:         func_t._ir_info.gas_estimate = ret.common_ir.gas",
          "146:     # XXX: when can this happen?",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "128:         # adjust gas estimate to include cost of mem expansion",
          "129:         # frame_size of external function includes all private functions called",
          "130:         # (note: internal functions do not need to adjust gas estimate since",
          "",
          "[Removed Lines]",
          "131:         # it is already accounted for by the caller.)",
          "132:         o.add_gas_estimate += calc_mem_gas(func_t._ir_info.frame_info.mem_used)  # type: ignore",
          "134:     func_t._ir_info.gas_estimate = o.gas",
          "136:     return o",
          "",
          "[Added Lines]",
          "156:         mem_expansion_cost = calc_mem_gas(func_t._ir_info.frame_info.mem_used)  # type: ignore",
          "157:         ret.common_ir.add_gas_estimate += mem_expansion_cost  # type: ignore",
          "159:     return ret",
          "",
          "---------------"
        ],
        "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py": [
          "File: vyper/codegen/function_definitions/external_function.py -> vyper/codegen/function_definitions/external_function.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: from vyper.codegen.abi_encoder import abi_encoding_matches_vyper",
          "5: from vyper.codegen.context import Context, VariableRecord",
          "6: from vyper.codegen.core import get_element_ptr, getpos, make_setter, needs_clamp",
          "",
          "[Removed Lines]",
          "1: from typing import Any, List",
          "3: import vyper.utils as util",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "16: # register function args with the local calling context.",
          "17: # also allocate the ones that live in memory (i.e. kwargs)",
          "19:     ret = []",
          "20:     # the type of the calldata",
          "21:     base_args_t = TupleT(tuple(arg.typ for arg in func_t.positional_args))",
          "",
          "[Removed Lines]",
          "18: def _register_function_args(func_t: ContractFunctionT, context: Context) -> List[IRnode]:",
          "",
          "[Added Lines]",
          "15: def _register_function_args(func_t: ContractFunctionT, context: Context) -> list[IRnode]:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "52:     return ret",
          "62:     # generate kwarg handlers.",
          "63:     # since they might come in thru calldata or be default,",
          "64:     # allocate them in memory and then fill it in based on calldata or default,",
          "",
          "[Removed Lines]",
          "55: def _annotated_method_id(abi_sig):",
          "56:     method_id = util.method_id_int(abi_sig)",
          "57:     annotation = f\"{hex(method_id)}: {abi_sig}\"",
          "58:     return IRnode(method_id, annotation=annotation)",
          "61: def _generate_kwarg_handlers(func_t: ContractFunctionT, context: Context) -> List[Any]:",
          "",
          "[Added Lines]",
          "52: def _generate_kwarg_handlers(",
          "53:     func_t: ContractFunctionT, context: Context",
          "54: ) -> dict[str, tuple[int, IRnode]]:",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "75:         calldata_args_t = TupleT(list(arg.typ for arg in calldata_args))",
          "77:         abi_sig = func_t.abi_signature_for_kwargs(calldata_kwargs)",
          "80:         calldata_kwargs_ofst = IRnode(",
          "81:             4, location=CALLDATA, typ=calldata_args_t, encoding=Encoding.ABI",
          "",
          "[Removed Lines]",
          "78:         method_id = _annotated_method_id(abi_sig)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "88:         args_abi_t = calldata_args_t.abi_type",
          "89:         calldata_min_size = args_abi_t.min_size() + 4",
          "96:         # TODO optimize make_setter by using",
          "97:         # TupleT(list(arg.typ for arg in calldata_kwargs + default_kwargs))",
          "98:         # (must ensure memory area is contiguous)",
          "",
          "[Removed Lines]",
          "91:         # note we don't need the check if calldata_min_size == 4,",
          "92:         # because the global calldatasize check ensures that already.",
          "93:         if calldata_min_size > 4:",
          "94:             ret.append([\"assert\", [\"ge\", \"calldatasize\", calldata_min_size]])",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "124:         ret.append([\"goto\", func_t._ir_info.external_function_base_entry_label])",
          "132:     keyword_args = func_t.keyword_args",
          "",
          "[Removed Lines]",
          "126:         method_id_check = [\"eq\", \"_calldata_method_id\", method_id]",
          "127:         ret = [\"if\", method_id_check, ret]",
          "128:         return ret",
          "130:     ret = [\"seq\"]",
          "",
          "[Added Lines]",
          "113:         # return something we can turn into ExternalFuncIR",
          "114:         return abi_sig, calldata_min_size, ret",
          "116:     ret = {}",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "139:         calldata_kwargs = keyword_args[:i]",
          "140:         default_kwargs = keyword_args[i:]",
          "146:     return ret",
          "",
          "[Removed Lines]",
          "142:         ret.append(handler_for(calldata_kwargs, default_kwargs))",
          "144:     ret.append(handler_for(keyword_args, []))",
          "",
          "[Added Lines]",
          "128:         sig, calldata_min_size, ir_node = handler_for(calldata_kwargs, default_kwargs)",
          "129:         ret[sig] = calldata_min_size, ir_node",
          "131:     sig, calldata_min_size, ir_node = handler_for(keyword_args, [])",
          "133:     ret[sig] = calldata_min_size, ir_node",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "149: # TODO it would be nice if this returned a data structure which were",
          "150: # amenable to generating a jump table instead of the linear search for",
          "151: # method_id we have now.",
          "153:     # TODO type hints:",
          "154:     # def generate_ir_for_external_function(",
          "155:     #    code: vy_ast.FunctionDef,",
          "",
          "[Removed Lines]",
          "152: def generate_ir_for_external_function(code, func_t, context, skip_nonpayable_check):",
          "",
          "[Added Lines]",
          "141: def generate_ir_for_external_function(code, func_t, context):",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "174:     # generate the main body of the function",
          "175:     body += handle_base_args",
          "185:     body += nonreentrant_pre",
          "187:     body += [parse_body(code.body, context, ensure_terminated=True)]",
          "",
          "[Removed Lines]",
          "177:     if not func_t.is_payable and not skip_nonpayable_check:",
          "178:         # if the contract contains payable functions, but this is not one of them",
          "179:         # add an assertion that the value of the call is zero",
          "180:         nonpayable_check = IRnode.from_list(",
          "181:             [\"assert\", [\"iszero\", \"callvalue\"]], error_msg=\"nonpayable check\"",
          "182:         )",
          "183:         body.append(nonpayable_check)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "201:     if context.return_type is not None:",
          "202:         exit_sequence_args += [\"ret_ofst\", \"ret_len\"]",
          "203:     # wrap the exit in a labeled block",
          "206:     # the ir which comprises the main body of the function,",
          "207:     # besides any kwarg handling",
          "",
          "[Removed Lines]",
          "204:     exit = [\"label\", func_t._ir_info.exit_sequence_label, exit_sequence_args, exit_sequence]",
          "208:     func_common_ir = [\"seq\", body, exit]",
          "210:     if func_t.is_fallback or func_t.is_constructor:",
          "211:         ret = [\"seq\"]",
          "212:         # add a goto to make the function entry look like other functions",
          "213:         # (for zksync interpreter)",
          "214:         ret.append([\"goto\", func_t._ir_info.external_function_base_entry_label])",
          "215:         ret.append(func_common_ir)",
          "216:     else:",
          "217:         ret = kwarg_handlers",
          "218:         # sneak the base code into the kwarg handler",
          "219:         # TODO rethink this / make it clearer",
          "220:         ret[-1][-1].append(func_common_ir)",
          "222:     return IRnode.from_list(ret, source_pos=getpos(code))",
          "",
          "[Added Lines]",
          "185:     exit_ = [\"label\", func_t._ir_info.exit_sequence_label, exit_sequence_args, exit_sequence]",
          "189:     func_common_ir = IRnode.from_list([\"seq\", body, exit_], source_pos=getpos(code))",
          "191:     return kwarg_handlers, func_common_ir",
          "",
          "---------------"
        ],
        "vyper/codegen/ir_node.py||vyper/codegen/ir_node.py": [
          "File: vyper/codegen/ir_node.py -> vyper/codegen/ir_node.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "149:             self.valency = 1",
          "150:             self._gas = 5",
          "151:         elif isinstance(self.value, str):",
          "152:             # Opcodes and pseudo-opcodes (e.g. clamp)",
          "153:             if self.value.upper() in get_ir_opcodes():",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "151:         elif isinstance(self.value, bytes):",
          "152:             # a literal bytes value, probably inside a \"data\" node.",
          "153:             _check(len(self.args) == 0, \"bytes can't have arguments\")",
          "155:             self.valency = 0",
          "156:             self._gas = 0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "264:                 self.valency = 0",
          "265:                 self._gas = sum([arg.gas for arg in self.args])",
          "266:             elif self.value == \"label\":",
          "269:                 self.valency = 0",
          "270:                 self._gas = 1 + sum(t.gas for t in self.args)",
          "271:             elif self.value == \"unique_symbol\":",
          "",
          "[Removed Lines]",
          "267:                 if not self.args[1].value == \"var_list\":",
          "268:                     raise CodegenPanic(f\"2nd argument to label must be var_list, {self}\")",
          "",
          "[Added Lines]",
          "274:                 _check(",
          "275:                     self.args[1].value == \"var_list\",",
          "276:                     f\"2nd argument to label must be var_list, {self}\",",
          "277:                 )",
          "278:                 _check(len(args) == 3, f\"label should have 3 args but has {len(args)}, {self}\")",
          "",
          "---------------"
        ],
        "vyper/codegen/jumptable_utils.py||vyper/codegen/jumptable_utils.py": [
          "File: vyper/codegen/jumptable_utils.py -> vyper/codegen/jumptable_utils.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # helper module which implements jumptable for function selection",
          "2: import math",
          "3: from dataclasses import dataclass",
          "5: from vyper.utils import method_id_int",
          "8: @dataclass",
          "9: class Signature:",
          "10:     method_id: int",
          "11:     payable: bool",
          "14: # bucket for dense function",
          "15: @dataclass",
          "16: class Bucket:",
          "17:     bucket_id: int",
          "18:     magic: int",
          "19:     method_ids: list[int]",
          "21:     @property",
          "22:     def image(self):",
          "23:         return _image_of([s for s in self.method_ids], self.magic)",
          "25:     @property",
          "26:     # return method ids, sorted by by their image",
          "27:     def method_ids_image_order(self):",
          "28:         return [x[1] for x in sorted(zip(self.image, self.method_ids))]",
          "30:     @property",
          "31:     def bucket_size(self):",
          "32:         return len(self.method_ids)",
          "35: BITS_MAGIC = 24  # a constant which produced good results, see _bench_dense()",
          "38: def _image_of(xs, magic):",
          "39:     bits_shift = BITS_MAGIC",
          "41:     # take the upper bits from the multiplication for more entropy",
          "42:     # can we do better using primes of some sort?",
          "43:     return [((x * magic) >> bits_shift) % len(xs) for x in xs]",
          "46: class _Failure(Exception):",
          "47:     pass",
          "50: def find_magic_for(xs):",
          "51:     for m in range(2**16):",
          "52:         test = _image_of(xs, m)",
          "53:         if len(test) == len(set(test)):",
          "54:             return m",
          "56:     raise _Failure(f\"Could not find hash for {xs}\")",
          "59: def _mk_buckets(method_ids, n_buckets):",
          "60:     buckets = {}",
          "61:     for x in method_ids:",
          "62:         t = x % n_buckets",
          "63:         buckets.setdefault(t, [])",
          "64:         buckets[t].append(x)",
          "65:     return buckets",
          "68: # two layer method for generating perfect hash",
          "69: # first get \"reasonably good\" distribution by using",
          "70: # method_id % len(method_ids)",
          "71: # second, get the magic for the bucket.",
          "72: def _dense_jumptable_info(method_ids, n_buckets):",
          "73:     buckets = _mk_buckets(method_ids, n_buckets)",
          "75:     ret = {}",
          "76:     for bucket_id, method_ids in buckets.items():",
          "77:         magic = find_magic_for(method_ids)",
          "78:         ret[bucket_id] = Bucket(bucket_id, magic, method_ids)",
          "80:     return ret",
          "83: START_BUCKET_SIZE = 5",
          "86: # this is expensive! for 80 methods, costs about 350ms and probably",
          "87: # linear in # of methods.",
          "88: # see _bench_perfect()",
          "89: # note the buckets are NOT in order!",
          "90: def generate_dense_jumptable_info(signatures):",
          "91:     method_ids = [method_id_int(sig) for sig in signatures]",
          "92:     n = len(signatures)",
          "93:     # start at bucket size of 5 and try to improve (generally",
          "94:     # speaking we want as few buckets as possible)",
          "95:     n_buckets = (n // START_BUCKET_SIZE) + 1",
          "96:     ret = None",
          "97:     tried_exhaustive = False",
          "98:     while n_buckets > 0:",
          "99:         try:",
          "100:             # print(f\"trying {n_buckets} (bucket size {n // n_buckets})\")",
          "101:             ret = _dense_jumptable_info(method_ids, n_buckets)",
          "102:         except _Failure:",
          "103:             if ret is not None:",
          "104:                 break",
          "106:             # we have not tried exhaustive search. try really hard",
          "107:             # to find a valid jumptable at the cost of performance",
          "108:             if not tried_exhaustive:",
          "109:                 # print(\"failed with guess! trying exhaustive search.\")",
          "110:                 n_buckets = n",
          "111:                 tried_exhaustive = True",
          "112:                 continue",
          "113:             else:",
          "114:                 raise RuntimeError(f\"Could not generate jumptable! {signatures}\")",
          "115:         n_buckets -= 1",
          "117:     return ret",
          "120: # note the buckets are NOT in order!",
          "121: def generate_sparse_jumptable_buckets(signatures):",
          "122:     method_ids = [method_id_int(sig) for sig in signatures]",
          "123:     n = len(signatures)",
          "125:     # search a range of buckets to try to minimize bucket size",
          "126:     # (doing the range search improves worst worst bucket size from 9 to 4,",
          "127:     # see _bench_sparse)",
          "128:     lo = max(1, math.floor(n * 0.85))",
          "129:     hi = max(1, math.ceil(n * 1.15))",
          "130:     stats = {}",
          "131:     for i in range(lo, hi + 1):",
          "132:         buckets = _mk_buckets(method_ids, i)",
          "134:         stats[i] = buckets",
          "136:     min_max_bucket_size = hi + 1  # smallest max_bucket_size",
          "137:     # find the smallest i which gives us the smallest max_bucket_size",
          "138:     for i, buckets in stats.items():",
          "139:         max_bucket_size = max(len(bucket) for bucket in buckets.values())",
          "140:         if max_bucket_size < min_max_bucket_size:",
          "141:             min_max_bucket_size = max_bucket_size",
          "142:             ret = i, buckets",
          "144:     assert ret is not None",
          "145:     return ret",
          "148: # benchmark for quality of buckets",
          "149: def _bench_dense(N=1_000, n_methods=100):",
          "150:     import random",
          "152:     stats = []",
          "153:     for i in range(N):",
          "154:         seed = random.randint(0, 2**64 - 1)",
          "155:         # \"large\" contracts in prod hit about ~50 methods, test with",
          "156:         # double the limit",
          "157:         sigs = [f\"foo{i + seed}()\" for i in range(n_methods)]",
          "159:         xs = generate_dense_jumptable_info(sigs)",
          "160:         print(f\"found. n buckets {len(xs)}\")",
          "161:         stats.append(xs)",
          "163:     def mean(xs):",
          "164:         return sum(xs) / len(xs)",
          "166:     avg_n_buckets = mean([len(jt) for jt in stats])",
          "167:     # usually around ~14 buckets per 100 sigs",
          "168:     # N=10, time=3.6s",
          "169:     print(f\"average N buckets: {avg_n_buckets}\")",
          "172: def _bench_sparse(N=10_000, n_methods=80):",
          "173:     import random",
          "175:     stats = []",
          "176:     for _ in range(N):",
          "177:         seed = random.randint(0, 2**64 - 1)",
          "178:         sigs = [f\"foo{i + seed}()\" for i in range(n_methods)]",
          "179:         _, buckets = generate_sparse_jumptable_buckets(sigs)",
          "181:         bucket_sizes = [len(bucket) for bucket in buckets.values()]",
          "182:         worst_bucket_size = max(bucket_sizes)",
          "183:         mean_bucket_size = sum(bucket_sizes) / len(bucket_sizes)",
          "184:         stats.append((worst_bucket_size, mean_bucket_size))",
          "186:     # N=10_000, time=9s",
          "187:     # range 0.85*n - 1.15*n",
          "188:     # worst worst bucket size: 4",
          "189:     # avg worst bucket size: 3.0018",
          "190:     # worst mean bucket size: 2.0",
          "191:     # avg mean bucket size: 1.579112583664968",
          "192:     print(\"worst worst bucket size:\", max(x[0] for x in stats))",
          "193:     print(\"avg worst bucket size:\", sum(x[0] for x in stats) / len(stats))",
          "194:     print(\"worst mean bucket size:\", max(x[1] for x in stats))",
          "195:     print(\"avg mean bucket size:\", sum(x[1] for x in stats) / len(stats))",
          "",
          "---------------"
        ],
        "vyper/codegen/module.py||vyper/codegen/module.py": [
          "File: vyper/codegen/module.py -> vyper/codegen/module.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: from typing import Any, List",
          "5: from vyper.codegen.core import shr",
          "6: from vyper.codegen.function_definitions import generate_ir_for_function",
          "7: from vyper.codegen.global_context import GlobalContext",
          "8: from vyper.codegen.ir_node import IRnode",
          "9: from vyper.exceptions import CompilerPanic",
          "12: def _topsort_helper(functions, lookup):",
          "",
          "[Removed Lines]",
          "1: # a contract.vy -- all functions and constructor",
          "",
          "[Added Lines]",
          "1: # a compilation unit -- all functions and constructor",
          "5: from vyper.codegen import core, jumptable_utils",
          "10: from vyper.compiler.settings import _is_debug_mode",
          "12: from vyper.utils import method_id_int",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47:     return func_ast._metadata[\"type\"].is_payable",
          "76:     if len(external_functions) == 0:",
          "101:         )",
          "138: # take a GlobalContext, and generate the runtime and deploy IR",
          "",
          "[Removed Lines]",
          "50: # codegen for all runtime functions + callvalue/calldata checks + method selector routines",
          "51: def _runtime_ir(runtime_functions, global_ctx):",
          "52:     # categorize the runtime functions because we will organize the runtime",
          "53:     # code into the following sections:",
          "54:     # payable functions, nonpayable functions, fallback function, internal_functions",
          "55:     internal_functions = [f for f in runtime_functions if _is_internal(f)]",
          "57:     external_functions = [f for f in runtime_functions if not _is_internal(f)]",
          "58:     default_function = next((f for f in external_functions if _is_fallback(f)), None)",
          "60:     # functions that need to go exposed in the selector section",
          "61:     regular_functions = [f for f in external_functions if not _is_fallback(f)]",
          "62:     payables = [f for f in regular_functions if _is_payable(f)]",
          "63:     nonpayables = [f for f in regular_functions if not _is_payable(f)]",
          "65:     # create a map of the IR functions since they might live in both",
          "66:     # runtime and deploy code (if init function calls them)",
          "67:     internal_functions_ir: list[IRnode] = []",
          "69:     for func_ast in internal_functions:",
          "70:         func_ir = generate_ir_for_function(func_ast, global_ctx, False)",
          "71:         internal_functions_ir.append(func_ir)",
          "73:     # for some reason, somebody may want to deploy a contract with no",
          "74:     # external functions, or more likely, a \"pure data\" contract which",
          "75:     # contains immutables",
          "77:         # TODO: prune internal functions in this case? dead code eliminator",
          "78:         # might not eliminate them, since internal function jumpdest is at the",
          "79:         # first instruction in the contract.",
          "80:         runtime = [\"seq\"] + internal_functions_ir",
          "81:         return runtime",
          "83:     # note: if the user does not provide one, the default fallback function",
          "84:     # reverts anyway. so it does not hurt to batch the payable check.",
          "85:     default_is_nonpayable = default_function is None or not _is_payable(default_function)",
          "87:     # when a contract has a nonpayable default function,",
          "88:     # we can do a single check for all nonpayable functions",
          "89:     batch_payable_check = len(nonpayables) > 0 and default_is_nonpayable",
          "90:     skip_nonpayable_check = batch_payable_check",
          "92:     selector_section = [\"seq\"]",
          "94:     for func_ast in payables:",
          "95:         func_ir = generate_ir_for_function(func_ast, global_ctx, False)",
          "96:         selector_section.append(func_ir)",
          "98:     if batch_payable_check:",
          "99:         nonpayable_check = IRnode.from_list(",
          "100:             [\"assert\", [\"iszero\", \"callvalue\"]], error_msg=\"nonpayable check\"",
          "102:         selector_section.append(nonpayable_check)",
          "104:     for func_ast in nonpayables:",
          "105:         func_ir = generate_ir_for_function(func_ast, global_ctx, skip_nonpayable_check)",
          "106:         selector_section.append(func_ir)",
          "108:     if default_function:",
          "109:         fallback_ir = generate_ir_for_function(",
          "110:             default_function, global_ctx, skip_nonpayable_check=False",
          "111:         )",
          "112:     else:",
          "113:         fallback_ir = IRnode.from_list(",
          "114:             [\"revert\", 0, 0], annotation=\"Default function\", error_msg=\"fallback function\"",
          "115:         )",
          "117:     # ensure the external jumptable section gets closed out",
          "118:     # (for basic block hygiene and also for zksync interpreter)",
          "119:     # NOTE: this jump gets optimized out in assembly since the",
          "120:     # fallback label is the immediate next instruction,",
          "121:     close_selector_section = [\"goto\", \"fallback\"]",
          "123:     global_calldatasize_check = [\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]]",
          "125:     runtime = [",
          "126:         \"seq\",",
          "127:         global_calldatasize_check,",
          "128:         [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section],",
          "129:         close_selector_section,",
          "130:         [\"label\", \"fallback\", [\"var_list\"], fallback_ir],",
          "131:     ]",
          "133:     runtime.extend(internal_functions_ir)",
          "135:     return runtime",
          "",
          "[Added Lines]",
          "53: def _annotated_method_id(abi_sig):",
          "54:     method_id = method_id_int(abi_sig)",
          "55:     annotation = f\"{hex(method_id)}: {abi_sig}\"",
          "56:     return IRnode(method_id, annotation=annotation)",
          "59: def label_for_entry_point(abi_sig, entry_point):",
          "60:     method_id = method_id_int(abi_sig)",
          "61:     return f\"{entry_point.func_t._ir_info.ir_identifier}{method_id}\"",
          "64: # adapt whatever generate_ir_for_function gives us into an IR node",
          "65: def _ir_for_fallback_or_ctor(func_ast, *args, **kwargs):",
          "66:     func_t = func_ast._metadata[\"type\"]",
          "67:     assert func_t.is_fallback or func_t.is_constructor",
          "69:     ret = [\"seq\"]",
          "70:     if not func_t.is_payable:",
          "71:         callvalue_check = [\"assert\", [\"iszero\", \"callvalue\"]]",
          "72:         ret.append(IRnode.from_list(callvalue_check, error_msg=\"nonpayable check\"))",
          "74:     func_ir = generate_ir_for_function(func_ast, *args, **kwargs)",
          "75:     assert len(func_ir.entry_points) == 1",
          "77:     # add a goto to make the function entry look like other functions",
          "78:     # (for zksync interpreter)",
          "79:     ret.append([\"goto\", func_t._ir_info.external_function_base_entry_label])",
          "80:     ret.append(func_ir.common_ir)",
          "82:     return IRnode.from_list(ret)",
          "85: def _ir_for_internal_function(func_ast, *args, **kwargs):",
          "86:     return generate_ir_for_function(func_ast, *args, **kwargs).func_ir",
          "89: def _generate_external_entry_points(external_functions, global_ctx):",
          "90:     entry_points = {}  # map from ABI sigs to ir code",
          "91:     sig_of = {}  # reverse map from method ids to abi sig",
          "93:     for code in external_functions:",
          "94:         func_ir = generate_ir_for_function(code, global_ctx)",
          "95:         for abi_sig, entry_point in func_ir.entry_points.items():",
          "96:             assert abi_sig not in entry_points",
          "97:             entry_points[abi_sig] = entry_point",
          "98:             sig_of[method_id_int(abi_sig)] = abi_sig",
          "100:         # stick function common body into final entry point to save a jump",
          "101:         ir_node = IRnode.from_list([\"seq\", entry_point.ir_node, func_ir.common_ir])",
          "102:         entry_point.ir_node = ir_node",
          "104:     return entry_points, sig_of",
          "107: # codegen for all runtime functions + callvalue/calldata checks,",
          "108: # with O(1) jumptable for selector table.",
          "109: # uses two level strategy: uses `method_id % n_buckets` to descend",
          "110: # into a bucket (of about 8-10 items), and then uses perfect hash",
          "111: # to select the final function.",
          "112: # costs about 212 gas for typical function and 8 bytes of code (+ ~87 bytes of global overhead)",
          "113: def _selector_section_dense(external_functions, global_ctx):",
          "114:     function_irs = []",
          "117:         return IRnode.from_list([\"seq\"])",
          "119:     entry_points, sig_of = _generate_external_entry_points(external_functions, global_ctx)",
          "121:     # generate the label so the jumptable works",
          "122:     for abi_sig, entry_point in entry_points.items():",
          "123:         label = label_for_entry_point(abi_sig, entry_point)",
          "124:         ir_node = [\"label\", label, [\"var_list\"], entry_point.ir_node]",
          "125:         function_irs.append(IRnode.from_list(ir_node))",
          "127:     jumptable_info = jumptable_utils.generate_dense_jumptable_info(entry_points.keys())",
          "128:     n_buckets = len(jumptable_info)",
          "130:     #  bucket magic <2 bytes> | bucket location <2 bytes> | bucket size <1 byte>",
          "131:     # TODO: can make it smaller if the largest bucket magic <= 255",
          "132:     SZ_BUCKET_HEADER = 5",
          "134:     selector_section = [\"seq\"]",
          "136:     bucket_id = [\"mod\", \"_calldata_method_id\", n_buckets]",
          "137:     bucket_hdr_location = [",
          "138:         \"add\",",
          "139:         [\"symbol\", \"BUCKET_HEADERS\"],",
          "140:         [\"mul\", bucket_id, SZ_BUCKET_HEADER],",
          "141:     ]",
          "142:     # get bucket header",
          "143:     dst = 32 - SZ_BUCKET_HEADER",
          "144:     assert dst >= 0",
          "146:     if _is_debug_mode():",
          "147:         selector_section.append([\"assert\", [\"eq\", \"msize\", 0]])",
          "149:     selector_section.append([\"codecopy\", dst, bucket_hdr_location, SZ_BUCKET_HEADER])",
          "151:     # figure out the minimum number of bytes we can use to encode",
          "152:     # min_calldatasize in function info",
          "153:     largest_mincalldatasize = max(f.min_calldatasize for f in entry_points.values())",
          "154:     FN_METADATA_BYTES = (largest_mincalldatasize.bit_length() + 7) // 8",
          "156:     func_info_size = 4 + 2 + FN_METADATA_BYTES",
          "157:     # grab function info.",
          "158:     # method id <4 bytes> | label <2 bytes> | func info <1-3 bytes>",
          "159:     # func info (1-3 bytes, packed) for: expected calldatasize, is_nonpayable bit",
          "160:     # NOTE: might be able to improve codesize if we use variable # of bytes",
          "161:     # per bucket",
          "163:     hdr_info = IRnode.from_list([\"mload\", 0])",
          "164:     with hdr_info.cache_when_complex(\"hdr_info\") as (b1, hdr_info):",
          "165:         bucket_location = [\"and\", 0xFFFF, shr(8, hdr_info)]",
          "166:         bucket_magic = shr(24, hdr_info)",
          "167:         bucket_size = [\"and\", 0xFF, hdr_info]",
          "168:         # ((method_id * bucket_magic) >> BITS_MAGIC) % bucket_size",
          "169:         func_id = [",
          "170:             \"mod\",",
          "171:             shr(jumptable_utils.BITS_MAGIC, [\"mul\", bucket_magic, \"_calldata_method_id\"]),",
          "172:             bucket_size,",
          "173:         ]",
          "174:         func_info_location = [\"add\", bucket_location, [\"mul\", func_id, func_info_size]]",
          "175:         dst = 32 - func_info_size",
          "176:         assert func_info_size >= SZ_BUCKET_HEADER  # otherwise mload will have dirty bytes",
          "177:         assert dst >= 0",
          "178:         selector_section.append(b1.resolve([\"codecopy\", dst, func_info_location, func_info_size]))",
          "180:     func_info = IRnode.from_list([\"mload\", 0])",
          "181:     fn_metadata_mask = 2 ** (FN_METADATA_BYTES * 8) - 1",
          "182:     calldatasize_mask = fn_metadata_mask - 1  # ex. 0xFFFE",
          "183:     with func_info.cache_when_complex(\"func_info\") as (b1, func_info):",
          "184:         x = [\"seq\"]",
          "186:         # expected calldatasize always satisfies (x - 4) % 32 == 0",
          "187:         # the lower 5 bits are always 0b00100, so we can use those",
          "188:         # bits for other purposes.",
          "189:         is_nonpayable = [\"and\", 1, func_info]",
          "190:         expected_calldatasize = [\"and\", calldatasize_mask, func_info]",
          "192:         label_bits_ofst = FN_METADATA_BYTES * 8",
          "193:         function_label = [\"and\", 0xFFFF, shr(label_bits_ofst, func_info)]",
          "194:         method_id_bits_ofst = (FN_METADATA_BYTES + 2) * 8",
          "195:         function_method_id = shr(method_id_bits_ofst, func_info)",
          "197:         # check method id is right, if not then fallback.",
          "198:         # need to check calldatasize >= 4 in case there are",
          "199:         # trailing 0s in the method id.",
          "200:         calldatasize_valid = [\"gt\", \"calldatasize\", 3]",
          "201:         method_id_correct = [\"eq\", function_method_id, \"_calldata_method_id\"]",
          "202:         should_fallback = [\"iszero\", [\"and\", calldatasize_valid, method_id_correct]]",
          "203:         x.append([\"if\", should_fallback, [\"goto\", \"fallback\"]])",
          "205:         # assert callvalue == 0 if nonpayable",
          "206:         bad_callvalue = [\"mul\", is_nonpayable, \"callvalue\"]",
          "207:         # assert calldatasize at least minimum for the abi type",
          "208:         bad_calldatasize = [\"lt\", \"calldatasize\", expected_calldatasize]",
          "209:         failed_entry_conditions = [\"or\", bad_callvalue, bad_calldatasize]",
          "210:         check_entry_conditions = IRnode.from_list(",
          "211:             [\"assert\", [\"iszero\", failed_entry_conditions]],",
          "212:             error_msg=\"bad calldatasize or callvalue\",",
          "214:         x.append(check_entry_conditions)",
          "215:         x.append([\"jump\", function_label])",
          "216:         selector_section.append(b1.resolve(x))",
          "218:     bucket_headers = [\"data\", \"BUCKET_HEADERS\"]",
          "220:     for bucket_id, bucket in sorted(jumptable_info.items()):",
          "221:         bucket_headers.append(bucket.magic.to_bytes(2, \"big\"))",
          "222:         bucket_headers.append([\"symbol\", f\"bucket_{bucket_id}\"])",
          "223:         # note: buckets are usually ~10 items. to_bytes would",
          "224:         # fail if the int is too big.",
          "225:         bucket_headers.append(bucket.bucket_size.to_bytes(1, \"big\"))",
          "227:     selector_section.append(bucket_headers)",
          "229:     for bucket_id, bucket in jumptable_info.items():",
          "230:         function_infos = [\"data\", f\"bucket_{bucket_id}\"]",
          "231:         # sort function infos by their image.",
          "232:         for method_id in bucket.method_ids_image_order:",
          "233:             abi_sig = sig_of[method_id]",
          "234:             entry_point = entry_points[abi_sig]",
          "236:             method_id_bytes = method_id.to_bytes(4, \"big\")",
          "237:             symbol = [\"symbol\", label_for_entry_point(abi_sig, entry_point)]",
          "238:             func_metadata_int = entry_point.min_calldatasize | int(",
          "239:                 not entry_point.func_t.is_payable",
          "240:             )",
          "241:             func_metadata = func_metadata_int.to_bytes(FN_METADATA_BYTES, \"big\")",
          "243:             function_infos.extend([method_id_bytes, symbol, func_metadata])",
          "245:         selector_section.append(function_infos)",
          "247:     ret = [\"seq\", [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section]]",
          "249:     ret.extend(function_irs)",
          "251:     return ret",
          "254: # codegen for all runtime functions + callvalue/calldata checks,",
          "255: # with O(1) jumptable for selector table.",
          "256: # uses two level strategy: uses `method_id % n_methods` to calculate",
          "257: # a bucket, and then descends into linear search from there.",
          "258: # costs about 126 gas for typical (nonpayable, >0 args, avg bucket size 1.5)",
          "259: # function and 24 bytes of code (+ ~23 bytes of global overhead)",
          "260: def _selector_section_sparse(external_functions, global_ctx):",
          "261:     ret = [\"seq\"]",
          "263:     if len(external_functions) == 0:",
          "264:         return ret",
          "266:     entry_points, sig_of = _generate_external_entry_points(external_functions, global_ctx)",
          "268:     n_buckets, buckets = jumptable_utils.generate_sparse_jumptable_buckets(entry_points.keys())",
          "270:     # 2 bytes for bucket location",
          "271:     SZ_BUCKET_HEADER = 2",
          "273:     if n_buckets > 1:",
          "274:         bucket_id = [\"mod\", \"_calldata_method_id\", n_buckets]",
          "275:         bucket_hdr_location = [",
          "276:             \"add\",",
          "277:             [\"symbol\", \"selector_buckets\"],",
          "278:             [\"mul\", bucket_id, SZ_BUCKET_HEADER],",
          "279:         ]",
          "280:         # get bucket header",
          "281:         dst = 32 - SZ_BUCKET_HEADER",
          "282:         assert dst >= 0",
          "284:         if _is_debug_mode():",
          "285:             ret.append([\"assert\", [\"eq\", \"msize\", 0]])",
          "287:         ret.append([\"codecopy\", dst, bucket_hdr_location, SZ_BUCKET_HEADER])",
          "289:         jumpdest = IRnode.from_list([\"mload\", 0])",
          "290:         # don't particularly like using `jump` here since it can cause",
          "291:         # issues for other backends, consider changing `goto` to allow",
          "292:         # dynamic jumps, or adding some kind of jumptable instruction",
          "293:         ret.append([\"jump\", jumpdest])",
          "295:         jumptable_data = [\"data\", \"selector_buckets\"]",
          "296:         for i in range(n_buckets):",
          "297:             if i in buckets:",
          "298:                 bucket_label = f\"selector_bucket_{i}\"",
          "299:                 jumptable_data.append([\"symbol\", bucket_label])",
          "300:             else:",
          "301:                 # empty bucket",
          "302:                 jumptable_data.append([\"symbol\", \"fallback\"])",
          "304:         ret.append(jumptable_data)",
          "306:     for bucket_id, bucket in buckets.items():",
          "307:         bucket_label = f\"selector_bucket_{bucket_id}\"",
          "308:         ret.append([\"label\", bucket_label, [\"var_list\"], [\"seq\"]])",
          "310:         handle_bucket = [\"seq\"]",
          "312:         for method_id in bucket:",
          "313:             sig = sig_of[method_id]",
          "314:             entry_point = entry_points[sig]",
          "315:             func_t = entry_point.func_t",
          "316:             expected_calldatasize = entry_point.min_calldatasize",
          "318:             dispatch = [\"seq\"]  # code to dispatch into the function",
          "319:             skip_callvalue_check = func_t.is_payable",
          "320:             skip_calldatasize_check = expected_calldatasize == 4",
          "321:             bad_callvalue = [0] if skip_callvalue_check else [\"callvalue\"]",
          "322:             bad_calldatasize = (",
          "323:                 [0] if skip_calldatasize_check else [\"lt\", \"calldatasize\", expected_calldatasize]",
          "324:             )",
          "326:             dispatch.append(",
          "327:                 IRnode.from_list(",
          "328:                     [\"assert\", [\"iszero\", [\"or\", bad_callvalue, bad_calldatasize]]],",
          "329:                     error_msg=\"bad calldatasize or callvalue\",",
          "330:                 )",
          "331:             )",
          "332:             # we could skip a jumpdest per method if we out-lined the entry point",
          "333:             # so the dispatcher looks just like -",
          "334:             # ```(if (eq <calldata_method_id> method_id)",
          "335:             #   (goto entry_point_label))```",
          "336:             # it would another optimization for patterns like",
          "337:             # `if ... (goto)` though.",
          "338:             dispatch.append(entry_point.ir_node)",
          "340:             method_id_check = [\"eq\", \"_calldata_method_id\", _annotated_method_id(sig)]",
          "341:             has_trailing_zeroes = method_id.to_bytes(4, \"big\").endswith(b\"\\x00\")",
          "342:             if has_trailing_zeroes:",
          "343:                 # if the method id check has trailing 0s, we need to include",
          "344:                 # a calldatasize check to distinguish from when not enough",
          "345:                 # bytes are provided for the method id in calldata.",
          "346:                 method_id_check = [\"and\", [\"ge\", \"calldatasize\", 4], method_id_check]",
          "347:             handle_bucket.append([\"if\", method_id_check, dispatch])",
          "349:         # close out the bucket with a goto fallback so we don't keep searching",
          "350:         handle_bucket.append([\"goto\", \"fallback\"])",
          "352:         ret.append(handle_bucket)",
          "354:     ret = [\"seq\", [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), ret]]",
          "356:     return ret",
          "359: # codegen for all runtime functions + callvalue/calldata checks,",
          "360: # O(n) linear search for the method id",
          "361: # mainly keep this in for backends which cannot handle the indirect jump",
          "362: # in selector_section_dense and selector_section_sparse",
          "363: def _selector_section_linear(external_functions, global_ctx):",
          "364:     ret = [\"seq\"]",
          "365:     if len(external_functions) == 0:",
          "366:         return ret",
          "368:     ret.append([\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]])",
          "370:     entry_points, sig_of = _generate_external_entry_points(external_functions, global_ctx)",
          "372:     dispatcher = [\"seq\"]",
          "374:     for sig, entry_point in entry_points.items():",
          "375:         func_t = entry_point.func_t",
          "376:         expected_calldatasize = entry_point.min_calldatasize",
          "378:         dispatch = [\"seq\"]  # code to dispatch into the function",
          "380:         if not func_t.is_payable:",
          "381:             callvalue_check = [\"assert\", [\"iszero\", \"callvalue\"]]",
          "382:             dispatch.append(IRnode.from_list(callvalue_check, error_msg=\"nonpayable check\"))",
          "384:         good_calldatasize = [\"ge\", \"calldatasize\", expected_calldatasize]",
          "385:         calldatasize_check = [\"assert\", good_calldatasize]",
          "386:         dispatch.append(IRnode.from_list(calldatasize_check, error_msg=\"calldatasize check\"))",
          "388:         dispatch.append(entry_point.ir_node)",
          "390:         method_id_check = [\"eq\", \"_calldata_method_id\", _annotated_method_id(sig)]",
          "391:         dispatcher.append([\"if\", method_id_check, dispatch])",
          "393:     ret.append([\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), dispatcher])",
          "395:     return ret",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "143:     runtime_functions = [f for f in function_defs if not _is_constructor(f)]",
          "144:     init_function = next((f for f in function_defs if _is_constructor(f)), None)",
          "148:     deploy_code: List[Any] = [\"seq\"]",
          "149:     immutables_len = global_ctx.immutable_section_bytes",
          "150:     if init_function:",
          "151:         # TODO might be cleaner to separate this into an _init_ir helper func",
          "156:         # pass the amount of memory allocated for the init function",
          "157:         # so that deployment does not clobber while preparing immutables",
          "",
          "[Removed Lines]",
          "146:     runtime = _runtime_ir(runtime_functions, global_ctx)",
          "152:         init_func_ir = generate_ir_for_function(",
          "153:             init_function, global_ctx, skip_nonpayable_check=False, is_ctor_context=True",
          "154:         )",
          "",
          "[Added Lines]",
          "406:     internal_functions = [f for f in runtime_functions if _is_internal(f)]",
          "408:     external_functions = [",
          "409:         f for f in runtime_functions if not _is_internal(f) and not _is_fallback(f)",
          "410:     ]",
          "411:     default_function = next((f for f in runtime_functions if _is_fallback(f)), None)",
          "413:     internal_functions_ir: list[IRnode] = []",
          "415:     # compile internal functions first so we have the function info",
          "416:     for func_ast in internal_functions:",
          "417:         func_ir = _ir_for_internal_function(func_ast, global_ctx, False)",
          "418:         internal_functions_ir.append(IRnode.from_list(func_ir))",
          "420:     if core._opt_none():",
          "421:         selector_section = _selector_section_linear(external_functions, global_ctx)",
          "422:     # dense vs sparse global overhead is amortized after about 4 methods.",
          "423:     # (--debug will force dense selector table anyway if _opt_codesize is selected.)",
          "424:     elif core._opt_codesize() and (len(external_functions) > 4 or _is_debug_mode()):",
          "425:         selector_section = _selector_section_dense(external_functions, global_ctx)",
          "426:     else:",
          "427:         selector_section = _selector_section_sparse(external_functions, global_ctx)",
          "429:     if default_function:",
          "430:         fallback_ir = _ir_for_fallback_or_ctor(default_function, global_ctx)",
          "431:     else:",
          "432:         fallback_ir = IRnode.from_list(",
          "433:             [\"revert\", 0, 0], annotation=\"Default function\", error_msg=\"fallback function\"",
          "434:         )",
          "436:     runtime = [\"seq\", selector_section]",
          "437:     runtime.append([\"goto\", \"fallback\"])",
          "438:     runtime.append([\"label\", \"fallback\", [\"var_list\"], fallback_ir])",
          "440:     runtime.extend(internal_functions_ir)",
          "446:         init_func_ir = _ir_for_fallback_or_ctor(init_function, global_ctx, is_ctor_context=True)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "184:         for f in internal_functions:",
          "185:             init_func_t = init_function._metadata[\"type\"]",
          "186:             if f.name not in init_func_t.recursive_calls:",
          "188:                 continue",
          "193:             deploy_code.append(func_ir)",
          "195:     else:",
          "",
          "[Removed Lines]",
          "187:                 # unreachable",
          "190:             func_ir = generate_ir_for_function(",
          "191:                 f, global_ctx, skip_nonpayable_check=False, is_ctor_context=True",
          "192:             )",
          "",
          "[Added Lines]",
          "479:                 # unreachable code, delete it",
          "482:             func_ir = _ir_for_internal_function(f, global_ctx, is_ctor_context=True)",
          "",
          "---------------"
        ],
        "vyper/compiler/output.py||vyper/compiler/output.py": [
          "File: vyper/compiler/output.py -> vyper/compiler/output.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "301:     while bytecode_sequence:",
          "302:         op = bytecode_sequence.popleft()",
          "304:         if \"PUSH\" in opcode_output[-1] and opcode_output[-1] != \"PUSH0\":",
          "305:             push_len = int(opcode_map[op][4:])",
          "306:             push_values = [hex(bytecode_sequence.popleft())[2:] for i in range(push_len)]",
          "307:             opcode_output.append(f\"0x{''.join(push_values).upper()}\")",
          "",
          "[Removed Lines]",
          "303:         opcode_output.append(opcode_map[op])",
          "",
          "[Added Lines]",
          "303:         opcode_output.append(opcode_map.get(op, f\"VERBATIM_{hex(op)}\"))",
          "306:             # we can have push_len > len(bytecode_sequence) when there is data",
          "307:             # (instead of code) at end of contract",
          "308:             # CMC 2023-07-13 maybe just strip known data segments?",
          "309:             push_len = min(push_len, len(bytecode_sequence))",
          "",
          "---------------"
        ],
        "vyper/compiler/settings.py||vyper/compiler/settings.py": [
          "File: vyper/compiler/settings.py -> vyper/compiler/settings.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:     compiler_version: Optional[str] = None",
          "43:     optimize: Optional[OptimizationLevel] = None",
          "44:     evm_version: Optional[str] = None",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47: _DEBUG = False",
          "50: def _is_debug_mode():",
          "51:     global _DEBUG",
          "52:     return _DEBUG",
          "55: def _set_debug_mode(dbg: bool = False) -> None:",
          "56:     global _DEBUG",
          "57:     _DEBUG = dbg",
          "",
          "---------------"
        ],
        "vyper/ir/compile_ir.py||vyper/ir/compile_ir.py": [
          "File: vyper/ir/compile_ir.py -> vyper/ir/compile_ir.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "158:         to_append.extend(_revert_string)",
          "160:     if len(to_append) > 0:",
          "161:         # for some reason there might not be a STOP at the end of asm_ops.",
          "162:         # (generally vyper programs will have it but raw IR might not).",
          "163:         asm_ops.append(\"STOP\")",
          "164:         asm_ops.extend(to_append)",
          "166:     # need to do this recursively since every sublist is basically",
          "167:     # treated as its own program (there are no global labels.)",
          "168:     for t in asm_ops:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "161:         # insert the postambles *before* runtime code",
          "162:         # so the data section of the runtime code can't bork the postambles.",
          "163:         runtime = None",
          "164:         if isinstance(asm_ops[-1], list) and isinstance(asm_ops[-1][0], _RuntimeHeader):",
          "165:             runtime = asm_ops.pop()",
          "172:         if runtime:",
          "173:             asm_ops.append(runtime)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213:     res = _compile_to_assembly(code)",
          "215:     _add_postambles(res)",
          "216:     if optimize != OptimizationLevel.NONE:",
          "217:         _optimize_assembly(res)",
          "218:     return res",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "226:     _relocate_segments(res)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "500:         assert isinstance(memsize, int), \"non-int memsize\"",
          "501:         assert isinstance(padding, int), \"non-int padding\"",
          "505:         subcode = _compile_to_assembly(ir)",
          "507:         o = []",
          "509:         # COPY the code to memory for deploy",
          "512:         # calculate the len of runtime code",
          "513:         o.extend([\"_OFST\", \"_sym_subcode_size\", padding])  # stack: len",
          "",
          "[Removed Lines]",
          "503:         begincode = mksymbol(\"runtime_begin\")",
          "510:         o.extend([\"_sym_subcode_size\", begincode, \"_mem_deploy_start\", \"CODECOPY\"])",
          "",
          "[Added Lines]",
          "515:         runtime_begin = mksymbol(\"runtime_begin\")",
          "522:         o.extend([\"_sym_subcode_size\", runtime_begin, \"_mem_deploy_start\", \"CODECOPY\"])",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "517:         # since the asm data structures are very primitive, to make sure",
          "518:         # assembly_to_evm is able to calculate data offsets correctly,",
          "519:         # we pass the memsize via magic opcodes to the subcode",
          "522:         # append the runtime code after the ctor code",
          "524:         # `append(...)` call here is intentional.",
          "525:         # each sublist is essentially its own program with its",
          "526:         # own symbols.",
          "",
          "[Removed Lines]",
          "520:         subcode = [f\"_DEPLOY_MEM_OFST_{memsize}\"] + subcode",
          "523:         o.extend([begincode, \"BLANK\"])",
          "",
          "[Added Lines]",
          "532:         subcode = [_RuntimeHeader(runtime_begin, memsize)] + subcode",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "661:             height,",
          "662:         )",
          "664:     # jump to a symbol, and push variable # of arguments onto stack",
          "665:     elif code.value == \"goto\":",
          "666:         o = []",
          "667:         for i, c in enumerate(reversed(code.args[1:])):",
          "668:             o.extend(_compile_to_assembly(c, withargs, existing_labels, break_dest, height + i))",
          "670:         return o",
          "671:     # push a literal symbol",
          "672:     elif code.value == \"symbol\":",
          "674:     # set a symbol as a location.",
          "675:     elif code.value == \"label\":",
          "676:         label_name = code.args[0].value",
          "",
          "[Removed Lines]",
          "669:         o.extend([\"_sym_\" + str(code.args[0]), \"JUMP\"])",
          "673:         return [\"_sym_\" + str(code.args[0])]",
          "",
          "[Added Lines]",
          "675:     elif code.value == \"data\":",
          "676:         data_node = [_DataHeader(\"_sym_\" + code.args[0].value)]",
          "678:         for c in code.args[1:]:",
          "679:             if isinstance(c.value, int):",
          "680:                 assert 0 <= c < 256, f\"invalid data byte {c}\"",
          "681:                 data_node.append(c.value)",
          "682:             elif isinstance(c.value, bytes):",
          "683:                 data_node.append(c.value)",
          "684:             elif isinstance(c, IRnode):",
          "685:                 assert c.value == \"symbol\"",
          "686:                 data_node.extend(",
          "687:                     _compile_to_assembly(c, withargs, existing_labels, break_dest, height)",
          "688:                 )",
          "689:             else:",
          "690:                 raise ValueError(f\"Invalid data: {type(c)} {c}\")",
          "692:         # intentionally return a sublist.",
          "693:         return [data_node]",
          "700:         o.extend([\"_sym_\" + code.args[0].value, \"JUMP\"])",
          "704:         return [\"_sym_\" + code.args[0].value]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "728:     # inject debug opcode.",
          "729:     elif code.value == \"pc_debugger\":",
          "730:         return mkdebug(pc_debugger=True, source_pos=code.source_pos)",
          "735: def note_line_num(line_number_map, item, pos):",
          "",
          "[Removed Lines]",
          "731:     else:",
          "732:         raise Exception(\"Weird code element: \" + repr(code))",
          "",
          "[Added Lines]",
          "762:     else:  # pragma: no cover",
          "763:         raise ValueError(f\"Weird code element: {type(code)} {code}\")",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "766: def _prune_unreachable_code(assembly):",
          "772:     changed = False",
          "773:     i = 0",
          "774:     while i < len(assembly) - 2:",
          "",
          "[Removed Lines]",
          "767:     # In converting IR to assembly we sometimes end up with unreachable",
          "768:     # instructions - POPing to clear the stack or STOPing execution at the",
          "769:     # end of a function that has already returned or reverted. This should",
          "770:     # be addressed in the IR, but for now we do a final sanity check here",
          "771:     # to avoid unnecessary bytecode bloat.",
          "",
          "[Added Lines]",
          "798:     # delete code between terminal ops and JUMPDESTS as those are",
          "799:     # unreachable",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "777:             instr = assembly[i][-1]",
          "779:         if assembly[i] in _TERMINAL_OPS and not (",
          "781:         ):",
          "782:             changed = True",
          "783:             del assembly[i + 1]",
          "",
          "[Removed Lines]",
          "780:             is_symbol(assembly[i + 1]) and assembly[i + 2] in (\"JUMPDEST\", \"BLANK\")",
          "",
          "[Added Lines]",
          "808:             is_symbol(assembly[i + 1]) or isinstance(assembly[i + 1], list)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "889:     return changed",
          "892: def _prune_unused_jumpdests(assembly):",
          "893:     changed = False",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "920: # a symbol _sym_x in assembly can either mean to push _sym_x to the stack,",
          "921: # or it can precede a location in code which we want to add to symbol map.",
          "922: # this helper function tells us if we want to add the previous instruction",
          "923: # to the symbol map.",
          "924: def is_symbol_map_indicator(asm_node):",
          "925:     return asm_node == \"JUMPDEST\"",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "897:     # find all used jumpdests",
          "898:     for i in range(len(assembly) - 1):",
          "900:             used_jumpdests.add(assembly[i])",
          "902:     # delete jumpdests that aren't used",
          "903:     i = 0",
          "904:     while i < len(assembly) - 2:",
          "",
          "[Removed Lines]",
          "899:         if is_symbol(assembly[i]) and assembly[i + 1] != \"JUMPDEST\":",
          "",
          "[Added Lines]",
          "935:         if is_symbol(assembly[i]) and not is_symbol_map_indicator(assembly[i + 1]):",
          "938:     for item in assembly:",
          "939:         if isinstance(item, list) and isinstance(item[0], _DataHeader):",
          "940:             # add symbols used in data sections as they are likely",
          "941:             # used for a jumptable.",
          "942:             for t in item:",
          "943:                 if is_symbol(t):",
          "944:                     used_jumpdests.add(t)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "937: # optimize assembly, in place",
          "938: def _optimize_assembly(assembly):",
          "939:     for x in assembly:",
          "941:             _optimize_assembly(x)",
          "943:     for _ in range(1024):",
          "",
          "[Removed Lines]",
          "940:         if isinstance(x, list):",
          "",
          "[Added Lines]",
          "984:         if isinstance(x, list) and isinstance(x[0], _RuntimeHeader):",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "970:     return ret",
          "973: def assembly_to_evm(assembly, pc_ofst=0, insert_vyper_signature=False):",
          "974:     \"\"\"",
          "975:     Assembles assembly into EVM",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1017: SYMBOL_SIZE = 2  # size of a PUSH instruction for a code symbol",
          "1020: def _data_to_evm(assembly, symbol_map):",
          "1021:     ret = bytearray()",
          "1022:     assert isinstance(assembly[0], _DataHeader)",
          "1023:     for item in assembly[1:]:",
          "1024:         if is_symbol(item):",
          "1025:             symbol = symbol_map[item].to_bytes(SYMBOL_SIZE, \"big\")",
          "1026:             ret.extend(symbol)",
          "1027:         elif isinstance(item, int):",
          "1028:             ret.append(item)",
          "1029:         elif isinstance(item, bytes):",
          "1030:             ret.extend(item)",
          "1031:         else:",
          "1032:             raise ValueError(f\"invalid data {type(item)} {item}\")",
          "1034:     return ret",
          "1037: # predict what length of an assembly [data] node will be in bytecode",
          "1038: def _length_of_data(assembly):",
          "1039:     ret = 0",
          "1040:     assert isinstance(assembly[0], _DataHeader)",
          "1041:     for item in assembly[1:]:",
          "1042:         if is_symbol(item):",
          "1043:             ret += SYMBOL_SIZE",
          "1044:         elif isinstance(item, int):",
          "1045:             assert 0 <= item < 256, f\"invalid data byte {item}\"",
          "1046:             ret += 1",
          "1047:         elif isinstance(item, bytes):",
          "1048:             ret += len(item)",
          "1049:         else:",
          "1050:             raise ValueError(f\"invalid data {type(item)} {item}\")",
          "1052:     return ret",
          "1055: class _RuntimeHeader:",
          "1056:     def __init__(self, label, ctor_mem_size):",
          "1057:         self.label = label",
          "1058:         self.ctor_mem_size = ctor_mem_size",
          "1060:     def __repr__(self):",
          "1061:         return f\"<RUNTIME {self.label} mem @{self.ctor_mem_size}>\"",
          "1064: class _DataHeader:",
          "1065:     def __init__(self, label):",
          "1066:         self.label = label",
          "1068:     def __repr__(self):",
          "1069:         return f\"DATA {self.label}\"",
          "1072: def _relocate_segments(assembly):",
          "1073:     # relocate all data segments to the end, otherwise data could be",
          "1074:     # interpreted as PUSH instructions and mangle otherwise valid jumpdests",
          "1075:     # relocate all runtime segments to the end as well",
          "1076:     data_segments = []",
          "1077:     non_data_segments = []",
          "1078:     code_segments = []",
          "1079:     for t in assembly:",
          "1080:         if isinstance(t, list):",
          "1081:             if isinstance(t[0], _DataHeader):",
          "1082:                 data_segments.append(t)",
          "1083:             else:",
          "1084:                 _relocate_segments(t)  # recurse",
          "1085:                 assert isinstance(t[0], _RuntimeHeader)",
          "1086:                 code_segments.append(t)",
          "1087:         else:",
          "1088:             non_data_segments.append(t)",
          "1089:     assembly.clear()",
          "1090:     assembly.extend(non_data_segments)",
          "1091:     assembly.extend(code_segments)",
          "1092:     assembly.extend(data_segments)",
          "1095: # TODO: change API to split assembly_to_evm and assembly_to_source/symbol_maps",
          "1097:     bytecode, source_maps, _ = assembly_to_evm_with_symbol_map(",
          "1098:         assembly, pc_ofst=pc_ofst, insert_vyper_signature=insert_vyper_signature",
          "1099:     )",
          "1100:     return bytecode, source_maps",
          "1103: def assembly_to_evm_with_symbol_map(assembly, pc_ofst=0, insert_vyper_signature=False):",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "999:         bytecode_suffix += b\"\\xa1\\x65vyper\\x83\" + bytes(list(version_tuple))",
          "1000:         bytecode_suffix += len(bytecode_suffix).to_bytes(2, \"big\")",
          "1004:     # to optimize the size of deploy code - we want to use the smallest",
          "1005:     # PUSH instruction possible which can support all memory symbols",
          "1006:     # (and also works with linear pass symbol resolution)",
          "",
          "[Removed Lines]",
          "1002:     CODE_OFST_SIZE = 2  # size of a PUSH instruction for a code symbol",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1009:     mem_ofst_size, ctor_mem_size = None, None",
          "1010:     max_mem_ofst = 0",
          "1011:     for i, item in enumerate(assembly):",
          "1013:             assert runtime_code is None, \"Multiple subcodes\"",
          "1017:             assert ctor_mem_size is None",
          "1020:             runtime_code_start, runtime_code_end = _runtime_code_offsets(",
          "1021:                 ctor_mem_size, len(runtime_code)",
          "",
          "[Removed Lines]",
          "1012:         if isinstance(item, list):",
          "1014:             runtime_code, runtime_map = assembly_to_evm(item)",
          "1016:             assert item[0].startswith(\"_DEPLOY_MEM_OFST_\")",
          "1018:             ctor_mem_size = int(item[0][len(\"_DEPLOY_MEM_OFST_\") :])",
          "",
          "[Added Lines]",
          "1140:         if isinstance(item, list) and isinstance(item[0], _RuntimeHeader):",
          "1144:             ctor_mem_size = item[0].ctor_mem_size",
          "1146:             runtime_code, runtime_map = assembly_to_evm(item[1:])",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1054:         # update pc",
          "1055:         if is_symbol(item):",
          "1057:                 # Don't increment pc as the symbol itself doesn't go into code",
          "1058:                 if item in symbol_map:",
          "1059:                     raise CompilerPanic(f\"duplicate jumpdest {item}\")",
          "1061:                 symbol_map[item] = pc",
          "1062:             else:",
          "1064:         elif is_mem_sym(item):",
          "1065:             # PUSH<n> item",
          "1066:             pc += mem_ofst_size + 1",
          "",
          "[Removed Lines]",
          "1056:             if assembly[i + 1] == \"JUMPDEST\" or assembly[i + 1] == \"BLANK\":",
          "1063:                 pc += CODE_OFST_SIZE + 1  # PUSH2 highbits lowbits",
          "",
          "[Added Lines]",
          "1184:             if is_symbol_map_indicator(assembly[i + 1]):",
          "1191:                 pc += SYMBOL_SIZE + 1  # PUSH2 highbits lowbits",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1070:             # [_OFST, _sym_foo, bar] -> PUSH2 (foo+bar)",
          "1071:             # [_OFST, _mem_foo, bar] -> PUSHN (foo+bar)",
          "1072:             pc -= 1",
          "1080:             # add source map for all items in the runtime map",
          "1081:             t = adjust_pc_maps(runtime_map, pc)",
          "1082:             for key in line_number_map:",
          "1083:                 line_number_map[key].update(t[key])",
          "1084:             pc += len(runtime_code)",
          "1086:         else:",
          "1087:             pc += 1",
          "",
          "[Removed Lines]",
          "1073:         elif item == \"BLANK\":",
          "1074:             pc += 0",
          "1075:         elif isinstance(item, str) and item.startswith(\"_DEPLOY_MEM_OFST_\"):",
          "1076:             # _DEPLOY_MEM_OFST is assembly magic which will",
          "1077:             # get removed during final assembly-to-bytecode",
          "1078:             pc += 0",
          "1079:         elif isinstance(item, list):",
          "",
          "[Added Lines]",
          "1201:         elif isinstance(item, list) and isinstance(item[0], _RuntimeHeader):",
          "1202:             symbol_map[item[0].label] = pc",
          "1208:         elif isinstance(item, list) and isinstance(item[0], _DataHeader):",
          "1209:             symbol_map[item[0].label] = pc",
          "1210:             pc += _length_of_data(item)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1094:     if runtime_code is not None:",
          "1095:         symbol_map[\"_sym_subcode_size\"] = len(runtime_code)",
          "1105:     # now that all symbols have been resolved, generate bytecode",
          "1106:     # using the symbol map",
          "",
          "[Removed Lines]",
          "1097:     # (NOTE CMC 2022-06-17 this way of generating bytecode did not",
          "1098:     # seem to be a perf hotspot. if it is, may want to use bytearray()",
          "1099:     # instead).",
          "1101:     # TODO refactor into two functions, create posmap and assemble",
          "1103:     o = b\"\"",
          "",
          "[Added Lines]",
          "1222:     # TODO refactor into two functions, create symbol_map and assemble",
          "1224:     ret = bytearray()",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1110:             to_skip -= 1",
          "1111:             continue",
          "1114:             continue  # skippable opcodes",
          "1119:         elif is_symbol(item):",
          "1124:         elif is_mem_sym(item):",
          "1125:             bytecode, _ = assembly_to_evm(PUSH_N(symbol_map[item], n=mem_ofst_size))",
          "1128:         elif is_ofst(item):",
          "1129:             # _OFST _sym_foo 32",
          "1130:             ofst = symbol_map[assembly[i + 1]] + assembly[i + 2]",
          "1132:             bytecode, _ = assembly_to_evm(PUSH_N(ofst, n))",
          "1134:             to_skip = 2",
          "1136:         elif isinstance(item, int):",
          "1138:         elif isinstance(item, str) and item.upper() in get_opcodes():",
          "1140:         elif item[:4] == \"PUSH\":",
          "1142:         elif item[:3] == \"DUP\":",
          "1144:         elif item[:4] == \"SWAP\":",
          "1154:     line_number_map[\"breakpoints\"] = list(line_number_map[\"breakpoints\"])",
          "1155:     line_number_map[\"pc_breakpoints\"] = list(line_number_map[\"pc_breakpoints\"])",
          "",
          "[Removed Lines]",
          "1113:         if item in (\"DEBUG\", \"BLANK\"):",
          "1116:         elif isinstance(item, str) and item.startswith(\"_DEPLOY_MEM_OFST_\"):",
          "1117:             continue",
          "1120:             if assembly[i + 1] != \"JUMPDEST\" and assembly[i + 1] != \"BLANK\":",
          "1121:                 bytecode, _ = assembly_to_evm(PUSH_N(symbol_map[item], n=CODE_OFST_SIZE))",
          "1122:                 o += bytecode",
          "1126:             o += bytecode",
          "1131:             n = mem_ofst_size if is_mem_sym(assembly[i + 1]) else CODE_OFST_SIZE",
          "1133:             o += bytecode",
          "1137:             o += bytes([item])",
          "1139:             o += bytes([get_opcodes()[item.upper()][0]])",
          "1141:             o += bytes([PUSH_OFFSET + int(item[4:])])",
          "1143:             o += bytes([DUP_OFFSET + int(item[3:])])",
          "1145:             o += bytes([SWAP_OFFSET + int(item[4:])])",
          "1146:         elif isinstance(item, list):",
          "1147:             o += runtime_code",
          "1148:         else:",
          "1149:             # Should never reach because, assembly is create in _compile_to_assembly.",
          "1150:             raise Exception(\"Weird symbol in assembly: \" + str(item))  # pragma: no cover",
          "1152:     o += bytecode_suffix",
          "1156:     return o, line_number_map",
          "",
          "[Added Lines]",
          "1234:         if item in (\"DEBUG\",):",
          "1238:             # push a symbol to stack",
          "1239:             if not is_symbol_map_indicator(assembly[i + 1]):",
          "1240:                 bytecode, _ = assembly_to_evm(PUSH_N(symbol_map[item], n=SYMBOL_SIZE))",
          "1241:                 ret.extend(bytecode)",
          "1245:             ret.extend(bytecode)",
          "1250:             n = mem_ofst_size if is_mem_sym(assembly[i + 1]) else SYMBOL_SIZE",
          "1252:             ret.extend(bytecode)",
          "1256:             ret.append(item)",
          "1258:             ret.append(get_opcodes()[item.upper()][0])",
          "1260:             ret.append(PUSH_OFFSET + int(item[4:]))",
          "1262:             ret.append(DUP_OFFSET + int(item[3:]))",
          "1264:             ret.append(SWAP_OFFSET + int(item[4:]))",
          "1265:         elif isinstance(item, list) and isinstance(item[0], _RuntimeHeader):",
          "1266:             ret.extend(runtime_code)",
          "1267:         elif isinstance(item, list) and isinstance(item[0], _DataHeader):",
          "1268:             ret.extend(_data_to_evm(item, symbol_map))",
          "1269:         else:  # pragma: no cover",
          "1270:             # unreachable",
          "1271:             raise ValueError(f\"Weird symbol in assembly: {type(item)} {item}\")",
          "1273:     ret.extend(bytecode_suffix)",
          "1277:     return bytes(ret), line_number_map, symbol_map",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4b44ee7bcc3d9dba74329cf35436a267e4dafa87",
      "candidate_info": {
        "commit_hash": "4b44ee7bcc3d9dba74329cf35436a267e4dafa87",
        "repo": "vyperlang/vyper",
        "commit_url": "https://github.com/vyperlang/vyper/commit/4b44ee7bcc3d9dba74329cf35436a267e4dafa87",
        "files": [
          "examples/stock/company.vy",
          "tests/conftest.py",
          "tests/parser/features/test_immutable.py",
          "tests/parser/features/test_init.py",
          "vyper/ast/signatures/__init__.py",
          "vyper/ast/signatures/function_signature.py",
          "vyper/ast/signatures/interface.py",
          "vyper/codegen/context.py",
          "vyper/codegen/function_definitions/__init__.py",
          "vyper/codegen/function_definitions/common.py",
          "vyper/codegen/function_definitions/external_function.py",
          "vyper/codegen/global_context.py",
          "vyper/codegen/ir_node.py",
          "vyper/codegen/module.py",
          "vyper/codegen/self_call.py",
          "vyper/compiler/output.py",
          "vyper/compiler/phases.py",
          "vyper/compiler/utils.py",
          "vyper/ir/compile_ir.py",
          "vyper/ir/optimizer.py",
          "vyper/semantics/types/function.py",
          "vyper/semantics/validation/annotation.py"
        ],
        "message": "fix: call internal functions from constructor (#2496)\n\nthis commit allows the user to call internal functions from the     \n`__init__` function. it does this by generating a call graph during the\nannotation phase and then generating code for the functions called from\nthe init function for during deploy code generation\n\nthis also has a performance benefit (compiler time) because we can get\nrid of the two-pass method for tracing frame size.\n\nnow that we have a call graph, this commit also introduces a topsort of\nfunctions based on the call dependency tree. this ensures we can compile\nfunctions that call functions that occur after them in the source code.\n\nlastly, this commit also refactors vyper/codegen/module.py so that the\npayable logic is cleaner, it uses properties instead of calculations\nmore, and cleans up properties on IRnode, FunctionSignature and Context.",
        "before_after_code_files": [
          "examples/stock/company.vy||examples/stock/company.vy",
          "tests/conftest.py||tests/conftest.py",
          "tests/parser/features/test_immutable.py||tests/parser/features/test_immutable.py",
          "tests/parser/features/test_init.py||tests/parser/features/test_init.py",
          "vyper/ast/signatures/__init__.py||vyper/ast/signatures/__init__.py",
          "vyper/ast/signatures/function_signature.py||vyper/ast/signatures/function_signature.py",
          "vyper/ast/signatures/interface.py||vyper/ast/signatures/interface.py",
          "vyper/codegen/context.py||vyper/codegen/context.py",
          "vyper/codegen/function_definitions/__init__.py||vyper/codegen/function_definitions/__init__.py",
          "vyper/codegen/function_definitions/common.py||vyper/codegen/function_definitions/common.py",
          "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
          "vyper/codegen/global_context.py||vyper/codegen/global_context.py",
          "vyper/codegen/ir_node.py||vyper/codegen/ir_node.py",
          "vyper/codegen/module.py||vyper/codegen/module.py",
          "vyper/codegen/self_call.py||vyper/codegen/self_call.py",
          "vyper/compiler/output.py||vyper/compiler/output.py",
          "vyper/compiler/phases.py||vyper/compiler/phases.py",
          "vyper/compiler/utils.py||vyper/compiler/utils.py",
          "vyper/ir/compile_ir.py||vyper/ir/compile_ir.py",
          "vyper/ir/optimizer.py||vyper/ir/optimizer.py",
          "vyper/semantics/types/function.py||vyper/semantics/types/function.py",
          "vyper/semantics/validation/annotation.py||vyper/semantics/validation/annotation.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tests/parser/features/test_init.py||tests/parser/features/test_init.py",
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ],
          "candidate": [
            "tests/parser/features/test_init.py||tests/parser/features/test_init.py",
            "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py",
            "vyper/codegen/module.py||vyper/codegen/module.py"
          ]
        }
      },
      "candidate_diff": {
        "examples/stock/company.vy||examples/stock/company.vy": [
          "File: examples/stock/company.vy -> examples/stock/company.vy",
          "--- Hunk 1 ---",
          "[Context before]",
          "39:     # The company holds all the shares at first, but can sell them all.",
          "40:     self.holdings[self.company] = _total_shares",
          "48: # Public function to allow external access to _stockAvailable",
          "49: @view",
          "50: @external",
          "",
          "[Removed Lines]",
          "42: # Find out how much stock the company holds",
          "43: @view",
          "44: @internal",
          "45: def _stockAvailable() -> uint256:",
          "46:     return self.holdings[self.company]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:     # Log the buy event.",
          "70:     log Buy(msg.sender, buy_order)",
          "78: # Public function to allow external access to _getHolding",
          "79: @view",
          "80: @external",
          "",
          "[Removed Lines]",
          "72: # Find out how much stock any address (that's owned by someone) has.",
          "73: @view",
          "74: @internal",
          "75: def _getHolding(_stockholder: address) -> uint256:",
          "76:     return self.holdings[_stockholder]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "135:     # Log the payment event.",
          "136:     log Pay(vendor, amount)",
          "144: # Public function to allow external access to _debt",
          "145: @view",
          "146: @external",
          "",
          "[Removed Lines]",
          "138: # Return the amount in wei that a company has raised in stock offerings.",
          "139: @view",
          "140: @internal",
          "141: def _debt() -> uint256:",
          "142:     return (self.totalShares - self._stockAvailable()) * self.price",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "154: @external",
          "155: def worth() -> uint256:",
          "156:     return self.balance - self._debt()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "140: # Return the amount in wei that a company has raised in stock offerings.",
          "141: @view",
          "142: @internal",
          "143: def _debt() -> uint256:",
          "144:     return (self.totalShares - self._stockAvailable()) * self.price",
          "146: # Find out how much stock the company holds",
          "147: @view",
          "148: @internal",
          "149: def _stockAvailable() -> uint256:",
          "150:     return self.holdings[self.company]",
          "152: # Find out how much stock any address (that's owned by someone) has.",
          "153: @view",
          "154: @internal",
          "155: def _getHolding(_stockholder: address) -> uint256:",
          "156:     return self.holdings[_stockholder]",
          "",
          "---------------"
        ],
        "tests/conftest.py||tests/conftest.py": [
          "File: tests/conftest.py -> tests/conftest.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "116: def get_compiler_gas_estimate(code, func):",
          "118:     if func:",
          "120:     else:",
          "124: def check_gas_on_chain(w3, tester, code, func=None, res=None):",
          "",
          "[Removed Lines]",
          "117:     ir_runtime = compiler.phases.CompilerData(code).ir_runtime",
          "119:         return compiler.utils.build_gas_estimates(ir_runtime)[func] + 22000",
          "121:         return sum(compiler.utils.build_gas_estimates(ir_runtime).values()) + 22000",
          "",
          "[Added Lines]",
          "117:     sigs = compiler.phases.CompilerData(code).function_signatures",
          "119:         return compiler.utils.build_gas_estimates(sigs)[func] + 22000",
          "121:         return sum(compiler.utils.build_gas_estimates(sigs).values()) + 22000",
          "",
          "---------------"
        ],
        "tests/parser/features/test_immutable.py||tests/parser/features/test_immutable.py": [
          "File: tests/parser/features/test_immutable.py -> tests/parser/features/test_immutable.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "212:     c = get_contract(code, *values)",
          "213:     assert c.get_my_list() == expected_values",
          "214:     assert c.get_idx_two() == expected_values[2][2][2]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "217: @pytest.mark.parametrize(\"n\", range(5))",
          "218: def test_internal_function_with_immutables(get_contract, n):",
          "219:     code = \"\"\"",
          "220: @internal",
          "221: def foo() -> uint256:",
          "222:     self.counter += 1",
          "223:     return self.counter",
          "225: counter: uint256",
          "226: VALUE: immutable(uint256)",
          "228: @external",
          "229: def __init__(x: uint256):",
          "230:     self.counter = x",
          "231:     self.foo()",
          "232:     VALUE = self.foo()",
          "233:     self.foo()",
          "235: @external",
          "236: def get_immutable() -> uint256:",
          "237:     return VALUE",
          "238:     \"\"\"",
          "240:     c = get_contract(code, n)",
          "241:     assert c.get_immutable() == n + 2",
          "",
          "---------------"
        ],
        "tests/parser/features/test_init.py||tests/parser/features/test_init.py": [
          "File: tests/parser/features/test_init.py -> tests/parser/features/test_init.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:     assert \"CALLDATALOAD\" in opcodes",
          "22:     assert \"CALLDATACOPY\" not in opcodes[:ir_return_idx]",
          "23:     assert \"CALLDATALOAD\" not in opcodes[:ir_return_idx]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: def test_init_calls_internal(get_contract, assert_compile_failed, assert_tx_failed):",
          "27:     code = \"\"\"",
          "28: foo: public(uint8)",
          "29: @internal",
          "30: def bar(x: uint256) -> uint8:",
          "31:     return convert(x, uint8) * 7",
          "32: @external",
          "33: def __init__(a: uint256):",
          "34:     self.foo = self.bar(a)",
          "36: @external",
          "37: def baz() -> uint8:",
          "38:     return self.bar(convert(self.foo, uint256))",
          "39:     \"\"\"",
          "40:     n = 5",
          "41:     c = get_contract(code, n)",
          "42:     assert c.foo() == n * 7",
          "43:     assert c.baz() == 245  # 5*7*7",
          "45:     n = 6",
          "46:     c = get_contract(code, n)",
          "47:     assert c.foo() == n * 7",
          "48:     assert_tx_failed(lambda: c.baz())",
          "50:     n = 255",
          "51:     assert_compile_failed(lambda: get_contract(code, n))",
          "53:     n = 256",
          "54:     assert_compile_failed(lambda: get_contract(code, n))",
          "",
          "---------------"
        ],
        "vyper/ast/signatures/__init__.py||vyper/ast/signatures/__init__.py": [
          "File: vyper/ast/signatures/__init__.py -> vyper/ast/signatures/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: from .function_signature import FunctionSignature, VariableRecord",
          "",
          "[Added Lines]",
          "1: from .function_signature import FrameInfo, FunctionSignature, VariableRecord",
          "",
          "---------------"
        ],
        "vyper/ast/signatures/function_signature.py||vyper/ast/signatures/function_signature.py": [
          "File: vyper/ast/signatures/function_signature.py -> vyper/ast/signatures/function_signature.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: from vyper.codegen.ir_node import Encoding",
          "8: from vyper.codegen.types import NodeType, parse_type",
          "9: from vyper.exceptions import StructureException",
          "12: # dict from function names to signatures",
          "13: FunctionSignatures = Dict[str, \"FunctionSignature\"]",
          "",
          "[Removed Lines]",
          "10: from vyper.utils import cached_property, mkalphanum",
          "",
          "[Added Lines]",
          "10: from vyper.utils import MemoryPositions, cached_property, mkalphanum",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "66:     ast_source: vy_ast.VyperNode",
          "69: # Function signature object",
          "70: class FunctionSignature:",
          "71:     def __init__(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "69: @dataclass",
          "70: class FrameInfo:",
          "71:     frame_start: int",
          "72:     frame_size: int",
          "74:     @property",
          "75:     def mem_used(self):",
          "76:         return self.frame_size + MemoryPositions.RESERVED_MEMORY",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "84:         self.return_type = return_type",
          "85:         self.mutability = mutability",
          "86:         self.internal = internal",
          "88:         self.nonreentrant_key = nonreentrant_key",
          "89:         self.func_ast_code = func_ast_code",
          "90:         self.is_from_json = is_from_json",
          "92:         self.set_default_args()",
          "94:     def __str__(self):",
          "95:         input_name = \"def \" + self.name + \"(\" + \",\".join([str(arg.typ) for arg in self.args]) + \")\"",
          "96:         if self.return_type:",
          "97:             return input_name + \" -> \" + str(self.return_type) + \":\"",
          "98:         return input_name + \":\"",
          "100:     @cached_property",
          "101:     def _ir_identifier(self) -> str:",
          "102:         # we could do a bit better than this but it just needs to be unique",
          "",
          "[Removed Lines]",
          "87:         self.gas = None",
          "",
          "[Added Lines]",
          "97:         self.gas_estimate = None",
          "104:         # frame info is metadata that will be generated during codegen.",
          "105:         self.frame_info: Optional[FrameInfo] = None",
          "113:     def set_frame_info(self, frame_info):",
          "114:         self.frame_info = frame_info",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "228:     @property",
          "229:     def is_init_func(self):",
          "230:         return self.name == \"__init__\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "248:     @property",
          "249:     def is_regular_function(self):",
          "250:         return not self.is_default_func and not self.is_init_func",
          "",
          "---------------"
        ],
        "vyper/ast/signatures/interface.py||vyper/ast/signatures/interface.py": [
          "File: vyper/ast/signatures/interface.py -> vyper/ast/signatures/interface.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "98: def _get_external_signatures(global_ctx, sig_formatter=lambda x: x):",
          "99:     ret = []",
          "102:         sig = FunctionSignature.from_definition(",
          "104:             sigs=global_ctx._contracts,",
          "105:             custom_structs=global_ctx._structs,",
          "106:         )",
          "",
          "[Removed Lines]",
          "101:     for code in global_ctx._defs:",
          "103:             code,",
          "",
          "[Added Lines]",
          "101:     for func_ast in global_ctx._function_defs:",
          "103:             func_ast,",
          "",
          "---------------"
        ],
        "vyper/codegen/context.py||vyper/codegen/context.py": [
          "File: vyper/codegen/context.py -> vyper/codegen/context.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: from vyper.ast import VyperNode",
          "6: from vyper.ast.signatures.function_signature import VariableRecord",
          "7: from vyper.codegen.types import NodeType",
          "11: class Constancy(enum.Enum):",
          "",
          "[Removed Lines]",
          "8: from vyper.exceptions import CompilerPanic, FunctionDeclarationException",
          "",
          "[Added Lines]",
          "8: from vyper.exceptions import CompilerPanic",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "22:         vars_=None,",
          "23:         sigs=None,",
          "24:         forvars=None,",
          "26:         constancy=Constancy.Mutable,",
          "30:         sig=None,",
          "31:     ):",
          "32:         # In-memory variables, in the form (name, memory location, type)",
          "",
          "[Removed Lines]",
          "25:         return_type=None,",
          "27:         is_internal=False,",
          "28:         is_payable=False,",
          "29:         # method_id=\"\",",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "41:         # Variables defined in for loops, e.g. for i in range(6): ...",
          "42:         self.forvars = forvars or {}",
          "47:         # Is the function constant?",
          "48:         self.constancy = constancy",
          "",
          "[Removed Lines]",
          "44:         # Return type of the function",
          "45:         self.return_type = return_type",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "53:         # Whether we are currently parsing a range expression",
          "54:         self.in_range_expr = False",
          "59:         # List of custom structs that have been defined.",
          "60:         self.structs = global_ctx._structs",
          "64:         # store global context",
          "65:         self.global_ctx = global_ctx",
          "",
          "[Removed Lines]",
          "56:         # Is the function payable?",
          "57:         self.is_payable = is_payable",
          "62:         self.is_internal = is_internal",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "73:         # Not intended to be accessed directly",
          "74:         self.memory_allocator = memory_allocator",
          "79:         self._internal_var_iter = 0",
          "80:         self._scope_id_iter = 0",
          "82:     def is_constant(self):",
          "83:         return self.constancy is Constancy.Constant or self.in_assertion or self.in_range_expr",
          "88:     @property",
          "94:     #",
          "95:     # Context Managers",
          "",
          "[Removed Lines]",
          "76:         self._callee_frame_sizes = []",
          "78:         # Intermented values, used for internal IDs",
          "85:     def register_callee(self, frame_size):",
          "86:         self._callee_frame_sizes.append(frame_size)",
          "89:     def max_callee_frame_size(self):",
          "90:         if len(self._callee_frame_sizes) == 0:",
          "91:             return 0",
          "92:         return max(self._callee_frame_sizes)",
          "",
          "[Added Lines]",
          "64:         # Incremented values, used for internal IDs",
          "71:     # convenience propreties",
          "72:     @property",
          "73:     def is_payable(self):",
          "74:         return self.sig.mutability == \"payable\"",
          "77:     def is_internal(self):",
          "78:         return self.sig.internal",
          "80:     @property",
          "81:     def return_type(self):",
          "82:         return self.sig.return_type",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "248:         the kwargs which need to be filled in by the compiler",
          "249:         \"\"\"",
          "251:         def _check(cond, s=\"Unreachable\"):",
          "252:             if not cond:",
          "253:                 raise CompilerPanic(s)",
          "266:         _check(len(sig.base_args) <= len(args_ir) <= len(sig.args))",
          "268:         # more sanity check, that the types match",
          "269:         # _check(all(l.typ == r.typ for (l, r) in zip(args_ir, sig.args))",
          "",
          "[Removed Lines]",
          "255:         sig = self.sigs[\"self\"].get(method_name, None)",
          "256:         if sig is None:",
          "257:             raise FunctionDeclarationException(",
          "258:                 \"Function does not exist or has not been declared yet \"",
          "259:                 \"(reminder: functions cannot call functions later in code \"",
          "260:                 \"than themselves)\",",
          "261:                 ast_source,",
          "262:             )",
          "264:         _check(sig.internal)  # sanity check",
          "265:         # should have been caught during type checking, sanity check anyway",
          "",
          "[Added Lines]",
          "241:         sig = self.sigs[\"self\"].get(method_name, None)",
          "247:         # these should have been caught during type checking; sanity check",
          "248:         _check(sig is not None)",
          "249:         _check(sig.internal)",
          "",
          "---------------"
        ],
        "vyper/codegen/function_definitions/__init__.py||vyper/codegen/function_definitions/__init__.py": [
          "File: vyper/codegen/function_definitions/__init__.py -> vyper/codegen/function_definitions/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: from .common import generate_ir_for_function, is_default_func, is_initializer  # noqa",
          "",
          "[Added Lines]",
          "1: from .common import generate_ir_for_function  # noqa",
          "",
          "---------------"
        ],
        "vyper/codegen/function_definitions/common.py||vyper/codegen/function_definitions/common.py": [
          "File: vyper/codegen/function_definitions/common.py -> vyper/codegen/function_definitions/common.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: # can't use from [module] import [object] because it breaks mocks in testing",
          "5: import vyper.ast as vy_ast",
          "7: from vyper.codegen.context import Constancy, Context",
          "8: from vyper.codegen.core import check_single_exit, getpos",
          "9: from vyper.codegen.function_definitions.external_function import generate_ir_for_external_function",
          "",
          "[Removed Lines]",
          "2: import copy",
          "3: from typing import Dict, Tuple",
          "6: from vyper.ast.signatures import FunctionSignature",
          "",
          "[Added Lines]",
          "2: from typing import Dict",
          "5: from vyper.ast.signatures import FrameInfo, FunctionSignature",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "14: from vyper.utils import MemoryPositions, calc_mem_gas",
          "27: def generate_ir_for_function(",
          "28:     code: vy_ast.FunctionDef,",
          "30:     global_ctx: GlobalContext,",
          "33:     \"\"\"",
          "34:     Parse a function and produce IR code for the function, includes:",
          "35:         - Signature method if statement",
          "",
          "[Removed Lines]",
          "17: # Is a function the initializer?",
          "18: def is_initializer(code: vy_ast.FunctionDef) -> bool:",
          "19:     return code.name == \"__init__\"",
          "22: # Is a function the default function?",
          "23: def is_default_func(code: vy_ast.FunctionDef) -> bool:",
          "24:     return code.name == \"__default__\"",
          "29:     sigs: Dict[str, Dict[str, FunctionSignature]],",
          "31:     check_nonpayable: bool,",
          "32: ) -> Tuple[IRnode, int, int]:",
          "",
          "[Added Lines]",
          "18:     sigs: Dict[str, Dict[str, FunctionSignature]],  # all signatures in all namespaces",
          "20:     skip_nonpayable_check: bool,",
          "21: ) -> IRnode:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "37:         - Clamping and copying of arguments",
          "38:         - Function body",
          "39:     \"\"\"",
          "46:     # Validate return statements.",
          "47:     check_single_exit(code)",
          "92:     frame_size = context.memory_allocator.size_of_mem - MemoryPositions.RESERVED_MEMORY",
          "94:     if not sig.internal:",
          "95:         # frame_size of external function includes all private functions called",
          "",
          "[Removed Lines]",
          "40:     sig = FunctionSignature.from_definition(",
          "41:         code,",
          "42:         sigs=sigs,",
          "43:         custom_structs=global_ctx._structs,",
          "44:     )",
          "49:     # in order to statically allocate function frames,",
          "50:     # we codegen functions in two passes.",
          "51:     # one pass is just called for its side effects on the context/memory",
          "52:     # allocator. once that pass is finished, we inspect the context",
          "53:     # to see what the max frame size of any callee in the function was,",
          "54:     # then we run the codegen again with the max frame size as",
          "55:     # the start of the frame for this function.",
          "56:     def _run_pass(memory_allocator=None):",
          "57:         # Create a local (per function) context.",
          "58:         if memory_allocator is None:",
          "59:             memory_allocator = MemoryAllocator()",
          "60:         nonlocal sig",
          "61:         sig = copy.deepcopy(sig)  # just in case",
          "62:         context = Context(",
          "63:             vars_=None,",
          "64:             global_ctx=global_ctx,",
          "65:             sigs=sigs,",
          "66:             memory_allocator=memory_allocator,",
          "67:             return_type=sig.return_type,",
          "68:             constancy=Constancy.Constant",
          "69:             if sig.mutability in (\"view\", \"pure\")",
          "70:             else Constancy.Mutable,",
          "71:             is_payable=sig.mutability == \"payable\",",
          "72:             is_internal=sig.internal,",
          "73:             sig=sig,",
          "74:         )",
          "76:         if sig.internal:",
          "77:             o = generate_ir_for_internal_function(code, sig, context)",
          "78:         else:",
          "79:             o = generate_ir_for_external_function(code, sig, context, check_nonpayable)",
          "81:         o.source_pos = getpos(code)",
          "83:         return o, context",
          "85:     _, context = _run_pass(memory_allocator=None)",
          "87:     allocate_start = context.max_callee_frame_size",
          "88:     allocate_start += MemoryPositions.RESERVED_MEMORY",
          "90:     o, context = _run_pass(memory_allocator=MemoryAllocator(allocate_start))",
          "96:         o.total_gas = o.gas + calc_mem_gas(frame_size)",
          "97:     else:",
          "98:         # frame size for internal function does not need to be adjusted",
          "99:         # since it is already accounted for by the caller",
          "100:         o.total_gas = o.gas",
          "102:     o.context = context",
          "103:     o.func_name = sig.name",
          "104:     return o, allocate_start, frame_size",
          "",
          "[Added Lines]",
          "29:     sig = code._metadata[\"signature\"]",
          "34:     callees = code._metadata[\"type\"].called_functions",
          "36:     # we start our function frame from the largest callee frame",
          "37:     max_callee_frame_size = 0",
          "38:     for c in callees:",
          "39:         frame_info = sigs[\"self\"][c.name].frame_info",
          "40:         assert frame_info is not None  # make mypy happy",
          "41:         max_callee_frame_size = max(max_callee_frame_size, frame_info.frame_size)",
          "43:     allocate_start = max_callee_frame_size + MemoryPositions.RESERVED_MEMORY",
          "45:     memory_allocator = MemoryAllocator(allocate_start)",
          "47:     context = Context(",
          "48:         vars_=None,",
          "49:         global_ctx=global_ctx,",
          "50:         sigs=sigs,",
          "51:         memory_allocator=memory_allocator,",
          "52:         constancy=Constancy.Constant if sig.mutability in (\"view\", \"pure\") else Constancy.Mutable,",
          "53:         sig=sig,",
          "54:     )",
          "56:     if sig.internal:",
          "57:         assert skip_nonpayable_check is False",
          "58:         o = generate_ir_for_internal_function(code, sig, context)",
          "59:     else:",
          "60:         if sig.mutability == \"payable\":",
          "61:             assert skip_nonpayable_check is False  # nonsense",
          "62:         o = generate_ir_for_external_function(code, sig, context, skip_nonpayable_check)",
          "64:     o.source_pos = getpos(code)",
          "68:     sig.set_frame_info(FrameInfo(allocate_start, frame_size))",
          "71:         # adjust gas estimate to include cost of mem expansion",
          "73:         # (note: internal functions do not need to adjust gas estimate since",
          "74:         # it is already accounted for by the caller.)",
          "75:         o.add_gas_estimate += calc_mem_gas(sig.frame_info.mem_used)",
          "77:     sig.gas_estimate = o.gas",
          "79:     return o",
          "",
          "---------------"
        ],
        "vyper/codegen/function_definitions/external_function.py||vyper/codegen/function_definitions/external_function.py": [
          "File: vyper/codegen/function_definitions/external_function.py -> vyper/codegen/function_definitions/external_function.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "143: # TODO it would be nice if this returned a data structure which were",
          "144: # amenable to generating a jump table instead of the linear search for",
          "145: # method_id we have now.",
          "147:     # TODO type hints:",
          "148:     # def generate_ir_for_external_function(",
          "149:     #    code: vy_ast.FunctionDef, sig: FunctionSignature, context: Context, check_nonpayable: bool,",
          "",
          "[Removed Lines]",
          "146: def generate_ir_for_external_function(code, sig, context, check_nonpayable):",
          "",
          "[Added Lines]",
          "146: def generate_ir_for_external_function(code, sig, context, skip_nonpayable_check):",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "167:     # generate the main body of the function",
          "168:     body += handle_base_args",
          "171:         # if the contract contains payable functions, but this is not one of them",
          "172:         # add an assertion that the value of the call is zero",
          "173:         body += [[\"assert\", [\"iszero\", \"callvalue\"]]]",
          "",
          "[Removed Lines]",
          "170:     if check_nonpayable and sig.mutability != \"payable\":",
          "",
          "[Added Lines]",
          "170:     if sig.mutability != \"payable\" and not skip_nonpayable_check:",
          "",
          "---------------"
        ],
        "vyper/codegen/global_context.py||vyper/codegen/global_context.py": [
          "File: vyper/codegen/global_context.py -> vyper/codegen/global_context.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: # Datatype to store all global context information.",
          "12: class GlobalContext:",
          "13:     def __init__(self):",
          "14:         # Oh jesus, just leave this. So confusing!",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: # TODO: rename me to ModuleInfo",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "20:         self._structs = dict()",
          "21:         self._events = list()",
          "22:         self._globals = dict()",
          "24:         self._nonrentrant_counter = 0",
          "25:         self._nonrentrant_keys = dict()",
          "27:     # Parse top-level functions and variables",
          "28:     @classmethod",
          "29:     def get_global_context(",
          "31:     ) -> \"GlobalContext\":",
          "32:         # TODO is this a cyclic import?",
          "33:         from vyper.ast.signatures.interface import extract_sigs, get_builtin_interfaces",
          "",
          "[Removed Lines]",
          "23:         self._defs = list()",
          "30:         cls, vyper_module: \"vy_ast.Module\", interface_codes: Optional[InterfaceImports] = None",
          "",
          "[Added Lines]",
          "24:         self._function_defs = list()",
          "30:     # TODO rename me to `from_module`",
          "32:         cls,",
          "33:         vyper_module: \"vy_ast.Module\",",
          "34:         interface_codes: Optional[InterfaceImports] = None,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "51:                 global_ctx.add_globals_and_events(item)",
          "52:             # Function definitions",
          "53:             elif isinstance(item, vy_ast.FunctionDef):",
          "55:             elif isinstance(item, vy_ast.ImportFrom):",
          "56:                 interface_name = item.name",
          "57:                 assigned_name = item.alias or item.name",
          "",
          "[Removed Lines]",
          "54:                 global_ctx._defs.append(item)",
          "",
          "[Added Lines]",
          "58:                 global_ctx._function_defs.append(item)",
          "",
          "---------------"
        ],
        "vyper/codegen/ir_node.py||vyper/codegen/ir_node.py": [
          "File: vyper/codegen/ir_node.py -> vyper/codegen/ir_node.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "53: # Data structure for IR parse tree",
          "54: class IRnode:",
          "55:     repr_show_gas = False",
          "57:     valency: int",
          "58:     args: List[\"IRnode\"]",
          "59:     value: Union[str, int]",
          "",
          "[Removed Lines]",
          "56:     gas: int",
          "",
          "[Added Lines]",
          "56:     _gas: int",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87:         self.encoding = encoding",
          "88:         self.as_hex = AS_HEX_DEFAULT",
          "94:         def _check(condition, err):",
          "95:             if not condition:",
          "96:                 raise CompilerPanic(str(err))",
          "",
          "[Removed Lines]",
          "90:         # Optional annotation properties for gas estimation",
          "91:         self.total_gas = None",
          "92:         self.func_name = None",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "104:         if isinstance(self.value, int):",
          "105:             _check(len(self.args) == 0, \"int can't have arguments\")",
          "106:             self.valency = 1",
          "108:         elif isinstance(self.value, str):",
          "109:             # Opcodes and pseudo-opcodes (e.g. clamp)",
          "110:             if self.value.upper() in get_ir_opcodes():",
          "",
          "[Removed Lines]",
          "107:             self.gas = 5",
          "",
          "[Added Lines]",
          "103:             self._gas = 5",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "116:                 )",
          "117:                 # We add 2 per stack height at push time and take it back",
          "118:                 # at pop time; this makes `break` easier to handle",
          "120:                 for arg in self.args:",
          "121:                     # pop and pass are used to push/pop values on the stack to be",
          "122:                     # consumed for internal functions, therefore we whitelist this as a zero valency",
          "",
          "[Removed Lines]",
          "119:                 self.gas = gas + 2 * (outs - ins)",
          "",
          "[Added Lines]",
          "115:                 self._gas = gas + 2 * (outs - ins)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "126:                         arg.valency == 1 or arg.value in zero_valency_whitelist,",
          "127:                         f\"invalid argument to `{self.value}`: {arg}\",",
          "128:                     )",
          "130:                 # Dynamic gas cost: 8 gas for each byte of logging data",
          "131:                 if self.value.upper()[0:3] == \"LOG\" and isinstance(self.args[1].value, int):",
          "133:                 # Dynamic gas cost: non-zero-valued call",
          "134:                 if self.value.upper() == \"CALL\" and self.args[2].value != 0:",
          "136:                 # Dynamic gas cost: filling sstore (ie. not clearing)",
          "137:                 elif self.value.upper() == \"SSTORE\" and self.args[1].value != 0:",
          "139:                 # Dynamic gas cost: calldatacopy",
          "140:                 elif self.value.upper() in (\"CALLDATACOPY\", \"CODECOPY\", \"EXTCODECOPY\"):",
          "141:                     size = 34000",
          "",
          "[Removed Lines]",
          "129:                     self.gas += arg.gas",
          "132:                     self.gas += self.args[1].value * 8",
          "135:                     self.gas += 34000",
          "138:                     self.gas += 15000",
          "",
          "[Added Lines]",
          "125:                     self._gas += arg.gas",
          "128:                     self._gas += self.args[1].value * 8",
          "131:                     self._gas += 34000",
          "134:                     self._gas += 15000",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "143:                     size_arg = self.args[size_arg_index]",
          "144:                     if isinstance(size_arg.value, int):",
          "145:                         size = size_arg.value",
          "147:                 # Gas limits in call",
          "148:                 if self.value.upper() == \"CALL\" and isinstance(self.args[0].value, int):",
          "150:             # If statements",
          "151:             elif self.value == \"if\":",
          "152:                 if len(self.args) == 3:",
          "154:                 if len(self.args) == 2:",
          "156:                 _check(",
          "157:                     self.args[0].valency > 0,",
          "158:                     f\"zerovalent argument as a test to an if statement: {self.args[0]}\",",
          "",
          "[Removed Lines]",
          "146:                     self.gas += ceil32(size) // 32 * 3",
          "149:                     self.gas += self.args[0].value",
          "153:                     self.gas = self.args[0].gas + max(self.args[1].gas, self.args[2].gas) + 3",
          "155:                     self.gas = self.args[0].gas + self.args[1].gas + 17",
          "",
          "[Added Lines]",
          "142:                     self._gas += ceil32(size) // 32 * 3",
          "145:                     self._gas += self.args[0].value",
          "149:                     self._gas = self.args[0].gas + max(self.args[1].gas, self.args[2].gas) + 3",
          "151:                     self._gas = self.args[0].gas + self.args[1].gas + 17",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "171:                     f\"zerovalent argument to with statement: {self.args[1]}\",",
          "172:                 )",
          "173:                 self.valency = self.args[2].valency",
          "175:             # Repeat statements: repeat <index_name> <startval> <rounds> <rounds_bound> <body>",
          "176:             elif self.value == \"repeat\":",
          "177:                 _check(",
          "",
          "[Removed Lines]",
          "174:                 self.gas = sum([arg.gas for arg in self.args]) + 5",
          "",
          "[Added Lines]",
          "170:                 self._gas = sum([arg.gas for arg in self.args]) + 5",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "195:                 self.valency = 0",
          "199:                 int_bound = int(repeat_bound.value)",
          "202:                 if repeat_count != repeat_bound:",
          "203:                     # gas for assert(repeat_count <= repeat_bound)",
          "206:             # Seq statements: seq <statement> <statement> ...",
          "207:             elif self.value == \"seq\":",
          "208:                 self.valency = self.args[-1].valency if self.args else 0",
          "211:             # GOTO is a jump with args",
          "212:             # e.g. (goto my_label x y z) will push x y and z onto the stack,",
          "",
          "[Removed Lines]",
          "197:                 self.gas = counter_ptr.gas + start.gas",
          "198:                 self.gas += 3  # gas for repeat_bound",
          "200:                 self.gas += int_bound * (body.gas + 50) + 30",
          "204:                     self.gas += 18",
          "209:                 self.gas = sum([arg.gas for arg in self.args]) + 30",
          "",
          "[Added Lines]",
          "193:                 self._gas = counter_ptr.gas + start.gas",
          "194:                 self._gas += 3  # gas for repeat_bound",
          "196:                 self._gas += int_bound * (body.gas + 50) + 30",
          "200:                     self._gas += 18",
          "205:                 self._gas = sum([arg.gas for arg in self.args]) + 30",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "219:                     )",
          "221:                 self.valency = 0",
          "223:             elif self.value == \"label\":",
          "224:                 if not self.args[1].value == \"var_list\":",
          "225:                     raise CodegenPanic(f\"2nd argument to label must be var_list, {self}\")",
          "226:                 self.valency = 0",
          "228:             # var_list names a variable number stack variables",
          "229:             elif self.value == \"var_list\":",
          "230:                 for arg in self.args:",
          "231:                     if not isinstance(arg.value, str) or len(arg.args) > 0:",
          "232:                         raise CodegenPanic(f\"var_list only takes strings: {self.args}\")",
          "233:                 self.valency = 0",
          "236:             # Multi statements: multi <expr> <expr> ...",
          "237:             elif self.value == \"multi\":",
          "",
          "[Removed Lines]",
          "222:                 self.gas = sum([arg.gas for arg in self.args])",
          "227:                 self.gas = 1 + sum(t.gas for t in self.args)",
          "234:                 self.gas = 0",
          "",
          "[Added Lines]",
          "218:                 self._gas = sum([arg.gas for arg in self.args])",
          "223:                 self._gas = 1 + sum(t.gas for t in self.args)",
          "230:                 self._gas = 0",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "240:                         arg.valency > 0, f\"Multi expects all children to not be zerovalent: {arg}\"",
          "241:                     )",
          "242:                 self.valency = sum([arg.valency for arg in self.args])",
          "244:             elif self.value == \"deploy\":",
          "245:                 self.valency = 0",
          "247:             # Stack variables",
          "248:             else:",
          "249:                 self.valency = 1",
          "251:         elif self.value is None:",
          "252:             self.valency = 1",
          "253:             # None IRnodes always get compiled into something else, e.g.",
          "254:             # mzero or PUSH1 0, and the gas will get re-estimated then.",
          "256:         else:",
          "257:             raise CompilerPanic(f\"Invalid value for IR AST node: {self.value}\")",
          "258:         assert isinstance(self.args, list)",
          "",
          "[Removed Lines]",
          "243:                 self.gas = sum([arg.gas for arg in self.args])",
          "246:                 self.gas = NullAttractor()  # unknown",
          "250:                 self.gas = 3",
          "255:             self.gas = 3",
          "",
          "[Added Lines]",
          "239:                 self._gas = sum([arg.gas for arg in self.args])",
          "242:                 self._gas = NullAttractor()  # unknown",
          "246:                 self._gas = 3",
          "251:             self._gas = 3",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "260:         if valency is not None:",
          "261:             self.valency = valency",
          "265:     # the IR should be cached.",
          "266:     # TODO make this private. turns out usages are all for the caching",
          "",
          "[Removed Lines]",
          "263:         self.gas += self.add_gas_estimate",
          "",
          "[Added Lines]",
          "259:     # TODO would be nice to rename to `gas_estimate` or `gas_bound`",
          "260:     @property",
          "261:     def gas(self):",
          "262:         return self._gas + self.add_gas_estimate",
          "",
          "---------------"
        ],
        "vyper/codegen/module.py||vyper/codegen/module.py": [
          "File: vyper/codegen/module.py -> vyper/codegen/module.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: # a contract.vy -- all functions and constructor",
          "5: from vyper import ast as vy_ast",
          "6: from vyper.ast.signatures.function_signature import FunctionSignature, FunctionSignatures",
          "7: from vyper.codegen.core import shr",
          "13: from vyper.codegen.global_context import GlobalContext",
          "14: from vyper.codegen.ir_node import IRnode",
          "27: def parse_external_interfaces(external_interfaces, global_ctx):",
          "28:     for _interfacename in global_ctx._contracts:",
          "30:         _interface_defs = global_ctx._contracts[_interfacename]",
          "31:         _defnames = [_def.name for _def in _interface_defs]",
          "32:         interface = {}",
          "33:         if len(set(_defnames)) < len(_interface_defs):",
          "34:             raise FunctionDeclarationException(",
          "35:                 \"Duplicate function name: \"",
          "",
          "[Removed Lines]",
          "3: from typing import List, Tuple, Union",
          "8: from vyper.codegen.function_definitions import (",
          "9:     generate_ir_for_function,",
          "10:     is_default_func,",
          "11:     is_initializer,",
          "12: )",
          "15: from vyper.exceptions import (",
          "16:     EventDeclarationException,",
          "17:     FunctionDeclarationException,",
          "18:     StructureException,",
          "19: )",
          "20: from vyper.semantics.types.function import FunctionVisibility, StateMutability",
          "22: # TODO remove this check",
          "23: if not hasattr(vy_ast, \"AnnAssign\"):",
          "24:     raise Exception(\"Requires python 3.6 or higher for annotation support\")",
          "29:         # TODO factor me into helper function",
          "",
          "[Added Lines]",
          "3: from typing import Any, Dict, List, Optional, Tuple",
          "8: from vyper.codegen.function_definitions import generate_ir_for_function",
          "11: from vyper.exceptions import CompilerPanic, FunctionDeclarationException, StructureException",
          "12: from vyper.semantics.types.function import StateMutability",
          "15: def _topsort_helper(functions, lookup):",
          "16:     #  single pass to get a global topological sort of functions (so that each",
          "17:     # function comes after each of its callees). may have duplicates, which get",
          "18:     # filtered out in _topsort()",
          "20:     ret = []",
          "21:     for f in functions:",
          "22:         # called_functions is a list of ContractFunctions, need to map",
          "23:         # back to FunctionDefs.",
          "24:         callees = [lookup[t.name] for t in f._metadata[\"type\"].called_functions]",
          "25:         ret.extend(_topsort_helper(callees, lookup))",
          "26:         ret.append(f)",
          "28:     return ret",
          "31: def _topsort(functions):",
          "32:     lookup = {f.name: f for f in functions}",
          "33:     # strip duplicates",
          "34:     return list(dict.fromkeys(_topsort_helper(functions, lookup)))",
          "37: # TODO this should really live in GlobalContext",
          "43:         # CMC 2022-05-06: TODO this seems like dead code",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:     return external_interfaces",
          "141:     else:",
          "151:     # ensure the external jumptable section gets closed out",
          "152:     # (for basic block hygiene and also for zksync interpreter)",
          "",
          "[Removed Lines]",
          "71: def parse_regular_functions(",
          "72:     regular_functions, sigs, external_interfaces, global_ctx, default_function, init_function",
          "73: ):",
          "74:     # check for payable/nonpayable external functions to optimize nonpayable assertions",
          "75:     func_types = [i._metadata[\"type\"] for i in global_ctx._defs]",
          "76:     mutabilities = [i.mutability for i in func_types if i.visibility == FunctionVisibility.EXTERNAL]",
          "77:     has_payable = any(i == StateMutability.PAYABLE for i in mutabilities)",
          "78:     has_nonpayable = any(i != StateMutability.PAYABLE for i in mutabilities)",
          "80:     is_default_payable = (",
          "81:         default_function is not None",
          "82:         and default_function._metadata[\"type\"].mutability == StateMutability.PAYABLE",
          "83:     )",
          "85:     # TODO streamline the nonpayable check logic",
          "87:     # when a contract has a payable default function and at least one nonpayable",
          "88:     # external function, we must perform the nonpayable check on every function",
          "89:     check_per_function = is_default_payable and has_nonpayable",
          "91:     # generate IR for regular functions",
          "92:     payable_funcs = []",
          "93:     nonpayable_funcs = []",
          "94:     internal_funcs = []",
          "95:     add_gas = 0",
          "97:     for func_node in regular_functions:",
          "98:         func_type = func_node._metadata[\"type\"]",
          "99:         func_ir, frame_start, frame_size = generate_ir_for_function(",
          "100:             func_node, {**{\"self\": sigs}, **external_interfaces}, global_ctx, check_per_function",
          "101:         )",
          "103:         if func_type.visibility == FunctionVisibility.INTERNAL:",
          "104:             internal_funcs.append(func_ir)",
          "106:         elif func_type.mutability == StateMutability.PAYABLE:",
          "107:             add_gas += 30  # CMC 20210910 why?",
          "108:             payable_funcs.append(func_ir)",
          "110:         else:",
          "111:             add_gas += 30  # CMC 20210910 why?",
          "112:             nonpayable_funcs.append(func_ir)",
          "114:         func_ir.total_gas += add_gas",
          "116:         # update sigs with metadata gathered from compiling the function so that",
          "117:         # we can handle calls to self",
          "118:         # TODO we only need to do this for internal functions; external functions",
          "119:         # cannot be called via `self`",
          "120:         sig = FunctionSignature.from_definition(func_node, external_interfaces, global_ctx._structs)",
          "121:         sig.gas = func_ir.total_gas",
          "122:         sig.frame_start = frame_start",
          "123:         sig.frame_size = frame_size",
          "124:         sigs[sig.name] = sig",
          "126:     # generate IR for fallback function",
          "127:     if default_function:",
          "128:         fallback_ir, _frame_start, _frame_size = generate_ir_for_function(",
          "129:             default_function,",
          "130:             {**{\"self\": sigs}, **external_interfaces},",
          "131:             global_ctx,",
          "132:             # include a nonpayble check here if the contract only has a default function",
          "133:             check_per_function or not regular_functions,",
          "134:         )",
          "135:     else:",
          "136:         fallback_ir = IRnode.from_list([\"revert\", 0, 0], typ=None, annotation=\"Default function\")",
          "138:     if check_per_function:",
          "139:         external_seq = [\"seq\"] + payable_funcs + nonpayable_funcs",
          "142:         # payable functions are placed prior to nonpayable functions",
          "143:         # and seperated by a nonpayable assertion",
          "144:         external_seq = [\"seq\"]",
          "145:         if has_payable:",
          "146:             external_seq += payable_funcs",
          "147:         if has_nonpayable:",
          "148:             external_seq.append([\"assert\", [\"iszero\", \"callvalue\"]])",
          "149:             external_seq += nonpayable_funcs",
          "",
          "[Added Lines]",
          "83: def _is_init_func(func_ast):",
          "84:     return func_ast._metadata[\"signature\"].is_init_func",
          "87: def _is_default_func(func_ast):",
          "88:     return func_ast._metadata[\"signature\"].is_default_func",
          "91: def _is_internal(func_ast):",
          "92:     return func_ast._metadata[\"type\"].is_internal",
          "95: def _is_payable(func_ast):",
          "96:     return func_ast._metadata[\"type\"].mutability == StateMutability.PAYABLE",
          "99: # codegen for all runtime functions + callvalue/calldata checks + method selector routines",
          "100: def _runtime_ir(runtime_functions, all_sigs, global_ctx):",
          "101:     # categorize the runtime functions because we will organize the runtime",
          "102:     # code into the following sections:",
          "103:     # payable functions, nonpayable functions, fallback function, internal_functions",
          "104:     internal_functions = [f for f in runtime_functions if _is_internal(f)]",
          "106:     external_functions = [f for f in runtime_functions if not _is_internal(f)]",
          "107:     default_function = next((f for f in external_functions if _is_default_func(f)), None)",
          "109:     # functions that need to go exposed in the selector section",
          "110:     regular_functions = [f for f in external_functions if not _is_default_func(f)]",
          "111:     payables = [f for f in regular_functions if _is_payable(f)]",
          "112:     nonpayables = [f for f in regular_functions if not _is_payable(f)]",
          "114:     # create a map of the IR functions since they might live in both",
          "115:     # runtime and deploy code (if init function calls them)",
          "116:     internal_functions_map: Dict[str, IRnode] = {}",
          "118:     for func_ast in internal_functions:",
          "119:         func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, False)",
          "120:         internal_functions_map[func_ast.name] = func_ir",
          "122:     # for some reason, somebody may want to deploy a contract with no",
          "123:     # external functions, or more likely, a \"pure data\" contract which",
          "124:     # contains immutables",
          "125:     if len(external_functions) == 0:",
          "126:         # TODO: prune internal functions in this case?",
          "127:         runtime = [\"seq\"] + list(internal_functions_map.values())",
          "128:         return runtime, internal_functions_map",
          "130:     # note: if the user does not provide one, the default fallback function",
          "131:     # reverts anyway. so it does not hurt to batch the payable check.",
          "132:     default_is_nonpayable = default_function is None or not _is_payable(default_function)",
          "134:     # when a contract has a nonpayable default function,",
          "135:     # we can do a single check for all nonpayable functions",
          "136:     batch_payable_check = len(nonpayables) > 0 and default_is_nonpayable",
          "137:     skip_nonpayable_check = batch_payable_check",
          "139:     selector_section = [\"seq\"]",
          "141:     for func_ast in payables:",
          "142:         func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, False)",
          "143:         selector_section.append(func_ir)",
          "145:     if batch_payable_check:",
          "146:         selector_section.append([\"assert\", [\"iszero\", \"callvalue\"]])",
          "148:     for func_ast in nonpayables:",
          "149:         func_ir = generate_ir_for_function(func_ast, all_sigs, global_ctx, skip_nonpayable_check)",
          "150:         selector_section.append(func_ir)",
          "152:     if default_function:",
          "153:         fallback_ir = generate_ir_for_function(",
          "154:             default_function, all_sigs, global_ctx, skip_nonpayable_check",
          "155:         )",
          "157:         fallback_ir = IRnode.from_list([\"revert\", 0, 0], annotation=\"Default function\")",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "154:     # fallback label is the immediate next instruction,",
          "155:     close_selector_section = [\"goto\", \"fallback\"]",
          "159:     runtime = [",
          "160:         \"seq\",",
          "161:         # check that calldatasize is at least 4, otherwise",
          "162:         # calldataload will load zeros (cf. yellow paper).",
          "163:         [\"if\", [\"lt\", \"calldatasize\", 4], [\"goto\", \"fallback\"]],",
          "165:         close_selector_section,",
          "166:         [\"label\", \"fallback\", [\"var_list\"], fallback_ir],",
          "167:     ]",
          "202:     if global_ctx._contracts or global_ctx._interfaces:",
          "231:     if init_function:",
          "",
          "[Removed Lines]",
          "157:     # bytecode is organized by: external functions, fallback fn, internal functions",
          "158:     # this way we save gas and reduce bytecode by not jumping over internal functions",
          "164:         [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), external_seq],",
          "168:     runtime.extend(internal_funcs)",
          "170:     return runtime",
          "173: # Main python parse tree => IR method",
          "174: def parse_tree_to_ir(global_ctx: GlobalContext) -> Tuple[IRnode, IRnode, FunctionSignatures]:",
          "175:     _names_def = [_def.name for _def in global_ctx._defs]",
          "176:     # Checks for duplicate function names",
          "177:     if len(set(_names_def)) < len(_names_def):",
          "178:         raise FunctionDeclarationException(",
          "179:             \"Duplicate function name: \"",
          "180:             f\"{[name for name in _names_def if _names_def.count(name) > 1][0]}\"",
          "181:         )",
          "182:     _names_events = [_event.name for _event in global_ctx._events]",
          "183:     # Checks for duplicate event names",
          "184:     if len(set(_names_events)) < len(_names_events):",
          "185:         raise EventDeclarationException(",
          "186:             f\"\"\"Duplicate event name:",
          "187:             {[name for name in _names_events if _names_events.count(name) > 1][0]}\"\"\"",
          "188:         )",
          "189:     # Initialization function",
          "190:     init_function = next((_def for _def in global_ctx._defs if is_initializer(_def)), None)",
          "191:     # Default function",
          "192:     default_function = next((i for i in global_ctx._defs if is_default_func(i)), None)",
          "194:     regular_functions = [",
          "195:         _def for _def in global_ctx._defs if not is_initializer(_def) and not is_default_func(_def)",
          "196:     ]",
          "198:     sigs: dict = {}",
          "199:     external_interfaces: dict = {}",
          "200:     # Create the main statement",
          "201:     o: List[Union[str, IRnode]] = [\"seq\"]",
          "203:         external_interfaces = parse_external_interfaces(external_interfaces, global_ctx)",
          "205:     init_func_ir = None",
          "206:     if init_function:",
          "207:         init_func_ir, _frame_start, init_frame_size = generate_ir_for_function(",
          "208:             init_function,",
          "209:             {**{\"self\": sigs}, **external_interfaces},",
          "210:             global_ctx,",
          "211:             False,",
          "212:         )",
          "213:         o.append(init_func_ir)",
          "215:     if regular_functions or default_function:",
          "216:         runtime = parse_regular_functions(",
          "217:             regular_functions,",
          "218:             sigs,",
          "219:             external_interfaces,",
          "220:             global_ctx,",
          "221:             default_function,",
          "222:             init_func_ir,",
          "223:         )",
          "224:     else:",
          "225:         # for some reason, somebody may want to deploy a contract with no code,",
          "226:         # or more likely, a \"pure data\" contract which contains immutables",
          "227:         runtime = IRnode.from_list([\"seq\"])",
          "229:     immutables_len = global_ctx.immutable_section_bytes",
          "232:         memsize = init_func_ir.context.memory_allocator.size_of_mem  # type: ignore",
          "233:     else:",
          "234:         memsize = 0",
          "236:     # note: (deploy mem_ofst, code, extra_padding)",
          "237:     o.append([\"deploy\", memsize, runtime, immutables_len])  # type: ignore",
          "239:     return IRnode.from_list(o), IRnode.from_list(runtime), sigs",
          "",
          "[Added Lines]",
          "170:         [\"with\", \"_calldata_method_id\", shr(224, [\"calldataload\", 0]), selector_section],",
          "175:     # TODO: prune unreachable functions?",
          "176:     runtime.extend(internal_functions_map.values())",
          "178:     return runtime, internal_functions_map",
          "181: # take a GlobalContext, which is basically",
          "182: # and generate the runtime and deploy IR, also return the dict of all signatures",
          "183: def generate_ir_for_module(global_ctx: GlobalContext) -> Tuple[IRnode, IRnode, FunctionSignatures]:",
          "184:     # order functions so that each function comes after all of its callees",
          "185:     function_defs = _topsort(global_ctx._function_defs)",
          "187:     # FunctionSignatures for all interfaces defined in this module",
          "188:     all_sigs: Dict[str, FunctionSignatures] = {}",
          "190:         all_sigs = parse_external_interfaces(all_sigs, global_ctx)",
          "192:     init_function: Optional[vy_ast.FunctionDef] = None",
          "193:     sigs: FunctionSignatures = {}",
          "195:     # generate all signatures",
          "196:     # TODO really this should live in GlobalContext",
          "197:     for f in function_defs:",
          "198:         sig = FunctionSignature.from_definition(f, all_sigs, global_ctx._structs)",
          "199:         # add it to the global namespace.",
          "200:         sigs[sig.name] = sig",
          "201:         # a little hacky, eventually FunctionSignature should be",
          "202:         # merged with ContractFunction and we can remove this.",
          "203:         f._metadata[\"signature\"] = sig",
          "205:     assert \"self\" not in all_sigs",
          "206:     all_sigs[\"self\"] = sigs",
          "208:     runtime_functions = [f for f in function_defs if not _is_init_func(f)]",
          "209:     init_function = next((f for f in function_defs if _is_init_func(f)), None)",
          "211:     runtime, internal_functions = _runtime_ir(runtime_functions, all_sigs, global_ctx)",
          "213:     deploy_code: List[Any] = [\"seq\"]",
          "214:     immutables_len = global_ctx.immutable_section_bytes",
          "216:         init_func_ir = generate_ir_for_function(init_function, all_sigs, global_ctx, False)",
          "217:         deploy_code.append(init_func_ir)",
          "219:         # pass the amount of memory allocated for the init function",
          "220:         # so that deployment does not clobber while preparing immutables",
          "221:         # note: (deploy mem_ofst, code, extra_padding)",
          "222:         init_mem_used = init_function._metadata[\"signature\"].frame_info.mem_used",
          "223:         deploy_code.append([\"deploy\", init_mem_used, runtime, immutables_len])",
          "225:         # internal functions come after everything else",
          "226:         for f in init_function._metadata[\"type\"].called_functions:",
          "227:             deploy_code.append(internal_functions[f.name])",
          "229:     else:",
          "230:         if immutables_len != 0:",
          "231:             raise CompilerPanic(\"unreachable\")",
          "232:         deploy_code.append([\"deploy\", 0, runtime, 0])",
          "234:     return IRnode.from_list(deploy_code), IRnode.from_list(runtime), sigs",
          "",
          "---------------"
        ],
        "vyper/codegen/self_call.py||vyper/codegen/self_call.py": [
          "File: vyper/codegen/self_call.py -> vyper/codegen/self_call.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "38:     args_tuple_t = TupleType([x.typ for x in args_ir])",
          "39:     args_as_tuple = IRnode.from_list([\"multi\"] + [x for x in args_ir], typ=args_tuple_t)",
          "44:     if context.is_constant() and sig.mutability not in (\"view\", \"pure\"):",
          "45:         raise StateAccessViolation(",
          "46:             f\"May not call state modifying function \"",
          "",
          "[Removed Lines]",
          "41:     # register callee to help calculate our starting frame offset",
          "42:     context.register_callee(sig.frame_size)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "66:     # note: dst_tuple_t != args_tuple_t",
          "67:     dst_tuple_t = TupleType([arg.typ for arg in sig.args])",
          "70:     # if one of the arguments is a self call, the argument",
          "71:     # buffer could get borked. to prevent against that,",
          "",
          "[Removed Lines]",
          "68:     args_dst = IRnode(sig.frame_start, typ=dst_tuple_t, location=MEMORY)",
          "",
          "[Added Lines]",
          "65:     args_dst = IRnode(sig.frame_info.frame_start, typ=dst_tuple_t, location=MEMORY)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "111:         typ=sig.return_type,",
          "112:         location=MEMORY,",
          "113:         annotation=stmt_expr.get(\"node_source_code\"),",
          "115:     )",
          "116:     o.is_self_call = True",
          "117:     return o",
          "",
          "[Removed Lines]",
          "114:         add_gas_estimate=sig.gas,",
          "",
          "[Added Lines]",
          "111:         add_gas_estimate=sig.gas_estimate,",
          "",
          "---------------"
        ],
        "vyper/compiler/output.py||vyper/compiler/output.py": [
          "File: vyper/compiler/output.py -> vyper/compiler/output.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "108:         ret = vars(sig)",
          "109:         ret[\"return_type\"] = str(ret[\"return_type\"])",
          "110:         ret[\"_ir_identifier\"] = sig._ir_identifier",
          "112:             del ret[attr]",
          "113:         for attr in (\"args\", \"base_args\", \"default_args\"):",
          "114:             if attr in ret:",
          "",
          "[Removed Lines]",
          "111:         for attr in (\"gas\", \"func_ast_code\"):",
          "",
          "[Added Lines]",
          "111:         for attr in (\"gas_estimate\", \"func_ast_code\"):",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "132:     abi = compiler_data.vyper_module_folded._metadata[\"type\"].to_abi_dict()",
          "133:     if compiler_data.show_gas_estimates:",
          "134:         # Add gas estimates for each function to ABI",
          "136:         for func in abi:",
          "137:             try:",
          "138:                 func_signature = func[\"name\"]",
          "",
          "[Removed Lines]",
          "135:         gas_estimates = build_gas_estimates(compiler_data.ir_runtime)",
          "",
          "[Added Lines]",
          "135:         gas_estimates = build_gas_estimates(compiler_data.function_signatures)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "143:             func_name, _, _ = func_signature.partition(\"(\")",
          "144:             # This check ensures we skip __init__ since it has no estimate",
          "145:             if func_name in gas_estimates:",
          "147:                 func[\"gas\"] = gas_estimates[func_name]",
          "148:     return abi",
          "",
          "[Removed Lines]",
          "146:                 # TODO: mutation",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "vyper/compiler/phases.py||vyper/compiler/phases.py": [
          "File: vyper/compiler/phases.py -> vyper/compiler/phases.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "284:         IR to generate deployment bytecode",
          "285:         IR to generate runtime bytecode",
          "286:     \"\"\"",
          "288:     if not no_optimize:",
          "289:         ir_nodes = optimizer.optimize(ir_nodes)",
          "290:         ir_runtime = optimizer.optimize(ir_runtime)",
          "",
          "[Removed Lines]",
          "287:     ir_nodes, ir_runtime, function_sigs = module.parse_tree_to_ir(global_ctx)",
          "",
          "[Added Lines]",
          "287:     ir_nodes, ir_runtime, function_sigs = module.generate_ir_for_module(global_ctx)",
          "",
          "---------------"
        ],
        "vyper/compiler/utils.py||vyper/compiler/utils.py": [
          "File: vyper/compiler/utils.py -> vyper/compiler/utils.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: def expand_source_map(compressed_map: str) -> list:",
          "",
          "[Removed Lines]",
          "1: from vyper.codegen.ir_node import IRnode",
          "4: def build_gas_estimates(ir_runtime: IRnode) -> dict:",
          "5:     gas_estimates: dict = {}",
          "7:     external_sub = next((i for i in ir_runtime.args if i.value == \"with\"), None)",
          "8:     if external_sub:",
          "9:         for func_ir in external_sub.args[-1].args:",
          "10:             if func_ir.func_name is not None:",
          "11:                 gas_estimates[func_ir.func_name] = func_ir.total_gas",
          "13:     return gas_estimates",
          "",
          "[Added Lines]",
          "1: from typing import Dict",
          "3: from vyper.ast.signatures import FunctionSignature",
          "6: def build_gas_estimates(function_sigs: Dict[str, FunctionSignature]) -> dict:",
          "7:     # note: `.gas_estimate` is added to FunctionSignature",
          "8:     # in vyper/codegen/function_definitions/common.py",
          "9:     return {k: v.gas_estimate for (k, v) in function_sigs.items()}",
          "",
          "---------------"
        ],
        "vyper/ir/compile_ir.py||vyper/ir/compile_ir.py": [
          "File: vyper/ir/compile_ir.py -> vyper/ir/compile_ir.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "510:         assert isinstance(padding, int), \"non-int padding\"",
          "512:         begincode = mksymbol(\"runtime_begin\")",
          "515:         o = []",
          "",
          "[Removed Lines]",
          "513:         subcode = _compile_to_assembly(ir, {}, existing_labels, None, 0)",
          "",
          "[Added Lines]",
          "514:         subcode = _compile_to_assembly(ir)",
          "",
          "---------------"
        ],
        "vyper/ir/optimizer.py||vyper/ir/optimizer.py": [
          "File: vyper/ir/optimizer.py -> vyper/ir/optimizer.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "182:         add_gas_estimate=add_gas_estimate,",
          "183:         valency=valency,",
          "184:     )",
          "189:     return ret",
          "",
          "[Removed Lines]",
          "185:     if node.total_gas is not None:",
          "186:         ret.total_gas = node.total_gas - node.gas + ret.gas",
          "187:         ret.func_name = node.func_name",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "vyper/semantics/types/function.py||vyper/semantics/types/function.py": [
          "File: vyper/semantics/types/function.py -> vyper/semantics/types/function.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: import re",
          "2: import warnings",
          "3: from collections import OrderedDict",
          "6: from vyper import ast as vy_ast",
          "7: from vyper.ast.validation import validate_call_args",
          "",
          "[Removed Lines]",
          "4: from typing import Any, Dict, List, Optional, Tuple",
          "",
          "[Added Lines]",
          "4: from typing import Any, Dict, List, Optional, Set, Tuple",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "122:         self.mutability = state_mutability",
          "123:         self.nonreentrant = nonreentrant",
          "125:     def __repr__(self):",
          "126:         arg_types = \",\".join(repr(a) for a in self.arguments.values())",
          "127:         return f\"contract function {self.name}({arg_types})\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "125:         # a list of internal functions this function calls",
          "126:         self.called_functions: Set[\"ContractFunction\"] = set()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "397:             state_mutability=StateMutability.VIEW,",
          "398:         )",
          "400:     @property",
          "401:     def method_ids(self) -> Dict[str, int]:",
          "402:         \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "403:     @property",
          "404:     def is_external(self) -> bool:",
          "405:         return self.visibility == FunctionVisibility.EXTERNAL",
          "407:     @property",
          "408:     def is_internal(self) -> bool:",
          "409:         return self.visibility == FunctionVisibility.INTERNAL",
          "",
          "---------------"
        ],
        "vyper/semantics/validation/annotation.py||vyper/semantics/validation/annotation.py": [
          "File: vyper/semantics/validation/annotation.py -> vyper/semantics/validation/annotation.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "50:     def __init__(self, fn_node: vy_ast.FunctionDef, namespace: dict) -> None:",
          "51:         self.func = fn_node._metadata[\"type\"]",
          "52:         self.namespace = namespace",
          "55:     def visit(self, node):",
          "56:         super().visit(node)",
          "",
          "[Removed Lines]",
          "53:         self.expr_visitor = ExpressionAnnotationVisitor()",
          "",
          "[Added Lines]",
          "53:         self.expr_visitor = ExpressionAnnotationVisitor(self.func)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "102:     ignored_types = ()",
          "104:     def visit(self, node, type_=None):",
          "105:         # the statement visitor sometimes passes type information about expressions",
          "106:         super().visit(node, type_)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "104:     def __init__(self, fn_node: ContractFunction):",
          "105:         self.func = fn_node",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "128:         node_type = type_ or call_type.fetch_call_return(node)",
          "129:         node._metadata[\"type\"] = node_type",
          "130:         self.visit(node.func)",
          "131:         if isinstance(call_type, (Event, ContractFunction)):",
          "133:             for arg, arg_type in zip(node.args, list(call_type.arguments.values())):",
          "134:                 self.visit(arg, arg_type)",
          "135:         elif isinstance(call_type, StructPrimitive):",
          "",
          "[Removed Lines]",
          "132:             # events and internal function calls",
          "",
          "[Added Lines]",
          "135:         if isinstance(call_type, ContractFunction) and call_type.is_internal:",
          "136:             self.func.called_functions.add(call_type)",
          "139:             # events and function calls",
          "",
          "---------------"
        ]
      }
    }
  ]
}
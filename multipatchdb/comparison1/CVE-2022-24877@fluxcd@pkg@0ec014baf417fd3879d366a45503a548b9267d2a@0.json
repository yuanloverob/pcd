{
  "cve_id": "CVE-2022-24877",
  "cve_desc": "Flux is an open and extensible continuous delivery solution for Kubernetes. Path Traversal in the kustomize-controller via a malicious `kustomization.yaml` allows an attacker to expose sensitive data from the controller\u2019s pod filesystem and possibly privilege escalation in multi-tenancy deployments. Workarounds include automated tooling in the user's CI/CD pipeline to validate `kustomization.yaml` files conform with specific policies. This vulnerability is fixed in kustomize-controller v0.24.0 and included in flux2 v0.29.0.",
  "repo": "fluxcd/pkg",
  "patch_hash": "0ec014baf417fd3879d366a45503a548b9267d2a",
  "patch_info": {
    "commit_hash": "0ec014baf417fd3879d366a45503a548b9267d2a",
    "repo": "fluxcd/pkg",
    "commit_url": "https://github.com/fluxcd/pkg/commit/0ec014baf417fd3879d366a45503a548b9267d2a",
    "files": [
      "kustomize/filesys/fs_secure.go",
      "kustomize/filesys/fs_secure_test.go"
    ],
    "message": "kustomize: introduce secure FS implementation\n\nThis implementation functions as a drop-in replacement for Kustomize's\nown `fsOnDisk`, and asserts any path it handles to be inside root.\n\nIn essence, the whole file system is now restricted like\nloader.RestrictionRootOnly would, but while allowing root to differ\nfrom the top Kustomization directory.\n\nThe main reason to put the constraint in the file system implementation\nis because the current Krusty API does not allow to configure a custom\nload restrictor, but does allow injecting a custom FS.\n\nSigned-off-by: Hidde Beydals <hello@hidde.co>",
    "before_after_code_files": [
      "kustomize/filesys/fs_secure.go||kustomize/filesys/fs_secure.go",
      "kustomize/filesys/fs_secure_test.go||kustomize/filesys/fs_secure_test.go"
    ]
  },
  "patch_diff": {
    "kustomize/filesys/fs_secure.go||kustomize/filesys/fs_secure.go": [
      "File: kustomize/filesys/fs_secure.go -> kustomize/filesys/fs_secure.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: Copyright 2022 The Flux authors",
      "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
      "5: you may not use this file except in compliance with the License.",
      "6: You may obtain a copy of the License at",
      "8:     http://www.apache.org/licenses/LICENSE-2.0",
      "10: Unless required by applicable law or agreed to in writing, software",
      "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
      "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
      "13: See the License for the specific language governing permissions and",
      "14: limitations under the License.",
      "17: package filesys",
      "19: import (",
      "20:  \"fmt\"",
      "21:  \"os\"",
      "22:  \"path/filepath\"",
      "24:  \"sigs.k8s.io/kustomize/kyaml/filesys\"",
      "25: )",
      "29: func MakeFsOnDiskSecure(root string) (filesys.FileSystem, error) {",
      "30:  unsafeFS := filesys.MakeFsOnDisk()",
      "31:  cleanedAbs, _, err := unsafeFS.CleanedAbs(root)",
      "32:  if err != nil {",
      "33:   return nil, err",
      "34:  }",
      "35:  return fsSecure{root: cleanedAbs, unsafeFS: unsafeFS}, nil",
      "36: }",
      "40: type fsSecure struct {",
      "41:  root     filesys.ConfirmedDir",
      "42:  unsafeFS filesys.FileSystem",
      "43: }",
      "47: type ConstraintError struct {",
      "48:  Op   string",
      "49:  Path string",
      "50:  Err  error",
      "51: }",
      "53: func (e *ConstraintError) Error() string {",
      "54:  return \"fs-security-constraint \" + e.Op + \" \" + e.Path + \": \" + e.Err.Error()",
      "55: }",
      "57: func (e *ConstraintError) Unwrap() error { return e.Err }",
      "62: func (fs fsSecure) Create(path string) (filesys.File, error) {",
      "63:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
      "64:   return nil, &ConstraintError{Op: \"create\", Path: path, Err: err}",
      "65:  }",
      "66:  return fs.unsafeFS.Create(path)",
      "67: }",
      "72: func (fs fsSecure) Mkdir(path string) error {",
      "73:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
      "74:   return &ConstraintError{Op: \"mkdir\", Path: path, Err: err}",
      "75:  }",
      "76:  return fs.unsafeFS.Mkdir(path)",
      "77: }",
      "82: func (fs fsSecure) MkdirAll(path string) error {",
      "83:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
      "84:   return &ConstraintError{Op: \"mkdir\", Path: path, Err: err}",
      "85:  }",
      "86:  return fs.unsafeFS.MkdirAll(path)",
      "87: }",
      "92: func (fs fsSecure) RemoveAll(path string) error {",
      "93:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
      "94:   return &ConstraintError{Op: \"remove\", Path: path, Err: err}",
      "95:  }",
      "96:  return fs.unsafeFS.RemoveAll(path)",
      "97: }",
      "102: func (fs fsSecure) Open(path string) (filesys.File, error) {",
      "103:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
      "104:   return nil, &ConstraintError{Op: \"open\", Path: path, Err: err}",
      "105:  }",
      "106:  return fs.unsafeFS.Open(path)",
      "107: }",
      "112: func (fs fsSecure) IsDir(path string) bool {",
      "113:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
      "114:   return false",
      "115:  }",
      "116:  return fs.unsafeFS.IsDir(path)",
      "117: }",
      "122: func (fs fsSecure) ReadDir(path string) ([]string, error) {",
      "123:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
      "124:   return nil, &ConstraintError{Op: \"open\", Path: path, Err: err}",
      "125:  }",
      "126:  return fs.unsafeFS.ReadDir(path)",
      "127: }",
      "134: func (fs fsSecure) CleanedAbs(path string) (filesys.ConfirmedDir, string, error) {",
      "135:  d, f, err := fs.unsafeFS.CleanedAbs(path)",
      "136:  if err != nil {",
      "137:   return d, f, err",
      "138:  }",
      "139:  if !d.HasPrefix(fs.root) {",
      "140:   return \"\", \"\", &ConstraintError{Op: \"abs\", Path: path, Err: rootConstraintErr(path, fs.root.String())}",
      "141:  }",
      "142:  return d, f, err",
      "143: }",
      "148: func (fs fsSecure) Exists(path string) bool {",
      "149:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
      "150:   return false",
      "151:  }",
      "152:  return fs.unsafeFS.Exists(path)",
      "153: }",
      "157: func (fs fsSecure) Glob(pattern string) ([]string, error) {",
      "158:  paths, err := fs.unsafeFS.Glob(pattern)",
      "159:  if err != nil {",
      "160:   return nil, err",
      "161:  }",
      "162:  var securePaths []string",
      "163:  for _, p := range paths {",
      "164:   if err := isSecurePath(fs.unsafeFS, fs.root, p); err == nil {",
      "165:    securePaths = append(securePaths, p)",
      "166:   }",
      "167:  }",
      "168:  return securePaths, err",
      "169: }",
      "174: func (fs fsSecure) ReadFile(path string) ([]byte, error) {",
      "175:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
      "176:   return nil, &ConstraintError{Op: \"read\", Path: path, Err: err}",
      "177:  }",
      "178:  return fs.unsafeFS.ReadFile(path)",
      "179: }",
      "184: func (fs fsSecure) WriteFile(path string, data []byte) error {",
      "185:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
      "186:   return &ConstraintError{Op: \"write\", Path: path, Err: err}",
      "187:  }",
      "188:  return fs.unsafeFS.WriteFile(path, data)",
      "189: }",
      "194: func (fs fsSecure) Walk(path string, walkFn filepath.WalkFunc) error {",
      "195:  wrapWalkFn := func(path string, info os.FileInfo, err error) error {",
      "196:   if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
      "197:    return &ConstraintError{Op: \"walk\", Path: path, Err: err}",
      "198:   }",
      "199:   return walkFn(path, info, err)",
      "200:  }",
      "201:  return fs.unsafeFS.Walk(path, wrapWalkFn)",
      "202: }",
      "207: func isSecurePath(fs filesys.FileSystem, root filesys.ConfirmedDir, path string) error {",
      "208:  absRoot, err := filepath.Abs(path)",
      "209:  if err != nil {",
      "210:   return fmt.Errorf(\"abs path error on '%s': %v\", path, err)",
      "211:  }",
      "212:  d := filesys.ConfirmedDir(filepath.Dir(absRoot))",
      "213:  if fs.Exists(absRoot) {",
      "214:   evaluated, err := filepath.EvalSymlinks(absRoot)",
      "215:   if err != nil {",
      "216:    return fmt.Errorf(\"evalsymlink failure on '%s': %w\", path, err)",
      "217:   }",
      "218:   evaluatedDir := evaluated",
      "219:   if !fs.IsDir(evaluatedDir) {",
      "220:    evaluatedDir = filepath.Dir(evaluatedDir)",
      "221:   }",
      "222:   d = filesys.ConfirmedDir(evaluatedDir)",
      "223:  }",
      "224:  if !d.HasPrefix(root) {",
      "225:   return rootConstraintErr(path, root.String())",
      "226:  }",
      "227:  return nil",
      "228: }",
      "230: func rootConstraintErr(path, root string) error {",
      "231:  return fmt.Errorf(\"path '%s' is not in or below '%s'\", path, root)",
      "232: }",
      "",
      "---------------"
    ],
    "kustomize/filesys/fs_secure_test.go||kustomize/filesys/fs_secure_test.go": [
      "File: kustomize/filesys/fs_secure_test.go -> kustomize/filesys/fs_secure_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2: Copyright 2022 The Flux authors",
      "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
      "5: you may not use this file except in compliance with the License.",
      "6: You may obtain a copy of the License at",
      "8:     http://www.apache.org/licenses/LICENSE-2.0",
      "10: Unless required by applicable law or agreed to in writing, software",
      "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
      "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
      "13: See the License for the specific language governing permissions and",
      "14: limitations under the License.",
      "17: package filesys",
      "19: import (",
      "20:  \"bytes\"",
      "21:  \"io\"",
      "22:  \"math/rand\"",
      "23:  \"os\"",
      "24:  \"path/filepath\"",
      "25:  \"strings\"",
      "26:  \"testing\"",
      "28:  . \"github.com/onsi/gomega\"",
      "29:  \"github.com/onsi/gomega/types\"",
      "30:  \"sigs.k8s.io/kustomize/kyaml/filesys\"",
      "31: )",
      "33: func Test_fsSecure_Create(t *testing.T) {",
      "34:  g := NewWithT(t)",
      "36:  root := t.TempDir()",
      "37:  fs, err := MakeFsOnDiskSecure(root)",
      "38:  g.Expect(err).ToNot(HaveOccurred())",
      "40:  t.Run(\"secure create\", func(t *testing.T) {",
      "41:   g := NewWithT(t)",
      "43:   path := filepath.Join(root, \"file.txt\")",
      "44:   got, err := fs.Create(path)",
      "45:   g.Expect(err).ToNot(HaveOccurred())",
      "46:   g.Expect(got).ToNot(BeNil())",
      "47:   g.Expect(got.Close()).To(Succeed())",
      "48:   g.Expect(fs.Exists(path)).To(BeTrue())",
      "49:  })",
      "51:  t.Run(\"illegal create\", func(t *testing.T) {",
      "52:   g := NewWithT(t)",
      "54:   path := filepath.Join(root, \"../file.txt\")",
      "55:   got, err := fs.Create(\"/file.txt\")",
      "56:   g.Expect(err).To(HaveOccurred())",
      "57:   g.Expect(got).To(BeNil())",
      "58:   g.Expect(fs.Exists(path)).To(BeFalse())",
      "59:  })",
      "60: }",
      "62: func Test_fsSecure_Mkdir(t *testing.T) {",
      "63:  g := NewWithT(t)",
      "65:  root := t.TempDir()",
      "66:  fs, err := MakeFsOnDiskSecure(root)",
      "67:  g.Expect(err).ToNot(HaveOccurred())",
      "69:  t.Run(\"secure mkdir\", func(t *testing.T) {",
      "70:   g := NewWithT(t)",
      "72:   path := filepath.Join(root, \"secure\")",
      "73:   g.Expect(fs.Mkdir(path)).To(Succeed())",
      "74:   g.Expect(path).To(BeADirectory())",
      "75:  })",
      "77:  t.Run(\"illegal mkdir\", func(t *testing.T) {",
      "78:   g := NewWithT(t)",
      "80:   path := filepath.Join(os.TempDir(), \"illegal\")",
      "81:   g.Expect(fs.Mkdir(path)).To(HaveOccurred())",
      "82:   g.Expect(path).ToNot(BeADirectory())",
      "83:   g.Expect(path).ToNot(BeAnExistingFile())",
      "84:  })",
      "85: }",
      "87: func Test_fsSecure_MkdirAll(t *testing.T) {",
      "88:  g := NewWithT(t)",
      "90:  root := t.TempDir()",
      "91:  fs, err := MakeFsOnDiskSecure(root)",
      "92:  g.Expect(err).ToNot(HaveOccurred())",
      "94:  t.Run(\"secure mkdir all\", func(t *testing.T) {",
      "95:   g := NewWithT(t)",
      "97:   path := filepath.Join(root, \"secure\", \"subdir\")",
      "98:   g.Expect(fs.MkdirAll(path)).To(Succeed())",
      "99:   g.Expect(path).To(BeADirectory())",
      "100:  })",
      "102:  t.Run(\"illegal mkdir all\", func(t *testing.T) {",
      "103:   g := NewWithT(t)",
      "105:   path := filepath.Join(root, \"..\", \"..\", \"subdir\")",
      "106:   g.Expect(fs.MkdirAll(path)).To(HaveOccurred())",
      "107:   g.Expect(path).ToNot(BeADirectory())",
      "108:   g.Expect(path).ToNot(BeAnExistingFile())",
      "109:  })",
      "110: }",
      "112: func Test_fsSecure_RemoveAll(t *testing.T) {",
      "113:  g := NewWithT(t)",
      "115:  tmpDir := t.TempDir()",
      "116:  root := filepath.Join(tmpDir, \"workdir\")",
      "118:  g.Expect(os.MkdirAll(filepath.Join(root, \"subdir\"), 0o700)).To(Succeed())",
      "119:  g.Expect(os.WriteFile(filepath.Join(root, \"subdir\", \"file.txt\"), []byte(\"\"), 0o644)).To(Succeed())",
      "120:  g.Expect(os.WriteFile(filepath.Join(tmpDir, \"file.txt\"), []byte(\"\"), 0o644)).To(Succeed())",
      "122:  fs, err := MakeFsOnDiskSecure(root)",
      "123:  g.Expect(err).ToNot(HaveOccurred())",
      "125:  t.Run(\"secure remove all\", func(t *testing.T) {",
      "126:   g := NewWithT(t)",
      "128:   path := filepath.Join(root, \"subdir\")",
      "129:   g.Expect(fs.RemoveAll(path)).To(Succeed())",
      "130:   g.Expect(path).NotTo(BeADirectory())",
      "131:  })",
      "133:  t.Run(\"illegal remove all\", func(t *testing.T) {",
      "134:   g := NewWithT(t)",
      "136:   path := filepath.Join(tmpDir, \"file.txt\")",
      "137:   g.Expect(fs.RemoveAll(path)).To(HaveOccurred())",
      "138:   g.Expect(path).To(BeAnExistingFile())",
      "139:  })",
      "140: }",
      "142: func Test_fsSecure_Open(t *testing.T) {",
      "143:  g := NewWithT(t)",
      "145:  tmpDir := t.TempDir()",
      "147:  root := filepath.Join(tmpDir, \"workdir\")",
      "148:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
      "149:  g.Expect(os.WriteFile(filepath.Join(root, \"file.txt\"), []byte(\"secure\"), 0o644)).To(Succeed())",
      "150:  g.Expect(os.WriteFile(filepath.Join(tmpDir, \"file.txt\"), []byte(\"illegal\"), 0o644)).To(Succeed())",
      "152:  fs, err := MakeFsOnDiskSecure(root)",
      "153:  g.Expect(err).ToNot(HaveOccurred())",
      "155:  t.Run(\"secure open\", func(t *testing.T) {",
      "156:   g := NewWithT(t)",
      "158:   path := filepath.Join(root, \"file.txt\")",
      "159:   f, err := fs.Open(path)",
      "160:   g.Expect(err).ToNot(HaveOccurred())",
      "161:   g.Expect(f).ToNot(BeNil())",
      "162:   var b bytes.Buffer",
      "163:   _, err = io.Copy(&b, f)",
      "164:   g.Expect(err).To(Succeed())",
      "165:   g.Expect(b.String()).To(Equal(\"secure\"))",
      "166:  })",
      "168:  t.Run(\"illegal open\", func(t *testing.T) {",
      "169:   g := NewWithT(t)",
      "171:   path := filepath.Join(tmpDir, \"file.txt\")",
      "172:   f, err := fs.Open(path)",
      "173:   g.Expect(err).To(HaveOccurred())",
      "174:   g.Expect(f).To(BeNil())",
      "175:  })",
      "176: }",
      "178: func Test_fsSecure_IsDir(t *testing.T) {",
      "179:  g := NewWithT(t)",
      "181:  tmpDir := t.TempDir()",
      "183:  root := filepath.Join(tmpDir, \"workdir\")",
      "184:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
      "185:  g.Expect(os.Mkdir(filepath.Join(tmpDir, \"illegal\"), 0o700)).To(Succeed())",
      "187:  fs, err := MakeFsOnDiskSecure(root)",
      "188:  g.Expect(err).ToNot(HaveOccurred())",
      "190:  t.Run(\"secure is dir\", func(t *testing.T) {",
      "191:   g := NewWithT(t)",
      "193:   path := filepath.Join(root, \"\")",
      "194:   g.Expect(fs.IsDir(path)).To(BeTrue())",
      "195:  })",
      "197:  t.Run(\"illegal is dir\", func(t *testing.T) {",
      "198:   g := NewWithT(t)",
      "200:   path := filepath.Join(tmpDir, \"illegal\")",
      "201:   g.Expect(fs.IsDir(path)).To(BeFalse())",
      "202:  })",
      "203: }",
      "205: func Test_fsSecure_ReadDir(t *testing.T) {",
      "206:  g := NewWithT(t)",
      "208:  tmpDir := t.TempDir()",
      "210:  root := filepath.Join(tmpDir, \"workdir\")",
      "211:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
      "212:  g.Expect(os.WriteFile(filepath.Join(root, \"file.txt\"), []byte(\"secure\"), 0o644)).To(Succeed())",
      "213:  g.Expect(os.Mkdir(filepath.Join(tmpDir, \"illegal\"), 0o700)).To(Succeed())",
      "214:  g.Expect(os.WriteFile(filepath.Join(tmpDir, \"illegal\", \"file.txt\"), []byte(\"illegal\"), 0o644)).To(Succeed())",
      "216:  fs, err := MakeFsOnDiskSecure(root)",
      "217:  g.Expect(err).ToNot(HaveOccurred())",
      "219:  t.Run(\"secure read dir\", func(t *testing.T) {",
      "220:   g := NewWithT(t)",
      "222:   path := filepath.Join(root, \"\")",
      "223:   files, err := fs.ReadDir(path)",
      "224:   g.Expect(err).ToNot(HaveOccurred())",
      "225:   g.Expect(files).To(HaveLen(1))",
      "226:   g.Expect(files).To(ContainElement(\"file.txt\"))",
      "227:  })",
      "229:  t.Run(\"illegal is dir\", func(t *testing.T) {",
      "230:   g := NewWithT(t)",
      "232:   path := filepath.Join(tmpDir, \"illegal\")",
      "233:   files, err := fs.ReadDir(path)",
      "234:   g.Expect(err).To(HaveOccurred())",
      "235:   g.Expect(files).To(HaveLen(0))",
      "236:  })",
      "237: }",
      "239: func Test_fsSecure_CleanedAbs(t *testing.T) {",
      "240:  g := NewWithT(t)",
      "242:  tmpDir := t.TempDir()",
      "244:  root := filepath.Join(tmpDir, \"workdir\")",
      "245:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
      "247:  fs, err := MakeFsOnDiskSecure(root)",
      "248:  g.Expect(err).ToNot(HaveOccurred())",
      "250:  t.Run(\"secure cleaned abs\", func(t *testing.T) {",
      "251:   g := NewWithT(t)",
      "253:   d, f, err := fs.CleanedAbs(filepath.Join(root, \"../workdir\"))",
      "254:   g.Expect(err).ToNot(HaveOccurred())",
      "255:   g.Expect(d).To(Equal(filesys.ConfirmedDir(root)))",
      "256:   g.Expect(f).To(BeEmpty())",
      "257:  })",
      "259:  t.Run(\"illegal cleaned abs\", func(t *testing.T) {",
      "260:   g := NewWithT(t)",
      "262:   d, f, err := fs.CleanedAbs(filepath.Join(root, \"../../workdir\"))",
      "263:   g.Expect(err).To(HaveOccurred())",
      "264:   g.Expect(d).To(BeEmpty())",
      "265:   g.Expect(f).To(BeEmpty())",
      "266:  })",
      "267: }",
      "269: func Test_fsSecure_Exists(t *testing.T) {",
      "270:  g := NewWithT(t)",
      "272:  tmpDir := t.TempDir()",
      "274:  root := filepath.Join(tmpDir, \"workdir\")",
      "275:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
      "277:  fs, err := MakeFsOnDiskSecure(root)",
      "278:  g.Expect(err).ToNot(HaveOccurred())",
      "280:  t.Run(\"secure exists\", func(t *testing.T) {",
      "281:   g := NewWithT(t)",
      "283:   g.Expect(fs.Exists(root)).To(BeTrue())",
      "284:  })",
      "286:  t.Run(\"illegal exists\", func(t *testing.T) {",
      "287:   g := NewWithT(t)",
      "289:   g.Expect(fs.Exists(tmpDir)).To(BeFalse())",
      "290:  })",
      "291: }",
      "293: func Test_fsSecure_Glob(t *testing.T) {",
      "294:  g := NewWithT(t)",
      "296:  tmpDir := t.TempDir()",
      "298:  root := filepath.Join(tmpDir, \"workdir\")",
      "299:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
      "301:  g.Expect(os.WriteFile(filepath.Join(root, \"file.txt\"), []byte(\"secure\"), 0o644)).To(Succeed())",
      "302:  g.Expect(os.WriteFile(filepath.Join(tmpDir, \"file.txt\"), []byte(\"illegal\"), 0o644)).To(Succeed())",
      "304:  fs, err := MakeFsOnDiskSecure(root)",
      "305:  g.Expect(err).ToNot(HaveOccurred())",
      "307:  files, err := fs.Glob(filepath.Join(tmpDir, \"*/*.txt\"))",
      "308:  g.Expect(err).ToNot(HaveOccurred())",
      "309:  g.Expect(files).To(ContainElement(filepath.Join(root, \"file.txt\")))",
      "310:  g.Expect(files).ToNot(ContainElement(filepath.Join(tmpDir, \"file.txt\")))",
      "311: }",
      "313: func Test_fsSecure_ReadFile(t *testing.T) {",
      "314:  g := NewWithT(t)",
      "316:  tmpDir := t.TempDir()",
      "318:  root := filepath.Join(tmpDir, \"workdir\")",
      "319:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
      "320:  g.Expect(os.WriteFile(filepath.Join(root, \"file.txt\"), []byte(\"secure\"), 0o644)).To(Succeed())",
      "321:  g.Expect(os.WriteFile(filepath.Join(tmpDir, \"file.txt\"), []byte(\"illegal\"), 0o644)).To(Succeed())",
      "323:  fs, err := MakeFsOnDiskSecure(root)",
      "324:  g.Expect(err).ToNot(HaveOccurred())",
      "326:  t.Run(\"secure read file\", func(t *testing.T) {",
      "327:   g := NewWithT(t)",
      "329:   path := filepath.Join(root, \"file.txt\")",
      "330:   b, err := fs.ReadFile(path)",
      "331:   g.Expect(err).ToNot(HaveOccurred())",
      "332:   g.Expect(b).To(Equal([]byte(\"secure\")))",
      "333:  })",
      "335:  t.Run(\"illegal read file\", func(t *testing.T) {",
      "336:   g := NewWithT(t)",
      "338:   path := filepath.Join(tmpDir, \"file.txt\")",
      "339:   b, err := fs.ReadFile(path)",
      "340:   g.Expect(err).To(HaveOccurred())",
      "341:   g.Expect(b).To(BeNil())",
      "342:  })",
      "343: }",
      "345: func Test_fsSecure_WriteFile(t *testing.T) {",
      "346:  g := NewWithT(t)",
      "348:  tmpDir := t.TempDir()",
      "350:  root := filepath.Join(tmpDir, \"workdir\")",
      "351:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
      "353:  fs, err := MakeFsOnDiskSecure(root)",
      "354:  g.Expect(err).ToNot(HaveOccurred())",
      "356:  t.Run(\"secure write file\", func(t *testing.T) {",
      "357:   g := NewWithT(t)",
      "359:   path := filepath.Join(root, \"file.txt\")",
      "360:   data := []byte(\"secure\")",
      "361:   err := fs.WriteFile(path, data)",
      "362:   g.Expect(err).ToNot(HaveOccurred())",
      "363:   g.Expect(path).To(BeAnExistingFile())",
      "364:   b, err := fs.ReadFile(path)",
      "365:   g.Expect(err).ToNot(HaveOccurred())",
      "366:   g.Expect(b).To(Equal(data))",
      "367:  })",
      "369:  t.Run(\"illegal write file\", func(t *testing.T) {",
      "370:   g := NewWithT(t)",
      "372:   path := filepath.Join(tmpDir, \"file.txt\")",
      "373:   err := fs.WriteFile(path, []byte(\"illegal\"))",
      "374:   g.Expect(err).To(HaveOccurred())",
      "375:   g.Expect(path).ToNot(BeAnExistingFile())",
      "376:  })",
      "377: }",
      "379: func Test_fsSecure_Walk(t *testing.T) {",
      "380:  g := NewWithT(t)",
      "382:  tmpDir := t.TempDir()",
      "384:  root := filepath.Join(tmpDir, \"workdir\")",
      "385:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
      "386:  g.Expect(os.WriteFile(filepath.Join(root, \"file.txt\"), []byte(\"secure\"), 0o644)).To(Succeed())",
      "387:  g.Expect(os.WriteFile(filepath.Join(tmpDir, \"file.txt\"), []byte(\"illegal\"), 0o644)).To(Succeed())",
      "389:  fs, err := MakeFsOnDiskSecure(root)",
      "390:  g.Expect(err).ToNot(HaveOccurred())",
      "392:  t.Run(\"secure walk\", func(t *testing.T) {",
      "393:   g := NewWithT(t)",
      "395:   var walkedPaths []string",
      "396:   walk := func(path string, info os.FileInfo, err error) error {",
      "397:    walkedPaths = append(walkedPaths, path)",
      "398:    return nil",
      "399:   }",
      "400:   g.Expect(fs.Walk(root, walk)).To(Succeed())",
      "401:   g.Expect(walkedPaths).To(Equal([]string{root, filepath.Join(root, \"file.txt\")}))",
      "402:  })",
      "404:  t.Run(\"illegal walk\", func(t *testing.T) {",
      "405:   g := NewWithT(t)",
      "407:   var walkedPaths []string",
      "408:   walk := func(path string, info os.FileInfo, err error) error {",
      "409:    walkedPaths = append(walkedPaths, path)",
      "410:    return nil",
      "411:   }",
      "412:   g.Expect(fs.Walk(tmpDir, walk)).To(HaveOccurred())",
      "413:   g.Expect(walkedPaths).To(BeEmpty())",
      "414:  })",
      "415: }",
      "417: func Test_isSecurePath(t *testing.T) {",
      "418:  type file struct {",
      "419:   name    string",
      "420:   symlink string",
      "421:  }",
      "422:  tests := []struct {",
      "423:   name       string",
      "424:   fs         filesys.FileSystem",
      "425:   rootSuffix string",
      "426:   files      []file",
      "427:   path       string",
      "428:   wantErr    types.GomegaMatcher",
      "429:  }{",
      "430:   {",
      "431:    name:    \"secure non existing path\",",
      "432:    fs:      filesys.MakeFsOnDisk(),",
      "433:    path:    \"<root>/filepath\",",
      "434:    wantErr: Succeed(),",
      "435:   },",
      "436:   {",
      "437:    name:       \"illegal relative path\",",
      "438:    fs:         filesys.MakeFsOnDisk(),",
      "439:    rootSuffix: \"subdir\",",
      "440:    path:       \"../\",",
      "441:    wantErr:    HaveOccurred(),",
      "442:   },",
      "443:   {",
      "444:    name:       \"illegal absolute path\",",
      "445:    fs:         filesys.MakeFsOnDisk(),",
      "446:    rootSuffix: \"subdir\",",
      "447:    path:       \"<root>\",",
      "448:    wantErr:    HaveOccurred(),",
      "449:   },",
      "450:   {",
      "451:    name:       \"relative symlink\",",
      "452:    fs:         filesys.MakeFsOnDisk(),",
      "453:    rootSuffix: \"subdir\",",
      "454:    files: []file{",
      "455:     {name: \"subdir/file.txt\"},",
      "456:     {name: \"subdir/subsubdir/symlink\", symlink: \"../file.txt\"},",
      "457:    },",
      "458:    path:    \"<root>/subdir/subsubdir/symlink\",",
      "459:    wantErr: Succeed(),",
      "460:   },",
      "461:   {",
      "462:    name:       \"absolute symlink\",",
      "463:    fs:         filesys.MakeFsOnDisk(),",
      "464:    rootSuffix: \"subdir\",",
      "465:    files: []file{",
      "466:     {name: \"subdir/file.txt\"},",
      "467:     {name: \"subdir/subsubdir/symlink\", symlink: \"<root>/subdir/file.txt\"},",
      "468:    },",
      "469:    path:    \"<root>/subdir/subsubdir/symlink\",",
      "470:    wantErr: Succeed(),",
      "471:   },",
      "472:   {",
      "473:    name:       \"illegal relative symlink\",",
      "474:    fs:         filesys.MakeFsOnDisk(),",
      "475:    rootSuffix: \"subdir\",",
      "476:    files: []file{",
      "477:     {name: \"file.txt\"},",
      "478:     {name: \"subdir/symlink\", symlink: \"../file.txt\"},",
      "479:    },",
      "480:    path:    \"<root>/subdir/symlink\",",
      "481:    wantErr: HaveOccurred(),",
      "482:   },",
      "483:   {",
      "484:    name:       \"illegal absolute symlink\",",
      "485:    fs:         filesys.MakeFsOnDisk(),",
      "486:    rootSuffix: \"subdir\",",
      "487:    files: []file{",
      "488:     {name: \"file.txt\"},",
      "489:     {name: \"subdir/symlink\", symlink: \"<root>/file.txt\"},",
      "490:    },",
      "491:    path:    \"<root>/subdir/symlink\",",
      "492:    wantErr: HaveOccurred(),",
      "493:   },",
      "494:  }",
      "495:  for _, tt := range tests {",
      "496:   t.Run(tt.name, func(t *testing.T) {",
      "497:    g := NewWithT(t)",
      "499:    root := newTemp()",
      "500:    realRoot := filesys.ConfirmedDir(filepath.Join(root, tt.rootSuffix))",
      "501:    g.Expect(tt.fs.MkdirAll(realRoot.String())).To(Succeed())",
      "502:    t.Cleanup(func() {",
      "503:     g.Expect(tt.fs.RemoveAll(root)).To(Succeed())",
      "504:    })",
      "506:    for _, f := range tt.files {",
      "507:     fPath := filepath.Join(root, f.name)",
      "508:     dir, base := filepath.Split(fPath)",
      "509:     g.Expect(tt.fs.MkdirAll(dir)).To(Succeed())",
      "511:     if symlink := f.symlink; symlink != \"\" {",
      "512:      if strings.HasPrefix(symlink, \"<root>\") {",
      "513:       symlink = strings.Replace(symlink, \"<root>\", root, 1)",
      "514:      }",
      "515:      g.Expect(os.Symlink(symlink, fPath)).To(Succeed())",
      "516:      continue",
      "517:     }",
      "519:     if base != \"\" {",
      "520:      file, err := tt.fs.Create(fPath)",
      "521:      g.Expect(err).ToNot(HaveOccurred())",
      "522:      _, err = file.Write([]byte(f.name + \" data\"))",
      "523:      g.Expect(err).ToNot(HaveOccurred())",
      "524:      g.Expect(file.Close()).To(Succeed())",
      "525:     }",
      "526:    }",
      "528:    path := tt.path",
      "529:    if strings.HasPrefix(path, \"<root>\") {",
      "530:     path = strings.Replace(path, \"<root>\", root, 1)",
      "531:    }",
      "533:    err := isSecurePath(tt.fs, realRoot, path)",
      "534:    g.Expect(err).To(tt.wantErr)",
      "535:   })",
      "536:  }",
      "537: }",
      "539: func newTemp() string {",
      "540:  return filepath.Join(os.TempDir(), \"securefs-\"+randStringBytes(5))",
      "541: }",
      "543: func randStringBytes(n int) string {",
      "544:  const letterBytes = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"",
      "546:  b := make([]byte, n)",
      "547:  for i := range b {",
      "548:   b[i] = letterBytes[rand.Int63()%int64(len(letterBytes))]",
      "549:  }",
      "550:  return string(b)",
      "551: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "fe2d6226b8c6d853619c48131fb5840d048d62e8",
      "candidate_info": {
        "commit_hash": "fe2d6226b8c6d853619c48131fb5840d048d62e8",
        "repo": "fluxcd/pkg",
        "commit_url": "https://github.com/fluxcd/pkg/commit/fe2d6226b8c6d853619c48131fb5840d048d62e8",
        "files": [
          ".github/workflows/build.yaml",
          "kustomize/filesys/fs_secure_test.go"
        ],
        "message": "Resolve symlink for tmp dir\n\nSigned-off-by: Somtochi Onyekwere <somtochionyekwere@gmail.com>",
        "before_after_code_files": [
          "kustomize/filesys/fs_secure_test.go||kustomize/filesys/fs_secure_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kustomize/filesys/fs_secure_test.go||kustomize/filesys/fs_secure_test.go"
          ],
          "candidate": [
            "kustomize/filesys/fs_secure_test.go||kustomize/filesys/fs_secure_test.go"
          ]
        }
      },
      "candidate_diff": {
        "kustomize/filesys/fs_secure_test.go||kustomize/filesys/fs_secure_test.go": [
          "File: kustomize/filesys/fs_secure_test.go -> kustomize/filesys/fs_secure_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: import (",
          "20:  \"bytes\"",
          "21:  \"io\"",
          "22:  \"math/rand\"",
          "23:  \"os\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21:  \"fmt\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34:  t.Run(\"error on root prefixed with allowed prefix\", func(t *testing.T) {",
          "35:   g := NewWithT(t)",
          "38:   matchingDir := filepath.Join(tmpDir, \"subdir\")",
          "39:   g.Expect(os.Mkdir(matchingDir, 0o644)).To(Succeed())",
          "",
          "[Removed Lines]",
          "37:   tmpDir := t.TempDir()",
          "",
          "[Added Lines]",
          "38:   tmpDir, err := testTempDir(t)",
          "39:   g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "48: func Test_fsSecure_Create(t *testing.T) {",
          "49:  g := NewWithT(t)",
          "52:  fs, err := MakeFsOnDiskSecure(root)",
          "53:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "[Removed Lines]",
          "51:  root := t.TempDir()",
          "",
          "[Added Lines]",
          "54:  root, err := testTempDir(t)",
          "55:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "77: func Test_fsSecure_Mkdir(t *testing.T) {",
          "78:  g := NewWithT(t)",
          "81:  fs, err := MakeFsOnDiskSecure(root)",
          "82:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "[Removed Lines]",
          "80:  root := t.TempDir()",
          "",
          "[Added Lines]",
          "84:  root, err := testTempDir(t)",
          "85:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "102: func Test_fsSecure_MkdirAll(t *testing.T) {",
          "103:  g := NewWithT(t)",
          "106:  fs, err := MakeFsOnDiskSecure(root)",
          "107:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "[Removed Lines]",
          "105:  root := t.TempDir()",
          "",
          "[Added Lines]",
          "110:  root, err := testTempDir(t)",
          "111:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "127: func Test_fsSecure_RemoveAll(t *testing.T) {",
          "128:  g := NewWithT(t)",
          "131:  root := filepath.Join(tmpDir, \"workdir\")",
          "133:  g.Expect(os.MkdirAll(filepath.Join(root, \"subdir\"), 0o700)).To(Succeed())",
          "",
          "[Removed Lines]",
          "130:  tmpDir := t.TempDir()",
          "",
          "[Added Lines]",
          "136:  tmpDir, err := testTempDir(t)",
          "137:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "157: func Test_fsSecure_Open(t *testing.T) {",
          "158:  g := NewWithT(t)",
          "162:  root := filepath.Join(tmpDir, \"workdir\")",
          "163:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
          "",
          "[Removed Lines]",
          "160:  tmpDir := t.TempDir()",
          "",
          "[Added Lines]",
          "167:  tmpDir, err := testTempDir(t)",
          "168:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "193: func Test_fsSecure_IsDir(t *testing.T) {",
          "194:  g := NewWithT(t)",
          "198:  root := filepath.Join(tmpDir, \"workdir\")",
          "199:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
          "",
          "[Removed Lines]",
          "196:  tmpDir := t.TempDir()",
          "",
          "[Added Lines]",
          "204:  tmpDir, err := testTempDir(t)",
          "205:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "220: func Test_fsSecure_ReadDir(t *testing.T) {",
          "221:  g := NewWithT(t)",
          "225:  root := filepath.Join(tmpDir, \"workdir\")",
          "226:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
          "",
          "[Removed Lines]",
          "223:  tmpDir := t.TempDir()",
          "",
          "[Added Lines]",
          "232:  tmpDir, err := testTempDir(t)",
          "233:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "254: func Test_fsSecure_CleanedAbs(t *testing.T) {",
          "255:  g := NewWithT(t)",
          "259:  root := filepath.Join(tmpDir, \"workdir\")",
          "260:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
          "",
          "[Removed Lines]",
          "257:  tmpDir := t.TempDir()",
          "",
          "[Added Lines]",
          "267:  tmpDir, err := testTempDir(t)",
          "268:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "292:   prefixedDir, err := os.MkdirTemp(\"\", tmpConfirmedDirPrefix)",
          "293:   g.Expect(err).ToNot(HaveOccurred())",
          "294:   t.Cleanup(func() { _ = os.RemoveAll(prefixedDir) })",
          "296:   d, f, err := fs.CleanedAbs(prefixedDir)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "305:   prefixedDir, err = filepath.EvalSymlinks(prefixedDir)",
          "306:   g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "303: func Test_fsSecure_Exists(t *testing.T) {",
          "304:  g := NewWithT(t)",
          "308:  root := filepath.Join(tmpDir, \"workdir\")",
          "309:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
          "",
          "[Removed Lines]",
          "306:  tmpDir := t.TempDir()",
          "",
          "[Added Lines]",
          "319:  tmpDir, err := testTempDir(t)",
          "320:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "327: func Test_fsSecure_Glob(t *testing.T) {",
          "328:  g := NewWithT(t)",
          "332:  root := filepath.Join(tmpDir, \"workdir\")",
          "333:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
          "",
          "[Removed Lines]",
          "330:  tmpDir := t.TempDir()",
          "",
          "[Added Lines]",
          "344:  tmpDir, err := testTempDir(t)",
          "345:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "347: func Test_fsSecure_ReadFile(t *testing.T) {",
          "348:  g := NewWithT(t)",
          "352:  root := filepath.Join(tmpDir, \"workdir\")",
          "353:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
          "",
          "[Removed Lines]",
          "350:  tmpDir := t.TempDir()",
          "",
          "[Added Lines]",
          "365:  tmpDir, err := testTempDir(t)",
          "366:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "379: func Test_fsSecure_WriteFile(t *testing.T) {",
          "380:  g := NewWithT(t)",
          "384:  root := filepath.Join(tmpDir, \"workdir\")",
          "385:  g.Expect(os.Mkdir(root, 0o700)).To(Succeed())",
          "",
          "[Removed Lines]",
          "382:  tmpDir := t.TempDir()",
          "",
          "[Added Lines]",
          "398:  tmpDir, err := testTempDir(t)",
          "399:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "454:  prefixedDir, err := os.MkdirTemp(\"\", tmpConfirmedDirPrefix)",
          "455:  g.Expect(err).ToNot(HaveOccurred())",
          "456:  t.Cleanup(func() { _ = os.RemoveAll(prefixedDir) })",
          "458:  allowPrefix, err := TmpConfirmedDirPrefix()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "473:  prefixedDir, err = filepath.EvalSymlinks(prefixedDir)",
          "474:  g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "554:   t.Run(tt.name, func(t *testing.T) {",
          "555:    g := NewWithT(t)",
          "558:    realRoot := filesys.ConfirmedDir(filepath.Join(root, tt.rootSuffix))",
          "559:    g.Expect(tt.fs.MkdirAll(realRoot.String())).To(Succeed())",
          "560:    t.Cleanup(func() {",
          "",
          "[Removed Lines]",
          "557:    root := newTemp()",
          "",
          "[Added Lines]",
          "576:    root, err := newTemp()",
          "577:    g.Expect(err).ToNot(HaveOccurred())",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "588:     path = strings.Replace(path, \"<root>\", root, 1)",
          "589:    }",
          "592:    g.Expect(err).To(tt.wantErr)",
          "593:   })",
          "594:  }",
          "",
          "[Removed Lines]",
          "591:    err := isSecurePath(tt.fs, realRoot, path, tt.allowedPrefixes...)",
          "",
          "[Added Lines]",
          "611:    err = isSecurePath(tt.fs, realRoot, path, tt.allowedPrefixes...)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "617:  }",
          "618: }",
          "622: }",
          "624: func randStringBytes(n int) string {",
          "",
          "[Removed Lines]",
          "620: func newTemp() string {",
          "621:  return filepath.Join(os.TempDir(), \"securefs-\"+randStringBytes(5))",
          "",
          "[Added Lines]",
          "640: func newTemp() (string, error) {",
          "641:  tmpDir, err := filepath.EvalSymlinks(os.TempDir())",
          "642:  if err != nil {",
          "643:   return \"\", err",
          "644:  }",
          "645:  return filepath.Join(tmpDir, \"securefs-\"+randStringBytes(5)), nil",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "630:  }",
          "631:  return string(b)",
          "632: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "658: func testTempDir(t *testing.T) (string, error) {",
          "659:  tmpDir := t.TempDir()",
          "661:  tmpDir, err := filepath.EvalSymlinks(tmpDir)",
          "662:  if err != nil {",
          "663:   return \"\", fmt.Errorf(\"error evaluating symlink: '%w'\", err)",
          "664:  }",
          "666:  return tmpDir, err",
          "667: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a2505ae518437cd2bfbee994ba0954fd49a7fa44",
      "candidate_info": {
        "commit_hash": "a2505ae518437cd2bfbee994ba0954fd49a7fa44",
        "repo": "fluxcd/pkg",
        "commit_url": "https://github.com/fluxcd/pkg/commit/a2505ae518437cd2bfbee994ba0954fd49a7fa44",
        "files": [
          "kustomize/filesys/fs_secure.go",
          "kustomize/filesys/fs_secure_test.go"
        ],
        "message": "kustomize/filesys: config of allowed prefixes\n\nThis introduction is required for the build of Kustomizations which\nrefer to remote bases, as the internal load process creates new\ntemporary directories to fetch these into.\n\nBy ensuring the `root` of the FS does not start with an allowed prefix,\nit is not possible for a FS to reach into another FS if the program\nwhich creates them uses a static list.\n\nThis solution is not optimal, and is a signal we need to fork Kustomize\n(and advocate upstream), to simply allow a more diverse configuration\nof loader restrictions. Making this FS implementation obsolete.\n\nSigned-off-by: Hidde Beydals <hello@hidde.co>",
        "before_after_code_files": [
          "kustomize/filesys/fs_secure.go||kustomize/filesys/fs_secure.go",
          "kustomize/filesys/fs_secure_test.go||kustomize/filesys/fs_secure_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kustomize/filesys/fs_secure.go||kustomize/filesys/fs_secure.go",
            "kustomize/filesys/fs_secure_test.go||kustomize/filesys/fs_secure_test.go"
          ],
          "candidate": [
            "kustomize/filesys/fs_secure.go||kustomize/filesys/fs_secure.go",
            "kustomize/filesys/fs_secure_test.go||kustomize/filesys/fs_secure_test.go"
          ]
        }
      },
      "candidate_diff": {
        "kustomize/filesys/fs_secure.go||kustomize/filesys/fs_secure.go": [
          "File: kustomize/filesys/fs_secure.go -> kustomize/filesys/fs_secure.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "20:  \"fmt\"",
          "21:  \"os\"",
          "22:  \"path/filepath\"",
          "24:  \"sigs.k8s.io/kustomize/kyaml/filesys\"",
          "25: )",
          "30:  unsafeFS := filesys.MakeFsOnDisk()",
          "31:  cleanedAbs, _, err := unsafeFS.CleanedAbs(root)",
          "32:  if err != nil {",
          "33:   return nil, err",
          "34:  }",
          "36: }",
          "40: type fsSecure struct {",
          "43: }",
          "",
          "[Removed Lines]",
          "29: func MakeFsOnDiskSecure(root string) (filesys.FileSystem, error) {",
          "35:  return fsSecure{root: cleanedAbs, unsafeFS: unsafeFS}, nil",
          "41:  root     filesys.ConfirmedDir",
          "42:  unsafeFS filesys.FileSystem",
          "",
          "[Added Lines]",
          "23:  \"strings\"",
          "28: var (",
          "31:  tmpConfirmedDirPrefix = \"kustomize-\"",
          "32: )",
          "40: func MakeFsOnDiskSecure(root string, allowPrefixes ...string) (filesys.FileSystem, error) {",
          "46:  if ok, prefix := hasOneOfPrefixes(cleanedAbs.String(), allowPrefixes); ok {",
          "47:   return nil, fmt.Errorf(\"root '%s' cannot be prefixed with '%s'\", root, prefix)",
          "48:  }",
          "49:  return fsSecure{root: cleanedAbs, unsafeFS: unsafeFS, allowPrefixes: allowPrefixes}, nil",
          "50: }",
          "54: func TmpConfirmedDirPrefix() (string, error) {",
          "56:  evaluated, err := filepath.EvalSymlinks(os.TempDir())",
          "57:  if err != nil {",
          "58:   return \"\", err",
          "59:  }",
          "60:  return filepath.Join(evaluated, tmpConfirmedDirPrefix), nil",
          "61: }",
          "67: func MakeFsOnDiskSecureBuild(root string, allowPrefixes ...string) (filesys.FileSystem, error) {",
          "68:  dirPrefix, err := TmpConfirmedDirPrefix()",
          "69:  if err != nil {",
          "70:   return nil, err",
          "71:  }",
          "72:  allowPrefixes = append([]string{dirPrefix}, allowPrefixes...)",
          "73:  return MakeFsOnDiskSecure(root, allowPrefixes...)",
          "79:  root          filesys.ConfirmedDir",
          "80:  unsafeFS      filesys.FileSystem",
          "81:  allowPrefixes []string",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62: func (fs fsSecure) Create(path string) (filesys.File, error) {",
          "64:   return nil, &ConstraintError{Op: \"create\", Path: path, Err: err}",
          "65:  }",
          "66:  return fs.unsafeFS.Create(path)",
          "",
          "[Removed Lines]",
          "63:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
          "",
          "[Added Lines]",
          "102:  if err := isSecurePath(fs.unsafeFS, fs.root, path, fs.allowPrefixes...); err != nil {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "72: func (fs fsSecure) Mkdir(path string) error {",
          "74:   return &ConstraintError{Op: \"mkdir\", Path: path, Err: err}",
          "75:  }",
          "76:  return fs.unsafeFS.Mkdir(path)",
          "",
          "[Removed Lines]",
          "73:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
          "",
          "[Added Lines]",
          "112:  if err := isSecurePath(fs.unsafeFS, fs.root, path, fs.allowPrefixes...); err != nil {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "82: func (fs fsSecure) MkdirAll(path string) error {",
          "84:   return &ConstraintError{Op: \"mkdir\", Path: path, Err: err}",
          "85:  }",
          "86:  return fs.unsafeFS.MkdirAll(path)",
          "",
          "[Removed Lines]",
          "83:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
          "",
          "[Added Lines]",
          "122:  if err := isSecurePath(fs.unsafeFS, fs.root, path, fs.allowPrefixes...); err != nil {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "92: func (fs fsSecure) RemoveAll(path string) error {",
          "94:   return &ConstraintError{Op: \"remove\", Path: path, Err: err}",
          "95:  }",
          "96:  return fs.unsafeFS.RemoveAll(path)",
          "",
          "[Removed Lines]",
          "93:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
          "",
          "[Added Lines]",
          "132:  if err := isSecurePath(fs.unsafeFS, fs.root, path, fs.allowPrefixes...); err != nil {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "102: func (fs fsSecure) Open(path string) (filesys.File, error) {",
          "104:   return nil, &ConstraintError{Op: \"open\", Path: path, Err: err}",
          "105:  }",
          "106:  return fs.unsafeFS.Open(path)",
          "",
          "[Removed Lines]",
          "103:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
          "",
          "[Added Lines]",
          "142:  if err := isSecurePath(fs.unsafeFS, fs.root, path, fs.allowPrefixes...); err != nil {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "112: func (fs fsSecure) IsDir(path string) bool {",
          "114:   return false",
          "115:  }",
          "116:  return fs.unsafeFS.IsDir(path)",
          "",
          "[Removed Lines]",
          "113:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
          "",
          "[Added Lines]",
          "152:  if err := isSecurePath(fs.unsafeFS, fs.root, path, fs.allowPrefixes...); err != nil {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "122: func (fs fsSecure) ReadDir(path string) ([]string, error) {",
          "124:   return nil, &ConstraintError{Op: \"open\", Path: path, Err: err}",
          "125:  }",
          "126:  return fs.unsafeFS.ReadDir(path)",
          "",
          "[Removed Lines]",
          "123:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
          "",
          "[Added Lines]",
          "162:  if err := isSecurePath(fs.unsafeFS, fs.root, path, fs.allowPrefixes...); err != nil {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "136:  if err != nil {",
          "137:   return d, f, err",
          "138:  }",
          "139:  if !d.HasPrefix(fs.root) {",
          "140:   return \"\", \"\", &ConstraintError{Op: \"abs\", Path: path, Err: rootConstraintErr(path, fs.root.String())}",
          "141:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "178:  if ok, _ := hasOneOfPrefixes(d.String(), fs.allowPrefixes); ok {",
          "179:   return d, f, err",
          "180:  }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "148: func (fs fsSecure) Exists(path string) bool {",
          "150:   return false",
          "151:  }",
          "152:  return fs.unsafeFS.Exists(path)",
          "",
          "[Removed Lines]",
          "149:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
          "",
          "[Added Lines]",
          "191:  if err := isSecurePath(fs.unsafeFS, fs.root, path, fs.allowPrefixes...); err != nil {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "161:  }",
          "162:  var securePaths []string",
          "163:  for _, p := range paths {",
          "165:    securePaths = append(securePaths, p)",
          "166:   }",
          "167:  }",
          "",
          "[Removed Lines]",
          "164:   if err := isSecurePath(fs.unsafeFS, fs.root, p); err == nil {",
          "",
          "[Added Lines]",
          "206:   if err := isSecurePath(fs.unsafeFS, fs.root, p, fs.allowPrefixes...); err == nil {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "174: func (fs fsSecure) ReadFile(path string) ([]byte, error) {",
          "176:   return nil, &ConstraintError{Op: \"read\", Path: path, Err: err}",
          "177:  }",
          "178:  return fs.unsafeFS.ReadFile(path)",
          "",
          "[Removed Lines]",
          "175:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
          "",
          "[Added Lines]",
          "217:  if err := isSecurePath(fs.unsafeFS, fs.root, path, fs.allowPrefixes...); err != nil {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "184: func (fs fsSecure) WriteFile(path string, data []byte) error {",
          "186:   return &ConstraintError{Op: \"write\", Path: path, Err: err}",
          "187:  }",
          "188:  return fs.unsafeFS.WriteFile(path, data)",
          "",
          "[Removed Lines]",
          "185:  if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
          "",
          "[Added Lines]",
          "227:  if err := isSecurePath(fs.unsafeFS, fs.root, path, fs.allowPrefixes...); err != nil {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "194: func (fs fsSecure) Walk(path string, walkFn filepath.WalkFunc) error {",
          "195:  wrapWalkFn := func(path string, info os.FileInfo, err error) error {",
          "197:    return &ConstraintError{Op: \"walk\", Path: path, Err: err}",
          "198:   }",
          "199:   return walkFn(path, info, err)",
          "",
          "[Removed Lines]",
          "196:   if err := isSecurePath(fs.unsafeFS, fs.root, path); err != nil {",
          "",
          "[Added Lines]",
          "238:   if err := isSecurePath(fs.unsafeFS, fs.root, path, fs.allowPrefixes...); err != nil {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "208:  absRoot, err := filepath.Abs(path)",
          "209:  if err != nil {",
          "210:   return fmt.Errorf(\"abs path error on '%s': %v\", path, err)",
          "211:  }",
          "213:  if fs.Exists(absRoot) {",
          "214:   evaluated, err := filepath.EvalSymlinks(absRoot)",
          "215:   if err != nil {",
          "",
          "[Removed Lines]",
          "207: func isSecurePath(fs filesys.FileSystem, root filesys.ConfirmedDir, path string) error {",
          "212:  d := filesys.ConfirmedDir(filepath.Dir(absRoot))",
          "",
          "[Added Lines]",
          "249: func isSecurePath(fs filesys.FileSystem, root filesys.ConfirmedDir, path string, allowedPrefixes ...string) error {",
          "254:  d := filesys.ConfirmedDir(absRoot)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "221:   }",
          "222:   d = filesys.ConfirmedDir(evaluatedDir)",
          "223:  }",
          "224:  if !d.HasPrefix(root) {",
          "225:   return rootConstraintErr(path, root.String())",
          "226:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "266:  if ok, _ := hasOneOfPrefixes(d.String(), allowedPrefixes); ok {",
          "267:   return nil",
          "268:  }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "230: func rootConstraintErr(path, root string) error {",
          "231:  return fmt.Errorf(\"path '%s' is not in or below '%s'\", path, root)",
          "232: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "279: func hasOneOfPrefixes(s string, prefixes []string) (bool, string) {",
          "280:  for _, p := range prefixes {",
          "281:   if strings.HasPrefix(s, p) {",
          "282:    return true, p",
          "283:   }",
          "284:  }",
          "285:  return false, \"\"",
          "286: }",
          "",
          "---------------"
        ],
        "kustomize/filesys/fs_secure_test.go||kustomize/filesys/fs_secure_test.go": [
          "File: kustomize/filesys/fs_secure_test.go -> kustomize/filesys/fs_secure_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "30:  \"sigs.k8s.io/kustomize/kyaml/filesys\"",
          "31: )",
          "33: func Test_fsSecure_Create(t *testing.T) {",
          "34:  g := NewWithT(t)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: func TestMakeFsOnDiskSecure(t *testing.T) {",
          "34:  t.Run(\"error on root prefixed with allowed prefix\", func(t *testing.T) {",
          "35:   g := NewWithT(t)",
          "37:   tmpDir := t.TempDir()",
          "38:   matchingDir := filepath.Join(tmpDir, \"subdir\")",
          "39:   g.Expect(os.Mkdir(matchingDir, 0o644)).To(Succeed())",
          "41:   got, err := MakeFsOnDiskSecure(filepath.Join(tmpDir, \"subdir\"), tmpDir)",
          "42:   g.Expect(err).To(HaveOccurred())",
          "43:   g.Expect(err.Error()).To(ContainSubstring(\"cannot be prefixed with\"))",
          "44:   g.Expect(got).To(BeNil())",
          "45:  })",
          "46: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "264:   g.Expect(d).To(BeEmpty())",
          "265:   g.Expect(f).To(BeEmpty())",
          "266:  })",
          "267: }",
          "269: func Test_fsSecure_Exists(t *testing.T) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "283:  t.Run(\"prefix allowed cleaned abs\", func(t *testing.T) {",
          "284:   g := NewWithT(t)",
          "286:   allowedPrefix, err := TmpConfirmedDirPrefix()",
          "287:   g.Expect(err).ToNot(HaveOccurred())",
          "289:   fs, err := MakeFsOnDiskSecureBuild(root, allowedPrefix)",
          "290:   g.Expect(err).ToNot(HaveOccurred())",
          "292:   prefixedDir, err := os.MkdirTemp(\"\", tmpConfirmedDirPrefix)",
          "293:   g.Expect(err).ToNot(HaveOccurred())",
          "294:   t.Cleanup(func() { _ = os.RemoveAll(prefixedDir) })",
          "296:   d, f, err := fs.CleanedAbs(prefixedDir)",
          "297:   g.Expect(err).ToNot(HaveOccurred())",
          "298:   g.Expect(d).To(Equal(filesys.ConfirmedDir(prefixedDir)))",
          "299:   g.Expect(f).To(BeEmpty())",
          "300:  })",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "415: }",
          "417: func Test_isSecurePath(t *testing.T) {",
          "418:  type file struct {",
          "419:   name    string",
          "420:   symlink string",
          "421:  }",
          "422:  tests := []struct {",
          "429:  }{",
          "430:   {",
          "431:    name:    \"secure non existing path\",",
          "",
          "[Removed Lines]",
          "423:   name       string",
          "424:   fs         filesys.FileSystem",
          "425:   rootSuffix string",
          "426:   files      []file",
          "427:   path       string",
          "428:   wantErr    types.GomegaMatcher",
          "",
          "[Added Lines]",
          "452:  g := NewWithT(t)",
          "454:  prefixedDir, err := os.MkdirTemp(\"\", tmpConfirmedDirPrefix)",
          "455:  g.Expect(err).ToNot(HaveOccurred())",
          "456:  t.Cleanup(func() { _ = os.RemoveAll(prefixedDir) })",
          "458:  allowPrefix, err := TmpConfirmedDirPrefix()",
          "459:  g.Expect(err).ToNot(HaveOccurred())",
          "466:   name            string",
          "467:   fs              filesys.FileSystem",
          "468:   rootSuffix      string",
          "469:   files           []file",
          "470:   path            string",
          "471:   allowedPrefixes []string",
          "472:   wantErr         types.GomegaMatcher",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "491:    path:    \"<root>/subdir/symlink\",",
          "492:    wantErr: HaveOccurred(),",
          "493:   },",
          "494:  }",
          "495:  for _, tt := range tests {",
          "496:   t.Run(tt.name, func(t *testing.T) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "538:   {",
          "539:    name:            \"allowed prefix\",",
          "540:    fs:              filesys.MakeFsOnDisk(),",
          "541:    path:            prefixedDir,",
          "542:    allowedPrefixes: []string{allowPrefix},",
          "543:    wantErr:         Succeed(),",
          "544:   },",
          "545:   {",
          "546:    name:            \"illegal prefix\",",
          "547:    fs:              filesys.MakeFsOnDisk(),",
          "548:    path:            filepath.Join(os.TempDir(), \"illegal-path\"),",
          "549:    allowedPrefixes: []string{allowPrefix},",
          "550:    wantErr:         HaveOccurred(),",
          "551:   },",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "530:     path = strings.Replace(path, \"<root>\", root, 1)",
          "531:    }",
          "534:    g.Expect(err).To(tt.wantErr)",
          "535:   })",
          "536:  }",
          "537: }",
          "539: func newTemp() string {",
          "540:  return filepath.Join(os.TempDir(), \"securefs-\"+randStringBytes(5))",
          "541: }",
          "",
          "[Removed Lines]",
          "533:    err := isSecurePath(tt.fs, realRoot, path)",
          "",
          "[Added Lines]",
          "591:    err := isSecurePath(tt.fs, realRoot, path, tt.allowedPrefixes...)",
          "597: func Test_hasOneOfPrefixes(t *testing.T) {",
          "598:  tests := []struct {",
          "599:   name       string",
          "600:   s          string",
          "601:   prefixes   []string",
          "602:   want       bool",
          "603:   wantPrefix string",
          "604:  }{",
          "605:   {name: \"match\", s: \"/tmp/kustomize-3828348\", prefixes: []string{\"/tmp/kustomize-\"}, want: true, wantPrefix: \"/tmp/kustomize-\"},",
          "606:   {name: \"not a match\", s: \"/tmp/workdir-6845913\", prefixes: []string{\"/tmp/kustomize-\"}, want: false},",
          "607:   {name: \"match list\", s: \"/tmp/workdir-6845913\", prefixes: []string{\"/tmp/kustomize-\", \"/tmp/workdir-\"}, want: true, wantPrefix: \"/tmp/workdir-\"},",
          "608:  }",
          "609:  for _, tt := range tests {",
          "610:   t.Run(tt.name, func(t *testing.T) {",
          "611:    g := NewWithT(t)",
          "613:    has, prefix := hasOneOfPrefixes(tt.s, tt.prefixes)",
          "614:    g.Expect(has).To(Equal(tt.want))",
          "615:    g.Expect(prefix).To(Equal(tt.wantPrefix))",
          "616:   })",
          "617:  }",
          "618: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
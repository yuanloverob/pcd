{
  "cve_id": "CVE-2022-39393",
  "cve_desc": "Wasmtime is a standalone runtime for WebAssembly. Prior to versions 2.0.2 and 1.0.2, there is a bug in Wasmtime's implementation of its pooling instance allocator where when a linear memory is reused for another instance the initial heap snapshot of the prior instance can be visible, erroneously to the next instance. This bug has been patched and users should upgrade to Wasmtime 2.0.2 and 1.0.2. Other mitigations include disabling the pooling allocator and disabling the `memory-init-cow`.",
  "repo": "bytecodealliance/wasmtime",
  "patch_hash": "2614f2e9d2d36805ead8a8da0fa0c6e0d9e428a0",
  "patch_info": {
    "commit_hash": "2614f2e9d2d36805ead8a8da0fa0c6e0d9e428a0",
    "repo": "bytecodealliance/wasmtime",
    "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/2614f2e9d2d36805ead8a8da0fa0c6e0d9e428a0",
    "files": [
      "crates/runtime/src/instance/allocator/pooling.rs",
      "tests/all/pooling_allocator.rs"
    ],
    "message": "Merge pull request from GHSA-wh6w-3828-g9qf\n\nThis is a minimal fix for the release branch to fix the issue of having\na memory slot get reused between a module with an image and one without.",
    "before_after_code_files": [
      "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
      "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
    ]
  },
  "patch_diff": {
    "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs": [
      "File: crates/runtime/src/instance/allocator/pooling.rs -> crates/runtime/src/instance/allocator/pooling.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "393:                 )",
      "394:             };",
      "396:             if let Some(image) = runtime_info",
      "397:                 .memory_image(defined_index)",
      "398:                 .map_err(|err| InstantiationError::Resource(err.into()))?",
      "399:             {",
      "403:                 let initial_size = plan.memory.minimum * WASM_PAGE_SIZE as u64;",
      "",
      "[Removed Lines]",
      "400:                 let mut slot = self",
      "401:                     .memories",
      "402:                     .take_memory_image_slot(instance_index, defined_index);",
      "",
      "[Added Lines]",
      "396:             let mut slot = self",
      "397:                 .memories",
      "398:                 .take_memory_image_slot(instance_index, defined_index);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "425:                     .map_err(InstantiationError::Resource)?,",
      "426:                 );",
      "427:             } else {",
      "428:                 memories.push(",
      "429:                     Memory::new_static(plan, memory, Some(commit_memory_pages), None, unsafe {",
      "430:                         &mut *store.unwrap()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "428:                 drop(slot);",
      "",
      "---------------"
    ],
    "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs": [
      "File: tests/all/pooling_allocator.rs -> tests/all/pooling_allocator.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "615:     Ok(())",
      "616: }",
      "618: #[test]",
      "619: #[cfg(target_pointer_width = \"64\")]",
      "620: fn instance_too_large() -> Result<()> {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "618: #[test]",
      "619: fn switch_image_and_non_image() -> Result<()> {",
      "620:     let mut c = Config::new();",
      "621:     c.allocation_strategy(InstanceAllocationStrategy::Pooling {",
      "622:         instance_limits: InstanceLimits {",
      "623:             count: 1,",
      "624:             ..Default::default()",
      "625:         },",
      "626:         strategy: Default::default(),",
      "627:     });",
      "628:     let engine = Engine::new(&c)?;",
      "629:     let module1 = Module::new(",
      "630:         &engine,",
      "631:         r#\"",
      "632:             (module",
      "633:                 (memory 1)",
      "634:                 (func (export \"load\") (param i32) (result i32)",
      "635:                     local.get 0",
      "636:                     i32.load",
      "637:                 )",
      "638:             )",
      "639:         \"#,",
      "640:     )?;",
      "641:     let module2 = Module::new(",
      "642:         &engine,",
      "643:         r#\"",
      "644:             (module",
      "645:                 (memory (export \"memory\") 1)",
      "646:                 (data (i32.const 0) \"1234\")",
      "647:             )",
      "648:         \"#,",
      "649:     )?;",
      "651:     let assert_zero = || -> Result<()> {",
      "652:         let mut store = Store::new(&engine, ());",
      "653:         let instance = Instance::new(&mut store, &module1, &[])?;",
      "654:         let func = instance.get_typed_func::<i32, i32, _>(&mut store, \"load\")?;",
      "655:         assert_eq!(func.call(&mut store, 0)?, 0);",
      "656:         Ok(())",
      "657:     };",
      "661:     Instance::new(&mut Store::new(&engine, ()), &module2, &[])?;",
      "662:     assert_zero()?;",
      "665:     Instance::new(&mut Store::new(&engine, ()), &module2, &[])?;",
      "666:     assert_zero()?;",
      "669:     let mut store = Store::new(&engine, ());",
      "670:     let instance = Instance::new(&mut store, &module2, &[])?;",
      "671:     let memory = instance.get_memory(&mut store, \"memory\").unwrap();",
      "672:     let mem = memory.data_mut(&mut store);",
      "673:     assert!(mem.starts_with(b\"1234\"));",
      "674:     mem[..6].copy_from_slice(b\"567890\");",
      "676:     Ok(())",
      "677: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bbd4a4a50093fa52178919022b091807198aa6ae",
      "candidate_info": {
        "commit_hash": "bbd4a4a50093fa52178919022b091807198aa6ae",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/bbd4a4a50093fa52178919022b091807198aa6ae",
        "files": [
          "Cargo.toml",
          "crates/fuzzing/src/generators.rs",
          "crates/runtime/Cargo.toml",
          "crates/runtime/build.rs",
          "crates/runtime/src/cow.rs",
          "crates/runtime/src/cow_disabled.rs",
          "crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/instance/allocator/pooling.rs",
          "crates/runtime/src/lib.rs",
          "crates/runtime/src/memfd.rs",
          "crates/runtime/src/memfd_disabled.rs",
          "crates/runtime/src/memory.rs",
          "crates/wasmtime/Cargo.toml",
          "crates/wasmtime/src/config.rs",
          "crates/wasmtime/src/lib.rs",
          "crates/wasmtime/src/module.rs",
          "crates/wasmtime/src/trampoline/memory.rs",
          "src/lib.rs"
        ],
        "message": "Enable copy-on-write heap initialization by default (#3825)\n\n* Enable copy-on-write heap initialization by default\n\nThis commit enables the `Config::memfd` feature by default now that it's\nbeen fuzzed for a few weeks on oss-fuzz, and will continue to be fuzzed\nleading up to the next release of Wasmtime in early March. The\ndocumentation of the `Config` option has been updated as well as adding\na CLI flag to disable the feature.\n\n* Remove ubiquitous \"memfd\" terminology\n\nSwitch instead to forms of \"memory image\" or \"cow\" or some combination\nthereof.\n\n* Update new option names",
        "before_after_code_files": [
          "crates/fuzzing/src/generators.rs||crates/fuzzing/src/generators.rs",
          "crates/runtime/build.rs||crates/runtime/build.rs",
          "crates/runtime/src/memfd.rs||crates/runtime/src/cow.rs",
          "crates/runtime/src/memfd_disabled.rs||crates/runtime/src/cow_disabled.rs",
          "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
          "crates/runtime/src/lib.rs||crates/runtime/src/lib.rs",
          "crates/runtime/src/memory.rs||crates/runtime/src/memory.rs",
          "crates/wasmtime/src/config.rs||crates/wasmtime/src/config.rs",
          "crates/wasmtime/src/lib.rs||crates/wasmtime/src/lib.rs",
          "crates/wasmtime/src/module.rs||crates/wasmtime/src/module.rs",
          "crates/wasmtime/src/trampoline/memory.rs||crates/wasmtime/src/trampoline/memory.rs",
          "src/lib.rs||src/lib.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs"
          ],
          "candidate": [
            "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs"
          ]
        }
      },
      "candidate_diff": {
        "crates/fuzzing/src/generators.rs||crates/fuzzing/src/generators.rs": [
          "File: crates/fuzzing/src/generators.rs -> crates/fuzzing/src/generators.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "257:     pub memory_config: MemoryConfig,",
          "258:     force_jump_veneers: bool,",
          "261:     use_precompiled_cwasm: bool,",
          "263:     pub strategy: InstanceAllocationStrategy,",
          "",
          "[Removed Lines]",
          "259:     memfd: bool,",
          "260:     memfd_guaranteed_dense_image_size: u64,",
          "",
          "[Added Lines]",
          "259:     memory_init_cow: bool,",
          "260:     memory_guaranteed_dense_image_size: u64,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "441:             .cranelift_opt_level(self.wasmtime.opt_level.to_wasmtime())",
          "442:             .interruptable(self.wasmtime.interruptable)",
          "443:             .consume_fuel(self.wasmtime.consume_fuel)",
          "448:                 16 << 20,",
          "450:             ))",
          "451:             .allocation_strategy(self.wasmtime.strategy.to_wasmtime());",
          "",
          "[Removed Lines]",
          "444:             .memfd(self.wasmtime.memfd)",
          "445:             .memfd_guaranteed_dense_image_size(std::cmp::min(",
          "449:                 self.wasmtime.memfd_guaranteed_dense_image_size,",
          "",
          "[Added Lines]",
          "444:             .memory_init_cow(self.wasmtime.memory_init_cow)",
          "445:             .memory_guaranteed_dense_image_size(std::cmp::min(",
          "449:                 self.wasmtime.memory_guaranteed_dense_image_size,",
          "",
          "---------------"
        ],
        "crates/runtime/build.rs||crates/runtime/build.rs": [
          "File: crates/runtime/build.rs -> crates/runtime/build.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:         .file(\"src/helpers.c\")",
          "12:         .compile(\"wasmtime-helpers\");",
          "21:     let family = env::var(\"CARGO_CFG_TARGET_FAMILY\").unwrap();",
          "23:     let is_uffd = env::var(\"CARGO_FEATURE_UFFD\").is_ok();",
          "26:     }",
          "27: }",
          "",
          "[Removed Lines]",
          "22:     let is_memfd = env::var(\"CARGO_FEATURE_MEMFD\").is_ok();",
          "24:     if &family == \"unix\" && is_memfd && !is_uffd {",
          "25:         println!(\"cargo:rustc-cfg=memfd\");",
          "",
          "[Added Lines]",
          "18:     let memory_init_cow = env::var(\"CARGO_FEATURE_MEMORY_INIT_COW\").is_ok();",
          "20:     if &family == \"unix\" && memory_init_cow && !is_uffd {",
          "21:         println!(\"cargo:rustc-cfg=memory_init_cow\");",
          "",
          "---------------"
        ],
        "crates/runtime/src/memfd.rs||crates/runtime/src/cow.rs": [
          "File: crates/runtime/src/memfd.rs -> crates/runtime/src/cow.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: use std::{convert::TryFrom, ops::Range};",
          "12: use wasmtime_environ::{DefinedMemoryIndex, MemoryInitialization, Module, PrimaryMap};",
          "20: }",
          "25:         self.memories[defined_index].as_ref()",
          "26:     }",
          "27: }",
          "30: #[derive(Debug)]",
          "",
          "[Removed Lines]",
          "18: pub struct ModuleMemFds {",
          "19:     memories: PrimaryMap<DefinedMemoryIndex, Option<Arc<MemoryMemFd>>>,",
          "22: impl ModuleMemFds {",
          "24:     pub fn get_memory_image(&self, defined_index: DefinedMemoryIndex) -> Option<&Arc<MemoryMemFd>> {",
          "31: pub struct MemoryMemFd {",
          "37:     fd: MemFdSource,",
          "",
          "[Added Lines]",
          "18: pub struct ModuleMemoryImages {",
          "19:     memories: PrimaryMap<DefinedMemoryIndex, Option<Arc<MemoryImage>>>,",
          "22: impl ModuleMemoryImages {",
          "24:     pub fn get_memory_image(&self, defined_index: DefinedMemoryIndex) -> Option<&Arc<MemoryImage>> {",
          "31: pub struct MemoryImage {",
          "37:     fd: FdSource,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59: }",
          "61: #[derive(Debug)]",
          "63:     Mmap(Arc<File>),",
          "64:     #[cfg(target_os = \"linux\")]",
          "65:     Memfd(memfd::Memfd),",
          "66: }",
          "69:     fn as_file(&self) -> &File {",
          "70:         match self {",
          "72:             #[cfg(target_os = \"linux\")]",
          "74:         }",
          "75:     }",
          "76: }",
          "79:     fn new(",
          "80:         page_size: u32,",
          "81:         offset: u64,",
          "82:         data: &[u8],",
          "83:         mmap: Option<&MmapVec>,",
          "86:         let len = data.len();",
          "87:         let offset = u32::try_from(offset).unwrap();",
          "",
          "[Removed Lines]",
          "62: enum MemFdSource {",
          "68: impl MemFdSource {",
          "71:             MemFdSource::Mmap(file) => file,",
          "73:             MemFdSource::Memfd(memfd) => memfd.as_file(),",
          "78: impl MemoryMemFd {",
          "84:     ) -> Result<Option<MemoryMemFd>> {",
          "",
          "[Added Lines]",
          "62: enum FdSource {",
          "68: impl FdSource {",
          "71:             FdSource::Mmap(file) => file,",
          "73:             FdSource::Memfd(memfd) => memfd.as_file(),",
          "78: impl MemoryImage {",
          "84:     ) -> Result<Option<MemoryImage>> {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "115:             assert_eq!((mmap.original_offset() as u32) % page_size, 0);",
          "117:             if let Some(file) = mmap.original_file() {",
          "120:                     fd_offset: u64::try_from(mmap.original_offset() + (data_start - start))",
          "121:                         .unwrap(),",
          "122:                     linear_memory_offset,",
          "",
          "[Removed Lines]",
          "118:                 return Ok(Some(MemoryMemFd {",
          "119:                     fd: MemFdSource::Mmap(file.clone()),",
          "",
          "[Added Lines]",
          "118:                 return Ok(Some(MemoryImage {",
          "119:                     fd: FdSource::Mmap(file.clone()),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "159:                 memfd.add_seal(memfd::FileSeal::SealWrite)?;",
          "160:                 memfd.add_seal(memfd::FileSeal::SealSeal)?;",
          "164:                     fd_offset: 0,",
          "165:                     linear_memory_offset,",
          "166:                     len,",
          "",
          "[Removed Lines]",
          "162:                 Ok(Some(MemoryMemFd {",
          "163:                     fd: MemFdSource::Memfd(memfd),",
          "",
          "[Added Lines]",
          "162:                 Ok(Some(MemoryImage {",
          "163:                     fd: FdSource::Memfd(memfd),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "188:         .map_err(|e| e.into())",
          "189: }",
          "195:     pub fn new(",
          "196:         module: &Module,",
          "197:         wasm_data: &[u8],",
          "198:         mmap: Option<&MmapVec>,",
          "200:         let map = match &module.memory_initialization {",
          "201:             MemoryInitialization::Static { map } => map,",
          "202:             _ => return Ok(None),",
          "",
          "[Removed Lines]",
          "191: impl ModuleMemFds {",
          "199:     ) -> Result<Option<ModuleMemFds>> {",
          "",
          "[Added Lines]",
          "191: impl ModuleMemoryImages {",
          "199:     ) -> Result<Option<ModuleMemoryImages>> {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "223:             };",
          "229:             let data = &wasm_data[init.data.start as usize..init.data.end as usize];",
          "232:                 None => return Ok(None),",
          "233:             };",
          "236:             assert_eq!(idx, defined_memory);",
          "237:         }",
          "240:     }",
          "241: }",
          "",
          "[Removed Lines]",
          "230:             let memfd = match MemoryMemFd::new(page_size, init.offset, data, mmap)? {",
          "231:                 Some(memfd) => memfd,",
          "235:             let idx = memories.push(Some(Arc::new(memfd)));",
          "239:         Ok(Some(ModuleMemFds { memories }))",
          "",
          "[Added Lines]",
          "230:             let image = match MemoryImage::new(page_size, init.offset, data, mmap)? {",
          "231:                 Some(image) => image,",
          "235:             let idx = memories.push(Some(Arc::new(image)));",
          "239:         Ok(Some(ModuleMemoryImages { memories }))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "267: #[derive(Debug)]",
          "271:     base: usize,",
          "273:     static_size: usize,",
          "278:     initial_size: usize,",
          "",
          "[Removed Lines]",
          "268: pub struct MemFdSlot {",
          "276:     pub(crate) image: Option<Arc<MemoryMemFd>>,",
          "",
          "[Added Lines]",
          "268: pub struct MemoryImageSlot {",
          "276:     pub(crate) image: Option<Arc<MemoryImage>>,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "292:     dirty: bool,",
          "297:     clear_on_drop: bool,",
          "298: }",
          "303:     pub(crate) fn create(base_addr: *mut c_void, initial_size: usize, static_size: usize) -> Self {",
          "304:         let base = base_addr as usize;",
          "306:             base,",
          "307:             static_size,",
          "308:             initial_size,",
          "",
          "[Removed Lines]",
          "300: impl MemFdSlot {",
          "305:         MemFdSlot {",
          "",
          "[Added Lines]",
          "300: impl MemoryImageSlot {",
          "305:         MemoryImageSlot {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "335:     pub(crate) fn instantiate(",
          "336:         &mut self,",
          "337:         initial_size_bytes: usize,",
          "339:     ) -> Result<(), InstantiationError> {",
          "340:         assert!(!self.dirty);",
          "341:         assert_eq!(self.cur_size, self.initial_size);",
          "",
          "[Removed Lines]",
          "338:         maybe_image: Option<&Arc<MemoryMemFd>>,",
          "",
          "[Added Lines]",
          "338:         maybe_image: Option<&Arc<MemoryImage>>,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "543:     }",
          "544: }",
          "547:     fn drop(&mut self) {",
          "",
          "[Removed Lines]",
          "546: impl Drop for MemFdSlot {",
          "",
          "[Added Lines]",
          "546: impl Drop for MemoryImageSlot {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "585: mod test {",
          "586:     use std::sync::Arc;",
          "589:     use crate::mmap::Mmap;",
          "590:     use anyhow::Result;",
          "591:     use std::io::Write;",
          "595:         let page_size = region::page::size();",
          "596:         assert_eq!(offset & (page_size - 1), 0);",
          "",
          "[Removed Lines]",
          "588:     use super::{create_memfd, MemFdSlot, MemFdSource, MemoryMemFd};",
          "593:     fn create_memfd_with_data(offset: usize, data: &[u8]) -> Result<MemoryMemFd> {",
          "",
          "[Added Lines]",
          "588:     use super::{create_memfd, FdSource, MemoryImage, MemoryImageSlot};",
          "593:     fn create_memfd_with_data(offset: usize, data: &[u8]) -> Result<MemoryImage> {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "601:         let image_len = (data.len() + page_size - 1) & !(page_size - 1);",
          "602:         memfd.as_file().set_len(image_len as u64)?;",
          "606:             len: image_len,",
          "607:             fd_offset: 0,",
          "608:             linear_memory_offset: offset,",
          "",
          "[Removed Lines]",
          "604:         Ok(MemoryMemFd {",
          "605:             fd: MemFdSource::Memfd(memfd),",
          "",
          "[Added Lines]",
          "604:         Ok(MemoryImage {",
          "605:             fd: FdSource::Memfd(memfd),",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "613:     fn instantiate_no_image() {",
          "615:         let mut mmap = Mmap::accessible_reserved(0, 4 << 20).unwrap();",
          "618:         memfd.no_clear_on_drop();",
          "619:         assert!(!memfd.is_dirty());",
          "",
          "[Removed Lines]",
          "617:         let mut memfd = MemFdSlot::create(mmap.as_mut_ptr() as *mut _, 0, 4 << 20);",
          "",
          "[Added Lines]",
          "617:         let mut memfd = MemoryImageSlot::create(mmap.as_mut_ptr() as *mut _, 0, 4 << 20);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "645:     fn instantiate_image() {",
          "647:         let mut mmap = Mmap::accessible_reserved(0, 4 << 20).unwrap();",
          "650:         memfd.no_clear_on_drop();",
          "652:         let image = Arc::new(create_memfd_with_data(4096, &[1, 2, 3, 4]).unwrap());",
          "",
          "[Removed Lines]",
          "649:         let mut memfd = MemFdSlot::create(mmap.as_mut_ptr() as *mut _, 0, 4 << 20);",
          "",
          "[Added Lines]",
          "649:         let mut memfd = MemoryImageSlot::create(mmap.as_mut_ptr() as *mut _, 0, 4 << 20);",
          "",
          "---------------"
        ],
        "crates/runtime/src/memfd_disabled.rs||crates/runtime/src/cow_disabled.rs": [
          "File: crates/runtime/src/memfd_disabled.rs -> crates/runtime/src/cow_disabled.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: use std::sync::Arc;",
          "8: use wasmtime_environ::{DefinedMemoryIndex, Module};",
          "15: #[allow(dead_code)]",
          "23:         Ok(None)",
          "24:     }",
          "30:         match *self {}",
          "31:     }",
          "32: }",
          "40: #[derive(Debug)]",
          "43: #[allow(dead_code)]",
          "45:     pub(crate) fn create(_: *mut libc::c_void, _: usize, _: usize) -> Self {",
          "47:     }",
          "49:     pub(crate) fn instantiate(",
          "50:         &mut self,",
          "51:         _: usize,",
          "53:     ) -> Result<Self, InstantiationError> {",
          "54:         match *self {}",
          "55:     }",
          "",
          "[Removed Lines]",
          "12: pub enum ModuleMemFds {}",
          "16: pub enum MemoryMemFd {}",
          "18: impl ModuleMemFds {",
          "22:     pub fn new(_: &Module, _: &[u8], _: Option<&MmapVec>) -> Result<Option<ModuleMemFds>> {",
          "27:     pub fn get_memory_image(&self, _: DefinedMemoryIndex) -> Option<&Arc<MemoryMemFd>> {",
          "41: pub enum MemFdSlot {}",
          "44: impl MemFdSlot {",
          "46:         panic!(\"create() on invalid MemFdSlot\");",
          "52:         _: Option<&Arc<MemoryMemFd>>,",
          "",
          "[Added Lines]",
          "11: pub enum ModuleMemoryImages {}",
          "15: pub enum MemoryImage {}",
          "17: impl ModuleMemoryImages {",
          "21:     pub fn new(_: &Module, _: &[u8], _: Option<&MmapVec>) -> Result<Option<ModuleMemoryImages>> {",
          "26:     pub fn get_memory_image(&self, _: DefinedMemoryIndex) -> Option<&Arc<MemoryImage>> {",
          "38: pub enum MemoryImageSlot {}",
          "41: impl MemoryImageSlot {",
          "43:         panic!(\"create() on invalid MemoryImageSlot\");",
          "49:         _: Option<&Arc<MemoryImage>>,",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
          "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "480:         let mut memories: PrimaryMap<DefinedMemoryIndex, _> =",
          "481:             PrimaryMap::with_capacity(module.memory_plans.len() - num_imports);",
          "482:         for (memory_idx, plan) in module.memory_plans.iter().skip(num_imports) {",
          "484:             let defined_memory_idx = module",
          "485:                 .defined_memory_index(memory_idx)",
          "486:                 .expect(\"Skipped imports, should never be None\");",
          "489:                 .map_err(|err| InstantiationError::Resource(err.into()))?;",
          "491:             memories.push(",
          "",
          "[Removed Lines]",
          "487:             let memfd_image = runtime_info",
          "488:                 .memfd_image(defined_memory_idx)",
          "",
          "[Added Lines]",
          "486:             let image = runtime_info",
          "487:                 .memory_image(defined_memory_idx)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "497:                             .get()",
          "498:                             .expect(\"if module has memory plans, store is not empty\")",
          "499:                     },",
          "501:                 )",
          "502:                 .map_err(InstantiationError::Resource)?,",
          "503:             );",
          "",
          "[Removed Lines]",
          "500:                     memfd_image,",
          "",
          "[Added Lines]",
          "499:                     image,",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs": [
          "File: crates/runtime/src/instance/allocator/pooling.rs -> crates/runtime/src/instance/allocator/pooling.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "12:     InstantiationError,",
          "13: };",
          "14: use crate::{instance::Instance, Memory, Mmap, Table};",
          "16: use anyhow::{anyhow, bail, Context, Result};",
          "17: use libc::c_void;",
          "18: use std::convert::TryFrom;",
          "",
          "[Removed Lines]",
          "15: use crate::{MemFdSlot, ModuleRuntimeInfo, Store};",
          "",
          "[Added Lines]",
          "15: use crate::{MemoryImageSlot, ModuleRuntimeInfo, Store};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "260: impl Default for PoolingAllocationStrategy {",
          "261:     fn default() -> Self {",
          "263:             Self::ReuseAffinity",
          "264:         } else {",
          "265:             Self::NextAvailable",
          "",
          "[Removed Lines]",
          "262:         if cfg!(memfd) {",
          "",
          "[Added Lines]",
          "262:         if cfg!(memory_init_cow) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "476:             };",
          "478:             if let Some(image) = runtime_info",
          "480:                 .map_err(|err| InstantiationError::Resource(err.into()))?",
          "481:             {",
          "483:                 let initial_size = plan.memory.minimum * WASM_PAGE_SIZE as u64;",
          "",
          "[Removed Lines]",
          "479:                 .memfd_image(defined_index)",
          "482:                 let mut slot = self.memories.take_memfd_slot(instance_index, defined_index);",
          "",
          "[Added Lines]",
          "479:                 .memory_image(defined_index)",
          "482:                 let mut slot = self",
          "483:                     .memories",
          "484:                     .take_memory_image_slot(instance_index, defined_index);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "532:             match memory {",
          "533:                 Memory::Static {",
          "535:                     ..",
          "536:                 } => {",
          "542:                         self.memories",
          "544:                     }",
          "545:                 }",
          "",
          "[Removed Lines]",
          "534:                     memfd_slot: Some(mut memfd_slot),",
          "541:                     if memfd_slot.clear_and_remain_ready().is_ok() {",
          "543:                             .return_memfd_slot(instance_index, def_mem_idx, memfd_slot);",
          "",
          "[Added Lines]",
          "536:                     memory_image: Some(mut image),",
          "543:                     if image.clear_and_remain_ready().is_ok() {",
          "545:                             .return_memory_image_slot(instance_index, def_mem_idx, image);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "630: #[derive(Debug)]",
          "631: struct MemoryPool {",
          "632:     mapping: Mmap,",
          "639:     memory_size: usize,",
          "",
          "[Removed Lines]",
          "636:     memfd_slots: Vec<Mutex<Option<MemFdSlot>>>,",
          "",
          "[Added Lines]",
          "638:     image_slots: Vec<Mutex<Option<MemoryImageSlot>>>,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "718:         let mapping = Mmap::accessible_reserved(0, allocation_size)",
          "719:             .context(\"failed to create memory pool mapping\")?;",
          "722:             max_instances * max_memories",
          "723:         } else {",
          "724:             0",
          "725:         };",
          "728:             .collect();",
          "730:         let pool = Self {",
          "731:             mapping,",
          "733:             memory_size,",
          "734:             initial_memory_offset,",
          "735:             max_memories,",
          "",
          "[Removed Lines]",
          "721:         let num_memfd_slots = if cfg!(memfd) {",
          "726:         let memfd_slots: Vec<_> = std::iter::repeat_with(|| Mutex::new(None))",
          "727:             .take(num_memfd_slots)",
          "732:             memfd_slots,",
          "",
          "[Added Lines]",
          "723:         let num_image_slots = if cfg!(memory_init_cow) {",
          "728:         let image_slots: Vec<_> = std::iter::repeat_with(|| Mutex::new(None))",
          "729:             .take(num_image_slots)",
          "734:             image_slots,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "758:             .map(move |i| self.get_base(instance_index, DefinedMemoryIndex::from_u32(i as u32)))",
          "759:     }",
          "764:         &self,",
          "765:         instance_index: usize,",
          "766:         memory_index: DefinedMemoryIndex,",
          "768:         let idx = instance_index * self.max_memories + (memory_index.as_u32() as usize);",
          "771:         maybe_slot.unwrap_or_else(|| {",
          "773:                 self.get_base(instance_index, memory_index) as *mut c_void,",
          "774:                 0,",
          "775:                 self.memory_size,",
          "",
          "[Removed Lines]",
          "763:     fn take_memfd_slot(",
          "767:     ) -> MemFdSlot {",
          "769:         let maybe_slot = self.memfd_slots[idx].lock().unwrap().take();",
          "772:             MemFdSlot::create(",
          "",
          "[Added Lines]",
          "765:     fn take_memory_image_slot(",
          "769:     ) -> MemoryImageSlot {",
          "771:         let maybe_slot = self.image_slots[idx].lock().unwrap().take();",
          "774:             MemoryImageSlot::create(",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "777:         })",
          "778:     }",
          "782:         &self,",
          "783:         instance_index: usize,",
          "784:         memory_index: DefinedMemoryIndex,",
          "786:     ) {",
          "787:         assert!(!slot.is_dirty());",
          "788:         let idx = instance_index * self.max_memories + (memory_index.as_u32() as usize);",
          "790:     }",
          "791: }",
          "793: impl Drop for MemoryPool {",
          "794:     fn drop(&mut self) {",
          "802:             }",
          "803:         }",
          "804:     }",
          "",
          "[Removed Lines]",
          "781:     fn return_memfd_slot(",
          "785:         slot: MemFdSlot,",
          "799:         for mut memfd in std::mem::take(&mut self.memfd_slots) {",
          "800:             if let Some(memfd_slot) = memfd.get_mut().unwrap() {",
          "801:                 memfd_slot.no_clear_on_drop();",
          "",
          "[Added Lines]",
          "783:     fn return_memory_image_slot(",
          "787:         slot: MemoryImageSlot,",
          "801:         for mut slot in std::mem::take(&mut self.image_slots) {",
          "802:             if let Some(slot) = slot.get_mut().unwrap() {",
          "803:                 slot.no_clear_on_drop();",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1145: #[cfg(test)]",
          "1146: mod test {",
          "1147:     use super::*;",
          "1149:     use std::sync::Arc;",
          "1150:     use wasmtime_environ::{",
          "1151:         DefinedFuncIndex, DefinedMemoryIndex, EntityRef, FunctionInfo, Global, GlobalInit, Memory,",
          "",
          "[Removed Lines]",
          "1148:     use crate::{CompiledModuleId, Imports, MemoryMemFd, StorePtr, VMSharedSignatureIndex};",
          "",
          "[Added Lines]",
          "1150:     use crate::{CompiledModuleId, Imports, MemoryImage, StorePtr, VMSharedSignatureIndex};",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1456:             fn signature(&self, _: SignatureIndex) -> VMSharedSignatureIndex {",
          "1457:                 unimplemented!()",
          "1458:             }",
          "1460:                 &self,",
          "1461:                 _: DefinedMemoryIndex,",
          "1463:                 Ok(None)",
          "1464:             }",
          "",
          "[Removed Lines]",
          "1459:             fn memfd_image(",
          "1462:             ) -> anyhow::Result<Option<&Arc<MemoryMemFd>>> {",
          "",
          "[Added Lines]",
          "1461:             fn memory_image(",
          "1464:             ) -> anyhow::Result<Option<&Arc<MemoryImage>>> {",
          "",
          "---------------"
        ],
        "crates/runtime/src/lib.rs||crates/runtime/src/lib.rs": [
          "File: crates/runtime/src/lib.rs -> crates/runtime/src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "19:         clippy::use_self",
          "20:     )",
          "21: )]",
          "24: use std::sync::atomic::AtomicU64;",
          "25: use std::sync::Arc;",
          "",
          "[Removed Lines]",
          "22: #![cfg_attr(not(memfd), allow(unused_variables, unreachable_code))]",
          "",
          "[Added Lines]",
          "22: #![cfg_attr(not(memory_init_cow), allow(unused_variables, unreachable_code))]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74: mod module_id;",
          "75: pub use module_id::{CompiledModuleId, CompiledModuleIdAllocator};",
          "88: pub const VERSION: &str = env!(\"CARGO_PKG_VERSION\");",
          "",
          "[Removed Lines]",
          "77: #[cfg(memfd)]",
          "78: mod memfd;",
          "79: #[cfg(memfd)]",
          "80: pub use crate::memfd::{MemFdSlot, MemoryMemFd, ModuleMemFds};",
          "82: #[cfg(not(memfd))]",
          "83: mod memfd_disabled;",
          "84: #[cfg(not(memfd))]",
          "85: pub use crate::memfd_disabled::{MemFdSlot, MemoryMemFd, ModuleMemFds};",
          "",
          "[Added Lines]",
          "77: #[cfg(memory_init_cow)]",
          "78: mod cow;",
          "79: #[cfg(memory_init_cow)]",
          "80: pub use crate::cow::{MemoryImage, MemoryImageSlot, ModuleMemoryImages};",
          "82: #[cfg(not(memory_init_cow))]",
          "83: mod cow_disabled;",
          "84: #[cfg(not(memory_init_cow))]",
          "85: pub use crate::cow_disabled::{MemoryImage, MemoryImageSlot, ModuleMemoryImages};",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "181:     fn function_info(&self, func_index: DefinedFuncIndex) -> &FunctionInfo;",
          "",
          "[Removed Lines]",
          "184:     fn memfd_image(&self, memory: DefinedMemoryIndex) -> anyhow::Result<Option<&Arc<MemoryMemFd>>>;",
          "",
          "[Added Lines]",
          "185:     fn memory_image(&self, memory: DefinedMemoryIndex)",
          "186:         -> anyhow::Result<Option<&Arc<MemoryImage>>>;",
          "",
          "---------------"
        ],
        "crates/runtime/src/memory.rs||crates/runtime/src/memory.rs": [
          "File: crates/runtime/src/memory.rs -> crates/runtime/src/memory.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: use crate::mmap::Mmap;",
          "6: use crate::vmcontext::VMMemoryDefinition;",
          "9: use crate::Store;",
          "10: use anyhow::Error;",
          "11: use anyhow::{bail, format_err, Result};",
          "",
          "[Removed Lines]",
          "7: use crate::MemFdSlot;",
          "8: use crate::MemoryMemFd;",
          "",
          "[Added Lines]",
          "7: use crate::MemoryImage;",
          "8: use crate::MemoryImageSlot;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "25:         plan: &MemoryPlan,",
          "26:         minimum: usize,",
          "27:         maximum: Option<usize>,",
          "30:     ) -> Result<Box<dyn RuntimeLinearMemory>>;",
          "31: }",
          "",
          "[Removed Lines]",
          "29:         memfd_image: Option<&Arc<MemoryMemFd>>,",
          "",
          "[Added Lines]",
          "29:         memory_image: Option<&Arc<MemoryImage>>,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "40:         plan: &MemoryPlan,",
          "41:         minimum: usize,",
          "42:         maximum: Option<usize>,",
          "44:     ) -> Result<Box<dyn RuntimeLinearMemory>> {",
          "45:         Ok(Box::new(MmapMemory::new(",
          "46:             plan,",
          "47:             minimum,",
          "48:             maximum,",
          "50:         )?))",
          "51:     }",
          "52: }",
          "",
          "[Removed Lines]",
          "43:         memfd_image: Option<&Arc<MemoryMemFd>>,",
          "49:             memfd_image,",
          "",
          "[Added Lines]",
          "43:         memory_image: Option<&Arc<MemoryImage>>,",
          "49:             memory_image,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "103:     pre_guard_size: usize,",
          "104:     offset_guard_size: usize,",
          "113: }",
          "115: impl MmapMemory {",
          "",
          "[Removed Lines]",
          "112:     memfd: Option<MemFdSlot>,",
          "",
          "[Added Lines]",
          "108:     memory_image: Option<MemoryImageSlot>,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "118:         plan: &MemoryPlan,",
          "119:         minimum: usize,",
          "120:         mut maximum: Option<usize>,",
          "122:     ) -> Result<Self> {",
          "",
          "[Removed Lines]",
          "121:         memfd_image: Option<&Arc<MemoryMemFd>>,",
          "",
          "[Added Lines]",
          "117:         memory_image: Option<&Arc<MemoryImage>>,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "155:             mmap.make_accessible(pre_guard_bytes, minimum)?;",
          "156:         }",
          "160:             Some(image) => {",
          "161:                 let base = unsafe { mmap.as_mut_ptr().add(pre_guard_bytes) };",
          "163:                     base.cast(),",
          "164:                     minimum,",
          "165:                     alloc_bytes + extra_to_reserve_on_growth,",
          "166:                 );",
          "174:             }",
          "175:             None => None,",
          "176:         };",
          "",
          "[Removed Lines]",
          "159:         let memfd = match memfd_image {",
          "162:                 let mut memfd_slot = MemFdSlot::create(",
          "167:                 memfd_slot.instantiate(minimum, Some(image))?;",
          "172:                 memfd_slot.no_clear_on_drop();",
          "173:                 Some(memfd_slot)",
          "",
          "[Added Lines]",
          "156:         let memory_image = match memory_image {",
          "159:                 let mut slot = MemoryImageSlot::create(",
          "164:                 slot.instantiate(minimum, Some(image))?;",
          "168:                 slot.no_clear_on_drop();",
          "169:                 Some(slot)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "182:             pre_guard_size: pre_guard_bytes,",
          "183:             offset_guard_size: offset_guard_bytes,",
          "184:             extra_to_reserve_on_growth,",
          "186:         })",
          "187:     }",
          "188: }",
          "",
          "[Removed Lines]",
          "185:             memfd,",
          "",
          "[Added Lines]",
          "181:             memory_image,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "215:             new_mmap.as_mut_slice()[self.pre_guard_size..][..self.accessible]",
          "216:                 .copy_from_slice(&self.mmap.as_slice()[self.pre_guard_size..][..self.accessible]);",
          "226:             self.mmap = new_mmap;",
          "231:         } else {",
          "",
          "[Removed Lines]",
          "224:             let _ = self.memfd.take();",
          "227:         } else if let Some(memfd) = self.memfd.as_mut() {",
          "230:             memfd.set_heap_limit(new_size)?;",
          "",
          "[Added Lines]",
          "219:             drop(self.memory_image.take());",
          "222:         } else if let Some(image) = self.memory_image.as_mut() {",
          "225:             image.set_heap_limit(new_size)?;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "255:     }",
          "257:     fn needs_init(&self) -> bool {",
          "261:     }",
          "262: }",
          "",
          "[Removed Lines]",
          "260:         self.memfd.is_none()",
          "",
          "[Added Lines]",
          "255:         self.memory_image.is_none()",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "279:         make_accessible: Option<fn(*mut u8, usize) -> Result<()>>,",
          "",
          "[Removed Lines]",
          "283:         memfd_slot: Option<MemFdSlot>,",
          "",
          "[Added Lines]",
          "278:         memory_image: Option<MemoryImageSlot>,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "299:         plan: &MemoryPlan,",
          "300:         creator: &dyn RuntimeMemoryCreator,",
          "301:         store: &mut dyn Store,",
          "303:     ) -> Result<Self> {",
          "304:         let (minimum, maximum) = Self::limit_new(plan, store)?;",
          "305:         Ok(Memory::Dynamic(creator.new_memory(",
          "306:             plan,",
          "307:             minimum,",
          "308:             maximum,",
          "310:         )?))",
          "311:     }",
          "",
          "[Removed Lines]",
          "302:         memfd_image: Option<&Arc<MemoryMemFd>>,",
          "309:             memfd_image,",
          "",
          "[Added Lines]",
          "297:         memory_image: Option<&Arc<MemoryImage>>,",
          "304:             memory_image,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "315:         plan: &MemoryPlan,",
          "316:         base: &'static mut [u8],",
          "317:         make_accessible: Option<fn(*mut u8, usize) -> Result<()>>,",
          "319:         store: &mut dyn Store,",
          "320:     ) -> Result<Self> {",
          "321:         let (minimum, maximum) = Self::limit_new(plan, store)?;",
          "",
          "[Removed Lines]",
          "318:         memfd_slot: Option<MemFdSlot>,",
          "",
          "[Added Lines]",
          "313:         memory_image: Option<MemoryImageSlot>,",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "335:             base,",
          "336:             size: minimum,",
          "337:             make_accessible,",
          "339:             #[cfg(all(feature = \"uffd\", target_os = \"linux\"))]",
          "340:             guard_page_faults: Vec::new(),",
          "341:         })",
          "",
          "[Removed Lines]",
          "338:             memfd_slot,",
          "",
          "[Added Lines]",
          "333:             memory_image,",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "461:     pub(crate) fn needs_init(&self) -> bool {",
          "462:         match self {",
          "463:             Memory::Static {",
          "465:                 ..",
          "466:             } => !slot.has_image(),",
          "467:             Memory::Dynamic(mem) => mem.needs_init(),",
          "",
          "[Removed Lines]",
          "464:                 memfd_slot: Some(ref slot),",
          "",
          "[Added Lines]",
          "459:                 memory_image: Some(slot),",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "542:             Memory::Static {",
          "543:                 base,",
          "544:                 size,",
          "546:                 ..",
          "547:             } => {",
          "",
          "[Removed Lines]",
          "545:                 memfd_slot: Some(ref mut memfd_slot),",
          "",
          "[Added Lines]",
          "540:                 memory_image: Some(image),",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "551:                     return Ok(None);",
          "552:                 }",
          "555:                     store.memory_grow_failed(&e);",
          "556:                     return Ok(None);",
          "557:                 }",
          "",
          "[Removed Lines]",
          "554:                 if let Err(e) = memfd_slot.set_heap_limit(new_byte_size) {",
          "",
          "[Added Lines]",
          "549:                 if let Err(e) = image.set_heap_limit(new_byte_size) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "564:                 ..",
          "565:             } => {",
          "566:                 let make_accessible = make_accessible",
          "570:                 if new_byte_size > base.len() {",
          "",
          "[Removed Lines]",
          "567:                     .expect(\"make_accessible must be Some if this is not a MemFD memory\");",
          "",
          "[Added Lines]",
          "562:                     .expect(\"make_accessible must be Some if this is not a CoW memory\");",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "658:             base: &mut [],",
          "659:             size: 0,",
          "660:             make_accessible: Some(|_, _| unreachable!()),",
          "662:             #[cfg(all(feature = \"uffd\", target_os = \"linux\"))]",
          "663:             guard_page_faults: Vec::new(),",
          "664:         }",
          "",
          "[Removed Lines]",
          "661:             memfd_slot: None,",
          "",
          "[Added Lines]",
          "656:             memory_image: None,",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/config.rs||crates/wasmtime/src/config.rs": [
          "File: crates/wasmtime/src/config.rs -> crates/wasmtime/src/config.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "104:     pub(crate) module_version: ModuleVersionStrategy,",
          "105:     pub(crate) parallel_compilation: bool,",
          "106:     pub(crate) paged_memory_initialization: bool,",
          "109: }",
          "111: impl Config {",
          "",
          "[Removed Lines]",
          "107:     pub(crate) memfd: bool,",
          "108:     pub(crate) memfd_guaranteed_dense_image_size: u64,",
          "",
          "[Added Lines]",
          "107:     pub(crate) memory_init_cow: bool,",
          "108:     pub(crate) memory_guaranteed_dense_image_size: u64,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "131:             parallel_compilation: true,",
          "133:             paged_memory_initialization: cfg!(all(target_os = \"linux\", feature = \"uffd\")),",
          "136:         };",
          "137:         #[cfg(compiler)]",
          "138:         {",
          "",
          "[Removed Lines]",
          "134:             memfd: false,",
          "135:             memfd_guaranteed_dense_image_size: 16 << 20,",
          "",
          "[Added Lines]",
          "134:             memory_init_cow: true,",
          "135:             memory_guaranteed_dense_image_size: 16 << 20,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1178:         self",
          "1179:     }",
          "1205:         self",
          "1206:     }",
          "1246:         self",
          "1247:     }",
          "",
          "[Removed Lines]",
          "1201:     #[cfg(feature = \"memfd\")]",
          "1202:     #[cfg_attr(nightlydoc, doc(cfg(feature = \"memfd\")))]",
          "1203:     pub fn memfd(&mut self, memfd: bool) -> &mut Self {",
          "1204:         self.memfd = memfd;",
          "1242:     #[cfg(feature = \"memfd\")]",
          "1243:     #[cfg_attr(nightlydoc, doc(cfg(feature = \"memfd\")))]",
          "1244:     pub fn memfd_guaranteed_dense_image_size(&mut self, size_in_bytes: u64) -> &mut Self {",
          "1245:         self.memfd_guaranteed_dense_image_size = size_in_bytes;",
          "",
          "[Added Lines]",
          "1220:     #[cfg(feature = \"memory-init-cow\")]",
          "1221:     #[cfg_attr(nightlydoc, doc(cfg(feature = \"memory-init-cow\")))]",
          "1222:     pub fn memory_init_cow(&mut self, enable: bool) -> &mut Self {",
          "1223:         self.memory_init_cow = enable;",
          "1262:     #[cfg(feature = \"memory-init-cow\")]",
          "1263:     #[cfg_attr(nightlydoc, doc(cfg(feature = \"memory-init-cow\")))]",
          "1264:     pub fn memory_guaranteed_dense_image_size(&mut self, size_in_bytes: u64) -> &mut Self {",
          "1265:         self.memory_guaranteed_dense_image_size = size_in_bytes;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1315:             module_version: self.module_version.clone(),",
          "1316:             parallel_compilation: self.parallel_compilation,",
          "1317:             paged_memory_initialization: self.paged_memory_initialization,",
          "1320:         }",
          "1321:     }",
          "1322: }",
          "",
          "[Removed Lines]",
          "1318:             memfd: self.memfd,",
          "1319:             memfd_guaranteed_dense_image_size: self.memfd_guaranteed_dense_image_size,",
          "",
          "[Added Lines]",
          "1338:             memory_init_cow: self.memory_init_cow,",
          "1339:             memory_guaranteed_dense_image_size: self.memory_guaranteed_dense_image_size,",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/lib.rs||crates/wasmtime/src/lib.rs": [
          "File: crates/wasmtime/src/lib.rs -> crates/wasmtime/src/lib.rs"
        ],
        "crates/wasmtime/src/module.rs||crates/wasmtime/src/module.rs": [
          "File: crates/wasmtime/src/module.rs -> crates/wasmtime/src/module.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: };",
          "17: use wasmtime_jit::{CompiledModule, CompiledModuleInfo, TypeTables};",
          "18: use wasmtime_runtime::{",
          "20: };",
          "22: mod registry;",
          "",
          "[Removed Lines]",
          "19:     CompiledModuleId, MemoryMemFd, MmapVec, ModuleMemFds, VMSharedSignatureIndex,",
          "",
          "[Added Lines]",
          "19:     CompiledModuleId, MemoryImage, MmapVec, ModuleMemoryImages, VMSharedSignatureIndex,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "114:     types: Arc<TypeTables>,",
          "116:     signatures: Arc<SignatureCollection>,",
          "122: }",
          "124: impl Module {",
          "",
          "[Removed Lines]",
          "121:     memfds: OnceCell<Option<ModuleMemFds>>,",
          "",
          "[Added Lines]",
          "120:     memory_images: OnceCell<Option<ModuleMemoryImages>>,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "434:                 let align = engine.compiler().page_size_align();",
          "436:                 translation.try_static_init(align, max_always_allowed);",
          "437:             }",
          "",
          "[Removed Lines]",
          "433:             if engine.config().memfd {",
          "435:                 let max_always_allowed = engine.config().memfd_guaranteed_dense_image_size;",
          "",
          "[Added Lines]",
          "432:             if engine.config().memory_init_cow {",
          "434:                 let max_always_allowed = engine.config().memory_guaranteed_dense_image_size;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "575:                 artifact_upvars: modules,",
          "576:                 module_upvars,",
          "577:                 signatures,",
          "579:             }),",
          "580:         });",
          "",
          "[Removed Lines]",
          "578:                 memfds: OnceCell::new(),",
          "",
          "[Added Lines]",
          "577:                 memory_images: OnceCell::new(),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "594:                     engine: engine.clone(),",
          "595:                     types: types.clone(),",
          "596:                     module,",
          "598:                     artifact_upvars: artifact_upvars",
          "599:                         .iter()",
          "600:                         .map(|i| artifacts[*i].clone())",
          "",
          "[Removed Lines]",
          "597:                     memfds: OnceCell::new(),",
          "",
          "[Added Lines]",
          "596:                     memory_images: OnceCell::new(),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "720:                 types: self.inner.types.clone(),",
          "721:                 engine: self.inner.engine.clone(),",
          "722:                 module,",
          "724:                 artifact_upvars: artifact_upvars",
          "725:                     .iter()",
          "726:                     .map(|i| self.inner.artifact_upvars[*i].clone())",
          "",
          "[Removed Lines]",
          "723:                 memfds: OnceCell::new(),",
          "",
          "[Added Lines]",
          "722:                 memory_images: OnceCell::new(),",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1032:         self.module.func_info(index)",
          "1033:     }",
          "1037:             return Ok(None);",
          "1038:         }",
          "1042:                 self.module.module(),",
          "1043:                 self.module.wasm_data(),",
          "1044:                 Some(self.module.mmap()),",
          "1045:             )",
          "1046:         })?;",
          "1048:             .as_ref()",
          "1050:     }",
          "1052:     fn unique_id(&self) -> Option<CompiledModuleId> {",
          "",
          "[Removed Lines]",
          "1035:     fn memfd_image(&self, memory: DefinedMemoryIndex) -> Result<Option<&Arc<MemoryMemFd>>> {",
          "1036:         if !self.engine.config().memfd {",
          "1040:         let memfds = self.memfds.get_or_try_init(|| {",
          "1041:             ModuleMemFds::new(",
          "1047:         Ok(memfds",
          "1049:             .and_then(|memfds| memfds.get_memory_image(memory)))",
          "",
          "[Added Lines]",
          "1034:     fn memory_image(&self, memory: DefinedMemoryIndex) -> Result<Option<&Arc<MemoryImage>>> {",
          "1035:         if !self.engine.config().memory_init_cow {",
          "1039:         let images = self.memory_images.get_or_try_init(|| {",
          "1040:             ModuleMemoryImages::new(",
          "1046:         Ok(images",
          "1048:             .and_then(|images| images.get_memory_image(memory)))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1138:         &self.function_info[index]",
          "1139:     }",
          "1142:         Ok(None)",
          "1143:     }",
          "",
          "[Removed Lines]",
          "1141:     fn memfd_image(&self, _memory: DefinedMemoryIndex) -> Result<Option<&Arc<MemoryMemFd>>> {",
          "",
          "[Added Lines]",
          "1140:     fn memory_image(&self, _memory: DefinedMemoryIndex) -> Result<Option<&Arc<MemoryImage>>> {",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/trampoline/memory.rs||crates/wasmtime/src/trampoline/memory.rs": [
          "File: crates/wasmtime/src/trampoline/memory.rs -> crates/wasmtime/src/trampoline/memory.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: use std::sync::Arc;",
          "8: use wasmtime_environ::{EntityIndex, MemoryPlan, MemoryStyle, Module, WASM_PAGE_SIZE};",
          "9: use wasmtime_runtime::{",
          "11: };",
          "13: pub fn create_memory(store: &mut StoreOpaque, memory: &MemoryType) -> Result<InstanceId> {",
          "",
          "[Removed Lines]",
          "10:     MemoryMemFd, RuntimeLinearMemory, RuntimeMemoryCreator, VMMemoryDefinition,",
          "",
          "[Added Lines]",
          "10:     MemoryImage, RuntimeLinearMemory, RuntimeMemoryCreator, VMMemoryDefinition,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63:         plan: &MemoryPlan,",
          "64:         minimum: usize,",
          "65:         maximum: Option<usize>,",
          "67:     ) -> Result<Box<dyn RuntimeLinearMemory>> {",
          "68:         let ty = MemoryType::from_wasmtime_memory(&plan.memory);",
          "69:         let reserved_size_in_bytes = match plan.style {",
          "",
          "[Removed Lines]",
          "66:         _: Option<&Arc<MemoryMemFd>>,",
          "",
          "[Added Lines]",
          "66:         _: Option<&Arc<MemoryImage>>,",
          "",
          "---------------"
        ],
        "src/lib.rs||src/lib.rs": [
          "File: src/lib.rs -> src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "252:     #[structopt(long)]",
          "253:     paged_memory_initialization: bool,",
          "257:     #[cfg(feature = \"pooling-allocator\")]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "257:     #[cfg(feature = \"memory-init-cow\")]",
          "258:     #[structopt(long)]",
          "259:     disable_memory_init_cow: bool,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "335:         config.epoch_interruption(self.epoch_interruption);",
          "336:         config.generate_address_map(!self.disable_address_map);",
          "337:         config.paged_memory_initialization(self.paged_memory_initialization);",
          "339:         #[cfg(feature = \"pooling-allocator\")]",
          "340:         {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "344:         #[cfg(feature = \"memory-init-cow\")]",
          "345:         config.memory_init_cow(!self.disable_memory_init_cow);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a528e0383e1177119a6c985dac1972513df11a03",
      "candidate_info": {
        "commit_hash": "a528e0383e1177119a6c985dac1972513df11a03",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/a528e0383e1177119a6c985dac1972513df11a03",
        "files": [
          "Cargo.lock",
          "Cargo.toml",
          "RELEASES.md",
          "cranelift/bforest/Cargo.toml",
          "cranelift/codegen/Cargo.toml",
          "cranelift/codegen/meta/Cargo.toml",
          "cranelift/codegen/shared/Cargo.toml",
          "cranelift/egraph/Cargo.toml",
          "cranelift/entity/Cargo.toml",
          "cranelift/frontend/Cargo.toml",
          "cranelift/interpreter/Cargo.toml",
          "cranelift/isle/isle/Cargo.toml",
          "cranelift/jit/Cargo.toml",
          "cranelift/module/Cargo.toml",
          "cranelift/native/Cargo.toml",
          "cranelift/object/Cargo.toml",
          "cranelift/preopt/Cargo.toml",
          "cranelift/reader/Cargo.toml",
          "cranelift/serde/Cargo.toml",
          "cranelift/umbrella/Cargo.toml",
          "cranelift/wasm/Cargo.toml",
          "crates/runtime/src/cow.rs",
          "crates/runtime/src/instance/allocator/pooling.rs"
        ],
        "message": "Release Wasmtime 2.0.2 (#5218)\n\n* Release Wasmtime 2.0.2\n\n[automatically-tag-and-release-this-commit]\n\n* Add release notes for 2.0.2\n\n* Fix an invalid zero-sized call to mmap\n\n* Fix windows tests\n\nCo-authored-by: Wasmtime Publish <wasmtime-publish@users.noreply.github.com>\nCo-authored-by: Alex Crichton <alex@alexcrichton.com>",
        "before_after_code_files": [
          "Cargo.lock||Cargo.lock",
          "crates/runtime/src/cow.rs||crates/runtime/src/cow.rs",
          "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs"
          ],
          "candidate": [
            "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs"
          ]
        }
      },
      "candidate_diff": {
        "Cargo.lock||Cargo.lock": [
          "File: Cargo.lock -> Cargo.lock",
          "--- Hunk 1 ---",
          "[Context before]",
          "506: [[package]]",
          "507: name = \"cranelift\"",
          "509: dependencies = [",
          "510:  \"cranelift-codegen\",",
          "511:  \"cranelift-frontend\",",
          "",
          "[Removed Lines]",
          "508: version = \"0.89.1\"",
          "",
          "[Added Lines]",
          "508: version = \"0.89.2\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "514: [[package]]",
          "515: name = \"cranelift-bforest\"",
          "517: dependencies = [",
          "518:  \"cranelift-entity\",",
          "519: ]",
          "521: [[package]]",
          "522: name = \"cranelift-codegen\"",
          "524: dependencies = [",
          "525:  \"arrayvec\",",
          "526:  \"bincode\",",
          "",
          "[Removed Lines]",
          "516: version = \"0.89.1\"",
          "523: version = \"0.89.1\"",
          "",
          "[Added Lines]",
          "516: version = \"0.89.2\"",
          "523: version = \"0.89.2\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "546: [[package]]",
          "547: name = \"cranelift-codegen-meta\"",
          "549: dependencies = [",
          "550:  \"cranelift-codegen-shared\",",
          "551: ]",
          "553: [[package]]",
          "554: name = \"cranelift-codegen-shared\"",
          "557: [[package]]",
          "558: name = \"cranelift-egraph\"",
          "560: dependencies = [",
          "561:  \"cranelift-entity\",",
          "562:  \"fxhash\",",
          "",
          "[Removed Lines]",
          "548: version = \"0.89.1\"",
          "555: version = \"0.89.1\"",
          "559: version = \"0.89.1\"",
          "",
          "[Added Lines]",
          "548: version = \"0.89.2\"",
          "555: version = \"0.89.2\"",
          "559: version = \"0.89.2\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "569: [[package]]",
          "570: name = \"cranelift-entity\"",
          "572: dependencies = [",
          "573:  \"serde\",",
          "574: ]",
          "",
          "[Removed Lines]",
          "571: version = \"0.89.1\"",
          "",
          "[Added Lines]",
          "571: version = \"0.89.2\"",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "599: [[package]]",
          "600: name = \"cranelift-frontend\"",
          "602: dependencies = [",
          "603:  \"cranelift-codegen\",",
          "604:  \"hashbrown\",",
          "",
          "[Removed Lines]",
          "601: version = \"0.89.1\"",
          "",
          "[Added Lines]",
          "601: version = \"0.89.2\"",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "620: [[package]]",
          "621: name = \"cranelift-interpreter\"",
          "623: dependencies = [",
          "624:  \"cranelift-codegen\",",
          "625:  \"cranelift-entity\",",
          "",
          "[Removed Lines]",
          "622: version = \"0.89.1\"",
          "",
          "[Added Lines]",
          "622: version = \"0.89.2\"",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "634: [[package]]",
          "635: name = \"cranelift-isle\"",
          "637: dependencies = [",
          "638:  \"log\",",
          "639:  \"miette\",",
          "",
          "[Removed Lines]",
          "636: version = \"0.89.1\"",
          "",
          "[Added Lines]",
          "636: version = \"0.89.2\"",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "643: [[package]]",
          "644: name = \"cranelift-jit\"",
          "646: dependencies = [",
          "647:  \"anyhow\",",
          "648:  \"cranelift\",",
          "",
          "[Removed Lines]",
          "645: version = \"0.89.1\"",
          "",
          "[Added Lines]",
          "645: version = \"0.89.2\"",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "662: [[package]]",
          "663: name = \"cranelift-module\"",
          "665: dependencies = [",
          "666:  \"anyhow\",",
          "667:  \"cranelift-codegen\",",
          "",
          "[Removed Lines]",
          "664: version = \"0.89.1\"",
          "",
          "[Added Lines]",
          "664: version = \"0.89.2\"",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "671: [[package]]",
          "672: name = \"cranelift-native\"",
          "674: dependencies = [",
          "675:  \"cranelift-codegen\",",
          "676:  \"libc\",",
          "",
          "[Removed Lines]",
          "673: version = \"0.89.1\"",
          "",
          "[Added Lines]",
          "673: version = \"0.89.2\"",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "680: [[package]]",
          "681: name = \"cranelift-object\"",
          "683: dependencies = [",
          "684:  \"anyhow\",",
          "685:  \"cranelift-codegen\",",
          "",
          "[Removed Lines]",
          "682: version = \"0.89.1\"",
          "",
          "[Added Lines]",
          "682: version = \"0.89.2\"",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "694: [[package]]",
          "695: name = \"cranelift-preopt\"",
          "697: dependencies = [",
          "698:  \"cranelift-codegen\",",
          "699: ]",
          "701: [[package]]",
          "702: name = \"cranelift-reader\"",
          "704: dependencies = [",
          "705:  \"cranelift-codegen\",",
          "706:  \"smallvec\",",
          "",
          "[Removed Lines]",
          "696: version = \"0.89.1\"",
          "703: version = \"0.89.1\"",
          "",
          "[Added Lines]",
          "696: version = \"0.89.2\"",
          "703: version = \"0.89.2\"",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "710: [[package]]",
          "711: name = \"cranelift-serde\"",
          "713: dependencies = [",
          "714:  \"clap 3.2.8\",",
          "715:  \"cranelift-codegen\",",
          "",
          "[Removed Lines]",
          "712: version = \"0.89.1\"",
          "",
          "[Added Lines]",
          "712: version = \"0.89.2\"",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "753: [[package]]",
          "754: name = \"cranelift-wasm\"",
          "756: dependencies = [",
          "757:  \"cranelift-codegen\",",
          "758:  \"cranelift-entity\",",
          "",
          "[Removed Lines]",
          "755: version = \"0.89.1\"",
          "",
          "[Added Lines]",
          "755: version = \"0.89.2\"",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3092: [[package]]",
          "3093: name = \"wasi-cap-std-sync\"",
          "3095: dependencies = [",
          "3096:  \"anyhow\",",
          "3097:  \"async-trait\",",
          "",
          "[Removed Lines]",
          "3094: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3094: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "3115: [[package]]",
          "3116: name = \"wasi-common\"",
          "3118: dependencies = [",
          "3119:  \"anyhow\",",
          "3120:  \"bitflags\",",
          "",
          "[Removed Lines]",
          "3117: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3117: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "3160: [[package]]",
          "3161: name = \"wasi-tokio\"",
          "3163: dependencies = [",
          "3164:  \"anyhow\",",
          "3165:  \"cap-std\",",
          "",
          "[Removed Lines]",
          "3162: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3162: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "3320: [[package]]",
          "3321: name = \"wasmtime\"",
          "3323: dependencies = [",
          "3324:  \"anyhow\",",
          "3325:  \"async-trait\",",
          "",
          "[Removed Lines]",
          "3322: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3322: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "3355: [[package]]",
          "3356: name = \"wasmtime-asm-macros\"",
          "3358: dependencies = [",
          "3359:  \"cfg-if\",",
          "3360: ]",
          "3362: [[package]]",
          "3363: name = \"wasmtime-bench-api\"",
          "3365: dependencies = [",
          "3366:  \"anyhow\",",
          "3367:  \"cap-std\",",
          "",
          "[Removed Lines]",
          "3357: version = \"2.0.1\"",
          "3364: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3357: version = \"2.0.2\"",
          "3364: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "3379: [[package]]",
          "3380: name = \"wasmtime-c-api\"",
          "3382: dependencies = [",
          "3383:  \"anyhow\",",
          "3384:  \"cap-std\",",
          "",
          "[Removed Lines]",
          "3381: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3381: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "3402: [[package]]",
          "3403: name = \"wasmtime-cache\"",
          "3405: dependencies = [",
          "3406:  \"anyhow\",",
          "3407:  \"base64\",",
          "",
          "[Removed Lines]",
          "3404: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3404: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3424: [[package]]",
          "3425: name = \"wasmtime-cli\"",
          "3427: dependencies = [",
          "3428:  \"anyhow\",",
          "3429:  \"async-trait\",",
          "",
          "[Removed Lines]",
          "3426: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3426: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3465: [[package]]",
          "3466: name = \"wasmtime-cli-flags\"",
          "3468: dependencies = [",
          "3469:  \"anyhow\",",
          "3470:  \"clap 3.2.8\",",
          "",
          "[Removed Lines]",
          "3467: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3467: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3477: [[package]]",
          "3478: name = \"wasmtime-component-macro\"",
          "3480: dependencies = [",
          "3481:  \"proc-macro2\",",
          "3482:  \"quote\",",
          "",
          "[Removed Lines]",
          "3479: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3479: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3487: [[package]]",
          "3488: name = \"wasmtime-component-util\"",
          "3491: [[package]]",
          "3492: name = \"wasmtime-cranelift\"",
          "3494: dependencies = [",
          "3495:  \"anyhow\",",
          "3496:  \"cranelift-codegen\",",
          "",
          "[Removed Lines]",
          "3489: version = \"2.0.1\"",
          "3493: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3489: version = \"2.0.2\"",
          "3493: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "3510: [[package]]",
          "3511: name = \"wasmtime-environ\"",
          "3513: dependencies = [",
          "3514:  \"anyhow\",",
          "3515:  \"atty\",",
          "",
          "[Removed Lines]",
          "3512: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3512: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "3548: [[package]]",
          "3549: name = \"wasmtime-fiber\"",
          "3551: dependencies = [",
          "3552:  \"backtrace\",",
          "3553:  \"cc\",",
          "",
          "[Removed Lines]",
          "3550: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3550: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3612: [[package]]",
          "3613: name = \"wasmtime-jit\"",
          "3615: dependencies = [",
          "3616:  \"addr2line\",",
          "3617:  \"anyhow\",",
          "",
          "[Removed Lines]",
          "3614: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3614: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "3636: [[package]]",
          "3637: name = \"wasmtime-jit-debug\"",
          "3639: dependencies = [",
          "3640:  \"object\",",
          "3641:  \"once_cell\",",
          "",
          "[Removed Lines]",
          "3638: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3638: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3645: [[package]]",
          "3646: name = \"wasmtime-runtime\"",
          "3648: dependencies = [",
          "3649:  \"anyhow\",",
          "3650:  \"cc\",",
          "",
          "[Removed Lines]",
          "3647: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3647: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "3670: [[package]]",
          "3671: name = \"wasmtime-types\"",
          "3673: dependencies = [",
          "3674:  \"cranelift-entity\",",
          "3675:  \"serde\",",
          "",
          "[Removed Lines]",
          "3672: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3672: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "3680: [[package]]",
          "3681: name = \"wasmtime-wasi\"",
          "3683: dependencies = [",
          "3684:  \"anyhow\",",
          "3685:  \"wasi-cap-std-sync\",",
          "",
          "[Removed Lines]",
          "3682: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3682: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "3692: [[package]]",
          "3693: name = \"wasmtime-wasi-crypto\"",
          "3695: dependencies = [",
          "3696:  \"anyhow\",",
          "3697:  \"wasi-crypto\",",
          "",
          "[Removed Lines]",
          "3694: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3694: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "3702: [[package]]",
          "3703: name = \"wasmtime-wasi-nn\"",
          "3705: dependencies = [",
          "3706:  \"anyhow\",",
          "3707:  \"openvino\",",
          "",
          "[Removed Lines]",
          "3704: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3704: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "3713: [[package]]",
          "3714: name = \"wasmtime-wast\"",
          "3716: dependencies = [",
          "3717:  \"anyhow\",",
          "3718:  \"log\",",
          "",
          "[Removed Lines]",
          "3715: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3715: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "3774: [[package]]",
          "3775: name = \"wiggle\"",
          "3777: dependencies = [",
          "3778:  \"anyhow\",",
          "3779:  \"async-trait\",",
          "",
          "[Removed Lines]",
          "3776: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3776: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "3791: [[package]]",
          "3792: name = \"wiggle-generate\"",
          "3794: dependencies = [",
          "3795:  \"anyhow\",",
          "3796:  \"heck\",",
          "",
          "[Removed Lines]",
          "3793: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3793: version = \"2.0.2\"",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "3804: [[package]]",
          "3805: name = \"wiggle-macro\"",
          "3807: dependencies = [",
          "3808:  \"proc-macro2\",",
          "3809:  \"quote\",",
          "",
          "[Removed Lines]",
          "3806: version = \"2.0.1\"",
          "",
          "[Added Lines]",
          "3806: version = \"2.0.2\"",
          "",
          "---------------"
        ],
        "crates/runtime/src/cow.rs||crates/runtime/src/cow.rs": [
          "File: crates/runtime/src/cow.rs -> crates/runtime/src/cow.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "535:     fn reset_with_anon_memory(&self) -> Result<()> {",
          "536:         unsafe {",
          "537:             let ptr = rustix::mm::mmap_anonymous(",
          "538:                 self.base as *mut c_void,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "536:         if self.static_size == 0 {",
          "537:             return Ok(());",
          "538:         }",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs": [
          "File: crates/runtime/src/instance/allocator/pooling.rs -> crates/runtime/src/instance/allocator/pooling.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "407:                 )",
          "408:             };",
          "413:             if let Some(image) = runtime_info",
          "414:                 .memory_image(defined_index)",
          "415:                 .map_err(|err| InstantiationError::Resource(err.into()))?",
          "416:             {",
          "417:                 let initial_size = plan.memory.minimum * WASM_PAGE_SIZE as u64;",
          "",
          "[Removed Lines]",
          "410:             let mut slot = self",
          "411:                 .memories",
          "412:                 .take_memory_image_slot(instance_index, defined_index);",
          "",
          "[Added Lines]",
          "410:             let slot = if cfg!(memory_init_cow) {",
          "411:                 Some(",
          "412:                     self.memories",
          "413:                         .take_memory_image_slot(instance_index, defined_index),",
          "414:                 )",
          "415:             } else {",
          "416:                 None",
          "417:             };",
          "422:                 let mut slot = slot.unwrap();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "39a52ceb4fe3b60697242222ee6d36305415eec6",
      "candidate_info": {
        "commit_hash": "39a52ceb4fe3b60697242222ee6d36305415eec6",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/39a52ceb4fe3b60697242222ee6d36305415eec6",
        "files": [
          "cranelift/wasm/src/code_translator.rs",
          "cranelift/wasm/src/environ/dummy.rs",
          "cranelift/wasm/src/environ/spec.rs",
          "crates/cranelift/src/func_environ.rs",
          "crates/environ/src/builtin.rs",
          "crates/environ/src/lib.rs",
          "crates/environ/src/module.rs",
          "crates/environ/src/module_environ.rs",
          "crates/environ/src/ref_bits.rs",
          "crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/instance/allocator/pooling.rs",
          "crates/runtime/src/instance/allocator/pooling/uffd.rs",
          "crates/runtime/src/lib.rs",
          "crates/runtime/src/libcalls.rs",
          "crates/runtime/src/memfd.rs",
          "crates/runtime/src/memfd_disabled.rs",
          "crates/runtime/src/table.rs",
          "crates/wasmtime/src/externals.rs",
          "crates/wasmtime/src/func.rs",
          "crates/wasmtime/src/instance.rs",
          "crates/wasmtime/src/module.rs",
          "crates/wasmtime/src/store.rs",
          "crates/wasmtime/src/trampoline.rs",
          "crates/wasmtime/src/trampoline/func.rs",
          "crates/wasmtime/src/trampoline/global.rs"
        ],
        "message": "Implement lazy funcref table and anyfunc initialization. (#3733)\n\nDuring instance initialization, we build two sorts of arrays eagerly:\n\n- We create an \"anyfunc\" (a `VMCallerCheckedAnyfunc`) for every function\n  in an instance.\n\n- We initialize every element of a funcref table with an initializer to\n  a pointer to one of these anyfuncs.\n\nMost instances will not touch (via call_indirect or table.get) all\nfuncref table elements. And most anyfuncs will never be referenced,\nbecause most functions are never placed in tables or used with\n`ref.func`. Thus, both of these initialization tasks are quite wasteful.\nProfiling shows that a significant fraction of the remaining\ninstance-initialization time after our other recent optimizations is\ngoing into these two tasks.\n\nThis PR implements two basic ideas:\n\n- The anyfunc array can be lazily initialized as long as we retain the\n  information needed to do so. For now, in this PR, we just recreate the\n  anyfunc whenever a pointer is taken to it, because doing so is fast\n  enough; in the future we could keep some state to know whether the\n  anyfunc has been written yet and skip this work if redundant.\n\n  This technique allows us to leave the anyfunc array as uninitialized\n  memory, which can be a significant savings. Filling it with\n  initialized anyfuncs is very expensive, but even zeroing it is\n  expensive: e.g. in a large module, it can be >500KB.\n\n- A funcref table can be lazily initialized as long as we retain a link\n  to its corresponding instance and function index for each element. A\n  zero in a table element means \"uninitialized\", and a slowpath does the\n  initialization.\n\nFuncref tables are a little tricky because funcrefs can be null. We need\nto distinguish \"element was initially non-null, but user stored explicit\nnull later\" from \"element never touched\" (ie the lazy init should not\nblow away an explicitly stored null). We solve this by stealing the LSB\nfrom every funcref (anyfunc pointer): when the LSB is set, the funcref\nis initialized and we don't hit the lazy-init slowpath. We insert the\nbit on storing to the table and mask it off after loading.\n\nWe do have to set up a precomputed array of `FuncIndex`s for the table\nin order for this to work. We do this as part of the module compilation.\n\nThis PR also refactors the way that the runtime crate gains access to\ninformation computed during module compilation.\n\nPerformance effect measured with in-tree benches/instantiation.rs, using\nSpiderMonkey built for WASI, and with memfd enabled:\n\n```\nBEFORE:\n\nsequential/default/spidermonkey.wasm\n                        time:   [68.569 us 68.696 us 68.856 us]\nsequential/pooling/spidermonkey.wasm\n                        time:   [69.406 us 69.435 us 69.465 us]\n\nparallel/default/spidermonkey.wasm: with 1 background thread\n                        time:   [69.444 us 69.470 us 69.497 us]\nparallel/default/spidermonkey.wasm: with 16 background threads\n                        time:   [183.72 us 184.31 us 184.89 us]\nparallel/pooling/spidermonkey.wasm: with 1 background thread\n                        time:   [69.018 us 69.070 us 69.136 us]\nparallel/pooling/spidermonkey.wasm: with 16 background threads\n                        time:   [326.81 us 337.32 us 347.01 us]\n\nWITH THIS PR:\n\nsequential/default/spidermonkey.wasm\n                        time:   [6.7821 us 6.8096 us 6.8397 us]\n                        change: [-90.245% -90.193% -90.142%] (p = 0.00 < 0.05)\n                        Performance has improved.\nsequential/pooling/spidermonkey.wasm\n                        time:   [3.0410 us 3.0558 us 3.0724 us]\n                        change: [-95.566% -95.552% -95.537%] (p = 0.00 < 0.05)\n                        Performance has improved.\n\nparallel/default/spidermonkey.wasm: with 1 background thread\n                        time:   [7.2643 us 7.2689 us 7.2735 us]\n                        change: [-89.541% -89.533% -89.525%] (p = 0.00 < 0.05)\n                        Performance has improved.\nparallel/default/spidermonkey.wasm: with 16 background threads\n                        time:   [147.36 us 148.99 us 150.74 us]\n                        change: [-18.997% -18.081% -17.285%] (p = 0.00 < 0.05)\n                        Performance has improved.\nparallel/pooling/spidermonkey.wasm: with 1 background thread\n                        time:   [3.1009 us 3.1021 us 3.1033 us]\n                        change: [-95.517% -95.511% -95.506%] (p = 0.00 < 0.05)\n                        Performance has improved.\nparallel/pooling/spidermonkey.wasm: with 16 background threads\n                        time:   [49.449 us 50.475 us 51.540 us]\n                        change: [-85.423% -84.964% -84.465%] (p = 0.00 < 0.05)\n                        Performance has improved.\n```\n\nSo an improvement of something like 80-95% for a very large module (7420\nfunctions in its one funcref table, 31928 functions total).",
        "before_after_code_files": [
          "cranelift/wasm/src/code_translator.rs||cranelift/wasm/src/code_translator.rs",
          "cranelift/wasm/src/environ/dummy.rs||cranelift/wasm/src/environ/dummy.rs",
          "cranelift/wasm/src/environ/spec.rs||cranelift/wasm/src/environ/spec.rs",
          "crates/cranelift/src/func_environ.rs||crates/cranelift/src/func_environ.rs",
          "crates/environ/src/builtin.rs||crates/environ/src/builtin.rs",
          "crates/environ/src/lib.rs||crates/environ/src/lib.rs",
          "crates/environ/src/module.rs||crates/environ/src/module.rs",
          "crates/environ/src/module_environ.rs||crates/environ/src/module_environ.rs",
          "crates/environ/src/ref_bits.rs||crates/environ/src/ref_bits.rs",
          "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
          "crates/runtime/src/instance/allocator/pooling/uffd.rs||crates/runtime/src/instance/allocator/pooling/uffd.rs",
          "crates/runtime/src/lib.rs||crates/runtime/src/lib.rs",
          "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs",
          "crates/runtime/src/memfd.rs||crates/runtime/src/memfd.rs",
          "crates/runtime/src/memfd_disabled.rs||crates/runtime/src/memfd_disabled.rs",
          "crates/runtime/src/table.rs||crates/runtime/src/table.rs",
          "crates/wasmtime/src/externals.rs||crates/wasmtime/src/externals.rs",
          "crates/wasmtime/src/func.rs||crates/wasmtime/src/func.rs",
          "crates/wasmtime/src/instance.rs||crates/wasmtime/src/instance.rs",
          "crates/wasmtime/src/module.rs||crates/wasmtime/src/module.rs",
          "crates/wasmtime/src/store.rs||crates/wasmtime/src/store.rs",
          "crates/wasmtime/src/trampoline.rs||crates/wasmtime/src/trampoline.rs",
          "crates/wasmtime/src/trampoline/func.rs||crates/wasmtime/src/trampoline/func.rs",
          "crates/wasmtime/src/trampoline/global.rs||crates/wasmtime/src/trampoline/global.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs"
          ],
          "candidate": [
            "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs"
          ]
        }
      },
      "candidate_diff": {
        "cranelift/wasm/src/code_translator.rs||cranelift/wasm/src/code_translator.rs": [
          "File: cranelift/wasm/src/code_translator.rs -> cranelift/wasm/src/code_translator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "612:             bitcast_arguments(args, &types, builder);",
          "614:             let call = environ.translate_call_indirect(",
          "616:                 TableIndex::from_u32(*table_index),",
          "617:                 table,",
          "618:                 TypeIndex::from_u32(*index),",
          "",
          "[Removed Lines]",
          "615:                 builder.cursor(),",
          "",
          "[Added Lines]",
          "615:                 builder,",
          "",
          "---------------"
        ],
        "cranelift/wasm/src/environ/dummy.rs||cranelift/wasm/src/environ/dummy.rs": [
          "File: cranelift/wasm/src/environ/dummy.rs -> cranelift/wasm/src/environ/dummy.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "405:     fn translate_call_indirect(",
          "406:         &mut self,",
          "408:         _table_index: TableIndex,",
          "409:         _table: ir::Table,",
          "410:         _sig_index: TypeIndex,",
          "",
          "[Removed Lines]",
          "407:         mut pos: FuncCursor,",
          "",
          "[Added Lines]",
          "407:         builder: &mut FunctionBuilder,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "413:         call_args: &[ir::Value],",
          "414:     ) -> WasmResult<ir::Inst> {",
          "417:             .func",
          "418:             .special_param(ir::ArgumentPurpose::VMContext)",
          "419:             .expect(\"Missing vmctx parameter\");",
          "",
          "[Removed Lines]",
          "416:         let vmctx = pos",
          "",
          "[Added Lines]",
          "416:         let vmctx = builder",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "424:         let ptr = self.pointer_type();",
          "425:         let callee_offset = if ptr == I32 {",
          "427:         } else {",
          "430:         };",
          "431:         let mflags = ir::MemFlags::trusted();",
          "436:         let mut args = ir::ValueList::default();",
          "442:             .ins()",
          "443:             .CallIndirect(ir::Opcode::CallIndirect, INVALID, sig_ref, args)",
          "444:             .0)",
          "",
          "[Removed Lines]",
          "426:             pos.ins().imul_imm(callee, 4)",
          "428:             let ext = pos.ins().uextend(I64, callee);",
          "429:             pos.ins().imul_imm(ext, 4)",
          "432:         let func_ptr = pos.ins().load(ptr, mflags, callee_offset, 0);",
          "437:         args.push(func_ptr, &mut pos.func.dfg.value_lists);",
          "438:         args.extend(call_args.iter().cloned(), &mut pos.func.dfg.value_lists);",
          "439:         args.push(vmctx, &mut pos.func.dfg.value_lists);",
          "441:         Ok(pos",
          "",
          "[Added Lines]",
          "426:             builder.ins().imul_imm(callee, 4)",
          "428:             let ext = builder.ins().uextend(I64, callee);",
          "429:             builder.ins().imul_imm(ext, 4)",
          "432:         let func_ptr = builder.ins().load(ptr, mflags, callee_offset, 0);",
          "437:         args.push(func_ptr, &mut builder.func.dfg.value_lists);",
          "438:         args.extend(call_args.iter().cloned(), &mut builder.func.dfg.value_lists);",
          "439:         args.push(vmctx, &mut builder.func.dfg.value_lists);",
          "441:         Ok(builder",
          "",
          "---------------"
        ],
        "cranelift/wasm/src/environ/spec.rs||cranelift/wasm/src/environ/spec.rs": [
          "File: cranelift/wasm/src/environ/spec.rs -> cranelift/wasm/src/environ/spec.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "219:     #[cfg_attr(feature = \"cargo-clippy\", allow(clippy::too_many_arguments))]",
          "220:     fn translate_call_indirect(",
          "221:         &mut self,",
          "223:         table_index: TableIndex,",
          "224:         table: ir::Table,",
          "225:         sig_index: TypeIndex,",
          "",
          "[Removed Lines]",
          "222:         pos: FuncCursor,",
          "",
          "[Added Lines]",
          "222:         builder: &mut FunctionBuilder,",
          "",
          "---------------"
        ],
        "crates/cranelift/src/func_environ.rs||crates/cranelift/src/func_environ.rs": [
          "File: crates/cranelift/src/func_environ.rs -> crates/cranelift/src/func_environ.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use cranelift_codegen::cursor::FuncCursor;",
          "2: use cranelift_codegen::ir;",
          "3: use cranelift_codegen::ir::condcodes::*;",
          "5: use cranelift_codegen::ir::types::*;",
          "6: use cranelift_codegen::ir::{AbiParam, ArgumentPurpose, Function, InstBuilder, Signature};",
          "7: use cranelift_codegen::isa::{self, TargetFrontendConfig, TargetIsa};",
          "",
          "[Removed Lines]",
          "4: use cranelift_codegen::ir::immediates::{Offset32, Uimm64};",
          "",
          "[Added Lines]",
          "4: use cranelift_codegen::ir::immediates::{Imm64, Offset32, Uimm64};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "19:     BuiltinFunctionIndex, MemoryPlan, MemoryStyle, Module, ModuleTranslation, TableStyle, Tunables,",
          "20:     TypeTables, VMOffsets, INTERRUPTED, WASM_PAGE_SIZE,",
          "21: };",
          "24: pub fn get_func_name(func_index: FuncIndex) -> ir::ExternalName {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: use wasmtime_environ::{FUNCREF_INIT_BIT, FUNCREF_MASK};",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "750:             pos.ins().uextend(I64, val)",
          "751:         }",
          "752:     }",
          "753: }",
          "755: impl<'module_environment> TargetEnvironment for FuncEnvironment<'module_environment> {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "755:     fn get_or_init_funcref_table_elem(",
          "756:         &mut self,",
          "757:         builder: &mut FunctionBuilder,",
          "758:         table_index: TableIndex,",
          "759:         table: ir::Table,",
          "760:         index: ir::Value,",
          "761:     ) -> ir::Value {",
          "762:         let pointer_type = self.pointer_type();",
          "768:         let table_entry_addr = builder.ins().table_addr(pointer_type, table, index, 0);",
          "769:         let value = builder",
          "770:             .ins()",
          "771:             .load(pointer_type, ir::MemFlags::trusted(), table_entry_addr, 0);",
          "775:         let value_masked = builder",
          "776:             .ins()",
          "777:             .band_imm(value, Imm64::from(FUNCREF_MASK as i64));",
          "779:         let null_block = builder.create_block();",
          "780:         let continuation_block = builder.create_block();",
          "781:         let result_param = builder.append_block_param(continuation_block, pointer_type);",
          "782:         builder.set_cold_block(null_block);",
          "784:         builder.ins().brz(value, null_block, &[]);",
          "785:         builder.ins().jump(continuation_block, &[value_masked]);",
          "786:         builder.seal_block(null_block);",
          "788:         builder.switch_to_block(null_block);",
          "789:         let table_index = builder.ins().iconst(I32, table_index.index() as i64);",
          "790:         let builtin_idx = BuiltinFunctionIndex::table_get_lazy_init_funcref();",
          "791:         let builtin_sig = self",
          "792:             .builtin_function_signatures",
          "793:             .table_get_lazy_init_funcref(builder.func);",
          "794:         let (vmctx, builtin_addr) =",
          "795:             self.translate_load_builtin_function_address(&mut builder.cursor(), builtin_idx);",
          "796:         let call_inst =",
          "797:             builder",
          "798:                 .ins()",
          "799:                 .call_indirect(builtin_sig, builtin_addr, &[vmctx, table_index, index]);",
          "800:         let returned_entry = builder.func.dfg.inst_results(call_inst)[0];",
          "801:         builder.ins().jump(continuation_block, &[returned_entry]);",
          "802:         builder.seal_block(continuation_block);",
          "804:         builder.switch_to_block(continuation_block);",
          "805:         result_param",
          "806:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "886:         match plan.table.wasm_ty {",
          "887:             WasmType::FuncRef => match plan.style {",
          "888:                 TableStyle::CallerChecksSignature => {",
          "896:                 }",
          "897:             },",
          "898:             WasmType::ExternRef => {",
          "",
          "[Removed Lines]",
          "889:                     let table_entry_addr = builder.ins().table_addr(pointer_type, table, index, 0);",
          "890:                     Ok(builder.ins().load(",
          "891:                         pointer_type,",
          "892:                         ir::MemFlags::trusted(),",
          "893:                         table_entry_addr,",
          "894:                         0,",
          "895:                     ))",
          "",
          "[Added Lines]",
          "943:                     Ok(self.get_or_init_funcref_table_elem(builder, table_index, table, index))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1033:             WasmType::FuncRef => match plan.style {",
          "1034:                 TableStyle::CallerChecksSignature => {",
          "1035:                     let table_entry_addr = builder.ins().table_addr(pointer_type, table, index, 0);",
          "1037:                         .ins()",
          "1039:                     Ok(())",
          "1040:                 }",
          "1041:             },",
          "",
          "[Removed Lines]",
          "1036:                     builder",
          "1038:                         .store(ir::MemFlags::trusted(), value, table_entry_addr, 0);",
          "",
          "[Added Lines]",
          "1087:                     let value_with_init_bit = builder",
          "1089:                         .bor_imm(value, Imm64::from(FUNCREF_INIT_BIT as i64));",
          "1090:                     builder.ins().store(",
          "1091:                         ir::MemFlags::trusted(),",
          "1092:                         value_with_init_bit,",
          "1093:                         table_entry_addr,",
          "1094:                         0,",
          "1095:                     );",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1253:         mut pos: cranelift_codegen::cursor::FuncCursor<'_>,",
          "1254:         func_index: FuncIndex,",
          "1255:     ) -> WasmResult<ir::Value> {",
          "1260:     }",
          "1262:     fn translate_custom_global_get(",
          "",
          "[Removed Lines]",
          "1256:         let vmctx = self.vmctx(&mut pos.func);",
          "1257:         let vmctx = pos.ins().global_value(self.pointer_type(), vmctx);",
          "1258:         let offset = self.offsets.vmctx_anyfunc(func_index);",
          "1259:         Ok(pos.ins().iadd_imm(vmctx, i64::from(offset)))",
          "",
          "[Added Lines]",
          "1313:         let func_index = pos.ins().iconst(I32, func_index.as_u32() as i64);",
          "1314:         let builtin_index = BuiltinFunctionIndex::ref_func();",
          "1315:         let builtin_sig = self.builtin_function_signatures.ref_func(&mut pos.func);",
          "1316:         let (vmctx, builtin_addr) =",
          "1317:             self.translate_load_builtin_function_address(&mut pos, builtin_index);",
          "1319:         let call_inst = pos",
          "1320:             .ins()",
          "1321:             .call_indirect(builtin_sig, builtin_addr, &[vmctx, func_index]);",
          "1322:         Ok(pos.func.dfg.first_result(call_inst))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1460:     fn translate_call_indirect(",
          "1461:         &mut self,",
          "1463:         table_index: TableIndex,",
          "1464:         table: ir::Table,",
          "1465:         ty_index: TypeIndex,",
          "",
          "[Removed Lines]",
          "1462:         mut pos: FuncCursor<'_>,",
          "",
          "[Added Lines]",
          "1525:         builder: &mut FunctionBuilder,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1469:     ) -> WasmResult<ir::Inst> {",
          "1470:         let pointer_type = self.pointer_type();",
          "1482:             .trapz(anyfunc_ptr, ir::TrapCode::IndirectCallToNull);",
          "1485:         let mem_flags = ir::MemFlags::trusted();",
          "1487:             pointer_type,",
          "1488:             mem_flags,",
          "1489:             anyfunc_ptr,",
          "",
          "[Removed Lines]",
          "1472:         let table_entry_addr = pos.ins().table_addr(pointer_type, table, callee, 0);",
          "1476:         let anyfunc_ptr =",
          "1477:             pos.ins()",
          "1478:                 .load(pointer_type, ir::MemFlags::trusted(), table_entry_addr, 0);",
          "1481:         pos.ins()",
          "1486:         let func_addr = pos.ins().load(",
          "",
          "[Added Lines]",
          "1536:         let anyfunc_ptr = self.get_or_init_funcref_table_elem(builder, table_index, table, callee);",
          "1539:         builder",
          "1540:             .ins()",
          "1545:         let func_addr = builder.ins().load(",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1495:             TableStyle::CallerChecksSignature => {",
          "1496:                 let sig_id_size = self.offsets.size_of_vmshared_signature_index();",
          "1497:                 let sig_id_type = Type::int(u16::from(sig_id_size) * 8).unwrap();",
          "1500:                 let offset =",
          "1501:                     i32::try_from(self.offsets.vmctx_vmshared_signature_id(ty_index)).unwrap();",
          "1504:                 let mut mem_flags = ir::MemFlags::trusted();",
          "1505:                 mem_flags.set_readonly();",
          "1509:                 let mem_flags = ir::MemFlags::trusted();",
          "1511:                     sig_id_type,",
          "1512:                     mem_flags,",
          "1513:                     anyfunc_ptr,",
          "",
          "[Removed Lines]",
          "1498:                 let vmctx = self.vmctx(pos.func);",
          "1499:                 let base = pos.ins().global_value(pointer_type, vmctx);",
          "1506:                 let caller_sig_id = pos.ins().load(sig_id_type, mem_flags, base, offset);",
          "1510:                 let callee_sig_id = pos.ins().load(",
          "",
          "[Added Lines]",
          "1557:                 let vmctx = self.vmctx(builder.func);",
          "1558:                 let base = builder.ins().global_value(pointer_type, vmctx);",
          "1565:                 let caller_sig_id = builder.ins().load(sig_id_type, mem_flags, base, offset);",
          "1569:                 let callee_sig_id = builder.ins().load(",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1515:                 );",
          "1520:             }",
          "1521:         }",
          "1523:         let mut real_call_args = Vec::with_capacity(call_args.len() + 2);",
          "1528:             pointer_type,",
          "1529:             mem_flags,",
          "1530:             anyfunc_ptr,",
          "",
          "[Removed Lines]",
          "1518:                 let cmp = pos.ins().icmp(IntCC::Equal, callee_sig_id, caller_sig_id);",
          "1519:                 pos.ins().trapz(cmp, ir::TrapCode::BadSignature);",
          "1524:         let caller_vmctx = pos.func.special_param(ArgumentPurpose::VMContext).unwrap();",
          "1527:         let vmctx = pos.ins().load(",
          "",
          "[Added Lines]",
          "1577:                 let cmp = builder",
          "1578:                     .ins()",
          "1579:                     .icmp(IntCC::Equal, callee_sig_id, caller_sig_id);",
          "1580:                 builder.ins().trapz(cmp, ir::TrapCode::BadSignature);",
          "1585:         let caller_vmctx = builder",
          "1586:             .func",
          "1587:             .special_param(ArgumentPurpose::VMContext)",
          "1588:             .unwrap();",
          "1591:         let vmctx = builder.ins().load(",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1537:         real_call_args.extend_from_slice(call_args);",
          "1540:     }",
          "1542:     fn translate_call(",
          "",
          "[Removed Lines]",
          "1539:         Ok(pos.ins().call_indirect(sig_ref, func_addr, &real_call_args))",
          "",
          "[Added Lines]",
          "1603:         Ok(builder",
          "1604:             .ins()",
          "1605:             .call_indirect(sig_ref, func_addr, &real_call_args))",
          "",
          "---------------"
        ],
        "crates/environ/src/builtin.rs||crates/environ/src/builtin.rs": [
          "File: crates/environ/src/builtin.rs -> crates/environ/src/builtin.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "18:             memory_fill(vmctx, i32, i64, i32, i64) -> ();",
          "20:             memory_init(vmctx, i32, i32, i64, i32, i32) -> ();",
          "22:             data_drop(vmctx, i32) -> ();",
          "24:             table_grow_funcref(vmctx, i32, i32, pointer) -> (i32);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22:             ref_func(vmctx, i32) -> (pointer);",
          "26:             table_get_lazy_init_funcref(vmctx, i32, i32) -> (pointer);",
          "",
          "---------------"
        ],
        "crates/environ/src/lib.rs||crates/environ/src/lib.rs": [
          "File: crates/environ/src/lib.rs -> crates/environ/src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: mod module;",
          "30: mod module_environ;",
          "31: pub mod obj;",
          "32: mod stack_map;",
          "33: mod trap_encoding;",
          "34: mod tunables;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: mod ref_bits;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "39: pub use crate::compilation::*;",
          "40: pub use crate::module::*;",
          "41: pub use crate::module_environ::*;",
          "42: pub use crate::stack_map::StackMap;",
          "43: pub use crate::trap_encoding::*;",
          "44: pub use crate::tunables::Tunables;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43: pub use crate::ref_bits::*;",
          "",
          "---------------"
        ],
        "crates/environ/src/module.rs||crates/environ/src/module.rs": [
          "File: crates/environ/src/module.rs -> crates/environ/src/module.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: use indexmap::IndexMap;",
          "5: use serde::{Deserialize, Serialize};",
          "6: use std::collections::BTreeMap;",
          "",
          "[Removed Lines]",
          "3: use crate::{EntityRef, ModuleTranslation, PrimaryMap, Tunables, WASM_PAGE_SIZE};",
          "",
          "[Added Lines]",
          "3: use crate::{ModuleTranslation, PrimaryMap, Tunables, WASM_PAGE_SIZE};",
          "4: use cranelift_entity::{packed_option::ReservedValue, EntityRef};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "259:         }",
          "260:         self.module.memory_initialization = MemoryInitialization::Paged { map };",
          "261:     }",
          "262: }",
          "264: impl Default for MemoryInitialization {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "268:     pub fn try_func_table_init(&mut self) {",
          "272:         const MAX_FUNC_TABLE_SIZE: u32 = 1024 * 1024;",
          "274:         let segments = match &self.module.table_initialization {",
          "275:             TableInitialization::Segments { segments } => segments,",
          "276:             TableInitialization::FuncTable { .. } => {",
          "278:                 return;",
          "279:             }",
          "280:         };",
          "283:         let mut tables = PrimaryMap::with_capacity(self.module.table_plans.len());",
          "285:         let mut leftovers = vec![];",
          "287:         for segment in segments {",
          "291:             if self",
          "292:                 .module",
          "293:                 .defined_table_index(segment.table_index)",
          "294:                 .is_none()",
          "295:             {",
          "296:                 leftovers.push(segment.clone());",
          "297:                 continue;",
          "298:             }",
          "302:             if self.module.table_plans[segment.table_index].table.wasm_ty != WasmType::FuncRef {",
          "303:                 leftovers.push(segment.clone());",
          "304:                 continue;",
          "305:             }",
          "310:             if segment.base.is_some() {",
          "311:                 leftovers.push(segment.clone());",
          "312:                 continue;",
          "313:             }",
          "318:             let top = match segment.offset.checked_add(segment.elements.len() as u32) {",
          "319:                 Some(top) => top,",
          "320:                 None => {",
          "321:                     leftovers.push(segment.clone());",
          "322:                     continue;",
          "323:                 }",
          "324:             };",
          "325:             let table_size = self.module.table_plans[segment.table_index].table.minimum;",
          "326:             if top > table_size || top > MAX_FUNC_TABLE_SIZE {",
          "327:                 leftovers.push(segment.clone());",
          "328:                 continue;",
          "329:             }",
          "332:             while tables.len() <= segment.table_index.index() {",
          "333:                 tables.push(vec![]);",
          "334:             }",
          "335:             let elements = &mut tables[segment.table_index];",
          "336:             if elements.is_empty() {",
          "337:                 elements.resize(table_size as usize, FuncIndex::reserved_value());",
          "338:             }",
          "340:             let dst = &mut elements[(segment.offset as usize)..(top as usize)];",
          "341:             dst.copy_from_slice(&segment.elements[..]);",
          "342:         }",
          "344:         self.module.table_initialization = TableInitialization::FuncTable {",
          "345:             tables,",
          "346:             segments: leftovers,",
          "347:         };",
          "348:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "473:     pub elements: Box<[FuncIndex]>,",
          "474: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "564: #[derive(Clone, Debug, Serialize, Deserialize)]",
          "565: pub enum TableInitialization {",
          "571:     Segments {",
          "574:         segments: Vec<TableInitializer>,",
          "575:     },",
          "590:     FuncTable {",
          "596:         tables: PrimaryMap<TableIndex, Vec<FuncIndex>>,",
          "603:         segments: Vec<TableInitializer>,",
          "604:     },",
          "605: }",
          "607: impl Default for TableInitialization {",
          "608:     fn default() -> Self {",
          "609:         TableInitialization::Segments { segments: vec![] }",
          "610:     }",
          "611: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "513:     pub start_func: Option<FuncIndex>,",
          "519:     pub memory_initialization: MemoryInitialization,",
          "",
          "[Removed Lines]",
          "516:     pub table_initializers: Vec<TableInitializer>,",
          "",
          "[Added Lines]",
          "653:     pub table_initialization: TableInitialization,",
          "",
          "---------------"
        ],
        "crates/environ/src/module_environ.rs||crates/environ/src/module_environ.rs": [
          "File: crates/environ/src/module_environ.rs -> crates/environ/src/module_environ.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: use crate::{",
          "6:     DataIndex, DefinedFuncIndex, ElemIndex, EntityIndex, EntityType, FuncIndex, Global,",
          "7:     GlobalIndex, GlobalInit, InstanceIndex, InstanceTypeIndex, MemoryIndex, ModuleIndex,",
          "10: };",
          "11: use cranelift_entity::packed_option::ReservedValue;",
          "12: use std::borrow::Cow;",
          "",
          "[Removed Lines]",
          "8:     ModuleTypeIndex, PrimaryMap, SignatureIndex, TableIndex, Tunables, TypeIndex, WasmError,",
          "9:     WasmFuncType, WasmResult,",
          "",
          "[Added Lines]",
          "8:     ModuleTypeIndex, PrimaryMap, SignatureIndex, TableIndex, TableInitialization, Tunables,",
          "9:     TypeIndex, WasmError, WasmFuncType, WasmResult,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "512:             Payload::ElementSection(elements) => {",
          "513:                 validator.element_section(&elements)?;",
          "518:                 for (index, entry) in elements.into_iter().enumerate() {",
          "519:                     let wasmparser::Element {",
          "520:                         kind,",
          "",
          "[Removed Lines]",
          "515:                 let cnt = usize::try_from(elements.get_count()).unwrap();",
          "516:                 self.result.module.table_initializers.reserve_exact(cnt);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "576:                                     )));",
          "577:                                 }",
          "578:                             };",
          "588:                         }",
          "590:                         ElementKind::Passive => {",
          "",
          "[Removed Lines]",
          "579:                             self.result",
          "580:                                 .module",
          "581:                                 .table_initializers",
          "582:                                 .push(TableInitializer {",
          "583:                                     table_index,",
          "584:                                     base,",
          "585:                                     offset,",
          "586:                                     elements: elements.into(),",
          "587:                                 });",
          "",
          "[Added Lines]",
          "577:                             let table_segments = match &mut self.result.module.table_initialization",
          "578:                             {",
          "579:                                 TableInitialization::Segments { segments } => segments,",
          "580:                                 TableInitialization::FuncTable { .. } => unreachable!(),",
          "581:                             };",
          "582:                             table_segments.push(TableInitializer {",
          "583:                                 table_index,",
          "584:                                 base,",
          "585:                                 offset,",
          "586:                                 elements: elements.into(),",
          "587:                             });",
          "",
          "---------------"
        ],
        "crates/environ/src/ref_bits.rs||crates/environ/src/ref_bits.rs": [
          "File: crates/environ/src/ref_bits.rs -> crates/environ/src/ref_bits.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: pub const FUNCREF_INIT_BIT: usize = 1;",
          "36: pub const FUNCREF_MASK: usize = !FUNCREF_INIT_BIT;",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
          "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:     VMCallerCheckedAnyfunc, VMContext, VMFunctionImport, VMGlobalDefinition, VMGlobalImport,",
          "12:     VMInterrupts, VMMemoryDefinition, VMMemoryImport, VMTableDefinition, VMTableImport,",
          "13: };",
          "15: use anyhow::Error;",
          "16: use memoffset::offset_of;",
          "17: use more_asserts::assert_lt;",
          "",
          "[Removed Lines]",
          "14: use crate::{CompiledModuleId, ExportFunction, ExportGlobal, ExportMemory, ExportTable, Store};",
          "",
          "[Added Lines]",
          "14: use crate::{ExportFunction, ExportGlobal, ExportMemory, ExportTable, ModuleRuntimeInfo, Store};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "24: use std::sync::atomic::AtomicU64;",
          "25: use std::sync::Arc;",
          "26: use std::{mem, ptr, slice};",
          "27: use wasmtime_environ::{",
          "28:     packed_option::ReservedValue, DataIndex, DefinedGlobalIndex, DefinedMemoryIndex,",
          "29:     DefinedTableIndex, ElemIndex, EntityIndex, EntityRef, EntitySet, FuncIndex, GlobalIndex,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: use wasmtime_environ::TableInitialization;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "52: #[repr(C)] // ensure that the vmctx field is last.",
          "53: pub(crate) struct Instance {",
          "61:     offsets: VMOffsets<HostPtr>,",
          "",
          "[Removed Lines]",
          "55:     module: Arc<Module>,",
          "58:     unique_id: Option<CompiledModuleId>,",
          "",
          "[Added Lines]",
          "60:     runtime_info: Arc<dyn ModuleRuntimeInfo>,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "81:     dropped_data: EntitySet<DataIndex>,",
          "",
          "[Removed Lines]",
          "87:     wasm_data: &'static [u8],",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "102: impl Instance {",
          "104:     pub(crate) fn create_raw(",
          "108:         memories: PrimaryMap<DefinedMemoryIndex, Memory>,",
          "109:         tables: PrimaryMap<DefinedTableIndex, Table>,",
          "110:         host_state: Box<dyn Any + Send + Sync>,",
          "111:     ) -> Instance {",
          "112:         Instance {",
          "116:             memories,",
          "117:             tables,",
          "120:             host_state,",
          "122:             vmctx: VMContext {",
          "123:                 _marker: std::marker::PhantomPinned,",
          "124:             },",
          "",
          "[Removed Lines]",
          "105:         module: &Arc<Module>,",
          "106:         unique_id: Option<CompiledModuleId>,",
          "107:         wasm_data: &'static [u8],",
          "113:             module: module.clone(),",
          "114:             unique_id,",
          "115:             offsets: VMOffsets::new(HostPtr, &module),",
          "118:             dropped_elements: EntitySet::with_capacity(module.passive_elements.len()),",
          "119:             dropped_data: EntitySet::with_capacity(module.passive_data_map.len()),",
          "121:             wasm_data,",
          "",
          "[Added Lines]",
          "101:         runtime_info: Arc<dyn ModuleRuntimeInfo>,",
          "106:         let module = runtime_info.module();",
          "107:         let offsets = VMOffsets::new(HostPtr, &module);",
          "108:         let dropped_elements = EntitySet::with_capacity(module.passive_elements.len());",
          "109:         let dropped_data = EntitySet::with_capacity(module.passive_data_map.len());",
          "111:             runtime_info,",
          "112:             offsets,",
          "115:             dropped_elements,",
          "116:             dropped_data,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "134:     }",
          "136:     pub(crate) fn module(&self) -> &Arc<Module> {",
          "138:     }",
          "",
          "[Removed Lines]",
          "137:         &self.module",
          "",
          "[Added Lines]",
          "133:         self.runtime_info.module()",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "179:     pub(crate) fn get_memory(&self, index: MemoryIndex) -> VMMemoryDefinition {",
          "181:             self.memory(defined_index)",
          "182:         } else {",
          "183:             let import = self.imported_memory(index);",
          "",
          "[Removed Lines]",
          "180:         if let Some(defined_index) = self.module.defined_memory_index(index) {",
          "",
          "[Added Lines]",
          "176:         if let Some(defined_index) = self.module().defined_memory_index(index) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "220:         &self,",
          "221:         index: GlobalIndex,",
          "222:     ) -> *mut VMGlobalDefinition {",
          "224:             self.global_ptr(index)",
          "225:         } else {",
          "226:             self.imported_global(index).from",
          "",
          "[Removed Lines]",
          "223:         if let Some(index) = self.module.defined_global_index(index) {",
          "",
          "[Added Lines]",
          "219:         if let Some(index) = self.module().defined_global_index(index) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "276:     }",
          "280:         match export {",
          "281:             EntityIndex::Function(index) => {",
          "282:                 let anyfunc = self.get_caller_checked_anyfunc(*index).unwrap();",
          "",
          "[Removed Lines]",
          "279:     pub fn lookup_by_declaration(&self, export: &EntityIndex) -> Export {",
          "",
          "[Added Lines]",
          "275:     pub fn lookup_by_declaration(&mut self, export: &EntityIndex) -> Export {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "286:             }",
          "287:             EntityIndex::Table(index) => {",
          "288:                 let (definition, vmctx) =",
          "290:                         (self.table_ptr(def_index), self.vmctx_ptr())",
          "291:                     } else {",
          "292:                         let import = self.imported_table(*index);",
          "",
          "[Removed Lines]",
          "289:                     if let Some(def_index) = self.module.defined_table_index(*index) {",
          "",
          "[Added Lines]",
          "285:                     if let Some(def_index) = self.module().defined_table_index(*index) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "295:                 ExportTable {",
          "296:                     definition,",
          "297:                     vmctx,",
          "299:                 }",
          "300:                 .into()",
          "301:             }",
          "302:             EntityIndex::Memory(index) => {",
          "303:                 let (definition, vmctx) =",
          "305:                         (self.memory_ptr(def_index), self.vmctx_ptr())",
          "306:                     } else {",
          "307:                         let import = self.imported_memory(*index);",
          "",
          "[Removed Lines]",
          "298:                     table: self.module.table_plans[*index].clone(),",
          "304:                     if let Some(def_index) = self.module.defined_memory_index(*index) {",
          "",
          "[Added Lines]",
          "294:                     table: self.module().table_plans[*index].clone(),",
          "300:                     if let Some(def_index) = self.module().defined_memory_index(*index) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "310:                 ExportMemory {",
          "311:                     definition,",
          "312:                     vmctx,",
          "314:                 }",
          "315:                 .into()",
          "316:             }",
          "317:             EntityIndex::Global(index) => ExportGlobal {",
          "319:                     self.global_ptr(def_index)",
          "320:                 } else {",
          "321:                     self.imported_global(*index).from",
          "322:                 },",
          "323:                 vmctx: self.vmctx_ptr(),",
          "325:             }",
          "326:             .into(),",
          "",
          "[Removed Lines]",
          "313:                     memory: self.module.memory_plans[*index].clone(),",
          "318:                 definition: if let Some(def_index) = self.module.defined_global_index(*index) {",
          "324:                 global: self.module.globals[*index],",
          "",
          "[Added Lines]",
          "309:                     memory: self.module().memory_plans[*index].clone(),",
          "314:                 definition: if let Some(def_index) = self.module().defined_global_index(*index) {",
          "320:                 global: self.module().globals[*index],",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "339:     pub fn exports(&self) -> indexmap::map::Iter<String, EntityIndex> {",
          "341:     }",
          "",
          "[Removed Lines]",
          "340:         self.module.exports.iter()",
          "",
          "[Added Lines]",
          "336:         self.module().exports.iter()",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "388:         index: MemoryIndex,",
          "389:         delta: u64,",
          "390:     ) -> Result<Option<usize>, Error> {",
          "392:             (idx, self)",
          "393:         } else {",
          "394:             let import = self.imported_memory(index);",
          "",
          "[Removed Lines]",
          "391:         let (idx, instance) = if let Some(idx) = self.module.defined_memory_index(index) {",
          "",
          "[Added Lines]",
          "387:         let (idx, instance) = if let Some(idx) = self.module().defined_memory_index(index) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "462:         Layout::from_size_align(size, align).unwrap()",
          "463:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "470:     fn construct_anyfunc(&mut self, index: FuncIndex, into: *mut VMCallerCheckedAnyfunc) {",
          "471:         let sig = self.module().functions[index];",
          "472:         let type_index = self.runtime_info.signature(sig);",
          "474:         let (func_ptr, vmctx) = if let Some(def_index) = self.module().defined_func_index(index) {",
          "475:             (",
          "476:                 (self.runtime_info.image_base()",
          "477:                     + self.runtime_info.function_info(def_index).start as usize)",
          "478:                     as *mut _,",
          "479:                 self.vmctx_ptr(),",
          "480:             )",
          "481:         } else {",
          "482:             let import = self.imported_function(index);",
          "483:             (import.body.as_ptr(), import.vmctx)",
          "484:         };",
          "488:         unsafe {",
          "490:                 vmctx,",
          "491:                 type_index,",
          "492:                 func_ptr: NonNull::new(func_ptr).expect(\"Non-null function pointer\"),",
          "493:             };",
          "494:         }",
          "495:     }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "471:     pub(crate) fn get_caller_checked_anyfunc(",
          "473:         index: FuncIndex,",
          "475:         if index == FuncIndex::reserved_value() {",
          "476:             return None;",
          "477:         }",
          "484:     }",
          "",
          "[Removed Lines]",
          "472:         &self,",
          "474:     ) -> Option<&VMCallerCheckedAnyfunc> {",
          "479:         unsafe { Some(&*self.vmctx_plus_offset(self.offsets.vmctx_anyfunc(index))) }",
          "480:     }",
          "482:     unsafe fn anyfunc_base(&self) -> *mut VMCallerCheckedAnyfunc {",
          "483:         self.vmctx_plus_offset(self.offsets.vmctx_anyfuncs_begin())",
          "",
          "[Added Lines]",
          "504:         &mut self,",
          "506:     ) -> Option<*mut VMCallerCheckedAnyfunc> {",
          "513:         unsafe {",
          "538:             let anyfunc: *mut VMCallerCheckedAnyfunc =",
          "539:                 self.vmctx_plus_offset::<VMCallerCheckedAnyfunc>(self.offsets.vmctx_anyfunc(index));",
          "540:             self.construct_anyfunc(index, anyfunc);",
          "542:             Some(anyfunc)",
          "543:         }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "506:         let elements = match module.passive_elements_map.get(&elem_index) {",
          "507:             Some(index) if !self.dropped_elements.contains(elem_index) => {",
          "",
          "[Removed Lines]",
          "504:         let module = self.module.clone();",
          "",
          "[Added Lines]",
          "564:         let module = self.module().clone();",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "533:         };",
          "535:         match table.element_type() {",
          "538:                 table.init_funcs(",
          "539:                     dst,",
          "540:                     elements.iter().map(|idx| {",
          "547:                     }),",
          "548:                 )?;",
          "551:             TableElementType::Extern => {",
          "552:                 debug_assert!(elements.iter().all(|e| *e == FuncIndex::reserved_value()));",
          "",
          "[Removed Lines]",
          "536:             TableElementType::Func => unsafe {",
          "537:                 let base = self.anyfunc_base();",
          "541:                         if *idx == FuncIndex::reserved_value() {",
          "542:                             ptr::null_mut()",
          "543:                         } else {",
          "544:                             debug_assert!(idx.as_u32() < self.offsets.num_defined_functions);",
          "545:                             base.add(usize::try_from(idx.as_u32()).unwrap())",
          "546:                         }",
          "549:             },",
          "",
          "[Added Lines]",
          "596:             TableElementType::Func => {",
          "600:                         self.get_caller_checked_anyfunc(*idx)",
          "601:                             .unwrap_or(std::ptr::null_mut())",
          "604:             }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "657:         src: u32,",
          "658:         len: u32,",
          "659:     ) -> Result<(), Trap> {",
          "661:             Some(range) if !self.dropped_data.contains(data_index) => range,",
          "662:             _ => 0..0,",
          "663:         };",
          "",
          "[Removed Lines]",
          "660:         let range = match self.module.passive_data_map.get(&data_index).cloned() {",
          "",
          "[Added Lines]",
          "715:         let range = match self.module().passive_data_map.get(&data_index).cloned() {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "665:     }",
          "667:     pub(crate) fn wasm_data(&self, range: Range<u32>) -> &[u8] {",
          "669:     }",
          "671:     pub(crate) fn memory_init_segment(",
          "",
          "[Removed Lines]",
          "668:         &self.wasm_data[range.start as usize..range.end as usize]",
          "",
          "[Added Lines]",
          "723:         &self.runtime_info.wasm_data()[range.start as usize..range.end as usize]",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "704:     }",
          "708:     pub(crate) fn get_table(&mut self, table_index: TableIndex) -> *mut Table {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "772:     pub(crate) fn get_table_with_lazy_init(",
          "773:         &mut self,",
          "774:         table_index: TableIndex,",
          "775:         range: impl Iterator<Item = u32>,",
          "776:     ) -> *mut Table {",
          "777:         let (idx, instance) = self.get_defined_table_index_and_instance(table_index);",
          "778:         let elt_ty = instance.tables[idx].element_type();",
          "780:         if elt_ty == TableElementType::Func {",
          "781:             for i in range {",
          "782:                 let value = match instance.tables[idx].get(i) {",
          "783:                     Some(value) => value,",
          "784:                     None => {",
          "788:                         break;",
          "789:                     }",
          "790:                 };",
          "791:                 if value.is_uninit() {",
          "792:                     let table_init = match &instance.module().table_initialization {",
          "798:                         TableInitialization::FuncTable { tables, .. } => tables,",
          "799:                         _ => break,",
          "800:                     }",
          "801:                     .get(table_index);",
          "811:                     let func_index =",
          "812:                         table_init.and_then(|indices| indices.get(i as usize).cloned());",
          "813:                     let anyfunc = func_index",
          "814:                         .and_then(|func_index| instance.get_caller_checked_anyfunc(func_index))",
          "815:                         .unwrap_or(std::ptr::null_mut());",
          "817:                     let value = TableElement::FuncRef(anyfunc);",
          "819:                     instance.tables[idx]",
          "820:                         .set(i, value)",
          "821:                         .expect(\"Table type should match and index should be in-bounds\");",
          "822:                 }",
          "823:             }",
          "824:         }",
          "826:         ptr::addr_of_mut!(instance.tables[idx])",
          "827:     }",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "719:         &mut self,",
          "720:         index: TableIndex,",
          "721:     ) -> (DefinedTableIndex, &mut Instance) {",
          "723:             (defined_table_index, self)",
          "724:         } else {",
          "725:             let import = self.imported_table(index);",
          "",
          "[Removed Lines]",
          "722:         if let Some(defined_table_index) = self.module.defined_table_index(index) {",
          "",
          "[Added Lines]",
          "845:         if let Some(defined_table_index) = self.module().defined_table_index(index) {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "733:     }",
          "735:     fn drop_globals(&mut self) {",
          "738:                 Some(idx) => idx,",
          "739:                 None => continue,",
          "740:             };",
          "",
          "[Removed Lines]",
          "736:         for (idx, global) in self.module.globals.iter() {",
          "737:             let idx = match self.module.defined_global_index(idx) {",
          "",
          "[Added Lines]",
          "859:         for (idx, global) in self.module().globals.iter() {",
          "860:             let idx = match self.module().defined_global_index(idx) {",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "804:     }",
          "809:     }",
          "",
          "[Removed Lines]",
          "807:     pub fn lookup_by_declaration(&self, export: &EntityIndex) -> Export {",
          "808:         self.instance().lookup_by_declaration(export)",
          "",
          "[Added Lines]",
          "930:     pub fn lookup_by_declaration(&mut self, export: &EntityIndex) -> Export {",
          "931:         self.instance_mut().lookup_by_declaration(export)",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "842:         self.instance_mut().get_defined_table(index)",
          "843:     }",
          "846:     #[inline]",
          "847:     pub(crate) fn instance(&self) -> &Instance {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "970:     pub fn get_defined_table_with_lazy_init(",
          "971:         &mut self,",
          "972:         index: DefinedTableIndex,",
          "973:         range: impl Iterator<Item = u32>,",
          "974:     ) -> *mut Table {",
          "975:         let index = self.instance().module().table_index(index);",
          "976:         self.instance_mut().get_table_with_lazy_init(index, range)",
          "977:     }",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
          "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: use crate::vmcontext::{",
          "7:     VMBuiltinFunctionsArray, VMCallerCheckedAnyfunc, VMGlobalDefinition, VMSharedSignatureIndex,",
          "8: };",
          "11: use anyhow::Result;",
          "12: use std::alloc;",
          "13: use std::any::Any;",
          "14: use std::convert::TryFrom;",
          "16: use std::slice;",
          "17: use std::sync::Arc;",
          "18: use thiserror::Error;",
          "19: use wasmtime_environ::{",
          "23: };",
          "25: #[cfg(feature = \"pooling-allocator\")]",
          "",
          "[Removed Lines]",
          "9: use crate::ModuleMemFds;",
          "10: use crate::{CompiledModuleId, Store};",
          "15: use std::ptr::{self, NonNull};",
          "20:     DefinedFuncIndex, DefinedMemoryIndex, DefinedTableIndex, EntityRef, FunctionInfo, GlobalInit,",
          "21:     InitMemory, MemoryInitialization, MemoryInitializer, Module, ModuleType, PrimaryMap,",
          "22:     SignatureIndex, TableInitializer, TrapCode, WasmType, WASM_PAGE_SIZE,",
          "",
          "[Added Lines]",
          "9: use crate::ModuleRuntimeInfo;",
          "10: use crate::Store;",
          "15: use std::ptr;",
          "20:     DefinedMemoryIndex, DefinedTableIndex, EntityRef, GlobalInit, InitMemory, MemoryInitialization,",
          "21:     MemoryInitializer, Module, ModuleType, PrimaryMap, TableInitialization, TableInitializer,",
          "22:     TrapCode, WasmType, WASM_PAGE_SIZE,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34: pub struct InstanceAllocationRequest<'a> {",
          "52:     pub imports: Imports<'a>,",
          "58:     pub host_state: Box<dyn Any + Send + Sync>,",
          "",
          "[Removed Lines]",
          "36:     pub module: &'a Arc<Module>,",
          "39:     pub unique_id: Option<CompiledModuleId>,",
          "42:     pub image_base: usize,",
          "45:     pub memfds: Option<&'a Arc<ModuleMemFds>>,",
          "49:     pub functions: &'a PrimaryMap<DefinedFuncIndex, FunctionInfo>,",
          "55:     pub shared_signatures: SharedSignatures<'a>,",
          "",
          "[Added Lines]",
          "40:     pub runtime_info: &'a Arc<dyn ModuleRuntimeInfo>,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "74:     pub store: StorePtr,",
          "85: }",
          "",
          "[Removed Lines]",
          "84:     pub wasm_data: *const [u8],",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "218:     unsafe fn deallocate_fiber_stack(&self, stack: &wasmtime_fiber::FiberStack);",
          "219: }",
          "261: fn get_table_init_start(",
          "262:     init: &TableInitializer,",
          "263:     instance: &Instance,",
          "",
          "[Removed Lines]",
          "221: pub enum SharedSignatures<'a> {",
          "223:     Table(&'a PrimaryMap<SignatureIndex, VMSharedSignatureIndex>),",
          "225:     Always(VMSharedSignatureIndex),",
          "227:     None,",
          "228: }",
          "230: impl SharedSignatures<'_> {",
          "231:     fn lookup(&self, index: SignatureIndex) -> VMSharedSignatureIndex {",
          "232:         match self {",
          "233:             SharedSignatures::Table(table) => table[index],",
          "234:             SharedSignatures::Always(index) => *index,",
          "235:             SharedSignatures::None => unreachable!(),",
          "236:         }",
          "237:     }",
          "238: }",
          "240: impl<'a> From<VMSharedSignatureIndex> for SharedSignatures<'a> {",
          "241:     fn from(val: VMSharedSignatureIndex) -> SharedSignatures<'a> {",
          "242:         SharedSignatures::Always(val)",
          "243:     }",
          "244: }",
          "246: impl<'a> From<Option<VMSharedSignatureIndex>> for SharedSignatures<'a> {",
          "247:     fn from(val: Option<VMSharedSignatureIndex>) -> SharedSignatures<'a> {",
          "248:         match val {",
          "249:             Some(idx) => SharedSignatures::Always(idx),",
          "250:             None => SharedSignatures::None,",
          "251:         }",
          "252:     }",
          "253: }",
          "255: impl<'a> From<&'a PrimaryMap<SignatureIndex, VMSharedSignatureIndex>> for SharedSignatures<'a> {",
          "256:     fn from(val: &'a PrimaryMap<SignatureIndex, VMSharedSignatureIndex>) -> SharedSignatures<'a> {",
          "257:         SharedSignatures::Table(val)",
          "258:     }",
          "259: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "265:     match init.base {",
          "266:         Some(base) => {",
          "267:             let val = unsafe {",
          "270:                 } else {",
          "",
          "[Removed Lines]",
          "268:                 if let Some(def_index) = instance.module.defined_global_index(base) {",
          "",
          "[Added Lines]",
          "206:                 if let Some(def_index) = instance.module().defined_global_index(base) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "286:     instance: &mut Instance,",
          "287:     module: &Module,",
          "288: ) -> Result<(), InstantiationError> {",
          "303:             }",
          "304:         }",
          "305:     }",
          "",
          "[Removed Lines]",
          "289:     for init in &module.table_initializers {",
          "290:         let table = unsafe { &*instance.get_table(init.table_index) };",
          "291:         let start = get_table_init_start(init, instance)?;",
          "292:         let start = usize::try_from(start).unwrap();",
          "293:         let end = start.checked_add(init.elements.len());",
          "295:         match end {",
          "296:             Some(end) if end <= table.size() as usize => {",
          "298:             }",
          "299:             _ => {",
          "300:                 return Err(InstantiationError::Link(LinkError(",
          "301:                     \"table out of bounds: elements segment does not fit\".to_owned(),",
          "302:                 )))",
          "",
          "[Added Lines]",
          "227:     match &module.table_initialization {",
          "228:         TableInitialization::FuncTable { segments, .. }",
          "229:         | TableInitialization::Segments { segments } => {",
          "230:             for segment in segments {",
          "231:                 let table = unsafe { &*instance.get_table(segment.table_index) };",
          "232:                 let start = get_table_init_start(segment, instance)?;",
          "233:                 let start = usize::try_from(start).unwrap();",
          "234:                 let end = start.checked_add(segment.elements.len());",
          "236:                 match end {",
          "237:                     Some(end) if end <= table.size() as usize => {",
          "239:                     }",
          "240:                     _ => {",
          "241:                         return Err(InstantiationError::Link(LinkError(",
          "242:                             \"table out of bounds: elements segment does not fit\".to_owned(),",
          "243:                         )))",
          "244:                     }",
          "245:                 }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "308: }",
          "310: fn initialize_tables(instance: &mut Instance, module: &Module) -> Result<(), InstantiationError> {",
          "321:     }",
          "323:     Ok(())",
          "",
          "[Removed Lines]",
          "311:     for init in &module.table_initializers {",
          "312:         instance",
          "313:             .table_init_segment(",
          "314:                 init.table_index,",
          "315:                 &init.elements,",
          "316:                 get_table_init_start(init, instance)?,",
          "317:                 0,",
          "318:                 init.elements.len() as u32,",
          "319:             )",
          "320:             .map_err(InstantiationError::Trap)?;",
          "",
          "[Added Lines]",
          "261:     match &module.table_initialization {",
          "262:         TableInitialization::FuncTable { segments, .. }",
          "263:         | TableInitialization::Segments { segments } => {",
          "264:             for segment in segments {",
          "265:                 instance",
          "266:                     .table_init_segment(",
          "267:                         segment.table_index,",
          "268:                         &segment.elements,",
          "269:                         get_table_init_start(segment, instance)?,",
          "270:                         0,",
          "271:                         segment.elements.len() as u32,",
          "272:                     )",
          "273:                     .map_err(InstantiationError::Trap)?;",
          "274:             }",
          "275:         }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "329: ) -> Result<u64, InstantiationError> {",
          "330:     match init.base {",
          "331:         Some(base) => {",
          "333:                 .memory",
          "334:                 .memory64;",
          "335:             let val = unsafe {",
          "337:                     instance.global(def_index)",
          "338:                 } else {",
          "339:                     &*instance.imported_global(base).from",
          "",
          "[Removed Lines]",
          "332:             let mem64 = instance.module.memory_plans[init.memory_index]",
          "336:                 let global = if let Some(def_index) = instance.module.defined_global_index(base) {",
          "",
          "[Added Lines]",
          "287:             let mem64 = instance.module().memory_plans[init.memory_index]",
          "291:                 let global = if let Some(def_index) = instance.module().defined_global_index(base) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "388:     let get_global_as_u64 = &|global| unsafe {",
          "390:             instance.global(def_index)",
          "391:         } else {",
          "392:             &*instance.imported_global(global).from",
          "",
          "[Removed Lines]",
          "389:         let def = if let Some(def_index) = instance.module.defined_global_index(global) {",
          "",
          "[Added Lines]",
          "344:         let def = if let Some(def_index) = instance.module().defined_global_index(global) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "441: fn check_init_bounds(instance: &mut Instance, module: &Module) -> Result<(), InstantiationError> {",
          "442:     check_table_init_bounds(instance, module)?;",
          "445:         MemoryInitialization::Segmented(initializers) => {",
          "446:             check_memory_init_bounds(instance, initializers)?;",
          "447:         }",
          "",
          "[Removed Lines]",
          "444:     match &instance.module.memory_initialization {",
          "",
          "[Added Lines]",
          "399:     match &instance.module().memory_initialization {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "482:         instance.set_store(store);",
          "483:     }",
          "488:     let mut ptr = instance.vmctx_plus_offset(instance.offsets.vmctx_signature_ids_begin());",
          "489:     for sig in module.types.values() {",
          "492:             _ => VMSharedSignatureIndex::new(u32::max_value()),",
          "493:         };",
          "494:         ptr = ptr.add(1);",
          "",
          "[Removed Lines]",
          "485:     let module = &instance.module;",
          "491:             ModuleType::Function(sig) => req.shared_signatures.lookup(*sig),",
          "",
          "[Added Lines]",
          "445:     let module = req.runtime_info.module();",
          "451:             ModuleType::Function(sig) => req.runtime_info.signature(*sig),",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "524:         req.imports.globals.len(),",
          "525:     );",
          "555:     let mut ptr = instance.vmctx_plus_offset(instance.offsets.vmctx_tables_begin());",
          "",
          "[Removed Lines]",
          "528:     let mut base = instance.anyfunc_base();",
          "529:     for (index, sig) in instance.module.functions.iter() {",
          "530:         let type_index = req.shared_signatures.lookup(*sig);",
          "532:         let (func_ptr, vmctx) = if let Some(def_index) = instance.module.defined_func_index(index) {",
          "533:             (",
          "534:                 NonNull::new((req.image_base + req.functions[def_index].start as usize) as *mut _)",
          "535:                     .unwrap(),",
          "536:                 instance.vmctx_ptr(),",
          "537:             )",
          "538:         } else {",
          "539:             let import = instance.imported_function(index);",
          "540:             (import.body, import.vmctx)",
          "541:         };",
          "543:         ptr::write(",
          "544:             base,",
          "545:             VMCallerCheckedAnyfunc {",
          "546:                 func_ptr,",
          "547:                 type_index,",
          "548:                 vmctx,",
          "549:             },",
          "550:         );",
          "551:         base = base.add(1);",
          "552:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "569:     }",
          "573: }",
          "577:     let num_imports = module.num_imported_globals;",
          "578:     for (index, global) in module.globals.iter().skip(num_imports) {",
          "579:         let def_index = module.defined_global_index(index).unwrap();",
          "",
          "[Removed Lines]",
          "572:     initialize_vmcontext_globals(instance);",
          "575: unsafe fn initialize_vmcontext_globals(instance: &Instance) {",
          "576:     let module = &instance.module;",
          "",
          "[Added Lines]",
          "511:     initialize_vmcontext_globals(instance, module);",
          "514: unsafe fn initialize_vmcontext_globals(",
          "515:     instance: &mut Instance,",
          "516:     module: &Arc<wasmtime_environ::Module>,",
          "517: ) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "637:     }",
          "639:     fn create_tables(",
          "641:         store: &mut StorePtr,",
          "642:     ) -> Result<PrimaryMap<DefinedTableIndex, Table>, InstantiationError> {",
          "643:         let num_imports = module.num_imported_tables;",
          "644:         let mut tables: PrimaryMap<DefinedTableIndex, _> =",
          "645:             PrimaryMap::with_capacity(module.table_plans.len() - num_imports);",
          "647:             tables.push(",
          "648:                 Table::new_dynamic(table, unsafe {",
          "649:                     store",
          "",
          "[Removed Lines]",
          "640:         module: &Module,",
          "646:         for table in &module.table_plans.values().as_slice()[num_imports..] {",
          "",
          "[Added Lines]",
          "582:         runtime_info: &Arc<dyn ModuleRuntimeInfo>,",
          "584:         let module = runtime_info.module();",
          "588:         for (_, table) in module.table_plans.iter().skip(num_imports) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "659:     fn create_memories(",
          "660:         &self,",
          "662:         store: &mut StorePtr,",
          "664:     ) -> Result<PrimaryMap<DefinedMemoryIndex, Memory>, InstantiationError> {",
          "665:         let creator = self",
          "666:             .mem_creator",
          "667:             .as_deref()",
          "",
          "[Removed Lines]",
          "661:         module: &Module,",
          "663:         memfds: Option<&Arc<ModuleMemFds>>,",
          "",
          "[Added Lines]",
          "604:         runtime_info: &Arc<dyn ModuleRuntimeInfo>,",
          "606:         let module = runtime_info.module();",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "674:             let defined_memory_idx = module",
          "675:                 .defined_memory_index(memory_idx)",
          "676:                 .expect(\"Skipped imports, should never be None\");",
          "679:             memories.push(",
          "680:                 Memory::new_dynamic(",
          "",
          "[Removed Lines]",
          "677:             let memfd_image = memfds.and_then(|memfds| memfds.get_memory_image(defined_memory_idx));",
          "",
          "[Added Lines]",
          "619:             let memfd_image = runtime_info",
          "620:                 .memfd_image(defined_memory_idx)",
          "621:                 .map_err(|err| InstantiationError::Resource(err.into()))?;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "709:         &self,",
          "710:         mut req: InstanceAllocationRequest,",
          "711:     ) -> Result<InstanceHandle, InstantiationError> {",
          "715:         let host_state = std::mem::replace(&mut req.host_state, Box::new(()));",
          "717:         let mut handle = {",
          "726:             let layout = instance.alloc_layout();",
          "727:             let instance_ptr = alloc::alloc(layout) as *mut Instance;",
          "728:             if instance_ptr.is_null() {",
          "",
          "[Removed Lines]",
          "712:         let memories = self.create_memories(&req.module, &mut req.store, req.memfds)?;",
          "713:         let tables = Self::create_tables(&req.module, &mut req.store)?;",
          "718:             let instance = Instance::create_raw(",
          "719:                 &req.module,",
          "720:                 req.unique_id,",
          "721:                 &*req.wasm_data,",
          "722:                 memories,",
          "723:                 tables,",
          "724:                 host_state,",
          "725:             );",
          "",
          "[Added Lines]",
          "656:         let memories = self.create_memories(&mut req.store, &req.runtime_info)?;",
          "657:         let tables = Self::create_tables(&mut req.store, &req.runtime_info)?;",
          "662:             let instance =",
          "663:                 Instance::create_raw(req.runtime_info.clone(), memories, tables, host_state);",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs": [
          "File: crates/runtime/src/instance/allocator/pooling.rs -> crates/runtime/src/instance/allocator/pooling.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:     initialize_instance, initialize_vmcontext, InstanceAllocationRequest, InstanceAllocator,",
          "12:     InstanceHandle, InstantiationError,",
          "13: };",
          "16: use anyhow::{anyhow, bail, Context, Result};",
          "17: use libc::c_void;",
          "18: use std::convert::TryFrom;",
          "",
          "[Removed Lines]",
          "14: use crate::MemFdSlot;",
          "15: use crate::{instance::Instance, Memory, Mmap, ModuleMemFds, Table};",
          "",
          "[Added Lines]",
          "14: use crate::{instance::Instance, Memory, Mmap, Table};",
          "15: use crate::{MemFdSlot, ModuleRuntimeInfo};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "350:     ) -> Result<InstanceHandle, InstantiationError> {",
          "351:         let host_state = std::mem::replace(&mut req.host_state, Box::new(()));",
          "352:         let instance_data = Instance::create_raw(",
          "356:             PrimaryMap::default(),",
          "357:             PrimaryMap::default(),",
          "358:             host_state,",
          "359:         );",
          "367:         std::ptr::write(instance as _, instance_data);",
          "",
          "[Removed Lines]",
          "353:             &req.module,",
          "354:             req.unique_id,",
          "355:             &*req.wasm_data,",
          "365:         let instance = self.instance(index);",
          "",
          "[Added Lines]",
          "353:             req.runtime_info.clone(),",
          "359:         let instance = self.instance(index);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "376:             index,",
          "377:             instance,",
          "378:             &self.memories,",
          "380:             self.memories.max_wasm_pages,",
          "381:         )?;",
          "383:         Self::set_instance_tables(",
          "",
          "[Removed Lines]",
          "379:             req.memfds,",
          "",
          "[Added Lines]",
          "378:             &req.runtime_info,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "402:             if alloc.is_empty() {",
          "403:                 return Err(InstantiationError::Limit(self.max_instances as u32));",
          "404:             }",
          "406:         };",
          "408:         unsafe {",
          "",
          "[Removed Lines]",
          "405:             alloc.alloc(req.unique_id).index()",
          "",
          "[Added Lines]",
          "403:             alloc.alloc(req.runtime_info.unique_id()).index()",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "504:         instance_idx: usize,",
          "505:         instance: &mut Instance,",
          "506:         memories: &MemoryPool,",
          "508:         max_pages: u64,",
          "509:     ) -> Result<(), InstantiationError> {",
          "512:         assert!(instance.memories.is_empty());",
          "",
          "[Removed Lines]",
          "507:         maybe_memfds: Option<&Arc<ModuleMemFds>>,",
          "510:         let module = instance.module.as_ref();",
          "",
          "[Added Lines]",
          "506:         runtime_info: &Arc<dyn ModuleRuntimeInfo>,",
          "508:         let module = instance.runtime_info.module();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "527:                 )",
          "528:             };",
          "532:                 let mut slot = memories.take_memfd_slot(instance_idx, defined_index);",
          "533:                 let initial_size = plan.memory.minimum * WASM_PAGE_SIZE as u64;",
          "",
          "[Removed Lines]",
          "530:             if let Some(memfds) = maybe_memfds {",
          "531:                 let image = memfds.get_memory_image(defined_index);",
          "",
          "[Added Lines]",
          "528:             if let Some(image) = runtime_info",
          "529:                 .memfd_image(defined_index)",
          "530:                 .map_err(|err| InstantiationError::Resource(err.into()))?",
          "531:             {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "549:                     .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "551:                 instance.memories.push(",
          "",
          "[Removed Lines]",
          "548:                 slot.instantiate(initial_size as usize, image)",
          "",
          "[Added Lines]",
          "548:                 slot.instantiate(initial_size as usize, Some(image))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "574:         mut tables: impl Iterator<Item = *mut usize>,",
          "575:         max_elements: u32,",
          "576:     ) -> Result<(), InstantiationError> {",
          "579:         assert!(instance.tables.is_empty());",
          "582:             let base = tables.next().unwrap();",
          "584:             commit_table_pages(",
          "",
          "[Removed Lines]",
          "577:         let module = instance.module.as_ref();",
          "581:         for plan in (&module.table_plans.values().as_slice()[module.num_imported_tables..]).iter() {",
          "",
          "[Added Lines]",
          "577:         let module = instance.runtime_info.module();",
          "581:         for (_, plan) in module.table_plans.iter().skip(module.num_imported_tables) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1130: #[cfg(test)]",
          "1131: mod test {",
          "1132:     use super::*;",
          "1134:     use wasmtime_environ::{",
          "1137:     };",
          "1139:     #[test]",
          "",
          "[Removed Lines]",
          "1133:     use crate::{Imports, StorePtr, VMSharedSignatureIndex};",
          "1135:         EntityRef, Global, GlobalInit, Memory, MemoryPlan, ModuleType, SignatureIndex, Table,",
          "1136:         TablePlan, TableStyle, WasmType,",
          "",
          "[Added Lines]",
          "1133:     use crate::{CompiledModuleId, Imports, MemoryMemFd, StorePtr, VMSharedSignatureIndex};",
          "1135:         DefinedFuncIndex, DefinedMemoryIndex, EntityRef, FunctionInfo, Global, GlobalInit, Memory,",
          "1136:         MemoryPlan, ModuleType, SignatureIndex, Table, TablePlan, TableStyle, WasmType,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1422:         );",
          "1423:     }",
          "1425:     #[cfg(target_pointer_width = \"64\")]",
          "1426:     #[test]",
          "1427:     fn test_instance_pool() -> Result<()> {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1425:     pub(crate) fn empty_runtime_info(",
          "1426:         module: Arc<wasmtime_environ::Module>,",
          "1427:     ) -> Arc<dyn ModuleRuntimeInfo> {",
          "1428:         struct RuntimeInfo(Arc<wasmtime_environ::Module>);",
          "1430:         impl ModuleRuntimeInfo for RuntimeInfo {",
          "1431:             fn module(&self) -> &Arc<wasmtime_environ::Module> {",
          "1432:                 &self.0",
          "1433:             }",
          "1434:             fn image_base(&self) -> usize {",
          "1435:                 0",
          "1436:             }",
          "1437:             fn function_info(&self, _: DefinedFuncIndex) -> &FunctionInfo {",
          "1438:                 unimplemented!()",
          "1439:             }",
          "1440:             fn signature(&self, _: SignatureIndex) -> VMSharedSignatureIndex {",
          "1441:                 unimplemented!()",
          "1442:             }",
          "1443:             fn memfd_image(",
          "1444:                 &self,",
          "1445:                 _: DefinedMemoryIndex,",
          "1446:             ) -> anyhow::Result<Option<&Arc<MemoryMemFd>>> {",
          "1447:                 Ok(None)",
          "1448:             }",
          "1450:             fn unique_id(&self) -> Option<CompiledModuleId> {",
          "1451:                 None",
          "1452:             }",
          "1453:             fn wasm_data(&self) -> &[u8] {",
          "1454:                 &[]",
          "1455:             }",
          "1456:         }",
          "1458:         Arc::new(RuntimeInfo(module))",
          "1459:     }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1463:         let mut handles = Vec::new();",
          "1464:         let module = Arc::new(Module::default());",
          "1467:         for _ in (0..3).rev() {",
          "1468:             handles.push(",
          "1469:                 instances",
          "1470:                     .allocate(InstanceAllocationRequest {",
          "1475:                         imports: Imports {",
          "1476:                             functions: &[],",
          "1477:                             tables: &[],",
          "1478:                             memories: &[],",
          "1479:                             globals: &[],",
          "1480:                         },",
          "1482:                         host_state: Box::new(()),",
          "1483:                         store: StorePtr::empty(),",
          "1486:                     })",
          "1487:                     .expect(\"allocation should succeed\"),",
          "1488:             );",
          "",
          "[Removed Lines]",
          "1465:         let functions = &PrimaryMap::new();",
          "1471:                         module: &module,",
          "1472:                         unique_id: None,",
          "1473:                         image_base: 0,",
          "1474:                         functions,",
          "1481:                         shared_signatures: VMSharedSignatureIndex::default().into(),",
          "1484:                         wasm_data: &[],",
          "1485:                         memfds: None,",
          "",
          "[Added Lines]",
          "1506:                         runtime_info: &empty_runtime_info(module.clone()),",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1494:         );",
          "1496:         match instances.allocate(InstanceAllocationRequest {",
          "1501:             imports: Imports {",
          "1502:                 functions: &[],",
          "1503:                 tables: &[],",
          "1504:                 memories: &[],",
          "1505:                 globals: &[],",
          "1506:             },",
          "1508:             host_state: Box::new(()),",
          "1509:             store: StorePtr::empty(),",
          "1512:         }) {",
          "1513:             Err(InstantiationError::Limit(3)) => {}",
          "1514:             _ => panic!(\"unexpected error\"),",
          "",
          "[Removed Lines]",
          "1497:             module: &module,",
          "1498:             unique_id: None,",
          "1499:             functions,",
          "1500:             image_base: 0,",
          "1507:             shared_signatures: VMSharedSignatureIndex::default().into(),",
          "1510:             wasm_data: &[],",
          "1511:             memfds: None,",
          "",
          "[Added Lines]",
          "1526:             runtime_info: &empty_runtime_info(module),",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator/pooling/uffd.rs||crates/runtime/src/instance/allocator/pooling/uffd.rs": [
          "File: crates/runtime/src/instance/allocator/pooling/uffd.rs -> crates/runtime/src/instance/allocator/pooling/uffd.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "262:     page_index: usize,",
          "263: ) -> Result<()> {",
          "266:         let memory_index = instance.module().memory_index(memory_index);",
          "267:         let pages = &map[memory_index];",
          "",
          "[Removed Lines]",
          "265:     if let MemoryInitialization::Paged { map, .. } = &instance.module.memory_initialization {",
          "",
          "[Added Lines]",
          "265:     if let MemoryInitialization::Paged { map, .. } =",
          "266:         &instance.runtime_info.module().memory_initialization",
          "267:     {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "437:     use super::*;",
          "438:     use crate::{",
          "439:         Imports, InstanceAllocationRequest, InstanceLimits, ModuleLimits,",
          "441:     };",
          "442:     use std::sync::atomic::AtomicU64;",
          "443:     use std::sync::Arc;",
          "446:     #[cfg(target_pointer_width = \"64\")]",
          "447:     #[test]",
          "",
          "[Removed Lines]",
          "440:         PoolingAllocationStrategy, Store, StorePtr, VMSharedSignatureIndex,",
          "444:     use wasmtime_environ::{Memory, MemoryPlan, MemoryStyle, Module, PrimaryMap, Tunables};",
          "",
          "[Added Lines]",
          "442:         PoolingAllocationStrategy, Store, StorePtr,",
          "446:     use wasmtime_environ::{Memory, MemoryPlan, MemoryStyle, Module, Tunables};",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "574:             let mut handles = Vec::new();",
          "575:             let module = Arc::new(module);",
          "579:             for _ in 0..instances.max_instances {",
          "580:                 handles.push(",
          "581:                     instances",
          "582:                         .allocate(InstanceAllocationRequest {",
          "588:                             imports: Imports {",
          "589:                                 functions: &[],",
          "590:                                 tables: &[],",
          "591:                                 memories: &[],",
          "592:                                 globals: &[],",
          "593:                             },",
          "595:                             host_state: Box::new(()),",
          "596:                             store: StorePtr::new(&mut mock_store),",
          "598:                         })",
          "599:                         .expect(\"instance should allocate\"),",
          "600:                 );",
          "",
          "[Removed Lines]",
          "576:             let functions = &PrimaryMap::new();",
          "583:                             module: &module,",
          "584:                             memfds: None,",
          "585:                             unique_id: None,",
          "586:                             image_base: 0,",
          "587:                             functions,",
          "594:                             shared_signatures: VMSharedSignatureIndex::default().into(),",
          "597:                             wasm_data: &[],",
          "",
          "[Added Lines]",
          "584:                             runtime_info: &super::super::test::empty_runtime_info(module.clone()),",
          "",
          "---------------"
        ],
        "crates/runtime/src/lib.rs||crates/runtime/src/lib.rs": [
          "File: crates/runtime/src/lib.rs -> crates/runtime/src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #![cfg_attr(not(memfd), allow(unused_variables, unreachable_code))]",
          "24: use std::sync::atomic::AtomicU64;",
          "26: use anyhow::Error;",
          "28: mod export;",
          "29: mod externref;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: use std::sync::Arc;",
          "28: use wasmtime_environ::DefinedFuncIndex;",
          "29: use wasmtime_environ::DefinedMemoryIndex;",
          "30: use wasmtime_environ::FunctionInfo;",
          "31: use wasmtime_environ::SignatureIndex;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "146:     fn new_epoch(&mut self) -> Result<u64, Error>;",
          "147: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "167: pub trait ModuleRuntimeInfo: Send + Sync + 'static {",
          "169:     fn module(&self) -> &Arc<wasmtime_environ::Module>;",
          "172:     fn signature(&self, index: SignatureIndex) -> VMSharedSignatureIndex;",
          "175:     fn image_base(&self) -> usize;",
          "179:     fn function_info(&self, func_index: DefinedFuncIndex) -> &FunctionInfo;",
          "182:     fn memfd_image(&self, memory: DefinedMemoryIndex) -> anyhow::Result<Option<&Arc<MemoryMemFd>>>;",
          "187:     fn unique_id(&self) -> Option<CompiledModuleId>;",
          "190:     fn wasm_data(&self) -> &[u8];",
          "191: }",
          "",
          "---------------"
        ],
        "crates/runtime/src/libcalls.rs||crates/runtime/src/libcalls.rs": [
          "File: crates/runtime/src/libcalls.rs -> crates/runtime/src/libcalls.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: use backtrace::Backtrace;",
          "65: use std::mem;",
          "66: use std::ptr::{self, NonNull};",
          "69: const TOINT_32: f32 = 1.0 / f32::EPSILON;",
          "70: const TOINT_64: f64 = 1.0 / f64::EPSILON;",
          "",
          "[Removed Lines]",
          "67: use wasmtime_environ::{DataIndex, ElemIndex, GlobalIndex, MemoryIndex, TableIndex, TrapCode};",
          "",
          "[Added Lines]",
          "67: use wasmtime_environ::{",
          "68:     DataIndex, ElemIndex, FuncIndex, GlobalIndex, MemoryIndex, TableIndex, TrapCode,",
          "69: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "293:         let src_table_index = TableIndex::from_u32(src_table_index);",
          "294:         let instance = (*vmctx).instance_mut();",
          "295:         let dst_table = instance.get_table(dst_table_index);",
          "297:         Table::copy(dst_table, src_table, dst, src, len)",
          "298:     };",
          "299:     if let Err(trap) = result {",
          "",
          "[Removed Lines]",
          "296:         let src_table = instance.get_table(src_table_index);",
          "",
          "[Added Lines]",
          "299:         let src_range = src..(src.checked_add(len).unwrap_or(u32::MAX));",
          "300:         let src_table = instance.get_table_with_lazy_init(src_table_index, src_range);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "386:     }",
          "387: }",
          "390: pub unsafe extern \"C\" fn data_drop(vmctx: *mut VMContext, data_index: u32) {",
          "391:     let data_index = DataIndex::from_u32(data_index);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "394: pub unsafe extern \"C\" fn ref_func(vmctx: *mut VMContext, func_index: u32) -> *mut u8 {",
          "395:     let instance = (*vmctx).instance_mut();",
          "396:     let anyfunc = instance",
          "397:         .get_caller_checked_anyfunc(FuncIndex::from_u32(func_index))",
          "398:         .expect(\"ref_func: caller_checked_anyfunc should always be available for given func index\");",
          "399:     anyfunc as *mut _",
          "400: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "393:     instance.data_drop(data_index)",
          "394: }",
          "397: pub unsafe extern \"C\" fn drop_externref(externref: *mut u8) {",
          "398:     let externref = externref as *mut crate::externref::VMExternData;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "410: pub unsafe extern \"C\" fn table_get_lazy_init_funcref(",
          "411:     vmctx: *mut VMContext,",
          "412:     table_index: u32,",
          "413:     index: u32,",
          "414: ) -> *mut u8 {",
          "415:     let instance = (*vmctx).instance_mut();",
          "416:     let table_index = TableIndex::from_u32(table_index);",
          "417:     let table = instance.get_table_with_lazy_init(table_index, std::iter::once(index));",
          "418:     let elem = (*table)",
          "419:         .get(index)",
          "420:         .expect(\"table access already bounds-checked\");",
          "422:     elem.into_ref_asserting_initialized() as *mut _",
          "423: }",
          "",
          "---------------"
        ],
        "crates/runtime/src/memfd.rs||crates/runtime/src/memfd.rs": [
          "File: crates/runtime/src/memfd.rs -> crates/runtime/src/memfd.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: const MAX_MEMFD_IMAGE_SIZE: usize = 1024 * 1024 * 1024; // limit to 1GiB.",
          "24: impl ModuleMemFds {",
          "29:         self.memories[defined_index].as_ref()",
          "30:     }",
          "31: }",
          "",
          "[Removed Lines]",
          "25:     pub(crate) fn get_memory_image(",
          "26:         &self,",
          "27:         defined_index: DefinedMemoryIndex,",
          "28:     ) -> Option<&Arc<MemoryMemFd>> {",
          "",
          "[Added Lines]",
          "26:     pub fn get_memory_image(&self, defined_index: DefinedMemoryIndex) -> Option<&Arc<MemoryMemFd>> {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "70:         let page_size = region::page::size() as u64;",
          "71:         let page_align = |x: u64| x & !(page_size - 1);",
          "72:         let page_align_up = |x: u64| page_align(x + page_size - 1);",
          "",
          "[Removed Lines]",
          "69:     pub fn new(module: &Module, wasm_data: &[u8]) -> Result<Option<Arc<ModuleMemFds>>> {",
          "",
          "[Added Lines]",
          "67:     pub fn new(module: &Module, wasm_data: &[u8]) -> Result<Option<ModuleMemFds>> {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "198:             assert_eq!(idx, defined_memory);",
          "199:         }",
          "202:     }",
          "203: }",
          "",
          "[Removed Lines]",
          "201:         Ok(Some(Arc::new(ModuleMemFds { memories })))",
          "",
          "[Added Lines]",
          "199:         Ok(Some(ModuleMemFds { memories }))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "403:             assert!(image.offset.checked_add(image.len).unwrap() <= initial_size_bytes);",
          "404:             if image.len > 0 {",
          "405:                 unsafe {",
          "",
          "[Removed Lines]",
          "402:         if let Some(image) = maybe_image {",
          "",
          "[Added Lines]",
          "400:         if let Some(image) = maybe_image.as_ref() {",
          "",
          "---------------"
        ],
        "crates/runtime/src/memfd_disabled.rs||crates/runtime/src/memfd_disabled.rs": [
          "File: crates/runtime/src/memfd_disabled.rs -> crates/runtime/src/memfd_disabled.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:         Ok(None)",
          "24:     }",
          "30:         match *self {}",
          "",
          "[Removed Lines]",
          "22:     pub fn new(_: &Module, _: &[u8]) -> Result<Option<Arc<ModuleMemFds>>> {",
          "27:     pub(crate) fn get_memory_image(&self, _: DefinedMemoryIndex) -> Option<&Arc<MemoryMemFd>> {",
          "",
          "[Added Lines]",
          "22:     pub fn new(_: &Module, _: &[u8]) -> Result<Option<ModuleMemFds>> {",
          "27:     pub fn get_memory_image(&self, _: DefinedMemoryIndex) -> Option<&Arc<MemoryMemFd>> {",
          "",
          "---------------"
        ],
        "crates/runtime/src/table.rs||crates/runtime/src/table.rs": [
          "File: crates/runtime/src/table.rs -> crates/runtime/src/table.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: use std::convert::{TryFrom, TryInto};",
          "9: use std::ops::Range;",
          "10: use std::ptr;",
          "",
          "[Removed Lines]",
          "11: use wasmtime_environ::{TablePlan, TrapCode, WasmType};",
          "",
          "[Added Lines]",
          "11: use wasmtime_environ::{TablePlan, TrapCode, WasmType, FUNCREF_INIT_BIT, FUNCREF_MASK};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "19:     FuncRef(*mut VMCallerCheckedAnyfunc),",
          "21:     ExternRef(Option<VMExternRef>),",
          "22: }",
          "24: #[derive(Copy, Clone, PartialEq, Eq)]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26:     UninitFunc,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "33: unsafe impl Sync for TableElement where VMExternRef: Sync {}",
          "35: impl TableElement {",
          "51:         }",
          "52:     }",
          "67:         }",
          "68:     }",
          "",
          "[Removed Lines]",
          "43:     unsafe fn from_raw(ty: TableElementType, ptr: usize) -> Self {",
          "44:         match ty {",
          "45:             TableElementType::Func => Self::FuncRef(ptr as _),",
          "46:             TableElementType::Extern => Self::ExternRef(if ptr == 0 {",
          "47:                 None",
          "48:             } else {",
          "49:                 Some(VMExternRef::from_raw(ptr as *mut u8))",
          "50:             }),",
          "59:     unsafe fn clone_from_raw(ty: TableElementType, ptr: usize) -> Self {",
          "60:         match ty {",
          "61:             TableElementType::Func => Self::FuncRef(ptr as _),",
          "62:             TableElementType::Extern => Self::ExternRef(if ptr == 0 {",
          "63:                 None",
          "64:             } else {",
          "65:                 Some(VMExternRef::clone_from_raw(ptr as *mut u8))",
          "66:             }),",
          "",
          "[Added Lines]",
          "48:     unsafe fn from_table_value(ty: TableElementType, ptr: usize) -> Self {",
          "49:         match (ty, ptr) {",
          "50:             (TableElementType::Func, 0) => Self::UninitFunc,",
          "51:             (TableElementType::Func, ptr) => Self::FuncRef((ptr & FUNCREF_MASK) as _),",
          "52:             (TableElementType::Extern, 0) => Self::ExternRef(None),",
          "53:             (TableElementType::Extern, ptr) => {",
          "54:                 Self::ExternRef(Some(VMExternRef::from_raw(ptr as *mut u8)))",
          "55:             }",
          "64:     unsafe fn clone_from_table_value(ty: TableElementType, ptr: usize) -> Self {",
          "65:         match (ty, ptr) {",
          "66:             (TableElementType::Func, 0) => Self::UninitFunc,",
          "67:             (TableElementType::Func, ptr) => Self::FuncRef((ptr & FUNCREF_MASK) as _),",
          "68:             (TableElementType::Extern, 0) => Self::ExternRef(None),",
          "69:             (TableElementType::Extern, ptr) => {",
          "70:                 Self::ExternRef(Some(VMExternRef::clone_from_raw(ptr as *mut u8)))",
          "71:             }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "79:         match self {",
          "81:             Self::ExternRef(e) => e.map_or(0, |e| e.into_raw() as usize),",
          "82:         }",
          "83:     }",
          "84: }",
          "",
          "[Removed Lines]",
          "78:     unsafe fn into_raw(self) -> usize {",
          "80:             Self::FuncRef(e) => e as _,",
          "",
          "[Added Lines]",
          "85:     unsafe fn into_table_value(self) -> usize {",
          "86:         match self {",
          "87:             Self::UninitFunc => 0,",
          "88:             Self::FuncRef(e) => (e as usize) | FUNCREF_INIT_BIT,",
          "89:             Self::ExternRef(e) => e.map_or(0, |e| e.into_raw() as usize),",
          "90:         }",
          "91:     }",
          "104:     pub(crate) unsafe fn into_ref_asserting_initialized(self) -> usize {",
          "106:             Self::FuncRef(e) => (e as usize),",
          "108:             Self::UninitFunc => panic!(\"Uninitialized table element value outside of table slot\"),",
          "109:         }",
          "110:     }",
          "114:     pub(crate) fn is_uninit(&self) -> bool {",
          "115:         match self {",
          "116:             Self::UninitFunc => true,",
          "117:             _ => false,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "334:     pub fn get(&self, index: u32) -> Option<TableElement> {",
          "335:         self.elements()",
          "336:             .get(index as usize)",
          "338:     }",
          "",
          "[Removed Lines]",
          "337:             .map(|p| unsafe { TableElement::clone_from_raw(self.element_type(), *p) })",
          "",
          "[Added Lines]",
          "373:             .map(|p| unsafe { TableElement::clone_from_table_value(self.element_type(), *p) })",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "436:     fn set_raw(ty: TableElementType, elem: &mut usize, val: TableElement) {",
          "437:         unsafe {",
          "438:             let old = *elem;",
          "443:         }",
          "444:     }",
          "",
          "[Removed Lines]",
          "442:             let _ = TableElement::from_raw(ty, old);",
          "",
          "[Added Lines]",
          "478:             let _ = TableElement::from_table_value(ty, old);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "465:                 let dst = dst_table.elements_mut();",
          "466:                 let src = src_table.elements();",
          "467:                 for (s, d) in src_range.zip(dst_range) {",
          "469:                     Self::set_raw(ty, &mut dst[d], elem);",
          "470:                 }",
          "471:             }",
          "",
          "[Removed Lines]",
          "468:                     let elem = unsafe { TableElement::clone_from_raw(ty, src[s]) };",
          "",
          "[Added Lines]",
          "504:                     let elem = unsafe { TableElement::clone_from_table_value(ty, src[s]) };",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "486:                 if dst_range.start <= src_range.start {",
          "487:                     for (s, d) in src_range.zip(dst_range) {",
          "489:                         Self::set_raw(ty, &mut dst[d], elem);",
          "490:                     }",
          "491:                 } else {",
          "492:                     for (s, d) in src_range.rev().zip(dst_range.rev()) {",
          "494:                         Self::set_raw(ty, &mut dst[d], elem);",
          "495:                     }",
          "496:                 }",
          "",
          "[Removed Lines]",
          "488:                         let elem = unsafe { TableElement::clone_from_raw(ty, dst[s]) };",
          "493:                         let elem = unsafe { TableElement::clone_from_raw(ty, dst[s]) };",
          "",
          "[Added Lines]",
          "524:                         let elem = unsafe { TableElement::clone_from_table_value(ty, dst[s]) };",
          "529:                         let elem = unsafe { TableElement::clone_from_table_value(ty, dst[s]) };",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "512:         for element in self.elements() {",
          "514:         }",
          "515:     }",
          "516: }",
          "",
          "[Removed Lines]",
          "513:             drop(unsafe { TableElement::from_raw(ty, *element) });",
          "",
          "[Added Lines]",
          "549:             drop(unsafe { TableElement::from_table_value(ty, *element) });",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/externals.rs||crates/wasmtime/src/externals.rs": [
          "File: crates/wasmtime/src/externals.rs -> crates/wasmtime/src/externals.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "477:         let init = init.into_table_element(store, ty.element())?;",
          "478:         unsafe {",
          "479:             let table = Table::from_wasmtime_table(wasmtime_export, store);",
          "481:                 .fill(0, init, ty.minimum())",
          "482:                 .map_err(Trap::from_runtime)?;",
          "",
          "[Removed Lines]",
          "480:             (*table.wasmtime_table(store))",
          "",
          "[Added Lines]",
          "480:             (*table.wasmtime_table(store, std::iter::empty()))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "497:         TableType::from_wasmtime_table(ty)",
          "498:     }",
          "501:         unsafe {",
          "502:             let export = &store[self.0];",
          "503:             let mut handle = InstanceHandle::from_vmctx(export.vmctx);",
          "504:             let idx = handle.table_index(&*export.definition);",
          "506:         }",
          "507:     }",
          "",
          "[Removed Lines]",
          "500:     fn wasmtime_table(&self, store: &mut StoreOpaque) -> *mut runtime::Table {",
          "505:             handle.get_defined_table(idx)",
          "",
          "[Added Lines]",
          "500:     fn wasmtime_table(",
          "501:         &self,",
          "502:         store: &mut StoreOpaque,",
          "503:         lazy_init_range: impl Iterator<Item = u32>,",
          "504:     ) -> *mut runtime::Table {",
          "509:             handle.get_defined_table_with_lazy_init(idx, lazy_init_range)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "516:     pub fn get(&self, mut store: impl AsContextMut, index: u32) -> Option<Val> {",
          "517:         let store = store.as_context_mut().0;",
          "519:         unsafe {",
          "520:             match (*table).get(index)? {",
          "521:                 runtime::TableElement::FuncRef(f) => {",
          "",
          "[Removed Lines]",
          "518:         let table = self.wasmtime_table(store);",
          "",
          "[Added Lines]",
          "522:         let table = self.wasmtime_table(store, std::iter::once(index));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "526:                 runtime::TableElement::ExternRef(Some(x)) => {",
          "527:                     Some(Val::ExternRef(Some(ExternRef { inner: x })))",
          "528:                 }",
          "529:             }",
          "530:         }",
          "531:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "533:                 runtime::TableElement::UninitFunc => {",
          "534:                     unreachable!(\"lazy init above should have converted UninitFunc\")",
          "535:                 }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "545:         let store = store.as_context_mut().0;",
          "546:         let ty = self.ty(&store).element().clone();",
          "547:         let val = val.into_table_element(store, ty)?;",
          "549:         unsafe {",
          "550:             (*table)",
          "551:                 .set(index, val)",
          "",
          "[Removed Lines]",
          "548:         let table = self.wasmtime_table(store);",
          "",
          "[Added Lines]",
          "555:         let table = self.wasmtime_table(store, std::iter::empty());",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "591:         let store = store.as_context_mut().0;",
          "592:         let ty = self.ty(&store).element().clone();",
          "593:         let init = init.into_table_element(store, ty)?;",
          "595:         unsafe {",
          "596:             match (*table).grow(delta, init, store)? {",
          "597:                 Some(size) => {",
          "",
          "[Removed Lines]",
          "594:         let table = self.wasmtime_table(store);",
          "",
          "[Added Lines]",
          "601:         let table = self.wasmtime_table(store, std::iter::empty());",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "656:             bail!(\"tables do not have the same element type\");",
          "657:         }",
          "661:         unsafe {",
          "663:                 .map_err(Trap::from_runtime)?;",
          "664:         }",
          "665:         Ok(())",
          "",
          "[Removed Lines]",
          "659:         let dst = dst_table.wasmtime_table(store);",
          "660:         let src = src_table.wasmtime_table(store);",
          "662:             runtime::Table::copy(dst, src, dst_index, src_index, len)",
          "",
          "[Added Lines]",
          "666:         let dst_table = dst_table.wasmtime_table(store, std::iter::empty());",
          "667:         let src_range = src_index..(src_index.checked_add(len).unwrap_or(u32::MAX));",
          "668:         let src_table = src_table.wasmtime_table(store, src_range);",
          "670:             runtime::Table::copy(dst_table, src_table, dst_index, src_index, len)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "686:         let ty = self.ty(&store).element().clone();",
          "687:         let val = val.into_table_element(store, ty)?;",
          "690:         unsafe {",
          "691:             (*table).fill(dst, val, len).map_err(Trap::from_runtime)?;",
          "692:         }",
          "",
          "[Removed Lines]",
          "689:         let table = self.wasmtime_table(store);",
          "",
          "[Added Lines]",
          "697:         let table = self.wasmtime_table(store, std::iter::empty());",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/func.rs||crates/wasmtime/src/func.rs": [
          "File: crates/wasmtime/src/func.rs -> crates/wasmtime/src/func.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "2064:         let idx = EntityIndex::Function(FuncIndex::from_u32(0));",
          "2065:         let export = match instance.lookup_by_declaration(&idx) {",
          "2066:             wasmtime_runtime::Export::Function(f) => f,",
          "",
          "[Removed Lines]",
          "2063:     fn _new(engine: &Engine, instance: InstanceHandle, trampoline: VMTrampoline) -> Self {",
          "",
          "[Added Lines]",
          "2063:     fn _new(engine: &Engine, mut instance: InstanceHandle, trampoline: VMTrampoline) -> Self {",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/instance.rs||crates/wasmtime/src/instance.rs": [
          "File: crates/wasmtime/src/instance.rs -> crates/wasmtime/src/instance.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "330:             InstanceData::Instantiated { id, exports, .. } => {",
          "333:                 if let Some(export) = &exports[i] {",
          "334:                     return Some(export.clone());",
          "335:                 }",
          "336:                 let item = unsafe {",
          "338:                 };",
          "339:                 let exports = match &mut store[self.0] {",
          "340:                     InstanceData::Instantiated { exports, .. } => exports,",
          "",
          "[Removed Lines]",
          "331:                 let instance = store.instance(*id);",
          "332:                 let (i, _, index) = instance.module().exports.get_full(name)?;",
          "337:                     Extern::from_wasmtime_export(instance.lookup_by_declaration(index), store)",
          "",
          "[Added Lines]",
          "331:                 let id = *id;",
          "332:                 let instance = store.instance(id);",
          "333:                 let (i, _, &index) = instance.module().exports.get_full(name)?;",
          "338:                 let instance = store.instance_mut(id); // reborrow the &mut Instancehandle",
          "340:                     Extern::from_wasmtime_export(instance.lookup_by_declaration(&index), store)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "691:         store.modules_mut().register(&self.cur.module);",
          "696:         unsafe {",
          "",
          "[Removed Lines]",
          "694:         let memfds = self.cur.module.memfds()?;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "706:             let instance_to_be = store.store_data().next_id::<InstanceData>();",
          "707:             let mut instance_handle =",
          "708:                 store",
          "709:                     .engine()",
          "710:                     .allocator()",
          "711:                     .allocate(InstanceAllocationRequest {",
          "717:                         imports: self.cur.build(),",
          "719:                         host_state: Box::new(Instance(instance_to_be)),",
          "720:                         store: StorePtr::new(store.traitobj()),",
          "722:                     })?;",
          "",
          "[Removed Lines]",
          "712:                         module: compiled_module.module(),",
          "713:                         unique_id: Some(compiled_module.unique_id()),",
          "714:                         memfds,",
          "715:                         image_base: compiled_module.code().as_ptr() as usize,",
          "716:                         functions: compiled_module.functions(),",
          "718:                         shared_signatures: self.cur.module.signatures().as_module_map().into(),",
          "721:                         wasm_data: compiled_module.wasm_data(),",
          "",
          "[Added Lines]",
          "713:                         runtime_info: &self.cur.module.runtime_info(),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "821:         };",
          "825:         let f = match instance.lookup_by_declaration(&EntityIndex::Function(start)) {",
          "826:             wasmtime_runtime::Export::Function(f) => f,",
          "827:             _ => unreachable!(), // valid modules shouldn't hit this",
          "",
          "[Removed Lines]",
          "824:         let instance = store.0.instance(id);",
          "",
          "[Added Lines]",
          "819:         let instance = store.0.instance_mut(id);",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/module.rs||crates/wasmtime/src/module.rs": [
          "File: crates/wasmtime/src/module.rs -> crates/wasmtime/src/module.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: use std::path::Path;",
          "11: use std::sync::Arc;",
          "12: use wasmparser::{Parser, ValidPayload, Validator};",
          "14: use wasmtime_jit::{CompiledModule, CompiledModuleInfo, MmapVec, TypeTables};",
          "17: mod registry;",
          "18: mod serialization;",
          "",
          "[Removed Lines]",
          "13: use wasmtime_environ::{ModuleEnvironment, ModuleIndex, PrimaryMap};",
          "15: use wasmtime_runtime::ModuleMemFds;",
          "",
          "[Added Lines]",
          "13: use wasmtime_environ::{",
          "14:     DefinedFuncIndex, DefinedMemoryIndex, FunctionInfo, ModuleEnvironment, ModuleIndex, PrimaryMap,",
          "15:     SignatureIndex,",
          "16: };",
          "18: use wasmtime_runtime::{CompiledModuleId, MemoryMemFd, ModuleMemFds, VMSharedSignatureIndex};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "111:     signatures: Arc<SignatureCollection>,",
          "117: }",
          "119: impl Module {",
          "",
          "[Removed Lines]",
          "116:     memfds: OnceCell<Option<Arc<ModuleMemFds>>>,",
          "",
          "[Added Lines]",
          "119:     memfds: OnceCell<Option<ModuleMemFds>>,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "421:                 translation.try_paged_init();",
          "422:             }",
          "424:             let (mmap, info) =",
          "425:                 wasmtime_jit::finish_compile(translation, obj, funcs, trampolines, tunables)?;",
          "426:             Ok((mmap, Some(info)))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "430:             translation.try_func_table_init();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "723:         &self.inner.signatures",
          "724:     }",
          "",
          "[Removed Lines]",
          "726:     pub(crate) fn memfds(&self) -> Result<Option<&Arc<ModuleMemFds>>> {",
          "727:         if !self.engine().config().memfd {",
          "728:             return Ok(None);",
          "729:         }",
          "730:         Ok(self",
          "731:             .inner",
          "732:             .memfds",
          "733:             .get_or_try_init(|| {",
          "734:                 ModuleMemFds::new(self.inner.module.module(), self.inner.module.wasm_data())",
          "735:             })?",
          "736:             .as_ref())",
          "737:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "953:     pub fn engine(&self) -> &Engine {",
          "954:         &self.inner.engine",
          "955:     }",
          "956: }",
          "958: fn _assert_send_sync() {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "954:     pub(crate) fn runtime_info(&self) -> Arc<dyn wasmtime_runtime::ModuleRuntimeInfo> {",
          "957:         self.inner.clone()",
          "958:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "987:         env!(\"CARGO_PKG_VERSION\").hash(hasher);",
          "988:     }",
          "989: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "994: impl wasmtime_runtime::ModuleRuntimeInfo for ModuleInner {",
          "995:     fn module(&self) -> &Arc<wasmtime_environ::Module> {",
          "996:         self.module.module()",
          "997:     }",
          "999:     fn signature(&self, index: SignatureIndex) -> VMSharedSignatureIndex {",
          "1000:         self.signatures.as_module_map()[index]",
          "1001:     }",
          "1003:     fn image_base(&self) -> usize {",
          "1004:         self.module.code().as_ptr() as usize",
          "1005:     }",
          "1007:     fn function_info(&self, index: DefinedFuncIndex) -> &FunctionInfo {",
          "1008:         self.module.func_info(index)",
          "1009:     }",
          "1011:     fn memfd_image(&self, memory: DefinedMemoryIndex) -> Result<Option<&Arc<MemoryMemFd>>> {",
          "1012:         if !self.engine.config().memfd {",
          "1013:             return Ok(None);",
          "1014:         }",
          "1016:         let memfds = self",
          "1017:             .memfds",
          "1018:             .get_or_try_init(|| ModuleMemFds::new(self.module.module(), self.module.wasm_data()))?;",
          "1019:         Ok(memfds",
          "1020:             .as_ref()",
          "1021:             .and_then(|memfds| memfds.get_memory_image(memory)))",
          "1022:     }",
          "1024:     fn unique_id(&self) -> Option<CompiledModuleId> {",
          "1025:         Some(self.module.unique_id())",
          "1026:     }",
          "1028:     fn wasm_data(&self) -> &[u8] {",
          "1029:         self.module.wasm_data()",
          "1030:     }",
          "1031: }",
          "1037: pub(crate) struct BareModuleInfo {",
          "1038:     module: Arc<wasmtime_environ::Module>,",
          "1039:     image_base: usize,",
          "1040:     one_signature: Option<(SignatureIndex, VMSharedSignatureIndex)>,",
          "1041:     function_info: PrimaryMap<DefinedFuncIndex, FunctionInfo>,",
          "1042: }",
          "1044: impl BareModuleInfo {",
          "1045:     pub(crate) fn empty(module: Arc<wasmtime_environ::Module>) -> Self {",
          "1046:         BareModuleInfo {",
          "1047:             module,",
          "1048:             image_base: 0,",
          "1049:             one_signature: None,",
          "1050:             function_info: PrimaryMap::default(),",
          "1051:         }",
          "1052:     }",
          "1054:     pub(crate) fn maybe_imported_func(",
          "1055:         module: Arc<wasmtime_environ::Module>,",
          "1056:         one_signature: Option<(SignatureIndex, VMSharedSignatureIndex)>,",
          "1057:     ) -> Self {",
          "1058:         BareModuleInfo {",
          "1059:             module,",
          "1060:             image_base: 0,",
          "1061:             one_signature,",
          "1062:             function_info: PrimaryMap::default(),",
          "1063:         }",
          "1064:     }",
          "1066:     pub(crate) fn one_func(",
          "1067:         module: Arc<wasmtime_environ::Module>,",
          "1068:         image_base: usize,",
          "1069:         info: FunctionInfo,",
          "1070:         signature_id: SignatureIndex,",
          "1071:         signature: VMSharedSignatureIndex,",
          "1072:     ) -> Self {",
          "1073:         let mut function_info = PrimaryMap::with_capacity(1);",
          "1074:         function_info.push(info);",
          "1075:         BareModuleInfo {",
          "1076:             module,",
          "1077:             image_base,",
          "1078:             function_info,",
          "1079:             one_signature: Some((signature_id, signature)),",
          "1080:         }",
          "1081:     }",
          "1083:     pub(crate) fn into_traitobj(self) -> Arc<dyn wasmtime_runtime::ModuleRuntimeInfo> {",
          "1084:         Arc::new(self)",
          "1085:     }",
          "1086: }",
          "1088: impl wasmtime_runtime::ModuleRuntimeInfo for BareModuleInfo {",
          "1089:     fn module(&self) -> &Arc<wasmtime_environ::Module> {",
          "1090:         &self.module",
          "1091:     }",
          "1093:     fn signature(&self, index: SignatureIndex) -> VMSharedSignatureIndex {",
          "1094:         let (signature_id, signature) = self",
          "1095:             .one_signature",
          "1096:             .expect(\"Signature for one function should be present if queried\");",
          "1097:         assert_eq!(index, signature_id);",
          "1098:         signature",
          "1099:     }",
          "1101:     fn image_base(&self) -> usize {",
          "1102:         self.image_base",
          "1103:     }",
          "1105:     fn function_info(&self, index: DefinedFuncIndex) -> &FunctionInfo {",
          "1106:         &self.function_info[index]",
          "1107:     }",
          "1109:     fn memfd_image(&self, _memory: DefinedMemoryIndex) -> Result<Option<&Arc<MemoryMemFd>>> {",
          "1110:         Ok(None)",
          "1111:     }",
          "1113:     fn unique_id(&self) -> Option<CompiledModuleId> {",
          "1114:         None",
          "1115:     }",
          "1117:     fn wasm_data(&self) -> &[u8] {",
          "1118:         &[]",
          "1119:     }",
          "1120: }",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/store.rs||crates/wasmtime/src/store.rs": [
          "File: crates/wasmtime/src/store.rs -> crates/wasmtime/src/store.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "79: use crate::{module::ModuleRegistry, Engine, Module, Trap, Val, ValRaw};",
          "80: use anyhow::{bail, Result};",
          "81: use std::cell::UnsafeCell;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "79: use crate::module::BareModuleInfo;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "411:     pub fn new(engine: &Engine, data: T) -> Self {",
          "",
          "[Removed Lines]",
          "412:         let functions = &Default::default();",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "420:         let default_callee = unsafe {",
          "421:             let module = Arc::new(wasmtime_environ::Module::default());",
          "422:             OnDemandInstanceAllocator::default()",
          "423:                 .allocate(InstanceAllocationRequest {",
          "424:                     host_state: Box::new(()),",
          "428:                     imports: Default::default(),",
          "432:                     store: StorePtr::empty(),",
          "434:                 })",
          "435:                 .expect(\"failed to allocate default callee\")",
          "436:         };",
          "",
          "[Removed Lines]",
          "425:                     image_base: 0,",
          "426:                     functions,",
          "427:                     shared_signatures: None.into(),",
          "429:                     module: &module,",
          "430:                     unique_id: None,",
          "431:                     memfds: None,",
          "433:                     wasm_data: &[],",
          "",
          "[Added Lines]",
          "422:             let shim = BareModuleInfo::empty(module).into_traitobj();",
          "428:                     runtime_info: &shim,",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/trampoline.rs||crates/wasmtime/src/trampoline.rs": [
          "File: crates/wasmtime/src/trampoline.rs -> crates/wasmtime/src/trampoline.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: use self::global::create_global;",
          "12: use self::memory::create_memory;",
          "13: use self::table::create_table;",
          "14: use crate::store::{InstanceId, StoreOpaque};",
          "15: use crate::{GlobalType, MemoryType, TableType, Val};",
          "16: use anyhow::Result;",
          "17: use std::any::Any;",
          "18: use std::sync::Arc;",
          "20: use wasmtime_runtime::{",
          "21:     Imports, InstanceAllocationRequest, InstanceAllocator, OnDemandInstanceAllocator, StorePtr,",
          "22:     VMFunctionImport, VMSharedSignatureIndex,",
          "",
          "[Removed Lines]",
          "19: use wasmtime_environ::{EntityIndex, GlobalIndex, MemoryIndex, Module, TableIndex};",
          "",
          "[Added Lines]",
          "14: use crate::module::BareModuleInfo;",
          "20: use wasmtime_environ::{EntityIndex, GlobalIndex, MemoryIndex, Module, SignatureIndex, TableIndex};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "27:     store: &mut StoreOpaque,",
          "28:     host_state: Box<dyn Any + Send + Sync>,",
          "29:     func_imports: &[VMFunctionImport],",
          "31: ) -> Result<InstanceId> {",
          "32:     let mut imports = Imports::default();",
          "33:     imports.functions = func_imports;",
          "36:     unsafe {",
          "37:         let config = store.engine().config();",
          "",
          "[Removed Lines]",
          "30:     shared_signature_id: Option<VMSharedSignatureIndex>,",
          "34:     let functions = &Default::default();",
          "",
          "[Added Lines]",
          "31:     one_signature: Option<(SignatureIndex, VMSharedSignatureIndex)>,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "41:         let module = Arc::new(module);",
          "42:         let handle = OnDemandInstanceAllocator::new(config.mem_creator.clone(), 0).allocate(",
          "43:             InstanceAllocationRequest {",
          "49:                 imports,",
          "51:                 host_state,",
          "52:                 store: StorePtr::new(store.traitobj()),",
          "54:             },",
          "55:         )?;",
          "",
          "[Removed Lines]",
          "44:                 module: &module,",
          "45:                 unique_id: None,",
          "46:                 memfds: None,",
          "47:                 functions,",
          "48:                 image_base: 0,",
          "50:                 shared_signatures: shared_signature_id.into(),",
          "53:                 wasm_data: &[],",
          "",
          "[Added Lines]",
          "42:         let runtime_info =",
          "43:             &BareModuleInfo::maybe_imported_func(module, one_signature).into_traitobj();",
          "49:                 runtime_info,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "65: ) -> Result<wasmtime_runtime::ExportGlobal> {",
          "66:     let instance = create_global(store, gt, val)?;",
          "67:     let idx = EntityIndex::Global(GlobalIndex::from_u32(0));",
          "69:         wasmtime_runtime::Export::Global(g) => Ok(g),",
          "70:         _ => unreachable!(),",
          "71:     }",
          "",
          "[Removed Lines]",
          "68:     match store.instance(instance).lookup_by_declaration(&idx) {",
          "",
          "[Added Lines]",
          "64:     match store.instance_mut(instance).lookup_by_declaration(&idx) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "77: ) -> Result<wasmtime_runtime::ExportMemory> {",
          "78:     let instance = create_memory(store, m)?;",
          "79:     let idx = EntityIndex::Memory(MemoryIndex::from_u32(0));",
          "81:         wasmtime_runtime::Export::Memory(m) => Ok(m),",
          "82:         _ => unreachable!(),",
          "83:     }",
          "",
          "[Removed Lines]",
          "80:     match store.instance(instance).lookup_by_declaration(&idx) {",
          "",
          "[Added Lines]",
          "76:     match store.instance_mut(instance).lookup_by_declaration(&idx) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "89: ) -> Result<wasmtime_runtime::ExportTable> {",
          "90:     let instance = create_table(store, t)?;",
          "91:     let idx = EntityIndex::Table(TableIndex::from_u32(0));",
          "93:         wasmtime_runtime::Export::Table(t) => Ok(t),",
          "94:         _ => unreachable!(),",
          "95:     }",
          "",
          "[Removed Lines]",
          "92:     match store.instance(instance).lookup_by_declaration(&idx) {",
          "",
          "[Added Lines]",
          "88:     match store.instance_mut(instance).lookup_by_declaration(&idx) {",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/trampoline/func.rs||crates/wasmtime/src/trampoline/func.rs": [
          "File: crates/wasmtime/src/trampoline/func.rs -> crates/wasmtime/src/trampoline/func.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: use crate::{Engine, FuncType, Trap, ValRaw};",
          "4: use anyhow::Result;",
          "5: use std::any::Any;",
          "6: use std::panic::{self, AssertUnwindSafe};",
          "7: use std::sync::Arc;",
          "9: use wasmtime_jit::{CodeMemory, MmapVec, ProfilingAgent};",
          "10: use wasmtime_runtime::{",
          "11:     Imports, InstanceAllocationRequest, InstanceAllocator, InstanceHandle,",
          "",
          "[Removed Lines]",
          "8: use wasmtime_environ::{EntityIndex, Module, ModuleType, PrimaryMap, SignatureIndex};",
          "",
          "[Added Lines]",
          "3: use crate::module::BareModuleInfo;",
          "9: use wasmtime_environ::{EntityIndex, FunctionInfo, Module, ModuleType, SignatureIndex};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "148:     host_state: Box<dyn Any + Send + Sync>,",
          "149: ) -> Result<InstanceHandle> {",
          "150:     let mut module = Module::new();",
          "154:     let sig_id = SignatureIndex::from_u32(u32::max_value() - 1);",
          "155:     module.types.push(ModuleType::Function(sig_id));",
          "",
          "[Removed Lines]",
          "151:     let mut functions = PrimaryMap::new();",
          "152:     functions.push(Default::default());",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "159:         .insert(String::new(), EntityIndex::Function(func_id));",
          "160:     let module = Arc::new(module);",
          "162:     Ok(",
          "163:         OnDemandInstanceAllocator::default().allocate(InstanceAllocationRequest {",
          "169:             imports: Imports::default(),",
          "171:             host_state,",
          "172:             store: StorePtr::empty(),",
          "174:         })?,",
          "175:     )",
          "176: }",
          "",
          "[Removed Lines]",
          "164:             module: &module,",
          "165:             unique_id: None,",
          "166:             memfds: None,",
          "167:             functions: &functions,",
          "168:             image_base: (*func).as_ptr() as usize,",
          "170:             shared_signatures: sig.into(),",
          "173:             wasm_data: &[],",
          "",
          "[Added Lines]",
          "161:     let runtime_info = &BareModuleInfo::one_func(",
          "162:         module.clone(),",
          "163:         (*func).as_ptr() as usize,",
          "164:         FunctionInfo::default(),",
          "165:         sig_id,",
          "166:         sig,",
          "167:     )",
          "168:     .into_traitobj();",
          "175:             runtime_info,",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/trampoline/global.rs||crates/wasmtime/src/trampoline/global.rs": [
          "File: crates/wasmtime/src/trampoline/global.rs -> crates/wasmtime/src/trampoline/global.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "9:     let mut module = Module::new();",
          "10:     let mut func_imports = Vec::new();",
          "11:     let mut externref_init = None;",
          "14:     let global = Global {",
          "15:         wasm_ty: gt.content().to_wasm_type(),",
          "",
          "[Removed Lines]",
          "12:     let mut shared_signature_id = None;",
          "",
          "[Added Lines]",
          "12:     let mut one_signature = None;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38:                 let f = f.caller_checked_anyfunc(store);",
          "39:                 let f = unsafe { f.as_ref() };",
          "41:                 let sig_id = SignatureIndex::from_u32(u32::max_value() - 1);",
          "42:                 module.types.push(ModuleType::Function(sig_id));",
          "43:                 let func_index = module.functions.push(sig_id);",
          "44:                 module.num_imported_funcs = 1;",
          "",
          "[Removed Lines]",
          "40:                 shared_signature_id = Some(f.type_index);",
          "",
          "[Added Lines]",
          "41:                 one_signature = Some((sig_id, f.type_index));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "64:     module",
          "65:         .exports",
          "66:         .insert(String::new(), EntityIndex::Global(global_id));",
          "75:     if let Some(x) = externref_init {",
          "77:         match instance.lookup_by_declaration(&EntityIndex::Global(global_id)) {",
          "78:             wasmtime_runtime::Export::Global(g) => unsafe {",
          "",
          "[Removed Lines]",
          "67:     let id = create_handle(",
          "68:         module,",
          "69:         store,",
          "70:         Box::new(()),",
          "71:         &func_imports,",
          "72:         shared_signature_id,",
          "73:     )?;",
          "76:         let instance = store.instance(id);",
          "",
          "[Added Lines]",
          "67:     let id = create_handle(module, store, Box::new(()), &func_imports, one_signature)?;",
          "70:         let instance = store.instance_mut(id);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b73ac83c375f953e9433021343f3c85f15beff58",
      "candidate_info": {
        "commit_hash": "b73ac83c375f953e9433021343f3c85f15beff58",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/b73ac83c375f953e9433021343f3c85f15beff58",
        "files": [
          ".github/workflows/main.yml",
          "Cargo.lock",
          "Cargo.toml",
          "crates/environ/src/module.rs",
          "crates/jit/src/instantiate.rs",
          "crates/runtime/Cargo.toml",
          "crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/instance/allocator/memfd.rs",
          "crates/runtime/src/instance/allocator/memfd_disabled.rs",
          "crates/runtime/src/instance/allocator/pooling.rs",
          "crates/runtime/src/instance/allocator/pooling/uffd.rs",
          "crates/runtime/src/lib.rs",
          "crates/runtime/src/memfd.rs",
          "crates/runtime/src/memory.rs",
          "crates/runtime/src/module_id.rs",
          "crates/runtime/src/traphandlers/unix.rs",
          "crates/wasmtime/Cargo.toml",
          "crates/wasmtime/src/engine.rs",
          "crates/wasmtime/src/instance.rs",
          "crates/wasmtime/src/module.rs",
          "crates/wasmtime/src/module/serialization.rs",
          "crates/wasmtime/src/store.rs",
          "crates/wasmtime/src/trampoline.rs",
          "crates/wasmtime/src/trampoline/func.rs",
          "src/lib.rs"
        ],
        "message": "Add a pooling allocator mode based on copy-on-write mappings of memfds.\n\nAs first suggested by Jan on the Zulip here [1], a cheap and effective\nway to obtain copy-on-write semantics of a \"backing image\" for a Wasm\nmemory is to mmap a file with `MAP_PRIVATE`. The `memfd` mechanism\nprovided by the Linux kernel allows us to create anonymous,\nin-memory-only files that we can use for this mapping, so we can\nconstruct the image contents on-the-fly then effectively create a CoW\noverlay. Furthermore, and importantly, `madvise(MADV_DONTNEED, ...)`\nwill discard the CoW overlay, returning the mapping to its original\nstate.\n\nBy itself this is almost enough for a very fast\ninstantiation-termination loop of the same image over and over,\nwithout changing the address space mapping at all (which is\nexpensive). The only missing bit is how to implement\nheap *growth*. But here memfds can help us again: if we create another\nanonymous file and map it where the extended parts of the heap would\ngo, we can take advantage of the fact that a `mmap()` mapping can\nbe *larger than the file itself*, with accesses beyond the end\ngenerating a `SIGBUS`, and the fact that we can cheaply resize the\nfile with `ftruncate`, even after a mapping exists. So we can map the\n\"heap extension\" file once with the maximum memory-slot size and grow\nthe memfd itself as `memory.grow` operations occur.\n\nThe above CoW technique and heap-growth technique together allow us a\nfastpath of `madvise()` and `ftruncate()` only when we re-instantiate\nthe same module over and over, as long as we can reuse the same\nslot. This fastpath avoids all whole-process address-space locks in\nthe Linux kernel, which should mean it is highly scalable. It also\navoids the cost of copying data on read, as the `uffd` heap backend\ndoes when servicing pagefaults; the kernel's own optimized CoW\nlogic (same as used by all file mmaps) is used instead.\n\n[1] https://bytecodealliance.zulipchat.com/#narrow/stream/206238-general/topic/Copy.20on.20write.20based.20instance.20reuse/near/266657772",
        "before_after_code_files": [
          "Cargo.lock||Cargo.lock",
          "crates/environ/src/module.rs||crates/environ/src/module.rs",
          "crates/jit/src/instantiate.rs||crates/jit/src/instantiate.rs",
          "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs",
          "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs",
          "crates/runtime/src/instance/allocator/memfd.rs||crates/runtime/src/instance/allocator/memfd.rs",
          "crates/runtime/src/instance/allocator/memfd_disabled.rs||crates/runtime/src/instance/allocator/memfd_disabled.rs",
          "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
          "crates/runtime/src/instance/allocator/pooling/uffd.rs||crates/runtime/src/instance/allocator/pooling/uffd.rs",
          "crates/runtime/src/lib.rs||crates/runtime/src/lib.rs",
          "crates/runtime/src/memfd.rs||crates/runtime/src/memfd.rs",
          "crates/runtime/src/memory.rs||crates/runtime/src/memory.rs",
          "crates/runtime/src/module_id.rs||crates/runtime/src/module_id.rs",
          "crates/runtime/src/traphandlers/unix.rs||crates/runtime/src/traphandlers/unix.rs",
          "crates/wasmtime/src/engine.rs||crates/wasmtime/src/engine.rs",
          "crates/wasmtime/src/instance.rs||crates/wasmtime/src/instance.rs",
          "crates/wasmtime/src/module.rs||crates/wasmtime/src/module.rs",
          "crates/wasmtime/src/module/serialization.rs||crates/wasmtime/src/module/serialization.rs",
          "crates/wasmtime/src/store.rs||crates/wasmtime/src/store.rs",
          "crates/wasmtime/src/trampoline.rs||crates/wasmtime/src/trampoline.rs",
          "crates/wasmtime/src/trampoline/func.rs||crates/wasmtime/src/trampoline/func.rs",
          "src/lib.rs||src/lib.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs"
          ],
          "candidate": [
            "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs"
          ]
        }
      },
      "candidate_diff": {
        "Cargo.lock||Cargo.lock": [
          "File: Cargo.lock -> Cargo.lock",
          "--- Hunk 1 ---",
          "[Context before]",
          "1602: source = \"registry+https://github.com/rust-lang/crates.io-index\"",
          "1603: checksum = \"308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a\"",
          "1605: [[package]]",
          "1606: name = \"memmap2\"",
          "1607: version = \"0.2.3\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1605: [[package]]",
          "1606: name = \"memfd\"",
          "1607: version = \"0.4.1\"",
          "1608: source = \"registry+https://github.com/rust-lang/crates.io-index\"",
          "1609: checksum = \"f6627dc657574b49d6ad27105ed671822be56e0d2547d413bfbf3e8d8fa92e7a\"",
          "1610: dependencies = [",
          "1611:  \"libc\",",
          "1612: ]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3587:  \"libc\",",
          "3588:  \"log\",",
          "3589:  \"mach\",",
          "3590:  \"memoffset\",",
          "3591:  \"more-asserts\",",
          "3592:  \"rand 0.8.3\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3599:  \"memfd\",",
          "",
          "---------------"
        ],
        "crates/environ/src/module.rs||crates/environ/src/module.rs": [
          "File: crates/environ/src/module.rs -> crates/environ/src/module.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "95:             },",
          "96:         }",
          "97:     }",
          "98: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "104:     pub fn initializer_possibly_out_of_bounds(&self, init: &MemoryInitializer) -> bool {",
          "105:         match init.end() {",
          "107:             None => true,",
          "108:             Some(end) => end > self.memory.minimum * (WASM_PAGE_SIZE as u64),",
          "109:         }",
          "110:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113:     pub data: Range<u32>,",
          "114: }",
          "117: #[derive(Clone, Debug, Serialize, Deserialize)]",
          "118: pub enum MemoryInitialization {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "129: impl MemoryInitializer {",
          "131:     pub fn end(&self) -> Option<u64> {",
          "132:         if self.base.is_some() {",
          "133:             return None;",
          "134:         }",
          "135:         self.offset.checked_add(self.data.len() as u64)",
          "136:     }",
          "137: }",
          "",
          "---------------"
        ],
        "crates/jit/src/instantiate.rs||crates/jit/src/instantiate.rs": [
          "File: crates/jit/src/instantiate.rs -> crates/jit/src/instantiate.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "19:     StackMapInformation, Trampoline, Tunables, WasmFuncType, ELF_WASMTIME_ADDRMAP,",
          "20:     ELF_WASMTIME_TRAPS,",
          "21: };",
          "",
          "[Removed Lines]",
          "22: use wasmtime_runtime::{GdbJitImageRegistration, InstantiationError, VMFunctionBody, VMTrampoline};",
          "",
          "[Added Lines]",
          "22: use wasmtime_runtime::{",
          "23:     CompiledModuleId, CompiledModuleIdAllocator, GdbJitImageRegistration, InstantiationError,",
          "24:     VMFunctionBody, VMTrampoline,",
          "25: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "248:     code: Range<usize>,",
          "249:     code_memory: CodeMemory,",
          "250:     dbg_jit_registration: Option<GdbJitImageRegistration>,",
          "251: }",
          "253: impl CompiledModule {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "255:     unique_id: CompiledModuleId,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "271:         mmap: MmapVec,",
          "272:         info: Option<CompiledModuleInfo>,",
          "273:         profiler: &dyn ProfilingAgent,",
          "274:     ) -> Result<Arc<Self>> {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "279:         id_allocator: &CompiledModuleIdAllocator,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "312:             dbg_jit_registration: None,",
          "313:             code_memory,",
          "314:             meta: info.meta,",
          "315:         };",
          "316:         ret.register_debug_and_profiling(profiler)?;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "321:             unique_id: id_allocator.alloc(),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "333:         Ok(())",
          "334:     }",
          "338:     pub fn mmap(&self) -> &MmapVec {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "345:     pub fn unique_id(&self) -> CompiledModuleId {",
          "346:         self.unique_id",
          "347:     }",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance.rs||crates/runtime/src/instance.rs": [
          "File: crates/runtime/src/instance.rs -> crates/runtime/src/instance.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "98: #[allow(clippy::cast_ptr_alignment)]",
          "99: impl Instance {",
          "102:     unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "101:     pub(crate) fn create_raw(",
          "102:         module: &Arc<Module>,",
          "103:         wasm_data: &'static [u8],",
          "104:         memories: PrimaryMap<DefinedMemoryIndex, Memory>,",
          "105:         tables: PrimaryMap<DefinedTableIndex, Table>,",
          "106:         host_state: Box<dyn Any + Send + Sync>,",
          "107:     ) -> Instance {",
          "108:         Instance {",
          "109:             module: module.clone(),",
          "110:             offsets: VMOffsets::new(HostPtr, &module),",
          "111:             memories,",
          "112:             tables,",
          "113:             dropped_elements: EntitySet::with_capacity(module.passive_elements.len()),",
          "114:             dropped_data: EntitySet::with_capacity(module.passive_data_map.len()),",
          "115:             host_state,",
          "116:             wasm_data,",
          "117:             vmctx: VMContext {",
          "118:                 _marker: std::marker::PhantomPinned,",
          "119:             },",
          "120:         }",
          "121:     }",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator.rs||crates/runtime/src/instance/allocator.rs": [
          "File: crates/runtime/src/instance/allocator.rs -> crates/runtime/src/instance/allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: use crate::table::Table;",
          "5: use crate::traphandlers::Trap;",
          "6: use crate::vmcontext::{",
          "9: };",
          "10: use crate::Store;",
          "11: use anyhow::Result;",
          "12: use std::alloc;",
          "13: use std::any::Any;",
          "14: use std::convert::TryFrom;",
          "16: use std::ptr::{self, NonNull};",
          "17: use std::slice;",
          "18: use std::sync::Arc;",
          "19: use thiserror::Error;",
          "20: use wasmtime_environ::{",
          "24: };",
          "26: #[cfg(feature = \"pooling-allocator\")]",
          "27: mod pooling;",
          "29: #[cfg(feature = \"pooling-allocator\")]",
          "30: pub use self::pooling::{",
          "31:     InstanceLimits, ModuleLimits, PoolingAllocationStrategy, PoolingInstanceAllocator,",
          "",
          "[Removed Lines]",
          "7:     VMBuiltinFunctionsArray, VMCallerCheckedAnyfunc, VMContext, VMGlobalDefinition,",
          "8:     VMSharedSignatureIndex,",
          "15: use std::marker;",
          "21:     DefinedFuncIndex, DefinedMemoryIndex, DefinedTableIndex, EntityRef, EntitySet, FunctionInfo,",
          "22:     GlobalInit, HostPtr, MemoryInitialization, MemoryInitializer, Module, ModuleType, PrimaryMap,",
          "23:     SignatureIndex, TableInitializer, TrapCode, VMOffsets, WasmType, WASM_PAGE_SIZE,",
          "",
          "[Added Lines]",
          "7:     VMBuiltinFunctionsArray, VMCallerCheckedAnyfunc, VMGlobalDefinition, VMSharedSignatureIndex,",
          "9: use crate::ModuleMemFds;",
          "20:     DefinedFuncIndex, DefinedMemoryIndex, DefinedTableIndex, EntityRef, FunctionInfo, GlobalInit,",
          "21:     MemoryInitialization, MemoryInitializer, Module, ModuleType, PrimaryMap, SignatureIndex,",
          "22:     TableInitializer, TrapCode, WasmType, WASM_PAGE_SIZE,",
          "28: #[cfg(feature = \"memfd-allocator\")]",
          "29: mod memfd;",
          "30: #[cfg(feature = \"memfd-allocator\")]",
          "31: pub use self::memfd::MemFdSlot;",
          "33: #[cfg(not(feature = \"memfd-allocator\"))]",
          "34: mod memfd_disabled;",
          "35: #[cfg(not(feature = \"memfd-allocator\"))]",
          "36: pub use self::memfd_disabled::MemFdSlot;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "40:     pub image_base: usize,",
          "44:     pub functions: &'a PrimaryMap<DefinedFuncIndex, FunctionInfo>,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52:     pub memfds: Option<Arc<ModuleMemFds>>,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "377: fn initialize_memories(",
          "378:     instance: &mut Instance,",
          "379:     initializers: &[MemoryInitializer],",
          "380: ) -> Result<(), InstantiationError> {",
          "381:     for init in initializers {",
          "382:         instance",
          "383:             .memory_init_segment(",
          "384:                 init.memory_index,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "391:     module: &Module,",
          "397:         let memory = init.memory_index;",
          "398:         if let Some(defined_index) = module.defined_memory_index(memory) {",
          "403:             if instance.memories[defined_index].is_memfd_with_image() {",
          "404:                 continue;",
          "405:             }",
          "406:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "432:     match &module.memory_initialization {",
          "433:         MemoryInitialization::Paged { map, out_of_bounds } => {",
          "434:             for (index, pages) in map {",
          "435:                 let memory = instance.memory(index);",
          "436:                 let slice =",
          "437:                     unsafe { slice::from_raw_parts_mut(memory.base, memory.current_length) };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "465:                 if instance.memories[index].is_memfd_with_image() {",
          "466:                     continue;",
          "467:                 }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "453:             }",
          "454:         }",
          "455:         MemoryInitialization::Segmented(initializers) => {",
          "457:         }",
          "458:     }",
          "",
          "[Removed Lines]",
          "456:             initialize_memories(instance, initializers)?;",
          "",
          "[Added Lines]",
          "490:             initialize_memories(instance, module, initializers)?;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "691:         let host_state = std::mem::replace(&mut req.host_state, Box::new(()));",
          "693:         let mut handle = {",
          "707:             let layout = instance.alloc_layout();",
          "708:             let instance_ptr = alloc::alloc(layout) as *mut Instance;",
          "709:             if instance_ptr.is_null() {",
          "",
          "[Removed Lines]",
          "694:             let instance = Instance {",
          "695:                 module: req.module.clone(),",
          "696:                 offsets: VMOffsets::new(HostPtr, &req.module),",
          "697:                 memories,",
          "698:                 tables,",
          "699:                 dropped_elements: EntitySet::with_capacity(req.module.passive_elements.len()),",
          "700:                 dropped_data: EntitySet::with_capacity(req.module.passive_data_map.len()),",
          "701:                 host_state,",
          "702:                 wasm_data: &*req.wasm_data,",
          "703:                 vmctx: VMContext {",
          "704:                     _marker: marker::PhantomPinned,",
          "705:                 },",
          "706:             };",
          "",
          "[Added Lines]",
          "728:             let instance =",
          "729:                 Instance::create_raw(&req.module, &*req.wasm_data, memories, tables, host_state);",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator/memfd.rs||crates/runtime/src/instance/allocator/memfd.rs": [
          "File: crates/runtime/src/instance/allocator/memfd.rs -> crates/runtime/src/instance/allocator/memfd.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: use crate::memfd::MemoryMemFd;",
          "4: use crate::InstantiationError;",
          "5: use anyhow::Result;",
          "6: use libc::c_void;",
          "7: use rustix::fd::AsRawFd;",
          "8: use std::convert::TryFrom;",
          "9: use std::fs::File;",
          "10: use std::sync::Arc;",
          "37: #[derive(Debug)]",
          "38: pub struct MemFdSlot {",
          "41:     base: usize,",
          "43:     static_size: usize,",
          "46:     pub(crate) image: Option<Arc<MemoryMemFd>>,",
          "50:     extension_offset: usize,",
          "61:     extension_file: File,",
          "66:     dirty: bool,",
          "67: }",
          "69: impl MemFdSlot {",
          "70:     pub(crate) fn create(",
          "71:         base_addr: *mut c_void,",
          "72:         static_size: usize,",
          "73:     ) -> Result<Self, InstantiationError> {",
          "74:         let base = base_addr as usize;",
          "78:         let extension_memfd = memfd::MemfdOptions::new()",
          "79:             .allow_sealing(true)",
          "80:             .create(\"wasm-anonymous-heap\")",
          "81:             .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "87:         extension_memfd",
          "88:             .add_seal(memfd::FileSeal::SealWrite)",
          "89:             .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "90:         extension_memfd",
          "91:             .add_seal(memfd::FileSeal::SealSeal)",
          "92:             .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "93:         let extension_file = extension_memfd.into_file();",
          "94:         extension_file",
          "95:             .set_len(0)",
          "96:             .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "98:         Ok(MemFdSlot {",
          "99:             base,",
          "100:             static_size,",
          "101:             image: None,",
          "102:             extension_file,",
          "103:             extension_offset: 0,",
          "104:             dirty: false,",
          "105:         })",
          "106:     }",
          "108:     pub(crate) fn set_heap_limit(&mut self, size_bytes: usize) -> Result<()> {",
          "109:         assert!(size_bytes >= self.extension_offset);",
          "115:         self.extension_file",
          "116:             .set_len(u64::try_from(size_bytes - self.extension_offset).unwrap())?;",
          "117:         Ok(())",
          "118:     }",
          "120:     pub(crate) fn instantiate(",
          "121:         &mut self,",
          "122:         initial_size_bytes: usize,",
          "123:         maybe_image: Option<&Arc<MemoryMemFd>>,",
          "124:     ) -> Result<(), InstantiationError> {",
          "125:         assert!(!self.dirty);",
          "127:         if let Some(existing_image) = &self.image {",
          "133:             if let Some(image) = maybe_image {",
          "134:                 if existing_image.fd.as_file().as_raw_fd() == image.fd.as_file().as_raw_fd() {",
          "135:                     self.dirty = true;",
          "136:                     return Ok(());",
          "137:                 }",
          "138:             }",
          "139:         }",
          "161:         if initial_size_bytes > 0 {",
          "162:             unsafe {",
          "163:                 let ptr = rustix::io::mmap_anonymous(",
          "164:                     self.base as *mut c_void,",
          "165:                     initial_size_bytes,",
          "166:                     rustix::io::ProtFlags::READ | rustix::io::ProtFlags::WRITE,",
          "167:                     rustix::io::MapFlags::PRIVATE | rustix::io::MapFlags::FIXED,",
          "168:                 )",
          "169:                 .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "170:                 assert_eq!(ptr as usize, self.base);",
          "171:             }",
          "172:         }",
          "178:         self.extension_offset = initial_size_bytes;",
          "179:         let extension_map_len = self.static_size - initial_size_bytes;",
          "180:         if extension_map_len > 0 {",
          "181:             unsafe {",
          "182:                 let fd = rustix::fd::BorrowedFd::borrow_raw_fd(self.extension_file.as_raw_fd());",
          "183:                 let ptr = rustix::io::mmap(",
          "184:                     (self.base + initial_size_bytes) as *mut c_void,",
          "185:                     extension_map_len,",
          "186:                     rustix::io::ProtFlags::READ | rustix::io::ProtFlags::WRITE,",
          "187:                     rustix::io::MapFlags::PRIVATE | rustix::io::MapFlags::FIXED,",
          "188:                     &fd,",
          "189:                     0,",
          "190:                 )",
          "191:                 .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "192:                 assert_eq!(ptr as usize, self.base + initial_size_bytes);",
          "193:             }",
          "194:         }",
          "197:         if let Some(image) = maybe_image {",
          "198:             if image.len > 0 {",
          "199:                 let image = image.clone();",
          "201:                 unsafe {",
          "202:                     let fd = rustix::fd::BorrowedFd::borrow_raw_fd(image.fd.as_file().as_raw_fd());",
          "203:                     let ptr = rustix::io::mmap(",
          "204:                         (self.base + image.offset) as *mut c_void,",
          "205:                         image.len,",
          "206:                         rustix::io::ProtFlags::READ | rustix::io::ProtFlags::WRITE,",
          "207:                         rustix::io::MapFlags::PRIVATE | rustix::io::MapFlags::FIXED,",
          "208:                         &fd,",
          "209:                         image.offset as u64,",
          "210:                     )",
          "211:                     .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "212:                     assert_eq!(ptr as usize, self.base + image.offset);",
          "213:                 }",
          "215:                 self.image = Some(image);",
          "216:             }",
          "217:         }",
          "219:         self.dirty = true;",
          "220:         Ok(())",
          "221:     }",
          "223:     pub(crate) fn clear_and_remain_ready(&mut self) -> Result<()> {",
          "224:         assert!(self.dirty);",
          "228:         unsafe {",
          "229:             rustix::io::madvise(",
          "230:                 self.base as *mut c_void,",
          "231:                 self.extension_offset,",
          "232:                 rustix::io::Advice::LinuxDontNeed,",
          "233:             )?;",
          "234:         }",
          "237:         self.extension_file",
          "238:             .set_len(0)",
          "239:             .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "240:         self.dirty = false;",
          "241:         Ok(())",
          "242:     }",
          "244:     pub(crate) fn has_image(&self) -> bool {",
          "245:         self.image.is_some()",
          "246:     }",
          "248:     pub(crate) fn is_dirty(&self) -> bool {",
          "249:         self.dirty",
          "250:     }",
          "251: }",
          "253: #[cfg(feature = \"memfd-allocator\")]",
          "254: impl Drop for MemFdSlot {",
          "255:     fn drop(&mut self) {",
          "281:         unsafe {",
          "282:             let _ = rustix::io::mmap_anonymous(",
          "283:                 self.base as *mut _,",
          "284:                 self.static_size,",
          "285:                 rustix::io::ProtFlags::empty(),",
          "286:                 rustix::io::MapFlags::FIXED | rustix::io::MapFlags::NORESERVE,",
          "287:             );",
          "288:         }",
          "289:     }",
          "290: }",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator/memfd_disabled.rs||crates/runtime/src/instance/allocator/memfd_disabled.rs": [
          "File: crates/runtime/src/instance/allocator/memfd_disabled.rs -> crates/runtime/src/instance/allocator/memfd_disabled.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: use crate::InstantiationError;",
          "6: use anyhow::Result;",
          "7: use std::sync::Arc;",
          "15: #[cfg(not(feature = \"memfd-allocator\"))]",
          "16: #[derive(Debug)]",
          "17: pub struct MemFdSlot;",
          "19: #[cfg(not(feature = \"memfd-allocator\"))]",
          "20: #[allow(dead_code)]",
          "21: impl MemFdSlot {",
          "22:     pub(crate) fn create(_: *mut libc::c_void, _: usize) -> Result<Self, InstantiationError> {",
          "23:         panic!(\"create() on invalid MemFdSlot\");",
          "24:     }",
          "26:     pub(crate) fn instantiate(",
          "27:         &mut self,",
          "28:         _: usize,",
          "29:         _: Option<&Arc<crate::memfd::MemoryMemFd>>,",
          "30:     ) -> Result<Self, InstantiationError> {",
          "31:         panic!(\"instantiate() on invalid MemFdSlot\");",
          "32:     }",
          "34:     pub(crate) fn clear_and_remain_ready(&mut self) -> Result<()> {",
          "35:         Ok(())",
          "36:     }",
          "38:     pub(crate) fn has_image(&self) -> bool {",
          "39:         false",
          "40:     }",
          "42:     pub(crate) fn is_dirty(&self) -> bool {",
          "43:         false",
          "44:     }",
          "46:     pub(crate) fn set_heap_limit(&mut self, _: usize) -> Result<()> {",
          "47:         panic!(\"set_heap_limit on invalid MemFdSlot\");",
          "48:     }",
          "49: }",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs": [
          "File: crates/runtime/src/instance/allocator/pooling.rs -> crates/runtime/src/instance/allocator/pooling.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: use super::{",
          "11:     initialize_instance, initialize_vmcontext, InstanceAllocationRequest, InstanceAllocator,",
          "12:     InstanceHandle, InstantiationError,",
          "13: };",
          "15: use anyhow::{anyhow, bail, Context, Result};",
          "16: use rand::Rng;",
          "17: use std::convert::TryFrom;",
          "19: use std::mem;",
          "21: use wasmtime_environ::{",
          "23:     WASM_PAGE_SIZE,",
          "24: };",
          "",
          "[Removed Lines]",
          "14: use crate::{instance::Instance, Memory, Mmap, Table, VMContext};",
          "18: use std::marker;",
          "20: use std::sync::{Arc, Mutex};",
          "22:     EntitySet, HostPtr, MemoryStyle, Module, PrimaryMap, Tunables, VMOffsets, VMOffsetsFields,",
          "",
          "[Added Lines]",
          "10: use super::MemFdSlot;",
          "15: use crate::{instance::Instance, Memory, Mmap, ModuleMemFds, Table};",
          "17: use libc::c_void;",
          "21: use std::sync::Arc;",
          "22: use std::sync::Mutex;",
          "24:     HostPtr, MemoryIndex, MemoryStyle, Module, PrimaryMap, Tunables, VMOffsets, VMOffsetsFields,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "284:     free_list: Mutex<Vec<usize>>,",
          "285:     memories: MemoryPool,",
          "286:     tables: TablePool,",
          "288: }",
          "290: impl InstancePool {",
          "",
          "[Removed Lines]",
          "287:     empty_module: Arc<Module>,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "332:             free_list: Mutex::new((0..max_instances).collect()),",
          "333:             memories: MemoryPool::new(module_limits, instance_limits, tunables)?,",
          "334:             tables: TablePool::new(module_limits, instance_limits)?,",
          "336:         };",
          "343:         Ok(pool)",
          "344:     }",
          "",
          "[Removed Lines]",
          "335:             empty_module: Arc::new(Module::default()),",
          "339:         for i in 0..instance_limits.count as usize {",
          "340:             pool.initialize(module_limits, i);",
          "341:         }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "348:         &mut *(self.mapping.as_mut_ptr().add(index * self.instance_size) as *mut Instance)",
          "349:     }",
          "375:     unsafe fn setup_instance(",
          "376:         &self,",
          "377:         index: usize,",
          "378:         mut req: InstanceAllocationRequest,",
          "379:     ) -> Result<InstanceHandle, InstantiationError> {",
          "",
          "[Removed Lines]",
          "351:     fn initialize(&self, limits: &ModuleLimits, index: usize) {",
          "352:         unsafe {",
          "353:             let instance = self.instance(index);",
          "356:             std::ptr::write(",
          "357:                 instance as _,",
          "358:                 Instance {",
          "359:                     module: self.empty_module.clone(),",
          "360:                     offsets: VMOffsets::new(HostPtr, &self.empty_module),",
          "361:                     memories: PrimaryMap::with_capacity(limits.memories as usize),",
          "362:                     tables: PrimaryMap::with_capacity(limits.tables as usize),",
          "363:                     dropped_elements: EntitySet::new(),",
          "364:                     dropped_data: EntitySet::new(),",
          "365:                     host_state: Box::new(()),",
          "366:                     wasm_data: &[],",
          "367:                     vmctx: VMContext {",
          "368:                         _marker: marker::PhantomPinned,",
          "369:                     },",
          "370:                 },",
          "371:             );",
          "372:         }",
          "373:     }",
          "380:         let instance = self.instance(index);",
          "382:         instance.module = req.module.clone();",
          "383:         instance.offsets = VMOffsets::new(HostPtr, instance.module.as_ref());",
          "384:         instance.host_state = std::mem::replace(&mut req.host_state, Box::new(()));",
          "385:         instance.wasm_data = &*req.wasm_data;",
          "",
          "[Added Lines]",
          "351:         let host_state = std::mem::replace(&mut req.host_state, Box::new(()));",
          "352:         let instance_data = Instance::create_raw(",
          "353:             &req.module,",
          "354:             &*req.wasm_data,",
          "355:             PrimaryMap::default(),",
          "356:             PrimaryMap::default(),",
          "357:             host_state,",
          "358:         );",
          "364:         let instance = self.instance(index);",
          "365:         std::ptr::write(instance as _, instance_data);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "391:         }",
          "393:         Self::set_instance_memories(",
          "394:             instance,",
          "396:             self.memories.max_wasm_pages,",
          "397:         )?;",
          "",
          "[Removed Lines]",
          "395:             self.memories.get(index),",
          "",
          "[Added Lines]",
          "374:             index,",
          "376:             &self.memories,",
          "377:             &req.memfds,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "448:         let instance = unsafe { &mut *handle.instance };",
          "452:             let mut memory = mem::take(memory);",
          "453:             debug_assert!(memory.is_static());",
          "465:         }",
          "467:         instance.memories.clear();",
          "",
          "[Removed Lines]",
          "451:         for (memory, base) in instance.memories.values_mut().zip(self.memories.get(index)) {",
          "456:             #[cfg(all(feature = \"uffd\", target_os = \"linux\"))]",
          "457:             memory",
          "458:                 .reset_guard_pages()",
          "459:                 .expect(\"failed to reset guard pages\");",
          "460:             drop(&mut memory); // require mutable on all platforms, not just uffd",
          "462:             let size = memory.byte_size();",
          "463:             drop(memory);",
          "464:             decommit_memory_pages(base, size).expect(\"failed to decommit linear memory pages\");",
          "",
          "[Added Lines]",
          "433:         for ((def_mem_idx, memory), base) in",
          "434:             instance.memories.iter_mut().zip(self.memories.get(index))",
          "435:         {",
          "439:             match memory {",
          "440:                 Memory::Static {",
          "441:                     memfd_slot: Some(mut memfd_slot),",
          "442:                     ..",
          "443:                 } => {",
          "444:                     let mem_idx = instance.module.memory_index(def_mem_idx);",
          "449:                     if memfd_slot.clear_and_remain_ready().is_ok() {",
          "450:                         self.memories.return_memfd_slot(index, mem_idx, memfd_slot);",
          "451:                     }",
          "452:                 }",
          "454:                 _ => {",
          "458:                     #[cfg(all(feature = \"uffd\", target_os = \"linux\"))]",
          "459:                     memory",
          "460:                         .reset_guard_pages()",
          "461:                         .expect(\"failed to reset guard pages\");",
          "463:                     drop(&mut memory);",
          "465:                     let size = memory.byte_size();",
          "466:                     drop(memory);",
          "467:                     decommit_memory_pages(base, size)",
          "468:                         .expect(\"failed to decommit linear memory pages\");",
          "469:                 }",
          "470:             }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "481:             decommit_table_pages(base, size).expect(\"failed to decommit table pages\");",
          "482:         }",
          "501:         self.free_list.lock().unwrap().push(index);",
          "502:     }",
          "504:     fn set_instance_memories(",
          "505:         instance: &mut Instance,",
          "507:         max_pages: u64,",
          "508:     ) -> Result<(), InstantiationError> {",
          "509:         let module = instance.module.as_ref();",
          "511:         debug_assert!(instance.memories.is_empty());",
          "515:         {",
          "516:             let memory = unsafe {",
          "517:                 std::slice::from_raw_parts_mut(",
          "519:                     (max_pages as usize) * (WASM_PAGE_SIZE as usize),",
          "520:                 )",
          "521:             };",
          "528:         }",
          "530:         debug_assert!(instance.dropped_data.is_empty());",
          "",
          "[Removed Lines]",
          "484:         instance.tables.clear();",
          "485:         instance.dropped_elements.clear();",
          "489:         instance.drop_globals();",
          "492:         instance.host_state = Box::new(());",
          "497:         instance.module = self.empty_module.clone();",
          "498:         instance.offsets = VMOffsets::new(HostPtr, &self.empty_module);",
          "499:         instance.wasm_data = &[];",
          "506:         mut memories: impl Iterator<Item = *mut u8>,",
          "513:         for plan in",
          "514:             (&module.memory_plans.values().as_slice()[module.num_imported_memories..]).iter()",
          "518:                     memories.next().unwrap(),",
          "522:             instance.memories.push(",
          "523:                 Memory::new_static(plan, memory, commit_memory_pages, unsafe {",
          "524:                     &mut *instance.store()",
          "525:                 })",
          "526:                 .map_err(InstantiationError::Resource)?,",
          "527:             );",
          "",
          "[Added Lines]",
          "493:         unsafe {",
          "494:             std::ptr::drop_in_place(instance as *mut _);",
          "495:         }",
          "504:         instance_idx: usize,",
          "506:         memories: &MemoryPool,",
          "507:         maybe_memfds: &Option<Arc<ModuleMemFds>>,",
          "514:         for (memory_index, plan) in module",
          "515:             .memory_plans",
          "516:             .iter()",
          "517:             .skip(module.num_imported_memories)",
          "519:             let defined_index = module",
          "520:                 .defined_memory_index(memory_index)",
          "521:                 .expect(\"should be a defined memory since we skipped imported ones\");",
          "525:                     memories.get_base(instance_idx, memory_index),",
          "530:             if let Some(memfds) = maybe_memfds {",
          "531:                 let image = memfds.get_memory_image(defined_index);",
          "532:                 let mut slot = memories.take_memfd_slot(instance_idx, memory_index)?;",
          "533:                 let initial_size = plan.memory.minimum * WASM_PAGE_SIZE as u64;",
          "548:                 slot.instantiate(initial_size as usize, image)",
          "549:                     .map_err(|e| InstantiationError::Resource(e.into()))?;",
          "551:                 instance.memories.push(",
          "552:                     Memory::new_static(plan, memory, None, Some(slot), unsafe {",
          "553:                         &mut *instance.store()",
          "554:                     })",
          "555:                     .map_err(InstantiationError::Resource)?,",
          "556:                 );",
          "557:             } else {",
          "558:                 instance.memories.push(",
          "559:                     Memory::new_static(plan, memory, Some(commit_memory_pages), None, unsafe {",
          "560:                         &mut *instance.store()",
          "561:                     })",
          "562:                     .map_err(InstantiationError::Resource)?,",
          "563:                 );",
          "564:             }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "566:     }",
          "567: }",
          "",
          "[Removed Lines]",
          "569: impl Drop for InstancePool {",
          "570:     fn drop(&mut self) {",
          "571:         unsafe {",
          "572:             for i in 0..self.max_instances {",
          "573:                 let ptr = self.mapping.as_mut_ptr().add(i * self.instance_size) as *mut Instance;",
          "574:                 std::ptr::drop_in_place(ptr);",
          "575:             }",
          "576:         }",
          "577:     }",
          "578: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "589: #[derive(Debug)]",
          "590: struct MemoryPool {",
          "591:     mapping: Mmap,",
          "594:     memory_size: usize,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "621:     memfd_slots: Vec<Mutex<Option<MemFdSlot>>>,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "673:         let mapping = Mmap::accessible_reserved(0, allocation_size)",
          "674:             .context(\"failed to create memory pool mapping\")?;",
          "676:         let pool = Self {",
          "677:             mapping,",
          "678:             memory_size,",
          "679:             initial_memory_offset,",
          "680:             max_memories,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "706:         let num_memfd_slots = if cfg!(feature = \"memfd-allocator\") {",
          "707:             max_instances * max_memories",
          "708:         } else {",
          "709:             0",
          "710:         };",
          "711:         let memfd_slots: Vec<_> = std::iter::repeat_with(|| Mutex::new(None))",
          "712:             .take(num_memfd_slots)",
          "713:             .collect();",
          "717:             memfd_slots,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "689:         Ok(pool)",
          "690:     }",
          "693:         debug_assert!(instance_index < self.max_instances);",
          "703:     }",
          "704: }",
          "",
          "[Removed Lines]",
          "692:     fn get(&self, instance_index: usize) -> impl Iterator<Item = *mut u8> {",
          "695:         let base: *mut u8 = unsafe {",
          "696:             self.mapping.as_mut_ptr().add(",
          "697:                 self.initial_memory_offset + instance_index * self.memory_size * self.max_memories,",
          "698:             ) as _",
          "699:         };",
          "701:         let size = self.memory_size;",
          "702:         (0..self.max_memories).map(move |i| unsafe { base.add(i * size) })",
          "",
          "[Added Lines]",
          "732:     fn get_base(&self, instance_index: usize, memory_index: MemoryIndex) -> *mut u8 {",
          "734:         let memory_index = memory_index.as_u32() as usize;",
          "735:         debug_assert!(memory_index < self.max_memories);",
          "736:         let idx = instance_index * self.max_memories + memory_index;",
          "737:         let offset = self.initial_memory_offset + idx * self.memory_size;",
          "738:         unsafe { self.mapping.as_mut_ptr().offset(offset as isize) }",
          "739:     }",
          "741:     fn get<'a>(&'a self, instance_index: usize) -> impl Iterator<Item = *mut u8> + 'a {",
          "742:         (0..self.max_memories)",
          "743:             .map(move |i| self.get_base(instance_index, MemoryIndex::from_u32(i as u32)))",
          "744:     }",
          "748:     fn take_memfd_slot(",
          "749:         &self,",
          "750:         instance_index: usize,",
          "751:         memory_index: MemoryIndex,",
          "752:     ) -> Result<MemFdSlot, InstantiationError> {",
          "753:         let idx = instance_index * self.max_memories + (memory_index.as_u32() as usize);",
          "754:         let maybe_slot = self.memfd_slots[idx].lock().unwrap().take();",
          "756:         maybe_slot.map(|slot| Ok(slot)).unwrap_or_else(|| {",
          "757:             MemFdSlot::create(",
          "758:                 self.get_base(instance_index, memory_index) as *mut c_void,",
          "759:                 self.memory_size,",
          "760:             )",
          "761:         })",
          "762:     }",
          "765:     fn return_memfd_slot(&self, instance_index: usize, memory_index: MemoryIndex, slot: MemFdSlot) {",
          "766:         assert!(!slot.is_dirty());",
          "767:         let idx = instance_index * self.max_memories + (memory_index.as_u32() as usize);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1413:                             host_state: Box::new(()),",
          "1414:                             store: StorePtr::empty(),",
          "1415:                             wasm_data: &[],",
          "1416:                         },",
          "1417:                     )",
          "1418:                     .expect(\"allocation should succeed\"),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1482:                             memfds: None,",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1437:                 host_state: Box::new(()),",
          "1438:                 store: StorePtr::empty(),",
          "1439:                 wasm_data: &[],",
          "1440:             },",
          "1441:         ) {",
          "1442:             Err(InstantiationError::Limit(3)) => {}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1507:                 memfds: None,",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator/pooling/uffd.rs||crates/runtime/src/instance/allocator/pooling/uffd.rs": [
          "File: crates/runtime/src/instance/allocator/pooling/uffd.rs -> crates/runtime/src/instance/allocator/pooling/uffd.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "577:                             PoolingAllocationStrategy::Random,",
          "578:                             InstanceAllocationRequest {",
          "579:                                 module: module.clone(),",
          "580:                                 image_base: 0,",
          "581:                                 functions,",
          "582:                                 imports: Imports {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "580:                                 memfds: None,",
          "",
          "---------------"
        ],
        "crates/runtime/src/lib.rs||crates/runtime/src/lib.rs": [
          "File: crates/runtime/src/lib.rs -> crates/runtime/src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "19:         clippy::use_self",
          "20:     )",
          "21: )]",
          "23: use std::sync::atomic::AtomicU64;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #![cfg_attr(feature = \"memfd-allocator\", allow(dead_code))]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63:     VMSharedSignatureIndex, VMTableDefinition, VMTableImport, VMTrampoline, ValRaw,",
          "64: };",
          "67: pub const VERSION: &str = env!(\"CARGO_PKG_VERSION\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "67: mod module_id;",
          "68: pub use module_id::{CompiledModuleId, CompiledModuleIdAllocator};",
          "70: #[cfg(feature = \"memfd-allocator\")]",
          "71: mod memfd;",
          "76: #[cfg(not(feature = \"memfd-allocator\"))]",
          "77: #[allow(dead_code)]",
          "78: mod memfd {",
          "79:     use anyhow::Result;",
          "80:     use std::sync::Arc;",
          "81:     use wasmtime_environ::{DefinedMemoryIndex, Module};",
          "85:     pub enum ModuleMemFds {}",
          "88:     #[allow(dead_code)]",
          "89:     pub enum MemoryMemFd {}",
          "91:     impl ModuleMemFds {",
          "95:         pub fn new(_: &Module, _: &[u8]) -> Result<Option<Arc<ModuleMemFds>>> {",
          "96:             Ok(None)",
          "97:         }",
          "100:         pub(crate) fn get_memory_image(&self, _: DefinedMemoryIndex) -> Option<&Arc<MemoryMemFd>> {",
          "103:             match *self {}",
          "104:         }",
          "105:     }",
          "106: }",
          "108: pub use crate::memfd::ModuleMemFds;",
          "",
          "---------------"
        ],
        "crates/runtime/src/memfd.rs||crates/runtime/src/memfd.rs": [
          "File: crates/runtime/src/memfd.rs -> crates/runtime/src/memfd.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: use anyhow::Result;",
          "4: use memfd::{Memfd, MemfdOptions};",
          "5: use rustix::fs::FileExt;",
          "6: use std::convert::TryFrom;",
          "7: use std::sync::Arc;",
          "8: use wasmtime_environ::{",
          "9:     DefinedMemoryIndex, MemoryInitialization, MemoryInitializer, MemoryPlan, Module, PrimaryMap,",
          "10: };",
          "16: pub struct ModuleMemFds {",
          "17:     memories: PrimaryMap<DefinedMemoryIndex, Option<Arc<MemoryMemFd>>>,",
          "18: }",
          "20: const MAX_MEMFD_IMAGE_SIZE: u64 = 1024 * 1024 * 1024; // limit to 1GiB.",
          "22: impl ModuleMemFds {",
          "23:     pub(crate) fn get_memory_image(",
          "24:         &self,",
          "25:         defined_index: DefinedMemoryIndex,",
          "26:     ) -> Option<&Arc<MemoryMemFd>> {",
          "27:         self.memories[defined_index].as_ref()",
          "28:     }",
          "29: }",
          "32: #[derive(Debug)]",
          "33: pub(crate) struct MemoryMemFd {",
          "34:     pub(crate) fd: Memfd,",
          "38:     pub(crate) len: usize,",
          "43:     pub(crate) offset: usize,",
          "44: }",
          "46: fn unsupported_initializer(segment: &MemoryInitializer, plan: &MemoryPlan) -> bool {",
          "52:     let end = match segment.end() {",
          "53:         None => {",
          "54:             return true;",
          "55:         }",
          "56:         Some(end) => end,",
          "57:     };",
          "61:     if plan.initializer_possibly_out_of_bounds(segment) {",
          "62:         return true;",
          "63:     }",
          "66:     if end > MAX_MEMFD_IMAGE_SIZE {",
          "67:         return true;",
          "68:     }",
          "70:     false",
          "71: }",
          "73: impl ModuleMemFds {",
          "77:     pub fn new(module: &Module, wasm_data: &[u8]) -> Result<Option<Arc<ModuleMemFds>>> {",
          "78:         let page_size = region::page::size() as u64;",
          "79:         let num_defined_memories = module.memory_plans.len() - module.num_imported_memories;",
          "85:         let mut memfds: PrimaryMap<DefinedMemoryIndex, Option<Memfd>> = PrimaryMap::default();",
          "86:         let mut sizes: PrimaryMap<DefinedMemoryIndex, u64> = PrimaryMap::default();",
          "87:         let mut excluded_memories: PrimaryMap<DefinedMemoryIndex, bool> = PrimaryMap::new();",
          "89:         for _ in 0..num_defined_memories {",
          "90:             memfds.push(None);",
          "91:             sizes.push(0);",
          "92:             excluded_memories.push(false);",
          "93:         }",
          "95:         fn create_memfd() -> Result<Memfd> {",
          "99:             MemfdOptions::new()",
          "100:                 .allow_sealing(true)",
          "101:                 .create(\"wasm-memory-image\")",
          "102:                 .map_err(|e| e.into())",
          "103:         }",
          "104:         let round_up_page = |len: u64| (len + page_size - 1) & !(page_size - 1);",
          "106:         match &module.memory_initialization {",
          "107:             &MemoryInitialization::Segmented(ref segments) => {",
          "108:                 for (i, segment) in segments.iter().enumerate() {",
          "109:                     let defined_memory = match module.defined_memory_index(segment.memory_index) {",
          "110:                         Some(defined_memory) => defined_memory,",
          "111:                         None => continue,",
          "112:                     };",
          "113:                     if excluded_memories[defined_memory] {",
          "114:                         continue;",
          "115:                     }",
          "117:                     if unsupported_initializer(segment, &module.memory_plans[segment.memory_index])",
          "118:                     {",
          "119:                         memfds[defined_memory] = None;",
          "120:                         excluded_memories[defined_memory] = true;",
          "121:                         continue;",
          "122:                     }",
          "124:                     if memfds[defined_memory].is_none() {",
          "125:                         memfds[defined_memory] = Some(create_memfd()?);",
          "126:                     }",
          "127:                     let memfd = memfds[defined_memory].as_mut().unwrap();",
          "129:                     let end = round_up_page(segment.end().expect(\"must have statically-known end\"));",
          "130:                     if end > sizes[defined_memory] {",
          "131:                         sizes[defined_memory] = end;",
          "132:                         memfd.as_file().set_len(end)?;",
          "133:                     }",
          "135:                     let base = segments[i].offset;",
          "136:                     let data = &wasm_data[segment.data.start as usize..segment.data.end as usize];",
          "137:                     memfd.as_file().write_at(data, base)?;",
          "138:                 }",
          "139:             }",
          "140:             &MemoryInitialization::Paged { ref map, .. } => {",
          "141:                 for (defined_memory, pages) in map {",
          "142:                     let top = pages",
          "143:                         .iter()",
          "144:                         .map(|(base, range)| *base + range.len() as u64)",
          "145:                         .max()",
          "146:                         .unwrap_or(0);",
          "148:                     let memfd = create_memfd()?;",
          "149:                     memfd.as_file().set_len(top)?;",
          "151:                     for (base, range) in pages {",
          "152:                         let data = &wasm_data[range.start as usize..range.end as usize];",
          "153:                         memfd.as_file().write_at(data, *base)?;",
          "154:                     }",
          "156:                     memfds[defined_memory] = Some(memfd);",
          "157:                     sizes[defined_memory] = top;",
          "158:                 }",
          "159:             }",
          "160:         }",
          "163:         let mut memories: PrimaryMap<DefinedMemoryIndex, Option<Arc<MemoryMemFd>>> =",
          "164:             PrimaryMap::default();",
          "165:         for (defined_memory, maybe_memfd) in memfds {",
          "166:             let memfd = match maybe_memfd {",
          "167:                 Some(memfd) => memfd,",
          "168:                 None => {",
          "169:                     memories.push(None);",
          "170:                     continue;",
          "171:                 }",
          "172:             };",
          "173:             let size = sizes[defined_memory];",
          "179:             let mut page_data = vec![0; page_size as usize];",
          "180:             let mut page_is_nonzero = |page| {",
          "181:                 let offset = page_size * page;",
          "182:                 memfd.as_file().read_at(&mut page_data[..], offset).unwrap();",
          "183:                 page_data.iter().any(|byte| *byte != 0)",
          "184:             };",
          "185:             let n_pages = size / page_size;",
          "187:             let mut offset = 0;",
          "188:             for page in 0..n_pages {",
          "189:                 if page_is_nonzero(page) {",
          "190:                     break;",
          "191:                 }",
          "192:                 offset += page_size;",
          "193:             }",
          "194:             let len = if offset == size {",
          "195:                 0",
          "196:             } else {",
          "197:                 let mut len = 0;",
          "198:                 for page in (0..n_pages).rev() {",
          "199:                     if page_is_nonzero(page) {",
          "200:                         len = (page + 1) * page_size - offset;",
          "201:                         break;",
          "202:                     }",
          "203:                 }",
          "204:                 len",
          "205:             };",
          "222:             memfd.add_seal(memfd::FileSeal::SealGrow)?;",
          "223:             memfd.add_seal(memfd::FileSeal::SealShrink)?;",
          "224:             memfd.add_seal(memfd::FileSeal::SealWrite)?;",
          "225:             memfd.add_seal(memfd::FileSeal::SealSeal)?;",
          "227:             memories.push(Some(Arc::new(MemoryMemFd {",
          "228:                 fd: memfd,",
          "229:                 offset: usize::try_from(offset).unwrap(),",
          "230:                 len: usize::try_from(len).unwrap(),",
          "231:             })));",
          "232:         }",
          "234:         Ok(Some(Arc::new(ModuleMemFds { memories })))",
          "235:     }",
          "236: }",
          "",
          "---------------"
        ],
        "crates/runtime/src/memory.rs||crates/runtime/src/memory.rs": [
          "File: crates/runtime/src/memory.rs -> crates/runtime/src/memory.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: use crate::mmap::Mmap;",
          "6: use crate::vmcontext::VMMemoryDefinition;",
          "7: use crate::Store;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5: use crate::instance::MemFdSlot;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "211:         make_accessible: fn(*mut u8, usize) -> Result<()>,",
          "",
          "[Added Lines]",
          "212:         make_accessible: Option<fn(*mut u8, usize) -> Result<()>>,",
          "216:         memfd_slot: Option<MemFdSlot>,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "236:     pub fn new_static(",
          "237:         plan: &MemoryPlan,",
          "238:         base: &'static mut [u8],",
          "240:         store: &mut dyn Store,",
          "241:     ) -> Result<Self> {",
          "242:         let (minimum, maximum) = Self::limit_new(plan, store)?;",
          "",
          "[Removed Lines]",
          "239:         make_accessible: fn(*mut u8, usize) -> Result<()>,",
          "",
          "[Added Lines]",
          "244:         make_accessible: Option<fn(*mut u8, usize) -> Result<()>>,",
          "245:         memfd_slot: Option<MemFdSlot>,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "246:             _ => base,",
          "247:         };",
          "251:         }",
          "253:         Ok(Memory::Static {",
          "254:             base,",
          "255:             size: minimum,",
          "256:             make_accessible,",
          "257:             #[cfg(all(feature = \"uffd\", target_os = \"linux\"))]",
          "258:             guard_page_faults: Vec::new(),",
          "259:         })",
          "",
          "[Removed Lines]",
          "249:         if minimum > 0 {",
          "250:             make_accessible(base.as_mut_ptr(), minimum)?;",
          "",
          "[Added Lines]",
          "255:         if let Some(make_accessible) = make_accessible {",
          "256:             if minimum > 0 {",
          "257:                 make_accessible(base.as_mut_ptr(), minimum)?;",
          "258:             }",
          "265:             memfd_slot,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "373:         }",
          "374:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "391:     pub(crate) fn is_memfd_with_image(&self) -> bool {",
          "392:         match self {",
          "393:             Memory::Static {",
          "394:                 memfd_slot: Some(ref slot),",
          "395:                 ..",
          "396:             } => slot.has_image(),",
          "397:             _ => false,",
          "398:         }",
          "399:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "443:         }",
          "445:         match self {",
          "446:             Memory::Static {",
          "447:                 base,",
          "448:                 size,",
          "449:                 make_accessible,",
          "450:                 ..",
          "451:             } => {",
          "453:                 if new_byte_size > base.len() {",
          "454:                     store.memory_grow_failed(&format_err!(\"static memory size exceeded\"));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "471:             Memory::Static {",
          "472:                 base,",
          "473:                 size,",
          "474:                 memfd_slot: Some(ref mut memfd_slot),",
          "475:                 ..",
          "476:             } => {",
          "478:                 if new_byte_size > base.len() {",
          "479:                     store.memory_grow_failed(&format_err!(\"static memory size exceeded\"));",
          "480:                     return Ok(None);",
          "481:                 }",
          "483:                 if let Err(e) = memfd_slot.set_heap_limit(new_byte_size) {",
          "484:                     store.memory_grow_failed(&e);",
          "485:                     return Ok(None);",
          "486:                 }",
          "488:             }",
          "495:                 let make_accessible = make_accessible",
          "496:                     .expect(\"make_accessible must be Some if this is not a MemFD memory\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "540:         Memory::Static {",
          "541:             base: &mut [],",
          "542:             size: 0,",
          "544:             #[cfg(all(feature = \"uffd\", target_os = \"linux\"))]",
          "545:             guard_page_faults: Vec::new(),",
          "546:         }",
          "",
          "[Removed Lines]",
          "543:             make_accessible: |_, _| unreachable!(),",
          "",
          "[Added Lines]",
          "589:             make_accessible: Some(|_, _| unreachable!()),",
          "590:             memfd_slot: None,",
          "",
          "---------------"
        ],
        "crates/runtime/src/module_id.rs||crates/runtime/src/module_id.rs": [
          "File: crates/runtime/src/module_id.rs -> crates/runtime/src/module_id.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: use std::sync::atomic::{AtomicU64, Ordering};",
          "7: #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]",
          "8: pub struct CompiledModuleId(u64);",
          "11: pub struct CompiledModuleIdAllocator {",
          "12:     next: AtomicU64,",
          "13: }",
          "15: impl CompiledModuleIdAllocator {",
          "17:     pub fn new() -> Self {",
          "18:         Self {",
          "19:             next: AtomicU64::new(1),",
          "20:         }",
          "21:     }",
          "24:     pub fn alloc(&self) -> CompiledModuleId {",
          "25:         let id = self.next.fetch_add(1, Ordering::Relaxed);",
          "26:         CompiledModuleId(id)",
          "27:     }",
          "28: }",
          "",
          "---------------"
        ],
        "crates/runtime/src/traphandlers/unix.rs||crates/runtime/src/traphandlers/unix.rs": [
          "File: crates/runtime/src/traphandlers/unix.rs -> crates/runtime/src/traphandlers/unix.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "51:         register(&mut PREV_SIGFPE, libc::SIGFPE);",
          "52:     }",
          "57:         register(&mut PREV_SIGBUS, libc::SIGBUS);",
          "58:     }",
          "59: }",
          "",
          "[Removed Lines]",
          "56:     if cfg!(target_arch = \"arm\") || cfg!(target_os = \"macos\") || cfg!(target_os = \"freebsd\") {",
          "",
          "[Added Lines]",
          "60:     if cfg!(target_arch = \"arm\")",
          "61:         || cfg!(target_os = \"macos\")",
          "62:         || cfg!(target_os = \"freebsd\")",
          "63:         || cfg!(feature = \"memfd-allocator\")",
          "64:     {",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/engine.rs||crates/wasmtime/src/engine.rs": [
          "File: crates/wasmtime/src/engine.rs -> crates/wasmtime/src/engine.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: use std::sync::Arc;",
          "8: #[cfg(feature = \"cache\")]",
          "9: use wasmtime_cache::CacheConfig;",
          "",
          "[Removed Lines]",
          "10: use wasmtime_runtime::{debug_builtins, InstanceAllocator};",
          "",
          "[Added Lines]",
          "10: use wasmtime_runtime::{debug_builtins, CompiledModuleIdAllocator, InstanceAllocator};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43:     allocator: Box<dyn InstanceAllocator>,",
          "44:     signatures: SignatureRegistry,",
          "45:     epoch: AtomicU64,",
          "46: }",
          "48: impl Engine {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:     unique_id_allocator: CompiledModuleIdAllocator,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "68:                 allocator,",
          "69:                 signatures: registry,",
          "70:                 epoch: AtomicU64::new(0),",
          "71:             }),",
          "72:         })",
          "73:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "72:                 unique_id_allocator: CompiledModuleIdAllocator::new(),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "153:         self.inner.epoch.fetch_add(1, Ordering::Relaxed);",
          "154:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "158:     pub(crate) fn unique_id_allocator(&self) -> &CompiledModuleIdAllocator {",
          "159:         &self.inner.unique_id_allocator",
          "160:     }",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/instance.rs||crates/wasmtime/src/instance.rs": [
          "File: crates/wasmtime/src/instance.rs -> crates/wasmtime/src/instance.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "651:                     artifacts,",
          "652:                     modules,",
          "653:                     &self.cur.modules,",
          "655:                 self.cur.modules.push(submodule);",
          "656:             }",
          "",
          "[Removed Lines]",
          "654:                 );",
          "",
          "[Added Lines]",
          "654:                 )?;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "707:                     .allocator()",
          "708:                     .allocate(InstanceAllocationRequest {",
          "709:                         module: compiled_module.module().clone(),",
          "710:                         image_base: compiled_module.code().as_ptr() as usize,",
          "711:                         functions: compiled_module.functions(),",
          "712:                         imports: self.cur.build(),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "710:                         memfds: self.cur.module.memfds().clone(),",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/module.rs||crates/wasmtime/src/module.rs": [
          "File: crates/wasmtime/src/module.rs -> crates/wasmtime/src/module.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: use wasmparser::{Parser, ValidPayload, Validator};",
          "12: use wasmtime_environ::{ModuleEnvironment, ModuleIndex, PrimaryMap};",
          "13: use wasmtime_jit::{CompiledModule, CompiledModuleInfo, MmapVec, TypeTables};",
          "15: mod registry;",
          "16: mod serialization;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: use wasmtime_runtime::ModuleMemFds;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "107:     types: Arc<TypeTables>,",
          "109:     signatures: Arc<SignatureCollection>,",
          "110: }",
          "112: impl Module {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "112:     memfds: Option<Arc<ModuleMemFds>>,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "336:         };",
          "338:         let modules = engine.run_maybe_parallel(artifacts, |(a, b)| {",
          "340:         })?;",
          "342:         Self::from_parts(engine, modules, main_module, Arc::new(types), &[])",
          "",
          "[Removed Lines]",
          "339:             CompiledModule::from_artifacts(a, b, &*engine.config().profiler)",
          "",
          "[Added Lines]",
          "342:             CompiledModule::from_artifacts(",
          "343:                 a,",
          "344:                 b,",
          "345:                 &*engine.config().profiler,",
          "346:                 engine.unique_id_allocator(),",
          "347:             )",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "523:             })",
          "524:             .collect::<Result<Vec<_>>>()?;",
          "526:         return Ok(Self {",
          "527:             inner: Arc::new(ModuleInner {",
          "528:                 engine: engine.clone(),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "534:         let memfds = ModuleMemFds::new(module.module(), module.wasm_data())?;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "531:                 artifact_upvars: modules,",
          "532:                 module_upvars,",
          "533:                 signatures,",
          "534:             }),",
          "535:         });",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "544:                 memfds,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "543:             module_upvars: &[serialization::SerializedModuleUpvar],",
          "544:             signatures: &Arc<SignatureCollection>,",
          "545:         ) -> Result<Module> {",
          "546:             Ok(Module {",
          "547:                 inner: Arc::new(ModuleInner {",
          "548:                     engine: engine.clone(),",
          "549:                     types: types.clone(),",
          "551:                     artifact_upvars: artifact_upvars",
          "552:                         .iter()",
          "553:                         .map(|i| artifacts[*i].clone())",
          "",
          "[Removed Lines]",
          "550:                     module: artifacts[module_index].clone(),",
          "",
          "[Added Lines]",
          "557:             let module = artifacts[module_index].clone();",
          "558:             let memfds = ModuleMemFds::new(module.module(), module.wasm_data())?;",
          "563:                     module,",
          "564:                     memfds,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "666:         artifact_upvars: &[usize],",
          "667:         module_upvars: &[wasmtime_environ::ModuleUpvar],",
          "668:         modules: &PrimaryMap<ModuleIndex, Module>,",
          "671:             inner: Arc::new(ModuleInner {",
          "672:                 types: self.inner.types.clone(),",
          "673:                 engine: self.inner.engine.clone(),",
          "675:                 artifact_upvars: artifact_upvars",
          "676:                     .iter()",
          "677:                     .map(|i| self.inner.artifact_upvars[*i].clone())",
          "",
          "[Removed Lines]",
          "669:     ) -> Module {",
          "670:         Module {",
          "674:                 module: self.inner.artifact_upvars[artifact_index].clone(),",
          "",
          "[Added Lines]",
          "683:     ) -> Result<Module> {",
          "684:         let module = self.inner.artifact_upvars[artifact_index].clone();",
          "685:         let memfds = ModuleMemFds::new(module.module(), module.wasm_data())?;",
          "686:         Ok(Module {",
          "690:                 module,",
          "691:                 memfds,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "687:                     .collect(),",
          "688:                 signatures: self.inner.signatures.clone(),",
          "689:             }),",
          "691:     }",
          "693:     pub(crate) fn compiled_module(&self) -> &Arc<CompiledModule> {",
          "",
          "[Removed Lines]",
          "690:         }",
          "",
          "[Added Lines]",
          "707:         })",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "706:         &self.inner.signatures",
          "707:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "726:     pub(crate) fn memfds(&self) -> &Option<Arc<ModuleMemFds>> {",
          "727:         &self.inner.memfds",
          "728:     }",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/module/serialization.rs||crates/wasmtime/src/module/serialization.rs": [
          "File: crates/wasmtime/src/module/serialization.rs -> crates/wasmtime/src/module/serialization.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "274:     pub fn into_module(self, engine: &Engine) -> Result<Module> {",
          "275:         let (main_module, modules, types, upvars) = self.into_parts(engine)?;",
          "276:         let modules = engine.run_maybe_parallel(modules, |(i, m)| {",
          "278:         })?;",
          "280:         Module::from_parts(engine, modules, main_module, Arc::new(types), &upvars)",
          "",
          "[Removed Lines]",
          "277:             CompiledModule::from_artifacts(i, m, &*engine.config().profiler)",
          "",
          "[Added Lines]",
          "277:             CompiledModule::from_artifacts(",
          "278:                 i,",
          "279:                 m,",
          "280:                 &*engine.config().profiler,",
          "281:                 engine.unique_id_allocator(),",
          "282:             )",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/store.rs||crates/wasmtime/src/store.rs": [
          "File: crates/wasmtime/src/store.rs -> crates/wasmtime/src/store.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "421:                     shared_signatures: None.into(),",
          "422:                     imports: Default::default(),",
          "423:                     module: Arc::new(wasmtime_environ::Module::default()),",
          "424:                     store: StorePtr::empty(),",
          "425:                     wasm_data: &[],",
          "426:                 })",
          "427:                 .expect(\"failed to allocate default callee\")",
          "428:         };",
          "429:         let mut inner = Box::new(StoreInner {",
          "430:             inner: StoreOpaque {",
          "431:                 _marker: marker::PhantomPinned,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "424:                     memfds: None,",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/trampoline.rs||crates/wasmtime/src/trampoline.rs": [
          "File: crates/wasmtime/src/trampoline.rs -> crates/wasmtime/src/trampoline.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "41:         let handle = OnDemandInstanceAllocator::new(config.mem_creator.clone(), 0).allocate(",
          "42:             InstanceAllocationRequest {",
          "43:                 module: Arc::new(module),",
          "44:                 functions,",
          "45:                 image_base: 0,",
          "46:                 imports,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "44:                 memfds: None,",
          "",
          "---------------"
        ],
        "crates/wasmtime/src/trampoline/func.rs||crates/wasmtime/src/trampoline/func.rs": [
          "File: crates/wasmtime/src/trampoline/func.rs -> crates/wasmtime/src/trampoline/func.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "161:     Ok(",
          "162:         OnDemandInstanceAllocator::default().allocate(InstanceAllocationRequest {",
          "163:             module: Arc::new(module),",
          "164:             functions: &functions,",
          "165:             image_base: (*func).as_ptr() as usize,",
          "166:             imports: Imports::default(),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "164:             memfds: None,",
          "",
          "---------------"
        ],
        "src/lib.rs||src/lib.rs": [
          "File: src/lib.rs -> src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "100: use std::path::PathBuf;",
          "101: use structopt::StructOpt;",
          "102: use wasmtime::{Config, ProfilingStrategy};",
          "104: fn pick_profiling_strategy(jitdump: bool, vtune: bool) -> Result<ProfilingStrategy> {",
          "105:     Ok(match (jitdump, vtune) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "103: #[cfg(feature = \"pooling-allocator\")]",
          "104: use wasmtime::{InstanceLimits, ModuleLimits, PoolingAllocationStrategy};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "251:     #[structopt(long)]",
          "252:     paged_memory_initialization: bool,",
          "253: }",
          "255: impl CommonOptions {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "258:     #[cfg(feature = \"pooling-allocator\")]",
          "259:     #[structopt(long)]",
          "260:     pooling_allocator: bool,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "325:         config.generate_address_map(!self.disable_address_map);",
          "326:         config.paged_memory_initialization(self.paged_memory_initialization);",
          "328:         Ok(config)",
          "329:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "336:         #[cfg(feature = \"pooling-allocator\")]",
          "337:         {",
          "338:             if self.pooling_allocator {",
          "339:                 let mut module_limits = ModuleLimits::default();",
          "340:                 module_limits.functions = 50000;",
          "341:                 module_limits.types = 10000;",
          "342:                 module_limits.globals = 1000;",
          "343:                 module_limits.memory_pages = 2048;",
          "344:                 let instance_limits = InstanceLimits::default();",
          "345:                 config.allocation_strategy(wasmtime::InstanceAllocationStrategy::Pooling {",
          "346:                     strategy: PoolingAllocationStrategy::NextAvailable,",
          "347:                     module_limits,",
          "348:                     instance_limits,",
          "349:                 });",
          "350:             }",
          "351:         }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "15991947f485a60298e45d1d915125c0f3cc5a8a",
      "candidate_info": {
        "commit_hash": "15991947f485a60298e45d1d915125c0f3cc5a8a",
        "repo": "bytecodealliance/wasmtime",
        "commit_url": "https://github.com/bytecodealliance/wasmtime/commit/15991947f485a60298e45d1d915125c0f3cc5a8a",
        "files": [
          ".github/actions/binary-compatible-builds/action.yml",
          ".github/actions/github-release/action.yml",
          ".github/actions/github-release/main.js",
          ".github/actions/github-release/package-lock.json",
          ".github/actions/github-release/package.json",
          ".github/actions/install-rust/action.yml",
          ".github/workflows/cargo-audit.yml",
          ".github/workflows/main.yml",
          ".github/workflows/publish-to-cratesio.yml",
          ".github/workflows/push-tag.yml",
          ".github/workflows/release-process.yml",
          "Cargo.lock",
          "Cargo.toml",
          "cranelift/Cargo.toml",
          "cranelift/bforest/Cargo.toml",
          "cranelift/codegen/Cargo.toml",
          "cranelift/codegen/meta/Cargo.toml",
          "cranelift/codegen/shared/Cargo.toml",
          "cranelift/codegen/src/isa/x64/inst/mod.rs",
          "cranelift/entity/Cargo.toml",
          "cranelift/filetests/Cargo.toml",
          "cranelift/frontend/Cargo.toml",
          "cranelift/fuzzgen/Cargo.toml",
          "cranelift/interpreter/Cargo.toml",
          "cranelift/isle/isle/Cargo.toml",
          "cranelift/jit/Cargo.toml",
          "cranelift/module/Cargo.toml",
          "cranelift/native/Cargo.toml",
          "cranelift/object/Cargo.toml",
          "cranelift/preopt/Cargo.toml",
          "cranelift/reader/Cargo.toml",
          "cranelift/serde/Cargo.toml",
          "cranelift/umbrella/Cargo.toml",
          "cranelift/wasm/Cargo.toml",
          "crates/asm-macros/Cargo.toml",
          "crates/c-api/src/trap.rs",
          "crates/cache/Cargo.toml",
          "crates/cli-flags/Cargo.toml",
          "crates/component-macro/Cargo.toml",
          "crates/component-util/Cargo.toml",
          "crates/cranelift/Cargo.toml",
          "crates/environ/Cargo.toml",
          "crates/fiber/Cargo.toml",
          "crates/jit-debug/Cargo.toml",
          "crates/jit/Cargo.toml",
          "crates/runtime/Cargo.toml",
          "crates/runtime/src/cow.rs",
          "crates/runtime/src/instance/allocator/pooling.rs",
          "crates/test-programs/Cargo.toml",
          "crates/types/Cargo.toml",
          "crates/wasi-common/Cargo.toml",
          "crates/wasi-common/cap-std-sync/Cargo.toml",
          "crates/wasi-common/tokio/Cargo.toml",
          "crates/wasi-crypto/Cargo.toml",
          "crates/wasi-nn/Cargo.toml",
          "crates/wasi/Cargo.toml",
          "crates/wasmtime/Cargo.toml",
          "crates/wast/Cargo.toml",
          "crates/wiggle/Cargo.toml",
          "crates/wiggle/generate/Cargo.toml",
          "crates/wiggle/macro/Cargo.toml",
          "tests/all/pooling_allocator.rs"
        ],
        "message": "Prepare a Wasmtime 1.0.2 release (#5246)\n\n* Merge pull request from GHSA-wh6w-3828-g9qf\n\nThis is a minimal fix for the release branch to fix the issue of having\na memory slot get reused between a module with an image and one without.\n\n* Merge pull request from GHSA-44mr-8vmm-wjhg\n\nThis ensures that memories, even with zero contents, still have the\nnecessary virtual mappings as required by the code generator to report\nout-of-bounds reads/writes.\n\n* Merge pull request from GHSA-h84q-m8rr-3v9q\n\nThe Rust definition was previously performing a 4-byte write when the C\nAPI was declared as taking an 1-byte buffer.\n\n* CI fixes from CVE patches\n\n* Bump to 1.0.2\n\n* Cherry-pick github actions fixes for 1.0.2 release\n\nCulmination of patches already landed in `main` and `release-2.0.0`\n\n* Release Wasmtime 1.0.2\n\n[automatically-tag-and-release-this-commit]\n\n* Fix inst size test for Rust 1.65.0\n\n* Use an alternate doxygen download link (#5150)\n\n* Use an alternate doxygen download link\n\nLooks like doxygen.nl is down otherwise.\n\n* Update link",
        "before_after_code_files": [
          ".github/actions/github-release/main.js||.githuactions/github-release/main.js",
          "Cargo.lock||Cargo.lock",
          "cranelift/codegen/src/isx64/inst/mod.rs||cranelift/codegen/src/isa/x64/inst/mod.rs",
          "crates/c-api/src/trap.rs||crates/c-api/src/trap.rs",
          "crates/runtime/src/cow.rs||crates/runtime/src/cow.rs",
          "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
          "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
            "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
          ],
          "candidate": [
            "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs",
            "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs"
          ]
        }
      },
      "candidate_diff": {
        ".github/actions/github-release/main.js||.githuactions/github-release/main.js": [
          "File: .github/actions/github-release/main.js -> .githuactions/github-release/main.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:   core.info(`name: ${name}`);",
          "26:   core.info(`token: ${token}`);",
          "",
          "[Removed Lines]",
          "28:   const octokit = new github.GitHub(token);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:     if (tag === null || tag.data.object.sha !== sha) {",
          "45:       core.info(`updating existing tag or creating new one`);",
          "57:       try {",
          "58:         core.info(`updating dev tag`);",
          "60:             owner,",
          "61:             repo,",
          "62:             ref: 'tags/dev',",
          "",
          "[Removed Lines]",
          "47:       try {",
          "48:         core.info(`fetching release for ${name}`);",
          "49:         const release = await octokit.repos.getReleaseByTag({ owner, repo, tag: name });",
          "50:         core.info(`deleting release ${release.data.id}`);",
          "51:         await octokit.repos.deleteRelease({ owner, repo, release_id: release.data.id });",
          "52:       } catch (e) {",
          "54:         console.log(\"ERROR: \", JSON.stringify(e, null, 2));",
          "55:       }",
          "59:         await octokit.git.updateRef({",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "81:         }",
          "82:       }",
          "83:     } else {",
          "84:       core.info(`existing tag works`);",
          "85:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "91:   let release = null;",
          "92:   try {",
          "93:     core.info(`fetching release`);",
          "95:   } catch (e) {",
          "96:     console.log(\"ERROR: \", JSON.stringify(e, null, 2));",
          "97:     core.info(`creating a release`);",
          "98:     try {",
          "100:         owner,",
          "101:         repo,",
          "102:         tag_name: name,",
          "",
          "[Removed Lines]",
          "94:     release = await octokit.repos.getReleaseByTag({ owner, repo, tag: name });",
          "99:       release = await octokit.repos.createRelease({",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "105:     } catch(e) {",
          "106:       console.log(\"ERROR: \", JSON.stringify(e, null, 2));",
          "107:       core.info(`fetching one more time`);",
          "109:     }",
          "110:   }",
          "111:   console.log(\"found release: \", JSON.stringify(release.data, null, 2));",
          "",
          "[Removed Lines]",
          "108:       release = await octokit.repos.getReleaseByTag({ owner, repo, tag: name });",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "114:   for (const file of glob.sync(files)) {",
          "115:     const size = fs.statSync(file).size;",
          "116:     core.info(`upload ${file}`);",
          "118:       data: fs.createReadStream(file),",
          "119:       headers: { 'content-length': size, 'content-type': 'application/octet-stream' },",
          "121:       url: release.data.upload_url,",
          "122:     });",
          "123:   }",
          "",
          "[Removed Lines]",
          "117:     await octokit.repos.uploadReleaseAsset({",
          "120:       name: path.basename(file),",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "Cargo.lock||Cargo.lock": [
          "File: Cargo.lock -> Cargo.lock",
          "--- Hunk 1 ---",
          "[Context before]",
          "510: [[package]]",
          "511: name = \"cranelift\"",
          "513: dependencies = [",
          "514:  \"cranelift-codegen\",",
          "515:  \"cranelift-frontend\",",
          "",
          "[Removed Lines]",
          "512: version = \"0.88.1\"",
          "",
          "[Added Lines]",
          "512: version = \"0.88.2\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "518: [[package]]",
          "519: name = \"cranelift-bforest\"",
          "521: dependencies = [",
          "522:  \"cranelift-entity\",",
          "523: ]",
          "525: [[package]]",
          "526: name = \"cranelift-codegen\"",
          "528: dependencies = [",
          "529:  \"arrayvec\",",
          "530:  \"bincode\",",
          "",
          "[Removed Lines]",
          "520: version = \"0.88.1\"",
          "527: version = \"0.88.1\"",
          "",
          "[Added Lines]",
          "520: version = \"0.88.2\"",
          "527: version = \"0.88.2\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "550: [[package]]",
          "551: name = \"cranelift-codegen-meta\"",
          "553: dependencies = [",
          "554:  \"cranelift-codegen-shared\",",
          "555: ]",
          "557: [[package]]",
          "558: name = \"cranelift-codegen-shared\"",
          "561: [[package]]",
          "562: name = \"cranelift-entity\"",
          "564: dependencies = [",
          "565:  \"serde\",",
          "566: ]",
          "",
          "[Removed Lines]",
          "552: version = \"0.88.1\"",
          "559: version = \"0.88.1\"",
          "563: version = \"0.88.1\"",
          "",
          "[Added Lines]",
          "552: version = \"0.88.2\"",
          "559: version = \"0.88.2\"",
          "563: version = \"0.88.2\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "591: [[package]]",
          "592: name = \"cranelift-frontend\"",
          "594: dependencies = [",
          "595:  \"cranelift-codegen\",",
          "596:  \"hashbrown\",",
          "",
          "[Removed Lines]",
          "593: version = \"0.88.1\"",
          "",
          "[Added Lines]",
          "593: version = \"0.88.2\"",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "612: [[package]]",
          "613: name = \"cranelift-interpreter\"",
          "615: dependencies = [",
          "616:  \"cranelift-codegen\",",
          "617:  \"cranelift-entity\",",
          "",
          "[Removed Lines]",
          "614: version = \"0.88.1\"",
          "",
          "[Added Lines]",
          "614: version = \"0.88.2\"",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "626: [[package]]",
          "627: name = \"cranelift-isle\"",
          "629: dependencies = [",
          "630:  \"log\",",
          "631:  \"miette\",",
          "",
          "[Removed Lines]",
          "628: version = \"0.88.1\"",
          "",
          "[Added Lines]",
          "628: version = \"0.88.2\"",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "635: [[package]]",
          "636: name = \"cranelift-jit\"",
          "638: dependencies = [",
          "639:  \"anyhow\",",
          "640:  \"cranelift\",",
          "",
          "[Removed Lines]",
          "637: version = \"0.88.1\"",
          "",
          "[Added Lines]",
          "637: version = \"0.88.2\"",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "654: [[package]]",
          "655: name = \"cranelift-module\"",
          "657: dependencies = [",
          "658:  \"anyhow\",",
          "659:  \"cranelift-codegen\",",
          "",
          "[Removed Lines]",
          "656: version = \"0.88.1\"",
          "",
          "[Added Lines]",
          "656: version = \"0.88.2\"",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "663: [[package]]",
          "664: name = \"cranelift-native\"",
          "666: dependencies = [",
          "667:  \"cranelift-codegen\",",
          "668:  \"libc\",",
          "",
          "[Removed Lines]",
          "665: version = \"0.88.1\"",
          "",
          "[Added Lines]",
          "665: version = \"0.88.2\"",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "672: [[package]]",
          "673: name = \"cranelift-object\"",
          "675: dependencies = [",
          "676:  \"anyhow\",",
          "677:  \"cranelift-codegen\",",
          "",
          "[Removed Lines]",
          "674: version = \"0.88.1\"",
          "",
          "[Added Lines]",
          "674: version = \"0.88.2\"",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "686: [[package]]",
          "687: name = \"cranelift-preopt\"",
          "689: dependencies = [",
          "690:  \"cranelift-codegen\",",
          "691: ]",
          "693: [[package]]",
          "694: name = \"cranelift-reader\"",
          "696: dependencies = [",
          "697:  \"cranelift-codegen\",",
          "698:  \"smallvec\",",
          "",
          "[Removed Lines]",
          "688: version = \"0.88.1\"",
          "695: version = \"0.88.1\"",
          "",
          "[Added Lines]",
          "688: version = \"0.88.2\"",
          "695: version = \"0.88.2\"",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "702: [[package]]",
          "703: name = \"cranelift-serde\"",
          "705: dependencies = [",
          "706:  \"clap 3.2.8\",",
          "707:  \"cranelift-codegen\",",
          "",
          "[Removed Lines]",
          "704: version = \"0.88.1\"",
          "",
          "[Added Lines]",
          "704: version = \"0.88.2\"",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "745: [[package]]",
          "746: name = \"cranelift-wasm\"",
          "748: dependencies = [",
          "749:  \"cranelift-codegen\",",
          "750:  \"cranelift-entity\",",
          "",
          "[Removed Lines]",
          "747: version = \"0.88.1\"",
          "",
          "[Added Lines]",
          "747: version = \"0.88.2\"",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3099: [[package]]",
          "3100: name = \"wasi-cap-std-sync\"",
          "3102: dependencies = [",
          "3103:  \"anyhow\",",
          "3104:  \"async-trait\",",
          "",
          "[Removed Lines]",
          "3101: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3101: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3122: [[package]]",
          "3123: name = \"wasi-common\"",
          "3125: dependencies = [",
          "3126:  \"anyhow\",",
          "3127:  \"bitflags\",",
          "",
          "[Removed Lines]",
          "3124: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3124: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "3167: [[package]]",
          "3168: name = \"wasi-tokio\"",
          "3170: dependencies = [",
          "3171:  \"anyhow\",",
          "3172:  \"cap-std\",",
          "",
          "[Removed Lines]",
          "3169: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3169: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "3327: [[package]]",
          "3328: name = \"wasmtime\"",
          "3330: dependencies = [",
          "3331:  \"anyhow\",",
          "3332:  \"async-trait\",",
          "",
          "[Removed Lines]",
          "3329: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3329: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "3362: [[package]]",
          "3363: name = \"wasmtime-asm-macros\"",
          "3365: dependencies = [",
          "3366:  \"cfg-if\",",
          "3367: ]",
          "",
          "[Removed Lines]",
          "3364: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3364: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "3409: [[package]]",
          "3410: name = \"wasmtime-cache\"",
          "3412: dependencies = [",
          "3413:  \"anyhow\",",
          "3414:  \"base64\",",
          "",
          "[Removed Lines]",
          "3411: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3411: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "3431: [[package]]",
          "3432: name = \"wasmtime-cli\"",
          "3434: dependencies = [",
          "3435:  \"anyhow\",",
          "3436:  \"async-trait\",",
          "",
          "[Removed Lines]",
          "3433: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3433: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "3472: [[package]]",
          "3473: name = \"wasmtime-cli-flags\"",
          "3475: dependencies = [",
          "3476:  \"anyhow\",",
          "3477:  \"clap 3.2.8\",",
          "",
          "[Removed Lines]",
          "3474: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3474: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3484: [[package]]",
          "3485: name = \"wasmtime-component-macro\"",
          "3487: dependencies = [",
          "3488:  \"proc-macro2\",",
          "3489:  \"quote\",",
          "",
          "[Removed Lines]",
          "3486: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3486: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3494: [[package]]",
          "3495: name = \"wasmtime-component-util\"",
          "3498: [[package]]",
          "3499: name = \"wasmtime-cranelift\"",
          "3501: dependencies = [",
          "3502:  \"anyhow\",",
          "3503:  \"cranelift-codegen\",",
          "",
          "[Removed Lines]",
          "3496: version = \"1.0.1\"",
          "3500: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3496: version = \"1.0.2\"",
          "3500: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3517: [[package]]",
          "3518: name = \"wasmtime-environ\"",
          "3520: dependencies = [",
          "3521:  \"anyhow\",",
          "3522:  \"atty\",",
          "",
          "[Removed Lines]",
          "3519: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3519: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3555: [[package]]",
          "3556: name = \"wasmtime-fiber\"",
          "3558: dependencies = [",
          "3559:  \"backtrace\",",
          "3560:  \"cc\",",
          "",
          "[Removed Lines]",
          "3557: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3557: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "3618: [[package]]",
          "3619: name = \"wasmtime-jit\"",
          "3621: dependencies = [",
          "3622:  \"addr2line\",",
          "3623:  \"anyhow\",",
          "",
          "[Removed Lines]",
          "3620: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3620: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "3642: [[package]]",
          "3643: name = \"wasmtime-jit-debug\"",
          "3645: dependencies = [",
          "3646:  \"object\",",
          "3647:  \"once_cell\",",
          "",
          "[Removed Lines]",
          "3644: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3644: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3651: [[package]]",
          "3652: name = \"wasmtime-runtime\"",
          "3654: dependencies = [",
          "3655:  \"anyhow\",",
          "3656:  \"cc\",",
          "",
          "[Removed Lines]",
          "3653: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3653: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "3676: [[package]]",
          "3677: name = \"wasmtime-types\"",
          "3679: dependencies = [",
          "3680:  \"cranelift-entity\",",
          "3681:  \"serde\",",
          "",
          "[Removed Lines]",
          "3678: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3678: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3686: [[package]]",
          "3687: name = \"wasmtime-wasi\"",
          "3689: dependencies = [",
          "3690:  \"anyhow\",",
          "3691:  \"wasi-cap-std-sync\",",
          "",
          "[Removed Lines]",
          "3688: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3688: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "3698: [[package]]",
          "3699: name = \"wasmtime-wasi-crypto\"",
          "3701: dependencies = [",
          "3702:  \"anyhow\",",
          "3703:  \"wasi-crypto\",",
          "",
          "[Removed Lines]",
          "3700: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3700: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "3708: [[package]]",
          "3709: name = \"wasmtime-wasi-nn\"",
          "3711: dependencies = [",
          "3712:  \"anyhow\",",
          "3713:  \"openvino\",",
          "",
          "[Removed Lines]",
          "3710: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3710: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "3719: [[package]]",
          "3720: name = \"wasmtime-wast\"",
          "3722: dependencies = [",
          "3723:  \"anyhow\",",
          "3724:  \"log\",",
          "",
          "[Removed Lines]",
          "3721: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3721: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "3780: [[package]]",
          "3781: name = \"wiggle\"",
          "3783: dependencies = [",
          "3784:  \"anyhow\",",
          "3785:  \"async-trait\",",
          "",
          "[Removed Lines]",
          "3782: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3782: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "3797: [[package]]",
          "3798: name = \"wiggle-generate\"",
          "3800: dependencies = [",
          "3801:  \"anyhow\",",
          "3802:  \"heck\",",
          "",
          "[Removed Lines]",
          "3799: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3799: version = \"1.0.2\"",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "3810: [[package]]",
          "3811: name = \"wiggle-macro\"",
          "3813: dependencies = [",
          "3814:  \"proc-macro2\",",
          "3815:  \"quote\",",
          "",
          "[Removed Lines]",
          "3812: version = \"1.0.1\"",
          "",
          "[Added Lines]",
          "3812: version = \"1.0.2\"",
          "",
          "---------------"
        ],
        "cranelift/codegen/src/isx64/inst/mod.rs||cranelift/codegen/src/isa/x64/inst/mod.rs": [
          "File: cranelift/codegen/src/isx64/inst/mod.rs -> cranelift/codegen/src/isa/x64/inst/mod.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "51:     assert_eq!(40, std::mem::size_of::<Inst>());",
          "",
          "---------------"
        ],
        "crates/c-api/src/trap.rs||crates/c-api/src/trap.rs": [
          "File: crates/c-api/src/trap.rs -> crates/c-api/src/trap.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "92: }",
          "94: #[no_mangle]",
          "96:     match raw.trap.trap_code() {",
          "97:         Some(c) => {",
          "",
          "[Removed Lines]",
          "95: pub extern \"C\" fn wasmtime_trap_code(raw: &wasm_trap_t, code: &mut i32) -> bool {",
          "",
          "[Added Lines]",
          "95: pub extern \"C\" fn wasmtime_trap_code(raw: &wasm_trap_t, code: &mut u8) -> bool {",
          "",
          "---------------"
        ],
        "crates/runtime/src/cow.rs||crates/runtime/src/cow.rs": [
          "File: crates/runtime/src/cow.rs -> crates/runtime/src/cow.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "535:     fn reset_with_anon_memory(&self) -> Result<()> {",
          "536:         unsafe {",
          "537:             let ptr = rustix::mm::mmap_anonymous(",
          "538:                 self.base as *mut c_void,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "536:         if self.static_size == 0 {",
          "537:             return Ok(());",
          "538:         }",
          "",
          "---------------"
        ],
        "crates/runtime/src/instance/allocator/pooling.rs||crates/runtime/src/instance/allocator/pooling.rs": [
          "File: crates/runtime/src/instance/allocator/pooling.rs -> crates/runtime/src/instance/allocator/pooling.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: use std::mem;",
          "20: use std::sync::Mutex;",
          "21: use wasmtime_environ::{",
          "24: };",
          "26: mod index_allocator;",
          "",
          "[Removed Lines]",
          "22:     DefinedMemoryIndex, DefinedTableIndex, HostPtr, Module, PrimaryMap, Tunables, VMOffsets,",
          "23:     WASM_PAGE_SIZE,",
          "",
          "[Added Lines]",
          "22:     DefinedMemoryIndex, DefinedTableIndex, HostPtr, MemoryStyle, Module, PrimaryMap, Tunables,",
          "23:     VMOffsets, WASM_PAGE_SIZE,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "386:                 .defined_memory_index(memory_index)",
          "387:                 .expect(\"should be a defined memory since we skipped imported ones\");",
          "389:             let memory = unsafe {",
          "390:                 std::slice::from_raw_parts_mut(",
          "391:                     self.memories.get_base(instance_index, defined_index),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "389:             match plan.style {",
          "390:                 MemoryStyle::Static { bound } => {",
          "391:                     let bound = bound * u64::from(WASM_PAGE_SIZE);",
          "392:                     if bound < self.memories.static_memory_bound {",
          "393:                         return Err(InstantiationError::Resource(anyhow!(",
          "394:                             \"static bound of {bound:x} bytes incompatible with \\",
          "395:                              reservation of {:x} bytes\",",
          "396:                             self.memories.static_memory_bound,",
          "397:                         )));",
          "398:                     }",
          "399:                 }",
          "400:                 MemoryStyle::Dynamic { .. } => {}",
          "401:             }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "393:                 )",
          "394:             };",
          "396:             if let Some(image) = runtime_info",
          "397:                 .memory_image(defined_index)",
          "398:                 .map_err(|err| InstantiationError::Resource(err.into()))?",
          "399:             {",
          "403:                 let initial_size = plan.memory.minimum * WASM_PAGE_SIZE as u64;",
          "",
          "[Removed Lines]",
          "400:                 let mut slot = self",
          "401:                     .memories",
          "402:                     .take_memory_image_slot(instance_index, defined_index);",
          "",
          "[Added Lines]",
          "410:             let slot = if cfg!(memory_init_cow) {",
          "411:                 Some(",
          "412:                     self.memories",
          "413:                         .take_memory_image_slot(instance_index, defined_index),",
          "414:                 )",
          "415:             } else {",
          "416:                 None",
          "417:             };",
          "422:                 let mut slot = slot.unwrap();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "425:                     .map_err(InstantiationError::Resource)?,",
          "426:                 );",
          "427:             } else {",
          "428:                 memories.push(",
          "429:                     Memory::new_static(plan, memory, Some(commit_memory_pages), None, unsafe {",
          "430:                         &mut *store.unwrap()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "448:                 drop(slot);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "657:     initial_memory_offset: usize,",
          "658:     max_memories: usize,",
          "659:     max_instances: usize,",
          "660: }",
          "662: impl MemoryPool {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "681:     static_memory_bound: u64,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "678:             );",
          "679:         }",
          "691:         assert!(",
          "692:             memory_size % crate::page_size() == 0,",
          "",
          "[Removed Lines]",
          "681:         let memory_size = if instance_limits.memory_pages > 0 {",
          "682:             usize::try_from(",
          "683:                 u64::from(tunables.static_memory_bound) * u64::from(WASM_PAGE_SIZE)",
          "684:                     + tunables.static_memory_offset_guard_size,",
          "685:             )",
          "686:             .map_err(|_| anyhow!(\"memory reservation size exceeds addressable memory\"))?",
          "687:         } else {",
          "688:             0",
          "689:         };",
          "",
          "[Added Lines]",
          "703:         let static_memory_bound =",
          "704:             u64::from(tunables.static_memory_bound) * u64::from(WASM_PAGE_SIZE);",
          "705:         let memory_size =",
          "706:             usize::try_from(static_memory_bound + tunables.static_memory_offset_guard_size)",
          "707:                 .map_err(|_| anyhow!(\"memory reservation size exceeds addressable memory\"))?;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "744:             max_memories,",
          "745:             max_instances,",
          "746:             max_memory_size: (instance_limits.memory_pages as usize) * (WASM_PAGE_SIZE as usize),",
          "747:         };",
          "749:         Ok(pool)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "765:             static_memory_bound,",
          "",
          "---------------"
        ],
        "tests/all/pooling_allocator.rs||tests/all/pooling_allocator.rs": [
          "File: tests/all/pooling_allocator.rs -> tests/all/pooling_allocator.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "615:     Ok(())",
          "616: }",
          "618: #[test]",
          "619: #[cfg(target_pointer_width = \"64\")]",
          "620: fn instance_too_large() -> Result<()> {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "618: #[test]",
          "619: fn switch_image_and_non_image() -> Result<()> {",
          "620:     let mut c = Config::new();",
          "621:     c.allocation_strategy(InstanceAllocationStrategy::Pooling {",
          "622:         instance_limits: InstanceLimits {",
          "623:             count: 1,",
          "624:             ..Default::default()",
          "625:         },",
          "626:         strategy: Default::default(),",
          "627:     });",
          "628:     let engine = Engine::new(&c)?;",
          "629:     let module1 = Module::new(",
          "630:         &engine,",
          "631:         r#\"",
          "632:             (module",
          "633:                 (memory 1)",
          "634:                 (func (export \"load\") (param i32) (result i32)",
          "635:                     local.get 0",
          "636:                     i32.load",
          "637:                 )",
          "638:             )",
          "639:         \"#,",
          "640:     )?;",
          "641:     let module2 = Module::new(",
          "642:         &engine,",
          "643:         r#\"",
          "644:             (module",
          "645:                 (memory (export \"memory\") 1)",
          "646:                 (data (i32.const 0) \"1234\")",
          "647:             )",
          "648:         \"#,",
          "649:     )?;",
          "651:     let assert_zero = || -> Result<()> {",
          "652:         let mut store = Store::new(&engine, ());",
          "653:         let instance = Instance::new(&mut store, &module1, &[])?;",
          "654:         let func = instance.get_typed_func::<i32, i32, _>(&mut store, \"load\")?;",
          "655:         assert_eq!(func.call(&mut store, 0)?, 0);",
          "656:         Ok(())",
          "657:     };",
          "661:     Instance::new(&mut Store::new(&engine, ()), &module2, &[])?;",
          "662:     assert_zero()?;",
          "665:     Instance::new(&mut Store::new(&engine, ()), &module2, &[])?;",
          "666:     assert_zero()?;",
          "669:     let mut store = Store::new(&engine, ());",
          "670:     let instance = Instance::new(&mut store, &module2, &[])?;",
          "671:     let memory = instance.get_memory(&mut store, \"memory\").unwrap();",
          "672:     let mem = memory.data_mut(&mut store);",
          "673:     assert!(mem.starts_with(b\"1234\"));",
          "674:     mem[..6].copy_from_slice(b\"567890\");",
          "676:     Ok(())",
          "677: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "661:     Ok(())",
          "662: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "725: #[test]",
          "726: fn zero_memory_pages_disallows_oob() -> Result<()> {",
          "727:     let mut config = Config::new();",
          "728:     config.allocation_strategy(InstanceAllocationStrategy::Pooling {",
          "729:         strategy: PoolingAllocationStrategy::NextAvailable,",
          "730:         instance_limits: InstanceLimits {",
          "731:             count: 1,",
          "732:             memory_pages: 0,",
          "733:             ..Default::default()",
          "734:         },",
          "735:     });",
          "737:     let engine = Engine::new(&config)?;",
          "738:     let module = Module::new(",
          "739:         &engine,",
          "740:         r#\"",
          "741:             (module",
          "742:                 (memory 0)",
          "744:                 (func (export \"load\") (param i32) (result i32)",
          "745:                     local.get 0",
          "746:                     i32.load)",
          "748:                 (func (export \"store\") (param i32 )",
          "749:                     local.get 0",
          "750:                     local.get 0",
          "751:                     i32.store)",
          "752:             )",
          "753:         \"#,",
          "754:     )?;",
          "755:     let mut store = Store::new(&engine, ());",
          "756:     let instance = Instance::new(&mut store, &module, &[])?;",
          "757:     let load32 = instance.get_typed_func::<i32, i32, _>(&mut store, \"load\")?;",
          "758:     let store32 = instance.get_typed_func::<i32, (), _>(&mut store, \"store\")?;",
          "759:     for i in 0..31 {",
          "760:         assert!(load32.call(&mut store, 1 << i).is_err());",
          "761:         assert!(store32.call(&mut store, 1 << i).is_err());",
          "762:     }",
          "763:     Ok(())",
          "764: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
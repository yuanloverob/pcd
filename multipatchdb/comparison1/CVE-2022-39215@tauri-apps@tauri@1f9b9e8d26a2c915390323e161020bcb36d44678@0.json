{
  "cve_id": "CVE-2022-39215",
  "cve_desc": "Tauri is a framework for building binaries for all major desktop platforms. Due to missing canonicalization when `readDir` is called recursively, it was possible to display directory listings outside of the defined `fs` scope. This required a crafted symbolic link or junction folder inside an allowed path of the `fs` scope. No arbitrary file content could be leaked. The issue has been resolved in version 1.0.6 and the implementation now properly checks if the requested (sub) directory is a symbolic link outside of the defined `scope`. Users are advised to upgrade. Users unable to upgrade should disable the `readDir` endpoint in the `allowlist` inside the `tauri.conf.json`.",
  "repo": "tauri-apps/tauri",
  "patch_hash": "1f9b9e8d26a2c915390323e161020bcb36d44678",
  "patch_info": {
    "commit_hash": "1f9b9e8d26a2c915390323e161020bcb36d44678",
    "repo": "tauri-apps/tauri",
    "commit_url": "https://github.com/tauri-apps/tauri/commit/1f9b9e8d26a2c915390323e161020bcb36d44678",
    "files": [
      ".changes/fix-readir-symlink-scope.md",
      "core/tauri/src/api/dir.rs",
      "core/tauri/src/api/file.rs",
      "core/tauri/src/endpoints/file_system.rs"
    ],
    "message": "fix(endpoints/fs/readDir): don't read symlinks that are not allowed by the scope, closes #4882",
    "before_after_code_files": [
      "core/tauri/src/api/dir.rs||core/tauri/src/api/dir.rs",
      "core/tauri/src/api/file.rs||core/tauri/src/api/file.rs",
      "core/tauri/src/endpoints/file_system.rs||core/tauri/src/endpoints/file_system.rs"
    ]
  },
  "patch_diff": {
    "core/tauri/src/api/dir.rs||core/tauri/src/api/dir.rs": [
      "File: core/tauri/src/api/dir.rs -> core/tauri/src/api/dir.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "7: use serde::Serialize;",
      "8: use std::{",
      "10:   path::{Path, PathBuf},",
      "11: };",
      "12: use tempfile::{self, tempdir};",
      "",
      "[Removed Lines]",
      "9:   fs::{self, metadata},",
      "",
      "[Added Lines]",
      "9:   fs::{self, metadata, symlink_metadata},",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "31:   metadata(path).map(|md| md.is_dir()).map_err(Into::into)",
      "32: }",
      "35: pub fn read_dir<P: AsRef<Path>>(path: P, recursive: bool) -> crate::api::Result<Vec<DiskEntry>> {",
      "36:   let mut files_and_dirs: Vec<DiskEntry> = vec![];",
      "37:   for entry in fs::read_dir(path)? {",
      "38:     let path = entry?.path();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "34: fn is_symlink<P: AsRef<Path>>(path: P) -> crate::api::Result<bool> {",
      "35:   symlink_metadata(path)",
      "36:     .map(|md| md.is_symlink())",
      "37:     .map_err(Into::into)",
      "38: }",
      "42:   read_dir_with_options(path, recursive, ReadDirOptions { scope: None })",
      "43: }",
      "45: pub(crate) struct ReadDirOptions<'a> {",
      "46:   pub scope: Option<&'a crate::FsScope>,",
      "47: }",
      "49: pub(crate) fn read_dir_with_options<P: AsRef<Path>>(",
      "50:   path: P,",
      "51:   recursive: bool,",
      "52:   options: ReadDirOptions<'_>,",
      "53: ) -> crate::api::Result<Vec<DiskEntry>> {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "42:       files_and_dirs.push(DiskEntry {",
      "43:         path: path.clone(),",
      "44:         children: if flag {",
      "50:         } else {",
      "51:           None",
      "52:         },",
      "",
      "[Removed Lines]",
      "45:           Some(if recursive {",
      "46:             read_dir(&path_as_string, true)?",
      "47:           } else {",
      "48:             vec![]",
      "49:           })",
      "",
      "[Added Lines]",
      "63:           Some(",
      "64:             if recursive",
      "65:               && (!is_symlink(&path_as_string)?",
      "66:                 || options.scope.map(|s| s.is_allowed(&path)).unwrap_or(true))",
      "67:             {",
      "68:               read_dir(&path_as_string, true)?",
      "69:             } else {",
      "70:               vec![]",
      "71:             },",
      "72:           )",
      "",
      "---------------"
    ],
    "core/tauri/src/api/file.rs||core/tauri/src/api/file.rs": [
      "File: core/tauri/src/api/file.rs -> core/tauri/src/api/file.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "74: #[cfg(test)]",
      "75: mod test {",
      "76:   use super::*;",
      "77:   use crate::api::Error;",
      "78:   use quickcheck::{Arbitrary, Gen};",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "77:   #[cfg(not(windows))]",
      "",
      "---------------"
    ],
    "core/tauri/src/endpoints/file_system.rs||core/tauri/src/endpoints/file_system.rs": [
      "File: core/tauri/src/endpoints/file_system.rs -> core/tauri/src/endpoints/file_system.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "191:       path,",
      "192:       dir,",
      "193:     )?;",
      "197:   }",
      "199:   #[module_command_handler(fs_copy_file)]",
      "",
      "[Removed Lines]",
      "194:     dir::read_dir(&resolved_path, recursive)",
      "195:       .with_context(|| format!(\"path: {}\", resolved_path.display()))",
      "196:       .map_err(Into::into)",
      "",
      "[Added Lines]",
      "194:     dir::read_dir_with_options(",
      "195:       &resolved_path,",
      "196:       recursive,",
      "197:       dir::ReadDirOptions {",
      "198:         scope: Some(&context.window.state::<Scopes>().fs),",
      "199:       },",
      "200:     )",
      "201:     .with_context(|| format!(\"path: {}\", resolved_path.display()))",
      "202:     .map_err(Into::into)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f4121c128e69b06c3eb5eea14dd2af4720afed49",
      "candidate_info": {
        "commit_hash": "f4121c128e69b06c3eb5eea14dd2af4720afed49",
        "repo": "tauri-apps/tauri",
        "commit_url": "https://github.com/tauri-apps/tauri/commit/f4121c128e69b06c3eb5eea14dd2af4720afed49",
        "files": [
          ".changes/fix-readir-symlink-scope.md",
          "core/tauri/src/api/dir.rs",
          "core/tauri/src/api/file.rs",
          "core/tauri/src/endpoints/file_system.rs"
        ],
        "message": "fix(endpoints/fs/readDir): don't read symlinks that are not allowed b\u2026 (#5123)",
        "before_after_code_files": [
          "core/tauri/src/api/dir.rs||core/tauri/src/api/dir.rs",
          "core/tauri/src/api/file.rs||core/tauri/src/api/file.rs",
          "core/tauri/src/endpoints/file_system.rs||core/tauri/src/endpoints/file_system.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/tauri-apps/tauri/pull/5123"
        ],
        "olp_code_files": {
          "patch": [
            "core/tauri/src/api/dir.rs||core/tauri/src/api/dir.rs",
            "core/tauri/src/api/file.rs||core/tauri/src/api/file.rs",
            "core/tauri/src/endpoints/file_system.rs||core/tauri/src/endpoints/file_system.rs"
          ],
          "candidate": [
            "core/tauri/src/api/dir.rs||core/tauri/src/api/dir.rs",
            "core/tauri/src/api/file.rs||core/tauri/src/api/file.rs",
            "core/tauri/src/endpoints/file_system.rs||core/tauri/src/endpoints/file_system.rs"
          ]
        }
      },
      "candidate_diff": {
        "core/tauri/src/api/dir.rs||core/tauri/src/api/dir.rs": [
          "File: core/tauri/src/api/dir.rs -> core/tauri/src/api/dir.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: use serde::Serialize;",
          "8: use std::{",
          "10:   path::{Path, PathBuf},",
          "11: };",
          "12: use tempfile::{self, tempdir};",
          "",
          "[Removed Lines]",
          "9:   fs::{self, metadata},",
          "",
          "[Added Lines]",
          "9:   fs::{self, metadata, symlink_metadata},",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "31:   metadata(path).map(|md| md.is_dir()).map_err(Into::into)",
          "32: }",
          "35: pub fn read_dir<P: AsRef<Path>>(path: P, recursive: bool) -> crate::api::Result<Vec<DiskEntry>> {",
          "36:   let mut files_and_dirs: Vec<DiskEntry> = vec![];",
          "37:   for entry in fs::read_dir(path)? {",
          "38:     let path = entry?.path();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34: fn is_symlink<P: AsRef<Path>>(path: P) -> crate::api::Result<bool> {",
          "36:   #[cfg(windows)]",
          "37:   let ret = symlink_metadata(path)",
          "38:     .map(|md| md.is_symlink())",
          "39:     .map_err(Into::into);",
          "41:   #[cfg(not(windows))]",
          "42:   let ret = symlink_metadata(path)",
          "43:     .map(|md| md.file_type().is_symlink())",
          "44:     .map_err(Into::into);",
          "46:   ret",
          "47: }",
          "51:   read_dir_with_options(path, recursive, ReadDirOptions { scope: None })",
          "52: }",
          "54: #[derive(Clone, Copy)]",
          "55: pub(crate) struct ReadDirOptions<'a> {",
          "56:   pub scope: Option<&'a crate::FsScope>,",
          "57: }",
          "59: pub(crate) fn read_dir_with_options<P: AsRef<Path>>(",
          "60:   path: P,",
          "61:   recursive: bool,",
          "62:   options: ReadDirOptions<'_>,",
          "63: ) -> crate::api::Result<Vec<DiskEntry>> {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "42:       files_and_dirs.push(DiskEntry {",
          "43:         path: path.clone(),",
          "44:         children: if flag {",
          "50:         } else {",
          "51:           None",
          "52:         },",
          "",
          "[Removed Lines]",
          "45:           Some(if recursive {",
          "46:             read_dir(&path_as_string, true)?",
          "47:           } else {",
          "48:             vec![]",
          "49:           })",
          "",
          "[Added Lines]",
          "73:           Some(",
          "74:             if recursive",
          "75:               && (!is_symlink(&path_as_string)?",
          "76:                 || options.scope.map(|s| s.is_allowed(&path)).unwrap_or(true))",
          "77:             {",
          "78:               read_dir_with_options(&path_as_string, true, options)?",
          "79:             } else {",
          "80:               vec![]",
          "81:             },",
          "82:           )",
          "",
          "---------------"
        ],
        "core/tauri/src/api/file.rs||core/tauri/src/api/file.rs": [
          "File: core/tauri/src/api/file.rs -> core/tauri/src/api/file.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "74: #[cfg(test)]",
          "75: mod test {",
          "76:   use super::*;",
          "77:   use crate::api::Error;",
          "78:   use quickcheck::{Arbitrary, Gen};",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "77:   #[cfg(not(windows))]",
          "",
          "---------------"
        ],
        "core/tauri/src/endpoints/file_system.rs||core/tauri/src/endpoints/file_system.rs": [
          "File: core/tauri/src/endpoints/file_system.rs -> core/tauri/src/endpoints/file_system.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "191:       path,",
          "192:       dir,",
          "193:     )?;",
          "197:   }",
          "199:   #[module_command_handler(fs_copy_file)]",
          "",
          "[Removed Lines]",
          "194:     dir::read_dir(&resolved_path, recursive)",
          "195:       .with_context(|| format!(\"path: {}\", resolved_path.display()))",
          "196:       .map_err(Into::into)",
          "",
          "[Added Lines]",
          "194:     dir::read_dir_with_options(",
          "195:       &resolved_path,",
          "196:       recursive,",
          "197:       dir::ReadDirOptions {",
          "198:         scope: Some(&context.window.state::<Scopes>().fs),",
          "199:       },",
          "200:     )",
          "201:     .with_context(|| format!(\"path: {}\", resolved_path.display()))",
          "202:     .map_err(Into::into)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
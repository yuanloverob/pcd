{
  "cve_id": "CVE-2024-29034",
  "cve_desc": "CarrierWave is a solution for file uploads for Rails, Sinatra and other Ruby web frameworks. The vulnerability CVE-2023-49090 wasn't fully addressed. This vulnerability is caused by the fact that when uploading to object storage, including Amazon S3, it is possible to set a Content-Type value that is interpreted by browsers to be different from what's allowed by `content_type_allowlist`, by providing multiple values separated by commas. This bypassed value can be used to cause XSS. Upgrade to 3.0.7 or 2.2.6.\n",
  "repo": "carrierwaveuploader/carrierwave",
  "patch_hash": "25b1c800d45ef8e78dc445ebe3bd8a6e3f0a3477",
  "patch_info": {
    "commit_hash": "25b1c800d45ef8e78dc445ebe3bd8a6e3f0a3477",
    "repo": "carrierwaveuploader/carrierwave",
    "commit_url": "https://github.com/carrierwaveuploader/carrierwave/commit/25b1c800d45ef8e78dc445ebe3bd8a6e3f0a3477",
    "files": [
      "lib/carrierwave/sanitized_file.rb",
      "spec/sanitized_file_spec.rb",
      "spec/uploader/content_type_allowlist_spec.rb"
    ],
    "message": "Fix Content-Type allowlist bypass vulnerability remained\n\nRefs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-vfmv-jfc5-pjjw",
    "before_after_code_files": [
      "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
      "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb",
      "spec/uploader/content_type_allowlist_spec.rb||spec/uploader/content_type_allowlist_spec.rb"
    ]
  },
  "patch_diff": {
    "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb": [
      "File: lib/carrierwave/sanitized_file.rb -> lib/carrierwave/sanitized_file.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "307:     def declared_content_type",
      "308:       @declared_content_type ||",
      "309:         if @file.respond_to?(:content_type) && @file.content_type",
      "311:         end",
      "312:     end",
      "",
      "[Removed Lines]",
      "310:           @file.content_type.to_s.chomp",
      "",
      "[Added Lines]",
      "310:           Marcel::MimeType.for(declared_type: @file.content_type.to_s.chomp)",
      "",
      "---------------"
    ],
    "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb": [
      "File: spec/sanitized_file_spec.rb -> spec/sanitized_file_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "327:       expect { sanitized_file.content_type }.not_to raise_error",
      "328:     end",
      "329:   end",
      "331:   describe \"#content_type=\" do",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "330:     it \"uses the first one when multiple mime types are given using a semicolon\" do",
      "331:       file = File.open(file_path(\"bork.txt\"))",
      "332:       allow(file).to receive(:content_type) { 'image/png; text/html' }",
      "334:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
      "336:       expect(sanitized_file.content_type).to eq(\"image/png\")",
      "337:     end",
      "339:     it \"uses the first one when multiple mime types are given using a comma\" do",
      "340:       file = File.open(file_path(\"bork.txt\"))",
      "341:       allow(file).to receive(:content_type) { 'image/png, text/html' }",
      "343:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
      "345:       expect(sanitized_file.content_type).to eq(\"image/png\")",
      "346:     end",
      "348:     it \"drops content type parameters\" do",
      "349:       file = File.open(file_path(\"bork.txt\"))",
      "350:       allow(file).to receive(:content_type) { 'text/html; charset=utf-8' }",
      "352:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
      "354:       expect(sanitized_file.content_type).to eq(\"text/html\")",
      "355:     end",
      "",
      "---------------"
    ],
    "spec/uploader/content_type_allowlist_spec.rb||spec/uploader/content_type_allowlist_spec.rb": [
      "File: spec/uploader/content_type_allowlist_spec.rb -> spec/uploader/content_type_allowlist_spec.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "87:           expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)",
      "88:         end",
      "89:       end",
      "106:     end",
      "108:     context \"when there is a whitelist\" do",
      "",
      "[Removed Lines]",
      "91:       context \"when the allowlist contains charset\" do",
      "92:         before do",
      "93:           allow(uploader).to receive(:content_type_allowlist).and_return(%r{text/plain;\\s*charset=utf-8})",
      "94:         end",
      "96:         it \"accepts the content with allowed charset\" do",
      "97:           allow(bork_file).to receive(:content_type).and_return('text/plain; charset=utf-8')",
      "98:           expect { uploader.cache!(bork_file) }.not_to raise_error",
      "99:         end",
      "101:         it \"rejects the content without charset\" do",
      "102:           allow(bork_file).to receive(:content_type).and_return('text/plain')",
      "103:           expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)",
      "104:         end",
      "105:       end",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a2ca59cbe67046ba7818c64849a9a4ffa90306db",
      "candidate_info": {
        "commit_hash": "a2ca59cbe67046ba7818c64849a9a4ffa90306db",
        "repo": "carrierwaveuploader/carrierwave",
        "commit_url": "https://github.com/carrierwaveuploader/carrierwave/commit/a2ca59cbe67046ba7818c64849a9a4ffa90306db",
        "files": [
          "lib/carrierwave/sanitized_file.rb",
          "spec/sanitized_file_spec.rb",
          "spec/uploader/download_spec.rb",
          "spec/uploader/proxy_spec.rb"
        ],
        "message": "Prioritize Magic-detected content type for spoof-tolerance\n\nFixes #2570",
        "before_after_code_files": [
          "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
          "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb",
          "spec/uploader/download_spec.rb||spec/uploader/download_spec.rb",
          "spec/uploader/proxy_spec.rb||spec/uploader/proxy_spec.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
            "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb"
          ],
          "candidate": [
            "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
            "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb"
          ]
        }
      },
      "candidate_diff": {
        "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb": [
          "File: lib/carrierwave/sanitized_file.rb -> lib/carrierwave/sanitized_file.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "28:     def initialize(file)",
          "29:       self.file = file",
          "31:     end",
          "33:     ##",
          "",
          "[Removed Lines]",
          "30:       @content = nil",
          "",
          "[Added Lines]",
          "30:       @content = @content_type = nil",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "163:       mkdir!(new_path, directory_permissions)",
          "164:       move!(new_path)",
          "165:       chmod!(new_path, permissions)",
          "171:       self",
          "172:     end",
          "",
          "[Removed Lines]",
          "166:       if keep_filename",
          "167:         self.file = {:tempfile => new_path, :filename => original_filename, :content_type => @content_type}",
          "168:       else",
          "169:         self.file = {:tempfile => new_path, :content_type => @content_type}",
          "170:       end",
          "",
          "[Added Lines]",
          "166:       self.file = {tempfile: new_path, filename: keep_filename ? original_filename : nil, content_type: declared_content_type}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "244:     #",
          "245:     def content_type",
          "246:       @content_type ||=",
          "250:     end",
          "252:     ##",
          "",
          "[Removed Lines]",
          "247:         existing_content_type ||",
          "248:         marcel_magic_by_mime_type ||",
          "249:         marcel_magic_by_path",
          "",
          "[Added Lines]",
          "243:         identified_content_type ||",
          "244:         declared_content_type ||",
          "245:         guessed_safe_content_type ||",
          "246:         Marcel::MimeType::BINARY",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "277:       if file.is_a?(Hash)",
          "278:         @file = file[\"tempfile\"] || file[:tempfile]",
          "279:         @original_filename = file[\"filename\"] || file[:filename]",
          "281:       else",
          "282:         @file = file",
          "283:         @original_filename = nil",
          "285:       end",
          "286:     end",
          "",
          "[Removed Lines]",
          "280:         @content_type = file[\"content_type\"] || file[:content_type] || file[\"type\"] || file[:type]",
          "284:         @content_type = nil",
          "",
          "[Added Lines]",
          "277:         @declared_content_type = file[\"content_type\"] || file[:content_type] || file[\"type\"] || file[:type]",
          "281:         @declared_content_type = nil",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "307:       name.mb_chars.to_s",
          "308:     end",
          "314:     end",
          "317:       return unless path",
          "326:       end",
          "329:     rescue Errno::ENOENT",
          "330:       nil",
          "331:     end",
          "337:     end",
          "338:   end # SanitizedFile",
          "339: end # CarrierWave",
          "",
          "[Removed Lines]",
          "310:     def existing_content_type",
          "311:       if @file.respond_to?(:content_type) && @file.content_type",
          "312:         @file.content_type.to_s.chomp",
          "313:       end",
          "316:     def marcel_magic_by_mime_type",
          "319:       type = File.open(path) do |file|",
          "320:         Marcel::Magic.by_magic(file).try(:type)",
          "321:       end",
          "323:       if type.nil?",
          "324:         type = Marcel::Magic.by_path(path).try(:type)",
          "325:         type = 'invalid/invalid' unless type.nil? || type.start_with?('text/') || type.start_with?('application/json')",
          "328:       type",
          "333:     def marcel_magic_by_path",
          "334:       return unless path",
          "336:       Marcel::Magic.by_path(path).to_s",
          "",
          "[Added Lines]",
          "307:     def declared_content_type",
          "308:       @declared_content_type ||",
          "309:         if @file.respond_to?(:content_type) && @file.content_type",
          "310:           @file.content_type.to_s.chomp",
          "311:         end",
          "314:     # Guess content type from its file extension. Limit what to be returned to prevent spoofing.",
          "315:     def guessed_safe_content_type",
          "318:       type = Marcel::Magic.by_path(original_filename).to_s",
          "319:       type if type.start_with?('text/') || type.start_with?('application/json')",
          "320:     end",
          "322:     def identified_content_type",
          "323:       with_io do |io|",
          "324:         Marcel::Magic.by_magic(io).try(:type)",
          "330:     def with_io(&block)",
          "331:       if file.is_a?(IO)",
          "332:         begin",
          "333:           yield file",
          "334:         ensure",
          "335:           file.try(:rewind)",
          "336:         end",
          "337:       elsif path",
          "338:         File.open(path, &block)",
          "339:       end",
          "",
          "---------------"
        ],
        "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb": [
          "File: spec/sanitized_file_spec.rb -> spec/sanitized_file_spec.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "220:       expect(sanitized_file.content_type).to eq(\"application/vnd.openxmlformats-officedocument.presentationml.presentation\")",
          "221:     end",
          "224:       sanitized_file = CarrierWave::SanitizedFile.new(\"llama.jpg\")",
          "227:     end",
          "229:     it \"reads content type of a CSV linked to a file\" do",
          "",
          "[Removed Lines]",
          "223:     it \"reads content type from path if missing\" do",
          "226:       expect(sanitized_file.content_type).to eq(\"image/jpeg\")",
          "",
          "[Added Lines]",
          "223:     it \"does not raise an error if missing\" do",
          "226:       expect(sanitized_file.content_type).to eq(\"application/octet-stream\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "234:       expect(sanitized_file.content_type).to eq(\"text/csv\")",
          "235:     end",
          "238:       file = File.open(file_path(\"zip.png\"))",
          "240:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
          "",
          "[Removed Lines]",
          "237:     it \"does not allow spoofing of the mime type\" do",
          "",
          "[Added Lines]",
          "237:     it \"does not allow spoofing of the mime type passed by Hash\" do",
          "238:       file = File.open(file_path(\"landscape.jpg\"))",
          "240:       sanitized_file = CarrierWave::SanitizedFile.new(tempfile: file, content_type: 'image/png')",
          "242:       expect(sanitized_file.content_type).to eq(\"image/jpeg\")",
          "243:     end",
          "245:     it \"does not allow spoofing of the mime type by setting file's content type\" do",
          "246:       file = File.open(file_path(\"landscape.jpg\"))",
          "247:       allow(file).to receive(:content_type) { 'image/png' }",
          "249:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
          "251:       expect(sanitized_file.content_type).to eq(\"image/jpeg\")",
          "252:     end",
          "254:     it \"does not allow spoofing of the mime type by file extension\" do",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "251:       expect { sanitized_file.content_type }.not_to raise_error",
          "253:       expect(sanitized_file.content_type).to_not eq 'image/png'",
          "255:     end",
          "257:     it \"returns valid content type on text file\" do",
          "",
          "[Removed Lines]",
          "254:       expect(sanitized_file.content_type).to eq 'invalid/invalid'",
          "",
          "[Added Lines]",
          "271:       expect(sanitized_file.content_type).to eq 'application/octet-stream'",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "274:       expect(sanitized_file.content_type).to eq 'application/json'",
          "275:     end",
          "278:       file = File.open(file_path('bork.ABCDE'))",
          "280:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
          "282:       expect { sanitized_file.content_type }.not_to raise_error",
          "285:     end",
          "287:     it \"does not raise an error if the path is not present\" do",
          "",
          "[Removed Lines]",
          "277:     it \"returns missing content type with unknown extension\" do",
          "284:       expect(sanitized_file.content_type).to eq \"\"",
          "",
          "[Added Lines]",
          "294:     it \"returns binary content type with unknown extension\" do",
          "301:       expect(sanitized_file.content_type).to eq \"application/octet-stream\"",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "406:       end",
          "408:       it \"should preserve the file's content type\" do",
          "410:         sanitized_file.move_to(file_path(\"new_dir\", \"gurr.png\"))",
          "413:       end",
          "416:         sanitized_file.content_type = nil",
          "417:         sanitized_file.move_to(file_path(\"new_dir\", \"gurr.png\"))",
          "420:       end",
          "422:       context 'target path only differs by case' do",
          "",
          "[Removed Lines]",
          "409:         sanitized_file.content_type = 'application/octet-stream'",
          "412:         expect(sanitized_file.content_type).to eq(\"application/octet-stream\")",
          "415:       it \"should detect content type correctly using Marcel when content_type is not set\" do",
          "419:         expect(sanitized_file.content_type).to eq(\"invalid/invalid\")",
          "",
          "[Added Lines]",
          "426:         sanitized_file.content_type = 'application/x-something'",
          "429:         expect(sanitized_file.content_type).to eq(\"application/x-something\")",
          "432:       it \"should detect content type using Magic when content_type is reset\" do",
          "436:         expect(sanitized_file).to receive(:identified_content_type)",
          "437:         sanitized_file.content_type",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "508:         expect(new_file.content_type).to eq(sanitized_file.content_type)",
          "509:       end",
          "510:     end",
          "511:   end",
          "513:   shared_examples_for \"all valid sanitized files that are stored on disk\" do",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "530:     describe \"#with_io\" do",
          "531:       it \"should yield an IO object\" do",
          "532:         sanitized_file.send(:with_io) do |io|",
          "533:           expect(io).to respond_to(:read)",
          "534:         end",
          "535:       end",
          "536:     end",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "577:         expect(sanitized_file.instance_variable_get(:@file).closed?).to be_falsey",
          "578:       end",
          "579:     end",
          "580:   end",
          "582:   shared_examples_for \"all valid sanitized files that are read from a non-StringIO object\" do",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "607:     describe \"#with_io\" do",
          "608:       it \"should try to rewind the IO object on finish\" do",
          "609:         sanitized_file.send(:with_io) do |io|",
          "610:           io.read",
          "611:         end",
          "612:         expect(sanitized_file.file.pos).to eq 0",
          "613:       end",
          "614:     end",
          "",
          "---------------"
        ],
        "spec/uploader/download_spec.rb||spec/uploader/download_spec.rb": [
          "File: spec/uploader/download_spec.rb -> spec/uploader/download_spec.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "50:       end",
          "52:       it \"sets the content type\" do",
          "54:       end",
          "55:     end",
          "",
          "[Removed Lines]",
          "53:         expect(uploader.content_type).to eq(\"image/jpeg\")",
          "",
          "[Added Lines]",
          "53:         expect(uploader.file.send(:declared_content_type)).to eq(\"image/jpeg\")",
          "",
          "---------------"
        ],
        "spec/uploader/proxy_spec.rb||spec/uploader/proxy_spec.rb": [
          "File: spec/uploader/proxy_spec.rb -> spec/uploader/proxy_spec.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "100:     context \"when the file is empty\" do",
          "101:       before { uploader.retrieve_from_cache!(path) }",
          "104:     end",
          "105:   end",
          "106: end",
          "",
          "[Removed Lines]",
          "103:       it { is_expected.to eq('image/jpeg') }",
          "",
          "[Added Lines]",
          "103:       it { is_expected.to eq('application/octet-stream') }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "431787193795dda9b01a0ee748bd93e2ec7101c2",
      "candidate_info": {
        "commit_hash": "431787193795dda9b01a0ee748bd93e2ec7101c2",
        "repo": "carrierwaveuploader/carrierwave",
        "commit_url": "https://github.com/carrierwaveuploader/carrierwave/commit/431787193795dda9b01a0ee748bd93e2ec7101c2",
        "files": [
          "lib/carrierwave/sanitized_file.rb",
          "spec/sanitized_file_spec.rb",
          "spec/uploader/content_type_whitelist_spec.rb"
        ],
        "message": "Fix Content-Type allowlist bypass vulnerability remained\n\nRefs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-vfmv-jfc5-pjjw",
        "before_after_code_files": [
          "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
          "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb",
          "spec/uploader/content_type_whitelist_spec.rb||spec/uploader/content_type_whitelist_spec.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
            "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb"
          ],
          "candidate": [
            "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
            "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb"
          ]
        }
      },
      "candidate_diff": {
        "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb": [
          "File: lib/carrierwave/sanitized_file.rb -> lib/carrierwave/sanitized_file.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "325:     def existing_content_type",
          "326:       if @file.respond_to?(:content_type) && @file.content_type",
          "328:       end",
          "329:     end",
          "",
          "[Removed Lines]",
          "327:         @file.content_type.to_s.chomp",
          "",
          "[Added Lines]",
          "327:         Marcel::MimeType.for(declared_type: @file.content_type.to_s.chomp)",
          "",
          "---------------"
        ],
        "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb": [
          "File: spec/sanitized_file_spec.rb -> spec/sanitized_file_spec.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "275:       expect { sanitized_file.content_type }.not_to raise_error",
          "276:     end",
          "277:   end",
          "279:   describe \"#content_type=\" do",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "278:     it \"uses the first one when multiple mime types are given using a semicolon\" do",
          "279:       file = File.open(file_path(\"bork.txt\"))",
          "280:       allow(file).to receive(:content_type) { 'image/png; text/html' }",
          "282:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
          "284:       expect(sanitized_file.content_type).to eq(\"image/png\")",
          "285:     end",
          "287:     it \"uses the first one when multiple mime types are given using a comma\" do",
          "288:       file = File.open(file_path(\"bork.txt\"))",
          "289:       allow(file).to receive(:content_type) { 'image/png, text/html' }",
          "291:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
          "293:       expect(sanitized_file.content_type).to eq(\"image/png\")",
          "294:     end",
          "296:     it \"drops content type parameters\" do",
          "297:       file = File.open(file_path(\"bork.txt\"))",
          "298:       allow(file).to receive(:content_type) { 'text/html; charset=utf-8' }",
          "300:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
          "302:       expect(sanitized_file.content_type).to eq(\"text/html\")",
          "303:     end",
          "",
          "---------------"
        ],
        "spec/uploader/content_type_whitelist_spec.rb||spec/uploader/content_type_whitelist_spec.rb": [
          "File: spec/uploader/content_type_whitelist_spec.rb -> spec/uploader/content_type_whitelist_spec.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:           expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)",
          "88:         end",
          "89:       end",
          "106:     end",
          "108:     context \"when there is a whitelist\" do",
          "",
          "[Removed Lines]",
          "91:       context \"when the allowlist contains charset\" do",
          "92:         before do",
          "93:           allow(uploader).to receive(:content_type_allowlist).and_return(%r{text/plain;\\s*charset=utf-8})",
          "94:         end",
          "96:         it \"accepts the content with allowed charset\" do",
          "97:           allow(bork_file).to receive(:content_type).and_return('text/plain; charset=utf-8')",
          "98:           expect { uploader.cache!(bork_file) }.not_to raise_error",
          "99:         end",
          "101:         it \"rejects the content without charset\" do",
          "102:           allow(bork_file).to receive(:content_type).and_return('text/plain')",
          "103:           expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)",
          "104:         end",
          "105:       end",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "00676e23d7f4beac12beddee6f2486b686fb7e46",
      "candidate_info": {
        "commit_hash": "00676e23d7f4beac12beddee6f2486b686fb7e46",
        "repo": "carrierwaveuploader/carrierwave",
        "commit_url": "https://github.com/carrierwaveuploader/carrierwave/commit/00676e23d7f4beac12beddee6f2486b686fb7e46",
        "files": [
          "lib/carrierwave/sanitized_file.rb",
          "spec/sanitized_file_spec.rb",
          "spec/uploader/content_type_allowlist_spec.rb"
        ],
        "message": "Fix Content-Type allowlist bypass vulnerability remained\n\nRefs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-vfmv-jfc5-pjjw",
        "before_after_code_files": [
          "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
          "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb",
          "spec/uploader/content_type_allowlist_spec.rb||spec/uploader/content_type_allowlist_spec.rb"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
            "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb",
            "spec/uploader/content_type_allowlist_spec.rb||spec/uploader/content_type_allowlist_spec.rb"
          ],
          "candidate": [
            "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb",
            "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb",
            "spec/uploader/content_type_allowlist_spec.rb||spec/uploader/content_type_allowlist_spec.rb"
          ]
        }
      },
      "candidate_diff": {
        "lib/carrierwave/sanitized_file.rb||lib/carrierwave/sanitized_file.rb": [
          "File: lib/carrierwave/sanitized_file.rb -> lib/carrierwave/sanitized_file.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "307:     def declared_content_type",
          "308:       @declared_content_type ||",
          "309:         if @file.respond_to?(:content_type) && @file.content_type",
          "311:         end",
          "312:     end",
          "",
          "[Removed Lines]",
          "310:           @file.content_type.to_s.chomp",
          "",
          "[Added Lines]",
          "310:           Marcel::MimeType.for(declared_type: @file.content_type.to_s.chomp)",
          "",
          "---------------"
        ],
        "spec/sanitized_file_spec.rb||spec/sanitized_file_spec.rb": [
          "File: spec/sanitized_file_spec.rb -> spec/sanitized_file_spec.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "307:       expect { sanitized_file.content_type }.not_to raise_error",
          "308:     end",
          "309:   end",
          "311:   describe \"#content_type=\" do",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "310:     it \"uses the first one when multiple mime types are given using a semicolon\" do",
          "311:       file = File.open(file_path(\"bork.txt\"))",
          "312:       allow(file).to receive(:content_type) { 'image/png; text/html' }",
          "314:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
          "316:       expect(sanitized_file.content_type).to eq(\"image/png\")",
          "317:     end",
          "319:     it \"uses the first one when multiple mime types are given using a comma\" do",
          "320:       file = File.open(file_path(\"bork.txt\"))",
          "321:       allow(file).to receive(:content_type) { 'image/png, text/html' }",
          "323:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
          "325:       expect(sanitized_file.content_type).to eq(\"image/png\")",
          "326:     end",
          "328:     it \"drops content type parameters\" do",
          "329:       file = File.open(file_path(\"bork.txt\"))",
          "330:       allow(file).to receive(:content_type) { 'text/html; charset=utf-8' }",
          "332:       sanitized_file = CarrierWave::SanitizedFile.new(file)",
          "334:       expect(sanitized_file.content_type).to eq(\"text/html\")",
          "335:     end",
          "",
          "---------------"
        ],
        "spec/uploader/content_type_allowlist_spec.rb||spec/uploader/content_type_allowlist_spec.rb": [
          "File: spec/uploader/content_type_allowlist_spec.rb -> spec/uploader/content_type_allowlist_spec.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:           expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)",
          "88:         end",
          "89:       end",
          "106:     end",
          "108:     context \"when there is a whitelist\" do",
          "",
          "[Removed Lines]",
          "91:       context \"when the allowlist contains charset\" do",
          "92:         before do",
          "93:           allow(uploader).to receive(:content_type_allowlist).and_return(%r{text/plain;\\s*charset=utf-8})",
          "94:         end",
          "96:         it \"accepts the content with allowed charset\" do",
          "97:           allow(bork_file).to receive(:content_type).and_return('text/plain; charset=utf-8')",
          "98:           expect { uploader.cache!(bork_file) }.not_to raise_error",
          "99:         end",
          "101:         it \"rejects the content without charset\" do",
          "102:           allow(bork_file).to receive(:content_type).and_return('text/plain')",
          "103:           expect { uploader.cache!(bork_file) }.to raise_error(CarrierWave::IntegrityError)",
          "104:         end",
          "105:       end",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
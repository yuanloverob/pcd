{
  "cve_id": "CVE-2021-29510",
  "cve_desc": "Pydantic is a data validation and settings management using Python type hinting. In affected versions passing either `'infinity'`, `'inf'` or `float('inf')` (or their negatives) to `datetime` or `date` fields causes validation to run forever with 100% CPU usage (on one CPU). Pydantic has been patched with fixes available in the following versions: v1.8.2, v1.7.4, v1.6.2. All these versions are available on pypi(https://pypi.org/project/pydantic/#history), and will be available on conda-forge(https://anaconda.org/conda-forge/pydantic) soon. See the changelog(https://pydantic-docs.helpmanual.io/) for details. If you absolutely can't upgrade, you can work around this risk using a validator(https://pydantic-docs.helpmanual.io/usage/validators/) to catch these values. This is not an ideal solution (in particular you'll need a slightly different function for datetimes), instead of a hack like this you should upgrade pydantic. If you are not using v1.8.x, v1.7.x or v1.6.x and are unable to upgrade to a fixed version of pydantic, please create an issue at https://github.com/samuelcolvin/pydantic/issues requesting a back-port, and we will endeavour to release a patch for earlier versions of pydantic.",
  "repo": "samuelcolvin/pydantic",
  "patch_hash": "7e83fdd2563ffac081db7ecdf1affa65ef38c468",
  "patch_info": {
    "commit_hash": "7e83fdd2563ffac081db7ecdf1affa65ef38c468",
    "repo": "samuelcolvin/pydantic",
    "commit_url": "https://github.com/samuelcolvin/pydantic/commit/7e83fdd2563ffac081db7ecdf1affa65ef38c468",
    "files": [
      "changes/2776-samuelcolvin.md",
      "pydantic/datetime_parse.py",
      "tests/test_datetime_parse.py"
    ],
    "message": "Merge pull request from GHSA-5jqp-qgf6-3pvh\n\n* fix infinite loop in datetime parsing\n\n* add change description\n\n* switch to set a max datetime number",
    "before_after_code_files": [
      "pydantic/datetime_parse.py||pydantic/datetime_parse.py",
      "tests/test_datetime_parse.py||tests/test_datetime_parse.py"
    ]
  },
  "patch_diff": {
    "pydantic/datetime_parse.py||pydantic/datetime_parse.py": [
      "File: pydantic/datetime_parse.py -> pydantic/datetime_parse.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "58: # if greater than this, the number is in ms, if less than or equal it's in seconds",
      "59: # (in seconds this is 11th October 2603, in ms it's 20th August 1970)",
      "60: MS_WATERSHED = int(2e10)",
      "61: StrBytesIntFloat = Union[str, bytes, int, float]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "61: # slightly more than datetime.max in ns - (datetime.max - EPOCH).total_seconds() * 1e9",
      "62: MAX_NUMBER = int(3e20)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "75: def from_unix_seconds(seconds: Union[int, float]) -> datetime:",
      "76:     while abs(seconds) > MS_WATERSHED:",
      "77:         seconds /= 1000",
      "78:     dt = EPOCH + timedelta(seconds=seconds)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "78:     if seconds > MAX_NUMBER:",
      "79:         return datetime.max",
      "80:     elif seconds < -MAX_NUMBER:",
      "81:         return datetime.min",
      "",
      "---------------"
    ],
    "tests/test_datetime_parse.py||tests/test_datetime_parse.py": [
      "File: tests/test_datetime_parse.py -> tests/test_datetime_parse.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "42:         (1_549_316_052_104, date(2019, 2, 4)),  # nowish in ms",
      "43:         (1_549_316_052_104_324, date(2019, 2, 4)),  # nowish in \u03bcs",
      "44:         (1_549_316_052_104_324_096, date(2019, 2, 4)),  # nowish in ns",
      "45:     ],",
      "46: )",
      "47: def test_date_parsing(value, result):",
      "50:             parse_date(value)",
      "51:     else:",
      "52:         assert parse_date(value) == result",
      "",
      "[Removed Lines]",
      "48:     if result == errors.DateError:",
      "49:         with pytest.raises(errors.DateError):",
      "",
      "[Added Lines]",
      "45:         ('infinity', date(9999, 12, 31)),",
      "46:         ('inf', date(9999, 12, 31)),",
      "47:         (float('inf'), date(9999, 12, 31)),",
      "48:         ('infinity ', date(9999, 12, 31)),",
      "49:         (int('1' + '0' * 100), date(9999, 12, 31)),",
      "50:         (1e1000, date(9999, 12, 31)),",
      "51:         ('-infinity', date(1, 1, 1)),",
      "52:         ('-inf', date(1, 1, 1)),",
      "53:         ('nan', ValueError),",
      "57:     if type(result) == type and issubclass(result, Exception):",
      "58:         with pytest.raises(result):",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "123:         (1_549_316_052_104, datetime(2019, 2, 4, 21, 34, 12, 104_000, tzinfo=timezone.utc)),  # nowish in ms",
      "124:         (1_549_316_052_104_324, datetime(2019, 2, 4, 21, 34, 12, 104_324, tzinfo=timezone.utc)),  # nowish in \u03bcs",
      "125:         (1_549_316_052_104_324_096, datetime(2019, 2, 4, 21, 34, 12, 104_324, tzinfo=timezone.utc)),  # nowish in ns",
      "126:     ],",
      "127: )",
      "128: def test_datetime_parsing(value, result):",
      "131:             parse_datetime(value)",
      "132:     else:",
      "133:         assert parse_datetime(value) == result",
      "",
      "[Removed Lines]",
      "129:     if result == errors.DateTimeError:",
      "130:         with pytest.raises(errors.DateTimeError):",
      "",
      "[Added Lines]",
      "135:         ('infinity', datetime(9999, 12, 31, 23, 59, 59, 999999)),",
      "136:         ('inf', datetime(9999, 12, 31, 23, 59, 59, 999999)),",
      "137:         ('inf ', datetime(9999, 12, 31, 23, 59, 59, 999999)),",
      "138:         (1e50, datetime(9999, 12, 31, 23, 59, 59, 999999)),",
      "139:         (float('inf'), datetime(9999, 12, 31, 23, 59, 59, 999999)),",
      "140:         ('-infinity', datetime(1, 1, 1, 0, 0)),",
      "141:         ('-inf', datetime(1, 1, 1, 0, 0)),",
      "142:         ('nan', ValueError),",
      "146:     if type(result) == type and issubclass(result, Exception):",
      "147:         with pytest.raises(result):",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "251:         'type': 'value_error.unicodedecode',",
      "252:         'msg': \"'utf-8' codec can't decode byte 0x81 in position 0: invalid start byte\",",
      "253:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "273: def test_nan():",
      "274:     class Model(BaseModel):",
      "275:         dt: datetime",
      "276:         d: date",
      "278:     with pytest.raises(ValidationError) as exc_info:",
      "279:         Model(dt='nan', d='nan')",
      "280:     assert exc_info.value.errors() == [",
      "281:         {",
      "282:             'loc': ('dt',),",
      "283:             'msg': 'cannot convert float NaN to integer',",
      "284:             'type': 'value_error',",
      "285:         },",
      "286:         {",
      "287:             'loc': ('d',),",
      "288:             'msg': 'cannot convert float NaN to integer',",
      "289:             'type': 'value_error',",
      "290:         },",
      "291:     ]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1c24f1d74ba95ea985b50bdc001ce96c813229aa",
      "candidate_info": {
        "commit_hash": "1c24f1d74ba95ea985b50bdc001ce96c813229aa",
        "repo": "samuelcolvin/pydantic",
        "commit_url": "https://github.com/samuelcolvin/pydantic/commit/1c24f1d74ba95ea985b50bdc001ce96c813229aa",
        "files": [
          "changes/2776-samuelcolvin.md",
          "pydantic/datetime_parse.py",
          "tests/test_datetime_parse.py"
        ],
        "message": "Merge pull request from GHSA-5jqp-qgf6-3pvh\n\n* fix infinite loop in datetime parsing\n\n* add change description\n\n* switch to set a max datetime number",
        "before_after_code_files": [
          "pydantic/datetime_parse.py||pydantic/datetime_parse.py",
          "tests/test_datetime_parse.py||tests/test_datetime_parse.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "pydantic/datetime_parse.py||pydantic/datetime_parse.py",
            "tests/test_datetime_parse.py||tests/test_datetime_parse.py"
          ],
          "candidate": [
            "pydantic/datetime_parse.py||pydantic/datetime_parse.py",
            "tests/test_datetime_parse.py||tests/test_datetime_parse.py"
          ]
        }
      },
      "candidate_diff": {
        "pydantic/datetime_parse.py||pydantic/datetime_parse.py": [
          "File: pydantic/datetime_parse.py -> pydantic/datetime_parse.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "58: # if greater than this, the number is in ms, if less than or equal it's in seconds",
          "59: # (in seconds this is 11th October 2603, in ms it's 20th August 1970)",
          "60: MS_WATERSHED = int(2e10)",
          "61: StrBytesIntFloat = Union[str, bytes, int, float]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61: # slightly more than datetime.max in ns - (datetime.max - EPOCH).total_seconds() * 1e9",
          "62: MAX_NUMBER = int(3e20)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75: def from_unix_seconds(seconds: Union[int, float]) -> datetime:",
          "76:     while abs(seconds) > MS_WATERSHED:",
          "77:         seconds /= 1000",
          "78:     dt = EPOCH + timedelta(seconds=seconds)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "78:     if seconds > MAX_NUMBER:",
          "79:         return datetime.max",
          "80:     elif seconds < -MAX_NUMBER:",
          "81:         return datetime.min",
          "",
          "---------------"
        ],
        "tests/test_datetime_parse.py||tests/test_datetime_parse.py": [
          "File: tests/test_datetime_parse.py -> tests/test_datetime_parse.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:         (1_549_316_052_104, date(2019, 2, 4)),  # nowish in ms",
          "43:         (1_549_316_052_104_324, date(2019, 2, 4)),  # nowish in \u03bcs",
          "44:         (1_549_316_052_104_324_096, date(2019, 2, 4)),  # nowish in ns",
          "45:     ],",
          "46: )",
          "47: def test_date_parsing(value, result):",
          "50:             parse_date(value)",
          "51:     else:",
          "52:         assert parse_date(value) == result",
          "",
          "[Removed Lines]",
          "48:     if result == errors.DateError:",
          "49:         with pytest.raises(errors.DateError):",
          "",
          "[Added Lines]",
          "45:         ('infinity', date(9999, 12, 31)),",
          "46:         ('inf', date(9999, 12, 31)),",
          "47:         (float('inf'), date(9999, 12, 31)),",
          "48:         ('infinity ', date(9999, 12, 31)),",
          "49:         (int('1' + '0' * 100), date(9999, 12, 31)),",
          "50:         (1e1000, date(9999, 12, 31)),",
          "51:         ('-infinity', date(1, 1, 1)),",
          "52:         ('-inf', date(1, 1, 1)),",
          "53:         ('nan', ValueError),",
          "57:     if type(result) == type and issubclass(result, Exception):",
          "58:         with pytest.raises(result):",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "123:         (1_549_316_052_104, datetime(2019, 2, 4, 21, 34, 12, 104_000, tzinfo=timezone.utc)),  # nowish in ms",
          "124:         (1_549_316_052_104_324, datetime(2019, 2, 4, 21, 34, 12, 104_324, tzinfo=timezone.utc)),  # nowish in \u03bcs",
          "125:         (1_549_316_052_104_324_096, datetime(2019, 2, 4, 21, 34, 12, 104_324, tzinfo=timezone.utc)),  # nowish in ns",
          "126:     ],",
          "127: )",
          "128: def test_datetime_parsing(value, result):",
          "131:             parse_datetime(value)",
          "132:     else:",
          "133:         assert parse_datetime(value) == result",
          "",
          "[Removed Lines]",
          "129:     if result == errors.DateTimeError:",
          "130:         with pytest.raises(errors.DateTimeError):",
          "",
          "[Added Lines]",
          "135:         ('infinity', datetime(9999, 12, 31, 23, 59, 59, 999999)),",
          "136:         ('inf', datetime(9999, 12, 31, 23, 59, 59, 999999)),",
          "137:         ('inf ', datetime(9999, 12, 31, 23, 59, 59, 999999)),",
          "138:         (1e50, datetime(9999, 12, 31, 23, 59, 59, 999999)),",
          "139:         (float('inf'), datetime(9999, 12, 31, 23, 59, 59, 999999)),",
          "140:         ('-infinity', datetime(1, 1, 1, 0, 0)),",
          "141:         ('-inf', datetime(1, 1, 1, 0, 0)),",
          "142:         ('nan', ValueError),",
          "146:     if type(result) == type and issubclass(result, Exception):",
          "147:         with pytest.raises(result):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "251:         'type': 'value_error.unicodedecode',",
          "252:         'msg': \"'utf-8' codec can't decode byte 0x81 in position 0: invalid start byte\",",
          "253:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "273: def test_nan():",
          "274:     class Model(BaseModel):",
          "275:         dt: datetime",
          "276:         d: date",
          "278:     with pytest.raises(ValidationError) as exc_info:",
          "279:         Model(dt='nan', d='nan')",
          "280:     assert exc_info.value.errors() == [",
          "281:         {",
          "282:             'loc': ('dt',),",
          "283:             'msg': 'cannot convert float NaN to integer',",
          "284:             'type': 'value_error',",
          "285:         },",
          "286:         {",
          "287:             'loc': ('d',),",
          "288:             'msg': 'cannot convert float NaN to integer',",
          "289:             'type': 'value_error',",
          "290:         },",
          "291:     ]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "80e0dd3f752bef145dce12f160d262bb40ec8d47",
      "candidate_info": {
        "commit_hash": "80e0dd3f752bef145dce12f160d262bb40ec8d47",
        "repo": "samuelcolvin/pydantic",
        "commit_url": "https://github.com/samuelcolvin/pydantic/commit/80e0dd3f752bef145dce12f160d262bb40ec8d47",
        "files": [
          "changes/2776-samuelcolvin.md",
          "pydantic/datetime_parse.py",
          "tests/test_datetime_parse.py"
        ],
        "message": "Merge pull request from GHSA-5jqp-qgf6-3pvh\n\n* fix infinite loop in datetime parsing\n\n* add change description\n\n* switch to set a max datetime number",
        "before_after_code_files": [
          "pydantic/datetime_parse.py||pydantic/datetime_parse.py",
          "tests/test_datetime_parse.py||tests/test_datetime_parse.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "pydantic/datetime_parse.py||pydantic/datetime_parse.py",
            "tests/test_datetime_parse.py||tests/test_datetime_parse.py"
          ],
          "candidate": [
            "pydantic/datetime_parse.py||pydantic/datetime_parse.py",
            "tests/test_datetime_parse.py||tests/test_datetime_parse.py"
          ]
        }
      },
      "candidate_diff": {
        "pydantic/datetime_parse.py||pydantic/datetime_parse.py": [
          "File: pydantic/datetime_parse.py -> pydantic/datetime_parse.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "58: # if greater than this, the number is in ms, if less than or equal it's in seconds",
          "59: # (in seconds this is 11th October 2603, in ms it's 20th August 1970)",
          "60: MS_WATERSHED = int(2e10)",
          "61: StrBytesIntFloat = Union[str, bytes, int, float]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61: # slightly more than datetime.max in ns - (datetime.max - EPOCH).total_seconds() * 1e9",
          "62: MAX_NUMBER = int(3e20)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75: def from_unix_seconds(seconds: Union[int, float]) -> datetime:",
          "76:     while abs(seconds) > MS_WATERSHED:",
          "77:         seconds /= 1000",
          "78:     dt = EPOCH + timedelta(seconds=seconds)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "78:     if seconds > MAX_NUMBER:",
          "79:         return datetime.max",
          "80:     elif seconds < -MAX_NUMBER:",
          "81:         return datetime.min",
          "",
          "---------------"
        ],
        "tests/test_datetime_parse.py||tests/test_datetime_parse.py": [
          "File: tests/test_datetime_parse.py -> tests/test_datetime_parse.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:         (1_549_316_052_104, date(2019, 2, 4)),  # nowish in ms",
          "43:         (1_549_316_052_104_324, date(2019, 2, 4)),  # nowish in \u03bcs",
          "44:         (1_549_316_052_104_324_096, date(2019, 2, 4)),  # nowish in ns",
          "45:     ],",
          "46: )",
          "47: def test_date_parsing(value, result):",
          "50:             parse_date(value)",
          "51:     else:",
          "52:         assert parse_date(value) == result",
          "",
          "[Removed Lines]",
          "48:     if result == errors.DateError:",
          "49:         with pytest.raises(errors.DateError):",
          "",
          "[Added Lines]",
          "45:         ('infinity', date(9999, 12, 31)),",
          "46:         ('inf', date(9999, 12, 31)),",
          "47:         (float('inf'), date(9999, 12, 31)),",
          "48:         ('infinity ', date(9999, 12, 31)),",
          "49:         (int('1' + '0' * 100), date(9999, 12, 31)),",
          "50:         (1e1000, date(9999, 12, 31)),",
          "51:         ('-infinity', date(1, 1, 1)),",
          "52:         ('-inf', date(1, 1, 1)),",
          "53:         ('nan', ValueError),",
          "57:     if type(result) == type and issubclass(result, Exception):",
          "58:         with pytest.raises(result):",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "123:         (1_549_316_052_104, datetime(2019, 2, 4, 21, 34, 12, 104_000, tzinfo=timezone.utc)),  # nowish in ms",
          "124:         (1_549_316_052_104_324, datetime(2019, 2, 4, 21, 34, 12, 104_324, tzinfo=timezone.utc)),  # nowish in \u03bcs",
          "125:         (1_549_316_052_104_324_096, datetime(2019, 2, 4, 21, 34, 12, 104_324, tzinfo=timezone.utc)),  # nowish in ns",
          "126:     ],",
          "127: )",
          "128: def test_datetime_parsing(value, result):",
          "131:             parse_datetime(value)",
          "132:     else:",
          "133:         assert parse_datetime(value) == result",
          "",
          "[Removed Lines]",
          "129:     if result == errors.DateTimeError:",
          "130:         with pytest.raises(errors.DateTimeError):",
          "",
          "[Added Lines]",
          "135:         ('infinity', datetime(9999, 12, 31, 23, 59, 59, 999999)),",
          "136:         ('inf', datetime(9999, 12, 31, 23, 59, 59, 999999)),",
          "137:         ('inf ', datetime(9999, 12, 31, 23, 59, 59, 999999)),",
          "138:         (1e50, datetime(9999, 12, 31, 23, 59, 59, 999999)),",
          "139:         (float('inf'), datetime(9999, 12, 31, 23, 59, 59, 999999)),",
          "140:         ('-infinity', datetime(1, 1, 1, 0, 0)),",
          "141:         ('-inf', datetime(1, 1, 1, 0, 0)),",
          "142:         ('nan', ValueError),",
          "146:     if type(result) == type and issubclass(result, Exception):",
          "147:         with pytest.raises(result):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "251:         'type': 'value_error.unicodedecode',",
          "252:         'msg': \"'utf-8' codec can't decode byte 0x81 in position 0: invalid start byte\",",
          "253:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "273: def test_nan():",
          "274:     class Model(BaseModel):",
          "275:         dt: datetime",
          "276:         d: date",
          "278:     with pytest.raises(ValidationError) as exc_info:",
          "279:         Model(dt='nan', d='nan')",
          "280:     assert exc_info.value.errors() == [",
          "281:         {",
          "282:             'loc': ('dt',),",
          "283:             'msg': 'cannot convert float NaN to integer',",
          "284:             'type': 'value_error',",
          "285:         },",
          "286:         {",
          "287:             'loc': ('d',),",
          "288:             'msg': 'cannot convert float NaN to integer',",
          "289:             'type': 'value_error',",
          "290:         },",
          "291:     ]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bdde15b7b947c94ca00fd6eb92da8db390a13520",
      "candidate_info": {
        "commit_hash": "bdde15b7b947c94ca00fd6eb92da8db390a13520",
        "repo": "samuelcolvin/pydantic",
        "commit_url": "https://github.com/samuelcolvin/pydantic/commit/bdde15b7b947c94ca00fd6eb92da8db390a13520",
        "files": [
          "changes/2776-samuelcolvin.md",
          "pydantic/datetime_parse.py",
          "tests/test_datetime_parse.py"
        ],
        "message": "Merge pull request from GHSA-5jqp-qgf6-3pvh\n\n* fix infinite loop in datetime parsing\n\n* add change description\n\n* switch to set a max datetime number",
        "before_after_code_files": [
          "pydantic/datetime_parse.py||pydantic/datetime_parse.py",
          "tests/test_datetime_parse.py||tests/test_datetime_parse.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "pydantic/datetime_parse.py||pydantic/datetime_parse.py",
            "tests/test_datetime_parse.py||tests/test_datetime_parse.py"
          ],
          "candidate": [
            "pydantic/datetime_parse.py||pydantic/datetime_parse.py",
            "tests/test_datetime_parse.py||tests/test_datetime_parse.py"
          ]
        }
      },
      "candidate_diff": {
        "pydantic/datetime_parse.py||pydantic/datetime_parse.py": [
          "File: pydantic/datetime_parse.py -> pydantic/datetime_parse.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "60: # if greater than this, the number is in ms, if less than or equal it's in seconds",
          "61: # (in seconds this is 11th October 2603, in ms it's 20th August 1970)",
          "62: MS_WATERSHED = int(2e10)",
          "63: StrBytesIntFloat = Union[str, bytes, int, float]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63: # slightly more than datetime.max in ns - (datetime.max - EPOCH).total_seconds() * 1e9",
          "64: MAX_NUMBER = int(3e20)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77: def from_unix_seconds(seconds: Union[int, float]) -> datetime:",
          "78:     while abs(seconds) > MS_WATERSHED:",
          "79:         seconds /= 1000",
          "80:     dt = EPOCH + timedelta(seconds=seconds)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "80:     if seconds > MAX_NUMBER:",
          "81:         return datetime.max",
          "82:     elif seconds < -MAX_NUMBER:",
          "83:         return datetime.min",
          "",
          "---------------"
        ],
        "tests/test_datetime_parse.py||tests/test_datetime_parse.py": [
          "File: tests/test_datetime_parse.py -> tests/test_datetime_parse.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:         (1_549_316_052_104, date(2019, 2, 4)),  # nowish in ms",
          "43:         (1_549_316_052_104_324, date(2019, 2, 4)),  # nowish in \u03bcs",
          "44:         (1_549_316_052_104_324_096, date(2019, 2, 4)),  # nowish in ns",
          "45:     ],",
          "46: )",
          "47: def test_date_parsing(value, result):",
          "50:             parse_date(value)",
          "51:     else:",
          "52:         assert parse_date(value) == result",
          "",
          "[Removed Lines]",
          "48:     if result == errors.DateError:",
          "49:         with pytest.raises(errors.DateError):",
          "",
          "[Added Lines]",
          "45:         ('infinity', date(9999, 12, 31)),",
          "46:         ('inf', date(9999, 12, 31)),",
          "47:         (float('inf'), date(9999, 12, 31)),",
          "48:         ('infinity ', date(9999, 12, 31)),",
          "49:         (int('1' + '0' * 100), date(9999, 12, 31)),",
          "50:         (1e1000, date(9999, 12, 31)),",
          "51:         ('-infinity', date(1, 1, 1)),",
          "52:         ('-inf', date(1, 1, 1)),",
          "53:         ('nan', ValueError),",
          "57:     if type(result) == type and issubclass(result, Exception):",
          "58:         with pytest.raises(result):",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "114:         (1_549_316_052_104, datetime(2019, 2, 4, 21, 34, 12, 104_000, tzinfo=timezone.utc)),  # nowish in ms",
          "115:         (1_549_316_052_104_324, datetime(2019, 2, 4, 21, 34, 12, 104_324, tzinfo=timezone.utc)),  # nowish in \u03bcs",
          "116:         (1_549_316_052_104_324_096, datetime(2019, 2, 4, 21, 34, 12, 104_324, tzinfo=timezone.utc)),  # nowish in ns",
          "117:     ],",
          "118: )",
          "119: def test_datetime_parsing(value, result):",
          "122:             parse_datetime(value)",
          "123:     else:",
          "124:         assert parse_datetime(value) == result",
          "",
          "[Removed Lines]",
          "120:     if result == errors.DateTimeError:",
          "121:         with pytest.raises(errors.DateTimeError):",
          "",
          "[Added Lines]",
          "126:         ('infinity', datetime(9999, 12, 31, 23, 59, 59, 999999)),",
          "127:         ('inf', datetime(9999, 12, 31, 23, 59, 59, 999999)),",
          "128:         ('inf ', datetime(9999, 12, 31, 23, 59, 59, 999999)),",
          "129:         (1e50, datetime(9999, 12, 31, 23, 59, 59, 999999)),",
          "130:         (float('inf'), datetime(9999, 12, 31, 23, 59, 59, 999999)),",
          "131:         ('-infinity', datetime(1, 1, 1, 0, 0)),",
          "132:         ('-inf', datetime(1, 1, 1, 0, 0)),",
          "133:         ('nan', ValueError),",
          "137:     if type(result) == type and issubclass(result, Exception):",
          "138:         with pytest.raises(result):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "242:         'type': 'value_error.unicodedecode',",
          "243:         'msg': \"'utf-8' codec can't decode byte 0x81 in position 0: invalid start byte\",",
          "244:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "264: def test_nan():",
          "265:     class Model(BaseModel):",
          "266:         dt: datetime",
          "267:         d: date",
          "269:     with pytest.raises(ValidationError) as exc_info:",
          "270:         Model(dt='nan', d='nan')",
          "271:     assert exc_info.value.errors() == [",
          "272:         {",
          "273:             'loc': ('dt',),",
          "274:             'msg': 'cannot convert float NaN to integer',",
          "275:             'type': 'value_error',",
          "276:         },",
          "277:         {",
          "278:             'loc': ('d',),",
          "279:             'msg': 'cannot convert float NaN to integer',",
          "280:             'type': 'value_error',",
          "281:         },",
          "282:     ]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
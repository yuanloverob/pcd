{
  "cve_id": "CVE-2021-40823",
  "cve_desc": "A logic error in the room key sharing functionality of matrix-js-sdk (aka Matrix Javascript SDK) before 12.4.1 allows a malicious Matrix homeserver present in an encrypted room to steal room encryption keys (via crafted Matrix protocol messages) that were originally sent by affected Matrix clients participating in that room. This allows the homeserver to decrypt end-to-end encrypted messages sent by affected clients.",
  "repo": "matrix-org/matrix-js-sdk",
  "patch_hash": "894c24880da0e1cc81818f51c0db80e3c9fb2be9",
  "patch_info": {
    "commit_hash": "894c24880da0e1cc81818f51c0db80e3c9fb2be9",
    "repo": "matrix-org/matrix-js-sdk",
    "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/894c24880da0e1cc81818f51c0db80e3c9fb2be9",
    "files": [
      "src/crypto/algorithms/megolm.ts"
    ],
    "message": "Verify target device key on reshare",
    "before_after_code_files": [
      "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
    ]
  },
  "patch_diff": {
    "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
      "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
      "--- Hunk 1 ---",
      "[Context before]",
      "101: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "104: interface SharedWithData {",
      "106:     deviceKey: string;",
      "108:     messageIndex: number;",
      "109: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "120: class OutboundSessionInfo {",
      "121:     public useCount = 0;",
      "122:     public creationTime: number;",
      "124:     public blockedDevicesNotified: Record<string, Record<string, boolean>> = {};",
      "126:     constructor(public readonly sessionId: string, public readonly sharedHistory = false) {",
      "",
      "[Removed Lines]",
      "123:     public sharedWithDevices: Record<string, Record<string, number>> = {};",
      "",
      "[Added Lines]",
      "130:     public sharedWithDevices: Record<string, Record<string, SharedWithData>> = {};",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "150:         return false;",
      "151:     }",
      "154:         if (!this.sharedWithDevices[userId]) {",
      "155:             this.sharedWithDevices[userId] = {};",
      "156:         }",
      "158:     }",
      "160:     public markNotifiedBlockedDevice(userId: string, deviceId: string): void {",
      "",
      "[Removed Lines]",
      "153:     public markSharedWithDevice(userId: string, deviceId: string, chainIndex: number): void {",
      "157:         this.sharedWithDevices[userId][deviceId] = chainIndex;",
      "",
      "[Added Lines]",
      "160:     public markSharedWithDevice(userId: string, deviceId: string, deviceKey: string, chainIndex: number): void {",
      "164:         this.sharedWithDevices[userId][deviceId] = { deviceKey, messageIndex: chainIndex };",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "572:         payload: IPayload,",
      "573:     ): Promise<void> {",
      "574:         const contentMap = {};",
      "576:         const promises = [];",
      "577:         for (let i = 0; i < userDeviceMap.length; i++) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "582:         const deviceInfoByDeviceId = new Map<string, DeviceInfo>();",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "584:             const userId = val.userId;",
      "585:             const deviceInfo = val.deviceInfo;",
      "586:             const deviceId = deviceInfo.deviceId;",
      "588:             if (!contentMap[userId]) {",
      "589:                 contentMap[userId] = {};",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "595:             deviceInfoByDeviceId.set(deviceId, deviceInfo);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "636:                 for (const userId of Object.keys(contentMap)) {",
      "637:                     for (const deviceId of Object.keys(contentMap[userId])) {",
      "638:                         session.markSharedWithDevice(",
      "640:                         );",
      "641:                     }",
      "642:                 }",
      "",
      "[Removed Lines]",
      "639:                             userId, deviceId, chainIndex,",
      "",
      "[Added Lines]",
      "648:                             userId,",
      "649:                             deviceId,",
      "650:                             deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
      "651:                             chainIndex,",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "719:             logger.debug(`megolm session ${sessionId} never shared with user ${userId}`);",
      "720:             return;",
      "721:         }",
      "724:             logger.debug(",
      "725:                 \"megolm session ID \" + sessionId + \" never shared with device \" +",
      "726:                 userId + \":\" + device.deviceId,",
      "",
      "[Removed Lines]",
      "722:         const sentChainIndex = obSessionInfo.sharedWithDevices[userId][device.deviceId];",
      "723:         if (sentChainIndex === undefined) {",
      "",
      "[Added Lines]",
      "734:         const sessionSharedData = obSessionInfo.sharedWithDevices[userId][device.deviceId];",
      "735:         if (sessionSharedData === undefined) {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "728:             return;",
      "729:         }",
      "733:         const key = await this.olmDevice.getInboundGroupSessionKey(",
      "735:         );",
      "737:         if (!key) {",
      "",
      "[Removed Lines]",
      "734:             this.roomId, senderKey, sessionId, sentChainIndex,",
      "",
      "[Added Lines]",
      "743:         if (sessionSharedData.deviceKey !== device.getIdentityKey()) {",
      "744:             logger.warn(",
      "745:                 `Session has been shared with device ${device.deviceId} but with identity ` +",
      "746:                 `key ${sessionSharedData.deviceKey}. Key is now ${device.getIdentityKey()}!`,",
      "747:             );",
      "748:             return;",
      "749:         }",
      "754:             this.roomId, senderKey, sessionId, sessionSharedData.messageIndex,",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "882:             const deviceId = deviceInfo.deviceId;",
      "884:             session.markSharedWithDevice(",
      "886:             );",
      "887:         }",
      "",
      "[Removed Lines]",
      "885:                 userId, deviceId, key.chain_index,",
      "",
      "[Added Lines]",
      "905:                 userId, deviceId, deviceInfo.getIdentityKey(), key.chain_index,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "aa94d5d95c732b7a08287eafbd220424771a6486",
      "candidate_info": {
        "commit_hash": "aa94d5d95c732b7a08287eafbd220424771a6486",
        "repo": "matrix-org/matrix-js-sdk",
        "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/aa94d5d95c732b7a08287eafbd220424771a6486",
        "files": [
          "src/crypto/algorithms/megolm.ts"
        ],
        "message": "Assume per-user deviceID uniqueness in encryptAndSendKeysToDevices (#2136)\n\n* Segment recorded device info by user ID when tracking key shares.\n\nFixes #2135.\n\n* address review feedback\n\n* fix userIdDeviceInfo\n\nCo-authored-by: Denis Kasak <dkasak@termina.org.uk>\nCo-authored-by: Michael Telatynski <7t3chguy@gmail.com>",
        "before_after_code_files": [
          "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ],
          "candidate": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ]
        }
      },
      "candidate_diff": {
        "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
          "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "592:         payload: IPayload,",
          "593:     ): Promise<void> {",
          "594:         const contentMap: Record<string, Record<string, IEncryptedContent>> = {};",
          "597:         const promises: Promise<unknown>[] = [];",
          "598:         for (let i = 0; i < userDeviceMap.length; i++) {",
          "",
          "[Removed Lines]",
          "595:         const deviceInfoByDeviceId = new Map<string, DeviceInfo>();",
          "",
          "[Added Lines]",
          "596:         const deviceInfoByUserIdAndDeviceId = new Map<string, Map<string, DeviceInfo>>();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "605:             const userId = val.userId;",
          "606:             const deviceInfo = val.deviceInfo;",
          "607:             const deviceId = deviceInfo.deviceId;",
          "610:             if (!contentMap[userId]) {",
          "611:                 contentMap[userId] = {};",
          "",
          "[Removed Lines]",
          "608:             deviceInfoByDeviceId.set(deviceId, deviceInfo);",
          "",
          "[Added Lines]",
          "611:             let userIdDeviceInfo = deviceInfoByUserIdAndDeviceId.get(userId);",
          "613:             if (userIdDeviceInfo === undefined) {",
          "614:                 userIdDeviceInfo = new Map<string, DeviceInfo>();",
          "616:                 deviceInfoByUserIdAndDeviceId.set(userId, userIdDeviceInfo);",
          "617:             }",
          "620:             userIdDeviceInfo.set(deviceId, deviceInfo);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "660:                         session.markSharedWithDevice(",
          "661:                             userId,",
          "662:                             deviceId,",
          "664:                             chainIndex,",
          "665:                         );",
          "666:                     }",
          "",
          "[Removed Lines]",
          "663:                             deviceInfoByDeviceId.get(deviceId).getIdentityKey(),",
          "",
          "[Added Lines]",
          "675:                             deviceInfoByUserIdAndDeviceId.get(userId).get(deviceId).getIdentityKey(),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dbede36085d38186163138a55d29936e53f588d4",
      "candidate_info": {
        "commit_hash": "dbede36085d38186163138a55d29936e53f588d4",
        "repo": "matrix-org/matrix-js-sdk",
        "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/dbede36085d38186163138a55d29936e53f588d4",
        "files": [
          "src/crypto/algorithms/megolm.ts"
        ],
        "message": "handle promises normally now tests are fixed",
        "before_after_code_files": [
          "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ],
          "candidate": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ]
        }
      },
      "candidate_diff": {
        "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
          "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "578:         userDeviceMap: IOlmDevice[],",
          "579:         payload: IPayload,",
          "580:     ): Promise<void> {",
          "582:             userDeviceMap,",
          "583:             payload,",
          "588:             const { contentMap, deviceInfoByDeviceId } = result;",
          "590:             for (const userId of Object.keys(contentMap)) {",
          "",
          "[Removed Lines]",
          "581:         const p = this.crypto.encryptAndSendToDevices(",
          "584:         );",
          "585:         if (!p) return;",
          "586:         return p.then((result) => {",
          "587:             if (!result) return;",
          "",
          "[Added Lines]",
          "581:         return this.crypto.encryptAndSendToDevices(",
          "584:         ).then((result) => {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "597:                     );",
          "598:                 }",
          "599:             }",
          "600:         });",
          "601:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "597:         }).catch((error) => {",
          "598:             console.error(\"failed to encryptAndSendToDevices\", error);",
          "599:             throw error;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7e784da00a6dc3fa28afd3d61d33d32ab507a882",
      "candidate_info": {
        "commit_hash": "7e784da00a6dc3fa28afd3d61d33d32ab507a882",
        "repo": "matrix-org/matrix-js-sdk",
        "commit_url": "https://github.com/matrix-org/matrix-js-sdk/commit/7e784da00a6dc3fa28afd3d61d33d32ab507a882",
        "files": [
          "package.json",
          "spec/unit/crypto/algorithms/megolm.spec.ts",
          "spec/unit/queueToDevice.spec.ts",
          "src/ToDeviceMessageQueue.ts",
          "src/client.ts",
          "src/crypto/algorithms/megolm.ts",
          "src/models/ToDeviceMessage.ts",
          "src/scheduler.ts",
          "src/store/index.ts",
          "src/store/indexeddb-backend.ts",
          "src/store/indexeddb-local-backend.ts",
          "src/store/indexeddb-remote-backend.ts",
          "src/store/indexeddb-store-worker.ts",
          "src/store/indexeddb.ts",
          "src/store/memory.ts",
          "src/store/stub.ts",
          "yarn.lock"
        ],
        "message": "Retry to-device messages (#2549)\n\n* Retry to-device messages\n\nThis adds a queueToDevice API alongside sendToDevice which is a\nmuch higher-level API that adds the messages to a queue, stored in\npersistent storage, and retries them periodically. Also converts\nsending of megolm keys to use the new API.\n\nOther uses of sendToDevice are nopt converted in this PR, but could\nbe later.\n\nRequires https://github.com/matrix-org/matrix-mock-request/pull/17\n\n* Bump matrix-mock-request\n\n* Add more waits to make indexeddb tests pass\n\n* Switch some test expectations to queueToDevice\n\n* Stop straight away if the client has been stopped\n\nHopefully will fix tests being flakey and logging after tests have\nfinished.\n\n* Add return types & fix constant usage\n\n* Fix return type\n\nCo-authored-by: Germain <germains@element.io>\n\n* Fix return type\n\nCo-authored-by: Germain <germains@element.io>\n\n* Fix return type\n\nCo-authored-by: Germain <germains@element.io>\n\n* Stop the client in all test cases\n\nCo-authored-by: Germain <germains@element.io>",
        "before_after_code_files": [
          "spec/unit/crypto/algorithms/megolm.spec.ts||spec/unit/crypto/algorithms/megolm.spec.ts",
          "spec/unit/queueToDevice.spec.ts||spec/unit/queueToDevice.spec.ts",
          "src/ToDeviceMessageQueue.ts||src/ToDeviceMessageQueue.ts",
          "src/client.ts||src/client.ts",
          "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts",
          "src/models/ToDeviceMessage.ts||src/models/ToDeviceMessage.ts",
          "src/scheduler.ts||src/scheduler.ts",
          "src/store/index.ts||src/store/index.ts",
          "src/store/indexeddb-backend.ts||src/store/indexeddb-backend.ts",
          "src/store/indexeddb-local-backend.ts||src/store/indexeddb-local-backend.ts",
          "src/store/indexeddb-remote-backend.ts||src/store/indexeddb-remote-backend.ts",
          "src/store/indexeddb-store-worker.ts||src/store/indexeddb-store-worker.ts",
          "src/store/indexeddb.ts||src/store/indexeddb.ts",
          "src/store/memory.ts||src/store/memory.ts",
          "src/store/stub.ts||src/store/stub.ts",
          "yarn.lock||yarn.lock"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ],
          "candidate": [
            "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts"
          ]
        }
      },
      "candidate_diff": {
        "spec/unit/crypto/algorithms/megolm.spec.ts||spec/unit/crypto/algorithms/megolm.spec.ts": [
          "File: spec/unit/crypto/algorithms/megolm.spec.ts -> spec/unit/crypto/algorithms/megolm.spec.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:         mockBaseApis = {",
          "60:             claimOneTimeKeys: jest.fn(),",
          "61:             sendToDevice: jest.fn(),",
          "62:         } as unknown as MockedObject<MatrixClient>;",
          "64:         const cryptoStore = new MemoryCryptoStore();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62:             queueToDevice: jest.fn(),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "179:                 });",
          "181:                 mockBaseApis.sendToDevice.mockReset();",
          "184:                 megolmDecryption.shareKeysWithDevice(keyRequest);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "183:                 mockBaseApis.queueToDevice.mockReset();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "324:                     },",
          "325:                 });",
          "326:                 mockBaseApis.sendToDevice.mockResolvedValue(undefined);",
          "328:                 aliceDeviceInfo = {",
          "329:                     deviceId: 'aliceDevice',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "329:                 mockBaseApis.queueToDevice.mockResolvedValue(undefined);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "403:                 expect(mockCrypto.downloadKeys).toHaveBeenCalledWith(",
          "404:                     ['@alice:home.server'], false,",
          "405:                 );",
          "407:                 expect(mockBaseApis.claimOneTimeKeys).toHaveBeenCalledWith(",
          "408:                     [['@alice:home.server', 'aliceDevice']], 'signed_curve25519', 2000,",
          "409:                 );",
          "",
          "[Removed Lines]",
          "406:                 expect(mockBaseApis.sendToDevice).toHaveBeenCalled();",
          "",
          "[Added Lines]",
          "409:                 expect(mockBaseApis.queueToDevice).toHaveBeenCalled();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "446:                     'YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWI',",
          "447:                 );",
          "450:                 await megolmEncryption.reshareKeyWithDevice(",
          "451:                     olmDevice.deviceCurve25519Key,",
          "452:                     ct1.session_id,",
          "",
          "[Removed Lines]",
          "449:                 mockBaseApis.sendToDevice.mockClear();",
          "",
          "[Added Lines]",
          "452:                 mockBaseApis.queueToDevice.mockClear();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "454:                     aliceDeviceInfo,",
          "455:                 );",
          "458:             });",
          "459:         });",
          "460:     });",
          "",
          "[Removed Lines]",
          "457:                 expect(mockBaseApis.sendToDevice).not.toHaveBeenCalled();",
          "",
          "[Added Lines]",
          "460:                 expect(mockBaseApis.queueToDevice).not.toHaveBeenCalled();",
          "",
          "---------------"
        ],
        "spec/unit/queueToDevice.spec.ts||spec/unit/queueToDevice.spec.ts": [
          "File: spec/unit/queueToDevice.spec.ts -> spec/unit/queueToDevice.spec.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: Copyright 2022 The Matrix.org Foundation C.I.C.",
          "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
          "5: you may not use this file except in compliance with the License.",
          "6: You may obtain a copy of the License at",
          "8:     http://www.apache.org/licenses/LICENSE-2.0",
          "10: Unless required by applicable law or agreed to in writing, software",
          "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
          "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "13: See the License for the specific language governing permissions and",
          "14: limitations under the License.",
          "17: import MockHttpBackend from 'matrix-mock-request';",
          "18: import { indexedDB as fakeIndexedDB } from 'fake-indexeddb';",
          "20: import { IHttpOpts, IndexedDBStore, MatrixEvent, MemoryStore, Room } from \"../../src\";",
          "21: import { MatrixClient } from \"../../src/client\";",
          "22: import { ToDeviceBatch } from '../../src/models/ToDeviceMessage';",
          "23: import { logger } from '../../src/logger';",
          "24: import { IStore } from '../../src/store';",
          "26: const FAKE_USER = \"@alice:example.org\";",
          "27: const FAKE_DEVICE_ID = \"AAAAAAAA\";",
          "28: const FAKE_PAYLOAD = {",
          "29:     \"foo\": 42,",
          "30: };",
          "31: const EXPECTED_BODY = {",
          "32:     messages: {",
          "33:         [FAKE_USER]: {",
          "34:             [FAKE_DEVICE_ID]: FAKE_PAYLOAD,",
          "35:         },",
          "36:     },",
          "37: };",
          "39: const FAKE_MSG = {",
          "40:     userId: FAKE_USER,",
          "41:     deviceId: FAKE_DEVICE_ID,",
          "42:     payload: FAKE_PAYLOAD,",
          "43: };",
          "45: enum StoreType {",
          "46:     Memory = 'Memory',",
          "47:     IndexedDB = 'IndexedDB',",
          "48: }",
          "56: const realSetTimeout = setTimeout;",
          "57: function flushPromises() {",
          "58:     return new Promise(r => {",
          "59:         realSetTimeout(r, 1);",
          "60:     });",
          "61: }",
          "63: async function flushAndRunTimersUntil(cond: () => boolean) {",
          "64:     while (!cond()) {",
          "65:         await flushPromises();",
          "66:         if (cond()) break;",
          "67:         jest.advanceTimersToNextTimer();",
          "68:     }",
          "69: }",
          "71: describe.each([",
          "72:     [StoreType.Memory], [StoreType.IndexedDB],",
          "73: ])(\"queueToDevice (%s store)\", function(storeType) {",
          "74:     let httpBackend: MockHttpBackend;",
          "75:     let client: MatrixClient;",
          "77:     beforeEach(async function() {",
          "78:         httpBackend = new MockHttpBackend();",
          "80:         let store: IStore;",
          "81:         if (storeType === StoreType.IndexedDB) {",
          "82:             const idbStore = new IndexedDBStore({ indexedDB: fakeIndexedDB });",
          "83:             await idbStore.startup();",
          "84:             store = idbStore;",
          "85:         } else {",
          "86:             store = new MemoryStore();",
          "87:         }",
          "89:         client = new MatrixClient({",
          "90:             baseUrl: \"https://my.home.server\",",
          "91:             accessToken: \"my.access.token\",",
          "92:             request: httpBackend.requestFn as IHttpOpts[\"request\"],",
          "93:             store,",
          "94:         });",
          "95:     });",
          "97:     afterEach(function() {",
          "98:         jest.useRealTimers();",
          "99:         client.stopClient();",
          "100:     });",
          "102:     it(\"sends a to-device message\", async function() {",
          "103:         httpBackend.when(",
          "104:             \"PUT\", \"/sendToDevice/org.example.foo/\",",
          "105:         ).check((request) => {",
          "106:             expect(request.data).toEqual(EXPECTED_BODY);",
          "107:         }).respond(200, {});",
          "109:         await client.queueToDevice({",
          "110:             eventType: \"org.example.foo\",",
          "111:             batch: [",
          "112:                 FAKE_MSG,",
          "113:             ],",
          "114:         });",
          "116:         await httpBackend.flushAllExpected();",
          "117:     });",
          "119:     it(\"retries on error\", async function() {",
          "120:         jest.useFakeTimers();",
          "122:         httpBackend.when(",
          "123:             \"PUT\", \"/sendToDevice/org.example.foo/\",",
          "124:         ).respond(500);",
          "126:         httpBackend.when(",
          "127:             \"PUT\", \"/sendToDevice/org.example.foo/\",",
          "128:         ).check((request) => {",
          "129:             expect(request.data).toEqual(EXPECTED_BODY);",
          "130:         }).respond(200, {});",
          "132:         await client.queueToDevice({",
          "133:             eventType: \"org.example.foo\",",
          "134:             batch: [",
          "135:                 FAKE_MSG,",
          "136:             ],",
          "137:         });",
          "138:         await flushAndRunTimersUntil(() => httpBackend.requests.length > 0);",
          "139:         expect(httpBackend.flushSync(null, 1)).toEqual(1);",
          "141:         await flushAndRunTimersUntil(() => httpBackend.requests.length > 0);",
          "143:         expect(httpBackend.flushSync(null, 1)).toEqual(1);",
          "144:     });",
          "146:     it(\"stops retrying on 4xx errors\", async function() {",
          "147:         jest.useFakeTimers();",
          "149:         httpBackend.when(",
          "150:             \"PUT\", \"/sendToDevice/org.example.foo/\",",
          "151:         ).respond(400);",
          "153:         await client.queueToDevice({",
          "154:             eventType: \"org.example.foo\",",
          "155:             batch: [",
          "156:                 FAKE_MSG,",
          "157:             ],",
          "158:         });",
          "159:         await flushAndRunTimersUntil(() => httpBackend.requests.length > 0);",
          "160:         expect(httpBackend.flushSync(null, 1)).toEqual(1);",
          "165:         let tries = 0;",
          "166:         await flushAndRunTimersUntil(() => ++tries === 10);",
          "168:         expect(httpBackend.requests.length).toEqual(0);",
          "169:     });",
          "171:     it(\"honours ratelimiting\", async function() {",
          "172:         jest.useFakeTimers();",
          "176:         const retryDelay = 279 * 1000;",
          "178:         httpBackend.when(",
          "179:             \"PUT\", \"/sendToDevice/org.example.foo/\",",
          "180:         ).respond(429, {",
          "181:             errcode: \"M_LIMIT_EXCEEDED\",",
          "182:             retry_after_ms: retryDelay,",
          "183:         });",
          "185:         httpBackend.when(",
          "186:             \"PUT\", \"/sendToDevice/org.example.foo/\",",
          "187:         ).respond(200, {});",
          "189:         await client.queueToDevice({",
          "190:             eventType: \"org.example.foo\",",
          "191:             batch: [",
          "192:                 FAKE_MSG,",
          "193:             ],",
          "194:         });",
          "195:         await flushAndRunTimersUntil(() => httpBackend.requests.length > 0);",
          "196:         expect(httpBackend.flushSync(null, 1)).toEqual(1);",
          "197:         await flushPromises();",
          "199:         logger.info(\"Advancing clock to just before expected retry time...\");",
          "201:         jest.advanceTimersByTime(retryDelay - 1000);",
          "202:         await flushPromises();",
          "204:         expect(httpBackend.requests.length).toEqual(0);",
          "206:         logger.info(\"Advancing clock past expected retry time...\");",
          "208:         jest.advanceTimersByTime(2000);",
          "209:         await flushPromises();",
          "211:         expect(httpBackend.flushSync(null, 1)).toEqual(1);",
          "212:     });",
          "214:     it(\"retries on retryImmediately()\", async function() {",
          "215:         httpBackend.when(\"GET\", \"/_matrix/client/versions\").respond(200, {",
          "216:             versions: [\"r0.0.1\"],",
          "217:         });",
          "219:         await Promise.all([client.startClient(), httpBackend.flush(null, 1, 20)]);",
          "221:         httpBackend.when(",
          "222:             \"PUT\", \"/sendToDevice/org.example.foo/\",",
          "223:         ).respond(500);",
          "225:         httpBackend.when(",
          "226:             \"PUT\", \"/sendToDevice/org.example.foo/\",",
          "227:         ).respond(200, {});",
          "229:         await client.queueToDevice({",
          "230:             eventType: \"org.example.foo\",",
          "231:             batch: [",
          "232:                 FAKE_MSG,",
          "233:             ],",
          "234:         });",
          "235:         expect(await httpBackend.flush(null, 1, 1)).toEqual(1);",
          "236:         await flushPromises();",
          "238:         client.retryImmediately();",
          "240:         expect(await httpBackend.flush(null, 1, 20)).toEqual(1);",
          "241:     });",
          "243:     it(\"retries on when client is started\", async function() {",
          "244:         httpBackend.when(\"GET\", \"/_matrix/client/versions\").respond(200, {",
          "245:             versions: [\"r0.0.1\"],",
          "246:         });",
          "248:         await Promise.all([client.startClient(), httpBackend.flush(\"/_matrix/client/versions\", 1, 20)]);",
          "250:         httpBackend.when(",
          "251:             \"PUT\", \"/sendToDevice/org.example.foo/\",",
          "252:         ).respond(500);",
          "254:         httpBackend.when(",
          "255:             \"PUT\", \"/sendToDevice/org.example.foo/\",",
          "256:         ).respond(200, {});",
          "258:         await client.queueToDevice({",
          "259:             eventType: \"org.example.foo\",",
          "260:             batch: [",
          "261:                 FAKE_MSG,",
          "262:             ],",
          "263:         });",
          "264:         expect(await httpBackend.flush(null, 1, 1)).toEqual(1);",
          "265:         await flushPromises();",
          "267:         client.stopClient();",
          "268:         await Promise.all([client.startClient(), httpBackend.flush(\"/_matrix/client/versions\", 1, 20)]);",
          "270:         expect(await httpBackend.flush(null, 1, 20)).toEqual(1);",
          "271:     });",
          "273:     it(\"retries when a message is retried\", async function() {",
          "274:         httpBackend.when(\"GET\", \"/_matrix/client/versions\").respond(200, {",
          "275:             versions: [\"r0.0.1\"],",
          "276:         });",
          "278:         await Promise.all([client.startClient(), httpBackend.flush(null, 1, 20)]);",
          "280:         httpBackend.when(",
          "281:             \"PUT\", \"/sendToDevice/org.example.foo/\",",
          "282:         ).respond(500);",
          "284:         httpBackend.when(",
          "285:             \"PUT\", \"/sendToDevice/org.example.foo/\",",
          "286:         ).respond(200, {});",
          "288:         await client.queueToDevice({",
          "289:             eventType: \"org.example.foo\",",
          "290:             batch: [",
          "291:                 FAKE_MSG,",
          "292:             ],",
          "293:         });",
          "295:         expect(await httpBackend.flush(null, 1, 1)).toEqual(1);",
          "296:         await flushPromises();",
          "298:         const dummyEvent = new MatrixEvent({",
          "299:             event_id: \"!fake:example.org\",",
          "300:         });",
          "301:         const mockRoom = {",
          "302:             updatePendingEvent: jest.fn(),",
          "303:         } as unknown as Room;",
          "304:         client.resendEvent(dummyEvent, mockRoom);",
          "306:         expect(await httpBackend.flush(null, 1, 20)).toEqual(1);",
          "307:     });",
          "309:     it(\"splits many messages into multiple HTTP requests\", async function() {",
          "310:         const batch: ToDeviceBatch = {",
          "311:             eventType: \"org.example.foo\",",
          "312:             batch: [],",
          "313:         };",
          "315:         for (let i = 0; i <= 20; ++i) {",
          "316:             batch.batch.push({",
          "317:                 userId: `@user${i}:example.org`,",
          "318:                 deviceId: FAKE_DEVICE_ID,",
          "319:                 payload: FAKE_PAYLOAD,",
          "320:             });",
          "321:         }",
          "323:         httpBackend.when(",
          "324:             \"PUT\", \"/sendToDevice/org.example.foo/\",",
          "325:         ).check((request) => {",
          "326:             expect(Object.keys(request.data.messages).length).toEqual(20);",
          "327:         }).respond(200, {});",
          "329:         httpBackend.when(",
          "330:             \"PUT\", \"/sendToDevice/org.example.foo/\",",
          "331:         ).check((request) => {",
          "332:             expect(Object.keys(request.data.messages).length).toEqual(1);",
          "333:         }).respond(200, {});",
          "335:         await client.queueToDevice(batch);",
          "336:         await httpBackend.flushAllExpected();",
          "337:     });",
          "338: });",
          "",
          "---------------"
        ],
        "src/ToDeviceMessageQueue.ts||src/ToDeviceMessageQueue.ts": [
          "File: src/ToDeviceMessageQueue.ts -> src/ToDeviceMessageQueue.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: Copyright 2022 The Matrix.org Foundation C.I.C.",
          "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
          "5: you may not use this file except in compliance with the License.",
          "6: You may obtain a copy of the License at",
          "8:     http://www.apache.org/licenses/LICENSE-2.0",
          "10: Unless required by applicable law or agreed to in writing, software",
          "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
          "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "13: See the License for the specific language governing permissions and",
          "14: limitations under the License.",
          "17: import { logger } from \"./logger\";",
          "18: import { MatrixClient } from \"./matrix\";",
          "19: import { IndexedToDeviceBatch, ToDeviceBatch, ToDeviceBatchWithTxnId, ToDevicePayload } from \"./models/ToDeviceMessage\";",
          "20: import { MatrixScheduler } from \"./scheduler\";",
          "22: const MAX_BATCH_SIZE = 20;",
          "28: export class ToDeviceMessageQueue {",
          "29:     private sending = false;",
          "30:     private running = true;",
          "31:     private retryTimeout: number = null;",
          "32:     private retryAttempts = 0;",
          "34:     constructor(private client: MatrixClient) {",
          "35:     }",
          "37:     public start(): void {",
          "38:         this.running = true;",
          "39:         this.sendQueue();",
          "40:     }",
          "42:     public stop(): void {",
          "43:         this.running = false;",
          "44:         if (this.retryTimeout !== null) clearTimeout(this.retryTimeout);",
          "45:         this.retryTimeout = null;",
          "46:     }",
          "48:     public async queueBatch(batch: ToDeviceBatch): Promise<void> {",
          "49:         const batches: ToDeviceBatchWithTxnId[] = [];",
          "50:         for (let i = 0; i < batch.batch.length; i += MAX_BATCH_SIZE) {",
          "51:             batches.push({",
          "52:                 eventType: batch.eventType,",
          "53:                 batch: batch.batch.slice(i, i + MAX_BATCH_SIZE),",
          "54:                 txnId: this.client.makeTxnId(),",
          "55:             });",
          "56:         }",
          "58:         await this.client.store.saveToDeviceBatches(batches);",
          "59:         this.sendQueue();",
          "60:     }",
          "62:     public sendQueue = async (): Promise<void> => {",
          "63:         if (this.retryTimeout !== null) clearTimeout(this.retryTimeout);",
          "64:         this.retryTimeout = null;",
          "66:         if (this.sending || !this.running) return;",
          "68:         logger.debug(\"Attempting to send queued to-device messages\");",
          "70:         this.sending = true;",
          "71:         let headBatch;",
          "72:         try {",
          "73:             while (this.running) {",
          "74:                 headBatch = await this.client.store.getOldestToDeviceBatch();",
          "75:                 if (headBatch === null) break;",
          "76:                 await this.sendBatch(headBatch);",
          "77:                 await this.client.store.removeToDeviceBatch(headBatch.id);",
          "78:                 this.retryAttempts = 0;",
          "79:             }",
          "82:             if (!this.running) return;",
          "84:             logger.debug(\"All queued to-device messages sent\");",
          "85:         } catch (e) {",
          "86:             ++this.retryAttempts;",
          "89:             const retryDelay = MatrixScheduler.RETRY_BACKOFF_RATELIMIT(null, this.retryAttempts, e);",
          "90:             if (retryDelay === -1) {",
          "93:                 if (Math.floor(e.httpStatus / 100) === 4) {",
          "94:                     logger.error(\"Fatal error when sending to-device message - dropping to-device batch!\", e);",
          "95:                     await this.client.store.removeToDeviceBatch(headBatch.id);",
          "96:                 } else {",
          "97:                     logger.info(\"Automatic retry limit reached for to-device messages.\");",
          "98:                 }",
          "99:                 return;",
          "100:             }",
          "102:             logger.info(`Failed to send batch of to-device messages. Will retry in ${retryDelay}ms`, e);",
          "103:             this.retryTimeout = setTimeout(this.sendQueue, retryDelay);",
          "104:         } finally {",
          "105:             this.sending = false;",
          "106:         }",
          "107:     };",
          "112:     private async sendBatch(batch: IndexedToDeviceBatch): Promise<void> {",
          "113:         const contentMap: Record<string, Record<string, ToDevicePayload>> = {};",
          "114:         for (const item of batch.batch) {",
          "115:             if (!contentMap[item.userId]) {",
          "116:                 contentMap[item.userId] = {};",
          "117:             }",
          "118:             contentMap[item.userId][item.deviceId] = item.payload;",
          "119:         }",
          "121:         logger.info(`Sending batch of ${batch.batch.length} to-device messages with ID ${batch.id}`);",
          "123:         await this.client.sendToDevice(batch.eventType, contentMap, batch.txnId);",
          "124:     }",
          "125: }",
          "",
          "---------------"
        ],
        "src/client.ts||src/client.ts": [
          "File: src/client.ts -> src/client.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "194: import { SlidingSyncSdk } from \"./sliding-sync-sdk\";",
          "195: import { Thread, THREAD_RELATION_TYPE } from \"./models/thread\";",
          "196: import { MBeaconInfoEventContent, M_BEACON_INFO } from \"./@types/beacon\";",
          "198: export type Store = IStore;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "197: import { ToDeviceMessageQueue } from \"./ToDeviceMessageQueue\";",
          "198: import { ToDeviceBatch } from \"./models/ToDeviceMessage\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "939:     protected mediaHandler = new MediaHandler(this);",
          "940:     protected pendingEventEncryption = new Map<string, Promise<void>>();",
          "942:     constructor(opts: IMatrixClientCreateOpts) {",
          "943:         super();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "944:     private toDeviceMessageQueue: ToDeviceMessageQueue;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1034:         this.roomList = new RoomList(this.cryptoStore);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1040:         this.toDeviceMessageQueue = new ToDeviceMessageQueue(this);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1196:             }, 1000 * this.clientOpts.clientWellKnownPollPeriod);",
          "1197:             this.fetchClientWellKnown();",
          "1198:         }",
          "1199:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1206:         this.toDeviceMessageQueue.start();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1223:         if (this.clientWellKnownIntervalID !== undefined) {",
          "1224:             global.clearInterval(this.clientWellKnownIntervalID);",
          "1225:         }",
          "1226:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1235:         this.toDeviceMessageQueue.stop();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1566:     public retryImmediately(): boolean {",
          "1567:         return this.syncApi.retryImmediately();",
          "1568:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1580:         this.toDeviceMessageQueue.sendQueue();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3510:     public resendEvent(event: MatrixEvent, room: Room): Promise<ISendEventResponse> {",
          "3511:         this.updatePendingEventStatus(room, event, EventStatus.SENDING);",
          "3512:         return this.encryptAndSendEvent(room, event);",
          "3513:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3526:         this.toDeviceMessageQueue.sendQueue();",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "8726:         return this.http.authedRequest(undefined, Method.Put, path, undefined, body);",
          "8727:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8756:     public queueToDevice(batch: ToDeviceBatch): Promise<void> {",
          "8757:         return this.toDeviceMessageQueue.queueBatch(batch);",
          "8758:     }",
          "",
          "---------------"
        ],
        "src/crypto/algorithms/megolm.ts||src/crypto/algorithms/megolm.ts": [
          "File: src/crypto/algorithms/megolm.ts -> src/crypto/algorithms/megolm.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: import { logger } from '../../logger';",
          "24: import * as olmlib from \"../olmlib\";",
          "25: import {",
          "26:     DecryptionAlgorithm,",
          "27:     DecryptionError,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: import { EventType } from '../../@types/event';",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37: import { DeviceInfoMap } from \"../DeviceList\";",
          "38: import { MatrixEvent } from \"../..\";",
          "39: import { IEventDecryptionResult, IMegolmSessionData, IncomingRoomKeyRequest } from \"../index\";",
          "42: export function isRoomSharedHistory(room: Room): boolean {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "41: import { ToDeviceBatch, ToDeviceMessage } from '../../models/ToDeviceMessage';",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "609:         userDeviceMap: IOlmDevice[],",
          "610:         payload: IPayload,",
          "611:     ): Promise<void> {",
          "614:         const deviceInfoByUserIdAndDeviceId = new Map<string, Map<string, DeviceInfo>>();",
          "",
          "[Removed Lines]",
          "612:         const contentMap: Record<string, Record<string, IEncryptedContent>> = {};",
          "",
          "[Added Lines]",
          "614:         const toDeviceBatch: ToDeviceBatch = {",
          "615:             eventType: EventType.RoomMessageEncrypted,",
          "616:             batch: [],",
          "617:         };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "638:             userIdDeviceInfo.set(deviceId, deviceInfo);",
          "645:             promises.push(",
          "646:                 olmlib.encryptMessageForDevice(",
          "",
          "[Removed Lines]",
          "640:             if (!contentMap[userId]) {",
          "641:                 contentMap[userId] = {};",
          "642:             }",
          "643:             contentMap[userId][deviceId] = encryptedContent;",
          "",
          "[Added Lines]",
          "646:             toDeviceBatch.batch.push({",
          "647:                 userId,",
          "648:                 deviceId,",
          "649:                 payload: encryptedContent,",
          "650:             });",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "677:                 }",
          "678:             }",
          "697:                 }",
          "698:             });",
          "699:         });",
          "",
          "[Removed Lines]",
          "663:             for (const userId of Object.keys(contentMap)) {",
          "664:                 for (const deviceId of Object.keys(contentMap[userId])) {",
          "665:                     if (Object.keys(contentMap[userId][deviceId].ciphertext).length === 0) {",
          "666:                         logger.log(",
          "667:                             \"No ciphertext for device \" +",
          "668:                             userId + \":\" + deviceId + \": pruning\",",
          "669:                         );",
          "670:                         delete contentMap[userId][deviceId];",
          "671:                     }",
          "672:                 }",
          "674:                 if (Object.keys(contentMap[userId]).length === 0) {",
          "675:                     logger.log(\"Pruned all devices for user \" + userId);",
          "676:                     delete contentMap[userId];",
          "681:             if (Object.keys(contentMap).length === 0) {",
          "682:                 logger.log(\"No users left to send to: aborting\");",
          "683:                 return;",
          "684:             }",
          "686:             return this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap).then(() => {",
          "688:                 for (const userId of Object.keys(contentMap)) {",
          "689:                     for (const deviceId of Object.keys(contentMap[userId])) {",
          "690:                         session.markSharedWithDevice(",
          "691:                             userId,",
          "692:                             deviceId,",
          "693:                             deviceInfoByUserIdAndDeviceId.get(userId).get(deviceId).getIdentityKey(),",
          "694:                             chainIndex,",
          "695:                         );",
          "696:                     }",
          "",
          "[Added Lines]",
          "670:             const prunedBatch: ToDeviceMessage[] = [];",
          "671:             for (const msg of toDeviceBatch.batch) {",
          "672:                 if (Object.keys(msg.payload.ciphertext).length > 0) {",
          "673:                     prunedBatch.push(msg);",
          "674:                 } else {",
          "675:                     logger.log(",
          "676:                         \"No ciphertext for device \" +",
          "677:                         msg.userId + \":\" + msg.deviceId + \": pruning\",",
          "678:                     );",
          "682:             toDeviceBatch.batch = prunedBatch;",
          "684:             return this.baseApis.queueToDevice(toDeviceBatch).then(() => {",
          "686:                 for (const msg of toDeviceBatch.batch) {",
          "687:                     session.markSharedWithDevice(",
          "688:                         msg.userId,",
          "689:                         msg.deviceId,",
          "690:                         deviceInfoByUserIdAndDeviceId.get(msg.userId).get(msg.deviceId).getIdentityKey(),",
          "691:                         chainIndex,",
          "692:                     );",
          "",
          "---------------"
        ],
        "src/models/ToDeviceMessage.ts||src/models/ToDeviceMessage.ts": [
          "File: src/models/ToDeviceMessage.ts -> src/models/ToDeviceMessage.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: Copyright 2022 The Matrix.org Foundation C.I.C.",
          "4: Licensed under the Apache License, Version 2.0 (the \"License\");",
          "5: you may not use this file except in compliance with the License.",
          "6: You may obtain a copy of the License at",
          "8:     http://www.apache.org/licenses/LICENSE-2.0",
          "10: Unless required by applicable law or agreed to in writing, software",
          "11: distributed under the License is distributed on an \"AS IS\" BASIS,",
          "12: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "13: See the License for the specific language governing permissions and",
          "14: limitations under the License.",
          "17: export type ToDevicePayload = Record<string, any>;",
          "19: export interface ToDeviceMessage {",
          "20:     userId: string;",
          "21:     deviceId: string;",
          "22:     payload: ToDevicePayload;",
          "23: }",
          "25: export interface ToDeviceBatch {",
          "26:     eventType: string;",
          "27:     batch: ToDeviceMessage[];",
          "28: }",
          "31: export interface ToDeviceBatchWithTxnId extends ToDeviceBatch {",
          "32:     txnId: string;",
          "33: }",
          "36: export interface IndexedToDeviceBatch extends ToDeviceBatchWithTxnId {",
          "37:     id: number;",
          "38: }",
          "",
          "---------------"
        ],
        "src/scheduler.ts||src/scheduler.ts": [
          "File: src/scheduler.ts -> src/scheduler.ts"
        ],
        "src/store/index.ts||src/store/index.ts": [
          "File: src/store/index.ts -> src/store/index.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: import { IMinimalEvent, IRooms, ISyncResponse } from \"../sync-accumulator\";",
          "24: import { IStartClientOpts } from \"../client\";",
          "25: import { IStateEventWithRoomId } from \"../@types/search\";",
          "27: export interface ISavedSync {",
          "28:     nextBatch: string;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: import { IndexedToDeviceBatch, ToDeviceBatchWithTxnId } from \"../models/ToDeviceMessage\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "222:     getPendingEvents(roomId: string): Promise<Partial<IEvent>[]>;",
          "224:     setPendingEvents(roomId: string, events: Partial<IEvent>[]): Promise<void>;",
          "225: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "245:      saveToDeviceBatches(batch: ToDeviceBatchWithTxnId[]): Promise<void>;",
          "250:      getOldestToDeviceBatch(): Promise<IndexedToDeviceBatch>;",
          "255:      removeToDeviceBatch(id: number): Promise<void>;",
          "",
          "---------------"
        ],
        "src/store/indexeddb-backend.ts||src/store/indexeddb-backend.ts": [
          "File: src/store/indexeddb-backend.ts -> src/store/indexeddb-backend.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: import { ISavedSync } from \"./index\";",
          "18: import { IEvent, IStartClientOpts, IStateEventWithRoomId, ISyncResponse } from \"..\";",
          "20: export interface IIndexedDBBackend {",
          "21:     connect(): Promise<void>;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: import { IndexedToDeviceBatch, ToDeviceBatchWithTxnId } from \"../models/ToDeviceMessage\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "31:     getUserPresenceEvents(): Promise<UserTuple[]>;",
          "32:     getClientOptions(): Promise<IStartClientOpts>;",
          "33:     storeClientOptions(options: IStartClientOpts): Promise<void>;",
          "34: }",
          "36: export type UserTuple = [userId: string, presenceEvent: Partial<IEvent>];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35:     saveToDeviceBatches(batches: ToDeviceBatchWithTxnId[]): Promise<void>;",
          "36:     getOldestToDeviceBatch(): Promise<IndexedToDeviceBatch>;",
          "37:     removeToDeviceBatch(id: number): Promise<void>;",
          "",
          "---------------"
        ],
        "src/store/indexeddb-local-backend.ts||src/store/indexeddb-local-backend.ts": [
          "File: src/store/indexeddb-local-backend.ts -> src/store/indexeddb-local-backend.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: import { IStartClientOpts, IStateEventWithRoomId } from \"..\";",
          "22: import { ISavedSync } from \"./index\";",
          "23: import { IIndexedDBBackend, UserTuple } from \"./indexeddb-backend\";",
          "27: function createDatabase(db: IDBDatabase): void {",
          "",
          "[Removed Lines]",
          "25: const VERSION = 3;",
          "",
          "[Added Lines]",
          "24: import { IndexedToDeviceBatch, ToDeviceBatchWithTxnId } from \"../models/ToDeviceMessage\";",
          "26: const VERSION = 4;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "49:         { keyPath: [\"clobber\"] });",
          "50: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "53: function upgradeSchemaV4(db: IDBDatabase): void {",
          "54:     db.createObjectStore(\"to_device_queue\", { autoIncrement: true });",
          "55: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "112:     });",
          "113: }",
          "116:     return reqAsEventPromise(req).then((event) => req.result);",
          "117: }",
          "",
          "[Removed Lines]",
          "115: function reqAsCursorPromise(req: IDBRequest<IDBCursor | null>): Promise<IDBCursor> {",
          "",
          "[Added Lines]",
          "120: function reqAsCursorPromise<T>(req: IDBRequest<T>): Promise<T> {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "177:             if (oldVersion < 3) {",
          "178:                 upgradeSchemaV3(db);",
          "179:             }",
          "181:         };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "185:             if (oldVersion < 4) {",
          "186:                 upgradeSchemaV4(db);",
          "187:             }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "561:         }); // put == UPSERT",
          "562:         await txnAsPromise(txn);",
          "563:     }",
          "564: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "573:     public async saveToDeviceBatches(batches: ToDeviceBatchWithTxnId[]): Promise<void> {",
          "574:         const txn = this.db.transaction([\"to_device_queue\"], \"readwrite\");",
          "575:         const store = txn.objectStore(\"to_device_queue\");",
          "576:         for (const batch of batches) {",
          "577:             store.add(batch);",
          "578:         }",
          "579:         await txnAsPromise(txn);",
          "580:     }",
          "582:     public async getOldestToDeviceBatch(): Promise<IndexedToDeviceBatch | null> {",
          "583:         const txn = this.db.transaction([\"to_device_queue\"], \"readonly\");",
          "584:         const store = txn.objectStore(\"to_device_queue\");",
          "585:         const cursor = await reqAsCursorPromise(store.openCursor());",
          "586:         if (!cursor) return null;",
          "588:         const resultBatch = cursor.value as ToDeviceBatchWithTxnId;",
          "590:         return {",
          "591:             id: cursor.key as number,",
          "592:             txnId: resultBatch.txnId,",
          "593:             eventType: resultBatch.eventType,",
          "594:             batch: resultBatch.batch,",
          "595:         };",
          "596:     }",
          "598:     public async removeToDeviceBatch(id: number): Promise<void> {",
          "599:         const txn = this.db.transaction([\"to_device_queue\"], \"readwrite\");",
          "600:         const store = txn.objectStore(\"to_device_queue\");",
          "601:         store.delete(id);",
          "602:         await txnAsPromise(txn);",
          "603:     }",
          "",
          "---------------"
        ],
        "src/store/indexeddb-remote-backend.ts||src/store/indexeddb-remote-backend.ts": [
          "File: src/store/indexeddb-remote-backend.ts -> src/store/indexeddb-remote-backend.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: import { IStartClientOpts } from \"../client\";",
          "21: import { IStateEventWithRoomId, ISyncResponse } from \"..\";",
          "22: import { IIndexedDBBackend, UserTuple } from \"./indexeddb-backend\";",
          "24: export class RemoteIndexedDBStoreBackend implements IIndexedDBBackend {",
          "25:     private worker: Worker;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: import { IndexedToDeviceBatch, ToDeviceBatchWithTxnId } from \"../models/ToDeviceMessage\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "133:         return this.doCmd('getUserPresenceEvents');",
          "134:     }",
          "136:     private ensureStarted(): Promise<void> {",
          "137:         if (this.startPromise === null) {",
          "138:             this.worker = this.workerFactory();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137:     public async saveToDeviceBatches(batches: ToDeviceBatchWithTxnId[]): Promise<void> {",
          "138:         return this.doCmd('saveToDeviceBatches', [batches]);",
          "139:     }",
          "141:     public async getOldestToDeviceBatch(): Promise<IndexedToDeviceBatch> {",
          "142:         return this.doCmd('getOldestToDeviceBatch');",
          "143:     }",
          "145:     public async removeToDeviceBatch(id: number): Promise<void> {",
          "146:         return this.doCmd('removeToDeviceBatch', [id]);",
          "147:     }",
          "",
          "---------------"
        ],
        "src/store/indexeddb-store-worker.ts||src/store/indexeddb-store-worker.ts": [
          "File: src/store/indexeddb-store-worker.ts -> src/store/indexeddb-store-worker.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "103:             case 'storeClientOptions':",
          "104:                 prom = this.backend.storeClientOptions(msg.args[0]);",
          "105:                 break;",
          "106:         }",
          "108:         if (prom === undefined) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "106:             case 'saveToDeviceBatches':",
          "107:                 prom = this.backend.saveToDeviceBatches(msg.args[0]);",
          "108:                 break;",
          "109:             case 'getOldestToDeviceBatch':",
          "110:                 prom = this.backend.getOldestToDeviceBatch();",
          "111:                 break;",
          "112:             case 'removeToDeviceBatch':",
          "113:                 prom = this.backend.removeToDeviceBatch(msg.args[0]);",
          "114:                 break;",
          "",
          "---------------"
        ],
        "src/store/indexeddb.ts||src/store/indexeddb.ts": [
          "File: src/store/indexeddb.ts -> src/store/indexeddb.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: import { ISyncResponse } from \"../sync-accumulator\";",
          "28: import { TypedEventEmitter } from \"../models/typed-event-emitter\";",
          "29: import { IStateEventWithRoomId } from \"../@types/search\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: import { IndexedToDeviceBatch, ToDeviceBatchWithTxnId } from \"../models/ToDeviceMessage\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "351:             this.localStorage.removeItem(pendingEventsKey(roomId));",
          "352:         }",
          "353:     }",
          "354: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "356:     public saveToDeviceBatches(batches: ToDeviceBatchWithTxnId[]): Promise<void> {",
          "357:         return this.backend.saveToDeviceBatches(batches);",
          "358:     }",
          "360:     public getOldestToDeviceBatch(): Promise<IndexedToDeviceBatch> {",
          "361:         return this.backend.getOldestToDeviceBatch();",
          "362:     }",
          "364:     public removeToDeviceBatch(id: number): Promise<void> {",
          "365:         return this.backend.removeToDeviceBatch(id);",
          "366:     }",
          "",
          "---------------"
        ],
        "src/store/memory.ts||src/store/memory.ts": [
          "File: src/store/memory.ts -> src/store/memory.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: import { RoomSummary } from \"../models/room-summary\";",
          "31: import { ISyncResponse } from \"../sync-accumulator\";",
          "32: import { IStateEventWithRoomId } from \"../@types/search\";",
          "34: function isValidFilterId(filterId: string): boolean {",
          "35:     const isValidStr = typeof filterId === \"string\" &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: import { IndexedToDeviceBatch, ToDeviceBatchWithTxnId } from \"../models/ToDeviceMessage\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:     private oobMembers: Record<string, IStateEventWithRoomId[]> = {}; // roomId: [member events]",
          "65:     private pendingEvents: { [roomId: string]: Partial<IEvent>[] } = {};",
          "66:     private clientOptions = {};",
          "68:     constructor(opts: IOpts = {}) {",
          "69:         this.localStorage = opts.localStorage;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:     private pendingToDeviceBatches: IndexedToDeviceBatch[] = [];",
          "69:     private nextToDeviceBatchId = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "429:     public async setPendingEvents(roomId: string, events: Partial<IEvent>[]): Promise<void> {",
          "430:         this.pendingEvents[roomId] = events;",
          "431:     }",
          "432: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "436:     public saveToDeviceBatches(batches: ToDeviceBatchWithTxnId[]): Promise<void> {",
          "437:         for (const batch of batches) {",
          "438:             this.pendingToDeviceBatches.push({",
          "439:                 id: this.nextToDeviceBatchId++,",
          "440:                 eventType: batch.eventType,",
          "441:                 txnId: batch.txnId,",
          "442:                 batch: batch.batch,",
          "443:             });",
          "444:         }",
          "445:         return Promise.resolve();",
          "446:     }",
          "448:     public async getOldestToDeviceBatch(): Promise<IndexedToDeviceBatch | null> {",
          "449:         if (this.pendingToDeviceBatches.length === 0) return null;",
          "450:         return this.pendingToDeviceBatches[0];",
          "451:     }",
          "453:     public removeToDeviceBatch(id: number): Promise<void> {",
          "454:         this.pendingToDeviceBatches = this.pendingToDeviceBatches.filter(batch => batch.id !== id);",
          "455:         return Promise.resolve();",
          "456:     }",
          "",
          "---------------"
        ],
        "src/store/stub.ts||src/store/stub.ts": [
          "File: src/store/stub.ts -> src/store/stub.ts",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: import { RoomSummary } from \"../models/room-summary\";",
          "29: import { ISyncResponse } from \"../sync-accumulator\";",
          "30: import { IStateEventWithRoomId } from \"../@types/search\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31: import { IndexedToDeviceBatch, ToDeviceBatch } from \"../models/ToDeviceMessage\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "270:     public setPendingEvents(roomId: string, events: Partial<IEvent>[]): Promise<void> {",
          "271:         return Promise.resolve();",
          "272:     }",
          "273: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "275:     public async saveToDeviceBatches(batch: ToDeviceBatch[]): Promise<void> {",
          "276:         return Promise.resolve();",
          "277:     }",
          "279:     public getOldestToDeviceBatch(): Promise<IndexedToDeviceBatch | null> {",
          "280:         return Promise.resolve(null);",
          "281:     }",
          "283:     public async removeToDeviceBatch(id: number): Promise<void> {",
          "284:         return Promise.resolve();",
          "285:     }",
          "",
          "---------------"
        ],
        "yarn.lock||yarn.lock": [
          "File: yarn.lock -> yarn.lock",
          "--- Hunk 1 ---",
          "[Context before]",
          "4802:   resolved \"https://registry.yarnpkg.com/matrix-events-sdk/-/matrix-events-sdk-0.0.1-beta.7.tgz#5ffe45eba1f67cc8d7c2377736c728b322524934\"",
          "4803:   integrity sha512-9jl4wtWanUFSy2sr2lCjErN/oC8KTAtaeaozJtrgot1JiQcEI4Rda9OLgQ7nLKaqb4Z/QUx/fR3XpDzm5Jy1JA==",
          "4809:   dependencies:",
          "4810:     expect \"^28.1.0\"",
          "",
          "[Removed Lines]",
          "4805: matrix-mock-request@^2.1.0:",
          "4806:   version \"2.1.0\"",
          "4807:   resolved \"https://registry.yarnpkg.com/matrix-mock-request/-/matrix-mock-request-2.1.0.tgz#86f5b0ef846865d0767d3a8e64f5bcd6ca94c178\"",
          "4808:   integrity sha512-Cjpl3yP6h0yu5GKG89m1XZXZlm69Kg/qHV41N/t6SrQsgcfM3Bfavqx9YrtG0UnuXGy4bBSZIe1QiWVeFPZw1A==",
          "",
          "[Added Lines]",
          "4805: matrix-mock-request@^2.1.1:",
          "4806:   version \"2.1.1\"",
          "4807:   resolved \"https://registry.yarnpkg.com/matrix-mock-request/-/matrix-mock-request-2.1.1.tgz#a8fc03a2816464bb95445df4cc8885ac36786b23\"",
          "4808:   integrity sha512-CxdaUPRVB4o8JxTBMASstS2loRe+hlqeJu0Q7yyS1r36LkSSo/KAP4AuomsqxuKqaqYYnEJFJzkG0gOhxV7aqA==",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-3920",
  "cve_desc": "HashiCorp Consul and Consul Enterprise 1.13.0 up to 1.13.3 do not filter cluster filtering's imported nodes and services for HTTP or RPC endpoints used by the UI. Fixed in 1.14.0.",
  "repo": "hashicorp/consul",
  "patch_hash": "706866fa0016b0aa302679f9c648859050d19b2e",
  "patch_info": {
    "commit_hash": "706866fa0016b0aa302679f9c648859050d19b2e",
    "repo": "hashicorp/consul",
    "commit_url": "https://github.com/hashicorp/consul/commit/706866fa0016b0aa302679f9c648859050d19b2e",
    "files": [
      ".changelog/15356.txt",
      "agent/structs/aclfilter/filter.go",
      "agent/structs/aclfilter/filter_test.go",
      "agent/structs/structs_oss.go"
    ],
    "message": "Ensure that NodeDump imported nodes are filtered (#15356)",
    "before_after_code_files": [
      "agent/structs/aclfilter/filter.go||agent/structs/aclfilter/filter.go",
      "agent/structs/aclfilter/filter_test.go||agent/structs/aclfilter/filter_test.go",
      "agent/structs/structs_oss.go||agent/structs/structs_oss.go"
    ]
  },
  "patch_diff": {
    "agent/structs/aclfilter/filter.go||agent/structs/aclfilter/filter.go": [
      "File: agent/structs/aclfilter/filter.go -> agent/structs/aclfilter/filter.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "61:   v.QueryMeta.ResultsFilteredByACLs = f.filterIntentions(&v.Intentions)",
      "63:  case *structs.IndexedNodeDump:",
      "66:  case *structs.IndexedServiceDump:",
      "67:   v.QueryMeta.ResultsFilteredByACLs = f.filterServiceDump(&v.Dump)",
      "",
      "[Removed Lines]",
      "64:   v.QueryMeta.ResultsFilteredByACLs = f.filterNodeDump(&v.Dump)",
      "",
      "[Added Lines]",
      "64:   if f.filterNodeDump(&v.Dump) {",
      "65:    v.QueryMeta.ResultsFilteredByACLs = true",
      "66:   }",
      "67:   if f.filterNodeDump(&v.ImportedDump) {",
      "68:    v.QueryMeta.ResultsFilteredByACLs = true",
      "69:   }",
      "",
      "---------------"
    ],
    "agent/structs/aclfilter/filter_test.go||agent/structs/aclfilter/filter_test.go": [
      "File: agent/structs/aclfilter/filter_test.go -> agent/structs/aclfilter/filter_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "1444:      },",
      "1445:     },",
      "1446:    },",
      "1447:   }",
      "1448:  }",
      "1453:    service \"foo\" {",
      "1454:      policy = \"read\"",
      "1455:    }",
      "1456:    node \"node1\" {",
      "1457:      policy = \"read\"",
      "1458:    }",
      "1459:   `, acl.SyntaxLegacy, nil, nil)",
      "1475:    service \"foo\" {",
      "1476:      policy = \"read\"",
      "1477:    }",
      "1478:   `, acl.SyntaxLegacy, nil, nil)",
      "1495:      policy = \"read\"",
      "1496:    }",
      "1497:   `, acl.SyntaxLegacy, nil, nil)",
      "1519: }",
      "1521: func TestACL_filterNodes(t *testing.T) {",
      "",
      "[Removed Lines]",
      "1450:  t.Run(\"allowed\", func(t *testing.T) {",
      "1452:   policy, err := acl.NewPolicyFromSource(`",
      "1460:   require.NoError(t, err)",
      "1462:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
      "1463:   require.NoError(t, err)",
      "1465:   list := makeList()",
      "1466:   New(authz, logger).Filter(list)",
      "1468:   require.Len(t, list.Dump, 1)",
      "1469:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
      "1470:  })",
      "1472:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
      "1474:   policy, err := acl.NewPolicyFromSource(`",
      "1479:   require.NoError(t, err)",
      "1481:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
      "1482:   require.NoError(t, err)",
      "1484:   list := makeList()",
      "1485:   New(authz, logger).Filter(list)",
      "1487:   require.Empty(t, list.Dump)",
      "1488:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
      "1489:  })",
      "1491:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
      "1493:   policy, err := acl.NewPolicyFromSource(`",
      "1494:    node \"node1\" {",
      "1498:   require.NoError(t, err)",
      "1500:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
      "1501:   require.NoError(t, err)",
      "1503:   list := makeList()",
      "1504:   New(authz, logger).Filter(list)",
      "1506:   require.Len(t, list.Dump, 1)",
      "1507:   require.Empty(t, list.Dump[0].Services)",
      "1508:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
      "1509:  })",
      "1511:  t.Run(\"denied\", func(t *testing.T) {",
      "1513:   list := makeList()",
      "1514:   New(acl.DenyAll(), logger).Filter(list)",
      "1516:   require.Empty(t, list.Dump)",
      "1517:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
      "1518:  })",
      "",
      "[Added Lines]",
      "1447:    ImportedDump: structs.NodeDump{",
      "1448:     {",
      "1451:      Node:     \"node1\",",
      "1452:      PeerName: \"cluster-02\",",
      "1453:      Services: []*structs.NodeService{",
      "1454:       {",
      "1455:        ID:       \"foo\",",
      "1456:        Service:  \"foo\",",
      "1457:        PeerName: \"cluster-02\",",
      "1458:       },",
      "1459:      },",
      "1460:      Checks: []*structs.HealthCheck{",
      "1461:       {",
      "1462:        Node:        \"node1\",",
      "1463:        CheckID:     \"check1\",",
      "1464:        ServiceName: \"foo\",",
      "1465:        PeerName:    \"cluster-02\",",
      "1466:       },",
      "1467:      },",
      "1468:     },",
      "1469:    },",
      "1472:  type testCase struct {",
      "1473:   authzFn func() acl.Authorizer",
      "1474:   expect  *structs.IndexedNodeDump",
      "1475:  }",
      "1477:  run := func(t *testing.T, tc testCase) {",
      "1478:   authz := tc.authzFn()",
      "1480:   list := makeList()",
      "1481:   New(authz, logger).Filter(list)",
      "1483:   require.Equal(t, tc.expect, list)",
      "1484:  }",
      "1486:  tt := map[string]testCase{",
      "1487:   \"denied\": {",
      "1488:    authzFn: func() acl.Authorizer {",
      "1489:     return acl.DenyAll()",
      "1490:    },",
      "1491:    expect: &structs.IndexedNodeDump{",
      "1492:     Dump:         structs.NodeDump{},",
      "1493:     ImportedDump: structs.NodeDump{},",
      "1494:     QueryMeta:    structs.QueryMeta{ResultsFilteredByACLs: true},",
      "1495:    },",
      "1496:   },",
      "1497:   \"can read local service but not the node\": {",
      "1498:    authzFn: func() acl.Authorizer {",
      "1499:     policy, err := acl.NewPolicyFromSource(`",
      "1503:   `, acl.SyntaxLegacy, nil, nil)",
      "1504:     require.NoError(t, err)",
      "1506:     authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
      "1507:     require.NoError(t, err)",
      "1509:     return authz",
      "1510:    },",
      "1511:    expect: &structs.IndexedNodeDump{",
      "1512:     Dump:         structs.NodeDump{},",
      "1513:     ImportedDump: structs.NodeDump{},",
      "1514:     QueryMeta:    structs.QueryMeta{ResultsFilteredByACLs: true},",
      "1515:    },",
      "1516:   },",
      "1517:   \"can read the local node but not the service\": {",
      "1518:    authzFn: func() acl.Authorizer {",
      "1519:     policy, err := acl.NewPolicyFromSource(`",
      "1524:     require.NoError(t, err)",
      "1526:     authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
      "1527:     require.NoError(t, err)",
      "1529:     return authz",
      "1530:    },",
      "1531:    expect: &structs.IndexedNodeDump{",
      "1532:     Dump: structs.NodeDump{",
      "1533:      {",
      "1534:       Node:     \"node1\",",
      "1535:       Services: []*structs.NodeService{},",
      "1536:       Checks:   structs.HealthChecks{},",
      "1537:      },",
      "1538:     },",
      "1539:     ImportedDump: structs.NodeDump{},",
      "1540:     QueryMeta:    structs.QueryMeta{ResultsFilteredByACLs: true},",
      "1541:    },",
      "1542:   },",
      "1543:   \"can read local data\": {",
      "1544:    authzFn: func() acl.Authorizer {",
      "1545:     policy, err := acl.NewPolicyFromSource(`",
      "1549:    node \"node1\" {",
      "1550:      policy = \"read\"",
      "1551:    }",
      "1553:     require.NoError(t, err)",
      "1555:     authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
      "1556:     require.NoError(t, err)",
      "1558:     return authz",
      "1559:    },",
      "1560:    expect: &structs.IndexedNodeDump{",
      "1561:     Dump: structs.NodeDump{",
      "1562:      {",
      "1563:       Node: \"node1\",",
      "1564:       Services: []*structs.NodeService{",
      "1565:        {",
      "1566:         ID:      \"foo\",",
      "1567:         Service: \"foo\",",
      "1568:        },",
      "1569:       },",
      "1570:       Checks: []*structs.HealthCheck{",
      "1571:        {",
      "1572:         Node:        \"node1\",",
      "1573:         CheckID:     \"check1\",",
      "1574:         ServiceName: \"foo\",",
      "1575:        },",
      "1576:       },",
      "1577:      },",
      "1578:     },",
      "1579:     ImportedDump: structs.NodeDump{},",
      "1580:     QueryMeta:    structs.QueryMeta{ResultsFilteredByACLs: true},",
      "1581:    },",
      "1582:   },",
      "1583:   \"can read imported service but not the node\": {",
      "1584:    authzFn: func() acl.Authorizer {",
      "1586:     policy, err := acl.NewPolicyFromSource(`",
      "1587:    service \"\" {",
      "1588:      policy = \"read\"",
      "1589:    }",
      "1590:   `, acl.SyntaxLegacy, nil, nil)",
      "1591:     require.NoError(t, err)",
      "1593:     authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
      "1594:     require.NoError(t, err)",
      "1596:     return authz",
      "1597:    },",
      "1598:    expect: &structs.IndexedNodeDump{",
      "1599:     Dump:         structs.NodeDump{},",
      "1600:     ImportedDump: structs.NodeDump{},",
      "1601:     QueryMeta:    structs.QueryMeta{ResultsFilteredByACLs: true},",
      "1602:    },",
      "1603:   },",
      "1604:   \"can read the imported node but not the service\": {",
      "1605:    authzFn: func() acl.Authorizer {",
      "1607:     policy, err := acl.NewPolicyFromSource(`",
      "1608:    node \"\" {",
      "1612:     require.NoError(t, err)",
      "1614:     authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
      "1615:     require.NoError(t, err)",
      "1617:     return authz",
      "1618:    },",
      "1619:    expect: &structs.IndexedNodeDump{",
      "1620:     Dump: structs.NodeDump{",
      "1621:      {",
      "1622:       Node:     \"node1\",",
      "1623:       Services: []*structs.NodeService{},",
      "1624:       Checks:   structs.HealthChecks{},",
      "1625:      },",
      "1626:     },",
      "1627:     ImportedDump: structs.NodeDump{",
      "1628:      {",
      "1629:       Node:     \"node1\",",
      "1630:       PeerName: \"cluster-02\",",
      "1631:       Services: []*structs.NodeService{},",
      "1632:       Checks:   structs.HealthChecks{},",
      "1633:      },",
      "1634:     },",
      "1635:     QueryMeta: structs.QueryMeta{ResultsFilteredByACLs: true},",
      "1636:    },",
      "1637:   },",
      "1638:   \"can read all data\": {",
      "1639:    authzFn: func() acl.Authorizer {",
      "1640:     policy, err := acl.NewPolicyFromSource(`",
      "1641:    service \"\" {",
      "1642:      policy = \"read\"",
      "1643:    }",
      "1644:    node \"\" {",
      "1645:      policy = \"read\"",
      "1646:    }",
      "1647:   `, acl.SyntaxLegacy, nil, nil)",
      "1648:     require.NoError(t, err)",
      "1650:     authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
      "1651:     require.NoError(t, err)",
      "1653:     return authz",
      "1654:    },",
      "1655:    expect: &structs.IndexedNodeDump{",
      "1656:     Dump: structs.NodeDump{",
      "1657:      {",
      "1658:       Node: \"node1\",",
      "1659:       Services: []*structs.NodeService{",
      "1660:        {",
      "1661:         ID:      \"foo\",",
      "1662:         Service: \"foo\",",
      "1663:        },",
      "1664:       },",
      "1665:       Checks: []*structs.HealthCheck{",
      "1666:        {",
      "1667:         Node:        \"node1\",",
      "1668:         CheckID:     \"check1\",",
      "1669:         ServiceName: \"foo\",",
      "1670:        },",
      "1671:       },",
      "1672:      },",
      "1673:     },",
      "1674:     ImportedDump: structs.NodeDump{",
      "1675:      {",
      "1676:       Node:     \"node1\",",
      "1677:       PeerName: \"cluster-02\",",
      "1678:       Services: []*structs.NodeService{",
      "1679:        {",
      "1680:         ID:       \"foo\",",
      "1681:         Service:  \"foo\",",
      "1682:         PeerName: \"cluster-02\",",
      "1683:        },",
      "1684:       },",
      "1685:       Checks: []*structs.HealthCheck{",
      "1686:        {",
      "1687:         Node:        \"node1\",",
      "1688:         CheckID:     \"check1\",",
      "1689:         ServiceName: \"foo\",",
      "1690:         PeerName:    \"cluster-02\",",
      "1691:        },",
      "1692:       },",
      "1693:      },",
      "1694:     },",
      "1695:     QueryMeta: structs.QueryMeta{ResultsFilteredByACLs: false},",
      "1696:    },",
      "1697:   },",
      "1698:  }",
      "1700:  for name, tc := range tt {",
      "1701:   t.Run(name, func(t *testing.T) {",
      "1702:    run(t, tc)",
      "1703:   })",
      "1704:  }",
      "",
      "---------------"
    ],
    "agent/structs/structs_oss.go||agent/structs/structs_oss.go": [
      "File: agent/structs/structs_oss.go -> agent/structs/structs_oss.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "68: func (_ *Coordinate) FillAuthzContext(_ *acl.AuthorizerContext) {}",
      "73: func (_ *DirEntry) FillAuthzContext(_ *acl.AuthorizerContext) {}",
      "",
      "[Removed Lines]",
      "70: func (_ *NodeInfo) FillAuthzContext(_ *acl.AuthorizerContext) {}",
      "",
      "[Added Lines]",
      "70: func (n *NodeInfo) FillAuthzContext(ctx *acl.AuthorizerContext) {",
      "71:  ctx.Peer = n.PeerName",
      "72: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "45886848b4a3706b25d8c4b7b75e80e2fb0b87fc",
      "candidate_info": {
        "commit_hash": "45886848b4a3706b25d8c4b7b75e80e2fb0b87fc",
        "repo": "hashicorp/consul",
        "commit_url": "https://github.com/hashicorp/consul/commit/45886848b4a3706b25d8c4b7b75e80e2fb0b87fc",
        "files": [
          "agent/agent.go",
          "agent/consul/acl.go",
          "agent/consul/acl_endpoint.go",
          "agent/consul/acl_endpoint_test.go",
          "agent/consul/acl_replication_test.go",
          "agent/consul/acl_replication_types.go",
          "agent/consul/acl_test.go",
          "agent/consul/leader.go",
          "agent/consul/prepared_query_endpoint.go",
          "agent/consul/prepared_query_endpoint_test.go",
          "agent/proxycfg-glue/config_entry.go",
          "agent/proxycfg-glue/glue.go",
          "agent/proxycfg-glue/intention_upstreams.go",
          "agent/proxycfg-glue/intention_upstreams_test.go",
          "agent/proxycfg-glue/intentions_ent_test.go",
          "agent/proxycfg-glue/intentions_test.go",
          "agent/structs/aclfilter/filter.go",
          "agent/structs/aclfilter/filter_test.go"
        ],
        "message": "proxycfg: server-local intention upstreams data source\n\nThis is the OSS portion of enterprise PR 2157.\n\nIt builds on the local blocking query work in #13438 to implement the\nproxycfg.IntentionUpstreams interface using server-local data.\n\nAlso moves the ACL filtering logic from agent/consul into the acl/filter\npackage so that it can be reused here.",
        "before_after_code_files": [
          "agent/agent.go||agent/agent.go",
          "agent/consul/acl.go||agent/consul/acl.go",
          "agent/consul/acl_endpoint.go||agent/consul/acl_endpoint.go",
          "agent/consul/acl_endpoint_test.go||agent/consul/acl_endpoint_test.go",
          "agent/consul/acl_replication_test.go||agent/consul/acl_replication_test.go",
          "agent/consul/acl_replication_types.go||agent/consul/acl_replication_types.go",
          "agent/consul/acl_test.go||agent/consul/acl_test.go",
          "agent/consul/leader.go||agent/consul/leader.go",
          "agent/consul/prepared_query_endpoint.go||agent/consul/prepared_query_endpoint.go",
          "agent/consul/prepared_query_endpoint_test.go||agent/consul/prepared_query_endpoint_test.go",
          "agent/proxycfg-glue/config_entry.go||agent/proxycfg-glue/config_entry.go",
          "agent/proxycfg-glue/glue.go||agent/proxycfg-glue/glue.go",
          "agent/proxycfg-glue/intention_upstreams.go||agent/proxycfg-glue/intention_upstreams.go",
          "agent/proxycfg-glue/intention_upstreams_test.go||agent/proxycfg-glue/intention_upstreams_test.go",
          "agent/proxycfg-glue/intentions_ent_test.go||agent/proxycfg-glue/intentions_ent_test.go",
          "agent/proxycfg-glue/intentions_test.go||agent/proxycfg-glue/intentions_test.go",
          "agent/structs/aclfilter/filter.go||agent/structs/aclfilter/filter.go",
          "agent/structs/aclfilter/filter_test.go||agent/structs/aclfilter/filter_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "agent/structs/aclfilter/filter.go||agent/structs/aclfilter/filter.go",
            "agent/structs/aclfilter/filter_test.go||agent/structs/aclfilter/filter_test.go"
          ],
          "candidate": [
            "agent/structs/aclfilter/filter.go||agent/structs/aclfilter/filter.go",
            "agent/structs/aclfilter/filter_test.go||agent/structs/aclfilter/filter_test.go"
          ]
        }
      },
      "candidate_diff": {
        "agent/agent.go||agent/agent.go": [
          "File: agent/agent.go -> agent/agent.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "4231:   ExportedPeeredServices:          proxycfgglue.CacheExportedPeeredServices(a.cache),",
          "4232:  }",
          "4235:   deps := proxycfgglue.ServerDataSourceDeps{",
          "4236:    EventPublisher: a.baseDeps.EventPublisher,",
          "4237:    ViewStore:      a.baseDeps.ViewStore,",
          "4238:    Logger:         a.logger.Named(\"proxycfg.server-data-sources\"),",
          "4239:    ACLResolver:    a.delegate,",
          "4240:   }",
          "4241:   sources.ConfigEntry = proxycfgglue.ServerConfigEntry(deps)",
          "4242:   sources.ConfigEntryList = proxycfgglue.ServerConfigEntryList(deps)",
          "4243:   sources.Intentions = proxycfgglue.ServerIntentions(deps)",
          "4244:  }",
          "4246:  a.fillEnterpriseProxyDataSources(&sources)",
          "",
          "[Removed Lines]",
          "4234:  if a.config.ServerMode {",
          "",
          "[Added Lines]",
          "4234:  if server, ok := a.delegate.(*consul.Server); ok {",
          "4240:    GetStore:       func() proxycfgglue.Store { return server.FSM().State() },",
          "4245:   sources.IntentionUpstreams = proxycfgglue.ServerIntentionUpstreams(deps)",
          "",
          "---------------"
        ],
        "agent/consul/acl.go||agent/consul/acl.go": [
          "File: agent/consul/acl.go -> agent/consul/acl.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:  \"github.com/hashicorp/consul/acl\"",
          "16:  \"github.com/hashicorp/consul/acl/resolver\"",
          "17:  \"github.com/hashicorp/consul/agent/structs\"",
          "18:  \"github.com/hashicorp/consul/agent/token\"",
          "19:  \"github.com/hashicorp/consul/logging\"",
          "20: )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18:  \"github.com/hashicorp/consul/agent/structs/aclfilter\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:  anonymousToken = \"anonymous\"",
          "51:  aclTokenReapingRateLimit rate.Limit = 1.0",
          "",
          "[Removed Lines]",
          "48:  redactedToken = \"<hidden>\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1114:  return result, err",
          "1115: }",
          "1806: func filterACLWithAuthorizer(logger hclog.Logger, authorizer acl.Authorizer, subj interface{}) {",
          "1927: }",
          "",
          "[Removed Lines]",
          "1119: type aclFilter struct {",
          "1120:  authorizer acl.Authorizer",
          "1121:  logger     hclog.Logger",
          "1122: }",
          "1125: func newACLFilter(authorizer acl.Authorizer, logger hclog.Logger) *aclFilter {",
          "1126:  if logger == nil {",
          "1127:   logger = hclog.New(&hclog.LoggerOptions{})",
          "1128:  }",
          "1129:  return &aclFilter{",
          "1130:   authorizer: authorizer,",
          "1131:   logger:     logger,",
          "1132:  }",
          "1133: }",
          "1136: func (f *aclFilter) allowNode(node string, ent *acl.AuthorizerContext) bool {",
          "1137:  return f.authorizer.NodeRead(node, ent) == acl.Allow",
          "1138: }",
          "1141: func (f *aclFilter) allowGateway(gs *structs.GatewayService) bool {",
          "1142:  var authzContext acl.AuthorizerContext",
          "1145:  gs.Gateway.FillAuthzContext(&authzContext)",
          "1146:  if !f.allowService(gs.Gateway.Name, &authzContext) {",
          "1147:   return false",
          "1148:  }",
          "1150:  gs.Service.FillAuthzContext(&authzContext)",
          "1151:  if !f.allowService(gs.Service.Name, &authzContext) {",
          "1152:   return false",
          "1153:  }",
          "1154:  return true",
          "1155: }",
          "1158: func (f *aclFilter) allowService(service string, ent *acl.AuthorizerContext) bool {",
          "1159:  if service == \"\" {",
          "1160:   return true",
          "1161:  }",
          "1163:  return f.authorizer.ServiceRead(service, ent) == acl.Allow",
          "1164: }",
          "1168: func (f *aclFilter) allowSession(node string, ent *acl.AuthorizerContext) bool {",
          "1169:  return f.authorizer.SessionRead(node, ent) == acl.Allow",
          "1170: }",
          "1175: func (f *aclFilter) filterHealthChecks(checks *structs.HealthChecks) bool {",
          "1176:  hc := *checks",
          "1177:  var authzContext acl.AuthorizerContext",
          "1178:  var removed bool",
          "1180:  for i := 0; i < len(hc); i++ {",
          "1181:   check := hc[i]",
          "1182:   check.FillAuthzContext(&authzContext)",
          "1183:   if f.allowNode(check.Node, &authzContext) && f.allowService(check.ServiceName, &authzContext) {",
          "1184:    continue",
          "1185:   }",
          "1187:   f.logger.Debug(\"dropping check from result due to ACLs\", \"check\", check.CheckID)",
          "1188:   removed = true",
          "1189:   hc = append(hc[:i], hc[i+1:]...)",
          "1190:   i--",
          "1191:  }",
          "1193:  return removed",
          "1194: }",
          "1198: func (f *aclFilter) filterServices(services structs.Services, entMeta *acl.EnterpriseMeta) bool {",
          "1199:  var authzContext acl.AuthorizerContext",
          "1200:  entMeta.FillAuthzContext(&authzContext)",
          "1202:  var removed bool",
          "1204:  for svc := range services {",
          "1205:   if f.allowService(svc, &authzContext) {",
          "1206:    continue",
          "1207:   }",
          "1208:   f.logger.Debug(\"dropping service from result due to ACLs\", \"service\", svc)",
          "1209:   removed = true",
          "1210:   delete(services, svc)",
          "1211:  }",
          "1213:  return removed",
          "1214: }",
          "1218: func (f *aclFilter) filterServiceNodes(nodes *structs.ServiceNodes) bool {",
          "1219:  sn := *nodes",
          "1220:  var authzContext acl.AuthorizerContext",
          "1221:  var removed bool",
          "1223:  for i := 0; i < len(sn); i++ {",
          "1224:   node := sn[i]",
          "1226:   node.FillAuthzContext(&authzContext)",
          "1227:   if f.allowNode(node.Node, &authzContext) && f.allowService(node.ServiceName, &authzContext) {",
          "1228:    continue",
          "1229:   }",
          "1230:   removed = true",
          "1231:   f.logger.Debug(\"dropping node from result due to ACLs\", \"node\", structs.NodeNameString(node.Node, &node.EnterpriseMeta))",
          "1232:   sn = append(sn[:i], sn[i+1:]...)",
          "1233:   i--",
          "1234:  }",
          "1236:  return removed",
          "1237: }",
          "1241: func (f *aclFilter) filterNodeServices(services **structs.NodeServices) bool {",
          "1242:  if *services == nil {",
          "1243:   return false",
          "1244:  }",
          "1246:  var authzContext acl.AuthorizerContext",
          "1247:  (*services).Node.FillAuthzContext(&authzContext)",
          "1248:  if !f.allowNode((*services).Node.Node, &authzContext) {",
          "1250:   return true",
          "1251:  }",
          "1253:  var removed bool",
          "1254:  for svcName, svc := range (*services).Services {",
          "1255:   svc.FillAuthzContext(&authzContext)",
          "1257:   if f.allowNode((*services).Node.Node, &authzContext) && f.allowService(svcName, &authzContext) {",
          "1258:    continue",
          "1259:   }",
          "1260:   f.logger.Debug(\"dropping service from result due to ACLs\", \"service\", svc.CompoundServiceID())",
          "1261:   removed = true",
          "1262:   delete((*services).Services, svcName)",
          "1263:  }",
          "1265:  return removed",
          "1266: }",
          "1270: func (f *aclFilter) filterNodeServiceList(services *structs.NodeServiceList) bool {",
          "1271:  if services.Node == nil {",
          "1272:   return false",
          "1273:  }",
          "1275:  var authzContext acl.AuthorizerContext",
          "1276:  services.Node.FillAuthzContext(&authzContext)",
          "1277:  if !f.allowNode(services.Node.Node, &authzContext) {",
          "1279:   return true",
          "1280:  }",
          "1282:  var removed bool",
          "1283:  svcs := services.Services",
          "1284:  for i := 0; i < len(svcs); i++ {",
          "1285:   svc := svcs[i]",
          "1286:   svc.FillAuthzContext(&authzContext)",
          "1288:   if f.allowService(svc.Service, &authzContext) {",
          "1289:    continue",
          "1290:   }",
          "1292:   f.logger.Debug(\"dropping service from result due to ACLs\", \"service\", svc.CompoundServiceID())",
          "1293:   svcs = append(svcs[:i], svcs[i+1:]...)",
          "1294:   i--",
          "1295:   removed = true",
          "1296:  }",
          "1297:  services.Services = svcs",
          "1299:  return removed",
          "1300: }",
          "1304: func (f *aclFilter) filterCheckServiceNodes(nodes *structs.CheckServiceNodes) bool {",
          "1305:  csn := *nodes",
          "1306:  var authzContext acl.AuthorizerContext",
          "1307:  var removed bool",
          "1309:  for i := 0; i < len(csn); i++ {",
          "1310:   node := csn[i]",
          "1311:   node.Service.FillAuthzContext(&authzContext)",
          "1312:   if f.allowNode(node.Node.Node, &authzContext) && f.allowService(node.Service.Service, &authzContext) {",
          "1313:    continue",
          "1314:   }",
          "1315:   f.logger.Debug(\"dropping node from result due to ACLs\", \"node\", structs.NodeNameString(node.Node.Node, node.Node.GetEnterpriseMeta()))",
          "1316:   removed = true",
          "1317:   csn = append(csn[:i], csn[i+1:]...)",
          "1318:   i--",
          "1319:  }",
          "1321:  return removed",
          "1322: }",
          "1326: func (f *aclFilter) filterServiceTopology(topology *structs.ServiceTopology) bool {",
          "1327:  filteredUpstreams := f.filterCheckServiceNodes(&topology.Upstreams)",
          "1328:  filteredDownstreams := f.filterCheckServiceNodes(&topology.Downstreams)",
          "1329:  return filteredUpstreams || filteredDownstreams",
          "1330: }",
          "1334: func (f *aclFilter) filterDatacenterCheckServiceNodes(datacenterNodes *map[string]structs.CheckServiceNodes) bool {",
          "1335:  dn := *datacenterNodes",
          "1336:  out := make(map[string]structs.CheckServiceNodes)",
          "1337:  var removed bool",
          "1338:  for dc := range dn {",
          "1339:   nodes := dn[dc]",
          "1340:   if f.filterCheckServiceNodes(&nodes) {",
          "1341:    removed = true",
          "1342:   }",
          "1343:   if len(nodes) > 0 {",
          "1344:    out[dc] = nodes",
          "1345:   }",
          "1346:  }",
          "1348:  return removed",
          "1349: }",
          "1353: func (f *aclFilter) filterSessions(sessions *structs.Sessions) bool {",
          "1354:  s := *sessions",
          "1356:  var removed bool",
          "1357:  for i := 0; i < len(s); i++ {",
          "1358:   session := s[i]",
          "1360:   var entCtx acl.AuthorizerContext",
          "1361:   session.FillAuthzContext(&entCtx)",
          "1363:   if f.allowSession(session.Node, &entCtx) {",
          "1364:    continue",
          "1365:   }",
          "1366:   removed = true",
          "1367:   f.logger.Debug(\"dropping session from result due to ACLs\", \"session\", session.ID)",
          "1368:   s = append(s[:i], s[i+1:]...)",
          "1369:   i--",
          "1370:  }",
          "1372:  return removed",
          "1373: }",
          "1377: func (f *aclFilter) filterCoordinates(coords *structs.Coordinates) bool {",
          "1378:  c := *coords",
          "1379:  var authzContext acl.AuthorizerContext",
          "1380:  var removed bool",
          "1382:  for i := 0; i < len(c); i++ {",
          "1383:   c[i].FillAuthzContext(&authzContext)",
          "1384:   node := c[i].Node",
          "1385:   if f.allowNode(node, &authzContext) {",
          "1386:    continue",
          "1387:   }",
          "1388:   f.logger.Debug(\"dropping node from result due to ACLs\", \"node\", structs.NodeNameString(node, c[i].GetEnterpriseMeta()))",
          "1389:   removed = true",
          "1390:   c = append(c[:i], c[i+1:]...)",
          "1391:   i--",
          "1392:  }",
          "1394:  return removed",
          "1395: }",
          "1401: func (f *aclFilter) filterIntentions(ixns *structs.Intentions) bool {",
          "1402:  ret := make(structs.Intentions, 0, len(*ixns))",
          "1403:  var removed bool",
          "1404:  for _, ixn := range *ixns {",
          "1405:   if !ixn.CanRead(f.authorizer) {",
          "1406:    removed = true",
          "1407:    f.logger.Debug(\"dropping intention from result due to ACLs\", \"intention\", ixn.ID)",
          "1408:    continue",
          "1409:   }",
          "1411:   ret = append(ret, ixn)",
          "1412:  }",
          "1415:  return removed",
          "1416: }",
          "1421: func (f *aclFilter) filterNodeDump(dump *structs.NodeDump) bool {",
          "1422:  nd := *dump",
          "1424:  var authzContext acl.AuthorizerContext",
          "1425:  var removed bool",
          "1426:  for i := 0; i < len(nd); i++ {",
          "1427:   info := nd[i]",
          "1430:   info.FillAuthzContext(&authzContext)",
          "1431:   if node := info.Node; !f.allowNode(node, &authzContext) {",
          "1432:    f.logger.Debug(\"dropping node from result due to ACLs\", \"node\", structs.NodeNameString(node, info.GetEnterpriseMeta()))",
          "1433:    removed = true",
          "1434:    nd = append(nd[:i], nd[i+1:]...)",
          "1435:    i--",
          "1436:    continue",
          "1437:   }",
          "1440:   for j := 0; j < len(info.Services); j++ {",
          "1441:    svc := info.Services[j].Service",
          "1442:    info.Services[j].FillAuthzContext(&authzContext)",
          "1443:    if f.allowNode(info.Node, &authzContext) && f.allowService(svc, &authzContext) {",
          "1444:     continue",
          "1445:    }",
          "1446:    f.logger.Debug(\"dropping service from result due to ACLs\", \"service\", svc)",
          "1447:    removed = true",
          "1448:    info.Services = append(info.Services[:j], info.Services[j+1:]...)",
          "1449:    j--",
          "1450:   }",
          "1453:   for j := 0; j < len(info.Checks); j++ {",
          "1454:    chk := info.Checks[j]",
          "1455:    chk.FillAuthzContext(&authzContext)",
          "1456:    if f.allowNode(info.Node, &authzContext) && f.allowService(chk.ServiceName, &authzContext) {",
          "1457:     continue",
          "1458:    }",
          "1459:    f.logger.Debug(\"dropping check from result due to ACLs\", \"check\", chk.CheckID)",
          "1460:    removed = true",
          "1461:    info.Checks = append(info.Checks[:j], info.Checks[j+1:]...)",
          "1462:    j--",
          "1463:   }",
          "1464:  }",
          "1466:  return removed",
          "1467: }",
          "1471: func (f *aclFilter) filterServiceDump(services *structs.ServiceDump) bool {",
          "1472:  svcs := *services",
          "1473:  var authzContext acl.AuthorizerContext",
          "1474:  var removed bool",
          "1476:  for i := 0; i < len(svcs); i++ {",
          "1477:   service := svcs[i]",
          "1479:   if f.allowGateway(service.GatewayService) {",
          "1481:    if service.Node == nil {",
          "1482:     continue",
          "1483:    }",
          "1485:    service.Service.FillAuthzContext(&authzContext)",
          "1486:    if f.allowNode(service.Node.Node, &authzContext) {",
          "1487:     continue",
          "1488:    }",
          "1489:   }",
          "1491:   f.logger.Debug(\"dropping service from result due to ACLs\", \"service\", service.GatewayService.Service)",
          "1492:   removed = true",
          "1493:   svcs = append(svcs[:i], svcs[i+1:]...)",
          "1494:   i--",
          "1495:  }",
          "1497:  return removed",
          "1498: }",
          "1503: func (f *aclFilter) filterNodes(nodes *structs.Nodes) bool {",
          "1504:  n := *nodes",
          "1506:  var authzContext acl.AuthorizerContext",
          "1507:  var removed bool",
          "1509:  for i := 0; i < len(n); i++ {",
          "1510:   n[i].FillAuthzContext(&authzContext)",
          "1511:   node := n[i].Node",
          "1512:   if f.allowNode(node, &authzContext) {",
          "1513:    continue",
          "1514:   }",
          "1515:   f.logger.Debug(\"dropping node from result due to ACLs\", \"node\", structs.NodeNameString(node, n[i].GetEnterpriseMeta()))",
          "1516:   removed = true",
          "1517:   n = append(n[:i], n[i+1:]...)",
          "1518:   i--",
          "1519:  }",
          "1521:  return removed",
          "1522: }",
          "1530: func (f *aclFilter) redactPreparedQueryTokens(query **structs.PreparedQuery) {",
          "1532:  var authzContext acl.AuthorizerContext",
          "1533:  structs.DefaultEnterpriseMetaInDefaultPartition().FillAuthzContext(&authzContext)",
          "1534:  if f.authorizer.ACLWrite(&authzContext) == acl.Allow {",
          "1535:   return",
          "1536:  }",
          "1541:  if (*query).Token != \"\" {",
          "1548:   clone := *(*query)",
          "1549:   clone.Token = redactedToken",
          "1551:  }",
          "1552: }",
          "1559: func (f *aclFilter) filterPreparedQueries(queries *structs.PreparedQueries) bool {",
          "1560:  var authzContext acl.AuthorizerContext",
          "1561:  structs.DefaultEnterpriseMetaInDefaultPartition().FillAuthzContext(&authzContext)",
          "1566:  if f.authorizer.ACLWrite(&authzContext) == acl.Allow {",
          "1567:   return false",
          "1568:  }",
          "1571:  var namedQueriesRemoved bool",
          "1572:  ret := make(structs.PreparedQueries, 0, len(*queries))",
          "1573:  for _, query := range *queries {",
          "1577:   prefix, hasName := query.GetACLPrefix()",
          "1578:   switch {",
          "1579:   case hasName && f.authorizer.PreparedQueryRead(prefix, &authzContext) != acl.Allow:",
          "1580:    namedQueriesRemoved = true",
          "1581:    fallthrough",
          "1582:   case !hasName:",
          "1583:    f.logger.Debug(\"dropping prepared query from result due to ACLs\", \"query\", query.ID)",
          "1584:    continue",
          "1585:   }",
          "1589:   final := query",
          "1590:   f.redactPreparedQueryTokens(&final)",
          "1591:   ret = append(ret, final)",
          "1592:  }",
          "1594:  return namedQueriesRemoved",
          "1595: }",
          "1597: func (f *aclFilter) filterToken(token **structs.ACLToken) {",
          "1598:  var entCtx acl.AuthorizerContext",
          "1599:  if token == nil || *token == nil || f == nil {",
          "1600:   return",
          "1601:  }",
          "1603:  (*token).FillAuthzContext(&entCtx)",
          "1605:  if f.authorizer.ACLRead(&entCtx) != acl.Allow {",
          "1608:  } else if f.authorizer.ACLWrite(&entCtx) != acl.Allow {",
          "1610:   clone := *(*token)",
          "1611:   clone.SecretID = redactedToken",
          "1613:  }",
          "1614: }",
          "1616: func (f *aclFilter) filterTokens(tokens *structs.ACLTokens) {",
          "1617:  ret := make(structs.ACLTokens, 0, len(*tokens))",
          "1618:  for _, token := range *tokens {",
          "1619:   final := token",
          "1620:   f.filterToken(&final)",
          "1621:   if final != nil {",
          "1622:    ret = append(ret, final)",
          "1623:   }",
          "1624:  }",
          "1626: }",
          "1628: func (f *aclFilter) filterTokenStub(token **structs.ACLTokenListStub) {",
          "1629:  var entCtx acl.AuthorizerContext",
          "1630:  if token == nil || *token == nil || f == nil {",
          "1631:   return",
          "1632:  }",
          "1634:  (*token).FillAuthzContext(&entCtx)",
          "1636:  if f.authorizer.ACLRead(&entCtx) != acl.Allow {",
          "1638:  } else if f.authorizer.ACLWrite(&entCtx) != acl.Allow {",
          "1640:   clone := *(*token)",
          "1641:   clone.SecretID = redactedToken",
          "1643:  }",
          "1644: }",
          "1646: func (f *aclFilter) filterTokenStubs(tokens *[]*structs.ACLTokenListStub) {",
          "1647:  ret := make(structs.ACLTokenListStubs, 0, len(*tokens))",
          "1648:  for _, token := range *tokens {",
          "1649:   final := token",
          "1650:   f.filterTokenStub(&final)",
          "1651:   if final != nil {",
          "1652:    ret = append(ret, final)",
          "1653:   }",
          "1654:  }",
          "1656: }",
          "1658: func (f *aclFilter) filterPolicy(policy **structs.ACLPolicy) {",
          "1659:  var entCtx acl.AuthorizerContext",
          "1660:  if policy == nil || *policy == nil || f == nil {",
          "1661:   return",
          "1662:  }",
          "1664:  (*policy).FillAuthzContext(&entCtx)",
          "1666:  if f.authorizer.ACLRead(&entCtx) != acl.Allow {",
          "1669:  }",
          "1670: }",
          "1672: func (f *aclFilter) filterPolicies(policies *structs.ACLPolicies) {",
          "1673:  ret := make(structs.ACLPolicies, 0, len(*policies))",
          "1674:  for _, policy := range *policies {",
          "1675:   final := policy",
          "1676:   f.filterPolicy(&final)",
          "1677:   if final != nil {",
          "1678:    ret = append(ret, final)",
          "1679:   }",
          "1680:  }",
          "1682: }",
          "1684: func (f *aclFilter) filterRole(role **structs.ACLRole) {",
          "1685:  var entCtx acl.AuthorizerContext",
          "1686:  if role == nil || *role == nil || f == nil {",
          "1687:   return",
          "1688:  }",
          "1690:  (*role).FillAuthzContext(&entCtx)",
          "1692:  if f.authorizer.ACLRead(&entCtx) != acl.Allow {",
          "1695:  }",
          "1696: }",
          "1698: func (f *aclFilter) filterRoles(roles *structs.ACLRoles) {",
          "1699:  ret := make(structs.ACLRoles, 0, len(*roles))",
          "1700:  for _, role := range *roles {",
          "1701:   final := role",
          "1702:   f.filterRole(&final)",
          "1703:   if final != nil {",
          "1704:    ret = append(ret, final)",
          "1705:   }",
          "1706:  }",
          "1708: }",
          "1710: func (f *aclFilter) filterBindingRule(rule **structs.ACLBindingRule) {",
          "1711:  var entCtx acl.AuthorizerContext",
          "1712:  if rule == nil || *rule == nil || f == nil {",
          "1713:   return",
          "1714:  }",
          "1716:  (*rule).FillAuthzContext(&entCtx)",
          "1718:  if f.authorizer.ACLRead(&entCtx) != acl.Allow {",
          "1721:  }",
          "1722: }",
          "1724: func (f *aclFilter) filterBindingRules(rules *structs.ACLBindingRules) {",
          "1725:  ret := make(structs.ACLBindingRules, 0, len(*rules))",
          "1726:  for _, rule := range *rules {",
          "1727:   final := rule",
          "1728:   f.filterBindingRule(&final)",
          "1729:   if final != nil {",
          "1730:    ret = append(ret, final)",
          "1731:   }",
          "1732:  }",
          "1734: }",
          "1736: func (f *aclFilter) filterAuthMethod(method **structs.ACLAuthMethod) {",
          "1737:  var entCtx acl.AuthorizerContext",
          "1738:  if method == nil || *method == nil || f == nil {",
          "1739:   return",
          "1740:  }",
          "1742:  (*method).FillAuthzContext(&entCtx)",
          "1744:  if f.authorizer.ACLRead(&entCtx) != acl.Allow {",
          "1747:  }",
          "1748: }",
          "1750: func (f *aclFilter) filterAuthMethods(methods *structs.ACLAuthMethods) {",
          "1751:  ret := make(structs.ACLAuthMethods, 0, len(*methods))",
          "1752:  for _, method := range *methods {",
          "1753:   final := method",
          "1754:   f.filterAuthMethod(&final)",
          "1755:   if final != nil {",
          "1756:    ret = append(ret, final)",
          "1757:   }",
          "1758:  }",
          "1760: }",
          "1762: func (f *aclFilter) filterServiceList(services *structs.ServiceList) bool {",
          "1763:  ret := make(structs.ServiceList, 0, len(*services))",
          "1764:  var removed bool",
          "1765:  for _, svc := range *services {",
          "1766:   var authzContext acl.AuthorizerContext",
          "1768:   svc.FillAuthzContext(&authzContext)",
          "1770:   if f.authorizer.ServiceRead(svc.Name, &authzContext) != acl.Allow {",
          "1771:    removed = true",
          "1772:    sid := structs.NewServiceID(svc.Name, &svc.EnterpriseMeta)",
          "1773:    f.logger.Debug(\"dropping service from result due to ACLs\", \"service\", sid.String())",
          "1774:    continue",
          "1775:   }",
          "1777:   ret = append(ret, svc)",
          "1778:  }",
          "1781:  return removed",
          "1782: }",
          "1786: func (f *aclFilter) filterGatewayServices(mappings *structs.GatewayServices) bool {",
          "1787:  ret := make(structs.GatewayServices, 0, len(*mappings))",
          "1788:  var removed bool",
          "1789:  for _, s := range *mappings {",
          "1792:   var authzContext acl.AuthorizerContext",
          "1793:   s.Service.FillAuthzContext(&authzContext)",
          "1795:   if f.authorizer.ServiceRead(s.Service.Name, &authzContext) != acl.Allow {",
          "1796:    f.logger.Debug(\"dropping service from result due to ACLs\", \"service\", s.Service.String())",
          "1797:    removed = true",
          "1798:    continue",
          "1799:   }",
          "1800:   ret = append(ret, s)",
          "1801:  }",
          "1803:  return removed",
          "1804: }",
          "1807:  if authorizer == nil {",
          "1808:   return",
          "1809:  }",
          "1810:  filt := newACLFilter(authorizer, logger)",
          "1812:  switch v := subj.(type) {",
          "1813:  case *structs.CheckServiceNodes:",
          "1814:   filt.filterCheckServiceNodes(v)",
          "1816:  case *structs.IndexedCheckServiceNodes:",
          "1817:   v.QueryMeta.ResultsFilteredByACLs = filt.filterCheckServiceNodes(&v.Nodes)",
          "1819:  case *structs.PreparedQueryExecuteResponse:",
          "1820:   v.QueryMeta.ResultsFilteredByACLs = filt.filterCheckServiceNodes(&v.Nodes)",
          "1822:  case *structs.IndexedServiceTopology:",
          "1823:   filtered := filt.filterServiceTopology(v.ServiceTopology)",
          "1824:   if filtered {",
          "1825:    v.FilteredByACLs = true",
          "1826:    v.QueryMeta.ResultsFilteredByACLs = true",
          "1827:   }",
          "1829:  case *structs.DatacenterIndexedCheckServiceNodes:",
          "1830:   v.QueryMeta.ResultsFilteredByACLs = filt.filterDatacenterCheckServiceNodes(&v.DatacenterNodes)",
          "1832:  case *structs.IndexedCoordinates:",
          "1833:   v.QueryMeta.ResultsFilteredByACLs = filt.filterCoordinates(&v.Coordinates)",
          "1835:  case *structs.IndexedHealthChecks:",
          "1836:   v.QueryMeta.ResultsFilteredByACLs = filt.filterHealthChecks(&v.HealthChecks)",
          "1838:  case *structs.IndexedIntentions:",
          "1839:   v.QueryMeta.ResultsFilteredByACLs = filt.filterIntentions(&v.Intentions)",
          "1841:  case *structs.IndexedNodeDump:",
          "1842:   v.QueryMeta.ResultsFilteredByACLs = filt.filterNodeDump(&v.Dump)",
          "1844:  case *structs.IndexedServiceDump:",
          "1845:   v.QueryMeta.ResultsFilteredByACLs = filt.filterServiceDump(&v.Dump)",
          "1847:  case *structs.IndexedNodes:",
          "1848:   v.QueryMeta.ResultsFilteredByACLs = filt.filterNodes(&v.Nodes)",
          "1850:  case *structs.IndexedNodeServices:",
          "1851:   v.QueryMeta.ResultsFilteredByACLs = filt.filterNodeServices(&v.NodeServices)",
          "1853:  case *structs.IndexedNodeServiceList:",
          "1854:   v.QueryMeta.ResultsFilteredByACLs = filt.filterNodeServiceList(&v.NodeServices)",
          "1856:  case *structs.IndexedServiceNodes:",
          "1857:   v.QueryMeta.ResultsFilteredByACLs = filt.filterServiceNodes(&v.ServiceNodes)",
          "1859:  case *structs.IndexedServices:",
          "1860:   v.QueryMeta.ResultsFilteredByACLs = filt.filterServices(v.Services, &v.EnterpriseMeta)",
          "1862:  case *structs.IndexedSessions:",
          "1863:   v.QueryMeta.ResultsFilteredByACLs = filt.filterSessions(&v.Sessions)",
          "1865:  case *structs.IndexedPreparedQueries:",
          "1866:   v.QueryMeta.ResultsFilteredByACLs = filt.filterPreparedQueries(&v.Queries)",
          "1868:  case **structs.PreparedQuery:",
          "1869:   filt.redactPreparedQueryTokens(v)",
          "1871:  case *structs.ACLTokens:",
          "1872:   filt.filterTokens(v)",
          "1873:  case **structs.ACLToken:",
          "1874:   filt.filterToken(v)",
          "1875:  case *[]*structs.ACLTokenListStub:",
          "1876:   filt.filterTokenStubs(v)",
          "1877:  case **structs.ACLTokenListStub:",
          "1878:   filt.filterTokenStub(v)",
          "1880:  case *structs.ACLPolicies:",
          "1881:   filt.filterPolicies(v)",
          "1882:  case **structs.ACLPolicy:",
          "1883:   filt.filterPolicy(v)",
          "1885:  case *structs.ACLRoles:",
          "1886:   filt.filterRoles(v)",
          "1887:  case **structs.ACLRole:",
          "1888:   filt.filterRole(v)",
          "1890:  case *structs.ACLBindingRules:",
          "1891:   filt.filterBindingRules(v)",
          "1892:  case **structs.ACLBindingRule:",
          "1893:   filt.filterBindingRule(v)",
          "1895:  case *structs.ACLAuthMethods:",
          "1896:   filt.filterAuthMethods(v)",
          "1897:  case **structs.ACLAuthMethod:",
          "1898:   filt.filterAuthMethod(v)",
          "1900:  case *structs.IndexedServiceList:",
          "1901:   v.QueryMeta.ResultsFilteredByACLs = filt.filterServiceList(&v.Services)",
          "1903:  case *structs.IndexedExportedServiceList:",
          "1904:   for peer, peerServices := range v.Services {",
          "1905:    v.QueryMeta.ResultsFilteredByACLs = filt.filterServiceList(&peerServices)",
          "1906:    if len(peerServices) == 0 {",
          "1907:     delete(v.Services, peer)",
          "1908:    } else {",
          "1909:     v.Services[peer] = peerServices",
          "1910:    }",
          "1911:   }",
          "1913:  case *structs.IndexedGatewayServices:",
          "1914:   v.QueryMeta.ResultsFilteredByACLs = filt.filterGatewayServices(&v.Services)",
          "1916:  case *structs.IndexedNodesWithGateways:",
          "1917:   if filt.filterCheckServiceNodes(&v.Nodes) {",
          "1918:    v.QueryMeta.ResultsFilteredByACLs = true",
          "1919:   }",
          "1920:   if filt.filterGatewayServices(&v.Gateways) {",
          "1921:    v.QueryMeta.ResultsFilteredByACLs = true",
          "1922:   }",
          "1924:  default:",
          "1925:   panic(fmt.Errorf(\"Unhandled type passed to ACL filter: %T %#v\", subj, subj))",
          "1926:  }",
          "",
          "[Added Lines]",
          "1115:  aclfilter.New(authorizer, logger).Filter(subj)",
          "",
          "---------------"
        ],
        "agent/consul/acl_endpoint.go||agent/consul/acl_endpoint.go": [
          "File: agent/consul/acl_endpoint.go -> agent/consul/acl_endpoint.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:  \"github.com/hashicorp/consul/agent/consul/authmethod\"",
          "23:  \"github.com/hashicorp/consul/agent/consul/state\"",
          "24:  \"github.com/hashicorp/consul/agent/structs\"",
          "25:  \"github.com/hashicorp/consul/lib\"",
          "26: )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25:  \"github.com/hashicorp/consul/agent/structs/aclfilter\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "291:      a.srv.filterACLWithAuthorizer(authz, &token)",
          "295:       reply.Redacted = true",
          "296:      }",
          "297:     }",
          "",
          "[Removed Lines]",
          "294:      if token.SecretID == redactedToken {",
          "",
          "[Added Lines]",
          "295:      if token.SecretID == aclfilter.RedactedToken {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "719:     a.srv.filterACLWithAuthorizer(authz, &final)",
          "720:     if final != nil {",
          "721:      ret = append(ret, final)",
          "723:       reply.Redacted = true",
          "724:      }",
          "725:     } else {",
          "",
          "[Removed Lines]",
          "722:      if final.SecretID == redactedToken {",
          "",
          "[Added Lines]",
          "723:      if final.SecretID == aclfilter.RedactedToken {",
          "",
          "---------------"
        ],
        "agent/consul/acl_endpoint_test.go||agent/consul/acl_endpoint_test.go": [
          "File: agent/consul/acl_endpoint_test.go -> agent/consul/acl_endpoint_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "20:  \"github.com/hashicorp/consul/agent/consul/authmethod/kubeauth\"",
          "21:  \"github.com/hashicorp/consul/agent/consul/authmethod/testauth\"",
          "22:  \"github.com/hashicorp/consul/agent/structs\"",
          "23:  \"github.com/hashicorp/consul/internal/go-sso/oidcauth/oidcauthtest\"",
          "24:  \"github.com/hashicorp/consul/sdk/testutil\"",
          "25:  \"github.com/hashicorp/consul/sdk/testutil/retry\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23:  \"github.com/hashicorp/consul/agent/structs/aclfilter\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1854:   }",
          "1855:   require.ElementsMatch(t, gatherIDs(t, resp.Tokens), tokens)",
          "1856:   for _, token := range resp.Tokens {",
          "1858:   }",
          "1859:  })",
          "1860: }",
          "",
          "[Removed Lines]",
          "1857:    require.Equal(t, redactedToken, token.SecretID)",
          "",
          "[Added Lines]",
          "1858:    require.Equal(t, aclfilter.RedactedToken, token.SecretID)",
          "",
          "---------------"
        ],
        "agent/consul/acl_replication_test.go||agent/consul/acl_replication_test.go": [
          "File: agent/consul/acl_replication_test.go -> agent/consul/acl_replication_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "12:  \"github.com/hashicorp/consul/acl\"",
          "13:  \"github.com/hashicorp/consul/agent/consul/authmethod/testauth\"",
          "14:  \"github.com/hashicorp/consul/agent/structs\"",
          "15:  tokenStore \"github.com/hashicorp/consul/agent/token\"",
          "16:  \"github.com/hashicorp/consul/sdk/testutil/retry\"",
          "17:  \"github.com/hashicorp/consul/testrpc\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15:  \"github.com/hashicorp/consul/agent/structs/aclfilter\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "752:   var tokenResp structs.ACLTokenResponse",
          "753:   req := structs.ACLTokenGetRequest{",
          "754:    Datacenter:   \"dc2\",",
          "756:    TokenIDType:  structs.ACLTokenSecret,",
          "758:   }",
          "759:   err := s2.RPC(\"ACL.TokenRead\", &req, &tokenResp)",
          "",
          "[Removed Lines]",
          "755:    TokenID:      redactedToken,",
          "757:    QueryOptions: structs.QueryOptions{Token: redactedToken},",
          "",
          "[Added Lines]",
          "756:    TokenID:      aclfilter.RedactedToken,",
          "758:    QueryOptions: structs.QueryOptions{Token: aclfilter.RedactedToken},",
          "",
          "---------------"
        ],
        "agent/consul/acl_replication_types.go||agent/consul/acl_replication_types.go": [
          "File: agent/consul/acl_replication_types.go -> agent/consul/acl_replication_types.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "5:  \"fmt\"",
          "7:  \"github.com/hashicorp/consul/agent/structs\"",
          "8: )",
          "10: type aclTokenReplicator struct {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8:  \"github.com/hashicorp/consul/agent/structs/aclfilter\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "99: }",
          "101: func (r *aclTokenReplicator) PendingUpdateIsRedacted(i int) bool {",
          "103: }",
          "105: func (r *aclTokenReplicator) UpdateLocalBatch(ctx context.Context, srv *Server, start, end int) error {",
          "",
          "[Removed Lines]",
          "102:  return r.updated[i].SecretID == redactedToken",
          "",
          "[Added Lines]",
          "103:  return r.updated[i].SecretID == aclfilter.RedactedToken",
          "",
          "---------------"
        ],
        "agent/consul/acl_test.go||agent/consul/acl_test.go": [
          "File: agent/consul/acl_test.go -> agent/consul/acl_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import (",
          "4:  \"fmt\"",
          "7:  \"strings\"",
          "8:  \"sync/atomic\"",
          "9:  \"testing\"",
          "10:  \"time\"",
          "13:  \"github.com/hashicorp/go-uuid\"",
          "14:  \"github.com/stretchr/testify/assert\"",
          "15:  \"github.com/stretchr/testify/require\"",
          "",
          "[Removed Lines]",
          "5:  \"os\"",
          "6:  \"reflect\"",
          "12:  \"github.com/hashicorp/go-hclog\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "20:  \"github.com/hashicorp/consul/acl/resolver\"",
          "21:  \"github.com/hashicorp/consul/agent/structs\"",
          "22:  \"github.com/hashicorp/consul/agent/token\"",
          "24:  \"github.com/hashicorp/consul/sdk/testutil\"",
          "25:  \"github.com/hashicorp/consul/sdk/testutil/retry\"",
          "26: )",
          "",
          "[Removed Lines]",
          "23:  \"github.com/hashicorp/consul/api\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2118:  })",
          "2119: }",
          "3781: func TestACL_LocalToken(t *testing.T) {",
          "3782:  t.Run(\"local token in same dc\", func(t *testing.T) {",
          "3783:   d := &ACLResolverTestDelegate{",
          "",
          "[Removed Lines]",
          "2121: func TestACL_filterHealthChecks(t *testing.T) {",
          "2122:  t.Parallel()",
          "2124:  logger := hclog.NewNullLogger()",
          "2126:  makeList := func() *structs.IndexedHealthChecks {",
          "2127:   return &structs.IndexedHealthChecks{",
          "2128:    HealthChecks: structs.HealthChecks{",
          "2129:     {",
          "2130:      Node:        \"node1\",",
          "2131:      CheckID:     \"check1\",",
          "2132:      ServiceName: \"foo\",",
          "2133:     },",
          "2134:    },",
          "2135:   }",
          "2136:  }",
          "2138:  t.Run(\"allowed\", func(t *testing.T) {",
          "2140:   policy, err := acl.NewPolicyFromSource(`",
          "2141:    service \"foo\" {",
          "2142:      policy = \"read\"",
          "2143:    }",
          "2144:    node \"node1\" {",
          "2145:      policy = \"read\"",
          "2146:    }",
          "2147:   `, acl.SyntaxLegacy, nil, nil)",
          "2148:   require.NoError(t, err)",
          "2150:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2151:   require.NoError(t, err)",
          "2153:   list := makeList()",
          "2154:   filterACLWithAuthorizer(logger, authz, list)",
          "2156:   require.Len(t, list.HealthChecks, 1)",
          "2157:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "2158:  })",
          "2160:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "2162:   policy, err := acl.NewPolicyFromSource(`",
          "2163:    service \"foo\" {",
          "2164:      policy = \"read\"",
          "2165:    }",
          "2166:   `, acl.SyntaxLegacy, nil, nil)",
          "2167:   require.NoError(t, err)",
          "2169:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2170:   require.NoError(t, err)",
          "2172:   list := makeList()",
          "2173:   filterACLWithAuthorizer(logger, authz, list)",
          "2175:   require.Empty(t, list.HealthChecks)",
          "2176:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2177:  })",
          "2179:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "2181:   policy, err := acl.NewPolicyFromSource(`",
          "2182:    node \"node1\" {",
          "2183:      policy = \"read\"",
          "2184:    }",
          "2185:   `, acl.SyntaxLegacy, nil, nil)",
          "2186:   require.NoError(t, err)",
          "2188:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2189:   require.NoError(t, err)",
          "2191:   list := makeList()",
          "2192:   filterACLWithAuthorizer(logger, authz, list)",
          "2194:   require.Empty(t, list.HealthChecks)",
          "2195:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2196:  })",
          "2198:  t.Run(\"denied\", func(t *testing.T) {",
          "2200:   list := makeList()",
          "2201:   filterACLWithAuthorizer(logger, acl.DenyAll(), list)",
          "2203:   require.Empty(t, list.HealthChecks)",
          "2204:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2205:  })",
          "2206: }",
          "2208: func TestACL_filterIntentions(t *testing.T) {",
          "2209:  t.Parallel()",
          "2211:  logger := hclog.NewNullLogger()",
          "2213:  makeList := func() *structs.IndexedIntentions {",
          "2214:   return &structs.IndexedIntentions{",
          "2215:    Intentions: structs.Intentions{",
          "2216:     &structs.Intention{",
          "2217:      ID:              \"f004177f-2c28-83b7-4229-eacc25fe55d1\",",
          "2218:      DestinationName: \"bar\",",
          "2219:     },",
          "2220:     &structs.Intention{",
          "2221:      ID:              \"f004177f-2c28-83b7-4229-eacc25fe55d2\",",
          "2222:      DestinationName: \"foo\",",
          "2223:     },",
          "2224:    },",
          "2225:   }",
          "2226:  }",
          "2228:  t.Run(\"allowed\", func(t *testing.T) {",
          "2230:   list := makeList()",
          "2231:   filterACLWithAuthorizer(logger, acl.AllowAll(), list)",
          "2233:   require.Len(t, list.Intentions, 2)",
          "2234:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "2235:  })",
          "2237:  t.Run(\"allowed to read 1\", func(t *testing.T) {",
          "2239:   policy, err := acl.NewPolicyFromSource(`",
          "2240:    service \"foo\" {",
          "2241:      policy = \"read\"",
          "2242:    }",
          "2243:   `, acl.SyntaxLegacy, nil, nil)",
          "2244:   require.NoError(t, err)",
          "2246:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2247:   require.NoError(t, err)",
          "2249:   list := makeList()",
          "2250:   filterACLWithAuthorizer(logger, authz, list)",
          "2252:   require.Len(t, list.Intentions, 1)",
          "2253:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2254:  })",
          "2256:  t.Run(\"denied\", func(t *testing.T) {",
          "2258:   list := makeList()",
          "2259:   filterACLWithAuthorizer(logger, acl.DenyAll(), list)",
          "2261:   require.Empty(t, list.Intentions)",
          "2262:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2263:  })",
          "2264: }",
          "2266: func TestACL_filterServices(t *testing.T) {",
          "2267:  t.Parallel()",
          "2270:  services := structs.Services{",
          "2271:   \"service1\": []string{},",
          "2272:   \"service2\": []string{},",
          "2273:   \"consul\":   []string{},",
          "2274:  }",
          "2277:  filt := newACLFilter(acl.AllowAll(), nil)",
          "2278:  removed := filt.filterServices(services, nil)",
          "2279:  require.False(t, removed)",
          "2280:  require.Len(t, services, 3)",
          "2283:  filt = newACLFilter(acl.DenyAll(), nil)",
          "2284:  removed = filt.filterServices(services, nil)",
          "2285:  require.True(t, removed)",
          "2286:  require.Empty(t, services)",
          "2287: }",
          "2289: func TestACL_filterServiceNodes(t *testing.T) {",
          "2290:  t.Parallel()",
          "2292:  logger := hclog.NewNullLogger()",
          "2294:  makeList := func() *structs.IndexedServiceNodes {",
          "2295:   return &structs.IndexedServiceNodes{",
          "2296:    ServiceNodes: structs.ServiceNodes{",
          "2297:     {",
          "2298:      Node:        \"node1\",",
          "2299:      ServiceName: \"foo\",",
          "2300:     },",
          "2301:    },",
          "2302:   }",
          "2303:  }",
          "2305:  t.Run(\"allowed\", func(t *testing.T) {",
          "2307:   policy, err := acl.NewPolicyFromSource(`",
          "2308:    service \"foo\" {",
          "2309:      policy = \"read\"",
          "2310:    }",
          "2311:    node \"node1\" {",
          "2312:      policy = \"read\"",
          "2313:    }",
          "2314:   `, acl.SyntaxLegacy, nil, nil)",
          "2315:   require.NoError(t, err)",
          "2317:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2318:   require.NoError(t, err)",
          "2320:   list := makeList()",
          "2321:   filterACLWithAuthorizer(logger, authz, list)",
          "2323:   require.Len(t, list.ServiceNodes, 1)",
          "2324:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "2325:  })",
          "2327:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "2329:   policy, err := acl.NewPolicyFromSource(`",
          "2330:    service \"foo\" {",
          "2331:      policy = \"read\"",
          "2332:    }",
          "2333:   `, acl.SyntaxLegacy, nil, nil)",
          "2334:   require.NoError(t, err)",
          "2336:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2337:   require.NoError(t, err)",
          "2339:   list := makeList()",
          "2340:   filterACLWithAuthorizer(logger, authz, list)",
          "2342:   require.Empty(t, list.ServiceNodes)",
          "2343:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2344:  })",
          "2346:  t.Run(\"denied\", func(t *testing.T) {",
          "2348:   list := makeList()",
          "2349:   filterACLWithAuthorizer(logger, acl.DenyAll(), list)",
          "2351:   require.Empty(t, list.ServiceNodes)",
          "2352:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2353:  })",
          "2354: }",
          "2356: func TestACL_filterNodeServices(t *testing.T) {",
          "2357:  t.Parallel()",
          "2359:  logger := hclog.NewNullLogger()",
          "2361:  makeList := func() *structs.IndexedNodeServices {",
          "2362:   return &structs.IndexedNodeServices{",
          "2363:    NodeServices: &structs.NodeServices{",
          "2364:     Node: &structs.Node{",
          "2365:      Node: \"node1\",",
          "2366:     },",
          "2367:     Services: map[string]*structs.NodeService{",
          "2368:      \"foo\": {",
          "2369:       ID:      \"foo\",",
          "2370:       Service: \"foo\",",
          "2371:      },",
          "2372:     },",
          "2373:    },",
          "2374:   }",
          "2375:  }",
          "2377:  t.Run(\"nil input\", func(t *testing.T) {",
          "2379:   list := &structs.IndexedNodeServices{",
          "2380:    NodeServices: nil,",
          "2381:   }",
          "2382:   filterACLWithAuthorizer(logger, acl.AllowAll(), list)",
          "2384:   require.Nil(t, list.NodeServices)",
          "2385:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "2386:  })",
          "2388:  t.Run(\"allowed\", func(t *testing.T) {",
          "2390:   policy, err := acl.NewPolicyFromSource(`",
          "2391:    service \"foo\" {",
          "2392:      policy = \"read\"",
          "2393:    }",
          "2394:    node \"node1\" {",
          "2395:      policy = \"read\"",
          "2396:    }",
          "2397:   `, acl.SyntaxLegacy, nil, nil)",
          "2398:   require.NoError(t, err)",
          "2400:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2401:   require.NoError(t, err)",
          "2403:   list := makeList()",
          "2404:   filterACLWithAuthorizer(logger, authz, list)",
          "2406:   require.Len(t, list.NodeServices.Services, 1)",
          "2407:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "2408:  })",
          "2410:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "2412:   policy, err := acl.NewPolicyFromSource(`",
          "2413:    service \"foo\" {",
          "2414:      policy = \"read\"",
          "2415:    }",
          "2416:   `, acl.SyntaxLegacy, nil, nil)",
          "2417:   require.NoError(t, err)",
          "2419:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2420:   require.NoError(t, err)",
          "2422:   list := makeList()",
          "2423:   filterACLWithAuthorizer(logger, authz, list)",
          "2425:   require.Nil(t, list.NodeServices)",
          "2426:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2427:  })",
          "2429:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "2431:   policy, err := acl.NewPolicyFromSource(`",
          "2432:    node \"node1\" {",
          "2433:      policy = \"read\"",
          "2434:    }",
          "2435:   `, acl.SyntaxLegacy, nil, nil)",
          "2436:   require.NoError(t, err)",
          "2438:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2439:   require.NoError(t, err)",
          "2441:   list := makeList()",
          "2442:   filterACLWithAuthorizer(logger, authz, list)",
          "2444:   require.Empty(t, list.NodeServices.Services)",
          "2445:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2446:  })",
          "2448:  t.Run(\"denied\", func(t *testing.T) {",
          "2450:   list := makeList()",
          "2451:   filterACLWithAuthorizer(logger, acl.DenyAll(), list)",
          "2453:   require.Nil(t, list.NodeServices)",
          "2454:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2455:  })",
          "2456: }",
          "2458: func TestACL_filterNodeServiceList(t *testing.T) {",
          "2459:  t.Parallel()",
          "2461:  logger := hclog.NewNullLogger()",
          "2463:  makeList := func() *structs.IndexedNodeServiceList {",
          "2464:   return &structs.IndexedNodeServiceList{",
          "2465:    NodeServices: structs.NodeServiceList{",
          "2466:     Node: &structs.Node{",
          "2467:      Node: \"node1\",",
          "2468:     },",
          "2469:     Services: []*structs.NodeService{",
          "2470:      {Service: \"foo\"},",
          "2471:     },",
          "2472:    },",
          "2473:   }",
          "2474:  }",
          "2476:  t.Run(\"empty NodeServices\", func(t *testing.T) {",
          "2478:   var list structs.IndexedNodeServiceList",
          "2479:   filterACLWithAuthorizer(logger, acl.AllowAll(), &list)",
          "2481:   require.Empty(t, list)",
          "2482:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "2483:  })",
          "2485:  t.Run(\"allowed\", func(t *testing.T) {",
          "2487:   policy, err := acl.NewPolicyFromSource(`",
          "2488:    service \"foo\" {",
          "2489:      policy = \"read\"",
          "2490:    }",
          "2491:    node \"node1\" {",
          "2492:      policy = \"read\"",
          "2493:    }",
          "2494:   `, acl.SyntaxLegacy, nil, nil)",
          "2495:   require.NoError(t, err)",
          "2497:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2498:   require.NoError(t, err)",
          "2500:   list := makeList()",
          "2501:   filterACLWithAuthorizer(logger, authz, list)",
          "2503:   require.Len(t, list.NodeServices.Services, 1)",
          "2504:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "2505:  })",
          "2507:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "2509:   policy, err := acl.NewPolicyFromSource(`",
          "2510:    service \"foo\" {",
          "2511:      policy = \"read\"",
          "2512:    }",
          "2513:   `, acl.SyntaxLegacy, nil, nil)",
          "2514:   require.NoError(t, err)",
          "2516:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2517:   require.NoError(t, err)",
          "2519:   list := makeList()",
          "2520:   filterACLWithAuthorizer(logger, authz, list)",
          "2522:   require.Empty(t, list.NodeServices)",
          "2523:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2524:  })",
          "2526:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "2528:   policy, err := acl.NewPolicyFromSource(`",
          "2529:    node \"node1\" {",
          "2530:      policy = \"read\"",
          "2531:    }",
          "2532:   `, acl.SyntaxLegacy, nil, nil)",
          "2533:   require.NoError(t, err)",
          "2535:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2536:   require.NoError(t, err)",
          "2538:   list := makeList()",
          "2539:   filterACLWithAuthorizer(logger, authz, list)",
          "2541:   require.NotEmpty(t, list.NodeServices.Node)",
          "2542:   require.Empty(t, list.NodeServices.Services)",
          "2543:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2544:  })",
          "2546:  t.Run(\"denied\", func(t *testing.T) {",
          "2548:   list := makeList()",
          "2549:   filterACLWithAuthorizer(logger, acl.DenyAll(), list)",
          "2551:   require.Empty(t, list.NodeServices)",
          "2552:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2553:  })",
          "2554: }",
          "2556: func TestACL_filterGatewayServices(t *testing.T) {",
          "2557:  t.Parallel()",
          "2559:  logger := hclog.NewNullLogger()",
          "2561:  makeList := func() *structs.IndexedGatewayServices {",
          "2562:   return &structs.IndexedGatewayServices{",
          "2563:    Services: structs.GatewayServices{",
          "2564:     {Service: structs.ServiceName{Name: \"foo\"}},",
          "2565:    },",
          "2566:   }",
          "2567:  }",
          "2569:  t.Run(\"allowed\", func(t *testing.T) {",
          "2571:   policy, err := acl.NewPolicyFromSource(`",
          "2572:    service \"foo\" {",
          "2573:      policy = \"read\"",
          "2574:    }",
          "2575:   `, acl.SyntaxLegacy, nil, nil)",
          "2576:   require.NoError(t, err)",
          "2578:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2579:   require.NoError(t, err)",
          "2581:   list := makeList()",
          "2582:   filterACLWithAuthorizer(logger, authz, list)",
          "2584:   require.Len(t, list.Services, 1)",
          "2585:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "2586:  })",
          "2588:  t.Run(\"denied\", func(t *testing.T) {",
          "2590:   list := makeList()",
          "2591:   filterACLWithAuthorizer(logger, acl.DenyAll(), list)",
          "2593:   require.Empty(t, list.Services)",
          "2594:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2595:  })",
          "2596: }",
          "2598: func TestACL_filterCheckServiceNodes(t *testing.T) {",
          "2599:  t.Parallel()",
          "2601:  logger := hclog.NewNullLogger()",
          "2603:  makeList := func() *structs.IndexedCheckServiceNodes {",
          "2604:   return &structs.IndexedCheckServiceNodes{",
          "2605:    Nodes: structs.CheckServiceNodes{",
          "2606:     {",
          "2607:      Node: &structs.Node{",
          "2608:       Node: \"node1\",",
          "2609:      },",
          "2610:      Service: &structs.NodeService{",
          "2611:       ID:      \"foo\",",
          "2612:       Service: \"foo\",",
          "2613:      },",
          "2614:      Checks: structs.HealthChecks{",
          "2615:       {",
          "2616:        Node:        \"node1\",",
          "2617:        CheckID:     \"check1\",",
          "2618:        ServiceName: \"foo\",",
          "2619:       },",
          "2620:      },",
          "2621:     },",
          "2622:    },",
          "2623:   }",
          "2624:  }",
          "2626:  t.Run(\"allowed\", func(t *testing.T) {",
          "2628:   policy, err := acl.NewPolicyFromSource(`",
          "2629:    service \"foo\" {",
          "2630:      policy = \"read\"",
          "2631:    }",
          "2632:    node \"node1\" {",
          "2633:      policy = \"read\"",
          "2634:    }",
          "2635:   `, acl.SyntaxLegacy, nil, nil)",
          "2636:   require.NoError(t, err)",
          "2638:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2639:   require.NoError(t, err)",
          "2641:   list := makeList()",
          "2642:   filterACLWithAuthorizer(logger, authz, list)",
          "2644:   require.Len(t, list.Nodes, 1)",
          "2645:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "2646:  })",
          "2648:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "2650:   policy, err := acl.NewPolicyFromSource(`",
          "2651:    service \"foo\" {",
          "2652:      policy = \"read\"",
          "2653:    }",
          "2654:   `, acl.SyntaxLegacy, nil, nil)",
          "2655:   require.NoError(t, err)",
          "2657:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2658:   require.NoError(t, err)",
          "2660:   list := makeList()",
          "2661:   filterACLWithAuthorizer(logger, authz, list)",
          "2663:   require.Empty(t, list.Nodes)",
          "2664:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2665:  })",
          "2667:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "2669:   policy, err := acl.NewPolicyFromSource(`",
          "2670:    node \"node1\" {",
          "2671:      policy = \"read\"",
          "2672:    }",
          "2673:   `, acl.SyntaxLegacy, nil, nil)",
          "2674:   require.NoError(t, err)",
          "2676:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2677:   require.NoError(t, err)",
          "2679:   list := makeList()",
          "2680:   filterACLWithAuthorizer(logger, authz, list)",
          "2682:   require.Empty(t, list.Nodes)",
          "2683:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2684:  })",
          "2686:  t.Run(\"denied\", func(t *testing.T) {",
          "2688:   list := makeList()",
          "2689:   filterACLWithAuthorizer(logger, acl.DenyAll(), list)",
          "2691:   require.Empty(t, list.Nodes)",
          "2692:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2693:  })",
          "2694: }",
          "2696: func TestACL_filterPreparedQueryExecuteResponse(t *testing.T) {",
          "2697:  t.Parallel()",
          "2699:  logger := hclog.NewNullLogger()",
          "2701:  makeList := func() *structs.PreparedQueryExecuteResponse {",
          "2702:   return &structs.PreparedQueryExecuteResponse{",
          "2703:    Nodes: structs.CheckServiceNodes{",
          "2704:     {",
          "2705:      Node: &structs.Node{",
          "2706:       Node: \"node1\",",
          "2707:      },",
          "2708:      Service: &structs.NodeService{",
          "2709:       ID:      \"foo\",",
          "2710:       Service: \"foo\",",
          "2711:      },",
          "2712:      Checks: structs.HealthChecks{",
          "2713:       {",
          "2714:        Node:        \"node1\",",
          "2715:        CheckID:     \"check1\",",
          "2716:        ServiceName: \"foo\",",
          "2717:       },",
          "2718:      },",
          "2719:     },",
          "2720:    },",
          "2721:   }",
          "2722:  }",
          "2724:  t.Run(\"allowed\", func(t *testing.T) {",
          "2726:   policy, err := acl.NewPolicyFromSource(`",
          "2727:    service \"foo\" {",
          "2728:      policy = \"read\"",
          "2729:    }",
          "2730:    node \"node1\" {",
          "2731:      policy = \"read\"",
          "2732:    }",
          "2733:   `, acl.SyntaxLegacy, nil, nil)",
          "2734:   require.NoError(t, err)",
          "2736:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2737:   require.NoError(t, err)",
          "2739:   list := makeList()",
          "2740:   filterACLWithAuthorizer(logger, authz, list)",
          "2742:   require.Len(t, list.Nodes, 1)",
          "2743:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "2744:  })",
          "2746:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "2748:   policy, err := acl.NewPolicyFromSource(`",
          "2749:    service \"foo\" {",
          "2750:      policy = \"read\"",
          "2751:    }",
          "2752:   `, acl.SyntaxLegacy, nil, nil)",
          "2753:   require.NoError(t, err)",
          "2755:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2756:   require.NoError(t, err)",
          "2758:   list := makeList()",
          "2759:   filterACLWithAuthorizer(logger, authz, list)",
          "2761:   require.Empty(t, list.Nodes)",
          "2762:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2763:  })",
          "2765:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "2767:   policy, err := acl.NewPolicyFromSource(`",
          "2768:    node \"node1\" {",
          "2769:      policy = \"read\"",
          "2770:    }",
          "2771:   `, acl.SyntaxLegacy, nil, nil)",
          "2772:   require.NoError(t, err)",
          "2774:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2775:   require.NoError(t, err)",
          "2777:   list := makeList()",
          "2778:   filterACLWithAuthorizer(logger, authz, list)",
          "2780:   require.Empty(t, list.Nodes)",
          "2781:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2782:  })",
          "2784:  t.Run(\"denied\", func(t *testing.T) {",
          "2786:   list := makeList()",
          "2787:   filterACLWithAuthorizer(logger, acl.DenyAll(), list)",
          "2789:   require.Empty(t, list.Nodes)",
          "2790:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2791:  })",
          "2792: }",
          "2794: func TestACL_filterServiceTopology(t *testing.T) {",
          "2795:  t.Parallel()",
          "2797:  fill := func() structs.ServiceTopology {",
          "2798:   return structs.ServiceTopology{",
          "2799:    Upstreams: structs.CheckServiceNodes{",
          "2800:     structs.CheckServiceNode{",
          "2801:      Node: &structs.Node{",
          "2802:       Node: \"node1\",",
          "2803:      },",
          "2804:      Service: &structs.NodeService{",
          "2805:       ID:      \"foo\",",
          "2806:       Service: \"foo\",",
          "2807:      },",
          "2808:      Checks: structs.HealthChecks{",
          "2809:       &structs.HealthCheck{",
          "2810:        Node:        \"node1\",",
          "2811:        CheckID:     \"check1\",",
          "2812:        ServiceName: \"foo\",",
          "2813:       },",
          "2814:      },",
          "2815:     },",
          "2816:    },",
          "2817:    Downstreams: structs.CheckServiceNodes{",
          "2818:     structs.CheckServiceNode{",
          "2819:      Node: &structs.Node{",
          "2820:       Node: \"node2\",",
          "2821:      },",
          "2822:      Service: &structs.NodeService{",
          "2823:       ID:      \"bar\",",
          "2824:       Service: \"bar\",",
          "2825:      },",
          "2826:      Checks: structs.HealthChecks{",
          "2827:       &structs.HealthCheck{",
          "2828:        Node:        \"node2\",",
          "2829:        CheckID:     \"check1\",",
          "2830:        ServiceName: \"bar\",",
          "2831:       },",
          "2832:      },",
          "2833:     },",
          "2834:    },",
          "2835:   }",
          "2836:  }",
          "2837:  original := fill()",
          "2839:  t.Run(\"allow all without permissions\", func(t *testing.T) {",
          "2840:   topo := fill()",
          "2841:   f := newACLFilter(acl.AllowAll(), nil)",
          "2843:   filtered := f.filterServiceTopology(&topo)",
          "2844:   if filtered {",
          "2845:    t.Fatalf(\"should not have been filtered\")",
          "2846:   }",
          "2847:   assert.Equal(t, original, topo)",
          "2848:  })",
          "2850:  t.Run(\"deny all without permissions\", func(t *testing.T) {",
          "2851:   topo := fill()",
          "2852:   f := newACLFilter(acl.DenyAll(), nil)",
          "2854:   filtered := f.filterServiceTopology(&topo)",
          "2855:   if !filtered {",
          "2856:    t.Fatalf(\"should have been marked as filtered\")",
          "2857:   }",
          "2858:   assert.Len(t, topo.Upstreams, 0)",
          "2859:   assert.Len(t, topo.Upstreams, 0)",
          "2860:  })",
          "2862:  t.Run(\"only upstream permissions\", func(t *testing.T) {",
          "2863:   rules := `",
          "2864: node \"node1\" {",
          "2865:   policy = \"read\"",
          "2866: }",
          "2867: service \"foo\" {",
          "2868:   policy = \"read\"",
          "2869: }`",
          "2870:   policy, err := acl.NewPolicyFromSource(rules, acl.SyntaxLegacy, nil, nil)",
          "2871:   if err != nil {",
          "2872:    t.Fatalf(\"err %v\", err)",
          "2873:   }",
          "2874:   perms, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2875:   if err != nil {",
          "2876:    t.Fatalf(\"err: %v\", err)",
          "2877:   }",
          "2879:   topo := fill()",
          "2880:   f := newACLFilter(perms, nil)",
          "2882:   filtered := f.filterServiceTopology(&topo)",
          "2883:   if !filtered {",
          "2884:    t.Fatalf(\"should have been marked as filtered\")",
          "2885:   }",
          "2886:   assert.Equal(t, original.Upstreams, topo.Upstreams)",
          "2887:   assert.Len(t, topo.Downstreams, 0)",
          "2888:  })",
          "2890:  t.Run(\"only downstream permissions\", func(t *testing.T) {",
          "2891:   rules := `",
          "2892: node \"node2\" {",
          "2893:   policy = \"read\"",
          "2894: }",
          "2895: service \"bar\" {",
          "2896:   policy = \"read\"",
          "2897: }`",
          "2898:   policy, err := acl.NewPolicyFromSource(rules, acl.SyntaxLegacy, nil, nil)",
          "2899:   if err != nil {",
          "2900:    t.Fatalf(\"err %v\", err)",
          "2901:   }",
          "2902:   perms, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2903:   if err != nil {",
          "2904:    t.Fatalf(\"err: %v\", err)",
          "2905:   }",
          "2907:   topo := fill()",
          "2908:   f := newACLFilter(perms, nil)",
          "2910:   filtered := f.filterServiceTopology(&topo)",
          "2911:   if !filtered {",
          "2912:    t.Fatalf(\"should have been marked as filtered\")",
          "2913:   }",
          "2914:   assert.Equal(t, original.Downstreams, topo.Downstreams)",
          "2915:   assert.Len(t, topo.Upstreams, 0)",
          "2916:  })",
          "2918:  t.Run(\"upstream and downstream permissions\", func(t *testing.T) {",
          "2919:   rules := `",
          "2920: node \"node1\" {",
          "2921:   policy = \"read\"",
          "2922: }",
          "2923: service \"foo\" {",
          "2924:   policy = \"read\"",
          "2925: }",
          "2926: node \"node2\" {",
          "2927:   policy = \"read\"",
          "2928: }",
          "2929: service \"bar\" {",
          "2930:   policy = \"read\"",
          "2931: }`",
          "2932:   policy, err := acl.NewPolicyFromSource(rules, acl.SyntaxLegacy, nil, nil)",
          "2933:   if err != nil {",
          "2934:    t.Fatalf(\"err %v\", err)",
          "2935:   }",
          "2936:   perms, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2937:   if err != nil {",
          "2938:    t.Fatalf(\"err: %v\", err)",
          "2939:   }",
          "2941:   topo := fill()",
          "2942:   f := newACLFilter(perms, nil)",
          "2944:   filtered := f.filterServiceTopology(&topo)",
          "2945:   if filtered {",
          "2946:    t.Fatalf(\"should not have been filtered\")",
          "2947:   }",
          "2949:   original := fill()",
          "2950:   assert.Equal(t, original, topo)",
          "2951:  })",
          "2952: }",
          "2954: func TestACL_filterCoordinates(t *testing.T) {",
          "2955:  t.Parallel()",
          "2957:  logger := hclog.NewNullLogger()",
          "2959:  makeList := func() *structs.IndexedCoordinates {",
          "2960:   return &structs.IndexedCoordinates{",
          "2961:    Coordinates: structs.Coordinates{",
          "2962:     {Node: \"node1\", Coord: generateRandomCoordinate()},",
          "2963:     {Node: \"node2\", Coord: generateRandomCoordinate()},",
          "2964:    },",
          "2965:   }",
          "2966:  }",
          "2968:  t.Run(\"allowed\", func(t *testing.T) {",
          "2970:   list := makeList()",
          "2971:   filterACLWithAuthorizer(logger, acl.AllowAll(), list)",
          "2973:   require.Len(t, list.Coordinates, 2)",
          "2974:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "2975:  })",
          "2977:  t.Run(\"allowed to read one node\", func(t *testing.T) {",
          "2979:   policy, err := acl.NewPolicyFromSource(`",
          "2980:    node \"node1\" {",
          "2981:      policy = \"read\"",
          "2982:    }",
          "2983:   `, acl.SyntaxLegacy, nil, nil)",
          "2984:   require.NoError(t, err)",
          "2986:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "2987:   require.NoError(t, err)",
          "2989:   list := makeList()",
          "2990:   filterACLWithAuthorizer(logger, authz, list)",
          "2992:   require.Len(t, list.Coordinates, 1)",
          "2993:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "2994:  })",
          "2996:  t.Run(\"denied\", func(t *testing.T) {",
          "2998:   list := makeList()",
          "2999:   filterACLWithAuthorizer(logger, acl.DenyAll(), list)",
          "3001:   require.Empty(t, list.Coordinates)",
          "3002:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3003:  })",
          "3004: }",
          "3006: func TestACL_filterSessions(t *testing.T) {",
          "3007:  t.Parallel()",
          "3009:  logger := hclog.NewNullLogger()",
          "3011:  makeList := func() *structs.IndexedSessions {",
          "3012:   return &structs.IndexedSessions{",
          "3013:    Sessions: structs.Sessions{",
          "3014:     {Node: \"foo\"},",
          "3015:     {Node: \"bar\"},",
          "3016:    },",
          "3017:   }",
          "3018:  }",
          "3020:  t.Run(\"all allowed\", func(t *testing.T) {",
          "3022:   list := makeList()",
          "3023:   filterACLWithAuthorizer(logger, acl.AllowAll(), list)",
          "3025:   require.Len(t, list.Sessions, 2)",
          "3026:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "3027:  })",
          "3029:  t.Run(\"just one node's sessions allowed\", func(t *testing.T) {",
          "3031:   policy, err := acl.NewPolicyFromSource(`",
          "3032:    session \"foo\" {",
          "3033:      policy = \"read\"",
          "3034:    }",
          "3035:   `, acl.SyntaxLegacy, nil, nil)",
          "3036:   require.NoError(t, err)",
          "3038:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3039:   require.NoError(t, err)",
          "3041:   list := makeList()",
          "3042:   filterACLWithAuthorizer(logger, authz, list)",
          "3044:   require.Len(t, list.Sessions, 1)",
          "3045:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3046:  })",
          "3048:  t.Run(\"denied\", func(t *testing.T) {",
          "3050:   list := makeList()",
          "3051:   filterACLWithAuthorizer(logger, acl.DenyAll(), list)",
          "3053:   require.Empty(t, list.Sessions)",
          "3054:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3055:  })",
          "3056: }",
          "3058: func TestACL_filterNodeDump(t *testing.T) {",
          "3059:  t.Parallel()",
          "3061:  logger := hclog.NewNullLogger()",
          "3063:  makeList := func() *structs.IndexedNodeDump {",
          "3064:   return &structs.IndexedNodeDump{",
          "3065:    Dump: structs.NodeDump{",
          "3066:     {",
          "3067:      Node: \"node1\",",
          "3068:      Services: []*structs.NodeService{",
          "3069:       {",
          "3070:        ID:      \"foo\",",
          "3071:        Service: \"foo\",",
          "3072:       },",
          "3073:      },",
          "3074:      Checks: []*structs.HealthCheck{",
          "3075:       {",
          "3076:        Node:        \"node1\",",
          "3077:        CheckID:     \"check1\",",
          "3078:        ServiceName: \"foo\",",
          "3079:       },",
          "3080:      },",
          "3081:     },",
          "3082:    },",
          "3083:   }",
          "3084:  }",
          "3086:  t.Run(\"allowed\", func(t *testing.T) {",
          "3088:   policy, err := acl.NewPolicyFromSource(`",
          "3089:    service \"foo\" {",
          "3090:      policy = \"read\"",
          "3091:    }",
          "3092:    node \"node1\" {",
          "3093:      policy = \"read\"",
          "3094:    }",
          "3095:   `, acl.SyntaxLegacy, nil, nil)",
          "3096:   require.NoError(t, err)",
          "3098:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3099:   require.NoError(t, err)",
          "3101:   list := makeList()",
          "3102:   filterACLWithAuthorizer(logger, authz, list)",
          "3104:   require.Len(t, list.Dump, 1)",
          "3105:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "3106:  })",
          "3108:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "3110:   policy, err := acl.NewPolicyFromSource(`",
          "3111:    service \"foo\" {",
          "3112:      policy = \"read\"",
          "3113:    }",
          "3114:   `, acl.SyntaxLegacy, nil, nil)",
          "3115:   require.NoError(t, err)",
          "3117:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3118:   require.NoError(t, err)",
          "3120:   list := makeList()",
          "3121:   filterACLWithAuthorizer(logger, authz, list)",
          "3123:   require.Empty(t, list.Dump)",
          "3124:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3125:  })",
          "3127:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "3129:   policy, err := acl.NewPolicyFromSource(`",
          "3130:    node \"node1\" {",
          "3131:      policy = \"read\"",
          "3132:    }",
          "3133:   `, acl.SyntaxLegacy, nil, nil)",
          "3134:   require.NoError(t, err)",
          "3136:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3137:   require.NoError(t, err)",
          "3139:   list := makeList()",
          "3140:   filterACLWithAuthorizer(logger, authz, list)",
          "3142:   require.Len(t, list.Dump, 1)",
          "3143:   require.Empty(t, list.Dump[0].Services)",
          "3144:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3145:  })",
          "3147:  t.Run(\"denied\", func(t *testing.T) {",
          "3149:   list := makeList()",
          "3150:   filterACLWithAuthorizer(logger, acl.DenyAll(), list)",
          "3152:   require.Empty(t, list.Dump)",
          "3153:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3154:  })",
          "3155: }",
          "3157: func TestACL_filterNodes(t *testing.T) {",
          "3158:  t.Parallel()",
          "3161:  nodes := structs.Nodes{",
          "3162:   &structs.Node{",
          "3163:    Node: \"foo\",",
          "3164:   },",
          "3165:   &structs.Node{",
          "3166:    Node: \"bar\",",
          "3167:   },",
          "3168:  }",
          "3171:  filt := newACLFilter(acl.AllowAll(), nil)",
          "3172:  removed := filt.filterNodes(&nodes)",
          "3173:  require.False(t, removed)",
          "3174:  require.Len(t, nodes, 2)",
          "3177:  filt = newACLFilter(acl.DenyAll(), nil)",
          "3178:  removed = filt.filterNodes(&nodes)",
          "3179:  require.True(t, removed)",
          "3180:  require.Len(t, nodes, 0)",
          "3181: }",
          "3183: func TestACL_filterIndexedNodesWithGateways(t *testing.T) {",
          "3184:  t.Parallel()",
          "3186:  logger := hclog.NewNullLogger()",
          "3188:  makeList := func() *structs.IndexedNodesWithGateways {",
          "3189:   return &structs.IndexedNodesWithGateways{",
          "3190:    Nodes: structs.CheckServiceNodes{",
          "3191:     {",
          "3192:      Node: &structs.Node{",
          "3193:       Node: \"node1\",",
          "3194:      },",
          "3195:      Service: &structs.NodeService{",
          "3196:       ID:      \"foo\",",
          "3197:       Service: \"foo\",",
          "3198:      },",
          "3199:      Checks: structs.HealthChecks{",
          "3200:       {",
          "3201:        Node:        \"node1\",",
          "3202:        CheckID:     \"check1\",",
          "3203:        ServiceName: \"foo\",",
          "3204:       },",
          "3205:      },",
          "3206:     },",
          "3207:    },",
          "3208:    Gateways: structs.GatewayServices{",
          "3209:     {Service: structs.ServiceNameFromString(\"foo\")},",
          "3210:     {Service: structs.ServiceNameFromString(\"bar\")},",
          "3211:    },",
          "3212:   }",
          "3213:  }",
          "3215:  t.Run(\"allowed\", func(t *testing.T) {",
          "3217:   policy, err := acl.NewPolicyFromSource(`",
          "3218:    service \"foo\" {",
          "3219:      policy = \"read\"",
          "3220:    }",
          "3221:    service \"bar\" {",
          "3222:      policy = \"read\"",
          "3223:    }",
          "3224:    node \"node1\" {",
          "3225:      policy = \"read\"",
          "3226:    }",
          "3227:   `, acl.SyntaxLegacy, nil, nil)",
          "3228:   require.NoError(t, err)",
          "3230:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3231:   require.NoError(t, err)",
          "3233:   list := makeList()",
          "3234:   filterACLWithAuthorizer(logger, authz, list)",
          "3236:   require.Len(t, list.Nodes, 1)",
          "3237:   require.Len(t, list.Gateways, 2)",
          "3238:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "3239:  })",
          "3241:  t.Run(\"not allowed to read the node\", func(t *testing.T) {",
          "3243:   policy, err := acl.NewPolicyFromSource(`",
          "3244:    service \"foo\" {",
          "3245:      policy = \"read\"",
          "3246:    }",
          "3247:    service \"bar\" {",
          "3248:      policy = \"read\"",
          "3249:    }",
          "3250:   `, acl.SyntaxLegacy, nil, nil)",
          "3251:   require.NoError(t, err)",
          "3253:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3254:   require.NoError(t, err)",
          "3256:   list := makeList()",
          "3257:   filterACLWithAuthorizer(logger, authz, list)",
          "3259:   require.Empty(t, list.Nodes)",
          "3260:   require.Len(t, list.Gateways, 2)",
          "3261:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3262:  })",
          "3264:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "3266:   policy, err := acl.NewPolicyFromSource(`",
          "3267:    node \"node1\" {",
          "3268:      policy = \"read\"",
          "3269:    }",
          "3270:    service \"bar\" {",
          "3271:      policy = \"read\"",
          "3272:    }",
          "3273:   `, acl.SyntaxLegacy, nil, nil)",
          "3274:   require.NoError(t, err)",
          "3276:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3277:   require.NoError(t, err)",
          "3279:   list := makeList()",
          "3280:   filterACLWithAuthorizer(logger, authz, list)",
          "3282:   require.Empty(t, list.Nodes)",
          "3283:   require.Len(t, list.Gateways, 1)",
          "3284:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3285:  })",
          "3287:  t.Run(\"not allowed to read the other gatway service\", func(t *testing.T) {",
          "3289:   policy, err := acl.NewPolicyFromSource(`",
          "3290:    service \"foo\" {",
          "3291:      policy = \"read\"",
          "3292:    }",
          "3293:    node \"node1\" {",
          "3294:      policy = \"read\"",
          "3295:    }",
          "3296:   `, acl.SyntaxLegacy, nil, nil)",
          "3297:   require.NoError(t, err)",
          "3299:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3300:   require.NoError(t, err)",
          "3302:   list := makeList()",
          "3303:   filterACLWithAuthorizer(logger, authz, list)",
          "3305:   require.Len(t, list.Nodes, 1)",
          "3306:   require.Len(t, list.Gateways, 1)",
          "3307:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3308:  })",
          "3310:  t.Run(\"denied\", func(t *testing.T) {",
          "3312:   list := makeList()",
          "3313:   filterACLWithAuthorizer(logger, acl.DenyAll(), list)",
          "3315:   require.Empty(t, list.Nodes)",
          "3316:   require.Empty(t, list.Gateways)",
          "3317:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3318:  })",
          "3319: }",
          "3321: func TestACL_filterIndexedServiceDump(t *testing.T) {",
          "3322:  t.Parallel()",
          "3324:  logger := hclog.NewNullLogger()",
          "3326:  makeList := func() *structs.IndexedServiceDump {",
          "3327:   return &structs.IndexedServiceDump{",
          "3328:    Dump: structs.ServiceDump{",
          "3329:     {",
          "3330:      Node: &structs.Node{",
          "3331:       Node: \"node1\",",
          "3332:      },",
          "3333:      Service: &structs.NodeService{",
          "3334:       Service: \"foo\",",
          "3335:      },",
          "3336:      GatewayService: &structs.GatewayService{",
          "3337:       Service: structs.ServiceNameFromString(\"foo\"),",
          "3338:       Gateway: structs.ServiceNameFromString(\"foo-gateway\"),",
          "3339:      },",
          "3340:     },",
          "3342:     {",
          "3343:      GatewayService: &structs.GatewayService{",
          "3344:       Service: structs.ServiceNameFromString(\"bar\"),",
          "3345:       Gateway: structs.ServiceNameFromString(\"bar-gateway\"),",
          "3346:      },",
          "3347:     },",
          "3348:    },",
          "3349:   }",
          "3350:  }",
          "3352:  t.Run(\"allowed\", func(t *testing.T) {",
          "3354:   policy, err := acl.NewPolicyFromSource(`",
          "3355:    node \"node1\" {",
          "3356:      policy = \"read\"",
          "3357:    }",
          "3358:    service_prefix \"foo\" {",
          "3359:      policy = \"read\"",
          "3360:    }",
          "3361:    service_prefix \"bar\" {",
          "3362:      policy = \"read\"",
          "3363:    }",
          "3364:   `, acl.SyntaxCurrent, nil, nil)",
          "3365:   require.NoError(t, err)",
          "3367:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3368:   require.NoError(t, err)",
          "3370:   list := makeList()",
          "3371:   filterACLWithAuthorizer(logger, authz, list)",
          "3373:   require.Len(t, list.Dump, 2)",
          "3374:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "3375:  })",
          "3377:  t.Run(\"not allowed to access node\", func(t *testing.T) {",
          "3379:   policy, err := acl.NewPolicyFromSource(`",
          "3380:    service_prefix \"foo\" {",
          "3381:      policy = \"read\"",
          "3382:    }",
          "3383:    service_prefix \"bar\" {",
          "3384:      policy = \"read\"",
          "3385:    }",
          "3386:   `, acl.SyntaxCurrent, nil, nil)",
          "3387:   require.NoError(t, err)",
          "3389:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3390:   require.NoError(t, err)",
          "3392:   list := makeList()",
          "3393:   filterACLWithAuthorizer(logger, authz, list)",
          "3395:   require.Len(t, list.Dump, 1)",
          "3396:   require.Equal(t, \"bar\", list.Dump[0].GatewayService.Service.Name)",
          "3397:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3398:  })",
          "3400:  t.Run(\"not allowed to access service\", func(t *testing.T) {",
          "3402:   policy, err := acl.NewPolicyFromSource(`",
          "3403:    node \"node1\" {",
          "3404:      policy = \"read\"",
          "3405:    }",
          "3406:    service \"foo-gateway\" {",
          "3407:      policy = \"read\"",
          "3408:    }",
          "3409:   `, acl.SyntaxCurrent, nil, nil)",
          "3410:   require.NoError(t, err)",
          "3412:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3413:   require.NoError(t, err)",
          "3415:   list := makeList()",
          "3416:   filterACLWithAuthorizer(logger, authz, list)",
          "3418:   require.Empty(t, list.Dump)",
          "3419:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3420:  })",
          "3422:  t.Run(\"not allowed to access gateway\", func(t *testing.T) {",
          "3424:   policy, err := acl.NewPolicyFromSource(`",
          "3425:    node \"node1\" {",
          "3426:      policy = \"read\"",
          "3427:    }",
          "3428:    service \"foo\" {",
          "3429:      policy = \"read\"",
          "3430:    }",
          "3431:   `, acl.SyntaxCurrent, nil, nil)",
          "3432:   require.NoError(t, err)",
          "3434:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3435:   require.NoError(t, err)",
          "3437:   list := makeList()",
          "3438:   filterACLWithAuthorizer(logger, authz, list)",
          "3440:   require.Empty(t, list.Dump)",
          "3441:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3442:  })",
          "3443: }",
          "3445: func TestACL_filterDatacenterCheckServiceNodes(t *testing.T) {",
          "3446:  t.Parallel()",
          "3448:  logger := hclog.NewNullLogger()",
          "3450:  makeList := func() *structs.DatacenterIndexedCheckServiceNodes {",
          "3451:   return &structs.DatacenterIndexedCheckServiceNodes{",
          "3452:    DatacenterNodes: map[string]structs.CheckServiceNodes{",
          "3453:     \"dc1\": []structs.CheckServiceNode{",
          "3454:      newTestMeshGatewayNode(",
          "3455:       \"dc1\", \"gateway1a\", \"1.2.3.4\", 5555, map[string]string{structs.MetaWANFederationKey: \"1\"}, api.HealthPassing,",
          "3456:      ),",
          "3457:      newTestMeshGatewayNode(",
          "3458:       \"dc1\", \"gateway2a\", \"4.3.2.1\", 9999, map[string]string{structs.MetaWANFederationKey: \"1\"}, api.HealthPassing,",
          "3459:      ),",
          "3460:     },",
          "3461:     \"dc2\": []structs.CheckServiceNode{",
          "3462:      newTestMeshGatewayNode(",
          "3463:       \"dc2\", \"gateway1b\", \"5.6.7.8\", 9999, map[string]string{structs.MetaWANFederationKey: \"1\"}, api.HealthPassing,",
          "3464:      ),",
          "3465:      newTestMeshGatewayNode(",
          "3466:       \"dc2\", \"gateway2b\", \"8.7.6.5\", 1111, map[string]string{structs.MetaWANFederationKey: \"1\"}, api.HealthPassing,",
          "3467:      ),",
          "3468:     },",
          "3469:    },",
          "3470:   }",
          "3471:  }",
          "3473:  t.Run(\"allowed\", func(t *testing.T) {",
          "3475:   policy, err := acl.NewPolicyFromSource(`",
          "3476:    node_prefix \"\" {",
          "3477:      policy = \"read\"",
          "3478:    }",
          "3479:    service_prefix \"\" {",
          "3480:      policy = \"read\"",
          "3481:    }",
          "3482:   `, acl.SyntaxCurrent, nil, nil)",
          "3483:   require.NoError(t, err)",
          "3485:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3486:   require.NoError(t, err)",
          "3488:   list := makeList()",
          "3489:   filterACLWithAuthorizer(logger, authz, list)",
          "3491:   require.Len(t, list.DatacenterNodes[\"dc1\"], 2)",
          "3492:   require.Len(t, list.DatacenterNodes[\"dc2\"], 2)",
          "3493:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "3494:  })",
          "3496:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "3498:   policy, err := acl.NewPolicyFromSource(`",
          "3499:    service_prefix \"\" {",
          "3500:      policy = \"read\"",
          "3501:    }",
          "3502:   `, acl.SyntaxCurrent, nil, nil)",
          "3503:   require.NoError(t, err)",
          "3505:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3506:   require.NoError(t, err)",
          "3508:   list := makeList()",
          "3509:   filterACLWithAuthorizer(logger, authz, list)",
          "3511:   require.Empty(t, list.DatacenterNodes)",
          "3512:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3513:  })",
          "3515:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "3517:   policy, err := acl.NewPolicyFromSource(`",
          "3518:    node_prefix \"\" {",
          "3519:      policy = \"read\"",
          "3520:    }",
          "3521:   `, acl.SyntaxCurrent, nil, nil)",
          "3522:   require.NoError(t, err)",
          "3524:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3525:   require.NoError(t, err)",
          "3527:   list := makeList()",
          "3528:   filterACLWithAuthorizer(logger, authz, list)",
          "3530:   require.Empty(t, list.DatacenterNodes)",
          "3531:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3532:  })",
          "3534:  t.Run(\"denied\", func(t *testing.T) {",
          "3536:   list := makeList()",
          "3537:   filterACLWithAuthorizer(logger, acl.DenyAll(), list)",
          "3539:   require.Empty(t, list.DatacenterNodes)",
          "3540:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3541:  })",
          "3542: }",
          "3544: func TestACL_redactPreparedQueryTokens(t *testing.T) {",
          "3545:  t.Parallel()",
          "3546:  query := &structs.PreparedQuery{",
          "3547:   ID:    \"f004177f-2c28-83b7-4229-eacc25fe55d1\",",
          "3548:   Token: \"root\",",
          "3549:  }",
          "3551:  expected := &structs.PreparedQuery{",
          "3552:   ID:    \"f004177f-2c28-83b7-4229-eacc25fe55d1\",",
          "3553:   Token: \"root\",",
          "3554:  }",
          "3558:  filt := newACLFilter(acl.ManageAll(), nil)",
          "3559:  filt.redactPreparedQueryTokens(&query)",
          "3560:  if !reflect.DeepEqual(query, expected) {",
          "3561:   t.Fatalf(\"bad: %#v\", &query)",
          "3562:  }",
          "3566:  original := query",
          "3570:  filt = newACLFilter(acl.AllowAll(), nil)",
          "3571:  filt.redactPreparedQueryTokens(&query)",
          "3572:  expected.Token = redactedToken",
          "3573:  if !reflect.DeepEqual(query, expected) {",
          "3574:   t.Fatalf(\"bad: %#v\", *query)",
          "3575:  }",
          "3578:  if original.Token != \"root\" {",
          "3579:   t.Fatalf(\"bad token: %s\", original.Token)",
          "3580:  }",
          "3581: }",
          "3583: func TestFilterACL_redactTokenSecret(t *testing.T) {",
          "3584:  t.Parallel()",
          "3585:  delegate := &ACLResolverTestDelegate{",
          "3586:   enabled:       true,",
          "3587:   datacenter:    \"dc1\",",
          "3588:   legacy:        false,",
          "3589:   localTokens:   true,",
          "3590:   localPolicies: true,",
          "3592:  }",
          "3593:  r := newTestACLResolver(t, delegate, nil)",
          "3595:  token := &structs.ACLToken{",
          "3596:   AccessorID: \"6a5e25b3-28f2-4085-9012-c3fb754314d1\",",
          "3597:   SecretID:   \"6a5e25b3-28f2-4085-9012-c3fb754314d1\",",
          "3598:  }",
          "3600:  err := filterACL(r, \"acl-wr\", &token)",
          "3601:  require.NoError(t, err)",
          "3602:  require.Equal(t, \"6a5e25b3-28f2-4085-9012-c3fb754314d1\", token.SecretID)",
          "3604:  err = filterACL(r, \"acl-ro\", &token)",
          "3605:  require.NoError(t, err)",
          "3606:  require.Equal(t, redactedToken, token.SecretID)",
          "3607: }",
          "3609: func TestFilterACL_redactTokenSecrets(t *testing.T) {",
          "3610:  t.Parallel()",
          "3611:  delegate := &ACLResolverTestDelegate{",
          "3612:   enabled:       true,",
          "3613:   datacenter:    \"dc1\",",
          "3614:   legacy:        false,",
          "3615:   localTokens:   true,",
          "3616:   localPolicies: true,",
          "3618:  }",
          "3619:  r := newTestACLResolver(t, delegate, nil)",
          "3621:  tokens := structs.ACLTokens{",
          "3622:   &structs.ACLToken{",
          "3623:    AccessorID: \"6a5e25b3-28f2-4085-9012-c3fb754314d1\",",
          "3624:    SecretID:   \"6a5e25b3-28f2-4085-9012-c3fb754314d1\",",
          "3625:   },",
          "3626:  }",
          "3628:  err := filterACL(r, \"acl-wr\", &tokens)",
          "3629:  require.NoError(t, err)",
          "3630:  require.Equal(t, \"6a5e25b3-28f2-4085-9012-c3fb754314d1\", tokens[0].SecretID)",
          "3632:  err = filterACL(r, \"acl-ro\", &tokens)",
          "3633:  require.NoError(t, err)",
          "3634:  require.Equal(t, redactedToken, tokens[0].SecretID)",
          "3635: }",
          "3637: func TestACL_filterPreparedQueries(t *testing.T) {",
          "3638:  t.Parallel()",
          "3640:  logger := hclog.NewNullLogger()",
          "3642:  makeList := func() *structs.IndexedPreparedQueries {",
          "3643:   return &structs.IndexedPreparedQueries{",
          "3644:    Queries: structs.PreparedQueries{",
          "3645:     {ID: \"f004177f-2c28-83b7-4229-eacc25fe55d1\"},",
          "3646:     {",
          "3647:      ID:   \"f004177f-2c28-83b7-4229-eacc25fe55d2\",",
          "3648:      Name: \"query-with-no-token\",",
          "3649:     },",
          "3650:     {",
          "3651:      ID:    \"f004177f-2c28-83b7-4229-eacc25fe55d3\",",
          "3652:      Name:  \"query-with-a-token\",",
          "3653:      Token: \"root\",",
          "3654:     },",
          "3655:    },",
          "3656:   }",
          "3657:  }",
          "3659:  t.Run(\"management token\", func(t *testing.T) {",
          "3661:   list := makeList()",
          "3662:   filterACLWithAuthorizer(logger, acl.ManageAll(), list)",
          "3665:   require.Len(t, list.Queries, 3)",
          "3668:   require.Equal(t, \"root\", list.Queries[2].Token)",
          "3670:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "3671:  })",
          "3673:  t.Run(\"permissive filtering\", func(t *testing.T) {",
          "3675:   list := makeList()",
          "3676:   queryWithToken := list.Queries[2]",
          "3678:   filterACLWithAuthorizer(logger, acl.AllowAll(), list)",
          "3681:   require.Len(t, list.Queries, 2)",
          "3684:   require.Equal(t, redactedToken, list.Queries[1].Token)",
          "3687:   require.Equal(t, \"root\", queryWithToken.Token)",
          "3691:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "3692:  })",
          "3694:  t.Run(\"limited access\", func(t *testing.T) {",
          "3696:   policy, err := acl.NewPolicyFromSource(`",
          "3697:    query \"query-with-a-token\" {",
          "3698:      policy = \"read\"",
          "3699:    }",
          "3700:   `, acl.SyntaxLegacy, nil, nil)",
          "3701:   require.NoError(t, err)",
          "3703:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "3704:   require.NoError(t, err)",
          "3706:   list := makeList()",
          "3707:   filterACLWithAuthorizer(logger, authz, list)",
          "3710:   require.Len(t, list.Queries, 1)",
          "3713:   require.Equal(t, redactedToken, list.Queries[0].Token)",
          "3715:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3716:  })",
          "3718:  t.Run(\"restrictive filtering\", func(t *testing.T) {",
          "3720:   list := makeList()",
          "3721:   filterACLWithAuthorizer(logger, acl.DenyAll(), list)",
          "3723:   require.Empty(t, list.Queries)",
          "3724:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3725:  })",
          "3726: }",
          "3728: func TestACL_filterServiceList(t *testing.T) {",
          "3729:  logger := hclog.NewNullLogger()",
          "3731:  makeList := func() *structs.IndexedServiceList {",
          "3732:   return &structs.IndexedServiceList{",
          "3733:    Services: structs.ServiceList{",
          "3734:     {Name: \"foo\"},",
          "3735:     {Name: \"bar\"},",
          "3736:    },",
          "3737:   }",
          "3738:  }",
          "3740:  t.Run(\"permissive filtering\", func(t *testing.T) {",
          "3742:   list := makeList()",
          "3743:   filterACLWithAuthorizer(logger, acl.AllowAll(), list)",
          "3745:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "3746:   require.Len(t, list.Services, 2)",
          "3747:  })",
          "3749:  t.Run(\"restrictive filtering\", func(t *testing.T) {",
          "3751:   list := makeList()",
          "3752:   filterACLWithAuthorizer(logger, acl.DenyAll(), list)",
          "3754:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "3755:   require.Empty(t, list.Services)",
          "3756:  })",
          "3757: }",
          "3759: func TestACL_unhandledFilterType(t *testing.T) {",
          "3760:  if testing.Short() {",
          "3761:   t.Skip(\"too slow for testing.Short\")",
          "3762:  }",
          "3764:  t.Parallel()",
          "3765:  defer func(t *testing.T) {",
          "3766:   if recover() == nil {",
          "3767:    t.Fatalf(\"should panic\")",
          "3768:   }",
          "3769:  }(t)",
          "3772:  dir, token, srv, client := testACLFilterServer(t)",
          "3773:  defer os.RemoveAll(dir)",
          "3774:  defer srv.Shutdown()",
          "3775:  defer client.Close()",
          "3778:  srv.filterACL(token, &structs.HealthCheck{})",
          "3779: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "agent/consul/leader.go||agent/consul/leader.go": [
          "File: agent/consul/leader.go -> agent/consul/leader.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:  \"github.com/hashicorp/consul/acl\"",
          "24:  \"github.com/hashicorp/consul/agent/metadata\"",
          "25:  \"github.com/hashicorp/consul/agent/structs\"",
          "26:  \"github.com/hashicorp/consul/api\"",
          "27:  \"github.com/hashicorp/consul/lib\"",
          "28:  \"github.com/hashicorp/consul/logging\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26:  \"github.com/hashicorp/consul/agent/structs/aclfilter\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "387:  if !s.InPrimaryDatacenter() {",
          "389:   if err == nil && token != nil {",
          "390:    req := structs.ACLTokenBatchDeleteRequest{",
          "391:     TokenIDs: []string{token.AccessorID},",
          "",
          "[Removed Lines]",
          "388:   _, token, err := s.fsm.State().ACLTokenGetBySecret(nil, redactedToken, nil)",
          "",
          "[Added Lines]",
          "389:   _, token, err := s.fsm.State().ACLTokenGetBySecret(nil, aclfilter.RedactedToken, nil)",
          "",
          "---------------"
        ],
        "agent/consul/prepared_query_endpoint.go||agent/consul/prepared_query_endpoint.go": [
          "File: agent/consul/prepared_query_endpoint.go -> agent/consul/prepared_query_endpoint.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "14:  \"github.com/hashicorp/consul/acl\"",
          "15:  \"github.com/hashicorp/consul/agent/consul/state\"",
          "16:  \"github.com/hashicorp/consul/agent/structs\"",
          "17:  \"github.com/hashicorp/consul/logging\"",
          "18: )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17:  \"github.com/hashicorp/consul/agent/structs/aclfilter\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "163:   return fmt.Errorf(\"Bad Token '%s', it looks like a query definition with a redacted token was submitted\", query.Token)",
          "164:  }",
          "",
          "[Removed Lines]",
          "162:  if query.Token == redactedToken {",
          "",
          "[Added Lines]",
          "163:  if query.Token == aclfilter.RedactedToken {",
          "",
          "---------------"
        ],
        "agent/consul/prepared_query_endpoint_test.go||agent/consul/prepared_query_endpoint_test.go": [
          "File: agent/consul/prepared_query_endpoint_test.go -> agent/consul/prepared_query_endpoint_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:  \"github.com/hashicorp/consul/acl\"",
          "22:  \"github.com/hashicorp/consul/agent/structs\"",
          "23:  tokenStore \"github.com/hashicorp/consul/agent/token\"",
          "24:  \"github.com/hashicorp/consul/api\"",
          "25:  \"github.com/hashicorp/consul/sdk/testutil/retry\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23:  \"github.com/hashicorp/consul/agent/structs/aclfilter\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "570:   t.Fatalf(\"err: %v\", err)",
          "571:  }",
          "574:  err = parseQuery(query)",
          "575:  if err == nil || !strings.Contains(err.Error(), \"Bad Token\") {",
          "576:   t.Fatalf(\"bad: %v\", err)",
          "",
          "[Removed Lines]",
          "573:  query.Token = redactedToken",
          "",
          "[Added Lines]",
          "574:  query.Token = aclfilter.RedactedToken",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "682:  query.Query.ID = reply",
          "684:  {",
          "685:   req := &structs.PreparedQuerySpecificRequest{",
          "686:    Datacenter:   \"dc1\",",
          "",
          "[Removed Lines]",
          "683:  query.Query.Token = redactedToken",
          "",
          "[Added Lines]",
          "684:  query.Query.Token = aclfilter.RedactedToken",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "779:  }",
          "783:  query.Query.Service.Service = \"anything\"",
          "784:  {",
          "785:   req := &structs.PreparedQueryExecuteRequest{",
          "",
          "[Removed Lines]",
          "782:  query.Query.Token = redactedToken",
          "",
          "[Added Lines]",
          "783:  query.Query.Token = aclfilter.RedactedToken",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "993:  }",
          "997:  {",
          "998:   req := &structs.PreparedQuerySpecificRequest{",
          "999:    Datacenter:   \"dc1\",",
          "",
          "[Removed Lines]",
          "996:  query.Query.Token = redactedToken",
          "",
          "[Added Lines]",
          "997:  query.Query.Token = aclfilter.RedactedToken",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1129:  query.Query.ID = reply",
          "1131:  {",
          "1132:   req := &structs.DCSpecificRequest{",
          "1133:    Datacenter:   \"dc1\",",
          "",
          "[Removed Lines]",
          "1130:  query.Query.Token = redactedToken",
          "",
          "[Added Lines]",
          "1131:  query.Query.Token = aclfilter.RedactedToken",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1355:  }",
          "1359:  query.Query.Service.Service = \"prod-redis\"",
          "1360:  {",
          "1361:   req := &structs.PreparedQueryExecuteRequest{",
          "",
          "[Removed Lines]",
          "1358:  query.Query.Token = redactedToken",
          "",
          "[Added Lines]",
          "1359:  query.Query.Token = aclfilter.RedactedToken",
          "",
          "---------------"
        ],
        "agent/proxycfg-glue/config_entry.go||agent/proxycfg-glue/config_entry.go": [
          "File: agent/proxycfg-glue/config_entry.go -> agent/proxycfg-glue/config_entry.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:  EventPublisher *stream.EventPublisher",
          "24:  Logger         hclog.Logger",
          "25:  ACLResolver    submatview.ACLResolver",
          "26: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26:  GetStore       func() Store",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "46:  if err != nil {",
          "47:   return err",
          "48:  }",
          "50: }",
          "52: func newConfigEntryRequest(req *structs.ConfigEntryQuery, deps ServerDataSourceDeps) (*configEntryRequest, error) {",
          "",
          "[Removed Lines]",
          "49:  return e.deps.ViewStore.NotifyCallback(ctx, cfgReq, correlationID, dispatchCacheUpdate(ctx, ch))",
          "",
          "[Added Lines]",
          "50:  return e.deps.ViewStore.NotifyCallback(ctx, cfgReq, correlationID, dispatchCacheUpdate(ch))",
          "",
          "---------------"
        ],
        "agent/proxycfg-glue/glue.go||agent/proxycfg-glue/glue.go": [
          "File: agent/proxycfg-glue/glue.go -> agent/proxycfg-glue/glue.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import (",
          "4:  \"context\"",
          "6:  \"github.com/hashicorp/consul/agent/cache\"",
          "7:  cachetype \"github.com/hashicorp/consul/agent/cache-types\"",
          "8:  \"github.com/hashicorp/consul/agent/proxycfg\"",
          "9:  \"github.com/hashicorp/consul/agent/rpcclient/health\"",
          "10:  \"github.com/hashicorp/consul/agent/structs\"",
          "11:  \"github.com/hashicorp/consul/proto/pbpeering\"",
          "12: )",
          "16: func CacheCARoots(c *cache.Cache) proxycfg.CARoots {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6:  \"github.com/hashicorp/go-memdb\"",
          "8:  \"github.com/hashicorp/consul/acl\"",
          "11:  \"github.com/hashicorp/consul/agent/consul/watch\"",
          "19: type Store interface {",
          "20:  watch.StateStore",
          "22:  IntentionTopology(ws memdb.WatchSet, target structs.ServiceName, downstreams bool, defaultDecision acl.EnforcementDecision, intentionTarget structs.IntentionTargetType) (uint64, structs.ServiceList, error)",
          "23: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "134:  correlationID string,",
          "135:  ch chan<- proxycfg.UpdateEvent,",
          "136: ) error {",
          "138: }",
          "",
          "[Removed Lines]",
          "137:  return c.c.NotifyCallback(ctx, c.t, req, correlationID, dispatchCacheUpdate(ctx, ch))",
          "",
          "[Added Lines]",
          "148:  return c.c.NotifyCallback(ctx, c.t, req, correlationID, dispatchCacheUpdate(ch))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "153:  correlationID string,",
          "154:  ch chan<- proxycfg.UpdateEvent,",
          "155: ) error {",
          "157: }",
          "160:  return func(ctx context.Context, e cache.UpdateEvent) {",
          "161:   u := proxycfg.UpdateEvent{",
          "162:    CorrelationID: e.CorrelationID,",
          "",
          "[Removed Lines]",
          "156:  return h.client.Notify(ctx, *req, correlationID, dispatchCacheUpdate(ctx, ch))",
          "159: func dispatchCacheUpdate(ctx context.Context, ch chan<- proxycfg.UpdateEvent) cache.Callback {",
          "",
          "[Added Lines]",
          "167:  return h.client.Notify(ctx, *req, correlationID, dispatchCacheUpdate(ch))",
          "170: func dispatchCacheUpdate(ch chan<- proxycfg.UpdateEvent) cache.Callback {",
          "",
          "---------------"
        ],
        "agent/proxycfg-glue/intention_upstreams.go||agent/proxycfg-glue/intention_upstreams.go": [
          "File: agent/proxycfg-glue/intention_upstreams.go -> agent/proxycfg-glue/intention_upstreams.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: package proxycfgglue",
          "3: import (",
          "4:  \"context\"",
          "6:  \"github.com/hashicorp/go-memdb\"",
          "8:  \"github.com/hashicorp/consul/agent/consul/watch\"",
          "9:  \"github.com/hashicorp/consul/agent/proxycfg\"",
          "10:  \"github.com/hashicorp/consul/agent/structs\"",
          "11:  \"github.com/hashicorp/consul/agent/structs/aclfilter\"",
          "12: )",
          "16: func ServerIntentionUpstreams(deps ServerDataSourceDeps) proxycfg.IntentionUpstreams {",
          "17:  return serverIntentionUpstreams{deps}",
          "18: }",
          "20: type serverIntentionUpstreams struct {",
          "21:  deps ServerDataSourceDeps",
          "22: }",
          "24: func (s serverIntentionUpstreams) Notify(ctx context.Context, req *structs.ServiceSpecificRequest, correlationID string, ch chan<- proxycfg.UpdateEvent) error {",
          "25:  target := structs.NewServiceName(req.ServiceName, &req.EnterpriseMeta)",
          "27:  return watch.ServerLocalNotify(ctx, correlationID, s.deps.GetStore,",
          "28:   func(ws memdb.WatchSet, store Store) (uint64, *structs.IndexedServiceList, error) {",
          "29:    authz, err := s.deps.ACLResolver.ResolveTokenAndDefaultMeta(req.Token, &req.EnterpriseMeta, nil)",
          "30:    if err != nil {",
          "31:     return 0, nil, err",
          "32:    }",
          "33:    defaultDecision := authz.IntentionDefaultAllow(nil)",
          "35:    index, services, err := store.IntentionTopology(ws, target, false, defaultDecision, structs.IntentionTargetService)",
          "36:    if err != nil {",
          "37:     return 0, nil, err",
          "38:    }",
          "40:    result := &structs.IndexedServiceList{",
          "41:     Services: services,",
          "42:     QueryMeta: structs.QueryMeta{",
          "43:      Index:   index,",
          "44:      Backend: structs.QueryBackendBlocking,",
          "45:     },",
          "46:    }",
          "47:    aclfilter.New(authz, s.deps.Logger).Filter(result)",
          "49:    return index, result, nil",
          "50:   },",
          "51:   dispatchBlockingQueryUpdate[*structs.IndexedServiceList](ch),",
          "52:  )",
          "53: }",
          "55: func dispatchBlockingQueryUpdate[ResultType any](ch chan<- proxycfg.UpdateEvent) func(context.Context, string, ResultType, error) {",
          "56:  return func(ctx context.Context, correlationID string, result ResultType, err error) {",
          "57:   event := proxycfg.UpdateEvent{",
          "58:    CorrelationID: correlationID,",
          "59:    Result:        result,",
          "60:    Err:           err,",
          "61:   }",
          "62:   select {",
          "63:   case ch <- event:",
          "64:   case <-ctx.Done():",
          "65:   }",
          "66:  }",
          "67: }",
          "",
          "---------------"
        ],
        "agent/proxycfg-glue/intention_upstreams_test.go||agent/proxycfg-glue/intention_upstreams_test.go": [
          "File: agent/proxycfg-glue/intention_upstreams_test.go -> agent/proxycfg-glue/intention_upstreams_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: package proxycfgglue",
          "3: import (",
          "4:  \"context\"",
          "5:  \"testing\"",
          "6:  \"time\"",
          "8:  \"github.com/stretchr/testify/require\"",
          "10:  \"github.com/hashicorp/consul/acl\"",
          "11:  \"github.com/hashicorp/consul/agent/consul/state\"",
          "12:  \"github.com/hashicorp/consul/agent/proxycfg\"",
          "13:  \"github.com/hashicorp/consul/agent/structs\"",
          "14: )",
          "16: func TestServerIntentionUpstreams(t *testing.T) {",
          "17:  const serviceName = \"web\"",
          "19:  var index uint64",
          "20:  getIndex := func() uint64 {",
          "21:   index++",
          "22:   return index",
          "23:  }",
          "25:  ctx, cancel := context.WithCancel(context.Background())",
          "26:  t.Cleanup(cancel)",
          "28:  store := state.NewStateStore(nil)",
          "29:  disableLegacyIntentions(t, store)",
          "32:  for _, service := range []string{\"api\", \"db\"} {",
          "33:   err := store.EnsureRegistration(getIndex(), &structs.RegisterRequest{",
          "34:    Node: \"node-1\",",
          "35:    Service: &structs.NodeService{",
          "36:     Service: service,",
          "37:    },",
          "38:   })",
          "39:   require.NoError(t, err)",
          "40:  }",
          "42:  createIntention := func(destination string) {",
          "43:   t.Helper()",
          "45:   err := store.EnsureConfigEntry(getIndex(), &structs.ServiceIntentionsConfigEntry{",
          "46:    Name: destination,",
          "47:    Sources: []*structs.SourceIntention{",
          "48:     {",
          "49:      Name:   serviceName,",
          "50:      Action: structs.IntentionActionAllow,",
          "51:      Type:   structs.IntentionSourceConsul,",
          "52:     },",
          "53:    },",
          "54:   })",
          "55:   require.NoError(t, err)",
          "56:  }",
          "60:  createIntention(\"api\")",
          "62:  authz := policyAuthorizer(t, `service \"db\" { policy = \"read\" }`)",
          "64:  dataSource := ServerIntentionUpstreams(ServerDataSourceDeps{",
          "65:   ACLResolver: staticResolver{authz},",
          "66:   GetStore:    func() Store { return store },",
          "67:  })",
          "69:  ch := make(chan proxycfg.UpdateEvent)",
          "70:  err := dataSource.Notify(ctx, &structs.ServiceSpecificRequest{ServiceName: serviceName}, \"\", ch)",
          "71:  require.NoError(t, err)",
          "73:  select {",
          "74:  case event := <-ch:",
          "75:   result, ok := event.Result.(*structs.IndexedServiceList)",
          "76:   require.Truef(t, ok, \"expected IndexedServiceList, got: %T\", event.Result)",
          "77:   require.Len(t, result.Services, 0)",
          "78:  case <-time.After(100 * time.Millisecond):",
          "79:   t.Fatal(\"timeout waiting for event\")",
          "80:  }",
          "84:  createIntention(\"db\")",
          "86:  select {",
          "87:  case event := <-ch:",
          "88:   result, ok := event.Result.(*structs.IndexedServiceList)",
          "89:   require.Truef(t, ok, \"expected IndexedServiceList, got: %T\", event.Result)",
          "90:   require.Len(t, result.Services, 1)",
          "91:   require.Equal(t, \"db\", result.Services[0].Name)",
          "92:  case <-time.After(100 * time.Millisecond):",
          "93:   t.Fatal(\"timeout waiting for event\")",
          "94:  }",
          "95: }",
          "97: func disableLegacyIntentions(t *testing.T, store *state.Store) {",
          "98:  t.Helper()",
          "100:  require.NoError(t, store.SystemMetadataSet(0, &structs.SystemMetadataEntry{",
          "101:   Key:   structs.SystemMetadataIntentionFormatKey,",
          "102:   Value: structs.SystemMetadataIntentionFormatConfigValue,",
          "103:  }))",
          "104: }",
          "106: func policyAuthorizer(t *testing.T, policyHCL string) acl.Authorizer {",
          "107:  policy, err := acl.NewPolicyFromSource(policyHCL, acl.SyntaxCurrent, nil, nil)",
          "108:  require.NoError(t, err)",
          "110:  authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "111:  require.NoError(t, err)",
          "113:  return authz",
          "114: }",
          "",
          "---------------"
        ],
        "agent/proxycfg-glue/intentions_ent_test.go||agent/proxycfg-glue/intentions_ent_test.go": [
          "File: agent/proxycfg-glue/intentions_ent_test.go -> agent/proxycfg-glue/intentions_ent_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "39:  go publisher.Run(ctx)",
          "41:  intentions := ServerIntentions(ServerDataSourceDeps{",
          "43:   ViewStore:      store,",
          "44:   EventPublisher: publisher,",
          "45:   Logger:         logger,",
          "",
          "[Removed Lines]",
          "42:   ACLResolver:    manageAllResolver{},",
          "",
          "[Added Lines]",
          "42:   ACLResolver:    staticResolver{acl.ManageAll()},",
          "",
          "---------------"
        ],
        "agent/proxycfg-glue/intentions_test.go||agent/proxycfg-glue/intentions_test.go": [
          "File: agent/proxycfg-glue/intentions_test.go -> agent/proxycfg-glue/intentions_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "39:  go publisher.Run(ctx)",
          "41:  intentions := ServerIntentions(ServerDataSourceDeps{",
          "43:   ViewStore:      store,",
          "44:   EventPublisher: publisher,",
          "45:   Logger:         logger,",
          "",
          "[Removed Lines]",
          "42:   ACLResolver:    manageAllResolver{},",
          "",
          "[Added Lines]",
          "42:   ACLResolver:    staticResolver{acl.ManageAll()},",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "146:  }",
          "147: }",
          "153: }",
          "",
          "[Removed Lines]",
          "149: type manageAllResolver struct{}",
          "151: func (manageAllResolver) ResolveTokenAndDefaultMeta(token string, entMeta *acl.EnterpriseMeta, authzContext *acl.AuthorizerContext) (resolver.Result, error) {",
          "152:  return resolver.Result{Authorizer: acl.ManageAll()}, nil",
          "",
          "[Added Lines]",
          "149: type staticResolver struct {",
          "150:  authorizer acl.Authorizer",
          "151: }",
          "153: func (r staticResolver) ResolveTokenAndDefaultMeta(token string, entMeta *acl.EnterpriseMeta, authzContext *acl.AuthorizerContext) (resolver.Result, error) {",
          "154:  return resolver.Result{Authorizer: r.authorizer}, nil",
          "",
          "---------------"
        ],
        "agent/structs/aclfilter/filter.go||agent/structs/aclfilter/filter.go": [
          "File: agent/structs/aclfilter/filter.go -> agent/structs/aclfilter/filter.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: package aclfilter",
          "3: import (",
          "4:  \"fmt\"",
          "6:  \"github.com/hashicorp/go-hclog\"",
          "8:  \"github.com/hashicorp/consul/acl\"",
          "9:  \"github.com/hashicorp/consul/agent/structs\"",
          "10: )",
          "12: const (",
          "15:  RedactedToken = \"<hidden>\"",
          "16: )",
          "19: type Filter struct {",
          "20:  authorizer acl.Authorizer",
          "21:  logger     hclog.Logger",
          "22: }",
          "25: func New(authorizer acl.Authorizer, logger hclog.Logger) *Filter {",
          "26:  if logger == nil {",
          "27:   logger = hclog.NewNullLogger()",
          "28:  }",
          "29:  return &Filter{authorizer, logger}",
          "30: }",
          "33: func (f *Filter) Filter(subject any) {",
          "34:  switch v := subject.(type) {",
          "35:  case *structs.CheckServiceNodes:",
          "36:   f.filterCheckServiceNodes(v)",
          "38:  case *structs.IndexedCheckServiceNodes:",
          "39:   v.QueryMeta.ResultsFilteredByACLs = f.filterCheckServiceNodes(&v.Nodes)",
          "41:  case *structs.PreparedQueryExecuteResponse:",
          "42:   v.QueryMeta.ResultsFilteredByACLs = f.filterCheckServiceNodes(&v.Nodes)",
          "44:  case *structs.IndexedServiceTopology:",
          "45:   filtered := f.filterServiceTopology(v.ServiceTopology)",
          "46:   if filtered {",
          "47:    v.FilteredByACLs = true",
          "48:    v.QueryMeta.ResultsFilteredByACLs = true",
          "49:   }",
          "51:  case *structs.DatacenterIndexedCheckServiceNodes:",
          "52:   v.QueryMeta.ResultsFilteredByACLs = f.filterDatacenterCheckServiceNodes(&v.DatacenterNodes)",
          "54:  case *structs.IndexedCoordinates:",
          "55:   v.QueryMeta.ResultsFilteredByACLs = f.filterCoordinates(&v.Coordinates)",
          "57:  case *structs.IndexedHealthChecks:",
          "58:   v.QueryMeta.ResultsFilteredByACLs = f.filterHealthChecks(&v.HealthChecks)",
          "60:  case *structs.IndexedIntentions:",
          "61:   v.QueryMeta.ResultsFilteredByACLs = f.filterIntentions(&v.Intentions)",
          "63:  case *structs.IndexedNodeDump:",
          "64:   v.QueryMeta.ResultsFilteredByACLs = f.filterNodeDump(&v.Dump)",
          "66:  case *structs.IndexedServiceDump:",
          "67:   v.QueryMeta.ResultsFilteredByACLs = f.filterServiceDump(&v.Dump)",
          "69:  case *structs.IndexedNodes:",
          "70:   v.QueryMeta.ResultsFilteredByACLs = f.filterNodes(&v.Nodes)",
          "72:  case *structs.IndexedNodeServices:",
          "73:   v.QueryMeta.ResultsFilteredByACLs = f.filterNodeServices(&v.NodeServices)",
          "75:  case *structs.IndexedNodeServiceList:",
          "76:   v.QueryMeta.ResultsFilteredByACLs = f.filterNodeServiceList(&v.NodeServices)",
          "78:  case *structs.IndexedServiceNodes:",
          "79:   v.QueryMeta.ResultsFilteredByACLs = f.filterServiceNodes(&v.ServiceNodes)",
          "81:  case *structs.IndexedServices:",
          "82:   v.QueryMeta.ResultsFilteredByACLs = f.filterServices(v.Services, &v.EnterpriseMeta)",
          "84:  case *structs.IndexedSessions:",
          "85:   v.QueryMeta.ResultsFilteredByACLs = f.filterSessions(&v.Sessions)",
          "87:  case *structs.IndexedPreparedQueries:",
          "88:   v.QueryMeta.ResultsFilteredByACLs = f.filterPreparedQueries(&v.Queries)",
          "90:  case **structs.PreparedQuery:",
          "91:   f.redactPreparedQueryTokens(v)",
          "93:  case *structs.ACLTokens:",
          "94:   f.filterTokens(v)",
          "95:  case **structs.ACLToken:",
          "96:   f.filterToken(v)",
          "97:  case *[]*structs.ACLTokenListStub:",
          "98:   f.filterTokenStubs(v)",
          "99:  case **structs.ACLTokenListStub:",
          "100:   f.filterTokenStub(v)",
          "102:  case *structs.ACLPolicies:",
          "103:   f.filterPolicies(v)",
          "104:  case **structs.ACLPolicy:",
          "105:   f.filterPolicy(v)",
          "107:  case *structs.ACLRoles:",
          "108:   f.filterRoles(v)",
          "109:  case **structs.ACLRole:",
          "110:   f.filterRole(v)",
          "112:  case *structs.ACLBindingRules:",
          "113:   f.filterBindingRules(v)",
          "114:  case **structs.ACLBindingRule:",
          "115:   f.filterBindingRule(v)",
          "117:  case *structs.ACLAuthMethods:",
          "118:   f.filterAuthMethods(v)",
          "119:  case **structs.ACLAuthMethod:",
          "120:   f.filterAuthMethod(v)",
          "122:  case *structs.IndexedServiceList:",
          "123:   v.QueryMeta.ResultsFilteredByACLs = f.filterServiceList(&v.Services)",
          "125:  case *structs.IndexedExportedServiceList:",
          "126:   for peer, peerServices := range v.Services {",
          "127:    v.QueryMeta.ResultsFilteredByACLs = f.filterServiceList(&peerServices)",
          "128:    if len(peerServices) == 0 {",
          "129:     delete(v.Services, peer)",
          "130:    } else {",
          "131:     v.Services[peer] = peerServices",
          "132:    }",
          "133:   }",
          "135:  case *structs.IndexedGatewayServices:",
          "136:   v.QueryMeta.ResultsFilteredByACLs = f.filterGatewayServices(&v.Services)",
          "138:  case *structs.IndexedNodesWithGateways:",
          "139:   if f.filterCheckServiceNodes(&v.Nodes) {",
          "140:    v.QueryMeta.ResultsFilteredByACLs = true",
          "141:   }",
          "142:   if f.filterGatewayServices(&v.Gateways) {",
          "143:    v.QueryMeta.ResultsFilteredByACLs = true",
          "144:   }",
          "146:  default:",
          "147:   panic(fmt.Errorf(\"Unhandled type passed to ACL filter: %T %#v\", subject, subject))",
          "148:  }",
          "149: }",
          "152: func (f *Filter) allowNode(node string, ent *acl.AuthorizerContext) bool {",
          "153:  return f.authorizer.NodeRead(node, ent) == acl.Allow",
          "154: }",
          "157: func (f *Filter) allowGateway(gs *structs.GatewayService) bool {",
          "158:  var authzContext acl.AuthorizerContext",
          "161:  gs.Gateway.FillAuthzContext(&authzContext)",
          "162:  if !f.allowService(gs.Gateway.Name, &authzContext) {",
          "163:   return false",
          "164:  }",
          "166:  gs.Service.FillAuthzContext(&authzContext)",
          "167:  if !f.allowService(gs.Service.Name, &authzContext) {",
          "168:   return false",
          "169:  }",
          "170:  return true",
          "171: }",
          "174: func (f *Filter) allowService(service string, ent *acl.AuthorizerContext) bool {",
          "175:  if service == \"\" {",
          "176:   return true",
          "177:  }",
          "179:  return f.authorizer.ServiceRead(service, ent) == acl.Allow",
          "180: }",
          "184: func (f *Filter) allowSession(node string, ent *acl.AuthorizerContext) bool {",
          "185:  return f.authorizer.SessionRead(node, ent) == acl.Allow",
          "186: }",
          "191: func (f *Filter) filterHealthChecks(checks *structs.HealthChecks) bool {",
          "192:  hc := *checks",
          "193:  var authzContext acl.AuthorizerContext",
          "194:  var removed bool",
          "196:  for i := 0; i < len(hc); i++ {",
          "197:   check := hc[i]",
          "198:   check.FillAuthzContext(&authzContext)",
          "199:   if f.allowNode(check.Node, &authzContext) && f.allowService(check.ServiceName, &authzContext) {",
          "200:    continue",
          "201:   }",
          "203:   f.logger.Debug(\"dropping check from result due to ACLs\", \"check\", check.CheckID)",
          "204:   removed = true",
          "205:   hc = append(hc[:i], hc[i+1:]...)",
          "206:   i--",
          "207:  }",
          "209:  return removed",
          "210: }",
          "214: func (f *Filter) filterServices(services structs.Services, entMeta *acl.EnterpriseMeta) bool {",
          "215:  var authzContext acl.AuthorizerContext",
          "216:  entMeta.FillAuthzContext(&authzContext)",
          "218:  var removed bool",
          "220:  for svc := range services {",
          "221:   if f.allowService(svc, &authzContext) {",
          "222:    continue",
          "223:   }",
          "224:   f.logger.Debug(\"dropping service from result due to ACLs\", \"service\", svc)",
          "225:   removed = true",
          "226:   delete(services, svc)",
          "227:  }",
          "229:  return removed",
          "230: }",
          "234: func (f *Filter) filterServiceNodes(nodes *structs.ServiceNodes) bool {",
          "235:  sn := *nodes",
          "236:  var authzContext acl.AuthorizerContext",
          "237:  var removed bool",
          "239:  for i := 0; i < len(sn); i++ {",
          "240:   node := sn[i]",
          "242:   node.FillAuthzContext(&authzContext)",
          "243:   if f.allowNode(node.Node, &authzContext) && f.allowService(node.ServiceName, &authzContext) {",
          "244:    continue",
          "245:   }",
          "246:   removed = true",
          "247:   f.logger.Debug(\"dropping node from result due to ACLs\", \"node\", structs.NodeNameString(node.Node, &node.EnterpriseMeta))",
          "248:   sn = append(sn[:i], sn[i+1:]...)",
          "249:   i--",
          "250:  }",
          "252:  return removed",
          "253: }",
          "257: func (f *Filter) filterNodeServices(services **structs.NodeServices) bool {",
          "258:  if *services == nil {",
          "259:   return false",
          "260:  }",
          "262:  var authzContext acl.AuthorizerContext",
          "263:  (*services).Node.FillAuthzContext(&authzContext)",
          "264:  if !f.allowNode((*services).Node.Node, &authzContext) {",
          "266:   return true",
          "267:  }",
          "269:  var removed bool",
          "270:  for svcName, svc := range (*services).Services {",
          "271:   svc.FillAuthzContext(&authzContext)",
          "273:   if f.allowNode((*services).Node.Node, &authzContext) && f.allowService(svcName, &authzContext) {",
          "274:    continue",
          "275:   }",
          "276:   f.logger.Debug(\"dropping service from result due to ACLs\", \"service\", svc.CompoundServiceID())",
          "277:   removed = true",
          "278:   delete((*services).Services, svcName)",
          "279:  }",
          "281:  return removed",
          "282: }",
          "286: func (f *Filter) filterNodeServiceList(services *structs.NodeServiceList) bool {",
          "287:  if services.Node == nil {",
          "288:   return false",
          "289:  }",
          "291:  var authzContext acl.AuthorizerContext",
          "292:  services.Node.FillAuthzContext(&authzContext)",
          "293:  if !f.allowNode(services.Node.Node, &authzContext) {",
          "295:   return true",
          "296:  }",
          "298:  var removed bool",
          "299:  svcs := services.Services",
          "300:  for i := 0; i < len(svcs); i++ {",
          "301:   svc := svcs[i]",
          "302:   svc.FillAuthzContext(&authzContext)",
          "304:   if f.allowService(svc.Service, &authzContext) {",
          "305:    continue",
          "306:   }",
          "308:   f.logger.Debug(\"dropping service from result due to ACLs\", \"service\", svc.CompoundServiceID())",
          "309:   svcs = append(svcs[:i], svcs[i+1:]...)",
          "310:   i--",
          "311:   removed = true",
          "312:  }",
          "313:  services.Services = svcs",
          "315:  return removed",
          "316: }",
          "320: func (f *Filter) filterCheckServiceNodes(nodes *structs.CheckServiceNodes) bool {",
          "321:  csn := *nodes",
          "322:  var authzContext acl.AuthorizerContext",
          "323:  var removed bool",
          "325:  for i := 0; i < len(csn); i++ {",
          "326:   node := csn[i]",
          "327:   node.Service.FillAuthzContext(&authzContext)",
          "328:   if f.allowNode(node.Node.Node, &authzContext) && f.allowService(node.Service.Service, &authzContext) {",
          "329:    continue",
          "330:   }",
          "331:   f.logger.Debug(\"dropping node from result due to ACLs\", \"node\", structs.NodeNameString(node.Node.Node, node.Node.GetEnterpriseMeta()))",
          "332:   removed = true",
          "333:   csn = append(csn[:i], csn[i+1:]...)",
          "334:   i--",
          "335:  }",
          "337:  return removed",
          "338: }",
          "342: func (f *Filter) filterServiceTopology(topology *structs.ServiceTopology) bool {",
          "343:  filteredUpstreams := f.filterCheckServiceNodes(&topology.Upstreams)",
          "344:  filteredDownstreams := f.filterCheckServiceNodes(&topology.Downstreams)",
          "345:  return filteredUpstreams || filteredDownstreams",
          "346: }",
          "350: func (f *Filter) filterDatacenterCheckServiceNodes(datacenterNodes *map[string]structs.CheckServiceNodes) bool {",
          "351:  dn := *datacenterNodes",
          "352:  out := make(map[string]structs.CheckServiceNodes)",
          "353:  var removed bool",
          "354:  for dc := range dn {",
          "355:   nodes := dn[dc]",
          "356:   if f.filterCheckServiceNodes(&nodes) {",
          "357:    removed = true",
          "358:   }",
          "359:   if len(nodes) > 0 {",
          "360:    out[dc] = nodes",
          "361:   }",
          "362:  }",
          "364:  return removed",
          "365: }",
          "369: func (f *Filter) filterSessions(sessions *structs.Sessions) bool {",
          "370:  s := *sessions",
          "372:  var removed bool",
          "373:  for i := 0; i < len(s); i++ {",
          "374:   session := s[i]",
          "376:   var entCtx acl.AuthorizerContext",
          "377:   session.FillAuthzContext(&entCtx)",
          "379:   if f.allowSession(session.Node, &entCtx) {",
          "380:    continue",
          "381:   }",
          "382:   removed = true",
          "383:   f.logger.Debug(\"dropping session from result due to ACLs\", \"session\", session.ID)",
          "384:   s = append(s[:i], s[i+1:]...)",
          "385:   i--",
          "386:  }",
          "388:  return removed",
          "389: }",
          "393: func (f *Filter) filterCoordinates(coords *structs.Coordinates) bool {",
          "394:  c := *coords",
          "395:  var authzContext acl.AuthorizerContext",
          "396:  var removed bool",
          "398:  for i := 0; i < len(c); i++ {",
          "399:   c[i].FillAuthzContext(&authzContext)",
          "400:   node := c[i].Node",
          "401:   if f.allowNode(node, &authzContext) {",
          "402:    continue",
          "403:   }",
          "404:   f.logger.Debug(\"dropping node from result due to ACLs\", \"node\", structs.NodeNameString(node, c[i].GetEnterpriseMeta()))",
          "405:   removed = true",
          "406:   c = append(c[:i], c[i+1:]...)",
          "407:   i--",
          "408:  }",
          "410:  return removed",
          "411: }",
          "417: func (f *Filter) filterIntentions(ixns *structs.Intentions) bool {",
          "418:  ret := make(structs.Intentions, 0, len(*ixns))",
          "419:  var removed bool",
          "420:  for _, ixn := range *ixns {",
          "421:   if !ixn.CanRead(f.authorizer) {",
          "422:    removed = true",
          "423:    f.logger.Debug(\"dropping intention from result due to ACLs\", \"intention\", ixn.ID)",
          "424:    continue",
          "425:   }",
          "427:   ret = append(ret, ixn)",
          "428:  }",
          "431:  return removed",
          "432: }",
          "437: func (f *Filter) filterNodeDump(dump *structs.NodeDump) bool {",
          "438:  nd := *dump",
          "440:  var authzContext acl.AuthorizerContext",
          "441:  var removed bool",
          "442:  for i := 0; i < len(nd); i++ {",
          "443:   info := nd[i]",
          "446:   info.FillAuthzContext(&authzContext)",
          "447:   if node := info.Node; !f.allowNode(node, &authzContext) {",
          "448:    f.logger.Debug(\"dropping node from result due to ACLs\", \"node\", structs.NodeNameString(node, info.GetEnterpriseMeta()))",
          "449:    removed = true",
          "450:    nd = append(nd[:i], nd[i+1:]...)",
          "451:    i--",
          "452:    continue",
          "453:   }",
          "456:   for j := 0; j < len(info.Services); j++ {",
          "457:    svc := info.Services[j].Service",
          "458:    info.Services[j].FillAuthzContext(&authzContext)",
          "459:    if f.allowNode(info.Node, &authzContext) && f.allowService(svc, &authzContext) {",
          "460:     continue",
          "461:    }",
          "462:    f.logger.Debug(\"dropping service from result due to ACLs\", \"service\", svc)",
          "463:    removed = true",
          "464:    info.Services = append(info.Services[:j], info.Services[j+1:]...)",
          "465:    j--",
          "466:   }",
          "469:   for j := 0; j < len(info.Checks); j++ {",
          "470:    chk := info.Checks[j]",
          "471:    chk.FillAuthzContext(&authzContext)",
          "472:    if f.allowNode(info.Node, &authzContext) && f.allowService(chk.ServiceName, &authzContext) {",
          "473:     continue",
          "474:    }",
          "475:    f.logger.Debug(\"dropping check from result due to ACLs\", \"check\", chk.CheckID)",
          "476:    removed = true",
          "477:    info.Checks = append(info.Checks[:j], info.Checks[j+1:]...)",
          "478:    j--",
          "479:   }",
          "480:  }",
          "482:  return removed",
          "483: }",
          "487: func (f *Filter) filterServiceDump(services *structs.ServiceDump) bool {",
          "488:  svcs := *services",
          "489:  var authzContext acl.AuthorizerContext",
          "490:  var removed bool",
          "492:  for i := 0; i < len(svcs); i++ {",
          "493:   service := svcs[i]",
          "495:   if f.allowGateway(service.GatewayService) {",
          "497:    if service.Node == nil {",
          "498:     continue",
          "499:    }",
          "501:    service.Service.FillAuthzContext(&authzContext)",
          "502:    if f.allowNode(service.Node.Node, &authzContext) {",
          "503:     continue",
          "504:    }",
          "505:   }",
          "507:   f.logger.Debug(\"dropping service from result due to ACLs\", \"service\", service.GatewayService.Service)",
          "508:   removed = true",
          "509:   svcs = append(svcs[:i], svcs[i+1:]...)",
          "510:   i--",
          "511:  }",
          "513:  return removed",
          "514: }",
          "519: func (f *Filter) filterNodes(nodes *structs.Nodes) bool {",
          "520:  n := *nodes",
          "522:  var authzContext acl.AuthorizerContext",
          "523:  var removed bool",
          "525:  for i := 0; i < len(n); i++ {",
          "526:   n[i].FillAuthzContext(&authzContext)",
          "527:   node := n[i].Node",
          "528:   if f.allowNode(node, &authzContext) {",
          "529:    continue",
          "530:   }",
          "531:   f.logger.Debug(\"dropping node from result due to ACLs\", \"node\", structs.NodeNameString(node, n[i].GetEnterpriseMeta()))",
          "532:   removed = true",
          "533:   n = append(n[:i], n[i+1:]...)",
          "534:   i--",
          "535:  }",
          "537:  return removed",
          "538: }",
          "546: func (f *Filter) redactPreparedQueryTokens(query **structs.PreparedQuery) {",
          "548:  var authzContext acl.AuthorizerContext",
          "549:  structs.DefaultEnterpriseMetaInDefaultPartition().FillAuthzContext(&authzContext)",
          "550:  if f.authorizer.ACLWrite(&authzContext) == acl.Allow {",
          "551:   return",
          "552:  }",
          "557:  if (*query).Token != \"\" {",
          "564:   clone := *(*query)",
          "565:   clone.Token = RedactedToken",
          "567:  }",
          "568: }",
          "575: func (f *Filter) filterPreparedQueries(queries *structs.PreparedQueries) bool {",
          "576:  var authzContext acl.AuthorizerContext",
          "577:  structs.DefaultEnterpriseMetaInDefaultPartition().FillAuthzContext(&authzContext)",
          "582:  if f.authorizer.ACLWrite(&authzContext) == acl.Allow {",
          "583:   return false",
          "584:  }",
          "587:  var namedQueriesRemoved bool",
          "588:  ret := make(structs.PreparedQueries, 0, len(*queries))",
          "589:  for _, query := range *queries {",
          "593:   prefix, hasName := query.GetACLPrefix()",
          "594:   switch {",
          "595:   case hasName && f.authorizer.PreparedQueryRead(prefix, &authzContext) != acl.Allow:",
          "596:    namedQueriesRemoved = true",
          "597:    fallthrough",
          "598:   case !hasName:",
          "599:    f.logger.Debug(\"dropping prepared query from result due to ACLs\", \"query\", query.ID)",
          "600:    continue",
          "601:   }",
          "605:   final := query",
          "606:   f.redactPreparedQueryTokens(&final)",
          "607:   ret = append(ret, final)",
          "608:  }",
          "610:  return namedQueriesRemoved",
          "611: }",
          "613: func (f *Filter) filterToken(token **structs.ACLToken) {",
          "614:  var entCtx acl.AuthorizerContext",
          "615:  if token == nil || *token == nil || f == nil {",
          "616:   return",
          "617:  }",
          "619:  (*token).FillAuthzContext(&entCtx)",
          "621:  if f.authorizer.ACLRead(&entCtx) != acl.Allow {",
          "624:  } else if f.authorizer.ACLWrite(&entCtx) != acl.Allow {",
          "626:   clone := *(*token)",
          "627:   clone.SecretID = RedactedToken",
          "629:  }",
          "630: }",
          "632: func (f *Filter) filterTokens(tokens *structs.ACLTokens) {",
          "633:  ret := make(structs.ACLTokens, 0, len(*tokens))",
          "634:  for _, token := range *tokens {",
          "635:   final := token",
          "636:   f.filterToken(&final)",
          "637:   if final != nil {",
          "638:    ret = append(ret, final)",
          "639:   }",
          "640:  }",
          "642: }",
          "644: func (f *Filter) filterTokenStub(token **structs.ACLTokenListStub) {",
          "645:  var entCtx acl.AuthorizerContext",
          "646:  if token == nil || *token == nil || f == nil {",
          "647:   return",
          "648:  }",
          "650:  (*token).FillAuthzContext(&entCtx)",
          "652:  if f.authorizer.ACLRead(&entCtx) != acl.Allow {",
          "654:  } else if f.authorizer.ACLWrite(&entCtx) != acl.Allow {",
          "656:   clone := *(*token)",
          "657:   clone.SecretID = RedactedToken",
          "659:  }",
          "660: }",
          "662: func (f *Filter) filterTokenStubs(tokens *[]*structs.ACLTokenListStub) {",
          "663:  ret := make(structs.ACLTokenListStubs, 0, len(*tokens))",
          "664:  for _, token := range *tokens {",
          "665:   final := token",
          "666:   f.filterTokenStub(&final)",
          "667:   if final != nil {",
          "668:    ret = append(ret, final)",
          "669:   }",
          "670:  }",
          "672: }",
          "674: func (f *Filter) filterPolicy(policy **structs.ACLPolicy) {",
          "675:  var entCtx acl.AuthorizerContext",
          "676:  if policy == nil || *policy == nil || f == nil {",
          "677:   return",
          "678:  }",
          "680:  (*policy).FillAuthzContext(&entCtx)",
          "682:  if f.authorizer.ACLRead(&entCtx) != acl.Allow {",
          "685:  }",
          "686: }",
          "688: func (f *Filter) filterPolicies(policies *structs.ACLPolicies) {",
          "689:  ret := make(structs.ACLPolicies, 0, len(*policies))",
          "690:  for _, policy := range *policies {",
          "691:   final := policy",
          "692:   f.filterPolicy(&final)",
          "693:   if final != nil {",
          "694:    ret = append(ret, final)",
          "695:   }",
          "696:  }",
          "698: }",
          "700: func (f *Filter) filterRole(role **structs.ACLRole) {",
          "701:  var entCtx acl.AuthorizerContext",
          "702:  if role == nil || *role == nil || f == nil {",
          "703:   return",
          "704:  }",
          "706:  (*role).FillAuthzContext(&entCtx)",
          "708:  if f.authorizer.ACLRead(&entCtx) != acl.Allow {",
          "711:  }",
          "712: }",
          "714: func (f *Filter) filterRoles(roles *structs.ACLRoles) {",
          "715:  ret := make(structs.ACLRoles, 0, len(*roles))",
          "716:  for _, role := range *roles {",
          "717:   final := role",
          "718:   f.filterRole(&final)",
          "719:   if final != nil {",
          "720:    ret = append(ret, final)",
          "721:   }",
          "722:  }",
          "724: }",
          "726: func (f *Filter) filterBindingRule(rule **structs.ACLBindingRule) {",
          "727:  var entCtx acl.AuthorizerContext",
          "728:  if rule == nil || *rule == nil || f == nil {",
          "729:   return",
          "730:  }",
          "732:  (*rule).FillAuthzContext(&entCtx)",
          "734:  if f.authorizer.ACLRead(&entCtx) != acl.Allow {",
          "737:  }",
          "738: }",
          "740: func (f *Filter) filterBindingRules(rules *structs.ACLBindingRules) {",
          "741:  ret := make(structs.ACLBindingRules, 0, len(*rules))",
          "742:  for _, rule := range *rules {",
          "743:   final := rule",
          "744:   f.filterBindingRule(&final)",
          "745:   if final != nil {",
          "746:    ret = append(ret, final)",
          "747:   }",
          "748:  }",
          "750: }",
          "752: func (f *Filter) filterAuthMethod(method **structs.ACLAuthMethod) {",
          "753:  var entCtx acl.AuthorizerContext",
          "754:  if method == nil || *method == nil || f == nil {",
          "755:   return",
          "756:  }",
          "758:  (*method).FillAuthzContext(&entCtx)",
          "760:  if f.authorizer.ACLRead(&entCtx) != acl.Allow {",
          "763:  }",
          "764: }",
          "766: func (f *Filter) filterAuthMethods(methods *structs.ACLAuthMethods) {",
          "767:  ret := make(structs.ACLAuthMethods, 0, len(*methods))",
          "768:  for _, method := range *methods {",
          "769:   final := method",
          "770:   f.filterAuthMethod(&final)",
          "771:   if final != nil {",
          "772:    ret = append(ret, final)",
          "773:   }",
          "774:  }",
          "776: }",
          "778: func (f *Filter) filterServiceList(services *structs.ServiceList) bool {",
          "779:  ret := make(structs.ServiceList, 0, len(*services))",
          "780:  var removed bool",
          "781:  for _, svc := range *services {",
          "782:   var authzContext acl.AuthorizerContext",
          "784:   svc.FillAuthzContext(&authzContext)",
          "786:   if f.authorizer.ServiceRead(svc.Name, &authzContext) != acl.Allow {",
          "787:    removed = true",
          "788:    sid := structs.NewServiceID(svc.Name, &svc.EnterpriseMeta)",
          "789:    f.logger.Debug(\"dropping service from result due to ACLs\", \"service\", sid.String())",
          "790:    continue",
          "791:   }",
          "793:   ret = append(ret, svc)",
          "794:  }",
          "797:  return removed",
          "798: }",
          "802: func (f *Filter) filterGatewayServices(mappings *structs.GatewayServices) bool {",
          "803:  ret := make(structs.GatewayServices, 0, len(*mappings))",
          "804:  var removed bool",
          "805:  for _, s := range *mappings {",
          "808:   var authzContext acl.AuthorizerContext",
          "809:   s.Service.FillAuthzContext(&authzContext)",
          "811:   if f.authorizer.ServiceRead(s.Service.Name, &authzContext) != acl.Allow {",
          "812:    f.logger.Debug(\"dropping service from result due to ACLs\", \"service\", s.Service.String())",
          "813:    removed = true",
          "814:    continue",
          "815:   }",
          "816:   ret = append(ret, s)",
          "817:  }",
          "819:  return removed",
          "820: }",
          "",
          "---------------"
        ],
        "agent/structs/aclfilter/filter_test.go||agent/structs/aclfilter/filter_test.go": [
          "File: agent/structs/aclfilter/filter_test.go -> agent/structs/aclfilter/filter_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: package aclfilter",
          "3: import (",
          "4:  \"reflect\"",
          "5:  \"testing\"",
          "7:  \"github.com/hashicorp/go-hclog\"",
          "8:  \"github.com/hashicorp/go-uuid\"",
          "9:  \"github.com/hashicorp/serf/coordinate\"",
          "10:  \"github.com/stretchr/testify/assert\"",
          "11:  \"github.com/stretchr/testify/require\"",
          "13:  \"github.com/hashicorp/consul/acl\"",
          "14:  \"github.com/hashicorp/consul/agent/structs\"",
          "15:  \"github.com/hashicorp/consul/api\"",
          "16:  \"github.com/hashicorp/consul/types\"",
          "17: )",
          "19: func TestACL_filterHealthChecks(t *testing.T) {",
          "20:  t.Parallel()",
          "22:  logger := hclog.NewNullLogger()",
          "24:  makeList := func() *structs.IndexedHealthChecks {",
          "25:   return &structs.IndexedHealthChecks{",
          "26:    HealthChecks: structs.HealthChecks{",
          "27:     {",
          "28:      Node:        \"node1\",",
          "29:      CheckID:     \"check1\",",
          "30:      ServiceName: \"foo\",",
          "31:     },",
          "32:    },",
          "33:   }",
          "34:  }",
          "36:  t.Run(\"allowed\", func(t *testing.T) {",
          "38:   policy, err := acl.NewPolicyFromSource(`",
          "39:    service \"foo\" {",
          "40:      policy = \"read\"",
          "41:    }",
          "42:    node \"node1\" {",
          "43:      policy = \"read\"",
          "44:    }",
          "45:   `, acl.SyntaxLegacy, nil, nil)",
          "46:   require.NoError(t, err)",
          "48:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "49:   require.NoError(t, err)",
          "51:   list := makeList()",
          "52:   New(authz, logger).Filter(list)",
          "54:   require.Len(t, list.HealthChecks, 1)",
          "55:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "56:  })",
          "58:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "60:   policy, err := acl.NewPolicyFromSource(`",
          "61:    service \"foo\" {",
          "62:      policy = \"read\"",
          "63:    }",
          "64:   `, acl.SyntaxLegacy, nil, nil)",
          "65:   require.NoError(t, err)",
          "67:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "68:   require.NoError(t, err)",
          "70:   list := makeList()",
          "71:   New(authz, logger).Filter(list)",
          "73:   require.Empty(t, list.HealthChecks)",
          "74:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "75:  })",
          "77:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "79:   policy, err := acl.NewPolicyFromSource(`",
          "80:    node \"node1\" {",
          "81:      policy = \"read\"",
          "82:    }",
          "83:   `, acl.SyntaxLegacy, nil, nil)",
          "84:   require.NoError(t, err)",
          "86:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "87:   require.NoError(t, err)",
          "89:   list := makeList()",
          "90:   New(authz, logger).Filter(list)",
          "92:   require.Empty(t, list.HealthChecks)",
          "93:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "94:  })",
          "96:  t.Run(\"denied\", func(t *testing.T) {",
          "98:   list := makeList()",
          "99:   New(acl.DenyAll(), logger).Filter(list)",
          "101:   require.Empty(t, list.HealthChecks)",
          "102:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "103:  })",
          "104: }",
          "106: func TestACL_filterIntentions(t *testing.T) {",
          "107:  t.Parallel()",
          "109:  logger := hclog.NewNullLogger()",
          "111:  makeList := func() *structs.IndexedIntentions {",
          "112:   return &structs.IndexedIntentions{",
          "113:    Intentions: structs.Intentions{",
          "114:     &structs.Intention{",
          "115:      ID:              \"f004177f-2c28-83b7-4229-eacc25fe55d1\",",
          "116:      DestinationName: \"bar\",",
          "117:     },",
          "118:     &structs.Intention{",
          "119:      ID:              \"f004177f-2c28-83b7-4229-eacc25fe55d2\",",
          "120:      DestinationName: \"foo\",",
          "121:     },",
          "122:    },",
          "123:   }",
          "124:  }",
          "126:  t.Run(\"allowed\", func(t *testing.T) {",
          "128:   list := makeList()",
          "129:   New(acl.AllowAll(), logger).Filter(list)",
          "131:   require.Len(t, list.Intentions, 2)",
          "132:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "133:  })",
          "135:  t.Run(\"allowed to read 1\", func(t *testing.T) {",
          "137:   policy, err := acl.NewPolicyFromSource(`",
          "138:    service \"foo\" {",
          "139:      policy = \"read\"",
          "140:    }",
          "141:   `, acl.SyntaxLegacy, nil, nil)",
          "142:   require.NoError(t, err)",
          "144:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "145:   require.NoError(t, err)",
          "147:   list := makeList()",
          "148:   New(authz, logger).Filter(list)",
          "150:   require.Len(t, list.Intentions, 1)",
          "151:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "152:  })",
          "154:  t.Run(\"denied\", func(t *testing.T) {",
          "156:   list := makeList()",
          "157:   New(acl.DenyAll(), logger).Filter(list)",
          "159:   require.Empty(t, list.Intentions)",
          "160:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "161:  })",
          "162: }",
          "164: func TestACL_filterServices(t *testing.T) {",
          "165:  t.Parallel()",
          "168:  services := structs.Services{",
          "169:   \"service1\": []string{},",
          "170:   \"service2\": []string{},",
          "171:   \"consul\":   []string{},",
          "172:  }",
          "175:  filt := New(acl.AllowAll(), nil)",
          "176:  removed := filt.filterServices(services, nil)",
          "177:  require.False(t, removed)",
          "178:  require.Len(t, services, 3)",
          "181:  filt = New(acl.DenyAll(), nil)",
          "182:  removed = filt.filterServices(services, nil)",
          "183:  require.True(t, removed)",
          "184:  require.Empty(t, services)",
          "185: }",
          "187: func TestACL_filterServiceNodes(t *testing.T) {",
          "188:  t.Parallel()",
          "190:  logger := hclog.NewNullLogger()",
          "192:  makeList := func() *structs.IndexedServiceNodes {",
          "193:   return &structs.IndexedServiceNodes{",
          "194:    ServiceNodes: structs.ServiceNodes{",
          "195:     {",
          "196:      Node:        \"node1\",",
          "197:      ServiceName: \"foo\",",
          "198:     },",
          "199:    },",
          "200:   }",
          "201:  }",
          "203:  t.Run(\"allowed\", func(t *testing.T) {",
          "205:   policy, err := acl.NewPolicyFromSource(`",
          "206:    service \"foo\" {",
          "207:      policy = \"read\"",
          "208:    }",
          "209:    node \"node1\" {",
          "210:      policy = \"read\"",
          "211:    }",
          "212:   `, acl.SyntaxLegacy, nil, nil)",
          "213:   require.NoError(t, err)",
          "215:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "216:   require.NoError(t, err)",
          "218:   list := makeList()",
          "219:   New(authz, logger).Filter(list)",
          "221:   require.Len(t, list.ServiceNodes, 1)",
          "222:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "223:  })",
          "225:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "227:   policy, err := acl.NewPolicyFromSource(`",
          "228:    service \"foo\" {",
          "229:      policy = \"read\"",
          "230:    }",
          "231:   `, acl.SyntaxLegacy, nil, nil)",
          "232:   require.NoError(t, err)",
          "234:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "235:   require.NoError(t, err)",
          "237:   list := makeList()",
          "238:   New(authz, logger).Filter(list)",
          "240:   require.Empty(t, list.ServiceNodes)",
          "241:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "242:  })",
          "244:  t.Run(\"denied\", func(t *testing.T) {",
          "246:   list := makeList()",
          "247:   New(acl.DenyAll(), logger).Filter(list)",
          "249:   require.Empty(t, list.ServiceNodes)",
          "250:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "251:  })",
          "252: }",
          "254: func TestACL_filterNodeServices(t *testing.T) {",
          "255:  t.Parallel()",
          "257:  logger := hclog.NewNullLogger()",
          "259:  makeList := func() *structs.IndexedNodeServices {",
          "260:   return &structs.IndexedNodeServices{",
          "261:    NodeServices: &structs.NodeServices{",
          "262:     Node: &structs.Node{",
          "263:      Node: \"node1\",",
          "264:     },",
          "265:     Services: map[string]*structs.NodeService{",
          "266:      \"foo\": {",
          "267:       ID:      \"foo\",",
          "268:       Service: \"foo\",",
          "269:      },",
          "270:     },",
          "271:    },",
          "272:   }",
          "273:  }",
          "275:  t.Run(\"nil input\", func(t *testing.T) {",
          "277:   list := &structs.IndexedNodeServices{",
          "278:    NodeServices: nil,",
          "279:   }",
          "280:   New(acl.AllowAll(), logger).Filter(list)",
          "282:   require.Nil(t, list.NodeServices)",
          "283:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "284:  })",
          "286:  t.Run(\"allowed\", func(t *testing.T) {",
          "288:   policy, err := acl.NewPolicyFromSource(`",
          "289:    service \"foo\" {",
          "290:      policy = \"read\"",
          "291:    }",
          "292:    node \"node1\" {",
          "293:      policy = \"read\"",
          "294:    }",
          "295:   `, acl.SyntaxLegacy, nil, nil)",
          "296:   require.NoError(t, err)",
          "298:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "299:   require.NoError(t, err)",
          "301:   list := makeList()",
          "302:   New(authz, logger).Filter(list)",
          "304:   require.Len(t, list.NodeServices.Services, 1)",
          "305:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "306:  })",
          "308:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "310:   policy, err := acl.NewPolicyFromSource(`",
          "311:    service \"foo\" {",
          "312:      policy = \"read\"",
          "313:    }",
          "314:   `, acl.SyntaxLegacy, nil, nil)",
          "315:   require.NoError(t, err)",
          "317:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "318:   require.NoError(t, err)",
          "320:   list := makeList()",
          "321:   New(authz, logger).Filter(list)",
          "323:   require.Nil(t, list.NodeServices)",
          "324:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "325:  })",
          "327:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "329:   policy, err := acl.NewPolicyFromSource(`",
          "330:    node \"node1\" {",
          "331:      policy = \"read\"",
          "332:    }",
          "333:   `, acl.SyntaxLegacy, nil, nil)",
          "334:   require.NoError(t, err)",
          "336:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "337:   require.NoError(t, err)",
          "339:   list := makeList()",
          "340:   New(authz, logger).Filter(list)",
          "342:   require.Empty(t, list.NodeServices.Services)",
          "343:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "344:  })",
          "346:  t.Run(\"denied\", func(t *testing.T) {",
          "348:   list := makeList()",
          "349:   New(acl.DenyAll(), logger).Filter(list)",
          "351:   require.Nil(t, list.NodeServices)",
          "352:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "353:  })",
          "354: }",
          "356: func TestACL_filterNodeServiceList(t *testing.T) {",
          "357:  t.Parallel()",
          "359:  logger := hclog.NewNullLogger()",
          "361:  makeList := func() *structs.IndexedNodeServiceList {",
          "362:   return &structs.IndexedNodeServiceList{",
          "363:    NodeServices: structs.NodeServiceList{",
          "364:     Node: &structs.Node{",
          "365:      Node: \"node1\",",
          "366:     },",
          "367:     Services: []*structs.NodeService{",
          "368:      {Service: \"foo\"},",
          "369:     },",
          "370:    },",
          "371:   }",
          "372:  }",
          "374:  t.Run(\"empty NodeServices\", func(t *testing.T) {",
          "376:   var list structs.IndexedNodeServiceList",
          "377:   New(acl.AllowAll(), logger).Filter(&list)",
          "379:   require.Empty(t, list)",
          "380:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "381:  })",
          "383:  t.Run(\"allowed\", func(t *testing.T) {",
          "385:   policy, err := acl.NewPolicyFromSource(`",
          "386:    service \"foo\" {",
          "387:      policy = \"read\"",
          "388:    }",
          "389:    node \"node1\" {",
          "390:      policy = \"read\"",
          "391:    }",
          "392:   `, acl.SyntaxLegacy, nil, nil)",
          "393:   require.NoError(t, err)",
          "395:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "396:   require.NoError(t, err)",
          "398:   list := makeList()",
          "399:   New(authz, logger).Filter(list)",
          "401:   require.Len(t, list.NodeServices.Services, 1)",
          "402:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "403:  })",
          "405:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "407:   policy, err := acl.NewPolicyFromSource(`",
          "408:    service \"foo\" {",
          "409:      policy = \"read\"",
          "410:    }",
          "411:   `, acl.SyntaxLegacy, nil, nil)",
          "412:   require.NoError(t, err)",
          "414:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "415:   require.NoError(t, err)",
          "417:   list := makeList()",
          "418:   New(authz, logger).Filter(list)",
          "420:   require.Empty(t, list.NodeServices)",
          "421:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "422:  })",
          "424:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "426:   policy, err := acl.NewPolicyFromSource(`",
          "427:    node \"node1\" {",
          "428:      policy = \"read\"",
          "429:    }",
          "430:   `, acl.SyntaxLegacy, nil, nil)",
          "431:   require.NoError(t, err)",
          "433:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "434:   require.NoError(t, err)",
          "436:   list := makeList()",
          "437:   New(authz, logger).Filter(list)",
          "439:   require.NotEmpty(t, list.NodeServices.Node)",
          "440:   require.Empty(t, list.NodeServices.Services)",
          "441:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "442:  })",
          "444:  t.Run(\"denied\", func(t *testing.T) {",
          "446:   list := makeList()",
          "447:   New(acl.DenyAll(), logger).Filter(list)",
          "449:   require.Empty(t, list.NodeServices)",
          "450:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "451:  })",
          "452: }",
          "454: func TestACL_filterGatewayServices(t *testing.T) {",
          "455:  t.Parallel()",
          "457:  logger := hclog.NewNullLogger()",
          "459:  makeList := func() *structs.IndexedGatewayServices {",
          "460:   return &structs.IndexedGatewayServices{",
          "461:    Services: structs.GatewayServices{",
          "462:     {Service: structs.ServiceName{Name: \"foo\"}},",
          "463:    },",
          "464:   }",
          "465:  }",
          "467:  t.Run(\"allowed\", func(t *testing.T) {",
          "469:   policy, err := acl.NewPolicyFromSource(`",
          "470:    service \"foo\" {",
          "471:      policy = \"read\"",
          "472:    }",
          "473:   `, acl.SyntaxLegacy, nil, nil)",
          "474:   require.NoError(t, err)",
          "476:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "477:   require.NoError(t, err)",
          "479:   list := makeList()",
          "480:   New(authz, logger).Filter(list)",
          "482:   require.Len(t, list.Services, 1)",
          "483:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "484:  })",
          "486:  t.Run(\"denied\", func(t *testing.T) {",
          "488:   list := makeList()",
          "489:   New(acl.DenyAll(), logger).Filter(list)",
          "491:   require.Empty(t, list.Services)",
          "492:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "493:  })",
          "494: }",
          "496: func TestACL_filterCheckServiceNodes(t *testing.T) {",
          "497:  t.Parallel()",
          "499:  logger := hclog.NewNullLogger()",
          "501:  makeList := func() *structs.IndexedCheckServiceNodes {",
          "502:   return &structs.IndexedCheckServiceNodes{",
          "503:    Nodes: structs.CheckServiceNodes{",
          "504:     {",
          "505:      Node: &structs.Node{",
          "506:       Node: \"node1\",",
          "507:      },",
          "508:      Service: &structs.NodeService{",
          "509:       ID:      \"foo\",",
          "510:       Service: \"foo\",",
          "511:      },",
          "512:      Checks: structs.HealthChecks{",
          "513:       {",
          "514:        Node:        \"node1\",",
          "515:        CheckID:     \"check1\",",
          "516:        ServiceName: \"foo\",",
          "517:       },",
          "518:      },",
          "519:     },",
          "520:    },",
          "521:   }",
          "522:  }",
          "524:  t.Run(\"allowed\", func(t *testing.T) {",
          "526:   policy, err := acl.NewPolicyFromSource(`",
          "527:    service \"foo\" {",
          "528:      policy = \"read\"",
          "529:    }",
          "530:    node \"node1\" {",
          "531:      policy = \"read\"",
          "532:    }",
          "533:   `, acl.SyntaxLegacy, nil, nil)",
          "534:   require.NoError(t, err)",
          "536:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "537:   require.NoError(t, err)",
          "539:   list := makeList()",
          "540:   New(authz, logger).Filter(list)",
          "542:   require.Len(t, list.Nodes, 1)",
          "543:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "544:  })",
          "546:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "548:   policy, err := acl.NewPolicyFromSource(`",
          "549:    service \"foo\" {",
          "550:      policy = \"read\"",
          "551:    }",
          "552:   `, acl.SyntaxLegacy, nil, nil)",
          "553:   require.NoError(t, err)",
          "555:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "556:   require.NoError(t, err)",
          "558:   list := makeList()",
          "559:   New(authz, logger).Filter(list)",
          "561:   require.Empty(t, list.Nodes)",
          "562:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "563:  })",
          "565:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "567:   policy, err := acl.NewPolicyFromSource(`",
          "568:    node \"node1\" {",
          "569:      policy = \"read\"",
          "570:    }",
          "571:   `, acl.SyntaxLegacy, nil, nil)",
          "572:   require.NoError(t, err)",
          "574:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "575:   require.NoError(t, err)",
          "577:   list := makeList()",
          "578:   New(authz, logger).Filter(list)",
          "580:   require.Empty(t, list.Nodes)",
          "581:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "582:  })",
          "584:  t.Run(\"denied\", func(t *testing.T) {",
          "586:   list := makeList()",
          "587:   New(acl.DenyAll(), logger).Filter(list)",
          "589:   require.Empty(t, list.Nodes)",
          "590:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "591:  })",
          "592: }",
          "594: func TestACL_filterPreparedQueryExecuteResponse(t *testing.T) {",
          "595:  t.Parallel()",
          "597:  logger := hclog.NewNullLogger()",
          "599:  makeList := func() *structs.PreparedQueryExecuteResponse {",
          "600:   return &structs.PreparedQueryExecuteResponse{",
          "601:    Nodes: structs.CheckServiceNodes{",
          "602:     {",
          "603:      Node: &structs.Node{",
          "604:       Node: \"node1\",",
          "605:      },",
          "606:      Service: &structs.NodeService{",
          "607:       ID:      \"foo\",",
          "608:       Service: \"foo\",",
          "609:      },",
          "610:      Checks: structs.HealthChecks{",
          "611:       {",
          "612:        Node:        \"node1\",",
          "613:        CheckID:     \"check1\",",
          "614:        ServiceName: \"foo\",",
          "615:       },",
          "616:      },",
          "617:     },",
          "618:    },",
          "619:   }",
          "620:  }",
          "622:  t.Run(\"allowed\", func(t *testing.T) {",
          "624:   policy, err := acl.NewPolicyFromSource(`",
          "625:    service \"foo\" {",
          "626:      policy = \"read\"",
          "627:    }",
          "628:    node \"node1\" {",
          "629:      policy = \"read\"",
          "630:    }",
          "631:   `, acl.SyntaxLegacy, nil, nil)",
          "632:   require.NoError(t, err)",
          "634:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "635:   require.NoError(t, err)",
          "637:   list := makeList()",
          "638:   New(authz, logger).Filter(list)",
          "640:   require.Len(t, list.Nodes, 1)",
          "641:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "642:  })",
          "644:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "646:   policy, err := acl.NewPolicyFromSource(`",
          "647:    service \"foo\" {",
          "648:      policy = \"read\"",
          "649:    }",
          "650:   `, acl.SyntaxLegacy, nil, nil)",
          "651:   require.NoError(t, err)",
          "653:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "654:   require.NoError(t, err)",
          "656:   list := makeList()",
          "657:   New(authz, logger).Filter(list)",
          "659:   require.Empty(t, list.Nodes)",
          "660:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "661:  })",
          "663:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "665:   policy, err := acl.NewPolicyFromSource(`",
          "666:    node \"node1\" {",
          "667:      policy = \"read\"",
          "668:    }",
          "669:   `, acl.SyntaxLegacy, nil, nil)",
          "670:   require.NoError(t, err)",
          "672:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "673:   require.NoError(t, err)",
          "675:   list := makeList()",
          "676:   New(authz, logger).Filter(list)",
          "678:   require.Empty(t, list.Nodes)",
          "679:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "680:  })",
          "682:  t.Run(\"denied\", func(t *testing.T) {",
          "684:   list := makeList()",
          "685:   New(acl.DenyAll(), logger).Filter(list)",
          "687:   require.Empty(t, list.Nodes)",
          "688:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "689:  })",
          "690: }",
          "692: func TestACL_filterServiceTopology(t *testing.T) {",
          "693:  t.Parallel()",
          "695:  fill := func() structs.ServiceTopology {",
          "696:   return structs.ServiceTopology{",
          "697:    Upstreams: structs.CheckServiceNodes{",
          "698:     structs.CheckServiceNode{",
          "699:      Node: &structs.Node{",
          "700:       Node: \"node1\",",
          "701:      },",
          "702:      Service: &structs.NodeService{",
          "703:       ID:      \"foo\",",
          "704:       Service: \"foo\",",
          "705:      },",
          "706:      Checks: structs.HealthChecks{",
          "707:       &structs.HealthCheck{",
          "708:        Node:        \"node1\",",
          "709:        CheckID:     \"check1\",",
          "710:        ServiceName: \"foo\",",
          "711:       },",
          "712:      },",
          "713:     },",
          "714:    },",
          "715:    Downstreams: structs.CheckServiceNodes{",
          "716:     structs.CheckServiceNode{",
          "717:      Node: &structs.Node{",
          "718:       Node: \"node2\",",
          "719:      },",
          "720:      Service: &structs.NodeService{",
          "721:       ID:      \"bar\",",
          "722:       Service: \"bar\",",
          "723:      },",
          "724:      Checks: structs.HealthChecks{",
          "725:       &structs.HealthCheck{",
          "726:        Node:        \"node2\",",
          "727:        CheckID:     \"check1\",",
          "728:        ServiceName: \"bar\",",
          "729:       },",
          "730:      },",
          "731:     },",
          "732:    },",
          "733:   }",
          "734:  }",
          "735:  original := fill()",
          "737:  t.Run(\"allow all without permissions\", func(t *testing.T) {",
          "738:   topo := fill()",
          "739:   f := New(acl.AllowAll(), nil)",
          "741:   filtered := f.filterServiceTopology(&topo)",
          "742:   if filtered {",
          "743:    t.Fatalf(\"should not have been filtered\")",
          "744:   }",
          "745:   assert.Equal(t, original, topo)",
          "746:  })",
          "748:  t.Run(\"deny all without permissions\", func(t *testing.T) {",
          "749:   topo := fill()",
          "750:   f := New(acl.DenyAll(), nil)",
          "752:   filtered := f.filterServiceTopology(&topo)",
          "753:   if !filtered {",
          "754:    t.Fatalf(\"should have been marked as filtered\")",
          "755:   }",
          "756:   assert.Len(t, topo.Upstreams, 0)",
          "757:   assert.Len(t, topo.Upstreams, 0)",
          "758:  })",
          "760:  t.Run(\"only upstream permissions\", func(t *testing.T) {",
          "761:   rules := `",
          "762: node \"node1\" {",
          "763:   policy = \"read\"",
          "764: }",
          "765: service \"foo\" {",
          "766:   policy = \"read\"",
          "767: }`",
          "768:   policy, err := acl.NewPolicyFromSource(rules, acl.SyntaxLegacy, nil, nil)",
          "769:   if err != nil {",
          "770:    t.Fatalf(\"err %v\", err)",
          "771:   }",
          "772:   perms, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "773:   if err != nil {",
          "774:    t.Fatalf(\"err: %v\", err)",
          "775:   }",
          "777:   topo := fill()",
          "778:   f := New(perms, nil)",
          "780:   filtered := f.filterServiceTopology(&topo)",
          "781:   if !filtered {",
          "782:    t.Fatalf(\"should have been marked as filtered\")",
          "783:   }",
          "784:   assert.Equal(t, original.Upstreams, topo.Upstreams)",
          "785:   assert.Len(t, topo.Downstreams, 0)",
          "786:  })",
          "788:  t.Run(\"only downstream permissions\", func(t *testing.T) {",
          "789:   rules := `",
          "790: node \"node2\" {",
          "791:   policy = \"read\"",
          "792: }",
          "793: service \"bar\" {",
          "794:   policy = \"read\"",
          "795: }`",
          "796:   policy, err := acl.NewPolicyFromSource(rules, acl.SyntaxLegacy, nil, nil)",
          "797:   if err != nil {",
          "798:    t.Fatalf(\"err %v\", err)",
          "799:   }",
          "800:   perms, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "801:   if err != nil {",
          "802:    t.Fatalf(\"err: %v\", err)",
          "803:   }",
          "805:   topo := fill()",
          "806:   f := New(perms, nil)",
          "808:   filtered := f.filterServiceTopology(&topo)",
          "809:   if !filtered {",
          "810:    t.Fatalf(\"should have been marked as filtered\")",
          "811:   }",
          "812:   assert.Equal(t, original.Downstreams, topo.Downstreams)",
          "813:   assert.Len(t, topo.Upstreams, 0)",
          "814:  })",
          "816:  t.Run(\"upstream and downstream permissions\", func(t *testing.T) {",
          "817:   rules := `",
          "818: node \"node1\" {",
          "819:   policy = \"read\"",
          "820: }",
          "821: service \"foo\" {",
          "822:   policy = \"read\"",
          "823: }",
          "824: node \"node2\" {",
          "825:   policy = \"read\"",
          "826: }",
          "827: service \"bar\" {",
          "828:   policy = \"read\"",
          "829: }`",
          "830:   policy, err := acl.NewPolicyFromSource(rules, acl.SyntaxLegacy, nil, nil)",
          "831:   if err != nil {",
          "832:    t.Fatalf(\"err %v\", err)",
          "833:   }",
          "834:   perms, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "835:   if err != nil {",
          "836:    t.Fatalf(\"err: %v\", err)",
          "837:   }",
          "839:   topo := fill()",
          "840:   f := New(perms, nil)",
          "842:   filtered := f.filterServiceTopology(&topo)",
          "843:   if filtered {",
          "844:    t.Fatalf(\"should not have been filtered\")",
          "845:   }",
          "847:   original := fill()",
          "848:   assert.Equal(t, original, topo)",
          "849:  })",
          "850: }",
          "852: func TestACL_filterCoordinates(t *testing.T) {",
          "853:  t.Parallel()",
          "855:  logger := hclog.NewNullLogger()",
          "857:  makeList := func() *structs.IndexedCoordinates {",
          "858:   return &structs.IndexedCoordinates{",
          "859:    Coordinates: structs.Coordinates{",
          "860:     {Node: \"node1\", Coord: coordinate.NewCoordinate(coordinate.DefaultConfig())},",
          "861:     {Node: \"node2\", Coord: coordinate.NewCoordinate(coordinate.DefaultConfig())},",
          "862:    },",
          "863:   }",
          "864:  }",
          "866:  t.Run(\"allowed\", func(t *testing.T) {",
          "868:   list := makeList()",
          "869:   New(acl.AllowAll(), logger).Filter(list)",
          "871:   require.Len(t, list.Coordinates, 2)",
          "872:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "873:  })",
          "875:  t.Run(\"allowed to read one node\", func(t *testing.T) {",
          "877:   policy, err := acl.NewPolicyFromSource(`",
          "878:    node \"node1\" {",
          "879:      policy = \"read\"",
          "880:    }",
          "881:   `, acl.SyntaxLegacy, nil, nil)",
          "882:   require.NoError(t, err)",
          "884:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "885:   require.NoError(t, err)",
          "887:   list := makeList()",
          "888:   New(authz, logger).Filter(list)",
          "890:   require.Len(t, list.Coordinates, 1)",
          "891:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "892:  })",
          "894:  t.Run(\"denied\", func(t *testing.T) {",
          "896:   list := makeList()",
          "897:   New(acl.DenyAll(), logger).Filter(list)",
          "899:   require.Empty(t, list.Coordinates)",
          "900:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "901:  })",
          "902: }",
          "904: func TestACL_filterSessions(t *testing.T) {",
          "905:  t.Parallel()",
          "907:  logger := hclog.NewNullLogger()",
          "909:  makeList := func() *structs.IndexedSessions {",
          "910:   return &structs.IndexedSessions{",
          "911:    Sessions: structs.Sessions{",
          "912:     {Node: \"foo\"},",
          "913:     {Node: \"bar\"},",
          "914:    },",
          "915:   }",
          "916:  }",
          "918:  t.Run(\"all allowed\", func(t *testing.T) {",
          "920:   list := makeList()",
          "921:   New(acl.AllowAll(), logger).Filter(list)",
          "923:   require.Len(t, list.Sessions, 2)",
          "924:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "925:  })",
          "927:  t.Run(\"just one node's sessions allowed\", func(t *testing.T) {",
          "929:   policy, err := acl.NewPolicyFromSource(`",
          "930:    session \"foo\" {",
          "931:      policy = \"read\"",
          "932:    }",
          "933:   `, acl.SyntaxLegacy, nil, nil)",
          "934:   require.NoError(t, err)",
          "936:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "937:   require.NoError(t, err)",
          "939:   list := makeList()",
          "940:   New(authz, logger).Filter(list)",
          "942:   require.Len(t, list.Sessions, 1)",
          "943:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "944:  })",
          "946:  t.Run(\"denied\", func(t *testing.T) {",
          "948:   list := makeList()",
          "949:   New(acl.DenyAll(), logger).Filter(list)",
          "951:   require.Empty(t, list.Sessions)",
          "952:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "953:  })",
          "954: }",
          "956: func TestACL_filterNodeDump(t *testing.T) {",
          "957:  t.Parallel()",
          "959:  logger := hclog.NewNullLogger()",
          "961:  makeList := func() *structs.IndexedNodeDump {",
          "962:   return &structs.IndexedNodeDump{",
          "963:    Dump: structs.NodeDump{",
          "964:     {",
          "965:      Node: \"node1\",",
          "966:      Services: []*structs.NodeService{",
          "967:       {",
          "968:        ID:      \"foo\",",
          "969:        Service: \"foo\",",
          "970:       },",
          "971:      },",
          "972:      Checks: []*structs.HealthCheck{",
          "973:       {",
          "974:        Node:        \"node1\",",
          "975:        CheckID:     \"check1\",",
          "976:        ServiceName: \"foo\",",
          "977:       },",
          "978:      },",
          "979:     },",
          "980:    },",
          "981:   }",
          "982:  }",
          "984:  t.Run(\"allowed\", func(t *testing.T) {",
          "986:   policy, err := acl.NewPolicyFromSource(`",
          "987:    service \"foo\" {",
          "988:      policy = \"read\"",
          "989:    }",
          "990:    node \"node1\" {",
          "991:      policy = \"read\"",
          "992:    }",
          "993:   `, acl.SyntaxLegacy, nil, nil)",
          "994:   require.NoError(t, err)",
          "996:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "997:   require.NoError(t, err)",
          "999:   list := makeList()",
          "1000:   New(authz, logger).Filter(list)",
          "1002:   require.Len(t, list.Dump, 1)",
          "1003:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "1004:  })",
          "1006:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "1008:   policy, err := acl.NewPolicyFromSource(`",
          "1009:    service \"foo\" {",
          "1010:      policy = \"read\"",
          "1011:    }",
          "1012:   `, acl.SyntaxLegacy, nil, nil)",
          "1013:   require.NoError(t, err)",
          "1015:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1016:   require.NoError(t, err)",
          "1018:   list := makeList()",
          "1019:   New(authz, logger).Filter(list)",
          "1021:   require.Empty(t, list.Dump)",
          "1022:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1023:  })",
          "1025:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "1027:   policy, err := acl.NewPolicyFromSource(`",
          "1028:    node \"node1\" {",
          "1029:      policy = \"read\"",
          "1030:    }",
          "1031:   `, acl.SyntaxLegacy, nil, nil)",
          "1032:   require.NoError(t, err)",
          "1034:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1035:   require.NoError(t, err)",
          "1037:   list := makeList()",
          "1038:   New(authz, logger).Filter(list)",
          "1040:   require.Len(t, list.Dump, 1)",
          "1041:   require.Empty(t, list.Dump[0].Services)",
          "1042:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1043:  })",
          "1045:  t.Run(\"denied\", func(t *testing.T) {",
          "1047:   list := makeList()",
          "1048:   New(acl.DenyAll(), logger).Filter(list)",
          "1050:   require.Empty(t, list.Dump)",
          "1051:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1052:  })",
          "1053: }",
          "1055: func TestACL_filterNodes(t *testing.T) {",
          "1056:  t.Parallel()",
          "1059:  nodes := structs.Nodes{",
          "1060:   &structs.Node{",
          "1061:    Node: \"foo\",",
          "1062:   },",
          "1063:   &structs.Node{",
          "1064:    Node: \"bar\",",
          "1065:   },",
          "1066:  }",
          "1069:  filt := New(acl.AllowAll(), nil)",
          "1070:  removed := filt.filterNodes(&nodes)",
          "1071:  require.False(t, removed)",
          "1072:  require.Len(t, nodes, 2)",
          "1075:  filt = New(acl.DenyAll(), nil)",
          "1076:  removed = filt.filterNodes(&nodes)",
          "1077:  require.True(t, removed)",
          "1078:  require.Len(t, nodes, 0)",
          "1079: }",
          "1081: func TestACL_filterIndexedNodesWithGateways(t *testing.T) {",
          "1082:  t.Parallel()",
          "1084:  logger := hclog.NewNullLogger()",
          "1086:  makeList := func() *structs.IndexedNodesWithGateways {",
          "1087:   return &structs.IndexedNodesWithGateways{",
          "1088:    Nodes: structs.CheckServiceNodes{",
          "1089:     {",
          "1090:      Node: &structs.Node{",
          "1091:       Node: \"node1\",",
          "1092:      },",
          "1093:      Service: &structs.NodeService{",
          "1094:       ID:      \"foo\",",
          "1095:       Service: \"foo\",",
          "1096:      },",
          "1097:      Checks: structs.HealthChecks{",
          "1098:       {",
          "1099:        Node:        \"node1\",",
          "1100:        CheckID:     \"check1\",",
          "1101:        ServiceName: \"foo\",",
          "1102:       },",
          "1103:      },",
          "1104:     },",
          "1105:    },",
          "1106:    Gateways: structs.GatewayServices{",
          "1107:     {Service: structs.ServiceNameFromString(\"foo\")},",
          "1108:     {Service: structs.ServiceNameFromString(\"bar\")},",
          "1109:    },",
          "1110:   }",
          "1111:  }",
          "1113:  t.Run(\"allowed\", func(t *testing.T) {",
          "1115:   policy, err := acl.NewPolicyFromSource(`",
          "1116:    service \"foo\" {",
          "1117:      policy = \"read\"",
          "1118:    }",
          "1119:    service \"bar\" {",
          "1120:      policy = \"read\"",
          "1121:    }",
          "1122:    node \"node1\" {",
          "1123:      policy = \"read\"",
          "1124:    }",
          "1125:   `, acl.SyntaxLegacy, nil, nil)",
          "1126:   require.NoError(t, err)",
          "1128:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1129:   require.NoError(t, err)",
          "1131:   list := makeList()",
          "1132:   New(authz, logger).Filter(list)",
          "1134:   require.Len(t, list.Nodes, 1)",
          "1135:   require.Len(t, list.Gateways, 2)",
          "1136:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "1137:  })",
          "1139:  t.Run(\"not allowed to read the node\", func(t *testing.T) {",
          "1141:   policy, err := acl.NewPolicyFromSource(`",
          "1142:    service \"foo\" {",
          "1143:      policy = \"read\"",
          "1144:    }",
          "1145:    service \"bar\" {",
          "1146:      policy = \"read\"",
          "1147:    }",
          "1148:   `, acl.SyntaxLegacy, nil, nil)",
          "1149:   require.NoError(t, err)",
          "1151:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1152:   require.NoError(t, err)",
          "1154:   list := makeList()",
          "1155:   New(authz, logger).Filter(list)",
          "1157:   require.Empty(t, list.Nodes)",
          "1158:   require.Len(t, list.Gateways, 2)",
          "1159:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1160:  })",
          "1162:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "1164:   policy, err := acl.NewPolicyFromSource(`",
          "1165:    node \"node1\" {",
          "1166:      policy = \"read\"",
          "1167:    }",
          "1168:    service \"bar\" {",
          "1169:      policy = \"read\"",
          "1170:    }",
          "1171:   `, acl.SyntaxLegacy, nil, nil)",
          "1172:   require.NoError(t, err)",
          "1174:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1175:   require.NoError(t, err)",
          "1177:   list := makeList()",
          "1178:   New(authz, logger).Filter(list)",
          "1180:   require.Empty(t, list.Nodes)",
          "1181:   require.Len(t, list.Gateways, 1)",
          "1182:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1183:  })",
          "1185:  t.Run(\"not allowed to read the other gatway service\", func(t *testing.T) {",
          "1187:   policy, err := acl.NewPolicyFromSource(`",
          "1188:    service \"foo\" {",
          "1189:      policy = \"read\"",
          "1190:    }",
          "1191:    node \"node1\" {",
          "1192:      policy = \"read\"",
          "1193:    }",
          "1194:   `, acl.SyntaxLegacy, nil, nil)",
          "1195:   require.NoError(t, err)",
          "1197:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1198:   require.NoError(t, err)",
          "1200:   list := makeList()",
          "1201:   New(authz, logger).Filter(list)",
          "1203:   require.Len(t, list.Nodes, 1)",
          "1204:   require.Len(t, list.Gateways, 1)",
          "1205:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1206:  })",
          "1208:  t.Run(\"denied\", func(t *testing.T) {",
          "1210:   list := makeList()",
          "1211:   New(acl.DenyAll(), logger).Filter(list)",
          "1213:   require.Empty(t, list.Nodes)",
          "1214:   require.Empty(t, list.Gateways)",
          "1215:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1216:  })",
          "1217: }",
          "1219: func TestACL_filterIndexedServiceDump(t *testing.T) {",
          "1220:  t.Parallel()",
          "1222:  logger := hclog.NewNullLogger()",
          "1224:  makeList := func() *structs.IndexedServiceDump {",
          "1225:   return &structs.IndexedServiceDump{",
          "1226:    Dump: structs.ServiceDump{",
          "1227:     {",
          "1228:      Node: &structs.Node{",
          "1229:       Node: \"node1\",",
          "1230:      },",
          "1231:      Service: &structs.NodeService{",
          "1232:       Service: \"foo\",",
          "1233:      },",
          "1234:      GatewayService: &structs.GatewayService{",
          "1235:       Service: structs.ServiceNameFromString(\"foo\"),",
          "1236:       Gateway: structs.ServiceNameFromString(\"foo-gateway\"),",
          "1237:      },",
          "1238:     },",
          "1240:     {",
          "1241:      GatewayService: &structs.GatewayService{",
          "1242:       Service: structs.ServiceNameFromString(\"bar\"),",
          "1243:       Gateway: structs.ServiceNameFromString(\"bar-gateway\"),",
          "1244:      },",
          "1245:     },",
          "1246:    },",
          "1247:   }",
          "1248:  }",
          "1250:  t.Run(\"allowed\", func(t *testing.T) {",
          "1252:   policy, err := acl.NewPolicyFromSource(`",
          "1253:    node \"node1\" {",
          "1254:      policy = \"read\"",
          "1255:    }",
          "1256:    service_prefix \"foo\" {",
          "1257:      policy = \"read\"",
          "1258:    }",
          "1259:    service_prefix \"bar\" {",
          "1260:      policy = \"read\"",
          "1261:    }",
          "1262:   `, acl.SyntaxCurrent, nil, nil)",
          "1263:   require.NoError(t, err)",
          "1265:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1266:   require.NoError(t, err)",
          "1268:   list := makeList()",
          "1269:   New(authz, logger).Filter(list)",
          "1271:   require.Len(t, list.Dump, 2)",
          "1272:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "1273:  })",
          "1275:  t.Run(\"not allowed to access node\", func(t *testing.T) {",
          "1277:   policy, err := acl.NewPolicyFromSource(`",
          "1278:    service_prefix \"foo\" {",
          "1279:      policy = \"read\"",
          "1280:    }",
          "1281:    service_prefix \"bar\" {",
          "1282:      policy = \"read\"",
          "1283:    }",
          "1284:   `, acl.SyntaxCurrent, nil, nil)",
          "1285:   require.NoError(t, err)",
          "1287:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1288:   require.NoError(t, err)",
          "1290:   list := makeList()",
          "1291:   New(authz, logger).Filter(list)",
          "1293:   require.Len(t, list.Dump, 1)",
          "1294:   require.Equal(t, \"bar\", list.Dump[0].GatewayService.Service.Name)",
          "1295:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1296:  })",
          "1298:  t.Run(\"not allowed to access service\", func(t *testing.T) {",
          "1300:   policy, err := acl.NewPolicyFromSource(`",
          "1301:    node \"node1\" {",
          "1302:      policy = \"read\"",
          "1303:    }",
          "1304:    service \"foo-gateway\" {",
          "1305:      policy = \"read\"",
          "1306:    }",
          "1307:   `, acl.SyntaxCurrent, nil, nil)",
          "1308:   require.NoError(t, err)",
          "1310:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1311:   require.NoError(t, err)",
          "1313:   list := makeList()",
          "1314:   New(authz, logger).Filter(list)",
          "1316:   require.Empty(t, list.Dump)",
          "1317:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1318:  })",
          "1320:  t.Run(\"not allowed to access gateway\", func(t *testing.T) {",
          "1322:   policy, err := acl.NewPolicyFromSource(`",
          "1323:    node \"node1\" {",
          "1324:      policy = \"read\"",
          "1325:    }",
          "1326:    service \"foo\" {",
          "1327:      policy = \"read\"",
          "1328:    }",
          "1329:   `, acl.SyntaxCurrent, nil, nil)",
          "1330:   require.NoError(t, err)",
          "1332:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1333:   require.NoError(t, err)",
          "1335:   list := makeList()",
          "1336:   New(authz, logger).Filter(list)",
          "1338:   require.Empty(t, list.Dump)",
          "1339:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1340:  })",
          "1341: }",
          "1343: func TestACL_filterDatacenterCheckServiceNodes(t *testing.T) {",
          "1344:  t.Parallel()",
          "1346:  logger := hclog.NewNullLogger()",
          "1348:  makeList := func() *structs.DatacenterIndexedCheckServiceNodes {",
          "1349:   t.Helper()",
          "1351:   node := func(dc, node, ip string) structs.CheckServiceNode {",
          "1352:    t.Helper()",
          "1354:    id, err := uuid.GenerateUUID()",
          "1355:    require.NoError(t, err)",
          "1357:    return structs.CheckServiceNode{",
          "1358:     Node: &structs.Node{",
          "1359:      ID:         types.NodeID(id),",
          "1360:      Node:       node,",
          "1361:      Datacenter: dc,",
          "1362:      Address:    ip,",
          "1363:     },",
          "1364:     Service: &structs.NodeService{",
          "1365:      ID:      \"mesh-gateway\",",
          "1366:      Service: \"mesh-gateway\",",
          "1367:      Kind:    structs.ServiceKindMeshGateway,",
          "1368:      Port:    9999,",
          "1369:      Meta:    map[string]string{structs.MetaWANFederationKey: \"1\"},",
          "1370:     },",
          "1371:     Checks: []*structs.HealthCheck{",
          "1372:      {",
          "1373:       Name:      \"web connectivity\",",
          "1374:       Status:    api.HealthPassing,",
          "1375:       ServiceID: \"mesh-gateway\",",
          "1376:      },",
          "1377:     },",
          "1378:    }",
          "1379:   }",
          "1381:   return &structs.DatacenterIndexedCheckServiceNodes{",
          "1382:    DatacenterNodes: map[string]structs.CheckServiceNodes{",
          "1383:     \"dc1\": []structs.CheckServiceNode{",
          "1384:      node(\"dc1\", \"gateway1a\", \"1.2.3.4\"),",
          "1385:      node(\"dc1\", \"gateway2a\", \"4.3.2.1\"),",
          "1386:     },",
          "1387:     \"dc2\": []structs.CheckServiceNode{",
          "1388:      node(\"dc2\", \"gateway1b\", \"5.6.7.8\"),",
          "1389:      node(\"dc2\", \"gateway2b\", \"8.7.6.5\"),",
          "1390:     },",
          "1391:    },",
          "1392:   }",
          "1393:  }",
          "1395:  t.Run(\"allowed\", func(t *testing.T) {",
          "1397:   policy, err := acl.NewPolicyFromSource(`",
          "1398:    node_prefix \"\" {",
          "1399:      policy = \"read\"",
          "1400:    }",
          "1401:    service_prefix \"\" {",
          "1402:      policy = \"read\"",
          "1403:    }",
          "1404:   `, acl.SyntaxCurrent, nil, nil)",
          "1405:   require.NoError(t, err)",
          "1407:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1408:   require.NoError(t, err)",
          "1410:   list := makeList()",
          "1411:   New(authz, logger).Filter(list)",
          "1413:   require.Len(t, list.DatacenterNodes[\"dc1\"], 2)",
          "1414:   require.Len(t, list.DatacenterNodes[\"dc2\"], 2)",
          "1415:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "1416:  })",
          "1418:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "1420:   policy, err := acl.NewPolicyFromSource(`",
          "1421:    service_prefix \"\" {",
          "1422:      policy = \"read\"",
          "1423:    }",
          "1424:   `, acl.SyntaxCurrent, nil, nil)",
          "1425:   require.NoError(t, err)",
          "1427:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1428:   require.NoError(t, err)",
          "1430:   list := makeList()",
          "1431:   New(authz, logger).Filter(list)",
          "1433:   require.Empty(t, list.DatacenterNodes)",
          "1434:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1435:  })",
          "1437:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "1439:   policy, err := acl.NewPolicyFromSource(`",
          "1440:    node_prefix \"\" {",
          "1441:      policy = \"read\"",
          "1442:    }",
          "1443:   `, acl.SyntaxCurrent, nil, nil)",
          "1444:   require.NoError(t, err)",
          "1446:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1447:   require.NoError(t, err)",
          "1449:   list := makeList()",
          "1450:   New(authz, logger).Filter(list)",
          "1452:   require.Empty(t, list.DatacenterNodes)",
          "1453:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1454:  })",
          "1456:  t.Run(\"denied\", func(t *testing.T) {",
          "1458:   list := makeList()",
          "1459:   New(acl.DenyAll(), logger).Filter(list)",
          "1461:   require.Empty(t, list.DatacenterNodes)",
          "1462:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1463:  })",
          "1464: }",
          "1466: func TestACL_redactPreparedQueryTokens(t *testing.T) {",
          "1467:  t.Parallel()",
          "1468:  query := &structs.PreparedQuery{",
          "1469:   ID:    \"f004177f-2c28-83b7-4229-eacc25fe55d1\",",
          "1470:   Token: \"root\",",
          "1471:  }",
          "1473:  expected := &structs.PreparedQuery{",
          "1474:   ID:    \"f004177f-2c28-83b7-4229-eacc25fe55d1\",",
          "1475:   Token: \"root\",",
          "1476:  }",
          "1480:  filt := New(acl.ManageAll(), nil)",
          "1481:  filt.redactPreparedQueryTokens(&query)",
          "1482:  if !reflect.DeepEqual(query, expected) {",
          "1483:   t.Fatalf(\"bad: %#v\", &query)",
          "1484:  }",
          "1488:  original := query",
          "1492:  filt = New(acl.AllowAll(), nil)",
          "1493:  filt.redactPreparedQueryTokens(&query)",
          "1494:  expected.Token = RedactedToken",
          "1495:  if !reflect.DeepEqual(query, expected) {",
          "1496:   t.Fatalf(\"bad: %#v\", *query)",
          "1497:  }",
          "1500:  if original.Token != \"root\" {",
          "1501:   t.Fatalf(\"bad token: %s\", original.Token)",
          "1502:  }",
          "1503: }",
          "1505: func TestFilterACL_redactTokenSecret(t *testing.T) {",
          "1506:  t.Parallel()",
          "1508:  token := &structs.ACLToken{",
          "1509:   AccessorID: \"6a5e25b3-28f2-4085-9012-c3fb754314d1\",",
          "1510:   SecretID:   \"6a5e25b3-28f2-4085-9012-c3fb754314d1\",",
          "1511:  }",
          "1513:  New(policy(t, `acl = \"write\"`), nil).Filter(&token)",
          "1514:  require.Equal(t, \"6a5e25b3-28f2-4085-9012-c3fb754314d1\", token.SecretID)",
          "1516:  New(policy(t, `acl = \"read\"`), nil).Filter(&token)",
          "1517:  require.Equal(t, RedactedToken, token.SecretID)",
          "1518: }",
          "1520: func TestFilterACL_redactTokenSecrets(t *testing.T) {",
          "1521:  t.Parallel()",
          "1523:  tokens := structs.ACLTokens{",
          "1524:   &structs.ACLToken{",
          "1525:    AccessorID: \"6a5e25b3-28f2-4085-9012-c3fb754314d1\",",
          "1526:    SecretID:   \"6a5e25b3-28f2-4085-9012-c3fb754314d1\",",
          "1527:   },",
          "1528:  }",
          "1530:  New(policy(t, `acl = \"write\"`), nil).Filter(&tokens)",
          "1531:  require.Equal(t, \"6a5e25b3-28f2-4085-9012-c3fb754314d1\", tokens[0].SecretID)",
          "1533:  New(policy(t, `acl = \"read\"`), nil).Filter(&tokens)",
          "1534:  require.Equal(t, RedactedToken, tokens[0].SecretID)",
          "1535: }",
          "1537: func TestACL_filterPreparedQueries(t *testing.T) {",
          "1538:  t.Parallel()",
          "1540:  logger := hclog.NewNullLogger()",
          "1542:  makeList := func() *structs.IndexedPreparedQueries {",
          "1543:   return &structs.IndexedPreparedQueries{",
          "1544:    Queries: structs.PreparedQueries{",
          "1545:     {ID: \"f004177f-2c28-83b7-4229-eacc25fe55d1\"},",
          "1546:     {",
          "1547:      ID:   \"f004177f-2c28-83b7-4229-eacc25fe55d2\",",
          "1548:      Name: \"query-with-no-token\",",
          "1549:     },",
          "1550:     {",
          "1551:      ID:    \"f004177f-2c28-83b7-4229-eacc25fe55d3\",",
          "1552:      Name:  \"query-with-a-token\",",
          "1553:      Token: \"root\",",
          "1554:     },",
          "1555:    },",
          "1556:   }",
          "1557:  }",
          "1559:  t.Run(\"management token\", func(t *testing.T) {",
          "1561:   list := makeList()",
          "1562:   New(acl.ManageAll(), logger).Filter(list)",
          "1565:   require.Len(t, list.Queries, 3)",
          "1568:   require.Equal(t, \"root\", list.Queries[2].Token)",
          "1570:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "1571:  })",
          "1573:  t.Run(\"permissive filtering\", func(t *testing.T) {",
          "1575:   list := makeList()",
          "1576:   queryWithToken := list.Queries[2]",
          "1578:   New(acl.AllowAll(), logger).Filter(list)",
          "1581:   require.Len(t, list.Queries, 2)",
          "1584:   require.Equal(t, RedactedToken, list.Queries[1].Token)",
          "1587:   require.Equal(t, \"root\", queryWithToken.Token)",
          "1591:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "1592:  })",
          "1594:  t.Run(\"limited access\", func(t *testing.T) {",
          "1596:   policy, err := acl.NewPolicyFromSource(`",
          "1597:    query \"query-with-a-token\" {",
          "1598:      policy = \"read\"",
          "1599:    }",
          "1600:   `, acl.SyntaxLegacy, nil, nil)",
          "1601:   require.NoError(t, err)",
          "1603:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1604:   require.NoError(t, err)",
          "1606:   list := makeList()",
          "1607:   New(authz, logger).Filter(list)",
          "1610:   require.Len(t, list.Queries, 1)",
          "1613:   require.Equal(t, RedactedToken, list.Queries[0].Token)",
          "1615:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1616:  })",
          "1618:  t.Run(\"restrictive filtering\", func(t *testing.T) {",
          "1620:   list := makeList()",
          "1621:   New(acl.DenyAll(), logger).Filter(list)",
          "1623:   require.Empty(t, list.Queries)",
          "1624:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1625:  })",
          "1626: }",
          "1628: func TestACL_filterServiceList(t *testing.T) {",
          "1629:  logger := hclog.NewNullLogger()",
          "1631:  makeList := func() *structs.IndexedServiceList {",
          "1632:   return &structs.IndexedServiceList{",
          "1633:    Services: structs.ServiceList{",
          "1634:     {Name: \"foo\"},",
          "1635:     {Name: \"bar\"},",
          "1636:    },",
          "1637:   }",
          "1638:  }",
          "1640:  t.Run(\"permissive filtering\", func(t *testing.T) {",
          "1642:   list := makeList()",
          "1643:   New(acl.AllowAll(), logger).Filter(list)",
          "1645:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "1646:   require.Len(t, list.Services, 2)",
          "1647:  })",
          "1649:  t.Run(\"restrictive filtering\", func(t *testing.T) {",
          "1651:   list := makeList()",
          "1652:   New(acl.DenyAll(), logger).Filter(list)",
          "1654:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1655:   require.Empty(t, list.Services)",
          "1656:  })",
          "1657: }",
          "1659: func TestACL_unhandledFilterType(t *testing.T) {",
          "1660:  t.Parallel()",
          "1662:  filter := New(acl.AllowAll(), nil)",
          "1664:  require.Panics(t, func() {",
          "1665:   filter.Filter(&structs.HealthCheck{})",
          "1666:  })",
          "1667: }",
          "1669: func policy(t *testing.T, hcl string) acl.Authorizer {",
          "1670:  t.Helper()",
          "1672:  policy, err := acl.NewPolicyFromSource(hcl, acl.SyntaxCurrent, nil, nil)",
          "1673:  require.NoError(t, err)",
          "1675:  authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1676:  require.NoError(t, err)",
          "1678:  return authz",
          "1679: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "40eb2845ca019b5e9640f3585886ddbf9ff7a910",
      "candidate_info": {
        "commit_hash": "40eb2845ca019b5e9640f3585886ddbf9ff7a910",
        "repo": "hashicorp/consul",
        "commit_url": "https://github.com/hashicorp/consul/commit/40eb2845ca019b5e9640f3585886ddbf9ff7a910",
        "files": [
          ".changelog/15356.txt",
          "agent/structs/aclfilter/filter.go",
          "agent/structs/aclfilter/filter_test.go",
          "agent/structs/structs_oss.go"
        ],
        "message": "Backport of Ensure that NodeDump imported nodes are filtered into release/1.13.x (#15358)\n\nThis pull request was automerged via backport-assistant",
        "before_after_code_files": [
          "agent/structs/aclfilter/filter.go||agent/structs/aclfilter/filter.go",
          "agent/structs/aclfilter/filter_test.go||agent/structs/aclfilter/filter_test.go",
          "agent/structs/structs_oss.go||agent/structs/structs_oss.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "agent/structs/aclfilter/filter.go||agent/structs/aclfilter/filter.go",
            "agent/structs/aclfilter/filter_test.go||agent/structs/aclfilter/filter_test.go",
            "agent/structs/structs_oss.go||agent/structs/structs_oss.go"
          ],
          "candidate": [
            "agent/structs/aclfilter/filter.go||agent/structs/aclfilter/filter.go",
            "agent/structs/aclfilter/filter_test.go||agent/structs/aclfilter/filter_test.go",
            "agent/structs/structs_oss.go||agent/structs/structs_oss.go"
          ]
        }
      },
      "candidate_diff": {
        "agent/structs/aclfilter/filter.go||agent/structs/aclfilter/filter.go": [
          "File: agent/structs/aclfilter/filter.go -> agent/structs/aclfilter/filter.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:   v.QueryMeta.ResultsFilteredByACLs = f.filterIntentions(&v.Intentions)",
          "63:  case *structs.IndexedNodeDump:",
          "66:  case *structs.IndexedServiceDump:",
          "67:   v.QueryMeta.ResultsFilteredByACLs = f.filterServiceDump(&v.Dump)",
          "",
          "[Removed Lines]",
          "64:   v.QueryMeta.ResultsFilteredByACLs = f.filterNodeDump(&v.Dump)",
          "",
          "[Added Lines]",
          "64:   if f.filterNodeDump(&v.Dump) {",
          "65:    v.QueryMeta.ResultsFilteredByACLs = true",
          "66:   }",
          "67:   if f.filterNodeDump(&v.ImportedDump) {",
          "68:    v.QueryMeta.ResultsFilteredByACLs = true",
          "69:   }",
          "",
          "---------------"
        ],
        "agent/structs/aclfilter/filter_test.go||agent/structs/aclfilter/filter_test.go": [
          "File: agent/structs/aclfilter/filter_test.go -> agent/structs/aclfilter/filter_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "978:      },",
          "979:     },",
          "980:    },",
          "981:   }",
          "982:  }",
          "987:    service \"foo\" {",
          "988:      policy = \"read\"",
          "989:    }",
          "990:    node \"node1\" {",
          "991:      policy = \"read\"",
          "992:    }",
          "993:   `, acl.SyntaxLegacy, nil, nil)",
          "1009:    service \"foo\" {",
          "1010:      policy = \"read\"",
          "1011:    }",
          "1012:   `, acl.SyntaxLegacy, nil, nil)",
          "1029:      policy = \"read\"",
          "1030:    }",
          "1031:   `, acl.SyntaxLegacy, nil, nil)",
          "1053: }",
          "1055: func TestACL_filterNodes(t *testing.T) {",
          "",
          "[Removed Lines]",
          "984:  t.Run(\"allowed\", func(t *testing.T) {",
          "986:   policy, err := acl.NewPolicyFromSource(`",
          "994:   require.NoError(t, err)",
          "996:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "997:   require.NoError(t, err)",
          "999:   list := makeList()",
          "1000:   New(authz, logger).Filter(list)",
          "1002:   require.Len(t, list.Dump, 1)",
          "1003:   require.False(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be false\")",
          "1004:  })",
          "1006:  t.Run(\"allowed to read the service, but not the node\", func(t *testing.T) {",
          "1008:   policy, err := acl.NewPolicyFromSource(`",
          "1013:   require.NoError(t, err)",
          "1015:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1016:   require.NoError(t, err)",
          "1018:   list := makeList()",
          "1019:   New(authz, logger).Filter(list)",
          "1021:   require.Empty(t, list.Dump)",
          "1022:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1023:  })",
          "1025:  t.Run(\"allowed to read the node, but not the service\", func(t *testing.T) {",
          "1027:   policy, err := acl.NewPolicyFromSource(`",
          "1028:    node \"node1\" {",
          "1032:   require.NoError(t, err)",
          "1034:   authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1035:   require.NoError(t, err)",
          "1037:   list := makeList()",
          "1038:   New(authz, logger).Filter(list)",
          "1040:   require.Len(t, list.Dump, 1)",
          "1041:   require.Empty(t, list.Dump[0].Services)",
          "1042:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1043:  })",
          "1045:  t.Run(\"denied\", func(t *testing.T) {",
          "1047:   list := makeList()",
          "1048:   New(acl.DenyAll(), logger).Filter(list)",
          "1050:   require.Empty(t, list.Dump)",
          "1051:   require.True(t, list.QueryMeta.ResultsFilteredByACLs, \"ResultsFilteredByACLs should be true\")",
          "1052:  })",
          "",
          "[Added Lines]",
          "981:    ImportedDump: structs.NodeDump{",
          "982:     {",
          "985:      Node:     \"node1\",",
          "986:      PeerName: \"cluster-02\",",
          "987:      Services: []*structs.NodeService{",
          "988:       {",
          "989:        ID:       \"foo\",",
          "990:        Service:  \"foo\",",
          "991:        PeerName: \"cluster-02\",",
          "992:       },",
          "993:      },",
          "994:      Checks: []*structs.HealthCheck{",
          "995:       {",
          "996:        Node:        \"node1\",",
          "997:        CheckID:     \"check1\",",
          "998:        ServiceName: \"foo\",",
          "999:        PeerName:    \"cluster-02\",",
          "1000:       },",
          "1001:      },",
          "1002:     },",
          "1003:    },",
          "1006:  type testCase struct {",
          "1007:   authzFn func() acl.Authorizer",
          "1008:   expect  *structs.IndexedNodeDump",
          "1009:  }",
          "1011:  run := func(t *testing.T, tc testCase) {",
          "1012:   authz := tc.authzFn()",
          "1014:   list := makeList()",
          "1015:   New(authz, logger).Filter(list)",
          "1017:   require.Equal(t, tc.expect, list)",
          "1018:  }",
          "1020:  tt := map[string]testCase{",
          "1021:   \"denied\": {",
          "1022:    authzFn: func() acl.Authorizer {",
          "1023:     return acl.DenyAll()",
          "1024:    },",
          "1025:    expect: &structs.IndexedNodeDump{",
          "1026:     Dump:         structs.NodeDump{},",
          "1027:     ImportedDump: structs.NodeDump{},",
          "1028:     QueryMeta:    structs.QueryMeta{ResultsFilteredByACLs: true},",
          "1029:    },",
          "1030:   },",
          "1031:   \"can read local service but not the node\": {",
          "1032:    authzFn: func() acl.Authorizer {",
          "1033:     policy, err := acl.NewPolicyFromSource(`",
          "1037:   `, acl.SyntaxLegacy, nil, nil)",
          "1038:     require.NoError(t, err)",
          "1040:     authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1041:     require.NoError(t, err)",
          "1043:     return authz",
          "1044:    },",
          "1045:    expect: &structs.IndexedNodeDump{",
          "1046:     Dump:         structs.NodeDump{},",
          "1047:     ImportedDump: structs.NodeDump{},",
          "1048:     QueryMeta:    structs.QueryMeta{ResultsFilteredByACLs: true},",
          "1049:    },",
          "1050:   },",
          "1051:   \"can read the local node but not the service\": {",
          "1052:    authzFn: func() acl.Authorizer {",
          "1053:     policy, err := acl.NewPolicyFromSource(`",
          "1058:     require.NoError(t, err)",
          "1060:     authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1061:     require.NoError(t, err)",
          "1063:     return authz",
          "1064:    },",
          "1065:    expect: &structs.IndexedNodeDump{",
          "1066:     Dump: structs.NodeDump{",
          "1067:      {",
          "1068:       Node:     \"node1\",",
          "1069:       Services: []*structs.NodeService{},",
          "1070:       Checks:   structs.HealthChecks{},",
          "1071:      },",
          "1072:     },",
          "1073:     ImportedDump: structs.NodeDump{},",
          "1074:     QueryMeta:    structs.QueryMeta{ResultsFilteredByACLs: true},",
          "1075:    },",
          "1076:   },",
          "1077:   \"can read local data\": {",
          "1078:    authzFn: func() acl.Authorizer {",
          "1079:     policy, err := acl.NewPolicyFromSource(`",
          "1083:    node \"node1\" {",
          "1084:      policy = \"read\"",
          "1085:    }",
          "1087:     require.NoError(t, err)",
          "1089:     authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1090:     require.NoError(t, err)",
          "1092:     return authz",
          "1093:    },",
          "1094:    expect: &structs.IndexedNodeDump{",
          "1095:     Dump: structs.NodeDump{",
          "1096:      {",
          "1097:       Node: \"node1\",",
          "1098:       Services: []*structs.NodeService{",
          "1099:        {",
          "1100:         ID:      \"foo\",",
          "1101:         Service: \"foo\",",
          "1102:        },",
          "1103:       },",
          "1104:       Checks: []*structs.HealthCheck{",
          "1105:        {",
          "1106:         Node:        \"node1\",",
          "1107:         CheckID:     \"check1\",",
          "1108:         ServiceName: \"foo\",",
          "1109:        },",
          "1110:       },",
          "1111:      },",
          "1112:     },",
          "1113:     ImportedDump: structs.NodeDump{},",
          "1114:     QueryMeta:    structs.QueryMeta{ResultsFilteredByACLs: true},",
          "1115:    },",
          "1116:   },",
          "1117:   \"can read imported service but not the node\": {",
          "1118:    authzFn: func() acl.Authorizer {",
          "1120:     policy, err := acl.NewPolicyFromSource(`",
          "1121:    service \"\" {",
          "1122:      policy = \"read\"",
          "1123:    }",
          "1124:   `, acl.SyntaxLegacy, nil, nil)",
          "1125:     require.NoError(t, err)",
          "1127:     authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1128:     require.NoError(t, err)",
          "1130:     return authz",
          "1131:    },",
          "1132:    expect: &structs.IndexedNodeDump{",
          "1133:     Dump:         structs.NodeDump{},",
          "1134:     ImportedDump: structs.NodeDump{},",
          "1135:     QueryMeta:    structs.QueryMeta{ResultsFilteredByACLs: true},",
          "1136:    },",
          "1137:   },",
          "1138:   \"can read the imported node but not the service\": {",
          "1139:    authzFn: func() acl.Authorizer {",
          "1141:     policy, err := acl.NewPolicyFromSource(`",
          "1142:    node \"\" {",
          "1146:     require.NoError(t, err)",
          "1148:     authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1149:     require.NoError(t, err)",
          "1151:     return authz",
          "1152:    },",
          "1153:    expect: &structs.IndexedNodeDump{",
          "1154:     Dump: structs.NodeDump{",
          "1155:      {",
          "1156:       Node:     \"node1\",",
          "1157:       Services: []*structs.NodeService{},",
          "1158:       Checks:   structs.HealthChecks{},",
          "1159:      },",
          "1160:     },",
          "1161:     ImportedDump: structs.NodeDump{",
          "1162:      {",
          "1163:       Node:     \"node1\",",
          "1164:       PeerName: \"cluster-02\",",
          "1165:       Services: []*structs.NodeService{},",
          "1166:       Checks:   structs.HealthChecks{},",
          "1167:      },",
          "1168:     },",
          "1169:     QueryMeta: structs.QueryMeta{ResultsFilteredByACLs: true},",
          "1170:    },",
          "1171:   },",
          "1172:   \"can read all data\": {",
          "1173:    authzFn: func() acl.Authorizer {",
          "1174:     policy, err := acl.NewPolicyFromSource(`",
          "1175:    service \"\" {",
          "1176:      policy = \"read\"",
          "1177:    }",
          "1178:    node \"\" {",
          "1179:      policy = \"read\"",
          "1180:    }",
          "1181:   `, acl.SyntaxLegacy, nil, nil)",
          "1182:     require.NoError(t, err)",
          "1184:     authz, err := acl.NewPolicyAuthorizerWithDefaults(acl.DenyAll(), []*acl.Policy{policy}, nil)",
          "1185:     require.NoError(t, err)",
          "1187:     return authz",
          "1188:    },",
          "1189:    expect: &structs.IndexedNodeDump{",
          "1190:     Dump: structs.NodeDump{",
          "1191:      {",
          "1192:       Node: \"node1\",",
          "1193:       Services: []*structs.NodeService{",
          "1194:        {",
          "1195:         ID:      \"foo\",",
          "1196:         Service: \"foo\",",
          "1197:        },",
          "1198:       },",
          "1199:       Checks: []*structs.HealthCheck{",
          "1200:        {",
          "1201:         Node:        \"node1\",",
          "1202:         CheckID:     \"check1\",",
          "1203:         ServiceName: \"foo\",",
          "1204:        },",
          "1205:       },",
          "1206:      },",
          "1207:     },",
          "1208:     ImportedDump: structs.NodeDump{",
          "1209:      {",
          "1210:       Node:     \"node1\",",
          "1211:       PeerName: \"cluster-02\",",
          "1212:       Services: []*structs.NodeService{",
          "1213:        {",
          "1214:         ID:       \"foo\",",
          "1215:         Service:  \"foo\",",
          "1216:         PeerName: \"cluster-02\",",
          "1217:        },",
          "1218:       },",
          "1219:       Checks: []*structs.HealthCheck{",
          "1220:        {",
          "1221:         Node:        \"node1\",",
          "1222:         CheckID:     \"check1\",",
          "1223:         ServiceName: \"foo\",",
          "1224:         PeerName:    \"cluster-02\",",
          "1225:        },",
          "1226:       },",
          "1227:      },",
          "1228:     },",
          "1229:     QueryMeta: structs.QueryMeta{ResultsFilteredByACLs: false},",
          "1230:    },",
          "1231:   },",
          "1232:  }",
          "1234:  for name, tc := range tt {",
          "1235:   t.Run(name, func(t *testing.T) {",
          "1236:    run(t, tc)",
          "1237:   })",
          "1238:  }",
          "",
          "---------------"
        ],
        "agent/structs/structs_oss.go||agent/structs/structs_oss.go": [
          "File: agent/structs/structs_oss.go -> agent/structs/structs_oss.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: func (_ *Coordinate) FillAuthzContext(_ *acl.AuthorizerContext) {}",
          "69: func (_ *DirEntry) FillAuthzContext(_ *acl.AuthorizerContext) {}",
          "",
          "[Removed Lines]",
          "66: func (_ *NodeInfo) FillAuthzContext(_ *acl.AuthorizerContext) {}",
          "",
          "[Added Lines]",
          "66: func (n *NodeInfo) FillAuthzContext(ctx *acl.AuthorizerContext) {",
          "67:  ctx.Peer = n.PeerName",
          "68: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
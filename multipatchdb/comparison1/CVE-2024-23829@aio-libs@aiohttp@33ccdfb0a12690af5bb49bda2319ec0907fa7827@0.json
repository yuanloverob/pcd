{
  "cve_id": "CVE-2024-23829",
  "cve_desc": "aiohttp is an asynchronous HTTP client/server framework for asyncio and Python. Security-sensitive parts of the Python HTTP parser retained minor differences in allowable character sets, that must trigger error handling to robustly match frame boundaries of proxies in order to protect against injection of additional requests. Additionally, validation could trigger exceptions that were not handled consistently with processing of other malformed input.  Being more lenient than internet standards require could, depending on deployment environment, assist in request smuggling. The unhandled exception could cause excessive resource consumption on the application server and/or its logging facilities. This vulnerability exists due to an incomplete fix for CVE-2023-47627. Version 3.9.2 fixes this vulnerability.",
  "repo": "aio-libs/aiohttp",
  "patch_hash": "33ccdfb0a12690af5bb49bda2319ec0907fa7827",
  "patch_info": {
    "commit_hash": "33ccdfb0a12690af5bb49bda2319ec0907fa7827",
    "repo": "aio-libs/aiohttp",
    "commit_url": "https://github.com/aio-libs/aiohttp/commit/33ccdfb0a12690af5bb49bda2319ec0907fa7827",
    "files": [
      "CHANGES/8074.bugfix.rst",
      "CONTRIBUTORS.txt",
      "aiohttp/http_parser.py",
      "tests/test_http_parser.py"
    ],
    "message": "Improve validation in HTTP parser (#8074)\n\nCo-authored-by: Paul J. Dorn <pajod@users.noreply.github.com>\nCo-authored-by: Sviatoslav Sydorenko (\u0421\u0432\u044f\u0442\u043e\u0441\u043b\u0430\u0432 \u0421\u0438\u0434\u043e\u0440\u0435\u043d\u043a\u043e) <sviat@redhat.com>",
    "before_after_code_files": [
      "aiohttp/http_parser.py||aiohttp/http_parser.py",
      "tests/test_http_parser.py||tests/test_http_parser.py"
    ]
  },
  "patch_diff": {
    "aiohttp/http_parser.py||aiohttp/http_parser.py": [
      "File: aiohttp/http_parser.py -> aiohttp/http_parser.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "69: #     tchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" /",
      "70: #             \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA",
      "71: #     token = 1*tchar",
      "80: class RawRequestMessage(NamedTuple):",
      "",
      "[Removed Lines]",
      "72: METHRE: Final[Pattern[str]] = re.compile(r\"[!#$%&'*+\\-.^_`|~0-9A-Za-z]+\")",
      "73: VERSRE: Final[Pattern[str]] = re.compile(r\"HTTP/(\\d).(\\d)\")",
      "74: HDRRE: Final[Pattern[bytes]] = re.compile(",
      "75:     rb\"[\\x00-\\x1F\\x7F-\\xFF()<>@,;:\\[\\]={} \\t\\\"\\\\]\"",
      "76: )",
      "77: HEXDIGIT = re.compile(rb\"[0-9a-fA-F]+\")",
      "",
      "[Added Lines]",
      "72: _TCHAR_SPECIALS: Final[str] = re.escape(\"!#$%&'*+-.^_`|~\")",
      "73: TOKENRE: Final[Pattern[str]] = re.compile(f\"[0-9A-Za-z{_TCHAR_SPECIALS}]+\")",
      "74: VERSRE: Final[Pattern[str]] = re.compile(r\"HTTP/(\\d)\\.(\\d)\", re.ASCII)",
      "75: DIGITS: Final[Pattern[str]] = re.compile(r\"\\d+\", re.ASCII)",
      "76: HEXDIGITS: Final[Pattern[bytes]] = re.compile(rb\"[0-9a-fA-F]+\")",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "133:         self, lines: List[bytes]",
      "134:     ) -> Tuple[\"CIMultiDictProxy[str]\", RawHeaders]:",
      "135:         headers: CIMultiDict[str] = CIMultiDict()",
      "136:         raw_headers = []",
      "138:         lines_idx = 1",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "135:         # note: \"raw\" does not mean inclusion of OWS before/after the field value",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "146:             except ValueError:",
      "147:                 raise InvalidHeader(line) from None",
      "149:             # https://www.rfc-editor.org/rfc/rfc9112.html#section-5.1-2",
      "150:             if {bname[0], bname[-1]} & {32, 9}:  # {\" \", \"\\t\"}",
      "151:                 raise InvalidHeader(line)",
      "153:             bvalue = bvalue.lstrip(b\" \\t\")",
      "156:             if len(bname) > self.max_field_size:",
      "157:                 raise LineTooLong(",
      "158:                     \"request header name {}\".format(",
      "",
      "[Removed Lines]",
      "154:             if HDRRE.search(bname):",
      "155:                 raise InvalidHeader(bname)",
      "",
      "[Added Lines]",
      "149:             if len(bname) == 0:",
      "150:                 raise InvalidHeader(bname)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "161:                     str(self.max_field_size),",
      "162:                     str(len(bname)),",
      "163:                 )",
      "165:             header_length = len(bvalue)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "165:             name = bname.decode(\"utf-8\", \"surrogateescape\")",
      "166:             if not TOKENRE.fullmatch(name):",
      "167:                 raise InvalidHeader(bname)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "207:                     )",
      "209:             bvalue = bvalue.strip(b\" \\t\")",
      "211:             value = bvalue.decode(\"utf-8\", \"surrogateescape\")",
      "213:             # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-5",
      "",
      "[Removed Lines]",
      "210:             name = bname.decode(\"utf-8\", \"surrogateescape\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "332:                             # Shouldn't allow +/- or other number formats.",
      "333:                             # https://www.rfc-editor.org/rfc/rfc9110#section-8.6-2",
      "335:                                 raise InvalidHeader(CONTENT_LENGTH)",
      "337:                             return int(length_hdr)",
      "",
      "[Removed Lines]",
      "334:                             if not length_hdr.strip(\" \\t\").isdecimal():",
      "",
      "[Added Lines]",
      "337:                             # msg.headers is already stripped of leading/trailing wsp",
      "338:                             if not DIGITS.fullmatch(length_hdr):",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "559:             )",
      "561:         # method",
      "563:             raise BadStatusLine(method)",
      "565:         # version",
      "",
      "[Removed Lines]",
      "562:         if not METHRE.fullmatch(method):",
      "",
      "[Added Lines]",
      "566:         if not TOKENRE.fullmatch(method):",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "676:             raise BadStatusLine(line)",
      "677:         version_o = HttpVersion(int(match.group(1)), int(match.group(2)))",
      "681:             raise BadStatusLine(line)",
      "682:         status_i = int(status)",
      "",
      "[Removed Lines]",
      "679:         # The status code is a three-digit number",
      "680:         if len(status) != 3 or not status.isdecimal():",
      "",
      "[Added Lines]",
      "683:         # The status code is a three-digit ASCII number, no padding",
      "684:         if len(status) != 3 or not DIGITS.fullmatch(status):",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "818:                         if self._lax:  # Allow whitespace in lax mode.",
      "819:                             size_b = size_b.strip()",
      "822:                             exc = TransferEncodingError(",
      "823:                                 chunk[:pos].decode(\"ascii\", \"surrogateescape\")",
      "824:                             )",
      "",
      "[Removed Lines]",
      "821:                         if not re.fullmatch(HEXDIGIT, size_b):",
      "",
      "[Added Lines]",
      "825:                         if not re.fullmatch(HEXDIGITS, size_b):",
      "",
      "---------------"
    ],
    "tests/test_http_parser.py||tests/test_http_parser.py": [
      "File: tests/test_http_parser.py -> tests/test_http_parser.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "4: import asyncio",
      "5: import re",
      "7: from unittest import mock",
      "8: from urllib.parse import quote",
      "",
      "[Removed Lines]",
      "6: from typing import Any, List",
      "",
      "[Added Lines]",
      "6: from contextlib import nullcontext",
      "7: from typing import Any, Dict, List",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "168:         parser.feed_data(text)",
      "171: @pytest.mark.parametrize(",
      "172:     \"hdr\",",
      "173:     (",
      "174:         \"Content-Length: -5\",  # https://www.rfc-editor.org/rfc/rfc9110.html#name-content-length",
      "175:         \"Content-Length: +256\",",
      "176:         \"Foo: abc\\rdef\",  # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-5",
      "177:         \"Bar: abc\\ndef\",",
      "178:         \"Baz: abc\\x00def\",",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "172: @pytest.mark.parametrize(",
      "173:     \"rfc9110_5_6_2_token_delim\",",
      "174:     r'\"(),/:;<=>?@[\\]{}',",
      "175: )",
      "176: def test_bad_header_name(parser: Any, rfc9110_5_6_2_token_delim: str) -> None:",
      "177:     text = f\"POST / HTTP/1.1\\r\\nhead{rfc9110_5_6_2_token_delim}er: val\\r\\n\\r\\n\".encode()",
      "178:     expectation = pytest.raises(http_exceptions.BadHttpMessage)",
      "179:     if rfc9110_5_6_2_token_delim == \":\":",
      "180:         # Inserting colon into header just splits name/value earlier.",
      "181:         expectation = nullcontext()",
      "182:     with expectation:",
      "183:         parser.feed_data(text)",
      "191:         \"Content-Length: \\N{superscript one}\",",
      "192:         \"Content-Length: \\N{mathematical double-struck digit one}\",",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "265:         parser.feed_data(text)",
      "268: def test_parse(parser: Any) -> None:",
      "269:     text = b\"GET /test HTTP/1.1\\r\\n\\r\\n\"",
      "270:     messages, upgrade, tail = parser.feed_data(text)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "285: def test_parse_unusual_request_line(parser: Any) -> None:",
      "286:     if not isinstance(response, HttpResponseParserPy):",
      "287:         pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
      "288:     text = b\"#smol //a HTTP/1.3\\r\\n\\r\\n\"",
      "289:     messages, upgrade, tail = parser.feed_data(text)",
      "290:     assert len(messages) == 1",
      "291:     msg, _ = messages[0]",
      "292:     assert msg.compression is None",
      "293:     assert not msg.upgrade",
      "294:     assert msg.method == \"#smol\"",
      "295:     assert msg.path == \"//a\"",
      "296:     assert msg.version == (1, 3)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "567:         parser.feed_data(text)",
      "570: def test_invalid_header(parser: Any) -> None:",
      "571:     text = b\"GET /test HTTP/1.1\\r\\n\" b\"test line\\r\\n\\r\\n\"",
      "572:     with pytest.raises(http_exceptions.BadHttpMessage):",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "601: _pad: Dict[bytes, str] = {",
      "602:     b\"\": \"empty\",",
      "603:     # not a typo. Python likes triple zero",
      "604:     b\"\\000\": \"NUL\",",
      "605:     b\" \": \"SP\",",
      "606:     b\"  \": \"SPSP\",",
      "607:     # not a typo: both 0xa0 and 0x0a in case of 8-bit fun",
      "608:     b\"\\n\": \"LF\",",
      "609:     b\"\\xa0\": \"NBSP\",",
      "610:     b\"\\t \": \"TABSP\",",
      "611: }",
      "614: @pytest.mark.parametrize(\"hdr\", [b\"\", b\"foo\"], ids=[\"name-empty\", \"with-name\"])",
      "615: @pytest.mark.parametrize(\"pad2\", _pad.keys(), ids=[\"post-\" + n for n in _pad.values()])",
      "616: @pytest.mark.parametrize(\"pad1\", _pad.keys(), ids=[\"pre-\" + n for n in _pad.values()])",
      "617: def test_invalid_header_spacing(",
      "618:     parser: Any, pad1: bytes, pad2: bytes, hdr: bytes",
      "619: ) -> None:",
      "620:     text = b\"GET /test HTTP/1.1\\r\\n\" b\"%s%s%s: value\\r\\n\\r\\n\" % (pad1, hdr, pad2)",
      "621:     expectation = pytest.raises(http_exceptions.BadHttpMessage)",
      "622:     if pad1 == pad2 == b\"\" and hdr != b\"\":",
      "623:         # one entry in param matrix is correct: non-empty name, not padded",
      "624:         expectation = nullcontext()",
      "625:     if pad1 == pad2 == hdr == b\"\":",
      "626:         if not isinstance(response, HttpResponseParserPy):",
      "627:             pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
      "628:     with expectation:",
      "629:         parser.feed_data(text)",
      "632: def test_empty_header_name(parser: Any) -> None:",
      "633:     if not isinstance(response, HttpResponseParserPy):",
      "634:         pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
      "635:     text = b\"GET /test HTTP/1.1\\r\\n\" b\":test\\r\\n\\r\\n\"",
      "636:     with pytest.raises(http_exceptions.BadHttpMessage):",
      "637:         parser.feed_data(text)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "689:     assert r\"\\n\" not in exc_info.value.message",
      "692: def test_http_request_bad_status_line_whitespace(parser: Any) -> None:",
      "693:     text = b\"GET\\n/path\\fHTTP/1.1\\r\\n\\r\\n\"",
      "694:     with pytest.raises(http_exceptions.BadStatusLine):",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "762: _num: Dict[bytes, str] = {",
      "763:     # dangerous: accepted by Python int()",
      "764:     # unicodedata.category(\"\\U0001D7D9\") == 'Nd'",
      "765:     \"\\N{mathematical double-struck digit one}\".encode(): \"utf8digit\",",
      "766:     # only added for interop tests, refused by Python int()",
      "767:     # unicodedata.category(\"\\U000000B9\") == 'No'",
      "768:     \"\\N{superscript one}\".encode(): \"utf8number\",",
      "769:     \"\\N{superscript one}\".encode(\"latin-1\"): \"latin1number\",",
      "770: }",
      "773: @pytest.mark.parametrize(\"nonascii_digit\", _num.keys(), ids=_num.values())",
      "774: def test_http_request_bad_status_line_number(",
      "775:     parser: Any, nonascii_digit: bytes",
      "776: ) -> None:",
      "777:     text = b\"GET /digit HTTP/1.\" + nonascii_digit + b\"\\r\\n\\r\\n\"",
      "778:     with pytest.raises(http_exceptions.BadStatusLine):",
      "779:         parser.feed_data(text)",
      "782: def test_http_request_bad_status_line_separator(parser: Any) -> None:",
      "783:     # single code point, old, multibyte NFKC, multibyte NFKD",
      "784:     utf8sep = \"\\N{arabic ligature sallallahou alayhe wasallam}\".encode()",
      "785:     text = b\"GET /ligature HTTP/1\" + utf8sep + b\"1\\r\\n\\r\\n\"",
      "786:     with pytest.raises(http_exceptions.BadStatusLine):",
      "787:         parser.feed_data(text)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "710:     assert tail == b\"some raw data\"",
      "713: def test_http_request_parser_utf8(parser: Any) -> None:",
      "714:     text = \"GET /path HTTP/1.1\\r\\nx-test:\u0442\u0435\u0441\u0442\\r\\n\\r\\n\".encode()",
      "715:     messages, upgrade, tail = parser.feed_data(text)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "811: def test_http_request_parser_utf8_request_line(parser: Any) -> None:",
      "812:     if not isinstance(response, HttpResponseParserPy):",
      "813:         pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
      "814:     messages, upgrade, tail = parser.feed_data(",
      "815:         # note the truncated unicode sequence",
      "816:         b\"GET /P\\xc3\\xbcnktchen\\xa0\\xef\\xb7 HTTP/1.1\\r\\n\" +",
      "817:         # for easier grep: ASCII 0xA0 more commonly known as non-breaking space",
      "818:         # note the leading and trailing spaces",
      "819:         \"sTeP:  \\N{latin small letter sharp s}nek\\t\\N{no-break space}  \"",
      "820:         \"\\r\\n\\r\\n\".encode()",
      "821:     )",
      "822:     msg = messages[0][0]",
      "824:     assert msg.method == \"GET\"",
      "825:     assert msg.path == \"/P\u00fcnktchen\\udca0\\udcef\\udcb7\"",
      "826:     assert msg.version == (1, 1)",
      "827:     assert msg.headers == CIMultiDict([(\"STEP\", \"\u00dfnek\\t\\xa0\")])",
      "828:     assert msg.raw_headers == ((b\"sTeP\", \"\u00dfnek\\t\\xa0\".encode()),)",
      "829:     assert not msg.should_close",
      "830:     assert msg.compression is None",
      "831:     assert not msg.upgrade",
      "832:     assert not msg.chunked",
      "833:     assert msg.url.path == URL(\"/P%C3%BCnktchen\\udca0\\udcef\\udcb7\").path",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "759:     assert not msg.chunked",
      "763:     with pytest.raises(http_exceptions.BadStatusLine):",
      "767: def test_http_request_parser_bad_version(parser: Any) -> None:",
      "",
      "[Removed Lines]",
      "762: def test_http_request_parser_bad_method(parser: Any) -> None:",
      "764:         parser.feed_data(b'G=\":<>(e),[T];?\" /get HTTP/1.1\\r\\n\\r\\n')",
      "",
      "[Added Lines]",
      "885: @pytest.mark.parametrize(",
      "886:     \"rfc9110_5_6_2_token_delim\",",
      "887:     [bytes([i]) for i in rb'\"(),/:;<=>?@[\\]{}'],",
      "888: )",
      "889: def test_http_request_parser_bad_method(",
      "890:     parser: Any, rfc9110_5_6_2_token_delim: bytes",
      "891: ) -> None:",
      "893:         parser.feed_data(rfc9110_5_6_2_token_delim + b'ET\" /get HTTP/1.1\\r\\n\\r\\n')",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "979:         response.feed_data(b\"HTTP/1.1 ttt test\\r\\n\\r\\n\")",
      "982: def test_http_request_chunked_payload(parser: Any) -> None:",
      "983:     text = b\"GET /test HTTP/1.1\\r\\n\" b\"transfer-encoding: chunked\\r\\n\\r\\n\"",
      "984:     msg, payload = parser.feed_data(text)[0][0]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1111: @pytest.mark.parametrize(\"nonascii_digit\", _num.keys(), ids=_num.values())",
      "1112: def test_http_response_parser_code_not_ascii(",
      "1113:     response: Any, nonascii_digit: bytes",
      "1114: ) -> None:",
      "1115:     with pytest.raises(http_exceptions.BadStatusLine):",
      "1116:         response.feed_data(b\"HTTP/1.1 20\" + nonascii_digit + b\" test\\r\\n\\r\\n\")",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a67fb1066f5b8dced690f64bd09f689c032126a6",
      "candidate_info": {
        "commit_hash": "a67fb1066f5b8dced690f64bd09f689c032126a6",
        "repo": "aio-libs/aiohttp",
        "commit_url": "https://github.com/aio-libs/aiohttp/commit/a67fb1066f5b8dced690f64bd09f689c032126a6",
        "files": [
          "CHANGES/8074.bugfix.rst",
          "CONTRIBUTORS.txt",
          "aiohttp/http_parser.py",
          "tests/test_http_parser.py"
        ],
        "message": "Improve validation in HTTP parser (#8074) (#8077)\n\nCo-authored-by: Paul J. Dorn <pajod@users.noreply.github.com>\nCo-authored-by: Sviatoslav Sydorenko (\u0421\u0432\u044f\u0442\u043e\u0441\u043b\u0430\u0432 \u0421\u0438\u0434\u043e\u0440\u0435\u043d\u043a\u043e)\n<sviat@redhat.com>\n(cherry picked from commit 33ccdfb0a12690af5bb49bda2319ec0907fa7827)",
        "before_after_code_files": [
          "aiohttp/http_parser.py||aiohttp/http_parser.py",
          "tests/test_http_parser.py||tests/test_http_parser.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "aiohttp/http_parser.py||aiohttp/http_parser.py",
            "tests/test_http_parser.py||tests/test_http_parser.py"
          ],
          "candidate": [
            "aiohttp/http_parser.py||aiohttp/http_parser.py",
            "tests/test_http_parser.py||tests/test_http_parser.py"
          ]
        }
      },
      "candidate_diff": {
        "aiohttp/http_parser.py||aiohttp/http_parser.py": [
          "File: aiohttp/http_parser.py -> aiohttp/http_parser.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "69: #     tchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" /",
          "70: #             \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA",
          "71: #     token = 1*tchar",
          "80: class RawRequestMessage(NamedTuple):",
          "",
          "[Removed Lines]",
          "72: METHRE: Final[Pattern[str]] = re.compile(r\"[!#$%&'*+\\-.^_`|~0-9A-Za-z]+\")",
          "73: VERSRE: Final[Pattern[str]] = re.compile(r\"HTTP/(\\d).(\\d)\")",
          "74: HDRRE: Final[Pattern[bytes]] = re.compile(",
          "75:     rb\"[\\x00-\\x1F\\x7F-\\xFF()<>@,;:\\[\\]={} \\t\\\"\\\\]\"",
          "76: )",
          "77: HEXDIGIT = re.compile(rb\"[0-9a-fA-F]+\")",
          "",
          "[Added Lines]",
          "72: _TCHAR_SPECIALS: Final[str] = re.escape(\"!#$%&'*+-.^_`|~\")",
          "73: TOKENRE: Final[Pattern[str]] = re.compile(f\"[0-9A-Za-z{_TCHAR_SPECIALS}]+\")",
          "74: VERSRE: Final[Pattern[str]] = re.compile(r\"HTTP/(\\d)\\.(\\d)\", re.ASCII)",
          "75: DIGITS: Final[Pattern[str]] = re.compile(r\"\\d+\", re.ASCII)",
          "76: HEXDIGITS: Final[Pattern[bytes]] = re.compile(rb\"[0-9a-fA-F]+\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "136:         self, lines: List[bytes]",
          "137:     ) -> Tuple[\"CIMultiDictProxy[str]\", RawHeaders]:",
          "138:         headers: CIMultiDict[str] = CIMultiDict()",
          "139:         raw_headers = []",
          "141:         lines_idx = 1",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "138:         # note: \"raw\" does not mean inclusion of OWS before/after the field value",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "149:             except ValueError:",
          "150:                 raise InvalidHeader(line) from None",
          "152:             # https://www.rfc-editor.org/rfc/rfc9112.html#section-5.1-2",
          "153:             if {bname[0], bname[-1]} & {32, 9}:  # {\" \", \"\\t\"}",
          "154:                 raise InvalidHeader(line)",
          "156:             bvalue = bvalue.lstrip(b\" \\t\")",
          "159:             if len(bname) > self.max_field_size:",
          "160:                 raise LineTooLong(",
          "161:                     \"request header name {}\".format(",
          "",
          "[Removed Lines]",
          "157:             if HDRRE.search(bname):",
          "158:                 raise InvalidHeader(bname)",
          "",
          "[Added Lines]",
          "152:             if len(bname) == 0:",
          "153:                 raise InvalidHeader(bname)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "164:                     str(self.max_field_size),",
          "165:                     str(len(bname)),",
          "166:                 )",
          "168:             header_length = len(bvalue)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "168:             name = bname.decode(\"utf-8\", \"surrogateescape\")",
          "169:             if not TOKENRE.fullmatch(name):",
          "170:                 raise InvalidHeader(bname)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "210:                     )",
          "212:             bvalue = bvalue.strip(b\" \\t\")",
          "214:             value = bvalue.decode(\"utf-8\", \"surrogateescape\")",
          "216:             # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-5",
          "",
          "[Removed Lines]",
          "213:             name = bname.decode(\"utf-8\", \"surrogateescape\")",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "339:                             # Shouldn't allow +/- or other number formats.",
          "340:                             # https://www.rfc-editor.org/rfc/rfc9110#section-8.6-2",
          "342:                                 raise InvalidHeader(CONTENT_LENGTH)",
          "344:                             return int(length_hdr)",
          "",
          "[Removed Lines]",
          "341:                             if not length_hdr.strip(\" \\t\").isdecimal():",
          "",
          "[Added Lines]",
          "344:                             # msg.headers is already stripped of leading/trailing wsp",
          "345:                             if not DIGITS.fullmatch(length_hdr):",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "566:             )",
          "568:         # method",
          "570:             raise BadStatusLine(method)",
          "572:         # version",
          "",
          "[Removed Lines]",
          "569:         if not METHRE.fullmatch(method):",
          "",
          "[Added Lines]",
          "573:         if not TOKENRE.fullmatch(method):",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "683:             raise BadStatusLine(line)",
          "684:         version_o = HttpVersion(int(match.group(1)), int(match.group(2)))",
          "688:             raise BadStatusLine(line)",
          "689:         status_i = int(status)",
          "",
          "[Removed Lines]",
          "686:         # The status code is a three-digit number",
          "687:         if len(status) != 3 or not status.isdecimal():",
          "",
          "[Added Lines]",
          "690:         # The status code is a three-digit ASCII number, no padding",
          "691:         if len(status) != 3 or not DIGITS.fullmatch(status):",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "826:                         if self._lax:  # Allow whitespace in lax mode.",
          "827:                             size_b = size_b.strip()",
          "830:                             exc = TransferEncodingError(",
          "831:                                 chunk[:pos].decode(\"ascii\", \"surrogateescape\")",
          "832:                             )",
          "",
          "[Removed Lines]",
          "829:                         if not re.fullmatch(HEXDIGIT, size_b):",
          "",
          "[Added Lines]",
          "833:                         if not re.fullmatch(HEXDIGITS, size_b):",
          "",
          "---------------"
        ],
        "tests/test_http_parser.py||tests/test_http_parser.py": [
          "File: tests/test_http_parser.py -> tests/test_http_parser.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import asyncio",
          "4: import re",
          "6: from unittest import mock",
          "7: from urllib.parse import quote",
          "",
          "[Removed Lines]",
          "5: from typing import Any, List",
          "",
          "[Added Lines]",
          "5: from contextlib import nullcontext",
          "6: from typing import Any, Dict, List",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "169:         parser.feed_data(text)",
          "172: @pytest.mark.parametrize(",
          "173:     \"hdr\",",
          "174:     (",
          "175:         \"Content-Length: -5\",  # https://www.rfc-editor.org/rfc/rfc9110.html#name-content-length",
          "176:         \"Content-Length: +256\",",
          "177:         \"Foo: abc\\rdef\",  # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-5",
          "178:         \"Bar: abc\\ndef\",",
          "179:         \"Baz: abc\\x00def\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "173: @pytest.mark.parametrize(",
          "174:     \"rfc9110_5_6_2_token_delim\",",
          "175:     r'\"(),/:;<=>?@[\\]{}',",
          "176: )",
          "177: def test_bad_header_name(parser: Any, rfc9110_5_6_2_token_delim: str) -> None:",
          "178:     text = f\"POST / HTTP/1.1\\r\\nhead{rfc9110_5_6_2_token_delim}er: val\\r\\n\\r\\n\".encode()",
          "179:     expectation = pytest.raises(http_exceptions.BadHttpMessage)",
          "180:     if rfc9110_5_6_2_token_delim == \":\":",
          "181:         # Inserting colon into header just splits name/value earlier.",
          "182:         expectation = nullcontext()",
          "183:     with expectation:",
          "184:         parser.feed_data(text)",
          "192:         \"Content-Length: \\N{superscript one}\",",
          "193:         \"Content-Length: \\N{mathematical double-struck digit one}\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "266:         parser.feed_data(text)",
          "269: def test_parse(parser) -> None:",
          "270:     text = b\"GET /test HTTP/1.1\\r\\n\\r\\n\"",
          "271:     messages, upgrade, tail = parser.feed_data(text)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "286: def test_parse_unusual_request_line(parser) -> None:",
          "287:     if not isinstance(response, HttpResponseParserPy):",
          "288:         pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
          "289:     text = b\"#smol //a HTTP/1.3\\r\\n\\r\\n\"",
          "290:     messages, upgrade, tail = parser.feed_data(text)",
          "291:     assert len(messages) == 1",
          "292:     msg, _ = messages[0]",
          "293:     assert msg.compression is None",
          "294:     assert not msg.upgrade",
          "295:     assert msg.method == \"#smol\"",
          "296:     assert msg.path == \"//a\"",
          "297:     assert msg.version == (1, 3)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "568:         parser.feed_data(text)",
          "571: def test_invalid_header(parser) -> None:",
          "572:     text = b\"GET /test HTTP/1.1\\r\\n\" b\"test line\\r\\n\\r\\n\"",
          "573:     with pytest.raises(http_exceptions.BadHttpMessage):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "602: _pad: Dict[bytes, str] = {",
          "603:     b\"\": \"empty\",",
          "604:     # not a typo. Python likes triple zero",
          "605:     b\"\\000\": \"NUL\",",
          "606:     b\" \": \"SP\",",
          "607:     b\"  \": \"SPSP\",",
          "608:     # not a typo: both 0xa0 and 0x0a in case of 8-bit fun",
          "609:     b\"\\n\": \"LF\",",
          "610:     b\"\\xa0\": \"NBSP\",",
          "611:     b\"\\t \": \"TABSP\",",
          "612: }",
          "615: @pytest.mark.parametrize(\"hdr\", [b\"\", b\"foo\"], ids=[\"name-empty\", \"with-name\"])",
          "616: @pytest.mark.parametrize(\"pad2\", _pad.keys(), ids=[\"post-\" + n for n in _pad.values()])",
          "617: @pytest.mark.parametrize(\"pad1\", _pad.keys(), ids=[\"pre-\" + n for n in _pad.values()])",
          "618: def test_invalid_header_spacing(parser, pad1: bytes, pad2: bytes, hdr: bytes) -> None:",
          "619:     text = b\"GET /test HTTP/1.1\\r\\n\" b\"%s%s%s: value\\r\\n\\r\\n\" % (pad1, hdr, pad2)",
          "620:     expectation = pytest.raises(http_exceptions.BadHttpMessage)",
          "621:     if pad1 == pad2 == b\"\" and hdr != b\"\":",
          "622:         # one entry in param matrix is correct: non-empty name, not padded",
          "623:         expectation = nullcontext()",
          "624:     if pad1 == pad2 == hdr == b\"\":",
          "625:         if not isinstance(response, HttpResponseParserPy):",
          "626:             pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
          "627:     with expectation:",
          "628:         parser.feed_data(text)",
          "631: def test_empty_header_name(parser) -> None:",
          "632:     if not isinstance(response, HttpResponseParserPy):",
          "633:         pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
          "634:     text = b\"GET /test HTTP/1.1\\r\\n\" b\":test\\r\\n\\r\\n\"",
          "635:     with pytest.raises(http_exceptions.BadHttpMessage):",
          "636:         parser.feed_data(text)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "690:     assert r\"\\n\" not in exc_info.value.message",
          "693: def test_http_request_bad_status_line_whitespace(parser: Any) -> None:",
          "694:     text = b\"GET\\n/path\\fHTTP/1.1\\r\\n\\r\\n\"",
          "695:     with pytest.raises(http_exceptions.BadStatusLine):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "761: _num: Dict[bytes, str] = {",
          "762:     # dangerous: accepted by Python int()",
          "763:     # unicodedata.category(\"\\U0001D7D9\") == 'Nd'",
          "764:     \"\\N{mathematical double-struck digit one}\".encode(): \"utf8digit\",",
          "765:     # only added for interop tests, refused by Python int()",
          "766:     # unicodedata.category(\"\\U000000B9\") == 'No'",
          "767:     \"\\N{superscript one}\".encode(): \"utf8number\",",
          "768:     \"\\N{superscript one}\".encode(\"latin-1\"): \"latin1number\",",
          "769: }",
          "772: @pytest.mark.parametrize(\"nonascii_digit\", _num.keys(), ids=_num.values())",
          "773: def test_http_request_bad_status_line_number(",
          "774:     parser: Any, nonascii_digit: bytes",
          "775: ) -> None:",
          "776:     text = b\"GET /digit HTTP/1.\" + nonascii_digit + b\"\\r\\n\\r\\n\"",
          "777:     with pytest.raises(http_exceptions.BadStatusLine):",
          "778:         parser.feed_data(text)",
          "781: def test_http_request_bad_status_line_separator(parser: Any) -> None:",
          "782:     # single code point, old, multibyte NFKC, multibyte NFKD",
          "783:     utf8sep = \"\\N{arabic ligature sallallahou alayhe wasallam}\".encode()",
          "784:     text = b\"GET /ligature HTTP/1\" + utf8sep + b\"1\\r\\n\\r\\n\"",
          "785:     with pytest.raises(http_exceptions.BadStatusLine):",
          "786:         parser.feed_data(text)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "711:     assert tail == b\"some raw data\"",
          "714: def test_http_request_parser_utf8(parser) -> None:",
          "715:     text = \"GET /path HTTP/1.1\\r\\nx-test:\u0442\u0435\u0441\u0442\\r\\n\\r\\n\".encode()",
          "716:     messages, upgrade, tail = parser.feed_data(text)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "810: def test_http_request_parser_utf8_request_line(parser) -> None:",
          "811:     if not isinstance(response, HttpResponseParserPy):",
          "812:         pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
          "813:     messages, upgrade, tail = parser.feed_data(",
          "814:         # note the truncated unicode sequence",
          "815:         b\"GET /P\\xc3\\xbcnktchen\\xa0\\xef\\xb7 HTTP/1.1\\r\\n\" +",
          "816:         # for easier grep: ASCII 0xA0 more commonly known as non-breaking space",
          "817:         # note the leading and trailing spaces",
          "818:         \"sTeP:  \\N{latin small letter sharp s}nek\\t\\N{no-break space}  \"",
          "819:         \"\\r\\n\\r\\n\".encode()",
          "820:     )",
          "821:     msg = messages[0][0]",
          "823:     assert msg.method == \"GET\"",
          "824:     assert msg.path == \"/P\u00fcnktchen\\udca0\\udcef\\udcb7\"",
          "825:     assert msg.version == (1, 1)",
          "826:     assert msg.headers == CIMultiDict([(\"STEP\", \"\u00dfnek\\t\\xa0\")])",
          "827:     assert msg.raw_headers == ((b\"sTeP\", \"\u00dfnek\\t\\xa0\".encode()),)",
          "828:     assert not msg.should_close",
          "829:     assert msg.compression is None",
          "830:     assert not msg.upgrade",
          "831:     assert not msg.chunked",
          "832:     assert msg.url.path == URL(\"/P%C3%BCnktchen\\udca0\\udcef\\udcb7\").path",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "760:     assert not msg.chunked",
          "764:     with pytest.raises(http_exceptions.BadStatusLine):",
          "768: def test_http_request_parser_bad_version(parser) -> None:",
          "",
          "[Removed Lines]",
          "763: def test_http_request_parser_bad_method(parser) -> None:",
          "765:         parser.feed_data(b'G=\":<>(e),[T];?\" /get HTTP/1.1\\r\\n\\r\\n')",
          "",
          "[Added Lines]",
          "884: @pytest.mark.parametrize(",
          "885:     \"rfc9110_5_6_2_token_delim\",",
          "886:     [bytes([i]) for i in rb'\"(),/:;<=>?@[\\]{}'],",
          "887: )",
          "888: def test_http_request_parser_bad_method(",
          "889:     parser, rfc9110_5_6_2_token_delim: bytes",
          "890: ) -> None:",
          "892:         parser.feed_data(rfc9110_5_6_2_token_delim + b'ET\" /get HTTP/1.1\\r\\n\\r\\n')",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "974:         response.feed_data(b\"HTTP/1.1 ttt test\\r\\n\\r\\n\")",
          "977: def test_http_request_chunked_payload(parser) -> None:",
          "978:     text = b\"GET /test HTTP/1.1\\r\\n\" b\"transfer-encoding: chunked\\r\\n\\r\\n\"",
          "979:     msg, payload = parser.feed_data(text)[0][0]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1104: @pytest.mark.parametrize(\"nonascii_digit\", _num.keys(), ids=_num.values())",
          "1105: def test_http_response_parser_code_not_ascii(response, nonascii_digit: bytes) -> None:",
          "1106:     with pytest.raises(http_exceptions.BadStatusLine):",
          "1107:         response.feed_data(b\"HTTP/1.1 20\" + nonascii_digit + b\" test\\r\\n\\r\\n\")",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d33bc21414e283c9e6fe7f6caf69e2ed60d66c82",
      "candidate_info": {
        "commit_hash": "d33bc21414e283c9e6fe7f6caf69e2ed60d66c82",
        "repo": "aio-libs/aiohttp",
        "commit_url": "https://github.com/aio-libs/aiohttp/commit/d33bc21414e283c9e6fe7f6caf69e2ed60d66c82",
        "files": [
          "CHANGES/8074.bugfix.rst",
          "CONTRIBUTORS.txt",
          "aiohttp/http_parser.py",
          "tests/test_http_parser.py"
        ],
        "message": "Improve validation in HTTP parser (#8074) (#8078)\n\nCo-authored-by: Paul J. Dorn <pajod@users.noreply.github.com>\nCo-authored-by: Sviatoslav Sydorenko (\u0421\u0432\u044f\u0442\u043e\u0441\u043b\u0430\u0432 \u0421\u0438\u0434\u043e\u0440\u0435\u043d\u043a\u043e)\n<sviat@redhat.com>\n(cherry picked from commit 33ccdfb0a12690af5bb49bda2319ec0907fa7827)",
        "before_after_code_files": [
          "aiohttp/http_parser.py||aiohttp/http_parser.py",
          "tests/test_http_parser.py||tests/test_http_parser.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "aiohttp/http_parser.py||aiohttp/http_parser.py",
            "tests/test_http_parser.py||tests/test_http_parser.py"
          ],
          "candidate": [
            "aiohttp/http_parser.py||aiohttp/http_parser.py",
            "tests/test_http_parser.py||tests/test_http_parser.py"
          ]
        }
      },
      "candidate_diff": {
        "aiohttp/http_parser.py||aiohttp/http_parser.py": [
          "File: aiohttp/http_parser.py -> aiohttp/http_parser.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "69: #     tchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" /",
          "70: #             \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA",
          "71: #     token = 1*tchar",
          "80: class RawRequestMessage(NamedTuple):",
          "",
          "[Removed Lines]",
          "72: METHRE: Final[Pattern[str]] = re.compile(r\"[!#$%&'*+\\-.^_`|~0-9A-Za-z]+\")",
          "73: VERSRE: Final[Pattern[str]] = re.compile(r\"HTTP/(\\d).(\\d)\")",
          "74: HDRRE: Final[Pattern[bytes]] = re.compile(",
          "75:     rb\"[\\x00-\\x1F\\x7F-\\xFF()<>@,;:\\[\\]={} \\t\\\"\\\\]\"",
          "76: )",
          "77: HEXDIGIT = re.compile(rb\"[0-9a-fA-F]+\")",
          "",
          "[Added Lines]",
          "72: _TCHAR_SPECIALS: Final[str] = re.escape(\"!#$%&'*+-.^_`|~\")",
          "73: TOKENRE: Final[Pattern[str]] = re.compile(f\"[0-9A-Za-z{_TCHAR_SPECIALS}]+\")",
          "74: VERSRE: Final[Pattern[str]] = re.compile(r\"HTTP/(\\d)\\.(\\d)\", re.ASCII)",
          "75: DIGITS: Final[Pattern[str]] = re.compile(r\"\\d+\", re.ASCII)",
          "76: HEXDIGITS: Final[Pattern[bytes]] = re.compile(rb\"[0-9a-fA-F]+\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "136:         self, lines: List[bytes]",
          "137:     ) -> Tuple[\"CIMultiDictProxy[str]\", RawHeaders]:",
          "138:         headers: CIMultiDict[str] = CIMultiDict()",
          "139:         raw_headers = []",
          "141:         lines_idx = 1",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "138:         # note: \"raw\" does not mean inclusion of OWS before/after the field value",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "149:             except ValueError:",
          "150:                 raise InvalidHeader(line) from None",
          "152:             # https://www.rfc-editor.org/rfc/rfc9112.html#section-5.1-2",
          "153:             if {bname[0], bname[-1]} & {32, 9}:  # {\" \", \"\\t\"}",
          "154:                 raise InvalidHeader(line)",
          "156:             bvalue = bvalue.lstrip(b\" \\t\")",
          "159:             if len(bname) > self.max_field_size:",
          "160:                 raise LineTooLong(",
          "161:                     \"request header name {}\".format(",
          "",
          "[Removed Lines]",
          "157:             if HDRRE.search(bname):",
          "158:                 raise InvalidHeader(bname)",
          "",
          "[Added Lines]",
          "152:             if len(bname) == 0:",
          "153:                 raise InvalidHeader(bname)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "164:                     str(self.max_field_size),",
          "165:                     str(len(bname)),",
          "166:                 )",
          "168:             header_length = len(bvalue)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "168:             name = bname.decode(\"utf-8\", \"surrogateescape\")",
          "169:             if not TOKENRE.fullmatch(name):",
          "170:                 raise InvalidHeader(bname)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "210:                     )",
          "212:             bvalue = bvalue.strip(b\" \\t\")",
          "214:             value = bvalue.decode(\"utf-8\", \"surrogateescape\")",
          "216:             # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-5",
          "",
          "[Removed Lines]",
          "213:             name = bname.decode(\"utf-8\", \"surrogateescape\")",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "339:                             # Shouldn't allow +/- or other number formats.",
          "340:                             # https://www.rfc-editor.org/rfc/rfc9110#section-8.6-2",
          "342:                                 raise InvalidHeader(CONTENT_LENGTH)",
          "344:                             return int(length_hdr)",
          "",
          "[Removed Lines]",
          "341:                             if not length_hdr.strip(\" \\t\").isdecimal():",
          "",
          "[Added Lines]",
          "344:                             # msg.headers is already stripped of leading/trailing wsp",
          "345:                             if not DIGITS.fullmatch(length_hdr):",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "566:             )",
          "568:         # method",
          "570:             raise BadStatusLine(method)",
          "572:         # version",
          "",
          "[Removed Lines]",
          "569:         if not METHRE.fullmatch(method):",
          "",
          "[Added Lines]",
          "573:         if not TOKENRE.fullmatch(method):",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "683:             raise BadStatusLine(line)",
          "684:         version_o = HttpVersion(int(match.group(1)), int(match.group(2)))",
          "688:             raise BadStatusLine(line)",
          "689:         status_i = int(status)",
          "",
          "[Removed Lines]",
          "686:         # The status code is a three-digit number",
          "687:         if len(status) != 3 or not status.isdecimal():",
          "",
          "[Added Lines]",
          "690:         # The status code is a three-digit ASCII number, no padding",
          "691:         if len(status) != 3 or not DIGITS.fullmatch(status):",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "826:                         if self._lax:  # Allow whitespace in lax mode.",
          "827:                             size_b = size_b.strip()",
          "830:                             exc = TransferEncodingError(",
          "831:                                 chunk[:pos].decode(\"ascii\", \"surrogateescape\")",
          "832:                             )",
          "",
          "[Removed Lines]",
          "829:                         if not re.fullmatch(HEXDIGIT, size_b):",
          "",
          "[Added Lines]",
          "833:                         if not re.fullmatch(HEXDIGITS, size_b):",
          "",
          "---------------"
        ],
        "tests/test_http_parser.py||tests/test_http_parser.py": [
          "File: tests/test_http_parser.py -> tests/test_http_parser.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import asyncio",
          "4: import re",
          "6: from unittest import mock",
          "7: from urllib.parse import quote",
          "",
          "[Removed Lines]",
          "5: from typing import Any, List",
          "",
          "[Added Lines]",
          "5: from contextlib import nullcontext",
          "6: from typing import Any, Dict, List",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "169:         parser.feed_data(text)",
          "172: @pytest.mark.parametrize(",
          "173:     \"hdr\",",
          "174:     (",
          "175:         \"Content-Length: -5\",  # https://www.rfc-editor.org/rfc/rfc9110.html#name-content-length",
          "176:         \"Content-Length: +256\",",
          "177:         \"Foo: abc\\rdef\",  # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-5",
          "178:         \"Bar: abc\\ndef\",",
          "179:         \"Baz: abc\\x00def\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "173: @pytest.mark.parametrize(",
          "174:     \"rfc9110_5_6_2_token_delim\",",
          "175:     r'\"(),/:;<=>?@[\\]{}',",
          "176: )",
          "177: def test_bad_header_name(parser: Any, rfc9110_5_6_2_token_delim: str) -> None:",
          "178:     text = f\"POST / HTTP/1.1\\r\\nhead{rfc9110_5_6_2_token_delim}er: val\\r\\n\\r\\n\".encode()",
          "179:     expectation = pytest.raises(http_exceptions.BadHttpMessage)",
          "180:     if rfc9110_5_6_2_token_delim == \":\":",
          "181:         # Inserting colon into header just splits name/value earlier.",
          "182:         expectation = nullcontext()",
          "183:     with expectation:",
          "184:         parser.feed_data(text)",
          "192:         \"Content-Length: \\N{superscript one}\",",
          "193:         \"Content-Length: \\N{mathematical double-struck digit one}\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "266:         parser.feed_data(text)",
          "269: def test_parse(parser) -> None:",
          "270:     text = b\"GET /test HTTP/1.1\\r\\n\\r\\n\"",
          "271:     messages, upgrade, tail = parser.feed_data(text)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "286: def test_parse_unusual_request_line(parser) -> None:",
          "287:     if not isinstance(response, HttpResponseParserPy):",
          "288:         pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
          "289:     text = b\"#smol //a HTTP/1.3\\r\\n\\r\\n\"",
          "290:     messages, upgrade, tail = parser.feed_data(text)",
          "291:     assert len(messages) == 1",
          "292:     msg, _ = messages[0]",
          "293:     assert msg.compression is None",
          "294:     assert not msg.upgrade",
          "295:     assert msg.method == \"#smol\"",
          "296:     assert msg.path == \"//a\"",
          "297:     assert msg.version == (1, 3)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "568:         parser.feed_data(text)",
          "571: def test_invalid_header(parser) -> None:",
          "572:     text = b\"GET /test HTTP/1.1\\r\\n\" b\"test line\\r\\n\\r\\n\"",
          "573:     with pytest.raises(http_exceptions.BadHttpMessage):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "602: _pad: Dict[bytes, str] = {",
          "603:     b\"\": \"empty\",",
          "604:     # not a typo. Python likes triple zero",
          "605:     b\"\\000\": \"NUL\",",
          "606:     b\" \": \"SP\",",
          "607:     b\"  \": \"SPSP\",",
          "608:     # not a typo: both 0xa0 and 0x0a in case of 8-bit fun",
          "609:     b\"\\n\": \"LF\",",
          "610:     b\"\\xa0\": \"NBSP\",",
          "611:     b\"\\t \": \"TABSP\",",
          "612: }",
          "615: @pytest.mark.parametrize(\"hdr\", [b\"\", b\"foo\"], ids=[\"name-empty\", \"with-name\"])",
          "616: @pytest.mark.parametrize(\"pad2\", _pad.keys(), ids=[\"post-\" + n for n in _pad.values()])",
          "617: @pytest.mark.parametrize(\"pad1\", _pad.keys(), ids=[\"pre-\" + n for n in _pad.values()])",
          "618: def test_invalid_header_spacing(parser, pad1: bytes, pad2: bytes, hdr: bytes) -> None:",
          "619:     text = b\"GET /test HTTP/1.1\\r\\n\" b\"%s%s%s: value\\r\\n\\r\\n\" % (pad1, hdr, pad2)",
          "620:     expectation = pytest.raises(http_exceptions.BadHttpMessage)",
          "621:     if pad1 == pad2 == b\"\" and hdr != b\"\":",
          "622:         # one entry in param matrix is correct: non-empty name, not padded",
          "623:         expectation = nullcontext()",
          "624:     if pad1 == pad2 == hdr == b\"\":",
          "625:         if not isinstance(response, HttpResponseParserPy):",
          "626:             pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
          "627:     with expectation:",
          "628:         parser.feed_data(text)",
          "631: def test_empty_header_name(parser) -> None:",
          "632:     if not isinstance(response, HttpResponseParserPy):",
          "633:         pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
          "634:     text = b\"GET /test HTTP/1.1\\r\\n\" b\":test\\r\\n\\r\\n\"",
          "635:     with pytest.raises(http_exceptions.BadHttpMessage):",
          "636:         parser.feed_data(text)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "690:     assert r\"\\n\" not in exc_info.value.message",
          "693: def test_http_request_bad_status_line_whitespace(parser: Any) -> None:",
          "694:     text = b\"GET\\n/path\\fHTTP/1.1\\r\\n\\r\\n\"",
          "695:     with pytest.raises(http_exceptions.BadStatusLine):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "761: _num: Dict[bytes, str] = {",
          "762:     # dangerous: accepted by Python int()",
          "763:     # unicodedata.category(\"\\U0001D7D9\") == 'Nd'",
          "764:     \"\\N{mathematical double-struck digit one}\".encode(): \"utf8digit\",",
          "765:     # only added for interop tests, refused by Python int()",
          "766:     # unicodedata.category(\"\\U000000B9\") == 'No'",
          "767:     \"\\N{superscript one}\".encode(): \"utf8number\",",
          "768:     \"\\N{superscript one}\".encode(\"latin-1\"): \"latin1number\",",
          "769: }",
          "772: @pytest.mark.parametrize(\"nonascii_digit\", _num.keys(), ids=_num.values())",
          "773: def test_http_request_bad_status_line_number(",
          "774:     parser: Any, nonascii_digit: bytes",
          "775: ) -> None:",
          "776:     text = b\"GET /digit HTTP/1.\" + nonascii_digit + b\"\\r\\n\\r\\n\"",
          "777:     with pytest.raises(http_exceptions.BadStatusLine):",
          "778:         parser.feed_data(text)",
          "781: def test_http_request_bad_status_line_separator(parser: Any) -> None:",
          "782:     # single code point, old, multibyte NFKC, multibyte NFKD",
          "783:     utf8sep = \"\\N{arabic ligature sallallahou alayhe wasallam}\".encode()",
          "784:     text = b\"GET /ligature HTTP/1\" + utf8sep + b\"1\\r\\n\\r\\n\"",
          "785:     with pytest.raises(http_exceptions.BadStatusLine):",
          "786:         parser.feed_data(text)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "711:     assert tail == b\"some raw data\"",
          "714: def test_http_request_parser_utf8(parser) -> None:",
          "715:     text = \"GET /path HTTP/1.1\\r\\nx-test:\u0442\u0435\u0441\u0442\\r\\n\\r\\n\".encode()",
          "716:     messages, upgrade, tail = parser.feed_data(text)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "810: def test_http_request_parser_utf8_request_line(parser) -> None:",
          "811:     if not isinstance(response, HttpResponseParserPy):",
          "812:         pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
          "813:     messages, upgrade, tail = parser.feed_data(",
          "814:         # note the truncated unicode sequence",
          "815:         b\"GET /P\\xc3\\xbcnktchen\\xa0\\xef\\xb7 HTTP/1.1\\r\\n\" +",
          "816:         # for easier grep: ASCII 0xA0 more commonly known as non-breaking space",
          "817:         # note the leading and trailing spaces",
          "818:         \"sTeP:  \\N{latin small letter sharp s}nek\\t\\N{no-break space}  \"",
          "819:         \"\\r\\n\\r\\n\".encode()",
          "820:     )",
          "821:     msg = messages[0][0]",
          "823:     assert msg.method == \"GET\"",
          "824:     assert msg.path == \"/P\u00fcnktchen\\udca0\\udcef\\udcb7\"",
          "825:     assert msg.version == (1, 1)",
          "826:     assert msg.headers == CIMultiDict([(\"STEP\", \"\u00dfnek\\t\\xa0\")])",
          "827:     assert msg.raw_headers == ((b\"sTeP\", \"\u00dfnek\\t\\xa0\".encode()),)",
          "828:     assert not msg.should_close",
          "829:     assert msg.compression is None",
          "830:     assert not msg.upgrade",
          "831:     assert not msg.chunked",
          "832:     assert msg.url.path == URL(\"/P%C3%BCnktchen\\udca0\\udcef\\udcb7\").path",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "760:     assert not msg.chunked",
          "764:     with pytest.raises(http_exceptions.BadStatusLine):",
          "768: def test_http_request_parser_bad_version(parser) -> None:",
          "",
          "[Removed Lines]",
          "763: def test_http_request_parser_bad_method(parser) -> None:",
          "765:         parser.feed_data(b'G=\":<>(e),[T];?\" /get HTTP/1.1\\r\\n\\r\\n')",
          "",
          "[Added Lines]",
          "884: @pytest.mark.parametrize(",
          "885:     \"rfc9110_5_6_2_token_delim\",",
          "886:     [bytes([i]) for i in rb'\"(),/:;<=>?@[\\]{}'],",
          "887: )",
          "888: def test_http_request_parser_bad_method(",
          "889:     parser, rfc9110_5_6_2_token_delim: bytes",
          "890: ) -> None:",
          "892:         parser.feed_data(rfc9110_5_6_2_token_delim + b'ET\" /get HTTP/1.1\\r\\n\\r\\n')",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "974:         response.feed_data(b\"HTTP/1.1 ttt test\\r\\n\\r\\n\")",
          "977: def test_http_request_chunked_payload(parser) -> None:",
          "978:     text = b\"GET /test HTTP/1.1\\r\\n\" b\"transfer-encoding: chunked\\r\\n\\r\\n\"",
          "979:     msg, payload = parser.feed_data(text)[0][0]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1104: @pytest.mark.parametrize(\"nonascii_digit\", _num.keys(), ids=_num.values())",
          "1105: def test_http_response_parser_code_not_ascii(response, nonascii_digit: bytes) -> None:",
          "1106:     with pytest.raises(http_exceptions.BadStatusLine):",
          "1107:         response.feed_data(b\"HTTP/1.1 20\" + nonascii_digit + b\" test\\r\\n\\r\\n\")",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "493f06797654c383242f0e8007f6e06b818a1fbc",
      "candidate_info": {
        "commit_hash": "493f06797654c383242f0e8007f6e06b818a1fbc",
        "repo": "aio-libs/aiohttp",
        "commit_url": "https://github.com/aio-libs/aiohttp/commit/493f06797654c383242f0e8007f6e06b818a1fbc",
        "files": [
          "CHANGES/7719.bugfix",
          "aiohttp/http_parser.py",
          "tests/test_http_parser.py"
        ],
        "message": "Stop accepting `\\x80-\\xff` in header names; stop accepting `\\n` as separating whitespace in status-lines (#7719)\n\n## What do these changes do?\n\nThis PR updates the python HTTP parser to stop accepting `\\x80-\\xff` in\nheader names and stop accepting `\\n` as separating whitespace in\nstatus-lines. Both of these are not allowed in the RFCs.\n\n## Are there changes in behavior for the user?\n\nOnly users of seriously misbehaving clients would notice a change in\nbehavior for this patch. If a client sends non-ascii UTF-8 within header\nnames, their messages will now 400. Note that (nearly) arbitrary values\nare still allowed within header values. Most HTTP servers (Apache,\nNginx, IIS, Node) do not accept UTF-8 within header names because of the\nrisk of control character injection.\n\n---------\n\nCo-authored-by: pre-commit-ci[bot] <66853113+pre-commit-ci[bot]@users.noreply.github.com>",
        "before_after_code_files": [
          "CHANGES/7719.bugfix||CHANGES/7719.bugfix",
          "aiohttp/http_parser.py||aiohttp/http_parser.py",
          "tests/test_http_parser.py||tests/test_http_parser.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "aiohttp/http_parser.py||aiohttp/http_parser.py",
            "tests/test_http_parser.py||tests/test_http_parser.py"
          ],
          "candidate": [
            "aiohttp/http_parser.py||aiohttp/http_parser.py",
            "tests/test_http_parser.py||tests/test_http_parser.py"
          ]
        }
      },
      "candidate_diff": {
        "CHANGES/7719.bugfix||CHANGES/7719.bugfix": [
          "File: CHANGES/7719.bugfix -> CHANGES/7719.bugfix",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: Update parser to disallow invalid characters in header field names and stop accepting LF as a request line separator.",
          "",
          "---------------"
        ],
        "aiohttp/http_parser.py||aiohttp/http_parser.py": [
          "File: aiohttp/http_parser.py -> aiohttp/http_parser.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "65: #     token = 1*tchar",
          "66: METHRE: Final[Pattern[str]] = re.compile(r\"[!#$%&'*+\\-.^_`|~0-9A-Za-z]+\")",
          "67: VERSRE: Final[Pattern[str]] = re.compile(r\"HTTP/(\\d).(\\d)\")",
          "69: HEXDIGIT = re.compile(rb\"[0-9a-fA-F]+\")",
          "",
          "[Removed Lines]",
          "68: HDRRE: Final[Pattern[bytes]] = re.compile(rb\"[\\x00-\\x1F\\x7F()<>@,;:\\[\\]={} \\t\\\"\\\\]\")",
          "",
          "[Added Lines]",
          "68: HDRRE: Final[Pattern[bytes]] = re.compile(",
          "69:     rb\"[\\x00-\\x1F\\x7F-\\xFF()<>@,;:\\[\\]={} \\t\\\"\\\\]\"",
          "70: )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "540:         # request line",
          "541:         line = lines[0].decode(\"utf-8\", \"surrogateescape\")",
          "542:         try:",
          "544:         except ValueError:",
          "545:             raise BadStatusLine(line) from None",
          "",
          "[Removed Lines]",
          "543:             method, path, version = line.split(maxsplit=2)",
          "",
          "[Added Lines]",
          "545:             method, path, version = line.split(\" \", maxsplit=2)",
          "",
          "---------------"
        ],
        "tests/test_http_parser.py||tests/test_http_parser.py": [
          "File: tests/test_http_parser.py -> tests/test_http_parser.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "177:         \"Baz: abc\\x00def\",",
          "178:         \"Foo : bar\",  # https://www.rfc-editor.org/rfc/rfc9112.html#section-5.1-2",
          "179:         \"Foo\\t: bar\",",
          "180:     ),",
          "181: )",
          "182: def test_bad_headers(parser: Any, hdr: str) -> None:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "180:         \"\\xffoo: bar\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "678:     assert r\"\\n\" not in exc_info.value.message",
          "681: def test_http_request_upgrade(parser: Any) -> None:",
          "682:     text = (",
          "683:         b\"GET /test HTTP/1.1\\r\\n\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "682: def test_http_request_bad_status_line_whitespace(parser: Any) -> None:",
          "683:     text = b\"GET\\n/path\\fHTTP/1.1\\r\\n\\r\\n\"",
          "684:     with pytest.raises(http_exceptions.BadStatusLine):",
          "685:         parser.feed_data(text)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0016004f0e5b861d35afc56a9a59040769af3122",
      "candidate_info": {
        "commit_hash": "0016004f0e5b861d35afc56a9a59040769af3122",
        "repo": "aio-libs/aiohttp",
        "commit_url": "https://github.com/aio-libs/aiohttp/commit/0016004f0e5b861d35afc56a9a59040769af3122",
        "files": [
          "CHANGES/8088.contrib.rst",
          "tests/test_http_parser.py"
        ],
        "message": "Add tests, accidentally dropped before (#8088)",
        "before_after_code_files": [
          "tests/test_http_parser.py||tests/test_http_parser.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tests/test_http_parser.py||tests/test_http_parser.py"
          ],
          "candidate": [
            "tests/test_http_parser.py||tests/test_http_parser.py"
          ]
        }
      },
      "candidate_diff": {
        "tests/test_http_parser.py||tests/test_http_parser.py": [
          "File: tests/test_http_parser.py -> tests/test_http_parser.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "282:         parser.feed_data(text)",
          "285: def test_parse_unusual_request_line(parser: Any) -> None:",
          "288:     text = b\"#smol //a HTTP/1.3\\r\\n\\r\\n\"",
          "289:     messages, upgrade, tail = parser.feed_data(text)",
          "290:     assert len(messages) == 1",
          "",
          "[Removed Lines]",
          "286:     if not isinstance(response, HttpResponseParserPy):",
          "287:         pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
          "",
          "[Added Lines]",
          "285: @pytest.fixture",
          "286: def xfail_c_parser_status(request) -> None:",
          "287:     if isinstance(request.getfixturevalue(\"parser\"), HttpRequestParserPy):",
          "288:         return",
          "289:     request.node.add_marker(",
          "290:         pytest.mark.xfail(",
          "291:             reason=\"Regression test for Py parser. May match C behaviour later.\",",
          "292:             raises=http_exceptions.BadStatusLine,",
          "293:         )",
          "294:     )",
          "297: @pytest.mark.usefixtures(\"xfail_c_parser_status\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "611: }",
          "614: @pytest.mark.parametrize(\"hdr\", [b\"\", b\"foo\"], ids=[\"name-empty\", \"with-name\"])",
          "615: @pytest.mark.parametrize(\"pad2\", _pad.keys(), ids=[\"post-\" + n for n in _pad.values()])",
          "616: @pytest.mark.parametrize(\"pad1\", _pad.keys(), ids=[\"pre-\" + n for n in _pad.values()])",
          "617: def test_invalid_header_spacing(",
          "618:     parser: Any, pad1: bytes, pad2: bytes, hdr: bytes",
          "619: ) -> None:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "625: @pytest.fixture",
          "626: def xfail_c_parser_empty_header(request) -> None:",
          "627:     if not all(",
          "628:         (request.getfixturevalue(name) == b\"\") for name in (\"pad1\", \"pad2\", \"hdr\")",
          "629:     ):",
          "630:         return",
          "631:     if isinstance(request.getfixturevalue(\"parser\"), HttpRequestParserPy):",
          "632:         return",
          "633:     request.node.add_marker(",
          "634:         pytest.mark.xfail(",
          "635:             reason=\"Regression test for Py parser. May match C behaviour later.\",",
          "636:         )",
          "637:     )",
          "643: @pytest.mark.usefixtures(\"xfail_c_parser_empty_header\")",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "622:     if pad1 == pad2 == b\"\" and hdr != b\"\":",
          "623:         # one entry in param matrix is correct: non-empty name, not padded",
          "624:         expectation = nullcontext()",
          "628:     with expectation:",
          "629:         parser.feed_data(text)",
          "632: def test_empty_header_name(parser: Any) -> None:",
          "634:         pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
          "635:     text = b\"GET /test HTTP/1.1\\r\\n\" b\":test\\r\\n\\r\\n\"",
          "636:     with pytest.raises(http_exceptions.BadHttpMessage):",
          "",
          "[Removed Lines]",
          "625:     if pad1 == pad2 == hdr == b\"\":",
          "626:         if not isinstance(response, HttpResponseParserPy):",
          "627:             pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
          "633:     if not isinstance(response, HttpResponseParserPy):",
          "",
          "[Added Lines]",
          "657:     if not isinstance(parser, HttpRequestParserPy):",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "808:     assert tail == b\"some raw data\"",
          "811: def test_http_request_parser_utf8_request_line(parser: Any) -> None:",
          "814:     messages, upgrade, tail = parser.feed_data(",
          "815:         # note the truncated unicode sequence",
          "816:         b\"GET /P\\xc3\\xbcnktchen\\xa0\\xef\\xb7 HTTP/1.1\\r\\n\" +",
          "",
          "[Removed Lines]",
          "812:     if not isinstance(response, HttpResponseParserPy):",
          "813:         pytest.xfail(\"Regression test for Py parser. May match C behaviour later.\")",
          "",
          "[Added Lines]",
          "835: @pytest.fixture",
          "836: def xfail_c_parser_url(request) -> None:",
          "837:     if isinstance(request.getfixturevalue(\"parser\"), HttpRequestParserPy):",
          "838:         return",
          "839:     request.node.add_marker(",
          "840:         pytest.mark.xfail(",
          "841:             reason=\"Regression test for Py parser. May match C behaviour later.\",",
          "842:             raises=http_exceptions.InvalidURLError,",
          "843:         )",
          "844:     )",
          "847: @pytest.mark.usefixtures(\"xfail_c_parser_url\")",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "830:     assert msg.compression is None",
          "831:     assert not msg.upgrade",
          "832:     assert not msg.chunked",
          "836: def test_http_request_parser_utf8(parser: Any) -> None:",
          "",
          "[Removed Lines]",
          "833:     assert msg.url.path == URL(\"/P%C3%BCnktchen\\udca0\\udcef\\udcb7\").path",
          "",
          "[Added Lines]",
          "868:     # python HTTP parser depends on Cython and CPython URL to match",
          "869:     # .. but yarl.URL(\"/abs\") is not equal to URL.build(path=\"/abs\"), see #6409",
          "870:     assert msg.url == URL.build(path=\"/P\u00fcnktchen\\udca0\\udcef\\udcb7\", encoded=True)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bd5f92437173aae77cb128a1ebb8bf58effd13b5",
      "candidate_info": {
        "commit_hash": "bd5f92437173aae77cb128a1ebb8bf58effd13b5",
        "repo": "aio-libs/aiohttp",
        "commit_url": "https://github.com/aio-libs/aiohttp/commit/bd5f92437173aae77cb128a1ebb8bf58effd13b5",
        "files": [
          "CHANGES/7663.feature",
          "Makefile",
          "aiohttp/http_parser.py",
          "tests/test_http_parser.py"
        ],
        "message": "Allow lax response parsing on Py parser (#7663)",
        "before_after_code_files": [
          "CHANGES/7663.feature||CHANGES/7663.feature",
          "aiohttp/http_parser.py||aiohttp/http_parser.py",
          "tests/test_http_parser.py||tests/test_http_parser.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "aiohttp/http_parser.py||aiohttp/http_parser.py",
            "tests/test_http_parser.py||tests/test_http_parser.py"
          ],
          "candidate": [
            "aiohttp/http_parser.py||aiohttp/http_parser.py",
            "tests/test_http_parser.py||tests/test_http_parser.py"
          ]
        }
      },
      "candidate_diff": {
        "CHANGES/7663.feature||CHANGES/7663.feature": [
          "File: CHANGES/7663.feature -> CHANGES/7663.feature",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: Updated Python parser to comply with latest HTTP specs and allow lax response parsing -- by :user:`Dreamorcerer`",
          "",
          "---------------"
        ],
        "aiohttp/http_parser.py||aiohttp/http_parser.py": [
          "File: aiohttp/http_parser.py -> aiohttp/http_parser.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: from contextlib import suppress",
          "6: from enum import IntEnum",
          "7: from typing import (",
          "8:     Final,",
          "9:     Generic,",
          "10:     List,",
          "11:     NamedTuple,",
          "12:     Optional,",
          "13:     Pattern,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8:     Any,",
          "9:     ClassVar,",
          "13:     Literal,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "24: from . import hdrs",
          "25: from .base_protocol import BaseProtocol",
          "26: from .compression_utils import HAS_BROTLI, BrotliDecompressor, ZLibDecompressor",
          "28: from .http_exceptions import (",
          "29:     BadHttpMessage,",
          "30:     BadStatusLine,",
          "",
          "[Removed Lines]",
          "27: from .helpers import NO_EXTENSIONS, BaseTimerContext",
          "",
          "[Added Lines]",
          "30: from .helpers import DEBUG, NO_EXTENSIONS, BaseTimerContext",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "48:     \"RawResponseMessage\",",
          "49: )",
          "51: ASCIISET: Final[Set[str]] = set(string.printable)",
          "53: # See https://www.rfc-editor.org/rfc/rfc9110.html#name-overview",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54: _SEP = Literal[b\"\\r\\n\", b\"\\n\"]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "60: METHRE: Final[Pattern[str]] = re.compile(r\"[!#$%&'*+\\-.^_`|~0-9A-Za-z]+\")",
          "61: VERSRE: Final[Pattern[str]] = re.compile(r\"HTTP/(\\d).(\\d)\")",
          "62: HDRRE: Final[Pattern[bytes]] = re.compile(rb\"[\\x00-\\x1F\\x7F()<>@,;:\\[\\]={} \\t\\\"\\\\]\")",
          "65: class RawRequestMessage(NamedTuple):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68: HEXDIGIT = re.compile(rb\"[0-9a-fA-F]+\")",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "208: class HttpParser(abc.ABC, Generic[_MsgT]):",
          "209:     def __init__(",
          "210:         self,",
          "211:         protocol: BaseProtocol,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "215:     lax: ClassVar[bool] = False",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "266:     def feed_data(",
          "267:         self,",
          "268:         data: bytes,",
          "270:         EMPTY: bytes = b\"\",",
          "271:         CONTENT_LENGTH: istr = hdrs.CONTENT_LENGTH,",
          "272:         METH_CONNECT: str = hdrs.METH_CONNECT,",
          "",
          "[Removed Lines]",
          "269:         SEP: bytes = b\"\\r\\n\",",
          "",
          "[Added Lines]",
          "277:         SEP: _SEP = b\"\\r\\n\",",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "288:                 pos = data.find(SEP, start_pos)",
          "289:                 # consume \\r\\n",
          "290:                 if pos == start_pos and not self._lines:",
          "292:                     continue",
          "294:                 if pos >= start_pos:",
          "295:                     # line found",
          "299:                     # \\r\\n\\r\\n found",
          "300:                     if self._lines[-1] == EMPTY:",
          "",
          "[Removed Lines]",
          "291:                     start_pos = pos + 2",
          "296:                     self._lines.append(data[start_pos:pos])",
          "297:                     start_pos = pos + 2",
          "",
          "[Added Lines]",
          "299:                     start_pos = pos + len(SEP)",
          "304:                     line = data[start_pos:pos]",
          "305:                     if SEP == b\"\\n\":  # For lax response parsing",
          "306:                         line = line.rstrip(b\"\\r\")",
          "307:                     self._lines.append(line)",
          "308:                     start_pos = pos + len(SEP)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "312:                             # Shouldn't allow +/- or other number formats.",
          "313:                             # https://www.rfc-editor.org/rfc/rfc9110#section-8.6-2",
          "315:                                 raise InvalidHeader(CONTENT_LENGTH)",
          "317:                             return int(length_hdr)",
          "",
          "[Removed Lines]",
          "314:                             if not length_hdr.strip(\" \\t\").isdigit():",
          "",
          "[Added Lines]",
          "325:                             if not length_hdr.strip(\" \\t\").isdecimal():",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "348:                                 readall=self.readall,",
          "349:                                 response_with_body=self.response_with_body,",
          "350:                                 auto_decompress=self._auto_decompress,",
          "351:                             )",
          "352:                             if not payload_parser.done:",
          "353:                                 self._payload_parser = payload_parser",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "362:                                 lax=self.lax,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "366:                                 compression=msg.compression,",
          "367:                                 readall=True,",
          "368:                                 auto_decompress=self._auto_decompress,",
          "369:                             )",
          "370:                         else:",
          "371:                             if (",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "381:                                 lax=self.lax,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "389:                                     readall=True,",
          "390:                                     response_with_body=self.response_with_body,",
          "391:                                     auto_decompress=self._auto_decompress,",
          "392:                                 )",
          "393:                                 if not payload_parser.done:",
          "394:                                     self._payload_parser = payload_parser",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "405:                                     lax=self.lax,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "411:                 assert not self._lines",
          "412:                 assert self._payload_parser is not None",
          "413:                 try:",
          "415:                 except BaseException as exc:",
          "416:                     if self.payload_exception is not None:",
          "417:                         self._payload_parser.payload.set_exception(",
          "",
          "[Removed Lines]",
          "414:                     eof, data = self._payload_parser.feed_data(data[start_pos:])",
          "",
          "[Added Lines]",
          "428:                     eof, data = self._payload_parser.feed_data(data[start_pos:], SEP)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "457:         # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-6",
          "458:         # https://www.rfc-editor.org/rfc/rfc9110.html#name-collected-abnf",
          "462:         bad_hdr = next((h for h in singletons if len(headers.getall(h, ())) > 1), None)",
          "463:         if bad_hdr is not None:",
          "466:         # keep-alive",
          "467:         conn = headers.get(hdrs.CONNECTION)",
          "",
          "[Removed Lines]",
          "459:         singletons = (hdrs.CONTENT_LENGTH, hdrs.CONTENT_LOCATION, hdrs.CONTENT_RANGE,",
          "460:                       hdrs.CONTENT_TYPE, hdrs.ETAG, hdrs.HOST, hdrs.MAX_FORWARDS,",
          "461:                       hdrs.SERVER, hdrs.TRANSFER_ENCODING, hdrs.USER_AGENT)",
          "464:             raise BadHttpMessage(\"Duplicate '{}' header found.\".format(bad_hdr))",
          "",
          "[Added Lines]",
          "473:         singletons = (",
          "474:             hdrs.CONTENT_LENGTH,",
          "475:             hdrs.CONTENT_LOCATION,",
          "476:             hdrs.CONTENT_RANGE,",
          "477:             hdrs.CONTENT_TYPE,",
          "478:             hdrs.ETAG,",
          "479:             hdrs.HOST,",
          "480:             hdrs.MAX_FORWARDS,",
          "481:             hdrs.SERVER,",
          "482:             hdrs.TRANSFER_ENCODING,",
          "483:             hdrs.USER_AGENT,",
          "484:         )",
          "487:             raise BadHttpMessage(f\"Duplicate '{bad_hdr}' header found.\")",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "597:     Returns RawResponseMessage.",
          "598:     \"\"\"",
          "600:     def parse_message(self, lines: List[bytes]) -> RawResponseMessage:",
          "601:         line = lines[0].decode(\"utf-8\", \"surrogateescape\")",
          "602:         try:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "623:     # Lax mode should only be enabled on response parser.",
          "624:     lax = not DEBUG",
          "626:     def feed_data(",
          "627:         self,",
          "628:         data: bytes,",
          "629:         SEP: Optional[_SEP] = None,",
          "632:     ) -> Tuple[List[Tuple[RawResponseMessage, StreamReader]], bool, bytes]:",
          "633:         if SEP is None:",
          "634:             SEP = b\"\\r\\n\" if DEBUG else b\"\\n\"",
          "635:         return super().feed_data(data, SEP, *args, **kwargs)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "621:         version_o = HttpVersion(int(match.group(1)), int(match.group(2)))",
          "623:         # The status code is a three-digit number",
          "625:             raise BadStatusLine(line)",
          "626:         status_i = int(status)",
          "",
          "[Removed Lines]",
          "624:         if len(status) != 3 or not status.isdigit():",
          "",
          "[Added Lines]",
          "661:         if len(status) != 3 or not status.isdecimal():",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "663:         readall: bool = False,",
          "664:         response_with_body: bool = True,",
          "665:         auto_decompress: bool = True,",
          "666:     ) -> None:",
          "667:         self._length = 0",
          "668:         self._type = ParseState.PARSE_NONE",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "703:         lax: bool = False,",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "670:         self._chunk_size = 0",
          "671:         self._chunk_tail = b\"\"",
          "672:         self._auto_decompress = auto_decompress",
          "673:         self.done = False",
          "675:         # payload decompression wrapper",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "711:         self._lax = lax",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "721:             )",
          "723:     def feed_data(",
          "725:     ) -> Tuple[bool, bytes]:",
          "726:         # Read specified amount of bytes",
          "727:         if self._type == ParseState.PARSE_LENGTH:",
          "",
          "[Removed Lines]",
          "724:         self, chunk: bytes, SEP: bytes = b\"\\r\\n\", CHUNK_EXT: bytes = b\";\"",
          "",
          "[Added Lines]",
          "763:         self, chunk: bytes, SEP: _SEP = b\"\\r\\n\", CHUNK_EXT: bytes = b\";\"",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "757:                         else:",
          "758:                             size_b = chunk[:pos]",
          "761:                             exc = TransferEncodingError(",
          "762:                                 chunk[:pos].decode(\"ascii\", \"surrogateescape\")",
          "763:                             )",
          "",
          "[Removed Lines]",
          "760:                         if not size_b.isdigit():",
          "",
          "[Added Lines]",
          "799:                         if self._lax:  # Allow whitespace in lax mode.",
          "800:                             size_b = size_b.strip()",
          "802:                         if not re.fullmatch(HEXDIGIT, size_b):",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "765:                             raise exc",
          "766:                         size = int(bytes(size_b), 16)",
          "769:                         if size == 0:  # eof marker",
          "770:                             self._chunk = ChunkState.PARSE_MAYBE_TRAILERS",
          "771:                         else:",
          "772:                             self._chunk = ChunkState.PARSE_CHUNKED_CHUNK",
          "773:                             self._chunk_size = size",
          "",
          "[Removed Lines]",
          "768:                         chunk = chunk[pos + 2 :]",
          "",
          "[Added Lines]",
          "810:                         chunk = chunk[pos + len(SEP) :]",
          "813:                             if self._lax and chunk.startswith(b\"\\r\"):",
          "814:                                 chunk = chunk[1:]",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "789:                         self._chunk_size = 0",
          "790:                         self.payload.feed_data(chunk[:required], required)",
          "791:                         chunk = chunk[required:]",
          "792:                         self._chunk = ChunkState.PARSE_CHUNKED_CHUNK_EOF",
          "793:                         self.payload.end_http_chunk_receiving()",
          "795:                 # toss the CRLF at the end of the chunk",
          "796:                 if self._chunk == ChunkState.PARSE_CHUNKED_CHUNK_EOF:",
          "799:                         self._chunk = ChunkState.PARSE_CHUNKED_SIZE",
          "800:                     else:",
          "801:                         self._chunk_tail = chunk",
          "",
          "[Removed Lines]",
          "797:                     if chunk[:2] == SEP:",
          "798:                         chunk = chunk[2:]",
          "",
          "[Added Lines]",
          "836:                         if self._lax and chunk.startswith(b\"\\r\"):",
          "837:                             chunk = chunk[1:]",
          "843:                     if chunk[: len(SEP)] == SEP:",
          "844:                         chunk = chunk[len(SEP) :]",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "805:                 # we should get another \\r\\n otherwise",
          "806:                 # trailers needs to be skiped until \\r\\n\\r\\n",
          "807:                 if self._chunk == ChunkState.PARSE_MAYBE_TRAILERS:",
          "809:                     if head == SEP:",
          "810:                         # end of stream",
          "811:                         self.payload.feed_eof()",
          "813:                     # Both CR and LF, or only LF may not be received yet. It is",
          "814:                     # expected that CRLF or LF will be shown at the very first",
          "815:                     # byte next time, otherwise trailers should come. The last",
          "",
          "[Removed Lines]",
          "808:                     head = chunk[:2]",
          "812:                         return True, chunk[2:]",
          "",
          "[Added Lines]",
          "854:                     head = chunk[: len(SEP)]",
          "858:                         return True, chunk[len(SEP) :]",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "827:                 if self._chunk == ChunkState.PARSE_TRAILERS:",
          "828:                     pos = chunk.find(SEP)",
          "829:                     if pos >= 0:",
          "831:                         self._chunk = ChunkState.PARSE_MAYBE_TRAILERS",
          "832:                     else:",
          "833:                         self._chunk_tail = chunk",
          "",
          "[Removed Lines]",
          "830:                         chunk = chunk[pos + 2 :]",
          "",
          "[Added Lines]",
          "876:                         chunk = chunk[pos + len(SEP) :]",
          "",
          "---------------"
        ],
        "tests/test_http_parser.py||tests/test_http_parser.py": [
          "File: tests/test_http_parser.py -> tests/test_http_parser.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "161:         parser.feed_data(text)",
          "164: def test_parse_headers_longline(parser: Any) -> None:",
          "165:     invalid_unicode_byte = b\"\\xd9\"",
          "166:     header_name = b\"Test\" + invalid_unicode_byte + b\"Header\" + b\"A\" * 8192",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "164: def test_cve_2023_37276(parser: Any) -> None:",
          "165:     text = b\"\"\"POST / HTTP/1.1\\r\\nHost: localhost:8080\\r\\nX-Abc: \\rxTransfer-Encoding: chunked\\r\\n\\r\\n\"\"\"",
          "166:     with pytest.raises(http_exceptions.BadHttpMessage):",
          "167:         parser.feed_data(text)",
          "170: @pytest.mark.parametrize(",
          "171:     \"hdr\",",
          "172:     (",
          "173:         \"Content-Length: -5\",  # https://www.rfc-editor.org/rfc/rfc9110.html#name-content-length",
          "174:         \"Content-Length: +256\",",
          "175:         \"Foo: abc\\rdef\",  # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-5",
          "176:         \"Bar: abc\\ndef\",",
          "177:         \"Baz: abc\\x00def\",",
          "178:         \"Foo : bar\",  # https://www.rfc-editor.org/rfc/rfc9112.html#section-5.1-2",
          "179:         \"Foo\\t: bar\",",
          "180:     ),",
          "181: )",
          "182: def test_bad_headers(parser: Any, hdr: str) -> None:",
          "183:     text = f\"POST / HTTP/1.1\\r\\n{hdr}\\r\\n\\r\\n\".encode()",
          "184:     with pytest.raises(http_exceptions.BadHttpMessage):",
          "185:         parser.feed_data(text)",
          "188: def test_content_length_transfer_encoding(parser: Any) -> None:",
          "189:     text = (",
          "190:         b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nContent-Length: 5\\r\\nTransfer-Encoding: a\\r\\n\\r\\n\"",
          "191:         + b\"apple\\r\\n\"",
          "192:     )",
          "193:     with pytest.raises(http_exceptions.BadHttpMessage):",
          "194:         parser.feed_data(text)",
          "197: def test_bad_chunked_py(loop: Any, protocol: Any) -> None:",
          "198:     \"\"\"Test that invalid chunked encoding doesn't allow content-length to be used.\"\"\"",
          "199:     parser = HttpRequestParserPy(",
          "200:         protocol,",
          "201:         loop,",
          "202:         2**16,",
          "203:         max_line_size=8190,",
          "204:         max_field_size=8190,",
          "205:     )",
          "206:     text = (",
          "207:         b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0_2e\\r\\n\\r\\n\"",
          "208:         + b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nContent-Length: 5\\r\\n\\r\\n0\\r\\n\\r\\n\"",
          "209:     )",
          "210:     messages, upgrade, tail = parser.feed_data(text)",
          "211:     assert isinstance(messages[0][1].exception(), http_exceptions.TransferEncodingError)",
          "214: @pytest.mark.skipif(",
          "215:     \"HttpRequestParserC\" not in dir(aiohttp.http_parser),",
          "216:     reason=\"C based HTTP parser not available\",",
          "217: )",
          "218: def test_bad_chunked_c(loop: Any, protocol: Any) -> None:",
          "219:     \"\"\"C parser behaves differently. Maybe we should align them later.\"\"\"",
          "220:     parser = HttpRequestParserC(",
          "221:         protocol,",
          "222:         loop,",
          "223:         2**16,",
          "224:         max_line_size=8190,",
          "225:         max_field_size=8190,",
          "226:     )",
          "227:     text = (",
          "228:         b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0_2e\\r\\n\\r\\n\"",
          "229:         + b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nContent-Length: 5\\r\\n\\r\\n0\\r\\n\\r\\n\"",
          "230:     )",
          "231:     with pytest.raises(http_exceptions.BadHttpMessage):",
          "232:         parser.feed_data(text)",
          "235: def test_whitespace_before_header(parser: Any) -> None:",
          "236:     text = b\"GET / HTTP/1.1\\r\\n\\tContent-Length: 1\\r\\n\\r\\nX\"",
          "237:     with pytest.raises(http_exceptions.BadHttpMessage):",
          "238:         parser.feed_data(text)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "475:         parser.feed_data(text)",
          "543: @pytest.mark.parametrize(\"size\", [40960, 8191])",
          "544: def test_max_header_field_size(parser: Any, size: Any) -> None:",
          "545:     name = b\"t\" * size",
          "",
          "[Removed Lines]",
          "478: def test_cve_2023_37276(parser: Any) -> None:",
          "479:     text = b\"\"\"POST / HTTP/1.1\\r\\nHost: localhost:8080\\r\\nX-Abc: \\rxTransfer-Encoding: chunked\\r\\n\\r\\n\"\"\"",
          "480:     with pytest.raises(http_exceptions.BadHttpMessage):",
          "481:         parser.feed_data(text)",
          "484: @pytest.mark.parametrize(",
          "485:     \"hdr\",",
          "486:     (",
          "487:         \"Content-Length: -5\",  # https://www.rfc-editor.org/rfc/rfc9110.html#name-content-length",
          "488:         \"Content-Length: +256\",",
          "489:         \"Foo: abc\\rdef\",  # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-5",
          "490:         \"Bar: abc\\ndef\",",
          "491:         \"Baz: abc\\x00def\",",
          "492:         \"Foo : bar\",  # https://www.rfc-editor.org/rfc/rfc9112.html#section-5.1-2",
          "493:         \"Foo\\t: bar\",",
          "494:     )",
          "495: )",
          "496: def test_bad_headers(parser: Any, hdr: str) -> None:",
          "497:     text = \"POST / HTTP/1.1\\r\\n{}\\r\\n\\r\\n\".format(hdr).encode()",
          "498:     with pytest.raises(http_exceptions.InvalidHeader):",
          "499:         parser.feed_data(text)",
          "502: def test_bad_chunked_py(loop: Any, protocol: Any) -> None:",
          "503:     \"\"\"Test that invalid chunked encoding doesn't allow content-length to be used.\"\"\"",
          "504:     parser = HttpRequestParserPy(",
          "505:         protocol,",
          "506:         loop,",
          "507:         2**16,",
          "508:         max_line_size=8190,",
          "509:         max_field_size=8190,",
          "510:     )",
          "511:     text = (b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0_2e\\r\\n\\r\\n\"",
          "512:             + b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nContent-Length: 5\\r\\n\\r\\n0\\r\\n\\r\\n\")",
          "513:     messages, upgrade, tail = parser.feed_data(text)",
          "514:     assert isinstance(messages[0][1].exception(), http_exceptions.TransferEncodingError)",
          "517: @pytest.mark.skipif(",
          "518:     \"HttpRequestParserC\" not in dir(aiohttp.http_parser),",
          "519:     reason=\"C based HTTP parser not available\",",
          "520: )",
          "521: def test_bad_chunked_c(loop: Any, protocol: Any) -> None:",
          "522:     \"\"\"C parser behaves differently. Maybe we should align them later.\"\"\"",
          "523:     payload = b\"GET1 /test HTTP/1.1\\r\\n\\r\\n\"",
          "524:     parser = HttpRequestParserC(",
          "525:         protocol,",
          "526:         loop,",
          "527:         2**16,",
          "528:         max_line_size=8190,",
          "529:         max_field_size=8190,",
          "530:     )",
          "531:     text = (b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0_2e\\r\\n\\r\\n\"",
          "532:             + b\"GET / HTTP/1.1\\r\\nHost: a\\r\\nContent-Length: 5\\r\\n\\r\\n0\\r\\n\\r\\n\")",
          "533:     with pytest.raises(http_exceptions.BadHttpMessage):",
          "534:         parser.feed_data(text)",
          "537: def test_whitespace_before_header(parser: Any) -> None:",
          "538:     text = b\"GET / HTTP/1.1\\r\\n\\tContent-Length: 1\\r\\n\\r\\nX\"",
          "539:     with pytest.raises(http_exceptions.BadHttpMessage):",
          "540:         parser.feed_data(text)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "825:         response.feed_data(b\"HTTP/1.1 200 test\\r\\nFoo: abc\\x01def\\r\\n\\r\\n\")",
          "828: def test_http_response_parser_bad(response: Any) -> None:",
          "829:     with pytest.raises(http_exceptions.BadHttpMessage):",
          "830:         response.feed_data(b\"HTT/1\\r\\n\\r\\n\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "840: def test_http_response_parser_bad_crlf(response: Any) -> None:",
          "841:     \"\"\"Still a lot of dodgy servers sending bad requests like this.\"\"\"",
          "842:     messages, upgrade, tail = response.feed_data(",
          "843:         b\"HTTP/1.0 200 OK\\nFoo: abc\\nBar: def\\n\\nBODY\\n\"",
          "844:     )",
          "845:     msg = messages[0][0]",
          "847:     assert msg.headers[\"Foo\"] == \"abc\"",
          "848:     assert msg.headers[\"Bar\"] == \"def\"",
          "851: async def test_http_response_parser_bad_chunked_lax(response: Any) -> None:",
          "852:     text = (",
          "853:         b\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5 \\r\\nabcde\\r\\n0\\r\\n\\r\\n\"",
          "854:     )",
          "855:     messages, upgrade, tail = response.feed_data(text)",
          "857:     assert await messages[0][1].read(5) == b\"abcde\"",
          "860: @pytest.mark.dev_mode",
          "861: async def test_http_response_parser_bad_chunked_strict_py(",
          "862:     loop: Any, protocol: Any",
          "863: ) -> None:",
          "864:     response = HttpResponseParserPy(",
          "865:         protocol,",
          "866:         loop,",
          "867:         2**16,",
          "868:         max_line_size=8190,",
          "869:         max_field_size=8190,",
          "870:     )",
          "871:     text = (",
          "872:         b\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5 \\r\\nabcde\\r\\n0\\r\\n\\r\\n\"",
          "873:     )",
          "874:     messages, upgrade, tail = response.feed_data(text)",
          "875:     assert isinstance(messages[0][1].exception(), http_exceptions.TransferEncodingError)",
          "878: @pytest.mark.dev_mode",
          "879: @pytest.mark.skipif(",
          "880:     \"HttpRequestParserC\" not in dir(aiohttp.http_parser),",
          "881:     reason=\"C based HTTP parser not available\",",
          "882: )",
          "883: async def test_http_response_parser_bad_chunked_strict_c(",
          "884:     loop: Any, protocol: Any",
          "885: ) -> None:",
          "886:     response = HttpResponseParserC(",
          "887:         protocol,",
          "888:         loop,",
          "889:         2**16,",
          "890:         max_line_size=8190,",
          "891:         max_field_size=8190,",
          "892:     )",
          "893:     text = (",
          "894:         b\"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5 \\r\\nabcde\\r\\n0\\r\\n\\r\\n\"",
          "895:     )",
          "896:     with pytest.raises(http_exceptions.BadHttpMessage):",
          "897:         response.feed_data(text)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
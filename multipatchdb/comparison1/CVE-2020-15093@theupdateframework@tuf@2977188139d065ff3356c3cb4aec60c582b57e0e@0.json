{
  "cve_id": "CVE-2020-15093",
  "cve_desc": "The tough library (Rust/crates.io) prior to version 0.7.1 does not properly verify the threshold of cryptographic signatures. It allows an attacker to duplicate a valid signature in order to circumvent TUF requiring a minimum threshold of unique signatures before the metadata is considered valid. A fix is available in version 0.7.1. CVE-2020-6174 is assigned to the same vulnerability in the TUF reference implementation.",
  "repo": "theupdateframework/tuf",
  "patch_hash": "2977188139d065ff3356c3cb4aec60c582b57e0e",
  "patch_info": {
    "commit_hash": "2977188139d065ff3356c3cb4aec60c582b57e0e",
    "repo": "theupdateframework/tuf",
    "commit_url": "https://github.com/theupdateframework/tuf/commit/2977188139d065ff3356c3cb4aec60c582b57e0e",
    "files": [
      "tests/test_sig.py",
      "tests/test_updater.py",
      "tuf/sig.py"
    ],
    "message": "Merge pull request #974 from lukpueh/fix-signature-threshold\n\nFix signature threshold",
    "before_after_code_files": [
      "tests/test_sig.py||tests/test_sig.py",
      "tests/test_updater.py||tests/test_updater.py",
      "tuf/sig.py||tuf/sig.py"
    ]
  },
  "patch_diff": {
    "tests/test_sig.py||tests/test_sig.py": [
      "File: tests/test_sig.py -> tests/test_sig.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "32: import unittest",
      "33: import logging",
      "35: import tuf",
      "36: import tuf.log",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "34: import copy",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "384:     tuf.roledb.remove_role('Root')",
      "387:   def test_verify_unrecognized_sig(self):",
      "388:     signable = {'signed' : 'test', 'signatures' : []}",
      "389:     signed = securesystemslib.formats.encode_canonical(signable['signed']).encode('utf-8')",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "389:   def test_verify_must_not_count_duplicate_keyids_towards_threshold(self):",
      "390:     # Create and sign dummy metadata twice with same key",
      "391:     # Note that we use the non-deterministic rsassa-pss signing scheme, so",
      "392:     # creating the signature twice shows that we don't only detect duplicate",
      "393:     # signatures but also different signatures from the same key.",
      "394:     signable = {\"signed\" : \"test\", \"signatures\" : []}",
      "395:     signed = securesystemslib.formats.encode_canonical(",
      "396:         signable[\"signed\"]).encode(\"utf-8\")",
      "397:     signable[\"signatures\"].append(",
      "398:         securesystemslib.keys.create_signature(KEYS[0], signed))",
      "399:     signable[\"signatures\"].append(",
      "400:         securesystemslib.keys.create_signature(KEYS[0], signed))",
      "402:     # 'get_signature_status' uses keys from keydb for verification",
      "403:     tuf.keydb.add_key(KEYS[0])",
      "405:     # Assert that 'get_signature_status' returns two good signatures ...",
      "406:     status = tuf.sig.get_signature_status(",
      "407:         signable, \"root\", keyids=[KEYS[0][\"keyid\"]], threshold=2)",
      "408:     self.assertTrue(len(status[\"good_sigs\"]) == 2)",
      "410:     # ... but only one counts towards the threshold",
      "411:     self.assertFalse(",
      "412:         tuf.sig.verify(signable, \"root\", keyids=[KEYS[0][\"keyid\"]], threshold=2))",
      "414:     # Clean-up keydb",
      "415:     tuf.keydb.remove_key(KEYS[0][\"keyid\"])",
      "419:   def test_verify_count_different_keyids_for_same_key_towards_threshold(self):",
      "420:     # Create and sign dummy metadata twice with same key but different keyids",
      "421:     signable = {\"signed\" : \"test\", \"signatures\" : []}",
      "422:     key_sha256 = copy.deepcopy(KEYS[0])",
      "423:     key_sha256[\"keyid\"] = \"deadbeef256\"",
      "425:     key_sha512 = copy.deepcopy(KEYS[0])",
      "426:     key_sha512[\"keyid\"] = \"deadbeef512\"",
      "428:     signed = securesystemslib.formats.encode_canonical(",
      "429:         signable[\"signed\"]).encode(\"utf-8\")",
      "430:     signable[\"signatures\"].append(",
      "431:         securesystemslib.keys.create_signature(key_sha256, signed))",
      "432:     signable[\"signatures\"].append(",
      "433:         securesystemslib.keys.create_signature(key_sha512, signed))",
      "435:     # 'get_signature_status' uses keys from keydb for verification",
      "436:     tuf.keydb.add_key(key_sha256)",
      "437:     tuf.keydb.add_key(key_sha512)",
      "439:     # Assert that both keys count towards threshold although its the same key",
      "440:     keyids = [key_sha256[\"keyid\"], key_sha512[\"keyid\"]]",
      "441:     self.assertTrue(",
      "442:         tuf.sig.verify(signable, \"root\", keyids=keyids, threshold=2))",
      "444:     # Clean-up keydb",
      "445:     tuf.keydb.remove_key(key_sha256[\"keyid\"])",
      "446:     tuf.keydb.remove_key(key_sha512[\"keyid\"])",
      "",
      "---------------"
    ],
    "tests/test_updater.py||tests/test_updater.py": [
      "File: tests/test_updater.py -> tests/test_updater.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "429:   def test_1__update_fileinfo(self):",
      "430:       # Tests",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "428:   def test_1__refresh_must_not_count_duplicate_keyids_towards_threshold(self):",
      "429:     # Update root threshold on the server repository and sign twice with 1 key",
      "430:     repository = repo_tool.load_repository(self.repository_directory)",
      "431:     repository.root.threshold = 2",
      "432:     repository.root.load_signing_key(self.role_keys['root']['private'])",
      "434:     # The client uses the threshold from the previous root file to verify the",
      "435:     # new root. Thus we need to make two updates so that the threshold used for",
      "436:     # verification becomes 2. I.e. we bump the version, sign twice with the",
      "437:     # same key and write to disk '2.root.json' and '3.root.json'.",
      "438:     for version in [2, 3]:",
      "439:       repository.root.version = version",
      "440:       info = tuf.roledb.get_roleinfo(\"root\")",
      "441:       metadata = repo_lib.generate_root_metadata(",
      "442:           info[\"version\"], info[\"expires\"], False)",
      "443:       signed_metadata = repo_lib.sign_metadata(",
      "444:           metadata, info[\"keyids\"], \"root.json\", \"default\")",
      "445:       signed_metadata[\"signatures\"].append(signed_metadata[\"signatures\"][0])",
      "446:       live_root_path = os.path.join(",
      "447:           self.repository_directory, \"metadata\", \"root.json\")",
      "449:       # Bypass server side verification in 'write' or 'writeall', which would",
      "450:       # catch the unmet threshold.",
      "451:       # We also skip writing to 'metadata.staged' and copying to 'metadata' and",
      "452:       # instead write directly to 'metadata'",
      "453:       repo_lib.write_metadata_file(signed_metadata, live_root_path, info[\"version\"], True)",
      "456:     # Update from current '1.root.json' to '3.root.json' on client and assert",
      "457:     # raise of 'BadSignatureError' (caused by unmet signature threshold).",
      "458:     try:",
      "459:       self.repository_updater.refresh()",
      "461:     except tuf.exceptions.NoWorkingMirrorError as e:",
      "462:       mirror_errors = list(e.mirror_errors.values())",
      "463:       self.assertTrue(len(mirror_errors) == 1)",
      "464:       self.assertTrue(",
      "465:           isinstance(mirror_errors[0],",
      "466:           securesystemslib.exceptions.BadSignatureError))",
      "467:       self.assertEqual(",
      "468:           str(mirror_errors[0]),",
      "469:           repr(\"root\") + \" metadata has bad signature.\")",
      "471:     else:",
      "472:       self.fail(",
      "473:           \"Expected a NoWorkingMirrorError composed of one BadSignatureError\")",
      "",
      "---------------"
    ],
    "tuf/sig.py||tuf/sig.py": [
      "File: tuf/sig.py -> tuf/sig.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "71:   \"\"\"",
      "72:   <Purpose>",
      "73:     Return a dictionary representing the status of the signatures listed in",
      "80:   <Arguments>",
      "81:     signable:",
      "",
      "[Removed Lines]",
      "74:     'signable'.  Given an object conformant to SIGNABLE_SCHEMA, a set of public",
      "75:     keys in 'tuf.keydb', a set of roles in 'tuf.roledb', and a role,",
      "76:     the status of these signatures can be determined.  This method will iterate",
      "77:     the signatures in 'signable' and enumerate all the keys that are valid,",
      "78:     invalid, unrecognized, or unauthorized.",
      "",
      "[Added Lines]",
      "74:     'signable'. Signatures in the returned dictionary are identified by the",
      "75:     signature keyid and can have a status of either:",
      "79:       authorized for the passed role as per 'tuf.roledb' (authorization may be",
      "80:       overwritten by passed 'keyids').",
      "82:       'role' is None.",
      "84:       scheme.",
      "86:       but is not trusted for the passed role as per 'tuf.roledb' or the passed",
      "87:       'keyids'.",
      "89:     NOTE: The result may contain duplicate keyids or keyids that reference the",
      "90:     same key, if 'signable' lists multiple signatures from the same key.",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "87:       Conformant to tuf.formats.SIGNABLE_SCHEMA.",
      "89:     role:",
      "92:     threshold:",
      "93:       Rather than reference the role's threshold as set in tuf.roledb.py, use",
      "",
      "[Removed Lines]",
      "90:       TUF role (e.g., 'root', 'targets', 'snapshot').",
      "",
      "[Added Lines]",
      "102:       TUF role string (e.g. 'root', 'targets', 'snapshot' or timestamp).",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "134:   # The signature status dictionary returned.",
      "135:   signature_status = {}",
      "152:   good_sigs = []",
      "153:   bad_sigs = []",
      "154:   unknown_sigs = []",
      "",
      "[Removed Lines]",
      "137:   # The fields of the signature_status dict, where each field stores keyids.  A",
      "138:   # description of each field:",
      "139:   #",
      "140:   # good_sigs = keys confirmed to have produced 'sig' using 'signed', which are",
      "141:   # associated with 'role';",
      "142:   #",
      "143:   # bad_sigs = negation of good_sigs;",
      "144:   #",
      "145:   # unknown_sigs = keys not found in the 'keydb' database;",
      "146:   #",
      "147:   # untrusted_sigs = keys that are not in the list of keyids associated with",
      "148:   # 'role';",
      "149:   #",
      "150:   # unknown_signing_scheme = signing schemes specified in keys that are",
      "151:   # unsupported;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "240:     keyids=None):",
      "241:   \"\"\"",
      "242:   <Purpose>",
      "248:   <Arguments>",
      "249:     signable:",
      "251:       signable = {'signed':, 'signatures': [{'keyid':, 'method':, 'sig':}]}",
      "253:     role:",
      "256:     threshold:",
      "257:       Rather than reference the role's threshold as set in tuf.roledb.py, use",
      "",
      "[Removed Lines]",
      "243:     Verify whether the authorized signatures of 'signable' meet the minimum",
      "244:     required by 'role'.  Authorized signatures are those with valid keys",
      "245:     associated with 'role'.  'signable' must conform to SIGNABLE_SCHEMA",
      "246:     and 'role' must not equal 'None' or be less than zero.",
      "250:       A dictionary containing a list of signatures and a 'signed' identifier.",
      "254:       TUF role (e.g., 'root', 'targets', 'snapshot').",
      "",
      "[Added Lines]",
      "239:     Verify that 'signable' has a valid threshold of authorized signatures",
      "240:     identified by unique keyids. The threshold and whether a keyid is",
      "241:     authorized is determined by querying the 'threshold' and 'keyids' info for",
      "242:     the passed 'role' in 'tuf.roledb'. Both values can be overwritten by",
      "243:     passing the 'threshold' or 'keyids' arguments.",
      "245:     NOTE:",
      "246:     - Signatures with identical authorized keyids only count towards the",
      "247:       threshold once.",
      "248:     - Signatures with different authorized keyids each count towards the",
      "249:       threshold, even if the keyids identify the same key.",
      "253:       A dictionary containing a list of signatures and a 'signed' identifier",
      "254:       that conforms to SIGNABLE_SCHEMA, e.g.:",
      "258:       TUF role string (e.g. 'root', 'targets', 'snapshot' or timestamp).",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "278:     get_signature_status() will be caught here and re-raised.",
      "280:   <Returns>",
      "283:   \"\"\"",
      "285:   tuf.formats.SIGNABLE_SCHEMA.check_match(signable)",
      "",
      "[Removed Lines]",
      "281:     Boolean.  True if the number of good signatures >= the role's threshold,",
      "282:     False otherwise.",
      "",
      "[Added Lines]",
      "285:     Boolean.  True if the number of good unique (by keyid) signatures >= the",
      "286:     role's threshold, False otherwise.",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "303:   if threshold is None or threshold <= 0: #pragma: no cover",
      "304:     raise securesystemslib.exceptions.Error(\"Invalid threshold: \" + repr(threshold))",
      "",
      "[Removed Lines]",
      "306:   return len(good_sigs) >= threshold",
      "",
      "[Added Lines]",
      "310:   return len(set(good_sigs)) >= threshold",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "67a3a7ab9214c4fb466592b8ed2b9dd64d5a8654",
      "candidate_info": {
        "commit_hash": "67a3a7ab9214c4fb466592b8ed2b9dd64d5a8654",
        "repo": "theupdateframework/tuf",
        "commit_url": "https://github.com/theupdateframework/tuf/commit/67a3a7ab9214c4fb466592b8ed2b9dd64d5a8654",
        "files": [
          "tests/test_sig.py",
          "tuf/sig.py"
        ],
        "message": "Update docs and comments in sig.py and test_sig.py\n\nSigned-off-by: Lukas Puehringer <lukas.puehringer@nyu.edu>",
        "before_after_code_files": [
          "tests/test_sig.py||tests/test_sig.py",
          "tuf/sig.py||tuf/sig.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/theupdateframework/python-tuf/pull/974"
        ],
        "olp_code_files": {
          "patch": [
            "tests/test_sig.py||tests/test_sig.py",
            "tuf/sig.py||tuf/sig.py"
          ],
          "candidate": [
            "tests/test_sig.py||tests/test_sig.py",
            "tuf/sig.py||tuf/sig.py"
          ]
        }
      },
      "candidate_diff": {
        "tests/test_sig.py||tests/test_sig.py": [
          "File: tests/test_sig.py -> tests/test_sig.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "389:   def test_verify_must_not_count_duplicate_keyids_towards_threshold(self):",
          "390:     # Create and sign dummy metadata twice with same key",
          "391:     signable = {\"signed\" : \"test\", \"signatures\" : []}",
          "392:     signed = securesystemslib.formats.encode_canonical(",
          "393:         signable[\"signed\"]).encode(\"utf-8\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "391:     # Note that we use the non-deterministic rsassa-pss signing scheme, so",
          "392:     # creating the signature twice shows that we don't only detect duplicate",
          "393:     # signatures but also different signatures from the same key.",
          "",
          "---------------"
        ],
        "tuf/sig.py||tuf/sig.py": [
          "File: tuf/sig.py -> tuf/sig.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "79:       authorized for the passed role as per 'tuf.roledb' (authorization may be",
          "80:       overwritten by passed 'keyids').",
          "83:       scheme.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "82:       'role' is None.",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a0397c7c820ec1c30ebc793cc9469b61c8d3f50e",
      "candidate_info": {
        "commit_hash": "a0397c7c820ec1c30ebc793cc9469b61c8d3f50e",
        "repo": "theupdateframework/tuf",
        "commit_url": "https://github.com/theupdateframework/tuf/commit/a0397c7c820ec1c30ebc793cc9469b61c8d3f50e",
        "files": [
          "tests/test_sig.py",
          "tests/test_updater.py",
          "tuf/sig.py"
        ],
        "message": "Fix signature threshold verification\n\nPrior to this commit metadadata signature verification as provided\nby `tuf.sig.verify()` and used e.g. in `tuf.client.updater` counted\nmultiple signatures with identical authorized keyids each\nseparately towards the threshold. This behavior practically\nsubverts the signature thresholds check.\n\nThis commit fixes the issue by counting identical authorized keyids\nonly once towards the threshold.\n\nThe commit further clarifies the behavior of the relevant functions\nin the `sig` module, i.e. `get_signature_status` and `verify` in\ntheir respective docstrings. And adds tests for those functions and\nalso for the client updater.\n\n---\n\nNOTE: With this commit signatures with different authorized keyids\nstill each count separately towards the threshold, even if the\nkeyids identify the same key. If this behavior is not desired, I\npropose the following fix instead. It verifies uniqueness of keys\n(and not keyids):\n\n```\ndiff --git a/tuf/sig.py b/tuf/sig.py\nindex ae9bae15..5392e596 100755\n--- a/tuf/sig.py\n+++ b/tuf/sig.py\n@@ -303,7 +303,14 @@ def verify(signable, role, repository_name='default', threshold=None,\n   if threshold is None or threshold <= 0: #pragma: no cover\n     raise securesystemslib.exceptions.Error(\"Invalid threshold: \" + repr(threshold))\n\n-  return len(good_sigs) >= threshold\n+  # Different keyids might point to the same key\n+  # To be safe, check against unique public key values\n+  unique_good_sig_keys = set()\n+  for keyid in good_sigs:\n+    key = tuf.keydb.get_key(keyid, repository_name)\n+    unique_good_sig_keys.add(key[\"keyval\"][\"public\"])\n+\n+  return len(unique_good_sig_keys) >= threshold\n\n```\n\nSigned-off-by: Lukas Puehringer <lukas.puehringer@nyu.edu>",
        "before_after_code_files": [
          "tests/test_sig.py||tests/test_sig.py",
          "tests/test_updater.py||tests/test_updater.py",
          "tuf/sig.py||tuf/sig.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/theupdateframework/python-tuf/pull/974"
        ],
        "olp_code_files": {
          "patch": [
            "tests/test_sig.py||tests/test_sig.py",
            "tests/test_updater.py||tests/test_updater.py",
            "tuf/sig.py||tuf/sig.py"
          ],
          "candidate": [
            "tests/test_sig.py||tests/test_sig.py",
            "tests/test_updater.py||tests/test_updater.py",
            "tuf/sig.py||tuf/sig.py"
          ]
        }
      },
      "candidate_diff": {
        "tests/test_sig.py||tests/test_sig.py": [
          "File: tests/test_sig.py -> tests/test_sig.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: import unittest",
          "33: import logging",
          "35: import tuf",
          "36: import tuf.log",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34: import copy",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "384:     tuf.roledb.remove_role('Root')",
          "387:   def test_verify_unrecognized_sig(self):",
          "388:     signable = {'signed' : 'test', 'signatures' : []}",
          "389:     signed = securesystemslib.formats.encode_canonical(signable['signed']).encode('utf-8')",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "389:   def test_verify_must_not_count_duplicate_keyids_towards_threshold(self):",
          "390:     # Create and sign dummy metadata twice with same key",
          "391:     signable = {\"signed\" : \"test\", \"signatures\" : []}",
          "392:     signed = securesystemslib.formats.encode_canonical(",
          "393:         signable[\"signed\"]).encode(\"utf-8\")",
          "394:     signable[\"signatures\"].append(",
          "395:         securesystemslib.keys.create_signature(KEYS[0], signed))",
          "396:     signable[\"signatures\"].append(",
          "397:         securesystemslib.keys.create_signature(KEYS[0], signed))",
          "399:     # 'get_signature_status' uses keys from keydb for verification",
          "400:     tuf.keydb.add_key(KEYS[0])",
          "402:     # Assert that 'get_signature_status' returns two good signatures ...",
          "403:     status = tuf.sig.get_signature_status(",
          "404:         signable, \"root\", keyids=[KEYS[0][\"keyid\"]], threshold=2)",
          "405:     self.assertTrue(len(status[\"good_sigs\"]) == 2)",
          "407:     # ... but only one counts towards the threshold",
          "408:     self.assertFalse(",
          "409:         tuf.sig.verify(signable, \"root\", keyids=[KEYS[0][\"keyid\"]], threshold=2))",
          "411:     # Clean-up keydb",
          "412:     tuf.keydb.remove_key(KEYS[0][\"keyid\"])",
          "416:   def test_verify_count_different_keyids_for_same_key_towards_threshold(self):",
          "417:     # Create and sign dummy metadata twice with same key but different keyids",
          "418:     signable = {\"signed\" : \"test\", \"signatures\" : []}",
          "419:     key_sha256 = copy.deepcopy(KEYS[0])",
          "420:     key_sha256[\"keyid\"] = \"deadbeef256\"",
          "422:     key_sha512 = copy.deepcopy(KEYS[0])",
          "423:     key_sha512[\"keyid\"] = \"deadbeef512\"",
          "425:     signed = securesystemslib.formats.encode_canonical(",
          "426:         signable[\"signed\"]).encode(\"utf-8\")",
          "427:     signable[\"signatures\"].append(",
          "428:         securesystemslib.keys.create_signature(key_sha256, signed))",
          "429:     signable[\"signatures\"].append(",
          "430:         securesystemslib.keys.create_signature(key_sha512, signed))",
          "432:     # 'get_signature_status' uses keys from keydb for verification",
          "433:     tuf.keydb.add_key(key_sha256)",
          "434:     tuf.keydb.add_key(key_sha512)",
          "436:     # Assert that both keys count towards threshold although its the same key",
          "437:     keyids = [key_sha256[\"keyid\"], key_sha512[\"keyid\"]]",
          "438:     self.assertTrue(",
          "439:         tuf.sig.verify(signable, \"root\", keyids=keyids, threshold=2))",
          "441:     # Clean-up keydb",
          "442:     tuf.keydb.remove_key(key_sha256[\"keyid\"])",
          "443:     tuf.keydb.remove_key(key_sha512[\"keyid\"])",
          "",
          "---------------"
        ],
        "tests/test_updater.py||tests/test_updater.py": [
          "File: tests/test_updater.py -> tests/test_updater.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "429:   def test_1__update_fileinfo(self):",
          "430:       # Tests",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "428:   def test_1__refresh_must_not_count_duplicate_keyids_towards_threshold(self):",
          "429:     # Update root threshold on the server repository and sign twice with 1 key",
          "430:     repository = repo_tool.load_repository(self.repository_directory)",
          "431:     repository.root.threshold = 2",
          "432:     repository.root.load_signing_key(self.role_keys['root']['private'])",
          "434:     # The client uses the threshold from the previous root file to verify the",
          "435:     # new root. Thus we need to make two updates so that the threshold used for",
          "436:     # verification becomes 2. I.e. we bump the version, sign twice with the",
          "437:     # same key and write to disk '2.root.json' and '3.root.json'.",
          "438:     for version in [2, 3]:",
          "439:       repository.root.version = version",
          "440:       info = tuf.roledb.get_roleinfo(\"root\")",
          "441:       metadata = repo_lib.generate_root_metadata(",
          "442:           info[\"version\"], info[\"expires\"], False)",
          "443:       signed_metadata = repo_lib.sign_metadata(",
          "444:           metadata, info[\"keyids\"], \"root.json\", \"default\")",
          "445:       signed_metadata[\"signatures\"].append(signed_metadata[\"signatures\"][0])",
          "446:       live_root_path = os.path.join(",
          "447:           self.repository_directory, \"metadata\", \"root.json\")",
          "449:       # Bypass server side verification in 'write' or 'writeall', which would",
          "450:       # catch the unmet threshold.",
          "451:       # We also skip writing to 'metadata.staged' and copying to 'metadata' and",
          "452:       # instead write directly to 'metadata'",
          "453:       repo_lib.write_metadata_file(signed_metadata, live_root_path, info[\"version\"], True)",
          "456:     # Update from current '1.root.json' to '3.root.json' on client and assert",
          "457:     # raise of 'BadSignatureError' (caused by unmet signature threshold).",
          "458:     try:",
          "459:       self.repository_updater.refresh()",
          "461:     except tuf.exceptions.NoWorkingMirrorError as e:",
          "462:       mirror_errors = list(e.mirror_errors.values())",
          "463:       self.assertTrue(len(mirror_errors) == 1)",
          "464:       self.assertTrue(",
          "465:           isinstance(mirror_errors[0],",
          "466:           securesystemslib.exceptions.BadSignatureError))",
          "467:       self.assertEqual(",
          "468:           str(mirror_errors[0]),",
          "469:           repr(\"root\") + \" metadata has bad signature.\")",
          "471:     else:",
          "472:       self.fail(",
          "473:           \"Expected a NoWorkingMirrorError composed of one BadSignatureError\")",
          "",
          "---------------"
        ],
        "tuf/sig.py||tuf/sig.py": [
          "File: tuf/sig.py -> tuf/sig.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "71:   \"\"\"",
          "72:   <Purpose>",
          "73:     Return a dictionary representing the status of the signatures listed in",
          "80:   <Arguments>",
          "81:     signable:",
          "",
          "[Removed Lines]",
          "74:     'signable'.  Given an object conformant to SIGNABLE_SCHEMA, a set of public",
          "75:     keys in 'tuf.keydb', a set of roles in 'tuf.roledb', and a role,",
          "76:     the status of these signatures can be determined.  This method will iterate",
          "77:     the signatures in 'signable' and enumerate all the keys that are valid,",
          "78:     invalid, unrecognized, or unauthorized.",
          "",
          "[Added Lines]",
          "74:     'signable'. Signatures in the returned dictionary are identified by the",
          "75:     signature keyid and can have a status of either:",
          "79:       authorized for the passed role as per 'tuf.roledb' (authorization may be",
          "80:       overwritten by passed 'keyids').",
          "83:       scheme.",
          "85:       but is not trusted for the passed role as per 'tuf.roledb' or the passed",
          "86:       'keyids'.",
          "88:     NOTE: The result may contain duplicate keyids or keyids that reference the",
          "89:     same key, if 'signable' lists multiple signatures from the same key.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87:       Conformant to tuf.formats.SIGNABLE_SCHEMA.",
          "89:     role:",
          "92:     threshold:",
          "93:       Rather than reference the role's threshold as set in tuf.roledb.py, use",
          "",
          "[Removed Lines]",
          "90:       TUF role (e.g., 'root', 'targets', 'snapshot').",
          "",
          "[Added Lines]",
          "101:       TUF role string (e.g. 'root', 'targets', 'snapshot' or timestamp).",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "134:   # The signature status dictionary returned.",
          "135:   signature_status = {}",
          "152:   good_sigs = []",
          "153:   bad_sigs = []",
          "154:   unknown_sigs = []",
          "",
          "[Removed Lines]",
          "137:   # The fields of the signature_status dict, where each field stores keyids.  A",
          "138:   # description of each field:",
          "139:   #",
          "140:   # good_sigs = keys confirmed to have produced 'sig' using 'signed', which are",
          "141:   # associated with 'role';",
          "142:   #",
          "143:   # bad_sigs = negation of good_sigs;",
          "144:   #",
          "145:   # unknown_sigs = keys not found in the 'keydb' database;",
          "146:   #",
          "147:   # untrusted_sigs = keys that are not in the list of keyids associated with",
          "148:   # 'role';",
          "149:   #",
          "150:   # unknown_signing_scheme = signing schemes specified in keys that are",
          "151:   # unsupported;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "240:     keyids=None):",
          "241:   \"\"\"",
          "242:   <Purpose>",
          "248:   <Arguments>",
          "249:     signable:",
          "251:       signable = {'signed':, 'signatures': [{'keyid':, 'method':, 'sig':}]}",
          "253:     role:",
          "256:     threshold:",
          "257:       Rather than reference the role's threshold as set in tuf.roledb.py, use",
          "",
          "[Removed Lines]",
          "243:     Verify whether the authorized signatures of 'signable' meet the minimum",
          "244:     required by 'role'.  Authorized signatures are those with valid keys",
          "245:     associated with 'role'.  'signable' must conform to SIGNABLE_SCHEMA",
          "246:     and 'role' must not equal 'None' or be less than zero.",
          "250:       A dictionary containing a list of signatures and a 'signed' identifier.",
          "254:       TUF role (e.g., 'root', 'targets', 'snapshot').",
          "",
          "[Added Lines]",
          "238:     Verify that 'signable' has a valid threshold of authorized signatures",
          "239:     identified by unique keyids. The threshold and whether a keyid is",
          "240:     authorized is determined by querying the 'threshold' and 'keyids' info for",
          "241:     the passed 'role' in 'tuf.roledb'. Both values can be overwritten by",
          "242:     passing the 'threshold' or 'keyids' arguments.",
          "244:     NOTE:",
          "245:     - Signatures with identical authorized keyids only count towards the",
          "246:       threshold once.",
          "247:     - Signatures with different authorized keyids each count towards the",
          "248:       threshold, even if the keyids identify the same key.",
          "252:       A dictionary containing a list of signatures and a 'signed' identifier",
          "253:       that conforms to SIGNABLE_SCHEMA, e.g.:",
          "257:       TUF role string (e.g. 'root', 'targets', 'snapshot' or timestamp).",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "278:     get_signature_status() will be caught here and re-raised.",
          "280:   <Returns>",
          "283:   \"\"\"",
          "285:   tuf.formats.SIGNABLE_SCHEMA.check_match(signable)",
          "",
          "[Removed Lines]",
          "281:     Boolean.  True if the number of good signatures >= the role's threshold,",
          "282:     False otherwise.",
          "",
          "[Added Lines]",
          "284:     Boolean.  True if the number of good unique (by keyid) signatures >= the",
          "285:     role's threshold, False otherwise.",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "303:   if threshold is None or threshold <= 0: #pragma: no cover",
          "304:     raise securesystemslib.exceptions.Error(\"Invalid threshold: \" + repr(threshold))",
          "",
          "[Removed Lines]",
          "306:   return len(good_sigs) >= threshold",
          "",
          "[Added Lines]",
          "309:   return len(set(good_sigs)) >= threshold",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e20fb54f5ce53240ab5686b532434a956151ba3b",
      "candidate_info": {
        "commit_hash": "e20fb54f5ce53240ab5686b532434a956151ba3b",
        "repo": "theupdateframework/tuf",
        "commit_url": "https://github.com/theupdateframework/tuf/commit/e20fb54f5ce53240ab5686b532434a956151ba3b",
        "files": [
          "requirements.txt",
          "tests/aggregate_tests.py",
          "tests/test_asn1_convert.py",
          "tests/test_sig.py",
          "tuf/client/updater.py",
          "tuf/developer_tool.py",
          "tuf/encoding/asn1_convert.py",
          "tuf/encoding/asn1_metadata_definitions.py",
          "tuf/encoding/metadata_definitions.asn1",
          "tuf/encoding/util.py",
          "tuf/exceptions.py",
          "tuf/formats.py",
          "tuf/repository_lib.py",
          "tuf/repository_tool.py",
          "tuf/sig.py"
        ],
        "message": "<~> DO NOT MERGE: status freeze to switch tracks\n\nsaving changes pending commit here, to switch tracks from\nASN.1 support itself to finally resolve #660, which is causing\nproblems here.\n\nSigned-off-by: Sebastien Awwad <sebastien.awwad@gmail.com>",
        "before_after_code_files": [
          "tests/aggregate_tests.py||tests/aggregate_tests.py",
          "tests/test_asn1_convert.py||tests/test_asn1_convert.py",
          "tests/test_sig.py||tests/test_sig.py",
          "tuf/client/updater.py||tuf/client/updater.py",
          "tuf/developer_tool.py||tuf/developer_tool.py",
          "tuf/encoding/asn1_convert.py||tuf/encoding/asn1_convert.py",
          "tuf/encoding/asn1_metadata_definitions.py||tuf/encoding/asn1_metadata_definitions.py",
          "tuf/encoding/metadata_definitions.asn1||tuf/encoding/metadata_definitions.asn1",
          "tuf/encoding/util.py||tuf/encoding/util.py",
          "tuf/exceptions.py||tuf/exceptions.py",
          "tuf/formats.py||tuf/formats.py",
          "tuf/repository_lib.py||tuf/repository_lib.py",
          "tuf/repository_tool.py||tuf/repository_tool.py",
          "tuf/sig.py||tuf/sig.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "tests/test_sig.py||tests/test_sig.py",
            "tuf/sig.py||tuf/sig.py"
          ],
          "candidate": [
            "tests/test_sig.py||tests/test_sig.py",
            "tuf/sig.py||tuf/sig.py"
          ]
        }
      },
      "candidate_diff": {
        "tests/aggregate_tests.py||tests/aggregate_tests.py": [
          "File: tests/aggregate_tests.py -> tests/aggregate_tests.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "59: # configured to use. Note also that this TUF implementation does not support",
          "60: # any Python versions <2.7 or any Python3 versions <3.4.",
          "61: VERSION_SPECIFIC_TESTS = {",
          "62:     'test_proxy_use': {'major': 2, 'minor': 7}} # Run test only if Python2.7",
          "63: # Further example:",
          "64: #   'test_abc': {'major': 2} # Run test only if Python2",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62:     'test_asn1_convert': {'major': 42, 'minor': 42}, # skip me for now. DEBUG ONLY",
          "",
          "---------------"
        ],
        "tests/test_asn1_convert.py||tests/test_asn1_convert.py": [
          "File: tests/test_asn1_convert.py -> tests/test_asn1_convert.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: import unittest",
          "29: unittest.util._MAX_LENGTH=20000  # DEBUG",
          "30: import os",
          "31: import logging",
          "32: import binascii # for bytes to hex",
          "33: # Dependency Imports",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31: import os.path",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "381:     root = {",
          "382:       'signatures': [",
          "383:         {",
          "",
          "[Removed Lines]",
          "380:   def test_signed_portion_of_root_conversion(self):",
          "",
          "[Added Lines]",
          "381:   def test_root_conversion(self):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "437:     # Test by calling the general to_asn1 and from_asn1 calls that will call",
          "438:     # the helper functions.",
          "439:     # 'signed' subsection first.",
          "441:         data=root['signed'],",
          "442:         datatype=asn1_defs.RootMetadata,",
          "443:         expected_der=root_data_expected_der)",
          "445:     # Then the whole thing.",
          "447:         data=root,",
          "448:         datatype=asn1_defs.RootEnvelope,",
          "449:         expected_der=root_signable_expected_der)",
          "456:     timestamp = {",
          "457:       'signatures': [",
          "458:         {",
          "",
          "[Removed Lines]",
          "440:     self.conversion_check(",
          "446:     self.conversion_check(",
          "455:   def test_signed_portion_of_timestamp_conversion(self):",
          "",
          "[Added Lines]",
          "441:     data_asn1, data_der = self.conversion_check(",
          "446:     write_test_data_file('root_signed_portion_only.der', data_der)",
          "449:     data_asn1, data_der = self.conversion_check(",
          "454:     write_test_data_file('root_envelope.der', data_der)",
          "459:   def test_timestamp_conversion(self):",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "486:     # Test by calling the general to_asn1 and from_asn1 calls that will call",
          "487:     # the helper functions.",
          "488:     # 'signed' subsection first.",
          "490:         data=timestamp['signed'],",
          "491:         datatype=asn1_defs.TimestampMetadata,",
          "492:         expected_der=timestamp_data_expected_der)",
          "494:     # Then the whole thing.",
          "496:         data=timestamp,",
          "497:         datatype=asn1_defs.TimestampEnvelope,",
          "498:         expected_der=timestamp_signable_expected_der)",
          "505:     snapshot = {",
          "506:       'signatures': [",
          "507:         {",
          "",
          "[Removed Lines]",
          "489:     self.conversion_check(",
          "495:     self.conversion_check(",
          "504:   def test_signed_portion_of_snapshot_conversion(self):",
          "",
          "[Added Lines]",
          "493:     data_asn1, data_der = self.conversion_check(",
          "498:     write_test_data_file('timestamp_signed_portion_only.der', data_der)",
          "502:     data_asn1, data_der = self.conversion_check(",
          "507:     write_test_data_file('timestamp_envelope.der', data_der)",
          "513:   def test_snapshot_conversion(self):",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "536:     # Test by calling the general to_asn1 and from_asn1 calls that will call",
          "537:     # the helper functions.",
          "538:     # 'signed' subsection first.",
          "540:         data=snapshot['signed'],",
          "541:         datatype=asn1_defs.SnapshotMetadata,",
          "542:         expected_der=snapshot_data_expected_der)",
          "544:     # Then the whole thing.",
          "546:         data=snapshot,",
          "547:         datatype=asn1_defs.SnapshotEnvelope,",
          "548:         expected_der=snapshot_signable_expected_der)",
          "",
          "[Removed Lines]",
          "539:     self.conversion_check(",
          "545:     self.conversion_check(",
          "",
          "[Added Lines]",
          "548:     data_asn1, data_der = self.conversion_check(",
          "553:     write_test_data_file('snapshot_signed_contents.der', data_der)",
          "557:     data_asn1, data_der = self.conversion_check(",
          "562:     write_test_data_file('snapshot_envelope.der', data_der)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "623:     # Test by calling the general to_asn1 and from_asn1 calls that will call",
          "624:     # the helper functions.",
          "625:     # 'signed' subsection first.",
          "627:         data=targets['signed'],",
          "628:         datatype=asn1_defs.TargetsMetadata,",
          "629:         expected_der=targets_data_expected_der)",
          "631:     # Then the whole thing.",
          "633:         data=targets,",
          "634:         datatype=asn1_defs.TargetsEnvelope,",
          "635:         expected_der=targets_signable_expected_der)",
          "",
          "[Removed Lines]",
          "626:     self.conversion_check(",
          "632:     self.conversion_check(",
          "",
          "[Added Lines]",
          "641:     data_asn1, data_der = self.conversion_check(",
          "646:     write_test_data_file('targets_w_delegation_and_targets_signed_contents.der', data_der)",
          "649:     data_asn1, data_der = self.conversion_check(",
          "654:     write_test_data_file('targets_w_delegation_and_targets_full_envelope.der', data_der)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "792: # Run unit test.",
          "793: if __name__ == '__main__':",
          "794:   unittest.main()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "812: def write_test_data_file(fname, data_der):",
          "814:   if not os.path.exists('der_test_data'):",
          "815:     os.mkdir('der_test_data')",
          "817:   # Lazy protection.",
          "818:   assert '/' not in fname",
          "819:   assert '\\\\' not in fname",
          "820:   assert '~' not in fname",
          "821:   assert '..' not in fname",
          "822:   fullpath = os.path.abspath(os.path.join('der_test_data', fname))",
          "823:   assert fullpath.startswith(os.getcwd())",
          "825:   with open(fullpath, 'wb') as fobj:",
          "826:     fobj.write(data_der)",
          "",
          "---------------"
        ],
        "tests/test_sig.py||tests/test_sig.py": [
          "File: tests/test_sig.py -> tests/test_sig.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: import unittest",
          "33: import logging",
          "35: import tuf",
          "36: import tuf.log",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34: import copy",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "39: import tuf.roledb",
          "40: import tuf.sig",
          "41: import tuf.exceptions",
          "43: import securesystemslib",
          "44: import securesystemslib.keys",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43: import tuf.encoding.util",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "51:   KEYS.append(securesystemslib.keys.generate_rsa_key(2048))",
          "55: class TestSig(unittest.TestCase):",
          "56:   def setUp(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56: tuf.DEBUG = False # TODO: <~> REMOVE THIS!  This was for a particular test.",
          "58: # An example of a piece of signable metadata that has no signatures yet.",
          "59: SIGNABLE_TIMESTAMP = {",
          "60:     \"signatures\": [",
          "61:       # a valid signature, for reference:",
          "62:       # {\"keyid\": \"8a1c4a3ac2d515dec982ba9910c5fd79b91ae57f625b9cff25d06bf0a61c1758\", \"sig\": \"7dddbfe94d6d80253433551700ea6dfe4171a33f1227a07830e951900b8325d67c3dce6410b9cf55abefa3dfca0b57814a4965c2d6ee60bb0336755cd0557e03\"}",
          "63:     ],",
          "64:     \"signed\": {",
          "65:       \"_type\": \"timestamp\",",
          "66:       \"expires\": \"2030-01-01T00:00:00Z\",",
          "67:       \"meta\": {",
          "68:         \"snapshot.json\": {",
          "69:           \"hashes\": {",
          "70:             \"sha256\": \"6990b6586ed545387c6a51db62173b903a5dff46b17b1bc3fe1e6ca0d0844f2f\"",
          "71:           },",
          "72:           \"length\": 554,",
          "73:           \"version\": 1",
          "74:           }",
          "75:       },",
          "76:       \"spec_version\": \"1.0\",",
          "77:       \"version\": 1",
          "78:     }",
          "79: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "64:   def test_get_signature_status_no_role(self):",
          "67:     # A valid, but empty signature status.",
          "68:     sig_status = tuf.sig.get_signature_status(signable)",
          "69:     self.assertTrue(securesystemslib.formats.SIGNATURESTATUS_SCHEMA.matches(sig_status))",
          "",
          "[Removed Lines]",
          "65:     signable = {'signed': 'test', 'signatures': []}",
          "",
          "[Added Lines]",
          "92:     signable = copy.deepcopy(SIGNABLE_TIMESTAMP)",
          "95:     signable['signatures'] = []",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "83:     # when doing the following action.  Here we know 'signable'",
          "84:     # has only one signature so it's okay.",
          "85:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "88:     tuf.keydb.add_key(KEYS[0])",
          "",
          "[Removed Lines]",
          "86:                                   KEYS[0], signable['signed']))",
          "",
          "[Added Lines]",
          "114:         KEYS[0], tuf.encoding.util.serialize(signable['signed'])))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "91:     self.assertRaises(securesystemslib.exceptions.FormatError,",
          "92:       tuf.sig.get_signature_status, signable, 1)",
          "98:     # Done.  Let's remove the added key(s) from the key database.",
          "99:     tuf.keydb.remove_key(KEYS[0]['keyid'])",
          "102:   def test_get_signature_status_bad_sig(self):",
          "105:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "109:     tuf.keydb.add_key(KEYS[0])",
          "110:     threshold = 1",
          "",
          "[Removed Lines]",
          "94:     # Not allowed to call verify() without having specified a role.",
          "95:     args = (signable, None)",
          "96:     self.assertRaises(securesystemslib.exceptions.Error, tuf.sig.verify, *args)",
          "103:     signable = {'signed' : 'test', 'signatures' : []}",
          "106:                                   KEYS[0], signable['signed']))",
          "107:     signable['signed'] += 'signature no longer matches signed data'",
          "",
          "[Added Lines]",
          "122:     # Not allowed to call verify_signable() without having specified a role.",
          "123:     with self.assertRaises(securesystemslib.exceptions.Error):",
          "124:       tuf.sig.verify_signable(signable, None)",
          "131:     signable = copy.deepcopy(SIGNABLE_TIMESTAMP)",
          "134:         KEYS[0], tuf.encoding.util.serialize(signable['signed'])))",
          "136:     # Alter the metadata so that the signature over it is no longer correct.",
          "137:     signable['signed']['version'] += 1",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "121:     self.assertEqual([], sig_status['untrusted_sigs'])",
          "122:     self.assertEqual([], sig_status['unknown_signing_schemes'])",
          "126:     # Done.  Let's remove the added key(s) from the key database.",
          "127:     tuf.keydb.remove_key(KEYS[0]['keyid'])",
          "",
          "[Removed Lines]",
          "124:     self.assertFalse(tuf.sig.verify(signable, 'Root'))",
          "",
          "[Added Lines]",
          "154:     self.assertFalse(tuf.sig.verify_signable(signable, 'Root'))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "132:   def test_get_signature_status_unknown_signing_scheme(self):",
          "135:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "138:     valid_scheme = KEYS[0]['scheme']",
          "139:     KEYS[0]['scheme'] = 'unknown_signing_scheme'",
          "",
          "[Removed Lines]",
          "133:     signable = {'signed' : 'test', 'signatures' : []}",
          "136:                                   KEYS[0], signable['signed']))",
          "",
          "[Added Lines]",
          "163:     signable = copy.deepcopy(SIGNABLE_TIMESTAMP)",
          "166:         KEYS[0], tuf.encoding.util.serialize(signable['signed'])))",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "153:     self.assertEqual([KEYS[0]['keyid']],",
          "154:                     sig_status['unknown_signing_schemes'])",
          "158:     # Done.  Let's remove the added key(s) from the key database.",
          "159:     KEYS[0]['scheme'] = valid_scheme",
          "",
          "[Removed Lines]",
          "156:     self.assertFalse(tuf.sig.verify(signable, 'root'))",
          "",
          "[Added Lines]",
          "186:     self.assertFalse(tuf.sig.verify_signable(signable, 'root'))",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "165:   def test_get_signature_status_single_key(self):",
          "168:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "171:     threshold = 1",
          "172:     roleinfo = tuf.formats.make_role_metadata(",
          "",
          "[Removed Lines]",
          "166:     signable = {'signed' : 'test', 'signatures' : []}",
          "169:                                   KEYS[0], signable['signed']))",
          "",
          "[Added Lines]",
          "196:     signable = copy.deepcopy(SIGNABLE_TIMESTAMP)",
          "199:         KEYS[0], tuf.encoding.util.serialize(signable['signed'])))",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "184:     self.assertEqual([], sig_status['untrusted_sigs'])",
          "185:     self.assertEqual([], sig_status['unknown_signing_schemes'])",
          "190:     sig_status = tuf.sig.get_signature_status(signable)",
          "192:     self.assertEqual(0, sig_status['threshold'])",
          "193:     self.assertEqual([], sig_status['good_sigs'])",
          "194:     self.assertEqual([], sig_status['bad_sigs'])",
          "197:     self.assertEqual([], sig_status['unknown_signing_schemes'])",
          "199:     # Done.  Let's remove the added key(s) from the key database.",
          "",
          "[Removed Lines]",
          "187:     self.assertTrue(tuf.sig.verify(signable, 'Root'))",
          "189:     # Test for an unknown signature when 'role' is left unspecified.",
          "195:     self.assertEqual([KEYS[0]['keyid']], sig_status['unknown_sigs'])",
          "196:     self.assertEqual([], sig_status['untrusted_sigs'])",
          "",
          "[Added Lines]",
          "217:     self.assertTrue(tuf.sig.verify_signable(signable, 'Root'))",
          "219:     # <~> (remove this comment and add to commit summary)",
          "220:     # The old behavior was wrong, I think.  The key is known -----",
          "221:     # If get_signature_status is not provided authorized keyids and threshold,",
          "222:     # and is also not provided a role to use to determine what keyids and",
          "223:     # threshold are authorized, then we expect any good signature to come back",
          "224:     # as untrustworthy, and any bad signature to come back as a bad signature.",
          "225:     # tuf.DEBUG = True # TODO: <~> Remove this.",
          "227:     # tuf.DEBUG = False",
          "232:     self.assertEqual([], sig_status['unknown_sigs'])",
          "233:     self.assertEqual([KEYS[0]['keyid']], sig_status['untrusted_sigs'])",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "205:   def test_get_signature_status_below_threshold(self):",
          "208:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "211:     tuf.keydb.add_key(KEYS[0])",
          "212:     threshold = 2",
          "",
          "[Removed Lines]",
          "206:     signable = {'signed' : 'test', 'signatures' : []}",
          "209:                                   KEYS[0], signable['signed']))",
          "",
          "[Added Lines]",
          "243:     signable = copy.deepcopy(SIGNABLE_TIMESTAMP)",
          "246:         KEYS[0], tuf.encoding.util.serialize(signable['signed'])))",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "224:     self.assertEqual([], sig_status['untrusted_sigs'])",
          "225:     self.assertEqual([], sig_status['unknown_signing_schemes'])",
          "229:     # Done.  Let's remove the added key(s) from the key database.",
          "230:     tuf.keydb.remove_key(KEYS[0]['keyid'])",
          "",
          "[Removed Lines]",
          "227:     self.assertFalse(tuf.sig.verify(signable, 'Root'))",
          "",
          "[Added Lines]",
          "264:     self.assertFalse(tuf.sig.verify_signable(signable, 'Root'))",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "236:   def test_get_signature_status_below_threshold_unrecognized_sigs(self):",
          "239:     # Two keys sign it, but only one of them will be trusted.",
          "240:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "242:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "245:     tuf.keydb.add_key(KEYS[0])",
          "246:     tuf.keydb.add_key(KEYS[1])",
          "",
          "[Removed Lines]",
          "237:     signable = {'signed' : 'test', 'signatures' : []}",
          "241:                                   KEYS[0], signable['signed']))",
          "243:                                   KEYS[2], signable['signed']))",
          "",
          "[Added Lines]",
          "274:     signable = copy.deepcopy(SIGNABLE_TIMESTAMP)",
          "278:         KEYS[0], tuf.encoding.util.serialize(signable['signed'])))",
          "280:         KEYS[2], tuf.encoding.util.serialize(signable['signed'])))",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "259:     self.assertEqual([], sig_status['untrusted_sigs'])",
          "260:     self.assertEqual([], sig_status['unknown_signing_schemes'])",
          "264:     # Done.  Let's remove the added key(s) from the key database.",
          "265:     tuf.keydb.remove_key(KEYS[0]['keyid'])",
          "",
          "[Removed Lines]",
          "262:     self.assertFalse(tuf.sig.verify(signable, 'Root'))",
          "",
          "[Added Lines]",
          "299:     self.assertFalse(tuf.sig.verify_signable(signable, 'Root'))",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "272:   def test_get_signature_status_below_threshold_unauthorized_sigs(self):",
          "275:     # Two keys sign it, but one of them is only trusted for a different",
          "276:     # role.",
          "277:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "279:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "282:     tuf.keydb.add_key(KEYS[0])",
          "283:     tuf.keydb.add_key(KEYS[1])",
          "",
          "[Removed Lines]",
          "273:     signable = {'signed' : 'test', 'signatures' : []}",
          "278:                                   KEYS[0], signable['signed']))",
          "280:                                   KEYS[1], signable['signed']))",
          "",
          "[Added Lines]",
          "310:     signable = copy.deepcopy(SIGNABLE_TIMESTAMP)",
          "315:         KEYS[0], tuf.encoding.util.serialize(signable['signed'])))",
          "317:         KEYS[1], tuf.encoding.util.serialize(signable['signed'])))",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "298:     self.assertEqual([KEYS[1]['keyid']], sig_status['untrusted_sigs'])",
          "299:     self.assertEqual([], sig_status['unknown_signing_schemes'])",
          "303:     self.assertRaises(tuf.exceptions.UnknownRoleError,",
          "304:                       tuf.sig.get_signature_status, signable, 'unknown_role')",
          "",
          "[Removed Lines]",
          "301:     self.assertFalse(tuf.sig.verify(signable, 'Root'))",
          "",
          "[Added Lines]",
          "338:     self.assertFalse(tuf.sig.verify_signable(signable, 'Root'))",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "316:   def test_check_signatures_no_role(self):",
          "319:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "322:     tuf.keydb.add_key(KEYS[0])",
          "324:     # No specific role we're considering. It's invalid to use the",
          "330:     # Done.  Let's remove the added key(s) from the key database.",
          "331:     tuf.keydb.remove_key(KEYS[0]['keyid'])",
          "",
          "[Removed Lines]",
          "317:     signable = {'signed' : 'test', 'signatures' : []}",
          "320:                                   KEYS[0], signable['signed']))",
          "325:     # function tuf.sig.verify() without a role specified because",
          "326:     # tuf.sig.verify() is checking trust, as well.",
          "327:     args = (signable, None)",
          "328:     self.assertRaises(securesystemslib.exceptions.Error, tuf.sig.verify, *args)",
          "",
          "[Added Lines]",
          "354:     signable = copy.deepcopy(SIGNABLE_TIMESTAMP)",
          "357:         KEYS[0], tuf.encoding.util.serialize(signable['signed'])))",
          "362:     # function tuf.sig.verify_signable() without a role specified because",
          "363:     # tuf.sig.verify_signable() is checking trust, as well.",
          "364:     with self.assertRaises(securesystemslib.exceptions.Error):",
          "365:       tuf.sig.verify_signable(signable, None)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "335:   def test_verify_single_key(self):",
          "337:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "340:     tuf.keydb.add_key(KEYS[0])",
          "341:     threshold = 1",
          "",
          "[Removed Lines]",
          "336:     signable = {'signed' : 'test', 'signatures' : []}",
          "338:                                   KEYS[0], signable['signed']))",
          "",
          "[Added Lines]",
          "373:     signable = copy.deepcopy(SIGNABLE_TIMESTAMP)",
          "375:         KEYS[0], tuf.encoding.util.serialize(signable['signed'])))",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "343:         [KEYS[0]['keyid']], threshold)",
          "344:     tuf.roledb.add_role('Root', roleinfo)",
          "347:     # False otherwise.",
          "350:     # Done.  Let's remove the added key(s) from the key database.",
          "351:     tuf.keydb.remove_key(KEYS[0]['keyid'])",
          "",
          "[Removed Lines]",
          "346:     # This will call verify() and return True if 'signable' is valid,",
          "348:     self.assertTrue(tuf.sig.verify(signable, 'Root'))",
          "",
          "[Added Lines]",
          "383:     # This will call verify_signable() and return True if 'signable' is valid,",
          "385:     self.assertTrue(tuf.sig.verify_signable(signable, 'Root'))",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "357:   def test_verify_unrecognized_sig(self):",
          "360:     # Two keys sign it, but only one of them will be trusted.",
          "361:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "363:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "366:     tuf.keydb.add_key(KEYS[0])",
          "367:     tuf.keydb.add_key(KEYS[1])",
          "",
          "[Removed Lines]",
          "358:     signable = {'signed' : 'test', 'signatures' : []}",
          "362:                                   KEYS[0], signable['signed']))",
          "364:                                   KEYS[2], signable['signed']))",
          "",
          "[Added Lines]",
          "395:     signable = copy.deepcopy(SIGNABLE_TIMESTAMP)",
          "399:         KEYS[0], tuf.encoding.util.serialize(signable['signed'])))",
          "401:         KEYS[2], tuf.encoding.util.serialize(signable['signed'])))",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "370:         [KEYS[0]['keyid'], KEYS[1]['keyid']], threshold)",
          "371:     tuf.roledb.add_role('Root', roleinfo)",
          "375:     # Done.  Let's remove the added key(s) from the key database.",
          "376:     tuf.keydb.remove_key(KEYS[0]['keyid'])",
          "",
          "[Removed Lines]",
          "373:     self.assertFalse(tuf.sig.verify(signable, 'Root'))",
          "",
          "[Added Lines]",
          "410:     self.assertFalse(tuf.sig.verify_signable(signable, 'Root'))",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "431:   def test_signable_has_invalid_format(self):",
          "433:     # 'signable' must be of the form: {'signed': , 'signatures': [{}]}.",
          "434:     # Object types are checked as well.",
          "436:     args = (signable['not_signed'], KEYS[0])",
          "437:     self.assertRaises(securesystemslib.exceptions.FormatError, tuf.sig.get_signature_status, *args)",
          "439:     # 'signatures' value must be a list.  Let's try a dict.",
          "441:     args = (signable['signed'], KEYS[0])",
          "442:     self.assertRaises(securesystemslib.exceptions.FormatError, tuf.sig.get_signature_status, *args)",
          "",
          "[Removed Lines]",
          "384:   def test_generate_rsa_signature(self):",
          "385:     signable = {'signed' : 'test', 'signatures' : []}",
          "387:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "388:                                   KEYS[0], signable['signed']))",
          "390:     self.assertEqual(1, len(signable['signatures']))",
          "391:     signature = signable['signatures'][0]",
          "392:     self.assertEqual(KEYS[0]['keyid'], signature['keyid'])",
          "394:     returned_signature = tuf.sig.generate_rsa_signature(signable['signed'], KEYS[0])",
          "395:     self.assertTrue(securesystemslib.formats.SIGNATURE_SCHEMA.matches(returned_signature))",
          "397:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "398:                                   KEYS[1], signable['signed']))",
          "400:     self.assertEqual(2, len(signable['signatures']))",
          "401:     signature = signable['signatures'][1]",
          "402:     self.assertEqual(KEYS[1]['keyid'], signature['keyid'])",
          "406:   def test_may_need_new_keys(self):",
          "407:     # One untrusted key in 'signable'.",
          "408:     signable = {'signed' : 'test', 'signatures' : []}",
          "410:     signable['signatures'].append(securesystemslib.keys.create_signature(",
          "411:                                   KEYS[0], signable['signed']))",
          "413:     tuf.keydb.add_key(KEYS[1])",
          "414:     threshold = 1",
          "415:     roleinfo = tuf.formats.make_role_metadata(",
          "416:         [KEYS[1]['keyid']], threshold)",
          "417:     tuf.roledb.add_role('Root', roleinfo)",
          "419:     sig_status = tuf.sig.get_signature_status(signable, 'Root')",
          "421:     self.assertTrue(tuf.sig.may_need_new_keys(sig_status))",
          "424:     # Done.  Let's remove the added key(s) from the key database.",
          "425:     tuf.keydb.remove_key(KEYS[1]['keyid'])",
          "427:     # Remove the roles.",
          "428:     tuf.roledb.remove_role('Root')",
          "432:     # get_signature_status() and verify() validate 'signable' before continuing.",
          "435:     signable = {'not_signed' : 'test', 'signatures' : []}",
          "440:     signable = {'signed' : 'test', 'signatures' : {}}",
          "",
          "[Added Lines]",
          "424:     # get_signature_status() and verify_signable() verify 'signable' before",
          "425:     # continuing.",
          "428:     signable = {'not_signed' : {'test'}, 'signatures' : []}",
          "433:     signable = {'signed' : {'type': 'some_role'}, 'signatures' : {}}",
          "",
          "---------------"
        ],
        "tuf/client/updater.py||tuf/client/updater.py": [
          "File: tuf/client/updater.py -> tuf/client/updater.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "139: import tuf.roledb",
          "140: import tuf.sig",
          "141: import tuf.exceptions",
          "143: import securesystemslib.hash",
          "144: import securesystemslib.keys",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "142: import tuf.encoding.util",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "833:       # Load the file.  The loaded object should conform to",
          "834:       # 'tuf.formats.SIGNABLE_SCHEMA'.",
          "835:       try:",
          "837:             metadata_filepath)",
          "839:       # Although the metadata file may exist locally, it may not",
          "840:       # be a valid json file.  On the next refresh cycle, it will be",
          "841:       # updated as required.  If Root if cannot be loaded from disk",
          "842:       # successfully, an exception should be raised by the caller.",
          "844:         return",
          "848:       # Extract the 'signed' role object from 'metadata_signable'.",
          "849:       metadata_object = metadata_signable['signed']",
          "",
          "[Removed Lines]",
          "836:         metadata_signable = securesystemslib.util.load_json_file(",
          "843:       except securesystemslib.exceptions.Error:",
          "846:       tuf.formats.check_signable_object_format(metadata_signable)",
          "",
          "[Added Lines]",
          "837:         metadata_signable = tuf.encoding.util.deserialize_file(",
          "844:       except (securesystemslib.exceptions.Error, tuf.exceptions.Error):",
          "847:       # JUST DEBUGGING. Get rid of the try/except again afterwards.",
          "848:       try:",
          "849:         tuf.formats.check_signable_object_format(metadata_signable)",
          "850:       except securesystemslib.exceptions.FormatError:",
          "851:         import pdb; pdb.set_trace()",
          "852:         print('debugging')",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1134:     latest_root_metadata_file = self._get_metadata_file(",
          "1135:         'root', 'root.json', DEFAULT_ROOT_UPPERLENGTH, None)",
          "1141:     next_version = current_root_metadata['version'] + 1",
          "",
          "[Removed Lines]",
          "1137:     latest_root_metadata = securesystemslib.util.load_json_string(",
          "1138:         latest_root_metadata_file.read().decode('utf-8'))",
          "",
          "[Added Lines]",
          "1144:     latest_root_metadata = tuf.encoding.util.deserialize(",
          "1145:         latest_root_metadata_file.read())",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1402:       None.",
          "1403:     \"\"\"",
          "1407:     try:",
          "1410:     except Exception as exception:",
          "1411:       raise tuf.exceptions.InvalidMetadataJSONError(exception)",
          "",
          "[Removed Lines]",
          "1405:     metadata = metadata_file_object.read().decode('utf-8')",
          "1408:       metadata_signable = securesystemslib.util.load_json_string(metadata)",
          "",
          "[Added Lines]",
          "1412:     metadata = metadata_file_object.read()",
          "1415:       metadata_signable = tuf.encoding.util.deserialize(metadata)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1423:     # metadata.",
          "1425:     # Verify the signature on the downloaded metadata object.",
          "1427:         self.repository_name)",
          "1429:     if not valid:",
          "",
          "[Removed Lines]",
          "1426:     valid = tuf.sig.verify(metadata_signable, metadata_role,",
          "",
          "[Added Lines]",
          "1433:     valid = tuf.sig.verify_signable(metadata_signable, metadata_role,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1487:         # Verify 'file_object' according to the callable function.",
          "1488:         # 'file_object' is also verified if decompressed above (i.e., the",
          "1489:         # uncompressed version).",
          "1493:         # Determine if the specification version number is supported.  It is",
          "1494:         # assumed that \"spec_version\" is in (major.minor.fix) format, (for",
          "",
          "[Removed Lines]",
          "1490:         metadata_signable = \\",
          "1491:           securesystemslib.util.load_json_string(file_object.read().decode('utf-8'))",
          "",
          "[Added Lines]",
          "1497:         metadata_signable = tuf.encoding.util.deserialize(file_object.read())",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1570:     current_root_role = current_root_metadata['roles'][rolename]",
          "1572:     # Verify next metadata with current keys/threshold",
          "1574:         current_root_role['threshold'], current_root_role['keyids'])",
          "1576:     if not valid:",
          "",
          "[Removed Lines]",
          "1573:     valid = tuf.sig.verify(next_root_metadata, rolename, self.repository_name,",
          "",
          "[Added Lines]",
          "1579:     valid = tuf.sig.verify_signable(",
          "1580:         next_root_metadata, rolename, self.repository_name,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1766:     # Note that the 'move' method comes from securesystemslib.util's TempFile class.",
          "1767:     # 'metadata_file_object' is an instance of securesystemslib.util.TempFile.",
          "1768:     metadata_signable = \\",
          "1771:     metadata_file_object.move(current_filepath)",
          "",
          "[Removed Lines]",
          "1769:       securesystemslib.util.load_json_string(metadata_file_object.read().decode('utf-8'))",
          "",
          "[Added Lines]",
          "1776:       tuf.encoding.util.deserialize(metadata_file_object.read())",
          "",
          "---------------"
        ],
        "tuf/developer_tool.py||tuf/developer_tool.py": [
          "File: tuf/developer_tool.py -> tuf/developer_tool.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: import tuf.log",
          "47: import tuf.repository_lib as repo_lib",
          "48: import tuf.repository_tool",
          "50: import securesystemslib",
          "51: import securesystemslib.util",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "49: import tuf.encoding.util",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "471:   # non-partial write()",
          "472:   else:",
          "474:       metadata['version'] = metadata['version'] + 1",
          "475:       signable = repo_lib.sign_metadata(metadata, roleinfo['signing_keyids'],",
          "476:           metadata_filename, repository_name)",
          "",
          "[Removed Lines]",
          "473:     if tuf.sig.verify(signable, rolename, repository_name):",
          "",
          "[Added Lines]",
          "474:     if tuf.sig.verify_signable(signable, rolename, repository_name):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "478:   # Write the metadata to file if contains a threshold of signatures.",
          "479:   signable['signatures'].extend(roleinfo['signatures'])",
          "482:     repo_lib._remove_invalid_and_duplicate_signatures(signable, repository_name)",
          "483:     filename = repo_lib.write_metadata_file(signable, metadata_filename,",
          "484:         metadata['version'], False)",
          "",
          "[Removed Lines]",
          "481:   if tuf.sig.verify(signable, rolename, repository_name) or write_partial:",
          "",
          "[Added Lines]",
          "482:   if tuf.sig.verify_signable(signable, rolename, repository_name) or write_partial:",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "832:   # Load the project's metadata.",
          "833:   targets_metadata_path = os.path.join(project_directory, metadata_directory,",
          "834:       project_filename)",
          "836:   tuf.formats.check_signable_object_format(signable)",
          "837:   targets_metadata = signable['signed']",
          "",
          "[Removed Lines]",
          "835:   signable = securesystemslib.util.load_json_file(targets_metadata_path)",
          "",
          "[Added Lines]",
          "836:   signable = tuf.encoding.util.deserialize_file(targets_metadata_path)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "898:         continue",
          "900:       signable = None",
          "903:       # Strip the prefix from the local working copy, it will be added again",
          "904:       # when the targets metadata is written to disk.",
          "",
          "[Removed Lines]",
          "901:       signable = securesystemslib.util.load_json_file(metadata_path)",
          "",
          "[Added Lines]",
          "902:       signable = tuf.encoding.util.deserialize_file(metadata_path)",
          "",
          "---------------"
        ],
        "tuf/encoding/asn1_convert.py||tuf/encoding/asn1_convert.py": [
          "File: tuf/encoding/asn1_convert.py -> tuf/encoding/asn1_convert.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: import tuf.exceptions",
          "40: recursion_level = -1",
          "41: def debug(msg):",
          "42:   if DEBUG_MODE:",
          "",
          "[Removed Lines]",
          "38: # DEBUG ONLY; remove.",
          "39: DEBUG_MODE = True",
          "",
          "[Added Lines]",
          "38: # DEBUG ONLY; remove.  These messages are low level and frequent enough that",
          "39: # they're not even appropriate for logger.debug(), so I have this here until",
          "40: # I'm satisfied with the behavior of this module.",
          "41: # TODO: Add a few logger messages at higher level (success and failure of",
          "42: # conversions, probably at the end to_asn1 and from_asn1.)",
          "43: DEBUG_MODE = False",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "664:         'to convert subcomponent named \"' + element_name_asn1 + '\", of type ' +",
          "665:         str(element_type))",
          "667:     element_asn1 = to_asn1(data[element_name_py], element_type)",
          "669:     asn1_obj[element_name_asn1] = element_asn1",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "671:     if element_type is None:",
          "672:       import pdb; pdb.set_trace()",
          "673:       print('debugging')",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "742:           and convert to ASN.1 and back, you will get a dict back that uses",
          "743:           strings for those indices instead.  There are probably a few quirky",
          "744:           edge cases like this to keep in mind.",
          "745:   \"\"\"",
          "746:   debug('from_asn1() called to convert from ' + str(type(asn1_obj)) +",
          "747:       '. asn1crypto data: ' + str(asn1_obj))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:   Cases addressed here: asn1_obj is:",
          "755:     Void",
          "756:     Primitive",
          "757:     List-like to be converted to list",
          "758:     List-like to be converted to dict",
          "759:     Struct-like",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "819:   elif is_structlike_datatype(type(asn1_obj)):",
          "820:     debug('Converting to struct-like dict from ' + str(type(asn1_obj)))",
          "821:     data = _structlike_dict_from_asn1(asn1_obj)",
          "822:     debug(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "835:     # In the case of converting from a Sequence/Set, we convert back to a dict,",
          "836:     # assuming that the structure of the dict should be the same as the",
          "837:     # structure of the ASN.1 object.",
          "",
          "---------------"
        ],
        "tuf/encoding/asn1_metadata_definitions.py||tuf/encoding/asn1_metadata_definitions.py": [
          "File: tuf/encoding/asn1_metadata_definitions.py -> tuf/encoding/asn1_metadata_definitions.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "557: # # Or we could define the following, instead of the above four Envelope classes.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "554: class AnyMetadata(ac.Choice):",
          "555:   _alternatives = [",
          "556:       ('root', RootMetadata),",
          "557:       ('timestamp', TimestampMetadata),",
          "558:       ('snapshot', SnapshotMetadata),",
          "559:       ('targets', TargetsMetadata)]",
          "561: class AnyEnvelope(ac.Choice):",
          "562:   _alternatives = [",
          "563:       ('root', RootEnvelope),",
          "564:       ('timestamp', TimestampEnvelope),",
          "565:       ('snapshot', SnapshotEnvelope),",
          "566:       ('targets', TargetsEnvelope)]",
          "568: class SomeType(ac.Choice):",
          "569:   _alternatives = [",
          "570:       ('int', ac.Integer),",
          "571:       ('oct', ac.OctetString)]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "567: #   _fields = [",
          "568: #       ('signatures', Signatures),",
          "569: #       ('signed', AnyMetadata)]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "589: KNOWN_TYPE_STRING_MAPPINGS = {",
          "590:     'root': RootMetadata,",
          "591:     'timestamp': TimestampMetadata,",
          "592:     'snapshot': SnapshotMetadata,",
          "593:     'targets': TargetsMetadata}",
          "",
          "---------------"
        ],
        "tuf/encoding/metadata_definitions.asn1||tuf/encoding/metadata_definitions.asn1": [
          "File: tuf/encoding/metadata_definitions.asn1 -> tuf/encoding/metadata_definitions.asn1",
          "--- Hunk 1 ---",
          "[Context before]",
          "228:     expires             VisibleString,  -- date&time, UTC, as a UNIX timestamp",
          "229:     version             IntegerNatural,",
          "232:     -- What these should probably be called instead:",
          "234:   }",
          "237:     filename            VisibleString,",
          "238:     version             IntegerNatural",
          "239:     -- Older versions of TUF used a hash here instead of a version number.",
          "",
          "[Removed Lines]",
          "231:     meta                SET OF RoleInfo                 -- unordered set",
          "233:     -- role-infos          SET OF RoleInfo",
          "236:   RoleInfo ::= SEQUENCE {",
          "",
          "[Added Lines]",
          "231:     meta                SET OF RoleVersion                 -- unordered set",
          "233:     -- role-versions    SET OF RoleVersion",
          "236:   RoleVersion ::= SEQUENCE {",
          "",
          "---------------"
        ],
        "tuf/encoding/util.py||tuf/encoding/util.py": [
          "File: tuf/encoding/util.py -> tuf/encoding/util.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/env python",
          "3: \"\"\"",
          "4: <Program Name>",
          "5:   util.py",
          "7: <Copyright>",
          "8:   See LICENSE-MIT OR LICENSE for licensing information.",
          "10: <Purpose>",
          "11:   tuf.encoding.util performs serialization and deserialization of JSON and",
          "12:   ASN.1/DER, using existing functions in securesystemslib.util for JSON and",
          "13:   asn1crypto for ASN.1.",
          "15:   Provides:",
          "16:     serialize()",
          "17:     deserialize_der()",
          "18:     deserialize()",
          "19:     deserialize_der_file()",
          "20:     deserialize_file()",
          "21: \"\"\"",
          "23: # Support some Python 3 style and functionality in Python 2 (example: print())",
          "24: from __future__ import print_function",
          "25: from __future__ import absolute_import",
          "26: from __future__ import division",
          "27: from __future__ import unicode_literals",
          "29: import logging",
          "31: import six",
          "32: import asn1crypto.core",
          "34: import securesystemslib",
          "35: import securesystemslib.formats",
          "36: import securesystemslib.util",
          "37: import tuf",
          "38: import tuf.formats",
          "39: import tuf.encoding.asn1_convert as asn1_convert",
          "40: import tuf.encoding.asn1_metadata_definitions as asn1_defs",
          "42: # See 'log.py' to learn how logging is handled in TUF.",
          "43: logger = logging.getLogger('tuf_util')",
          "46: def serialize(obj):",
          "47:   \"\"\"",
          "48:   <Purpose>",
          "49:     Encode an asn1crypto object or JSON-compatible dictionary as bytes, in the",
          "50:     serialized form of that object:",
          "51:       If obj is an asn1crypto object, it is converted to ASN.1/DER bytes.",
          "52:       If obj is a dictionary, it is converted into UTF-8-encoded JSON bytes.",
          "54:     Wrapper for 'securesystemslib.formats.encode_canonical()' and the",
          "55:     asn1crypto method 'dump()'.",
          "57:   <Arguments>",
          "58:     obj",
          "59:       an asn1crypto object or JSON-compatible dictionary.",
          "60:       # TODO: Consider defining what makes a dict JSON-compatible somewhere and",
          "61:       #       referencing that here....",
          "63:   <Exceptions>",
          "64:     tuf.exceptions.Error if both attempts to deserialize from JSON and DER fail.",
          "66:   <Returns>",
          "67:     If given JSON data, returns a dictionary.",
          "68:     Otherwise, if given ASN.1/DER data, returns an asn1crypto object.",
          "69:   \"\"\"",
          "71:   if isinstance(obj, asn1crypto.core.Asn1Value):",
          "72:     # If the given object is an asn1crypto object, then it has a dump() method",
          "73:     # that returns the serialized DER bytes that represent the ASN.1 object.",
          "74:     return obj.dump()",
          "76:   elif isinstance(obj, dict):",
          "77:     # If the given object is instead a dictionary, assume it is a dictionary",
          "78:     # that can be converted to canonicalized JSON and encoded as UTF-8.",
          "79:     return securesystemslib.formats.encode_canonical(obj).encode('utf-8')",
          "81:   else:",
          "82:     raise tuf.exceptions.FormatError(",
          "83:         'Received an object that appears to be neither an asn1crypto object '",
          "84:         'nor a dictionary.')",
          "86: # def serialize_json(dictionary):",
          "87: #   return securesystemslib.formats.encode_canonical(dictionary).encode('utf-8')",
          "93: def deserialize(data, convert=True):",
          "94:   \"\"\"",
          "95:   <Purpose>",
          "96:     bytes encoding JSON or ASN.1/DER -> dictionary or asn1crypto object",
          "99:     Wrapper for deserialize_json and deserialize_der. Also see docstrings there.",
          "101:     Deserializes the given bytes of ASN.1/DER or JSON/UTF-8.",
          "102:     Produces an asn1crypto object (from ASN.1) or dictionary object (from JSON).",
          "104:     Tries JSON UTF-8 first.  If that fails, tries ASN.1 DER.",
          "106:   <Arguments>",
          "107:     data",
          "108:       bytes.  Data in either ASN.1/DER or JSON/UTF8.",
          "110:   <Exceptions>",
          "111:     tuf.exceptions.Error if both attempts to deserialize from JSON and DER fail.",
          "113:   <Returns>",
          "114:     If given JSON data, returns a dictionary.",
          "115:     Otherwise, if given ASN.1/DER data, returns an asn1crypto object.",
          "117:   \"\"\"",
          "118:   exception_msgs = []",
          "121:   # Try JSON first.",
          "122:   try:",
          "123:     deserialized = deserialize_json(data)",
          "125:   except tuf.exceptions.InvalidMetadataJSONError as e:",
          "126:     exception_msgs.append(str(e))",
          "128:   else:",
          "129:     return deserialized",
          "132:   # Try ASN.1 second.",
          "133:   try:",
          "134:     deserialized = deserialize_der(data)",
          "136:   except Exception as e:",
          "137:     # TODO: <~> Refine expected errors. Catch only expected DER errors...?",
          "138:     exception_msgs.append(str(e))",
          "139:     # TODO: Create or choose a better error class for the below.",
          "140:     raise tuf.exceptions.Error(",
          "141:         'Unable to deserialize given data as JSON in UTF-8 or as ASN.1 in DER. '",
          "142:         'Exceptions follow: ' + str(exception_msgs))",
          "144:   else:",
          "145:     return deserialized",
          "151: def deserialize_file(filepath, convert=True):",
          "152:   \"\"\"",
          "153:   <Purpose>",
          "154:     Deserialize a JSON or ASN.1/DER object from a file containing the object.",
          "155:     Tries JSON first, and if that fails, tries ASN.1.",
          "157:     Wrapper for deserialize_json_file and deserialize_der_file. Also see",
          "158:     docstrings there.",
          "160:     Produces an asn1crypto object (from ASN.1) or dictionary object (from JSON).",
          "162:   <Arguments>",
          "163:     filepath",
          "164:       The path of a file containing data in either ASN.1/DER or JSON/UTF8.",
          "166:     convert",
          "167:       boolean, optional.  If True, converts ASN.1/DER data into JSON-compatible",
          "168:       dictionaries, the old TUF internal format, matching the specification.",
          "169:       Note that if this is done and there are signatures in the given data,",
          "170:       those signatures will still be signed over whatever format they were",
          "171:       signed over, and you should make sure to check them over the right format.",
          "173:       # TODO: Consider marking signatures here, if the file given has a",
          "174:       #       'signatures' element at the top level, and elements under it,",
          "175:       #       by adding an 'over_der' field to each signature, and adding a",
          "176:       #       tuf.formats.SIGNATURE_SCHEMA that takes over for",
          "177:       #       securesystemslib.formats.SIGNATURE_SCHEMA and includes an optional",
          "178:       #       element 'over_der'.  All uses of",
          "179:       #       securesystemslib.formats.SIGNATURE_SCHEMA in TUF should then be",
          "180:       #       switched.",
          "182:   <Exceptions>",
          "183:     tuf.exceptions.FormatError:",
          "184:       if 'filepath' is improperly formatted.",
          "186:     securesystemslib.exceptions.FormatError:",
          "187:       if 'filepath' is improperly formatted according to securesystemslib but",
          "188:       not according to tuf (unexpected, may occur if code changes).",
          "190:     tuf.exceptions.Error:",
          "191:       if 'filepath' cannot be deserialized to a Python object.",
          "193:     IOError:",
          "194:       if file manipulation fails due to IO errors.",
          "196:     tuf.exceptions.Error:",
          "197:       if both attempts to deserialize from JSON and DER fail",
          "199:   <Returns>",
          "200:     If given JSON data, returns a dictionary.",
          "201:     Otherwise, if given ASN.1/DER data, returns an asn1crypto object.",
          "202:   \"\"\"",
          "204:   # Making sure that the format of 'filepath' is a path string.",
          "205:   # tuf.FormatError is raised on incorrect format.",
          "206:   securesystemslib.formats.PATH_SCHEMA.check_match(filepath)",
          "208:   exception_msgs = []",
          "210:   deserialized = None",
          "212:   # Try JSON first.  (Quite a bit less work while blind.)",
          "213:   try:",
          "214:     deserialized = deserialize_json_file(filepath) # securesystemslib.util.load_json_file(filepath)",
          "216:   except securesystemslib.exceptions.Error as e:",
          "217:     exception_msgs.append(str(e))",
          "220:   if deserialized is None:",
          "221:     # Try ASN.1/DER second.",
          "222:     try:",
          "223:       deserialized = deserialize_der_file(filepath)",
          "225:     except (tuf.exceptions.Error, securesystemslib.exceptions.Error) as e:",
          "226:       exception_msgs.append(str(e))",
          "227:       raise tuf.exceptions.Error(",
          "228:           'Unable to deserialize given data as JSON in UTF-8 or as ASN.1 in '",
          "229:           'DER.  Exceptions follow: ' + str(exception_msgs))",
          "232:   logger.debug('Successfully read data from filepath ' + str(filepath))",
          "233:   return deserialized",
          "239: def deserialize_json_file(filepath):",
          "240:   \"\"\"",
          "241:   <Purpose>",
          "242:     Read in a utf-8-encoded JSON file and return a dictionary object with the",
          "243:     parsed JSON data.",
          "245:     Currently just uses securesystemslib.util.load_json_file.",
          "247:   <Arguments>",
          "248:     filepath:",
          "249:       Path of DER file.",
          "251:   <Exceptions>",
          "252:     tuf.exceptions.Error:",
          "253:       if 'filepath' cannot be deserialized to a Python object.",
          "255:     IOError:",
          "256:       if file manipulation fails due to IO errors.",
          "258:     tuf.exceptions.Error:",
          "259:       if the contents of filepath cannot be deserialized to a Python object.",
          "261:   <Side Effects>",
          "262:     None.",
          "264:   <Return>",
          "265:     An asn1crypto object deserialized from the DER data in the file whose path",
          "266:     was provided,",
          "267:   \"\"\"",
          "268:   return securesystemslib.util.load_json_file(filepath)",
          "274: def deserialize_der_file(filepath):",
          "275:   \"\"\"",
          "276:   <Purpose>",
          "277:     Read in an ASN.1/DER file and return an asn1crypto object containing the",
          "278:     translated contents of the DER file.",
          "280:   <Arguments>",
          "281:     filepath:",
          "282:       Path of DER file.",
          "284:   <Exceptions>",
          "285:     tuf.exceptions.Error:",
          "286:       if 'filepath' cannot be deserialized to a Python object.",
          "288:     IOError:",
          "289:       if file manipulation fails due to IO errors.",
          "291:     tuf.exceptions.Error:",
          "292:       if the contents of filepath cannot be deserialized to a Python object.",
          "294:   <Side Effects>",
          "295:     None.",
          "297:   <Return>",
          "298:     An asn1crypto object deserialized from the DER data in the file whose path",
          "299:     was provided,",
          "301:     # NO: Trying something different",
          "302:     # #  in TUF's standard format, conforming to",
          "303:     # # tuf.formats.SIGNABLE_SCHEMA, where the 'signed' entry matches",
          "304:     # # tuf.formats.ANYROLE_SCHEMA (though conversion of the Mirrors role is not",
          "305:     # # supported).",
          "306:     # # The signatures contained in the returned dictionary (the 'signatures'",
          "307:     # # entry), if any, will have been unchanged. If, for example, the signatures",
          "308:     # # were over a DER object, they will remain that way, even though the 'signed'",
          "309:     # # portion will no longer be in DER.",
          "310:   \"\"\"",
          "312:   # Making sure that the format of 'filepath' is a path string.",
          "313:   # tuf.FormatError is raised on incorrect format.",
          "314:   securesystemslib.formats.PATH_SCHEMA.check_match(filepath)",
          "316:   logger.debug('Reading file ' + str(filepath))",
          "317:   with open(filepath, 'rb') as fobj:",
          "318:     data = fobj.read()",
          "320:   # Decode the DER into an abstract asn1crypto ASN.1 representation of its data,",
          "323:   # NO: trying something new.",
          "324:   # # then convert that into a basic Python dictionary representation of the",
          "325:   # # data within.",
          "327:   return deserialize_der(data)",
          "333: def deserialize_json(data):",
          "334:   \"\"\"",
          "335:   <Purpose>",
          "336:     Deserializes the given bytes of utf-8-encoded JSON into a dictionary.",
          "338:   <Arguments>",
          "339:     data",
          "340:       bytes.  JSON data encoded as utf-8.",
          "342:   <Exceptions>",
          "343:     tuf.exceptions.InvalidMetadataJSONError",
          "344:       if unable to decode data as utf-8, or unable to parse resulting string",
          "345:       as valid JSON.",
          "347:   <Returns>",
          "348:     Deserialized object, as a dictionary.",
          "349:   \"\"\"",
          "351:   # TODO: Format check on data.",
          "353:   try:",
          "354:     deserialized = securesystemslib.util.load_json_string(data.decode('utf-8'))",
          "356:   except (",
          "357:       securesystemslib.exceptions.InvalidMetadataJSONError,   # never raised?",
          "358:       securesystemslib.exceptions.Error,        # takes the place of the former",
          "359:       UnicodeDecodeError) as e:                 # if not valid utf-8",
          "360:     # raise tuf.exceptions.InvalidMetadataJSONError('Cannot parse as JSON+utf8.') from e   # Python3-only",
          "361:     raise tuf.exceptions.InvalidMetadataJSONError(str(e))",
          "363:     # NOTE: Unit testing should try \"\\xfc\\xa1\\xa1\\xa1\\xa1\\xa1\", which is not",
          "364:     #       valid utf-8, but is valid octet string.",
          "366:   else:",
          "367:     return deserialized",
          "373: def deserialize_der(data, datatype=None):",
          "374:   \"\"\"",
          "375:   <Purpose>",
          "376:     Deserializes the given bytes of ASN.1/DER into an asn1crypto object.",
          "378:     Can be called without the datatype of the object to be deserialized known,",
          "379:     but will attempt to guess several types in order to avoid returning the",
          "380:     result of a blind conversion (a conversion that does not know the expected",
          "381:     datatype).",
          "383:     See docstring of tuf.encoding.asn1_convert.asn1_from_der() to have the",
          "384:     difference explained.",
          "386:     If datatype is None, attempts to avoid blind conversion by trying to",
          "387:     interpret the given data as, first, role metadata, then, second, a signing",
          "388:     envelope around role metadata.",
          "390:     If both fail, returns the results of the blind conversion.",
          "392:     This function will validate its output: whatever deserialized data it",
          "393:     produces will only be returned if serializing that data produces the",
          "394:     original bytes (variable 'data').",
          "396:   <Arguments>",
          "397:     data",
          "398:       bytes.  Data in ASN.1/DER format.",
          "400:     datatype  (optional)",
          "401:       A subclass of asn1crypto.core.Asn1Value, the type of data expected to",
          "402:       be returned.",
          "404:   <Exceptions>",
          "405:     tuf.exceptions.ASN1ConversionError",
          "406:       if a deserialized object is produced, but that object does not produce",
          "407:       the original bytes ('data') when serialized again.",
          "409:     asn1crypto errors or tuf.exceptions.ASN1ConversionError",
          "410:       if DER deserialization fails otherwise.",
          "411:     # TODO: delineate the above errors?",
          "413:   <Returns>",
          "414:     Deserialized object, as an asn1crypto object.",
          "415:   \"\"\"",
          "417:   # TODO: Format check on data.",
          "419:   deserialized = None",
          "421:   # If we were told the datatype, then convert expecting that type.",
          "422:   if datatype is not None:",
          "424:     if not issubclass(datatype, asn1crypto.core.Asn1Value):",
          "425:       raise tuf.exceptions.FormatError(",
          "426:           'Received a datatype that was not an asn1crypto class.')",
          "428:     deserialized = asn1_convert.asn1_from_der(data, datatype)",
          "431:   else:      # datatype is None, so we must be clever",
          "433:     # ABANDONED STRATEGY 1:  No: do not just blind load.",
          "434:     # # If we were NOT told the datatype, get creative. Attempt a blind conversion,",
          "435:     # # not knowing what datatype the encoded object is (the data definition).  See",
          "436:     # # asn1_from_der docstring for the differences.",
          "437:     # deserialized = asn1_convert.asn1_from_der(data)",
          "439:     # Given the result of the blind conversion, attempt to deduce the type from",
          "440:     # the converted data in a few ways....",
          "442:     # (It would be nice to look for a '_type' field in the data or a '_type'",
          "443:     #  field under the object in a 'signed' field in the data, but we can't,",
          "444:     #  because, after a blind conversion, we don't have field names.)",
          "445:     # # if '_type' in deserialized:",
          "446:     # #   datatype = interpret_datatype(deserialized['_type'].native)",
          "447:     # # else if 'signed' in deserialized and '_type' in deserialized['signed']:",
          "448:     # #   datatype = interpret_datatype(deserialized['signed']['_type'].native)",
          "451:     # ABANDONED STRATEGY 2: No.  Do not try creating an additional level of",
          "452:     #                       Choice on top of the objects. This has to be part of",
          "453:     #                       the original DER we're now loading. Try AnyEnvelope",
          "454:     #                       and AnyMetadata.  These are guaranteed to have a",
          "455:     #                       '_type' field somewhere that defines their metadata",
          "456:     #                       type.",
          "457:     # asn1_obj = None",
          "458:     # datatype_str = None",
          "459:     # is_envelope = None",
          "460:     #",
          "461:     # try:",
          "462:     #   asn1_obj = asn1_convert.asn1_from_der(data, asn1_defs.AnyEnvelope)",
          "463:     #   datatype_str = asn1_obj.native['signed']['_type']",
          "464:     #   is_envelope = True",
          "465:     #",
          "466:     # except:",
          "467:     #   # TODO: Refine the expected exceptions from the above.",
          "468:     #   # It looks like ValueError, btw, when unexpected structures are encountered.",
          "469:     #   pass",
          "470:     #",
          "471:     # # Note that we check for the success of the parsing of datatype_str as well,",
          "472:     # # since asn1crypto will still provide an object in some circumstances if the",
          "473:     # # parsing failed to produce a coherent object.  Trying to use asn1_obj.native",
          "474:     # # or asn1_obj.debug() is the easiest way to check.",
          "475:     # # I think this is related to a kind of lazy parsing in which some checks are",
          "476:     # # skipped for speed....",
          "477:     # if asn1_obj is None or datatype_str is None or is_envelope is None:",
          "478:     #   try:",
          "479:     #     asn1_obj = asn1_convert.asn1_from_der(data, asn1_defs.AnyMetadata)",
          "480:     #     datatype_str = asn1_obj.native['_type']",
          "481:     #     is_envelope = False",
          "482:     #",
          "483:     #   except:",
          "484:     #     # TODO: Refine the expected exceptions from the above.",
          "485:     #     pass",
          "486:     #",
          "487:     # # If neither of those succeeded, give up and return the results of a blind",
          "488:     # # conversion.",
          "489:     # if asn1_obj is None or datatype_str is None or is_envelope is None:",
          "490:     #   return asn1_convert.asn1_from_der(data)",
          "491:     #",
          "492:     #",
          "493:     # # If one of those succeeded, then asn1_obj is now either a Choice object that",
          "494:     # # is an AnyMetadata or an AnyEnvelope, and datatype_str contains all we need",
          "495:     # # to re-parse the object with the correct subclasses and field names.",
          "496:     # datatype = _interpret_datatype(datatype_str, is_envelope)",
          "497:     # return asn1_convert.asn1_from_der(data, datatype)",
          "500:     # Strategy 3: Just try every role type metadata definition individually....",
          "501:     # This is presumably quite slow, so they're in order of likely access.",
          "502:     for datatype in [",
          "503:         asn1_defs.RootEnvelope,",
          "504:         asn1_defs.TimestampEnvelope,",
          "505:         asn1_defs.SnapshotEnvelope,",
          "506:         asn1_defs.TargetsEnvelope,",
          "507:         asn1_defs.RootMetadata,",
          "508:         asn1_defs.TimestampMetadata,",
          "509:         asn1_defs.SnapshotMetadata,",
          "510:         asn1_defs.TargetsMetadata]:",
          "512:       try:",
          "513:         deserialized = asn1_convert.asn1_from_der(data, datatype)",
          "515:       except (tuf.exceptions.ASN1ConversionError, ValueError):",
          "516:         # Note that asn1crypto often raises ValueError if parsing fails.",
          "517:         continue",
          "520:   # If NONE of those succeeded, then give up and return the results of a blind",
          "521:   # conversion.",
          "522:   if deserialized is None:",
          "523:     logger.debug(",
          "524:         'Failed to interpret ASN.1/DER as role metadata.  Converting into '",
          "525:         'generic asn1crypto object (no field data or subclass data).')",
          "526:     deserialized = asn1_convert.asn1_from_der(data)",
          "529:   # Regardless of how we produced the deserialized object, we must now do",
          "530:   # consistency checking, as asn1crypto is a little bit too happy to produce",
          "531:   # something when the data doesn't actually make sense.",
          "532:   # Our primary expectation is that if we try to serialize the data again, we",
          "533:   # get the same thing we loaded.",
          "534:   der_sanity_check(deserialized, data)",
          "536:   # If it worked, return the object....",
          "537:   logger.debug('Successfully interpreted ASN.1/DER as ' + str(datatype))",
          "538:   return deserialized",
          "544: def der_sanity_check(asn1_obj, expected_der_bytes):",
          "545:   \"\"\"",
          "546:   Raises tuf.exceptions.ASN1ConversionError if the given asn1_obj does not",
          "547:   serialize to produce the expected DER bytes.",
          "548:   Intended as helper function for deserialize_der().",
          "549:   \"\"\"",
          "550:   # First, force some lazy loading to complete.  This also sometimes raises",
          "551:   # errors if the object is malformed.",
          "552:   try:",
          "553:     asn1_obj.contents",
          "554:   except Exception:",
          "555:     raise tuf.exceptions.ASN1ConversionError(",
          "556:         'Attempted deserialization of ASN.1/DER data resulted in an asn1crypto '",
          "557:         'object which was not as expected (would not serialize back to the '",
          "558:         'same data.')",
          "560:   if asn1_obj.dump() != expected_der_bytes:",
          "561:     raise tuf.exceptions.ASN1ConversionError(",
          "562:         'Attempted deserialization of ASN.1/DER data resulted in an asn1crypto '",
          "563:         'object which was not as expected (would not serialize back to the '",
          "564:         'same data.')",
          "570: # This was used for Abandoned Strategy 2 in deserialize_der.",
          "571: # def _interpret_datatype(datatype_str, is_envelope):",
          "572: #   \"\"\"",
          "573: #   Converts role type string to a type of asn1crypto object for that role type.",
          "574: #",
          "575: #   e.g. 'root' to type tuf.encoding.asn1_metadata_definitions.RootMetadata",
          "576: #   \"\"\"",
          "577: #   datatype_str = datatype_str.lower()",
          "578: #",
          "579: #   if datatype_str == 'root':",
          "580: #     if is_envelope:",
          "581: #       return tuf.encoding.asn1_metadata_definitions.RootEnvelope",
          "582: #     else:",
          "583: #       return tuf.encoding.asn1_metadata_definitions.RootMetadata",
          "584: #",
          "585: #   elif datatype_str == 'timestamp':",
          "586: #     if is_envelope:",
          "587: #       return tuf.encoding.asn1_metadata_definitions.TimestampEnvelope",
          "588: #     else:",
          "589: #       return tuf.encoding.asn1_metadata_definitions.TimestampMetadata",
          "590: #",
          "591: #   elif datatype_str == 'snapshot':",
          "592: #     if is_envelope:",
          "593: #       return tuf.encoding.asn1_metadata_definitions.SnapshotEnvelope",
          "594: #     else:",
          "595: #       return tuf.encoding.asn1_metadata_definitions.SnapshotMetadata",
          "596: #",
          "597: #   elif datatype_str == 'targets':",
          "598: #     if is_envelope:",
          "599: #       return tuf.encoding.asn1_metadata_definitions.TargetsEnvelope",
          "600: #     else:",
          "601: #       return tuf.encoding.asn1_metadata_definitions.TargetsMetadata",
          "602: #",
          "603: #   else:",
          "604: #     # TODO: Consider a different exception class.  UnknownRoleError is used",
          "605: #     #       pretty differently in other parts of the code.",
          "606: #     raise tuf.exceptions.UnknownRoleError(",
          "607: #         'Given type string, \"' + datatype_str + '\" matches no known datatype.')",
          "",
          "---------------"
        ],
        "tuf/exceptions.py||tuf/exceptions.py": [
          "File: tuf/exceptions.py -> tuf/exceptions.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "140: class UnknownMethodError(CryptoError):",
          "144: class UnsupportedLibraryError(Error):",
          "",
          "[Removed Lines]",
          "141:   \"\"\"Indicate that a user-specified cryptograpthic method is unknown.\"\"\"",
          "",
          "[Added Lines]",
          "141:   \"\"\"Indicate that a user-specified cryptographic method is unknown.\"\"\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "264:   defined in the specification) to the ASN.1 format this implementation allows,",
          "265:   or vice versa.",
          "266:   \"\"\"",
          "",
          "[Removed Lines]",
          "267:   pass",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tuf/formats.py||tuf/formats.py": [
          "File: tuf/formats.py -> tuf/formats.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "110: # A string representing a role's name.",
          "111: ROLENAME_SCHEMA = SCHEMA.AnyString()",
          "113: # Role object in {'keyids': [keydids..], 'name': 'ABC', 'threshold': 1,",
          "114: # 'paths':[filepaths..]} format.",
          "115: ROLE_SCHEMA = SCHEMA.Object(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "113: TOPLEVEL_ROLENAME_SCHEMA = SCHEMA.OneOf([",
          "114:     SCHEMA.String('root'), SCHEMA.String('timestamp'),",
          "115:     SCHEMA.String('snapshot'), SCHEMA.String('targets'),",
          "116:     SCHEMA.String('Root'), SCHEMA.String('Timestamp'),",
          "117:     SCHEMA.String('Snapshot'), SCHEMA.String('Targets')])",
          "",
          "---------------"
        ],
        "tuf/repository_lib.py||tuf/repository_lib.py": [
          "File: tuf/repository_lib.py -> tuf/repository_lib.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: import tuf.sig",
          "48: import tuf.log",
          "49: import tuf.settings",
          "51: import securesystemslib",
          "52: import securesystemslib.interface",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50: import tuf.encoding.util",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "187:     def should_write():",
          "188:       # Root must be signed by its previous keys and threshold.",
          "189:       if rolename == 'root' and len(previous_keyids) > 0:",
          "191:             previous_threshold, previous_keyids):",
          "192:           return False",
          "",
          "[Removed Lines]",
          "190:         if not tuf.sig.verify(signable, rolename, repository_name,",
          "",
          "[Added Lines]",
          "191:         if not tuf.sig.verify_signable(signable, rolename, repository_name,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "195:           logger.debug('Root is signed by a threshold of its previous keyids.')",
          "197:       # In the normal case, we should write metadata if the threshold is met.",
          "199:           roleinfo['threshold'], roleinfo['signing_keyids'])",
          "",
          "[Removed Lines]",
          "198:       return tuf.sig.verify(signable, rolename, repository_name,",
          "",
          "[Added Lines]",
          "199:       return tuf.sig.verify_signable(signable, rolename, repository_name,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "248: def _metadata_is_partially_loaded(rolename, signable, repository_name):",
          "249:   \"\"\"",
          "250:   Non-public function that determines whether 'rolename' is loaded with",
          "255:   signatures.",
          "259:   a role's version number should be incremented when write() or write_parital()",
          "260:   is called.  Return True if 'rolename' was partially loaded, False otherwise.",
          "261:   \"\"\"",
          "",
          "[Removed Lines]",
          "251:   at least zero good signatures, but an insufficient threshold (which means",
          "252:   'rolename' was written to disk with repository.write_partial()).  A repository",
          "253:   maintainer may write partial metadata without including a valid signature.",
          "254:   Howerver, the final repository.write() must include a threshold number of",
          "257:   If 'rolename' is found to be partially loaded, mark it as partially loaded in",
          "258:   its 'tuf.roledb' roleinfo.  This function exists to assist in deciding whether",
          "",
          "[Added Lines]",
          "252:   insufficient good signatures to meet its signing threshold.  'rolename' may",
          "253:   have been written to disk with repository.write_partial(), which allows a",
          "254:   role to be written even if it does not have enough signatures to be trusted.",
          "255:   (A repository maintainer may write partial metadata without including a valid",
          "256:   signature, or enough valid signatures.)",
          "257:   However, the final repository.write() must include a threshold number of",
          "260:   This function exists to assist in deciding whether",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "264:   # bad, untrusted, unknown, etc.",
          "265:   status = tuf.sig.get_signature_status(signable, rolename, repository_name)",
          "269:     return True",
          "271:   else:",
          "",
          "[Removed Lines]",
          "267:   if len(status['good_sigs']) < status['threshold'] and \\",
          "268:                                                   len(status['good_sigs']) >= 0:",
          "",
          "[Added Lines]",
          "269:   if len(status['good_sigs']) < status['threshold']:",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "542:   if os.path.exists(root_filename):",
          "544:     # Initialize the key and role metadata of the top-level roles.",
          "546:     tuf.formats.check_signable_object_format(signable)",
          "547:     root_metadata = signable['signed']",
          "548:     tuf.keydb.create_keydb_from_root_metadata(root_metadata, repository_name)",
          "",
          "[Removed Lines]",
          "545:     signable = securesystemslib.util.load_json_file(root_filename)",
          "",
          "[Added Lines]",
          "546:     signable = tuf.encoding.util.deserialize_file(root_filename)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "585:   # Load 'timestamp.json'.  A Timestamp role file without a version number is",
          "586:   # always written.",
          "587:   if os.path.exists(timestamp_filename):",
          "589:     timestamp_metadata = signable['signed']",
          "590:     for signature in signable['signatures']:",
          "591:       repository.timestamp.add_signature(signature, mark_role_as_dirty=False)",
          "",
          "[Removed Lines]",
          "588:     signable = securesystemslib.util.load_json_file(timestamp_filename)",
          "",
          "[Added Lines]",
          "589:     signable = tuf.encoding.util.deserialize_file(timestamp_filename)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "622:         str(snapshot_version) + '.' + basename + METADATA_EXTENSION)",
          "624:   if os.path.exists(snapshot_filename):",
          "626:     tuf.formats.check_signable_object_format(signable)",
          "627:     snapshot_metadata = signable['signed']",
          "",
          "[Removed Lines]",
          "625:     signable = securesystemslib.util.load_json_file(snapshot_filename)",
          "",
          "[Added Lines]",
          "626:     signable = tuf.encoding.util.deserialize_file(snapshot_filename)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "657:     targets_filename = os.path.join(dirname, str(targets_version) + '.' + basename)",
          "659:   if os.path.exists(targets_filename):",
          "661:     tuf.formats.check_signable_object_format(signable)",
          "662:     targets_metadata = signable['signed']",
          "",
          "[Removed Lines]",
          "660:     signable = securesystemslib.util.load_json_file(targets_filename)",
          "",
          "[Added Lines]",
          "661:     signable = tuf.encoding.util.deserialize_file(targets_filename)",
          "",
          "---------------"
        ],
        "tuf/repository_tool.py||tuf/repository_tool.py": [
          "File: tuf/repository_tool.py -> tuf/repository_tool.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: import tuf.log",
          "48: import tuf.exceptions",
          "49: import tuf.repository_lib as repo_lib",
          "51: import securesystemslib.keys",
          "52: import securesystemslib.formats",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50: import tuf.encoding.util",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2976:     signable = None",
          "2978:     try:",
          "2981:     except (securesystemslib.exceptions.Error, ValueError, IOError):",
          "2982:       logger.debug('Tried to load metadata with invalid JSON'",
          "",
          "[Removed Lines]",
          "2979:       signable = securesystemslib.util.load_json_file(metadata_path)",
          "",
          "[Added Lines]",
          "2980:       signable = tuf.encoding.util.deserialize_file(metadata_path)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3081:   # Are the argument properly formatted?",
          "3082:   securesystemslib.formats.PATH_SCHEMA.check_match(metadata_filepath)",
          "3086:   # Is 'signable' a valid metadata file?",
          "3087:   tuf.formats.SIGNABLE_SCHEMA.check_match(signable)",
          "",
          "[Removed Lines]",
          "3084:   signable = securesystemslib.util.load_json_file(metadata_filepath)",
          "",
          "[Added Lines]",
          "3085:   signable = tuf.encoding.util.deserialize_file(metadata_filepath)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3137:   securesystemslib.formats.SIGNATURE_SCHEMA.check_match(signature)",
          "3138:   securesystemslib.formats.PATH_SCHEMA.check_match(metadata_filepath)",
          "3142:   # Is 'signable' a valid metadata file?",
          "3143:   tuf.formats.SIGNABLE_SCHEMA.check_match(signable)",
          "",
          "[Removed Lines]",
          "3140:   signable = securesystemslib.util.load_json_file(metadata_filepath)",
          "",
          "[Added Lines]",
          "3141:   signable = tuf.encoding.util.deserialize_file(metadata_filepath)",
          "",
          "---------------"
        ],
        "tuf/sig.py||tuf/sig.py": [
          "File: tuf/sig.py -> tuf/sig.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "17:   See LICENSE-MIT OR LICENSE for licensing information.",
          "19: <Purpose>",
          "41: \"\"\"",
          "43: # Help with Python 3 compatibility, where the print statement is a function, an",
          "",
          "[Removed Lines]",
          "20:   Survivable key compromise is one feature of a secure update system",
          "21:   incorporated into TUF's design. Responsibility separation through",
          "22:   the use of multiple roles, multi-signature trust, and explicit and",
          "23:   implicit key revocation are some of the mechanisms employed towards",
          "24:   this goal of survivability.  These mechanisms can all be seen in",
          "25:   play by the functions available in this module.",
          "27:   The signed metadata files utilized by TUF to download target files",
          "28:   securely are used and represented here as the 'signable' object.",
          "29:   More precisely, the signature structures contained within these metadata",
          "30:   files are packaged into 'signable' dictionaries.  This module makes it",
          "31:   possible to capture the states of these signatures by organizing the",
          "32:   keys into different categories.  As keys are added and removed, the",
          "33:   system must securely and efficiently verify the status of these signatures.",
          "34:   For instance, a bunch of keys have recently expired. How many valid keys",
          "35:   are now available to the Snapshot role?  This question can be answered by",
          "36:   get_signature_status(), which will return a full 'status report' of these",
          "37:   'signable' dicts.  This module also provides a convenient verify() function",
          "38:   that will determine if a role still has a sufficient number of valid keys.",
          "39:   If a caller needs to update the signatures of a 'signable' object, there",
          "40:   is also a function for that.",
          "",
          "[Added Lines]",
          "20:   sig provides a higher-level signature handling interface for tuf.updater,",
          "21:   tuf.repository_lib, and tuf.developer_tool.  Lower-level functionality used",
          "22:   here comes primarily from securesystemslib, tuf.roledb, and tuf.keydb.",
          "24:   sig also helps isolate signature-over-encoding issues from the rest of TUF.",
          "25:   Signatures should be made and verified over the serialized form of metadata,",
          "26:   which may or may not be JSON.  If signatures over ASN.1/DER metadata need to",
          "27:   be handled, that is abstracted away here.",
          "30: <Public Functions>",
          "31:   NOTE that EVERY function in this module abstracts away serialization format,",
          "32:   attempting to handles metadata in the form of BOTH ASN1 (asn1crypto objects",
          "33:   of classes defined in tuf.encoding.asn1_definitions) AND JSON-compatible",
          "34:   dictionaries (matching tuf.formats.ANYROLE_SCHEMA).",
          "36:   These are provided from lowest to highest level:",
          "39:   HELPER FUNCTIONS:",
          "41:     is_top_level_role()",
          "42:       True if the given rolename is a top-level role's name (root, targets,",
          "43:       etc.)",
          "45:     check_is_serializable_role_metadata()",
          "46:       makes sure that the given data is serializable TUF role metadata in",
          "47:       either a JSON-compatible dictionary or an asn1crypto ASN1 object.",
          "50:   SINGLE SIGNATURE MANIPULATION:",
          "52:     create_signature_over_metadata()",
          "53:       given key and data, wraps securesystemslib.keys.create_signature(),",
          "54:       creating a signature over given TUF role metadata, which it first",
          "55:       canonicalizes and serializes, handling either ASN.1 or JSON- compatible",
          "56:       formats.",
          "58:     verify_signature_over_metadata()",
          "59:       given key, signature, and data, wraps",
          "60:       securesystemslib.keys.verify_signature(), verifying a signature over",
          "61:       given TUF role metadata by a given key.  It first canonicalizes and",
          "62:       serializes the role metadata, handling either ASN.1 or JSON-compatible",
          "63:       formats.",
          "66:   FULL METADATA VERIFICATION:",
          "68:     get_signature_status()",
          "69:       Analyzes the signatures included in given role metadata that includes",
          "70:       signatures, taking arguments that convey the expected keyids and",
          "71:       threshold for those signatures (either directly or in the form of a",
          "72:       rolename to look up in roledb), produces a report of the validity of the",
          "73:       signatures provided in the metadata indicating whether or not they",
          "74:       correctly sign the given metadata and whether or each signature is from",
          "75:       an authorized key.",
          "77:     verify_signable()",
          "78:       Verifies a full piece of role metadata, returning True if the given role",
          "79:       metadata is verified (signed by at least enough correct signatures from",
          "80:       authorized keys to meet the threshold expected for this metadata) and",
          "81:       False otherwise.  It uses get_signature_status() to glean the status of",
          "82:       each signature.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "56: import tuf.formats",
          "58: import securesystemslib",
          "60: # See 'log.py' to learn how logging is handled in TUF.",
          "61: logger = logging.getLogger('tuf.sig')",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102: import securesystemslib.keys",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "66: iso8601_logger.disabled = True",
          "69: def get_signature_status(signable, role=None, repository_name='default',",
          "70:     threshold=None, keyids=None):",
          "71:   \"\"\"",
          "72:   <Purpose>",
          "73:     Return a dictionary representing the status of the signatures listed in",
          "74:     'signable'.  Given an object conformant to SIGNABLE_SCHEMA, a set of public",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "113: def _is_top_level_role(rolename):",
          "114:   tuf.formats.ROLENAME_SCHEMA.check_match(rolename)",
          "115:   return rolename.lower() in ['root', 'timestamp', 'snapshot', 'targets']",
          "118: def check_is_serializable_role_metadata(data):",
          "119:   \"\"\"",
          "120:   # TODO: write good docstring",
          "122:   raises an appropriate error if the provided data is neither permitted format",
          "123:   for TUF metadata:",
          "124:     - JSON-compatible role dictionary conforming to tuf.formats.ANYROLE_SCHEMA",
          "125:     - asn1crypto object, instance of one of the four role types defined in",
          "126:       tuf.encoding.asn1_definitions (e.g TargetsMetadata).",
          "127:   \"\"\"",
          "129:   if isinstance(data, dict):",
          "130:     # Assume JSON-compatible metadata conforming to TUF specification.",
          "131:     tuf.formats.ANYROLE_SCHEMA.check_match(data)",
          "133:   elif isinstance(data, asn1core.Sequence):",
          "134:     # Assume ASN.1 metadata conforming to tuf.encoding.asn1_metadata_definitions",
          "135:     if not (isinstance(data, asn1defs.TargetsMetadata)",
          "136:         or isinstance(data, asn1defs.RootMetadata)",
          "137:         or isinstance(data, asn1defs.TimestampMetadata)",
          "138:         or isinstance(data, asn1defs.SnapshotMetadata)):",
          "139:       raise tuf.exceptions.FormatError('Unrecognized ASN1 metadata object.')",
          "142:   else:",
          "143:     raise tuf.exceptions.FormatError(",
          "144:         'Unrecognized metadata object.  Expecting dictionary or asn1crypto '",
          "145:         'object. Received object of type: ' + str(type(data)) + ', with '",
          "146:         'value: ' + repr(data))",
          "152: def create_signature_over_metadata(",
          "153:     key, data):",
          "154:   \"\"\"",
          "155:   <Purpose>",
          "156:     Given a public key and data (JSON-compatible dictionary or asn1crypto ASN1",
          "157:     object), create a signature using that key over a canonical, serialized",
          "158:     form of the given data.",
          "160:     Higher level function that wraps securesystemslib.keys.create_signature,",
          "161:     and works specifically with metadata in the JSON-compatible metadata format",
          "162:     from the TUF specification or an ASN.1 format defined by",
          "163:     tuf.encoding.asn1_definitions.",
          "165:   <Arguments>",
          "166:     key:",
          "167:       A dictionary representing a public key and its properties, conforming to",
          "168:       securesystemslib.formats.PUBLIC_KEY_SCHEMA.",
          "170:       For example, if 'key' is an RSA key, it has the form:",
          "171:         {'keytype': 'rsa',",
          "172:          'keyid': 'f30a0870d026980100c0573bd557394f8c1bbd6...',",
          "173:          'keyid_hash_algorithms': ['sha256', 'sha512'],",
          "174:          'keyval': {'public': '-----BEGIN RSA PUBLIC KEY----- ...'}}# PEM format",
          "176:     data:",
          "177:       Data object over which a signature will be produced.",
          "179:       Acceptable formats are:",
          "181:         - ASN.1 metadata:",
          "182:           an asn1crypto object, specifically an instance of one of these",
          "183:           classes defined in tuf.encoding.asn1_metadata_definitions:",
          "184:             RootMetadata, TimestampMetadata, SnapshotMetadata, TargetsMetadata.",
          "185:           ASN.1 metadata will be serialized into to bytes as ASN.1/DER",
          "186:           (Distinguished Encoding Rules) for signature checks.",
          "188:         - JSON-compatible standard TUF-internal metadata:",
          "189:           a dictionary conforming to one of these schemas from tuf.formats:",
          "190:           ROOT_SCHEMA, TARGETS_SCHEMA, TIMESTAMP_SCHEMA, SNAPSHOT_SCHEMA.",
          "191:           This is the usual metadata format defined in the TUF specification.",
          "192:           JSON-compatible metadata will be serialized to bytes encoding",
          "193:           canonical JSON for signature checks.",
          "195:           (Note: While this function is intended to create signatures over",
          "196:            these metadata types, it can technically be used more broadly with",
          "197:            any dictionary that can be canonicalized to JSON or any serializable",
          "198:            asn1crypto object.  Please be careful with such use, support for",
          "199:            which may change.)",
          "201:   <Exceptions>",
          "202:     tuf.FormatError, raised if either 'key' or 'signature' are improperly",
          "203:     formatted, or if data does not seem to match one of the expected formats.",
          "205:     tuf.UnsupportedLibraryError, if an unsupported or unavailable library is",
          "206:     detected.",
          "208:     # TODO: Determine the likely types of errors asn1crypto will raise.  It",
          "209:     #       doesn't look like they have the error classes I'd expect.",
          "211:   <Returns>",
          "212:     signature:",
          "213:       The signature dictionary produced by one of the key generation functions,",
          "214:       conforming to securesystemslib.formats.SIGNATURE_SCHEMA.",
          "216:       For example:",
          "217:         {'keyid': 'f30a0870d026980100c0573bd557394f8c1bbd6...',",
          "218:          'sig': 'abcdef0123456...'}.",
          "219:   \"\"\"",
          "221:   securesystemslib.formats.ANYKEY_SCHEMA.check_match(key)",
          "223:   # Validate format of data and serialize data.  Note that",
          "224:   # tuf.encoding.util.serialize() only checks to make sure the data is a",
          "225:   # JSON-compatible dict or any asn1crypto value that can be serialized, while",
          "226:   # check_is_serializable_role_metadata() checks to make sure the metadata is",
          "227:   # specifically TUF role metadata (of either type) that can be serialized.",
          "228:   check_is_serializable_role_metadata(data)",
          "229:   serialized_data = tuf.encoding.util.serialize(data)",
          "231:   # All's well and the data is serialized.  Check the signature over it.",
          "232:   return securesystemslib.keys.create_signature(key, serialized_data)",
          "239: def verify_signature_over_metadata(",
          "240:     key, signature, data):",
          "241:   \"\"\"",
          "242:   <Purpose>",
          "243:     Determine whether the given signature is a valid signature by key over",
          "244:     the given data.  securesystemslib.keys.verify_signature() will use the",
          "245:     public key found in 'key', the 'sig' objects contained in 'signature',",
          "246:     along with 'data', to complete the verification.",
          "248:     Higher level function that wraps securesystemslib.keys.verify_signature,",
          "249:     and works specifically with metadata in the JSON-compatible metadata format",
          "250:     from the TUF specification or an ASN.1 format defined by",
          "251:     tuf.encoding.asn1_definitions.",
          "253:   <Arguments>",
          "254:     key:",
          "255:       A dictionary representing a public key and its properties, conforming to",
          "256:       securesystemslib.formats.PUBLIC_KEY_SCHEMA.",
          "258:       For example, if 'key' is an RSA key, it has the form:",
          "259:         {'keytype': 'rsa',",
          "260:          'keyid': 'f30a0870d026980100c0573bd557394f8c1bbd6...',",
          "261:          'keyid_hash_algorithms': ['sha256', 'sha512'],",
          "262:          'keyval': {'public': '-----BEGIN RSA PUBLIC KEY----- ...'}}# PEM format",
          "264:     signature:",
          "265:       The signature dictionary produced by one of the key generation functions,",
          "266:       conforming to securesystemslib.formats.SIGNATURE_SCHEMA.",
          "268:       For example:",
          "269:         {'keyid': 'f30a0870d026980100c0573bd557394f8c1bbd6...',",
          "270:          'sig': 'abcdef0123456...'}.",
          "272:     data:",
          "273:       Data object over which the validity of the provided signature will be",
          "274:       checked.",
          "276:       Acceptable formats are:",
          "278:         - ASN.1 metadata:",
          "279:           an asn1crypto object, specifically an instance of one of these",
          "280:           classes defined in tuf.encoding.asn1_metadata_definitions:",
          "281:             RootMetadata, TimestampMetadata, SnapshotMetadata, TargetsMetadata.",
          "282:           ASN.1 metadata will be serialized into to bytes as ASN.1/DER",
          "283:           (Distinguished Encoding Rules) for signature checks.",
          "285:         - JSON-compatible standard TUF-internal metadata:",
          "286:           a dictionary conforming to one of these schemas from tuf.formats:",
          "287:           ROOT_SCHEMA, TARGETS_SCHEMA, TIMESTAMP_SCHEMA, SNAPSHOT_SCHEMA.",
          "288:           This is the usual metadata format defined in the TUF specification.",
          "289:           JSON-compatible metadata will be serialized to bytes encoding",
          "290:           canonical JSON for signature checks.",
          "292:           (Note: While this function is intended to verify signatures over",
          "293:            these metadata types, it can technically be used more broadly with",
          "294:            any dictionary that can be canonicalized to JSON or any serializable",
          "295:            asn1crypto object.  Please be careful with such use, support for",
          "296:            which may change.)",
          "298:   <Exceptions>",
          "299:     tuf.FormatError, raised if either 'key' or 'signature' are improperly",
          "300:     formatted, or if data does not seem to match one of the expected formats.",
          "302:     tuf.UnsupportedLibraryError, if an unsupported or unavailable library is",
          "303:     detected.",
          "305:     # TODO: Determine the likely types of errors asn1crypto will raise.  It",
          "306:     #       doesn't look like they have the error classes I'd expect.",
          "308:   <Returns>",
          "309:     Boolean.  True if the signature is valid, False otherwise.",
          "310:   \"\"\"",
          "312:   securesystemslib.formats.ANYKEY_SCHEMA.check_match(key)",
          "313:   securesystemslib.formats.SIGNATURE_SCHEMA.check_match(signature)",
          "315:   # Validate format of data and serialize data.  Note that",
          "316:   # tuf.encoding.util.serialize() only checks to make sure the data is a",
          "317:   # JSON-compatible dict or any asn1crypto value that can be serialized, while",
          "318:   # check_is_serializable_role_metadata() checks to make sure the metadata is",
          "319:   # specifically TUF role metadata (of either type) that can be serialized.",
          "320:   check_is_serializable_role_metadata(data)",
          "321:   serialized_data = tuf.encoding.util.serialize(data)",
          "323:   # All's well and the data is serialized.  Check the signature over it.",
          "324:   return securesystemslib.keys.verify_signature(key, signature, serialized_data)",
          "333:   # TODO: should probably be called get_status_of_signatures, plural?",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "77:     the signatures in 'signable' and enumerate all the keys that are valid,",
          "78:     invalid, unrecognized, or unauthorized.",
          "80:   <Arguments>",
          "89:     role:",
          "92:     threshold:",
          "93:       Rather than reference the role's threshold as set in tuf.roledb.py, use",
          "94:       the given 'threshold' to calculate the signature status of 'signable'.",
          "95:       'threshold' is an integer value that sets the role's threshold value, or",
          "97:       fully signed.",
          "99:     keyids:",
          "",
          "[Removed Lines]",
          "81:     signable:",
          "82:       A dictionary containing a list of signatures and a 'signed' identifier.",
          "83:       signable = {'signed': 'signer',",
          "84:                   'signatures': [{'keyid': keyid,",
          "85:                                   'sig': sig}]}",
          "87:       Conformant to tuf.formats.SIGNABLE_SCHEMA.",
          "90:       TUF role (e.g., 'root', 'targets', 'snapshot').",
          "96:       the miminum number of signatures needed for metadata to be considered",
          "",
          "[Added Lines]",
          "343:     Top-level roles (root, snapshot, timestamp, targets) have unambiguous",
          "344:     signature expectations: the expected keyids and threshold come only from",
          "345:     trusted root metadata.  Therefore, if optional args threshold and keyids",
          "346:     are not provided, the expected values can be taken from trusted root",
          "347:     metadata in tuf.roledb.  Delegated targets roles, on the other hand, may be",
          "348:     the objects of multiple different delegations from different roles that can",
          "349:     each have different keyid and threshold expectations, so it is not possible",
          "350:     to deduce these without knowing the delegating role of interest.  Please",
          "351:     always provide threshold and keyids if providing a role that isn't a",
          "352:     top-level role.",
          "354:     # TODO: After Issue #660 is fixed, update the above.",
          "355:     # Replace \"Please always provide...\" with:",
          "356:     # \"If 'role' is not a top-level role but a delegated targets role, 'keyids'",
          "357:     # and 'threshold' MUST be provided.\"",
          "361:     signable:",
          "362:       A metadata dictionary conformant to tuf.formats.SIGNABLE_SCHEMA.",
          "363:       For example:",
          "364:           {'signed': {...},",
          "365:            'signatures': [{'keyid': '1234ef...', 'sig': 'abcd1234...'}]}",
          "368:       TUF role (e.g., 'root', 'targets', 'some_delegated_project').",
          "374:       the minimum number of signatures needed for metadata to be considered",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "102:       in tuf.roledb.py for 'role'.",
          "104:   <Exceptions>",
          "105:     securesystemslib.exceptions.FormatError, if 'signable' does not have the",
          "106:     correct format.",
          "108:     tuf.exceptions.UnknownRoleError, if 'role' is not recognized.",
          "110:   <Side Effects>",
          "111:     None.",
          "113:   <Returns>",
          "114:     A dictionary representing the status of the signatures in 'signable'.",
          "115:     Conformant to tuf.formats.SIGNATURESTATUS_SCHEMA.",
          "116:   \"\"\"",
          "118:   # Do the arguments have the correct format?  This check will ensure that",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "389:     tuf.exceptions.Error, if the optional arguments keyids and threshold are",
          "390:     partially provided -- i.e. one is provided and one is not.  (They must",
          "391:     both be provided or both not be provided.)",
          "393:     # TODO: After Issue #660 is fixed, add the following:",
          "394:     # tuf.exceptions.Error, if role is not a top-level role and keyids and",
          "395:     # threshold are not provided.",
          "403:     Includes threshold, good_sigs, bad_sigs, unknown_sigs, untrusted_sigs,",
          "404:     and unknown_signing_schemes.",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "122:   tuf.formats.SIGNABLE_SCHEMA.check_match(signable)",
          "123:   securesystemslib.formats.NAME_SCHEMA.check_match(repository_name)",
          "125:   if role is not None:",
          "126:     tuf.formats.ROLENAME_SCHEMA.check_match(role)",
          "131:   if keyids is not None:",
          "132:     securesystemslib.formats.KEYIDS_SCHEMA.check_match(keyids)",
          "135:   signature_status = {}",
          "139:   #",
          "142:   #",
          "144:   #",
          "146:   #",
          "149:   #",
          "152:   good_sigs = []",
          "153:   bad_sigs = []",
          "154:   unknown_sigs = []",
          "",
          "[Removed Lines]",
          "128:   if threshold is not None:",
          "129:     securesystemslib.formats.THRESHOLD_SCHEMA.check_match(threshold)",
          "134:   # The signature status dictionary returned.",
          "137:   # The fields of the signature_status dict, where each field stores keyids.  A",
          "138:   # description of each field:",
          "140:   # good_sigs = keys confirmed to have produced 'sig' using 'signed', which are",
          "141:   # associated with 'role';",
          "143:   # bad_sigs = negation of good_sigs;",
          "145:   # unknown_sigs = keys not found in the 'keydb' database;",
          "147:   # untrusted_sigs = keys that are not in the list of keyids associated with",
          "148:   # 'role';",
          "150:   # unknown_signing_scheme = signing schemes specified in keys that are",
          "151:   # unsupported;",
          "",
          "[Added Lines]",
          "414:   # Argument sanity: we must either be given both the authorized keyids",
          "415:   # and the threshold, or neither.  Receiving just one or the other makes no",
          "416:   # sense.",
          "417:   if (threshold is None) != (keyids is None):",
          "418:     raise tuf.exceptions.Error(",
          "419:         'Incoherent optional arguments: we must receive either both expected '",
          "420:         'keyids and threshold, or neither.')",
          "422:   # Argument sanity: We need either keyids&threshold or role.",
          "423:   if keyids is None and role is None:",
          "424:     logger.warning(",
          "425:         'Given no information to use to validate signatures -- neither the '",
          "426:         'expected keys and threshold, nor a role from which to derive them.  '",
          "427:         'Signature report will be of very limited use.')",
          "428:     # raise tuf.exceptions.Error(",
          "429:     #   'Invalid arguments: no keyids or threshold provided, and no ' # update after #660 is fixed, to: ', and no top-level '",
          "430:     #   'role provided from which to deduce them.')",
          "432:   # Argument sanity: role has the right format, if provided.",
          "434:     assert threshold is None and keyids is None, 'Not possible; mistake in this function!'  # TODO: consider removing after debug",
          "436:     # The following code must be used when it is time to fix #660....",
          "437:     # if not _is_top_level_role(role):         # implicit -- and (threshold is None or keyids is None):",
          "438:     #   raise tuf.exceptions.Error(",
          "439:     #       # See github.com/theupdateframework/tuf/issues/660",
          "440:     #       'Unable to determine keyids and threshold to expect from delegated '",
          "441:     #       'targets role, \"' + role + '\"; when called for a delegated targets '",
          "442:     #       'role, sig.get_signature_status() must be told which keyids and '",
          "443:     #       'threshold should be used to validate the role.  A delegated role '",
          "444:     #       'rolename need never be provided as argument.')",
          "446:   # Argument sanity: keyids and threshold have the right format, if provided.",
          "449:     assert threshold is not None, 'Not possible; mistake in this function!'  # TODO: consider removing after testing",
          "450:     assert role is None, 'Not possible: mistake in this function!'  # TODO: consider removing after testing",
          "451:     securesystemslib.formats.THRESHOLD_SCHEMA.check_match(threshold)",
          "454:   # Determine which keyids and threshold should be used to verify this",
          "455:   # metadata.  Either they are provided as arguments, or, if not, we will try",
          "456:   # to check the roledb ourselves to see if the expected keyids and threshold",
          "457:   # for this role (****) are known there.  (This only works for the four",
          "458:   # top-level roles. See TUF Issue #660 on GitHub.)    # TODO: <~> Review this section!",
          "459:   if keyids is None:",
          "460:     # Redundant argument sanity check",
          "461:     assert threshold is None, 'Not possible; mistake in this function!'",
          "464:     if role is None:",
          "465:       # We can only reach this spot if no role information AND no keyids were",
          "466:       # given to this function, in which case our return data is QUITE limited,",
          "467:       # but we can still check to see if a given signature is correct (though",
          "468:       # not if that key is authorized to sign).",
          "469:       keyids = []",
          "471:     else:",
          "472:       # Note that if the role is not known, tuf.exceptions.UnknownRoleError",
          "473:       # is raised here.",
          "474:       keyids = tuf.roledb.get_role_keyids(role, repository_name)",
          "475:       threshold = tuf.roledb.get_role_threshold(",
          "476:           role, repository_name=repository_name)",
          "479:   # The signature status dictionary we will return.",
          "482:   # The fields of the signature_status dict, where each field is a list of",
          "483:   # keyids.  A description of each field:",
          "485:   # good_sigs =      keyids confirmed to have produced 'sig' over 'signed',",
          "486:   #                  which are associated with 'role'.",
          "488:   # bad_sigs =       keyids for which a signature is included that is not a",
          "489:   #                  valid signature using the key indicated over 'signed'.",
          "491:   # unknown_sigs =   unknown keyids: keyids from signatures for which the keyid",
          "492:   #                  has no entry in the 'keydb' database.",
          "494:   # untrusted_sigs = untrusted keyids: keyids from signatures whose keyids",
          "495:   #                  correspond to known keys, but which are not authorized to",
          "496:   #                  sign this metadata (according to keyids arg or rolename",
          "497:   #                  lookup in roledb).",
          "499:   # unknown_signing_scheme = keyids from signatures that list a signing scheme",
          "500:   #                          that is not supported.",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "165:   for signature in signatures:",
          "166:     keyid = signature['keyid']",
          "169:     try:",
          "170:       key = tuf.keydb.get_key(keyid, repository_name)",
          "",
          "[Removed Lines]",
          "168:     # Does the signature use an unrecognized key?",
          "",
          "[Added Lines]",
          "517:     # Try to find the public key corresponding to the keyid (fingerprint)",
          "518:     # listed in the signature, so that we can actually verify the signature.",
          "519:     # If we can't find it, note this as an unknown key, and skip to the next.",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "173:       unknown_sigs.append(keyid)",
          "174:       continue",
          "177:     try:",
          "180:     except securesystemslib.exceptions.UnsupportedAlgorithmError:",
          "181:       unknown_signing_schemes.append(keyid)",
          "182:       continue",
          "199:       else:",
          "206:     else:",
          "208:       bad_sigs.append(keyid)",
          "210:   # Retrieve the threshold value for 'role'.  Raise",
          "211:   # securesystemslib.exceptions.UnknownRoleError if we were given an invalid",
          "212:   # role.",
          "",
          "[Removed Lines]",
          "176:     # Does the signature use an unknown/unsupported signing scheme?",
          "178:       valid_sig = securesystemslib.keys.verify_signature(key, signature, signed)",
          "184:     # We are now dealing with either a trusted or untrusted key...",
          "185:     if valid_sig:",
          "186:       if role is not None:",
          "188:         # Is this an unauthorized key? (a keyid associated with 'role')",
          "189:         # Note that if the role is not known, tuf.exceptions.UnknownRoleError",
          "190:         # is raised here.",
          "191:         if keyids is None:",
          "192:           keyids = tuf.roledb.get_role_keyids(role, repository_name)",
          "194:         if keyid not in keyids:",
          "195:           untrusted_sigs.append(keyid)",
          "196:           continue",
          "198:       # This is an unset role, thus an unknown signature.",
          "200:         unknown_sigs.append(keyid)",
          "201:         continue",
          "203:       # Identify good/authorized key.",
          "204:       good_sigs.append(keyid)",
          "207:       # This is a bad signature for a trusted key.",
          "",
          "[Added Lines]",
          "527:     # Now try verifying the signature (whether it's over canonical JSON + utf-8",
          "528:     # or over ASN.1/DER).",
          "529:     # If the signature use an unknown/unsupported signing scheme and cannot be",
          "530:     # verified, note that and skip to the next signature.",
          "531:     # TODO: Make sure that verify_signature_over_metadata will actually raise",
          "532:     #       this unsupported algorithm error appropriately.",
          "534:       valid_sig = verify_signature_over_metadata(key, signature, signed)",
          "539:     # We know the key, we support the signing scheme, and",
          "540:     # verify_signature_over_metadata completed, its boolean return telling us if",
          "541:     # the signature is a valid signature by the key the signature mentions,",
          "542:     # over the data provided.",
          "543:     # We now ascertain whether or not this known key is one trusted to sign",
          "544:     # this particular metadata.",
          "546:     if valid_sig:",
          "547:         # Is this an authorized key? (a keyid associated with 'role')",
          "548:       if keyid in keyids:",
          "549:         good_sigs.append(keyid)       # good sig from right key",
          "551:         untrusted_sigs.append(keyid)  # good sig from wrong key",
          "554:       # The signature not even valid for the key the signature says it's using.",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "241:     keyids=None):",
          "242:   \"\"\"",
          "243:   <Purpose>",
          "",
          "[Removed Lines]",
          "240: def verify(signable, role, repository_name='default', threshold=None,",
          "",
          "[Added Lines]",
          "588: def verify_signable(signable, role, repository_name='default', threshold=None,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "246:     associated with 'role'.  'signable' must conform to SIGNABLE_SCHEMA",
          "247:     and 'role' must not equal 'None' or be less than zero.",
          "249:   <Arguments>",
          "250:     signable:",
          "251:       A dictionary containing a list of signatures and a 'signed' identifier.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "597:     Top-level roles (root, snapshot, timestamp, targets) have unambiguous",
          "598:     signature expectations: the expected keyids and threshold come only from",
          "599:     trusted root metadata.  Therefore, if optional args threshold and keyids",
          "600:     are not provided, the expected values can be taken from trusted root",
          "601:     metadata in tuf.roledb.  Delegated targets roles, on the other hand, may be",
          "602:     the objects of multiple different delegations from different roles that can",
          "603:     each have different keyid and threshold expectations, so it is not possible",
          "604:     to deduce these without knowing the delegating role of interest; therefore,",
          "605:     if 'role' is not a top-level role but a delegated targets role, 'keyids'",
          "606:     and 'threshold' MUST be provided.",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "275:     securesystemslib.exceptions.Error, if an invalid threshold is encountered.",
          "277:   <Side Effects>",
          "278:     tuf.sig.get_signature_status() called.  Any exceptions thrown by",
          "279:     get_signature_status() will be caught here and re-raised.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "636:     tuf.exceptions.Error, if role is not a top-level role and keyids and",
          "637:     threshold are not provided.",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "284:   \"\"\"",
          "286:   tuf.formats.SIGNABLE_SCHEMA.check_match(signable)",
          "290:   # Retrieve the signature status.  tuf.sig.get_signature_status() raises:",
          "291:   # securesystemslib.exceptions.UnknownRoleError",
          "292:   # securesystemslib.exceptions.FormatError.  'threshold' and 'keyids' are also",
          "293:   # validated.",
          "294:   status = get_signature_status(signable, role, repository_name, threshold, keyids)",
          "296:   # Retrieve the role's threshold and the authorized keys of 'status'",
          "",
          "[Removed Lines]",
          "287:   tuf.formats.ROLENAME_SCHEMA.check_match(role)",
          "288:   securesystemslib.formats.NAME_SCHEMA.check_match(repository_name)",
          "",
          "[Added Lines]",
          "650:   # The other arguments are checked by the get_signature_status call.",
          "656:   # tuf.exceptions.Error if the role is a delegated targets role but keyids and",
          "657:   # threshold are not provided.",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "305:     raise securesystemslib.exceptions.Error(\"Invalid threshold: \" + repr(threshold))",
          "307:   return len(good_sigs) >= threshold",
          "",
          "[Removed Lines]",
          "313: def may_need_new_keys(signature_status):",
          "314:   \"\"\"",
          "315:   <Purpose>",
          "316:     Return true iff downloading a new set of keys might tip this",
          "317:     signature status over to valid.  This is determined by checking",
          "318:     if either the number of unknown or untrused keys is > 0.",
          "320:   <Arguments>",
          "321:     signature_status:",
          "322:       The dictionary returned by tuf.sig.get_signature_status().",
          "324:   <Exceptions>",
          "325:     securesystemslib.exceptions.FormatError, if 'signature_status does not have",
          "326:     the correct format.",
          "328:   <Side Effects>",
          "329:     None.",
          "331:   <Returns>",
          "332:     Boolean.",
          "333:   \"\"\"",
          "335:   # Does 'signature_status' have the correct format?",
          "336:   # This check will ensure 'signature_status' has the appropriate number",
          "337:   # of objects and object types, and that all dict keys are properly named.",
          "338:   # Raise 'securesystemslib.exceptions.FormatError' if the check fails.",
          "339:   securesystemslib.formats.SIGNATURESTATUS_SCHEMA.check_match(signature_status)",
          "341:   unknown = signature_status['unknown_sigs']",
          "342:   untrusted = signature_status['untrusted_sigs']",
          "344:   return len(unknown) or len(untrusted)",
          "350: def generate_rsa_signature(signed, rsakey_dict):",
          "351:   \"\"\"",
          "352:   <Purpose>",
          "353:     Generate a new signature dict presumably to be added to the 'signatures'",
          "354:     field of 'signable'.  The 'signable' dict is of the form:",
          "356:     {'signed': 'signer',",
          "357:                'signatures': [{'keyid': keyid,",
          "358:                                'method': 'evp',",
          "359:                                'sig': sig}]}",
          "361:     The 'signed' argument is needed here for the signing process.",
          "362:     The 'rsakey_dict' argument is used to generate 'keyid', 'method', and 'sig'.",
          "364:     The caller should ensure the returned signature is not already in",
          "365:     'signable'.",
          "367:   <Arguments>",
          "368:     signed:",
          "369:       The data used by 'securesystemslib.keys.create_signature()' to generate",
          "370:       signatures.  It is stored in the 'signed' field of 'signable'.",
          "372:     rsakey_dict:",
          "373:       The RSA key, a 'securesystemslib.formats.RSAKEY_SCHEMA' dictionary.",
          "374:       Used here to produce 'keyid', 'method', and 'sig'.",
          "376:   <Exceptions>",
          "377:     securesystemslib.exceptions.FormatError, if 'rsakey_dict' does not have the",
          "378:     correct format.",
          "380:     TypeError, if a private key is not defined for 'rsakey_dict'.",
          "382:   <Side Effects>",
          "383:     None.",
          "385:   <Returns>",
          "386:     Signature dictionary conformant to securesystemslib.formats.SIGNATURE_SCHEMA.",
          "387:     Has the form:",
          "388:     {'keyid': keyid, 'method': 'evp', 'sig': sig}",
          "389:   \"\"\"",
          "391:   # We need 'signed' in canonical JSON format to generate",
          "392:   # the 'method' and 'sig' fields of the signature.",
          "393:   signed = securesystemslib.formats.encode_canonical(signed)",
          "395:   # Generate the RSA signature.",
          "396:   # Raises securesystemslib.exceptions.FormatError and TypeError.",
          "397:   signature = securesystemslib.keys.create_signature(rsakey_dict, signed)",
          "399:   return signature",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2018-1000159",
  "cve_desc": "tlslite-ng version 0.7.3 and earlier, since commit d7b288316bca7bcdd082e6ccff5491e241305233 contains a CWE-354: Improper Validation of Integrity Check Value vulnerability in TLS implementation, tlslite/utils/constanttime.py: ct_check_cbc_mac_and_pad(); line \"end_pos = data_len - 1 - mac.digest_size\" that can result in an attacker manipulating the TLS ciphertext which will not be detected by receiving tlslite-ng. This attack appears to be exploitable via man in the middle on a network connection. This vulnerability appears to have been fixed after commit 3674815d1b0f7484454995e2737a352e0a6a93d8.",
  "repo": "tlsfuzzer/tlslite-ng",
  "patch_hash": "d7b288316bca7bcdd082e6ccff5491e241305233",
  "patch_info": {
    "commit_hash": "d7b288316bca7bcdd082e6ccff5491e241305233",
    "repo": "tlsfuzzer/tlslite-ng",
    "commit_url": "https://github.com/tlsfuzzer/tlslite-ng/commit/d7b288316bca7bcdd082e6ccff5491e241305233",
    "files": [
      "tlslite/utils/constanttime.py",
      "unit_tests/test_tlslite_utils_constanttime.py"
    ],
    "message": "constant time implementation of CBC mac and pad check\n\nto protect against Lucky 13 attacks, we need to check both the\nhash and padding in constant time, independent of the length of\npadding",
    "before_after_code_files": [
      "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py",
      "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
    ]
  },
  "patch_diff": {
    "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py": [
      "File: tlslite/utils/constanttime.py -> tlslite/utils/constanttime.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: # Copyright (c) 2015, Hubert Kario",
      "2: #",
      "3: # See the LICENSE file for legal information regarding use of this file.",
      "4: \"\"\"Various constant time functions for processing sensitive data\"\"\"",
      "6: from __future__ import division",
      "8: from .compat import compatHMAC",
      "9: import hmac",
      "11: def ct_lt_u32(val_a, val_b):",
      "12:     \"\"\"",
      "13:     Returns 1 if val_a < val_b, 0 otherwise. Constant time.",
      "15:     @type val_a: int",
      "16:     @type val_b: int",
      "17:     @param val_a: an unsigned integer representable as a 32 bit value",
      "18:     @param val_b: an unsigned integer representable as a 32 bit value",
      "19:     @rtype: int",
      "20:     \"\"\"",
      "21:     val_a &= 0xffffffff",
      "22:     val_b &= 0xffffffff",
      "24:     return (val_a^((val_a^val_b)|(((val_a-val_b)&0xffffffff)^val_b)))>>31",
      "26: def ct_gt_u32(val_a, val_b):",
      "27:     \"\"\"",
      "28:     Return 1 if val_a > val_b, 0 otherwise. Constant time.",
      "30:     @type val_a: int",
      "31:     @type val_b: int",
      "32:     @param val_a: an unsigned integer representable as a 32 bit value",
      "33:     @param val_b: an unsigned integer representable as a 32 bit value",
      "34:     @rtype: int",
      "35:     \"\"\"",
      "36:     return ct_lt_u32(val_b, val_a)",
      "38: def ct_le_u32(val_a, val_b):",
      "39:     \"\"\"",
      "40:     Return 1 if val_a <= val_b, 0 otherwise. Constant time.",
      "42:     @type val_a: int",
      "43:     @type val_b: int",
      "44:     @param val_a: an unsigned integer representable as a 32 bit value",
      "45:     @param val_b: an unsigned integer representable as a 32 bit value",
      "46:     @rtype: int",
      "47:     \"\"\"",
      "48:     return 1 ^ ct_gt_u32(val_a, val_b)",
      "50: def ct_lsb_prop_u8(val):",
      "51:     \"\"\"Propagate LSB to all 8 bits of the returned byte. Constant time.\"\"\"",
      "52:     val &= 0x01",
      "53:     val |= val << 1",
      "54:     val |= val << 2",
      "55:     val |= val << 4",
      "56:     return val",
      "58: def ct_isnonzero_u32(val):",
      "59:     \"\"\"",
      "60:     Returns 1 if val is != 0, 0 otherwise. Constant time.",
      "62:     @type val: int",
      "63:     @param val: an unsigned integer representable as a 32 bit value",
      "64:     @rtype: int",
      "65:     \"\"\"",
      "66:     val &= 0xffffffff",
      "67:     return (val|(-val&0xffffffff)) >> 31",
      "69: def ct_neq_u32(val_a, val_b):",
      "70:     \"\"\"",
      "71:     Return 1 if val_a != val_b, 0 otherwise. Constant time.",
      "73:     @type val_a: int",
      "74:     @type val_b: int",
      "75:     @param val_a: an unsigned integer representable as a 32 bit value",
      "76:     @param val_b: an unsigned integer representable as a 32 bit value",
      "77:     @rtype: int",
      "78:     \"\"\"",
      "79:     val_a &= 0xffffffff",
      "80:     val_b &= 0xffffffff",
      "82:     return (((val_a-val_b)&0xffffffff) | ((val_b-val_a)&0xffffffff)) >> 31",
      "84: def ct_eq_u32(val_a, val_b):",
      "85:     \"\"\"",
      "86:     Return 1 if val_a == val_b, 0 otherwise. Constant time.",
      "88:     @type val_a: int",
      "89:     @type val_b: int",
      "90:     @param val_a: an unsigned integer representable as a 32 bit value",
      "91:     @param val_b: an unsigned integer representable as a 32 bit value",
      "92:     @rtype: int",
      "93:     \"\"\"",
      "94:     return 1 ^ ct_neq_u32(val_a, val_b)",
      "96: def ct_check_cbc_mac_and_pad(data, mac, seqnumBytes, contentType, version):",
      "97:     \"\"\"",
      "98:     Check CBC cipher HMAC and padding. Close to constant time.",
      "100:     @type data: bytearray",
      "101:     @param data: data with HMAC value to test and padding",
      "103:     @type mac: hashlib mac",
      "104:     @param mac: empty HMAC, initialised with a key",
      "106:     @type seqnumBytes: bytearray",
      "107:     @param seqnumBytes: TLS sequence number, used as input to HMAC",
      "109:     @type contentType: int",
      "110:     @param contentType: a single byte, used as input to HMAC",
      "112:     @type version: tuple of int",
      "113:     @param version: a tuple of two ints, used as input to HMAC and to guide",
      "114:     checking of padding",
      "116:     @rtype: boolean",
      "117:     @return: True if MAC and pad is ok, False otherwise",
      "118:     \"\"\"",
      "119:     assert version in ((3, 0), (3, 1), (3, 2), (3, 3))",
      "121:     data_len = len(data)",
      "122:     if mac.digest_size + 1 > data_len: # data_len is public",
      "123:         return False",
      "125:     # 0 - OK",
      "126:     result = 0x00",
      "128:     #",
      "129:     # check padding",
      "130:     #",
      "131:     pad_length = data[data_len-1]",
      "132:     pad_start = data_len - pad_length - 1",
      "133:     pad_start = max(0, pad_start)",
      "135:     if version == (3, 0): # version is public",
      "136:         # in SSLv3 we can only check if pad is not longer than overall length",
      "138:         # subtract 1 for the pad length byte",
      "139:         mask = ct_lsb_prop_u8(ct_lt_u32(data_len-1, pad_length))",
      "140:         result |= mask",
      "141:     else:",
      "142:         start_pos = max(0, data_len - 256)",
      "143:         for i in range(start_pos, data_len):",
      "144:             # if pad_start < i: mask = 0xff; else: mask = 0x00",
      "145:             mask = ct_lsb_prop_u8(ct_le_u32(pad_start, i))",
      "146:             # if data[i] != pad_length and \"inside_pad\": result = False",
      "147:             result |= (data[i] ^ pad_length) & mask",
      "149:     #",
      "150:     # check MAC",
      "151:     #",
      "153:     # real place where mac starts and data ends",
      "154:     mac_start = pad_start - mac.digest_size",
      "155:     mac_start = max(0, mac_start)",
      "157:     # place to start processing",
      "158:     start_pos = max(0, data_len - (256 + mac.digest_size)) // mac.block_size",
      "159:     start_pos *= mac.block_size",
      "161:     # add start data",
      "162:     data_mac = mac.copy()",
      "163:     data_mac.update(compatHMAC(seqnumBytes))",
      "164:     data_mac.update(compatHMAC(bytearray([contentType])))",
      "165:     if version != (3, 0): # version is public",
      "166:         data_mac.update(compatHMAC(bytearray([version[0]])))",
      "167:         data_mac.update(compatHMAC(bytearray([version[1]])))",
      "168:     data_mac.update(compatHMAC(bytearray([mac_start >> 8])))",
      "169:     data_mac.update(compatHMAC(bytearray([mac_start & 0xff])))",
      "170:     data_mac.update(compatHMAC(data[:start_pos]))",
      "172:     # don't check past the array end (already checked to be >= zero)",
      "173:     end_pos = data_len - 1 - mac.digest_size",
      "175:     # calculate all possible",
      "176:     for i in range(start_pos, end_pos): # constant for given overall length",
      "177:         cur_mac = data_mac.copy()",
      "178:         cur_mac.update(compatHMAC(data[start_pos:i]))",
      "179:         mac_compare = bytearray(cur_mac.digest())",
      "180:         # compare the hash for real only if it's the place where mac is",
      "181:         # supposed to be",
      "182:         mask = ct_lsb_prop_u8(ct_eq_u32(i, mac_start))",
      "183:         for j in range(0, mac.digest_size): # digest_size is public",
      "184:             result |= (data[i+j] ^ mac_compare[j]) & mask",
      "186:     # return python boolean",
      "187:     return result == 0",
      "189: if hasattr(hmac, 'compare_digest'):",
      "190:     ct_compare_digest = hmac.compare_digest",
      "191: else:",
      "192:     def ct_compare_digest(val_a, val_b):",
      "193:         \"\"\"Compares if string like objects are equal. Constant time.\"\"\"",
      "194:         if len(val_a) != len(val_b):",
      "195:             return False",
      "197:         result = 0",
      "198:         for x, y in zip(val_a, val_b):",
      "199:             result |= x ^ y",
      "201:         return result == 0",
      "",
      "---------------"
    ],
    "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py": [
      "File: unit_tests/test_tlslite_utils_constanttime.py -> unit_tests/test_tlslite_utils_constanttime.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: # Copyright (c) 2015, Hubert Kario",
      "2: #",
      "3: # See the LICENSE file for legal information regarding use of this file.",
      "5: # compatibility with Python 2.6, for that we need unittest2 package,",
      "6: # which is not available on 3.3 or 3.4",
      "7: try:",
      "8:     import unittest2 as unittest",
      "9: except ImportError:",
      "10:     import unittest",
      "12: from tlslite.utils.constanttime import ct_lt_u32, ct_gt_u32, ct_le_u32, \\",
      "13:         ct_lsb_prop_u8, ct_isnonzero_u32, ct_neq_u32, ct_eq_u32, \\",
      "14:         ct_check_cbc_mac_and_pad, ct_compare_digest",
      "16: from tlslite.utils.compat import compatHMAC",
      "17: from tlslite.recordlayer import RecordLayer",
      "18: import hashlib",
      "19: import hmac",
      "21: class TestContanttime(unittest.TestCase):",
      "22:     def test_ct_lt_u32(self):",
      "23:         for i in range(0, 256):",
      "24:             for j in range(0, 256):",
      "25:                 self.assertEqual((i < j), (ct_lt_u32(i, j) == 1))",
      "27:         for i in range(2**32-256, 2**32):",
      "28:             for j in range(2**32-256, 2**32):",
      "29:                 self.assertEqual((i < j), (ct_lt_u32(i, j) == 1))",
      "31:         for i in range(0, 256):",
      "32:             for j in range(2**32-256, 2**32):",
      "33:                 self.assertEqual((i < j), (ct_lt_u32(i, j) == 1))",
      "35:         for i in range(2**32-256, 2**32):",
      "36:             for j in range(0, 256):",
      "37:                 self.assertEqual((i < j), (ct_lt_u32(i, j) == 1))",
      "39:     def test_ct_gt_u32(self):",
      "40:         for i in range(0, 256):",
      "41:             for j in range(0, 256):",
      "42:                 self.assertEqual((i > j), (ct_gt_u32(i, j) == 1))",
      "44:         for i in range(2**32-256, 2**32):",
      "45:             for j in range(2**32-256, 2**32):",
      "46:                 self.assertEqual((i > j), (ct_gt_u32(i, j) == 1))",
      "48:         for i in range(0, 256):",
      "49:             for j in range(2**32-256, 2**32):",
      "50:                 self.assertEqual((i > j), (ct_gt_u32(i, j) == 1))",
      "52:         for i in range(2**32-256, 2**32):",
      "53:             for j in range(0, 256):",
      "54:                 self.assertEqual((i > j), (ct_gt_u32(i, j) == 1))",
      "56:     def test_ct_le_u32(self):",
      "57:         for i in range(0, 256):",
      "58:             for j in range(0, 256):",
      "59:                 self.assertEqual((i <= j), (ct_le_u32(i, j) == 1))",
      "61:         for i in range(2**32-256, 2**32):",
      "62:             for j in range(2**32-256, 2**32):",
      "63:                 self.assertEqual((i <= j), (ct_le_u32(i, j) == 1))",
      "65:         for i in range(0, 256):",
      "66:             for j in range(2**32-256, 2**32):",
      "67:                 self.assertEqual((i <= j), (ct_le_u32(i, j) == 1))",
      "69:         for i in range(2**32-256, 2**32):",
      "70:             for j in range(0, 256):",
      "71:                 self.assertEqual((i <= j), (ct_le_u32(i, j) == 1))",
      "73:     def test_ct_lsb_prop_u8(self):",
      "74:         for i in range(0, 256):",
      "75:             self.assertEqual(((i & 0x1) == 1), (ct_lsb_prop_u8(i) == 0xff))",
      "76:             self.assertEqual(((i & 0x1) == 0), (ct_lsb_prop_u8(i) == 0x00))",
      "78:     def test_ct_isnonzero_u32(self):",
      "79:         for i in range(0, 256):",
      "80:             self.assertEqual((i != 0), (ct_isnonzero_u32(i) == 1))",
      "82:     def test_ct_neq_u32(self):",
      "83:         for i in range(0, 256):",
      "84:             for j in range(0, 256):",
      "85:                 self.assertEqual((i != j), (ct_neq_u32(i, j) == 1))",
      "87:         for i in range(2**32-128, 2**32):",
      "88:             for j in range(2**32-128, 2**32):",
      "89:                 self.assertEqual((i != j), (ct_neq_u32(i, j) == 1))",
      "91:     def test_ct_eq_u32(self):",
      "92:         for i in range(0, 256):",
      "93:             for j in range(0, 256):",
      "94:                 self.assertEqual((i == j), (ct_eq_u32(i, j) == 1))",
      "96:         for i in range(2**32-128, 2**32):",
      "97:             for j in range(2**32-128, 2**32):",
      "98:                 self.assertEqual((i == j), (ct_eq_u32(i, j) == 1))",
      "100: class TestContanttimeCBCCheck(unittest.TestCase):",
      "102:     @staticmethod",
      "103:     def data_prepare(application_data, seqnum_bytes, content_type, version,",
      "104:                      mac, key):",
      "105:         r_layer = RecordLayer(None)",
      "106:         r_layer.version = version",
      "108:         h = hmac.new(key, digestmod=mac)",
      "110:         digest = r_layer._calculateMAC(h, seqnum_bytes, content_type,",
      "111:                                        application_data)",
      "113:         return application_data + digest",
      "115:     def test_with_empty_data_and_minimum_pad(self):",
      "116:         key = compatHMAC(bytearray(20))",
      "117:         seqnum_bytes = bytearray(16)",
      "118:         content_type = 0x14",
      "119:         version = (3, 1)",
      "120:         application_data = bytearray(0)",
      "121:         mac = hashlib.sha1",
      "123:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "124:                                  version, mac, key)",
      "126:         padding = bytearray(b'\\x00')",
      "127:         data += padding",
      "129:         h = hmac.new(key, digestmod=mac)",
      "130:         h.block_size = mac().block_size # python2 workaround",
      "131:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "132:                                                  content_type, version))",
      "134:     def test_with_empty_data_and_maximum_pad(self):",
      "135:         key = compatHMAC(bytearray(20))",
      "136:         seqnum_bytes = bytearray(16)",
      "137:         content_type = 0x14",
      "138:         version = (3, 1)",
      "139:         application_data = bytearray(0)",
      "140:         mac = hashlib.sha1",
      "142:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "143:                                  version, mac, key)",
      "145:         padding = bytearray(b'\\xff'*256)",
      "146:         data += padding",
      "148:         h = hmac.new(key, digestmod=mac)",
      "149:         h.block_size = mac().block_size # python2 workaround",
      "150:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "151:                                                  content_type, version))",
      "153:     def test_with_little_data_and_minimum_pad(self):",
      "154:         key = compatHMAC(bytearray(20))",
      "155:         seqnum_bytes = bytearray(16)",
      "156:         content_type = 0x14",
      "157:         version = (3, 1)",
      "158:         application_data = bytearray(b'\\x01'*32)",
      "159:         mac = hashlib.sha1",
      "161:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "162:                                  version, mac, key)",
      "164:         padding = bytearray(b'\\x00')",
      "165:         data += padding",
      "167:         h = hmac.new(key, digestmod=mac)",
      "168:         h.block_size = mac().block_size # python2 workaround",
      "169:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "170:                                                  content_type, version))",
      "172:     def test_with_little_data_and_maximum_pad(self):",
      "173:         key = compatHMAC(bytearray(20))",
      "174:         seqnum_bytes = bytearray(16)",
      "175:         content_type = 0x14",
      "176:         version = (3, 1)",
      "177:         application_data = bytearray(b'\\x01'*32)",
      "178:         mac = hashlib.sha1",
      "180:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "181:                                  version, mac, key)",
      "183:         padding = bytearray(b'\\xff'*256)",
      "184:         data += padding",
      "186:         h = hmac.new(key, digestmod=mac)",
      "187:         h.block_size = mac().block_size # python2 workaround",
      "188:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "189:                                                  content_type, version))",
      "191:     def test_with_lots_of_data_and_minimum_pad(self):",
      "192:         key = compatHMAC(bytearray(20))",
      "193:         seqnum_bytes = bytearray(16)",
      "194:         content_type = 0x14",
      "195:         version = (3, 1)",
      "196:         application_data = bytearray(b'\\x01'*1024)",
      "197:         mac = hashlib.sha1",
      "199:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "200:                                  version, mac, key)",
      "202:         padding = bytearray(b'\\x00')",
      "203:         data += padding",
      "205:         h = hmac.new(key, digestmod=mac)",
      "206:         h.block_size = mac().block_size # python2 workaround",
      "207:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "208:                                                  content_type, version))",
      "210:     def test_with_lots_of_data_and_maximum_pad(self):",
      "211:         key = compatHMAC(bytearray(20))",
      "212:         seqnum_bytes = bytearray(16)",
      "213:         content_type = 0x14",
      "214:         version = (3, 1)",
      "215:         application_data = bytearray(b'\\x01'*1024)",
      "216:         mac = hashlib.sha1",
      "218:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "219:                                  version, mac, key)",
      "221:         padding = bytearray(b'\\xff'*256)",
      "222:         data += padding",
      "224:         h = hmac.new(key, digestmod=mac)",
      "225:         h.block_size = mac().block_size # python2 workaround",
      "226:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "227:                                                  content_type, version))",
      "229:     def test_with_lots_of_data_and_small_pad(self):",
      "230:         key = compatHMAC(bytearray(20))",
      "231:         seqnum_bytes = bytearray(16)",
      "232:         content_type = 0x14",
      "233:         version = (3, 1)",
      "234:         application_data = bytearray(b'\\x01'*1024)",
      "235:         mac = hashlib.sha1",
      "237:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "238:                                  version, mac, key)",
      "240:         padding = bytearray(b'\\x0a'*11)",
      "241:         data += padding",
      "243:         h = hmac.new(key, digestmod=mac)",
      "244:         h.block_size = mac().block_size # python2 workaround",
      "245:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "246:                                                  content_type, version))",
      "248:     def test_with_too_little_data(self):",
      "249:         key = compatHMAC(bytearray(20))",
      "250:         seqnum_bytes = bytearray(16)",
      "251:         content_type = 0x14",
      "252:         version = (3, 1)",
      "253:         mac = hashlib.sha1",
      "255:         data = bytearray(mac().digest_size)",
      "257:         h = hmac.new(key, digestmod=mac)",
      "258:         h.block_size = mac().block_size # python2 workaround",
      "259:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "260:                                                   content_type, version))",
      "262:     def test_with_invalid_hash(self):",
      "263:         key = compatHMAC(bytearray(20))",
      "264:         seqnum_bytes = bytearray(16)",
      "265:         content_type = 0x14",
      "266:         version = (3, 1)",
      "267:         application_data = bytearray(b'\\x01'*1024)",
      "268:         mac = hashlib.sha1",
      "270:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "271:                                  version, mac, key)",
      "272:         data[-1] ^= 0xff",
      "274:         padding = bytearray(b'\\xff'*256)",
      "275:         data += padding",
      "277:         h = hmac.new(key, digestmod=mac)",
      "278:         h.block_size = mac().block_size # python2 workaround",
      "279:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "280:                                                   content_type, version))",
      "282:     def test_with_invalid_pad(self):",
      "283:         key = compatHMAC(bytearray(20))",
      "284:         seqnum_bytes = bytearray(16)",
      "285:         content_type = 0x14",
      "286:         version = (3, 1)",
      "287:         application_data = bytearray(b'\\x01'*1024)",
      "288:         mac = hashlib.sha1",
      "290:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "291:                                  version, mac, key)",
      "293:         padding = bytearray(b'\\x00' + b'\\xff'*255)",
      "294:         data += padding",
      "296:         h = hmac.new(key, digestmod=mac)",
      "297:         h.block_size = mac().block_size # python2 workaround",
      "298:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "299:                                                   content_type, version))",
      "301:     def test_with_pad_longer_than_data(self):",
      "302:         key = compatHMAC(bytearray(20))",
      "303:         seqnum_bytes = bytearray(16)",
      "304:         content_type = 0x14",
      "305:         version = (3, 1)",
      "306:         application_data = bytearray(b'\\x01')",
      "307:         mac = hashlib.sha1",
      "309:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "310:                                  version, mac, key)",
      "312:         padding = bytearray(b'\\xff')",
      "313:         data += padding",
      "315:         h = hmac.new(key, digestmod=mac)",
      "316:         h.block_size = mac().block_size # python2 workaround",
      "317:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "318:                                                   content_type, version))",
      "320:     def test_with_pad_longer_than_data_in_SSLv3(self):",
      "321:         key = compatHMAC(bytearray(20))",
      "322:         seqnum_bytes = bytearray(16)",
      "323:         content_type = 0x14",
      "324:         version = (3, 0)",
      "325:         application_data = bytearray(b'\\x01')",
      "326:         mac = hashlib.sha1",
      "328:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "329:                                  version, mac, key)",
      "331:         padding = bytearray([len(application_data) + mac().digest_size + 1])",
      "332:         data += padding",
      "334:         h = hmac.new(key, digestmod=mac)",
      "335:         h.block_size = mac().block_size # python2 workaround",
      "336:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "337:                                                   content_type, version))",
      "339:     def test_with_null_pad_in_SSLv3(self):",
      "340:         key = compatHMAC(bytearray(20))",
      "341:         seqnum_bytes = bytearray(16)",
      "342:         content_type = 0x14",
      "343:         version = (3, 0)",
      "344:         application_data = bytearray(b'\\x01'*10)",
      "345:         mac = hashlib.md5",
      "347:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "348:                                  version, mac, key)",
      "350:         padding = bytearray(b'\\x00'*10 + b'\\x0a')",
      "351:         data += padding",
      "353:         h = hmac.new(key, digestmod=mac)",
      "354:         h.block_size = mac().block_size # python2 workaround",
      "355:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "356:                                                  content_type, version))",
      "358:     def test_with_MD5(self):",
      "359:         key = compatHMAC(bytearray(20))",
      "360:         seqnum_bytes = bytearray(16)",
      "361:         content_type = 0x14",
      "362:         version = (3, 1)",
      "363:         application_data = bytearray(b'\\x01'*10)",
      "364:         mac = hashlib.md5",
      "366:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "367:                                  version, mac, key)",
      "369:         padding = bytearray(b'\\x0a'*11)",
      "370:         data += padding",
      "372:         h = hmac.new(key, digestmod=mac)",
      "373:         h.block_size = mac().block_size # python2 workaround",
      "374:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "375:                                                  content_type, version))",
      "377:     def test_with_SHA256(self):",
      "378:         key = compatHMAC(bytearray(20))",
      "379:         seqnum_bytes = bytearray(16)",
      "380:         content_type = 0x14",
      "381:         version = (3, 3)",
      "382:         application_data = bytearray(b'\\x01'*10)",
      "383:         mac = hashlib.sha256",
      "385:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "386:                                  version, mac, key)",
      "388:         padding = bytearray(b'\\x0a'*11)",
      "389:         data += padding",
      "391:         h = hmac.new(key, digestmod=mac)",
      "392:         h.block_size = mac().block_size # python2 workaround",
      "393:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "394:                                                  content_type, version))",
      "396:     def test_with_SHA384(self):",
      "397:         key = compatHMAC(bytearray(20))",
      "398:         seqnum_bytes = bytearray(16)",
      "399:         content_type = 0x14",
      "400:         version = (3, 3)",
      "401:         application_data = bytearray(b'\\x01'*10)",
      "402:         mac = hashlib.sha384",
      "404:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
      "405:                                  version, mac, key)",
      "407:         padding = bytearray(b'\\x0a'*11)",
      "408:         data += padding",
      "410:         h = hmac.new(key, digestmod=mac)",
      "411:         h.block_size = mac().block_size # python2 workaround",
      "412:         self.assertTrue(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
      "413:                                                  content_type, version))",
      "415: class TestCompareDigest(unittest.TestCase):",
      "416:     def test_with_equal_length(self):",
      "417:         self.assertTrue(ct_compare_digest(bytearray(10), bytearray(10)))",
      "419:         self.assertTrue(ct_compare_digest(bytearray(b'\\x02'*8),",
      "420:                                           bytearray(b'\\x02'*8)))",
      "422:     def test_different_lengths(self):",
      "423:         self.assertFalse(ct_compare_digest(bytearray(10), bytearray(12)))",
      "425:         self.assertFalse(ct_compare_digest(bytearray(20), bytearray(12)))",
      "427:     def test_different(self):",
      "428:         self.assertFalse(ct_compare_digest(bytearray(b'\\x01'),",
      "429:                                            bytearray(b'\\x03')))",
      "431:         self.assertFalse(ct_compare_digest(bytearray(b'\\x01'*10 + b'\\x02'),",
      "432:                                            bytearray(b'\\x01'*10 + b'\\x03')))",
      "434:         self.assertFalse(ct_compare_digest(bytearray(b'\\x02' + b'\\x01'*10),",
      "435:                                            bytearray(b'\\x03' + b'\\x01'*10)))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "60d4f1c6ea70308f07f4999626bb60a81758eb17",
      "candidate_info": {
        "commit_hash": "60d4f1c6ea70308f07f4999626bb60a81758eb17",
        "repo": "tlsfuzzer/tlslite-ng",
        "commit_url": "https://github.com/tlsfuzzer/tlslite-ng/commit/60d4f1c6ea70308f07f4999626bb60a81758eb17",
        "files": [
          "tlslite/mathtls.py",
          "tlslite/recordlayer.py"
        ],
        "message": "fix Lucky 13, mostly\n\nbecause variables in python are stored in hashtables, it's not\npossible to make a real constant time implementation,\ndo a best effort anyway",
        "before_after_code_files": [
          "tlslite/mathtls.py||tlslite/mathtls.py",
          "tlslite/recordlayer.py||tlslite/recordlayer.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/tlsfuzzer/tlslite-ng/pull/23"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tlslite/mathtls.py||tlslite/mathtls.py": [
          "File: tlslite/mathtls.py -> tlslite/mathtls.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "131:   return bytesToNumber(SHA1(numberToByteArray(N) + PAD(N, g)))",
          "133: def createHMAC(k, digestmod=hashlib.sha1):",
          "136: def createMAC_SSL(k, digestmod=None):",
          "137:     mac = MAC_SSL()",
          "",
          "[Removed Lines]",
          "134:     return hmac.HMAC(k, digestmod=digestmod)",
          "",
          "[Added Lines]",
          "134:     h = hmac.HMAC(k, digestmod=digestmod)",
          "135:     h.block_size = digestmod().block_size",
          "136:     return h",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "142: class MAC_SSL(object):",
          "143:     def create(self, k, digestmod=None):",
          "144:         self.digestmod = digestmod or hashlib.sha1",
          "145:         # Repeat pad bytes 48 times for MD5; 40 times for other hash functions.",
          "146:         self.digest_size = 16 if (self.digestmod is hashlib.md5) else 20",
          "147:         repeat = 40 if self.digest_size == 20 else 48",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "147:         self.block_size = self.digestmod().block_size",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "160:         new.ohash = self.ohash.copy()",
          "161:         new.digestmod = self.digestmod",
          "162:         new.digest_size = self.digest_size",
          "163:         return new",
          "165:     def digest(self):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "166:         new.block_size = self.block_size",
          "",
          "---------------"
        ],
        "tlslite/recordlayer.py||tlslite/recordlayer.py": [
          "File: tlslite/recordlayer.py -> tlslite/recordlayer.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: from .utils.codec import Parser, Writer",
          "15: from .utils.compat import compatHMAC",
          "16: from .utils.cryptomath import getRandomBytes",
          "17: from .errors import TLSRecordOverflow, TLSIllegalParameterException,\\",
          "18:         TLSAbruptCloseError, TLSDecryptionFailed, TLSBadRecordMAC",
          "19: from .mathtls import createMAC_SSL, createHMAC, PRF_SSL, PRF, PRF_1_2, \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: from .utils.constanttime import ct_compare_digest, ct_check_cbc_mac_and_pad",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "446:                                               data)",
          "448:                 #Compare MACs",
          "450:                     macGood = False",
          "452:             if not macGood:",
          "",
          "[Removed Lines]",
          "449:                 if macBytes != checkBytes:",
          "",
          "[Added Lines]",
          "450:                 if not ct_compare_digest(macBytes, checkBytes):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "458:     def _decryptThenMAC(self, recordType, data):",
          "459:         \"\"\"Decrypt data, check padding and MAC\"\"\"",
          "462:         if self._readState.encContext:",
          "463:             assert self.version in ((3, 0), (3, 1), (3, 2), (3, 3))",
          "464:             assert self._readState.encContext.isBlockCipher",
          "466:             blockLength = self._readState.encContext.block_size",
          "467:             if len(data) % blockLength != 0:",
          "468:                 raise TLSDecryptionFailed()",
          "",
          "[Removed Lines]",
          "460:         totalPaddingLength = 0",
          "461:         paddingGood = True",
          "",
          "[Added Lines]",
          "464:             assert self._readState.macContext",
          "466:             #",
          "467:             # decrypt the record",
          "468:             #",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "470:             if self.version >= (3, 2): #For TLS 1.1, remove explicit IV",
          "471:                 data = data[self._readState.encContext.block_size : ]",
          "516:         return data",
          "",
          "[Removed Lines]",
          "473:             #Check padding",
          "474:             paddingGood = True",
          "475:             paddingLength = data[-1]",
          "476:             if (paddingLength+1) > len(data):",
          "477:                 paddingGood = False",
          "478:                 totalPaddingLength = 0",
          "479:             else:",
          "480:                 totalPaddingLength = paddingLength+1",
          "481:                 if self.version != (3, 0):",
          "482:                     # check if all padding bytes have correct value",
          "483:                     paddingBytes = data[-totalPaddingLength:-1]",
          "484:                     for byte in paddingBytes:",
          "485:                         if byte != paddingLength:",
          "486:                             paddingGood = False",
          "487:                             totalPaddingLength = 0",
          "489:         if self._readState.macContext:",
          "490:             #Check MAC",
          "491:             macGood = True",
          "492:             macLength = self._readState.macContext.digest_size",
          "493:             endLength = macLength + totalPaddingLength",
          "494:             if endLength > len(data):",
          "495:                 macGood = False",
          "496:             else:",
          "497:                 #Read MAC",
          "498:                 startIndex = len(data) - endLength",
          "499:                 endIndex = startIndex + macLength",
          "500:                 checkBytes = data[startIndex : endIndex]",
          "502:                 #Calculate MAC",
          "503:                 seqnumBytes = self._readState.getSeqNumBytes()",
          "504:                 data = data[:-endLength]",
          "505:                 mac = self._readState.macContext.copy()",
          "506:                 macBytes = self._calculateMAC(mac, seqnumBytes, recordType,",
          "507:                                               data)",
          "509:                 #Compare MACs",
          "510:                 if macBytes != checkBytes:",
          "511:                     macGood = False",
          "513:             if not (paddingGood and macGood):",
          "514:                 raise TLSBadRecordMAC()",
          "",
          "[Added Lines]",
          "476:             #",
          "477:             # check padding and MAC",
          "478:             #",
          "479:             seqnumBytes = self._readState.getSeqNumBytes()",
          "481:             if not ct_check_cbc_mac_and_pad(data,",
          "482:                                             self._readState.macContext,",
          "483:                                             seqnumBytes,",
          "484:                                             recordType,",
          "485:                                             self.version):",
          "486:                 raise TLSBadRecordMAC()",
          "488:             #",
          "489:             # strip padding and MAC",
          "490:             #",
          "492:             endLength = data[-1] + 1 + self._readState.macContext.digest_size",
          "494:             data = data[:-endLength]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "536:             macBytes = self._calculateMAC(mac, seqnumBytes, recordType, buf)",
          "539:                 raise TLSBadRecordMAC(\"MAC mismatch\")",
          "541:         if self._readState.encContext:",
          "",
          "[Removed Lines]",
          "538:             if macBytes != checkBytes:",
          "",
          "[Added Lines]",
          "518:             if not ct_compare_digest(macBytes, checkBytes):",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "92ee55122ea35a498d0df36d7f636f852d1d09dd",
      "candidate_info": {
        "commit_hash": "92ee55122ea35a498d0df36d7f636f852d1d09dd",
        "repo": "tlsfuzzer/tlslite-ng",
        "commit_url": "https://github.com/tlsfuzzer/tlslite-ng/commit/92ee55122ea35a498d0df36d7f636f852d1d09dd",
        "files": [
          "tlslite/recordlayer.py",
          "unit_tests/test_tlslite_recordlayer.py"
        ],
        "message": "split stream cipher reading from CBC ciphers reading\n\nsince timing of operations is critical for CBC ciphers and is\nof secondary importance for stream ciphers, don't process them\nin same method",
        "before_after_code_files": [
          "tlslite/recordlayer.py||tlslite/recordlayer.py",
          "unit_tests/test_tlslite_recordlayer.py||unit_tests/test_tlslite_recordlayer.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/tlsfuzzer/tlslite-ng/pull/23"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tlslite/recordlayer.py||tlslite/recordlayer.py": [
          "File: tlslite/recordlayer.py -> tlslite/recordlayer.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "418:     # receiving messages",
          "419:     #",
          "421:     def _decryptThenMAC(self, recordType, data):",
          "422:         \"\"\"Decrypt data, check padding and MAC\"\"\"",
          "423:         totalPaddingLength = 0",
          "424:         paddingGood = True",
          "425:         if self._readState.encContext:",
          "426:             assert self.version in ((3, 0), (3, 1), (3, 2), (3, 3))",
          "454:             else:",
          "457:         if self._readState.macContext:",
          "458:             #Check MAC",
          "",
          "[Removed Lines]",
          "428:             #Decrypt if it's a block cipher",
          "429:             if self._readState.encContext.isBlockCipher:",
          "430:                 blockLength = self._readState.encContext.block_size",
          "431:                 if len(data) % blockLength != 0:",
          "432:                     raise TLSDecryptionFailed()",
          "433:                 data = self._readState.encContext.decrypt(data)",
          "434:                 if self.version >= (3, 2): #For TLS 1.1, remove explicit IV",
          "435:                     data = data[self._readState.encContext.block_size : ]",
          "437:                 #Check padding",
          "438:                 paddingGood = True",
          "439:                 paddingLength = data[-1]",
          "440:                 if (paddingLength+1) > len(data):",
          "441:                     paddingGood = False",
          "442:                     totalPaddingLength = 0",
          "443:                 else:",
          "444:                     totalPaddingLength = paddingLength+1",
          "445:                     if self.version != (3, 0):",
          "446:                         # check if all padding bytes have correct value",
          "447:                         paddingBytes = data[-totalPaddingLength:-1]",
          "448:                         for byte in paddingBytes:",
          "449:                             if byte != paddingLength:",
          "450:                                 paddingGood = False",
          "451:                                 totalPaddingLength = 0",
          "453:             #Decrypt if it's a stream cipher",
          "455:                 data = self._readState.encContext.decrypt(data)",
          "",
          "[Added Lines]",
          "421:     def _decryptStreamThenMAC(self, recordType, data):",
          "422:         \"\"\"Decrypt a stream cipher and check MAC\"\"\"",
          "423:         if self._readState.encContext:",
          "424:             assert self.version in ((3, 0), (3, 1), (3, 2), (3, 3))",
          "426:             data = self._readState.encContext.decrypt(data)",
          "428:         if self._readState.macContext:",
          "429:             #Check MAC",
          "430:             macGood = True",
          "431:             macLength = self._readState.macContext.digest_size",
          "432:             endLength = macLength",
          "433:             if endLength > len(data):",
          "434:                 macGood = False",
          "435:             else:",
          "436:                 #Read MAC",
          "437:                 startIndex = len(data) - endLength",
          "438:                 endIndex = startIndex + macLength",
          "439:                 checkBytes = data[startIndex : endIndex]",
          "441:                 #Calculate MAC",
          "442:                 seqnumBytes = self._readState.getSeqNumBytes()",
          "443:                 data = data[:-endLength]",
          "444:                 mac = self._readState.macContext.copy()",
          "445:                 macBytes = self._calculateMAC(mac, seqnumBytes, recordType,",
          "446:                                               data)",
          "448:                 #Compare MACs",
          "449:                 if macBytes != checkBytes:",
          "450:                     macGood = False",
          "452:             if not macGood:",
          "453:                 raise TLSBadRecordMAC()",
          "455:         return data",
          "464:             assert self._readState.encContext.isBlockCipher",
          "466:             blockLength = self._readState.encContext.block_size",
          "467:             if len(data) % blockLength != 0:",
          "468:                 raise TLSDecryptionFailed()",
          "469:             data = self._readState.encContext.decrypt(data)",
          "470:             if self.version >= (3, 2): #For TLS 1.1, remove explicit IV",
          "471:                 data = data[self._readState.encContext.block_size : ]",
          "473:             #Check padding",
          "474:             paddingGood = True",
          "475:             paddingLength = data[-1]",
          "476:             if (paddingLength+1) > len(data):",
          "477:                 paddingGood = False",
          "478:                 totalPaddingLength = 0",
          "480:                 totalPaddingLength = paddingLength+1",
          "481:                 if self.version != (3, 0):",
          "482:                     # check if all padding bytes have correct value",
          "483:                     paddingBytes = data[-totalPaddingLength:-1]",
          "484:                     for byte in paddingBytes:",
          "485:                         if byte != paddingLength:",
          "486:                             paddingGood = False",
          "487:                             totalPaddingLength = 0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "592:             data = self._decryptAndUnseal(header.type, data)",
          "593:         elif self.encryptThenMAC:",
          "594:             data = self._macThenDecrypt(header.type, data)",
          "596:             data = self._decryptThenMAC(header.type, data)",
          "598:         yield (header, Parser(data))",
          "",
          "[Removed Lines]",
          "595:         else:",
          "",
          "[Added Lines]",
          "627:         elif self._readState and \\",
          "628:                 self._readState.encContext and \\",
          "629:                 self._readState.encContext.isBlockCipher:",
          "631:         else:",
          "632:             data = self._decryptStreamThenMAC(header.type, data)",
          "",
          "---------------"
        ],
        "unit_tests/test_tlslite_recordlayer.py||unit_tests/test_tlslite_recordlayer.py": [
          "File: unit_tests/test_tlslite_recordlayer.py -> unit_tests/test_tlslite_recordlayer.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "1170:         self.assertEqual((3, 1), header.version)",
          "1171:         self.assertEqual(bytearray(b'test'), parser.bytes)",
          "1173:     def test_recvRecord_with_invalid_length_payload(self):",
          "1174:         sock = MockSocket(bytearray(",
          "1175:             b'\\x17' +           # application data",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1173:     def test_recvRecord_with_stream_cipher_and_tls1_0_and_incorrect_data(self):",
          "1174:         sock = MockSocket(bytearray(",
          "1175:             b'\\x17' +           # application data",
          "1176:             b'\\x03\\x01' +       # TLSv1.0",
          "1177:             b'\\x00\\x18' +       # length (24 bytes)",
          "1178:             # data from test_sendRecord_with_stream_cipher_and_tls1_0",
          "1179:             # last byte changed from \\x1e to \\x0e",
          "1180:             b'B\\xb8H\\xc6\\xd7\\\\\\x01\\xe27\\xa9\\x86\\xf2\\xfdm!\\x1d' +",
          "1181:             b'\\xa1\\xaf]Q%y5\\x0e'",
          "1182:             ))",
          "1184:         recordLayer = RecordLayer(sock)",
          "1185:         recordLayer.client = False",
          "1186:         recordLayer.version = (3, 1)",
          "1187:         recordLayer.calcPendingStates(CipherSuite.TLS_RSA_WITH_RC4_128_SHA,",
          "1188:                                       bytearray(48), # master secret",
          "1189:                                       bytearray(32), # client random",
          "1190:                                       bytearray(32), # server random",
          "1191:                                       None)",
          "1192:         recordLayer.changeReadState()",
          "1194:         with self.assertRaises(TLSBadRecordMAC):",
          "1195:             for result in recordLayer.recvRecord():",
          "1196:                 if result in (0, 1):",
          "1197:                     self.assertTrue(False, \"Blocking read\")",
          "1198:                 else:",
          "1199:                     break",
          "1201:     def test_recvRecord_with_stream_cipher_and_tls1_0_and_too_short_data(self):",
          "1202:         sock = MockSocket(bytearray(",
          "1203:             b'\\x17' +           # application data",
          "1204:             b'\\x03\\x01' +       # TLSv1.0",
          "1205:             b'\\x00\\x13' +       # length (19 bytes)",
          "1206:             # data from test_sendRecord_with_stream_cipher_and_tls1_0",
          "1207:             b'B\\xb8H\\xc6\\xd7\\\\\\x01\\xe27\\xa9\\x86\\xf2\\xfdm!\\x1d' +",
          "1208:             b'\\xa1\\xaf]'",
          "1209:             ))",
          "1211:         recordLayer = RecordLayer(sock)",
          "1212:         recordLayer.client = False",
          "1213:         recordLayer.version = (3, 1)",
          "1214:         recordLayer.calcPendingStates(CipherSuite.TLS_RSA_WITH_RC4_128_SHA,",
          "1215:                                       bytearray(48), # master secret",
          "1216:                                       bytearray(32), # client random",
          "1217:                                       bytearray(32), # server random",
          "1218:                                       None)",
          "1219:         recordLayer.changeReadState()",
          "1221:         with self.assertRaises(TLSBadRecordMAC):",
          "1222:             for result in recordLayer.recvRecord():",
          "1223:                 if result in (0, 1):",
          "1224:                     self.assertTrue(False, \"Blocking read\")",
          "1225:                 else:",
          "1226:                     break",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7688d405fceb410670557049c9e3c97dc300b87c",
      "candidate_info": {
        "commit_hash": "7688d405fceb410670557049c9e3c97dc300b87c",
        "repo": "tlsfuzzer/tlslite-ng",
        "commit_url": "https://github.com/tlsfuzzer/tlslite-ng/commit/7688d405fceb410670557049c9e3c97dc300b87c",
        "files": [
          "tlslite/recordlayer.py",
          "unit_tests/test_tlslite_utils_constanttime.py"
        ],
        "message": "expose calculateMAC function",
        "before_after_code_files": [
          "tlslite/recordlayer.py||tlslite/recordlayer.py",
          "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
          ],
          "candidate": [
            "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
          ]
        }
      },
      "candidate_diff": {
        "tlslite/recordlayer.py||tlslite/recordlayer.py": [
          "File: tlslite/recordlayer.py -> tlslite/recordlayer.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "307:         data += paddingBytes",
          "308:         return data",
          "311:         \"\"\"Calculate the SSL/TLS version of a MAC\"\"\"",
          "312:         mac.update(compatHMAC(seqnumBytes))",
          "313:         mac.update(compatHMAC(bytearray([contentType])))",
          "",
          "[Removed Lines]",
          "310:     def _calculateMAC(self, mac, seqnumBytes, contentType, data):",
          "",
          "[Added Lines]",
          "310:     def calculateMAC(self, mac, seqnumBytes, contentType, data):",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "325:         if self._writeState.macContext:",
          "326:             seqnumBytes = self._writeState.getSeqNumBytes()",
          "327:             mac = self._writeState.macContext.copy()",
          "329:             data += macBytes",
          "331:         #Encrypt for Block or Stream Cipher",
          "",
          "[Removed Lines]",
          "328:             macBytes = self._calculateMAC(mac, seqnumBytes, contentType, data)",
          "",
          "[Added Lines]",
          "328:             macBytes = self.calculateMAC(mac, seqnumBytes, contentType, data)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "361:             mac = self._writeState.macContext.copy()",
          "363:             # append MAC",
          "365:             buf += macBytes",
          "367:         return buf",
          "",
          "[Removed Lines]",
          "364:             macBytes = self._calculateMAC(mac, seqnumBytes, contentType, buf)",
          "",
          "[Added Lines]",
          "364:             macBytes = self.calculateMAC(mac, seqnumBytes, contentType, buf)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "443:                 seqnumBytes = self._readState.getSeqNumBytes()",
          "444:                 data = data[:-endLength]",
          "445:                 mac = self._readState.macContext.copy()",
          "449:                 #Compare MACs",
          "450:                 if not ct_compare_digest(macBytes, checkBytes):",
          "",
          "[Removed Lines]",
          "446:                 macBytes = self._calculateMAC(mac, seqnumBytes, recordType,",
          "447:                                               data)",
          "",
          "[Added Lines]",
          "446:                 macBytes = self.calculateMAC(mac, seqnumBytes, recordType,",
          "447:                                              data)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "513:             seqnumBytes = self._readState.getSeqNumBytes()",
          "514:             mac = self._readState.macContext.copy()",
          "518:             if not ct_compare_digest(macBytes, checkBytes):",
          "519:                 raise TLSBadRecordMAC(\"MAC mismatch\")",
          "",
          "[Removed Lines]",
          "516:             macBytes = self._calculateMAC(mac, seqnumBytes, recordType, buf)",
          "",
          "[Added Lines]",
          "516:             macBytes = self.calculateMAC(mac, seqnumBytes, recordType, buf)",
          "",
          "---------------"
        ],
        "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py": [
          "File: unit_tests/test_tlslite_utils_constanttime.py -> unit_tests/test_tlslite_utils_constanttime.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "108:         h = hmac.new(key, digestmod=mac)",
          "113:         return application_data + digest",
          "",
          "[Removed Lines]",
          "110:         digest = r_layer._calculateMAC(h, seqnum_bytes, content_type,",
          "111:                                        application_data)",
          "",
          "[Added Lines]",
          "110:         digest = r_layer.calculateMAC(h, seqnum_bytes, content_type,",
          "111:                                       application_data)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3674815d1b0f7484454995e2737a352e0a6a93d8",
      "candidate_info": {
        "commit_hash": "3674815d1b0f7484454995e2737a352e0a6a93d8",
        "repo": "tlsfuzzer/tlslite-ng",
        "commit_url": "https://github.com/tlsfuzzer/tlslite-ng/pull/234/commits/3674815d1b0f7484454995e2737a352e0a6a93d8",
        "files": [
          "tlslite/utils/constanttime.py",
          "unit_tests/test_tlslite_utils_constanttime.py"
        ],
        "message": "verify the mac even if the padding is 1 byte long\n\noff-by-one error on mac checking, if the padding is of\nminimal length (a single 0x00 byte), the mac is not\nchecked and thus the return value is never falsified\n\nthis fixes the issue",
        "before_after_code_files": [
          "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py",
          "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py",
            "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
          ],
          "candidate": [
            "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py",
            "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
          ]
        }
      },
      "candidate_diff": {
        "tlslite/utils/constanttime.py||tlslite/utils/constanttime.py": [
          "File: tlslite/utils/constanttime.py -> tlslite/utils/constanttime.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "170:     data_mac.update(compatHMAC(data[:start_pos]))",
          "172:     # don't check past the array end (already checked to be >= zero)",
          "175:     # calculate all possible",
          "176:     for i in range(start_pos, end_pos): # constant for given overall length",
          "",
          "[Removed Lines]",
          "173:     end_pos = data_len - 1 - mac.digest_size",
          "",
          "[Added Lines]",
          "173:     end_pos = data_len - mac.digest_size",
          "",
          "---------------"
        ],
        "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py": [
          "File: unit_tests/test_tlslite_utils_constanttime.py -> unit_tests/test_tlslite_utils_constanttime.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: from hypothesis import given, example",
          "17: import hypothesis.strategies as st",
          "18: from tlslite.utils.compat import compatHMAC",
          "19: from tlslite.recordlayer import RecordLayer",
          "20: import tlslite.utils.tlshashlib as hashlib",
          "21: import hmac",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: from tlslite.utils.cryptomath import getRandomBytes",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "266:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "267:                                                   content_type, version))",
          "269:     def test_with_invalid_pad(self):",
          "270:         key = compatHMAC(bytearray(20))",
          "271:         seqnum_bytes = bytearray(16)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "270:     @given(i=st.integers(1, 20))",
          "271:     def test_with_invalid_random_hash(self, i):",
          "272:         key = compatHMAC(getRandomBytes(20))",
          "273:         seqnum_bytes = bytearray(16)",
          "274:         content_type = 0x15",
          "275:         version = (3, 3)",
          "276:         application_data = getRandomBytes(63)",
          "277:         mac = hashlib.sha1",
          "279:         data = self.data_prepare(application_data, seqnum_bytes, content_type,",
          "280:                                  version, mac, key)",
          "281:         data[-i] ^= 0xff",
          "282:         padding = bytearray(b'\\x00')",
          "283:         data += padding",
          "285:         h = hmac.new(key, digestmod=mac)",
          "286:         h.block_size = mac().block_size",
          "287:         self.assertFalse(ct_check_cbc_mac_and_pad(data, h, seqnum_bytes,",
          "288:                                                   content_type, version))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "00f1997b628b0be9844bbd5cc37f4ac72214dab1",
      "candidate_info": {
        "commit_hash": "00f1997b628b0be9844bbd5cc37f4ac72214dab1",
        "repo": "tlsfuzzer/tlslite-ng",
        "commit_url": "https://github.com/tlsfuzzer/tlslite-ng/commit/00f1997b628b0be9844bbd5cc37f4ac72214dab1",
        "files": [
          "tlslite/handshakehashes.py",
          "tlslite/mathtls.py",
          "tlslite/recordlayer.py",
          "tlslite/utils/cryptomath.py",
          "tlslite/utils/tlshashlib.py",
          "unit_tests/test_tlslite_utils_constanttime.py",
          "unit_tests/test_tlslite_utils_cryptomath_m2crypto.py",
          "unit_tests/test_tlslite_utils_tlshashlib.py"
        ],
        "message": "Workaround FIPS limitations\n\nIn FIPS mode use of MD5 is restricted while use of RC4 is\ndisallowed, so we need to make the library indicate to\nhashlib that we will use MD5 \"carefully\" and in case of RC4,\nwe simply don't use m2crypto in FIPS mode",
        "before_after_code_files": [
          "tlslite/handshakehashes.py||tlslite/handshakehashes.py",
          "tlslite/mathtls.py||tlslite/mathtls.py",
          "tlslite/recordlayer.py||tlslite/recordlayer.py",
          "tlslite/utils/cryptomath.py||tlslite/utils/cryptomath.py",
          "tlslite/utils/tlshashlib.py||tlslite/utils/tlshashlib.py",
          "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py",
          "unit_tests/test_tlslite_utils_cryptomath_m2crypto.py||unit_tests/test_tlslite_utils_cryptomath_m2crypto.py",
          "unit_tests/test_tlslite_utils_tlshashlib.py||unit_tests/test_tlslite_utils_tlshashlib.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
          ],
          "candidate": [
            "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py"
          ]
        }
      },
      "candidate_diff": {
        "tlslite/handshakehashes.py||tlslite/handshakehashes.py": [
          "File: tlslite/handshakehashes.py -> tlslite/handshakehashes.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: from .utils.compat import compat26Str, compatHMAC",
          "7: from .utils.cryptomath import MD5, SHA1",
          "10: class HandshakeHashes(object):",
          "",
          "[Removed Lines]",
          "8: import hashlib",
          "",
          "[Added Lines]",
          "8: from .utils import tlshashlib as hashlib",
          "",
          "---------------"
        ],
        "tlslite/mathtls.py||tlslite/mathtls.py": [
          "File: tlslite/mathtls.py -> tlslite/mathtls.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: from .utils.compat import *",
          "12: from .utils.cryptomath import *",
          "13: from .constants import CipherSuite",
          "15: import hmac",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: from .utils import tlshashlib as hashlib",
          "",
          "---------------"
        ],
        "tlslite/recordlayer.py||tlslite/recordlayer.py": [
          "File: tlslite/recordlayer.py -> tlslite/recordlayer.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: import socket",
          "8: import errno",
          "10: from .constants import ContentType, CipherSuite",
          "11: from .messages import RecordHeader3, RecordHeader2, Message",
          "12: from .utils.cipherfactory import createAESGCM, createAES, createRC4, \\",
          "",
          "[Removed Lines]",
          "9: import hashlib",
          "",
          "[Added Lines]",
          "9: from .utils import tlshashlib as hashlib",
          "",
          "---------------"
        ],
        "tlslite/utils/cryptomath.py||tlslite/utils/cryptomath.py": [
          "File: tlslite/utils/cryptomath.py -> tlslite/utils/cryptomath.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:     from M2Crypto import m2",
          "28:     m2cryptoLoaded = True",
          "30: except ImportError:",
          "31:     m2cryptoLoaded = False",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30:     try:",
          "31:         with open('/proc/sys/crypto/fips_enabled', 'r') as fipsFile:",
          "32:             if '1' in fipsFile.read():",
          "33:                 m2cryptoLoaded = False",
          "34:     except (IOError, OSError):",
          "35:         # looks like we're running in container, likely not FIPS mode",
          "36:         m2cryptoLoaded = True",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67: # **************************************************************************",
          "69: import hmac",
          "72: def MD5(b):",
          "73:     \"\"\"Return a MD5 digest of data\"\"\"",
          "",
          "[Removed Lines]",
          "70: import hashlib",
          "",
          "[Added Lines]",
          "78: from . import tlshashlib as hashlib",
          "",
          "---------------"
        ],
        "tlslite/utils/tlshashlib.py||tlslite/utils/tlshashlib.py": [
          "File: tlslite/utils/tlshashlib.py -> tlslite/utils/tlshashlib.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Author: Hubert Kario (c) 2015",
          "2: # see LICENCE file for legal information regarding use of this file",
          "4: \"\"\"hashlib that handles FIPS mode.\"\"\"",
          "6: # Because we are extending the hashlib module, we need to import all its",
          "7: # fields to suppport the same uses",
          "8: # pylint: disable=unused-wildcard-import, wildcard-import",
          "9: from hashlib import *",
          "10: # pylint: enable=unused-wildcard-import, wildcard-import",
          "11: import hashlib",
          "14: def _fipsFunction(func, *args, **kwargs):",
          "15:     \"\"\"Make hash function support FIPS mode.\"\"\"",
          "16:     try:",
          "17:         return func(*args, **kwargs)",
          "18:     except ValueError:",
          "19:         return func(*args, usedforsecurity=False, **kwargs)",
          "22: # redefining the function is exactly what we intend to do",
          "23: # pylint: disable=function-redefined",
          "24: def md5(*args, **kwargs):",
          "25:     \"\"\"MD5 constructor that works in FIPS mode.\"\"\"",
          "26:     return _fipsFunction(hashlib.md5, *args, **kwargs)",
          "29: def new(*args, **kwargs):",
          "30:     \"\"\"General constructor that works in FIPS mode.\"\"\"",
          "31:     return _fipsFunction(hashlib.new, *args, **kwargs)",
          "32: # pylint: enable=function-redefined",
          "",
          "---------------"
        ],
        "unit_tests/test_tlslite_utils_constanttime.py||unit_tests/test_tlslite_utils_constanttime.py": [
          "File: unit_tests/test_tlslite_utils_constanttime.py -> unit_tests/test_tlslite_utils_constanttime.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: from tlslite.utils.compat import compatHMAC",
          "17: from tlslite.recordlayer import RecordLayer",
          "19: import hmac",
          "21: class TestContanttime(unittest.TestCase):",
          "",
          "[Removed Lines]",
          "18: import hashlib",
          "",
          "[Added Lines]",
          "18: import tlslite.utils.tlshashlib as hashlib",
          "",
          "---------------"
        ],
        "unit_tests/test_tlslite_utils_cryptomath_m2crypto.py||unit_tests/test_tlslite_utils_cryptomath_m2crypto.py": [
          "File: unit_tests/test_tlslite_utils_cryptomath_m2crypto.py -> unit_tests/test_tlslite_utils_cryptomath_m2crypto.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2014, Hubert Kario",
          "2: #",
          "3: # See the LICENSE file for legal information regarding use of this file.",
          "5: # compatibility with Python 2.6, for that we need unittest2 package,",
          "6: # which is not available on 3.3 or 3.4",
          "7: try:",
          "8:     import unittest2 as unittest",
          "9: except ImportError:",
          "10:     import unittest",
          "11: try:",
          "12:     import mock",
          "13:     from mock import call",
          "14: except ImportError:",
          "15:     import unittest.mock as mock",
          "16:     from unittest.mock import call",
          "17: import sys",
          "18: try:",
          "19:     # Python 2",
          "20:     reload",
          "21: except NameError:",
          "22:     try:",
          "23:         # Python >= 3.4",
          "24:         from importlib import reload",
          "25:     except ImportError:",
          "26:         # Python <= 3.3",
          "27:         from imp import reload",
          "28: try:",
          "29:     import __builtin__ as builtins",
          "30: except ImportError:",
          "31:     import builtins",
          "33: real_open = builtins.open",
          "35: class magic_open(object):",
          "36:     def __init__(self, *args, **kwargs):",
          "37:         self.args = args",
          "38:         self.kwargs = kwargs",
          "40:     def __enter__(self):",
          "41:         if self.args[0] == '/proc/sys/crypto/fips_enabled':",
          "42:             m = mock.MagicMock()",
          "43:             m.read.return_value = '1'",
          "44:             self.f = m",
          "45:             return m",
          "46:         else:",
          "47:             self.f = real_open(*self.args, **self.kwargs)",
          "48:             return self.f",
          "50:     def __exit__(self, exc_type, exc_value, exc_traceback):",
          "51:         self.f.close()",
          "53: class magic_open_error(object):",
          "54:     def __init__(self, *args, **kwargs):",
          "55:         self.args = args",
          "56:         self.kwargs = kwargs",
          "58:     def __enter__(self):",
          "59:         if self.args[0] == '/proc/sys/crypto/fips_enabled':",
          "60:             m = mock.MagicMock()",
          "61:             self.f = m",
          "62:             raise IOError(12)",
          "63:         else:",
          "64:             self.f = real_open(*self.args, **self.kwargs)",
          "65:             return self.f",
          "67:     def __exit__(self, exc_type, exc_value, exc_traceback):",
          "68:         self.f.close()",
          "71: class TestM2CryptoLoaded(unittest.TestCase):",
          "72:     def test_import_without_m2crypto(self):",
          "73:         with mock.patch.dict('sys.modules', {'M2Crypto': None}):",
          "74:             import tlslite.utils.cryptomath",
          "75:             reload(tlslite.utils.cryptomath)",
          "76:             from tlslite.utils.cryptomath import m2cryptoLoaded",
          "77:             self.assertFalse(m2cryptoLoaded)",
          "79:     def test_import_with_m2crypto(self):",
          "80:         fake_m2 = mock.MagicMock()",
          "82:         with mock.patch.dict('sys.modules', {'M2Crypto': fake_m2}):",
          "83:             import tlslite.utils.cryptomath",
          "84:             reload(tlslite.utils.cryptomath)",
          "85:             from tlslite.utils.cryptomath import m2cryptoLoaded",
          "86:             self.assertTrue(m2cryptoLoaded)",
          "88:     def test_import_with_m2crypto_in_fips_mode(self):",
          "89:         fake_m2 = mock.MagicMock()",
          "91:         with mock.patch.dict('sys.modules', {'M2Crypto': fake_m2}):",
          "92:             with mock.patch.object(builtins, 'open', magic_open):",
          "93:                 import tlslite.utils.cryptomath",
          "94:                 reload(tlslite.utils.cryptomath)",
          "95:                 from tlslite.utils.cryptomath import m2cryptoLoaded",
          "96:                 self.assertFalse(m2cryptoLoaded)",
          "98:     def test_import_with_m2crypto_in_container(self):",
          "99:         fake_m2 = mock.MagicMock()",
          "101:         with mock.patch.dict('sys.modules', {'M2Crypto': fake_m2}):",
          "102:             with mock.patch.object(builtins, 'open', magic_open_error):",
          "103:                 import tlslite.utils.cryptomath",
          "104:                 reload(tlslite.utils.cryptomath)",
          "105:                 from tlslite.utils.cryptomath import m2cryptoLoaded",
          "106:                 self.assertTrue(m2cryptoLoaded)",
          "",
          "---------------"
        ],
        "unit_tests/test_tlslite_utils_tlshashlib.py||unit_tests/test_tlslite_utils_tlshashlib.py": [
          "File: unit_tests/test_tlslite_utils_tlshashlib.py -> unit_tests/test_tlslite_utils_tlshashlib.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2014, Hubert Kario",
          "2: #",
          "3: # See the LICENSE file for legal information regarding use of this file.",
          "5: # compatibility with Python 2.6, for that we need unittest2 package,",
          "6: # which is not available on 3.3 or 3.4",
          "7: try:",
          "8:     import unittest2 as unittest",
          "9: except ImportError:",
          "10:     import unittest",
          "11: try:",
          "12:     import mock",
          "13:     from mock import call",
          "14: except ImportError:",
          "15:     import unittest.mock as mock",
          "16:     from unittest.mock import call",
          "18: class TestTLSHashlib(unittest.TestCase):",
          "20:     def test_in_fips_mode(self):",
          "21:         def m(*args, **kwargs):",
          "22:             if 'usedforsecurity' not in kwargs:",
          "23:                 raise ValueError(\"MD5 disabled in FIPS mode\")",
          "25:         with mock.patch('hashlib.md5', m):",
          "26:             from tlslite.utils.tlshashlib import md5",
          "27:             md5()",
          "",
          "---------------"
        ]
      }
    }
  ]
}
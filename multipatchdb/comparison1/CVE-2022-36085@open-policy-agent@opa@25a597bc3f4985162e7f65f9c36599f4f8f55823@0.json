{
  "cve_id": "CVE-2022-36085",
  "cve_desc": "Open Policy Agent (OPA) is an open source, general-purpose policy engine. The Rego compiler provides a (deprecated) `WithUnsafeBuiltins` function, which allows users to provide a set of built-in functions that should be deemed unsafe \u2014 and as such rejected \u2014 by the compiler if encountered in the policy compilation stage. A bypass of this protection has been found, where the use of the `with` keyword to mock such a built-in function (a feature introduced in OPA v0.40.0), isn\u2019t taken into account by `WithUnsafeBuiltins`. Multiple conditions need to be met in order to create an adverse effect. Version 0.43.1 contains a patch for this issue. As a workaround, avoid using the `WithUnsafeBuiltins` function and use the `capabilities` feature instead.",
  "repo": "open-policy-agent/opa",
  "patch_hash": "25a597bc3f4985162e7f65f9c36599f4f8f55823",
  "patch_info": {
    "commit_hash": "25a597bc3f4985162e7f65f9c36599f4f8f55823",
    "repo": "open-policy-agent/opa",
    "commit_url": "https://github.com/open-policy-agent/opa/commit/25a597bc3f4985162e7f65f9c36599f4f8f55823",
    "files": [
      "ast/compile.go",
      "ast/compile_test.go",
      "rego/rego_test.go"
    ],
    "message": "ast/compile: respect unsafeBuiltinMap for 'with' replacements (#5107)\n\nThe changes are necessary for both the Compiler and the QueryCompiler. Tests\nhave been added to ensure that the code path through the rego package has also\nbeen fixed.\n\nFixes CVE-2022-36085.\n\nSigned-off-by: Stephan Renatus <stephan.renatus@gmail.com>",
    "before_after_code_files": [
      "ast/compile.go||ast/compile.go",
      "ast/compile_test.go||ast/compile_test.go",
      "rego/rego_test.go||rego/rego_test.go"
    ]
  },
  "patch_diff": {
    "ast/compile.go||ast/compile.go": [
      "File: ast/compile.go -> ast/compile.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "2196:    if !ok {",
      "2197:     return x, nil",
      "2198:    }",
      "2200:    if err != nil {",
      "2201:     c.err(err)",
      "2202:    }",
      "",
      "[Removed Lines]",
      "2199:    body, err := rewriteWithModifiersInBody(c, f, body)",
      "",
      "[Added Lines]",
      "2199:    body, err := rewriteWithModifiersInBody(c, c.unsafeBuiltinsMap, f, body)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2475: }",
      "2477: func (qc *queryCompiler) checkUnsafeBuiltins(_ *QueryContext, body Body) (Body, error) {",
      "2485:  if len(errs) > 0 {",
      "2486:   return nil, errs",
      "2487:  }",
      "2488:  return body, nil",
      "2489: }",
      "2491: func (qc *queryCompiler) checkDeprecatedBuiltins(_ *QueryContext, body Body) (Body, error) {",
      "2492:  errs := checkDeprecatedBuiltins(qc.compiler.deprecatedBuiltinsMap, body, qc.compiler.strict)",
      "2493:  if len(errs) > 0 {",
      "",
      "[Removed Lines]",
      "2478:  var unsafe map[string]struct{}",
      "2479:  if qc.unsafeBuiltins != nil {",
      "2480:   unsafe = qc.unsafeBuiltins",
      "2481:  } else {",
      "2482:   unsafe = qc.compiler.unsafeBuiltinsMap",
      "2483:  }",
      "2484:  errs := checkUnsafeBuiltins(unsafe, body)",
      "",
      "[Added Lines]",
      "2478:  errs := checkUnsafeBuiltins(qc.unsafeBuiltinsMap(), body)",
      "2485: func (qc *queryCompiler) unsafeBuiltinsMap() map[string]struct{} {",
      "2486:  if qc.unsafeBuiltins != nil {",
      "2487:   return qc.unsafeBuiltins",
      "2488:  }",
      "2489:  return qc.compiler.unsafeBuiltinsMap",
      "2490: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2499: func (qc *queryCompiler) rewriteWithModifiers(_ *QueryContext, body Body) (Body, error) {",
      "2500:  f := newEqualityFactory(newLocalVarGenerator(\"q\", body))",
      "2502:  if err != nil {",
      "2503:   return nil, Errors{err}",
      "2504:  }",
      "",
      "[Removed Lines]",
      "2501:  body, err := rewriteWithModifiersInBody(qc.compiler, f, body)",
      "",
      "[Added Lines]",
      "2502:  body, err := rewriteWithModifiersInBody(qc.compiler, qc.unsafeBuiltinsMap(), f, body)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "4789:  var result Body",
      "4790:  for i := range body {",
      "4792:   if err != nil {",
      "4793:    return nil, err",
      "4794:   }",
      "",
      "[Removed Lines]",
      "4788: func rewriteWithModifiersInBody(c *Compiler, f *equalityFactory, body Body) (Body, *Error) {",
      "4791:   exprs, err := rewriteWithModifier(c, f, body[i])",
      "",
      "[Added Lines]",
      "4789: func rewriteWithModifiersInBody(c *Compiler, unsafeBuiltinsMap map[string]struct{}, f *equalityFactory, body Body) (Body, *Error) {",
      "4792:   exprs, err := rewriteWithModifier(c, unsafeBuiltinsMap, f, body[i])",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "4803:  return result, nil",
      "4804: }",
      "4808:  var result []*Expr",
      "4809:  for i := range expr.With {",
      "4811:   if err != nil {",
      "4812:    return nil, err",
      "4813:   }",
      "",
      "[Removed Lines]",
      "4806: func rewriteWithModifier(c *Compiler, f *equalityFactory, expr *Expr) ([]*Expr, *Error) {",
      "4810:   eval, err := validateWith(c, expr, i)",
      "",
      "[Added Lines]",
      "4807: func rewriteWithModifier(c *Compiler, unsafeBuiltinsMap map[string]struct{}, f *equalityFactory, expr *Expr) ([]*Expr, *Error) {",
      "4811:   eval, err := validateWith(c, unsafeBuiltinsMap, expr, i)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "4822:  return append(result, expr), nil",
      "4823: }",
      "4826:  target, value := expr.With[i].Target, expr.With[i].Value",
      "",
      "[Removed Lines]",
      "4825: func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {",
      "",
      "[Added Lines]",
      "4826: func validateWith(c *Compiler, unsafeBuiltinsMap map[string]struct{}, expr *Expr, i int) (bool, *Error) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "4831:    value.Value = Ref([]*Term{NewTerm(v)})",
      "4832:   }",
      "4833:  }",
      "4835:  switch {",
      "4836:  case isDataRef(target):",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4835:  isBuiltinRefOrVar, err := isBuiltinRefOrVar(c.builtins, unsafeBuiltinsMap, target)",
      "4836:  if err != nil {",
      "4837:   return false, err",
      "4838:  }",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "4854:    if child := node.Child(ref[len(ref)-1].Value); child != nil {",
      "4855:     for _, v := range child.Values {",
      "4856:      if len(v.(*Rule).Head.Args) > 0 {",
      "4859:       }",
      "4860:      }",
      "4861:     }",
      "4862:    }",
      "4863:   }",
      "4864:  case isInputRef(target): // ok, valid",
      "",
      "[Removed Lines]",
      "4857:       if validateWithFunctionValue(c.builtins, c.RuleTree, value) {",
      "4858:        return false, nil",
      "4865:  case isBuiltinRefOrVar(c.builtins, target):",
      "",
      "[Added Lines]",
      "4862:       if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {",
      "4863:        return false, err // may be nil",
      "4870:  case isBuiltinRefOrVar:",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "4876:    return false, err",
      "4877:   }",
      "4881:   }",
      "4882:  default:",
      "4883:   return false, NewError(TypeErr, target.Location, \"with keyword target must reference existing %v, %v, or a function\", InputRootDocument, DefaultRootDocument)",
      "",
      "[Removed Lines]",
      "4879:   if validateWithFunctionValue(c.builtins, c.RuleTree, value) {",
      "4880:    return false, nil",
      "",
      "[Added Lines]",
      "4884:   if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {",
      "4885:    return false, err // may be nil",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "4906:  return nil",
      "4907: }",
      "4910:  if v, ok := value.Value.(Ref); ok {",
      "4911:   if ruleTree.Find(v) != nil { // ref exists in rule tree",
      "4913:   }",
      "4914:  }",
      "4916: }",
      "4918: func isInputRef(term *Term) bool {",
      "",
      "[Removed Lines]",
      "4909: func validateWithFunctionValue(bs map[string]*Builtin, ruleTree *TreeNode, value *Term) bool {",
      "4912:    return true",
      "4915:  return isBuiltinRefOrVar(bs, value)",
      "",
      "[Added Lines]",
      "4914: func validateWithFunctionValue(bs map[string]*Builtin, unsafeMap map[string]struct{}, ruleTree *TreeNode, value *Term) (bool, *Error) {",
      "4917:    return true, nil",
      "4920:  return isBuiltinRefOrVar(bs, unsafeMap, value)",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "4933:  return false",
      "4934: }",
      "4937:  switch v := term.Value.(type) {",
      "4938:  case Ref, Var:",
      "4939:   _, ok := bs[v.String()]",
      "4941:  }",
      "4943: }",
      "4945: func isVirtual(node *TreeNode, ref Ref) bool {",
      "",
      "[Removed Lines]",
      "4936: func isBuiltinRefOrVar(bs map[string]*Builtin, term *Term) bool {",
      "4940:   return ok",
      "4942:  return false",
      "",
      "[Added Lines]",
      "4941: func isBuiltinRefOrVar(bs map[string]*Builtin, unsafeBuiltinsMap map[string]struct{}, term *Term) (bool, *Error) {",
      "4944:   if _, ok := unsafeBuiltinsMap[v.String()]; ok {",
      "4945:    return false, NewError(CompileErr, term.Location, \"with keyword replacing built-in function: target must not be unsafe: %q\", v)",
      "4946:   }",
      "4948:   return ok, nil",
      "4950:  return false, nil",
      "",
      "---------------"
    ],
    "ast/compile_test.go||ast/compile_test.go": [
      "File: ast/compile_test.go -> ast/compile_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "4049:  tests := []struct {",
      "4050:   note         string",
      "4051:   input        string",
      "4052:   expected     string",
      "4053:   expectedRule *Rule",
      "4054:   wantErr      error",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4052:   opts         func(*Compiler) *Compiler",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4154:     return r",
      "4155:    }(),",
      "4156:   },",
      "4157:   {",
      "4158:    note: \"built-in function: valid, arity 1, non-compound name\",",
      "4159:    input: `",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4158:   {",
      "4159:    note: \"built-in function: replaced by another built-in that's marked unsafe\",",
      "4160:    input: `",
      "4161:     q := is_object({\"url\": \"https://httpbin.org\", \"method\": \"GET\"})",
      "4162:     p { q with is_object as http.send }",
      "4163:    `,",
      "4164:    opts:    func(c *Compiler) *Compiler { return c.WithUnsafeBuiltins(map[string]struct{}{\"http.send\": {}}) },",
      "4165:    wantErr: fmt.Errorf(\"rego_compile_error: with keyword replacing built-in function: target must not be unsafe: \\\"http.send\\\"\"),",
      "4166:   },",
      "4167:   {",
      "4168:    note: \"non-built-in function: replaced by another built-in that's marked unsafe\",",
      "4169:    input: `",
      "4170:    r(_) = {}",
      "4171:    q := r({\"url\": \"https://httpbin.org\", \"method\": \"GET\"})",
      "4172:    p {",
      "4173:     q with r as http.send",
      "4174:    }`,",
      "4175:    opts:    func(c *Compiler) *Compiler { return c.WithUnsafeBuiltins(map[string]struct{}{\"http.send\": {}}) },",
      "4176:    wantErr: fmt.Errorf(\"rego_compile_error: with keyword replacing built-in function: target must not be unsafe: \\\"http.send\\\"\"),",
      "4177:   },",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "4171:  for _, tc := range tests {",
      "4172:   t.Run(tc.note, func(t *testing.T) {",
      "4173:    c := NewCompiler()",
      "4174:    module := fixture + tc.input",
      "4175:    c.Modules[\"test\"] = MustParseModule(module)",
      "4176:    compileStages(c, c.rewriteWithModifiers)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4195:    if tc.opts != nil {",
      "4196:     c = tc.opts(c)",
      "4197:    }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "6676: }",
      "6678: func TestQueryCompilerWithUnsafeBuiltins(t *testing.T) {",
      "6686:  }",
      "6687: }",
      "",
      "[Removed Lines]",
      "6679:  c := NewCompiler().WithUnsafeBuiltins(map[string]struct{}{",
      "6680:   \"count\": {},",
      "6681:  })",
      "6683:  _, err := c.QueryCompiler().WithUnsafeBuiltins(map[string]struct{}{}).Compile(MustParseBody(\"count([])\"))",
      "6684:  if err != nil {",
      "6685:   t.Fatal(err)",
      "",
      "[Added Lines]",
      "6703:  tests := []struct {",
      "6704:   note     string",
      "6705:   query    string",
      "6706:   compiler *Compiler",
      "6707:   opts     func(QueryCompiler) QueryCompiler",
      "6708:   err      string",
      "6709:  }{",
      "6710:   {",
      "6711:    note:     \"builtin unsafe via compiler\",",
      "6712:    query:    \"count([])\",",
      "6713:    compiler: NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\"count\": {}}),",
      "6714:    err:      \"unsafe built-in function calls in expression: count\",",
      "6715:   },",
      "6716:   {",
      "6717:    note:     \"builtin unsafe via query compiler\",",
      "6718:    query:    \"count([])\",",
      "6719:    compiler: NewCompiler(),",
      "6720:    opts: func(qc QueryCompiler) QueryCompiler {",
      "6721:     return qc.WithUnsafeBuiltins(map[string]struct{}{\"count\": {}})",
      "6722:    },",
      "6723:    err: \"unsafe built-in function calls in expression: count\",",
      "6724:   },",
      "6725:   {",
      "6726:    note:     \"builtin unsafe via compiler, 'with' mocking\",",
      "6727:    query:    \"is_array([]) with is_array as count\",",
      "6728:    compiler: NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\"count\": {}}),",
      "6729:    err:      `with keyword replacing built-in function: target must not be unsafe: \"count\"`,",
      "6730:   },",
      "6731:   {",
      "6732:    note:     \"builtin unsafe via query compiler,  'with' mocking\",",
      "6733:    query:    \"is_array([]) with is_array as count\",",
      "6734:    compiler: NewCompiler(),",
      "6735:    opts: func(qc QueryCompiler) QueryCompiler {",
      "6736:     return qc.WithUnsafeBuiltins(map[string]struct{}{\"count\": {}})",
      "6737:    },",
      "6738:    err: `with keyword replacing built-in function: target must not be unsafe: \"count\"`,",
      "6739:   },",
      "6740:  }",
      "6742:  for _, tc := range tests {",
      "6743:   t.Run(tc.note, func(t *testing.T) {",
      "6744:    qc := tc.compiler.QueryCompiler()",
      "6745:    if tc.opts != nil {",
      "6746:     qc = tc.opts(qc)",
      "6747:    }",
      "6748:    _, err := qc.Compile(MustParseBody(tc.query))",
      "6749:    var errs Errors",
      "6750:    if !errors.As(err, &errs) {",
      "6751:     t.Fatalf(\"expected error type %T, got %v %[2]T\", errs, err)",
      "6752:    }",
      "6753:    if exp, act := 1, len(errs); exp != act {",
      "6754:     t.Fatalf(\"expected %d error(s), got %d\", exp, act)",
      "6755:    }",
      "6756:    if exp, act := tc.err, errs[0].Message; exp != act {",
      "6757:     t.Errorf(\"expected message %q, got %q\", exp, act)",
      "6758:    }",
      "6759:   })",
      "",
      "---------------"
    ],
    "rego/rego_test.go||rego/rego_test.go": [
      "File: rego/rego_test.go -> rego/rego_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "1437:  ctx := context.Background()",
      "1439:  unsafeCountExpr := \"unsafe built-in function calls in expression: count\"",
      "1441:  t.Run(\"unsafe query\", func(t *testing.T) {",
      "1442:   r := New(",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1440:  unsafeCountExprWith := `with keyword replacing built-in function: target must not be unsafe: \"count\"`",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1448:   }",
      "1449:  })",
      "1451:  t.Run(\"unsafe module\", func(t *testing.T) {",
      "1452:   r := New(",
      "1453:    Query(`data.pkg.deny`),",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1452:  t.Run(\"unsafe query, 'with' replacement\", func(t *testing.T) {",
      "1453:   r := New(",
      "1454:    Query(`is_array([1, 2, 3]) with is_array as count`),",
      "1455:    UnsafeBuiltins(map[string]struct{}{\"count\": {}}),",
      "1456:   )",
      "1457:   if _, err := r.Eval(ctx); err == nil || !strings.Contains(err.Error(), unsafeCountExprWith) {",
      "1458:    t.Fatalf(\"Expected unsafe built-in error but got %v\", err)",
      "1459:   }",
      "1460:  })",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1463:   }",
      "1464:  })",
      "1466:  t.Run(\"inherit in query\", func(t *testing.T) {",
      "1467:   r := New(",
      "1468:    Compiler(ast.NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\"count\": {}})),",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1477:  t.Run(\"unsafe module, 'with' replacement in query\", func(t *testing.T) {",
      "1478:   r := New(",
      "1479:    Query(`data.pkg.deny with is_array as count`),",
      "1480:    Module(\"pkg.rego\", `package pkg",
      "1481:    deny {",
      "1482:     is_array(input.requests) > 10",
      "1483:    }",
      "1484:    `),",
      "1485:    UnsafeBuiltins(map[string]struct{}{\"count\": {}}),",
      "1486:   )",
      "1487:   if _, err := r.Eval(ctx); err == nil || !strings.Contains(err.Error(), unsafeCountExprWith) {",
      "1488:    t.Fatalf(\"Expected unsafe built-in error but got %v\", err)",
      "1489:   }",
      "1490:  })",
      "1492:  t.Run(\"unsafe module, 'with' replacement in module\", func(t *testing.T) {",
      "1493:   r := New(",
      "1494:    Query(`data.pkg.deny`),",
      "1495:    Module(\"pkg.rego\", `package pkg",
      "1496:    deny {",
      "1497:     is_array(input.requests) > 10 with is_array as count",
      "1498:    }",
      "1499:    `),",
      "1500:    UnsafeBuiltins(map[string]struct{}{\"count\": {}}),",
      "1501:   )",
      "1502:   if _, err := r.Eval(ctx); err == nil || !strings.Contains(err.Error(), unsafeCountExprWith) {",
      "1503:    t.Fatalf(\"Expected unsafe built-in error but got %v\", err)",
      "1504:   }",
      "1505:  })",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1473:   }",
      "1474:  })",
      "1476:  t.Run(\"override/disable in query\", func(t *testing.T) {",
      "1477:   r := New(",
      "1478:    Compiler(ast.NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\"count\": {}})),",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1517:  t.Run(\"inherit in query, 'with' replacement\", func(t *testing.T) {",
      "1518:   r := New(",
      "1519:    Compiler(ast.NewCompiler().WithUnsafeBuiltins(map[string]struct{}{\"count\": {}})),",
      "1520:    Query(\"is_array([]) with is_array as count\"),",
      "1521:   )",
      "1522:   if _, err := r.Eval(ctx); err == nil || !strings.Contains(err.Error(), unsafeCountExprWith) {",
      "1523:    t.Fatalf(\"Expected unsafe built-in error but got %v\", err)",
      "1524:   }",
      "1525:  })",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3406e96789771e992a0dcc20b87af79529d05b26",
      "candidate_info": {
        "commit_hash": "3406e96789771e992a0dcc20b87af79529d05b26",
        "repo": "open-policy-agent/opa",
        "commit_url": "https://github.com/open-policy-agent/opa/commit/3406e96789771e992a0dcc20b87af79529d05b26",
        "files": [
          "ast/compile.go",
          "ast/compile_test.go",
          "docs/content/policy-language.md",
          "internal/planner/planner.go",
          "internal/wasm/sdk/test/e2e/exceptions.yaml",
          "test/cases/testdata/withkeyword/test-with-builtin-mock.yaml",
          "test/cases/testdata/withkeyword/test-with-function-mock.yaml",
          "test/cases/testdata/withkeyword/test-with-function-mocks-issue-5299.yaml",
          "topdown/eval.go"
        ],
        "message": "ast/compile: rewrite ref-replacements with non-function values (#5301)\n\nBefore, this was OK:\n\n    test_a {\n    . mock_f := true\n      allow with f as mock_f\n    }\n\nbut this had panicked:\n\n    mock_f := true\n    test_a {\n      allow with f as mock_f\n    }\n\nWhich, from a user perspective, is quite incomprehensible. Technically,\nthe first snippet was a (supported) replacement-by-value, and the second\nwas an unsupported replacement by a rule that was not a function.\n\nFurthermore, the second case wasn't properly caught in the 'with' validations.\n\nNow, we'll capture the situation, and start supporting it. Both snippets will\nnow work the same, as one would expect from the language surface.\n\nFixes #5299.\n\nSigned-off-by: Stephan Renatus <stephan.renatus@gmail.com>",
        "before_after_code_files": [
          "ast/compile.go||ast/compile.go",
          "ast/compile_test.go||ast/compile_test.go",
          "internal/planner/planner.go||internal/planner/planner.go",
          "topdown/eval.go||topdown/eval.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ast/compile.go||ast/compile.go",
            "ast/compile_test.go||ast/compile_test.go"
          ],
          "candidate": [
            "ast/compile.go||ast/compile.go",
            "ast/compile_test.go||ast/compile_test.go"
          ]
        }
      },
      "candidate_diff": {
        "ast/compile.go||ast/compile.go": [
          "File: ast/compile.go -> ast/compile.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "5151:     for _, v := range child.Values {",
          "5152:      if len(v.(*Rule).Head.Args) > 0 {",
          "5153:       if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {",
          "5155:       }",
          "5156:      }",
          "5157:     }",
          "",
          "[Removed Lines]",
          "5154:        return false, err // may be nil",
          "",
          "[Added Lines]",
          "5154:        return false, err // err may be nil",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5173:   }",
          "5175:   if ok, err := validateWithFunctionValue(c.builtins, unsafeBuiltinsMap, c.RuleTree, value); err != nil || ok {",
          "5177:   }",
          "5178:  default:",
          "5179:   return false, NewError(TypeErr, target.Location, \"with keyword target must reference existing %v, %v, or a function\", InputRootDocument, DefaultRootDocument)",
          "",
          "[Removed Lines]",
          "5176:    return false, err // may be nil",
          "",
          "[Added Lines]",
          "5176:    return false, err // err may be nil",
          "",
          "---------------"
        ],
        "ast/compile_test.go||ast/compile_test.go": [
          "File: ast/compile_test.go -> ast/compile_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "5292:    `,",
          "5293:    expected: `p { true with http.send as {\"body\": \"yay\"} }`,",
          "5294:   },",
          "5295:   {",
          "5296:    note: \"built-in function: replaced by comprehension\",",
          "5297:    input: `",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5295:   {",
          "5296:    note: \"built-in function: replaced by var\",",
          "5297:    input: `",
          "5298:     p {",
          "5299:      resp := { \"body\": \"yay\" }",
          "5300:      true with http.send as resp",
          "5301:     }",
          "5302:    `,",
          "5303:    expected: `p { __local0__ = {\"body\": \"yay\"}; true with http.send as __local0__ }`,",
          "5304:   },",
          "5305:   {",
          "5306:    note: \"non-built-in function: replaced by var\",",
          "5307:    input: `",
          "5308:     p {",
          "5309:      resp := true",
          "5310:      f(true) with f as resp",
          "5311:     }",
          "5312:     f(false) { true }",
          "5313:    `,",
          "5314:    expected: `p { __local0__ = true; data.test.f(true) with data.test.f as __local0__ }`,",
          "5315:   },",
          "",
          "---------------"
        ],
        "internal/planner/planner.go||internal/planner/planner.go": [
          "File: internal/planner/planner.go -> internal/planner/planner.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "870:     if node := p.rules.Lookup(r); node != nil {",
          "875:      }",
          "878:     }",
          "889:    }",
          "890:   }",
          "892:   if node := p.rules.Lookup(op); node != nil {",
          "",
          "[Removed Lines]",
          "871:      p.mocks.Push() // new scope",
          "872:      name, err = p.planRules(node.Rules(), false)",
          "873:      if err != nil {",
          "874:       return err",
          "876:      p.mocks.Pop()",
          "877:      return p.planExprCallFunc(name, node.Arity(), void, operands, p.defaultOperands(), iter)",
          "880:     return fmt.Errorf(\"illegal replacement of operator %q by %v\", operator, replacement)",
          "882:    default: // replacement is a value",
          "883:     if bi, ok := p.decls[operator]; ok {",
          "884:      return p.planExprCallValue(replacement, len(bi.Decl.FuncArgs().Args), operands, iter)",
          "885:     }",
          "886:     if node := p.rules.Lookup(op); node != nil {",
          "887:      return p.planExprCallValue(replacement, node.Arity(), operands, iter)",
          "888:     }",
          "",
          "[Added Lines]",
          "871:      if node.Arity() > 0 {",
          "872:       p.mocks.Push() // new scope",
          "873:       name, err = p.planRules(node.Rules(), false)",
          "874:       if err != nil {",
          "875:        return err",
          "876:       }",
          "877:       p.mocks.Pop()",
          "878:       return p.planExprCallFunc(name, node.Arity(), void, operands, p.defaultOperands(), iter)",
          "882:    }",
          "885:    if bi, ok := p.decls[operator]; ok {",
          "886:     return p.planExprCallValue(replacement, len(bi.Decl.FuncArgs().Args), operands, iter)",
          "887:    }",
          "888:    if node := p.rules.Lookup(op); node != nil {",
          "889:     return p.planExprCallValue(replacement, node.Arity(), operands, iter)",
          "891:    return fmt.Errorf(\"illegal replacement of operator %q by %v\", operator, replacement) // should be unreachable",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "972: func (p *Planner) planExprCallFunc(name string, arity int, void bool, operands []*ast.Term, args []ir.Operand, iter planiter) error {",
          "977:   return p.planCallArgs(operands, 0, args, func(args []ir.Operand) error {",
          "",
          "[Removed Lines]",
          "974:  if len(operands) == arity {",
          "",
          "[Added Lines]",
          "976:  switch {",
          "977:  case len(operands) == arity:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "993:    return iter()",
          "994:   })",
          "1005:   })",
          "1008: }",
          "1010: func (p *Planner) planExprCallValue(value *ast.Term, arity int, operands []*ast.Term, iter planiter) error {",
          "1012:   return p.planCallArgs(operands, 0, nil, func([]ir.Operand) error {",
          "1013:    p.ltarget = p.newOperand()",
          "1014:    return p.planTerm(value, func() error {",
          "",
          "[Removed Lines]",
          "995:  }",
          "999:  return p.planCallArgs(operands[:len(operands)-1], 0, args, func(args []ir.Operand) error {",
          "1000:   result := p.newLocal()",
          "1001:   p.appendStmt(&ir.CallStmt{",
          "1002:    Func:   name,",
          "1003:    Args:   args,",
          "1004:    Result: result,",
          "1006:   return p.planUnifyLocal(op(result), operands[len(operands)-1], iter)",
          "1007:  })",
          "1011:  if len(operands) == arity { // call: f(x) # result not captured",
          "",
          "[Added Lines]",
          "999:  case len(operands) == arity+1:",
          "1002:   return p.planCallArgs(operands[:len(operands)-1], 0, args, func(args []ir.Operand) error {",
          "1003:    result := p.newLocal()",
          "1004:    p.appendStmt(&ir.CallStmt{",
          "1005:     Func:   name,",
          "1006:     Args:   args,",
          "1007:     Result: result,",
          "1008:    })",
          "1009:    return p.planUnifyLocal(op(result), operands[len(operands)-1], iter)",
          "1012:  default:",
          "1013:   return fmt.Errorf(\"impossible replacement, arity mismatch\")",
          "1014:  }",
          "1018:  switch {",
          "1019:  case len(operands) == arity: // call: f(x) # result not captured",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1019:     return iter()",
          "1020:    })",
          "1021:   })",
          "1029:   })",
          "1031: }",
          "1033: func (p *Planner) planCallArgs(terms []*ast.Term, idx int, args []ir.Operand, iter func([]ir.Operand) error) error {",
          "",
          "[Removed Lines]",
          "1022:  }",
          "1025:  return p.planCallArgs(operands[:len(operands)-1], 0, nil, func([]ir.Operand) error {",
          "1026:   p.ltarget = p.newOperand()",
          "1027:   return p.planTerm(value, func() error {",
          "1028:    return p.planUnifyLocal(p.ltarget, operands[len(operands)-1], iter)",
          "1030:  })",
          "",
          "[Added Lines]",
          "1031:  case len(operands) == arity+1: // call: f(x, 1) # caller captures result",
          "1032:   return p.planCallArgs(operands[:len(operands)-1], 0, nil, func([]ir.Operand) error {",
          "1033:    p.ltarget = p.newOperand()",
          "1034:    return p.planTerm(value, func() error {",
          "1035:     return p.planUnifyLocal(p.ltarget, operands[len(operands)-1], iter)",
          "1036:    })",
          "1038:  default:",
          "1039:   return fmt.Errorf(\"impossible replacement, arity mismatch\")",
          "1040:  }",
          "",
          "---------------"
        ],
        "topdown/eval.go||topdown/eval.go": [
          "File: topdown/eval.go -> topdown/eval.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "727:  var mocked bool",
          "728:  mock, mocked := e.functionMocks.Get(ref)",
          "729:  if mocked {",
          "731:    mockCall := append([]*ast.Term{ast.NewTerm(m)}, terms[1:]...)",
          "733:    e.functionMocks.Push()",
          "",
          "[Removed Lines]",
          "730:   if m, ok := mock.Value.(ast.Ref); ok { // builtin or data function",
          "",
          "[Added Lines]",
          "730:   if m, ok := mock.Value.(ast.Ref); ok && isFunction(e.compiler.TypeEnv, m) { // builtin or data function",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3402:  return !ref.HasPrefix(ast.DefaultRootRef) && !ref.HasPrefix(ast.InputRootRef)",
          "3403: }",
          "3408:   return false",
          "3409:  }",
          "3411:  return ok",
          "3412: }",
          "",
          "[Removed Lines]",
          "3405: func isFunction(env *ast.TypeEnv, ref *ast.Term) bool {",
          "3406:  r, ok := ref.Value.(ast.Ref)",
          "3407:  if !ok {",
          "3410:  _, ok = env.Get(r).(*types.Function)",
          "",
          "[Added Lines]",
          "3405: func isFunction(env *ast.TypeEnv, ref interface{}) bool {",
          "3406:  var r ast.Ref",
          "3407:  switch v := ref.(type) {",
          "3408:  case ast.Ref:",
          "3409:   r = v",
          "3410:  case *ast.Term:",
          "3411:   return isFunction(env, v.Value)",
          "3412:  case ast.Value:",
          "3414:  default:",
          "3415:   panic(\"expected ast.Value or *ast.Term\")",
          "3417:  _, ok := env.Get(r).(*types.Function)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7e502930df7d61a3a5bc37eadaf672cbd15d69e2",
      "candidate_info": {
        "commit_hash": "7e502930df7d61a3a5bc37eadaf672cbd15d69e2",
        "repo": "open-policy-agent/opa",
        "commit_url": "https://github.com/open-policy-agent/opa/commit/7e502930df7d61a3a5bc37eadaf672cbd15d69e2",
        "files": [
          "ast/compile.go",
          "ast/compile_test.go",
          "docs/content/policy-language.md",
          "docs/content/policy-testing.md",
          "format/testfiles/test_with.rego",
          "format/testfiles/test_with.rego.formatted",
          "internal/planner/planner.go",
          "internal/planner/rules.go",
          "test/cases/testdata/withkeyword/test-with-function-mock.yaml",
          "topdown/cache.go",
          "topdown/eval.go",
          "topdown/topdown_partial_test.go"
        ],
        "message": "ast+topdown+planner: replacement of non-built-in functions via 'with' (#4616)\n\nFollow-up to #4540\n\nWe can now mock functions that are user-defined:\n\n    package test\n\n    f(_) = 1 {\n        input.x = \"x\"\n    }\n    p = y {\n        y := f(1) with f as 2\n    }\n\n...following the same scoping rules as laid out for built-in mocks.\nThe replacement can be a value (replacing all calls), or a built-in,\nor another non-built-in function.\n\nAlso addresses bugs in the previous slice:\n* topdown/evalCall: account for empty rules result from indexer\n* topdown/eval: capture value replacement in PE could panic\n\nNote: in PE, we now drop 'with' for function mocks of any kind:\n\nThese are always fully replaced in the saved support modules, so\nthis should be OK.\n\nWhen keeping them, we'd also have to either copy the existing definitions\ninto the support module; or create a function stub in it.\n\nFixes #4449.\n\nSigned-off-by: Stephan Renatus <stephan.renatus@gmail.com>",
        "before_after_code_files": [
          "ast/compile.go||ast/compile.go",
          "ast/compile_test.go||ast/compile_test.go",
          "format/testfiles/test_with.rego||format/testfiles/test_with.rego",
          "format/testfiles/test_with.rego.formatted||format/testfiles/test_with.rego.formatted",
          "internal/planner/planner.go||internal/planner/planner.go",
          "internal/planner/rules.go||internal/planner/rules.go",
          "topdown/cache.go||topdown/cache.go",
          "topdown/eval.go||topdown/eval.go",
          "topdown/topdown_partial_test.go||topdown/topdown_partial_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ast/compile.go||ast/compile.go",
            "ast/compile_test.go||ast/compile_test.go"
          ],
          "candidate": [
            "ast/compile.go||ast/compile.go",
            "ast/compile_test.go||ast/compile_test.go"
          ]
        }
      },
      "candidate_diff": {
        "ast/compile.go||ast/compile.go": [
          "File: ast/compile.go -> ast/compile.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "4799: func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {",
          "4800:  target, value := expr.With[i].Target, expr.With[i].Value",
          "4801:  switch {",
          "4802:  case isDataRef(target):",
          "4803:   ref := target.Value.(Ref)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4803:  if v, ok := value.Value.(Var); ok {",
          "4804:   if _, ok := c.builtins[v.String()]; ok {",
          "4805:    value.Value = Ref([]*Term{NewTerm(v)})",
          "4806:   }",
          "4807:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4813:   }",
          "4815:   if node != nil {",
          "4816:    if child := node.Child(ref[len(ref)-1].Value); child != nil {",
          "4821:      }",
          "4822:     }",
          "4823:    }",
          "",
          "[Removed Lines]",
          "4817:     for _, value := range child.Values {",
          "4818:      if len(value.(*Rule).Head.Args) > 0 {",
          "4820:       return false, NewError(CompileErr, target.Loc(), \"with keyword used on non-built-in function\")",
          "",
          "[Added Lines]",
          "4829:     for _, v := range child.Values {",
          "4830:      if len(v.(*Rule).Head.Args) > 0 {",
          "4831:       if validateWithFunctionValue(c.builtins, c.RuleTree, value) {",
          "4832:        return false, nil",
          "4833:       }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4830:   if v, ok := target.Value.(Var); ok {",
          "4831:    target.Value = Ref([]*Term{NewTerm(v)})",
          "4832:   }",
          "4839:   targetRef := target.Value.(Ref)",
          "4840:   bi := c.builtins[targetRef.String()] // safe because isBuiltinRefOrVar checked this",
          "",
          "[Removed Lines]",
          "4833:   if v, ok := value.Value.(Var); ok {",
          "4834:    if _, ok := c.builtins[v.String()]; ok {",
          "4835:     value.Value = Ref([]*Term{NewTerm(v)})",
          "4836:    }",
          "4837:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4842:    return false, err",
          "4843:   }",
          "4852:   }",
          "4854:  default:",
          "4856:  }",
          "4857:  return requiresEval(value), nil",
          "4858: }",
          "",
          "[Removed Lines]",
          "4845:   if v, ok := value.Value.(Ref); ok {",
          "4846:    if c.RuleTree.Find(v) != nil { // ref exists in rule tree",
          "4847:     return false, nil",
          "4848:    }",
          "4849:    if _, ok := c.builtins[v.String()]; ok { // built-in replaced by other built-in",
          "4850:     return false, nil",
          "4851:    }",
          "4855:   return false, NewError(TypeErr, target.Location, \"with keyword target must reference existing %v, %v, or a built-in function\", InputRootDocument, DefaultRootDocument)",
          "",
          "[Added Lines]",
          "4853:   if validateWithFunctionValue(c.builtins, c.RuleTree, value) {",
          "4854:    return false, nil",
          "4857:   return false, NewError(TypeErr, target.Location, \"with keyword target must reference existing %v, %v, or a function\", InputRootDocument, DefaultRootDocument)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4878:  return nil",
          "4879: }",
          "4881: func isInputRef(term *Term) bool {",
          "4882:  if ref, ok := term.Value.(Ref); ok {",
          "4883:   if ref.HasPrefix(InputRootRef) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4883: func validateWithFunctionValue(bs map[string]*Builtin, ruleTree *TreeNode, value *Term) bool {",
          "4884:  if v, ok := value.Value.(Ref); ok {",
          "4885:   if ruleTree.Find(v) != nil { // ref exists in rule tree",
          "4886:    return true",
          "4887:   }",
          "4888:  }",
          "4889:  return isBuiltinRefOrVar(bs, value)",
          "4890: }",
          "",
          "---------------"
        ],
        "ast/compile_test.go||ast/compile_test.go": [
          "File: ast/compile_test.go -> ast/compile_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "4040:   {",
          "4041:    note:    \"invalid target\",",
          "4042:    input:   `p { true with foo.q as 1 }`,",
          "4044:   },",
          "4045:   {",
          "4046:    note:     \"built-in function: replaced by (unknown) var\",",
          "",
          "[Removed Lines]",
          "4043:    wantErr: fmt.Errorf(\"rego_type_error: with keyword target must reference existing input, data, or a built-in function\"),",
          "",
          "[Added Lines]",
          "4043:    wantErr: fmt.Errorf(\"rego_type_error: with keyword target must reference existing input, data, or a function\"),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4495: }",
          "4497: func TestCompilerMockFunction(t *testing.T) {",
          "4513:  tests := []struct {",
          "4514:   note          string",
          "4515:   module, extra string",
          "",
          "[Removed Lines]",
          "4498:  c := NewCompiler()",
          "4499:  c.Modules[\"test\"] = MustParseModule(`",
          "4500:  package test",
          "4502:  is_allowed(label) {",
          "4503:      label == \"test_label\"",
          "4504:  }",
          "4506:  p {true with data.test.is_allowed as \"blah\" }",
          "4507:  `)",
          "4508:  compileStages(c, c.rewriteWithModifiers)",
          "4509:  assertCompilerErrorStrings(t, c, []string{\"rego_compile_error: with keyword used on non-built-in function\"})",
          "4510: }",
          "4512: func TestCompilerMockBuiltinFunction(t *testing.T) {",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4645:     p { bar(foo.bar(\"one\")) with bar as mock with foo.bar as mock_mock }",
          "4646:    `,",
          "4647:   },",
          "4648:  }",
          "4650:  for _, tc := range tests {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4633:   {",
          "4634:    note: \"non-built-in function replaced value\",",
          "4635:    module: `package test",
          "4636:     original(_)",
          "4637:     p { original(true) with original as 123 }",
          "4638:    `,",
          "4639:   },",
          "4640:   {",
          "4641:    note: \"non-built-in function replaced by another, arity 0\",",
          "4642:    module: `package test",
          "4643:     original() = 1",
          "4644:     mock() = 2",
          "4645:     p { original() with original as mock }",
          "4646:    `,",
          "4647:    err: \"rego_type_error: undefined function data.test.original\", // TODO(sr): file bug -- this doesn't depend on \"with\" used or not",
          "4648:   },",
          "4649:   {",
          "4650:    note: \"non-built-in function replaced by another, arity 1\",",
          "4651:    module: `package test",
          "4652:     original(_)",
          "4653:     mock(_)",
          "4654:     p { original(true) with original as mock }",
          "4655:    `,",
          "4656:   },",
          "4657:   {",
          "4658:    note: \"non-built-in function replaced by built-in\",",
          "4659:    module: `package test",
          "4660:     original(_)",
          "4661:     p { original([1]) with original as count }",
          "4662:    `,",
          "4663:   },",
          "4664:   {",
          "4665:    note: \"non-built-in function replaced by another, arity mismatch\",",
          "4666:    module: `package test",
          "4667:     original(_)",
          "4668:     mock(_, _)",
          "4669:     p { original([1]) with original as mock }",
          "4670:    `,",
          "4671:    err: \"rego_type_error: data.test.original: arity mismatch\\n\\thave: (any, any)\\n\\twant: (any)\",",
          "4672:   },",
          "4673:   {",
          "4674:    note: \"non-built-in function replaced by built-in, arity mismatch\",",
          "4675:    module: `package test",
          "4676:     original(_)",
          "4677:     p { original([1]) with original as concat }",
          "4678:    `,",
          "4679:    err: \"rego_type_error: data.test.original: arity mismatch\\n\\thave: (string, any<array[string], set[string]>)\\n\\twant: (any)\",",
          "4680:   },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6415:    q:        \"x = 1 with foo.p as null\",",
          "6416:    pkg:      \"\",",
          "6417:    imports:  nil,",
          "6419:   },",
          "6420:   {",
          "6421:    note:     \"rewrite with value\",",
          "",
          "[Removed Lines]",
          "6418:    expected: fmt.Errorf(\"1 error occurred: 1:12: rego_type_error: with keyword target must reference existing input, data, or a built-in function\"),",
          "",
          "[Added Lines]",
          "6451:    expected: fmt.Errorf(\"1 error occurred: 1:12: rego_type_error: with keyword target must reference existing input, data, or a function\"),",
          "",
          "---------------"
        ],
        "format/testfiles/test_with.rego||format/testfiles/test_with.rego": [
          "File: format/testfiles/test_with.rego -> format/testfiles/test_with.rego",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:     count(array.concat(input.x, [])) with input.x as \"foo\"",
          "23:     with array.concat as true",
          "24:     with count as mock_f",
          "25: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: }",
          "27: original(x) = x+1",
          "29: more_func_replacements {",
          "30:     original(1) with original as mock_f",
          "31:     original(1) with original as 1234",
          "",
          "---------------"
        ],
        "format/testfiles/test_with.rego.formatted||format/testfiles/test_with.rego.formatted": [
          "File: format/testfiles/test_with.rego.formatted -> format/testfiles/test_with.rego.formatted",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:   with array.concat as true",
          "23:   with count as mock_f",
          "24: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: original(x) = x + 1",
          "28: more_func_replacements {",
          "29:  original(1) with original as mock_f",
          "30:  original(1) with original as 1234",
          "31: }",
          "",
          "---------------"
        ],
        "internal/planner/planner.go||internal/planner/planner.go": [
          "File: internal/planner/planner.go -> internal/planner/planner.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "558:  values := make([]*ast.Term, 0, len(e.With)) // NOTE(sr): we could be overallocating if there are builtin replacements",
          "559:  targets := make([]ast.Ref, 0, len(e.With))",
          "563:  for _, w := range e.With {",
          "573:   }",
          "577:  }",
          "579:  return p.planTermSlice(values, func(locals []ir.Operand) error {",
          "583:   paths := make([][]int, len(targets))",
          "584:   saveVars := ast.NewVarSet()",
          "",
          "[Removed Lines]",
          "561:  builtins := frame{}",
          "564:   switch v := w.Target.Value.(type) {",
          "565:   case ast.Ref:",
          "566:    if ast.DefaultRootDocument.Equal(v[0]) ||",
          "567:     ast.InputRootDocument.Equal(v[0]) {",
          "569:     values = append(values, w.Value)",
          "570:     targets = append(targets, w.Target.Value.(ast.Ref))",
          "571:     continue",
          "572:    }",
          "576:   builtins[w.Target.String()] = w.Value",
          "581:   p.mocks.PushFrame(builtins)",
          "",
          "[Added Lines]",
          "561:  mocks := frame{}",
          "564:   v := w.Target.Value.(ast.Ref)",
          "566:   switch {",
          "567:   case p.isFunction(v): // nothing to do",
          "569:   case ast.DefaultRootDocument.Equal(v[0]) ||",
          "570:    ast.InputRootDocument.Equal(v[0]):",
          "572:    values = append(values, w.Value)",
          "573:    targets = append(targets, w.Target.Value.(ast.Ref))",
          "575:    continue // not a mock",
          "578:   mocks[w.Target.String()] = w.Value",
          "583:   p.mocks.PushFrame(mocks)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "638:     err := iter()",
          "641:     if shadowing {",
          "642:      p.funcs.Push(map[string]string{})",
          "643:      for _, ref := range dataRefs {",
          "",
          "[Removed Lines]",
          "640:     p.mocks.PushFrame(builtins)",
          "",
          "[Added Lines]",
          "642:     p.mocks.PushFrame(mocks)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "826:    switch r := replacement.Value.(type) {",
          "827:    case ast.Ref:",
          "828:     if !r.HasPrefix(ast.DefaultRootRef) && !r.HasPrefix(ast.InputRootRef) {",
          "830:      operator = r.String()",
          "836:     }",
          "",
          "[Removed Lines]",
          "831:      decl := p.decls[operator]",
          "832:      p.externs[operator] = decl",
          "835:      return p.planExprCallFunc(operator, len(decl.Decl.Args()), void, operands, args, iter)",
          "",
          "[Added Lines]",
          "833:      bi := p.decls[operator]",
          "834:      p.externs[operator] = bi",
          "837:      return p.planExprCallFunc(operator, len(bi.Decl.FuncArgs().Args), void, operands, args, iter)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "849:     return fmt.Errorf(\"illegal replacement of operator %q by %v\", operator, replacement)",
          "853:    }",
          "854:   }",
          "",
          "[Removed Lines]",
          "851:    default: // target is a builtin, replacement a value",
          "852:     return p.planExprCallValue(replacement, len(p.decls[operator].Decl.Args()), operands, iter)",
          "",
          "[Added Lines]",
          "853:    default: // replacement is a value",
          "854:     if bi, ok := p.decls[operator]; ok {",
          "855:      return p.planExprCallValue(replacement, len(bi.Decl.FuncArgs().Args), operands, iter)",
          "856:     }",
          "857:     if node := p.rules.Lookup(op); node != nil {",
          "858:      return p.planExprCallValue(replacement, node.Arity(), operands, iter)",
          "859:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2264:  }",
          "2265: }",
          "2267: func op(v ir.Val) ir.Operand {",
          "2268:  return ir.Operand{Value: v}",
          "2269: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2274: func (p *Planner) isFunction(r ast.Ref) bool {",
          "2275:  if node := p.rules.Lookup(r); node != nil {",
          "2276:   return node.Arity() > 0",
          "2277:  }",
          "2278:  return false",
          "2279: }",
          "",
          "---------------"
        ],
        "internal/planner/rules.go||internal/planner/rules.go": [
          "File: internal/planner/rules.go -> internal/planner/rules.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "204: }",
          "207:  current := *s.stack[len(s.stack)-1]",
          "208:  for i := len(current) - 1; i >= 0; i-- {",
          "210:    return t",
          "211:   }",
          "212:  }",
          "",
          "[Removed Lines]",
          "206: func (s *functionMocksStack) Lookup(builtinName string) *ast.Term {",
          "209:   if t, ok := current[i][builtinName]; ok {",
          "",
          "[Added Lines]",
          "206: func (s *functionMocksStack) Lookup(f string) *ast.Term {",
          "209:   if t, ok := current[i][f]; ok {",
          "",
          "---------------"
        ],
        "topdown/cache.go||topdown/cache.go": [
          "File: topdown/cache.go -> topdown/cache.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "281: }",
          "284:  current := *s.stack[len(s.stack)-1]",
          "285:  for i := len(current) - 1; i >= 0; i-- {",
          "287:    return r, true",
          "288:   }",
          "289:  }",
          "",
          "[Removed Lines]",
          "283: func (s *functionMocksStack) Get(builtinName string) (*ast.Term, bool) {",
          "286:   if r, ok := current[i][builtinName]; ok {",
          "",
          "[Added Lines]",
          "283: func (s *functionMocksStack) Get(f ast.Ref) (*ast.Term, bool) {",
          "286:   if r, ok := current[i][f.String()]; ok {",
          "",
          "---------------"
        ],
        "topdown/eval.go||topdown/eval.go": [
          "File: topdown/eval.go -> topdown/eval.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "16:  \"github.com/open-policy-agent/opa/topdown/copypropagation\"",
          "17:  \"github.com/open-policy-agent/opa/topdown/print\"",
          "18:  \"github.com/open-policy-agent/opa/tracing\"",
          "19: )",
          "21: type evalIterator func(*eval) error",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19:  \"github.com/open-policy-agent/opa/types\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "466:   for _, with := range expr.With {",
          "470:     continue",
          "471:    }",
          "",
          "[Removed Lines]",
          "467:    if isOtherRef(with.Target) {",
          "469:     _ = disableRef(with.Value.Value.(ast.Ref))",
          "",
          "[Added Lines]",
          "468:    if isFunction(e.compiler.TypeEnv, with.Target) || // non-builtin function replaced",
          "469:     isOtherRef(with.Target) { // built-in replaced",
          "471:     ast.WalkRefs(with.Value, disableRef)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "490:  targets := []ast.Ref{}",
          "492:  for i := range expr.With {",
          "494:   plugged := e.bindings.Plug(expr.With[i].Value)",
          "495:   switch {",
          "500:   default: // target must be builtin",
          "504:    }",
          "506:   }",
          "508:  }",
          "510:  input, err := mergeTermWithValues(e.input, pairsInput)",
          "",
          "[Removed Lines]",
          "493:   target := expr.With[i].Target.Value",
          "496:   case isInputRef(expr.With[i].Target):",
          "497:    pairsInput = append(pairsInput, [...]*ast.Term{expr.With[i].Target, plugged})",
          "498:   case isDataRef(expr.With[i].Target):",
          "499:    pairsData = append(pairsData, [...]*ast.Term{expr.With[i].Target, plugged})",
          "501:    _, _, ok := e.builtinFunc(target.String())",
          "502:    if ok {",
          "503:     functionMocks = append(functionMocks, [...]*ast.Term{expr.With[i].Target, plugged})",
          "505:    continue",
          "507:   targets = append(targets, target.(ast.Ref))",
          "",
          "[Added Lines]",
          "494:   target := expr.With[i].Target",
          "498:   case isFunction(e.compiler.TypeEnv, target):",
          "499:    functionMocks = append(functionMocks, [...]*ast.Term{target, plugged})",
          "501:   case isInputRef(target):",
          "502:    pairsInput = append(pairsInput, [...]*ast.Term{target, plugged})",
          "504:   case isDataRef(target):",
          "505:    pairsData = append(pairsData, [...]*ast.Term{target, plugged})",
          "508:    if _, _, ok := e.builtinFunc(target.String()); ok {",
          "509:     functionMocks = append(functionMocks, [...]*ast.Term{target, plugged})",
          "510:     continue // don't append to disabled targets below",
          "513:   targets = append(targets, target.Value.(ast.Ref))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "709:  ref := terms[0].Value.(ast.Ref)",
          "711:  if ref[0].Equal(ast.DefaultRootDocument) {",
          "712:   var ir *ast.IndexResult",
          "713:   var err error",
          "714:   if e.partial() {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "717:  var mocked bool",
          "718:  mock, mocked := e.functionMocks.Get(ref)",
          "719:  if mocked {",
          "720:   if m, ok := mock.Value.(ast.Ref); ok { // builtin or data function",
          "721:    mockCall := append([]*ast.Term{ast.NewTerm(m)}, terms[1:]...)",
          "723:    e.functionMocks.Push()",
          "724:    err := e.evalCall(mockCall, func() error {",
          "725:     e.functionMocks.Pop()",
          "726:     err := iter()",
          "727:     e.functionMocks.Push()",
          "728:     return err",
          "729:    })",
          "730:    e.functionMocks.Pop()",
          "731:    return err",
          "732:   }",
          "733:  }",
          "738:   if mocked {",
          "739:    f := e.compiler.TypeEnv.Get(ref).(*types.Function)",
          "740:    return e.evalCallValue(len(f.FuncArgs().Args), terms, mock, iter)",
          "741:   }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "734:   return unsupportedBuiltinErr(e.query[e.index].Location)",
          "735:  }",
          "764:  }",
          "766:  if e.unknown(e.query[e.index], e.bindings) {",
          "",
          "[Removed Lines]",
          "737:  if mock, ok := e.functionMocks.Get(builtinName); ok {",
          "738:   switch m := mock.Value.(type) {",
          "739:   case ast.Ref: // builtin or data function",
          "740:    mockCall := append([]*ast.Term{ast.NewTerm(m)}, terms[1:]...)",
          "742:    e.functionMocks.Push()",
          "743:    err := e.evalCall(mockCall, func() error {",
          "744:     e.functionMocks.Pop()",
          "745:     err := iter()",
          "746:     e.functionMocks.Push()",
          "747:     return err",
          "748:    })",
          "749:    e.functionMocks.Pop()",
          "750:    return err",
          "752:   default: // value replacement",
          "753:    switch {",
          "754:    case len(terms) == len(bi.Decl.Args())+2: // captured var",
          "755:     return e.unify(terms[len(terms)-1], mock, iter)",
          "757:    case len(terms) == len(bi.Decl.Args())+1:",
          "758:     if mock.Value.Compare(ast.Boolean(false)) != 0 {",
          "759:      return iter()",
          "760:     }",
          "761:     return nil",
          "762:    }",
          "763:   }",
          "",
          "[Added Lines]",
          "769:  if mocked { // value replacement of built-in call",
          "770:   return e.evalCallValue(len(bi.Decl.Args()), terms, mock, iter)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "806:  return eval.eval(iter)",
          "807: }",
          "809: func (e *eval) unify(a, b *ast.Term, iter unifyIterator) error {",
          "810:  return e.biunify(a, b, e.bindings, e.bindings, iter)",
          "811: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "816: func (e *eval) evalCallValue(arity int, terms []*ast.Term, mock *ast.Term, iter unifyIterator) error {",
          "817:  switch {",
          "818:  case len(terms) == arity+2: // captured var",
          "819:   return e.unify(terms[len(terms)-1], mock, iter)",
          "821:  case len(terms) == arity+1:",
          "822:   if mock.Value.Compare(ast.Boolean(false)) != 0 {",
          "823:    return iter()",
          "824:   }",
          "825:   return nil",
          "826:  }",
          "827:  panic(\"unreachable\")",
          "828: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3254:  return !ref.HasPrefix(ast.DefaultRootRef) && !ref.HasPrefix(ast.InputRootRef)",
          "3255: }",
          "3257: func merge(a, b ast.Value) (ast.Value, bool) {",
          "3258:  aObj, ok1 := a.(ast.Object)",
          "3259:  bObj, ok2 := b.(ast.Object)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3278: func isFunction(env *ast.TypeEnv, ref *ast.Term) bool {",
          "3279:  r, ok := ref.Value.(ast.Ref)",
          "3280:  if !ok {",
          "3281:   return false",
          "3282:  }",
          "3283:  _, ok = env.Get(r).(*types.Function)",
          "3284:  return ok",
          "3285: }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3323: func (e *eval) updateSavedMocks(withs []*ast.With) []*ast.With {",
          "3324:  ret := make([]*ast.With, 0, len(withs))",
          "3325:  for _, w := range withs {",
          "3335:   }",
          "3337:  }",
          "3338:  return ret",
          "3339: }",
          "",
          "[Removed Lines]",
          "3326:   v := w.Copy()",
          "3327:   if isOtherRef(w.Target) {",
          "3328:    ref := v.Value.Value.(ast.Ref)",
          "3329:    nref := e.namespaceRef(ref)",
          "3330:    if e.saveSupport.Exists(nref) {",
          "3331:     v.Value.Value = nref",
          "3332:    } else {",
          "3333:     continue // skip",
          "3334:    }",
          "3336:   ret = append(ret, v)",
          "",
          "[Added Lines]",
          "3356:   if isOtherRef(w.Target) || isFunction(e.compiler.TypeEnv, w.Target) {",
          "3357:    continue",
          "3359:   ret = append(ret, w.Copy())",
          "",
          "---------------"
        ],
        "topdown/topdown_partial_test.go||topdown/topdown_partial_test.go": [
          "File: topdown/topdown_partial_test.go -> topdown/topdown_partial_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "766:     `package test",
          "768:     mock_concat(_, _) = \"foo/bar\"",
          "770:     q { concat(\"/\", [\"a\", \"b\"], \"foo/bar\") }`,",
          "771:    },",
          "772:    wantQueries: []string{`a = true`},",
          "773:   },",
          "774:   {",
          "775:    note:  \"with+builtin: unknowns in replacement function\",",
          "776:    query: \"data.test.p = a\",",
          "",
          "[Removed Lines]",
          "769:     p { q with concat as mock_concat}",
          "",
          "[Added Lines]",
          "769:     p { q with concat as mock_concat }",
          "770:     q { concat(\"/\", [\"a\", \"b\"], \"foo/bar\") }`,",
          "771:    },",
          "772:    wantQueries: []string{`a = true`},",
          "773:   },",
          "774:   {",
          "775:    note:  \"with+builtin: value replacement\",",
          "776:    query: \"data.test.p = a\",",
          "777:    modules: []string{",
          "778:     `package test",
          "780:     p { q with concat as \"foo/bar\" }",
          "785:   {",
          "786:    note:  \"with+function: no unknowns\",",
          "787:    query: \"data.test.p = a\",",
          "788:    modules: []string{",
          "789:     `package test",
          "790:     f(_, _) = \"x\"",
          "791:     mock_f(_, _) = \"foo/bar\"",
          "792:     p { q with f as mock_f }",
          "793:     q { f(\"/\", [\"a\", \"b\"], \"foo/bar\") }`,",
          "794:    },",
          "795:    wantQueries: []string{`a = true`},",
          "796:   },",
          "797:   {",
          "798:    note:  \"with+function: value replacement\",",
          "799:    query: \"data.test.p = a\",",
          "800:    modules: []string{",
          "801:     `package test",
          "802:     f(_, _) = \"x\"",
          "803:     p { q with f as \"foo/bar\" }",
          "804:     q { f(\"/\", [\"a\", \"b\"], \"foo/bar\") }`,",
          "805:    },",
          "806:    wantQueries: []string{`a = true`},",
          "807:   },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "791:     }`,",
          "792:    },",
          "793:   },",
          "794:   {",
          "795:    note:  \"with+builtin: unknowns in replaced function's args\",",
          "796:    query: \"data.test.p = a\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "828:   {",
          "829:    note:  \"with+function: unknowns in replacement function\",",
          "830:    query: \"data.test.p = a\",",
          "831:    modules: []string{",
          "832:     `package test",
          "833:     f(_) = \"x/y\"",
          "834:     mock_f(_) = \"foo/bar\" { input.y }",
          "835:     p { q with f as mock_f}",
          "836:     q { f(\"/\", \"foo/bar\") }`,",
          "837:    },",
          "838:    wantQueries: []string{`data.partial.test.mock_f(\"/\", \"foo/bar\"); a = true`},",
          "839:    wantSupport: []string{",
          "840:     `package partial.test",
          "842:     mock_f(__local1__3) = \"foo/bar\" {",
          "843:      input.y = x_term_3_03",
          "844:      x_term_3_03",
          "845:     }`,",
          "846:    },",
          "847:   },",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "806:     }`,",
          "807:    },",
          "808:    wantQueries: []string{`",
          "811:     a = true",
          "812:    `},",
          "813:    wantSupport: []string{`package partial.test",
          "",
          "[Removed Lines]",
          "809:     data.partial.test.q = x_term_1_01 with array.concat as data.partial.test.mock_concat",
          "810:     x_term_1_01 with array.concat as data.partial.test.mock_concat",
          "",
          "[Added Lines]",
          "863:     data.partial.test.q",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "818:     mock_concat(__local0__3, __local1__3) = [\"foo\", \"bar\"]",
          "819:    `},",
          "820:   },",
          "821:   {",
          "822:    note:  \"with+builtin: unknowns in replacement function's bodies\",",
          "823:    query: \"data.test.p = a\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "874:   {",
          "875:    note:  \"with+function: unknowns in replaced function's args\",",
          "876:    query: \"data.test.p = a\",",
          "877:    modules: []string{",
          "878:     `package test",
          "879:     my_concat(x, y) = concat(x, y)",
          "880:     mock_concat(_, _) = \"foo,bar\"",
          "881:     p {",
          "882:      q with my_concat as mock_concat",
          "883:     }",
          "884:     q {",
          "885:      my_concat(\"/\", input, \"foo,bar\")",
          "886:     }`,",
          "887:    },",
          "888:    wantQueries: []string{`",
          "889:     data.partial.test.q",
          "890:     a = true",
          "891:    `},",
          "892:    wantSupport: []string{`package partial.test",
          "894:     q {",
          "895:      data.partial.test.mock_concat(\"/\", input, \"foo,bar\")",
          "896:     }",
          "897:     mock_concat(__local2__3, __local3__3) = \"foo,bar\"",
          "898:    `},",
          "899:   },",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "831:     q { x := array.concat([\"foo\"], input) }`,",
          "832:    },",
          "833:    wantQueries: []string{`",
          "836:     a = true",
          "837:    `},",
          "838:    wantSupport: []string{`package partial.test",
          "",
          "[Removed Lines]",
          "834:     data.partial.test.q = x_term_1_01 with array.concat as data.partial.test.mock_concat",
          "835:     x_term_1_01 with array.concat as data.partial.test.mock_concat",
          "",
          "[Added Lines]",
          "913:     data.partial.test.q",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "851:     x_term_4_04",
          "852:    }`},",
          "853:   },",
          "854:   {",
          "855:    note:  \"with+builtin+negation: when replacement has no unknowns (args, defs), save negated expr without replacement\",",
          "856:    query: \"data.test.p = true\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "932:   {",
          "933:    note:  \"with+function: unknowns in replacement function's bodies\",",
          "934:    query: \"data.test.p = a\",",
          "935:    modules: []string{",
          "936:     `package test",
          "937:     my_concat(x, y) = concat(x, y)",
          "938:     mock_concat(_, _) = \"foo,bar\" { input.foo }",
          "939:     mock_concat(_, _) = \"bar,baz\" { input.bar }",
          "941:     p { q with my_concat as mock_concat }",
          "942:     q { x := my_concat(\",\", input) }`,",
          "943:    },",
          "944:    wantQueries: []string{`",
          "945:     data.partial.test.q",
          "946:     a = true",
          "947:    `},",
          "948:    wantSupport: []string{`package partial.test",
          "950:    q {",
          "951:     __local9__2 = input",
          "952:     data.partial.test.mock_concat(\",\", __local9__2, __local8__2)",
          "953:     __local6__2 = __local8__2",
          "954:    }",
          "955:    mock_concat(__local2__3, __local3__3) = \"foo,bar\" {",
          "956:     input.foo = x_term_3_03",
          "957:     x_term_3_03",
          "958:    }",
          "959:    mock_concat(__local4__4, __local5__4) = \"bar,baz\" {",
          "960:     input.bar = x_term_4_04",
          "961:     x_term_4_04",
          "962:    }`},",
          "963:   },",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "873:     q { 100 = input.x }",
          "874:    `},",
          "875:   },",
          "876:   {",
          "877:    note:  \"with+builtin+negation: when replacement args have unknowns, save negated expr with replacement\",",
          "878:    query: \"data.test.p = true\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "986:   {",
          "987:    note:  \"with+function+negation: when replacement has no unknowns (args, defs), save negated expr without replacement\",",
          "988:    query: \"data.test.p = true\",",
          "989:    modules: []string{`",
          "990:     package test",
          "991:     my_count(x) = count(x)",
          "992:     mock_count(_) = 100",
          "993:     p {",
          "994:      not q with input.x as 1 with my_count as mock_count",
          "995:     }",
          "997:     q {",
          "998:      my_count([1,2,3]) = input.x",
          "999:     }",
          "1000:    `},",
          "1001:    wantQueries: []string{\"not data.partial.test.q with input.x as 1\"},",
          "1002:    wantSupport: []string{`",
          "1003:     package partial.test",
          "1005:     q { 100 = input.x }",
          "1006:    `},",
          "1007:   },",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "888:      count(input.y) = input.x # unknown arg for mocked func",
          "889:     }",
          "890:    `},",
          "896:    wantSupport: []string{`",
          "897:     package partial.test",
          "899:     q { data.partial.test.mock_count(input.y, __local1__3); __local1__3 = input.x }",
          "901:    `},",
          "902:   },",
          "903:   {",
          "",
          "[Removed Lines]",
          "891:    wantQueryASTs: func() []ast.Body {",
          "892:     b := ast.MustParseBody(\"not data.partial.test.q with input.x as 1 with count as data.partial.test.mock_count\")",
          "893:     b[0].With[1].Target.Value = ast.Ref([]*ast.Term{ast.VarTerm(\"count\")})",
          "894:     return []ast.Body{b}",
          "895:    }(),",
          "900:     mock_count(__local0__4) = 100 { true }",
          "",
          "[Added Lines]",
          "1023:    wantQueries: []string{\"not data.partial.test.q with input.x as 1\"},",
          "1028:     mock_count(__local0__4) = 100",
          "1029:    `},",
          "1030:   },",
          "1031:   {",
          "1032:    note:  \"with+function+negation: when replacement args have unknowns, save negated expr with replacement\",",
          "1033:    query: \"data.test.p = true\",",
          "1034:    modules: []string{`",
          "1035:     package test",
          "1036:     my_count(x) = count(x)",
          "1037:     mock_count(_) = 100",
          "1038:     p {",
          "1039:      not q with input.x as 1 with my_count as mock_count",
          "1040:     }",
          "1042:     q {",
          "1043:      my_count(input.y) = input.x # unknown arg for mocked func",
          "1044:     }",
          "1045:    `},",
          "1046:    wantQueries: []string{`not data.partial.test.q with input.x as 1`},",
          "1047:    wantSupport: []string{`",
          "1048:     package partial.test",
          "1050:     q { data.partial.test.mock_count(input.y, __local3__3); __local3__3 = input.x }",
          "1051:     mock_count(__local1__4) = 100",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "916:      count([1]) = input.x # unknown arg for mocked func",
          "917:     }",
          "918:    `},",
          "924:    wantSupport: []string{`",
          "925:     package partial.test",
          "",
          "[Removed Lines]",
          "919:    wantQueryASTs: func() []ast.Body {",
          "920:     b := ast.MustParseBody(\"not data.partial.test.q with input.x as 1 with count as data.partial.test.mock_count\")",
          "921:     b[0].With[1].Target.Value = ast.Ref([]*ast.Term{ast.VarTerm(\"count\")})",
          "922:     return []ast.Body{b}",
          "923:    }(),",
          "",
          "[Added Lines]",
          "1070:    wantQueries: []string{\"not data.partial.test.q with input.x as 1\"},",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "929:     mock_count(__local1__5) = 101 { input.z = x_term_5_05; x_term_5_05 }",
          "930:    `},",
          "931:   },",
          "932:   {",
          "933:    note:  \"save: sub path\",",
          "934:    query: \"input.x = 1; input.y = 2; input.z.a = 3; input.z.b = x\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1079:   {",
          "1080:    note:  \"with+function+negation: when replacement defs have unknowns, save negated expr with replacement\",",
          "1081:    query: \"data.test.p = true\",",
          "1082:    modules: []string{`",
          "1083:     package test",
          "1084:     my_count(x) = count(x)",
          "1085:     mock_count(_) = 100 { input.y }",
          "1086:     mock_count(_) = 101 { input.z }",
          "1087:     p {",
          "1088:      not q with input.x as 1 with my_count as mock_count",
          "1089:     }",
          "1091:     q {",
          "1092:      my_count([1]) = input.x # unknown arg for mocked func",
          "1093:     }",
          "1094:    `},",
          "1095:    wantQueries: []string{\"not data.partial.test.q with input.x as 1\"},",
          "1096:    wantSupport: []string{`",
          "1097:     package partial.test",
          "1099:     q { data.partial.test.mock_count([1], __local4__3); __local4__3 = input.x }",
          "1100:     mock_count(__local1__4) = 100 { input.y = x_term_4_04; x_term_4_04 }",
          "1101:     mock_count(__local2__5) = 101 { input.z = x_term_5_05; x_term_5_05 }",
          "1102:    `},",
          "1103:   },",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8f4986946cae047c532687efe8223f090527b39f",
      "candidate_info": {
        "commit_hash": "8f4986946cae047c532687efe8223f090527b39f",
        "repo": "open-policy-agent/opa",
        "commit_url": "https://github.com/open-policy-agent/opa/commit/8f4986946cae047c532687efe8223f090527b39f",
        "files": [
          "ast/check.go",
          "ast/compile.go",
          "ast/compile_test.go",
          "ast/parser.go",
          "ast/visit.go",
          "docs/content/policy-language.md",
          "docs/content/policy-testing.md",
          "format/testfiles/test_with.rego",
          "format/testfiles/test_with.rego.formatted",
          "internal/planner/planner.go",
          "internal/planner/rules.go",
          "test/cases/testdata/withkeyword/test-with-builtin-mock.yaml",
          "topdown/cache.go",
          "topdown/eval.go",
          "topdown/query.go",
          "topdown/save.go",
          "topdown/topdown_partial_test.go"
        ],
        "message": "ast+topdown+planner: allow for mocking built-in functions via \"with\" (#4540)\n\nWith this change, we can replace calls to built-in functions via `with`. The replacement\ncan either be a value -- which will be used as the return value for every call to the\nmocked built-in -- or a reference to a non-built-in function -- when the results need\nto depend on the call's arguments.\n\nCompiler, topdown, and planner have been adapted in this change. The included\ndocs changes describe the replacement options further.\n\nFixes first part of #4449. (Missing are non-built-in functions as mock targets.)\n\nSigned-off-by: Stephan Renatus <stephan.renatus@gmail.com>",
        "before_after_code_files": [
          "ast/check.go||ast/check.go",
          "ast/compile.go||ast/compile.go",
          "ast/compile_test.go||ast/compile_test.go",
          "ast/parser.go||ast/parser.go",
          "ast/visit.go||ast/visit.go",
          "format/testfiles/test_with.rego||format/testfiles/test_with.rego",
          "format/testfiles/test_with.rego.formatted||format/testfiles/test_with.rego.formatted",
          "internal/planner/planner.go||internal/planner/planner.go",
          "internal/planner/rules.go||internal/planner/rules.go",
          "topdown/cache.go||topdown/cache.go",
          "topdown/eval.go||topdown/eval.go",
          "topdown/query.go||topdown/query.go",
          "topdown/save.go||topdown/save.go",
          "topdown/topdown_partial_test.go||topdown/topdown_partial_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "ast/compile.go||ast/compile.go",
            "ast/compile_test.go||ast/compile_test.go"
          ],
          "candidate": [
            "ast/compile.go||ast/compile.go",
            "ast/compile_test.go||ast/compile_test.go"
          ]
        }
      },
      "candidate_diff": {
        "ast/check.go||ast/check.go": [
          "File: ast/check.go -> ast/check.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "267: }",
          "269: func (tc *typeChecker) checkExpr(env *TypeEnv, expr *Expr) *Error {",
          "270:  if !expr.IsCall() {",
          "271:   return nil",
          "272:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "270:  if err := tc.checkExprWith(env, expr, 0); err != nil {",
          "271:   return err",
          "272:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "365:  return nil",
          "366: }",
          "368: func unify2(env *TypeEnv, a *Term, typeA types.Type, b *Term, typeB types.Type) bool {",
          "370:  nilA := types.Nil(typeA)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "371: func (tc *typeChecker) checkExprWith(env *TypeEnv, expr *Expr, i int) *Error {",
          "372:  if i == len(expr.With) {",
          "373:   return nil",
          "374:  }",
          "376:  target, value := expr.With[i].Target, expr.With[i].Value",
          "377:  targetType, valueType := env.Get(target), env.Get(value)",
          "379:  if t, ok := targetType.(*types.Function); ok { // built-in function replacement",
          "380:   switch v := valueType.(type) {",
          "381:   case *types.Function: // ...by function",
          "382:    if !unifies(targetType, valueType) {",
          "383:     return newArgError(expr.With[i].Loc(), target.Value.(Ref), \"arity mismatch\", v.Args(), t.FuncArgs())",
          "384:    }",
          "385:   default: // ... by value, nothing to check",
          "386:   }",
          "387:  }",
          "389:  return tc.checkExprWith(env, expr, i+1)",
          "390: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "610: }",
          "612: func (rc *refChecker) checkApply(curr *TypeEnv, ref Ref) *Error {",
          "617:  }",
          "618:  return nil",
          "619: }",
          "",
          "[Removed Lines]",
          "613:  if tpe := curr.Get(ref); tpe != nil {",
          "614:   if _, ok := tpe.(*types.Function); ok {",
          "615:    return newRefErrUnsupported(ref[0].Location, rc.varRewriter(ref), len(ref)-1, tpe)",
          "616:   }",
          "",
          "[Added Lines]",
          "637:  switch tpe := curr.Get(ref).(type) {",
          "638:  case *types.Function: // NOTE(sr): We don't support first-class functions, except for `with`.",
          "639:   return newRefErrUnsupported(ref[0].Location, rc.varRewriter(ref), len(ref)-1, tpe)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "797:   }",
          "798:   return unifies(types.Values(a), types.Values(b))",
          "799:  case *types.Function:",
          "801:   return false",
          "802:  default:",
          "803:   panic(\"unreachable\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "826:   if types.Arity(a) == types.Arity(b) {",
          "827:    b := b.(*types.Function)",
          "828:    for i := range a.FuncArgs().Args {",
          "829:     if !unifies(a.FuncArgs().Arg(i), b.FuncArgs().Arg(i)) {",
          "830:      return false",
          "831:     }",
          "832:    }",
          "833:    return true",
          "834:   }",
          "",
          "---------------"
        ],
        "ast/compile.go||ast/compile.go": [
          "File: ast/compile.go -> ast/compile.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:  \"strconv\"",
          "12:  \"strings\"",
          "14:  \"github.com/open-policy-agent/opa/internal/debug\"",
          "15:  \"github.com/open-policy-agent/opa/internal/gojsonschema\"",
          "16:  \"github.com/open-policy-agent/opa/metrics\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14:  \"github.com/open-policy-agent/opa/ast/location\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "634:  set := map[*Rule]struct{}{}",
          "635:  var walk func(node *TreeNode, i int)",
          "636:  walk = func(node *TreeNode, i int) {",
          "640:    node.DepthFirst(func(descendant *TreeNode) bool {",
          "",
          "[Removed Lines]",
          "637:   if i >= len(ref) {",
          "",
          "[Added Lines]",
          "638:   switch {",
          "639:   case i >= len(ref):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "644:     }",
          "645:     return descendant.Hide",
          "646:    })",
          "",
          "[Removed Lines]",
          "647:   } else if i == 0 || IsConstant(ref[i].Value) {",
          "",
          "[Added Lines]",
          "650:   case i == 0 || IsConstant(ref[i].Value):",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "659:     walk(child, i+1)",
          "660:    }",
          "664:    for _, child := range node.Children {",
          "",
          "[Removed Lines]",
          "661:   } else {",
          "",
          "[Added Lines]",
          "665:   default:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2846:  return nil",
          "2847: }",
          "2851: func (n *TreeNode) DepthFirst(f func(node *TreeNode) bool) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2854: func (n *TreeNode) Find(ref Ref) *TreeNode {",
          "2855:  node := n",
          "2856:  for _, r := range ref {",
          "2857:   child := node.Child(r.Value)",
          "2858:   if child == nil {",
          "2859:    return nil",
          "2860:   }",
          "2861:   node = child",
          "2862:  }",
          "2863:  return node",
          "2864: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4765:  var result []*Expr",
          "4766:  for i := range expr.With {",
          "4768:   if err != nil {",
          "4769:    return nil, err",
          "4770:   }",
          "4773:    eq := f.Generate(expr.With[i].Value)",
          "4774:    result = append(result, eq)",
          "4775:    expr.With[i].Value = eq.Operand(0)",
          "4776:   }",
          "4777:  }",
          "4786: }",
          "4795:   node := c.RuleTree",
          "4796:   for i := 0; i < len(ref)-1; i++ {",
          "4797:    child := node.Child(ref[i].Value)",
          "4798:    if child == nil {",
          "4799:     break",
          "4800:    } else if len(child.Values) > 0 {",
          "4802:    }",
          "4803:    node = child",
          "4804:   }",
          "",
          "[Removed Lines]",
          "4767:   err := validateTarget(c, expr.With[i].Target)",
          "4772:   if requiresEval(expr.With[i].Value) {",
          "4782:  if len(result) > 0 {",
          "4783:   result = append(result, expr)",
          "4784:  }",
          "4785:  return result, nil",
          "4788: func validateTarget(c *Compiler, term *Term) *Error {",
          "4789:  if !isInputRef(term) && !isDataRef(term) {",
          "4790:   return NewError(TypeErr, term.Location, \"with keyword target must reference existing %v or %v\", InputRootDocument, DefaultRootDocument)",
          "4791:  }",
          "4793:  if isDataRef(term) {",
          "4794:   ref := term.Value.(Ref)",
          "4801:     return NewError(CompileErr, term.Loc(), \"with keyword cannot partially replace virtual document(s)\")",
          "",
          "[Added Lines]",
          "4784:   eval, err := validateWith(c, expr, i)",
          "4789:   if eval {",
          "4796:  return append(result, expr), nil",
          "4799: func validateWith(c *Compiler, expr *Expr, i int) (bool, *Error) {",
          "4800:  target, value := expr.With[i].Target, expr.With[i].Value",
          "4801:  switch {",
          "4802:  case isDataRef(target):",
          "4803:   ref := target.Value.(Ref)",
          "4810:     return false, NewError(CompileErr, target.Loc(), \"with keyword cannot partially replace virtual document(s)\")",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4807:    if child := node.Child(ref[len(ref)-1].Value); child != nil {",
          "4808:     for _, value := range child.Values {",
          "4809:      if len(value.(*Rule).Head.Args) > 0 {",
          "4811:      }",
          "4812:     }",
          "4813:    }",
          "4814:   }",
          "4816:  }",
          "4817:  return nil",
          "4818: }",
          "",
          "[Removed Lines]",
          "4810:       return NewError(CompileErr, term.Loc(), \"with keyword cannot replace functions\")",
          "",
          "[Added Lines]",
          "4820:       return false, NewError(CompileErr, target.Loc(), \"with keyword used on non-built-in function\")",
          "4825:  case isInputRef(target): // ok, valid",
          "4826:  case isBuiltinRefOrVar(c.builtins, target):",
          "4830:   if v, ok := target.Value.(Var); ok {",
          "4831:    target.Value = Ref([]*Term{NewTerm(v)})",
          "4832:   }",
          "4833:   if v, ok := value.Value.(Var); ok {",
          "4834:    if _, ok := c.builtins[v.String()]; ok {",
          "4835:     value.Value = Ref([]*Term{NewTerm(v)})",
          "4836:    }",
          "4837:   }",
          "4839:   targetRef := target.Value.(Ref)",
          "4840:   bi := c.builtins[targetRef.String()] // safe because isBuiltinRefOrVar checked this",
          "4841:   if err := validateWithBuiltinTarget(bi, targetRef, target.Loc()); err != nil {",
          "4842:    return false, err",
          "4843:   }",
          "4845:   if v, ok := value.Value.(Ref); ok {",
          "4846:    if c.RuleTree.Find(v) != nil { // ref exists in rule tree",
          "4847:     return false, nil",
          "4848:    }",
          "4849:    if _, ok := c.builtins[v.String()]; ok { // built-in replaced by other built-in",
          "4850:     return false, nil",
          "4851:    }",
          "4852:   }",
          "4854:  default:",
          "4855:   return false, NewError(TypeErr, target.Location, \"with keyword target must reference existing %v, %v, or a built-in function\", InputRootDocument, DefaultRootDocument)",
          "4856:  }",
          "4857:  return requiresEval(value), nil",
          "4858: }",
          "4860: func validateWithBuiltinTarget(bi *Builtin, target Ref, loc *location.Location) *Error {",
          "4861:  switch bi.Name {",
          "4862:  case Equality.Name,",
          "4863:   RegoMetadataChain.Name,",
          "4864:   RegoMetadataRule.Name:",
          "4865:   return NewError(CompileErr, loc, \"with keyword replacing built-in function: replacement of %q invalid\", bi.Name)",
          "4866:  }",
          "4868:  switch {",
          "4869:  case target.HasPrefix(Ref([]*Term{VarTerm(\"internal\")})):",
          "4870:   return NewError(CompileErr, loc, \"with keyword replacing built-in function: replacement of internal function %q invalid\", target)",
          "4872:  case bi.Relation:",
          "4873:   return NewError(CompileErr, loc, \"with keyword replacing built-in function: target must not be a relation\")",
          "4875:  case bi.Decl.Result() == nil:",
          "4876:   return NewError(CompileErr, loc, \"with keyword replacing built-in function: target must not be a void function\")",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4835:  return false",
          "4836: }",
          "4838: func isVirtual(node *TreeNode, ref Ref) bool {",
          "4839:  for i := 0; i < len(ref); i++ {",
          "4840:   child := node.Child(ref[i].Value)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4899: func isBuiltinRefOrVar(bs map[string]*Builtin, term *Term) bool {",
          "4900:  switch v := term.Value.(type) {",
          "4901:  case Ref, Var:",
          "4902:   _, ok := bs[v.String()]",
          "4903:   return ok",
          "4904:  }",
          "4905:  return false",
          "4906: }",
          "",
          "---------------"
        ],
        "ast/compile_test.go||ast/compile_test.go": [
          "File: ast/compile_test.go -> ast/compile_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "3996:  `",
          "3998:  tests := []struct {",
          "4003:  }{",
          "4004:   {",
          "4005:    note:     \"nop\",",
          "",
          "[Removed Lines]",
          "3999:   note     string",
          "4000:   input    string",
          "4001:   expected string",
          "4002:   wantErr  error",
          "",
          "[Added Lines]",
          "3999:   note         string",
          "4000:   input        string",
          "4001:   expected     string",
          "4002:   expectedRule *Rule",
          "4003:   wantErr      error",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4039:   {",
          "4040:    note:    \"invalid target\",",
          "4041:    input:   `p { true with foo.q as 1 }`,",
          "4043:   },",
          "4044:  }",
          "",
          "[Removed Lines]",
          "4042:    wantErr: fmt.Errorf(\"rego_type_error: with keyword target must reference existing input or data\"),",
          "",
          "[Added Lines]",
          "4043:    wantErr: fmt.Errorf(\"rego_type_error: with keyword target must reference existing input, data, or a built-in function\"),",
          "4044:   },",
          "4045:   {",
          "4046:    note:     \"built-in function: replaced by (unknown) var\",",
          "4047:    input:    `p { true with time.now_ns as foo }`,",
          "4048:    expected: `p { true with time.now_ns as foo }`, // `foo` still a Var here",
          "4049:   },",
          "4050:   {",
          "4051:    note: \"built-in function: valid, arity 0\",",
          "4052:    input: `",
          "4053:     p { true with time.now_ns as now }",
          "4054:     now() = 1",
          "4055:    `,",
          "4056:    expected: `p { true with time.now_ns as data.test.now }`,",
          "4057:   },",
          "4058:   {",
          "4059:    note: \"built-in function: valid func ref, arity 1\",",
          "4060:    input: `",
          "4061:     p { true with http.send as mock_http_send }",
          "4062:     mock_http_send(_) = { \"body\": \"yay\" }",
          "4063:    `,",
          "4064:    expected: `p { true with http.send as data.test.mock_http_send }`,",
          "4065:   },",
          "4066:   {",
          "4067:    note: \"built-in function: replaced by value\",",
          "4068:    input: `",
          "4069:     p { true with http.send as { \"body\": \"yay\" } }",
          "4070:    `,",
          "4071:    expected: `p { true with http.send as {\"body\": \"yay\"} }`,",
          "4072:   },",
          "4073:   {",
          "4074:    note: \"built-in function: replaced by comprehension\",",
          "4075:    input: `",
          "4076:     p { true with http.send as { x: true | x := [\"a\", \"b\"][_] } }",
          "4077:    `,",
          "4078:    expected: `p { __local2__ = {__local0__: true | __local1__ = [\"a\", \"b\"]; __local0__ = __local1__[_]}; true with http.send as __local2__ }`,",
          "4079:   },",
          "4080:   {",
          "4081:    note: \"built-in function: replaced by ref\",",
          "4082:    input: `",
          "4083:     p { true with http.send as resp }",
          "4084:     resp := { \"body\": \"yay\" }",
          "4085:    `,",
          "4086:    expected: `p { true with http.send as data.test.resp }`,",
          "4087:   },",
          "4088:   {",
          "4089:    note: \"built-in function: replaced by another built-in (ref)\",",
          "4090:    input: `",
          "4091:     p { true with http.send as object.union_n }",
          "4092:    `,",
          "4093:    expected: `p { true with http.send as object.union_n }`,",
          "4094:   },",
          "4095:   {",
          "4096:    note: \"built-in function: replaced by another built-in (simple)\",",
          "4097:    input: `",
          "4098:     p { true with http.send as count }",
          "4099:    `,",
          "4100:    expectedRule: func() *Rule {",
          "4101:     r := MustParseRule(`p { true with http.send as count }`)",
          "4102:     r.Body[0].With[0].Value.Value = Ref([]*Term{VarTerm(\"count\")})",
          "4103:     return r",
          "4104:    }(),",
          "4105:   },",
          "4106:   {",
          "4107:    note: \"built-in function: valid, arity 1, non-compound name\",",
          "4108:    input: `",
          "4109:     p { concat(\"/\", input) with concat as mock_concat }",
          "4110:     mock_concat(_, _) = \"foo/bar\"",
          "4111:    `,",
          "4112:    expectedRule: func() *Rule {",
          "4113:     r := MustParseRule(`p { concat(\"/\", input) with concat as data.test.mock_concat }`)",
          "4114:     r.Body[0].With[0].Target.Value = Ref([]*Term{VarTerm(\"concat\")})",
          "4115:     return r",
          "4116:    }(),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4051:    compileStages(c, c.rewriteWithModifiers)",
          "4052:    if tc.wantErr == nil {",
          "4053:     assertNotFailed(t, c)",
          "4055:     result := c.Modules[\"test\"].Rules[1]",
          "4056:     if result.Compare(expected) != 0 {",
          "4057:      t.Fatalf(\"\\nExp: %v\\nGot: %v\", expected, result)",
          "",
          "[Removed Lines]",
          "4054:     expected := MustParseRule(tc.expected)",
          "",
          "[Added Lines]",
          "4128:     expected := tc.expectedRule",
          "4129:     if expected == nil {",
          "4130:      expected = MustParseRule(tc.expected)",
          "4131:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4429:  p {true with data.test.is_allowed as \"blah\" }",
          "4430:  `)",
          "4431:  compileStages(c, c.rewriteWithModifiers)",
          "4433: }",
          "4435: func TestCompilerMockVirtualDocumentPartially(t *testing.T) {",
          "",
          "[Removed Lines]",
          "4432:  assertCompilerErrorStrings(t, c, []string{\"rego_compile_error: with keyword cannot replace functions\"})",
          "",
          "[Added Lines]",
          "4509:  assertCompilerErrorStrings(t, c, []string{\"rego_compile_error: with keyword used on non-built-in function\"})",
          "4510: }",
          "4512: func TestCompilerMockBuiltinFunction(t *testing.T) {",
          "4513:  tests := []struct {",
          "4514:   note          string",
          "4515:   module, extra string",
          "4516:   err           string",
          "4517:  }{",
          "4518:   {",
          "4519:    note: \"simple valid\",",
          "4520:    module: `package test",
          "4521:     now() = 123",
          "4522:     p { true with time.now_ns as now }",
          "4523:    `,",
          "4524:   },",
          "4525:   {",
          "4526:    note: \"simple valid, simple name\",",
          "4527:    module: `package test",
          "4528:     mock_concat(_, _) = \"foo/bar\"",
          "4529:     p { concat(\"/\", input) with concat as mock_concat }",
          "4530:    `,",
          "4531:   },",
          "4532:   {",
          "4533:    note: \"invalid ref: nonexistant\",",
          "4534:    module: `package test",
          "4535:     p { true with time.now_ns as now }",
          "4536:    `,",
          "4537:    err: \"rego_unsafe_var_error: var now is unsafe\", // we're running all compiler stages here",
          "4538:   },",
          "4539:   {",
          "4540:    note: \"valid ref: not a function, but arity = 0\",",
          "4541:    module: `package test",
          "4542:     now = 1",
          "4543:     p { true with time.now_ns as now }",
          "4544:    `,",
          "4545:   },",
          "4546:   {",
          "4547:    note: \"ref: not a function, arity > 0\",",
          "4548:    module: `package test",
          "4549:     http_send = { \"body\": \"nope\" }",
          "4550:     p { true with http.send as http_send }",
          "4551:    `,",
          "4552:   },",
          "4553:   {",
          "4554:    note: \"invalid ref: arity mismatch\",",
          "4555:    module: `package test",
          "4556:     http_send(_, _) = { \"body\": \"nope\" }",
          "4557:     p { true with http.send as http_send }",
          "4558:    `,",
          "4559:    err: \"rego_type_error: http.send: arity mismatch\\n\\thave: (any, any)\\n\\twant: (object[string: any])\",",
          "4560:   },",
          "4561:   {",
          "4562:    note: \"invalid ref: arity mismatch (in call)\",",
          "4563:    module: `package test",
          "4564:     http_send(_, _) = { \"body\": \"nope\" }",
          "4565:     p { http.send({}) with http.send as http_send }",
          "4566:    `,",
          "4567:    err: \"rego_type_error: http.send: arity mismatch\\n\\thave: (any, any)\\n\\twant: (object[string: any])\",",
          "4568:   },",
          "4569:   {",
          "4570:    note: \"invalid ref: value another built-in with different type\",",
          "4571:    module: `package test",
          "4572:     p { true with http.send as net.lookup_ip_addr }",
          "4573:    `,",
          "4574:    err: \"rego_type_error: http.send: arity mismatch\\n\\thave: (string)\\n\\twant: (object[string: any])\",",
          "4575:   },",
          "4576:   {",
          "4577:    note: \"ref: value another built-in with compatible type\",",
          "4578:    module: `package test",
          "4579:     p { true with count as object.union_n }",
          "4580:    `,",
          "4581:   },",
          "4582:   {",
          "4583:    note: \"valid: package import\",",
          "4584:    extra: `package mocks",
          "4585:     http_send(_) = {}",
          "4586:    `,",
          "4587:    module: `package test",
          "4588:     import data.mocks",
          "4589:     p { true with http.send as mocks.http_send }",
          "4590:    `,",
          "4591:   },",
          "4592:   {",
          "4593:    note: \"valid: function import\",",
          "4594:    extra: `package mocks",
          "4595:     http_send(_) = {}",
          "4596:    `,",
          "4597:    module: `package test",
          "4598:     import data.mocks.http_send",
          "4599:     p { true with http.send as http_send }",
          "4600:    `,",
          "4601:   },",
          "4602:   {",
          "4603:    note: \"invalid target: relation\",",
          "4604:    module: `package test",
          "4605:     my_walk(_, _)",
          "4606:     p { true with walk as my_walk }",
          "4607:    `,",
          "4608:    err: \"rego_compile_error: with keyword replacing built-in function: target must not be a relation\",",
          "4609:   },",
          "4610:   {",
          "4611:    note: \"invalid target: eq\",",
          "4612:    module: `package test",
          "4613:     my_eq(_, _)",
          "4614:     p { true with eq as my_eq }",
          "4615:    `,",
          "4616:    err: `rego_compile_error: with keyword replacing built-in function: replacement of \"eq\" invalid`,",
          "4617:   },",
          "4618:   {",
          "4619:    note: \"invalid target: rego.metadata.chain\",",
          "4620:    module: `package test",
          "4621:     p { true with rego.metadata.chain as [] }",
          "4622:    `,",
          "4623:    err: `rego_compile_error: with keyword replacing built-in function: replacement of \"rego.metadata.chain\" invalid`,",
          "4624:   },",
          "4625:   {",
          "4626:    note: \"invalid target: rego.metadata.rule\",",
          "4627:    module: `package test",
          "4628:     p { true with rego.metadata.rule as {} }",
          "4629:    `,",
          "4630:    err: `rego_compile_error: with keyword replacing built-in function: replacement of \"rego.metadata.rule\" invalid`,",
          "4631:   },",
          "4632:   {",
          "4633:    note: \"invalid target: internal.print\",",
          "4634:    module: `package test",
          "4635:     my_print(_, _)",
          "4636:     p { true with internal.print as my_print }",
          "4637:    `,",
          "4638:    err: `rego_compile_error: with keyword replacing built-in function: replacement of internal function \"internal.print\" invalid`,",
          "4639:   },",
          "4640:   {",
          "4641:    note: \"mocking custom built-in\",",
          "4642:    module: `package test",
          "4643:     mock(_)",
          "4644:     mock_mock(_)",
          "4645:     p { bar(foo.bar(\"one\")) with bar as mock with foo.bar as mock_mock }",
          "4646:    `,",
          "4647:   },",
          "4648:  }",
          "4650:  for _, tc := range tests {",
          "4651:   t.Run(tc.note, func(t *testing.T) {",
          "4652:    c := NewCompiler().WithBuiltins(map[string]*Builtin{",
          "4653:     \"bar\": {",
          "4654:      Name: \"bar\",",
          "4655:      Decl: types.NewFunction([]types.Type{types.S}, types.A),",
          "4656:     },",
          "4657:     \"foo.bar\": {",
          "4658:      Name: \"foo.bar\",",
          "4659:      Decl: types.NewFunction([]types.Type{types.S}, types.A),",
          "4660:     },",
          "4661:    })",
          "4662:    if tc.extra != \"\" {",
          "4663:     c.Modules[\"extra\"] = MustParseModule(tc.extra)",
          "4664:    }",
          "4665:    c.Modules[\"test\"] = MustParseModule(tc.module)",
          "4669:    c.Compile(c.Modules)",
          "4671:    if tc.err != \"\" {",
          "4672:     if !strings.Contains(c.Errors.Error(), tc.err) {",
          "4673:      t.Errorf(\"expected error to contain %q, got %q\", tc.err, c.Errors.Error())",
          "4674:     }",
          "4675:    } else if len(c.Errors) > 0 {",
          "4676:     t.Errorf(\"expected no errors, got %v\", c.Errors)",
          "4677:    }",
          "4678:   })",
          "4679:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6167:    q:        \"x = 1 with foo.p as null\",",
          "6168:    pkg:      \"\",",
          "6169:    imports:  nil,",
          "6171:   },",
          "6172:   {",
          "6173:    note:     \"rewrite with value\",",
          "",
          "[Removed Lines]",
          "6170:    expected: fmt.Errorf(\"1 error occurred: 1:12: rego_type_error: with keyword target must reference existing input or data\"),",
          "",
          "[Added Lines]",
          "6418:    expected: fmt.Errorf(\"1 error occurred: 1:12: rego_type_error: with keyword target must reference existing input, data, or a built-in function\"),",
          "",
          "---------------"
        ],
        "ast/parser.go||ast/parser.go": [
          "File: ast/parser.go -> ast/parser.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "865:    return nil",
          "866:   }",
          "869:    return nil",
          "870:   }",
          "",
          "[Removed Lines]",
          "868:   if with.Target = p.parseTerm(); with.Target == nil {",
          "",
          "[Added Lines]",
          "868:   with.Target = p.parseTerm()",
          "869:   if with.Target == nil {",
          "",
          "---------------"
        ],
        "ast/visit.go||ast/visit.go": [
          "File: ast/visit.go -> ast/visit.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "608:     vis.Walk(v[i])",
          "609:    }",
          "610:    return true",
          "611:   }",
          "612:  }",
          "613:  if v, ok := v.(Var); ok {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "611:   case *With:",
          "612:    if ref, ok := v.Target.Value.(Ref); ok {",
          "613:     for _, t := range ref[1:] {",
          "614:      vis.Walk(t)",
          "615:     }",
          "616:    }",
          "617:    if ref, ok := v.Value.Value.(Ref); ok {",
          "618:     for _, t := range ref[1:] {",
          "619:      vis.Walk(t)",
          "620:     }",
          "621:    } else {",
          "622:     vis.Walk(v.Value)",
          "623:    }",
          "624:    return true",
          "",
          "---------------"
        ],
        "format/testfiles/test_with.rego||format/testfiles/test_with.rego": [
          "File: format/testfiles/test_with.rego -> format/testfiles/test_with.rego",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:                     2,",
          "16:                     3]",
          "17: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: mock_f(_) = 123",
          "21: func_replacements {",
          "22:     count(array.concat(input.x, [])) with input.x as \"foo\"",
          "23:     with array.concat as true",
          "24:     with count as mock_f",
          "25: }",
          "",
          "---------------"
        ],
        "format/testfiles/test_with.rego.formatted||format/testfiles/test_with.rego.formatted": [
          "File: format/testfiles/test_with.rego.formatted -> format/testfiles/test_with.rego.formatted",
          "--- Hunk 1 ---",
          "[Context before]",
          "14:    3,",
          "15:   ]",
          "16: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: mock_f(_) = 123",
          "20: func_replacements {",
          "21:  count(array.concat(input.x, [])) with input.x as \"foo\"",
          "22:   with array.concat as true",
          "23:   with count as mock_f",
          "24: }",
          "",
          "---------------"
        ],
        "internal/planner/planner.go||internal/planner/planner.go": [
          "File: internal/planner/planner.go -> internal/planner/planner.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "36:  externs map[string]*ast.Builtin // built-in functions that are required in execution environment",
          "37:  decls   map[string]*ast.Builtin // built-in functions that may be provided in execution environment",
          "38:  rules   *ruletrie               // rules that may be planned",
          "39:  funcs   *funcstack              // functions that have been planned",
          "40:  plan    *ir.Plan                // in-progress query plan",
          "41:  curr    *ir.Block               // in-progress query block",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39:  mocks   *functionMocksStack     // replacements for built-in functions",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76:   }),",
          "77:   rules: newRuletrie(),",
          "78:   funcs: newFuncstack(),",
          "79:   debug: debug.Discard(),",
          "80:  }",
          "81: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "80:   mocks: newFunctionMocksStack(),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "552: func (p *Planner) planWith(e *ast.Expr, iter planiter) error {",
          "560:  }",
          "562:  return p.planTermSlice(values, func(locals []ir.Operand) error {",
          "565:   saveVars := ast.NewVarSet()",
          "566:   dataRefs := []ast.Ref{}",
          "571:    paths[i] = make([]int, len(target)-1)",
          "573:    for j := 1; j < len(target); j++ {",
          "",
          "[Removed Lines]",
          "556:  values := make([]*ast.Term, len(e.With))",
          "558:  for i := range e.With {",
          "559:   values[i] = e.With[i].Value",
          "564:   paths := make([][]int, len(e.With))",
          "568:   for i := range e.With {",
          "570:    target := e.With[i].Target.Value.(ast.Ref)",
          "",
          "[Added Lines]",
          "558:  values := make([]*ast.Term, 0, len(e.With)) // NOTE(sr): we could be overallocating if there are builtin replacements",
          "559:  targets := make([]ast.Ref, 0, len(e.With))",
          "561:  builtins := frame{}",
          "563:  for _, w := range e.With {",
          "564:   switch v := w.Target.Value.(type) {",
          "565:   case ast.Ref:",
          "566:    if ast.DefaultRootDocument.Equal(v[0]) ||",
          "567:     ast.InputRootDocument.Equal(v[0]) {",
          "569:     values = append(values, w.Value)",
          "570:     targets = append(targets, w.Target.Value.(ast.Ref))",
          "571:     continue",
          "572:    }",
          "573:   }",
          "576:   builtins[w.Target.String()] = w.Value",
          "581:   p.mocks.PushFrame(builtins)",
          "583:   paths := make([][]int, len(targets))",
          "587:   for i, target := range targets {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "608:   }",
          "610:   err := p.planWithRec(e, paths, locals, 0, func() error {",
          "611:    if shadowing {",
          "612:     p.funcs.Pop()",
          "613:     for i := len(dataRefs) - 1; i >= 0; i-- {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "628:    p.mocks.PopFrame()",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "620:     err := iter()",
          "622:     if shadowing {",
          "623:      p.funcs.Push(map[string]string{})",
          "624:      for _, ref := range dataRefs {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "640:     p.mocks.PushFrame(builtins)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "631:    return err",
          "632:   })",
          "634:   if shadowing {",
          "635:    p.funcs.Pop()",
          "636:    for i := len(dataRefs) - 1; i >= 0; i-- {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "653:   p.mocks.PopFrame()",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "643: }",
          "645: func (p *Planner) planWithRec(e *ast.Expr, targets [][]int, values []ir.Operand, index int, iter planiter) error {",
          "647:   return p.planExpr(e.NoWith(), iter)",
          "648:  }",
          "",
          "[Removed Lines]",
          "646:  if index >= len(e.With) {",
          "",
          "[Added Lines]",
          "666:  if index >= len(targets) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "797:   var arity int",
          "798:   var void bool",
          "799:   var args []ir.Operand",
          "805:    name, err = p.planRules(node.Rules())",
          "806:    if err != nil {",
          "807:     return err",
          "808:    }",
          "809:    arity = node.Arity()",
          "814:   } else if decl, ok := p.decls[operator]; ok {",
          "815:    relation = decl.Relation",
          "816:    arity = len(decl.Decl.Args())",
          "",
          "[Removed Lines]",
          "801:   node := p.rules.Lookup(e.Operator())",
          "803:   if node != nil {",
          "804:    var err error",
          "810:    args = []ir.Operand{",
          "811:     p.vars.GetOpOrEmpty(ast.InputRootDocument.Value.(ast.Var)),",
          "812:     p.vars.GetOpOrEmpty(ast.DefaultRootDocument.Value.(ast.Var)),",
          "813:    }",
          "",
          "[Added Lines]",
          "820:   var err error",
          "822:   operands := e.Operands()",
          "823:   op := e.Operator()",
          "825:   if replacement := p.mocks.Lookup(operator); replacement != nil {",
          "826:    switch r := replacement.Value.(type) {",
          "827:    case ast.Ref:",
          "828:     if !r.HasPrefix(ast.DefaultRootRef) && !r.HasPrefix(ast.InputRootRef) {",
          "830:      operator = r.String()",
          "831:      decl := p.decls[operator]",
          "832:      p.externs[operator] = decl",
          "835:      return p.planExprCallFunc(operator, len(decl.Decl.Args()), void, operands, args, iter)",
          "836:     }",
          "839:     if node := p.rules.Lookup(r); node != nil {",
          "840:      p.mocks.Push() // new scope",
          "841:      name, err = p.planRules(node.Rules())",
          "842:      if err != nil {",
          "843:       return err",
          "844:      }",
          "845:      p.mocks.Pop()",
          "846:      return p.planExprCallFunc(name, node.Arity(), void, operands, p.defaultOperands(), iter)",
          "847:     }",
          "849:     return fmt.Errorf(\"illegal replacement of operator %q by %v\", operator, replacement)",
          "851:    default: // target is a builtin, replacement a value",
          "852:     return p.planExprCallValue(replacement, len(p.decls[operator].Decl.Args()), operands, iter)",
          "853:    }",
          "854:   }",
          "856:   if node := p.rules.Lookup(op); node != nil {",
          "862:    args = p.defaultOperands()",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "821:    return fmt.Errorf(\"illegal call: unknown operator %q\", operator)",
          "822:   }",
          "826:   if len(operands) < arity || len(operands) > arity+1 {",
          "827:    return fmt.Errorf(\"illegal call: wrong number of operands: got %v, want %v)\", len(operands), arity)",
          "828:   }",
          "",
          "[Removed Lines]",
          "824:   operands := e.Operands()",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "924:  })",
          "925: }",
          "927: func (p *Planner) planCallArgs(terms []*ast.Term, idx int, args []ir.Operand, iter func([]ir.Operand) error) error {",
          "928:  if idx >= len(terms) {",
          "929:   return iter(args)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "974: func (p *Planner) planExprCallValue(value *ast.Term, arity int, operands []*ast.Term, iter planiter) error {",
          "975:  if len(operands) == arity { // call: f(x) # result not captured",
          "976:   return p.planCallArgs(operands, 0, nil, func([]ir.Operand) error {",
          "977:    p.ltarget = p.newOperand()",
          "978:    return p.planTerm(value, func() error {",
          "979:     p.appendStmt(&ir.NotEqualStmt{",
          "980:      A: p.ltarget,",
          "981:      B: op(ir.Bool(false)),",
          "982:     })",
          "983:     return iter()",
          "984:    })",
          "985:   })",
          "986:  }",
          "989:  return p.planCallArgs(operands[:len(operands)-1], 0, nil, func([]ir.Operand) error {",
          "990:   p.ltarget = p.newOperand()",
          "991:   return p.planTerm(value, func() error {",
          "992:    return p.planUnifyLocal(p.ltarget, operands[len(operands)-1], iter)",
          "993:   })",
          "994:  })",
          "995: }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1639:    }",
          "1641:    p.appendStmt(&ir.CallStmt{",
          "1647:     Result: p.ltarget.Value.(ir.Local),",
          "1648:    })",
          "",
          "[Removed Lines]",
          "1642:     Func: funcName,",
          "1643:     Args: []ir.Operand{",
          "1644:      p.vars.GetOpOrEmpty(ast.InputRootDocument.Value.(ast.Var)),",
          "1645:      p.vars.GetOpOrEmpty(ast.DefaultRootDocument.Value.(ast.Var)),",
          "1646:     },",
          "",
          "[Added Lines]",
          "1712:     Func:   funcName,",
          "1713:     Args:   p.defaultOperands(),",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1801:    b := &ir.Block{}",
          "1802:    p.appendStmtToBlock(&ir.CallStmt{",
          "1808:     Result: lvalue,",
          "1809:    }, b)",
          "1810:    p.appendStmtToBlock(&ir.ObjectInsertStmt{",
          "",
          "[Removed Lines]",
          "1803:     Func: funcName,",
          "1804:     Args: []ir.Operand{",
          "1805:      p.vars.GetOpOrEmpty(ast.InputRootDocument.Value.(ast.Var)),",
          "1806:      p.vars.GetOpOrEmpty(ast.DefaultRootDocument.Value.(ast.Var)),",
          "1807:     },",
          "",
          "[Added Lines]",
          "1870:     Func:   funcName,",
          "1871:     Args:   p.defaultOperands(),",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2193:  return unseen",
          "2194: }",
          "2196: func op(v ir.Val) ir.Operand {",
          "2197:  return ir.Operand{Value: v}",
          "2198: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2260: func (p *Planner) defaultOperands() []ir.Operand {",
          "2261:  return []ir.Operand{",
          "2262:   p.vars.GetOpOrEmpty(ast.InputRootDocument.Value.(ast.Var)),",
          "2263:   p.vars.GetOpOrEmpty(ast.DefaultRootDocument.Value.(ast.Var)),",
          "2264:  }",
          "2265: }",
          "",
          "---------------"
        ],
        "internal/planner/rules.go||internal/planner/rules.go": [
          "File: internal/planner/rules.go -> internal/planner/rules.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "166:  }",
          "167:  return nodes[len(nodes)-1]",
          "168: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "170: type functionMocksStack struct {",
          "171:  stack []*functionMocksElem",
          "172: }",
          "174: type functionMocksElem []frame",
          "176: type frame map[string]*ast.Term",
          "178: func newFunctionMocksStack() *functionMocksStack {",
          "179:  stack := &functionMocksStack{}",
          "180:  stack.Push()",
          "181:  return stack",
          "182: }",
          "184: func newFunctionMocksElem() *functionMocksElem {",
          "185:  return &functionMocksElem{}",
          "186: }",
          "188: func (s *functionMocksStack) Push() {",
          "189:  s.stack = append(s.stack, newFunctionMocksElem())",
          "190: }",
          "192: func (s *functionMocksStack) Pop() {",
          "193:  s.stack = s.stack[:len(s.stack)-1]",
          "194: }",
          "196: func (s *functionMocksStack) PushFrame(f frame) {",
          "197:  current := s.stack[len(s.stack)-1]",
          "199: }",
          "201: func (s *functionMocksStack) PopFrame() {",
          "202:  current := s.stack[len(s.stack)-1]",
          "204: }",
          "206: func (s *functionMocksStack) Lookup(builtinName string) *ast.Term {",
          "207:  current := *s.stack[len(s.stack)-1]",
          "208:  for i := len(current) - 1; i >= 0; i-- {",
          "209:   if t, ok := current[i][builtinName]; ok {",
          "210:    return t",
          "211:   }",
          "212:  }",
          "213:  return nil",
          "214: }",
          "",
          "---------------"
        ],
        "topdown/cache.go||topdown/cache.go": [
          "File: topdown/cache.go -> topdown/cache.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "235:   return x.(*ast.Term).Hash()",
          "236:  })",
          "237: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "239: type functionMocksStack struct {",
          "240:  stack []*functionMocksElem",
          "241: }",
          "243: type functionMocksElem []frame",
          "245: type frame map[string]*ast.Term",
          "247: func newFunctionMocksStack() *functionMocksStack {",
          "248:  stack := &functionMocksStack{}",
          "249:  stack.Push()",
          "250:  return stack",
          "251: }",
          "253: func newFunctionMocksElem() *functionMocksElem {",
          "254:  return &functionMocksElem{}",
          "255: }",
          "257: func (s *functionMocksStack) Push() {",
          "258:  s.stack = append(s.stack, newFunctionMocksElem())",
          "259: }",
          "261: func (s *functionMocksStack) Pop() {",
          "262:  s.stack = s.stack[:len(s.stack)-1]",
          "263: }",
          "265: func (s *functionMocksStack) PopPairs() {",
          "266:  current := s.stack[len(s.stack)-1]",
          "268: }",
          "270: func (s *functionMocksStack) PutPairs(mocks [][2]*ast.Term) {",
          "271:  el := frame{}",
          "272:  for i := range mocks {",
          "273:   el[mocks[i][0].Value.String()] = mocks[i][1]",
          "274:  }",
          "275:  s.Put(el)",
          "276: }",
          "278: func (s *functionMocksStack) Put(el frame) {",
          "279:  current := s.stack[len(s.stack)-1]",
          "281: }",
          "283: func (s *functionMocksStack) Get(builtinName string) (*ast.Term, bool) {",
          "284:  current := *s.stack[len(s.stack)-1]",
          "285:  for i := len(current) - 1; i >= 0; i-- {",
          "286:   if r, ok := current[i][builtinName]; ok {",
          "287:    return r, true",
          "288:   }",
          "289:  }",
          "290:  return nil, false",
          "291: }",
          "",
          "---------------"
        ],
        "topdown/eval.go||topdown/eval.go": [
          "File: topdown/eval.go -> topdown/eval.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "77:  instr                  *Instrumentation",
          "78:  builtins               map[string]*Builtin",
          "79:  builtinCache           builtins.Cache",
          "80:  virtualCache           *virtualCache",
          "81:  comprehensionCache     *comprehensionCache",
          "82:  interQueryBuiltinCache cache.InterQueryCache",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "80:  functionMocks          *functionMocksStack",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "446: func (e *eval) evalWith(iter evalIterator) error {",
          "448:  expr := e.query[e.index]",
          "449:  var disable []ast.Ref",
          "451:  if e.partial() {",
          "457:   for _, with := range expr.With {",
          "458:    if e.saveSet.ContainsRecursive(with.Value, e.bindings) {",
          "459:     return e.saveExprMarkUnknowns(expr, e.bindings, func() error {",
          "460:      return e.next(iter)",
          "461:     })",
          "462:    }",
          "463:   }",
          "472:  }",
          "474:  pairsInput := [][2]*ast.Term{}",
          "475:  pairsData := [][2]*ast.Term{}",
          "476:  targets := []ast.Ref{}",
          "478:  for i := range expr.With {",
          "479:   plugged := e.bindings.Plug(expr.With[i].Value)",
          "481:    pairsInput = append(pairsInput, [...]*ast.Term{expr.With[i].Target, plugged})",
          "483:    pairsData = append(pairsData, [...]*ast.Term{expr.With[i].Target, plugged})",
          "484:   }",
          "486:  }",
          "488:  input, err := mergeTermWithValues(e.input, pairsInput)",
          "",
          "[Removed Lines]",
          "468:   ast.WalkRefs(expr, func(x ast.Ref) bool {",
          "469:    disable = append(disable, x.GroundPrefix())",
          "470:    return false",
          "471:   })",
          "480:   if isInputRef(expr.With[i].Target) {",
          "482:   } else if isDataRef(expr.With[i].Target) {",
          "485:   targets = append(targets, expr.With[i].Target.Value.(ast.Ref))",
          "",
          "[Added Lines]",
          "455:  disableRef := func(x ast.Ref) bool {",
          "456:   disable = append(disable, x.GroundPrefix())",
          "457:   return false",
          "458:  }",
          "467:    if isOtherRef(with.Target) {",
          "469:     _ = disableRef(with.Value.Value.(ast.Ref))",
          "470:     continue",
          "471:    }",
          "480:    ast.WalkRefs(with.Target, disableRef)",
          "481:    ast.WalkRefs(with.Value, disableRef)",
          "484:   ast.WalkRefs(expr.NoWith(), disableRef)",
          "489:  functionMocks := [][2]*ast.Term{}",
          "493:   target := expr.With[i].Target.Value",
          "495:   switch {",
          "496:   case isInputRef(expr.With[i].Target):",
          "498:   case isDataRef(expr.With[i].Target):",
          "500:   default: // target must be builtin",
          "501:    _, _, ok := e.builtinFunc(target.String())",
          "502:    if ok {",
          "503:     functionMocks = append(functionMocks, [...]*ast.Term{expr.With[i].Target, plugged})",
          "504:    }",
          "505:    continue",
          "507:   targets = append(targets, target.(ast.Ref))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "503:   }",
          "504:  }",
          "508:  err = e.evalStep(func(e *eval) error {",
          "509:   e.evalWithPop(oldInput, oldData)",
          "510:   err := e.next(iter)",
          "512:   return err",
          "513:  })",
          "",
          "[Removed Lines]",
          "506:  oldInput, oldData := e.evalWithPush(input, data, targets, disable)",
          "511:   oldInput, oldData = e.evalWithPush(input, data, targets, disable)",
          "",
          "[Added Lines]",
          "528:  oldInput, oldData := e.evalWithPush(input, data, functionMocks, targets, disable)",
          "533:   oldInput, oldData = e.evalWithPush(input, data, functionMocks, targets, disable)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "517:  return err",
          "518: }",
          "521:  var oldInput *ast.Term",
          "523:  if input != nil {",
          "",
          "[Removed Lines]",
          "520: func (e *eval) evalWithPush(input, data *ast.Term, targets, disable []ast.Ref) (*ast.Term, *ast.Term) {",
          "",
          "[Added Lines]",
          "542: func (e *eval) evalWithPush(input, data *ast.Term, functionMocks [][2]*ast.Term, targets, disable []ast.Ref) (*ast.Term, *ast.Term) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "536:  e.virtualCache.Push()",
          "537:  e.targetStack.Push(targets)",
          "538:  e.inliningControl.PushDisable(disable, true)",
          "540:  return oldInput, oldData",
          "541: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "561:  e.functionMocks.PutPairs(functionMocks)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "545:  e.targetStack.Pop()",
          "546:  e.virtualCache.Pop()",
          "547:  e.comprehensionCache.Pop()",
          "548:  e.data = data",
          "549:  e.input = input",
          "550: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "571:  e.functionMocks.PopPairs()",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "704:   return eval.eval(iter)",
          "705:  }",
          "708:  if !ok {",
          "709:   return unsupportedBuiltinErr(e.query[e.index].Location)",
          "710:  }",
          "712:  if e.unknown(e.query[e.index], e.bindings) {",
          "713:   return e.saveCall(len(bi.Decl.Args()), terms, iter)",
          "714:  }",
          "",
          "[Removed Lines]",
          "707:  bi, f, ok := e.builtinFunc(ref.String())",
          "",
          "[Added Lines]",
          "731:  builtinName := ref.String()",
          "732:  bi, f, ok := e.builtinFunc(builtinName)",
          "737:  if mock, ok := e.functionMocks.Get(builtinName); ok {",
          "738:   switch m := mock.Value.(type) {",
          "739:   case ast.Ref: // builtin or data function",
          "740:    mockCall := append([]*ast.Term{ast.NewTerm(m)}, terms[1:]...)",
          "742:    e.functionMocks.Push()",
          "743:    err := e.evalCall(mockCall, func() error {",
          "744:     e.functionMocks.Pop()",
          "745:     err := iter()",
          "746:     e.functionMocks.Push()",
          "747:     return err",
          "748:    })",
          "749:    e.functionMocks.Pop()",
          "750:    return err",
          "752:   default: // value replacement",
          "753:    switch {",
          "754:    case len(terms) == len(bi.Decl.Args())+2: // captured var",
          "755:     return e.unify(terms[len(terms)-1], mock, iter)",
          "757:    case len(terms) == len(bi.Decl.Args())+1:",
          "758:     if mock.Value.Compare(ast.Boolean(false)) != 0 {",
          "759:      return iter()",
          "760:     }",
          "761:     return nil",
          "762:    }",
          "763:   }",
          "764:  }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1215: }",
          "1217: func (e *eval) saveExpr(expr *ast.Expr, b *bindings, iter unifyIterator) error {",
          "1220:  e.saveStack.Push(expr, b, b)",
          "1221:  e.traceSave(expr)",
          "1222:  err := iter()",
          "",
          "[Removed Lines]",
          "1218:  expr.With = e.query[e.index].With",
          "1219:  expr.Location = e.query[e.index].Location",
          "",
          "[Added Lines]",
          "1272:  e.updateFromQuery(expr)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1225: }",
          "1227: func (e *eval) saveExprMarkUnknowns(expr *ast.Expr, b *bindings, iter unifyIterator) error {",
          "1230:  declArgsLen, err := e.getDeclArgsLen(expr)",
          "1231:  if err != nil {",
          "1232:   return err",
          "",
          "[Removed Lines]",
          "1228:  expr.With = e.query[e.index].With",
          "1229:  expr.Location = e.query[e.index].Location",
          "",
          "[Added Lines]",
          "1281:  e.updateFromQuery(expr)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1251: func (e *eval) saveUnify(a, b *ast.Term, b1, b2 *bindings, iter unifyIterator) error {",
          "1252:  e.instr.startTimer(partialOpSaveUnify)",
          "1253:  expr := ast.Equality.Expr(a, b)",
          "1256:  pops := 0",
          "1257:  if pairs := getSavePairsFromTerm(a, b1, nil); len(pairs) > 0 {",
          "1258:   pops += len(pairs)",
          "",
          "[Removed Lines]",
          "1254:  expr.With = e.query[e.index].With",
          "1255:  expr.Location = e.query[e.index].Location",
          "",
          "[Added Lines]",
          "1306:  e.updateFromQuery(expr)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1283: func (e *eval) saveCall(declArgsLen int, terms []*ast.Term, iter unifyIterator) error {",
          "1284:  expr := ast.NewExpr(terms)",
          "",
          "[Removed Lines]",
          "1285:  expr.With = e.query[e.index].With",
          "1286:  expr.Location = e.query[e.index].Location",
          "",
          "[Added Lines]",
          "1336:  e.updateFromQuery(expr)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1318:  }",
          "1320:  for _, expr := range exprs {",
          "1322:   e.saveStack.Push(expr, nil, nil)",
          "1323:   e.traceSave(expr)",
          "1324:  }",
          "",
          "[Removed Lines]",
          "1321:   expr.With = with",
          "",
          "[Added Lines]",
          "1371:   expr.With = e.updateSavedMocks(with)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1583:  return len(ir.Rules[0].Head.Args), nil",
          "1584: }",
          "1586: type evalBuiltin struct {",
          "1587:  e     *eval",
          "1588:  bi    *ast.Builtin",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1640: func (e *eval) updateFromQuery(expr *ast.Expr) {",
          "1641:  expr.With = e.updateSavedMocks(e.query[e.index].With)",
          "1642:  expr.Location = e.query[e.index].Location",
          "1643: }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3187:  return false",
          "3188: }",
          "3190: func merge(a, b ast.Value) (ast.Value, bool) {",
          "3191:  aObj, ok1 := a.(ast.Object)",
          "3192:  bObj, ok2 := b.(ast.Object)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3249: func isOtherRef(term *ast.Term) bool {",
          "3250:  ref, ok := term.Value.(ast.Ref)",
          "3251:  if !ok {",
          "3252:   panic(\"unreachable\")",
          "3253:  }",
          "3254:  return !ref.HasPrefix(ast.DefaultRootRef) && !ref.HasPrefix(ast.InputRootRef)",
          "3255: }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3252:  }",
          "3253:  return ee.prev // nil if we're done",
          "3254: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3323: func (e *eval) updateSavedMocks(withs []*ast.With) []*ast.With {",
          "3324:  ret := make([]*ast.With, 0, len(withs))",
          "3325:  for _, w := range withs {",
          "3326:   v := w.Copy()",
          "3327:   if isOtherRef(w.Target) {",
          "3328:    ref := v.Value.Value.(ast.Ref)",
          "3329:    nref := e.namespaceRef(ref)",
          "3330:    if e.saveSupport.Exists(nref) {",
          "3331:     v.Value.Value = nref",
          "3332:    } else {",
          "3333:     continue // skip",
          "3334:    }",
          "3335:   }",
          "3336:   ret = append(ret, v)",
          "3337:  }",
          "3338:  return ret",
          "3339: }",
          "",
          "---------------"
        ],
        "topdown/query.go||topdown/query.go": [
          "File: topdown/query.go -> topdown/query.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "311:   instr:                  q.instr,",
          "312:   builtins:               q.builtins,",
          "313:   builtinCache:           builtins.Cache{},",
          "314:   interQueryBuiltinCache: q.interQueryBuiltinCache,",
          "315:   virtualCache:           newVirtualCache(),",
          "316:   comprehensionCache:     newComprehensionCache(),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "314:   functionMocks:          newFunctionMocksStack(),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "451:   instr:                  q.instr,",
          "452:   builtins:               q.builtins,",
          "453:   builtinCache:           builtins.Cache{},",
          "454:   interQueryBuiltinCache: q.interQueryBuiltinCache,",
          "455:   virtualCache:           newVirtualCache(),",
          "456:   comprehensionCache:     newComprehensionCache(),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "455:   functionMocks:          newFunctionMocksStack(),",
          "",
          "---------------"
        ],
        "topdown/save.go||topdown/save.go": [
          "File: topdown/save.go -> topdown/save.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "279: }",
          "281: func (s *saveSupport) List() []*ast.Module {",
          "283:  for _, module := range s.modules {",
          "284:   result = append(result, module)",
          "285:  }",
          "",
          "[Removed Lines]",
          "282:  result := []*ast.Module{}",
          "",
          "[Added Lines]",
          "282:  result := make([]*ast.Module, 0, len(s.modules))",
          "",
          "---------------"
        ],
        "topdown/topdown_partial_test.go||topdown/topdown_partial_test.go": [
          "File: topdown/topdown_partial_test.go -> topdown/topdown_partial_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "759:    },",
          "760:    wantQueries: []string{`{} = a`},",
          "761:   },",
          "762:   {",
          "763:    note:  \"save: sub path\",",
          "764:    query: \"input.x = 1; input.y = 2; input.z.a = 3; input.z.b = x\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "762:   {",
          "763:    note:  \"with+builtin: no unknowns\",",
          "764:    query: \"data.test.p = a\",",
          "765:    modules: []string{",
          "766:     `package test",
          "768:     mock_concat(_, _) = \"foo/bar\"",
          "769:     p { q with concat as mock_concat}",
          "770:     q { concat(\"/\", [\"a\", \"b\"], \"foo/bar\") }`,",
          "771:    },",
          "772:    wantQueries: []string{`a = true`},",
          "773:   },",
          "774:   {",
          "775:    note:  \"with+builtin: unknowns in replacement function\",",
          "776:    query: \"data.test.p = a\",",
          "777:    modules: []string{",
          "778:     `package test",
          "780:     mock_concat(x, _) = concat(x, input)",
          "781:     p { q with concat as mock_concat}",
          "782:     q { concat(\"/\", [\"a\", \"b\"], \"foo/bar\") }`,",
          "783:    },",
          "784:    wantQueries: []string{`data.partial.test.mock_concat(\"/\", [\"a\", \"b\"], \"foo/bar\"); a = true`},",
          "785:    wantSupport: []string{",
          "786:     `package partial.test",
          "788:     mock_concat(__local0__3, __local1__3) = __local2__3 {",
          "789:      __local3__3 = input",
          "790:      concat(__local0__3, __local3__3, __local2__3)",
          "791:     }`,",
          "792:    },",
          "793:   },",
          "794:   {",
          "795:    note:  \"with+builtin: unknowns in replaced function's args\",",
          "796:    query: \"data.test.p = a\",",
          "797:    modules: []string{",
          "798:     `package test",
          "800:     mock_concat(_, _) = [\"foo\", \"bar\"]",
          "801:     p {",
          "802:      q with array.concat as mock_concat",
          "803:     }",
          "804:     q {",
          "805:      array.concat([\"foo\"], input, [\"foo\", \"bar\"])",
          "806:     }`,",
          "807:    },",
          "808:    wantQueries: []string{`",
          "809:     data.partial.test.q = x_term_1_01 with array.concat as data.partial.test.mock_concat",
          "810:     x_term_1_01 with array.concat as data.partial.test.mock_concat",
          "811:     a = true",
          "812:    `},",
          "813:    wantSupport: []string{`package partial.test",
          "815:     q {",
          "816:      data.partial.test.mock_concat([\"foo\"], input, [\"foo\", \"bar\"])",
          "817:     }",
          "818:     mock_concat(__local0__3, __local1__3) = [\"foo\", \"bar\"]",
          "819:    `},",
          "820:   },",
          "821:   {",
          "822:    note:  \"with+builtin: unknowns in replacement function's bodies\",",
          "823:    query: \"data.test.p = a\",",
          "824:    modules: []string{",
          "825:     `package test",
          "827:     mock_concat(_, _) = [\"foo\", \"bar\"] { input.foo }",
          "828:     mock_concat(_, _) = [\"bar\", \"baz\"] { input.bar }",
          "830:     p { q with array.concat as mock_concat }",
          "831:     q { x := array.concat([\"foo\"], input) }`,",
          "832:    },",
          "833:    wantQueries: []string{`",
          "834:     data.partial.test.q = x_term_1_01 with array.concat as data.partial.test.mock_concat",
          "835:     x_term_1_01 with array.concat as data.partial.test.mock_concat",
          "836:     a = true",
          "837:    `},",
          "838:    wantSupport: []string{`package partial.test",
          "840:    q {",
          "841:     __local6__2 = input",
          "842:     data.partial.test.mock_concat([\"foo\"], __local6__2, __local5__2)",
          "843:     __local4__2 = __local5__2",
          "844:    }",
          "845:    mock_concat(__local0__3, __local1__3) = [\"foo\", \"bar\"] {",
          "846:     input.foo = x_term_3_03",
          "847:     x_term_3_03",
          "848:    }",
          "849:    mock_concat(__local2__4, __local3__4) = [\"bar\", \"baz\"] {",
          "850:     input.bar = x_term_4_04",
          "851:     x_term_4_04",
          "852:    }`},",
          "853:   },",
          "854:   {",
          "855:    note:  \"with+builtin+negation: when replacement has no unknowns (args, defs), save negated expr without replacement\",",
          "856:    query: \"data.test.p = true\",",
          "857:    modules: []string{`",
          "858:     package test",
          "860:     mock_count(_) = 100",
          "861:     p {",
          "862:      not q with input.x as 1 with count as mock_count",
          "863:     }",
          "865:     q {",
          "866:      count([1,2,3]) = input.x",
          "867:     }",
          "868:    `},",
          "869:    wantQueries: []string{\"not data.partial.test.q with input.x as 1\"},",
          "870:    wantSupport: []string{`",
          "871:     package partial.test",
          "873:     q { 100 = input.x }",
          "874:    `},",
          "875:   },",
          "876:   {",
          "877:    note:  \"with+builtin+negation: when replacement args have unknowns, save negated expr with replacement\",",
          "878:    query: \"data.test.p = true\",",
          "879:    modules: []string{`",
          "880:     package test",
          "882:     mock_count(_) = 100",
          "883:     p {",
          "884:      not q with input.x as 1 with count as mock_count",
          "885:     }",
          "887:     q {",
          "888:      count(input.y) = input.x # unknown arg for mocked func",
          "889:     }",
          "890:    `},",
          "891:    wantQueryASTs: func() []ast.Body {",
          "892:     b := ast.MustParseBody(\"not data.partial.test.q with input.x as 1 with count as data.partial.test.mock_count\")",
          "893:     b[0].With[1].Target.Value = ast.Ref([]*ast.Term{ast.VarTerm(\"count\")})",
          "894:     return []ast.Body{b}",
          "895:    }(),",
          "896:    wantSupport: []string{`",
          "897:     package partial.test",
          "899:     q { data.partial.test.mock_count(input.y, __local1__3); __local1__3 = input.x }",
          "900:     mock_count(__local0__4) = 100 { true }",
          "901:    `},",
          "902:   },",
          "903:   {",
          "904:    note:  \"with+builtin+negation: when replacement defs have unknowns, save negated expr with replacement\",",
          "905:    query: \"data.test.p = true\",",
          "906:    modules: []string{`",
          "907:     package test",
          "909:     mock_count(_) = 100 { input.y }",
          "910:     mock_count(_) = 101 { input.z }",
          "911:     p {",
          "912:      not q with input.x as 1 with count as mock_count",
          "913:     }",
          "915:     q {",
          "916:      count([1]) = input.x # unknown arg for mocked func",
          "917:     }",
          "918:    `},",
          "919:    wantQueryASTs: func() []ast.Body {",
          "920:     b := ast.MustParseBody(\"not data.partial.test.q with input.x as 1 with count as data.partial.test.mock_count\")",
          "921:     b[0].With[1].Target.Value = ast.Ref([]*ast.Term{ast.VarTerm(\"count\")})",
          "922:     return []ast.Body{b}",
          "923:    }(),",
          "924:    wantSupport: []string{`",
          "925:     package partial.test",
          "927:     q { data.partial.test.mock_count([1], __local2__3); __local2__3 = input.x }",
          "928:     mock_count(__local0__4) = 100 { input.y = x_term_4_04; x_term_4_04 }",
          "929:     mock_count(__local1__5) = 101 { input.z = x_term_5_05; x_term_5_05 }",
          "930:    `},",
          "931:   },",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-2513",
  "cve_desc": "The password hasher in contrib/auth/hashers.py in Django before 1.8.10 and 1.9.x before 1.9.3 allows remote attackers to enumerate users via a timing attack involving login requests.",
  "repo": "django/django",
  "patch_hash": "67b46ba7016da2d259c1ecc7d666d11f5e1cfaab",
  "patch_info": {
    "commit_hash": "67b46ba7016da2d259c1ecc7d666d11f5e1cfaab",
    "repo": "django/django",
    "commit_url": "https://github.com/django/django/commit/67b46ba7016da2d259c1ecc7d666d11f5e1cfaab",
    "files": [
      "django/contrib/auth/hashers.py",
      "docs/releases/1.8.10.txt",
      "docs/releases/1.9.3.txt",
      "docs/topics/auth/passwords.txt",
      "tests/auth_tests/test_hashers.py"
    ],
    "message": "Fixed CVE-2016-2513 -- Fixed user enumeration timing attack during login.\n\nThis is a security fix.",
    "before_after_code_files": [
      "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py",
      "tests/auth_tests/test_hashers.py||tests/auth_tests/test_hashers.py"
    ]
  },
  "patch_diff": {
    "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py": [
      "File: django/contrib/auth/hashers.py -> django/contrib/auth/hashers.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "4: import binascii",
      "5: import hashlib",
      "6: import importlib",
      "7: from collections import OrderedDict",
      "9: from django.conf import settings",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7: import warnings",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "46:     preferred = get_hasher(preferred)",
      "47:     hasher = identify_hasher(encoded)",
      "52:     is_correct = hasher.verify(password, encoded)",
      "53:     if setter and is_correct and must_update:",
      "54:         setter(password)",
      "55:     return is_correct",
      "",
      "[Removed Lines]",
      "49:     must_update = hasher.algorithm != preferred.algorithm",
      "50:     if not must_update:",
      "51:         must_update = preferred.must_update(encoded)",
      "",
      "[Added Lines]",
      "50:     hasher_changed = hasher.algorithm != preferred.algorithm",
      "51:     must_update = hasher_changed or preferred.must_update(encoded)",
      "54:     # If the hasher didn't change (we don't protect against enumeration if it",
      "55:     # does) and the password should get updated, try to close the timing gap",
      "56:     # between the work factor of the current encoded password and the default",
      "57:     # work factor.",
      "58:     if not is_correct and not hasher_changed and must_update:",
      "59:         hasher.harden_runtime(password, encoded)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "216:     def must_update(self, encoded):",
      "217:         return False",
      "220: class PBKDF2PasswordHasher(BasePasswordHasher):",
      "221:     \"\"\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "227:     def harden_runtime(self, password, encoded):",
      "228:         \"\"\"",
      "229:         Bridge the runtime gap between the work factor supplied in `encoded`",
      "230:         and the work factor suggested by this hasher.",
      "232:         Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and",
      "233:         `self.iterations` is 30000, this method should run password through",
      "234:         another 10000 iterations of PBKDF2. Similar approaches should exist",
      "235:         for any hasher that has a work factor. If not, this method should be",
      "236:         defined as a no-op to silence the warning.",
      "237:         \"\"\"",
      "238:         warnings.warn('subclasses of BasePasswordHasher should provide a harden_runtime() method')",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "258:         algorithm, iterations, salt, hash = encoded.split('$', 3)",
      "259:         return int(iterations) != self.iterations",
      "262: class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):",
      "263:     \"\"\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "282:     def harden_runtime(self, password, encoded):",
      "283:         algorithm, iterations, salt, hash = encoded.split('$', 3)",
      "284:         extra_iterations = self.iterations - int(iterations)",
      "285:         if extra_iterations > 0:",
      "286:             self.encode(password, salt, extra_iterations)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "305:     def verify(self, password, encoded):",
      "306:         algorithm, data = encoded.split('$', 1)",
      "307:         assert algorithm == self.algorithm",
      "326:     def safe_summary(self, encoded):",
      "327:         algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)",
      "",
      "[Removed Lines]",
      "308:         bcrypt = self._load_library()",
      "310:         # Hash the password prior to using bcrypt to prevent password",
      "311:         # truncation as described in #20138.",
      "312:         if self.digest is not None:",
      "313:             # Use binascii.hexlify() because a hex encoded bytestring is",
      "314:             # Unicode on Python 3.",
      "315:             password = binascii.hexlify(self.digest(force_bytes(password)).digest())",
      "316:         else:",
      "317:             password = force_bytes(password)",
      "319:         # Ensure that our data is a bytestring",
      "320:         data = force_bytes(data)",
      "321:         # force_bytes() necessary for py-bcrypt compatibility",
      "322:         hashpw = force_bytes(bcrypt.hashpw(password, data))",
      "324:         return constant_time_compare(data, hashpw)",
      "",
      "[Added Lines]",
      "335:         encoded_2 = self.encode(password, force_bytes(data))",
      "336:         return constant_time_compare(encoded, encoded_2)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "338:         algorithm, empty, algostr, rounds, data = encoded.split('$', 4)",
      "339:         return int(rounds) != self.rounds",
      "342: class BCryptPasswordHasher(BCryptSHA256PasswordHasher):",
      "343:     \"\"\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "353:     def harden_runtime(self, password, encoded):",
      "354:         _, data = encoded.split('$', 1)",
      "355:         salt = data[:29]  # Length of the salt in bcrypt.",
      "356:         rounds = data.split('$')[2]",
      "357:         # work factor is logarithmic, adding one doubles the load.",
      "358:         diff = 2**(self.rounds - int(rounds)) - 1",
      "359:         while diff > 0:",
      "360:             self.encode(password, force_bytes(salt))",
      "361:             diff -= 1",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "385:             (_('hash'), mask_hash(hash)),",
      "386:         ])",
      "389: class MD5PasswordHasher(BasePasswordHasher):",
      "390:     \"\"\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "410:     def harden_runtime(self, password, encoded):",
      "411:         pass",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "413:             (_('hash'), mask_hash(hash)),",
      "414:         ])",
      "417: class UnsaltedSHA1PasswordHasher(BasePasswordHasher):",
      "418:     \"\"\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "441:     def harden_runtime(self, password, encoded):",
      "442:         pass",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "445:             (_('hash'), mask_hash(hash)),",
      "446:         ])",
      "449: class UnsaltedMD5PasswordHasher(BasePasswordHasher):",
      "450:     \"\"\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "476:     def harden_runtime(self, password, encoded):",
      "477:         pass",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "478:             (_('hash'), mask_hash(encoded, show=3)),",
      "479:         ])",
      "482: class CryptPasswordHasher(BasePasswordHasher):",
      "483:     \"\"\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "512:     def harden_runtime(self, password, encoded):",
      "513:         pass",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "512:             (_('salt'), salt),",
      "513:             (_('hash'), mask_hash(data, show=3)),",
      "514:         ])",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "550:     def harden_runtime(self, password, encoded):",
      "551:         pass",
      "",
      "---------------"
    ],
    "tests/auth_tests/test_hashers.py||tests/auth_tests/test_hashers.py": [
      "File: tests/auth_tests/test_hashers.py -> tests/auth_tests/test_hashers.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "10:     check_password, get_hasher, identify_hasher, is_password_usable,",
      "11:     make_password,",
      "12: )",
      "14: from django.test.utils import override_settings",
      "15: from django.utils import six",
      "17: try:",
      "18:     import crypt",
      "",
      "[Removed Lines]",
      "13: from django.test import SimpleTestCase",
      "",
      "[Added Lines]",
      "13: from django.test import SimpleTestCase, mock",
      "16: from django.utils.encoding import force_bytes",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "214:         finally:",
      "215:             hasher.rounds = old_rounds",
      "217:     def test_unusable(self):",
      "218:         encoded = make_password(None)",
      "219:         self.assertEqual(len(encoded), len(UNUSABLE_PASSWORD_PREFIX) + UNUSABLE_PASSWORD_SUFFIX_LENGTH)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "218:     @skipUnless(bcrypt, \"bcrypt not installed\")",
      "219:     def test_bcrypt_harden_runtime(self):",
      "220:         hasher = get_hasher('bcrypt')",
      "221:         self.assertEqual('bcrypt', hasher.algorithm)",
      "223:         with mock.patch.object(hasher, 'rounds', 4):",
      "224:             encoded = make_password('letmein', hasher='bcrypt')",
      "226:         with mock.patch.object(hasher, 'rounds', 6), \\",
      "227:                 mock.patch.object(hasher, 'encode', side_effect=hasher.encode):",
      "228:             hasher.harden_runtime('wrong_password', encoded)",
      "230:             # Increasing rounds from 4 to 6 means an increase of 4 in workload,",
      "231:             # therefore hardening should run 3 times to make the timing the",
      "232:             # same (the original encode() call already ran once).",
      "233:             self.assertEqual(hasher.encode.call_count, 3)",
      "235:             # Get the original salt (includes the original workload factor)",
      "236:             algorithm, data = encoded.split('$', 1)",
      "237:             expected_call = (('wrong_password', force_bytes(data[:29])),)",
      "238:             self.assertEqual(hasher.encode.call_args_list, [expected_call] * 3)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "337:         finally:",
      "338:             hasher.iterations = old_iterations",
      "340:     def test_pbkdf2_upgrade_new_hasher(self):",
      "341:         hasher = get_hasher('default')",
      "342:         self.assertEqual('pbkdf2_sha256', hasher.algorithm)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "363:     def test_pbkdf2_harden_runtime(self):",
      "364:         hasher = get_hasher('default')",
      "365:         self.assertEqual('pbkdf2_sha256', hasher.algorithm)",
      "367:         with mock.patch.object(hasher, 'iterations', 1):",
      "368:             encoded = make_password('letmein')",
      "370:         with mock.patch.object(hasher, 'iterations', 6), \\",
      "371:                 mock.patch.object(hasher, 'encode', side_effect=hasher.encode):",
      "372:             hasher.harden_runtime('wrong_password', encoded)",
      "374:             # Encode should get called once ...",
      "375:             self.assertEqual(hasher.encode.call_count, 1)",
      "377:             # ... with the original salt and 5 iterations.",
      "378:             algorithm, iterations, salt, hash = encoded.split('$', 3)",
      "379:             expected_call = (('wrong_password', salt, 5),)",
      "380:             self.assertEqual(hasher.encode.call_args, expected_call)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "365:             self.assertTrue(check_password('letmein', encoded, setter))",
      "366:             self.assertTrue(state['upgraded'])",
      "368:     def test_load_library_no_algorithm(self):",
      "369:         with self.assertRaises(ValueError) as e:",
      "370:             BasePasswordHasher()._load_library()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "410:     def test_check_password_calls_harden_runtime(self):",
      "411:         hasher = get_hasher('default')",
      "412:         encoded = make_password('letmein')",
      "414:         with mock.patch.object(hasher, 'harden_runtime'), \\",
      "415:                 mock.patch.object(hasher, 'must_update', return_value=True):",
      "416:             # Correct password supplied, no hardening needed",
      "417:             check_password('letmein', encoded)",
      "418:             self.assertEqual(hasher.harden_runtime.call_count, 0)",
      "420:             # Wrong password supplied, hardening needed",
      "421:             check_password('wrong_password', encoded)",
      "422:             self.assertEqual(hasher.harden_runtime.call_count, 1)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f0ad641628a3ddc4e1c208e481b9cd0e9304dc3d",
      "candidate_info": {
        "commit_hash": "f0ad641628a3ddc4e1c208e481b9cd0e9304dc3d",
        "repo": "django/django",
        "commit_url": "https://github.com/django/django/commit/f0ad641628a3ddc4e1c208e481b9cd0e9304dc3d",
        "files": [
          "django/contrib/auth/hashers.py",
          "docs/releases/1.9.1.txt"
        ],
        "message": "Fixed #26016 -- Restored contrib.auth hashers compatibility with py-bcrypt.\n\nReverted \"Explicitly passed rounds as rounds to bcrypt.gensalt()\"\n\nThis reverts commit 23529fb19594ffcc6ba6d716356b828157200288.",
        "before_after_code_files": [
          "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py"
          ],
          "candidate": [
            "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py"
          ]
        }
      },
      "candidate_diff": {
        "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py": [
          "File: django/contrib/auth/hashers.py -> django/contrib/auth/hashers.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "287:     def salt(self):",
          "288:         bcrypt = self._load_library()",
          "291:     def encode(self, password, salt):",
          "292:         bcrypt = self._load_library()",
          "",
          "[Removed Lines]",
          "289:         return bcrypt.gensalt(rounds=self.rounds)",
          "",
          "[Added Lines]",
          "289:         return bcrypt.gensalt(self.rounds)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "23529fb19594ffcc6ba6d716356b828157200288",
      "candidate_info": {
        "commit_hash": "23529fb19594ffcc6ba6d716356b828157200288",
        "repo": "django/django",
        "commit_url": "https://github.com/django/django/commit/23529fb19594ffcc6ba6d716356b828157200288",
        "files": [
          "django/contrib/auth/hashers.py"
        ],
        "message": "Explicitly passed rounds as rounds to bcrypt.gensalt()",
        "before_after_code_files": [
          "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py"
          ],
          "candidate": [
            "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py"
          ]
        }
      },
      "candidate_diff": {
        "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py": [
          "File: django/contrib/auth/hashers.py -> django/contrib/auth/hashers.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "287:     def salt(self):",
          "288:         bcrypt = self._load_library()",
          "291:     def encode(self, password, salt):",
          "292:         bcrypt = self._load_library()",
          "",
          "[Removed Lines]",
          "289:         return bcrypt.gensalt(self.rounds)",
          "",
          "[Added Lines]",
          "289:         return bcrypt.gensalt(rounds=self.rounds)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "926d41f0e74cc7578d71cfe12a970c9309bddfbc",
      "candidate_info": {
        "commit_hash": "926d41f0e74cc7578d71cfe12a970c9309bddfbc",
        "repo": "django/django",
        "commit_url": "https://github.com/django/django/commit/926d41f0e74cc7578d71cfe12a970c9309bddfbc",
        "files": [
          "django/contrib/auth/hashers.py"
        ],
        "message": "Updated some comments for BCryptSHA256PasswordHasher.",
        "before_after_code_files": [
          "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py"
          ],
          "candidate": [
            "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py"
          ]
        }
      },
      "candidate_diff": {
        "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py": [
          "File: django/contrib/auth/hashers.py -> django/contrib/auth/hashers.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "291:     def encode(self, password, salt):",
          "292:         bcrypt = self._load_library()",
          "298:         if self.digest is not None:",
          "301:             password = binascii.hexlify(self.digest(force_bytes(password)).digest())",
          "302:         else:",
          "303:             password = force_bytes(password)",
          "",
          "[Removed Lines]",
          "293:         # Need to reevaluate the force_bytes call once bcrypt is supported on",
          "294:         # Python 3",
          "296:         # Hash the password prior to using bcrypt to prevent password truncation",
          "297:         #   See: https://code.djangoproject.com/ticket/20138",
          "299:             # We use binascii.hexlify here because Python3 decided that a hex encoded",
          "300:             #   bytestring is somehow a unicode.",
          "",
          "[Added Lines]",
          "293:         # Hash the password prior to using bcrypt to prevent password",
          "294:         # truncation as described in #20138.",
          "296:             # Use binascii.hexlify() because a hex encoded bytestring is",
          "297:             # Unicode on Python 3.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "310:         assert algorithm == self.algorithm",
          "311:         bcrypt = self._load_library()",
          "315:         if self.digest is not None:",
          "318:             password = binascii.hexlify(self.digest(force_bytes(password)).digest())",
          "319:         else:",
          "320:             password = force_bytes(password)",
          "",
          "[Removed Lines]",
          "313:         # Hash the password prior to using bcrypt to prevent password truncation",
          "314:         #   See: https://code.djangoproject.com/ticket/20138",
          "316:             # We use binascii.hexlify here because Python3 decided that a hex encoded",
          "317:             #   bytestring is somehow a unicode.",
          "",
          "[Added Lines]",
          "310:         # Hash the password prior to using bcrypt to prevent password",
          "311:         # truncation as described in #20138.",
          "313:             # Use binascii.hexlify() because a hex encoded bytestring is",
          "314:             # Unicode on Python 3.",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "af7d09b0c5c6ab68e629fd9baf736f9dd203b18e",
      "candidate_info": {
        "commit_hash": "af7d09b0c5c6ab68e629fd9baf736f9dd203b18e",
        "repo": "django/django",
        "commit_url": "https://github.com/django/django/commit/af7d09b0c5c6ab68e629fd9baf736f9dd203b18e",
        "files": [
          "django/contrib/auth/hashers.py",
          "docs/releases/1.8.10.txt",
          "docs/releases/1.9.3.txt",
          "docs/topics/auth/passwords.txt",
          "tests/auth_tests/test_hashers.py"
        ],
        "message": "[1.9.x] Fixed CVE-2016-2513 -- Fixed user enumeration timing attack during login.\n\nThis is a security fix.",
        "before_after_code_files": [
          "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py",
          "tests/auth_tests/test_hashers.py||tests/auth_tests/test_hashers.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py",
            "tests/auth_tests/test_hashers.py||tests/auth_tests/test_hashers.py"
          ],
          "candidate": [
            "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py",
            "tests/auth_tests/test_hashers.py||tests/auth_tests/test_hashers.py"
          ]
        }
      },
      "candidate_diff": {
        "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py": [
          "File: django/contrib/auth/hashers.py -> django/contrib/auth/hashers.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: import binascii",
          "5: import hashlib",
          "6: import importlib",
          "7: from collections import OrderedDict",
          "9: from django.conf import settings",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: import warnings",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "46:     preferred = get_hasher(preferred)",
          "47:     hasher = identify_hasher(encoded)",
          "52:     is_correct = hasher.verify(password, encoded)",
          "53:     if setter and is_correct and must_update:",
          "54:         setter(password)",
          "55:     return is_correct",
          "",
          "[Removed Lines]",
          "49:     must_update = hasher.algorithm != preferred.algorithm",
          "50:     if not must_update:",
          "51:         must_update = preferred.must_update(encoded)",
          "",
          "[Added Lines]",
          "50:     hasher_changed = hasher.algorithm != preferred.algorithm",
          "51:     must_update = hasher_changed or preferred.must_update(encoded)",
          "54:     # If the hasher didn't change (we don't protect against enumeration if it",
          "55:     # does) and the password should get updated, try to close the timing gap",
          "56:     # between the work factor of the current encoded password and the default",
          "57:     # work factor.",
          "58:     if not is_correct and not hasher_changed and must_update:",
          "59:         hasher.harden_runtime(password, encoded)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "216:     def must_update(self, encoded):",
          "217:         return False",
          "220: class PBKDF2PasswordHasher(BasePasswordHasher):",
          "221:     \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "227:     def harden_runtime(self, password, encoded):",
          "228:         \"\"\"",
          "229:         Bridge the runtime gap between the work factor supplied in `encoded`",
          "230:         and the work factor suggested by this hasher.",
          "232:         Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and",
          "233:         `self.iterations` is 30000, this method should run password through",
          "234:         another 10000 iterations of PBKDF2. Similar approaches should exist",
          "235:         for any hasher that has a work factor. If not, this method should be",
          "236:         defined as a no-op to silence the warning.",
          "237:         \"\"\"",
          "238:         warnings.warn('subclasses of BasePasswordHasher should provide a harden_runtime() method')",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "258:         algorithm, iterations, salt, hash = encoded.split('$', 3)",
          "259:         return int(iterations) != self.iterations",
          "262: class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):",
          "263:     \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "282:     def harden_runtime(self, password, encoded):",
          "283:         algorithm, iterations, salt, hash = encoded.split('$', 3)",
          "284:         extra_iterations = self.iterations - int(iterations)",
          "285:         if extra_iterations > 0:",
          "286:             self.encode(password, salt, extra_iterations)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "308:     def verify(self, password, encoded):",
          "309:         algorithm, data = encoded.split('$', 1)",
          "310:         assert algorithm == self.algorithm",
          "329:     def safe_summary(self, encoded):",
          "330:         algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)",
          "",
          "[Removed Lines]",
          "311:         bcrypt = self._load_library()",
          "313:         # Hash the password prior to using bcrypt to prevent password truncation",
          "314:         #   See: https://code.djangoproject.com/ticket/20138",
          "315:         if self.digest is not None:",
          "316:             # We use binascii.hexlify here because Python3 decided that a hex encoded",
          "317:             #   bytestring is somehow a unicode.",
          "318:             password = binascii.hexlify(self.digest(force_bytes(password)).digest())",
          "319:         else:",
          "320:             password = force_bytes(password)",
          "322:         # Ensure that our data is a bytestring",
          "323:         data = force_bytes(data)",
          "324:         # force_bytes() necessary for py-bcrypt compatibility",
          "325:         hashpw = force_bytes(bcrypt.hashpw(password, data))",
          "327:         return constant_time_compare(data, hashpw)",
          "",
          "[Added Lines]",
          "338:         encoded_2 = self.encode(password, force_bytes(data))",
          "339:         return constant_time_compare(encoded, encoded_2)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "341:         algorithm, empty, algostr, rounds, data = encoded.split('$', 4)",
          "342:         return int(rounds) != self.rounds",
          "345: class BCryptPasswordHasher(BCryptSHA256PasswordHasher):",
          "346:     \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "356:     def harden_runtime(self, password, encoded):",
          "357:         _, data = encoded.split('$', 1)",
          "358:         salt = data[:29]  # Length of the salt in bcrypt.",
          "359:         rounds = data.split('$')[2]",
          "360:         # work factor is logarithmic, adding one doubles the load.",
          "361:         diff = 2**(self.rounds - int(rounds)) - 1",
          "362:         while diff > 0:",
          "363:             self.encode(password, force_bytes(salt))",
          "364:             diff -= 1",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "388:             (_('hash'), mask_hash(hash)),",
          "389:         ])",
          "392: class MD5PasswordHasher(BasePasswordHasher):",
          "393:     \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "413:     def harden_runtime(self, password, encoded):",
          "414:         pass",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "416:             (_('hash'), mask_hash(hash)),",
          "417:         ])",
          "420: class UnsaltedSHA1PasswordHasher(BasePasswordHasher):",
          "421:     \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "444:     def harden_runtime(self, password, encoded):",
          "445:         pass",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "448:             (_('hash'), mask_hash(hash)),",
          "449:         ])",
          "452: class UnsaltedMD5PasswordHasher(BasePasswordHasher):",
          "453:     \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "479:     def harden_runtime(self, password, encoded):",
          "480:         pass",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "481:             (_('hash'), mask_hash(encoded, show=3)),",
          "482:         ])",
          "485: class CryptPasswordHasher(BasePasswordHasher):",
          "486:     \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "515:     def harden_runtime(self, password, encoded):",
          "516:         pass",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "515:             (_('salt'), salt),",
          "516:             (_('hash'), mask_hash(data, show=3)),",
          "517:         ])",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "553:     def harden_runtime(self, password, encoded):",
          "554:         pass",
          "",
          "---------------"
        ],
        "tests/auth_tests/test_hashers.py||tests/auth_tests/test_hashers.py": [
          "File: tests/auth_tests/test_hashers.py -> tests/auth_tests/test_hashers.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "10:     check_password, get_hasher, identify_hasher, is_password_usable,",
          "11:     make_password,",
          "12: )",
          "14: from django.test.utils import override_settings",
          "15: from django.utils import six",
          "17: try:",
          "18:     import crypt",
          "",
          "[Removed Lines]",
          "13: from django.test import SimpleTestCase",
          "",
          "[Added Lines]",
          "13: from django.test import SimpleTestCase, mock",
          "16: from django.utils.encoding import force_bytes",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "209:         finally:",
          "210:             hasher.rounds = old_rounds",
          "212:     def test_unusable(self):",
          "213:         encoded = make_password(None)",
          "214:         self.assertEqual(len(encoded), len(UNUSABLE_PASSWORD_PREFIX) + UNUSABLE_PASSWORD_SUFFIX_LENGTH)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "213:     @skipUnless(bcrypt, \"bcrypt not installed\")",
          "214:     def test_bcrypt_harden_runtime(self):",
          "215:         hasher = get_hasher('bcrypt')",
          "216:         self.assertEqual('bcrypt', hasher.algorithm)",
          "218:         with mock.patch.object(hasher, 'rounds', 4):",
          "219:             encoded = make_password('letmein', hasher='bcrypt')",
          "221:         with mock.patch.object(hasher, 'rounds', 6), \\",
          "222:                 mock.patch.object(hasher, 'encode', side_effect=hasher.encode):",
          "223:             hasher.harden_runtime('wrong_password', encoded)",
          "225:             # Increasing rounds from 4 to 6 means an increase of 4 in workload,",
          "226:             # therefore hardening should run 3 times to make the timing the",
          "227:             # same (the original encode() call already ran once).",
          "228:             self.assertEqual(hasher.encode.call_count, 3)",
          "230:             # Get the original salt (includes the original workload factor)",
          "231:             algorithm, data = encoded.split('$', 1)",
          "232:             expected_call = (('wrong_password', force_bytes(data[:29])),)",
          "233:             self.assertEqual(hasher.encode.call_args_list, [expected_call] * 3)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "316:         finally:",
          "317:             hasher.iterations = old_iterations",
          "319:     def test_pbkdf2_upgrade_new_hasher(self):",
          "320:         hasher = get_hasher('default')",
          "321:         self.assertEqual('pbkdf2_sha256', hasher.algorithm)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "342:     def test_pbkdf2_harden_runtime(self):",
          "343:         hasher = get_hasher('default')",
          "344:         self.assertEqual('pbkdf2_sha256', hasher.algorithm)",
          "346:         with mock.patch.object(hasher, 'iterations', 1):",
          "347:             encoded = make_password('letmein')",
          "349:         with mock.patch.object(hasher, 'iterations', 6), \\",
          "350:                 mock.patch.object(hasher, 'encode', side_effect=hasher.encode):",
          "351:             hasher.harden_runtime('wrong_password', encoded)",
          "353:             # Encode should get called once ...",
          "354:             self.assertEqual(hasher.encode.call_count, 1)",
          "356:             # ... with the original salt and 5 iterations.",
          "357:             algorithm, iterations, salt, hash = encoded.split('$', 3)",
          "358:             expected_call = (('wrong_password', salt, 5),)",
          "359:             self.assertEqual(hasher.encode.call_args, expected_call)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "344:             self.assertTrue(check_password('letmein', encoded, setter))",
          "345:             self.assertTrue(state['upgraded'])",
          "347:     def test_load_library_no_algorithm(self):",
          "348:         with self.assertRaises(ValueError) as e:",
          "349:             BasePasswordHasher()._load_library()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "389:     def test_check_password_calls_harden_runtime(self):",
          "390:         hasher = get_hasher('default')",
          "391:         encoded = make_password('letmein')",
          "393:         with mock.patch.object(hasher, 'harden_runtime'), \\",
          "394:                 mock.patch.object(hasher, 'must_update', return_value=True):",
          "395:             # Correct password supplied, no hardening needed",
          "396:             check_password('letmein', encoded)",
          "397:             self.assertEqual(hasher.harden_runtime.call_count, 0)",
          "399:             # Wrong password supplied, hardening needed",
          "400:             check_password('wrong_password', encoded)",
          "401:             self.assertEqual(hasher.harden_runtime.call_count, 1)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f4e6e02f7713a6924d16540be279909ff4091eb6",
      "candidate_info": {
        "commit_hash": "f4e6e02f7713a6924d16540be279909ff4091eb6",
        "repo": "django/django",
        "commit_url": "https://github.com/django/django/commit/f4e6e02f7713a6924d16540be279909ff4091eb6",
        "files": [
          "django/contrib/auth/hashers.py",
          "docs/releases/1.8.10.txt",
          "docs/topics/auth/passwords.txt",
          "tests/auth_tests/test_hashers.py"
        ],
        "message": "[1.8.x] Fixed CVE-2016-2513 -- Fixed user enumeration timing attack during login.\n\nThis is a security fix.",
        "before_after_code_files": [
          "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py",
          "tests/auth_tests/test_hashers.py||tests/auth_tests/test_hashers.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py",
            "tests/auth_tests/test_hashers.py||tests/auth_tests/test_hashers.py"
          ],
          "candidate": [
            "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py",
            "tests/auth_tests/test_hashers.py||tests/auth_tests/test_hashers.py"
          ]
        }
      },
      "candidate_diff": {
        "django/contrib/auth/hashers.py||django/contrib/auth/hashers.py": [
          "File: django/contrib/auth/hashers.py -> django/contrib/auth/hashers.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: import binascii",
          "5: import hashlib",
          "6: import importlib",
          "7: from collections import OrderedDict",
          "9: from django.conf import settings",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: import warnings",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "46:     preferred = get_hasher(preferred)",
          "47:     hasher = identify_hasher(encoded)",
          "52:     is_correct = hasher.verify(password, encoded)",
          "53:     if setter and is_correct and must_update:",
          "54:         setter(password)",
          "55:     return is_correct",
          "",
          "[Removed Lines]",
          "49:     must_update = hasher.algorithm != preferred.algorithm",
          "50:     if not must_update:",
          "51:         must_update = preferred.must_update(encoded)",
          "",
          "[Added Lines]",
          "50:     hasher_changed = hasher.algorithm != preferred.algorithm",
          "51:     must_update = hasher_changed or preferred.must_update(encoded)",
          "54:     # If the hasher didn't change (we don't protect against enumeration if it",
          "55:     # does) and the password should get updated, try to close the timing gap",
          "56:     # between the work factor of the current encoded password and the default",
          "57:     # work factor.",
          "58:     if not is_correct and not hasher_changed and must_update:",
          "59:         hasher.harden_runtime(password, encoded)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "216:     def must_update(self, encoded):",
          "217:         return False",
          "220: class PBKDF2PasswordHasher(BasePasswordHasher):",
          "221:     \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "227:     def harden_runtime(self, password, encoded):",
          "228:         \"\"\"",
          "229:         Bridge the runtime gap between the work factor supplied in `encoded`",
          "230:         and the work factor suggested by this hasher.",
          "232:         Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and",
          "233:         `self.iterations` is 30000, this method should run password through",
          "234:         another 10000 iterations of PBKDF2. Similar approaches should exist",
          "235:         for any hasher that has a work factor. If not, this method should be",
          "236:         defined as a no-op to silence the warning.",
          "237:         \"\"\"",
          "238:         warnings.warn('subclasses of BasePasswordHasher should provide a harden_runtime() method')",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "258:         algorithm, iterations, salt, hash = encoded.split('$', 3)",
          "259:         return int(iterations) != self.iterations",
          "262: class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):",
          "263:     \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "282:     def harden_runtime(self, password, encoded):",
          "283:         algorithm, iterations, salt, hash = encoded.split('$', 3)",
          "284:         extra_iterations = self.iterations - int(iterations)",
          "285:         if extra_iterations > 0:",
          "286:             self.encode(password, salt, extra_iterations)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "308:     def verify(self, password, encoded):",
          "309:         algorithm, data = encoded.split('$', 1)",
          "310:         assert algorithm == self.algorithm",
          "329:     def safe_summary(self, encoded):",
          "330:         algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)",
          "",
          "[Removed Lines]",
          "311:         bcrypt = self._load_library()",
          "313:         # Hash the password prior to using bcrypt to prevent password truncation",
          "314:         #   See: https://code.djangoproject.com/ticket/20138",
          "315:         if self.digest is not None:",
          "316:             # We use binascii.hexlify here because Python3 decided that a hex encoded",
          "317:             #   bytestring is somehow a unicode.",
          "318:             password = binascii.hexlify(self.digest(force_bytes(password)).digest())",
          "319:         else:",
          "320:             password = force_bytes(password)",
          "322:         # Ensure that our data is a bytestring",
          "323:         data = force_bytes(data)",
          "324:         # force_bytes() necessary for py-bcrypt compatibility",
          "325:         hashpw = force_bytes(bcrypt.hashpw(password, data))",
          "327:         return constant_time_compare(data, hashpw)",
          "",
          "[Added Lines]",
          "338:         encoded_2 = self.encode(password, force_bytes(data))",
          "339:         return constant_time_compare(encoded, encoded_2)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "337:             (_('checksum'), mask_hash(checksum)),",
          "338:         ])",
          "341: class BCryptPasswordHasher(BCryptSHA256PasswordHasher):",
          "342:     \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "352:     def harden_runtime(self, password, encoded):",
          "353:         _, data = encoded.split('$', 1)",
          "354:         salt = data[:29]  # Length of the salt in bcrypt.",
          "355:         rounds = data.split('$')[2]",
          "356:         # work factor is logarithmic, adding one doubles the load.",
          "357:         diff = 2**(self.rounds - int(rounds)) - 1",
          "358:         while diff > 0:",
          "359:             self.encode(password, force_bytes(salt))",
          "360:             diff -= 1",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "384:             (_('hash'), mask_hash(hash)),",
          "385:         ])",
          "388: class MD5PasswordHasher(BasePasswordHasher):",
          "389:     \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "409:     def harden_runtime(self, password, encoded):",
          "410:         pass",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "412:             (_('hash'), mask_hash(hash)),",
          "413:         ])",
          "416: class UnsaltedSHA1PasswordHasher(BasePasswordHasher):",
          "417:     \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "440:     def harden_runtime(self, password, encoded):",
          "441:         pass",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "444:             (_('hash'), mask_hash(hash)),",
          "445:         ])",
          "448: class UnsaltedMD5PasswordHasher(BasePasswordHasher):",
          "449:     \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "475:     def harden_runtime(self, password, encoded):",
          "476:         pass",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "477:             (_('hash'), mask_hash(encoded, show=3)),",
          "478:         ])",
          "481: class CryptPasswordHasher(BasePasswordHasher):",
          "482:     \"\"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "511:     def harden_runtime(self, password, encoded):",
          "512:         pass",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "511:             (_('salt'), salt),",
          "512:             (_('hash'), mask_hash(data, show=3)),",
          "513:         ])",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "549:     def harden_runtime(self, password, encoded):",
          "550:         pass",
          "",
          "---------------"
        ],
        "tests/auth_tests/test_hashers.py||tests/auth_tests/test_hashers.py": [
          "File: tests/auth_tests/test_hashers.py -> tests/auth_tests/test_hashers.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "10:     check_password, get_hasher, identify_hasher, is_password_usable,",
          "11:     make_password,",
          "12: )",
          "14: from django.test.utils import override_settings",
          "15: from django.utils import six",
          "17: try:",
          "18:     import crypt",
          "",
          "[Removed Lines]",
          "13: from django.test import SimpleTestCase",
          "",
          "[Added Lines]",
          "13: from django.test import SimpleTestCase, mock",
          "16: from django.utils.encoding import force_bytes",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "177:         self.assertTrue(check_password('', blank_encoded))",
          "178:         self.assertFalse(check_password(' ', blank_encoded))",
          "180:     def test_unusable(self):",
          "181:         encoded = make_password(None)",
          "182:         self.assertEqual(len(encoded), len(UNUSABLE_PASSWORD_PREFIX) + UNUSABLE_PASSWORD_SUFFIX_LENGTH)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "181:     @skipUnless(bcrypt, \"bcrypt not installed\")",
          "182:     def test_bcrypt_harden_runtime(self):",
          "183:         hasher = get_hasher('bcrypt')",
          "184:         self.assertEqual('bcrypt', hasher.algorithm)",
          "186:         with mock.patch.object(hasher, 'rounds', 4):",
          "187:             encoded = make_password('letmein', hasher='bcrypt')",
          "189:         with mock.patch.object(hasher, 'rounds', 6), \\",
          "190:                 mock.patch.object(hasher, 'encode', side_effect=hasher.encode):",
          "191:             hasher.harden_runtime('wrong_password', encoded)",
          "193:             # Increasing rounds from 4 to 6 means an increase of 4 in workload,",
          "194:             # therefore hardening should run 3 times to make the timing the",
          "195:             # same (the original encode() call already ran once).",
          "196:             self.assertEqual(hasher.encode.call_count, 3)",
          "198:             # Get the original salt (includes the original workload factor)",
          "199:             algorithm, data = encoded.split('$', 1)",
          "200:             expected_call = (('wrong_password', force_bytes(data[:29])),)",
          "201:             self.assertEqual(hasher.encode.call_args_list, [expected_call] * 3)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "284:         finally:",
          "285:             hasher.iterations = old_iterations",
          "287:     def test_pbkdf2_upgrade_new_hasher(self):",
          "288:         hasher = get_hasher('default')",
          "289:         self.assertEqual('pbkdf2_sha256', hasher.algorithm)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "310:     def test_pbkdf2_harden_runtime(self):",
          "311:         hasher = get_hasher('default')",
          "312:         self.assertEqual('pbkdf2_sha256', hasher.algorithm)",
          "314:         with mock.patch.object(hasher, 'iterations', 1):",
          "315:             encoded = make_password('letmein')",
          "317:         with mock.patch.object(hasher, 'iterations', 6), \\",
          "318:                 mock.patch.object(hasher, 'encode', side_effect=hasher.encode):",
          "319:             hasher.harden_runtime('wrong_password', encoded)",
          "321:             # Encode should get called once ...",
          "322:             self.assertEqual(hasher.encode.call_count, 1)",
          "324:             # ... with the original salt and 5 iterations.",
          "325:             algorithm, iterations, salt, hash = encoded.split('$', 3)",
          "326:             expected_call = (('wrong_password', salt, 5),)",
          "327:             self.assertEqual(hasher.encode.call_args, expected_call)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "312:             self.assertTrue(check_password('letmein', encoded, setter))",
          "313:             self.assertTrue(state['upgraded'])",
          "315:     def test_load_library_no_algorithm(self):",
          "316:         with self.assertRaises(ValueError) as e:",
          "317:             BasePasswordHasher()._load_library()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "357:     def test_check_password_calls_harden_runtime(self):",
          "358:         hasher = get_hasher('default')",
          "359:         encoded = make_password('letmein')",
          "361:         with mock.patch.object(hasher, 'harden_runtime'), \\",
          "362:                 mock.patch.object(hasher, 'must_update', return_value=True):",
          "363:             # Correct password supplied, no hardening needed",
          "364:             check_password('letmein', encoded)",
          "365:             self.assertEqual(hasher.harden_runtime.call_count, 0)",
          "367:             # Wrong password supplied, hardening needed",
          "368:             check_password('wrong_password', encoded)",
          "369:             self.assertEqual(hasher.harden_runtime.call_count, 1)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
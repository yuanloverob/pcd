{
  "cve_id": "CVE-2020-35884",
  "cve_desc": "An issue was discovered in the tiny_http crate through 2020-06-16 for Rust. HTTP Request smuggling can occur via a malformed Transfer-Encoding header.",
  "repo": "tiny-http/tiny-http",
  "patch_hash": "623b87397a569729c4bcabae747823c5668cce94",
  "patch_info": {
    "commit_hash": "623b87397a569729c4bcabae747823c5668cce94",
    "repo": "tiny-http/tiny-http",
    "commit_url": "https://github.com/tiny-http/tiny-http/commit/623b87397a569729c4bcabae747823c5668cce94",
    "files": [
      "src/common.rs"
    ],
    "message": "Fix RUSTSEC-2020-0031",
    "before_after_code_files": [
      "src/common.rs||src/common.rs"
    ]
  },
  "patch_diff": {
    "src/common.rs||src/common.rs": [
      "File: src/common.rs -> src/common.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "239:     type Err = ();",
      "241:     fn from_str(s: &str) -> Result<HeaderField, ()> {",
      "243:             .map(HeaderField)",
      "244:             .map_err(|_| ())",
      "245:     }",
      "",
      "[Removed Lines]",
      "242:         AsciiString::from_ascii(s.trim())",
      "",
      "[Added Lines]",
      "242:         AsciiString::from_ascii(s)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "952439bc5e9011e5778b16dbbd29e259b925e3c2",
      "candidate_info": {
        "commit_hash": "952439bc5e9011e5778b16dbbd29e259b925e3c2",
        "repo": "tiny-http/tiny-http",
        "commit_url": "https://github.com/tiny-http/tiny-http/commit/952439bc5e9011e5778b16dbbd29e259b925e3c2",
        "files": [
          "src/common.rs"
        ],
        "message": "add test",
        "before_after_code_files": [
          "src/common.rs||src/common.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/tiny-http/tiny-http/pull/190"
        ],
        "olp_code_files": {
          "patch": [
            "src/common.rs||src/common.rs"
          ],
          "candidate": [
            "src/common.rs||src/common.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/common.rs||src/common.rs": [
          "File: src/common.rs -> src/common.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "461:         assert!(header.field.equiv(&\"time\"));",
          "462:         assert!(header.value.as_str() == \"20: 34\");",
          "463:     }",
          "464: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "468:     #[test]",
          "469:     fn test_strict_headers() {",
          "470:         let smuggled = \"Transfer-Encoding : chunked\".parse::<Header>().unwrap();",
          "471:         assert!(!smuggled.field.equiv(\"Transfer-Encoding\"));",
          "472:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cbe07c3cefadabe678b7b38fbed814f715ad71b7",
      "candidate_info": {
        "commit_hash": "cbe07c3cefadabe678b7b38fbed814f715ad71b7",
        "repo": "tiny-http/tiny-http",
        "commit_url": "https://github.com/tiny-http/tiny-http/commit/cbe07c3cefadabe678b7b38fbed814f715ad71b7",
        "files": [
          "tests/input-tests.rs"
        ],
        "message": "Add test suggested (and written) by @rawler",
        "before_after_code_files": [
          "tests/input-tests.rs||tests/input-tests.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/tiny-http/tiny-http/pull/190"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tests/input-tests.rs||tests/input-tests.rs": [
          "File: tests/input-tests.rs -> tests/input-tests.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "81:     client.read_to_string(&mut content).unwrap();",
          "82:     assert!(&content[9..].starts_with(\"417\")); // 417 status code",
          "83: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "85: #[test]",
          "86: fn invalid_header_name() {",
          "87:     let mut client = support::new_client_to_hello_world_server();",
          "90:     (write!(client, \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\nContent-Type: text/plain; charset=utf8\\r\\nContent-Length : 5\\r\\n\\r\\nhello\")).unwrap();",
          "92:     let mut content = String::new();",
          "93:     client.read_to_string(&mut content).unwrap();",
          "94:     assert!(&content[9..].starts_with(\"400 Bad Request\")); // 400 status code",
          "95: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "16fa7b56b6d30ef73acf0cea88d0bba27df2c1c4",
      "candidate_info": {
        "commit_hash": "16fa7b56b6d30ef73acf0cea88d0bba27df2c1c4",
        "repo": "tiny-http/tiny-http",
        "commit_url": "https://github.com/tiny-http/tiny-http/commit/16fa7b56b6d30ef73acf0cea88d0bba27df2c1c4",
        "files": [
          "benches/bench.rs",
          "examples/hello-world.rs",
          "examples/php-cgi.rs",
          "examples/readme-example.rs",
          "examples/serve-root.rs",
          "examples/ssl.rs",
          "examples/websockets.rs",
          "src/client.rs",
          "src/common.rs",
          "src/lib.rs",
          "src/request.rs",
          "src/response.rs",
          "src/util/custom_stream.rs",
          "src/util/equal_reader.rs",
          "src/util/messages_queue.rs",
          "src/util/mod.rs",
          "src/util/refined_tcp_stream.rs",
          "src/util/sequential.rs",
          "src/util/task_pool.rs",
          "tests/input-tests.rs",
          "tests/network.rs",
          "tests/simple-test.rs",
          "tests/support/mod.rs"
        ],
        "message": "Cargo fmt all code",
        "before_after_code_files": [
          "benches/bench.rs||benches/bench.rs",
          "examples/hello-world.rs||examples/hello-world.rs",
          "examples/php-cgi.rs||examples/php-cgi.rs",
          "examples/readme-example.rs||examples/readme-example.rs",
          "examples/serve-root.rs||examples/serve-root.rs",
          "examples/ssl.rs||examples/ssl.rs",
          "examples/websockets.rs||examples/websockets.rs",
          "src/client.rs||src/client.rs",
          "src/common.rs||src/common.rs",
          "src/lib.rs||src/lib.rs",
          "src/request.rs||src/request.rs",
          "src/response.rs||src/response.rs",
          "src/util/custom_stream.rs||src/util/custom_stream.rs",
          "src/util/equal_reader.rs||src/util/equal_reader.rs",
          "src/util/messages_queue.rs||src/util/messages_queue.rs",
          "src/util/mod.rs||src/util/mod.rs",
          "src/util/refined_tcp_stream.rs||src/util/refined_tcp_stream.rs",
          "src/util/sequential.rs||src/util/sequential.rs",
          "src/util/task_pool.rs||src/util/task_pool.rs",
          "tests/input-tests.rs||tests/input-tests.rs",
          "tests/network.rs||tests/network.rs",
          "tests/simple-test.rs||tests/simple-test.rs",
          "tests/support/mod.rs||tests/support/mod.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/common.rs||src/common.rs"
          ],
          "candidate": [
            "src/common.rs||src/common.rs"
          ]
        }
      },
      "candidate_diff": {
        "benches/bench.rs||benches/bench.rs": [
          "File: benches/bench.rs -> benches/bench.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:         .output()",
          "23:     {",
          "24:         Ok(p) => p,",
          "26:     };",
          "28:     drop(server);",
          "",
          "[Removed Lines]",
          "25:         Err(_) => return,       // ignoring test",
          "",
          "[Added Lines]",
          "25:         Err(_) => return, // ignoring test",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:         for _ in 0..1000usize {",
          "60:             let mut stream = std::net::TcpStream::connect((\"127.0.0.1\", port)).unwrap();",
          "62:             streams.push(stream);",
          "63:         }",
          "65:         loop {",
          "66:             let request = match server.try_recv().unwrap() {",
          "67:                 None => break,",
          "69:             };",
          "71:             assert_eq!(request.method(), &Method::Get);",
          "",
          "[Removed Lines]",
          "61:             (write!(stream, \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n\")).unwrap();",
          "68:                 Some(rq) => rq",
          "",
          "[Added Lines]",
          "61:             (write!(",
          "62:                 stream,",
          "63:                 \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n\"",
          "64:             ))",
          "65:             .unwrap();",
          "72:                 Some(rq) => rq,",
          "",
          "---------------"
        ],
        "examples/hello-world.rs||examples/hello-world.rs": [
          "File: examples/hello-world.rs -> examples/hello-world.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "10:     let mut handles = Vec::new();",
          "13:         let server = server.clone();",
          "15:         handles.push(thread::spawn(move || {",
          "",
          "[Removed Lines]",
          "12:     for _ in 0 .. 4 {",
          "",
          "[Added Lines]",
          "12:     for _ in 0..4 {",
          "",
          "---------------"
        ],
        "examples/php-cgi.rs||examples/php-cgi.rs": [
          "File: examples/php-cgi.rs -> examples/php-cgi.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: fn handle(rq: tiny_http::Request, script: &str) {",
          "16:     use std::io::Write;",
          "18:     let php = Command::new(\"php-cgi\")",
          "19:         .arg(script)",
          "22:         .env(\"AUTH_TYPE\", \"\")",
          "24:         .env(\"CONTENT_TYPE\", \"\")",
          "25:         .env(\"GATEWAY_INTERFACE\", \"CGI/1.1\")",
          "26:         .env(\"PATH_INFO\", \"\")",
          "",
          "[Removed Lines]",
          "15:     use std::process::Command;",
          "23:         .env(\"CONTENT_LENGTH\", format!(\"{}\", rq.body_length().unwrap_or(0)))",
          "",
          "[Added Lines]",
          "16:     use std::process::Command;",
          "23:         .env(",
          "24:             \"CONTENT_LENGTH\",",
          "25:             format!(\"{}\", rq.body_length().unwrap_or(0)),",
          "26:         )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:             (write!(writer, \"{}\", php.stdout.clone().as_ascii_str().unwrap())).unwrap();",
          "54:             writer.flush().unwrap();",
          "56:         _ => {",
          "58:         }",
          "59:     }",
          "60: }",
          "62: fn main() {",
          "63:     use std::sync::Arc;",
          "64:     use std::thread::spawn;",
          "67:     let php_script = {",
          "68:         let mut args = env::args();",
          "70:         args.nth(1).unwrap()",
          "71:     };",
          "73:     let server = Arc::new(tiny_http::Server::http(\"0.0.0.0:9975\").unwrap());",
          "74:     println!(\"Now listening on port 9975\");",
          "77:     for _ in 0..num_cpus {",
          "78:         let server = server.clone();",
          "79:         let php_script = php_script.clone();",
          "",
          "[Removed Lines]",
          "55:         },",
          "57:             println!(\"Error in script execution: {}\", php.stderr.clone().as_ascii_str().unwrap());",
          "65:     use std::env;",
          "69:         if args.len() < 2 { println!(\"Usage: php-cgi <php-script-path>\"); return }",
          "76:     let num_cpus = 4;  // TODO: dynamically generate this value",
          "",
          "[Added Lines]",
          "57:         }",
          "59:             println!(",
          "60:                 \"Error in script execution: {}\",",
          "61:                 php.stderr.clone().as_ascii_str().unwrap()",
          "62:             );",
          "68:     use std::env;",
          "74:         if args.len() < 2 {",
          "75:             println!(\"Usage: php-cgi <php-script-path>\");",
          "76:             return;",
          "77:         }",
          "84:     let num_cpus = 4; // TODO: dynamically generate this value",
          "",
          "---------------"
        ],
        "examples/readme-example.rs||examples/readme-example.rs": [
          "File: examples/readme-example.rs -> examples/readme-example.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: extern crate tiny_http;",
          "3: fn main() {",
          "6:     let server = Server::http(\"0.0.0.0:8000\").unwrap();",
          "8:     for request in server.incoming_requests() {",
          "10:             request.method(),",
          "11:             request.url(),",
          "12:             request.headers()",
          "",
          "[Removed Lines]",
          "4:     use tiny_http::{Server, Response};",
          "9:         println!(\"received request! method: {:?}, url: {:?}, headers: {:?}\",",
          "",
          "[Added Lines]",
          "4:     use tiny_http::{Response, Server};",
          "9:         println!(",
          "10:             \"received request! method: {:?}, url: {:?}, headers: {:?}\",",
          "",
          "---------------"
        ],
        "examples/serve-root.rs||examples/serve-root.rs": [
          "File: examples/serve-root.rs -> examples/serve-root.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: use ascii::AsciiString;",
          "5: extern crate ascii;",
          "6: extern crate tiny_http;",
          "",
          "[Removed Lines]",
          "1: use std::path::Path;",
          "2: use std::fs;",
          "",
          "[Added Lines]",
          "2: use std::fs;",
          "3: use std::path::Path;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "8: fn get_content_type(path: &Path) -> &'static str {",
          "9:     let extension = match path.extension() {",
          "10:         None => return \"text/plain\",",
          "12:     };",
          "14:     match extension.to_str().unwrap() {",
          "",
          "[Removed Lines]",
          "11:         Some(e) => e",
          "",
          "[Added Lines]",
          "11:         Some(e) => e,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "20:         \"htm\" => \"text/html; charset=utf8\",",
          "21:         \"html\" => \"text/html; charset=utf8\",",
          "22:         \"txt\" => \"text/plain; charset=utf8\",",
          "24:     }",
          "25: }",
          "",
          "[Removed Lines]",
          "23:         _ => \"text/plain; charset=utf8\"",
          "",
          "[Added Lines]",
          "23:         _ => \"text/plain; charset=utf8\",",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "32:     loop {",
          "33:         let rq = match server.recv() {",
          "34:             Ok(rq) => rq,",
          "36:         };",
          "38:         println!(\"{:?}\", rq);",
          "",
          "[Removed Lines]",
          "35:             Err(_) => break",
          "",
          "[Added Lines]",
          "35:             Err(_) => break,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "44:         if file.is_ok() {",
          "45:             let response = tiny_http::Response::from_file(file.unwrap());",
          "54:             let _ = rq.respond(response);",
          "56:         } else {",
          "57:             let rep = tiny_http::Response::new_empty(tiny_http::StatusCode(404));",
          "58:             let _ = rq.respond(rep);",
          "",
          "[Removed Lines]",
          "47:             let response = response.with_header(",
          "48:                 tiny_http::Header {",
          "49:                     field: \"Content-Type\".parse().unwrap(),",
          "50:                     value: AsciiString::from_ascii(get_content_type(&path)).unwrap(),",
          "51:                 }",
          "52:             );",
          "",
          "[Added Lines]",
          "47:             let response = response.with_header(tiny_http::Header {",
          "48:                 field: \"Content-Type\".parse().unwrap(),",
          "49:                 value: AsciiString::from_ascii(get_content_type(&path)).unwrap(),",
          "50:             });",
          "",
          "---------------"
        ],
        "examples/ssl.rs||examples/ssl.rs": [
          "File: examples/ssl.rs -> examples/ssl.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: extern crate tiny_http;",
          "3: #[cfg(not(feature = \"ssl\"))]",
          "6: #[cfg(feature = \"ssl\")]",
          "7: fn main() {",
          "16:               because the connection is unsecure. This is because the certificate used by this \\",
          "19:     for request in server.incoming_requests() {",
          "20:         assert!(request.secure());",
          "23:             request.method(),",
          "24:             request.url(),",
          "25:             request.headers()",
          "",
          "[Removed Lines]",
          "4: fn main() { println!(\"This example requires the `ssl` feature to be enabled\"); }",
          "8:     use tiny_http::{Server, Response};",
          "10:     let server = Server::https(\"0.0.0.0:8000\", tiny_http::SslConfig {",
          "11:         certificate: include_bytes!(\"ssl-cert.pem\").to_vec(),",
          "12:         private_key: include_bytes!(\"ssl-key.pem\").to_vec(),",
          "13:     }).unwrap();",
          "15:     println!(\"Note: connecting to this server will likely give you a warning from your browser \\",
          "17:               example is self-signed. With a real certificate, you wouldn't get this warning.\");",
          "22:         println!(\"received request! method: {:?}, url: {:?}, headers: {:?}\",",
          "",
          "[Added Lines]",
          "4: fn main() {",
          "5:     println!(\"This example requires the `ssl` feature to be enabled\");",
          "6: }",
          "10:     use tiny_http::{Response, Server};",
          "12:     let server = Server::https(",
          "13:         \"0.0.0.0:8000\",",
          "14:         tiny_http::SslConfig {",
          "15:             certificate: include_bytes!(\"ssl-cert.pem\").to_vec(),",
          "16:             private_key: include_bytes!(\"ssl-key.pem\").to_vec(),",
          "17:         },",
          "18:     )",
          "19:     .unwrap();",
          "21:     println!(",
          "22:         \"Note: connecting to this server will likely give you a warning from your browser \\",
          "24:               example is self-signed. With a real certificate, you wouldn't get this warning.\"",
          "25:     );",
          "30:         println!(",
          "31:             \"received request! method: {:?}, url: {:?}, headers: {:?}\",",
          "",
          "---------------"
        ],
        "examples/websockets.rs||examples/websockets.rs": [
          "File: examples/websockets.rs -> examples/websockets.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: extern crate rustc_serialize;",
          "3: extern crate sha1;",
          "6: use std::io::Cursor;",
          "7: use std::io::Read;",
          "12: fn home_page(port: u16) -> tiny_http::Response<Cursor<Vec<u8>>> {",
          "14:         <script type=\\\"text/javascript\\\">",
          "15:         var socket = new WebSocket(\\\"ws://localhost:{}/\\\", \\\"ping\\\");",
          "",
          "[Removed Lines]",
          "1: extern crate tiny_http;",
          "5: use std::thread::spawn;",
          "9: use rustc_serialize::base64::{Config, Standard, ToBase64, Newline};",
          "13:     tiny_http::Response::from_string(format!(\"",
          "",
          "[Added Lines]",
          "3: extern crate tiny_http;",
          "7: use std::thread::spawn;",
          "9: use rustc_serialize::base64::{Config, Newline, Standard, ToBase64};",
          "12:     tiny_http::Response::from_string(format!(",
          "13:         \"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "28:         <button onclick=\\\"send(document.getElementById('msg').value)\\\">Send</button></p>",
          "29:         <p>Received: </p>",
          "30:         <p id=\\\"result\\\"></p>",
          "33: }",
          "",
          "[Removed Lines]",
          "31:     \", port))",
          "32:         .with_header(\"Content-type: text/html\".parse::<tiny_http::Header>().unwrap())",
          "",
          "[Added Lines]",
          "31:     \",",
          "32:         port",
          "33:     ))",
          "34:     .with_header(",
          "35:         \"Content-type: text/html\"",
          "36:             .parse::<tiny_http::Header>()",
          "37:             .unwrap(),",
          "38:     )",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "38:     use sha1::Sha1;",
          "40:     let mut input = input.to_string().into_bytes();",
          "42:     input.append(&mut bytes);",
          "44:     let mut sha1 = Sha1::new();",
          "45:     sha1.update(&input);",
          "49: }",
          "51: fn main() {",
          "",
          "[Removed Lines]",
          "41:     let mut bytes = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\".to_string().into_bytes();",
          "47:     sha1.digest().bytes().to_base64(Config { char_set: Standard, pad: true,",
          "48:                                              line_length: None, newline: Newline::LF })",
          "",
          "[Added Lines]",
          "47:     let mut bytes = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"",
          "48:         .to_string()",
          "49:         .into_bytes();",
          "55:     sha1.digest().bytes().to_base64(Config {",
          "56:         char_set: Standard,",
          "57:         pad: true,",
          "58:         line_length: None,",
          "59:         newline: Newline::LF,",
          "60:     })",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "53:     let port = server.server_addr().port();",
          "55:     println!(\"Server started\");",
          "58:     for request in server.incoming_requests() {",
          "60:         spawn(move || {",
          "66:                 None => {",
          "68:                     request.respond(home_page(port));",
          "72:             };",
          "76:                 .find(|h| h.field.equiv(&\"Sec-WebSocket-Key\"))",
          "77:                 .map(|h| h.value.clone())",
          "78:             {",
          "",
          "[Removed Lines]",
          "56:     println!(\"To try this example, open a browser to http://localhost:{}/\", port);",
          "62:             match request.headers().iter()",
          "63:                 .find(|h| h.field.equiv(&\"Upgrade\"))",
          "64:                 .and_then(|hdr| if hdr.value == \"websocket\" { Some(hdr) } else { None })",
          "65:             {",
          "69:                     return",
          "70:                 },",
          "71:                 _ => ()",
          "75:             let key = match request.headers().iter()",
          "",
          "[Added Lines]",
          "68:     println!(",
          "69:         \"To try this example, open a browser to http://localhost:{}/\",",
          "70:         port",
          "71:     );",
          "77:             match request",
          "78:                 .headers()",
          "79:                 .iter()",
          "80:                 .find(|h| h.field.equiv(&\"Upgrade\"))",
          "81:                 .and_then(|hdr| {",
          "82:                     if hdr.value == \"websocket\" {",
          "83:                         Some(hdr)",
          "84:                     } else {",
          "85:                         None",
          "86:                     }",
          "87:                 }) {",
          "91:                     return;",
          "92:                 }",
          "93:                 _ => (),",
          "97:             let key = match request",
          "98:                 .headers()",
          "99:                 .iter()",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "80:                     let response = tiny_http::Response::new_empty(tiny_http::StatusCode(400));",
          "81:                     request.respond(response);",
          "82:                     return;",
          "85:             };",
          "88:             let response = tiny_http::Response::new_empty(tiny_http::StatusCode(101))",
          "89:                 .with_header(\"Upgrade: websocket\".parse::<tiny_http::Header>().unwrap())",
          "90:                 .with_header(\"Connection: Upgrade\".parse::<tiny_http::Header>().unwrap())",
          "92:                 .with_header(",
          "98:             let mut stream = request.upgrade(\"websocket\", response);",
          "101:             loop {",
          "102:                 let mut out = Vec::new();",
          "103:                 match Read::by_ref(&mut stream).take(1).read_to_end(&mut out) {",
          "",
          "[Removed Lines]",
          "83:                 },",
          "84:                 Some(k) => k",
          "91:                 .with_header(\"Sec-WebSocket-Protocol: ping\".parse::<tiny_http::Header>().unwrap())",
          "93:                     format!(\"Sec-WebSocket-Accept: {}\",",
          "94:                         convert_key(key.as_str())",
          "95:                     ).parse::<tiny_http::Header>().unwrap());",
          "",
          "[Added Lines]",
          "107:                 }",
          "108:                 Some(k) => k,",
          "116:                     \"Sec-WebSocket-Protocol: ping\"",
          "117:                         .parse::<tiny_http::Header>()",
          "118:                         .unwrap(),",
          "119:                 )",
          "120:                 .with_header(",
          "121:                     format!(\"Sec-WebSocket-Accept: {}\", convert_key(key.as_str()))",
          "122:                         .parse::<tiny_http::Header>()",
          "123:                         .unwrap(),",
          "124:                 );",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "106:                         let data = [0x81, 0x05, 0x48, 0x65, 0x6c, 0x6c, 0x6f];",
          "107:                         stream.write(&data).ok();",
          "108:                         stream.flush().ok();",
          "110:                     Ok(_) => panic!(\"eof ; should never happen\"),",
          "111:                     Err(e) => {",
          "112:                         println!(\"closing connection because: {}\", e);",
          "115:                 };",
          "116:             }",
          "117:         });",
          "",
          "[Removed Lines]",
          "109:                     },",
          "113:                         return",
          "114:                     },",
          "",
          "[Added Lines]",
          "138:                     }",
          "142:                         return;",
          "143:                     }",
          "",
          "---------------"
        ],
        "src/client.rs||src/client.rs": [
          "File: src/client.rs -> src/client.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: use std::io::Error as IoError;",
          "4: use std::io::Result as IoResult;",
          "7: use std::net::SocketAddr;",
          "8: use std::str::FromStr;",
          "10: use common::{HTTPVersion, Method};",
          "12: use util::RefinedTcpStream;",
          "14: use Request;",
          "",
          "[Removed Lines]",
          "1: use ascii::{AsciiString};",
          "5: use std::io::{ErrorKind, Read, BufReader, BufWriter};",
          "11: use util::{SequentialReader, SequentialReaderBuilder, SequentialWriterBuilder};",
          "",
          "[Added Lines]",
          "1: use ascii::AsciiString;",
          "5: use std::io::{BufReader, BufWriter, ErrorKind, Read};",
          "12: use util::{SequentialReader, SequentialReaderBuilder, SequentialWriterBuilder};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "51: impl ClientConnection {",
          "56:         let remote_addr = read_socket.peer_addr();",
          "57:         let secure = read_socket.secure();",
          "",
          "[Removed Lines]",
          "53:     pub fn new(write_socket: RefinedTcpStream, mut read_socket: RefinedTcpStream)",
          "54:                -> ClientConnection",
          "55:     {",
          "",
          "[Added Lines]",
          "53:     pub fn new(",
          "54:         write_socket: RefinedTcpStream,",
          "55:         mut read_socket: RefinedTcpStream,",
          "56:     ) -> ClientConnection {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "88:             let byte = match byte {",
          "89:                 Some(b) => try!(b),",
          "91:             };",
          "93:             if byte == b'\\n' && prev_byte_was_cr {",
          "95:                 return AsciiString::from_ascii(buf)",
          "97:             }",
          "99:             prev_byte_was_cr = byte == b'\\r';",
          "",
          "[Removed Lines]",
          "90:                 None => return Err(IoError::new(ErrorKind::ConnectionAborted, \"Unexpected EOF\"))",
          "94:                 buf.pop();  // removing the '\\r'",
          "96:                     .map_err(|_| IoError::new(ErrorKind::InvalidInput, \"Header is not in ASCII\"))",
          "",
          "[Added Lines]",
          "91:                 None => return Err(IoError::new(ErrorKind::ConnectionAborted, \"Unexpected EOF\")),",
          "95:                 buf.pop(); // removing the '\\r'",
          "97:                     .map_err(|_| IoError::new(ErrorKind::InvalidInput, \"Header is not in ASCII\"));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "111:                 let line = try!(self.read_next_line().map_err(|e| ReadError::ReadIoError(e)));",
          "113:                 try!(parse_request_line(",
          "115:                 ))",
          "116:             };",
          "",
          "[Removed Lines]",
          "114:                     line.as_str().trim()    // TODO: remove this conversion",
          "",
          "[Added Lines]",
          "115:                     line.as_str().trim() // TODO: remove this conversion",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "121:                 loop {",
          "122:                     let line = try!(self.read_next_line().map_err(|e| ReadError::ReadIoError(e)));",
          "131:                 }",
          "133:                 headers",
          "",
          "[Removed Lines]",
          "124:                     if line.len() == 0 { break };",
          "125:                     headers.push(",
          "126:                         match FromStr::from_str(line.as_str().trim()) {    // TODO: remove this conversion",
          "127:                             Ok(h) => h,",
          "128:                             _ => return Err(ReadError::WrongHeader(version))",
          "129:                         }",
          "130:                     );",
          "",
          "[Added Lines]",
          "125:                     if line.len() == 0 {",
          "126:                         break;",
          "127:                     };",
          "128:                     headers.push(match FromStr::from_str(line.as_str().trim()) {",
          "130:                         Ok(h) => h,",
          "131:                         _ => return Err(ReadError::WrongHeader(version)),",
          "132:                     });",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "144:         ::std::mem::swap(&mut self.next_header_source, &mut data_source);",
          "154:                 }",
          "158:         Ok(request)",
          "",
          "[Removed Lines]",
          "147:         let request = try!(::request::new_request(self.secure, method, path, version.clone(),",
          "148:                 headers, self.remote_addr.as_ref().unwrap().clone(), data_source, writer)",
          "149:             .map_err(|e| {",
          "150:                 use request;",
          "151:                 match e {",
          "152:                     request::RequestCreationError::CreationIoError(e) => ReadError::ReadIoError(e),",
          "153:                     request::RequestCreationError::ExpectationFailed => ReadError::ExpectationFailed(version)",
          "155:             }));",
          "",
          "[Added Lines]",
          "149:         let request = try!(::request::new_request(",
          "150:             self.secure,",
          "151:             method,",
          "152:             path,",
          "153:             version.clone(),",
          "154:             headers,",
          "155:             self.remote_addr.as_ref().unwrap().clone(),",
          "156:             data_source,",
          "157:             writer",
          "158:         )",
          "159:         .map_err(|e| {",
          "160:             use request;",
          "161:             match e {",
          "162:                 request::RequestCreationError::CreationIoError(e) => ReadError::ReadIoError(e),",
          "163:                 request::RequestCreationError::ExpectationFailed => {",
          "164:                     ReadError::ExpectationFailed(version)",
          "166:             }",
          "167:         }));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "171:         if self.no_more_requests {",
          "173:         }",
          "175:         loop {",
          "",
          "[Removed Lines]",
          "172:             return None",
          "",
          "[Added Lines]",
          "184:             return None;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "177:                 Err(ReadError::WrongRequestLine) => {",
          "178:                     let writer = self.sink.next().unwrap();",
          "179:                     let response = Response::new_empty(StatusCode(400));",
          "185:                 Err(ReadError::WrongHeader(ver)) => {",
          "186:                     let writer = self.sink.next().unwrap();",
          "187:                     let response = Response::new_empty(StatusCode(400));",
          "188:                     response.raw_print(writer, ver, &[], false, None).ok();",
          "193:                 Err(ReadError::ReadIoError(ref err)) if err.kind() == ErrorKind::TimedOut => {",
          "195:                     let writer = self.sink.next().unwrap();",
          "196:                     let response = Response::new_empty(StatusCode(408));",
          "201:                 Err(ReadError::ExpectationFailed(ver)) => {",
          "202:                     let writer = self.sink.next().unwrap();",
          "203:                     let response = Response::new_empty(StatusCode(417));",
          "204:                     response.raw_print(writer, ver, &[], true, None).ok();",
          "212:             };",
          "215:             if *rq.http_version() > (1, 1) {",
          "216:                 let writer = self.sink.next().unwrap();",
          "222:             }",
          "225:             {",
          "227:                     .find(|h| h.field.equiv(&\"Connection\"))",
          "228:                     .map(|h| h.value.as_str());",
          "230:                 let lowercase = connection_header.map(|h| h.to_ascii_lowercase());",
          "232:                 match lowercase {",
          "247:                 };",
          "248:             }",
          "",
          "[Removed Lines]",
          "180:                     response.raw_print(writer, HTTPVersion(1, 1), &[], false, None).ok();",
          "181:                     return None;    // we don't know where the next request would start,",
          "183:                 },",
          "189:                     return None;    // we don't know where the next request would start,",
          "191:                 },",
          "197:                     response.raw_print(writer, HTTPVersion(1, 1), &[], false, None).ok();",
          "198:                     return None;    // closing the connection",
          "199:                 },",
          "205:                     return None;    // TODO: should be recoverable, but needs handling in case of body",
          "206:                 },",
          "208:                 Err(ReadError::ReadIoError(_)) =>",
          "209:                     return None,",
          "211:                 Ok(rq) => rq",
          "217:                 let response =",
          "218:                     Response::from_string(\"This server only supports HTTP versions 1.0 and 1.1\"",
          "219:                         .to_owned()).with_status_code(StatusCode(505));",
          "220:                 response.raw_print(writer, HTTPVersion(1, 1), &[], false, None).ok();",
          "221:                 continue",
          "226:                 let connection_header = rq.headers().iter()",
          "233:                     Some(ref val) if val.contains(\"close\") =>",
          "234:                         self.no_more_requests = true,",
          "236:                     Some(ref val) if val.contains(\"upgrade\") =>",
          "237:                         self.no_more_requests = true,",
          "239:                     Some(ref val) if !val.contains(\"keep-alive\") &&",
          "241:                         self.no_more_requests = true,",
          "243:                     None if *rq.http_version() == HTTPVersion(1, 0) =>",
          "244:                         self.no_more_requests = true,",
          "246:                     _ => ()",
          "",
          "[Added Lines]",
          "192:                     response",
          "193:                         .raw_print(writer, HTTPVersion(1, 1), &[], false, None)",
          "194:                         .ok();",
          "195:                     return None; // we don't know where the next request would start,",
          "197:                 }",
          "203:                     return None; // we don't know where the next request would start,",
          "205:                 }",
          "211:                     response",
          "212:                         .raw_print(writer, HTTPVersion(1, 1), &[], false, None)",
          "213:                         .ok();",
          "214:                     return None; // closing the connection",
          "215:                 }",
          "221:                     return None; // TODO: should be recoverable, but needs handling in case of body",
          "222:                 }",
          "224:                 Err(ReadError::ReadIoError(_)) => return None,",
          "226:                 Ok(rq) => rq,",
          "232:                 let response = Response::from_string(",
          "233:                     \"This server only supports HTTP versions 1.0 and 1.1\".to_owned(),",
          "234:                 )",
          "235:                 .with_status_code(StatusCode(505));",
          "236:                 response",
          "237:                     .raw_print(writer, HTTPVersion(1, 1), &[], false, None)",
          "238:                     .ok();",
          "239:                 continue;",
          "244:                 let connection_header = rq",
          "245:                     .headers()",
          "246:                     .iter()",
          "253:                     Some(ref val) if val.contains(\"close\") => self.no_more_requests = true,",
          "255:                     Some(ref val) if val.contains(\"upgrade\") => self.no_more_requests = true,",
          "257:                     Some(ref val)",
          "258:                         if !val.contains(\"keep-alive\")",
          "259:                             && *rq.http_version() == HTTPVersion(1, 0) =>",
          "260:                     {",
          "261:                         self.no_more_requests = true",
          "262:                     }",
          "264:                     None if *rq.http_version() == HTTPVersion(1, 0) => self.no_more_requests = true,",
          "266:                     _ => (),",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "257: fn parse_http_version(version: &str) -> Result<HTTPVersion, ReadError> {",
          "259:     if elems.len() != 2 {",
          "261:     }",
          "265:     if elems.len() != 2 {",
          "267:     }",
          "269:     match (FromStr::from_str(&elems[0]), FromStr::from_str(&elems[1])) {",
          "273:     }",
          "274: }",
          "",
          "[Removed Lines]",
          "258:     let elems = version.splitn(2, '/').map(|e| e.to_owned()).collect::<Vec<String>>();",
          "260:         return Err(ReadError::WrongRequestLine)",
          "263:     let elems = elems[1].splitn(2, '.')",
          "264:         .map(|e| e.to_owned()).collect::<Vec<String>>();",
          "266:         return Err(ReadError::WrongRequestLine)",
          "270:         (Ok(major), Ok(minor)) =>",
          "271:             Ok(HTTPVersion(major, minor)),",
          "272:         _ => Err(ReadError::WrongRequestLine)",
          "",
          "[Added Lines]",
          "278:     let elems = version",
          "279:         .splitn(2, '/')",
          "280:         .map(|e| e.to_owned())",
          "281:         .collect::<Vec<String>>();",
          "283:         return Err(ReadError::WrongRequestLine);",
          "286:     let elems = elems[1]",
          "287:         .splitn(2, '.')",
          "288:         .map(|e| e.to_owned())",
          "289:         .collect::<Vec<String>>();",
          "291:         return Err(ReadError::WrongRequestLine);",
          "295:         (Ok(major), Ok(minor)) => Ok(HTTPVersion(major, minor)),",
          "296:         _ => Err(ReadError::WrongRequestLine),",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "285:     let (method, path, version) = match (method, path, version) {",
          "286:         (Some(m), Some(p), Some(v)) => (m, p, v),",
          "288:     };",
          "290:     let method = match FromStr::from_str(method) {",
          "291:         Ok(method) => method,",
          "293:     };",
          "295:     let version = try!(parse_http_version(version));",
          "",
          "[Removed Lines]",
          "287:         _ => return Err(ReadError::WrongRequestLine)",
          "292:         Err(()) => return Err(ReadError::WrongRequestLine)",
          "",
          "[Added Lines]",
          "311:         _ => return Err(ReadError::WrongRequestLine),",
          "316:         Err(()) => return Err(ReadError::WrongRequestLine),",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "301: mod test {",
          "302:     #[test]",
          "303:     fn test_parse_request_line() {",
          "310:         assert!(method == ::Method::Get);",
          "311:         assert!(path == \"/hello\");",
          "",
          "[Removed Lines]",
          "304:         let (method, path, ver) =",
          "305:             match super::parse_request_line(\"GET /hello HTTP/1.1\") {",
          "306:                 Err(_) => panic!(),",
          "307:                 Ok(v) => v",
          "308:             };",
          "",
          "[Added Lines]",
          "328:         let (method, path, ver) = match super::parse_request_line(\"GET /hello HTTP/1.1\") {",
          "329:             Err(_) => panic!(),",
          "330:             Ok(v) => v,",
          "331:         };",
          "",
          "---------------"
        ],
        "src/common.rs||src/common.rs": [
          "File: src/common.rs -> src/common.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: use std::cmp::Ordering;",
          "6: use chrono::*;",
          "",
          "[Removed Lines]",
          "1: use ascii::{AsciiString, AsciiStr, FromAsciiError};",
          "2: use std::fmt::{self, Display, Formatter};",
          "3: use std::str::{FromStr};",
          "",
          "[Added Lines]",
          "1: use ascii::{AsciiStr, AsciiString, FromAsciiError};",
          "3: use std::fmt::{self, Display, Formatter};",
          "4: use std::str::FromStr;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78:             508 => \"Loop Detected\",",
          "79:             510 => \"Not Extended\",",
          "80:             511 => \"Network Authentication Required\",",
          "82:         }",
          "83:     }",
          "84: }",
          "",
          "[Removed Lines]",
          "81:             _ => \"Unknown\"",
          "",
          "[Added Lines]",
          "81:             _ => \"Unknown\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "167:     pub fn from_bytes<B1, B2>(header: B1, value: B2) -> Result<Header, ()>",
          "170:     {",
          "171:         let header = try!(HeaderField::from_bytes(header).or(Err(())));",
          "172:         let value = try!(AsciiString::from_ascii(value).or(Err(())));",
          "175:     }",
          "177: }",
          "179: impl FromStr for Header {",
          "",
          "[Removed Lines]",
          "168:                               where B1: Into<Vec<u8>> + AsRef<[u8]>,",
          "169:                                     B2: Into<Vec<u8>> + AsRef<[u8]>",
          "174:         Ok(Header { field: header, value: value })",
          "",
          "[Added Lines]",
          "168:     where",
          "169:         B1: Into<Vec<u8>> + AsRef<[u8]>,",
          "170:         B2: Into<Vec<u8>> + AsRef<[u8]>,",
          "175:         Ok(Header {",
          "176:             field: header,",
          "177:             value: value,",
          "178:         })",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "188:         let (field, value) = match (field, value) {",
          "189:             (Some(f), Some(v)) => (f, v),",
          "191:         };",
          "193:         let field = match FromStr::from_str(field) {",
          "194:             Ok(f) => f,",
          "196:         };",
          "200:         Ok(Header {",
          "201:             field: field,",
          "",
          "[Removed Lines]",
          "190:             _ => return Err(())",
          "195:             _ => return Err(())",
          "198:         let value = try!(AsciiString::from_ascii(value.trim()).map_err(|_| () ));",
          "",
          "[Added Lines]",
          "193:             _ => return Err(()),",
          "198:             _ => return Err(()),",
          "201:         let value = try!(AsciiString::from_ascii(value.trim()).map_err(|_| ()));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "217: pub struct HeaderField(AsciiString);",
          "219: impl HeaderField {",
          "221:         AsciiString::from_ascii(bytes).map(HeaderField)",
          "222:     }",
          "224:     pub fn as_str<'a>(&'a self) -> &'a AsciiStr {",
          "226:     }",
          "228:     pub fn equiv(&self, other: &'static str) -> bool {",
          "",
          "[Removed Lines]",
          "220:     pub fn from_bytes<B>(bytes: B) -> Result<HeaderField, FromAsciiError<B>> where B: Into<Vec<u8>> + AsRef<[u8]> {",
          "225:         match self { &HeaderField(ref s) => s }",
          "",
          "[Added Lines]",
          "223:     pub fn from_bytes<B>(bytes: B) -> Result<HeaderField, FromAsciiError<B>>",
          "224:     where",
          "225:         B: Into<Vec<u8>> + AsRef<[u8]>,",
          "226:     {",
          "231:         match self {",
          "232:             &HeaderField(ref s) => s,",
          "233:         }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "234:     type Err = ();",
          "236:     fn from_str(s: &str) -> Result<HeaderField, ()> {",
          "238:     }",
          "239: }",
          "",
          "[Removed Lines]",
          "237:         AsciiString::from_ascii(s.trim()).map(HeaderField).map_err(|_| () )",
          "",
          "[Added Lines]",
          "245:         AsciiString::from_ascii(s.trim())",
          "246:             .map(HeaderField)",
          "247:             .map_err(|_| ())",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "325:             s if s.eq_ignore_ascii_case(\"TRACE\") => Method::Trace,",
          "326:             s if s.eq_ignore_ascii_case(\"PATCH\") => Method::Patch,",
          "327:             s => {",
          "329:                 Method::NonStandard(ascii_string)",
          "330:             }",
          "331:         })",
          "",
          "[Removed Lines]",
          "328:                 let ascii_string = try!(AsciiString::from_ascii(s).map_err(|_| () ));",
          "",
          "[Added Lines]",
          "337:                 let ascii_string = try!(AsciiString::from_ascii(s).map_err(|_| ()));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "341: impl PartialEq for Method {",
          "342:     fn eq(&self, other: &Method) -> bool {",
          "343:         match (self, other) {",
          "346:             (&Method::Get, &Method::Get) => true,",
          "347:             (&Method::Head, &Method::Head) => true,",
          "348:             (&Method::Post, &Method::Post) => true,",
          "",
          "[Removed Lines]",
          "344:             (&Method::NonStandard(ref s1), &Method::NonStandard(ref s2)) =>",
          "345:                 s1.as_str().eq_ignore_ascii_case(s2.as_str()),",
          "",
          "[Added Lines]",
          "353:             (&Method::NonStandard(ref s1), &Method::NonStandard(ref s2)) => {",
          "354:                 s1.as_str().eq_ignore_ascii_case(s2.as_str())",
          "355:             }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "360: impl Eq for Method {}",
          "364: #[derive(Debug, Clone, PartialEq, Eq, Ord)]",
          "365: pub struct HTTPVersion(pub u8, pub u8);",
          "367: impl Display for HTTPVersion {",
          "368:     fn fmt(&self, formatter: &mut Formatter) -> Result<(), fmt::Error> {",
          "370:         write!(formatter, \"{}.{}\", major, minor)",
          "371:     }",
          "372: }",
          "374: impl PartialOrd for HTTPVersion {",
          "375:     fn partial_cmp(&self, other: &HTTPVersion) -> Option<Ordering> {",
          "379:         if my_major != other_major {",
          "381:         }",
          "383:         my_minor.partial_cmp(&other_minor)",
          "",
          "[Removed Lines]",
          "369:         let (major, minor) = match self { &HTTPVersion(m, n) => (m, n) };",
          "376:         let (my_major, my_minor) = match self { &HTTPVersion(m, n) => (m, n) };",
          "377:         let (other_major, other_minor) = match other { &HTTPVersion(m, n) => (m, n) };",
          "380:             return my_major.partial_cmp(&other_major)",
          "",
          "[Added Lines]",
          "378:         let (major, minor) = match self {",
          "379:             &HTTPVersion(m, n) => (m, n),",
          "380:         };",
          "387:         let (my_major, my_minor) = match self {",
          "388:             &HTTPVersion(m, n) => (m, n),",
          "389:         };",
          "390:         let (other_major, other_minor) = match other {",
          "391:             &HTTPVersion(m, n) => (m, n),",
          "392:         };",
          "395:             return my_major.partial_cmp(&other_major);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "417: }",
          "419: pub struct HTTPDate {",
          "421: }",
          "423: impl HTTPDate {",
          "424:     pub fn new() -> HTTPDate {",
          "426:     }",
          "427: }",
          "",
          "[Removed Lines]",
          "420:     d: DateTime<Utc>",
          "425:         HTTPDate {d: Utc::now(),}",
          "",
          "[Added Lines]",
          "435:     d: DateTime<Utc>,",
          "440:         HTTPDate { d: Utc::now() }",
          "",
          "---------------"
        ],
        "src/lib.rs||src/lib.rs": [
          "File: src/lib.rs -> src/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "97: extern crate log;",
          "99: extern crate ascii;",
          "100: extern crate chunked_transfer;",
          "101: extern crate url;",
          "104: #[cfg(feature = \"ssl\")]",
          "105: extern crate openssl;",
          "",
          "[Removed Lines]",
          "102: extern crate chrono;",
          "",
          "[Added Lines]",
          "100: extern crate chrono;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "107: use std::error::Error;",
          "108: use std::io::Error as IoError;",
          "109: use std::io::Result as IoResult;",
          "111: use std::sync::atomic::AtomicBool;",
          "112: use std::sync::mpsc;",
          "113: use std::thread;",
          "116: use std::time::Duration;",
          "119: use client::ClientConnection;",
          "120: use util::MessagesQueue;",
          "126: mod client;",
          "127: mod common;",
          "",
          "[Removed Lines]",
          "110: use std::sync::Arc;",
          "114: use std::net;",
          "115: use std::net::{ToSocketAddrs, TcpStream, Shutdown};",
          "117: use std::sync::atomic::Ordering::Relaxed;",
          "122: pub use common::{Header, HeaderField, HTTPVersion, Method, StatusCode};",
          "123: pub use request::{Request, ReadWrite};",
          "124: pub use response::{ResponseBox, Response};",
          "",
          "[Added Lines]",
          "110: use std::net;",
          "111: use std::net::{Shutdown, TcpStream, ToSocketAddrs};",
          "113: use std::sync::atomic::Ordering::Relaxed;",
          "115: use std::sync::Arc;",
          "122: pub use common::{HTTPVersion, Header, HeaderField, Method, StatusCode};",
          "123: pub use request::{ReadWrite, Request};",
          "124: pub use response::{Response, ResponseBox};",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "167: #[doc(hidden)]",
          "169: #[doc(hidden)]",
          "170: impl MustBeShareDummy for Server {}",
          "173: pub struct IncomingRequests<'a> {",
          "175: }",
          "178: #[derive(Debug, Clone)]",
          "181:     pub addr: A,",
          "",
          "[Removed Lines]",
          "168: trait MustBeShareDummy : Sync + Send {}",
          "174:     server: &'a Server",
          "179: pub struct ServerConfig<A> where A: ToSocketAddrs {",
          "",
          "[Added Lines]",
          "168: trait MustBeShareDummy: Sync + Send {}",
          "173:     server: &'a Server,",
          "178: pub struct ServerConfig<A>",
          "179: where",
          "180:     A: ToSocketAddrs,",
          "181: {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "198:     #[inline]",
          "199:     pub fn http<A>(addr: A) -> Result<Server, Box<Error + Send + Sync + 'static>>",
          "201:     {",
          "202:         Server::new(ServerConfig {",
          "203:             addr: addr,",
          "",
          "[Removed Lines]",
          "200:         where A: ToSocketAddrs",
          "",
          "[Added Lines]",
          "202:     where",
          "203:         A: ToSocketAddrs,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "209:     #[cfg(feature = \"ssl\")]",
          "210:     #[inline]",
          "214:     {",
          "215:         Server::new(ServerConfig {",
          "216:             addr: addr,",
          "",
          "[Removed Lines]",
          "211:     pub fn https<A>(addr: A, config: SslConfig)",
          "212:                     -> Result<Server, Box<Error + Send + Sync + 'static>>",
          "213:         where A: ToSocketAddrs",
          "",
          "[Added Lines]",
          "214:     pub fn https<A>(",
          "215:         addr: A,",
          "216:         config: SslConfig,",
          "217:     ) -> Result<Server, Box<Error + Send + Sync + 'static>>",
          "218:     where",
          "219:         A: ToSocketAddrs,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "222:     pub fn new<A>(config: ServerConfig<A>) -> Result<Server, Box<Error + Send + Sync + 'static>>",
          "224:     {",
          "226:         let close_trigger = Arc::new(AtomicBool::new(false));",
          "",
          "[Removed Lines]",
          "223:         where A: ToSocketAddrs",
          "",
          "[Added Lines]",
          "229:     where",
          "230:         A: ToSocketAddrs,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "241:         let ssl: Option<SslContext> = match config.ssl {",
          "242:             #[cfg(feature = \"ssl\")]",
          "243:             Some(mut config) => {",
          "246:                 use openssl::pkey::PKey;",
          "247:                 use openssl::ssl::SslVerifyMode;",
          "249:                 let mut ctxt = try!(SslContext::builder(ssl::SslMethod::tls()));",
          "250:                 try!(ctxt.set_cipher_list(\"DEFAULT\"));",
          "",
          "[Removed Lines]",
          "244:                 use openssl::ssl;",
          "245:                 use openssl::x509::X509;",
          "",
          "[Added Lines]",
          "252:                 use openssl::ssl;",
          "254:                 use openssl::x509::X509;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "263:                 Some(ctxt.build())",
          "265:             #[cfg(not(feature = \"ssl\"))]",
          "268:             None => None,",
          "269:         };",
          "",
          "[Removed Lines]",
          "260:                 for b in &mut config.certificate { *b = 0; }",
          "261:                 for b in &mut config.private_key { *b = 0; }",
          "264:             },",
          "266:             Some(_) => return Err(\"Building a server with SSL requires enabling the `ssl` feature \\",
          "267:                                    in tiny-http\".to_owned().into()),",
          "",
          "[Added Lines]",
          "267:                 for b in &mut config.certificate {",
          "269:                 }",
          "270:                 for b in &mut config.private_key {",
          "272:                 }",
          "275:             }",
          "277:             Some(_) => {",
          "278:                 return Err(",
          "279:                     \"Building a server with SSL requires enabling the `ssl` feature \\",
          "280:                                    in tiny-http\"",
          "281:                         .to_owned()",
          "282:                         .into(),",
          "283:                 )",
          "284:             }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "284:                     Ok((sock, _)) => {",
          "285:                         use util::RefinedTcpStream;",
          "286:                         let (read_closable, write_closable) = match ssl {",
          "290:                             #[cfg(feature = \"ssl\")]",
          "291:                             Some(ref ssl) => {",
          "292:                                 let ssl = openssl::ssl::Ssl::new(ssl).expect(\"Couldn't create ssl\");",
          "",
          "[Removed Lines]",
          "287:                             None => {",
          "288:                                 RefinedTcpStream::new(sock)",
          "289:                             },",
          "",
          "[Added Lines]",
          "304:                             None => RefinedTcpStream::new(sock),",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "295:                                 let sock = match ssl.accept(sock) {",
          "296:                                     Ok(s) => s,",
          "298:                                 };",
          "300:                                 RefinedTcpStream::new(sock)",
          "302:                             #[cfg(not(feature = \"ssl\"))]",
          "303:                             Some(_) => unreachable!(),",
          "304:                         };",
          "306:                         Ok(ClientConnection::new(write_closable, read_closable))",
          "308:                     Err(e) => Err(e),",
          "309:                 };",
          "",
          "[Removed Lines]",
          "297:                                     Err(_) => continue",
          "301:                             },",
          "307:                     },",
          "",
          "[Added Lines]",
          "312:                                     Err(_) => continue,",
          "316:                             }",
          "322:                     }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "328:                                 }",
          "329:                             }",
          "330:                         }));",
          "333:                     Err(e) => {",
          "334:                         error!(\"Error accepting new client: {}\", e);",
          "",
          "[Removed Lines]",
          "331:                     },",
          "",
          "[Added Lines]",
          "346:                     }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "381:         match self.messages.pop_timeout(timeout) {",
          "382:             Some(Message::Error(err)) => return Err(err),",
          "383:             Some(Message::NewRequest(rq)) => return Ok(Some(rq)),",
          "385:         }",
          "386:     }",
          "",
          "[Removed Lines]",
          "384:             None => return Ok(None)",
          "",
          "[Added Lines]",
          "399:             None => return Ok(None),",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "390:         match self.messages.try_pop() {",
          "391:             Some(Message::Error(err)) => return Err(err),",
          "392:             Some(Message::NewRequest(rq)) => return Ok(Some(rq)),",
          "394:         }",
          "395:     }",
          "396: }",
          "",
          "[Removed Lines]",
          "393:             None => return Ok(None)",
          "",
          "[Added Lines]",
          "408:             None => return Ok(None),",
          "",
          "---------------"
        ],
        "src/request.rs||src/request.rs": [
          "File: src/request.rs -> src/request.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use std::io::Error as IoError;",
          "5: use std::fmt;",
          "6: use std::str::FromStr;",
          "8: use std::sync::mpsc::Sender;",
          "12: use chunked_transfer::Decoder;",
          "",
          "[Removed Lines]",
          "2: use std::io::{self, Cursor, Read, Write, ErrorKind};",
          "4: use std::net::SocketAddr;",
          "10: use {Header, HTTPVersion, Method, Response, StatusCode};",
          "11: use util::EqualReader;",
          "",
          "[Added Lines]",
          "2: use std::io::{self, Cursor, ErrorKind, Read, Write};",
          "5: use std::net::SocketAddr;",
          "11: use util::EqualReader;",
          "12: use {HTTPVersion, Header, Method, Response, StatusCode};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "128: {",
          "131:         .find(|h: &&Header| h.field.equiv(&\"Transfer-Encoding\"))",
          "132:         .map(|h| h.value.clone());",
          "",
          "[Removed Lines]",
          "123: pub fn new_request<R, W>(secure: bool, method: Method, path: String,",
          "124:                          version: HTTPVersion, headers: Vec<Header>,",
          "125:                          remote_addr: SocketAddr, mut source_data: R, writer: W)",
          "126:                          -> Result<Request, RequestCreationError>",
          "127:                          where R: Read + Send + 'static, W: Write + Send + 'static",
          "130:     let transfer_encoding = headers.iter()",
          "",
          "[Added Lines]",
          "123: pub fn new_request<R, W>(",
          "124:     secure: bool,",
          "125:     method: Method,",
          "126:     path: String,",
          "127:     version: HTTPVersion,",
          "128:     headers: Vec<Header>,",
          "129:     remote_addr: SocketAddr,",
          "130:     mut source_data: R,",
          "131:     writer: W,",
          "132: ) -> Result<Request, RequestCreationError>",
          "133: where",
          "134:     R: Read + Send + 'static,",
          "135:     W: Write + Send + 'static,",
          "138:     let transfer_encoding = headers",
          "139:         .iter()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "138:         None",
          "140:     } else {",
          "144:     };",
          "147:     let expects_continue = {",
          "149:             None => false,",
          "153:         }",
          "154:     };",
          "157:     let connection_upgrade = {",
          "162:         }",
          "163:     };",
          "193:                 }",
          "200:             }",
          "207:         } else {",
          "214:     Ok(Request {",
          "215:         data_reader: Some(reader),",
          "",
          "[Removed Lines]",
          "141:         headers.iter()",
          "142:                .find(|h: &&Header| h.field.equiv(&\"Content-Length\"))",
          "143:                .and_then(|h| FromStr::from_str(h.value.as_str()).ok())",
          "148:         match headers.iter().find(|h: &&Header| h.field.equiv(&\"Expect\")).map(|h| h.value.as_str()) {",
          "150:             Some(v) if v.eq_ignore_ascii_case(\"100-continue\")",
          "151:                 => true,",
          "152:             _ => return Err(RequestCreationError::ExpectationFailed)",
          "158:         match headers.iter().find(|h: &&Header| h.field.equiv(&\"Connection\")).map(|h| h.value.as_str()) {",
          "159:             Some(v) if v.to_ascii_lowercase().contains(\"upgrade\")",
          "160:                 => true,",
          "161:             _ => false",
          "167:     let reader =",
          "168:         if connection_upgrade {",
          "170:             Box::new(source_data) as Box<Read + Send + 'static>",
          "172:         } else if let Some(content_length) = content_length {",
          "173:             if content_length == 0 {",
          "174:                 Box::new(io::empty()) as Box<Read + Send + 'static>",
          "176:             } else if content_length <= 1024 && !expects_continue {",
          "179:                 let mut buffer = vec![0; content_length];",
          "180:                 let mut offset = 0;",
          "182:                 while offset != content_length {",
          "183:                     let read = try!(source_data.read(&mut buffer[offset..]));",
          "184:                     if read == 0 {",
          "187:                         let info = \"Connection has been closed before we received enough data\";",
          "188:                         let err = IoError::new(ErrorKind::ConnectionAborted, info);",
          "189:                         return Err(RequestCreationError::CreationIoError(err));",
          "190:                     }",
          "192:                     offset += read;",
          "195:                 Box::new(Cursor::new(buffer)) as Box<Read + Send + 'static>",
          "197:             } else {",
          "198:                 let (data_reader, _) = EqualReader::new(source_data, content_length);   // TODO:",
          "199:                 Box::new(data_reader) as Box<Read + Send + 'static>",
          "202:         } else if transfer_encoding.is_some() {",
          "205:             Box::new(Decoder::new(source_data)) as Box<Read + Send + 'static>",
          "211:             Box::new(io::empty()) as Box<Read + Send + 'static>",
          "212:         };",
          "",
          "[Added Lines]",
          "149:         headers",
          "150:             .iter()",
          "151:             .find(|h: &&Header| h.field.equiv(&\"Content-Length\"))",
          "152:             .and_then(|h| FromStr::from_str(h.value.as_str()).ok())",
          "157:         match headers",
          "158:             .iter()",
          "159:             .find(|h: &&Header| h.field.equiv(&\"Expect\"))",
          "160:             .map(|h| h.value.as_str())",
          "161:         {",
          "163:             Some(v) if v.eq_ignore_ascii_case(\"100-continue\") => true,",
          "164:             _ => return Err(RequestCreationError::ExpectationFailed),",
          "170:         match headers",
          "171:             .iter()",
          "172:             .find(|h: &&Header| h.field.equiv(&\"Connection\"))",
          "173:             .map(|h| h.value.as_str())",
          "174:         {",
          "175:             Some(v) if v.to_ascii_lowercase().contains(\"upgrade\") => true,",
          "176:             _ => false,",
          "182:     let reader = if connection_upgrade {",
          "184:         Box::new(source_data) as Box<Read + Send + 'static>",
          "185:     } else if let Some(content_length) = content_length {",
          "186:         if content_length == 0 {",
          "187:             Box::new(io::empty()) as Box<Read + Send + 'static>",
          "188:         } else if content_length <= 1024 && !expects_continue {",
          "191:             let mut buffer = vec![0; content_length];",
          "192:             let mut offset = 0;",
          "194:             while offset != content_length {",
          "195:                 let read = try!(source_data.read(&mut buffer[offset..]));",
          "196:                 if read == 0 {",
          "199:                     let info = \"Connection has been closed before we received enough data\";",
          "200:                     let err = IoError::new(ErrorKind::ConnectionAborted, info);",
          "201:                     return Err(RequestCreationError::CreationIoError(err));",
          "204:                 offset += read;",
          "207:             Box::new(Cursor::new(buffer)) as Box<Read + Send + 'static>",
          "209:             let (data_reader, _) = EqualReader::new(source_data, content_length); // TODO:",
          "210:             Box::new(data_reader) as Box<Read + Send + 'static>",
          "211:         }",
          "212:     } else if transfer_encoding.is_some() {",
          "215:         Box::new(Decoder::new(source_data)) as Box<Read + Send + 'static>",
          "216:     } else {",
          "220:         Box::new(io::empty()) as Box<Read + Send + 'static>",
          "221:     };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "288:         use util::CustomStream;",
          "295:         let stream = CustomStream::new(self.into_reader_impl(), self.into_writer_impl());",
          "296:         if let Some(sender) = self.notify_when_responded.take() {",
          "298:             Box::new(stream) as Box<ReadWrite + Send>",
          "299:         } else {",
          "300:             Box::new(stream) as Box<ReadWrite + Send>",
          "",
          "[Removed Lines]",
          "287:     pub fn upgrade<R: Read>(mut self, protocol: &str, response: Response<R>) -> Box<ReadWrite + Send> {",
          "290:         response.raw_print(self.response_writer.as_mut().unwrap().by_ref(), self.http_version.clone(),",
          "291:                            &self.headers, false, Some(protocol)).ok();   // TODO: unused result",
          "293:         self.response_writer.as_mut().unwrap().flush().ok();    // TODO: unused result",
          "297:             let stream = NotifyOnDrop { sender, inner: stream };",
          "",
          "[Added Lines]",
          "296:     pub fn upgrade<R: Read>(",
          "297:         mut self,",
          "298:         protocol: &str,",
          "299:         response: Response<R>,",
          "300:     ) -> Box<ReadWrite + Send> {",
          "303:         response",
          "304:             .raw_print(",
          "305:                 self.response_writer.as_mut().unwrap().by_ref(),",
          "306:                 self.http_version.clone(),",
          "307:                 &self.headers,",
          "308:                 false,",
          "309:                 Some(protocol),",
          "310:             )",
          "311:             .ok(); // TODO: unused result",
          "313:         self.response_writer.as_mut().unwrap().flush().ok(); // TODO: unused result",
          "317:             let stream = NotifyOnDrop {",
          "318:                 sender,",
          "319:                 inner: stream,",
          "320:             };",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "329:     pub fn as_reader(&mut self) -> &mut Read {",
          "330:         if self.must_send_continue {",
          "331:             let msg = Response::new_empty(StatusCode(100));",
          "334:             self.response_writer.as_mut().unwrap().flush().ok();",
          "335:             self.must_send_continue = false;",
          "336:         }",
          "",
          "[Removed Lines]",
          "332:             msg.raw_print(self.response_writer.as_mut().unwrap().by_ref(),",
          "333:                           self.http_version.clone(), &self.headers, true, None).ok();",
          "",
          "[Added Lines]",
          "355:             msg.raw_print(",
          "356:                 self.response_writer.as_mut().unwrap().by_ref(),",
          "357:                 self.http_version.clone(),",
          "358:                 &self.headers,",
          "359:                 true,",
          "360:                 None,",
          "361:             )",
          "362:             .ok();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "352:     pub fn into_writer(mut self) -> Box<Write + Send + 'static> {",
          "353:         let writer = self.into_writer_impl();",
          "354:         if let Some(sender) = self.notify_when_responded.take() {",
          "356:             Box::new(writer) as Box<Write + Send + 'static>",
          "357:         } else {",
          "358:             writer",
          "",
          "[Removed Lines]",
          "355:             let writer = NotifyOnDrop { sender, inner: writer };",
          "",
          "[Added Lines]",
          "384:             let writer = NotifyOnDrop {",
          "385:                 sender,",
          "386:                 inner: writer,",
          "387:             };",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "383:     #[inline]",
          "384:     pub fn respond<R>(mut self, response: Response<R>) -> Result<(), IoError>",
          "386:     {",
          "387:         let res = self.respond_impl(response);",
          "388:         if let Some(sender) = self.notify_when_responded.take() {",
          "",
          "[Removed Lines]",
          "385:         where R: Read",
          "",
          "[Added Lines]",
          "417:     where",
          "418:         R: Read,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "392:     }",
          "394:     fn respond_impl<R>(&mut self, response: Response<R>) -> Result<(), IoError>",
          "396:     {",
          "398:         self.data_reader = None;",
          "",
          "[Removed Lines]",
          "395:         where R: Read",
          "",
          "[Added Lines]",
          "428:     where",
          "429:         R: Read,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "402:         let do_not_send_body = self.method == Method::Head;",
          "408:             Ok(_) => (),",
          "409:             Err(ref err) if err.kind() == ErrorKind::BrokenPipe => (),",
          "410:             Err(ref err) if err.kind() == ErrorKind::ConnectionAborted => (),",
          "411:             Err(ref err) if err.kind() == ErrorKind::ConnectionRefused => (),",
          "412:             Err(ref err) if err.kind() == ErrorKind::ConnectionReset => (),",
          "414:         };",
          "416:         writer.flush()",
          "",
          "[Removed Lines]",
          "404:         match response.raw_print(writer.by_ref(),",
          "405:                                  self.http_version.clone(), &self.headers,",
          "406:                                  do_not_send_body, None)",
          "407:         {",
          "413:             Err(err) => return Err(err)",
          "",
          "[Added Lines]",
          "438:         match response.raw_print(",
          "439:             writer.by_ref(),",
          "440:             self.http_version.clone(),",
          "441:             &self.headers,",
          "442:             do_not_send_body,",
          "443:             None,",
          "444:         ) {",
          "450:             Err(err) => return Err(err),",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "425: impl fmt::Debug for Request {",
          "426:     fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {",
          "428:     }",
          "429: }",
          "",
          "[Removed Lines]",
          "427:         write!(formatter, \"Request({} {} from {})\", self.method, self.path, self.remote_addr)",
          "",
          "[Added Lines]",
          "464:         write!(",
          "465:             formatter,",
          "466:             \"Request({} {} from {})\",",
          "467:             self.method, self.path, self.remote_addr",
          "468:         )",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "436:         if self.response_writer.is_some() {",
          "437:             let response = Response::empty(500);",
          "439:             if let Some(sender) = self.notify_when_responded.take() {",
          "440:                 sender.send(()).unwrap();",
          "441:             }",
          "",
          "[Removed Lines]",
          "438:             let _ = self.respond_impl(response);        // ignoring any potential error",
          "",
          "[Added Lines]",
          "479:             let _ = self.respond_impl(response); // ignoring any potential error",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "457:     fn must_be_send() {",
          "458:         #![allow(dead_code)]",
          "459:         fn f<T: Send>(_: &T) {}",
          "461:     }",
          "462: }",
          "",
          "[Removed Lines]",
          "460:         fn bar(rq: &Request) { f(rq); }",
          "",
          "[Added Lines]",
          "501:         fn bar(rq: &Request) {",
          "502:             f(rq);",
          "503:         }",
          "",
          "---------------"
        ],
        "src/response.rs||src/response.rs": [
          "File: src/response.rs -> src/response.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: use std::cmp::Ordering;",
          "4: use std::sync::mpsc::Receiver;",
          "7: use std::io::Result as IoResult;",
          "9: use std::fs::File;",
          "",
          "[Removed Lines]",
          "1: use common::{Header, HTTPVersion, StatusCode, HTTPDate};",
          "6: use std::io::{self, Read, Write, Cursor};",
          "",
          "[Added Lines]",
          "1: use common::{HTTPDate, HTTPVersion, Header, StatusCode};",
          "7: use std::io::{self, Cursor, Read, Write};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37:     reader: R,",
          "38:     status_code: StatusCode,",
          "39:     headers: Vec<Header>,",
          "40:     data_length: Option<usize>,",
          "42: }",
          "",
          "[Removed Lines]",
          "36: pub struct Response<R> where R: Read {",
          "41:     chunked_threshold: Option<usize>",
          "",
          "[Added Lines]",
          "36: pub struct Response<R>",
          "37: where",
          "38:     R: Read,",
          "39: {",
          "44:     chunked_threshold: Option<usize>,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "72:     Header::from_bytes(&b\"Date\"[..], &d.to_string().into_bytes()[..]).unwrap()",
          "73: }",
          "78: {",
          "81:         http_version.0,",
          "82:         http_version.1,",
          "83:         status_code.0,",
          "",
          "[Removed Lines]",
          "75: fn write_message_header<W>(mut writer: W, http_version: &HTTPVersion,",
          "76:                            status_code: &StatusCode, headers: &[Header])",
          "77:                            -> IoResult<()> where W: Write",
          "80:     try!(write!(&mut writer, \"HTTP/{}.{} {} {}\\r\\n\",",
          "",
          "[Added Lines]",
          "78: fn write_message_header<W>(",
          "79:     mut writer: W,",
          "80:     http_version: &HTTPVersion,",
          "81:     status_code: &StatusCode,",
          "82:     headers: &[Header],",
          "83: ) -> IoResult<()>",
          "84: where",
          "85:     W: Write,",
          "88:     try!(write!(",
          "89:         &mut writer,",
          "90:         \"HTTP/{}.{} {} {}\\r\\n\",",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "98:     Ok(())",
          "99: }",
          "106:     use util;",
          "",
          "[Removed Lines]",
          "101: fn choose_transfer_encoding(request_headers: &[Header], http_version: &HTTPVersion,",
          "102:                             entity_length: &Option<usize>, has_additional_headers: bool,",
          "103:                             chunked_threshold: usize)",
          "104:     -> TransferEncoding",
          "105: {",
          "",
          "[Added Lines]",
          "111: fn choose_transfer_encoding(",
          "112:     request_headers: &[Header],",
          "113:     http_version: &HTTPVersion,",
          "114:     entity_length: &Option<usize>,",
          "115:     has_additional_headers: bool,",
          "116:     chunked_threshold: usize,",
          "117: ) -> TransferEncoding {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "111:     }",
          "116:         .find(|h| h.field.equiv(&\"TE\"))",
          "119:         .map(|h| h.value.clone())",
          "122:         .and_then(|value| {",
          "127:             parse.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(Ordering::Equal));",
          "",
          "[Removed Lines]",
          "114:     let user_request = request_headers.iter()",
          "124:             let mut parse = util::parse_header_value(value.as_str());     // TODO: remove conversion",
          "",
          "[Added Lines]",
          "126:     let user_request = request_headers",
          "127:         .iter()",
          "135:             let mut parse = util::parse_header_value(value.as_str()); // TODO: remove conversion",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "130:             for value in parse.iter() {",
          "134:                 match <TransferEncoding as FromStr>::from_str(value.0) {",
          "135:                     Ok(te) => return Some(te),",
          "137:                 };",
          "138:             }",
          "",
          "[Removed Lines]",
          "132:                 if value.1 <= 0.0 { continue }",
          "136:                     _ => ()     // unrecognized/unsupported encoding",
          "",
          "[Added Lines]",
          "143:                 if value.1 <= 0.0 {",
          "144:                     continue;",
          "145:                 }",
          "149:                     _ => (), // unrecognized/unsupported encoding",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "152:     }",
          "156:         return TransferEncoding::Chunked;",
          "157:     }",
          "",
          "[Removed Lines]",
          "155:     if entity_length.as_ref().map_or(true, |val| *val >= chunked_threshold) {",
          "",
          "[Added Lines]",
          "168:     if entity_length",
          "169:         .as_ref()",
          "170:         .map_or(true, |val| *val >= chunked_threshold)",
          "171:     {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "160:     TransferEncoding::Identity",
          "161: }",
          "175:         let mut response = Response {",
          "176:             reader: data,",
          "177:             status_code: status_code,",
          "",
          "[Removed Lines]",
          "163: impl<R> Response<R> where R: Read {",
          "170:     pub fn new(status_code: StatusCode, headers: Vec<Header>,",
          "171:                data: R, data_length: Option<usize>,",
          "172:                additional_headers: Option<Receiver<Header>>)",
          "173:                 -> Response<R>",
          "174:     {",
          "",
          "[Added Lines]",
          "179: impl<R> Response<R>",
          "180: where",
          "181:     R: Read,",
          "182: {",
          "189:     pub fn new(",
          "190:         status_code: StatusCode,",
          "191:         headers: Vec<Header>,",
          "192:         data: R,",
          "193:         data_length: Option<usize>,",
          "194:         additional_headers: Option<Receiver<Header>>,",
          "195:     ) -> Response<R> {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "202:         self.chunked_threshold = Some(length);",
          "203:         self",
          "204:     }",
          "",
          "[Removed Lines]",
          "201:     pub fn with_chunked_threshold(mut self, length: usize) -> Response<R>{",
          "",
          "[Added Lines]",
          "222:     pub fn with_chunked_threshold(mut self, length: usize) -> Response<R> {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "217:         let header = header.into();",
          "226:         {",
          "227:             return;",
          "228:         }",
          "",
          "[Removed Lines]",
          "216:     pub fn add_header<H>(&mut self, header: H) where H: Into<Header> {",
          "220:         if header.field.equiv(&\"Accept-Ranges\") ||",
          "221:            header.field.equiv(&\"Connection\") ||",
          "222:            header.field.equiv(&\"Content-Range\") ||",
          "223:            header.field.equiv(&\"Trailer\") ||",
          "224:            header.field.equiv(&\"Transfer-Encoding\") ||",
          "225:            header.field.equiv(&\"Upgrade\")",
          "",
          "[Added Lines]",
          "237:     pub fn add_header<H>(&mut self, header: H)",
          "238:     where",
          "239:         H: Into<Header>,",
          "240:     {",
          "244:         if header.field.equiv(&\"Accept-Ranges\")",
          "245:             || header.field.equiv(&\"Connection\")",
          "246:             || header.field.equiv(&\"Content-Range\")",
          "247:             || header.field.equiv(&\"Trailer\")",
          "248:             || header.field.equiv(&\"Transfer-Encoding\")",
          "249:             || header.field.equiv(&\"Upgrade\")",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "231:         if header.field.equiv(&\"Content-Length\") {",
          "232:             match <usize as FromStr>::from_str(header.value.as_str()) {",
          "233:                 Ok(val) => self.data_length = Some(val),",
          "235:             };",
          "237:             return;",
          "",
          "[Removed Lines]",
          "234:                 Err(_) => ()      // wrong value for content-length",
          "",
          "[Added Lines]",
          "258:                 Err(_) => (), // wrong value for content-length",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "247:     #[inline]",
          "249:         self.add_header(header.into());",
          "250:         self",
          "251:     }",
          "254:     #[inline]",
          "256:         self.status_code = code.into();",
          "257:         self",
          "258:     }",
          "262:         Response {",
          "263:             reader: reader,",
          "264:             headers: self.headers,",
          "",
          "[Removed Lines]",
          "248:     pub fn with_header<H>(mut self, header: H) -> Response<R> where H: Into<Header> {",
          "255:     pub fn with_status_code<S>(mut self, code: S) -> Response<R> where S: Into<StatusCode> {",
          "261:     pub fn with_data<S>(self, reader: S, data_length: Option<usize>) -> Response<S> where S: Read {",
          "",
          "[Added Lines]",
          "272:     pub fn with_header<H>(mut self, header: H) -> Response<R>",
          "273:     where",
          "274:         H: Into<Header>,",
          "275:     {",
          "282:     pub fn with_status_code<S>(mut self, code: S) -> Response<R>",
          "283:     where",
          "284:         S: Into<StatusCode>,",
          "285:     {",
          "291:     pub fn with_data<S>(self, reader: S, data_length: Option<usize>) -> Response<S>",
          "292:     where",
          "293:         S: Read,",
          "294:     {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "291:             self.headers.insert(0, build_date_header());",
          "292:         }",
          "298:             );",
          "299:         }",
          "302:         if let Some(upgrade) = upgrade {",
          "305:             transfer_encoding = None;",
          "306:         }",
          "",
          "[Removed Lines]",
          "280:     pub fn raw_print<W: Write>(mut self, mut writer: W, http_version: HTTPVersion,",
          "281:                                request_headers: &[Header], do_not_send_body: bool,",
          "282:                                upgrade: Option<&str>)",
          "283:                                -> IoResult<()>",
          "284:     {",
          "285:         let mut transfer_encoding = Some(choose_transfer_encoding(request_headers,",
          "286:                                     &http_version, &self.data_length, false /* TODO */,",
          "287:                                     self.chunked_threshold()));",
          "290:         if self.headers.iter().find(|h| h.field.equiv(&\"Date\")).is_none() {",
          "295:         if self.headers.iter().find(|h| h.field.equiv(&\"Server\")).is_none() {",
          "296:             self.headers.insert(0,",
          "297:                 Header::from_bytes(&b\"Server\"[..], &b\"tiny-http (Rust)\"[..]).unwrap()",
          "303:             self.headers.insert(0, Header::from_bytes(&b\"Upgrade\"[..], upgrade.as_bytes()).unwrap());",
          "304:             self.headers.insert(0, Header::from_bytes(&b\"Connection\"[..], &b\"upgrade\"[..]).unwrap());",
          "",
          "[Added Lines]",
          "313:     pub fn raw_print<W: Write>(",
          "314:         mut self,",
          "315:         mut writer: W,",
          "316:         http_version: HTTPVersion,",
          "317:         request_headers: &[Header],",
          "318:         do_not_send_body: bool,",
          "319:         upgrade: Option<&str>,",
          "320:     ) -> IoResult<()> {",
          "321:         let mut transfer_encoding = Some(choose_transfer_encoding(",
          "322:             request_headers,",
          "323:             &http_version,",
          "324:             &self.data_length,",
          "326:             self.chunked_threshold(),",
          "327:         ));",
          "330:         if self",
          "331:             .headers",
          "332:             .iter()",
          "333:             .find(|h| h.field.equiv(&\"Date\"))",
          "334:             .is_none()",
          "335:         {",
          "340:         if self",
          "341:             .headers",
          "342:             .iter()",
          "343:             .find(|h| h.field.equiv(&\"Server\"))",
          "344:             .is_none()",
          "345:         {",
          "346:             self.headers.insert(",
          "347:                 0,",
          "348:                 Header::from_bytes(&b\"Server\"[..], &b\"tiny-http (Rust)\"[..]).unwrap(),",
          "354:             self.headers.insert(",
          "355:                 0,",
          "356:                 Header::from_bytes(&b\"Upgrade\"[..], upgrade.as_bytes()).unwrap(),",
          "357:             );",
          "358:             self.headers.insert(",
          "359:                 0,",
          "360:                 Header::from_bytes(&b\"Connection\"[..], &b\"upgrade\"[..]).unwrap(),",
          "361:             );",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "315:                 try!(self.reader.read_to_end(&mut buf));",
          "316:                 let l = buf.len();",
          "317:                 (Box::new(Cursor::new(buf)) as Box<Read>, Some(l))",
          "319:             _ => (Box::new(self.reader) as Box<Read>, None),",
          "320:         };",
          "326:                 100...199 | 204 | 304 => true,",
          "328:             };",
          "331:         match transfer_encoding {",
          "338:             Some(TransferEncoding::Identity) => {",
          "339:                 assert!(data_length.is_some());",
          "340:                 let data_length = data_length.unwrap();",
          "342:                 self.headers.push(",
          "344:                 )",
          "348:         };",
          "355:         if !do_not_send_body {",
          "356:             match transfer_encoding {",
          "358:                 Some(TransferEncoding::Chunked) => {",
          "359:                     use chunked_transfer::Encoder;",
          "361:                     let mut writer = Encoder::new(writer);",
          "362:                     try!(io::copy(&mut reader, &mut writer));",
          "365:                 Some(TransferEncoding::Identity) => {",
          "366:                     use util::EqualReader;",
          "",
          "[Removed Lines]",
          "318:             },",
          "323:         let do_not_send_body = do_not_send_body ||",
          "324:             match self.status_code.0 {",
          "327:                 _ => false",
          "332:             Some(TransferEncoding::Chunked) => {",
          "333:                 self.headers.push(",
          "334:                     Header::from_bytes(&b\"Transfer-Encoding\"[..], &b\"chunked\"[..]).unwrap()",
          "335:                 )",
          "336:             },",
          "343:                     Header::from_bytes(&b\"Content-Length\"[..], format!(\"{}\", data_length).as_bytes()).unwrap()",
          "345:             },",
          "347:             _ => ()",
          "351:         try!(write_message_header(writer.by_ref(), &http_version,",
          "352:             &self.status_code, &self.headers));",
          "363:                 },",
          "",
          "[Added Lines]",
          "375:             }",
          "380:         let do_not_send_body = do_not_send_body",
          "381:             || match self.status_code.0 {",
          "384:                 _ => false,",
          "389:             Some(TransferEncoding::Chunked) => self",
          "390:                 .headers",
          "391:                 .push(Header::from_bytes(&b\"Transfer-Encoding\"[..], &b\"chunked\"[..]).unwrap()),",
          "398:                     Header::from_bytes(",
          "399:                         &b\"Content-Length\"[..],",
          "400:                         format!(\"{}\", data_length).as_bytes(),",
          "401:                     )",
          "402:                     .unwrap(),",
          "404:             }",
          "406:             _ => (),",
          "410:         try!(write_message_header(",
          "411:             writer.by_ref(),",
          "412:             &http_version,",
          "413:             &self.status_code,",
          "414:             &self.headers",
          "415:         ));",
          "425:                 }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "369:                     let data_length = data_length.unwrap();",
          "371:                     if data_length >= 1 {",
          "374:                         try!(io::copy(&mut equ_reader, &mut writer));",
          "375:                     }",
          "380:             }",
          "381:         }",
          "",
          "[Removed Lines]",
          "372:                         let (mut equ_reader, _) =",
          "373:                             EqualReader::new(reader.by_ref(), data_length);",
          "376:                 },",
          "378:                 _ => ()",
          "",
          "[Added Lines]",
          "434:                         let (mut equ_reader, _) = EqualReader::new(reader.by_ref(), data_length);",
          "437:                 }",
          "439:                 _ => (),",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "384:     }",
          "385: }",
          "389:     pub fn boxed(self) -> ResponseBox {",
          "390:         Response {",
          "",
          "[Removed Lines]",
          "387: impl<R> Response<R> where R: Read + Send + 'static {",
          "",
          "[Added Lines]",
          "447: impl<R> Response<R>",
          "448: where",
          "449:     R: Read + Send + 'static,",
          "450: {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "416: }",
          "418: impl Response<Cursor<Vec<u8>>> {",
          "420:         let data = data.into();",
          "421:         let data_len = data.len();",
          "",
          "[Removed Lines]",
          "419:     pub fn from_data<D>(data: D) -> Response<Cursor<Vec<u8>>> where D: Into<Vec<u8>> {",
          "",
          "[Added Lines]",
          "482:     pub fn from_data<D>(data: D) -> Response<Cursor<Vec<u8>>>",
          "483:     where",
          "484:         D: Into<Vec<u8>>,",
          "485:     {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "429:         )",
          "430:     }",
          "433:         let data = data.into();",
          "434:         let data_len = data.len();",
          "436:         Response::new(",
          "437:             StatusCode(200),",
          "438:             vec![",
          "440:             ],",
          "441:             Cursor::new(data.into_bytes()),",
          "442:             Some(data_len),",
          "",
          "[Removed Lines]",
          "432:     pub fn from_string<S>(data: S) -> Response<Cursor<Vec<u8>>> where S: Into<String> {",
          "439:                 Header::from_bytes(&b\"Content-Type\"[..], &b\"text/plain; charset=UTF-8\"[..]).unwrap()",
          "",
          "[Added Lines]",
          "498:     pub fn from_string<S>(data: S) -> Response<Cursor<Vec<u8>>>",
          "499:     where",
          "500:         S: Into<String>,",
          "501:     {",
          "508:                 Header::from_bytes(&b\"Content-Type\"[..], &b\"text/plain; charset=UTF-8\"[..])",
          "509:                     .unwrap(),",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "448: impl Response<io::Empty> {",
          "451:         Response::new(",
          "452:             status_code.into(),",
          "453:             Vec::with_capacity(0),",
          "",
          "[Removed Lines]",
          "450:     pub fn empty<S>(status_code: S) -> Response<io::Empty> where S: Into<StatusCode> {",
          "",
          "[Added Lines]",
          "520:     pub fn empty<S>(status_code: S) -> Response<io::Empty>",
          "521:     where",
          "522:         S: Into<StatusCode>,",
          "523:     {",
          "",
          "---------------"
        ],
        "src/util/custom_stream.rs||src/util/custom_stream.rs": [
          "File: src/util/custom_stream.rs -> src/util/custom_stream.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "6:     writer: W,",
          "7: }",
          "10:     pub fn new(reader: R, writer: W) -> CustomStream<R, W> {",
          "11:         CustomStream {",
          "12:             reader: reader,",
          "",
          "[Removed Lines]",
          "9: impl<R, W> CustomStream<R, W> where R: Read, W: Write {",
          "",
          "[Added Lines]",
          "9: impl<R, W> CustomStream<R, W>",
          "10: where",
          "11:     R: Read,",
          "12:     W: Write,",
          "13: {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "15:     }",
          "16: }",
          "19:     fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {",
          "20:         self.reader.read(buf)",
          "21:     }",
          "22: }",
          "25:     fn write(&mut self, buf: &[u8]) -> IoResult<usize> {",
          "26:         self.writer.write(buf)",
          "27:     }",
          "",
          "[Removed Lines]",
          "18: impl<R, W> Read for CustomStream<R, W> where R: Read {",
          "24: impl<R, W> Write for CustomStream<R, W> where W: Write {",
          "",
          "[Added Lines]",
          "22: impl<R, W> Read for CustomStream<R, W>",
          "23: where",
          "24:     R: Read,",
          "25: {",
          "31: impl<R, W> Write for CustomStream<R, W>",
          "32: where",
          "33:     W: Write,",
          "34: {",
          "",
          "---------------"
        ],
        "src/util/equal_reader.rs||src/util/equal_reader.rs": [
          "File: src/util/equal_reader.rs -> src/util/equal_reader.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: use std::io::Read;",
          "12:     reader: R,",
          "13:     size: usize,",
          "14:     last_read_signal: Sender<IoResult<()>>,",
          "15: }",
          "18:     pub fn new(reader: R, size: usize) -> (EqualReader<R>, Receiver<IoResult<()>>) {",
          "19:         let (tx, rx) = channel();",
          "",
          "[Removed Lines]",
          "1: use std::sync::mpsc::channel;",
          "2: use std::io::Result as IoResult;",
          "3: use std::sync::mpsc::{Sender, Receiver};",
          "11: pub struct EqualReader<R> where R: Read {",
          "17: impl<R> EqualReader<R> where R: Read {",
          "",
          "[Added Lines]",
          "2: use std::io::Result as IoResult;",
          "3: use std::sync::mpsc::channel;",
          "4: use std::sync::mpsc::{Receiver, Sender};",
          "11: pub struct EqualReader<R>",
          "12: where",
          "13:     R: Read,",
          "14: {",
          "20: impl<R> EqualReader<R>",
          "21: where",
          "22:     R: Read,",
          "23: {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "28:     }",
          "29: }",
          "32:     fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {",
          "33:         if self.size == 0 {",
          "34:             return Ok(0);",
          "",
          "[Removed Lines]",
          "31: impl<R> Read for EqualReader<R> where R: Read {",
          "",
          "[Added Lines]",
          "37: impl<R> Read for EqualReader<R>",
          "38: where",
          "39:     R: Read,",
          "40: {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "37:         let buf = if buf.len() < self.size {",
          "38:             buf",
          "39:         } else {",
          "41:         };",
          "43:         match self.reader.read(buf) {",
          "46:         }",
          "47:     }",
          "48: }",
          "51:     fn drop(&mut self) {",
          "52:         let mut remaining_to_read = self.size;",
          "54:         while remaining_to_read > 0 {",
          "57:             match self.reader.read(&mut buf) {",
          "61:             }",
          "62:         }",
          "63:     }",
          "",
          "[Removed Lines]",
          "40:             &mut buf[.. self.size]",
          "44:             Ok(len) => { self.size -= len; Ok(len) },",
          "45:             err @ Err(_) => err",
          "50: impl<R> Drop for EqualReader<R> where R: Read {",
          "55:             let mut buf = vec![0 ; remaining_to_read];",
          "58:                 Err(e) => { self.last_read_signal.send(Err(e)).ok(); break; }",
          "59:                 Ok(0) => { self.last_read_signal.send(Ok(())).ok(); break; },",
          "60:                 Ok(other) => { remaining_to_read -= other; }",
          "",
          "[Added Lines]",
          "49:             &mut buf[..self.size]",
          "53:             Ok(len) => {",
          "54:                 self.size -= len;",
          "55:                 Ok(len)",
          "56:             }",
          "57:             err @ Err(_) => err,",
          "62: impl<R> Drop for EqualReader<R>",
          "63: where",
          "64:     R: Read,",
          "65: {",
          "70:             let mut buf = vec![0; remaining_to_read];",
          "73:                 Err(e) => {",
          "74:                     self.last_read_signal.send(Err(e)).ok();",
          "75:                     break;",
          "76:                 }",
          "77:                 Ok(0) => {",
          "78:                     self.last_read_signal.send(Ok(())).ok();",
          "79:                     break;",
          "80:                 }",
          "81:                 Ok(other) => {",
          "82:                     remaining_to_read -= other;",
          "83:                 }",
          "",
          "---------------"
        ],
        "src/util/messages_queue.rs||src/util/messages_queue.rs": [
          "File: src/util/messages_queue.rs -> src/util/messages_queue.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use std::collections::VecDeque;",
          "2: use std::time::{Duration, Instant};",
          "6:     queue: Mutex<VecDeque<T>>,",
          "7:     condvar: Condvar,",
          "8: }",
          "11:     pub fn with_capacity(capacity: usize) -> Arc<MessagesQueue<T>> {",
          "12:         Arc::new(MessagesQueue {",
          "13:             queue: Mutex::new(VecDeque::with_capacity(capacity)),",
          "",
          "[Removed Lines]",
          "3: use std::sync::{Arc, Mutex, Condvar};",
          "5: pub struct MessagesQueue<T> where T: Send {",
          "10: impl<T> MessagesQueue<T> where T: Send {",
          "",
          "[Added Lines]",
          "2: use std::sync::{Arc, Condvar, Mutex};",
          "5: pub struct MessagesQueue<T>",
          "6: where",
          "7:     T: Send,",
          "8: {",
          "13: impl<T> MessagesQueue<T>",
          "14: where",
          "15:     T: Send,",
          "16: {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54:             let (_queue, result) = self.condvar.wait_timeout(queue, timeout).unwrap();",
          "55:             queue = _queue;",
          "56:             let sleep_time = now.elapsed();",
          "60:                 return None;",
          "61:             }",
          "62:         }",
          "",
          "[Removed Lines]",
          "57:             duration = if duration > sleep_time { duration - sleep_time } else { Duration::from_millis(0) };",
          "58:             if result.timed_out() ||",
          "59:                (duration.as_secs() == 0 && duration.subsec_nanos() < 1000000) {",
          "",
          "[Added Lines]",
          "63:             duration = if duration > sleep_time {",
          "64:                 duration - sleep_time",
          "65:             } else {",
          "66:                 Duration::from_millis(0)",
          "67:             };",
          "68:             if result.timed_out() || (duration.as_secs() == 0 && duration.subsec_nanos() < 1000000)",
          "69:             {",
          "",
          "---------------"
        ],
        "src/util/mod.rs||src/util/mod.rs": [
          "File: src/util/mod.rs -> src/util/mod.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: pub use self::equal_reader::EqualReader;",
          "3: pub use self::messages_queue::MessagesQueue;",
          "4: pub use self::refined_tcp_stream::RefinedTcpStream;",
          "7: pub use self::task_pool::TaskPool;",
          "9: use std::str::FromStr;",
          "",
          "[Removed Lines]",
          "5: pub use self::sequential::{SequentialReaderBuilder, SequentialReader};",
          "6: pub use self::sequential::{SequentialWriterBuilder, SequentialWriter};",
          "",
          "[Added Lines]",
          "5: pub use self::sequential::{SequentialReader, SequentialReaderBuilder};",
          "6: pub use self::sequential::{SequentialWriter, SequentialWriterBuilder};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "23: pub fn parse_header_value<'a>(input: &'a str) -> Vec<(&'a str, f32)> {",
          "37:                 }",
          "38:             }",
          "44: }",
          "46: #[cfg(test)]",
          "",
          "[Removed Lines]",
          "24:     input.split(',').filter_map(|elem| {",
          "25:         let mut params = elem.split(';');",
          "27:         let t = params.next();",
          "28:         if t.is_none() { return None; }",
          "30:         let mut value = 1.0f32;",
          "32:         for p in params {",
          "33:             if p.trim_left().starts_with(\"q=\") {",
          "34:                 match FromStr::from_str(&p.trim_left()[2..].trim()) {",
          "35:                     Ok(val) => { value = val; break },",
          "36:                     _ => ()",
          "39:         }",
          "41:         Some((t.unwrap().trim(), value))",
          "43:     }).collect()",
          "",
          "[Added Lines]",
          "24:     input",
          "25:         .split(',')",
          "26:         .filter_map(|elem| {",
          "27:             let mut params = elem.split(';');",
          "29:             let t = params.next();",
          "30:             if t.is_none() {",
          "31:                 return None;",
          "32:             }",
          "34:             let mut value = 1.0f32;",
          "36:             for p in params {",
          "37:                 if p.trim_left().starts_with(\"q=\") {",
          "38:                     match FromStr::from_str(&p.trim_left()[2..].trim()) {",
          "39:                         Ok(val) => {",
          "40:                             value = val;",
          "41:                             break;",
          "42:                         }",
          "43:                         _ => (),",
          "44:                     }",
          "48:             Some((t.unwrap().trim(), value))",
          "49:         })",
          "50:         .collect()",
          "",
          "---------------"
        ],
        "src/util/refined_tcp_stream.rs||src/util/refined_tcp_stream.rs": [
          "File: src/util/refined_tcp_stream.rs -> src/util/refined_tcp_stream.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: use std::io::Result as IoResult;",
          "7: #[cfg(feature = \"ssl\")]",
          "8: use openssl::ssl::SslStream;",
          "10: pub struct RefinedTcpStream {",
          "11:     stream: Stream,",
          "",
          "[Removed Lines]",
          "1: use std::io::{Read, Write};",
          "3: use std::net::{SocketAddr, TcpStream, Shutdown};",
          "5: #[cfg(feature = \"ssl\")]",
          "6: use std::sync::{Arc, Mutex};",
          "",
          "[Added Lines]",
          "2: use std::io::{Read, Write};",
          "3: use std::net::{Shutdown, SocketAddr, TcpStream};",
          "7: #[cfg(feature = \"ssl\")]",
          "8: use std::sync::{Arc, Mutex};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37: impl RefinedTcpStream {",
          "38:     pub fn new<S>(stream: S) -> (RefinedTcpStream, RefinedTcpStream)",
          "40:     {",
          "41:         let stream = stream.into();",
          "",
          "[Removed Lines]",
          "39:         where S: Into<Stream>",
          "",
          "[Added Lines]",
          "39:     where",
          "40:         S: Into<Stream>,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "88:                 Stream::Http(ref mut stream) => stream.shutdown(Shutdown::Read).ok(),",
          "89:                 #[cfg(feature = \"ssl\")]",
          "91:             };",
          "92:         }",
          "",
          "[Removed Lines]",
          "90:                 Stream::Https(ref mut stream) => stream.lock().unwrap().get_mut().shutdown(Shutdown::Read).ok(),",
          "",
          "[Added Lines]",
          "91:                 Stream::Https(ref mut stream) => stream",
          "92:                     .lock()",
          "93:                     .unwrap()",
          "94:                     .get_mut()",
          "95:                     .shutdown(Shutdown::Read)",
          "96:                     .ok(),",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "97:                 Stream::Http(ref mut stream) => stream.shutdown(Shutdown::Write).ok(),",
          "98:                 #[cfg(feature = \"ssl\")]",
          "100:             };",
          "101:         }",
          "102:     }",
          "",
          "[Removed Lines]",
          "99:                 Stream::Https(ref mut stream) => stream.lock().unwrap().get_mut().shutdown(Shutdown::Write).ok(),",
          "",
          "[Added Lines]",
          "105:                 Stream::Https(ref mut stream) => stream",
          "106:                     .lock()",
          "107:                     .unwrap()",
          "108:                     .get_mut()",
          "109:                     .shutdown(Shutdown::Write)",
          "110:                     .ok(),",
          "",
          "---------------"
        ],
        "src/util/sequential.rs||src/util/sequential.rs": [
          "File: src/util/sequential.rs -> src/util/sequential.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: use std::io::Result as IoResult;",
          "2: use std::io::{Read, Write};",
          "5: use std::sync::mpsc::channel;",
          "6: use std::sync::{Arc, Mutex};",
          "8: use std::mem;",
          "11:     inner: SequentialReaderBuilderInner<R>,",
          "12: }",
          "15:     First(R),",
          "16:     NotFirst(Receiver<R>),",
          "17: }",
          "20:     inner: SequentialReaderInner<R>,",
          "21:     next: Sender<R>,",
          "22: }",
          "25:     MyTurn(R),",
          "26:     Waiting(Receiver<R>),",
          "27:     Empty,",
          "28: }",
          "31:     writer: Arc<Mutex<W>>,",
          "32:     next_trigger: Option<Receiver<()>>,",
          "33: }",
          "36:     trigger: Option<Receiver<()>>,",
          "37:     writer: Arc<Mutex<W>>,",
          "38:     on_finish: Sender<()>,",
          "",
          "[Removed Lines]",
          "4: use std::sync::mpsc::{Receiver, Sender};",
          "10: pub struct SequentialReaderBuilder<R> where R: Read + Send {",
          "14: enum SequentialReaderBuilderInner<R> where R: Read + Send {",
          "19: pub struct SequentialReader<R> where R: Read + Send {",
          "24: enum SequentialReaderInner<R> where R: Read + Send {",
          "30: pub struct SequentialWriterBuilder<W> where W: Write + Send {",
          "35: pub struct SequentialWriter<W> where W: Write + Send {",
          "",
          "[Added Lines]",
          "5: use std::sync::mpsc::{Receiver, Sender};",
          "10: pub struct SequentialReaderBuilder<R>",
          "11: where",
          "12:     R: Read + Send,",
          "13: {",
          "17: enum SequentialReaderBuilderInner<R>",
          "18: where",
          "19:     R: Read + Send,",
          "20: {",
          "25: pub struct SequentialReader<R>",
          "26: where",
          "27:     R: Read + Send,",
          "28: {",
          "33: enum SequentialReaderInner<R>",
          "34: where",
          "35:     R: Read + Send,",
          "36: {",
          "42: pub struct SequentialWriterBuilder<W>",
          "43: where",
          "44:     W: Write + Send,",
          "45: {",
          "50: pub struct SequentialWriter<W>",
          "51: where",
          "52:     W: Write + Send,",
          "53: {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:         let inner = mem::replace(&mut self.inner, SequentialReaderBuilderInner::NotFirst(rx));",
          "66:         match inner {",
          "80:         }",
          "81:     }",
          "82: }",
          "",
          "[Removed Lines]",
          "67:             SequentialReaderBuilderInner::First(reader) => {",
          "68:                 Some(SequentialReader {",
          "69:                     inner: SequentialReaderInner::MyTurn(reader),",
          "70:                     next: tx,",
          "71:                 })",
          "72:             },",
          "74:             SequentialReaderBuilderInner::NotFirst(previous) => {",
          "75:                 Some(SequentialReader {",
          "76:                     inner: SequentialReaderInner::Waiting(previous),",
          "77:                     next: tx,",
          "78:                 })",
          "79:             },",
          "",
          "[Added Lines]",
          "85:             SequentialReaderBuilderInner::First(reader) => Some(SequentialReader {",
          "86:                 inner: SequentialReaderInner::MyTurn(reader),",
          "87:                 next: tx,",
          "88:             }),",
          "90:             SequentialReaderBuilderInner::NotFirst(previous) => Some(SequentialReader {",
          "91:                 inner: SequentialReaderInner::Waiting(previous),",
          "92:                 next: tx,",
          "93:             }),",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "126:     }",
          "127: }",
          "130:     fn drop(&mut self) {",
          "131:         let inner = mem::replace(&mut self.inner, SequentialReaderInner::Empty);",
          "133:         match inner {",
          "134:             SequentialReaderInner::MyTurn(reader) => {",
          "135:                 self.next.send(reader).ok();",
          "137:             SequentialReaderInner::Waiting(recv) => {",
          "138:                 let reader = recv.recv().unwrap();",
          "139:                 self.next.send(reader).ok();",
          "141:             SequentialReaderInner::Empty => (),",
          "142:         }",
          "143:     }",
          "144: }",
          "147:     fn drop(&mut self) {",
          "148:         self.on_finish.send(()).ok();",
          "149:     }",
          "",
          "[Removed Lines]",
          "129: impl<R> Drop for SequentialReader<R> where R: Read + Send {",
          "136:             },",
          "140:             },",
          "146: impl<W> Drop for SequentialWriter<W> where W: Write + Send {",
          "",
          "[Added Lines]",
          "143: impl<R> Drop for SequentialReader<R>",
          "144: where",
          "145:     R: Read + Send,",
          "146: {",
          "153:             }",
          "157:             }",
          "163: impl<W> Drop for SequentialWriter<W>",
          "164: where",
          "165:     W: Write + Send,",
          "166: {",
          "",
          "---------------"
        ],
        "src/util/task_pool.rs||src/util/task_pool.rs": [
          "File: src/util/task_pool.rs -> src/util/task_pool.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: use std::collections::VecDeque;",
          "5: use std::thread;",
          "",
          "[Removed Lines]",
          "1: use std::sync::{Arc, Mutex, Condvar};",
          "2: use std::sync::atomic::{Ordering, AtomicUsize};",
          "4: use std::time::Duration;",
          "",
          "[Added Lines]",
          "2: use std::sync::atomic::{AtomicUsize, Ordering};",
          "3: use std::sync::{Arc, Condvar, Mutex};",
          "5: use std::time::Duration;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "30: static MIN_THREADS: usize = 4;",
          "32: struct Registration<'a> {",
          "34: }",
          "36: impl<'a> Registration<'a> {",
          "",
          "[Removed Lines]",
          "33:     nb: &'a AtomicUsize",
          "",
          "[Added Lines]",
          "33:     nb: &'a AtomicUsize,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "102:                         }",
          "103:                         let _waiting_guard = Registration::new(&sharing.waiting_tasks);",
          "119:                         if !received && todo.is_empty() {",
          "120:                             return;",
          "",
          "[Removed Lines]",
          "105:                         let received = if sharing.active_tasks.load(Ordering::Acquire)",
          "106:                                                 <= MIN_THREADS",
          "107:                         {",
          "108:                             todo = sharing.condvar.wait(todo).unwrap();",
          "109:                             true",
          "111:                         } else {",
          "112:                             let (new_lock, waitres) = sharing.condvar",
          "113:                                                              .wait_timeout(todo, Duration::from_millis(5000))",
          "114:                                                              .unwrap();",
          "115:                             todo = new_lock;",
          "116:                             !waitres.timed_out()",
          "117:                         };",
          "",
          "[Added Lines]",
          "104:                         let received =",
          "105:                             if sharing.active_tasks.load(Ordering::Acquire) <= MIN_THREADS {",
          "106:                                 todo = sharing.condvar.wait(todo).unwrap();",
          "107:                                 true",
          "108:                             } else {",
          "109:                                 let (new_lock, waitres) = sharing",
          "110:                                     .condvar",
          "111:                                     .wait_timeout(todo, Duration::from_millis(5000))",
          "112:                                     .unwrap();",
          "113:                                 todo = new_lock;",
          "114:                                 !waitres.timed_out()",
          "115:                             };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "133: impl Drop for TaskPool {",
          "134:     fn drop(&mut self) {",
          "136:         self.sharing.condvar.notify_all();",
          "137:     }",
          "138: }",
          "",
          "[Removed Lines]",
          "135:         self.sharing.active_tasks.store(999999999, Ordering::Release);",
          "",
          "[Added Lines]",
          "133:         self.sharing",
          "134:             .active_tasks",
          "135:             .store(999999999, Ordering::Release);",
          "",
          "---------------"
        ],
        "tests/input-tests.rs||tests/input-tests.rs": [
          "File: tests/input-tests.rs -> tests/input-tests.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: extern crate tiny_http;",
          "3: use std::io::{Read, Write};",
          "5: use std::net::Shutdown;",
          "6: use std::thread;",
          "8: #[allow(dead_code)]",
          "",
          "[Removed Lines]",
          "4: use std::sync::mpsc;",
          "",
          "[Added Lines]",
          "5: use std::sync::mpsc;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "62:     let mut content = vec![0; 12];",
          "63:     client.read(&mut content).unwrap();",
          "66:     (write!(client, \"hello\")).unwrap();",
          "67:     client.flush().unwrap();",
          "",
          "[Removed Lines]",
          "64:     assert!(&content[9..].starts_with(b\"100\"));   // 100 status code",
          "",
          "[Added Lines]",
          "64:     assert!(&content[9..].starts_with(b\"100\")); // 100 status code",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "80:     let mut content = String::new();",
          "81:     client.read_to_string(&mut content).unwrap();",
          "83: }",
          "",
          "[Removed Lines]",
          "82:     assert!(&content[9..].starts_with(\"417\"));   // 417 status code",
          "",
          "[Added Lines]",
          "82:     assert!(&content[9..].starts_with(\"417\")); // 417 status code",
          "",
          "---------------"
        ],
        "tests/network.rs||tests/network.rs": [
          "File: tests/network.rs -> tests/network.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: extern crate tiny_http;",
          "4: use std::io::{Read, Write};",
          "5: use std::thread;",
          "6: use std::time::Duration;",
          "",
          "[Removed Lines]",
          "3: use std::net::{TcpStream, Shutdown};",
          "",
          "[Added Lines]",
          "4: use std::net::{Shutdown, TcpStream};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87:     (write!(client, \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\")).unwrap();",
          "88:     (write!(client, \"GET /hello HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\")).unwrap();",
          "92:     let mut data = String::new();",
          "",
          "[Removed Lines]",
          "89:     (write!(client, \"GET /world HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n\")).unwrap();",
          "",
          "[Added Lines]",
          "89:     (write!(",
          "90:         client,",
          "91:         \"GET /world HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n\"",
          "92:     ))",
          "93:     .unwrap();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "106:     });",
          "111:     let mut content = String::new();",
          "112:     client.read_to_string(&mut content).unwrap();",
          "114: }",
          "116: #[test]",
          "",
          "[Removed Lines]",
          "108:     (write!(client, \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n\")).unwrap();",
          "113:     assert!(&content[9..].starts_with(\"5\"));   // 5xx status code",
          "",
          "[Added Lines]",
          "112:     (write!(",
          "113:         client,",
          "114:         \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n\"",
          "115:     ))",
          "116:     .unwrap();",
          "121:     assert!(&content[9..].starts_with(\"5\")); // 5xx status code",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "118:     let (server, mut client) = support::new_one_server_one_client();",
          "120:     (write!(client, \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\")).unwrap();",
          "123:     thread::spawn(move || {",
          "124:         let rq1 = server.recv().unwrap();",
          "125:         let rq2 = server.recv().unwrap();",
          "127:         thread::spawn(move || {",
          "129:         });",
          "131:         thread::sleep(Duration::from_millis(100));",
          "133:         thread::spawn(move || {",
          "135:         });",
          "136:     });",
          "",
          "[Removed Lines]",
          "121:     (write!(client, \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n\")).unwrap();",
          "128:             rq2.respond(tiny_http::Response::from_string(format!(\"second request\"))).unwrap();",
          "134:             rq1.respond(tiny_http::Response::from_string(format!(\"first request\"))).unwrap();",
          "",
          "[Added Lines]",
          "129:     (write!(",
          "130:         client,",
          "131:         \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n\"",
          "132:     ))",
          "133:     .unwrap();",
          "140:             rq2.respond(tiny_http::Response::from_string(format!(\"second request\")))",
          "141:                 .unwrap();",
          "147:             rq1.respond(tiny_http::Response::from_string(format!(\"first request\")))",
          "148:                 .unwrap();",
          "",
          "---------------"
        ],
        "tests/simple-test.rs||tests/simple-test.rs": [
          "File: tests/simple-test.rs -> tests/simple-test.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #[test]",
          "9: fn basic_handling() {",
          "10:     let (server, mut stream) = support::new_one_server_one_client();",
          "13:     let request = server.recv().unwrap();",
          "14:     assert!(*request.method() == tiny_http::Method::Get);",
          "18:     server.try_recv().unwrap();",
          "",
          "[Removed Lines]",
          "11:     write!(stream, \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n\").unwrap();",
          "16:     request.respond(tiny_http::Response::from_string(format!(\"hello world\"))).unwrap();",
          "",
          "[Added Lines]",
          "11:     write!(",
          "12:         stream,",
          "13:         \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n\"",
          "14:     )",
          "15:     .unwrap();",
          "20:     request",
          "21:         .respond(tiny_http::Response::from_string(format!(\"hello world\")))",
          "22:         .unwrap();",
          "",
          "---------------"
        ],
        "tests/support/mod.rs||tests/support/mod.rs": [
          "File: tests/support/mod.rs -> tests/support/mod.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:                 Some(rq) => {",
          "28:                     let response = tiny_http::Response::from_string(\"hello world\".to_string());",
          "29:                     rq.respond(response).unwrap();",
          "32:             };",
          "34:             thread::sleep(Duration::from_millis(20));",
          "",
          "[Removed Lines]",
          "30:                 },",
          "31:                 _ => ()",
          "",
          "[Added Lines]",
          "30:                 }",
          "31:                 _ => (),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "43db7f0fd4632d85e802c8b5ac900aa2895e7e23",
      "candidate_info": {
        "commit_hash": "43db7f0fd4632d85e802c8b5ac900aa2895e7e23",
        "repo": "tiny-http/tiny-http",
        "commit_url": "https://github.com/tiny-http/tiny-http/commit/43db7f0fd4632d85e802c8b5ac900aa2895e7e23",
        "files": [
          "src/common.rs",
          "tests/network.rs"
        ],
        "message": "Run rustfmt",
        "before_after_code_files": [
          "src/common.rs||src/common.rs",
          "tests/network.rs||tests/network.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/common.rs||src/common.rs"
          ],
          "candidate": [
            "src/common.rs||src/common.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/common.rs||src/common.rs": [
          "File: src/common.rs -> src/common.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "242:         if s.contains(char::is_whitespace) {",
          "243:             Err(())",
          "244:         } else {",
          "248:         }",
          "249:     }",
          "250: }",
          "",
          "[Removed Lines]",
          "245:             AsciiString::from_ascii(s)",
          "246:                 .map(HeaderField)",
          "247:                 .map_err(|_| ())",
          "",
          "[Added Lines]",
          "245:             AsciiString::from_ascii(s).map(HeaderField).map_err(|_| ())",
          "",
          "---------------"
        ],
        "tests/network.rs||tests/network.rs": [
          "File: tests/network.rs -> tests/network.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "159: fn no_transfer_encoding_on_204() {",
          "160:     let (server, mut client) = support::new_one_server_one_client();",
          "164:     thread::spawn(move || {",
          "165:         let rq = server.recv().unwrap();",
          "",
          "[Removed Lines]",
          "162:     (write!(client, \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nTE: chunked\\r\\nConnection: close\\r\\n\\r\\n\")).unwrap();",
          "",
          "[Added Lines]",
          "162:     (write!(",
          "163:         client,",
          "164:         \"GET / HTTP/1.1\\r\\nHost: localhost\\r\\nTE: chunked\\r\\nConnection: close\\r\\n\\r\\n\"",
          "165:     ))",
          "166:     .unwrap();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "46a14ca45be8ef7b9295f3321d1d4902e56a77f0",
      "candidate_info": {
        "commit_hash": "46a14ca45be8ef7b9295f3321d1d4902e56a77f0",
        "repo": "tiny-http/tiny-http",
        "commit_url": "https://github.com/tiny-http/tiny-http/commit/46a14ca45be8ef7b9295f3321d1d4902e56a77f0",
        "files": [
          "src/common.rs"
        ],
        "message": "Header fields can't contain whitespace.",
        "before_after_code_files": [
          "src/common.rs||src/common.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/common.rs||src/common.rs"
          ],
          "candidate": [
            "src/common.rs||src/common.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/common.rs||src/common.rs": [
          "File: src/common.rs -> src/common.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "239:     type Err = ();",
          "241:     fn from_str(s: &str) -> Result<HeaderField, ()> {",
          "245:     }",
          "246: }",
          "",
          "[Removed Lines]",
          "242:         AsciiString::from_ascii(s)",
          "243:             .map(HeaderField)",
          "244:             .map_err(|_| ())",
          "",
          "[Added Lines]",
          "242:         if s.contains(char::is_whitespace) {",
          "243:             Err(())",
          "244:         } else {",
          "245:             AsciiString::from_ascii(s)",
          "246:                 .map(HeaderField)",
          "247:                 .map_err(|_| ())",
          "248:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "468:     #[test]",
          "469:     fn test_strict_headers() {",
          "472:     }",
          "473: }",
          "",
          "[Removed Lines]",
          "470:         let smuggled = \"Transfer-Encoding : chunked\".parse::<Header>().unwrap();",
          "471:         assert!(!smuggled.field.equiv(\"Transfer-Encoding\"));",
          "",
          "[Added Lines]",
          "474:         assert!(\"Transfer-Encoding : chunked\".parse::<Header>().is_err());",
          "475:         assert!(\" Transfer-Encoding: chunked\".parse::<Header>().is_err());",
          "476:         assert!(\"Transfer Encoding: chunked\".parse::<Header>().is_err());",
          "477:         assert!(\" Transfer\\tEncoding : chunked\".parse::<Header>().is_err());",
          "478:         assert!(\"Transfer-Encoding: chunked\".parse::<Header>().is_ok());",
          "479:         assert!(\"Transfer-Encoding: chunked \".parse::<Header>().is_ok());",
          "480:         assert!(\"Transfer-Encoding:   chunked \".parse::<Header>().is_ok());",
          "",
          "---------------"
        ]
      }
    }
  ]
}
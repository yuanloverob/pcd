{
  "cve_id": "CVE-2021-32715",
  "cve_desc": "hyper is an HTTP library for rust. hyper's HTTP/1 server code had a flaw that incorrectly parses and accepts requests with a `Content-Length` header with a prefixed plus sign, when it should have been rejected as illegal. This combined with an upstream HTTP proxy that doesn't parse such `Content-Length` headers, but forwards them, can result in \"request smuggling\" or \"desync attacks\". The flaw exists in all prior versions of hyper prior to 0.14.10, if built with `rustc` v1.5.0 or newer. The vulnerability is patched in hyper version 0.14.10. Two workarounds exist: One may reject requests manually that contain a plus sign prefix in the `Content-Length` header or ensure any upstream proxy handles `Content-Length` headers with a plus sign prefix.",
  "repo": "rust-lang/rust",
  "patch_hash": "123a83326fb95366e94a3be1a74775df4db97739",
  "patch_info": {
    "commit_hash": "123a83326fb95366e94a3be1a74775df4db97739",
    "repo": "rust-lang/rust",
    "commit_url": "https://github.com/rust-lang/rust/pull/28826/commits/123a83326fb95366e94a3be1a74775df4db97739",
    "files": [
      "src/libcore/num/mod.rs",
      "src/libcoretest/num/mod.rs"
    ],
    "message": "integer parsing should accept leading plus",
    "before_after_code_files": [
      "src/libcore/num/mod.rs||src/libcore/num/mod.rs",
      "src/libcoretest/num/mod.rs||src/libcoretest/num/mod.rs"
    ]
  },
  "patch_diff": {
    "src/libcore/num/mod.rs||src/libcore/num/mod.rs": [
      "File: src/libcore/num/mod.rs -> src/libcore/num/mod.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "1388:     let src = src.as_bytes();",
      "1415:                 None => return Err(PIE { kind: InvalidDigit }),",
      "1416:             };",
      "1432:         }",
      "1433:     }",
      "1434: }",
      "",
      "[Removed Lines]",
      "1390:     match (src[0], &src[1..])  {",
      "1391:         (b'-', digits) if digits.is_empty() => Err(PIE { kind: Empty }),",
      "1392:         (b'-', digits) if is_signed_ty => {",
      "1394:             let mut result = T::from_u32(0);",
      "1395:             for &c in digits {",
      "1396:                 let x = match (c as char).to_digit(radix) {",
      "1397:                     Some(x) => x,",
      "1398:                     None => return Err(PIE { kind: InvalidDigit }),",
      "1399:                 };",
      "1400:                 result = match result.checked_mul(radix) {",
      "1401:                     Some(result) => result,",
      "1402:                     None => return Err(PIE { kind: Underflow }),",
      "1403:                 };",
      "1404:                 result = match result.checked_sub(x) {",
      "1405:                     Some(result) => result,",
      "1406:                     None => return Err(PIE { kind: Underflow }),",
      "1407:                 };",
      "1408:             }",
      "1409:             Ok(result)",
      "1410:         },",
      "1411:         (c, digits) => {",
      "1413:             let mut result = match (c as char).to_digit(radix) {",
      "1414:                 Some(x) => T::from_u32(x),",
      "1417:             for &c in digits {",
      "1418:                 let x = match (c as char).to_digit(radix) {",
      "1419:                     Some(x) => x,",
      "1420:                     None => return Err(PIE { kind: InvalidDigit }),",
      "1421:                 };",
      "1422:                 result = match result.checked_mul(radix) {",
      "1423:                     Some(result) => result,",
      "1424:                     None => return Err(PIE { kind: Overflow }),",
      "1425:                 };",
      "1426:                 result = match result.checked_add(x) {",
      "1427:                     Some(result) => result,",
      "1428:                     None => return Err(PIE { kind: Overflow }),",
      "1429:                 };",
      "1430:             }",
      "1431:             Ok(result)",
      "",
      "[Added Lines]",
      "1390:     let (is_positive, digits) = match src[0] {",
      "1391:         b'+' => (true, &src[1..]),",
      "1392:         b'-' if is_signed_ty => (false, &src[1..]),",
      "1393:         _ => (true, src)",
      "1394:     };",
      "1396:     if digits.is_empty() {",
      "1397:         return Err(PIE { kind: Empty });",
      "1398:     }",
      "1400:     let mut result = T::from_u32(0);",
      "1401:     if is_positive {",
      "1403:         for &c in digits {",
      "1404:             let x = match (c as char).to_digit(radix) {",
      "1405:                 Some(x) => x,",
      "1408:             result = match result.checked_mul(radix) {",
      "1409:                 Some(result) => result,",
      "1410:                 None => return Err(PIE { kind: Overflow }),",
      "1411:             };",
      "1412:             result = match result.checked_add(x) {",
      "1413:                 Some(result) => result,",
      "1414:                 None => return Err(PIE { kind: Overflow }),",
      "1415:             };",
      "1416:         }",
      "1417:     } else {",
      "1419:         for &c in digits {",
      "1420:             let x = match (c as char).to_digit(radix) {",
      "1421:                 Some(x) => x,",
      "1422:                 None => return Err(PIE { kind: InvalidDigit }),",
      "1423:             };",
      "1424:             result = match result.checked_mul(radix) {",
      "1425:                 Some(result) => result,",
      "1426:                 None => return Err(PIE { kind: Underflow }),",
      "1427:             };",
      "1428:             result = match result.checked_sub(x) {",
      "1429:                 Some(result) => result,",
      "1430:                 None => return Err(PIE { kind: Underflow }),",
      "1431:             };",
      "1434:     Ok(result)",
      "",
      "---------------"
    ],
    "src/libcoretest/num/mod.rs||src/libcoretest/num/mod.rs": [
      "File: src/libcoretest/num/mod.rs -> src/libcoretest/num/mod.rs",
      "--- Hunk 1 ---",
      "[Context before]",
      "118:         assert_eq!(\"-9223372036854775809\".parse::<i64>().ok(), None);",
      "119:     }",
      "121:     #[test]",
      "122:     fn test_invalid() {",
      "123:         assert_eq!(\"--129\".parse::<i8>().ok(), None);",
      "124:         assert_eq!(\"\u0421\u044a\u0435\u0448\u044c\".parse::<u8>().ok(), None);",
      "125:     }",
      "127:     #[test]",
      "128:     fn test_empty() {",
      "129:         assert_eq!(\"-\".parse::<i8>().ok(), None);",
      "130:         assert_eq!(\"\".parse::<u8>().ok(), None);",
      "131:     }",
      "132: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "121:     #[test]",
      "122:     fn test_leading_plus() {",
      "123:         assert_eq!(\"+127\".parse::<u8>().ok(), Some(127u8));",
      "124:         assert_eq!(\"+9223372036854775807\".parse::<i64>().ok(), Some(9223372036854775807i64));",
      "125:     }",
      "130:         assert_eq!(\"++129\".parse::<i8>().ok(), None);",
      "137:         assert_eq!(\"+\".parse::<i8>().ok(), None);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a9779df1886e18923f40cf0bb67ab72d4e4942df",
      "candidate_info": {
        "commit_hash": "a9779df1886e18923f40cf0bb67ab72d4e4942df",
        "repo": "rust-lang/rust",
        "commit_url": "https://github.com/rust-lang/rust/commit/a9779df1886e18923f40cf0bb67ab72d4e4942df",
        "files": [
          "src/libcore/convert.rs",
          "src/libcore/num/mod.rs",
          "src/libcoretest/lib.rs",
          "src/libcoretest/num/mod.rs",
          "src/libstd/error.rs",
          "src/libstd/lib.rs",
          "src/libstd/num/mod.rs"
        ],
        "message": "Implement RFC 1542\n\ncc #33417",
        "before_after_code_files": [
          "src/libcore/convert.rs||src/libcore/convert.rs",
          "src/libcore/num/mod.rs||src/libcore/num/mod.rs",
          "src/libcoretest/lib.rs||src/libcoretest/lib.rs",
          "src/libcoretest/num/mod.rs||src/libcoretest/num/mod.rs",
          "src/libstd/error.rs||src/libstd/error.rs",
          "src/libstd/lib.rs||src/libstd/lib.rs",
          "src/libstd/num/mod.rs||src/libstd/num/mod.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libcore/num/mod.rs||src/libcore/num/mod.rs",
            "src/libcoretest/num/mod.rs||src/libcoretest/num/mod.rs"
          ],
          "candidate": [
            "src/libcore/num/mod.rs||src/libcore/num/mod.rs",
            "src/libcoretest/num/mod.rs||src/libcoretest/num/mod.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/libcore/convert.rs||src/libcore/convert.rs": [
          "File: src/libcore/convert.rs -> src/libcore/convert.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: #![stable(feature = \"rust1\", since = \"1.0.0\")]",
          "42: use marker::Sized;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "44: use result::Result;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "158:     fn from(T) -> Self;",
          "159: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "168: #[unstable(feature = \"try_from\", issue = \"33417\")]",
          "169: pub trait TryInto<T>: Sized {",
          "171:     type Err;",
          "174:     fn try_into(self) -> Result<T, Self::Err>;",
          "175: }",
          "178: #[unstable(feature = \"try_from\", issue = \"33417\")]",
          "179: pub trait TryFrom<T>: Sized {",
          "181:     type Err;",
          "184:     fn try_from(T) -> Result<Self, Self::Err>;",
          "185: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "216:     fn from(t: T) -> T { t }",
          "217: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "247: #[unstable(feature = \"try_from\", issue = \"33417\")]",
          "248: impl<T, U> TryInto<U> for T where U: TryFrom<T> {",
          "249:     type Err = U::Err;",
          "251:     fn try_into(self) -> Result<U, U::Err> {",
          "252:         U::try_from(self)",
          "253:     }",
          "254: }",
          "",
          "---------------"
        ],
        "src/libcore/num/mod.rs||src/libcore/num/mod.rs": [
          "File: src/libcore/num/mod.rs -> src/libcore/num/mod.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: use char::CharExt;",
          "17: use cmp::PartialOrd;",
          "19: use fmt;",
          "20: use intrinsics;",
          "21: use marker::{Copy, Sized};",
          "",
          "[Removed Lines]",
          "18: use convert::From;",
          "",
          "[Added Lines]",
          "18: use convert::{From, TryFrom};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2341: }",
          "2342: from_str_radix_int_impl! { isize i8 i16 i32 i64 usize u8 u16 u32 u64 }",
          "2344: #[doc(hidden)]",
          "2345: trait FromStrRadixHelper: PartialOrd + Copy {",
          "2346:     fn min_value() -> Self;",
          "2347:     fn from_u32(u: u32) -> Self;",
          "2348:     fn checked_mul(&self, other: u32) -> Option<Self>;",
          "2349:     fn checked_sub(&self, other: u32) -> Option<Self>;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2345: #[unstable(feature = \"try_from\", issue = \"33417\")]",
          "2346: #[derive(Debug, Copy, Clone)]",
          "2347: pub struct TryFromIntError(());",
          "2349: impl TryFromIntError {",
          "2350:     #[unstable(feature = \"int_error_internals\",",
          "2351:                reason = \"available through Error trait and this method should \\",
          "2352:                          not be exposed publicly\",",
          "2353:                issue = \"0\")]",
          "2354:     #[doc(hidden)]",
          "2355:     pub fn __description(&self) -> &str {",
          "2356:         \"out of range integral type conversion attempted\"",
          "2357:     }",
          "2358: }",
          "2360: #[unstable(feature = \"try_from\", issue = \"33417\")]",
          "2361: impl fmt::Display for TryFromIntError {",
          "2362:     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {",
          "2363:         self.__description().fmt(fmt)",
          "2364:     }",
          "2365: }",
          "2367: macro_rules! same_sign_from_int_impl {",
          "2368:     ($storage:ty, $target:ty, $($source:ty),*) => {$(",
          "2369:         #[stable(feature = \"rust1\", since = \"1.0.0\")]",
          "2370:         impl TryFrom<$source> for $target {",
          "2371:             type Err = TryFromIntError;",
          "2373:             fn try_from(u: $source) -> Result<$target, TryFromIntError> {",
          "2374:                 let min = <$target as FromStrRadixHelper>::min_value() as $storage;",
          "2375:                 let max = <$target as FromStrRadixHelper>::max_value() as $storage;",
          "2376:                 if u as $storage < min || u as $storage > max {",
          "2377:                     Err(TryFromIntError(()))",
          "2378:                 } else {",
          "2379:                     Ok(u as $target)",
          "2380:                 }",
          "2381:             }",
          "2382:         }",
          "2383:     )*}",
          "2384: }",
          "2386: same_sign_from_int_impl!(u64, u8, u8, u16, u32, u64, usize);",
          "2387: same_sign_from_int_impl!(i64, i8, i8, i16, i32, i64, isize);",
          "2388: same_sign_from_int_impl!(u64, u16, u8, u16, u32, u64, usize);",
          "2389: same_sign_from_int_impl!(i64, i16, i8, i16, i32, i64, isize);",
          "2390: same_sign_from_int_impl!(u64, u32, u8, u16, u32, u64, usize);",
          "2391: same_sign_from_int_impl!(i64, i32, i8, i16, i32, i64, isize);",
          "2392: same_sign_from_int_impl!(u64, u64, u8, u16, u32, u64, usize);",
          "2393: same_sign_from_int_impl!(i64, i64, i8, i16, i32, i64, isize);",
          "2394: same_sign_from_int_impl!(u64, usize, u8, u16, u32, u64, usize);",
          "2395: same_sign_from_int_impl!(i64, isize, i8, i16, i32, i64, isize);",
          "2397: macro_rules! cross_sign_from_int_impl {",
          "2398:     ($unsigned:ty, $($signed:ty),*) => {$(",
          "2399:         #[stable(feature = \"rust1\", since = \"1.0.0\")]",
          "2400:         impl TryFrom<$unsigned> for $signed {",
          "2401:             type Err = TryFromIntError;",
          "2403:             fn try_from(u: $unsigned) -> Result<$signed, TryFromIntError> {",
          "2404:                 let max = <$signed as FromStrRadixHelper>::max_value() as u64;",
          "2405:                 if u as u64 > max {",
          "2406:                     Err(TryFromIntError(()))",
          "2407:                 } else {",
          "2408:                     Ok(u as $signed)",
          "2409:                 }",
          "2410:             }",
          "2411:         }",
          "2413:         #[stable(feature = \"rust1\", since = \"1.0.0\")]",
          "2414:         impl TryFrom<$signed> for $unsigned {",
          "2415:             type Err = TryFromIntError;",
          "2417:             fn try_from(u: $signed) -> Result<$unsigned, TryFromIntError> {",
          "2418:                 let max = <$unsigned as FromStrRadixHelper>::max_value() as u64;",
          "2419:                 if u < 0 || u as u64 > max {",
          "2420:                     Err(TryFromIntError(()))",
          "2421:                 } else {",
          "2422:                     Ok(u as $unsigned)",
          "2423:                 }",
          "2424:             }",
          "2425:         }",
          "2426:     )*}",
          "2427: }",
          "2429: cross_sign_from_int_impl!(u8, i8, i16, i32, i64, isize);",
          "2430: cross_sign_from_int_impl!(u16, i8, i16, i32, i64, isize);",
          "2431: cross_sign_from_int_impl!(u32, i8, i16, i32, i64, isize);",
          "2432: cross_sign_from_int_impl!(u64, i8, i16, i32, i64, isize);",
          "2433: cross_sign_from_int_impl!(usize, i8, i16, i32, i64, isize);",
          "2438:     fn max_value() -> Self;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2353: macro_rules! doit {",
          "2354:     ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {",
          "2355:         fn min_value() -> Self { Self::min_value() }",
          "2356:         fn from_u32(u: u32) -> Self { u as Self }",
          "2357:         fn checked_mul(&self, other: u32) -> Option<Self> {",
          "2358:             Self::checked_mul(*self, other as Self)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2448:         fn max_value() -> Self { Self::max_value() }",
          "",
          "---------------"
        ],
        "src/libcoretest/lib.rs||src/libcoretest/lib.rs": [
          "File: src/libcoretest/lib.rs -> src/libcoretest/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #![feature(unboxed_closures)]",
          "35: #![feature(unicode)]",
          "36: #![feature(unique)]",
          "38: extern crate core;",
          "39: extern crate test;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "37: #![feature(try_from)]",
          "",
          "---------------"
        ],
        "src/libcoretest/num/mod.rs||src/libcoretest/num/mod.rs": [
          "File: src/libcoretest/num/mod.rs -> src/libcoretest/num/mod.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: use core::cmp::PartialEq;",
          "12: use core::fmt::Debug;",
          "14: use core::marker::Copy;",
          "16: #[macro_use]",
          "17: mod int_macros;",
          "",
          "[Removed Lines]",
          "13: use core::ops::{Add, Sub, Mul, Div, Rem};",
          "",
          "[Added Lines]",
          "11: use core::convert::TryFrom;",
          "15: use core::num::Float;",
          "16: use core::ops::{Add, Sub, Mul, Div, Rem};",
          "17: use core::option::Option;",
          "18: use core::option::Option::{Some, None};",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:     assert_eq!(ten.rem(two),  ten % two);",
          "49: }",
          "104:     }",
          "111:     }",
          "118:     }",
          "131:         }",
          "132:     }",
          "215:     }",
          "216: }",
          "",
          "[Removed Lines]",
          "51: #[cfg(test)]",
          "52: mod tests {",
          "53:     use core::option::Option;",
          "54:     use core::option::Option::{Some, None};",
          "55:     use core::num::Float;",
          "57:     #[test]",
          "58:     fn from_str_issue7588() {",
          "59:         let u : Option<u8> = u8::from_str_radix(\"1000\", 10).ok();",
          "60:         assert_eq!(u, None);",
          "61:         let s : Option<i16> = i16::from_str_radix(\"80000\", 10).ok();",
          "62:         assert_eq!(s, None);",
          "63:     }",
          "65:     #[test]",
          "66:     fn test_int_from_str_overflow() {",
          "67:         let mut i8_val: i8 = 127;",
          "68:         assert_eq!(\"127\".parse::<i8>().ok(), Some(i8_val));",
          "69:         assert_eq!(\"128\".parse::<i8>().ok(), None);",
          "71:         i8_val = i8_val.wrapping_add(1);",
          "72:         assert_eq!(\"-128\".parse::<i8>().ok(), Some(i8_val));",
          "73:         assert_eq!(\"-129\".parse::<i8>().ok(), None);",
          "75:         let mut i16_val: i16 = 32_767;",
          "76:         assert_eq!(\"32767\".parse::<i16>().ok(), Some(i16_val));",
          "77:         assert_eq!(\"32768\".parse::<i16>().ok(), None);",
          "79:         i16_val = i16_val.wrapping_add(1);",
          "80:         assert_eq!(\"-32768\".parse::<i16>().ok(), Some(i16_val));",
          "81:         assert_eq!(\"-32769\".parse::<i16>().ok(), None);",
          "83:         let mut i32_val: i32 = 2_147_483_647;",
          "84:         assert_eq!(\"2147483647\".parse::<i32>().ok(), Some(i32_val));",
          "85:         assert_eq!(\"2147483648\".parse::<i32>().ok(), None);",
          "87:         i32_val = i32_val.wrapping_add(1);",
          "88:         assert_eq!(\"-2147483648\".parse::<i32>().ok(), Some(i32_val));",
          "89:         assert_eq!(\"-2147483649\".parse::<i32>().ok(), None);",
          "91:         let mut i64_val: i64 = 9_223_372_036_854_775_807;",
          "92:         assert_eq!(\"9223372036854775807\".parse::<i64>().ok(), Some(i64_val));",
          "93:         assert_eq!(\"9223372036854775808\".parse::<i64>().ok(), None);",
          "95:         i64_val = i64_val.wrapping_add(1);",
          "96:         assert_eq!(\"-9223372036854775808\".parse::<i64>().ok(), Some(i64_val));",
          "97:         assert_eq!(\"-9223372036854775809\".parse::<i64>().ok(), None);",
          "98:     }",
          "100:     #[test]",
          "101:     fn test_leading_plus() {",
          "102:         assert_eq!(\"+127\".parse::<u8>().ok(), Some(127));",
          "103:         assert_eq!(\"+9223372036854775807\".parse::<i64>().ok(), Some(9223372036854775807));",
          "106:     #[test]",
          "107:     fn test_invalid() {",
          "108:         assert_eq!(\"--129\".parse::<i8>().ok(), None);",
          "109:         assert_eq!(\"++129\".parse::<i8>().ok(), None);",
          "110:         assert_eq!(\"\u0421\u044a\u0435\u0448\u044c\".parse::<u8>().ok(), None);",
          "113:     #[test]",
          "114:     fn test_empty() {",
          "115:         assert_eq!(\"-\".parse::<i8>().ok(), None);",
          "116:         assert_eq!(\"+\".parse::<i8>().ok(), None);",
          "117:         assert_eq!(\"\".parse::<u8>().ok(), None);",
          "120:     macro_rules! test_impl_from {",
          "121:         ($fn_name: ident, $Small: ty, $Large: ty) => {",
          "122:             #[test]",
          "123:             fn $fn_name() {",
          "124:                 let small_max = <$Small>::max_value();",
          "125:                 let small_min = <$Small>::min_value();",
          "126:                 let large_max: $Large = small_max.into();",
          "127:                 let large_min: $Large = small_min.into();",
          "128:                 assert_eq!(large_max as $Small, small_max);",
          "129:                 assert_eq!(large_min as $Small, small_min);",
          "130:             }",
          "135:     test_impl_from! { test_u8u16, u8, u16 }",
          "136:     test_impl_from! { test_u8u32, u8, u32 }",
          "137:     test_impl_from! { test_u8u64, u8, u64 }",
          "138:     test_impl_from! { test_u8usize, u8, usize }",
          "139:     test_impl_from! { test_u16u32, u16, u32 }",
          "140:     test_impl_from! { test_u16u64, u16, u64 }",
          "141:     test_impl_from! { test_u32u64, u32, u64 }",
          "144:     test_impl_from! { test_i8i16, i8, i16 }",
          "145:     test_impl_from! { test_i8i32, i8, i32 }",
          "146:     test_impl_from! { test_i8i64, i8, i64 }",
          "147:     test_impl_from! { test_i8isize, i8, isize }",
          "148:     test_impl_from! { test_i16i32, i16, i32 }",
          "149:     test_impl_from! { test_i16i64, i16, i64 }",
          "150:     test_impl_from! { test_i32i64, i32, i64 }",
          "153:     test_impl_from! { test_u8i16, u8, i16 }",
          "154:     test_impl_from! { test_u8i32, u8, i32 }",
          "155:     test_impl_from! { test_u8i64, u8, i64 }",
          "156:     test_impl_from! { test_u16i32, u16, i32 }",
          "157:     test_impl_from! { test_u16i64, u16, i64 }",
          "158:     test_impl_from! { test_u32i64, u32, i64 }",
          "161:     test_impl_from! { test_i8f32, i8, f32 }",
          "162:     test_impl_from! { test_i8f64, i8, f64 }",
          "163:     test_impl_from! { test_i16f32, i16, f32 }",
          "164:     test_impl_from! { test_i16f64, i16, f64 }",
          "165:     test_impl_from! { test_i32f64, i32, f64 }",
          "168:     test_impl_from! { test_u8f32, u8, f32 }",
          "169:     test_impl_from! { test_u8f64, u8, f64 }",
          "170:     test_impl_from! { test_u16f32, u16, f32 }",
          "171:     test_impl_from! { test_u16f64, u16, f64 }",
          "172:     test_impl_from! { test_u32f64, u32, f64 }",
          "175:     #[test]",
          "176:     fn test_f32f64() {",
          "177:         use core::f32;",
          "179:         let max: f64 = f32::MAX.into();",
          "180:         assert_eq!(max as f32, f32::MAX);",
          "181:         assert!(max.is_normal());",
          "183:         let min: f64 = f32::MIN.into();",
          "184:         assert_eq!(min as f32, f32::MIN);",
          "185:         assert!(min.is_normal());",
          "187:         let min_positive: f64 = f32::MIN_POSITIVE.into();",
          "188:         assert_eq!(min_positive as f32, f32::MIN_POSITIVE);",
          "189:         assert!(min_positive.is_normal());",
          "191:         let epsilon: f64 = f32::EPSILON.into();",
          "192:         assert_eq!(epsilon as f32, f32::EPSILON);",
          "193:         assert!(epsilon.is_normal());",
          "195:         let zero: f64 = (0.0f32).into();",
          "196:         assert_eq!(zero as f32, 0.0f32);",
          "197:         assert!(zero.is_sign_positive());",
          "199:         let neg_zero: f64 = (-0.0f32).into();",
          "200:         assert_eq!(neg_zero as f32, -0.0f32);",
          "201:         assert!(neg_zero.is_sign_negative());",
          "203:         let infinity: f64 = f32::INFINITY.into();",
          "204:         assert_eq!(infinity as f32, f32::INFINITY);",
          "205:         assert!(infinity.is_infinite());",
          "206:         assert!(infinity.is_sign_positive());",
          "208:         let neg_infinity: f64 = f32::NEG_INFINITY.into();",
          "209:         assert_eq!(neg_infinity as f32, f32::NEG_INFINITY);",
          "210:         assert!(neg_infinity.is_infinite());",
          "211:         assert!(neg_infinity.is_sign_negative());",
          "213:         let nan: f64 = f32::NAN.into();",
          "214:         assert!(nan.is_nan());",
          "",
          "[Added Lines]",
          "55: #[test]",
          "56: fn from_str_issue7588() {",
          "57:     let u : Option<u8> = u8::from_str_radix(\"1000\", 10).ok();",
          "58:     assert_eq!(u, None);",
          "59:     let s : Option<i16> = i16::from_str_radix(\"80000\", 10).ok();",
          "60:     assert_eq!(s, None);",
          "61: }",
          "63: #[test]",
          "64: fn test_int_from_str_overflow() {",
          "65:     let mut i8_val: i8 = 127;",
          "66:     assert_eq!(\"127\".parse::<i8>().ok(), Some(i8_val));",
          "67:     assert_eq!(\"128\".parse::<i8>().ok(), None);",
          "69:     i8_val = i8_val.wrapping_add(1);",
          "70:     assert_eq!(\"-128\".parse::<i8>().ok(), Some(i8_val));",
          "71:     assert_eq!(\"-129\".parse::<i8>().ok(), None);",
          "73:     let mut i16_val: i16 = 32_767;",
          "74:     assert_eq!(\"32767\".parse::<i16>().ok(), Some(i16_val));",
          "75:     assert_eq!(\"32768\".parse::<i16>().ok(), None);",
          "77:     i16_val = i16_val.wrapping_add(1);",
          "78:     assert_eq!(\"-32768\".parse::<i16>().ok(), Some(i16_val));",
          "79:     assert_eq!(\"-32769\".parse::<i16>().ok(), None);",
          "81:     let mut i32_val: i32 = 2_147_483_647;",
          "82:     assert_eq!(\"2147483647\".parse::<i32>().ok(), Some(i32_val));",
          "83:     assert_eq!(\"2147483648\".parse::<i32>().ok(), None);",
          "85:     i32_val = i32_val.wrapping_add(1);",
          "86:     assert_eq!(\"-2147483648\".parse::<i32>().ok(), Some(i32_val));",
          "87:     assert_eq!(\"-2147483649\".parse::<i32>().ok(), None);",
          "89:     let mut i64_val: i64 = 9_223_372_036_854_775_807;",
          "90:     assert_eq!(\"9223372036854775807\".parse::<i64>().ok(), Some(i64_val));",
          "91:     assert_eq!(\"9223372036854775808\".parse::<i64>().ok(), None);",
          "93:     i64_val = i64_val.wrapping_add(1);",
          "94:     assert_eq!(\"-9223372036854775808\".parse::<i64>().ok(), Some(i64_val));",
          "95:     assert_eq!(\"-9223372036854775809\".parse::<i64>().ok(), None);",
          "96: }",
          "98: #[test]",
          "99: fn test_leading_plus() {",
          "100:     assert_eq!(\"+127\".parse::<u8>().ok(), Some(127));",
          "101:     assert_eq!(\"+9223372036854775807\".parse::<i64>().ok(), Some(9223372036854775807));",
          "102: }",
          "104: #[test]",
          "105: fn test_invalid() {",
          "106:     assert_eq!(\"--129\".parse::<i8>().ok(), None);",
          "107:     assert_eq!(\"++129\".parse::<i8>().ok(), None);",
          "108:     assert_eq!(\"\u0421\u044a\u0435\u0448\u044c\".parse::<u8>().ok(), None);",
          "109: }",
          "111: #[test]",
          "112: fn test_empty() {",
          "113:     assert_eq!(\"-\".parse::<i8>().ok(), None);",
          "114:     assert_eq!(\"+\".parse::<i8>().ok(), None);",
          "115:     assert_eq!(\"\".parse::<u8>().ok(), None);",
          "116: }",
          "118: macro_rules! test_impl_from {",
          "119:     ($fn_name: ident, $Small: ty, $Large: ty) => {",
          "120:         #[test]",
          "121:         fn $fn_name() {",
          "122:             let small_max = <$Small>::max_value();",
          "123:             let small_min = <$Small>::min_value();",
          "124:             let large_max: $Large = small_max.into();",
          "125:             let large_min: $Large = small_min.into();",
          "126:             assert_eq!(large_max as $Small, small_max);",
          "127:             assert_eq!(large_min as $Small, small_min);",
          "128:         }",
          "130: }",
          "133: test_impl_from! { test_u8u16, u8, u16 }",
          "134: test_impl_from! { test_u8u32, u8, u32 }",
          "135: test_impl_from! { test_u8u64, u8, u64 }",
          "136: test_impl_from! { test_u8usize, u8, usize }",
          "137: test_impl_from! { test_u16u32, u16, u32 }",
          "138: test_impl_from! { test_u16u64, u16, u64 }",
          "139: test_impl_from! { test_u32u64, u32, u64 }",
          "142: test_impl_from! { test_i8i16, i8, i16 }",
          "143: test_impl_from! { test_i8i32, i8, i32 }",
          "144: test_impl_from! { test_i8i64, i8, i64 }",
          "145: test_impl_from! { test_i8isize, i8, isize }",
          "146: test_impl_from! { test_i16i32, i16, i32 }",
          "147: test_impl_from! { test_i16i64, i16, i64 }",
          "148: test_impl_from! { test_i32i64, i32, i64 }",
          "151: test_impl_from! { test_u8i16, u8, i16 }",
          "152: test_impl_from! { test_u8i32, u8, i32 }",
          "153: test_impl_from! { test_u8i64, u8, i64 }",
          "154: test_impl_from! { test_u16i32, u16, i32 }",
          "155: test_impl_from! { test_u16i64, u16, i64 }",
          "156: test_impl_from! { test_u32i64, u32, i64 }",
          "159: test_impl_from! { test_i8f32, i8, f32 }",
          "160: test_impl_from! { test_i8f64, i8, f64 }",
          "161: test_impl_from! { test_i16f32, i16, f32 }",
          "162: test_impl_from! { test_i16f64, i16, f64 }",
          "163: test_impl_from! { test_i32f64, i32, f64 }",
          "166: test_impl_from! { test_u8f32, u8, f32 }",
          "167: test_impl_from! { test_u8f64, u8, f64 }",
          "168: test_impl_from! { test_u16f32, u16, f32 }",
          "169: test_impl_from! { test_u16f64, u16, f64 }",
          "170: test_impl_from! { test_u32f64, u32, f64 }",
          "173: #[test]",
          "174: fn test_f32f64() {",
          "175:     use core::f32;",
          "177:     let max: f64 = f32::MAX.into();",
          "178:     assert_eq!(max as f32, f32::MAX);",
          "179:     assert!(max.is_normal());",
          "181:     let min: f64 = f32::MIN.into();",
          "182:     assert_eq!(min as f32, f32::MIN);",
          "183:     assert!(min.is_normal());",
          "185:     let min_positive: f64 = f32::MIN_POSITIVE.into();",
          "186:     assert_eq!(min_positive as f32, f32::MIN_POSITIVE);",
          "187:     assert!(min_positive.is_normal());",
          "189:     let epsilon: f64 = f32::EPSILON.into();",
          "190:     assert_eq!(epsilon as f32, f32::EPSILON);",
          "191:     assert!(epsilon.is_normal());",
          "193:     let zero: f64 = (0.0f32).into();",
          "194:     assert_eq!(zero as f32, 0.0f32);",
          "195:     assert!(zero.is_sign_positive());",
          "197:     let neg_zero: f64 = (-0.0f32).into();",
          "198:     assert_eq!(neg_zero as f32, -0.0f32);",
          "199:     assert!(neg_zero.is_sign_negative());",
          "201:     let infinity: f64 = f32::INFINITY.into();",
          "202:     assert_eq!(infinity as f32, f32::INFINITY);",
          "203:     assert!(infinity.is_infinite());",
          "204:     assert!(infinity.is_sign_positive());",
          "206:     let neg_infinity: f64 = f32::NEG_INFINITY.into();",
          "207:     assert_eq!(neg_infinity as f32, f32::NEG_INFINITY);",
          "208:     assert!(neg_infinity.is_infinite());",
          "209:     assert!(neg_infinity.is_sign_negative());",
          "211:     let nan: f64 = f32::NAN.into();",
          "212:     assert!(nan.is_nan());",
          "213: }",
          "215: macro_rules! test_impl_try_from_always_ok {",
          "216:     ($fn_name:ident, $source:ty, $target: ty) => {",
          "217:         #[test]",
          "218:         fn $fn_name() {",
          "219:             let max = <$source>::max_value();",
          "220:             let min = <$source>::min_value();",
          "221:             let zero: $source = 0;",
          "222:             assert_eq!(<$target as TryFrom<$source>>::try_from(max).unwrap(),",
          "223:                        max as $target);",
          "224:             assert_eq!(<$target as TryFrom<$source>>::try_from(min).unwrap(),",
          "225:                        min as $target);",
          "226:             assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(),",
          "227:                        zero as $target);",
          "228:         }",
          "230: }",
          "232: test_impl_try_from_always_ok! { test_try_u8u8, u8, u8 }",
          "233: test_impl_try_from_always_ok! { test_try_u8u16, u8, u16 }",
          "234: test_impl_try_from_always_ok! { test_try_u8u32, u8, u32 }",
          "235: test_impl_try_from_always_ok! { test_try_u8u64, u8, u64 }",
          "236: test_impl_try_from_always_ok! { test_try_u8i16, u8, i16 }",
          "237: test_impl_try_from_always_ok! { test_try_u8i32, u8, i32 }",
          "238: test_impl_try_from_always_ok! { test_try_u8i64, u8, i64 }",
          "240: test_impl_try_from_always_ok! { test_try_u16u16, u16, u16 }",
          "241: test_impl_try_from_always_ok! { test_try_u16u32, u16, u32 }",
          "242: test_impl_try_from_always_ok! { test_try_u16u64, u16, u64 }",
          "243: test_impl_try_from_always_ok! { test_try_u16i32, u16, i32 }",
          "244: test_impl_try_from_always_ok! { test_try_u16i64, u16, i64 }",
          "246: test_impl_try_from_always_ok! { test_try_u32u32, u32, u32 }",
          "247: test_impl_try_from_always_ok! { test_try_u32u64, u32, u64 }",
          "248: test_impl_try_from_always_ok! { test_try_u32i64, u32, i64 }",
          "250: test_impl_try_from_always_ok! { test_try_u64u64, u64, u64 }",
          "252: test_impl_try_from_always_ok! { test_try_i8i8, i8, i8 }",
          "253: test_impl_try_from_always_ok! { test_try_i8i16, i8, i16 }",
          "254: test_impl_try_from_always_ok! { test_try_i8i32, i8, i32 }",
          "255: test_impl_try_from_always_ok! { test_try_i8i64, i8, i64 }",
          "257: test_impl_try_from_always_ok! { test_try_i16i16, i16, i16 }",
          "258: test_impl_try_from_always_ok! { test_try_i16i32, i16, i32 }",
          "259: test_impl_try_from_always_ok! { test_try_i16i64, i16, i64 }",
          "261: test_impl_try_from_always_ok! { test_try_i32i32, i32, i32 }",
          "262: test_impl_try_from_always_ok! { test_try_i32i64, i32, i64 }",
          "264: test_impl_try_from_always_ok! { test_try_i64i64, i64, i64 }",
          "266: macro_rules! test_impl_try_from_signed_to_unsigned_upper_ok {",
          "267:     ($fn_name:ident, $source:ty, $target:ty) => {",
          "268:         #[test]",
          "269:         fn $fn_name() {",
          "270:             let max = <$source>::max_value();",
          "271:             let min = <$source>::min_value();",
          "272:             let zero: $source = 0;",
          "273:             let neg_one: $source = -1;",
          "274:             assert_eq!(<$target as TryFrom<$source>>::try_from(max).unwrap(),",
          "275:                        max as $target);",
          "276:             assert!(<$target as TryFrom<$source>>::try_from(min).is_err());",
          "277:             assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(),",
          "278:                        zero as $target);",
          "279:             assert!(<$target as TryFrom<$source>>::try_from(neg_one).is_err());",
          "280:         }",
          "282: }",
          "284: test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u8, i8, u8 }",
          "285: test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u16, i8, u16 }",
          "286: test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u32, i8, u32 }",
          "287: test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u64, i8, u64 }",
          "289: test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u16, i16, u16 }",
          "290: test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u32, i16, u32 }",
          "291: test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u64, i16, u64 }",
          "293: test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32u32, i32, u32 }",
          "294: test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32u64, i32, u64 }",
          "296: test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i64u64, i64, u64 }",
          "298: macro_rules! test_impl_try_from_unsigned_to_signed_upper_err {",
          "299:     ($fn_name:ident, $source:ty, $target:ty) => {",
          "300:         #[test]",
          "301:         fn $fn_name() {",
          "302:             let max = <$source>::max_value();",
          "303:             let min = <$source>::min_value();",
          "304:             let zero: $source = 0;",
          "305:             assert!(<$target as TryFrom<$source>>::try_from(max).is_err());",
          "306:             assert_eq!(<$target as TryFrom<$source>>::try_from(min).unwrap(),",
          "307:                        min as $target);",
          "308:             assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(),",
          "309:                        zero as $target);",
          "312: }",
          "314: test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u8i8, u8, i8 }",
          "316: test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u16i8, u16, i8 }",
          "317: test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u16i16, u16, i16 }",
          "319: test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32i8, u32, i8 }",
          "320: test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32i16, u32, i16 }",
          "321: test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32i32, u32, i32 }",
          "323: test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i8, u64, i8 }",
          "324: test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i16, u64, i16 }",
          "325: test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i32, u64, i32 }",
          "326: test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i64, u64, i64 }",
          "328: macro_rules! test_impl_try_from_same_sign_err {",
          "329:     ($fn_name:ident, $source:ty, $target:ty) => {",
          "330:         #[test]",
          "331:         fn $fn_name() {",
          "332:             let max = <$source>::max_value();",
          "333:             let min = <$source>::min_value();",
          "334:             let zero: $source = 0;",
          "335:             let t_max = <$target>::max_value();",
          "336:             let t_min = <$target>::min_value();",
          "337:             assert!(<$target as TryFrom<$source>>::try_from(max).is_err());",
          "338:             if min != 0 {",
          "339:                 assert!(<$target as TryFrom<$source>>::try_from(min).is_err());",
          "340:             }",
          "341:             assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(),",
          "342:                        zero as $target);",
          "343:             assert_eq!(<$target as TryFrom<$source>>::try_from(t_max as $source)",
          "344:                             .unwrap(),",
          "345:                        t_max as $target);",
          "346:             assert_eq!(<$target as TryFrom<$source>>::try_from(t_min as $source)",
          "347:                             .unwrap(),",
          "348:                        t_min as $target);",
          "349:         }",
          "353: test_impl_try_from_same_sign_err! { test_try_u16u8, u16, u8 }",
          "355: test_impl_try_from_same_sign_err! { test_try_u32u8, u32, u8 }",
          "356: test_impl_try_from_same_sign_err! { test_try_u32u16, u32, u16 }",
          "358: test_impl_try_from_same_sign_err! { test_try_u64u8, u64, u8 }",
          "359: test_impl_try_from_same_sign_err! { test_try_u64u16, u64, u16 }",
          "360: test_impl_try_from_same_sign_err! { test_try_u64u32, u64, u32 }",
          "362: test_impl_try_from_same_sign_err! { test_try_i16i8, i16, i8 }",
          "364: test_impl_try_from_same_sign_err! { test_try_i32i8, i32, i8 }",
          "365: test_impl_try_from_same_sign_err! { test_try_i32i16, i32, i16 }",
          "367: test_impl_try_from_same_sign_err! { test_try_i64i8, i64, i8 }",
          "368: test_impl_try_from_same_sign_err! { test_try_i64i16, i64, i16 }",
          "369: test_impl_try_from_same_sign_err! { test_try_i64i32, i64, i32 }",
          "",
          "---------------"
        ],
        "src/libstd/error.rs||src/libstd/error.rs": [
          "File: src/libstd/error.rs -> src/libstd/error.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "159:     }",
          "160: }",
          "162: #[stable(feature = \"rust1\", since = \"1.0.0\")]",
          "163: impl Error for num::ParseFloatError {",
          "164:     fn description(&self) -> &str {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "162: #[unstable(feature = \"try_from\", issue = \"33417\")]",
          "163: impl Error for num::TryFromIntError {",
          "164:     fn description(&self) -> &str {",
          "165:         self.__description()",
          "166:     }",
          "167: }",
          "",
          "---------------"
        ],
        "src/libstd/lib.rs||src/libstd/lib.rs": [
          "File: src/libstd/lib.rs -> src/libstd/lib.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "270: #![feature(vec_push_all)]",
          "271: #![feature(zero_one)]",
          "272: #![feature(question_mark)]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "273: #![feature(try_from)]",
          "",
          "---------------"
        ],
        "src/libstd/num/mod.rs||src/libstd/num/mod.rs": [
          "File: src/libstd/num/mod.rs -> src/libstd/num/mod.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: #[stable(feature = \"rust1\", since = \"1.0.0\")]",
          "20: pub use core::num::{Zero, One};",
          "21: #[stable(feature = \"rust1\", since = \"1.0.0\")]",
          "23: #[stable(feature = \"rust1\", since = \"1.0.0\")]",
          "24: pub use core::num::Wrapping;",
          "",
          "[Removed Lines]",
          "22: pub use core::num::{FpCategory, ParseIntError, ParseFloatError};",
          "",
          "[Added Lines]",
          "22: pub use core::num::{FpCategory, ParseIntError, ParseFloatError, TryFromIntError};",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c073f81920bc2324b026cf9610a096df0d97c6a5",
      "candidate_info": {
        "commit_hash": "c073f81920bc2324b026cf9610a096df0d97c6a5",
        "repo": "rust-lang/rust",
        "commit_url": "https://github.com/rust-lang/rust/commit/c073f81920bc2324b026cf9610a096df0d97c6a5",
        "files": [
          "src/libcore/num/mod.rs",
          "src/libcoretest/num/mod.rs"
        ],
        "message": "optimize from_str_radix",
        "before_after_code_files": [
          "src/libcore/num/mod.rs||src/libcore/num/mod.rs",
          "src/libcoretest/num/mod.rs||src/libcoretest/num/mod.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libcore/num/mod.rs||src/libcore/num/mod.rs",
            "src/libcoretest/num/mod.rs||src/libcoretest/num/mod.rs"
          ],
          "candidate": [
            "src/libcore/num/mod.rs||src/libcore/num/mod.rs",
            "src/libcoretest/num/mod.rs||src/libcoretest/num/mod.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/libcore/num/mod.rs||src/libcore/num/mod.rs": [
          "File: src/libcore/num/mod.rs -> src/libcore/num/mod.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: use option::Option::{self, Some, None};",
          "25: use result::Result::{self, Ok, Err};",
          "26: use str::{FromStr, StrExt};",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: use slice::SliceExt;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1448:                                          -> Result<T, ParseIntError> {",
          "1449:     use self::IntErrorKind::*;",
          "1450:     use self::ParseIntError as PIE;",
          "1451:     assert!(radix >= 2 && radix <= 36,",
          "1452:            \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",",
          "1453:            radix);",
          "1455:     let is_signed_ty = T::from_u32(0) > T::min_value();",
          "1461:             let mut result = T::from_u32(0);",
          "1464:                     Some(x) => x,",
          "1465:                     None => return Err(PIE { kind: InvalidDigit }),",
          "1466:                 };",
          "",
          "[Removed Lines]",
          "1457:     match src.slice_shift_char() {",
          "1458:         Some(('-', \"\")) => Err(PIE { kind: Empty }),",
          "1459:         Some(('-', src)) if is_signed_ty => {",
          "1462:             for c in src.chars() {",
          "1463:                 let x = match c.to_digit(radix) {",
          "",
          "[Added Lines]",
          "1457:     if src.is_empty() {",
          "1458:         return Err(PIE { kind: Empty });",
          "1459:     }",
          "1467:     let src = src.as_bytes();",
          "1469:     match (src[0], &src[1..])  {",
          "1470:         (b'-', digits) if digits.is_empty() => Err(PIE { kind: Empty }),",
          "1471:         (b'-', digits) if is_signed_ty => {",
          "1474:             for &c in digits {",
          "1475:                 let x = match (c as char).to_digit(radix) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1475:             }",
          "1476:             Ok(result)",
          "1477:         },",
          "1483:                     Some(x) => x,",
          "1484:                     None => return Err(PIE { kind: InvalidDigit }),",
          "1485:                 };",
          "",
          "[Removed Lines]",
          "1478:         Some((_, _)) => {",
          "1480:             let mut result = T::from_u32(0);",
          "1481:             for c in src.chars() {",
          "1482:                 let x = match c.to_digit(radix) {",
          "",
          "[Added Lines]",
          "1490:         (c, digits) => {",
          "1492:             let mut result = match (c as char).to_digit(radix) {",
          "1493:                 Some(x) => T::from_u32(x),",
          "1494:                 None => return Err(PIE { kind: InvalidDigit }),",
          "1495:             };",
          "1496:             for &c in digits {",
          "1497:                 let x = match (c as char).to_digit(radix) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1493:                 };",
          "1494:             }",
          "1495:             Ok(result)",
          "1498:     }",
          "1499: }",
          "",
          "[Removed Lines]",
          "1496:         },",
          "1497:         None => Err(ParseIntError { kind: Empty }),",
          "",
          "[Added Lines]",
          "1511:         }",
          "",
          "---------------"
        ],
        "src/libcoretest/num/mod.rs||src/libcoretest/num/mod.rs": [
          "File: src/libcoretest/num/mod.rs -> src/libcoretest/num/mod.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "117:     }",
          "119:     #[test]",
          "122:     }",
          "123: }",
          "",
          "[Removed Lines]",
          "120:     fn test_int_from_minus_sign() {",
          "121:         assert_eq!(\"-\".parse::<i32>().ok(), None);",
          "",
          "[Added Lines]",
          "120:     fn test_invalid() {",
          "121:         assert_eq!(\"--129\".parse::<i8>().ok(), None);",
          "122:         assert_eq!(\"\u0421\u044a\u0435\u0448\u044c\".parse::<u8>().ok(), None);",
          "123:     }",
          "125:     #[test]",
          "126:     fn test_empty() {",
          "127:         assert_eq!(\"-\".parse::<i8>().ok(), None);",
          "128:         assert_eq!(\"\".parse::<u8>().ok(), None);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e1cc628549020207e07ce8271478f7baff602757",
      "candidate_info": {
        "commit_hash": "e1cc628549020207e07ce8271478f7baff602757",
        "repo": "rust-lang/rust",
        "commit_url": "https://github.com/rust-lang/rust/commit/e1cc628549020207e07ce8271478f7baff602757",
        "files": [
          "src/libcoretest/fmt/builders.rs",
          "src/libcoretest/iter.rs",
          "src/libcoretest/num/int_macros.rs",
          "src/libcoretest/num/mod.rs",
          "src/libcoretest/option.rs"
        ],
        "message": "cleanup int suffixes in libcoretest",
        "before_after_code_files": [
          "src/libcoretest/fmt/builders.rs||src/libcoretest/fmt/builders.rs",
          "src/libcoretest/iter.rs||src/libcoretest/iter.rs",
          "src/libcoretest/num/int_macros.rs||src/libcoretest/num/int_macros.rs",
          "src/libcoretest/num/mod.rs||src/libcoretest/num/mod.rs",
          "src/libcoretest/option.rs||src/libcoretest/option.rs"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libcoretest/num/mod.rs||src/libcoretest/num/mod.rs"
          ],
          "candidate": [
            "src/libcoretest/num/mod.rs||src/libcoretest/num/mod.rs"
          ]
        }
      },
      "candidate_diff": {
        "src/libcoretest/fmt/builders.rs||src/libcoretest/fmt/builders.rs": [
          "File: src/libcoretest/fmt/builders.rs -> src/libcoretest/fmt/builders.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {",
          "54:                 fmt.debug_struct(\"Foo\")",
          "55:                     .field(\"bar\", &true)",
          "57:                     .finish()",
          "58:             }",
          "59:         }",
          "",
          "[Removed Lines]",
          "56:                     .field(\"baz\", &format_args!(\"{}/{}\", 10i32, 20i32))",
          "",
          "[Added Lines]",
          "56:                     .field(\"baz\", &format_args!(\"{}/{}\", 10, 20))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75:             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {",
          "76:                 fmt.debug_struct(\"Foo\")",
          "77:                     .field(\"bar\", &true)",
          "79:                     .finish()",
          "80:             }",
          "81:         }",
          "",
          "[Removed Lines]",
          "78:                     .field(\"baz\", &format_args!(\"{}/{}\", 10i32, 20i32))",
          "",
          "[Added Lines]",
          "78:                     .field(\"baz\", &format_args!(\"{}/{}\", 10, 20))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "150:             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {",
          "151:                 fmt.debug_tuple(\"Foo\")",
          "152:                     .field(&true)",
          "154:                     .finish()",
          "155:             }",
          "156:         }",
          "",
          "[Removed Lines]",
          "153:                     .field(&format_args!(\"{}/{}\", 10i32, 20i32))",
          "",
          "[Added Lines]",
          "153:                     .field(&format_args!(\"{}/{}\", 10, 20))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "172:             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {",
          "173:                 fmt.debug_tuple(\"Foo\")",
          "174:                     .field(&true)",
          "176:                     .finish()",
          "177:             }",
          "178:         }",
          "",
          "[Removed Lines]",
          "175:                     .field(&format_args!(\"{}/{}\", 10i32, 20i32))",
          "",
          "[Added Lines]",
          "175:                     .field(&format_args!(\"{}/{}\", 10, 20))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "247:             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {",
          "248:                 fmt.debug_map()",
          "249:                     .entry(&\"bar\", &true)",
          "251:                     .finish()",
          "252:             }",
          "253:         }",
          "",
          "[Removed Lines]",
          "250:                     .entry(&10i32, &format_args!(\"{}/{}\", 10i32, 20i32))",
          "",
          "[Added Lines]",
          "250:                     .entry(&10, &format_args!(\"{}/{}\", 10, 20))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "269:             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {",
          "270:                 fmt.debug_map()",
          "271:                     .entry(&\"bar\", &true)",
          "273:                     .finish()",
          "274:             }",
          "275:         }",
          "",
          "[Removed Lines]",
          "272:                     .entry(&10i32, &format_args!(\"{}/{}\", 10i32, 20i32))",
          "",
          "[Added Lines]",
          "272:                     .entry(&10, &format_args!(\"{}/{}\", 10, 20))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "348:             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {",
          "349:                 fmt.debug_set()",
          "350:                     .entry(&true)",
          "352:                     .finish()",
          "353:             }",
          "354:         }",
          "",
          "[Removed Lines]",
          "351:                     .entry(&format_args!(\"{}/{}\", 10i32, 20i32))",
          "",
          "[Added Lines]",
          "351:                     .entry(&format_args!(\"{}/{}\", 10, 20))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "370:             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {",
          "371:                 fmt.debug_set()",
          "372:                     .entry(&true)",
          "374:                     .finish()",
          "375:             }",
          "376:         }",
          "",
          "[Removed Lines]",
          "373:                     .entry(&format_args!(\"{}/{}\", 10i32, 20i32))",
          "",
          "[Added Lines]",
          "373:                     .entry(&format_args!(\"{}/{}\", 10, 20))",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "445:             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {",
          "446:                 fmt.debug_list()",
          "447:                     .entry(&true)",
          "449:                     .finish()",
          "450:             }",
          "451:         }",
          "",
          "[Removed Lines]",
          "448:                     .entry(&format_args!(\"{}/{}\", 10i32, 20i32))",
          "",
          "[Added Lines]",
          "448:                     .entry(&format_args!(\"{}/{}\", 10, 20))",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "467:             fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {",
          "468:                 fmt.debug_list()",
          "469:                     .entry(&true)",
          "471:                     .finish()",
          "472:             }",
          "473:         }",
          "",
          "[Removed Lines]",
          "470:                     .entry(&format_args!(\"{}/{}\", 10i32, 20i32))",
          "",
          "[Added Lines]",
          "470:                     .entry(&format_args!(\"{}/{}\", 10, 20))",
          "",
          "---------------"
        ],
        "src/libcoretest/iter.rs||src/libcoretest/iter.rs": [
          "File: src/libcoretest/iter.rs -> src/libcoretest/iter.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "678: #[test]",
          "679: fn test_cloned() {",
          "682:     let mut it = xs.iter().cloned();",
          "683:     assert_eq!(it.len(), 4);",
          "",
          "[Removed Lines]",
          "680:     let xs = [2u8, 4, 6, 8];",
          "",
          "[Added Lines]",
          "680:     let xs = [2, 4, 6, 8];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "861:     assert_eq!((-10..-1).size_hint(), (9, Some(9)));",
          "862:     assert_eq!((-1..-10).size_hint(), (0, Some(0)));",
          "866:     assert_eq!((-2..isize::MAX).size_hint(),",
          "867:                (isize::MAX as usize + 2, Some(isize::MAX as usize + 2)));",
          "868: }",
          "",
          "[Removed Lines]",
          "864:     assert_eq!((-70..58i8).size_hint(), (128, Some(128)));",
          "865:     assert_eq!((-128..127i8).size_hint(), (255, Some(255)));",
          "",
          "[Added Lines]",
          "864:     assert_eq!((-70..58).size_hint(), (128, Some(128)));",
          "865:     assert_eq!((-128..127).size_hint(), (255, Some(255)));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1013:         array.iter().enumerate().max_by_key(|&(_, item)| item).unwrap().0",
          "1014:     }",
          "1017:     data[514] = 9999;",
          "1019:     b.iter(|| max_index_iter(&data));",
          "",
          "[Removed Lines]",
          "1016:     let mut data = vec![0i32; 1638];",
          "",
          "[Added Lines]",
          "1016:     let mut data = vec![0; 1638];",
          "",
          "---------------"
        ],
        "src/libcoretest/num/int_macros.rs||src/libcoretest/num/int_macros.rs": [
          "File: src/libcoretest/num/int_macros.rs -> src/libcoretest/num/int_macros.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "208:     fn test_pow() {",
          "209:         let mut r = 2 as $T;",
          "213:         r = -2 as $T;",
          "216:     }",
          "217: }",
          "",
          "[Removed Lines]",
          "211:         assert_eq!(r.pow(2u32), 4 as $T);",
          "212:         assert_eq!(r.pow(0u32), 1 as $T);",
          "214:         assert_eq!(r.pow(2u32), 4 as $T);",
          "215:         assert_eq!(r.pow(3u32), -8 as $T);",
          "",
          "[Added Lines]",
          "211:         assert_eq!(r.pow(2), 4 as $T);",
          "212:         assert_eq!(r.pow(0), 1 as $T);",
          "214:         assert_eq!(r.pow(2), 4 as $T);",
          "215:         assert_eq!(r.pow(3), -8 as $T);",
          "",
          "---------------"
        ],
        "src/libcoretest/num/mod.rs||src/libcoretest/num/mod.rs": [
          "File: src/libcoretest/num/mod.rs -> src/libcoretest/num/mod.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "100:     #[test]",
          "101:     fn test_leading_plus() {",
          "104:     }",
          "106:     #[test]",
          "",
          "[Removed Lines]",
          "102:         assert_eq!(\"+127\".parse::<u8>().ok(), Some(127u8));",
          "103:         assert_eq!(\"+9223372036854775807\".parse::<i64>().ok(), Some(9223372036854775807i64));",
          "",
          "[Added Lines]",
          "102:         assert_eq!(\"+127\".parse::<u8>().ok(), Some(127));",
          "103:         assert_eq!(\"+9223372036854775807\".parse::<i64>().ok(), Some(9223372036854775807));",
          "",
          "---------------"
        ],
        "src/libcoretest/option.rs||src/libcoretest/option.rs": [
          "File: src/libcoretest/option.rs -> src/libcoretest/option.rs",
          "--- Hunk 1 ---",
          "[Context before]",
          "252: #[test]",
          "253: fn test_cloned() {",
          "255:     let val_ref = &val;",
          "256:     let opt_none: Option<&'static u32> = None;",
          "257:     let opt_ref = Some(&val);",
          "",
          "[Removed Lines]",
          "254:     let val = 1u32;",
          "",
          "[Added Lines]",
          "254:     let val = 1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "265:     assert_eq!(opt_ref.clone(), Some(&val));",
          "269:     assert_eq!(opt_ref_ref.clone(), Some(&val_ref));",
          "270:     assert_eq!(opt_ref_ref.clone().cloned(), Some(&val));",
          "272: }",
          "",
          "[Removed Lines]",
          "266:     assert_eq!(opt_ref.cloned(), Some(1u32));",
          "271:     assert_eq!(opt_ref_ref.cloned().cloned(), Some(1u32));",
          "",
          "[Added Lines]",
          "266:     assert_eq!(opt_ref.cloned(), Some(1));",
          "271:     assert_eq!(opt_ref_ref.cloned().cloned(), Some(1));",
          "",
          "---------------"
        ]
      }
    }
  ]
}
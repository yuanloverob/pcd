{
  "cve_id": "CVE-2023-39441",
  "cve_desc": "Apache Airflow SMTP Provider before 1.3.0, Apache Airflow IMAP Provider before 3.3.0, and\u00a0Apache Airflow before 2.7.0 are affected by the\u00a0Validation of OpenSSL Certificate vulnerability.\n\nThe default SSL context with SSL library did not check a server's X.509\u00a0certificate.\u00a0 Instead, the code accepted any certificate, which could\u00a0result in the disclosure of mail server credentials or mail contents\u00a0when the client connects to an attacker in a MITM position.\n\nUsers are strongly advised to upgrade to Apache Airflow version 2.7.0 or newer, Apache Airflow IMAP Provider version 3.3.0 or newer, and Apache Airflow SMTP Provider version 1.3.0 or newer to mitigate the risk associated with this vulnerability",
  "repo": "apache/airflow",
  "patch_hash": "38fc9cd823feafd8ec61d5d5c7eddb9e9162f755",
  "patch_info": {
    "commit_hash": "38fc9cd823feafd8ec61d5d5c7eddb9e9162f755",
    "repo": "apache/airflow",
    "commit_url": "https://github.com/apache/airflow/commit/38fc9cd823feafd8ec61d5d5c7eddb9e9162f755",
    "files": [
      "airflow/providers/imap/CHANGELOG.rst",
      "airflow/providers/imap/hooks/imap.py",
      "airflow/providers/imap/provider.yaml",
      "docs/apache-airflow-providers-imap/configurations-ref.rst",
      "docs/apache-airflow-providers-imap/index.rst",
      "docs/apache-airflow/configurations-ref.rst",
      "tests/providers/imap/hooks/test_imap.py"
    ],
    "message": "Allows to choose SSL context for IMAP provider (#33108)\n\n* Allows to choose SSL context for IMAP provider\n\nThis change add two options to choose from when SSL IMAP connection is created:\n\n* default - for balance between compatibility and security\n* none - in case compatibility with existing infrastructure is preferred\n\nThe fallback is:\n\n* The Airflow \"email\", \"ssl_context\"\n* \"default\"\n\nCo-authored-by: Ephraim Anierobi <splendidzigy24@gmail.com>\n(cherry picked from commit 52ca7bfc988f4c9b608f544bc3e9524fd6564639)",
    "before_after_code_files": [
      "airflow/providers/imap/hooks/imap.py||airflow/providers/imap/hooks/imap.py",
      "tests/providers/imap/hooks/test_imap.py||tests/providers/imap/hooks/test_imap.py"
    ]
  },
  "patch_diff": {
    "airflow/providers/imap/hooks/imap.py||airflow/providers/imap/hooks/imap.py": [
      "File: airflow/providers/imap/hooks/imap.py -> airflow/providers/imap/hooks/imap.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "26: import imaplib",
      "27: import os",
      "28: import re",
      "29: from typing import Any, Iterable",
      "31: from airflow.exceptions import AirflowException",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "29: import ssl",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "78:         return self",
      "80:     def _build_client(self, conn: Connection) -> imaplib.IMAP4_SSL | imaplib.IMAP4:",
      "84:         else:",
      "92:         return mail_client",
      "",
      "[Removed Lines]",
      "81:         IMAP: type[imaplib.IMAP4_SSL] | type[imaplib.IMAP4]",
      "82:         if conn.extra_dejson.get(\"use_ssl\", True):",
      "83:             IMAP = imaplib.IMAP4_SSL",
      "85:             IMAP = imaplib.IMAP4",
      "87:         if conn.port:",
      "88:             mail_client = IMAP(conn.host, conn.port)",
      "89:         else:",
      "90:             mail_client = IMAP(conn.host)",
      "",
      "[Added Lines]",
      "82:         mail_client: imaplib.IMAP4_SSL | imaplib.IMAP4",
      "83:         use_ssl = conn.extra_dejson.get(\"use_ssl\", True)",
      "84:         if use_ssl:",
      "85:             from airflow.configuration import conf",
      "87:             ssl_context_string = conf.get(\"imap\", \"SSL_CONTEXT\", fallback=None)",
      "88:             if ssl_context_string is None:",
      "89:                 ssl_context_string = conf.get(\"email\", \"SSL_CONTEXT\", fallback=None)",
      "90:             if ssl_context_string is None:",
      "91:                 ssl_context_string = \"default\"",
      "92:             if ssl_context_string == \"default\":",
      "93:                 ssl_context = ssl.create_default_context()",
      "94:             elif ssl_context_string == \"none\":",
      "95:                 ssl_context = None",
      "96:             else:",
      "97:                 raise RuntimeError(",
      "98:                     f\"The email.ssl_context configuration variable must \"",
      "99:                     f\"be set to 'default' or 'none' and is '{ssl_context_string}'.\"",
      "100:                 )",
      "101:             if conn.port:",
      "102:                 mail_client = imaplib.IMAP4_SSL(conn.host, conn.port, ssl_context=ssl_context)",
      "103:             else:",
      "104:                 mail_client = imaplib.IMAP4_SSL(conn.host, ssl_context=ssl_context)",
      "106:             if conn.port:",
      "107:                 mail_client = imaplib.IMAP4(conn.host, conn.port)",
      "108:             else:",
      "109:                 mail_client = imaplib.IMAP4(conn.host)",
      "",
      "---------------"
    ],
    "tests/providers/imap/hooks/test_imap.py||tests/providers/imap/hooks/test_imap.py": [
      "File: tests/providers/imap/hooks/test_imap.py -> tests/providers/imap/hooks/test_imap.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "27: from airflow.models import Connection",
      "28: from airflow.providers.imap.hooks.imap import ImapHook",
      "29: from airflow.utils import db",
      "31: imaplib_string = \"airflow.providers.imap.hooks.imap.imaplib\"",
      "32: open_string = \"airflow.providers.imap.hooks.imap.open\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "30: from tests.test_utils.config import conf_vars",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "85:         )",
      "87:     @patch(imaplib_string)",
      "89:         mock_conn = _create_fake_imap(mock_imaplib)",
      "91:         with ImapHook():",
      "92:             pass",
      "95:         mock_conn.login.assert_called_once_with(\"imap_user\", \"imap_password\")",
      "96:         assert mock_conn.logout.call_count == 1",
      "",
      "[Removed Lines]",
      "88:     def test_connect_and_disconnect(self, mock_imaplib):",
      "94:         mock_imaplib.IMAP4_SSL.assert_called_once_with(\"imap_server_address\", 1993)",
      "",
      "[Added Lines]",
      "89:     @patch(\"ssl.create_default_context\")",
      "90:     def test_connect_and_disconnect(self, create_default_context, mock_imaplib):",
      "96:         assert create_default_context.called",
      "97:         mock_imaplib.IMAP4_SSL.assert_called_once_with(",
      "98:             \"imap_server_address\", 1993, ssl_context=create_default_context.return_value",
      "99:         )",
      "100:         mock_conn.login.assert_called_once_with(\"imap_user\", \"imap_password\")",
      "101:         assert mock_conn.logout.call_count == 1",
      "103:     @patch(imaplib_string)",
      "104:     @patch(\"ssl.create_default_context\")",
      "105:     def test_connect_and_disconnect_imap_ssl_context_none(self, create_default_context, mock_imaplib):",
      "106:         mock_conn = _create_fake_imap(mock_imaplib)",
      "108:         with conf_vars({(\"imap\", \"ssl_context\"): \"none\"}):",
      "109:             with ImapHook():",
      "110:                 pass",
      "112:         assert not create_default_context.called",
      "113:         mock_imaplib.IMAP4_SSL.assert_called_once_with(\"imap_server_address\", 1993, ssl_context=None)",
      "114:         mock_conn.login.assert_called_once_with(\"imap_user\", \"imap_password\")",
      "115:         assert mock_conn.logout.call_count == 1",
      "117:     @patch(imaplib_string)",
      "118:     @patch(\"ssl.create_default_context\")",
      "119:     def test_connect_and_disconnect_imap_ssl_context_default(self, create_default_context, mock_imaplib):",
      "120:         mock_conn = _create_fake_imap(mock_imaplib)",
      "122:         with conf_vars({(\"imap\", \"ssl_context\"): \"default\"}):",
      "123:             with ImapHook():",
      "124:                 pass",
      "126:         assert create_default_context.called",
      "127:         mock_imaplib.IMAP4_SSL.assert_called_once_with(",
      "128:             \"imap_server_address\", 1993, ssl_context=create_default_context.return_value",
      "129:         )",
      "130:         mock_conn.login.assert_called_once_with(\"imap_user\", \"imap_password\")",
      "131:         assert mock_conn.logout.call_count == 1",
      "133:     @patch(imaplib_string)",
      "134:     @patch(\"ssl.create_default_context\")",
      "135:     def test_connect_and_disconnect_email_ssl_context_none(self, create_default_context, mock_imaplib):",
      "136:         mock_conn = _create_fake_imap(mock_imaplib)",
      "138:         with conf_vars({(\"email\", \"ssl_context\"): \"none\"}):",
      "139:             with ImapHook():",
      "140:                 pass",
      "142:         assert not create_default_context.called",
      "143:         mock_imaplib.IMAP4_SSL.assert_called_once_with(\"imap_server_address\", 1993, ssl_context=None)",
      "144:         mock_conn.login.assert_called_once_with(\"imap_user\", \"imap_password\")",
      "145:         assert mock_conn.logout.call_count == 1",
      "147:     @patch(imaplib_string)",
      "148:     @patch(\"ssl.create_default_context\")",
      "149:     def test_connect_and_disconnect_imap_ssl_context_override(self, create_default_context, mock_imaplib):",
      "150:         mock_conn = _create_fake_imap(mock_imaplib)",
      "152:         with conf_vars({(\"email\", \"ssl_context\"): \"none\", (\"imap\", \"ssl_context\"): \"default\"}):",
      "153:             with ImapHook():",
      "154:                 pass",
      "156:         assert create_default_context.called",
      "157:         mock_imaplib.IMAP4_SSL.assert_called_once_with(",
      "158:             \"imap_server_address\", 1993, ssl_context=create_default_context.return_value",
      "159:         )",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "fdb96229b61c3e380bb84886cdc757a0e83b2c2a",
      "candidate_info": {
        "commit_hash": "fdb96229b61c3e380bb84886cdc757a0e83b2c2a",
        "repo": "apache/airflow",
        "commit_url": "https://github.com/apache/airflow/commit/fdb96229b61c3e380bb84886cdc757a0e83b2c2a",
        "files": [
          "airflow/config_templates/config.yml",
          "airflow/jobs/job.py",
          "airflow/jobs/triggerer_job_runner.py",
          "airflow/models/trigger.py",
          "tests/jobs/test_base_job.py",
          "tests/models/test_trigger.py"
        ],
        "message": "Configurable health check threshold for triggerer (#33089)\n\nRecently the Triggerer was forced to a health check threshold of\n`trigger_heartbeat * 2.1` with a default of 5s for the heartbeat, this\ngenerates a threshold of 10.5s, the previous threshold was 30s, this\nleads to a very unstable situation where Triggerers are not given a\nreasonable amount of time to heartbeat and their triggers are taken\nfrom them.\n\nThis change allows the user to configure this threshold the same way we\ndo for the scheduler.\n\n(cherry picked from commit 6ec3b9abb67617ebbea2129421c05e45dc863bee)",
        "before_after_code_files": [
          "airflow/jobs/job.py||airflow/jobs/job.py",
          "airflow/jobs/triggerer_job_runner.py||airflow/jobs/triggerer_job_runner.py",
          "airflow/models/trigger.py||airflow/models/trigger.py",
          "tests/jobs/test_base_job.py||tests/jobs/test_base_job.py",
          "tests/models/test_trigger.py||tests/models/test_trigger.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/apache/airflow/pull/33247"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "airflow/jobs/job.py||airflow/jobs/job.py": [
          "File: airflow/jobs/job.py -> airflow/jobs/job.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "129:         \"\"\"",
          "130:         if self.job_type == \"SchedulerJob\":",
          "131:             health_check_threshold: int = conf.getint(\"scheduler\", \"scheduler_health_check_threshold\")",
          "132:         else:",
          "133:             health_check_threshold: int = self.heartrate * grace_multiplier",
          "134:         return (",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "132:         elif self.job_type == \"TriggererJob\":",
          "133:             health_check_threshold: int = conf.getint(\"triggerer\", \"triggerer_health_check_threshold\")",
          "",
          "---------------"
        ],
        "airflow/jobs/triggerer_job_runner.py||airflow/jobs/triggerer_job_runner.py": [
          "File: airflow/jobs/triggerer_job_runner.py -> airflow/jobs/triggerer_job_runner.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "257:         else:",
          "258:             raise ValueError(f\"Capacity number {capacity} is invalid\")",
          "260:         should_queue = True",
          "261:         if DISABLE_WRAPPER:",
          "262:             self.log.warning(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "260:         self.health_check_threshold = conf.getint(\"triggerer\", \"triggerer_health_check_threshold\")",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "364:     def load_triggers(self):",
          "365:         \"\"\"Query the database for the triggers we're supposed to be running and update the runner.\"\"\"",
          "367:         ids = Trigger.ids_for_triggerer(self.job.id)",
          "368:         self.trigger_runner.update_triggers(set(ids))",
          "",
          "[Removed Lines]",
          "366:         Trigger.assign_unassigned(self.job.id, self.capacity, self.job.heartrate)",
          "",
          "[Added Lines]",
          "368:         Trigger.assign_unassigned(self.job.id, self.capacity, self.health_check_threshold)",
          "",
          "---------------"
        ],
        "airflow/models/trigger.py||airflow/models/trigger.py": [
          "File: airflow/models/trigger.py -> airflow/models/trigger.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "199:     @classmethod",
          "200:     @internal_api_call",
          "201:     @provide_session",
          "203:         \"\"\"",
          "204:         Assign unassigned triggers based on a number of conditions.",
          "209:         \"\"\"",
          "210:         from airflow.jobs.job import Job  # To avoid circular import",
          "",
          "[Removed Lines]",
          "202:     def assign_unassigned(cls, triggerer_id, capacity, heartrate, session: Session = NEW_SESSION) -> None:",
          "206:         Takes a triggerer_id, the capacity for that triggerer and the Triggerer job heartrate,",
          "207:         and assigns unassigned triggers until that capacity is reached, or there are no more",
          "208:         unassigned triggers.",
          "",
          "[Added Lines]",
          "202:     def assign_unassigned(",
          "203:         cls, triggerer_id, capacity, health_check_threshold, session: Session = NEW_SESSION",
          "204:     ) -> None:",
          "208:         Takes a triggerer_id, the capacity for that triggerer and the Triggerer job heartrate",
          "209:         health check threshold, and assigns unassigned triggers until that capacity is reached,",
          "210:         or there are no more unassigned triggers.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "215:         if capacity <= 0:",
          "216:             return",
          "220:         alive_triggerer_ids = session.scalars(",
          "221:             select(Job.id).where(",
          "222:                 Job.end_date.is_(None),",
          "",
          "[Removed Lines]",
          "217:         # we multiply heartrate by a grace_multiplier to give the triggerer",
          "218:         # a chance to heartbeat before we consider it dead",
          "219:         health_check_threshold = heartrate * 2.1",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tests/jobs/test_base_job.py||tests/jobs/test_base_job.py": [
          "File: tests/jobs/test_base_job.py -> tests/jobs/test_base_job.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: import sys",
          "22: from unittest.mock import ANY, Mock, patch",
          "25: from sqlalchemy.exc import OperationalError",
          "27: from airflow.executors.sequential_executor import SequentialExecutor",
          "",
          "[Removed Lines]",
          "24: from pytest import raises",
          "",
          "[Added Lines]",
          "24: import pytest",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "85:         job = Job()",
          "86:         job_runner = MockJobRunner(job=job, func=abort)",
          "88:             run_job(job=job, execute_callable=job_runner._execute)",
          "90:         assert job.state == State.FAILED",
          "",
          "[Removed Lines]",
          "87:         with raises(RuntimeError):",
          "",
          "[Added Lines]",
          "87:         with pytest.raises(RuntimeError):",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "148:         job.latest_heartbeat = timezone.utcnow() - datetime.timedelta(seconds=10)",
          "149:         assert job.is_alive() is False, \"Completed jobs even with recent heartbeat should not be alive\"",
          "153:         assert job.is_alive() is True",
          "155:         job.latest_heartbeat = timezone.utcnow() - datetime.timedelta(seconds=20)",
          "",
          "[Removed Lines]",
          "151:     def test_is_alive_scheduler(self):",
          "152:         job = Job(heartrate=10, state=State.RUNNING, job_type=\"SchedulerJob\")",
          "",
          "[Added Lines]",
          "151:     @pytest.mark.parametrize(\"job_type\", [\"SchedulerJob\", \"TriggererJob\"])",
          "152:     def test_is_alive_scheduler(self, job_type):",
          "153:         job = Job(heartrate=10, state=State.RUNNING, job_type=job_type)",
          "",
          "---------------"
        ],
        "tests/models/test_trigger.py||tests/models/test_trigger.py": [
          "File: tests/models/test_trigger.py -> tests/models/test_trigger.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "141:     \"\"\"",
          "142:     Tests that unassigned triggers of all appropriate states are assigned.",
          "143:     \"\"\"",
          "144:     triggerer_heartrate = 10",
          "145:     finished_triggerer = Job(heartrate=triggerer_heartrate, state=State.SUCCESS)",
          "146:     TriggererJobRunner(finished_triggerer)",
          "148:     session.add(finished_triggerer)",
          "149:     assert not finished_triggerer.is_alive()",
          "150:     healthy_triggerer = Job(heartrate=triggerer_heartrate, state=State.RUNNING)",
          "",
          "[Removed Lines]",
          "147:     finished_triggerer.end_date = timezone.utcnow() - datetime.timedelta(hours=1)",
          "",
          "[Added Lines]",
          "144:     time_now = timezone.utcnow()",
          "148:     finished_triggerer.end_date = time_now - datetime.timedelta(hours=1)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "155:     TriggererJobRunner(new_triggerer)",
          "156:     session.add(new_triggerer)",
          "157:     assert new_triggerer.is_alive()",
          "158:     session.commit()",
          "159:     trigger_on_healthy_triggerer = Trigger(classpath=\"airflow.triggers.testing.SuccessTrigger\", kwargs={})",
          "160:     trigger_on_healthy_triggerer.id = 1",
          "161:     trigger_on_healthy_triggerer.triggerer_id = healthy_triggerer.id",
          "162:     trigger_on_killed_triggerer = Trigger(classpath=\"airflow.triggers.testing.SuccessTrigger\", kwargs={})",
          "164:     trigger_on_killed_triggerer.triggerer_id = finished_triggerer.id",
          "165:     trigger_unassigned_to_triggerer = Trigger(classpath=\"airflow.triggers.testing.SuccessTrigger\", kwargs={})",
          "167:     assert trigger_unassigned_to_triggerer.triggerer_id is None",
          "168:     session.add(trigger_on_healthy_triggerer)",
          "169:     session.add(trigger_on_killed_triggerer)",
          "170:     session.add(trigger_unassigned_to_triggerer)",
          "171:     session.commit()",
          "174:     session.expire_all()",
          "175:     # Check that trigger on killed triggerer and unassigned trigger are assigned to new triggerer",
          "176:     assert (",
          "",
          "[Removed Lines]",
          "163:     trigger_on_killed_triggerer.id = 2",
          "166:     trigger_unassigned_to_triggerer.id = 3",
          "172:     assert session.query(Trigger).count() == 3",
          "173:     Trigger.assign_unassigned(new_triggerer.id, 100, session=session, heartrate=triggerer_heartrate)",
          "",
          "[Added Lines]",
          "159:     # This trigger's last heartbeat is older than the check threshold, expect",
          "160:     # its triggers to be taken by other healthy triggerers below",
          "161:     unhealthy_triggerer = Job(",
          "162:         heartrate=triggerer_heartrate,",
          "163:         state=State.RUNNING,",
          "164:         latest_heartbeat=time_now - datetime.timedelta(seconds=100),",
          "165:     )",
          "166:     TriggererJobRunner(unhealthy_triggerer)",
          "167:     session.add(unhealthy_triggerer)",
          "168:     # Triggerer is not healtht, its last heartbeat was too long ago",
          "169:     assert not unhealthy_triggerer.is_alive()",
          "174:     trigger_on_unhealthy_triggerer = Trigger(classpath=\"airflow.triggers.testing.SuccessTrigger\", kwargs={})",
          "175:     trigger_on_unhealthy_triggerer.id = 2",
          "176:     trigger_on_unhealthy_triggerer.triggerer_id = unhealthy_triggerer.id",
          "178:     trigger_on_killed_triggerer.id = 3",
          "181:     trigger_unassigned_to_triggerer.id = 4",
          "184:     session.add(trigger_on_unhealthy_triggerer)",
          "188:     assert session.query(Trigger).count() == 4",
          "189:     Trigger.assign_unassigned(new_triggerer.id, 100, health_check_threshold=30)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "186:         session.query(Trigger).filter(Trigger.id == trigger_on_healthy_triggerer.id).one().triggerer_id",
          "187:         == healthy_triggerer.id",
          "188:     )",
          "246: def test_get_sorted_triggers(session, create_task_instance):",
          "",
          "[Removed Lines]",
          "191: @pytest.mark.parametrize(\"check_triggerer_heartrate\", [10, 60, 300])",
          "192: def test_assign_unassigned_missing_heartbeat(session, create_task_instance, check_triggerer_heartrate):",
          "193:     \"\"\"",
          "194:     Tests that the triggers assigned to a dead triggers are considered as unassigned",
          "195:     and they are  assigned to an alive triggerer.",
          "196:     \"\"\"",
          "197:     import time_machine",
          "199:     block_triggerer_heartrate = 9999",
          "200:     with time_machine.travel(datetime.datetime.utcnow(), tick=False) as t:",
          "201:         first_triggerer = Job(heartrate=block_triggerer_heartrate, state=State.RUNNING)",
          "202:         TriggererJobRunner(first_triggerer)",
          "203:         session.add(first_triggerer)",
          "204:         assert first_triggerer.is_alive()",
          "205:         second_triggerer = Job(heartrate=block_triggerer_heartrate, state=State.RUNNING)",
          "206:         TriggererJobRunner(second_triggerer)",
          "207:         session.add(second_triggerer)",
          "208:         assert second_triggerer.is_alive()",
          "209:         session.commit()",
          "210:         trigger_on_first_triggerer = Trigger(classpath=\"airflow.triggers.testing.SuccessTrigger\", kwargs={})",
          "211:         trigger_on_first_triggerer.id = 1",
          "212:         trigger_on_first_triggerer.triggerer_id = first_triggerer.id",
          "213:         trigger_on_second_triggerer = Trigger(classpath=\"airflow.triggers.testing.SuccessTrigger\", kwargs={})",
          "214:         trigger_on_second_triggerer.id = 2",
          "215:         trigger_on_second_triggerer.triggerer_id = second_triggerer.id",
          "216:         session.add(trigger_on_first_triggerer)",
          "217:         session.add(trigger_on_second_triggerer)",
          "218:         session.commit()",
          "219:         assert session.query(Trigger).count() == 2",
          "220:         triggers_ids = [",
          "221:             (first_triggerer.id, second_triggerer.id),",
          "222:             (first_triggerer.id, second_triggerer.id),",
          "223:             (first_triggerer.id, second_triggerer.id),",
          "224:             # Check that after more than 2.1 heartrates, the first triggerer is considered dead",
          "225:             # and the first trigger is assigned to the second triggerer",
          "226:             (second_triggerer.id, second_triggerer.id),",
          "227:         ]",
          "228:         for i in range(4):",
          "229:             Trigger.assign_unassigned(",
          "230:                 second_triggerer.id, 100, session=session, heartrate=check_triggerer_heartrate",
          "231:             )",
          "232:             session.expire_all()",
          "233:             # Check that trigger on killed triggerer and unassigned trigger are assigned to new triggerer",
          "234:             assert (",
          "235:                 session.query(Trigger).filter(Trigger.id == trigger_on_first_triggerer.id).one().triggerer_id",
          "236:                 == triggers_ids[i][0]",
          "237:             )",
          "238:             assert (",
          "239:                 session.query(Trigger).filter(Trigger.id == trigger_on_second_triggerer.id).one().triggerer_id",
          "240:                 == triggers_ids[i][1]",
          "241:             )",
          "242:             t.shift(datetime.timedelta(seconds=check_triggerer_heartrate))",
          "243:             second_triggerer.latest_heartbeat += datetime.timedelta(seconds=check_triggerer_heartrate)",
          "",
          "[Added Lines]",
          "205:     # Check that trigger on unhealthy triggerer is assigned to new triggerer",
          "206:     assert (",
          "207:         session.query(Trigger).filter(Trigger.id == trigger_on_unhealthy_triggerer.id).one().triggerer_id",
          "208:         == new_triggerer.id",
          "209:     )",
          "",
          "---------------"
        ]
      }
    }
  ]
}
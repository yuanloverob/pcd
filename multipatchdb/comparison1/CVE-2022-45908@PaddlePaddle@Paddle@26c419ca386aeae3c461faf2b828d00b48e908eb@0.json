{
  "cve_id": "CVE-2022-45908",
  "cve_desc": "In PaddlePaddle before 2.4, paddle.audio.functional.get_window is vulnerable to code injection because it calls eval on a user-supplied winstr. This may lead to arbitrary code execution.",
  "repo": "PaddlePaddle/Paddle",
  "patch_hash": "26c419ca386aeae3c461faf2b828d00b48e908eb",
  "patch_info": {
    "commit_hash": "26c419ca386aeae3c461faf2b828d00b48e908eb",
    "repo": "PaddlePaddle/Paddle",
    "commit_url": "https://github.com/PaddlePaddle/Paddle/commit/26c419ca386aeae3c461faf2b828d00b48e908eb",
    "files": [
      "python/paddle/audio/functional/window.py"
    ],
    "message": "[audio]fix audio get_window security error (#47386)\n\n* fix window security error\n\n* format",
    "before_after_code_files": [
      "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py"
    ]
  },
  "patch_diff": {
    "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py": [
      "File: python/paddle/audio/functional/window.py -> python/paddle/audio/functional/window.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "19: from paddle import Tensor",
      "22: def _cat(x: List[Tensor], data_type: str) -> Tensor:",
      "23:     l = [paddle.to_tensor(_, data_type) for _ in x]",
      "24:     return paddle.concat(l)",
      "27: def _acosh(x: Union[Tensor, float]) -> Tensor:",
      "28:     if isinstance(x, float):",
      "29:         return math.log(x + math.sqrt(x**2 - 1))",
      "30:     return paddle.log(x + paddle.sqrt(paddle.square(x) - 1))",
      "33: def _extend(M: int, sym: bool) -> bool:",
      "34:     \"\"\"Extend window by 1 sample if needed for DFT-even symmetry.\"\"\"",
      "35:     if not sym:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "22: class WindowFunctionRegister(object):",
      "23:     def __init__(self):",
      "24:         self._functions_dict = dict()",
      "26:     def register(self, func=None):",
      "27:         def add_subfunction(func):",
      "28:             name = func.__name__",
      "29:             self._functions_dict[name] = func",
      "30:             return func",
      "32:         return add_subfunction",
      "34:     def get(self, name):",
      "35:         return self._functions_dict[name]",
      "38: window_function_register = WindowFunctionRegister()",
      "41: @window_function_register.register()",
      "47: @window_function_register.register()",
      "54: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "38:         return M, False",
      "41: def _len_guards(M: int) -> bool:",
      "42:     \"\"\"Handle small or incorrect window lengths.\"\"\"",
      "43:     if int(M) != M or M < 0:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "63: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "46:     return M <= 1",
      "49: def _truncate(w: Tensor, needed: bool) -> Tensor:",
      "50:     \"\"\"Truncate window by 1 sample if needed for DFT-even symmetry.\"\"\"",
      "51:     if needed:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "72: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "54:         return w",
      "57: def _general_gaussian(",
      "58:     M: int, p, sig, sym: bool = True, dtype: str = 'float64'",
      "59: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "81: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "70:     return _truncate(w, needs_trunc)",
      "73: def _general_cosine(",
      "74:     M: int, a: float, sym: bool = True, dtype: str = 'float64'",
      "75: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "98: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "86:     return _truncate(w, needs_trunc)",
      "89: def _general_hamming(",
      "90:     M: int, alpha: float, sym: bool = True, dtype: str = 'float64'",
      "91: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "115: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "95:     return _general_cosine(M, [alpha, 1.0 - alpha], sym, dtype=dtype)",
      "98: def _taylor(",
      "99:     M: int, nbar=4, sll=30, norm=True, sym: bool = True, dtype: str = 'float64'",
      "100: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "125: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "151:     return _truncate(w, needs_trunc)",
      "154: def _hamming(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
      "155:     \"\"\"Compute a Hamming window.",
      "156:     The Hamming window is a taper formed by using a raised cosine with",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "182: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "159:     return _general_hamming(M, 0.54, sym, dtype=dtype)",
      "162: def _hann(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
      "163:     \"\"\"Compute a Hann window.",
      "164:     The Hann window is a taper formed by using a raised cosine or sine-squared",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "191: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "167:     return _general_hamming(M, 0.5, sym, dtype=dtype)",
      "170: def _tukey(",
      "171:     M: int, alpha=0.5, sym: bool = True, dtype: str = 'float64'",
      "172: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "200: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "200:     return _truncate(w, needs_trunc)",
      "203: def _kaiser(",
      "204:     M: int, beta: float, sym: bool = True, dtype: str = 'float64'",
      "205: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "234: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "209:     raise NotImplementedError()",
      "212: def _gaussian(",
      "213:     M: int, std: float, sym: bool = True, dtype: str = 'float64'",
      "214: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "244: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "226:     return _truncate(w, needs_trunc)",
      "229: def _exponential(",
      "230:     M: int, center=None, tau=1.0, sym: bool = True, dtype: str = 'float64'",
      "231: ) -> Tensor:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "262: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "245:     return _truncate(w, needs_trunc)",
      "248: def _triang(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
      "249:     \"\"\"Compute a triangular window.\"\"\"",
      "250:     if _len_guards(M):",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "282: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "262:     return _truncate(w, needs_trunc)",
      "265: def _bohman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
      "266:     \"\"\"Compute a Bohman window.",
      "267:     The Bohman window is the autocorrelation of a cosine window.",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "300: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "279:     return _truncate(w, needs_trunc)",
      "282: def _blackman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
      "283:     \"\"\"Compute a Blackman window.",
      "284:     The Blackman window is a taper formed by using the first three terms of",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "318: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "289:     return _general_cosine(M, [0.42, 0.50, 0.08], sym, dtype=dtype)",
      "292: def _cosine(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
      "293:     \"\"\"Compute a window with a simple cosine shape.\"\"\"",
      "294:     if _len_guards(M):",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "329: @window_function_register.register()",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "308:     \"\"\"Return a window of a given length and type.",
      "310:     Args:",
      "312:         win_length (int): Number of samples.",
      "313:         fftbins (bool, optional): If True, create a \"periodic\" window. Otherwise, create a \"symmetric\" window, for use in filter design. Defaults to True.",
      "314:         dtype (str, optional): The data type of the return window. Defaults to 'float64'.",
      "",
      "[Removed Lines]",
      "311:         window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.",
      "",
      "[Added Lines]",
      "349:         window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'general_gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "348:         )",
      "350:     try:",
      "353:         raise ValueError(\"Unknown window type.\") from e",
      "355:     params = (win_length,) + args",
      "",
      "[Removed Lines]",
      "351:         winfunc = eval('_' + winstr)",
      "352:     except NameError as e:",
      "",
      "[Added Lines]",
      "389:         winfunc = window_function_register.get('_' + winstr)",
      "390:     except KeyError as e:",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d4b68dafd3ca54b0e16d5b23261b849cdc42395f",
      "candidate_info": {
        "commit_hash": "d4b68dafd3ca54b0e16d5b23261b849cdc42395f",
        "repo": "PaddlePaddle/Paddle",
        "commit_url": "https://github.com/PaddlePaddle/Paddle/commit/d4b68dafd3ca54b0e16d5b23261b849cdc42395f",
        "files": [
          "python/paddle/audio/functional/window.py",
          "python/paddle/audio/utils/__init__.py",
          "python/paddle/audio/utils/error.py",
          "python/paddle/tests/test_audio_functions.py"
        ],
        "message": "[audio] rm kaiser window in audio get_window function && rm audio utils (#47469)\n\n* rm kaiser window in audio window function\n\n* rm paddle audio utils which is redundant\n\n* rm kaiser in test_audio_functions.py",
        "before_after_code_files": [
          "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py",
          "python/paddle/audio/utils/__init__.py||python/paddle/audio/utils/__init__.py",
          "python/paddle/audio/utils/error.py||python/paddle/audio/utils/error.py",
          "python/paddle/tests/test_audio_functions.py||python/paddle/tests/test_audio_functions.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py"
          ],
          "candidate": [
            "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py"
          ]
        }
      },
      "candidate_diff": {
        "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py": [
          "File: python/paddle/audio/functional/window.py -> python/paddle/audio/functional/window.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "231:     return _truncate(w, needs_trunc)",
          "244: @window_function_register.register()",
          "245: def _gaussian(",
          "246:     M: int, std: float, sym: bool = True, dtype: str = 'float64'",
          "",
          "[Removed Lines]",
          "234: @window_function_register.register()",
          "235: def _kaiser(",
          "236:     M: int, beta: float, sym: bool = True, dtype: str = 'float64'",
          "237: ) -> Tensor:",
          "238:     \"\"\"Compute a Kaiser window.",
          "239:     The Kaiser window is a taper formed by using a Bessel function.",
          "240:     \"\"\"",
          "241:     raise NotImplementedError()",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "346:     \"\"\"Return a window of a given length and type.",
          "348:     Args:",
          "350:         win_length (int): Number of samples.",
          "351:         fftbins (bool, optional): If True, create a \"periodic\" window. Otherwise, create a \"symmetric\" window, for use in filter design. Defaults to True.",
          "352:         dtype (str, optional): The data type of the return window. Defaults to 'float64'.",
          "",
          "[Removed Lines]",
          "349:         window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'general_gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.",
          "",
          "[Added Lines]",
          "339:         window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'gaussian', 'general_gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "363:             cosine_window = paddle.audio.functional.get_window('cosine', n_fft)",
          "365:             std = 7",
          "367:     \"\"\"",
          "368:     sym = not fftbins",
          "",
          "[Removed Lines]",
          "366:             gussian_window = paddle.audio.functional.get_window(('gaussian',std), n_fft)",
          "",
          "[Added Lines]",
          "356:             gaussian_window = paddle.audio.functional.get_window(('gaussian',std), n_fft)",
          "",
          "---------------"
        ],
        "python/paddle/audio/utils/__init__.py||python/paddle/audio/utils/__init__.py": [
          "File: python/paddle/audio/utils/__init__.py -> python/paddle/audio/utils/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "python/paddle/audio/utils/error.py||python/paddle/audio/utils/error.py": [
          "File: python/paddle/audio/utils/error.py -> python/paddle/audio/utils/error.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "python/paddle/tests/test_audio_functions.py||python/paddle/tests/test_audio_functions.py": [
          "File: python/paddle/tests/test_audio_functions.py -> python/paddle/tests/test_audio_functions.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "178:         np.testing.assert_array_almost_equal(",
          "179:             window_scipy_exp, window_paddle_exp.numpy(), decimal=5",
          "180:         )",
          "188:         try:",
          "189:             window_paddle = paddle.audio.functional.get_window(\"hann\", -1)",
          "190:         except ValueError:",
          "",
          "[Removed Lines]",
          "181:         try:",
          "182:             window_paddle = paddle.audio.functional.get_window(",
          "183:                 (\"kaiser\", 1.0), self.n_fft",
          "184:             )",
          "185:         except NotImplementedError:",
          "186:             pass",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7c1dc754f83228f1f29a90a5f8cb01f09cfe2b31",
      "candidate_info": {
        "commit_hash": "7c1dc754f83228f1f29a90a5f8cb01f09cfe2b31",
        "repo": "PaddlePaddle/Paddle",
        "commit_url": "https://github.com/PaddlePaddle/Paddle/commit/7c1dc754f83228f1f29a90a5f8cb01f09cfe2b31",
        "files": [
          "paddle/fluid/API.spec",
          "python/paddle/audio/__init__.py",
          "python/paddle/audio/features/__init__.py",
          "python/paddle/audio/features/layers.py",
          "python/paddle/audio/functional/__init__.py",
          "python/paddle/audio/functional/functional.py",
          "python/paddle/audio/functional/window.py",
          "python/paddle/audio/utils/__init__.py",
          "python/paddle/audio/utils/error.py",
          "python/paddle/tests/test_audio_functions.py",
          "python/paddle/tests/test_audio_logmel_feature.py",
          "python/paddle/tests/test_audio_mel_feature.py",
          "python/setup.py.in",
          "python/unittest_py/requirements.txt",
          "tools/dockerfile/ci_dockerfile.sh"
        ],
        "message": "Add paddle audio feature module (#45424)\n\n* add audio feature dataset\n\n* fix coding style\n\n* fix coding style2\n\n* rm librosa\n\n* rm voxceleb\n\n* rm librosa in test\n\n* add scipy fftpack\n\n* add functional\n\n* fix setup\n\n* fix setup2\n\n* rm colorlog\n\n* refactor dataset __init__.py\n\n* fix converage\n\n* fix librosa import error\n\n* fix windows test\n\n* fix windows ci\n\n* rm datasets\n\n* fix setup\n\n* remove testdata\n\n* add librosa in requirement\n\n* add librosa in requirement2\n\n* change librosa to 0.8.1\n\n* update ci docker\n\n* fix ci error\n\n* fix ci error2\n\n* fix ci coverage\n\n* fix converage\n\n* fix coverage\n\n* rm audio_base in test, notest,test=coverage\n\n* fix copyright\n\n* rm backend\n\n* rm compliance&&add function test\n\n* fix setup\n\n* fix windows\n\n* fix windows2\n\n* fix test timeout\n\n* fix ci time issue\n\n* rm test_audio_feature\n\n* avoid windows isssue, tmp\n\n* note windows isssue\n\n* skip windows issue\n\n* fix dtype in layers.mfcc && fix ci-static-check\n\n* add relative accuracy\n\n* modity API.spec\n\n* skip cuda11.2 test\n\n* skip cuda11.2 test2\n\n* skip cuda11.2",
        "before_after_code_files": [
          "paddle/fluid/API.spec||paddle/fluid/API.spec",
          "python/paddle/audio/__init__.py||python/paddle/audio/__init__.py",
          "python/paddle/audio/features/__init__.py||python/paddle/audio/features/__init__.py",
          "python/paddle/audio/features/layers.py||python/paddle/audio/features/layers.py",
          "python/paddle/audio/functional/__init__.py||python/paddle/audio/functional/__init__.py",
          "python/paddle/audio/functional/functional.py||python/paddle/audio/functional/functional.py",
          "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py",
          "python/paddle/audio/utils/__init__.py||python/paddle/audio/utils/__init__.py",
          "python/paddle/audio/utils/error.py||python/paddle/audio/utils/error.py",
          "python/paddle/tests/test_audio_functions.py||python/paddle/tests/test_audio_functions.py",
          "python/paddle/tests/test_audio_logmel_feature.py||python/paddle/tests/test_audio_logmel_feature.py",
          "python/paddle/tests/test_audio_mel_feature.py||python/paddle/tests/test_audio_mel_feature.py",
          "python/setup.py.in||python/setup.py.in",
          "tools/dockerfile/ci_dockerfile.sh||tools/dockerfile/ci_dockerfile.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py"
          ],
          "candidate": [
            "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py"
          ]
        }
      },
      "candidate_diff": {
        "paddle/fluid/API.spec||paddle/fluid/API.spec": [
          "File: paddle/fluid/API.spec -> paddle/fluid/API.spec",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: paddle.fluid.optimizer.PipelineOptimizer (paddle.fluid.optimizer.PipelineOptimizer, ('document', '2e55a29dbeb874934f7a1a1af3a22b8c'))",
          "2: paddle.fluid.optimizer.PipelineOptimizer.__init__ (ArgSpec(args=['self', 'optimizer', 'num_microbatches', 'start_cpu_core_id'], varargs=None, keywords=None, defaults=(1, 0)), ('document', '6adf97f83acf6453d4a6a4b1070f3754'))",
          "3: paddle.fluid.optimizer.PipelineOptimizer.minimize (ArgSpec(args=['self', 'loss', 'startup_program', 'parameter_list', 'no_grad_set'], varargs=None, keywords=None, defaults=(None, None, None)), ('document', '6adf97f83acf6453d4a6a4b1070f3754'))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: paddle.audio.features (ArgSpec(), ('document', 'd41d8cd98f00b204e9800998ecf8427e'))",
          "5: paddle.audio.features.layers.LogMelSpectrogram (ArgSpec(), ('document', 'c38b53606aa89215c4f00d3833e158b8'))",
          "6: paddle.audio.features.layers.LogMelSpectrogram.forward (ArgSpec(args=['self', 'x'], varargs=None, varkw=None, defaults=None, kwonlyargs=[], kwonlydefaults=None, annotations={'return': <class 'paddle.Tensor'>, 'x': <class 'paddle.Tensor'>}), ('document', '6c14f6f78dc697a6981cf90412e2f1ea'))",
          "7: paddle.audio.features.layers.LogMelSpectrogram.load_dict (ArgSpec(args=[], varargs='args', varkw='kwargs', defaults=None, kwonlyargs=[], kwonlydefaults=None, annotations={}), ('document', '01221a60445ee437f439a8cbe293f759'))",
          "8: paddle.audio.features.layers.LogMelSpectrogram.state_dict (ArgSpec(args=['self', 'destination', 'include_sublayers', 'structured_name_prefix', 'use_hook'], varargs=None, varkw=None, defaults=(None, True, '', True), kwonlyargs=[], kwonlydefaults=None, annotations={}), ('document', '0c01cb0c12220c9426ae49549b145b0b'))",
          "9: paddle.audio.features.layers.MFCC (ArgSpec(), ('document', 'bcbe6499830d9228a4f746ddd63b6c0f'))",
          "10: paddle.audio.features.layers.MFCC.forward (ArgSpec(args=['self', 'x'], varargs=None, varkw=None, defaults=None, kwonlyargs=[], kwonlydefaults=None, annotations={'return': <class 'paddle.Tensor'>, 'x': <class 'paddle.Tensor'>}), ('document', 'd86bcaa345f26851089bfdb3efecd9e7'))",
          "11: paddle.audio.features.layers.MelSpectrogram (ArgSpec(), ('document', 'adf4012310984568ae9da6170aa89f91'))",
          "12: paddle.audio.features.layers.MelSpectrogram.forward (ArgSpec(args=['self', 'x'], varargs=None, varkw=None, defaults=None, kwonlyargs=[], kwonlydefaults=None, annotations={'return': <class 'paddle.Tensor'>, 'x': <class 'paddle.Tensor'>}), ('document', '458e9d454c8773091567c6b400f48cf5'))",
          "13: paddle.audio.features.layers.Spectrogram (ArgSpec(), ('document', '83811af6da032099bf147e3e01a458e1'))",
          "14: paddle.audio.features.layers.Spectrogram.forward (ArgSpec(args=['self', 'x'], varargs=None, varkw=None, defaults=None, kwonlyargs=[], kwonlydefaults=None, annotations={'return': <class 'paddle.Tensor'>, 'x': <class 'paddle.Tensor'>}), ('document', 'ab11e318fca1410f743b5432394dea35'))",
          "15: paddle.audio.functional (ArgSpec(), ('document', 'd41d8cd98f00b204e9800998ecf8427e'))",
          "16: paddle.audio.functional.functional.compute_fbank_matrix (ArgSpec(args=['sr', 'n_fft', 'n_mels', 'f_min', 'f_max', 'htk', 'norm', 'dtype'], varargs=None, varkw=None, defaults=(64, 0.0, None, False, 'slaney', 'float32'), kwonlyargs=[], kwonlydefaults=None, annotations={'return': <class 'paddle.Tensor'>, 'sr': <class 'int'>, 'n_fft': <class 'int'>, 'n_mels': <class 'int'>, 'f_min': <class 'float'>, 'f_max': typing.Union[float, NoneType], 'htk': <class 'bool'>, 'norm': typing.Union[str, float], 'dtype': <class 'str'>}), ('document', '3c5411caa6baedb68860b09c81e0147c'))",
          "17: paddle.audio.functional.functional.create_dct (ArgSpec(args=['n_mfcc', 'n_mels', 'norm', 'dtype'], varargs=None, varkw=None, defaults=('ortho', 'float32'), kwonlyargs=[], kwonlydefaults=None, annotations={'return': <class 'paddle.Tensor'>, 'n_mfcc': <class 'int'>, 'n_mels': <class 'int'>, 'norm': typing.Union[str, NoneType], 'dtype': <class 'str'>}), ('document', 'c9c57550671f9725b053769411d2f65a'))",
          "18: paddle.audio.functional.functional.fft_frequencies (ArgSpec(args=['sr', 'n_fft', 'dtype'], varargs=None, varkw=None, defaults=('float32',), kwonlyargs=[], kwonlydefaults=None, annotations={'return': <class 'paddle.Tensor'>, 'sr': <class 'int'>, 'n_fft': <class 'int'>, 'dtype': <class 'str'>}), ('document', '057b990e79c9c780622407267c0a43c6'))",
          "19: paddle.audio.functional.functional.hz_to_mel (ArgSpec(args=['freq', 'htk'], varargs=None, varkw=None, defaults=(False,), kwonlyargs=[], kwonlydefaults=None, annotations={'return': typing.Union[paddle.Tensor, float], 'freq': typing.Union[paddle.Tensor, float], 'htk': <class 'bool'>}), ('document', '7ca01521dd0bf26cd3f72c67f7168dc4'))",
          "20: paddle.audio.functional.functional.mel_frequencies (ArgSpec(args=['n_mels', 'f_min', 'f_max', 'htk', 'dtype'], varargs=None, varkw=None, defaults=(64, 0.0, 11025.0, False, 'float32'), kwonlyargs=[], kwonlydefaults=None, annotations={'return': <class 'paddle.Tensor'>, 'n_mels': <class 'int'>, 'f_min': <class 'float'>, 'f_max': <class 'float'>, 'htk': <class 'bool'>, 'dtype': <class 'str'>}), ('document', '2af3cf997ed1274214ec240b2b59a98d'))",
          "21: paddle.audio.functional.functional.mel_to_hz (ArgSpec(args=['mel', 'htk'], varargs=None, varkw=None, defaults=(False,), kwonlyargs=[], kwonlydefaults=None, annotations={'return': typing.Union[float, paddle.Tensor], 'mel': typing.Union[float, paddle.Tensor], 'htk': <class 'bool'>}), ('document', 'e93b432d382f98c60d7c7599489e7072'))",
          "22: paddle.audio.functional.functional.power_to_db (ArgSpec(args=['spect', 'ref_value', 'amin', 'top_db'], varargs=None, varkw=None, defaults=(1.0, 1e-10, 80.0), kwonlyargs=[], kwonlydefaults=None, annotations={'return': <class 'paddle.Tensor'>, 'spect': <class 'paddle.Tensor'>, 'ref_value': <class 'float'>, 'amin': <class 'float'>, 'top_db': typing.Union[float, NoneType]}), ('document', '28bbb1973e8399e856bfaea0415cecb9'))",
          "23: paddle.audio.functional.window.get_window (ArgSpec(args=['window', 'win_length', 'fftbins', 'dtype'], varargs=None, varkw=None, defaults=(True, 'float64'), kwonlyargs=[], kwonlydefaults=None, annotations={'return': <class 'paddle.Tensor'>, 'window': typing.Union[str, typing.Tuple[str, float]], 'win_length': <class 'int'>, 'fftbins': <class 'bool'>, 'dtype': <class 'str'>}), ('document', '2418d63da10c0cd5da9ecf0a88ddf783'))",
          "24: paddle.audio.utils (ArgSpec(), ('document', 'd41d8cd98f00b204e9800998ecf8427e'))",
          "25: paddle.audio.utils.error.ParameterError (ArgSpec(), ('document', 'e12783df4d137af121ebadceb389bf7a'))",
          "26: paddle.audio.utils.error.ParameterError.args (ArgSpec(), ('document', 'd41d8cd98f00b204e9800998ecf8427e'))",
          "27: paddle.audio.utils.error.ParameterError.with_traceback (ArgSpec(), ('document', '3f2d1353ad5034ed0f4628f2c9f066cc'))",
          "",
          "---------------"
        ],
        "python/paddle/audio/__init__.py||python/paddle/audio/__init__.py": [
          "File: python/paddle/audio/__init__.py -> python/paddle/audio/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved.",
          "2: #",
          "3: # Licensed under the Apache License, Version 2.0 (the \"License\");",
          "4: # you may not use this file except in compliance with the License.",
          "5: # You may obtain a copy of the License at",
          "6: #",
          "7: #     http://www.apache.org/licenses/LICENSE-2.0",
          "8: #",
          "9: # Unless required by applicable law or agreed to in writing, software",
          "10: # distributed under the License is distributed on an \"AS IS\" BASIS,",
          "11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "12: # See the License for the specific language governing permissions and",
          "13: # limitations under the License.",
          "15: from . import features",
          "16: from . import functional",
          "17: from . import utils",
          "19: __all__ = [\"functional\", \"features\", \"utils\"]",
          "",
          "---------------"
        ],
        "python/paddle/audio/features/__init__.py||python/paddle/audio/features/__init__.py": [
          "File: python/paddle/audio/features/__init__.py -> python/paddle/audio/features/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved.",
          "2: #",
          "3: # Licensed under the Apache License, Version 2.0 (the \"License\");",
          "4: # you may not use this file except in compliance with the License.",
          "5: # You may obtain a copy of the License at",
          "6: #",
          "7: #     http://www.apache.org/licenses/LICENSE-2.0",
          "8: #",
          "9: # Unless required by applicable law or agreed to in writing, software",
          "10: # distributed under the License is distributed on an \"AS IS\" BASIS,",
          "11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "12: # See the License for the specific language governing permissions and",
          "13: # limitations under the License.",
          "14: from .layers import LogMelSpectrogram",
          "15: from .layers import MelSpectrogram",
          "16: from .layers import MFCC",
          "17: from .layers import Spectrogram",
          "",
          "---------------"
        ],
        "python/paddle/audio/features/layers.py||python/paddle/audio/features/layers.py": [
          "File: python/paddle/audio/features/layers.py -> python/paddle/audio/features/layers.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved.",
          "2: #",
          "3: # Licensed under the Apache License, Version 2.0 (the \"License\");",
          "4: # you may not use this file except in compliance with the License.",
          "5: # You may obtain a copy of the License at",
          "6: #",
          "7: #     http://www.apache.org/licenses/LICENSE-2.0",
          "8: #",
          "9: # Unless required by applicable law or agreed to in writing, software",
          "10: # distributed under the License is distributed on an \"AS IS\" BASIS,",
          "11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "12: # See the License for the specific language governing permissions and",
          "13: # limitations under the License.",
          "14: from functools import partial",
          "15: from typing import Optional",
          "16: from typing import Union",
          "18: import paddle",
          "19: import paddle.nn as nn",
          "20: from paddle import Tensor",
          "22: from ..functional import compute_fbank_matrix",
          "23: from ..functional import create_dct",
          "24: from ..functional import power_to_db",
          "25: from ..functional.window import get_window",
          "27: __all__ = [",
          "28:     'Spectrogram',",
          "29:     'MelSpectrogram',",
          "30:     'LogMelSpectrogram',",
          "31:     'MFCC',",
          "32: ]",
          "35: class Spectrogram(nn.Layer):",
          "36:     \"\"\"Compute spectrogram of given signals, typically audio waveforms.",
          "37:     The spectorgram is defined as the complex norm of the short-time Fourier transformation.",
          "39:     Args:",
          "40:         n_fft (int, optional): The number of frequency components of the discrete Fourier transform. Defaults to 512.",
          "41:         hop_length (Optional[int], optional): The hop length of the short time FFT. If `None`, it is set to `win_length//4`. Defaults to None.",
          "42:         win_length (Optional[int], optional): The window length of the short time FFT. If `None`, it is set to same as `n_fft`. Defaults to None.",
          "43:         window (str, optional): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'. Defaults to 'hann'.",
          "44:         power (float, optional): Exponent for the magnitude spectrogram. Defaults to 2.0.",
          "45:         center (bool, optional): Whether to pad `x` to make that the :math:`t \\times hop\\\\_length` at the center of `t`-th frame. Defaults to True.",
          "46:         pad_mode (str, optional): Choose padding pattern when `center` is `True`. Defaults to 'reflect'.",
          "47:         dtype (str, optional): Data type of input and window. Defaults to 'float32'.",
          "48:     \"\"\"",
          "50:     def __init__(self,",
          "51:                  n_fft: int = 512,",
          "52:                  hop_length: Optional[int] = 512,",
          "53:                  win_length: Optional[int] = None,",
          "54:                  window: str = 'hann',",
          "55:                  power: float = 1.0,",
          "56:                  center: bool = True,",
          "57:                  pad_mode: str = 'reflect',",
          "58:                  dtype: str = 'float32') -> None:",
          "59:         super(Spectrogram, self).__init__()",
          "61:         assert power > 0, 'Power of spectrogram must be > 0.'",
          "62:         self.power = power",
          "64:         if win_length is None:",
          "65:             win_length = n_fft",
          "67:         self.fft_window = get_window(window,",
          "68:                                      win_length,",
          "69:                                      fftbins=True,",
          "70:                                      dtype=dtype)",
          "71:         self._stft = partial(paddle.signal.stft,",
          "72:                              n_fft=n_fft,",
          "73:                              hop_length=hop_length,",
          "74:                              win_length=win_length,",
          "75:                              window=self.fft_window,",
          "76:                              center=center,",
          "77:                              pad_mode=pad_mode)",
          "78:         self.register_buffer('fft_window', self.fft_window)",
          "80:     def forward(self, x: Tensor) -> Tensor:",
          "81:         \"\"\"",
          "82:         Args:",
          "83:             x (Tensor): Tensor of waveforms with shape `(N, T)`",
          "85:         Returns:",
          "86:             Tensor: Spectrograms with shape `(N, n_fft//2 + 1, num_frames)`.",
          "87:         \"\"\"",
          "88:         stft = self._stft(x)",
          "89:         spectrogram = paddle.pow(paddle.abs(stft), self.power)",
          "90:         return spectrogram",
          "93: class MelSpectrogram(nn.Layer):",
          "94:     \"\"\"Compute the melspectrogram of given signals, typically audio waveforms. It is computed by multiplying spectrogram with Mel filter bank matrix.",
          "96:     Args:",
          "97:         sr (int, optional): Sample rate. Defaults to 22050.",
          "98:         n_fft (int, optional): The number of frequency components of the discrete Fourier transform. Defaults to 512.",
          "99:         hop_length (Optional[int], optional): The hop length of the short time FFT. If `None`, it is set to `win_length//4`. Defaults to None.",
          "100:         win_length (Optional[int], optional): The window length of the short time FFT. If `None`, it is set to same as `n_fft`. Defaults to None.",
          "101:         window (str, optional): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'. Defaults to 'hann'.",
          "102:         power (float, optional): Exponent for the magnitude spectrogram. Defaults to 2.0.",
          "103:         center (bool, optional): Whether to pad `x` to make that the :math:`t \\times hop\\\\_length` at the center of `t`-th frame. Defaults to True.",
          "104:         pad_mode (str, optional): Choose padding pattern when `center` is `True`. Defaults to 'reflect'.",
          "105:         n_mels (int, optional): Number of mel bins. Defaults to 64.",
          "106:         f_min (float, optional): Minimum frequency in Hz. Defaults to 50.0.",
          "107:         f_max (Optional[float], optional): Maximum frequency in Hz. Defaults to None.",
          "108:         htk (bool, optional): Use HTK formula in computing fbank matrix. Defaults to False.",
          "109:         norm (Union[str, float], optional): Type of normalization in computing fbank matrix. Slaney-style is used by default. You can specify norm=1.0/2.0 to use customized p-norm normalization. Defaults to 'slaney'.",
          "110:         dtype (str, optional): Data type of input and window. Defaults to 'float32'.",
          "111:     \"\"\"",
          "113:     def __init__(self,",
          "114:                  sr: int = 22050,",
          "115:                  n_fft: int = 2048,",
          "116:                  hop_length: Optional[int] = 512,",
          "117:                  win_length: Optional[int] = None,",
          "118:                  window: str = 'hann',",
          "119:                  power: float = 2.0,",
          "120:                  center: bool = True,",
          "121:                  pad_mode: str = 'reflect',",
          "122:                  n_mels: int = 64,",
          "123:                  f_min: float = 50.0,",
          "124:                  f_max: Optional[float] = None,",
          "125:                  htk: bool = False,",
          "126:                  norm: Union[str, float] = 'slaney',",
          "127:                  dtype: str = 'float32') -> None:",
          "128:         super(MelSpectrogram, self).__init__()",
          "130:         self._spectrogram = Spectrogram(n_fft=n_fft,",
          "131:                                         hop_length=hop_length,",
          "132:                                         win_length=win_length,",
          "133:                                         window=window,",
          "134:                                         power=power,",
          "135:                                         center=center,",
          "136:                                         pad_mode=pad_mode,",
          "137:                                         dtype=dtype)",
          "138:         self.n_mels = n_mels",
          "139:         self.f_min = f_min",
          "140:         self.f_max = f_max",
          "141:         self.htk = htk",
          "142:         self.norm = norm",
          "143:         if f_max is None:",
          "144:             f_max = sr // 2",
          "145:         self.fbank_matrix = compute_fbank_matrix(sr=sr,",
          "146:                                                  n_fft=n_fft,",
          "147:                                                  n_mels=n_mels,",
          "148:                                                  f_min=f_min,",
          "149:                                                  f_max=f_max,",
          "150:                                                  htk=htk,",
          "151:                                                  norm=norm,",
          "152:                                                  dtype=dtype)",
          "153:         self.register_buffer('fbank_matrix', self.fbank_matrix)",
          "155:     def forward(self, x: Tensor) -> Tensor:",
          "156:         \"\"\"",
          "157:         Args:",
          "158:             x (Tensor): Tensor of waveforms with shape `(N, T)`",
          "160:         Returns:",
          "161:             Tensor: Mel spectrograms with shape `(N, n_mels, num_frames)`.",
          "162:         \"\"\"",
          "163:         spect_feature = self._spectrogram(x)",
          "164:         mel_feature = paddle.matmul(self.fbank_matrix, spect_feature)",
          "165:         return mel_feature",
          "168: class LogMelSpectrogram(nn.Layer):",
          "169:     \"\"\"Compute log-mel-spectrogram feature of given signals, typically audio waveforms.",
          "171:     Args:",
          "172:         sr (int, optional): Sample rate. Defaults to 22050.",
          "173:         n_fft (int, optional): The number of frequency components of the discrete Fourier transform. Defaults to 512.",
          "174:         hop_length (Optional[int], optional): The hop length of the short time FFT. If `None`, it is set to `win_length//4`. Defaults to None.",
          "175:         win_length (Optional[int], optional): The window length of the short time FFT. If `None`, it is set to same as `n_fft`. Defaults to None.",
          "176:         window (str, optional): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'. Defaults to 'hann'.",
          "177:         power (float, optional): Exponent for the magnitude spectrogram. Defaults to 2.0.",
          "178:         center (bool, optional): Whether to pad `x` to make that the :math:`t \\times hop\\\\_length` at the center of `t`-th frame. Defaults to True.",
          "179:         pad_mode (str, optional): Choose padding pattern when `center` is `True`. Defaults to 'reflect'.",
          "180:         n_mels (int, optional): Number of mel bins. Defaults to 64.",
          "181:         f_min (float, optional): Minimum frequency in Hz. Defaults to 50.0.",
          "182:         f_max (Optional[float], optional): Maximum frequency in Hz. Defaults to None.",
          "183:         htk (bool, optional): Use HTK formula in computing fbank matrix. Defaults to False.",
          "184:         norm (Union[str, float], optional): Type of normalization in computing fbank matrix. Slaney-style is used by default. You can specify norm=1.0/2.0 to use customized p-norm normalization. Defaults to 'slaney'.",
          "185:         ref_value (float, optional): The reference value. If smaller than 1.0, the db level of the signal will be pulled up accordingly. Otherwise, the db level is pushed down. Defaults to 1.0.",
          "186:         amin (float, optional): The minimum value of input magnitude. Defaults to 1e-10.",
          "187:         top_db (Optional[float], optional): The maximum db value of spectrogram. Defaults to None.",
          "188:         dtype (str, optional): Data type of input and window. Defaults to 'float32'.",
          "189:     \"\"\"",
          "191:     def __init__(self,",
          "192:                  sr: int = 22050,",
          "193:                  n_fft: int = 512,",
          "194:                  hop_length: Optional[int] = None,",
          "195:                  win_length: Optional[int] = None,",
          "196:                  window: str = 'hann',",
          "197:                  power: float = 2.0,",
          "198:                  center: bool = True,",
          "199:                  pad_mode: str = 'reflect',",
          "200:                  n_mels: int = 64,",
          "201:                  f_min: float = 50.0,",
          "202:                  f_max: Optional[float] = None,",
          "203:                  htk: bool = False,",
          "204:                  norm: Union[str, float] = 'slaney',",
          "205:                  ref_value: float = 1.0,",
          "206:                  amin: float = 1e-10,",
          "207:                  top_db: Optional[float] = None,",
          "208:                  dtype: str = 'float32') -> None:",
          "209:         super(LogMelSpectrogram, self).__init__()",
          "211:         self._melspectrogram = MelSpectrogram(sr=sr,",
          "212:                                               n_fft=n_fft,",
          "213:                                               hop_length=hop_length,",
          "214:                                               win_length=win_length,",
          "215:                                               window=window,",
          "216:                                               power=power,",
          "217:                                               center=center,",
          "218:                                               pad_mode=pad_mode,",
          "219:                                               n_mels=n_mels,",
          "220:                                               f_min=f_min,",
          "221:                                               f_max=f_max,",
          "222:                                               htk=htk,",
          "223:                                               norm=norm,",
          "224:                                               dtype=dtype)",
          "226:         self.ref_value = ref_value",
          "227:         self.amin = amin",
          "228:         self.top_db = top_db",
          "230:     def forward(self, x: Tensor) -> Tensor:",
          "231:         \"\"\"",
          "232:         Args:",
          "233:             x (Tensor): Tensor of waveforms with shape `(N, T)`",
          "235:         Returns:",
          "236:             Tensor: Log mel spectrograms with shape `(N, n_mels, num_frames)`.",
          "237:         \"\"\"",
          "238:         mel_feature = self._melspectrogram(x)",
          "239:         log_mel_feature = power_to_db(mel_feature,",
          "240:                                       ref_value=self.ref_value,",
          "241:                                       amin=self.amin,",
          "242:                                       top_db=self.top_db)",
          "243:         return log_mel_feature",
          "246: class MFCC(nn.Layer):",
          "247:     \"\"\"Compute mel frequency cepstral coefficients(MFCCs) feature of given waveforms.",
          "249:     Args:",
          "250:         sr (int, optional): Sample rate. Defaults to 22050.",
          "251:         n_mfcc (int, optional): [description]. Defaults to 40.",
          "252:         n_fft (int, optional): The number of frequency components of the discrete Fourier transform. Defaults to 512.",
          "253:         hop_length (Optional[int], optional): The hop length of the short time FFT. If `None`, it is set to `win_length//4`. Defaults to None.",
          "254:         win_length (Optional[int], optional): The window length of the short time FFT. If `None`, it is set to same as `n_fft`. Defaults to None.",
          "255:         window (str, optional): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'. Defaults to 'hann'.",
          "256:         power (float, optional): Exponent for the magnitude spectrogram. Defaults to 2.0.",
          "257:         center (bool, optional): Whether to pad `x` to make that the :math:`t \\times hop\\\\_length` at the center of `t`-th frame. Defaults to True.",
          "258:         pad_mode (str, optional): Choose padding pattern when `center` is `True`. Defaults to 'reflect'.",
          "259:         n_mels (int, optional): Number of mel bins. Defaults to 64.",
          "260:         f_min (float, optional): Minimum frequency in Hz. Defaults to 50.0.",
          "261:         f_max (Optional[float], optional): Maximum frequency in Hz. Defaults to None.",
          "262:         htk (bool, optional): Use HTK formula in computing fbank matrix. Defaults to False.",
          "263:         norm (Union[str, float], optional): Type of normalization in computing fbank matrix. Slaney-style is used by default. You can specify norm=1.0/2.0 to use customized p-norm normalization. Defaults to 'slaney'.",
          "264:         ref_value (float, optional): The reference value. If smaller than 1.0, the db level of the signal will be pulled up accordingly. Otherwise, the db level is pushed down. Defaults to 1.0.",
          "265:         amin (float, optional): The minimum value of input magnitude. Defaults to 1e-10.",
          "266:         top_db (Optional[float], optional): The maximum db value of spectrogram. Defaults to None.",
          "267:         dtype (str, optional): Data type of input and window. Defaults to 'float32'.",
          "268:     \"\"\"",
          "270:     def __init__(self,",
          "271:                  sr: int = 22050,",
          "272:                  n_mfcc: int = 40,",
          "273:                  n_fft: int = 512,",
          "274:                  hop_length: Optional[int] = None,",
          "275:                  win_length: Optional[int] = None,",
          "276:                  window: str = 'hann',",
          "277:                  power: float = 2.0,",
          "278:                  center: bool = True,",
          "279:                  pad_mode: str = 'reflect',",
          "280:                  n_mels: int = 64,",
          "281:                  f_min: float = 50.0,",
          "282:                  f_max: Optional[float] = None,",
          "283:                  htk: bool = False,",
          "284:                  norm: Union[str, float] = 'slaney',",
          "285:                  ref_value: float = 1.0,",
          "286:                  amin: float = 1e-10,",
          "287:                  top_db: Optional[float] = None,",
          "288:                  dtype: str = 'float32') -> None:",
          "289:         super(MFCC, self).__init__()",
          "290:         assert n_mfcc <= n_mels, 'n_mfcc cannot be larger than n_mels: %d vs %d' % (",
          "291:             n_mfcc, n_mels)",
          "292:         self._log_melspectrogram = LogMelSpectrogram(sr=sr,",
          "293:                                                      n_fft=n_fft,",
          "294:                                                      hop_length=hop_length,",
          "295:                                                      win_length=win_length,",
          "296:                                                      window=window,",
          "297:                                                      power=power,",
          "298:                                                      center=center,",
          "299:                                                      pad_mode=pad_mode,",
          "300:                                                      n_mels=n_mels,",
          "301:                                                      f_min=f_min,",
          "302:                                                      f_max=f_max,",
          "303:                                                      htk=htk,",
          "304:                                                      norm=norm,",
          "305:                                                      ref_value=ref_value,",
          "306:                                                      amin=amin,",
          "307:                                                      top_db=top_db,",
          "308:                                                      dtype=dtype)",
          "309:         self.dct_matrix = create_dct(n_mfcc=n_mfcc, n_mels=n_mels, dtype=dtype)",
          "310:         self.register_buffer('dct_matrix', self.dct_matrix)",
          "312:     def forward(self, x: Tensor) -> Tensor:",
          "313:         \"\"\"",
          "314:         Args:",
          "315:             x (Tensor): Tensor of waveforms with shape `(N, T)`",
          "317:         Returns:",
          "318:             Tensor: Mel frequency cepstral coefficients with shape `(N, n_mfcc, num_frames)`.",
          "319:         \"\"\"",
          "320:         log_mel_feature = self._log_melspectrogram(x)",
          "321:         mfcc = paddle.matmul(log_mel_feature.transpose(",
          "322:             (0, 2, 1)), self.dct_matrix).transpose((0, 2, 1))  # (B, n_mels, L)",
          "323:         return mfcc",
          "",
          "---------------"
        ],
        "python/paddle/audio/functional/__init__.py||python/paddle/audio/functional/__init__.py": [
          "File: python/paddle/audio/functional/__init__.py -> python/paddle/audio/functional/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved.",
          "2: #",
          "3: # Licensed under the Apache License, Version 2.0 (the \"License\");",
          "4: # you may not use this file except in compliance with the License.",
          "5: # You may obtain a copy of the License at",
          "6: #",
          "7: #     http://www.apache.org/licenses/LICENSE-2.0",
          "8: #",
          "9: # Unless required by applicable law or agreed to in writing, software",
          "10: # distributed under the License is distributed on an \"AS IS\" BASIS,",
          "11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "12: # See the License for the specific language governing permissions and",
          "13: # limitations under the License.",
          "14: from .functional import compute_fbank_matrix",
          "15: from .functional import create_dct",
          "16: from .functional import fft_frequencies",
          "17: from .functional import hz_to_mel",
          "18: from .functional import mel_frequencies",
          "19: from .functional import mel_to_hz",
          "20: from .functional import power_to_db",
          "21: from .window import get_window",
          "",
          "---------------"
        ],
        "python/paddle/audio/functional/functional.py||python/paddle/audio/functional/functional.py": [
          "File: python/paddle/audio/functional/functional.py -> python/paddle/audio/functional/functional.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved.",
          "2: #",
          "3: # Licensed under the Apache License, Version 2.0 (the \"License\");",
          "4: # you may not use this file except in compliance with the License.",
          "5: # You may obtain a copy of the License at",
          "6: #",
          "7: #     http://www.apache.org/licenses/LICENSE-2.0",
          "8: #",
          "9: # Unless required by applicable law or agreed to in writing, software",
          "10: # distributed under the License is distributed on an \"AS IS\" BASIS,",
          "11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "12: # See the License for the specific language governing permissions and",
          "13: # limitations under the License.",
          "14: # Modified from librosa(https://github.com/librosa/librosa)",
          "15: import math",
          "16: from typing import Optional",
          "17: from typing import Union",
          "19: import paddle",
          "20: from paddle import Tensor",
          "22: __all__ = [",
          "23:     'hz_to_mel',",
          "24:     'mel_to_hz',",
          "25:     'mel_frequencies',",
          "26:     'fft_frequencies',",
          "27:     'compute_fbank_matrix',",
          "28:     'power_to_db',",
          "29:     'create_dct',",
          "30: ]",
          "33: def hz_to_mel(freq: Union[Tensor, float],",
          "34:               htk: bool = False) -> Union[Tensor, float]:",
          "35:     \"\"\"Convert Hz to Mels.",
          "37:     Args:",
          "38:         freq (Union[Tensor, float]): The input tensor with arbitrary shape.",
          "39:         htk (bool, optional): Use htk scaling. Defaults to False.",
          "41:     Returns:",
          "42:         Union[Tensor, float]: Frequency in mels.",
          "43:     \"\"\"",
          "45:     if htk:",
          "46:         if isinstance(freq, Tensor):",
          "47:             return 2595.0 * paddle.log10(1.0 + freq / 700.0)",
          "48:         else:",
          "49:             return 2595.0 * math.log10(1.0 + freq / 700.0)",
          "51:     # Fill in the linear part",
          "52:     f_min = 0.0",
          "53:     f_sp = 200.0 / 3",
          "55:     mels = (freq - f_min) / f_sp",
          "57:     # Fill in the log-scale part",
          "59:     min_log_hz = 1000.0  # beginning of log region (Hz)",
          "60:     min_log_mel = (min_log_hz - f_min) / f_sp  # same (Mels)",
          "61:     logstep = math.log(6.4) / 27.0  # step size for log region",
          "63:     if isinstance(freq, Tensor):",
          "64:         target = min_log_mel + paddle.log(",
          "65:             freq / min_log_hz + 1e-10) / logstep  # prevent nan with 1e-10",
          "66:         mask = (freq > min_log_hz).astype(freq.dtype)",
          "67:         mels = target * mask + mels * (",
          "68:             1 - mask)  # will replace by masked_fill OP in future",
          "69:     else:",
          "70:         if freq >= min_log_hz:",
          "71:             mels = min_log_mel + math.log(freq / min_log_hz + 1e-10) / logstep",
          "73:     return mels",
          "76: def mel_to_hz(mel: Union[float, Tensor],",
          "77:               htk: bool = False) -> Union[float, Tensor]:",
          "78:     \"\"\"Convert mel bin numbers to frequencies.",
          "80:     Args:",
          "81:         mel (Union[float, Tensor]): The mel frequency represented as a tensor with arbitrary shape.",
          "82:         htk (bool, optional): Use htk scaling. Defaults to False.",
          "84:     Returns:",
          "85:         Union[float, Tensor]: Frequencies in Hz.",
          "86:     \"\"\"",
          "87:     if htk:",
          "88:         return 700.0 * (10.0**(mel / 2595.0) - 1.0)",
          "90:     f_min = 0.0",
          "91:     f_sp = 200.0 / 3",
          "92:     freqs = f_min + f_sp * mel",
          "93:     # And now the nonlinear scale",
          "94:     min_log_hz = 1000.0  # beginning of log region (Hz)",
          "95:     min_log_mel = (min_log_hz - f_min) / f_sp  # same (Mels)",
          "96:     logstep = math.log(6.4) / 27.0  # step size for log region",
          "97:     if isinstance(mel, Tensor):",
          "98:         target = min_log_hz * paddle.exp(logstep * (mel - min_log_mel))",
          "99:         mask = (mel > min_log_mel).astype(mel.dtype)",
          "100:         freqs = target * mask + freqs * (",
          "101:             1 - mask)  # will replace by masked_fill OP in future",
          "102:     else:",
          "103:         if mel >= min_log_mel:",
          "104:             freqs = min_log_hz * math.exp(logstep * (mel - min_log_mel))",
          "105:     return freqs",
          "108: def mel_frequencies(n_mels: int = 64,",
          "109:                     f_min: float = 0.0,",
          "110:                     f_max: float = 11025.0,",
          "111:                     htk: bool = False,",
          "112:                     dtype: str = 'float32') -> Tensor:",
          "113:     \"\"\"Compute mel frequencies.",
          "115:     Args:",
          "116:         n_mels (int, optional): Number of mel bins. Defaults to 64.",
          "117:         f_min (float, optional): Minimum frequency in Hz. Defaults to 0.0.",
          "118:         fmax (float, optional): Maximum frequency in Hz. Defaults to 11025.0.",
          "119:         htk (bool, optional): Use htk scaling. Defaults to False.",
          "120:         dtype (str, optional): The data type of the return frequencies. Defaults to 'float32'.",
          "122:     Returns:",
          "123:         Tensor: Tensor of n_mels frequencies in Hz with shape `(n_mels,)`.",
          "124:     \"\"\"",
          "125:     # 'Center freqs' of mel bands - uniformly spaced between limits",
          "126:     min_mel = hz_to_mel(f_min, htk=htk)",
          "127:     max_mel = hz_to_mel(f_max, htk=htk)",
          "128:     mels = paddle.linspace(min_mel, max_mel, n_mels, dtype=dtype)",
          "129:     freqs = mel_to_hz(mels, htk=htk)",
          "130:     return freqs",
          "133: def fft_frequencies(sr: int, n_fft: int, dtype: str = 'float32') -> Tensor:",
          "134:     \"\"\"Compute fourier frequencies.",
          "136:     Args:",
          "137:         sr (int): Sample rate.",
          "138:         n_fft (int): Number of fft bins.",
          "139:         dtype (str, optional): The data type of the return frequencies. Defaults to 'float32'.",
          "141:     Returns:",
          "142:         Tensor: FFT frequencies in Hz with shape `(n_fft//2 + 1,)`.",
          "143:     \"\"\"",
          "144:     return paddle.linspace(0, float(sr) / 2, int(1 + n_fft // 2), dtype=dtype)",
          "147: def compute_fbank_matrix(sr: int,",
          "148:                          n_fft: int,",
          "149:                          n_mels: int = 64,",
          "150:                          f_min: float = 0.0,",
          "151:                          f_max: Optional[float] = None,",
          "152:                          htk: bool = False,",
          "153:                          norm: Union[str, float] = 'slaney',",
          "154:                          dtype: str = 'float32') -> Tensor:",
          "155:     \"\"\"Compute fbank matrix.",
          "157:     Args:",
          "158:         sr (int): Sample rate.",
          "159:         n_fft (int): Number of fft bins.",
          "160:         n_mels (int, optional): Number of mel bins. Defaults to 64.",
          "161:         f_min (float, optional): Minimum frequency in Hz. Defaults to 0.0.",
          "162:         f_max (Optional[float], optional): Maximum frequency in Hz. Defaults to None.",
          "163:         htk (bool, optional): Use htk scaling. Defaults to False.",
          "164:         norm (Union[str, float], optional): Type of normalization. Defaults to 'slaney'.",
          "165:         dtype (str, optional): The data type of the return matrix. Defaults to 'float32'.",
          "167:     Returns:",
          "168:         Tensor: Mel transform matrix with shape `(n_mels, n_fft//2 + 1)`.",
          "169:     \"\"\"",
          "171:     if f_max is None:",
          "172:         f_max = float(sr) / 2",
          "174:     # Initialize the weights",
          "175:     weights = paddle.zeros((n_mels, int(1 + n_fft // 2)), dtype=dtype)",
          "177:     # Center freqs of each FFT bin",
          "178:     fftfreqs = fft_frequencies(sr=sr, n_fft=n_fft, dtype=dtype)",
          "180:     # 'Center freqs' of mel bands - uniformly spaced between limits",
          "181:     mel_f = mel_frequencies(n_mels + 2,",
          "182:                             f_min=f_min,",
          "183:                             f_max=f_max,",
          "184:                             htk=htk,",
          "185:                             dtype=dtype)",
          "187:     fdiff = mel_f[1:] - mel_f[:-1]  #np.diff(mel_f)",
          "188:     ramps = mel_f.unsqueeze(1) - fftfreqs.unsqueeze(0)",
          "189:     #ramps = np.subtract.outer(mel_f, fftfreqs)",
          "191:     for i in range(n_mels):",
          "192:         # lower and upper slopes for all bins",
          "193:         lower = -ramps[i] / fdiff[i]",
          "194:         upper = ramps[i + 2] / fdiff[i + 1]",
          "196:         # .. then intersect them with each other and zero",
          "197:         weights[i] = paddle.maximum(paddle.zeros_like(lower),",
          "198:                                     paddle.minimum(lower, upper))",
          "200:     # Slaney-style mel is scaled to be approx constant energy per channel",
          "201:     if norm == 'slaney':",
          "202:         enorm = 2.0 / (mel_f[2:n_mels + 2] - mel_f[:n_mels])",
          "203:         weights *= enorm.unsqueeze(1)",
          "204:     elif isinstance(norm, int) or isinstance(norm, float):",
          "205:         weights = paddle.nn.functional.normalize(weights, p=norm, axis=-1)",
          "207:     return weights",
          "210: def power_to_db(spect: Tensor,",
          "211:                 ref_value: float = 1.0,",
          "212:                 amin: float = 1e-10,",
          "213:                 top_db: Optional[float] = 80.0) -> Tensor:",
          "214:     \"\"\"Convert a power spectrogram (amplitude squared) to decibel (dB) units. The function computes the scaling `10 * log10(x / ref)` in a numerically stable way.",
          "216:     Args:",
          "217:         spect (Tensor): STFT power spectrogram.",
          "218:         ref_value (float, optional): The reference value. If smaller than 1.0, the db level of the signal will be pulled up accordingly. Otherwise, the db level is pushed down. Defaults to 1.0.",
          "219:         amin (float, optional): Minimum threshold. Defaults to 1e-10.",
          "220:         top_db (Optional[float], optional): Threshold the output at `top_db` below the peak. Defaults to None.",
          "222:     Returns:",
          "223:         Tensor: Power spectrogram in db scale.",
          "224:     \"\"\"",
          "225:     if amin <= 0:",
          "226:         raise Exception(\"amin must be strictly positive\")",
          "228:     if ref_value <= 0:",
          "229:         raise Exception(\"ref_value must be strictly positive\")",
          "231:     ones = paddle.ones_like(spect)",
          "232:     log_spec = 10.0 * paddle.log10(paddle.maximum(ones * amin, spect))",
          "233:     log_spec -= 10.0 * math.log10(max(ref_value, amin))",
          "235:     if top_db is not None:",
          "236:         if top_db < 0:",
          "237:             raise Exception(\"top_db must be non-negative\")",
          "238:         log_spec = paddle.maximum(log_spec, ones * (log_spec.max() - top_db))",
          "240:     return log_spec",
          "243: def create_dct(n_mfcc: int,",
          "244:                n_mels: int,",
          "245:                norm: Optional[str] = 'ortho',",
          "246:                dtype: str = 'float32') -> Tensor:",
          "247:     \"\"\"Create a discrete cosine transform(DCT) matrix.",
          "249:     Args:",
          "250:         n_mfcc (int): Number of mel frequency cepstral coefficients.",
          "251:         n_mels (int): Number of mel filterbanks.",
          "252:         norm (Optional[str], optional): Normalizaiton type. Defaults to 'ortho'.",
          "253:         dtype (str, optional): The data type of the return matrix. Defaults to 'float32'.",
          "255:     Returns:",
          "256:         Tensor: The DCT matrix with shape `(n_mels, n_mfcc)`.",
          "257:     \"\"\"",
          "258:     n = paddle.arange(n_mels, dtype=dtype)",
          "259:     k = paddle.arange(n_mfcc, dtype=dtype).unsqueeze(1)",
          "260:     dct = paddle.cos(math.pi / float(n_mels) * (n + 0.5) *",
          "261:                      k)  # size (n_mfcc, n_mels)",
          "262:     if norm is None:",
          "263:         dct *= 2.0",
          "264:     else:",
          "265:         assert norm == \"ortho\"",
          "266:         dct[0] *= 1.0 / math.sqrt(2.0)",
          "267:         dct *= math.sqrt(2.0 / float(n_mels))",
          "268:     return dct.T",
          "",
          "---------------"
        ],
        "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py": [
          "File: python/paddle/audio/functional/window.py -> python/paddle/audio/functional/window.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved",
          "2: #",
          "3: # Licensed under the Apache License, Version 2.0 (the \"License\");",
          "4: # you may not use this file except in compliance with the License.",
          "5: # You may obtain a copy of the License at",
          "6: #",
          "7: #     http://www.apache.org/licenses/LICENSE-2.0",
          "8: #",
          "9: # Unless required by applicable law or agreed to in writing, software",
          "10: # distributed under the License is distributed on an \"AS IS\" BASIS,",
          "11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "12: # See the License for the specific language governing permissions and",
          "13: import math",
          "14: from typing import List",
          "15: from typing import Tuple",
          "16: from typing import Union",
          "18: import paddle",
          "19: from paddle import Tensor",
          "21: __all__ = [",
          "22:     'get_window',",
          "23: ]",
          "26: def _cat(x: List[Tensor], data_type: str) -> Tensor:",
          "27:     l = [paddle.to_tensor(_, data_type) for _ in x]",
          "28:     return paddle.concat(l)",
          "31: def _acosh(x: Union[Tensor, float]) -> Tensor:",
          "32:     if isinstance(x, float):",
          "33:         return math.log(x + math.sqrt(x**2 - 1))",
          "34:     return paddle.log(x + paddle.sqrt(paddle.square(x) - 1))",
          "37: def _extend(M: int, sym: bool) -> bool:",
          "38:     \"\"\"Extend window by 1 sample if needed for DFT-even symmetry. \"\"\"",
          "39:     if not sym:",
          "40:         return M + 1, True",
          "41:     else:",
          "42:         return M, False",
          "45: def _len_guards(M: int) -> bool:",
          "46:     \"\"\"Handle small or incorrect window lengths. \"\"\"",
          "47:     if int(M) != M or M < 0:",
          "48:         raise ValueError('Window length M must be a non-negative integer')",
          "50:     return M <= 1",
          "53: def _truncate(w: Tensor, needed: bool) -> Tensor:",
          "54:     \"\"\"Truncate window by 1 sample if needed for DFT-even symmetry. \"\"\"",
          "55:     if needed:",
          "56:         return w[:-1]",
          "57:     else:",
          "58:         return w",
          "61: def _general_gaussian(M: int,",
          "62:                       p,",
          "63:                       sig,",
          "64:                       sym: bool = True,",
          "65:                       dtype: str = 'float64') -> Tensor:",
          "66:     \"\"\"Compute a window with a generalized Gaussian shape.",
          "67:     This function is consistent with scipy.signal.windows.general_gaussian().",
          "68:     \"\"\"",
          "69:     if _len_guards(M):",
          "70:         return paddle.ones((M, ), dtype=dtype)",
          "71:     M, needs_trunc = _extend(M, sym)",
          "73:     n = paddle.arange(0, M, dtype=dtype) - (M - 1.0) / 2.0",
          "74:     w = paddle.exp(-0.5 * paddle.abs(n / sig)**(2 * p))",
          "76:     return _truncate(w, needs_trunc)",
          "79: def _general_cosine(M: int,",
          "80:                     a: float,",
          "81:                     sym: bool = True,",
          "82:                     dtype: str = 'float64') -> Tensor:",
          "83:     \"\"\"Compute a generic weighted sum of cosine terms window.",
          "84:     This function is consistent with scipy.signal.windows.general_cosine().",
          "85:     \"\"\"",
          "86:     if _len_guards(M):",
          "87:         return paddle.ones((M, ), dtype=dtype)",
          "88:     M, needs_trunc = _extend(M, sym)",
          "89:     fac = paddle.linspace(-math.pi, math.pi, M, dtype=dtype)",
          "90:     w = paddle.zeros((M, ), dtype=dtype)",
          "91:     for k in range(len(a)):",
          "92:         w += a[k] * paddle.cos(k * fac)",
          "93:     return _truncate(w, needs_trunc)",
          "96: def _general_hamming(M: int,",
          "97:                      alpha: float,",
          "98:                      sym: bool = True,",
          "99:                      dtype: str = 'float64') -> Tensor:",
          "100:     \"\"\"Compute a generalized Hamming window.",
          "101:     This function is consistent with scipy.signal.windows.general_hamming()",
          "102:     \"\"\"",
          "103:     return _general_cosine(M, [alpha, 1. - alpha], sym, dtype=dtype)",
          "106: def _taylor(M: int,",
          "107:             nbar=4,",
          "108:             sll=30,",
          "109:             norm=True,",
          "110:             sym: bool = True,",
          "111:             dtype: str = 'float64') -> Tensor:",
          "112:     \"\"\"Compute a Taylor window.",
          "113:     The Taylor window taper function approximates the Dolph-Chebyshev window's",
          "114:     constant sidelobe level for a parameterized number of near-in sidelobes.",
          "115:     \"\"\"",
          "116:     if _len_guards(M):",
          "117:         return paddle.ones((M, ), dtype=dtype)",
          "118:     M, needs_trunc = _extend(M, sym)",
          "119:     # Original text uses a negative sidelobe level parameter and then negates",
          "120:     # it in the calculation of B. To keep consistent with other methods we",
          "121:     # assume the sidelobe level parameter to be positive.",
          "122:     B = 10**(sll / 20)",
          "123:     A = _acosh(B) / math.pi",
          "124:     s2 = nbar**2 / (A**2 + (nbar - 0.5)**2)",
          "125:     ma = paddle.arange(1, nbar, dtype=dtype)",
          "127:     Fm = paddle.empty((nbar - 1, ), dtype=dtype)",
          "128:     signs = paddle.empty_like(ma)",
          "129:     signs[::2] = 1",
          "130:     signs[1::2] = -1",
          "131:     m2 = ma * ma",
          "132:     for mi in range(len(ma)):",
          "133:         numer = signs[mi] * paddle.prod(1 - m2[mi] / s2 / (A**2 +",
          "134:                                                            (ma - 0.5)**2))",
          "135:         if mi == 0:",
          "136:             denom = 2 * paddle.prod(1 - m2[mi] / m2[mi + 1:])",
          "137:         elif mi == len(ma) - 1:",
          "138:             denom = 2 * paddle.prod(1 - m2[mi] / m2[:mi])",
          "139:         else:",
          "140:             denom = 2 * paddle.prod(1 - m2[mi] / m2[:mi]) * paddle.prod(",
          "141:                 1 - m2[mi] / m2[mi + 1:])",
          "143:         Fm[mi] = numer / denom",
          "145:     def W(n):",
          "146:         return 1 + 2 * paddle.matmul(",
          "147:             Fm.unsqueeze(0),",
          "148:             paddle.cos(2 * math.pi * ma.unsqueeze(1) * (n - M / 2. + 0.5) / M))",
          "150:     w = W(paddle.arange(0, M, dtype=dtype))",
          "152:     # normalize (Note that this is not described in the original text [1])",
          "153:     if norm:",
          "154:         scale = 1.0 / W((M - 1) / 2)",
          "155:         w *= scale",
          "156:     w = w.squeeze()",
          "157:     return _truncate(w, needs_trunc)",
          "160: def _hamming(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "161:     \"\"\"Compute a Hamming window.",
          "162:     The Hamming window is a taper formed by using a raised cosine with",
          "163:     non-zero endpoints, optimized to minimize the nearest side lobe.",
          "164:     \"\"\"",
          "165:     return _general_hamming(M, 0.54, sym, dtype=dtype)",
          "168: def _hann(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "169:     \"\"\"Compute a Hann window.",
          "170:     The Hann window is a taper formed by using a raised cosine or sine-squared",
          "171:     with ends that touch zero.",
          "172:     \"\"\"",
          "173:     return _general_hamming(M, 0.5, sym, dtype=dtype)",
          "176: def _tukey(M: int,",
          "177:            alpha=0.5,",
          "178:            sym: bool = True,",
          "179:            dtype: str = 'float64') -> Tensor:",
          "180:     \"\"\"Compute a Tukey window.",
          "181:     The Tukey window is also known as a tapered cosine window.",
          "182:     \"\"\"",
          "183:     if _len_guards(M):",
          "184:         return paddle.ones((M, ), dtype=dtype)",
          "186:     if alpha <= 0:",
          "187:         return paddle.ones((M, ), dtype=dtype)",
          "188:     elif alpha >= 1.0:",
          "189:         return hann(M, sym=sym)",
          "191:     M, needs_trunc = _extend(M, sym)",
          "193:     n = paddle.arange(0, M, dtype=dtype)",
          "194:     width = int(alpha * (M - 1) / 2.0)",
          "195:     n1 = n[0:width + 1]",
          "196:     n2 = n[width + 1:M - width - 1]",
          "197:     n3 = n[M - width - 1:]",
          "199:     w1 = 0.5 * (1 + paddle.cos(math.pi * (-1 + 2.0 * n1 / alpha / (M - 1))))",
          "200:     w2 = paddle.ones(n2.shape, dtype=dtype)",
          "201:     w3 = 0.5 * (1 + paddle.cos(math.pi * (-2.0 / alpha + 1 + 2.0 * n3 / alpha /",
          "202:                                           (M - 1))))",
          "203:     w = paddle.concat([w1, w2, w3])",
          "205:     return _truncate(w, needs_trunc)",
          "208: def _kaiser(M: int,",
          "209:             beta: float,",
          "210:             sym: bool = True,",
          "211:             dtype: str = 'float64') -> Tensor:",
          "212:     \"\"\"Compute a Kaiser window.",
          "213:     The Kaiser window is a taper formed by using a Bessel function.",
          "214:     \"\"\"",
          "215:     raise NotImplementedError()",
          "218: def _gaussian(M: int,",
          "219:               std: float,",
          "220:               sym: bool = True,",
          "221:               dtype: str = 'float64') -> Tensor:",
          "222:     \"\"\"Compute a Gaussian window.",
          "223:     The Gaussian widows has a Gaussian shape defined by the standard deviation(std).",
          "224:     \"\"\"",
          "225:     if _len_guards(M):",
          "226:         return paddle.ones((M, ), dtype=dtype)",
          "227:     M, needs_trunc = _extend(M, sym)",
          "229:     n = paddle.arange(0, M, dtype=dtype) - (M - 1.0) / 2.0",
          "230:     sig2 = 2 * std * std",
          "231:     w = paddle.exp(-n**2 / sig2)",
          "233:     return _truncate(w, needs_trunc)",
          "236: def _exponential(M: int,",
          "237:                  center=None,",
          "238:                  tau=1.,",
          "239:                  sym: bool = True,",
          "240:                  dtype: str = 'float64') -> Tensor:",
          "241:     \"\"\"Compute an exponential (or Poisson) window. \"\"\"",
          "242:     if sym and center is not None:",
          "243:         raise ValueError(\"If sym==True, center must be None.\")",
          "244:     if _len_guards(M):",
          "245:         return paddle.ones((M, ), dtype=dtype)",
          "246:     M, needs_trunc = _extend(M, sym)",
          "248:     if center is None:",
          "249:         center = (M - 1) / 2",
          "251:     n = paddle.arange(0, M, dtype=dtype)",
          "252:     w = paddle.exp(-paddle.abs(n - center) / tau)",
          "254:     return _truncate(w, needs_trunc)",
          "257: def _triang(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "258:     \"\"\"Compute a triangular window.",
          "259:     \"\"\"",
          "260:     if _len_guards(M):",
          "261:         return paddle.ones((M, ), dtype=dtype)",
          "262:     M, needs_trunc = _extend(M, sym)",
          "264:     n = paddle.arange(1, (M + 1) // 2 + 1, dtype=dtype)",
          "265:     if M % 2 == 0:",
          "266:         w = (2 * n - 1.0) / M",
          "267:         w = paddle.concat([w, w[::-1]])",
          "268:     else:",
          "269:         w = 2 * n / (M + 1.0)",
          "270:         w = paddle.concat([w, w[-2::-1]])",
          "272:     return _truncate(w, needs_trunc)",
          "275: def _bohman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "276:     \"\"\"Compute a Bohman window.",
          "277:     The Bohman window is the autocorrelation of a cosine window.",
          "278:     \"\"\"",
          "279:     if _len_guards(M):",
          "280:         return paddle.ones((M, ), dtype=dtype)",
          "281:     M, needs_trunc = _extend(M, sym)",
          "283:     fac = paddle.abs(paddle.linspace(-1, 1, M, dtype=dtype)[1:-1])",
          "284:     w = (1 - fac) * paddle.cos(math.pi * fac) + 1.0 / math.pi * paddle.sin(",
          "285:         math.pi * fac)",
          "286:     w = _cat([0, w, 0], dtype)",
          "288:     return _truncate(w, needs_trunc)",
          "291: def _blackman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "292:     \"\"\"Compute a Blackman window.",
          "293:     The Blackman window is a taper formed by using the first three terms of",
          "294:     a summation of cosines. It was designed to have close to the minimal",
          "295:     leakage possible.  It is close to optimal, only slightly worse than a",
          "296:     Kaiser window.",
          "297:     \"\"\"",
          "298:     return _general_cosine(M, [0.42, 0.50, 0.08], sym, dtype=dtype)",
          "301: def _cosine(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "302:     \"\"\"Compute a window with a simple cosine shape.",
          "303:     \"\"\"",
          "304:     if _len_guards(M):",
          "305:         return paddle.ones((M, ), dtype=dtype)",
          "306:     M, needs_trunc = _extend(M, sym)",
          "307:     w = paddle.sin(math.pi / M * (paddle.arange(0, M, dtype=dtype) + .5))",
          "309:     return _truncate(w, needs_trunc)",
          "312: def get_window(window: Union[str, Tuple[str, float]],",
          "313:                win_length: int,",
          "314:                fftbins: bool = True,",
          "315:                dtype: str = 'float64') -> Tensor:",
          "316:     \"\"\"Return a window of a given length and type.",
          "318:     Args:",
          "319:         window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.",
          "320:         win_length (int): Number of samples.",
          "321:         fftbins (bool, optional): If True, create a \"periodic\" window. Otherwise, create a \"symmetric\" window, for use in filter design. Defaults to True.",
          "322:         dtype (str, optional): The data type of the return window. Defaults to 'float64'.",
          "324:     Returns:",
          "325:         Tensor: The window represented as a tensor.",
          "326:     \"\"\"",
          "327:     sym = not fftbins",
          "329:     args = ()",
          "330:     if isinstance(window, tuple):",
          "331:         winstr = window[0]",
          "332:         if len(window) > 1:",
          "333:             args = window[1:]",
          "334:     elif isinstance(window, str):",
          "335:         if window in ['gaussian', 'exponential']:",
          "336:             raise ValueError(\"The '\" + window + \"' window needs one or \"",
          "337:                              \"more parameters -- pass a tuple.\")",
          "338:         else:",
          "339:             winstr = window",
          "340:     else:",
          "341:         raise ValueError(\"%s as window type is not supported.\" %",
          "342:                          str(type(window)))",
          "344:     try:",
          "345:         winfunc = eval('_' + winstr)",
          "346:     except NameError as e:",
          "347:         raise ValueError(\"Unknown window type.\") from e",
          "349:     params = (win_length, ) + args",
          "350:     kwargs = {'sym': sym}",
          "351:     return winfunc(*params, dtype=dtype, **kwargs)",
          "",
          "---------------"
        ],
        "python/paddle/audio/utils/__init__.py||python/paddle/audio/utils/__init__.py": [
          "File: python/paddle/audio/utils/__init__.py -> python/paddle/audio/utils/__init__.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved.",
          "2: #",
          "3: # Licensed under the Apache License, Version 2.0 (the \"License\"",
          "4: # you may not use this file except in compliance with the License.",
          "5: # You may obtain a copy of the License at",
          "6: #",
          "7: #     http://www.apache.org/licenses/LICENSE-2.0",
          "8: #",
          "9: # Unless required by applicable law or agreed to in writing, software",
          "10: # distributed under the License is distributed on an \"AS IS\" BASIS,",
          "11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "12: # See the License for the specific language governing permissions and",
          "13: # limitations under the License.",
          "14: from .error import ParameterError",
          "",
          "---------------"
        ],
        "python/paddle/audio/utils/error.py||python/paddle/audio/utils/error.py": [
          "File: python/paddle/audio/utils/error.py -> python/paddle/audio/utils/error.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved.",
          "2: #",
          "3: # Licensed under the Apache License, Version 2.0 (the \"License\");",
          "4: # you may not use this file except in compliance with the License.",
          "5: # You may obtain a copy of the License at",
          "6: #",
          "7: #     http://www.apache.org/licenses/LICENSE-2.0",
          "8: #",
          "9: # Unless required by applicable law or agreed to in writing, software",
          "10: # distributed under the License is distributed on an \"AS IS\" BASIS,",
          "11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "12: # See the License for the specific language governing permissions and",
          "13: # limitations under the License.",
          "15: __all__ = ['ParameterError']",
          "18: class ParameterError(Exception):",
          "19:     \"\"\"Exception class for Parameter checking\"\"\"",
          "20:     pass",
          "",
          "---------------"
        ],
        "python/paddle/tests/test_audio_functions.py||python/paddle/tests/test_audio_functions.py": [
          "File: python/paddle/tests/test_audio_functions.py -> python/paddle/tests/test_audio_functions.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved.",
          "2: #",
          "3: # Licensed under the Apache License, Version 2.0 (the \"License\");",
          "4: # you may not use this file except in compliance with the License.",
          "5: # You may obtain a copy of the License at",
          "6: #",
          "7: #     http://www.apache.org/licenses/LICENSE-2.0",
          "8: #",
          "9: # Unless required by applicable law or agreed to in writing, software",
          "10: # distributed under the License is distributed on an \"AS IS\" BASIS,",
          "11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "12: # See the License for the specific language governing permissions and",
          "13: # limitations under the License.",
          "14: import unittest",
          "16: import librosa",
          "17: import numpy as np",
          "18: import os",
          "19: import paddle",
          "21: import paddle.audio",
          "22: from scipy import signal",
          "23: import itertools",
          "24: from parameterized import parameterized",
          "27: def parameterize(*params):",
          "28:     return parameterized.expand(list(itertools.product(*params)))",
          "31: class TestAudioFuncitons(unittest.TestCase):",
          "33:     def setUp(self):",
          "34:         self.initParmas()",
          "36:     def initParmas(self):",
          "38:         def get_wav_data(dtype: str, num_channels: int, num_frames: int):",
          "39:             dtype_ = getattr(paddle, dtype)",
          "40:             base = paddle.linspace(-1.0, 1.0, num_frames, dtype=dtype_) * 0.1",
          "41:             data = base.tile([num_channels, 1])",
          "42:             return data",
          "44:         self.n_fft = 512",
          "45:         self.hop_length = 128",
          "46:         self.n_mels = 40",
          "47:         self.n_mfcc = 20",
          "48:         self.fmin = 0.0",
          "49:         self.window_str = 'hann'",
          "50:         self.pad_mode = 'reflect'",
          "51:         self.top_db = 80.0",
          "52:         self.duration = 0.5",
          "53:         self.num_channels = 1",
          "54:         self.sr = 16000",
          "55:         self.dtype = \"float32\"",
          "56:         self.window_size = 1024",
          "57:         waveform_tensor = get_wav_data(self.dtype,",
          "58:                                        self.num_channels,",
          "59:                                        num_frames=self.duration * self.sr)",
          "60:         self.waveform = waveform_tensor.numpy()",
          "62:     @parameterize([1.0, 3.0, 9.0, 25.0], [True, False])",
          "63:     def test_audio_function(self, val: float, htk_flag: bool):",
          "64:         mel_paddle = paddle.audio.functional.hz_to_mel(val, htk_flag)",
          "65:         mel_paddle_tensor = paddle.audio.functional.hz_to_mel(",
          "66:             paddle.to_tensor(val), htk_flag)",
          "67:         mel_librosa = librosa.hz_to_mel(val, htk_flag)",
          "68:         np.testing.assert_almost_equal(mel_paddle, mel_librosa, decimal=5)",
          "69:         np.testing.assert_almost_equal(mel_paddle_tensor.numpy(),",
          "70:                                        mel_librosa,",
          "71:                                        decimal=4)",
          "73:         hz_paddle = paddle.audio.functional.mel_to_hz(val, htk_flag)",
          "74:         hz_paddle_tensor = paddle.audio.functional.mel_to_hz(",
          "75:             paddle.to_tensor(val), htk_flag)",
          "76:         hz_librosa = librosa.mel_to_hz(val, htk_flag)",
          "77:         np.testing.assert_almost_equal(hz_paddle, hz_librosa, decimal=4)",
          "78:         np.testing.assert_almost_equal(hz_paddle_tensor.numpy(),",
          "79:                                        hz_librosa,",
          "80:                                        decimal=4)",
          "82:         decibel_paddle = paddle.audio.functional.power_to_db(",
          "83:             paddle.to_tensor(val))",
          "84:         decibel_librosa = librosa.power_to_db(val)",
          "85:         np.testing.assert_almost_equal(decibel_paddle.numpy(),",
          "86:                                        decibel_paddle,",
          "87:                                        decimal=5)",
          "89:     @parameterize([64, 128, 256], [0.0, 0.5, 1.0], [10000, 11025],",
          "90:                   [False, True])",
          "91:     def test_audio_function_mel(self, n_mels: int, f_min: float, f_max: float,",
          "92:                                 htk_flag: bool):",
          "93:         librosa_mel_freq = librosa.mel_frequencies(n_mels, f_min, f_max,",
          "94:                                                    htk_flag)",
          "95:         paddle_mel_freq = paddle.audio.functional.mel_frequencies(",
          "96:             n_mels, f_min, f_max, htk_flag, 'float64')",
          "97:         np.testing.assert_almost_equal(paddle_mel_freq,",
          "98:                                        librosa_mel_freq,",
          "99:                                        decimal=3)",
          "101:     @parameterize([8000, 16000], [64, 128, 256])",
          "102:     def test_audio_function_fft(self, sr: int, n_fft: int):",
          "103:         librosa_fft = librosa.fft_frequencies(sr, n_fft)",
          "104:         paddle_fft = paddle.audio.functional.fft_frequencies(sr, n_fft)",
          "105:         np.testing.assert_almost_equal(paddle_fft, librosa_fft, decimal=5)",
          "107:     @parameterize([1.0, 3.0, 9.0])",
          "108:     def test_audio_function_exception(self, spect: float):",
          "109:         try:",
          "110:             paddle.audio.functional.power_to_db(paddle.to_tensor([spect]),",
          "111:                                                 amin=0)",
          "112:         except Exception:",
          "113:             pass",
          "115:         try:",
          "116:             paddle.audio.functional.power_to_db(paddle.to_tensor([spect]),",
          "117:                                                 ref_value=0)",
          "119:         except Exception:",
          "120:             pass",
          "122:         try:",
          "123:             paddle.audio.functional.power_to_db(paddle.to_tensor([spect]),",
          "124:                                                 top_db=-1)",
          "125:         except Exception:",
          "126:             pass",
          "128:     @parameterize([",
          "129:         \"hamming\", \"hann\", \"triang\", \"bohman\", \"blackman\", \"cosine\", \"tukey\",",
          "130:         \"taylor\"",
          "131:     ], [1, 512])",
          "132:     def test_window(self, window_type: str, n_fft: int):",
          "133:         window_scipy = signal.get_window(window_type, n_fft)",
          "134:         window_paddle = paddle.audio.functional.get_window(window_type, n_fft)",
          "135:         np.testing.assert_array_almost_equal(window_scipy,",
          "136:                                              window_paddle.numpy(),",
          "137:                                              decimal=5)",
          "139:     @parameterize([1, 512])",
          "140:     def test_gussian_window_and_exception(self, n_fft: int):",
          "141:         window_scipy_gaussain = signal.windows.gaussian(n_fft, std=7)",
          "142:         window_paddle_gaussian = paddle.audio.functional.get_window(",
          "143:             ('gaussian', 7), n_fft, False)",
          "144:         np.testing.assert_array_almost_equal(window_scipy_gaussain,",
          "145:                                              window_paddle_gaussian.numpy(),",
          "146:                                              decimal=5)",
          "147:         window_scipy_general_gaussain = signal.windows.general_gaussian(",
          "148:             n_fft, 1, 7)",
          "149:         window_paddle_general_gaussian = paddle.audio.functional.get_window(",
          "150:             ('general_gaussian', 1, 7), n_fft, False)",
          "151:         np.testing.assert_array_almost_equal(window_scipy_gaussain,",
          "152:                                              window_paddle_gaussian.numpy(),",
          "153:                                              decimal=5)",
          "155:         window_scipy_exp = signal.windows.exponential(n_fft)",
          "156:         window_paddle_exp = paddle.audio.functional.get_window(",
          "157:             ('exponential', None, 1), n_fft, False)",
          "158:         np.testing.assert_array_almost_equal(window_scipy_exp,",
          "159:                                              window_paddle_exp.numpy(),",
          "160:                                              decimal=5)",
          "161:         try:",
          "162:             window_paddle = paddle.audio.functional.get_window((\"kaiser\", 1.0),",
          "163:                                                                self.n_fft)",
          "164:         except NotImplementedError:",
          "165:             pass",
          "167:         try:",
          "168:             window_paddle = paddle.audio.functional.get_window(\"hann\", -1)",
          "169:         except ValueError:",
          "170:             pass",
          "172:         try:",
          "173:             window_paddle = paddle.audio.functional.get_window(",
          "174:                 \"fake_window\", self.n_fft)",
          "175:         except ValueError:",
          "176:             pass",
          "178:         try:",
          "179:             window_paddle = paddle.audio.functional.get_window(1043, self.n_fft)",
          "180:         except ValueError:",
          "181:             pass",
          "183:     @parameterize([5, 13, 23], [257, 513, 1025])",
          "184:     def test_create_dct(self, n_mfcc: int, n_mels: int):",
          "186:         def dct(n_filters, n_input):",
          "187:             basis = np.empty((n_filters, n_input))",
          "188:             basis[0, :] = 1.0 / np.sqrt(n_input)",
          "189:             samples = np.arange(1, 2 * n_input, 2) * np.pi / (2.0 * n_input)",
          "191:             for i in range(1, n_filters):",
          "192:                 basis[i, :] = np.cos(i * samples) * np.sqrt(2.0 / n_input)",
          "193:             return basis.T",
          "195:         librosa_dct = dct(n_mfcc, n_mels)",
          "196:         paddle_dct = paddle.audio.functional.create_dct(n_mfcc, n_mels)",
          "197:         np.testing.assert_array_almost_equal(librosa_dct, paddle_dct, decimal=5)",
          "199:     @parameterize([128, 256, 512], [\"hamming\", \"hann\", \"triang\", \"bohman\"],",
          "200:                   [True, False])",
          "201:     def test_stft_and_spect(self, n_fft: int, window_str: str,",
          "202:                             center_flag: bool):",
          "203:         hop_length = int(n_fft / 4)",
          "204:         if len(self.waveform.shape) == 2:  # (C, T)",
          "205:             self.waveform = self.waveform.squeeze(",
          "206:                 0)  # 1D input for librosa.feature.melspectrogram",
          "207:         feature_librosa = librosa.core.stft(",
          "208:             y=self.waveform,",
          "209:             n_fft=n_fft,",
          "210:             hop_length=hop_length,",
          "211:             win_length=None,",
          "212:             window=window_str,",
          "213:             center=center_flag,",
          "214:             dtype=None,",
          "215:             pad_mode=self.pad_mode,",
          "216:         )",
          "217:         x = paddle.to_tensor(self.waveform).unsqueeze(0)",
          "218:         window = paddle.audio.functional.get_window(window_str,",
          "219:                                                     n_fft,",
          "220:                                                     dtype=x.dtype)",
          "221:         feature_paddle = paddle.signal.stft(",
          "222:             x=x,",
          "223:             n_fft=n_fft,",
          "224:             hop_length=hop_length,",
          "225:             win_length=None,",
          "226:             window=window,",
          "227:             center=center_flag,",
          "228:             pad_mode=self.pad_mode,",
          "229:             normalized=False,",
          "230:             onesided=True,",
          "231:         ).squeeze(0)",
          "232:         np.testing.assert_array_almost_equal(feature_librosa,",
          "233:                                              feature_paddle,",
          "234:                                              decimal=5)",
          "236:         feature_bg = np.power(np.abs(feature_librosa), 2.0)",
          "237:         feature_extractor = paddle.audio.features.Spectrogram(",
          "238:             n_fft=n_fft,",
          "239:             hop_length=hop_length,",
          "240:             win_length=None,",
          "241:             window=window_str,",
          "242:             power=2.0,",
          "243:             center=center_flag,",
          "244:             pad_mode=self.pad_mode,",
          "245:         )",
          "246:         feature_layer = feature_extractor(x).squeeze(0)",
          "247:         np.testing.assert_array_almost_equal(feature_layer,",
          "248:                                              feature_bg,",
          "249:                                              decimal=3)",
          "251:     @parameterize([128, 256, 512], [64, 82],",
          "252:                   [\"hamming\", \"hann\", \"triang\", \"bohman\"])",
          "253:     def test_istft(self, n_fft: int, hop_length: int, window_str: str):",
          "254:         if len(self.waveform.shape) == 2:  # (C, T)",
          "255:             self.waveform = self.waveform.squeeze(",
          "256:                 0)  # 1D input for librosa.feature.melspectrogram",
          "257:         # librosa",
          "258:         # Get stft result from librosa.",
          "259:         stft_matrix = librosa.core.stft(",
          "260:             y=self.waveform,",
          "261:             n_fft=n_fft,",
          "262:             hop_length=hop_length,",
          "263:             win_length=None,",
          "264:             window=window_str,",
          "265:             center=True,",
          "266:             pad_mode=self.pad_mode,",
          "267:         )",
          "268:         feature_librosa = librosa.core.istft(",
          "269:             stft_matrix=stft_matrix,",
          "270:             hop_length=hop_length,",
          "271:             win_length=None,",
          "272:             window=window_str,",
          "273:             center=True,",
          "274:             dtype=None,",
          "275:             length=None,",
          "276:         )",
          "277:         x = paddle.to_tensor(stft_matrix).unsqueeze(0)",
          "278:         window = paddle.audio.functional.get_window(window_str,",
          "279:                                                     n_fft,",
          "280:                                                     dtype=paddle.to_tensor(",
          "281:                                                         self.waveform).dtype)",
          "282:         feature_paddle = paddle.signal.istft(",
          "283:             x=x,",
          "284:             n_fft=n_fft,",
          "285:             hop_length=hop_length,",
          "286:             win_length=None,",
          "287:             window=window,",
          "288:             center=True,",
          "289:             normalized=False,",
          "290:             onesided=True,",
          "291:             length=None,",
          "292:             return_complex=False,",
          "293:         ).squeeze(0)",
          "295:         np.testing.assert_array_almost_equal(feature_librosa,",
          "296:                                              feature_paddle,",
          "297:                                              decimal=5)",
          "300: if __name__ == '__main__':",
          "301:     unittest.main()",
          "",
          "---------------"
        ],
        "python/paddle/tests/test_audio_logmel_feature.py||python/paddle/tests/test_audio_logmel_feature.py": [
          "File: python/paddle/tests/test_audio_logmel_feature.py -> python/paddle/tests/test_audio_logmel_feature.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved.",
          "2: #",
          "3: # Licensed under the Apache License, Version 2.0 (the \"License\");",
          "4: # you may not use this file except in compliance with the License.",
          "5: # You may obtain a copy of the License at",
          "6: #",
          "7: #     http://www.apache.org/licenses/LICENSE-2.0",
          "8: #",
          "9: # Unless required by applicable law or agreed to in writing, software",
          "10: # distributed under the License is distributed on an \"AS IS\" BASIS,",
          "11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "12: # See the License for the specific language governing permissions and",
          "13: # limitations under the License.",
          "14: import unittest",
          "16: import librosa",
          "17: import numpy as np",
          "18: import os",
          "19: import paddle",
          "21: import paddle.audio",
          "22: import scipy",
          "23: from scipy import signal",
          "24: import itertools",
          "25: from parameterized import parameterized",
          "28: def parameterize(*params):",
          "29:     return parameterized.expand(list(itertools.product(*params)))",
          "32: class TestFeatures(unittest.TestCase):",
          "34:     def setUp(self):",
          "35:         self.initParmas()",
          "37:     def initParmas(self):",
          "39:         def get_wav_data(dtype: str, num_channels: int, num_frames: int):",
          "40:             dtype_ = getattr(paddle, dtype)",
          "41:             base = paddle.linspace(-1.0, 1.0, num_frames, dtype=dtype_) * 0.1",
          "42:             data = base.tile([num_channels, 1])",
          "43:             return data",
          "45:         self.fmin = 0.0",
          "46:         self.top_db = 80.0",
          "47:         self.duration = 0.5",
          "48:         self.num_channels = 1",
          "49:         self.sr = 16000",
          "50:         self.dtype = \"float32\"",
          "51:         waveform_tensor = get_wav_data(self.dtype,",
          "52:                                        self.num_channels,",
          "53:                                        num_frames=self.duration * self.sr)",
          "54:         self.waveform = waveform_tensor.numpy()",
          "56:     @parameterize([16000], [\"hamming\", \"bohman\"], [128], [128, 64], [64, 32],",
          "57:                   [0.0, 50.0])",
          "58:     def test_log_melspect(self, sr: int, window_str: str, n_fft: int,",
          "59:                           hop_length: int, n_mels: int, fmin: float):",
          "60:         if len(self.waveform.shape) == 2:  # (C, T)",
          "61:             self.waveform = self.waveform.squeeze(",
          "62:                 0)  # 1D input for librosa.feature.melspectrogram",
          "64:         # librosa:",
          "65:         feature_librosa = librosa.feature.melspectrogram(y=self.waveform,",
          "66:                                                          sr=sr,",
          "67:                                                          n_fft=n_fft,",
          "68:                                                          hop_length=hop_length,",
          "69:                                                          window=window_str,",
          "70:                                                          n_mels=n_mels,",
          "71:                                                          center=True,",
          "72:                                                          fmin=fmin,",
          "73:                                                          pad_mode='reflect')",
          "74:         feature_librosa = librosa.power_to_db(feature_librosa, top_db=None)",
          "75:         x = paddle.to_tensor(self.waveform, dtype=paddle.float64).unsqueeze(",
          "76:             0)  # Add batch dim.",
          "77:         feature_extractor = paddle.audio.features.LogMelSpectrogram(",
          "78:             sr=sr,",
          "79:             n_fft=n_fft,",
          "80:             hop_length=hop_length,",
          "81:             window=window_str,",
          "82:             center=True,",
          "83:             n_mels=n_mels,",
          "84:             f_min=fmin,",
          "85:             top_db=None,",
          "86:             dtype=x.dtype)",
          "87:         feature_layer = feature_extractor(x).squeeze(0).numpy()",
          "88:         np.testing.assert_array_almost_equal(feature_librosa,",
          "89:                                              feature_layer,",
          "90:                                              decimal=2)",
          "91:         # relative difference",
          "92:         np.testing.assert_allclose(feature_librosa, feature_layer, rtol=1e-4)",
          "94:     @parameterize([16000], [256, 128], [40, 64], [64, 128],",
          "95:                   ['float32', 'float64'])",
          "96:     def test_mfcc(self, sr: int, n_fft: int, n_mfcc: int, n_mels: int,",
          "97:                   dtype: str):",
          "98:         if paddle.version.cuda() != 'False':",
          "99:             if float(paddle.version.cuda()) >= 11.0:",
          "100:                 return",
          "102:         if len(self.waveform.shape) == 2:  # (C, T)",
          "103:             self.waveform = self.waveform.squeeze(",
          "104:                 0)  # 1D input for librosa.feature.melspectrogram",
          "106:         # librosa:",
          "107:         np_dtype = getattr(np, dtype)",
          "108:         feature_librosa = librosa.feature.mfcc(y=self.waveform,",
          "109:                                                sr=sr,",
          "110:                                                S=None,",
          "111:                                                n_mfcc=n_mfcc,",
          "112:                                                dct_type=2,",
          "113:                                                lifter=0,",
          "114:                                                n_fft=n_fft,",
          "115:                                                hop_length=64,",
          "116:                                                n_mels=n_mels,",
          "117:                                                fmin=50.0,",
          "118:                                                dtype=np_dtype)",
          "119:         # paddlespeech.audio.features.layer",
          "120:         x = paddle.to_tensor(self.waveform,",
          "121:                              dtype=dtype).unsqueeze(0)  # Add batch dim.",
          "122:         feature_extractor = paddle.audio.features.MFCC(sr=sr,",
          "123:                                                        n_mfcc=n_mfcc,",
          "124:                                                        n_fft=n_fft,",
          "125:                                                        hop_length=64,",
          "126:                                                        n_mels=n_mels,",
          "127:                                                        top_db=self.top_db,",
          "128:                                                        dtype=x.dtype)",
          "129:         feature_layer = feature_extractor(x).squeeze(0).numpy()",
          "131:         np.testing.assert_array_almost_equal(feature_librosa,",
          "132:                                              feature_layer,",
          "133:                                              decimal=3)",
          "135:         np.testing.assert_allclose(feature_librosa, feature_layer, rtol=1e-1)",
          "137:         # split mffcc: logmel-->dct --> mfcc, which prove the difference.",
          "138:         # the dct module is correct.",
          "139:         feature_extractor = paddle.audio.features.LogMelSpectrogram(",
          "140:             sr=sr,",
          "141:             n_fft=n_fft,",
          "142:             hop_length=64,",
          "143:             n_mels=n_mels,",
          "144:             center=True,",
          "145:             pad_mode='reflect',",
          "146:             top_db=self.top_db,",
          "147:             dtype=x.dtype)",
          "148:         feature_layer_logmel = feature_extractor(x).squeeze(0).numpy()",
          "150:         feature_layer_mfcc = scipy.fftpack.dct(feature_layer_logmel,",
          "151:                                                axis=0,",
          "152:                                                type=2,",
          "153:                                                norm=\"ortho\")[:n_mfcc]",
          "154:         np.testing.assert_array_almost_equal(feature_layer_mfcc,",
          "155:                                              feature_librosa,",
          "156:                                              decimal=3)",
          "157:         np.testing.assert_allclose(feature_layer_mfcc,",
          "158:                                    feature_librosa,",
          "159:                                    rtol=1e-1)",
          "162: if __name__ == '__main__':",
          "163:     unittest.main()",
          "",
          "---------------"
        ],
        "python/paddle/tests/test_audio_mel_feature.py||python/paddle/tests/test_audio_mel_feature.py": [
          "File: python/paddle/tests/test_audio_mel_feature.py -> python/paddle/tests/test_audio_mel_feature.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved.",
          "2: #",
          "3: # Licensed under the Apache License, Version 2.0 (the \"License\");",
          "4: # you may not use this file except in compliance with the License.",
          "5: # You may obtain a copy of the License at",
          "6: #",
          "7: #     http://www.apache.org/licenses/LICENSE-2.0",
          "8: #",
          "9: # Unless required by applicable law or agreed to in writing, software",
          "10: # distributed under the License is distributed on an \"AS IS\" BASIS,",
          "11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
          "12: # See the License for the specific language governing permissions and",
          "13: # limitations under the License.",
          "14: import unittest",
          "16: import librosa",
          "17: import numpy as np",
          "18: import os",
          "19: import paddle",
          "21: import paddle.audio",
          "22: from scipy import signal",
          "23: import itertools",
          "24: from parameterized import parameterized",
          "27: def parameterize(*params):",
          "28:     return parameterized.expand(list(itertools.product(*params)))",
          "31: class TestFeatures(unittest.TestCase):",
          "33:     def setUp(self):",
          "34:         self.initParmas()",
          "36:     def initParmas(self):",
          "38:         def get_wav_data(dtype: str, num_channels: int, num_frames: int):",
          "39:             dtype_ = getattr(paddle, dtype)",
          "40:             base = paddle.linspace(-1.0, 1.0, num_frames, dtype=dtype_) * 0.1",
          "41:             data = base.tile([num_channels, 1])",
          "42:             return data",
          "44:         self.hop_length = 128",
          "45:         self.duration = 0.5",
          "46:         self.num_channels = 1",
          "47:         self.sr = 16000",
          "48:         self.dtype = \"float32\"",
          "49:         waveform_tensor = get_wav_data(self.dtype,",
          "50:                                        self.num_channels,",
          "51:                                        num_frames=self.duration * self.sr)",
          "52:         self.waveform = waveform_tensor.numpy()",
          "54:     @parameterize([8000], [128, 256], [64, 32], [0.0, 1.0],",
          "55:                   ['float32', 'float64'])",
          "56:     def test_mel(self, sr: int, n_fft: int, n_mels: int, fmin: float,",
          "57:                  dtype: str):",
          "58:         feature_librosa = librosa.filters.mel(",
          "59:             sr=sr,",
          "60:             n_fft=n_fft,",
          "61:             n_mels=n_mels,",
          "62:             fmin=fmin,",
          "63:             fmax=None,",
          "64:             htk=False,",
          "65:             norm='slaney',",
          "66:             dtype=np.dtype(dtype),",
          "67:         )",
          "68:         paddle_dtype = getattr(paddle, dtype)",
          "69:         feature_functional = paddle.audio.functional.compute_fbank_matrix(",
          "70:             sr=sr,",
          "71:             n_fft=n_fft,",
          "72:             n_mels=n_mels,",
          "73:             f_min=fmin,",
          "74:             f_max=None,",
          "75:             htk=False,",
          "76:             norm='slaney',",
          "77:             dtype=paddle_dtype,",
          "78:         )",
          "80:         np.testing.assert_array_almost_equal(feature_librosa,",
          "81:                                              feature_functional)",
          "83:     @parameterize([8000, 16000], [128, 256], [64, 82], [40, 80], [False, True])",
          "84:     def test_melspect(self, sr: int, n_fft: int, hop_length: int, n_mels: int,",
          "85:                       htk: bool):",
          "86:         if len(self.waveform.shape) == 2:  # (C, T)",
          "87:             self.waveform = self.waveform.squeeze(",
          "88:                 0)  # 1D input for librosa.feature.melspectrogram",
          "90:         # librosa:",
          "91:         feature_librosa = librosa.feature.melspectrogram(y=self.waveform,",
          "92:                                                          sr=sr,",
          "93:                                                          n_fft=n_fft,",
          "94:                                                          hop_length=hop_length,",
          "95:                                                          n_mels=n_mels,",
          "96:                                                          htk=htk,",
          "97:                                                          fmin=50.0)",
          "99:         # paddle.audio.features.layer",
          "100:         x = paddle.to_tensor(self.waveform, dtype=paddle.float64).unsqueeze(",
          "101:             0)  # Add batch dim.",
          "102:         feature_extractor = paddle.audio.features.MelSpectrogram(",
          "103:             sr=sr,",
          "104:             n_fft=n_fft,",
          "105:             hop_length=hop_length,",
          "106:             n_mels=n_mels,",
          "107:             htk=htk,",
          "108:             dtype=x.dtype)",
          "109:         feature_layer = feature_extractor(x).squeeze(0).numpy()",
          "111:         np.testing.assert_array_almost_equal(feature_librosa,",
          "112:                                              feature_layer,",
          "113:                                              decimal=5)",
          "116: if __name__ == '__main__':",
          "117:     unittest.main()",
          "",
          "---------------"
        ],
        "python/setup.py.in||python/setup.py.in": [
          "File: python/setup.py.in -> python/setup.py.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "365:           'paddle.vision.models',",
          "366:           'paddle.vision.transforms',",
          "367:           'paddle.vision.datasets',",
          "368:           'paddle.text',",
          "369:           'paddle.text.datasets',",
          "370:           'paddle.incubate',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "368:           'paddle.audio',",
          "369:    'paddle.audio.functional',",
          "370:    'paddle.audio.features',",
          "371:    'paddle.audio.utils',",
          "",
          "---------------"
        ],
        "tools/dockerfile/ci_dockerfile.sh||tools/dockerfile/ci_dockerfile.sh": [
          "File: tools/dockerfile/ci_dockerfile.sh -> tools/dockerfile/ci_dockerfile.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "38:     ENV PATH=/usr/local/gcc-8.2/bin:\\$PATH #g\" ${dockerfile_name}",
          "39:   sed -i \"s#bash /build_scripts/install_nccl2.sh#wget -q --no-proxy https://nccl2-deb.cdn.bcebos.com/nccl-repo-ubuntu1604-2.7.8-ga-cuda10.1_1-1_amd64.deb \\\\",
          "40:     RUN dpkg -i nccl-repo-ubuntu1604-2.7.8-ga-cuda10.1_1-1_amd64.deb \\\\",
          "42: }",
          "44: function make_ubuntu_trt7_dockerfile(){",
          "",
          "[Removed Lines]",
          "41:     RUN apt remove -y libnccl* --allow-change-held-packages \\&\\&  apt-get install -y libnccl2=2.7.8-1+cuda10.1 libnccl-dev=2.7.8-1+cuda10.1 zstd pigz --allow-change-held-packages #g\" ${dockerfile_name}",
          "",
          "[Added Lines]",
          "41:     RUN apt remove -y libnccl* --allow-change-held-packages \\&\\&  apt-get install -y libsndfile1 libnccl2=2.7.8-1+cuda10.1 libnccl-dev=2.7.8-1+cuda10.1 zstd pigz --allow-change-held-packages #g\" ${dockerfile_name}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "47:   sed -i \"s#liblzma-dev#liblzma-dev openmpi-bin openmpi-doc libopenmpi-dev#g\" ${dockerfile_name}",
          "48:   dockerfile_line=$(wc -l ${dockerfile_name}|awk '{print $1}')",
          "49:   sed -i \"${dockerfile_line}i RUN apt remove -y libcudnn* --allow-change-held-packages \\&\\& \\",
          "51:   sed -i \"${dockerfile_line}i RUN wget --no-check-certificate -q  \\",
          "52:       https://developer.download.nvidia.com/compute/cuda/10.2/Prod/patches/2/cuda_10.2.2_linux.run \\&\\& \\",
          "53:       bash cuda_10.2.2_linux.run --silent --toolkit \\&\\& ldconfig\" ${dockerfile_name}",
          "",
          "[Removed Lines]",
          "50:       apt-get install -y --allow-unauthenticated libcudnn8=8.1.0.77-1+cuda10.2 libcudnn8-dev=8.1.0.77-1+cuda10.2 --allow-change-held-packages\" ${dockerfile_name}",
          "",
          "[Added Lines]",
          "50:       apt-get install -y --allow-unauthenticated libsndfile1 libcudnn8=8.1.0.77-1+cuda10.2 libcudnn8-dev=8.1.0.77-1+cuda10.2 --allow-change-held-packages\" ${dockerfile_name}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "73:     RUN ln -s /usr/local/gcc-8.2/bin/g++ /usr/bin/g++ \\\\",
          "74:     ENV PATH=/usr/local/gcc-8.2/bin:\\$PATH #g\" ${dockerfile_name}",
          "75:   sed -i \"s#bash /build_scripts/install_nccl2.sh#wget -q --no-proxy https://nccl2-deb.cdn.bcebos.com/nccl-repo-ubuntu1604-2.7.8-ga-cuda10.1_1-1_amd64.deb \\\\",
          "77: }",
          "",
          "[Removed Lines]",
          "76:     RUN apt remove -y libnccl* --allow-change-held-packages \\&\\&  apt-get install -y libnccl2=2.7.8-1+cuda10.1 libnccl-dev=2.7.8-1+cuda10.1 zstd pigz --allow-change-held-packages #g\" ${dockerfile_name}",
          "",
          "[Added Lines]",
          "76:     RUN apt remove -y libnccl* --allow-change-held-packages \\&\\&  apt-get install -y libsndfile1 libnccl2=2.7.8-1+cuda10.1 libnccl-dev=2.7.8-1+cuda10.1 zstd pigz --allow-change-held-packages #g\" ${dockerfile_name}",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "82:   sed \"s/<baseimg>/11.0-cudnn8-devel-centos7/g\" Dockerfile.centos >${dockerfile_name}",
          "83:   sed -i \"s#COPY build_scripts /build_scripts#COPY tools/dockerfile/build_scripts  ./build_scripts#g\" ${dockerfile_name}",
          "84:   dockerfile_line=$(wc -l ${dockerfile_name}|awk '{print $1}')",
          "86:   sed -i \"${dockerfile_line}i RUN pip3.7 install distro\" ${dockerfile_name}",
          "87:   sed -i \"${dockerfile_line}i ENV LD_LIBRARY_PATH /opt/_internal/cpython-3.7.0/lib:/usr/local/ssl/lib:/opt/rh/devtoolset-2/root/usr/lib64:/opt/rh/devtoolset-2/root/usr/lib:/usr/local/lib64:/usr/local/lib:/usr/local/nvidia/lib:/usr/local/nvidia/lib64 \" ${dockerfile_name}",
          "88:   sed -i \"${dockerfile_line}i ENV PATH /opt/_internal/cpython-3.7.0/bin:/usr/local/ssl:/usr/local/gcc-8.2/bin:/usr/local/go/bin:/root/gopath/bin:/opt/rh/devtoolset-2/root/usr/bin:/usr/local/nvidia/bin:/usr/local/cuda/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/java/jdk1.8.0_192/bin \" ${dockerfile_name}",
          "",
          "[Removed Lines]",
          "85:   sed -i \"${dockerfile_line}i RUN yum install -y pigz graphviz zstd\" ${dockerfile_name}",
          "",
          "[Added Lines]",
          "85:   sed -i \"${dockerfile_line}i RUN yum install -y pigz graphviz zstd libsndfile\" ${dockerfile_name}",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "104:   sed -i 's#<install_cpu_package>##g' ${dockerfile_name}",
          "105:   sed -i \"7i ENV TZ=Asia/Beijing\" ${dockerfile_name}",
          "106:   sed -i \"8i RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone\" ${dockerfile_name}",
          "108:   dockerfile_line=$(wc -l ${dockerfile_name}|awk '{print $1}')",
          "109:   sed -i \"${dockerfile_line}i RUN wget --no-check-certificate -q https://paddle-edl.bj.bcebos.com/hadoop-2.7.7.tar.gz \\&\\& \\",
          "110:      tar -xzf  hadoop-2.7.7.tar.gz && mv hadoop-2.7.7 /usr/local/\" ${dockerfile_name}",
          "",
          "[Removed Lines]",
          "107:   sed -i \"9i RUN apt-get update && apt-get install -y liblzma-dev openmpi-bin openmpi-doc libopenmpi-dev\" ${dockerfile_name}",
          "",
          "[Added Lines]",
          "107:   sed -i \"27i RUN apt-get update && apt-get install -y liblzma-dev openmpi-bin openmpi-doc libopenmpi-dev libsndfile1\" ${dockerfile_name}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "26465cdbd609a6bce4f1f6333619f5d961be43bd",
      "candidate_info": {
        "commit_hash": "26465cdbd609a6bce4f1f6333619f5d961be43bd",
        "repo": "PaddlePaddle/Paddle",
        "commit_url": "https://github.com/PaddlePaddle/Paddle/commit/26465cdbd609a6bce4f1f6333619f5d961be43bd",
        "files": [
          "python/paddle/audio/functional/window.py"
        ],
        "message": "fix paddle.audio.function.get_window security error (#47453)",
        "before_after_code_files": [
          "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py"
          ],
          "candidate": [
            "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py"
          ]
        }
      },
      "candidate_diff": {
        "python/paddle/audio/functional/window.py||python/paddle/audio/functional/window.py": [
          "File: python/paddle/audio/functional/window.py -> python/paddle/audio/functional/window.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: from paddle import Tensor",
          "22: def _cat(x: List[Tensor], data_type: str) -> Tensor:",
          "23:     l = [paddle.to_tensor(_, data_type) for _ in x]",
          "24:     return paddle.concat(l)",
          "27: def _acosh(x: Union[Tensor, float]) -> Tensor:",
          "28:     if isinstance(x, float):",
          "29:         return math.log(x + math.sqrt(x**2 - 1))",
          "30:     return paddle.log(x + paddle.sqrt(paddle.square(x) - 1))",
          "33: def _extend(M: int, sym: bool) -> bool:",
          "35:     if not sym:",
          "36:         return M + 1, True",
          "37:     else:",
          "38:         return M, False",
          "41: def _len_guards(M: int) -> bool:",
          "43:     if int(M) != M or M < 0:",
          "44:         raise ValueError('Window length M must be a non-negative integer')",
          "46:     return M <= 1",
          "49: def _truncate(w: Tensor, needed: bool) -> Tensor:",
          "51:     if needed:",
          "52:         return w[:-1]",
          "53:     else:",
          "54:         return w",
          "62:     \"\"\"Compute a window with a generalized Gaussian shape.",
          "63:     This function is consistent with scipy.signal.windows.general_gaussian().",
          "64:     \"\"\"",
          "65:     if _len_guards(M):",
          "67:     M, needs_trunc = _extend(M, sym)",
          "69:     n = paddle.arange(0, M, dtype=dtype) - (M - 1.0) / 2.0",
          "72:     return _truncate(w, needs_trunc)",
          "79:     \"\"\"Compute a generic weighted sum of cosine terms window.",
          "80:     This function is consistent with scipy.signal.windows.general_cosine().",
          "81:     \"\"\"",
          "82:     if _len_guards(M):",
          "84:     M, needs_trunc = _extend(M, sym)",
          "85:     fac = paddle.linspace(-math.pi, math.pi, M, dtype=dtype)",
          "87:     for k in range(len(a)):",
          "88:         w += a[k] * paddle.cos(k * fac)",
          "89:     return _truncate(w, needs_trunc)",
          "96:     \"\"\"Compute a generalized Hamming window.",
          "97:     This function is consistent with scipy.signal.windows.general_hamming()",
          "98:     \"\"\"",
          "108:     \"\"\"Compute a Taylor window.",
          "109:     The Taylor window taper function approximates the Dolph-Chebyshev window's",
          "110:     constant sidelobe level for a parameterized number of near-in sidelobes.",
          "111:     \"\"\"",
          "112:     if _len_guards(M):",
          "114:     M, needs_trunc = _extend(M, sym)",
          "115:     # Original text uses a negative sidelobe level parameter and then negates",
          "116:     # it in the calculation of B. To keep consistent with other methods we",
          "117:     # assume the sidelobe level parameter to be positive.",
          "119:     A = _acosh(B) / math.pi",
          "121:     ma = paddle.arange(1, nbar, dtype=dtype)",
          "124:     signs = paddle.empty_like(ma)",
          "125:     signs[::2] = 1",
          "126:     signs[1::2] = -1",
          "127:     m2 = ma * ma",
          "128:     for mi in range(len(ma)):",
          "131:         if mi == 0:",
          "133:         elif mi == len(ma) - 1:",
          "134:             denom = 2 * paddle.prod(1 - m2[mi] / m2[:mi])",
          "135:         else:",
          "139:         Fm[mi] = numer / denom",
          "141:     def W(n):",
          "142:         return 1 + 2 * paddle.matmul(",
          "143:             Fm.unsqueeze(0),",
          "146:     w = W(paddle.arange(0, M, dtype=dtype))",
          "",
          "[Removed Lines]",
          "34:     \"\"\"Extend window by 1 sample if needed for DFT-even symmetry. \"\"\"",
          "42:     \"\"\"Handle small or incorrect window lengths. \"\"\"",
          "50:     \"\"\"Truncate window by 1 sample if needed for DFT-even symmetry. \"\"\"",
          "57: def _general_gaussian(M: int,",
          "58:                       p,",
          "59:                       sig,",
          "60:                       sym: bool = True,",
          "61:                       dtype: str = 'float64') -> Tensor:",
          "66:         return paddle.ones((M, ), dtype=dtype)",
          "70:     w = paddle.exp(-0.5 * paddle.abs(n / sig)**(2 * p))",
          "75: def _general_cosine(M: int,",
          "76:                     a: float,",
          "77:                     sym: bool = True,",
          "78:                     dtype: str = 'float64') -> Tensor:",
          "83:         return paddle.ones((M, ), dtype=dtype)",
          "86:     w = paddle.zeros((M, ), dtype=dtype)",
          "92: def _general_hamming(M: int,",
          "93:                      alpha: float,",
          "94:                      sym: bool = True,",
          "95:                      dtype: str = 'float64') -> Tensor:",
          "99:     return _general_cosine(M, [alpha, 1. - alpha], sym, dtype=dtype)",
          "102: def _taylor(M: int,",
          "103:             nbar=4,",
          "104:             sll=30,",
          "105:             norm=True,",
          "106:             sym: bool = True,",
          "107:             dtype: str = 'float64') -> Tensor:",
          "113:         return paddle.ones((M, ), dtype=dtype)",
          "118:     B = 10**(sll / 20)",
          "120:     s2 = nbar**2 / (A**2 + (nbar - 0.5)**2)",
          "123:     Fm = paddle.empty((nbar - 1, ), dtype=dtype)",
          "129:         numer = signs[mi] * paddle.prod(1 - m2[mi] / s2 / (A**2 +",
          "130:                                                            (ma - 0.5)**2))",
          "132:             denom = 2 * paddle.prod(1 - m2[mi] / m2[mi + 1:])",
          "136:             denom = 2 * paddle.prod(1 - m2[mi] / m2[:mi]) * paddle.prod(",
          "137:                 1 - m2[mi] / m2[mi + 1:])",
          "144:             paddle.cos(2 * math.pi * ma.unsqueeze(1) * (n - M / 2. + 0.5) / M))",
          "",
          "[Added Lines]",
          "22: class WindowFunctionRegister(object):",
          "23:     def __init__(self):",
          "24:         self._functions_dict = dict()",
          "26:     def register(self, func=None):",
          "27:         def add_subfunction(func):",
          "28:             name = func.__name__",
          "29:             self._functions_dict[name] = func",
          "30:             return func",
          "32:         return add_subfunction",
          "34:     def get(self, name):",
          "35:         return self._functions_dict[name]",
          "38: window_function_register = WindowFunctionRegister()",
          "41: @window_function_register.register()",
          "47: @window_function_register.register()",
          "54: @window_function_register.register()",
          "56:     \"\"\"Extend window by 1 sample if needed for DFT-even symmetry.\"\"\"",
          "63: @window_function_register.register()",
          "65:     \"\"\"Handle small or incorrect window lengths.\"\"\"",
          "72: @window_function_register.register()",
          "74:     \"\"\"Truncate window by 1 sample if needed for DFT-even symmetry.\"\"\"",
          "81: @window_function_register.register()",
          "82: def _general_gaussian(",
          "83:     M: int, p, sig, sym: bool = True, dtype: str = 'float64'",
          "84: ) -> Tensor:",
          "89:         return paddle.ones((M,), dtype=dtype)",
          "93:     w = paddle.exp(-0.5 * paddle.abs(n / sig) ** (2 * p))",
          "98: @window_function_register.register()",
          "99: def _general_cosine(",
          "100:     M: int, a: float, sym: bool = True, dtype: str = 'float64'",
          "101: ) -> Tensor:",
          "106:         return paddle.ones((M,), dtype=dtype)",
          "109:     w = paddle.zeros((M,), dtype=dtype)",
          "115: @window_function_register.register()",
          "116: def _general_hamming(",
          "117:     M: int, alpha: float, sym: bool = True, dtype: str = 'float64'",
          "118: ) -> Tensor:",
          "122:     return _general_cosine(M, [alpha, 1.0 - alpha], sym, dtype=dtype)",
          "125: @window_function_register.register()",
          "126: def _taylor(",
          "127:     M: int, nbar=4, sll=30, norm=True, sym: bool = True, dtype: str = 'float64'",
          "128: ) -> Tensor:",
          "134:         return paddle.ones((M,), dtype=dtype)",
          "139:     B = 10 ** (sll / 20)",
          "141:     s2 = nbar**2 / (A**2 + (nbar - 0.5) ** 2)",
          "144:     Fm = paddle.empty((nbar - 1,), dtype=dtype)",
          "150:         numer = signs[mi] * paddle.prod(",
          "151:             1 - m2[mi] / s2 / (A**2 + (ma - 0.5) ** 2)",
          "152:         )",
          "154:             denom = 2 * paddle.prod(1 - m2[mi] / m2[mi + 1 :])",
          "158:             denom = (",
          "159:                 2",
          "162:             )",
          "169:             paddle.cos(2 * math.pi * ma.unsqueeze(1) * (n - M / 2.0 + 0.5) / M),",
          "170:         )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "153:     return _truncate(w, needs_trunc)",
          "156: def _hamming(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "157:     \"\"\"Compute a Hamming window.",
          "158:     The Hamming window is a taper formed by using a raised cosine with",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "182: @window_function_register.register()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "161:     return _general_hamming(M, 0.54, sym, dtype=dtype)",
          "164: def _hann(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "165:     \"\"\"Compute a Hann window.",
          "166:     The Hann window is a taper formed by using a raised cosine or sine-squared",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "191: @window_function_register.register()",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "169:     return _general_hamming(M, 0.5, sym, dtype=dtype)",
          "176:     \"\"\"Compute a Tukey window.",
          "177:     The Tukey window is also known as a tapered cosine window.",
          "178:     \"\"\"",
          "179:     if _len_guards(M):",
          "182:     if alpha <= 0:",
          "184:     elif alpha >= 1.0:",
          "185:         return hann(M, sym=sym)",
          "",
          "[Removed Lines]",
          "172: def _tukey(M: int,",
          "173:            alpha=0.5,",
          "174:            sym: bool = True,",
          "175:            dtype: str = 'float64') -> Tensor:",
          "180:         return paddle.ones((M, ), dtype=dtype)",
          "183:         return paddle.ones((M, ), dtype=dtype)",
          "",
          "[Added Lines]",
          "200: @window_function_register.register()",
          "201: def _tukey(",
          "202:     M: int, alpha=0.5, sym: bool = True, dtype: str = 'float64'",
          "203: ) -> Tensor:",
          "208:         return paddle.ones((M,), dtype=dtype)",
          "211:         return paddle.ones((M,), dtype=dtype)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "189:     n = paddle.arange(0, M, dtype=dtype)",
          "190:     width = int(alpha * (M - 1) / 2.0)",
          "195:     w1 = 0.5 * (1 + paddle.cos(math.pi * (-1 + 2.0 * n1 / alpha / (M - 1))))",
          "196:     w2 = paddle.ones(n2.shape, dtype=dtype)",
          "199:     w = paddle.concat([w1, w2, w3])",
          "201:     return _truncate(w, needs_trunc)",
          "208:     \"\"\"Compute a Kaiser window.",
          "209:     The Kaiser window is a taper formed by using a Bessel function.",
          "210:     \"\"\"",
          "211:     raise NotImplementedError()",
          "218:     \"\"\"Compute a Gaussian window.",
          "219:     The Gaussian widows has a Gaussian shape defined by the standard deviation(std).",
          "220:     \"\"\"",
          "221:     if _len_guards(M):",
          "223:     M, needs_trunc = _extend(M, sym)",
          "225:     n = paddle.arange(0, M, dtype=dtype) - (M - 1.0) / 2.0",
          "226:     sig2 = 2 * std * std",
          "229:     return _truncate(w, needs_trunc)",
          "238:     if sym and center is not None:",
          "239:         raise ValueError(\"If sym==True, center must be None.\")",
          "240:     if _len_guards(M):",
          "242:     M, needs_trunc = _extend(M, sym)",
          "244:     if center is None:",
          "",
          "[Removed Lines]",
          "191:     n1 = n[0:width + 1]",
          "192:     n2 = n[width + 1:M - width - 1]",
          "193:     n3 = n[M - width - 1:]",
          "197:     w3 = 0.5 * (1 + paddle.cos(math.pi * (-2.0 / alpha + 1 + 2.0 * n3 / alpha /",
          "198:                                           (M - 1))))",
          "204: def _kaiser(M: int,",
          "205:             beta: float,",
          "206:             sym: bool = True,",
          "207:             dtype: str = 'float64') -> Tensor:",
          "214: def _gaussian(M: int,",
          "215:               std: float,",
          "216:               sym: bool = True,",
          "217:               dtype: str = 'float64') -> Tensor:",
          "222:         return paddle.ones((M, ), dtype=dtype)",
          "227:     w = paddle.exp(-n**2 / sig2)",
          "232: def _exponential(M: int,",
          "233:                  center=None,",
          "234:                  tau=1.,",
          "235:                  sym: bool = True,",
          "236:                  dtype: str = 'float64') -> Tensor:",
          "237:     \"\"\"Compute an exponential (or Poisson) window. \"\"\"",
          "241:         return paddle.ones((M, ), dtype=dtype)",
          "",
          "[Added Lines]",
          "219:     n1 = n[0 : width + 1]",
          "220:     n2 = n[width + 1 : M - width - 1]",
          "221:     n3 = n[M - width - 1 :]",
          "225:     w3 = 0.5 * (",
          "226:         1",
          "227:         + paddle.cos(math.pi * (-2.0 / alpha + 1 + 2.0 * n3 / alpha / (M - 1)))",
          "228:     )",
          "234: @window_function_register.register()",
          "235: def _kaiser(",
          "236:     M: int, beta: float, sym: bool = True, dtype: str = 'float64'",
          "237: ) -> Tensor:",
          "244: @window_function_register.register()",
          "245: def _gaussian(",
          "246:     M: int, std: float, sym: bool = True, dtype: str = 'float64'",
          "247: ) -> Tensor:",
          "252:         return paddle.ones((M,), dtype=dtype)",
          "257:     w = paddle.exp(-(n**2) / sig2)",
          "262: @window_function_register.register()",
          "263: def _exponential(",
          "264:     M: int, center=None, tau=1.0, sym: bool = True, dtype: str = 'float64'",
          "265: ) -> Tensor:",
          "266:     \"\"\"Compute an exponential (or Poisson) window.\"\"\"",
          "270:         return paddle.ones((M,), dtype=dtype)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "250:     return _truncate(w, needs_trunc)",
          "253: def _triang(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "256:     if _len_guards(M):",
          "258:     M, needs_trunc = _extend(M, sym)",
          "260:     n = paddle.arange(1, (M + 1) // 2 + 1, dtype=dtype)",
          "",
          "[Removed Lines]",
          "254:     \"\"\"Compute a triangular window.",
          "255:     \"\"\"",
          "257:         return paddle.ones((M, ), dtype=dtype)",
          "",
          "[Added Lines]",
          "282: @window_function_register.register()",
          "284:     \"\"\"Compute a triangular window.\"\"\"",
          "286:         return paddle.ones((M,), dtype=dtype)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "268:     return _truncate(w, needs_trunc)",
          "271: def _bohman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "272:     \"\"\"Compute a Bohman window.",
          "273:     The Bohman window is the autocorrelation of a cosine window.",
          "274:     \"\"\"",
          "275:     if _len_guards(M):",
          "277:     M, needs_trunc = _extend(M, sym)",
          "279:     fac = paddle.abs(paddle.linspace(-1, 1, M, dtype=dtype)[1:-1])",
          "280:     w = (1 - fac) * paddle.cos(math.pi * fac) + 1.0 / math.pi * paddle.sin(",
          "282:     w = _cat([0, w, 0], dtype)",
          "284:     return _truncate(w, needs_trunc)",
          "287: def _blackman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "288:     \"\"\"Compute a Blackman window.",
          "289:     The Blackman window is a taper formed by using the first three terms of",
          "",
          "[Removed Lines]",
          "276:         return paddle.ones((M, ), dtype=dtype)",
          "281:         math.pi * fac)",
          "",
          "[Added Lines]",
          "300: @window_function_register.register()",
          "306:         return paddle.ones((M,), dtype=dtype)",
          "311:         math.pi * fac",
          "312:     )",
          "318: @window_function_register.register()",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "294:     return _general_cosine(M, [0.42, 0.50, 0.08], sym, dtype=dtype)",
          "297: def _cosine(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:",
          "300:     if _len_guards(M):",
          "302:     M, needs_trunc = _extend(M, sym)",
          "305:     return _truncate(w, needs_trunc)",
          "312:     \"\"\"Return a window of a given length and type.",
          "314:     Args:",
          "316:         win_length (int): Number of samples.",
          "317:         fftbins (bool, optional): If True, create a \"periodic\" window. Otherwise, create a \"symmetric\" window, for use in filter design. Defaults to True.",
          "318:         dtype (str, optional): The data type of the return window. Defaults to 'float64'.",
          "",
          "[Removed Lines]",
          "298:     \"\"\"Compute a window with a simple cosine shape.",
          "299:     \"\"\"",
          "301:         return paddle.ones((M, ), dtype=dtype)",
          "303:     w = paddle.sin(math.pi / M * (paddle.arange(0, M, dtype=dtype) + .5))",
          "308: def get_window(window: Union[str, Tuple[str, float]],",
          "309:                win_length: int,",
          "310:                fftbins: bool = True,",
          "311:                dtype: str = 'float64') -> Tensor:",
          "315:         window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.",
          "",
          "[Added Lines]",
          "329: @window_function_register.register()",
          "331:     \"\"\"Compute a window with a simple cosine shape.\"\"\"",
          "333:         return paddle.ones((M,), dtype=dtype)",
          "335:     w = paddle.sin(math.pi / M * (paddle.arange(0, M, dtype=dtype) + 0.5))",
          "340: def get_window(",
          "341:     window: Union[str, Tuple[str, float]],",
          "342:     win_length: int,",
          "343:     fftbins: bool = True,",
          "344:     dtype: str = 'float64',",
          "345: ) -> Tensor:",
          "349:         window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'general_gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "340:             args = window[1:]",
          "341:     elif isinstance(window, str):",
          "342:         if window in ['gaussian', 'exponential']:",
          "345:         else:",
          "346:             winstr = window",
          "347:     else:",
          "351:     try:",
          "354:         raise ValueError(\"Unknown window type.\") from e",
          "357:     kwargs = {'sym': sym}",
          "358:     return winfunc(*params, dtype=dtype, **kwargs)",
          "",
          "[Removed Lines]",
          "343:             raise ValueError(\"The '\" + window + \"' window needs one or \"",
          "344:                              \"more parameters -- pass a tuple.\")",
          "348:         raise ValueError(\"%s as window type is not supported.\" %",
          "349:                          str(type(window)))",
          "352:         winfunc = eval('_' + winstr)",
          "353:     except NameError as e:",
          "356:     params = (win_length, ) + args",
          "",
          "[Added Lines]",
          "377:             raise ValueError(",
          "378:                 \"The '\" + window + \"' window needs one or \"",
          "379:                 \"more parameters -- pass a tuple.\"",
          "380:             )",
          "384:         raise ValueError(",
          "385:             \"%s as window type is not supported.\" % str(type(window))",
          "386:         )",
          "389:         winfunc = window_function_register.get('_' + winstr)",
          "390:     except KeyError as e:",
          "393:     params = (win_length,) + args",
          "",
          "---------------"
        ]
      }
    }
  ]
}